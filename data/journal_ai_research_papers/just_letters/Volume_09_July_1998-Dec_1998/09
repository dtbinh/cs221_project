journal artificial intelligence research                 

submitted       published      

automatic inference state invariants tim
maria fox
derek long

maria fox dur ac uk
d p long dur ac uk

department computer science
university durham  uk

abstract
planning applied larger richer domains effort involved constructing
domain descriptions increases becomes significant burden human application
designer  general planners applied successfully large complex domains
necessary provide domain designer assistance building correctly
encoded domains  one way provide domain independent techniques
extracting  domain description  knowledge implicit description
assist domain designers debugging domain descriptions  knowledge
exploited improve performance planners  several researchers explored
potential state invariants speeding performance domain independent
planners  paper describe process state invariants extracted
automatically inferred type structure domain  techniques
developed exploitation stan  graphplan based planner employs state analysis
techniques enhance performance 

   introduction
stan  long   fox  press  domain independent planner based constraint
satisfaction technology graphplan  blum   furst         name derived
fact performs variety pre processing analyses  state analyses  domain
description applied  assist planning eciently domain  stan
took part aips    planning competition  first international competition
domain independent planners compared terms performance well known
benchmark domains  four planners competed strips track  three
based graphplan  blum   furst        architecture  important difference stan graphplan based planners use state analysis
techniques  although techniques not  stage  fully integrated
planning algorithm stan gave impressive performance determined examination competition results  description competition  objectives
results  aips    planning competition ftp site  see appendix a  
one important analyses performed stan automatic inference
state invariants  described paper  state invariants inferred
type structure domain automatically inferred  enriched  stan 
techniques used completely independent planning architecture  isolated
pre processing module call tim  type inference module   tim used
planner  regardless whether based graphplan underlying
c      ai access foundation morgan kaufmann publishers  rights reserved 

fifox   long

architecture  tim implemented c   executables examples output
available web site  see appendix a  online appendix   
tim takes domain description type information need supplied infers
rich type structure functional relationships objects domain  type
information supplied tim exploit foundation type structure
often infer enriched type structure basis  state invariants extracted
way inferred types partitioned  consequence domain
designer relieved considerable overhead description domain  whilst
easy hand code types state invariants simple domains containing objects
relations  becomes progressively dicult ensure cross consistency handcoded invariants domains become increasingly complex  similarly  exploitable type
structure domain may much richer easily provided hand 
observed tim often infers unexpected type partitions increase discrimination
type structure provide corresponding benefits stan s performance  therefore
see tim domain engineering tool  helping shift burden domain design
human automatic system 
usefulness types state invariants well documented  types
provided hand since first observed reduce number operator instantiations considered traversal planner s search space 
elimination meaningless instantiations particularly helpful system graphplan  structure traversed explicitly constructed prior search 
believe benefits obtained type inference planning similar
obtained programing language design  type inference powerful type checking
assist identification semantic errors specification relational
structure domain  indeed  found tim useful domain debugging
tool  allowing us identify aws published benchmark domains  used
tim reveal underlying structure mystery domain  disguised transportation
problem domain  used planning competition  mystery domain described
appendix c   
use domain knowledge significantly improve performance planners 
shown number researchers  gerevini schubert      a      b  considered automatic inference state constraints demonstrated significant
empirical advantage obtained use  kautz selman        handcoded invariants provided part domain description used blackbox 
demonstrate performance advantages obtained acknowledge importance
inferring invariants automatically  mccluskey porteous        demonstrated important role hand coded state invariants play domain compilation
ecient planning  earlier work kelleher cohn        morris feldman
       explores automatic generation restricted invariant forms  discuss
these  other  related approaches section   
paper describe type inference process employed tim explain
four different forms state invariant extracted inferred type structure 
argue tim correct since never infers sentences state invariants 
provide experimental results demonstrating performance advantages
obtained use types 
   

fiautomatic inference state invariants

drive

unfuelled  
fuelled

 

drive

 

load

 


 

unload

figure    simple transportation domain seen collection fsms 

   type inference module
one way viewing strips  fikes   nilsson        domains collection finite state
machines  fsms  domain constants traversing states within them  example 
simple transportation domain rockets packages  rockets capable
locations moving  driving  one location
another  fuelled unfuelled  moving two states 
seen forming one node fsm  fuelled unfuelled forming two node fsm 
view depicted figure   
   

fifox   long

packages locations rockets  move states
resulting two node fsm  example  rockets states involve
one fsm  since fuelled  unfuelled  strips domains
seen way earlier work  mccluskey   porteous        grant        
discussed section   

    types tim

two objects participate identical fsms functionally equivalent
seen type  notion type similar sorts work
mccluskey porteous         primary objective tim module automatically
identify equivalence classes form primitive types domain description
infer hierarchical type structure domain basis primitive types 
way done discussed section      primitive types functional equivalence
classes  objects domain partitioned classes  identified
types domain objects tim infers types parameters operators 
state invariants inferred final stage 
early parts process rely three key abstract data types  property space 
attribute space transition rule  formal definitions components
provided section      provide informal descriptions support following
definitions  transition rules represent state transformations comprise fsms
traversed objects domain  property spaces fsms  together objects
participate them  properties objects transition rules
acquire properties  attribute spaces contain collections objects
have  acquire  associated attributes  attributes differ properties
acquired  lost  without associated loss  acquisition  respectively  
another attribute  attribute spaces contain transition rules enable
acquisition  or loss  attributes  state attribute spaces
constructed assign types domain objects according membership
property attribute spaces  two objects belong identical property
attribute spaces assigned type  therefore important ensure
property attribute spaces adequately discriminating  otherwise important
type distinctions lost  much subtlety algorithm described section    
concerned maintaining adequate discrimination construction spaces 
present following definitions support informal characterisation
roles types strips tim  definitions used sections         
discuss types assigned objects operator parameters 

definition   type vector bit vector bit corresponds membership 
otherwise  unique state attribute space  number bits vector always
equal number distinct state attribute spaces 

definition   type set domain objects associated type vector 
definition   type vector  v   two distinct bits  si sj   set corresponds

sub type type associated vector  v   si set  all settings
   

fiautomatic inference state invariants

equal   type associated v  seen super type type
associated v   

definition   type structure hierarchy types organised sub type relationships
component types 

definition   type structure adequately discriminating objects assigned
state  and attribute  spaces characterize state transitions  and attributes  

definition   type structure under discriminating fails distinguish types
functionally distinct 

definition   type structure over discriminating functionally identical objects
assigned different types 

two distinct ways types play role specification domain 
restrict set possible operator instances eliminate
meaningless domain hence improve eciency reducing size search
space  eliminate unsound plans could constructed
provided  following examples clarify difference two roles 
untyped schema 

drive x y z 
pre 
add 
del 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

permits instances typed schema 

drive x y z 
params 
pre 
add 
del 

x rocket y package z location
at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

meaningless instances eliminated search preconditions
satisfiable  hand  typed schema 

y x y z 
params 
pre 
add 
del 

x aircraft y z location
at x y 
at x z 
at x y 

ensures aircraft own  whilst untyped schema 
   

fifox   long

y x y z 
pre 
add 
del 

at x y 
at x z 
at x y 

allows ying means travel object location  including packages 
objects  well aircraft  tim capable automatically inferring types
playing restrictive role indicated typed drive operator  however  tim cannot infer
type information implicit domain description  thus  given untyped fly
schema  grounds tim infer type restrictions  tim draw attention
unintended under discrimination making packages aircraft indistinguishable
type level  unless distinguishing information provided schemas 
least tim make explicit fact packages amongst objects
y  assists domain designer tracking errors omissions domain
description  unstated intended distinctions cannot enforced tim 

    overview tim algorithm

figure   gives broad outline tim algorithm  detailed description given
appendix b  role component algorithm described  together
commentary discussing related issues justifications  sections              
broadly  tim begins analysis domain operators  extracting transition rules
form foundations property attribute spaces described previously 
rules used separate properties equivalence classes property
attribute spaces constructed  tim analyses initial state order assign
domain objects appropriate spaces  analysis identifies initial properties
individual objects uses form states objects property spaces 
initial states property space extended application transition rules
space form complete sets states accounting states objects
property space possibly inhabit  described section      attribute spaces
behave fsms  property spaces do  extension carried
different procedure  one add new objects spaces  rather new states 
tim assigns types objects using pattern membership spaces
constructed  finally  tim uses spaces determine invariants govern behaviour
domain objects it 

    constructing transition rules

begin describing process transition rules constructed 
following definitions required 

definition   property predicate subscripted number   arity
predicate  every predicate arity n defines n properties 

definition   transition rule expression form 
property   property   property
   

fiautomatic inference state invariants

construct base prss  section     
split prss  section     
construct transition rules  section     
seed property attribute spaces  section     
assign transition rules  section     
analyse initial state  section     
extend property spaces  section     
extend attribute spaces  section     
identify types  section     
construct invariants  section     
figure    outline tim algorithm 
three components bags zero properties called enablers  start
finish  respectively 

double arrow     read enables single arrow     read transition
from  so 

e s f

read  e enables transition f  properties given result
transition  properties f acquired result transition  properties
e given up 
enablers empty write 

start   finish
start empty write 

transition rule  

enablers   null   finish
finish empty write 

transition rule  

enablers   start   null
bag null empty bag properties  role emphasise that  transition
rule    nothing given result transition and  transition rule    nothing
acquired  rules null start null finish discarded describe
null transitions 
property bags contain one element separated commas 
collection 

pk   qm       rn
   

fifox   long

interpreted mean properties collection satisfied
many times appear collection  comma therefore used separate
elements bag  use denote bag union  denote bag difference 
denote
bag intersection v denote bag inclusion 

definition    property relating structure  prs  triple bags properties 
first stage algorithm constructs set transition rules set operator
schemas  operator schema analysed respect parameter turn and 
parameter  prs built  first bag properties formed preconditions
schema  number used form property argument position
parameter considered  example  precondition on x    
parameter considered x   property formed on    bag  called precs 
contains enablers used formation transition rules  second
bag  called deleted precs  properties formed preconditions appear
delete list schema  with respect parameter   third bag  called
add elements  contains properties formed add list schema 
prs contains deleted elements component   assumed every element
delete list strips operator appears precondition list  reasonable
restriction given strips operators allow use conditional effects 
assumed every pair atoms delete list schema distinct
legal instantiations schema  constitute significant restriction since
operator schemas always easily rephrased whenever condition violated 
consider process prss constructed  given schema 

drive x y z 
pre 
add 
del 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

considering parameter x   following prs built 

prs  

precs  
at    fuelled 
deleted precs   at    fuelled 
add elements   at    unfuelled 
considering parameter obtain 

prs  
precs  
at 
deleted precs   at 
add elements  
considering parameter z obtain 
   

fiautomatic inference state invariants

prs  

precs  
location 
deleted precs  
add elements   at 

constructing structures identifying state transformations
objects  instantiating operator parameters  progress  note objects instantiate x go fuelled somewhere unfuelled somewhere  objects
instantiate lose property anything gain nothing result application operator  objects instantiate z continue locations
gain property something them  convert structures
transition rules order correctly capture state transformations 
standard formula construction rules prss is 

precs deleted precs   deleted precs   add elements
thus  using prs   above  could build rule 

at    fuelled    at    unfuelled 
potential problem rule causes at  fuelled  linked state
transformations  at  fuelled  become associated property space
and  consequence  objects places  cannot fuelled  may

indistinguishable objects require fuelling moved  fact 
wish transition rules express fact fuelled enables things go
one place another place  whilst excluding possibility
may enablers transition 
therefore begin second phase prs construction identifying  special treatment  prss property appears deleted precs add elements 
property exchanged application operator  is  relation
continues hold identified argument object objects  not
necessarily object objects application operator   example  prs    vehicle new location application operator 
longer old location  observe vehicle must fuelled make transition  separate transition condition split prs  splitting identifies
exchanged properties prs creates one new prs exchange one
unexchanged properties  therefore  splitting prs always results k    
 and least k  new prss  k number exchanges prs represents 
splitting prs   construct two new prss  one characterizing exchange
property  one characterising fuelled unfuelled transition 
first new prss is 

prs  

precs  
at    fuelled 
deleted precs   at 
add elements   at 
   

fifox   long

rule

fuelled    at    at 
constructed  noted property fuelled longer seen
part state transformation enabler  appear
deleted precs bag resulting prs 
second new prs captures fact at  seen enabler
transition fuelled  unfuelled  

prs  

precs  
at    fuelled 
deleted precs   fuelled 
add elements   unfuelled 

prs splits required since properties exchanged
it  general example follows 

prs  

precs  
p   p  pn
deleted precs   p  pi pi k pm
add elements   p  pi q  qk

prss would constructed deal exchanged pairs
final prs  prs    would constructed describe remainder transition making
    prss total 

prs  

precs  
p    p  pn
deleted precs   pi k pm
add elements   q  qk

need consider additional pairings add delete list elements  since
would correspond exchanges properties  splitting process justified section      standard rule construction formula applied prs    yielding
rule
at    fuelled    unfuelled 
observed that  even add elements bag contains multiple properties 
single rule always built standard construction formula applied 
considering remaining prss       observed contain
empty field    add elements field empty   deleted precs field empty 
prs empty field special treatment required  prs   build
rule

at    null

represent fact object instantiates gives property
something it  gains nothing return    build rule

location    null   at 
   

fiautomatic inference state invariants

represent fact object instantiates z gains property something virtue location  gives nothing return  rules
somewhat different status ones characterize exchange properties 
cases properties lost gained  without exchange  seen resources
accumulated spent domain objects rather states
domain objects pass  example  location acquire property something it  without relinquishing anything return  whereas object requires fuel
become fuelled relinquishing property unfuelled  vice versa 
increasing decreasing resources identified attributes distinguished
states  distinction later prove important  since generation true
state invariants depends upon made correctly  properties increase
decrease without exchange invariant  false assertions would proposed
invariants treated way state valued properties 
rule form constructed prs   must constructed separately every
property add elements bag properties must individually characterized increasing resources  rules constructed using null distinguished attribute
transition rules  null left side   rule increasing attribute
transition rule  null right hand side rule decreasing attribute
transition rule 
final case consider rule construction case prs empty
precs field  happens parameter  respect prs constructed 
appear preconditions operator schema  case set
rules constructed  one property  a  add elements bag  form

null  
ecting fact increasing resource  the deleted precs field necessarily
empty case  

definition    state bag properties 
necessary distinguish bag set  square brackets used denote
bag 
definition    property space tuple four components  set properties  set
transition rules  set states set domain constants 

definition    attribute space tuple three components  set properties  set

transition rules set domain constants 

helpful observe state attribute spaces represent disjoint collections properties  disjoint collections formed transition
rules putting start finish properties rule collection 
example  given two rules 
e     p   p   p      q    q  

e     r   r      s   
   

fifox   long

collections  p   p   p   q   q    r   r   s   would formed  property appears
start finish rules single collection formed two rules 
last stage rule construction phase identify basis construction
property attribute spaces  done uniting left right hand sides
rules  uniting forms collections properties seed unique property attribute
space  yet possible decide seeds form attribute spaces 
treatment kinds space identical stage  enablers rules
ignored process  wish make enablers automatically fall
property spaces states transformations enable  could result
incorrect assignment properties property attribute spaces since enablers
facilitate  participate in  state transformations  output phase
collection rules  properties marked attributes  property space seeds
formed uniting process  properties remain unassigned stage
used seed separate attribute spaces  one property 
role played second phase prs construction postpone commitment
uniting collections properties possibility objects 
properties  associated different property spaces left open long
possible  may consideration schemas provides enough information
possibility eliminated  following abstract example  support
much type discrimination possible earlier phases analysis  consider
simple example illustrate problem 
      postponing property space amalgamation

given domain description containing following operator schema 

op  x y z 
pre 
add 
del 

p x y   q x y 
p x z   q x z 
p x y   q x y 

prs 

precs  
p    q 
deleted precs   p    q 
add elements   p   q 
constructed  first phase  x   properties p  q  bound
together prs  resulting rule would be 

p   q    p    q 
forces objects property p  occupy property space objects
property q    since prs models exchange p  split it 
replace two new prss 

precs  
p    q 
deleted precs   p 
add elements   p 
   

fiautomatic inference state invariants

precs  
p    q 
deleted precs   q 
add elements   q 
consider pairings p  q    since found prss
operator schemas domain allows them  two prss generated lead
generation rules 

q    p    p 



p    q    q 

two rules indicate p  q  used form different property spaces since
could  principle  independent one another  objects assigned two
spaces turn distinct types  however  add following two schemas 

op  x y 
pre 
add 
del 

op  x y z 

q x y 
p x y 
q x y 

pre 
add 
del 

p x y 
q x y 
p x y 

generate  x   prss 

precs  
q 
deleted precs   q 
add elements   p 


precs  
p 
deleted precs   p 
add elements   q 
rules 


q    p 
p    q 

indicating p  q  united set hence form single property
space  objects properties really type 
uniting overrides potential separate property spaces formed but  absence
two schemas  would insucient information available determine
nature relationship two properties 
   

fifox   long

    constructing property spaces synthesising types

objective stage construct type structure domain identifying
domain objects distinct property spaces  objects appear one property
space  giving us basis deriving hierarchical type structure 
first part process involves completing seeded property spaces  first
task associate transition rules appropriate property space seeds 
easily done picking arbitrary property start finish component rule
identifying property space seed property belongs  never
ambiguity every property belongs one seed uniting ensures
properties referred rule belong seed  point distinction
states attributes becomes important  property space seed
attribute transition rule associated becomes attribute space dealt
differently property spaces certain respects explained below 
next step identify domain objects associated property space
attribute space 
object referred initial state construct type vector bit
set corresponding space inhabited object  object inhabit
one space  habitation checked identifying properties hold 
initial state  object considered allocating states  rather
properties  appropriate state attribute spaces  every domain object
considered unique type identifier associated different bit patterns 
next task populate property spaces states  following definitions
required support explanation process 

definition    world state collection propositions characterising configuration
objects given planning domain description 

definition    given world state  w   property space  p    ps  trs  ss  os  
attribute space  p    ps  trs  os   object   os  p  projection st
bag properties  possessed w   belongs ps 

collection properties object  o  initial state divided set
bags properties  bag corresponding p  projection initial state o 
property attribute space p   bag added state set corresponding
property space  discarded corresponding space attribute space  need
extend spaces by  property space  adding states inferred
reachable objects within space along transitions within space  done
every state space  including states newly added process 
new states reachable  ordering properties within states irrelevant 
two states considered equal contain properties  regardless ordering
 they considered order equivalent   since  come use information
parts process invariant generation  require knowledge inclusion
relations pairs states  convenient mark stage  addition
reachable states important inference state invariants  use
discussed section      attribute spaces receive different treatment point 
   

fiautomatic inference state invariants

important difference observe that  since property spaces characterize exchange
properties  objects property space must start initial state members
property space  however  since attributes acquired without exchange 
possible objects particular attributes initial state acquire
attributes later  possible attribute space increasing attribute
transition rule associated it  now  therefore  consider attribute space see
whether objects added application corresponding increasing rule 
object added attribute space potentiates enablers
increasing rule attribute space  object potentiates enabling property
member state attribute space property belongs  membership
spaces indicates object could enter state satisfies
enabling properties  would justify application increasing rule 
enabling property associated state attribute space static condition 
initial state checked confirm property true object
considered 
complication arises enabling property used seed attribute space
 in case attribute   necessary identify
objects attribute space consider addition current attribute space 
course could  principle  initiate loop process avoid marking
attribute spaces considered ensuring  iterating convergence 
attribute spaces loop completely assigned  correctness part
procedure discussed section   
done state attribute spaces complete types
domain objects extracted  completeness construction phase discussed
section     

    worked example

fully worked example stages process help clarify involved 
consider simplified version rocket domain two operator schemas 

drive x y z 
pre 
add 
del 

load x y z 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

pre 
at x y   at z y 
add 
in x z 
del 
at x y 
initial state containing four constants  rocket  package  london paris 
relations  at rocket paris   fuelled rocket  at package london   observed
simplified rocket domain rather odd feature load schema
restricted loading packages rockets  oddity highlighted analysis
constructed  showing analysis performed tim help understanding
 and debugging  behaviour domain  drive operator schema following
prss constructed variables x   z respectively 
   

fifox   long

precs 
at    fuelled 
deleted precs  at    fuelled 
add elements  at    unfuelled 
precs 
at 
deleted precs  at 
add elements 
precs 
location 
deleted precs 
add elements  at 
load operator schema following prss constructed variables x  
z respectively 
precs 
at 
deleted precs  at 
add elements  in 
precs 
at    at 
deleted precs  at 
add elements 
precs 
at 
deleted precs 
add elements  in 
following rules built  first prs generates first two rules subsequent
prss generate one rule 
fuelled    at    at 
at    fuelled    unfuelled 

at    null
location    null   at 
at    in 
at    at    null
at    null   in 

construct following united sets properties 

fat   in g
ffuelled   unfuelled g
fat g
fin g
   

fiautomatic inference state invariants

used seed property spaces  first associate rules property
space seeds  resulting following assignment 

fat   in g
at    in    fuelled    at    at 
ffuelled   unfuelled g at    fuelled    unfuelled 
fat g
location    null   at    at    at    null 
at    null
fin g
at    null   in 
last two spaces converted attribute spaces association
attribute transition rules  resulting spaces supplemented domain
constants legal states  first identify subset legal states
domain objects identifiable initial state  use goal state
provide information properties objects  goal state might
unachievable objects cannot obtain required properties  would invalidate
tim s analysis domain  initial state rocket properties at  fuelled  
package property at    london property at  paris property at    using
information associate domain constants developing state attribute
spaces obtain 

fat   in g
at    in   fuelled    at    at 
frocket  packageg
ffuelled   unfuelled g at    fuelled    unfuelled 
frocketg
fat g
location    null   at    at    at    null  flondon  parisg
at    null
fin g
at    null   in 
next step add legal states objects  identifiable far 
property spaces  results following structures  first two
extended inference  as explained  completed property spaces  last
two extended completed attribute spaces addition objects
potentially acquire associated attributes  also described below  

fat   in g

at    in   fuelled    at    at 

ffuelled   unfuelled g at    fuelled    unfuelled 
fat g
fin g

frocket  packageg
 at   
frocketg
 fuelled  

location    null   at    at    at    null  flondon  parisg
at    null
at    null   in 

last stage construction two property spaces add states
inferred reachable  via transition rules  objects property spaces 
example  packages go at  in   application rule at    in  
since rule available property space package belongs  at 
one legal states property space  add in  legal state 
general  construct extension by  state space  identifying applicable
rules and  rule  creating new state removing properties start
   

fifox   long

rule adding properties finish rule  done states
order equivalent already generated  enablers rules ignored 
consequence new states generated might unreachable 
process completed current example finished property spaces follows 

property space  
fat   in g at    in   fuelled    at    at  frocket  packageg
 at     in  

property space  
ffuelled   unfuelled g at    fuelled    unfuelled  frocketg

 fuelled      unfuelled   

consider attribute space turn add domain objects  not already
members  potentiate increasing rules  new domain objects added
first attribute space since london paris potentiate increasing rule 
already present  however  second attribute space considered
observed rocket package potentiate increasing rule therefore
added new members  resulting attribute spaces are 

fat g location    null   at   at    at    null  flondon  parisg
at    null
fin g at    null   in 
frocket  packageg
oddity load operator revealed stage  since package rocket
assigned members in  attribute space  meaning
attribute things them  

number distinct bit patterns constructed  indicating object membership
state attribute spaces  determines number distinct types exist
domain  hence  simplified encoding rocket domain  three distinct
types  rocket type         package type        paris london
type         types given abstract identifiers  t   t  t   might
meaningfully interpreted types of  movable object requiring fuel  movable object
location respectively  expected  london paris type location  whilst
package type movable object rocket type movable object requiring fuel 
sub type movable object 
distinction made state attribute spaces exploited
process inferring state invariants  discussed section     

    assignment types operator parameters

types assigned parameters operators following way  given
operator schema collection property spaces attribute spaces allocate type
vector variables schema  membership state attribute
spaces properties given variable recorded setting appropriate bits
vector variable  properties appear preconditions
   

fiautomatic inference state invariants

schema considered  object satisfy preconditions operator
properties represented postconditions therefore right type
instantiation operator  type associated vector union
sub types taken  union type assigned variable  domain
object  type sub type type associated variable 
used instantiate variable  see process works  consider variable x
drive schema above  precondition properties x are  at    fuelled  
members two property spaces      therefore  type vector associated x
        observed type vector associated rocket        
type rocket sub type type x   sub type  union
sub types contains t   type rocket  means x instantiated
rocket  domain constant  since domain constant type
appropriate sub type relation  type operator parameters introduce new type
variables  tk   tn unused values k n  k number existing types
n k plus number variables schema considered  type vector
variable        z type vector location static
relation z appear argument predicate preconditions 
z therefore acquires type london paris  two objects
location true initial state  t  super type t   taking unions
sub types specify drive schema following way 

drive x y z 

params 
x t  y t  z t 
pre 
at x y   fuelled x   location z 
add 
at x z   unfuelled x 
del 
at x y   fuelled x 
stan exploits sub typing relations inferred constructing instances drive operator  variable appears schema appear
preconditions instantiated objects type  domain
description contains basis inferring type restrictions case  variable
appear delete list without appearing precondition list  since assume
delete list elements appear preconditions  variable would occur
add list  would mean that  regardless properties holding object used
instantiate variable  initial state  acquire add list property freely 
since acquisition would occur irrespective type object  variables
essentially polymorphic 

    inference state invariants

final phase computation tim inference state invariants
property spaces  attribute spaces used inference invariants 
incorrect invariants would proposed tim attribute spaces inadvertantly used 
explains importance identifying attribute spaces earlier stages
algorithm 
current version tim capable inferring four kinds invariant  three
inferred property spaces  identity invariants  state membership invariants
   

fifox   long

invariants characterizing uniqueness state membership  one inferred
operator schemas initial state directly  fixed resource invariants   simplified
rocket domain  considered above  example identity invariant is 

 x   tk   y  z  at x  y    at x  z    x   z 
state membership invariant is 

 x   tk   y   tn at x  y     y   tm in x  y  
uniqueness invariant is 

 x   tk     y   tn at x  y     y   tm in x  y  
infer identity invariants property space considered turn  respect
properties states  property  example pk p arity n      occurs
state invariant following form  z vectors
containing n     values  constructed 

 x  y  z  p  y   k    x  yk  n      p  z   k    x  zk  n        z 
form invariant generalised deal case
    occurrences pk state space  case build following
expression  assumed k      simplicity 

 x  y    ym  p  x  y           p  x  ym     y    y    y    y          ym     ym   
state membership invariants form 

 x  disjunct         disjunctn 
disjunct constructed single state  thus  property space contains k
states k disjuncts invariant constructed property space 
one state membership invariant constructed property space 
given collection states property space first identify supersets
states collection  supersets discarded  since invariants would
built would logically equivalent built subset states 
remaining state used build single disjunct  state considered contains
single property  pk p arity n  expression

 y p  y   k    x  yk  n   
constructed  course  n     existential quantifier disjunct
p  x   state contains one property  say denoted p     p  
build  again  assuming k     simplicity  

 y     ym  p   x  y     p   x  y           p  x  ym  
uniqueness invariants constructed similar way  property space
begin analysing superset states identify non exclusive pairs subset states 
   

fiautomatic inference state invariants

example  given subset states fat  g fin g superset state fat    in g 
observed two subset states mutually exclusive since at  in 
simultaneously held  done analysis identified mutually exclusive pairs
states mark subset states unusable generation invariants  remaining
states considered possible pairings  every pair states  p  q  generate
invariant following form assuming  simplicity  x first position
p     p n q    qm  form invariant easily generalised  before 

 x    y    yn  p   x  y     p   x  y           p n  x  yn  
   y    ym  q  x  y     q  x  y           qm  x  ym    
fourth kind invariant inferred structure operator schemas
without reference property spaces domain type structure  call invariants
fixed resource invariants since capture physical limitations domain  fixed
resource invariants cannot inferred state attribute spaces describe properties domain rather objects within it  following schema
gripper domain provides example fixed resource invariants distinguished
three kinds 

move x y 

pre 
add 
del 

robot x   room y 
robot y 
robot x 

prss would built operator are 

precs  
robot 
deleted precs   robot 
add elements  
precs  
room 
deleted precs  
add elements   robot 
rules constructed are 

robot    null


room    null   robot 

observed rules attribute transition rules robot 
attribute rather state valued  means invariants first three kinds
discussed would constructed 
reason lack invariants first three forms encoding
robot embedded predicate  robot cannot participate directly state transitions 
obvious invariant robot  would naturally true domain 
   

fifox   long

robot always exactly one room cannot inferred using techniques far
described  fact  axiom world  domain  rather specific objects
within it  obtained information state transformations
objects 
seen operator schemas gripper domain robot  balanced  is  always deleted whenever added added whenever deleted 
means number occurrences robot initial state determines
number occurrences possible subsequent state  leads construction  domain  invariant

jfx   robot x gj    
since one robot relation initial state  form fixed resource
invariants always equational  invariant states size set combinations objects satisfying certain predicate equal  or  cases  less equal 
certain positive integer  integer large convenient
write equation would write logical expression  information encoded
fixed resource invariants useful identifying unsolvable goal sets without attempting plan them  example  icparc version three blocks blocks
world  liatsos   richards         three table positions  must
always exactly three clear surfaces  goal specifying three clear relationships identified unachievable fixed resource invariants domain 
fixed resource uniqueness invariants produced tim seen providing
form multi mutex relations  contrast binary mutex relations inferred
construction plan graph graphplan based planners  blum   furst         binary
mutex relations indicate two actions facts mutually incompatible  whilst multimutex relations indicate larger groups actions facts collectively incompatible 
binary mutex relations  preventing fact true one object holding
two different objects simultaneously  extracted identity invariants
tim infers  multi mutex relations powerful binary ones  stan detect
unsolvable goal sets using fixed resource uniqueness invariants even
binary mutex relations corresponding level indicate problem exists 
infer invariants examine predicates language see whether
exchanged add delete lists operator schemas  predicate
exchanged equally schemas  it always appears number times add
list delete list schema  predicate corresponds fixed resource 
single schema upsets balance predicate treated fixed  given
fixed resource predicate  inferred never combinations
objects satisfying predicate initial state  slightly
odd encoding rocket world considered paper  location fixed resource 
fixed equally exchanged load schema  examples fixed
resource invariants inferred various standard domains provided appendix c 
certain circumstances necessary infer weaker invariant

jfx   p  x gj k
   

fiautomatic inference state invariants

positive integer k  p holds multiple objects initial state
possible subsequent state transformations  attribute acquisitions  result states
two instances p collapse one  p holds multiply often initial
state  or reachable state  necessary build invariant using
instead    p state valued  multiple instances never occur state
property space  safe assert equality construction invariant 
automatic inference first three kinds invariants relies construction
property spaces discussed section      discussed  distinction
state attribute spaces critical inference correct invariants  however 
using techniques described far  tim would lose information could
construct useful invariants  give example could occur consider
following simple encoding standard blocks world 

move x y z 
pre 
add 
del 

on x y   clear x   clear z 
on x z   clear y   clear table 
on x y   clear z 

operator  used bundy et al          add list element clear table  makes
reference constant  operator schema submitted analysis
current form prs would built constant  rules would constructed 
hence state attribute spaces constructed  would fail record fact every
application move results state table clear  resulting analysis
would result incorrect invariants types  grant        identifies version
move operator awed  need maintain state correctness addition
invariant clear table  add list  however  analyse schema correctly
first abstract remove constant  yielding following new schema 

move x y z t 
pre 
add 
del 

on x y   clear x   clear z   table t 
on x z   clear y   clear t 
on x y   clear z 

now  given initial state blockc blocka blockb table 
add proposition table table   so new precondition satisfied 
property attribute spaces constructed follows 

fon g

clear    on    on 

fblocka  blockb  blockc g
 on   
fon   clear g on    clear   clear    on   fblocka  blockb  blockc  tableg
table    null   clear 

second attribute space  invariant extraction algorithm
applied it  consequently  invariants infer characterize
positions blocks  every block exactly one surface   pity 
information available attribute space could yield useful extra invariants 
particular  would infer invariant every block either clear
   

fifox   long

something it  cannot clear something it  reason
cannot infer invariant would asserted hold every object
attribute space  including table  even though actually true table  the
table things still clear  
      sub space analysis property attribute spaces

solution problem loss invariants decompose property attribute
space contains k     object types k sub spaces  property sub space structurally identical property space  attribute sub spaces identified used 
invariants obtained them  property sub spaces obtained analysis attribute spaces  following example show  reason distinguishing
sub spaces property attribute spaces properties partitioned
sub spaces property attribute spaces  original property
attribute space discarded sub spaces used determining types
objects  role sub space analysis enable construction additional
invariants 
consider blocks domain described previous section example
benefits sub space analysis  point invariant construction types
domain objects identified property attribute space membership 
table already known different type blocks  table
member property space on    therefore  two sub spaces constructed
attribute space  one type       blocks  one type      
tables  sub spaces constructed property space contains
one type object  rules associated sub spaces rules
original attribute space enabled objects appropriate type  second
two sub spaces attribute sub space inclusion increasing
attribute transition rule  stage two sub spaces follows 

fon   clear g on    clear   clear    on 
fblocka  blockb  blockc g
fon   clear g table    null   clear   on    clear   ftableg
clear    on 
attribute sub space used invariant construction contains
attribute transition rule would result incorrect invariants  as case attribute
spaces   nothing gained developing further  however  state
sub space completed addition states associated objects
space  initial state extension  resulting sub spaces are 

fon   clear g on    clear   clear    on 

fblocka  blockb  blockc g
 on      clear  
fon   clear g table    null   clear   on    clear   ftableg
clear    on 
new state sub space infer following invariants  using type name
block stand type vector       infer identity invariant 
 x   block   y  z  on y  x    on z  x      z  
   

fiautomatic inference state invariants

state membership invariant 

 x   block   y   block on y  x    clear x  
unique state invariant 

 x   block    y   block  on y  x    clear x   
although additional invariant  table always clear  cannot infer
present 

    problem mixed spaces

happen encoding domain conceals presence attributes within
schemas point property space extension occurs  prevent
property space extension process terminating  example  simple lightswitch domain contains following two schemas 

switchon x 
pre 
add 
del 

switchoff x 
pre 
add 
del 

off x 
on x   touched x 
off x 
on x 
off x   touched x 
on x 

initial state switcha on  two prss constructed 
precs  
off 
deleted precs   off 
add elements   on    touched 

precs  
on 
deleted precs   on 
add elements   off    touched 
giving rise two rules 


off    on    touched 

on    off   touched 

uniting seeds one property space containing three properties  addition
rules property space follows 

fon   off   touched g off    on   touched   fswitchag
on    off    touched   on   
   

fifox   long

point extension space problem arises  following states
added   off   touched     on   touched   touched      off   touched   touched   touched   
on  cannot simply avoid adding properties already state extended two  apparently identical  properties might general refer different
arguments 
problem due fact touched  actually increasing attribute
become apparent prss  consequence mixed spaces
constructed  mixed space property space containing hidden attributes  tim detects
hidden attributes checking  extension  new state contains state already
generated initial state starting point  thus  extension mixed space
above  tim would detect hidden attribute state  on    touched   touched  
constructed  state contains state  on    initiated extension 
detected hidden attribute two possibilities  either tim convert
mixed space attribute space  case invariants constructed 
attempt identify attribute split mixed space attribute space
property space containing state valued components mixed space  take
option split state  allows us infer invariants concerning state valued
properties 
tim takes difference including included states and  distinct
property difference  processes rules cutting rule containing property
two rules  least one attribute rule  following method
used cut rules  following  attr  indicates one occurrences
attribute valued property comma overloaded mean bag conjunction
bag union  rule form 

enablers   start   adds  attr 
two new rules forms 

enablers  start   null   attr 

rule form 

enablers   start   adds
enablers   attr    precs   adds

two new rules forms 

enablers  precs   attr   null


enablers  attr   precs   adds

rule cutting separates attribute valued properties state valued properties 
pure attribute property spaces constructed  however discard
original mixed space used determining type structure
   

fiautomatic inference state invariants

domain  additional type information could extracted state
attribute spaces built following analysis currently exploited 
analysis applied lightswitch domain  following new property
space attribute space built 
fon   off g off    on   on    off 
fswitchag
 on      off  
ftouched g off    null   touched   on    null   touched  fswitchag
using lightswitch stand type       following state membership invariant
constructed property space 
 x   lightswitch  on x    off x  
tim constructs uniqueness invariant 
 x   lightswitch   on x    off x  

   properties tim

correctness tim relies constructing necessarily true invariants  demonstration true invariants constructed guarantees construction adequately discriminating type structure  cannot guarantee under discrimination
argue over discrimination occur type structures generated
tim  properties defined section     
over discrimination would result distinguishing functionally identical objects
type level  would occur tim placed objects participate identical
state transitions different property spaces but  underlying partitioning
properties property spaces  cannot happen  further  membership different
property spaces requires distinguishing state transformations 
functionally identical objects  flawed assignment  assigning object
property space without corresponding state transformations   simply seen
erroneous  rather over discrimination  possibility occurring
excluded property attribute space construction extension shown
correct section     
failure detect type differences  under discrimination  domain result
weak invariants  over discrimination  could occur  would lead over targeted
invariants would still true  subset objects ought
cover  flawed assignment would clearly lead construction false invariants  underdiscrimination  arise  therefore affects completeness state invariant
inference procedure  lead over generalisation operators since types
assigned operator parameters equally under discriminating  enable meaningless instances formed  needlessly increasing size search space
must explored planner  clearly raises eciency issues
undermine formal properties planner exploits tim 
observed  consequence under discrimination construction weak  but
valid  invariants  following example illustrates under discrimination occur 
given schema 
   

fifox   long

op x y 
pre 
add 
del 
initial state

p x y 
q x y 
p x y 

p a  c   p b  c   q b  d 

hold  following two property spaces constructed 

fp   q g p    q  fa  bg
 p     q     p   q      q   q   
fp   q g p    q  fc  dg
 q      p   p      q   p      q   q   
given property spaces impossible distinguish b c d  even
though analysis operator schema initial state reveal functionally distinct
b c d  seen that  although must always exchange p  q   
b p  q  simultaneously  similar observation made c
d  however  process invariants constructed cannot gain access
information  identity invariant constructed first property space is 

 x    y  z  u  q x  y    q x  z    q x  u      z     u   z   u 
invariant weaker ideal  participate one q relation  b
participate two simultaneously   state membership invariant property space
is 
 x      y   t  p x  y      y   t  q x  y  
understates case b  p  q  simultaneously  unique
state invariant constructed property space  p  q  mutually
exclusive 

    correctness completeness transition rule construction phase

correctness algorithm used tim depends two elements  firstly  property
spaces identified algorithm must correctly populated  is  objects
assigned property spaces belong every achievable state must
included appropriate property space  secondly  property spaces must
support generation correct invariants  second element examined section     
interesting relationship exists states property space invariants generated space  incorrect invariants contructed property space
missing achievable states  state membership invariants assert
object property space must one states property space  states
missing invariant false  prove achievable states
appropriate property space 

theorem   given initial state    collection operator schemas  o  property space 
p    ps  trs  ss  os   generated tim applied o  state  st 
   

fiautomatic inference state invariants

reachable application valid linearised plan formed ground instances
operator schemas o    os  p  projection st o  stop   ss 

proof 

proof induction length plan yields state st  base
case plan contains operator instances st     p  projection
ss  definition first phase property space construction process described
section     
suppose st generated plan length k      last step penultimate
state pre st  let p  projection pre st pre stop   inductive hypothesis 
state ss  affect state o  p  projection st
pre stop   therefore ss trivially  otherwise  consider operator schema 
op   o  formed  described section      constants appear op
variables body op parameters op  let initial collection prss
constructed op  parameters instantiated creation a 
set prs     prsn every prsi form 
precs  
pi
deleted precs   di
add elements   ai
initial collection collection formed prior splitting 
value ith prs lead construction k     transition rules 
k size bag intersection  xi   di ai   k rules
following form 
 c   xi  pi fcg   c   c 
remaining rule form 

pi  di xi      di xi     ai xi  
refer latter rule prsi ith complex rule  subset n complex
rules contain property ps either start finish will  therefore 
relevant transition pre st st  observed complex
rules  prs     prsm without loss generality  must p uniting process
described     
define pres a op p  projection preconditions o  similarly 
adds a op dels a op defined p  projections add delete lists
respectively  construction prss  defined section     


  pi
mm
adds a op   ai
mm
dels a op   di

pres a op

 
 

 

   

fifox   long

restriction delete lists must subset preconditions 
fact applicable pre st  follows dels a op v pres a op v pre stop   since
v represents bag inclusion seen separate bags di included
pre stop without overlap 
extension process involves iterated application rules explained
section     indicated pseudo code algorithm presented appendix b 
rule applicable state start must included state  therefore
complex rules applicable  regardless sequence application  pre stop  
follows state
 pre stop

mm  di xi   mm  ai xi 
 

 

generated extension process  definition xi   fact di v pre stop  
state written as 
 pre stop

mm di  ai
 

which  observed above  just 
 pre stop dels a op   adds a op
equals stop standard semantics operator application strips 

 

proof demonstrates splitting  discussed      result generation
invalid invariants  however  splitting compromise completeness invariantgeneration process  result inclusion unreachable states property spaces 
consequence identity state membership invariants generated
weaker would otherwise case  discussed section     
explain role splitting prs construction phases  domain
object strips domain associated finite automaton states consist
properties  for example  at    have  either initially result application
arbitrary length sequence operators  objects observed
type identical automata property level  prss capture ways
operator applications modify configurations individual objects hence
provide encoding automata 
prss built two phases  first phase  parameters
schemas considered  possible object state transitions captured  however 
transitions conceal functional distinctions inherent domain description
would lead premature amalgamation property spaces  observed
discussion rocket domain section      example observed use
standard formula construction rules prss alone would result
failure detect type distinction rockets packages 
second phase assists type inference processes avoiding under discrimination
distinguishing enablers state transformation properties exchanged
   

fiautomatic inference state invariants

transformation  prs characterizing exchange k properties split
form k     new prss  prss      given section      show two
prss constructed single prs containing single exchanged property 
simple example  one split required remove exchanges  general might
necessary split repeatedly exchanges removed  shown example given
prs   section      non exchange combinations properties deleted precs
add elements considered splitting  resulting prss lead
construction transition rules allow generic state transformations  movement
one location another  separated specific nature objects
make transformations 
observed rules result splitting process general
rules would obtained prs prior splitting 
distinguish precisely properties take part state transitions
properties simply enable transitions  allowing finer type distinctions
inferred basis functionalities objects domain  finer distinctions
made process seeding property attribute spaces uniting 
uniting merges  single equivalence classes  properties appear
start finish rule 
argue state transformations accounted end second
phase  result second phase automata formed first phase
separated collections simpler automata possible  transitions
lost finer grained encoding possible transitions made
objects appropriate properties  prss constructed phase support
construction rules allow objects making transitions occupy different property
spaces  second phase prss may under constraining  sense
analysis subsequent schemas might eliminate possibilities keeping open 
example        set prss obtained end second phase cannot
over constraining first phase prss considered splitting 
subtlety concerns consequence  type level  assigning two functionally
distinct objects state attribute space  example  example      rocket
package assigned property space fin   at  g attribute space
fin g  however  rocket fuelled unfuelled  package cannot 
distinction emerges property attribute membership vectors
associated rocket package objects  membership additional property space
ffuelled   unfuelled g means rocket assigned type sub type type
package functional distinctness rocket package recognised  discussed 
oddity encoding results package assigned membership
fin g attribute space  furthermore  at  in  united  effect
rockets make at    in  transition used instantiate variables type
movable object  even variables type intended instantiated
package  nothing domain description prevent interpretation 
conventional encoding load schema would prevent rocket loaded
object  would cause refinement type structure would
identify loadable objects  would prohibit use rocket forming instances
operators restricted operating objects 
   

fifox   long

construction transition rules follows simple rule whereby undeleted preconditions used enable transformation state deleted preconditions
prs hold one added elements prs hold  given assumption
deleted atoms operator schema must appear preconditions schema 
rules correctly characterize strips style state transformations  possible transformations captured second phase prs construction  complete set
correct transition rules therefore constructed 
given correctness completeness transition rule construction phase  correct
initial allocation objects spaces depends simply correctly checking membership
initial properties object property sets  formed uniting rules 
used seed spaces  extension property spaces done straightforward
application transition rules  configurations properties occupied
objects property space added end extension phase 
extension attribute spaces unproblematic cases potential enabler
attribute  one is  process attribute space enabler
completed could  appears  initiate loop attribute space extension process 
fact  happen tim able detect loop occurred avoid
repeatedly iterating it 
following example illustrates problem way solved tim  suppose
three attribute spaces 

attribute space  

fq g p    null   q  fa  bg

attribute space  
fr g q    null   r  fcg

attribute space  
fp g r    null   p  fdg
spaces extended addition objects potentiate increasing rules 
discussed section      problem arises enablers rules states 
attributes  extension attribute space   enabler  p    attribute 
attribute space p  yet extended  necessary complete
space using complete    extension   requires extension   
reason  requires extension   requires extension    on 
way tim avoids re entering loop marking space  considered 
seen iteration  marked space encountered extended
used already complete  second iteration required extend
spaces still require completion  subsequent iterations required
process converges  experiments suggest unusual
two iterations required  worst case upper bound as  number
domain constants number attribute spaces  which limited number
properties   hence quadratic size domain description 
   

fiautomatic inference state invariants

extension process starts attribute space    example  attribute
space   marked seen first iteration  tim goes
extend space   extension space   depends upon space   complete 
space   marked seen iteration space   considered  space  
marked space   revisited  space   marked tim infers loop
entered  objects added space   without extension objects space  
added space    finally  objects space   added space  
first iteration complete 

fq g p    null   q  fa  bg   fc  dg
fr g q    null   r  fcg   fa  bg
fp g r    null   p  fdg   fc  a  bg
however  space   yet complete  second iteration required  iteration
starts place first process repeated  except
iterations required example 

    correctness state invariants

argue correctness invariant inference procedure considering
four kinds invariant turn  following arguments rely upon correctly distinguishing property spaces attribute spaces  since invariant analysis cannot
performed attribute spaces  scope confusing distinction extension mixed spaces  extract attributes mixed spaces checking inclusion
existing states new states generated extension  process discussed
section     

definition    given property space p    ps  trs  ss  os   ss partitioned
three disjoint sets  sssubs sssups contain states ss included
 as bags  include  as bags   respectively  least one state ss ssind
contains independent states ss neither sssubs sssups  
theorem   given property space p    ps  trs  ss  os   set states ss

union three disjoint sets states ssind   sssubs sssups   object  o 
os following families invariants hold 
   identity invariants 
   state membership invariants 
   unique state invariants 
defined section     

proof 

address kind invariant turn  theorem   every object os must
state ss  furthermore  states object os  respect property
ps  ss  follows properties partitioned spaces
   

fifox   long

seeding process  therefore  maximum number occurrences property
p ps  possessed object os state world  bounded
maximum number instances property state ss  these maximum values
might equal since ss contain inaccessible states   identity invariants simply
express bound properties objects os 
every object os must state ssind  sssubs   follows definition
sets definition    theorem    state membership invariants assert
every object os must least one states  disjunct invariant
corresponding assertion membership one states 
argue correctness unique state invariants  observe proposed
invariants would false paired states mutually exclusive 
case  either state extension process would put properties could simultaneously held bag  properties would simultaneously held
initial state hence would appear bag initial construction property
space  either case  state exist property space superset
non exclusive states  however  uniqueness invariants generated pairs states
drawn ssind   sssups non exclusive pairs states lead
generation incorrect invariants 

 
fixed resource invariants always associated particular predicate  atoms
built predicate balanced add delete lists operator
schemas number occurrences atoms initial state fixed
subsequent states  invariant expresses  invariant constructed
every predicate forms balanced atoms 
since new techniques required infer invariants sub spaces 
argument required support correctness invariants formed following sub space
analysis 
although theorem   demonstrates correctness invariants inferred tim
possible weak invariants inferred presence unreachable states ss 
weak identity invariants inferred unreachable state generated  extension 
containing instances property contained reachable state 
happens identity invariant generated weaker would ideal 
still valid  further  property space contains unreachable states cause
inclusion additional false disjuncts state membership invariants  since
false disjuncts exclude satisfying assignments presence invalidate
invariants  unreachable states cause additional tautologous uniqueness invariants
generated affect strength invariants refer reachable states 
clearly cannot hope identify unreachable states  analysis would
hard planning itself 
invariants generated attribute spaces tim cannot claimed
complete  sub space analysis rectifies extent identifying property spaces
exist within attribute spaces allowing invariants generated 
analysis could refined 
   

fiautomatic inference state invariants

    effects tim properties planner

tim sound  planner uses tim danger losing soundness result 
tim certainly complete domain axioms invariant properties

kinds cannot extracted current version  example  kautz selman
       identify optimality conditions simplifying assumptions amongst different
kinds axioms might inferred domain  optimality condition
logistics domain might be  package returned location
removed from  simplifying assumption domain might be  truck
loaded immediately move  assuming necessary loads done parallel  
constraints require deeper analysis domain currently performed
tim  intend characterise infer future work 
cannot guarantee type structure inferred tim always fully discriminating  although guarantee over discriminating  however  failure
tim s part infer structure inferred impact
completeness planner using tim because  cases  tim return unstructured
domain planner therefore default reasoning unstructured domain
necessary 

   experimental results

examination tim s performance carried several dimensions  consider
three specific dimensions here  viability analysis typical benchmark domains 
scalability analysis utility performing analysis prior planning 
general performance standard benchmark problems provides indication scale
overhead involved using tim preprocessing tool  experiments performed
linux    mhz pc     mb ram  figure   shows that  even large
problem instances  overhead entirely acceptable  mystery problems listed
table large  involving initial states containing hundreds facts  could
solved stan  ipp  koehler  nebel    dimopoulos        blackbox  kautz  
selman        aips    competition  nature mystery domain described
appendix c  emphasises relative costs preprocessing planning efforts 
selection problems used construct table   justified follows  blocks
world used representative example three encodings supplied
pddl release  are  simple encoding  prob     att encoding  prob   
snlp encoding  prob     hanoi set contains collection reasonably sized problems 
representative group relatively large mystery instances chosen pddl
release  two tyre world instances two strips instances available
release  three logistics problems three largest simple strips encoding
included pddl release 
second dimension scalability analysis  analytic examination
algorithm determine upper bound performance polynomial
key domain problem components  including number operator schemas  number
literals operators  numbers objects facts initial state number
arities predicates language  figure   shows performance tim roughly
quadratic size problem specification  graph  size crudely equated
   

fifox   long

domain problem
blocks
prob   pddl
prob   pddl
prob   pddl
hanoi
  disc
  disc
  disc
  disc
  disc
mystery
prob    pddl
prob    pddl
prob    pddl
prob    pddl
prob    pddl
tyre world prob   pddl
prob   pddl
logistics
prob   pddl
prob   pddl
prob   pddl

parse time
 
 
 
 
 
 
 
 
  
  
  
  
  
 
 
 
 
 

analysis time
 
 
 
 
 
 
 
 
  
  
  
 
  
 
 
 
 
 

output time total
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
  
  
   
  
  
 
  
  
  
  
  
  
  
 
  
 
  
 
  

figure    table showing tim s performance milliseconds standard domains problems  timings elapsed times minor discrepancies totals arise
rounding 

   

fiautomatic inference state invariants

tim analysis mystery domain

     
     



    
millisecs     



    
    










 
 





                                               
size file

figure    graph showing tim s performance mystery problems  plotting time
size  in characters  problem file  solid line plot quadratic function 
number characters specification file  graph constructed running
tim strips mystery domain problems pddl release  increasing
sizes problem specifications ect increases various categories
objects domain corresponding facts describe initial states 
figure   shows effect tim s performance number operator schemas
increases  graph constructed using artificial domain new operator
causes two new state transitions described two new literals  thus  number
operators number properties increasing whilst number objects stays constant 
domain described detail appendix e  graph indicates linear growth
cost analysis 
final dimension evaluating tim effect exploitation output
planner  gerevini schubert        kautz selman        provide convincing
evidence supporting powerful role state invariants enhancing performance
sat based planning  figure   demonstrate power inferred types showing
advantage stan tim obtains stan without tim untyped rocket domain
problems  figure   shows effect performance increasing number packages
transported  time taken stan tim grows linearly  whilst stan without
tim follows cubic curve  p packages problem instance stan tim
constructs   p     operator instances stan without tim constructs  p      p      p
instances  demonstrates type information significant factor
advantage depicted graph  figure   demonstrates similar improvement
obtained logistics domain  graph series sub problems considered
   

fifox   long

  
  
  
  
  
millisecs   
  
  
  
  
  

tim performance increasing number operators

 
 

 
 

 

 
 

 

 

 

 

 

 

 

 
 
  
number operators

 

 

 

  

  

  

  

figure    graph showing consequences increasing number schemas inferrable property spaces 
effect tim performance stan

     

 

stan without tim  
stan tim  

     
    

 

millisecs    
    

 

 

 

 

 

 

  
 
   
  
                          
   
  
   
   

    

 

 

  

  
  
  
number packages

  

  

  

figure    graph showing comparison stan stan without tim rocket
domain problems generated rocket domain provided appendix d 
   

fiautomatic inference state invariants

effect tim performance stan

     
     

stan without tim
stan tim

    
millisecs    
    
    
 

 

   

 

   
 
   
number sub problems

 

   

 

figure    graph showing comparison stan stan without tim logistics
domain problems 
sub problem involves independent transportation single package
two cities 
simple domains  overhead carrying analysis outweigh
advantages offered  example  movie domain used competition stan gained
benefits using tim paid overhead detriment performance
instances domain  however  general observe benefits analysis
increase increasing complexity domains 

   related work
although importance state invariants ecient planning observed
relatively little work automatic inference invariants  published work
closely resembles research described paper state constraint inference
system discoplan  gerevini schubert         discoplan enables inference
sv constraints correspond subset identity invariants  reason
discoplan restricted subset generates sv constraints pairs literals
 one addlist schema delete list  arguments
vary one place  tim infer identity invariants vectors arguments vary 
shown section      discoplan cannot currently infer singly varying constraints
 although techniques described gerevini schubert      a  yet fully
implemented discoplan   example  discoplan cannot infer blocks
   

fifox   long

one surface  analysis blocks world domain cited paper  tim
infer invariants sub space analysis 
gerevini schubert      a      b  examined potential inferring
parameter domains similar operator parameter types inferred tim 
domains inferred iterative process accretion similar attribute
space extension process tim  however  accretion process describe synthetic 
parameter domains synthesised directly operator descriptions
initial state  tim analytic system constructs types analysis functional properties domain objects  analytic approach provides rich information
source structures  including domain invariants  derived 
implicative constraints inferred discoplan correspond implicit
type assignment would arise type structure built tim  implicative
constraint generated discoplan refers separation functional roles objects 
particular  irre exivity on  in 
 x  y  on x  y      x   y  
captured using kind constraint  tim cannot currently infer invariants 
tim uses analysis based state view objects domain able
generate broader collection invariants  including state membership unique state
invariants currently produced discoplan 
although discoplan deal negative preconditions tim cannot yet manage
them  invariants produce overall currently less powerful inferred
tim 
apart work gerevini schubert  older work inference
invariants relies generation candidate invariants
confirmed inductive process domain operators  two examples
work kelleher cohn        morris feldman         former work
concentrates identifying directed mutual persistence relations  hold pairs
facts domain when  established  second continues hold
first does  use relations leads inference collection constraints
fall uniqueness invariants inferred tim  work described  morris
  feldman        authors build invariants using truth counts counts
number propositions particular identified sets must true state
domain  sets count   used build invariants
subset state membership uniqueness invariants  authors describe methods
attempting identify sets facts work  work  common
kelleher cohn gerevini schubert  builds invariants first hypothesising
possible seed invariants determining validity analysing effects
operators seeds  contrast generate and test strategy  tim produces
correct invariants infers deep  structural analysis domain 
inference invariants exhaust possibilities analysis  example 
type structure inferred automatically analysis  shown
dramatic potential eciency planning  relationship enablers 
state transitions enable  determines ordering satisfaction goals 
significance eciency  further  state based view behaviour
   

fiautomatic inference state invariants

domain objects would allow techniques described mccluskey porteous       
automated 
mccluskey porteous        proposed explored object centred approach
planning  approach based provision  domain engineer  rich
collection state invariants object sorts participating functional relationships
domain  invariants exploited domain compilation phase facilitate
ecient planning application domain  tim infers precisely sorts collections
state invariants mccluskey porteous provide hand 
grant        generates state invariants state descriptions  provided hand 
uses invariants build operator schemas  approach clearly related even
though objectives analysis different  grant concerned automatic
synthesis domain descriptions rich requirements specification provided
expert user  concern reverse engineering domain description obtain information help increase eciency planners applied domain  although
primary objectives use tim enhance performance planning within
domain  tim provides valuable tool construction domain descriptions
revealing underlying behaviours domain engineer implicitly imposed 
helping debugging domain descriptions 

   conclusion
tim planner independent set techniques identifying underlying structure

domain  revealing type structure collection four different kinds invariant conditions  one important application techniques domain debugging aid
construction large complex domains  using tim revealed many anomalies
domains encoded us others  greatly assisted us understanding
stan s performance many domains problems  another important application
increasing eciency planners making explicit planner information
domain would otherwise infer  domain representation 
planning 
tim generates rich collection invariants containing many inferrable
related systems  discussed previous section  results presented gerevini
schubert        suggest marked improvement obtained use
invariants performance planners based sat solving techniques  analysis
yet done determine advantages might obtainable using invariants
planners based architectures  stan yet exploit invariants produced tim planning  uses type structure fixed resource invariants
currently developing extension stan fully exploit kinds
invariant  expect able use uniqueness identity invariants shortcut
effort involved deducing significant subset necessary mutex relations
graph construction 
analysis performed tim ecient  growing slowly quadratic function
size initial state analysed  empirical analysis consider
effect tim s performance increasing numbers operator schemas  however 
argument presented section   shows tim s analysis grows linearly number
   

fifox   long

operator schemas  linearly number domain constants linearly
size initial state  factors take account  confirms
polynomial performance size  and related structure  domain increases 
type analysis performed tim differs  important respects  various
forms type analysis performed compilation programs written strongly
typed languages  latter context type correctness program judged
respect imposed context basic types  tim infers basic types domain
description impossible domain specification well typed  consequently
attempt type check domain descriptions using tim  direction
hope move near future  type checking enable unsolvable
problems detected unsolvable statically rather planning time  currently
focus type inference exploitation inferred type structure
management search space planner 

   acknowledgements

would thank alfonso gerevini  gerry kelleher anonymous referees
useful discussions helpful comments earlier drafts paper 

appendix a  ftp web sites

aips    planning competition ftp site at 

http   ftp cs yale edu pub mcdermott aipscomp results html 

web site  stan tim executables found  at 



http   www dur ac uk  dcs www research stanstuff planpage html

appendix b  tim algorithm

following pseudo code description tim algorithm 
fconstruct base prss  section     g
ps    fg 
operator schema  o 
variable o  x 
construct prs x add ps 

fsplit prssg

prs ps  p 
property  p  appears p adds deleted precs fields
split p p  p  q replace p p  q ps 
split p p 
construct prs q precs p  deleted precs adds set fpg 
construct prs p  p removing p deleted precs adds p 

fconstruct transition rules  section     g
ts    fg 

prs ps  p 
construct transition rule p add ts 

fseed property attribute spaces  section     g

let property initially assigned separate equivalence class 
rule  r  ts
merge together  unite  equivalence classes properties start finish r 

   

fiautomatic inference state invariants

construct separate space equivalence class properties 

fassign transition rules  section     g

rule  r  ts
place r space associated equivalence class containing properties
start  and finish  r  s 
r increasing decreasing rule
mark attribute space 

fanalyse initial state  section     g

object  o  domain
identify bag initial properties o  i o  
space  s 
construct bag properties i o  belong equivalence class
associated s  b 
b non empty
add space s 
attribute space
add b state s 

fextend property spaces  section     g

property space  p 
unextended state p  s 
mark extended 
newgen    fg 
rule p  r 
start r included
add state snew    s ominus start oplus end  newgen 
snewis superset state newgen
mark p attribute space exit analysis p 
add newgen states p 

fextend attribute spaces  section     g

changes    true 
changes 
changes    false 
unmarked attribute space  a 
extend extend a 
mark a 
rule a  r 
property enablers r  p 
p s equivalence class associated unmarked attribute space  a  
extend a  
add objects appear every space associated enabling property r a 
objects added
changes    true 

fidentify types  section     g

object domain  o 
identify pattern membership spaces o  tt 
associate type pattern  tt  o 
operator schema  o 
argument o  x 
identify pattern membership spaces x implied properties x
preconditions o  tt 
associate type pattern  tt  x o 

fconstruct invariants  section     g

property space  p 
property p  p 
construct identity invariant p 
construct state membership invariant p 
construct uniqueness invariant p 

   

fifox   long

appendix c  example output

following output produced tim found  along examples 
stan webpage  examples show details analysis performed
three domains  flat tyre domain  mystery domain logistics domain 
analysis done respect initial state set operator schemas  operator
schemas used three domains provided pddl strips releases
domains  initial states taken pddl release  pddl release
found http   www cs yale edu html yale cs hyplans mcdermott html 

c   tyre world
tim  type inference mechanism   support stan  state analysis planner
d  long m  fox  university durham

reading domain file  domain   pddl
reading problem file  prob   pddl
tim  domain analysis complete flat tire strips
tim  types 
type
type
type
type
type
type
type
type

t 
t 
t 
t 
t 
t 
t 
t 

 
 
 
 
 
 
 
 

 wrench 
 wheel  
 wheel  
 trunk 
 the hub 
 pump 
 nuts 
 jack 

noticed two wheels separated different types 
one wheel intact intact  operator repairing wheels
intact  tools given different types 
appear constants different operators therefore functionally distinct 
tim  state invariants 
forall x t    on ground x  lifted x  
forall x t    on ground x  lifted x  
forall x t    closed x  open x  
forall x t    closed x  open x  

   

fiautomatic inference state invariants

forall x t  u t    deflated x  inflated x  
forall x t  u t    deflated x  inflated x  

invariants hubs  below  suggest almost anything could hub  since
case type structure under discriminating  however  additional
invariants drawn sub space analysis provide enough information  principle 
discriminate fully types  information yet fully exploited 
forall x t   forall y   forall z   on y  x  on z  x     y    z 
forall x t    exists y  t  u t  u t  u t  u t  u t   on y  x 
free x  
forall x t    exists y  t  u t  u t  u t  u t  u t   on y  x 
free x  
forall x t   forall y   forall z   tight y  x  tight z  x     y    z 
forall x t   forall y   forall z   loose y  x  loose z  x     y    z 
forall x t     exists y  t  u t  u t  u t  u t  u t   tight y  x 
fastened x  
 exists y  t  u t  u t  u t  u t  u t   loose y  x 
fastened x   unfastened x  
forall x t     exists y  t  u t  u t  u t  u t  u t   tight y  x 
fastened x  
 exists y  t  u t  u t  u t  u t  u t   loose y  x 
fastened x   
forall x t     exists y  t  u t  u t  u t  u t  u t   tight y  x 
fastened x   unfastened x  
forall x t     exists y  t  u t  u t  u t  u t  u t   loose y  x 
fastened x   unfastened x  

tim  domain invariants 
  x  
  x  
  x  
  x  
  x  
  x  
  x  
  x  
  x  

container x        
hub x        
intact x        
jack x        
nut x        
pump x        
unlocked x        
wheel x        
wrench x        

tim  attribute spaces 

   

fifox   long

attribute space properties first groups subjected much
rigorous analysis sub space invariants below 
objects  x  t  u t  u t  u t  u t  u t  property 
exists y  t   in x y   
exists y  t   on x y   
exists y  t   tight x y   
exists y  t   loose x y   
have x  
objects  x  t  property 
exists y  t  u t  u t  u t  u t  u t   in y  x  
objects  x  t  property  container x  
objects  x  t  property  hub x  
objects  x  t  property  intact x  
objects  x  t  property  jack x  
objects  x  t  property  nut x  
objects  x  t  property  pump x  
objects  x  t  property  unlocked x  
objects  x  t  u t  property  wheel x  
objects  x  t  property  wrench x  

tim  operator parameter restrictions 
inflate x  t  
put on wheel x  t  u t  x  t  
remove wheel x  t  u t  x  t  
put on nuts x  t  x  t  
remove nuts x  t  x  t  
jack down x  t  
jack up x  t  
tighten x  t  x  t  
loosen x  t  x  t  
put away x  t  u t  u t  u t  u t  u t  x  t  
fetch x  t  u t  u t  u t  u t  u t  x  t  
close container x  t  
open container x  t  
cuss  

tim  additional state invariants  using sub space analysis 

report additional state invariants add information invariants
already listed  tim currently reports invariants subsumed earlier collection 
observed first wheel intact second not  gives
rise following new invariant wheels second type 
   

fiautomatic inference state invariants

forall x t    deflated x  

first attribute space  contains objects except trunk hub 
subjected sub space analysis yielding rich new collection invariants 
forall x t   forall y   forall z   in x y   in x z      y    z 
forall x t    exists y  t   in x y   have x  
forall x t    exists y  t   in x y   have x  
forall x t   forall y   forall z   in x y   in x z      y    z 
forall x t   forall y   forall z   on x y   on x z      y    z 
forall x t    exists y  t   in x y   have x 
exists y  t   on x y   
forall x t    exists y  t   in x y   have x  
forall x t    exists y  t   in x y   exists y  t   on x y   
forall x t    have x  exists y  t   on x y   
forall x t   forall y   forall z   in x y   in x z      y    z 
forall x t   forall y   forall z   on x y   on x z      y    z 
forall x t    exists y  t   on x y   have x 
exists y  t   in x y   
forall x t    exists y  t   on x y   have x  
forall x t    exists y  t   on x y   exists y  t   in x y   
forall x t    have x  exists y  t   in x y   
forall x t   forall y   forall z   in x y   in x z      y    z 
forall x t    exists y  t   in x y   have x  
forall x t    exists y  t   in x y   have x  
forall x t   forall y   forall z   in x y   in x z      y    z 
forall x t   forall y   forall z   tight x y  
tight x z      y    z 
forall x t   forall y   forall z   loose x y  
loose x z      y    z 
forall x t    exists y  t   tight x y  
exists y  t   loose x y  
have x  exists y  t   in x y   
forall x t    exists y  t   tight x y  
exists y  t   loose x y   
forall x t    exists y  t   tight x y   have x  
forall x t    exists y  t   tight x y  
exists y  t   in x y   
forall x t    exists y  t   loose x y   have x  
forall x t    exists y  t   loose x y  
exists y  t   in x y   
forall x t    have x  exists y  t   in x y   

   

fifox   long

c   mystery domain

mystery domain devised drew mcdermott aips    planning competition 
intention conceal structure problem domain employing obscure
encoding transportation domain  code replaces locations names foods
routes eats relations  transports pleasures cargos
pains  cargos transports locations  relation encoded craves 
cargo either location transport encoded fears relation  transports
restricted capacity encoded planets consume fuel travelling locations 
fuel exists limited quantities locations measured provinces  using tim
able decode domain identify roles played components
encoding 
tim  domain analysis complete mystery strips  prob    pddl 
tim  types 

noted provinces  types t   t  t   divided three separate
types form sequence  defined attacks relation  first
last slightly different functional role others  true planets
 types t   t  t   
type t     beef cantelope chocolate flounder guava mutton onion 
pepper rice shrimp sweetroll tuna yogurt 
type t     saturn 
type t     pluto 
type t     neptune 
type t     achievement lubricity 
type t     abrasion anger angina boils depression grief hangover 
laceration 
type t     alsace bosnia guanabara kentucky 
type t     goias 
type t     arizona 

tim  state invariants 
forall x t   forall y   forall z   harmony x y  
harmony x z      y    z 
forall x t    exists y  t  u t  u t   harmony x y   
forall x t   forall y   forall z   locale x y  
locale x z      y    z 
forall x t    exists y  t  u t  u t   locale x y   
forall x t  u t   forall y   forall z   fears x y  

   

fiautomatic inference state invariants

fears x z      y    z 
forall x t  u t   forall y   forall z   craves x y  
craves x z      y    z 
forall x t  u t    exists y  t   craves x y  
exists y  t   fears x y   
forall x t  u t    exists y  t   craves x y  
exists y  t   fears x y   

tim  domain invariants 
   x  x    attacks x  x        
   x  x    eats x  x         
  x   food x         
   x  x    harmony x  x        
   x  x    locale x  x         
   x  x    orbits x  x        
  x   pain x        
  x   planet x        
  x   pleasure x        
  x   province x        

tim  attribute spaces 
objects  x  t  u t  u t  property 
exists y  t   harmony y  x  
objects  x  t  u t  u t  property 
exists y  t   locale y  x  
objects  x  t  property 
exists y  t   fears y  x  
objects  x  t  property 
exists y  t  u t   craves y  x  
objects  x  t  u t  property 
exists y  t  u t   attacks x y   
objects  x  t  u t  property 
exists y  t  u t   attacks y  x  
objects  x  t  property 
exists y  t   eats x y   
objects  x  t  property 
exists y  t   eats y  x  
objects  x  t  property  food x  
objects  x  t  u t  property 
exists y  t  u t   orbits x y   

   

fifox   long

objects  x 
exists y  t  u
objects  x 
objects  x 
objects  x 
objects  x 

t  u t  property 
t   orbits y  x  
t  property  pain x  
t  u t  u t  property  planet x  
t  property  pleasure x  
t  u t  u t  property  province x  

tim  operator parameter restrictions 
succumb x  t  x  t  
feast x  t  x  t  x  t  
overcome x  t  x  t  

tim  additional state invariants  using sub state analysis 

additional invariants show transports always location never
loaded transports 
forall x t   forall y   forall z   craves x y  
craves x z      y    z 
forall x t    exists y  t   craves x y   

c   logistics domain
tim  domain analysis complete logistics strips  prob   pddl 
tim  types 
type t     bos truck la truck pgh truck 
type t     bos po la po pgh po 
type t     bos airport la airport pgh airport 
type t     bos la pgh 
type t     package  package  package  package  package  package  
package  package  
type t     airplane  airplane  

tim  state invariants 
forall x t  u t  u
at x z      y 
forall x t  u t  u
in x z      y 
forall x t  u t  u

t   forall y   forall z   at x y  
  z 
t   forall y   forall z   in x y  
  z 
t    exists y  t  u t   at x y  

   

fiautomatic inference state invariants

exists y  t  u t   in x y   
forall x t  u t  u t    exists y  t  u t   at x y  
exists y  t  u t   in x y   

tim  domain invariants 
  x   airplane x        
  x   airport x        
  x   city x        
   x  x    in city x  x        
  x   location x        
  x   obj x        
  x   truck x        

tim  attribute spaces 
objects  x 
exists y  t  u
objects  x 
exists y  t  u
objects  x 
objects  x 
objects  x 
objects  x 
objects  x 
objects  x 
objects  x 
objects  x 

t 
t 
t 
t 
t 
t 
t 
t 
t 
t 
t 
t 

u t  property 
u t   at y  x  
u t  property 
u t   in y  x  
property  airplane x  
property  airport x  
property  city x  
u t  property  exists y  t   in city x y   
property  exists y  t  u t   in city y  x  
u t  property  location x  
property  obj x  
property  truck x  

tim  operator parameter restrictions 
drive x  t  x  t  u t  x  t 
fly x  t  x  t  x  t  
unload x  t  u t  u t  x  t 
load plane x  t  x  t  x  t 
load truck x  t  x  t  x  t 

u t  x  t  
u t  x  t  u t  
u t  
u t  

tim  additional state invariants  using sub state analysis 

   

fifox   long

following invariants add constraints trucks airplanes must always
location never loaded one another 
forall x t   forall y   forall z   at x y   at x z      y    z 
forall x t    exists y  t  u t   at x y   
forall x t   forall y   forall z   at x y   at x z      y    z 
forall x t    exists y  t  u t   at x y   

appendix d  rocket domain

rocket domain used construction figure   follows 
 define  domain rocket 
  predicates
 at  x  y 
 in  x  y 
 fuelled  x 
 unfuelled  x 
 loc  x 
 obj  x 
 container  x  
  action fly
 parameters   x  y  z 
 precondition  and  at  x  y   loc  z   fuelled  x  
 effect  and  not  at  x  y    at  x  z   unfuelled  x 
 not  fuelled  x    
  action load
 parameters   x  y  z 
 precondition  and  obj  x   container  y   at  x  z 
 at  y  z  
 effect  and  in  x  y   not  at  x  z    
  action unload
 parameters   x  y  z 
 precondition  and  at  y  z   in  x  y  
 effect  and  at  x  z   not  in  x  y     

appendix e  operator test domain

domain artificial domain used test effects increasing operators literals
domain encoding performance tim  example third instance  
variation achieved adding operator schemas pattern included
here 
   

fiautomatic inference state invariants

 define  domain od 
  predicates
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y  
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y   
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y   
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y    

problem instance fixed follows 
 define  problem op 
  domain od 
  objects b c 

   

fifox   long

  init

 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p  b 
 q  c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c 
 p   b 
 q   c  
  goal  and  p  c   q  b    

references

blum  a     furst  m          fast planning plan graph analysis  ijcai 
bundy  a   burstall  r   weir  s     young  r          artificial intelligence  introductory course  edinburgh university press 
fikes  r     nilsson  n          strips  new approach application theoremproving problem solving  artificial intelligence        
gerevini  a     schubert  l       a   accelerating partial order planners  techniques effective search control pruning  jair            
gerevini  a     schubert  l       b   computing parameter domains aid planning 
aips    
gerevini  a     schubert  l          inferring state constraints domain independent
planning  aaai 
grant  t  j          inductive learning knowledge based planning operators  ph d 
thesis  rijksuniversiteit limburg de maastricht 
kautz  h     selman  b          role domain specific knowledge planning
satisfiability framework  fourth international conference artificial
intelligence planning systems 
   

fiautomatic inference state invariants

kelleher  g     cohn  a          automatically synthesising domain constraints
operator descriptions  proceedings ecai   
koehler  j   nebel  b     dimopoulos  y          extending planning graphs adl
subset  proceedings  th european conference planning 
liatsos  v     richards  b          least commitment  optimal planning strategy 
proceedings   th workshop uk planning scheduling special interest
group 
long  d     fox  m   in press   ecient implementation plangraph stan 
jair 
mccluskey  t  l     porteous  j          engineering compiling planning domain
models promote validity eciency  artificial intelligence         
morris  p     feldman  r          automatically derived heuristics planning search 
proceedings  nd irish conference artificial intelligence cognitive
science  school computer applications  dublin city university 

   


