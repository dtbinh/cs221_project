journal of artificial intelligence research              

submitted       published     

the computational complexity of probabilistic planning
michael l  littman

mlittman cs duke edu

department of computer science  duke university
durham  nc            usa

judy goldsmith

goldsmit cs engr uky edu

martin mundhenk

mundhenk ti uni trier de

department of computer science  university of kentucky
lexington  ky            usa
fb    theoretische informatik  universitat trier
d       trier  germany

abstract
we examine the computational complexity of testing and finding small plans in probabilistic planning domains with both at and propositional representations  the complexity
of plan evaluation and existence varies with the plan type sought  we examine totally
ordered plans  acyclic plans  and looping plans  and partially ordered plans under three
natural definitions of plan value  we show that problems of interest are complete for a
variety of complexity classes  pl  p  np  co np  pp  nppp  co nppp  and pspace  in
the process of proving that certain planning problems are complete for nppp  we introduce
a new basic nppp complete problem  e majsat  which generalizes the standard boolean
satisfiability problem to computations involving probabilistic quantities  our results suggest
that the development of good heuristics for e majsat could be important for the creation
of ecient algorithms for a wide variety of problems 

   introduction
recent work in artificial intelligence planning has addressed the problem of finding effective plans in domains in which operators have probabilistic effects  drummond   bresina 
      mansell        draper  hanks    weld        koenig   simmons        goldman  
boddy        kushmerick  hanks    weld        boutilier  dearden    goldszmidt       
dearden   boutilier        kaelbling  littman    cassandra        boutilier  dean   
hanks         here  an  effective  or  successful  plan is one that reaches a goal state
with sucient probability  in probabilistic propositional planning   operators are specified
in a bayes network or an extended strips like notation  and the planner seeks a recipe
for choosing operators to achieve a goal configuration with some user specified probability 
this problem is closely related to that of solving a markov decision process  puterman 
      when it is expressed in a compact representation 
in previous work  goldsmith  lusena    mundhenk        littman      a   we examined the complexity of determining whether an effective plan exists for completely observable
domains  the problem is exp complete in its general form and pspace complete when limited to polynomial depth plans   a polynomial depth  or polynomial horizon  plan is one
that takes at most a polynomial number of actions before terminating   for these results 
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

filittman  goldsmith   mundhenk

plans are permitted to be arbitrarily large objects there is no restriction that a valid plan
need have any sort of compact  polynomial size  representation 
because they place no restrictions on the size of valid plans  these earlier results are not
directly applicable to the problem of finding valid plans  it is possible  for example  that for
a given planning domain  the only valid plans require exponential space  and exponential
time  to write down  knowing whether or not such plans exist is simply not very important
because they are intractable to express 
in the present paper  we consider the complexity of a more practical and realistic
problem that of determining whether or not a plan exists in a given restricted form and of a
given restricted size  the plans we consider take several possible forms that have been used
in previous planning work  totally ordered plans  partially ordered plans   totally ordered 
conditional plans  and  totally order  looping plans  in all cases  we limit our attention to
plans that can be expressed in size bounded by a polynomial in the size of the specification
of the problem  this way  once we determine that a plan exists  we can use this information
to try to write it down in a reasonable amount of time and space 
in the deterministic planning literature  several authors have addressed the computational complexity of determining whether a valid plan exists  of determining whether a plan
exists of a given cost  and of finding the valid plans themselves under a variety of assumptions  chapman        bylander        erol  nau    subrahmanian        backstrom 
      backstrom   nebel         these results provide lower bounds  hardness results  for
analogous probabilistic planning problems since deterministic planning is a special case  in
deterministic planning  optimal plans can be represented by a simple sequence of operators
 a totally ordered plan   in probabilistic planning  a good conditional plan will often perform better than any totally ordered  unconditional  plan  therefore  we need to consider
the complexity of the planning process for a richer set of plan structures 
for ease of discussion  we only explicitly describe the case of planning in completely
observable domains  this means that the state of the world is known at all times during
plan execution  in spite of the uncertainty of state transitions  we know that the state of the
system is sucient information for choosing actions optimally  puterman         however 
representing such a universal plan is often impractical in propositional domains in which
the size of the state space is exponential in the size of the domain representation  for this
reason  we consider other types of plan structures based on simple finite state machines 
because the type of plans we consider do not necessarily use the full state of the system to
make every decision  our results carry over to partially observable domains  although we do
not explore this fact in detail in the present work 
the computational problems we look at are complete for a variety of complexity classes
ranging from pl  probabilistic logspace  to pspace  two results are deserving of special
mention because they concern problems closely related to ones being actively addressed
by artificial intelligence researchers  first  the problem of evaluating a totally ordered plan
in a compactly represented planning domain is pp complete   a compactly represented
   the class pp is closely related to the somewhat more familiar  p  toda        showed that p p   ppp  
roughly speaking  this means that  p and pp are equally powerful when used as oracles  the counting
class  p has already been recognized by the artificial intelligence community as an important complexity
class in computations involving probabilistic quantities  such as belief network inference  roth        

 

ficomplexity of probabilistic planning

planning domain is one that is described by a two stage temporal bayes network  boutilier
et al         or similar notation 
second  the problem of determining whether a valid totally ordered plan exists for a
compactly represented planning domain is nppp  complete  whereas the class np can be
thought of as the set of problems solvable by guessing the answer and checking it in polynomial time  the class nppp can be thought of as the set of problems solvable by guessing the
answer and checking it using a probabilistic polynomial time  pp  computation  it is likely
that nppp characterizes many problems of interest in the area of uncertainty in artificial
intelligence  this paper and earlier work  goldsmith et al         mundhenk  goldsmith   
allender      a  mundhenk  goldsmith  lusena    allender      b  give initial evidence
of this 

    planning domain representations
a probabilistic planning domain m   hs   s    a  t  gi is characterized by a finite set of states
s   an initial state s    s   a finite set of operators or actions a  and a set of goal states
g  s   the application of an action a in a state s results in a probabilistic transition

to a new state s  according to the probability transition function t  where t s  a  s    is the
probability that state s  is reached from state s when action a is taken  the objective is to
choose actions  one after another  to move from the initial state s  to one of the goal states
with probability above some threshold    the state of the system is known at all times
 fully observable  and so can be used to choose the action to apply 
we are concerned with two main representations for planning domains  at representations  which enumerate states explicitly  and propositional representations  sometimes
called compact  structured  or factored representations   which view states as assignments
to a set of boolean state variables or propositions  propositional representations can represent many domains exponentially more compactly than can at representations 
in the at representation  the transition function t is represented by a collection of
jsj  jsj matrices   one for each action  in the propositional representation  this type of
jsj  jsj matrix would be huge  so the transition function must be expressed another way 
in the probabilistic planning literature  two popular representations for propositional planning domains are probabilistic state space operators  psos   kushmerick et al         and
two stage temporal bayes networks   tbns   boutilier et al          although these representations differ in the type of planning domains they can express naturally  boutilier et al  
       they are computationally equivalent  a planning domain expressed in one representation can be converted in polynomial time to an equivalent planning domain expressed in
the other with at most a polynomial increase in representation size  littman      a  
in this work  we focus on a propositional representation called the sequential effectstree representation  st   littman      a   which is a syntactic variant of  tbns with
conditional probability tables represented as trees  boutilier et al                this representation is equivalent to  tbns and psos and simplifies the presentation of our results 
   it is also possible to formulate the objective as one of maximizing expected total discounted reward  boutilier et al          but the two formulations are essentially polynomially equivalent  condon         the only diculty is that compactly represented domains may require discount factors
exponentially close to one for this equivalence to hold  this is discussed further in section   
   we assume that the number of bits used to represent the individual probability values isn t too large 

 

filittman  goldsmith   mundhenk

in st  the effect of each action on each proposition is represented as a separate decision
tree  for a given action a  the set of decision trees for the different propositions is ordered 
so the decision tree for one proposition can refer to both the new and old values of previous propositions  this allows st to represent any probability distribution  the leaves of a
decision tree describe how the associated proposition changes as a function of the state and
action  perhaps probabilistically  section     gives a simple example of this representation 
as in other propositional representations  the states in the set of goal states g are not
explicitly enumerated in st  instead  we define a goal set   which is a set of propositions
such that any state in which all the goal set propositions are true is considered a goal state 
the set of actions a is explicitly enumerated in st  just as it is in the at representation 
the st representation of a planning domain m   hs   s    a  t  gi can be defined more
formally as m   hp  i  a  t  g i  we use blackboard bold font to stand for an st representation on a domain   here  p is a finite set of distinct propositions  the set of states s is
the power set of p  the propositions in s   s are said to be  true  in s  the set i  p is
the initial state  the set g is the goal set  so the set of goal states g is the set of states s
such that g  s 
the transition function t is represented by a function t  which maps each action in
a to an ordered sequence of jpj binary decision trees  each of these decision trees has a
distinct label proposition  decision propositions at the nodes  optionally labeled with the
sux   new    and probabilities at the leaves  the ith decision tree t a i for action a
defines the transition probabilities t s  a  s    as follows  for the ith decision tree  let pi be
its label proposition  define i to be the value of the leaf node found by traversing decision
tree t a i   taking the left branch if the decision proposition is in s  or s  if the decision
proposition has the   new  sux  and the right branch otherwise  finally  we let
y  i 
if pi   s   
 
t s  a  s    
   
    i   otherwise 
i

this definition of t constitutes a well defined probability distribution over s  for each a and
s 
to insure the validity of the representation  we only allow  p new  to appear as a
decision proposition in t a i if p is the label proposition for some decision tree t a j for
j   i  for this reason  the order of the decision trees in t a  is significant  to put this
another way  a proposition only has a new value after this new value has been defined by
some decision tree 
the complexity results we derive for st apply also to psos   tbns  and all other computationally equivalent representations  they also hold for the  succinct representation  
a propositional representation popular in the complexity theory literature  which captures
the set of transition matrices as a function  most commonly represented by a boolean circuit
that computes that function  st can straightforwardly be represented as a boolean circuit 
and  in the proof of theorem    we show how to represent particular boolean circuits in
st  thus  although we have not shown that the succinct representation is formally equivalent to st  the two representations are closely related  the proofs we give for st need to
be changed only slightly to work for the succinct representation  goldsmith  littman   
mundhenk      a      b  mundhenk et al       b   our results require that we restrict
the succinct representation to generate transition probabilities with at most a polynomial
 

ficomplexity of probabilistic planning

number of bits  the results may be different for other circuit based representations that can
represent probabilities with an exponential number of bits  mundhenk et al       a  

    example domain

to help make these domain representation ideas more concrete  we present the following
simple probabilistic planning domain based on the problem of building a sand castle at the
beach  there are a total of four states in the domain  described by combinations of two
boolean propositions  moat and castle  propositions appear in boldface   the proposition
moat signifies that a moat has been dug in the sand  and the proposition castle signifies
that the castle has been built  in the initial state  both moat and castle are false  and the
goal set is fcastleg 
there are two actions  dig moat and erect castle  actions appear in sans serif   figure  
illustrates these actions in st  executing dig moat when moat is false causes moat to
become true with probability      if moat is already true  dig moat leaves it unchanged 
the castle proposition in not affected  the dig moat action is depicted in the left half of
figure   
the second action is erect castle  which appears in the right half of figure    the decision
trees are numbered to allow sequential dependencies between their effects to be expressed 
the first decision tree is for castle  which does not change value if it is already true when
erect castle is executed  otherwise  the probability that it becomes true is dependent on
whether moat is true  the castle is built with probability     if moat is true and only
probability     if it is not  the idea here is that building a moat first protects the castle
from being destroyed prematurely by the ocean waves 
the second decision tree is for the proposition moat  because erect castle cannot make
moat become true  there is no effect when moat is false  on the other hand  if the moat
exists  it may collapse as a result of trying to erect the castle  the label castle new in the
diagram refers to the value of the castle proposition after the first decision tree is evaluated 
if the castle was already built when erect castle was selected  the moat remains built with
probability      if the castle had not been built  but erect castle successfully builds it  moat
remains true  finally  if erect castle fails to make castle true  moat becomes false with
probability     and everything is destroyed 
note that given an st representation of a domain  we can perform a number of useful
operations eciently  first  given a state s and action a  we can generate a next state s  with
the proper probabilities  this is accomplished by calculating the value of the propositions
of s  one at a time in the order given in the representation of a  ipping coins with the
probabilities given in the leaves of the decision trees  second  given a state s  action a 
and state s    we can compute t s  a  s     the probability that state s  is reached from state s
when action a is taken  via equation   

    plan types and representations

we consider four classes of plans for probabilistic domains  totally ordered plans are the
most basic type  being a finite sequence of actions that must be executed in order  this
type of plan ignores the state of the system  acyclic plans generalize totally ordered plans
to include conditional execution of actions  partially ordered plans are a different way of
 

filittman  goldsmith   mundhenk

dig moat
   moat

   castle

moat
t
 t

erect castle
   castle

castle
f

    t

t
 t

   moat

castle
f

t

 t

 t

moat
f

t

moat

f

castle

t

f

    t

    t

    t

 t

f

t

castle  new
t

f

 t

    t

figure    sequential effects tree  st  representation for the sand castle domain
generalizing totally ordered plans in which the precise sequence is left exible  mcallester
  rosenblitt         looping plans generalize acyclic plans to the case in which plan steps
can be repeated  smith   williamson        lin   dean         this type of plan is also
referred to as a plan graph or policy graph  kaelbling et al         
in the following sections  we prove computational complexity results concerning each
of these plan types  the remainder of this section provides formal definitions of the plan
types  illustrated in figure   with examples for the sand castle domain 
in its most general form  a plan  or policy  controller or transducer  is a program that
outputs actions and takes as input information about the outcome of these actions  in this
work  we consider only a particularly restricted finite state controller based plan representation 
a plan p for a planning domain m   hs   s    a  t  gi can be represented by a structure
 v  v    e      consisting of a directed  multi  graph  v  e   with initial node v    v   a
labeling    v   a of plan nodes called plan steps  to domain actions  and a labeling
of edges with state sets    e   p  s   such that for every v   v with outgoing edges 
s
 
v  v   v v   e  v  v     s and  v  v       v  v        for all v    v    v   v     v    some plan
steps have no outgoing edges at all these are the terminal steps   actions for terminal
steps are not executed  note that the function  can be represented in a direct manner for
at domains  but for propositional domains  a more compact representation is needed  we
assume that for propositional domains  edge labels are given as conjunctions of literals 
the behavior of plan p in domain m is as follows  the initial time step is t      at time
step t     the domain is in state st and the plan is at step vt  s  is defined by the planning
domain  v  by the plan   action  vt   is executed  resulting in a transition to domain state
st   with probability t st    vt    st      plan step vt   is chosen so that st      vt   vt     
the function  tells the plan where to  go  next  at this point  the time step index t is
incremented and the process repeats  this continues until a terminal step is reached in the
plan 
one can understand the behavior of domain m under plan p in several different ways 
the possible sequences of states of m can be viewed as a tree  each node of the tree at
depth t is a state reachable from the initial state at time step t  alternatively  one can view
the state of m at time step t under plan p as a probability distribution over s   at time
 

 

 

ficomplexity of probabilistic planning

step    with probability   the process is in state s    the probability that m is in state s 
at time step t      pr s    t       is the sum of the probabilities of all length t     paths from
s  to s   i e  

x

t
y

s   s   s       st st   s j   

t sj   aj   sj     

 

where aj is the action selected by plan p at time j given the observed sequence of state
transitions s            sj   this view is useful in some of the later proofs 
next  we formalize the probability that domain m reaches a goal state under plan p  
we need to introduce several notions  a  legal  sequence of states and steps applied is
called a trajectory   i e   for m and p this is a sequence ff   h si   vi  iki   of pairs with

 t si   vi    si         for    i  k     
 si      vi   vi     for    i  k      and
 v            vk   are not terminal steps 
a goal trajectory is a trajectory that ends in a goal state of m   sk   g   note that
each goal trajectory is finite q thus  we can calculate the probability of a goal trajectory
   t s    v    s    given that s   g   the probability that
ff   h si   vi  iki   as pr ff    ki  
i
i i  
k
m reaches a goal state under plan p is the sum of the probabilities of goal trajectories for
m 
x
pr m reaches a goal state under p     
pr ff  
ff goal trajectory

we call this the value of the plan 
we characterize a plan p    v  v    e      on the basis of the size and structure of its
underlying graph  v  e    if the graph  v  e   contains no cycles  we call it an acyclic plan  
otherwise it is a looping plan   it follows that an acyclic plan has a terminal step  and that
a terminal step will be reached after no more than jv j actions are taken  such plans can
only be used for finite horizon control  a totally ordered plan  sometimes called a  linear
plan  or a  straight line  plan  is an acyclic plan with no more than one outgoing edge for
each node in v   such a plan is a simple path 
in this work  we also consider partially ordered plans  sometimes called  nonlinear 
plans  that express an entire family of totally ordered plans  in this representation  the steps
of the plan are given as a partial order  specified  for example  as a directed acyclic graph  
this partial order represents a set of totally ordered plans  all totally ordered sequences of
plan steps consistent with the partial order that consist of all steps of the partially ordered
plan  each of these totally ordered plans has a value  and these values need not all be the
same  as such  we have a choice in defining the value for a partially ordered plan  in this
work  we consider the optimistic  pessimistic  and average interpretations  let 
 p   be the
set of totally ordered sequences consistent with partial order plan p   under the optimistic
interpretation 
the value of p    max pr m reaches a goal state under p  
p 
 p  

 

filittman  goldsmith   mundhenk

under the pessimistic interpretation 
the value of p    min pr m reaches a goal state under p  
p 
 p  

under the average interpretation 
x
pr m reaches a goal state under p  
the value of p    j
  p  j
p 
 p  
to illustrate these notions  figure   gives plans of each type for the sand castle domain
described earlier  initial nodes are marked an incoming arrow  and terminal steps are
represented as filled circles  the   step totally ordered plan in figure   a  successfully
builds a sand castle with probability         an acyclic plan is given in figure   b   which
succeeds with probability         and executes dig moat an average of      times  note
that it succeeds more often and with fewer actions on average than the totally ordered plan
in figure   a  
figure   c  illustrates a partially ordered plan for the sand castle domain  while this
plan bears a superficial resemblance to the acyclic plan in figure   b   it has a different
interpretation  in particular  the plan in figure   c  represents a set of totally ordered plans
with five  non terminal  plan steps    dig moat steps and   erect castle steps   in contrast
to the solid arrows in figure   b   which indicate ow of control  the dashed arrows in
figure   c  represent ordering constraints  each erect castle step must be preceded by at
least two dig moat steps for example 
although there are         distinct ways of arranging the five plan steps in figure   c  into a totally ordered plan  only two distinct totally ordered plans are consistent
with the ordering constraints 
dig moat   dig moat   dig moat   erect castle   erect castle   

 success probability          and

dig moat   dig moat   erect castle   dig moat   erect castle   

 success probability            thus  the optimistic success probability of this partially
ordered plan is           the pessimistic          note that the pessimistic interpretation is closely related to the standard interpretation in deterministic partial order planning  mcallester   rosenblitt         in which a partially ordered plan is considered successful only if all its consistent totally ordered plans are successful  the average success
probability is            here  because there are   orderings that yield the poorer plan
described above  and   that yield the better one 
the looping plan in figure   d  does not terminate until it succeeds in building a sand
castle  which it will do with probability     eventually  of course  not all looping plans
succeed with probability    the totally ordered plan in figure   a  and the acyclic plan in
figure   b  are special cases of such looping plans  for instance 
we define jp j the size of a plan p to be the number of steps it contains  we define jm j
the size of a domain m to be the sum of the number of actions and states for a at domain
and the sum of the sizes of the st decision trees for a propositional domain 
 

ficomplexity of probabilistic planning

dig moat

dig moat

erect castle

dig moat

erect castle

dig moat

erect castle

dig moat

 a  a totally ordered plan 

 c  a partially ordered plan 
not moat 
dig moat

not moat 
dig moat

moat

dig moat

erect castle

not moat 

moat and not castle 

moat

moat
dig moat

castle
erect castle

 b  an acyclic  conditional  plan 
not moat  and not castle 
 d  a looping plan 

figure    example plans for the sand castle domain
we consider the following decision problems  the plan evaluation problem asks  given
a domain m   a plan p of size jp j  jm j  and threshold   whether its value is greater than
  i e   whether
pr m reaches a goal state under p      
note that the condition that jp j  jm j is just a technical one we simply want to use jm j
to represent the size of the problem  given an instance in which jp j is larger than jm j  we
simply imagine  padding out  jm j to make it larger  the important thing is that we are
considering plans that are roughly the size of the description of the domain  and not the
size of the number of states  which might be considerably larger  
the plan existence problem asks  given domain m   threshold   and size bound z  jm j 
whether there exists a plan p of size z with value greater than   note that because we
bound the size of the target plan  the complexity of plan generation is no more than that of
plan existence  the technique of self reduction can be used to construct a valid plan using
polynomially many calls to an oracle for the decision problem 
each of these decision problems has a different version for each type of domain  at
and propositional  and each type of plan category  looping  acyclic  totally ordered  and
partially ordered under each of the three interpretations   we address all of these problems
in the succeeding sections 

    complexity classes

for definitions of complexity classes  reductions  and standard results from complexity
theory  we refer the reader to papadimitriou        
briey  we are looking only at the complexity of decision problems  those with yes no
answers   the class p consists of problems that can be decided in polynomial time  that is 
given an instance of the problem  there is a program for deciding whether the answer is yes
or no that runs in polynomial time  the class np contains the problems with polynomialtime checkable polynomial size certificates  for any given instance and certificate  it can be
checked in time polynomial in the size of the instance whether the certificate proves that
the instance is in the np set  this means that  if the answer to the instance is  yes   this
 

filittman  goldsmith   mundhenk

can be shown in polynomial time given the right key  the class co np is the opposite if
the answer is  no   this can be shown in polynomial time given the right key 
a problem x is c  hard for some complexity class c if every problem in c can be reduced
to it  to put it another way  a fast algorithm for x can be used as a subroutine to solve any
problem in c quickly  a problem is c  complete if it is both c  hard and in c   these are the
hardest problems in the class 
in the interest of being complete  we next give more detailed descriptions of the less
familiar probabilistic and counting complexity classes we use in this work 
the class  l  a lvarez   jenner        is the class of functions f such that  for some
nondeterministic logarithmically space bounded machine n   the number of accepting paths
of n on x equals f  x   the class  p is defined analogously as the class of functions f
such that  for some nondeterministic polynomial time  bounded machine n   the number of
accepting paths of n on x equals f  x   typical complete problems are computing the
determinant for  l and computing the permanent for  p 
a function f is defined to be in gapl if it is the difference f   g   h of  l functions g
and h  while  l functions have nonnegative integer values by definition  gapl functions
may have negative integer values  for example  if g always returns zero  
probabilistic logspace  gill         pl  is the class of sets a for which there exists a
nondeterministic logarithmically space bounded machine n such that x   a if and only if
the number of accepting paths of n on x is greater than its number of rejecting paths  in
the original definition of pl  there is no time bound on computations  borodin  cook  and
pippenger        later showed pl  p  jung        proved that any set computable in
probabilistic logspace is computable in probabilistic logspace where the pl machine has a
simultaneous polynomial time bound  in apparent contrast to p complete sets  sets in pl
are decidable using very fast parallel computations  borodin et al         
probabilistic polynomial time  pp  is defined analogously  a classic pp complete problem is majsat  given a boolean formula in conjunctive normal form  cnf   does the
majority of assignments satisfy it  according to balcazar  daz  and gabarro         the
pp completeness of majsat was shown in a combination of results from gill        and
simon        
for polynomial space bounded computations  pspace equals probabilistic pspace 
and  pspace is the same as the class of polynomial space computable functions  ladner 
      
note that l  nl   l  pl and gapl are to logarithmic space what p  np   p  pp  and
gapp are to polynomial time  also  the notion of completeness we use in this paper relies
on many one reductions  in the case of pl  the reduction functions are logarithmic space 
in the case of np and above  they are polynomial time 
for any complexity classes c and c   the class c c consists of those sets that are c  turing
reducible to sets in c     i e   sets that can be accepted with resource bounds specified by c  
using some problem in c   as a subroutine  oracle  with instantaneous output  for any class
c  pspace  it is the case that npc  pspace  and therefore nppspace   pspace 
the primary oracle defined class we consider is nppp   it equals the  np
m   closure of
pp  toran         which can be seen as the closure of pp under polynomial time disjunctive reducibility with an exponential number of queries  each of the queries computable in
polynomial time from its index in the list of queries   to simplify our completeness results
 

  

ficomplexity of probabilistic planning

for this class  we introduce a decision problem we call e majsat   exists  majsat   which
generalizes the standard np complete satisfiability problem and the pp complete majsat 
an e majsat instance is defined by a cnf boolean formula  on n boolean variables
x            xn and a number k between   and n  the task is to decide whether there is an
initial partial assignment to variables x            xk so that the majority of assignments that
extend that partial assignment satisfies   we prove that this problem is nppp  complete
in the appendix 
the complexity classes we consider satisfy the following containment properties and
relations to other well known classes 
np  pp  nppp  pspace  exp 
l  nl  pl  p  co np
co nppp
because p is properly contained in exp  exp complete problems are provably intractable 
the other classes may equal p  although that is not generally believed to be the case 
several other observations are worth making here  it is also known that ph  nppp  
where ph represents the polynomial hierarchy  in a crude sense  ph is close to pspace 
and  thus  our nppp  completeness results place important problems close to pspace 
however  some early empirical results  littman      b  show that random problem instances from pp have similar properties to random problem instances from np  suggesting
that pp might be close enough to np for np type heuristics to be effective 

    results summary

tables   and   summarize our results  which are explained in more detail in later sections 
the general avor of our main results and techniques can be conveyed as follows  to
show that a plan evaluation problem is in a particular complexity class c   we take the
cross product of the steps of the plan and the states of the domain and then look at the
complexity of evaluating the absorption probability of the resulting markov chain  i e   the
directed graph with probability labeled edges   the complexity of the corresponding planexistence problem is then bounded by npc   because the problem can be solved by guessing
the correct plan non deterministically and then evaluating it  in many cases  it is npc complete  the appropriate complexity class c depends primarily on the representation of
the cross product markov chain 
exceptions to this basic pattern are the results for partially ordered plans in section   
these appear to require a distinct set of techniques 
it is also worth noting that  although propositional domains can be exponentially more
compact than at domains  the computational complexity of solving problems in propositional domains is not always exponentially greater  in one instance  evaluating partially
ordered plans under the average interpretation  the complexity is actually the same for at
and propositional domains 
we also prove results concerning plan evaluation and existence for compactly represented
plans  pp complete and nppp  complete  corollary     plan existence of  large enough 
looping plans in at domains  p complete  theorem     plan evaluation and existence
for looping plans in deterministic propositional domains  pspace complete  theorems  
and     and plan existence for polynomial size looping plans in partially observable domains
 np complete  section      
  

filittman  goldsmith   mundhenk

plan type
plan evaluation plan existence
unrestricted
 
p complete
polynomial depth
 
p complete
looping
pl complete
np complete
acyclic
pl complete
np complete
totally ordered
pl complete
np complete
partially ordered  optimistic
np complete
np complete
partially ordered  average
pp complete
np complete
partially ordered  pessimistic co np complete
np complete

reference
p   t       
p   t       
section  
section  
section  
section  
section  
section  

table    complexity results for at representations  p   t        is papadimitriou and
tsitsiklis        

plan type
plan evaluation plan existence reference
unrestricted
 
exp complete littman      a 
polynomial depth
 
pspace complete littman      a 
looping
pspace complete pspace complete section  
acyclic
pp complete
nppp  complete section  
totally ordered
pp complete
nppp  complete section  
pp
partially ordered  optimistic
np  complete
nppp  complete section  
partially ordered  average
pp complete
nppp  complete section  
pp
partially ordered  pessimistic co np  complete nppp  complete section  
table    complexity results for propositional representations

  

ficomplexity of probabilistic planning

   acyclic plans

in this section  we treat the complexity of generating and evaluating acyclic and totally
ordered plans 

theorem   the plan evaluation problem for acyclic and totally ordered plans in at domains is pl complete 

proof  first  we show pl hardness for totally ordered plans  jung        proved that a
set a is in pl if and only if there exists a logarithmically space bounded and polynomially
time bounded nondeterministic turing machine n with the following property  for every
input x  machine n must have at least half of its computations on input x be accepting
if and only if x is in a  the machine n can be transformed into a probabilistic turing
machine r such that for each input x  the probability that r x  accepts x equals the
fraction of computations of n  x  that accepted  given r  a planning domain m can be
described as follows  the state set of m is the set of configurations of r on input x  note
that a configuration consists of the contents of the logarithmically space bounded tape  the
state  the location of the read write heads  and one symbol each from the input and output
tapes  thus  a configuration can be represented with logarithmically many bits  and there
are only polynomially many such configurations  the state transition probabilities of m
under the unique action a are the configuration transition probabilities of r  all states
obtained from accepting configurations are goal states  the totally ordered plan consists
of a  step counter  for r on input x  and each of its plan steps takes the only action a 
the probability that the planning domain under this plan reaches a goal state is exactly
the probability that r x  reaches an accepting configuration  thus  evaluating this totally
ordered plan is pl hard 
since totally ordered plans are acyclic plans  this also proves pl hardness of the planevaluation problem for acyclic plans 
next  we show that the plan evaluation problem is in pl for acyclic plans  let m  
hs   s    a  t  gi be a planning domain  let p   hv  v    e    i be an acyclic plan  and let
threshold  be given  we show how our question  whether the probability that m under p
reaches a goal state with probability greater than   can be equivalently transformed into
the question of whether a gapl function is greater than    the transformation can be done
in logarithmic space  as shown by allender and ogihara         it follows that our question
is in pl 
at first  we construct a markov chain c from m and p   which simulates the execution
or  evaluation  of m under p   note that a markov chain can be seen as a probabilistic
domain with only one action in its set of actions  since there is no choice of actions  we do
not mention them in this construction  the state space of c is s  v   the initial state is
 s    v     the set of goal states is g  v   and the transition probabilities tc for c are
 
t s   v   s     if s     v  v    
 
tc   s  v    s    v           
if v is a terminal step node  and  s  v     s    v    
  
otherwise 
let m be the number of plan steps of p  i e   jv j  the number of nodes in the graph
representing p    since states of c that contain a terminal step of p are sinks in c   it follows
  

filittman  goldsmith   mundhenk

that
pr m reaches a goal state under p     pr c reaches a goal state in exactly m steps  
let
pc  s  m     pr c reaches a goal state in exactly m steps from initial state s  
then  pc   s    v     m  is the probability we want to calculate  the standard inductive definition of pc used to evaluate plans by dynamic programming is

s is a goal state of c  
pc  s            ifotherwise 
x
pc  s  k       
tc  s  s    pc  s    k      k  m     
s  sv
 

let h be the maximum length of the representation of a state transition probability tc  
then  for

if s is a goal state of c  
ph  s            otherwise 
x h
ph s  k       
   tc  s  s     ph  s    k      k  m     
s  sv
 

it follows that pc   s    v     m    ph  s    v     m     hm   note that ph  s    v     m  is an integer
value  therefore  pc   s    v     m     if and only if ph   s    v     m    b hm c      in order
to show that pc   s    v     m     is decidable in pl  it suces to show that ph  s    v     m 
is in gapl  therefore  we  unwind  the inductive definition of ph  let t be the integer
matrix obtained from tc with t s s     tc  s  s      h   we introduce the integer valued t to
show that ph can be composed from gapl functions using compositions under which gapl
is closed  as tc is not integer valued  it cannot be used to show this  we can write
 

ph s  m   

x

s  sv

 t m   s s    ph s       
 

 

we argue that ph is in gapl  each entry t s s   is logspace computable from the domain m and plan p   therefore  the powers of the matrix are in gapl  as shown by
vinay         because gapl is closed under multiplication and summation of polynomially
many summands  it follows that ph   gapl  finally  we use closure properties of gapl
from allender and ogihara         since gapl is closed under subtraction  it follows that
the plan evaluation for acyclic plans is in pl 
because totally ordered plans are acyclic plans  the plan evaluation problem for totally
ordered plans is also in pl 
 

the technique of forming a markov chain by taking the cross product of a domain and
a plan will be useful later  plan existence problems require a different set of techniques 

theorem   the plan existence problem for acyclic and totally ordered plans in at domains is np complete 

  

ficomplexity of probabilistic planning

proof  first  we show containment in np  given a planning domain m   a threshold  
and a size bound z  jm j  guess a plan of the correct form of size at most z and accept if

and only if m reaches a goal state with probability greater than  under this plan  note that
checking whether a plan has the correct form can be done in polynomial time  because the
plan evaluation problem is in pl  theorem     it follows that the plan existence problem
is in np  i e   it is in nppl   np  
to show the np hardness of the plan existence problem  we give a reduction from the
np complete satisfiability problem for boolean formulae in conjunctive normal form  we
construct a planning domain that evaluates a boolean formula with n variables  where a
 n      step plan describes an assignment of values to the variables  in the first step  a
clause is chosen randomly  at step i      the planning domain  checks  whether the plan
satisfies the appearance of variable i in that clause  if so  the clause is marked as satisfied 
after n     steps  if no literal was satisfied in that clause  then no goal state is reached
through this clause  otherwise  a transition is made to the goal state  therefore  the goal
state will be reached with probability    greater than       m  if and only if all clauses are
satisfied the plan describes a satisfying assignment 
we formally define the reduction  which is similar to one presented by papadimitriou
and tsitsiklis         let  be a cnf formula with n variables x            xn and m clauses
c            cm   let the sign of an appearance of a variable in a clause be    if the variable is
negated  and   otherwise  define the planning domain m      hs   s    a  t  gi where

s
a
g

  fsat i  j    unsat i  j   j    i  n         j  mg   fs    sacc   srejg 
  fassign i  b  j    i  n  b   f     gg   fstart  endg 
  fsacc g 
   
 
 
m   if s   s    a   start  s    unsat    j       j  m 
 
 
 
   if s   s    a    start  s   srej 
 
 
 
 
 
   if s   unsat i  j    a   assign i  b   s    sat i      j    i  n 
 
 
 
 
xi appears in cj with sign b 
 
 
 
 
 
 
if
s
  unsat i  j    a   assign i  b   s    unsat i      j    i  n 
 
 
 
 
xi does not appear in cj with sign b 
 
 
 
 
 
 
if
s
  unsat i  j    a   assign i    b  or a   start or a   end 
 
 
 
 
srej  i     i  n  b   f     g 
t s  a  s          if ss  
  unsat n      j    s    srej 
 
 
 
 
   if s   sat i  j    a   assign i  b   s    sat i      j    i  n 
 
 
 
 
   if s   sat i  j    a   assign i    b  or a   start or a   end 
 
 
 
 
s    srej  i     i  n 
 
 
 
 
   if s   sat n      j    a   end  s    sacc  
 
 
 
 
   if s   sat n      j    a    end  s    srej 
 
 
 
 
s   s    srej or s   s    sacc  
 
 
       ifotherwise 
the meaning of the states in this domain is as follows  when the domain is in state
sat i  j   for    i  n     j  m  it means the formula has been satisfied  and we are
currently checking variable i in clause j   state sat n      j   for all    j  m means that
we ve finished verifying clause j and it was satisfied  the meanings are similar for the
  

filittman  goldsmith   mundhenk

s 

start

   

unsat      

assign      

assign   

sat      

assign    x 

   

   

start

assign   

   

sat      

assign      

sat      

assign    x 

sat      

unsat      

end

end

sacc

unsat      

assign    x 

unsat      

assign    x 

assign      

sat      

unsat      

assign   

unsat      

   

unsat      

assign      
sat      

end

assign   

   

unsat      

end

srej

figure    a domain generated from the boolean formula  x     x        x    x   
 unsat  states  of course  s  is the initial state and sacc and srej are the accepting and
rejecting states  respectively 
the actions in this domain are start and end  which mark the beginning and end of the
assignment  and assign i  b  for    i  n  b   f     g  which assign the truth value b to
variable i  figure   gives the domain generated by this reduction from a simple boolean
formula  by the description of the reduction  m    can be computed from  in time
polynomial in jj 
by construction  m    under z    n      step plan p can only reach goal state sacc if
p has the form
start   assign    b      assign    b           assign n  bn     end    
p reaches sacc with probability   if and only if b            bn is a satisfying assignment for the
n variables in   this shows that boolean satisfiability polynomial time reduces to the
plan existence problem for totally ordered and acyclic plans  showing that it is np hard 
note that if we bound the plan depth  horizon  instead of the plan size  the planexistence problem for acyclic plans in at domains is p complete  goldsmith et al       a 
papadimitriou   tsitsiklis         limiting the plan size makes the problem more dicult
because it is possible to force the planner to take the same action from different states 
figuring out how to do this without sacrificing plan quality is very challenging 
in propositional domains  plan evaluation is harder because of the large number of states 

theorem   the plan evaluation problem for acyclic and totally ordered plans in propositional domains is pp complete 

proof  to show pp hardness for totally ordered plans  we give a reduction from the

pp complete problem majsat  given a cnf boolean formula   does the majority of
assignments satisfy it 
  

ficomplexity of probabilistic planning

evaluate
   xi
   

   xi

t

   

t

n    clause 
xa  new
t

f

xb  new

 t

t
 

t

t
 

t

t
 

t

 t

xbm new

clause  new

t

t

xcm new
t

 t

 

f

f

 t

 t

n m    done

done
t

f

t

f

n m    satisfied

xam new

   

xc  new

xd  new

    t

n m  clausem

f

t

n  xi

   

t

f
 

f

clause  new
   

t

 t

f
 

t

clausem new

f

t

 t

 

f
t

 t

figure    sequential effects tree representation for evaluate
given   we construct a planning domain m    and a   step plan such that the plan
achieves the goal with probability greater than        if and only if the majority of
assignments satisfies   the planning domain m    consists of a single action evaluate 
which is also the   step plan to be evaluated  there are n   m     propositions in m    
x  through xn  which correspond to the n variables of   clause  through clausem   which
correspond to the m clauses of   satisfied  which is also the sole element of the goal set 
and done  which insures that evaluate is only executed once  this is important when this
domain is used later in theorem   to show the complexity of plan existence   in the initial
state  all propositions are false 
the evaluate action generates a random assignment to the variables of   evaluates the
clauses  clausei is true if any of the literals in the ith clause is true   and evaluates the entire
formula  satisfied is true if all the clauses are true   figure   gives an st representation
of evaluate  in which xa   xb         represent the variables in clause i 
by construction   is in majsat if and only if m    reaches a goal state with probability
greater than        under the plan consisting of the single action evaluate 
we next show membership in pp for acyclic plans  we do this by showing that a
planning domain m and an acyclic plan p induce a computation tree consisting of all
paths through m under p   evaluating this computation tree can be accomplished by a pp
machine 
let b be a bound on the number of bits used to specify probabilities in the leaves of the
decision trees representing m    consider a computation tree defined as follows  it has root
labeled hs    v  i  if  in the planning domain m   the probability of reaching state s  from s
i

i

   we represent numbers in polynomial precision binary representation  in principle  this could introduce
round off errors if planning problems are specified in some other form 

  

filittman  goldsmith   mundhenk

given action  v  is equal to    then hs   v i will have    b children labeled hs     v  s   i 
each of the identically labeled child nodes is independent but is defined identically to the
others  thus  the number of paths with a given set of labels corresponds to the probability
of that trajectory through the domain and plan multiplied by   b  h   where h is the depth
of the plan 
the number of accepting computations is  therefore  more than     b  h if and only if
the probability of achieving the goal is more than   note that b is inherent in the planning
domain  rather than in h  a pp machine accepts if more than half of the final states are
accepting  so if          it will be necessary to pad the computation tree by introducing
 dummy  branches that accept or reject in the right proportions 
the plan existence problem is essentially equivalent to guessing and evaluating a valid
plan 

theorem   the plan existence problem for acyclic and totally ordered plans in propositional domains is nppp  complete 

proof  containment in nppp for both totally ordered and for acyclic plans follows from

the fact that a polynomial size plan can be guessed in polynomial time and checked in pp
 theorem    
hardness for nppp for both totally ordered and acyclic plans can be shown using a
reduction from e majsat  shown nppp  hard in the appendix  the reduction echoes the
one used in the pp hardness argument in the proof of theorem   
given a cnf boolean formula  with variables x            xn   and a number k  we construct
a planning domain m    k  such that a plan exists that can reach the goal with probability
greater than        if and only if there is an assignment to the variables x            xk such
that the majority of assignments to the remaining variables satisfies   the planning domain
m    k   consists of the action evaluate from theorem   and one action  set xi   for each of
the first k variables  just as in the proof of theorem    there are n   m     propositions in
m    k    all initially false  x  through xn   which correspond to the n variables of   clause 
through clausem   which correspond to the m clauses of   satisfied  and done  which
insures that evaluate is only executed once  the goal set contains satisfied and done 
for    i  k  action set xi makes proposition xi true  analogously to theorem    the
evaluate action generates a random assignment to the remaining variables of   evaluates
the clauses  clausei is true if any of the literals in the clause is true   and evaluates the
entire formula  satisfied is true if all the clauses are true   and sets done to true  if done
is true  no further action can make satisfied true 
if the pair   k is in e majsat  then there exists an assignment b        bk to the first k
variables of  such that the majority of assignments to the rest of the variables satisfies  
therefore  the plan applying steps set xi for all i with bi     followed by an evaluate action
reaches a goal state with probability greater than        
conversely  assume m    k  under totally ordered plan p reaches a goal state with
probability greater than      since the evaluate action is the only action setting done to
true  and since no action reaches the goal once done is set to true  we can assume without
loss of generality that p consists of a sequence of steps set xi that ends with evaluate  by
construction  the assignment to x            xk assigning   exactly to those variables set by p
  

ficomplexity of probabilistic planning

is an assignment under which the majority of the assignments to the rest of the variables
satisfies   and therefore   k is in e majsat 
since every totally ordered plan is acyclic  the same hardness holds for acyclic plans 
in the above results  we consider both at and compactly represented  propositional 
planning domains but only at plans  compactly represented plans are also quite useful 
a compact acyclic plan is an acyclic plan in which the names of the plan steps
are encoded by a set of propositional variables and the step transition function
 between plan steps is represented by a set of decision trees  just as in st  we
require that the plan has depth polynomial in the size of the representation 
even though the total number of steps in the plan might be exponential due to
the logarithmic succinctness of the encodings 
because the plan domain cross product technique used in the proof of theorem   generalizes to compact acyclic plans  the same complexity results apply  this also holds true
for a probabilistic acyclic plan   which is an acyclic plan that can make random transitions
between plan steps  i e   the step transition function  is stochastic   these insights can be
combined to yield the following corollary of theorems   and   

corollary   the plan evaluation problem for compact probabilistic acyclic plans in propositional domains is pp complete and the plan existence problem for compact probabilistic
acyclic plans in propositional domains is nppp  complete 

we mention probabilistic plans here for two reasons  first  the behavior of some planning structures  such as partially ordered plan evaluation under the average interpretation 
discussed in section    can be thought of as generating probabilistic plans  second  there
are many instances in which simple probabilistic plans perform nearly as well as much larger
and more complicated deterministic plans  this notion is often exploited in the field of randomized algorithms  work by platzman         described by lovejoy        shows how the
idea of randomized plans can come in handy for planning in partially observable domains 

   looping plans

looping plans can be applied to infinite horizon control  the complexity of plan existence
and plan evaluation in at domains  theorems   and    does not depend on the presence
or absence of loops in the plan 

theorem   the plan evaluation problem for looping plans in at domains is pl complete 
proof  given a domain m and a looping plan p   we can construct a product markov

chain c as in the proof of theorem    as in the proof of theorem   of allender and
ogihara         this chain can be constructed such that it has exactly one accepting and
exactly one rejecting state  both of these states are absorbing  the probability that m
reaches a goal state under p equals the probability that c reaches its accepting state if
started in its initial state  which is the product of the initial states of m and p   in the
  

filittman  goldsmith   mundhenk

proof of theorem   of allender and ogihara         it is shown that the construction of
the markov chain and the computation of whether it reaches its final state with probability
greater than  can be performed in pl 
pl hardness is implied by theorem    since acyclic plans are a special case of looping
plans 

theorem   the plan existence problem for looping plans in at domains is np complete

in general  but p complete if the size of the desired plan is at least the size of the state or
action space  i e   z  min jsj  jaj   

proof sketch  np completeness follows from the proof of theorem    containment and

hardness still hold if plans are permitted to be looping 
however  this is only true if we are forced to specify a plan whose size is small with
respect to the size of the domain  if our looping plan is allowed to have a number of states
that is at least as large as the number of states or actions in the domain  the problem can
be solved in polynomial time 
it is known that for markov decision processes such as these the maximum probability
of reaching a goal state equals the maximum probability of reaching a goal state under
any infinite horizon stationary policy   where a stationary policy is a mapping from states
to actions that is used repeatedly to choose actions at each time step  it is known that
such an optimal stationary policy can be computed in polynomial time via linear programming  condon         any stationary policy for a domain m   hs   s    a  g   ti can be
written as a looping plan  although  of course  not all looping plans correspond to stationary
policies 
we show that for any fixed stationary policy p   s   a  there are two simple ways a
looping plan p    v  v    e      can be represented  first  let v   a  v    p s      v    v 
and  v  v      fs   s j p s    v  g  it follows that whenever m reaches state s  then the
action applied according to the looping plan is the same as according to p  
second  let v   s   v    s     v    p v   and  v  v      fv  g  it follows that whenever
m reaches state s  the plan will be at the node corresponding to that state and  therefore 
the appropriate action for that state will be applied by the looping plan  therefore  the
maximum probability of reaching a goal state can be obtained by either of these looping
plans 
since the best stationary policy can be computed in polynomial time  the best looping
plan can be computed in polynomial time  too  p hardness follows from a theorem of
papadimitriou and tsitsiklis        
in propositional domains  the complexity of plan existence and plan evaluation of looping
plans is quite different from the acyclic case  looping plan evaluation is very hard 

theorem   the plan evaluation problem for looping plans in both deterministic and stochastic propositional domains is pspace complete 

proof  recall that the plan evaluation problem for at domains is in pl  theorem    

for a planning domain with cn states and a representation of size n  a looping plan can
  

ficomplexity of probabilistic planning

be evaluated in probabilistic space o log cn     theorem     which is to say probabilistic
space polynomial in the size of the input  this follows because the st representation of
the domain can be used to compute entries of the transition function t in polynomial space 
since probabilistic pspace equals pspace  this shows that the plan evaluation problem
for looping plans in stochastic propositional domains is in pspace 
it remains to show pspace hardness for deterministic propositional domains  let n
be a deterministic polynomial space bounded turing machine  the moment to moment
computation state  configuration  of n can be expressed as a polynomial length bit string
that encodes the contents of the turing machine s tape  the location of the read write head 
the state of n  s finite state controller  and whether or not the machine is in an accepting
state 
for any input x  we describe how to construct in polynomial time a deterministic planning domain m  x  and a single action looping plan that reaches a goal state of m  x  if and
only x is accepted by turing machine n  
given a description of n and x  one can  in time polynomial in the size of the descriptions
of n and x  produce a description of a turing machine t that computes the transition
function for n   in other words  t on input c  a configuration of n   outputs the next
configuration of n    in fact  t can even check whether c is a valid configuration in the
computation of n  x  by simulating that computation   by an argument similar to that
used in cook s theorem  t can be modeled by a polynomial size circuit  this circuit takes
as input the bit string describing the current configuration of n and outputs the next
configuration 
next  we argue that the computation of this circuit can be expressed by an action compute in st representation  there is one proposition in m  x  for each bit in the configuration 
plus one for each gate of the circuit  the three standard gates   and    or   and  not  are
all easily represented as decision trees  by ordering the decision trees in compute according to a topological sort of the gates of the circuit  a single compute action can compute
precisely the same output as the circuit  figure   illustrates this conversion for a simple
circuit  which gives the form of the  not   i      and   i     and  or   i    gates 
we can now describe the complete reduction  the planning domain m  x  consists of
the single action compute and the set of propositions described in the previous paragraph 
the initial state is the initial configuration of the turing machine n   and the goal set is the
proposition corresponding to whether or not the configuration is an accepting state for n  
because all transitions are deterministic and only one action can be chosen  it follows
that the goal state is reached with probability    greater than      for example  under
the plan that repeatedly chooses compute until an accepting state is reached if and only if
polynomial space machine n on input x accepts 
a similar argument shows that looping plan existence is not actually any harder than
looping plan evaluation 

theorem   the plan existence problem for looping plans in both deterministic and stochastic propositional domains is pspace complete 
  

filittman  goldsmith   mundhenk

compute
   i 

   i 

c 
c 

c 

not
i 

or
i 
and

c 

not

t

i 

c 

f

c 

 t

 t

 t

t

f

c 

 t

f

t

 t

f

 t

 t

or

   c 
c 

t

t
and

c 

i  new
f

 t

   i 

   c 
i  new

c 

c 
t

f

i  new
t
 t

   c 

 t

t
 t

f
 t

i  new
t

f

i  new

 t

t

f
 t

 t

f
 t

figure    a circuit and its representation as a sequential effects tree

proof  hardness for pspace follows from the same construction as in the proof of

theorem    either the one step looping plan is successful  or it is not  no other plan yields
a better result 
recall that we are only interested in determining whether there is a plan of size z   where
z is bounded by the size of the domain  that reaches the goal with a given probability  the
problem is in pspace because the plan can be guessed in polynomial time and checked in
pspace  theorem     because nppspace   pspace  the result follows 
as we mentioned earlier  the unrestricted infinite horizon plan existence problem is
exp complete  littman      a   this shows the problem of determining unrestricted plan
existence is exp hard only because some domains require plans that are larger than polynomialsize looping plans 
because theorem   shows pspace completeness for determining plan existence in deterministic domains  it is closely related to the pspace completeness result of bylander         the main difference between the two results is that our theorem applies to
more compact plans  polynomial instead of exponential  with more complex operator descriptions  conditional effects instead of preconditions with add and delete lists  that can
include loops  also  as the proofs above show  pspace hardness is retained even in planning domains with only one action  so it is the looping that makes looping plans hard to
work with 

   partially ordered plans
partially ordered plans are a popular representation because they allow planning algorithms
to defer a precise commitment to the ordering of plan steps until it becomes necessary in
  

ficomplexity of probabilistic planning

the planning process  a k step partially ordered plan corresponds to a set of k step totally
ordered plans all those that are consistent with the given partial order  the evaluation of
a partially ordered plan can be defined to be the evaluation of the best  worst  or average
member of the set of consistent totally ordered plans  these are the optimistic  pessimistic 
and average interpretations  respectively 
the plan evaluation problem for partially ordered plans is different from that of totally
ordered plans  this is because a single partial order can encode all totally ordered plans 
hence  evaluating a partially ordered plan involves figuring out the best  in case of optimistic
interpretation  or the worst  for pessimistic interpretation  member  or the average  for
average interpretation  of this combinatorial set 

theorem    the plan evaluation problem for partially ordered plans in at domains is
np complete under the optimistic interpretation 
proof sketch  membership in np follows from the fact that we can guess any totally

ordered plan consistent with the given partial order and accept if and only if the domain
reaches a goal state with probability more than   remember that this evaluation can be
performed in pl  theorem     and therefore deterministically in polynomial time 
the hardness proof is a variation of the construction used in theorem    the partiallyordered plan to evaluate has the form given in figure    the consistent total orders are of
the form
start   assign    b      assign     b      assign    b      assign     b     

     assign n  bn    assign n   bn    end    
where bi is either   or     each of the possible plans can be interpreted as an assignment

to n boolean variables by ignoring every second assignment action  the construction in
theorem   shows how to turn a cnf formula  into a planning domain m     and it
can easily be modified to ignore every second action  thus  the best totally ordered plan
consistent with the given partially ordered plan reaches the goal with probability   if and
only if it reaches the goal with probability greater than       m if and only if it satisfies all
clauses of  if and only if  is satisfiable 

theorem    the plan evaluation problem for partially ordered plans in at domains is
co np complete under the pessimistic interpretation 

proof sketch  both the proof of membership in co np and the proof of hardness are

very similar to the proof of theorem     we show a reduction from the co np complete set
of unsatisfiable formulae in cnf  the plan to evaluate has the form given in figure  
and is interpreted as above  as in the proof of theorem    we construct a planning domain
m      but we take g   fsrejg as goal states  where the state srej is reached with probability
greater than   if and only if the assignment does not satisfy one of the clauses of formula  
a formula is unsatisfiable if and only if under every assignment at least one of the clauses
is not satisfied  therefore  the probability that m      reaches a goal state under a given
totally ordered plan is greater than   if and only if the plan corresponds to an unsatisfying
sat

  

filittman  goldsmith   mundhenk

start

assign     

assign      

assign     

assign      

assign     

assign      

   
assign n   

assign n    

end

figure    a partially ordered plan that can be hard to evaluate
assignment  finally  the minimum of that probability over all consistent partially ordered
plans is greater than   if and only if  is unsatisfiable 

theorem    the plan evaluation problem for partially ordered plans in at domains is

pp complete under the average interpretation 
proof  under the average interpretation  we must decide whether the average evaluation
over all consistent totally ordered plans is greater than threshold   this can be decided in
pp by guessing uniformly a totally ordered plan and checking its consistency with the given
partially ordered plan in polynomial time  if the guessed totally ordered plan is consistent 
it can be evaluated in polynomial time  theorem    and accepted or rejected as appropriate 
if the guessed plan is inconsistent  the computation accepts with probability  and rejects
with probability       leaving the average over the consistent orderings unchanged with
respect to the threshold  
the pp hardness is shown by a reduction from the pp complete majsat  let  be a
formula in cnf  we show how to construct a domain m    and a partially ordered plan
p    such that    majsat if and only if the average performance of m    under a totally
ordered plan consistent with p    is greater than     
let  consist of the m clauses c            cm   which contain n variables x            xn   domain
m      hs   s    a  t  gi has actions
a   fassign i  b  j i   f           ng  b   f     gg   fstart  check  endg 
action assign i  b  will be interpreted as  assign sign b to xi    the partially ordered plan
p    has plan steps
v   f i  b  h  j i   f           ng  b   f     g  h   f           mgg   fstart  check  endg
and mapping    v   a with
      for    fstart  check  endg  and   i  b  h     assign i  b  
  

ficomplexity of probabilistic planning

the order e requires that a consistent plan has start as the first and end as the last step 
the steps in between are arbitrarily ordered  more formally 
e   f start  q  j q   v   fstart  endgg   f q  end  j q   v   fstart  endgg 
now  we define how the domain m    acts on a given totally ordered plan p consistent
with p     domain m    consists of the cross product of the following polynomial size
deterministic domains ms and m   to which a final probabilistic transition will be added 
before we describe ms and m precisely  here are their intuitive definitions  the domain
ms is satisfied by plans that have the form of an assignment to the n boolean variables with
the restriction that the assignment is repeated m times  for easy checking   the domain
m is satisfied by plans that correspond to satisfying assignments  the composite of these
two domains is only satisfied by plans that correspond to satisfying assignments  we will
now define these domains formally 
first  ms checks whether the totally ordered plan matches the regular expression
start  assign      m jassign      m  
    assign n    m jassign n    m  
check   assign      jassign            assign n    jassign n      m  
note that the m here is a constant  let  good  be the state reached by ms if the plan
matches that expression  otherwise  the state reached is  bad   to clarify  the actions before check are there simply to  use up  the extra steps not used in specifying the assignment
in the partially ordered plan 
next  m checks whether the sequence of actions following the check action satisfies
the clauses of  in the following sense  let a     ak be this sequence  m interprets each
subsequence a   j    n    an  j    n with al  j    m   assign x  bl   as assignment b            bn
to the variables x            xn   and checks whether this assignment satisfies clause cj   if all
single clauses are satisfied in this way  then m reaches state  satisfied  
note that ms and m are defined so that they do not deal with the final end action 
m    consists of the product domain of ms and m with the transitions for action end
as follows  if m is in state  bad  q  for any state q of m   then action end lets m go
probabilistically to state  accept  or to state  reject   with probability     each  if m is
in state  good  satisfied   the m under action end goes to state  accept   with probability
    otherwise  m under action end goes to state reject  with probability     the set of goal
states of m consists of the only state  accept  
we analyze the behavior of m    under any plan p consistent with p     if ms under
p reaches state  bad   then m    under p reaches a goal state with probability      now 
consider a plan p under which ms reaches the state  good  called a good plan  then
p matches the above regular expression  therefore  for every i   f           mg there exists
bi   f     g such that all steps s i  bi   h  are between start and check  thus  all steps
between check and end are
s        i          s n      in     s        i          s n      in  m 
consequently  the sequence of actions defined by the labeling of these plan steps are
 assign    i   assign    i       assign n  in   m  
  

filittman  goldsmith   mundhenk

this means  that m checks whether all clauses of  are satisfied by the assignment i     in  
i e   m checks whether i     in satisfies   therefore  m    accepts under plan p with
probability    if the plan represents a satisfying assignment  and with probability   otherwise 
note that each assignment corresponds to exactly one good plan  therefore  the average
over all good plans that m    accepts equals the fraction of satisfying assignments of  
since m    accepts under  bad  plans with probability      this yields that the average
over all plans consistent with p    of the acceptance probabilities of m    is greater than
    if and only if    majsat 
the complexity of the plan existence problem for partially ordered plans is identical to
that for totally ordered plans 

theorem    the plan existence problem for partially ordered plans in at domains is npcomplete under the pessimistic  optimistic and average interpretations  the plan existence
problem for partially ordered plans in propositional domains is nppp  complete under the
pessimistic  optimistic and average interpretations 

proof  first  note that a totally ordered plan is a special type of partially ordered plan

and its evaluation is unchanged under the pessimistic  optimistic  or average interpretation 
in particular  because there is only one ordering consistent with a given totally ordered
plan  the best  worst  and average orderings are all the same  therefore  if there exists a
totally ordered plan with value greater than   then there is a partially ordered plan with
value greater than   the same plan   under all three interpretations 
conversely  if there is a partially ordered plan with value greater than  under any of
the three interpretations  then there is a totally ordered plan with value greater than  
this is because the value of the best  worst  and average ordering of a partially ordered
plan is always a lower bound on the value of the best consistent totally ordered plan 
given this strong equivalence  the complexity of plan existence for partially ordered
plans is a direct corollary of theorems   and   
the pattern for partially ordered plan evaluation in at domains is that the average
interpretation is no easier to decide than either the optimistic or pessimistic interpretations 
in propositional domains  the pattern is the opposite  the average interpretation is no harder
to decide than either the optimistic or pessimistic interpretations 

theorem    the plan evaluation problem for partially ordered plans in propositional do 

mains is nppp  complete under the optimistic interpretation  co nppp  complete under the
pessimistic interpretation  and pp complete under the average interpretation 

proof sketch  for the optimistic interpretation  membership in nppp follows from the

fact that we can guess a single suciently good consistent total order and evaluate it in
pp  theorem     hardness for nppp can be shown using a straightforward reduction from
e majsat  as in the proof of theorem    
for the pessimistic interpretation  membership in co nppp follows from the fact that we
can guess the worst consistent total order and evaluate it in pp  theorem     hardness for
  

ficomplexity of probabilistic planning

co nppp can be shown by reducing to it the co nppp version of e majsat  e majsat  
the proof is a simple adaptation of the techniques used  for example  in theorem   above 
for the average interpretation  the problem can be shown to be in pp by combining
the argument in the proof of theorem    showing how to average over consistent totally
ordered plans with the argument in the proof of theorem   showing how to evaluate a
plan in a propositional domain in pp  alternatively  we could express the evaluation of a
partially ordered plan under the average interpretation as a compact probabilistic acyclic
plan  corollary   states that such plans can be evaluated in pp  pp hardness follows directly
from theorem    because totally ordered plans are a special case of partially ordered plans
and evaluating totally ordered plans is pp hard 

   applications
to help illustrate the utility of our results  this section cites several planners from the
literature and analyzes the computational complexity of the problems they attack  we do
not give detailed explanations of the planners themselves  for this  we refer the reader to
the original papers  we focus on three planning systems  witness  brown university  
buridan  university of washington   and treeplan  university of british columbia   in
the process of making connections to these planners  we also describe how our work relates to
the discounted reward criterion  partial observability  other domain representations  partial
order conditional planning  policy based planning  and approximate planning 

    witness

the witness algorithm  cassandra  kaelbling    littman        kaelbling et al        
solves at partially observable markov decision processes using a dynamic programming approach  the basic algorithm finds optimal unrestricted solutions to finite horizon problems 
papadimitriou and tsitsiklis        showed that the plan existence problem for polynomialhorizon partially observable markov decision processes is pspace complete 
as an extension to their finite horizon algorithm  kaelbling et al         sketch a method
for finding optimal looping plans for some domains  although this is not presented as a
formal algorithm  it is not unreasonable to say that the pure form of the problem that this
extended version of witness attacks is one of finding a valid polynomial size looping plan
for a partially observable domain  the similarities between this problem and that described
in section   are that the domains are at and that the plans are identical in form  the
apparent differences are that witness optimizes a reward function instead of probability
of goal satisfaction and that witness works in partially observable domains whereas our
results are defined in terms of completely observable domains  both of these apparent
differences are insignificant  however  from a computational complexity point of view 
first  witness attempts to maximize the expected total discounted reward over an
infinite horizon  sometimes called optimizing a time separable value function   as argued
by condon         any problem defined in terms of a sum of discounted rewards can be
recast as one of goal satisfaction  the argument proceeds roughly as follows  let         
be the discount factor and r s  a  be the immediate reward received for taking action a in
state s 
  

filittman  goldsmith   mundhenk

define

s  a r s    a   
r  s  a    max r s ra  s    amin
      min r s    a     
 

s  a
 

 

s  a

 

 

 

from this  we have that    r   s  a     for all s and a and that the value of any plan with
respect to the revised reward function is a simple linear transformation of its true value 
now  we introduce an auxiliary state g to be the goal state and create a new transition
function t  such that t   s  a  g           r   s  a  and t   s  a  s                  r   s  a  t s  a  s   
for s     g  t  is a well defined transition function and the probability of goal satisfaction for
any plan under transition function t  is precisely the same as the expected total discounted
reward under reward function r  and transition function t  thus  any problem stated as
one of optimizing the expected total of discounted immediate rewards can be turned into an
equivalent problem of optimizing goal satisfaction with only a slight change to the transition
function and one additional state  this means there is no fundamental computational
complexity difference between these two different types of planning objectives 
the second apparent difference between the problem solved by the extended witness
algorithm and that described in section   is that of partial versus complete observability 
in fact  our results do address partial observability  albeit indirectly  in our formulation of
the plan existence problem  plans are constrained to make no conditional branches  in the
totally ordered and partially ordered cases   or to branch only on distinctions made by the
step transition function   in the acyclic and looping cases   these two choices correspond
to unobservable and partially observable domains  respectively  in a partially observable
domain  the plan existence problem becomes one of finding a valid polynomial size finitestate controller subject to the given observability constraints  nothing in our complexity
proofs depends on the presence or absence of additional observability constraints  therefore 
it is a direct corollary of theorem   that the plan existence problem for polynomial horizon
plans in unobservable domains is np complete  papadimitriou   tsitsiklis        and of
theorem   that the plan existence problem for polynomial size looping plans in partially
observable domains is np complete  this is a new result  
it is interesting to note that the computational complexity of searching for size bounded
plans in partially observable domains is generally substantially less than that of solving the
corresponding unconstrained partially observable markov decision process  for example 
we found that the plan existence problem for acyclic plans in propositional domains is
nppp  complete  theorem     the corresponding unconstrained problem is that of determining the existence of a history dependent policy for a polynomial horizon  compactly
represented partially observable markov decision process  which is expspace complete
 theorem      of goldsmith et al         or theorem     of mundhenk et al       b   the
gap here is enormous  expspace is to exp what pspace is to p  and exp is already
provably intractable in the worst case  in contrast to expspace complete problems  it is
conceivable that good heuristics for nppp  complete problems can be created by extensions
of recent advances in heuristics for np complete problems  therefore  there is some hope
of devising effective planning algorithms by building on the observations in this paper and
searching for optimal size bounded plans instead of optimal unrestricted plans  in fact  recent planners for both propositional domains  majercik   littman      a      b  and at
domains  hansen        are motivated by these results 
  

ficomplexity of probabilistic planning

domain type
at
propositional
at
propositional

horizon type
polynomial
polynomial
infinite
infinite

size bounded plan unrestricted plan
np complete
nppp  complete
np complete
pspace complete

pspace complete
expspace complete
undecidable
undecidable

table    complexity results for plan existence in partially observable domains
table   summarizes complexity results for planning in partially observable domains 
the results for size bounded plans are corollaries of theorems          and   of this paper  the results for unrestricted plans are due to papadimitriou and tsitsiklis       
 at  polynomial   goldsmith et al          propositional  polynomial   and hanks       
 infinite horizon   this last result is derived by noting the isomorphism of the infinitehorizon problem to the emptiness problem for probabilistic finite state automata  which is
undecidable  rabin        

    buridan

the buridan planner  kushmerick et al         finds partially ordered plans for propositional domains in the pso representation  there are two identifiable differences between
the problem solved by buridan and the problem analyzed in section    the representation
of planning problems and the fact that buridan is not restricted to find polynomial size
plans  we address each of these differences below 
although  on the surface  pso is different from st  either can be converted into the
other in polynomial time with at most a polynomial increase in domain size  in particular 
the effect of an action in pso is represented by a single decision tree consisting of proposition
nodes  like st  and random nodes  easily simulated in st using auxiliary propositions  
at the leaves are a list of propositions that become true and another list of propositions
that become false should that leaf be reached  this type of correlated effect is also easily
represented in st using the chain rule of probability theory to decompose the probability
distribution into separate probabilities for each proposition and careful use of the   new 
sux  thus  any pso domain can be converted to a similar size st domain quickly 
similarly  a domain in st can be converted to pso with at most a polynomial expansion 
this conversion is too complex to sketch here  but follows from the proof of equivalence between st and a simplified representation called if  littman      a   given the polynomial
equivalence between st and pso  any complexity results for st carry over to pso  
the results described in this paper concern planning problems in which a bound is given
on the size of the plan sought  although kushmerick et al         do not explicitly describe
their planner as one that prefers small plans to large plans  the design of the planner as
one that searches through the space of plans makes the notion of plan size central to the
algorithm  indeed  the public domain buridan implementation uses plan size as part of a
best first search procedure for identifying a suciently successful plan  this means that  all
other things being equal  shorter plans will be found before larger plans  furthermore  to
assure termination  the planner only considers a fixed number of plans before halting  thus
   to be more precise  this is true for complexity classes closed under log space reductions 

  

filittman  goldsmith   mundhenk

putting a limit indirectly on the maximum allowable plan size  so  although buridan does
not attempt to solve precisely the same problem that we considered  it is fair to say that the
problem we consider is an idealization of the problem attacked by buridan  regardless 
our lower bounds on complexity apply to buridan 
kushmerick et al         looked at generating suciently successful plans under both
the optimistic interpretation and the pessimistic interpretation  they also explicitly examined the plan evaluation problem for partially ordered plans under both interpretations 
therefore  theorems    and    apply to buridan 
the more sophisticated c buridan planner  draper et al         extends buridan to
plan in partially observable domains and to produce plans with conditional execution  the
results of our work also shed light on the computational complexity of the problem addressed
by c buridan  draper et al         devised a representation for partially ordered acyclic
 conditional  plans  in this representation  each plan step generates an observation label as
a function of the probabilistic outcome of the step  each step also has an associated set of
context labels dictating the circumstances under which that step must be executed  a plan
step is executed only if its context labels are consistent with the observation labels produced
in earlier steps  in its totally ordered form  this type of plan can be expressed as a compact
acyclic plan  corollary   can be used to show that the plan evaluation and plan existence
problems for a totally ordered version of c buridan s conditional plan representation in
propositional domains are pp complete and nppp  complete  respectively 
in our results above  we consider evaluating and searching for plans that are partially
ordered and plans that have conditional execution  but not both at once  nonetheless  the
same sorts of techniques presented in this paper can be applied to analyzing the problems
attacked by c buridan  for example  consider the plan existence problem for c buridan s
partially ordered conditional plans under the optimistic interpretation  this problem asks
whether there is a partially ordered conditional plan that has some total order that reaches
the goal with sucient probability  this is equivalent to asking whether there is a totally
ordered conditional plan that reaches the goal with sucient probability  therefore  the
problem is nppp  complete  by the argument in the previous paragraph 
in spite of many superficial differences between the problems analyzed in this paper and
those studied by the creators of the buridan planners  our results are quite relevant to
understanding their work 

    treeplan
a family of planners have been designed that generate a decision tree based representation
of stationary policies  mappings from state to action   boutilier et al         boutilier  
poole        boutilier   dearden        in probabilistic propositional domains  we refer
to these planners collectively as the treeplan planners  once again  these planners solve
problems that are not identical to the problems addressed in this paper but are closely
related 
the planner described by boutilier et al         finds solutions that maximize expected
total discounted reward in compactly represented markov decision processes  the domain
representation used is expressively equivalent to st   as mentioned earlier  the difference
between maximizing goal satisfaction and maximizing expected total discounted reward is a
  

ficomplexity of probabilistic planning

superficial one  so the problem addressed by this planner is exp complete  littman      a  
although the policies used by boutilier et al         appears quite dissimilar from the finitestate controllers described in our work  policies can be converted to a type of similarly
sized compact looping plan  an extension of the type of plan described in corollary    
the conversion from stationary policies to looping plans is as described in the proof of
theorem    except that the resulting plans are represented compactly 
in later work  boutilier and dearden        show how it is possible to limit the size
of the representation of the policy in treeplan and still obtain approximately optimal
performance  this is necessary because  in general  the size of decision trees needed to
represent the optimal policies can be exponentially large  by keeping the decision trees
from getting too large  the resulting planner becomes subject to an extension of theorem  
and  therefore  attacks a pspace complete problem 
one emphasis of boutilier and dearden        is on finding approximately optimal
solutions  with the hope that doing so is easier than finding optimal solutions  we do
not explore the worst case complexity of approximation in this paper  although lusena 
goldsmith  and mundhenk        have produced some strong negative results in this area 
a related issue is one of using simulation  random sampling  to find approximately optimal
solutions to probabilistic planning problems  some empirical successes have been obtained
with the related approach of reinforcement learning  tesauro        crites   barto        
but  once again  the worst case complexity of probabilistic planning is not known to be any
lower for approximation by simulation 

   conclusions
in this paper  we explored the computational complexity of plan evaluation and plan existence in probabilistic domains  we found that  in compactly represented propositional
domains  restricting the size and form of the policies under consideration reduced the
computational complexity of plan existence from exp complete for unrestricted plans to
pspace complete for polynomial size looping plans and nppp  complete for polynomialsize acyclic plans  in contrast  in at domains  restricting the form of the policies under
consideration increased the computational complexity of plan existence from p complete
for unrestricted plans to np complete for totally ordered plans  this is because a plan that
is smaller than the domain in which it operates is often unable to exploit important markov
properties of the domain  we were able to characterize precisely the complexity of all
problems we examined with regard to the current state of knowledge in complexity theory 
several problems we studied turned out to be nppp  complete  the class nppp promises
to be very useful to researchers in uncertainty in artificial intelligence because it captures
the type of problems resulting from choosing   guessing   a solution and then evaluating its
probabilistic behavior  this is precisely the type of problem faced by planning algorithms in
probabilistic domains  and captures important problems in other domains as well  such as
constructing explanations in belief networks and designing robust communication networks 
we provide a new conceptually simple nppp  complete problem  e majsat  that may be
useful in further explorations in this direction 
the basic structure of our results is that if plan evaluation is complete for some class c  
then plan existence is typically npc  complete  this same basic structure holds in determin  

filittman  goldsmith   mundhenk

istic domains  evaluating a totally ordered plan in a propositional domain is p complete  for
suciently powerful domain representations  and determining the existence of a polynomialsize totally ordered plan is npp   np complete 
from a pragmatic standpoint  the intuition that searching for small plans is more efficient than searching for arbitrary size plans suggests that exact dynamic programming
algorithms  which are so successful in at domains  may not be as effective in propositional
domains  they do not focus their efforts on the set of small plans  algorithm development
energy  therefore  might fruitfully be spent devising heuristics for problems in the class nppp
as this class captures the essence of searching for small plans in probabilistic domains some
early results in this direction are appearing  majercik   littman      a      b   complexity theorists have only recently begun to explore classes such as nppp that lie between the
polynomial hierarchy and pspace and algorithm designers have come to these classes even
more recently  as this paper marks the beginning of our exploration of this class of problems  much work is still to be done in probing algorithmic implications  but it is our hope
that heuristics for nppp could lead to powerful methods for solving a range of important
uncertainty sensitive combinatorial problems 

acknowledgements
this work was supported in part by grants nsf iri          career  littman   and
nsf ccr          goldsmith   we gratefully acknowledge andrew klapper  anne condon  matthew levy  steve majercik  chris lusena  mark peot  and our reviewers for helpful
feedback and conversations on this topic 

appendix a  complexity of e majsat
the e majsat problem is  given a pair    k  consisting of a boolean formula  of n
variables x            xn and a number    k  n  is there an assignment to the first k variables
x            xk such that the majority of assignments to the remaining n k variables xk             xn
satisfies  
for k   n  this is precisely boolean satisfiability  a classic np complete problem  this
is because we are asking whether there exists an assignment to all the variables that makes
 true  for k      e majsat is precisely majsat  a well known pp complete problem 
this is because we are asking whether the majority of all total assignments makes  true 
deciding an instance of e majsat for intermediate values of k has a different character 
it involves both an np type calculation to pick a good setting for the first k variables and a
pp type calculation to see if the majority of assignments to the remaining variables makes
 true  this is akin to searching for a good answer  plan  schedule  coloring  belief network
explanation  etc   in a combinatorial space when  good  is determined by a computation
over probabilistic quantities  this is just the type of computation described by the class
nppp   and we show next that e majsat is nppp  complete 

theorem   

e majsat

is nppp  complete 
  

ficomplexity of probabilistic planning

proof  membership in nppp follows directly from definitions  to show completeness of
e majsat  we first observe  tor
an        that nppp is the np
m  closure of the pp complete

set majsat  thus  any nppp computation can be modeled by a nondeterministic machine
n that  on each possible computation  first guesses a sequence s of bits that controls its
nondeterministic moves  deterministically performs some computation on input x and s 
and then writes down a formula qx s with variables in z            zl as a query to majsat 
finally  n  x  with oracle majsat accepts if and only if for some s  qx s   majsat 
given any input x  like in cook s theorem  we can construct a formula x with variables
y           yk and z           zl such that for every assignment a           ak   b            bl it holds that
x  a            ak   b            bl     qx a a  b            bl    thus   x   k    e majsat if and only if for
some assignment s to y            yk   qx s   majsat if and only if n  x  accepts 
k

references

allender  e     ogihara  m          relationships among pl   l  and the determinant 
theoretical informatics and applications               
a lvarez  c     jenner  b          a very hard log space counting class  theoretical computer
science            
backstrom  c          expressive equivalence of planning formalisms  artificial intelligence 
                
backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence                  
balcazar  j   daz  j     gabarro  j               structural complexity i ii  eatcs
monographs on theoretical computer science  springer verlag 
borodin  a   cook  s     pippenger  n          parallel computation for well endowed
rings and space bounded probabilistic machines  information and control           
        
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions and computational leverage  in preparation 
boutilier  c     dearden  r          approximating value trees in structured dynamic programming  in saitta  l   ed    proceedings of the thirteenth international conference
on machine learning 
boutilier  c   dearden  r     goldszmidt  m          exploiting structure in policy construction  in proceedings of the fourteenth international joint conference on artificial
intelligence  pp            
boutilier  c     poole  d          computing optimal policies for partially observable
decision processes using compact representations  in proceedings of the thirteenth
national conference on artificial intelligence  pp             aaai press the mit
press 
  

filittman  goldsmith   mundhenk

bylander  t          the computational complexity of propositional strips planning 
artificial intelligence              
cassandra  a  r   kaelbling  l  p     littman  m  l          acting optimally in partially
observable stochastic domains  in proceedings of the twelfth national conference on
artificial intelligence  pp            seattle  wa 
chapman  d          planning for conjunctive goals  artificial intelligence              
condon  a          the complexity of stochastic games  information and computation 
                
crites  r  h     barto  a  g          improving elevator performance using reinforcement
learning  in touretzky  d  s   mozer  m  c     hasselmo  m  e   eds    advances in
neural information processing systems   cambridge  ma  the mit press 
dearden  r     boutilier  c          abstraction and approximate decision theoretic planning  artificial intelligence                    
draper  d   hanks  s     weld  d          probabilistic planning with information gathering
and contingent execution  in proceedings of the aaai spring symposium on decision
theoretic planning  pp        
drummond  m     bresina  j          anytime synthetic projection  maximizing the
probability of goal satisfaction  in proceedings of the eighth national conference on
artificial intelligence  pp           morgan kaufmann 
erol  k   nau  d  s     subrahmanian  v  s          complexity  decidability and undecidability results for domain independent planning  artificial intelligence            
gill  j          computational complexity of probabilistic turing machines  siam journal
on computing                 
goldman  r  p     boddy  m  s          epsilon safe planning  in proceedings of the   th
conference on uncertainty in artificial intelligence  uai     pp          seattle 
wa 
goldsmith  j   littman  m     mundhenk  m       a   the complexity of plan existence and
evaluation in probabilistic domains  tech  rep  cs          department of computer
science  duke university 
goldsmith  j   littman  m  l     mundhenk  m       b   the complexity of plan existence
and evaluation in probabilistic domains  in proceedings of the thirteenth annual conference on uncertainty in artificial intelligence  uai      pp          san francisco 
ca  morgan kaufmann publishers 
goldsmith  j   lusena  c     mundhenk  m          the complexity of deterministically
observable finite horizon markov decision processes  tech  rep          department
of computer science  university of kentucky 
  

ficomplexity of probabilistic planning

hanks  s          decision theoretic planning in unobservable domains is undecidable 
personal communication 
hansen  e  a          finite memory control of partially observable systems  ph d  thesis 
university of massachusetts 
jung  h          on probabilistic time and space  in proceedings   th icalp  pp          
lecture notes in computer science  springer verlag 
kaelbling  l  p   littman  m  l     cassandra  a  r          planning and acting in
partially observable stochastic domains  artificial intelligence                    
koenig  s     simmons  r  g          risk sensitive planning with probabilistic decision
graphs  in proceedings of the  th international conference on principles of knowledge
representation and reasoning  pp          
kushmerick  n   hanks  s     weld  d  s          an algorithm for probabilistic planning 
artificial intelligence                    
ladner  r          polynomial space counting problems  siam journal on computing     
          
lin  s  h     dean  t          generating optimal policies for high level plans with conditional branches and loops  in proceedings of the third european workshop on
planning  pp          
littman  m  l       a   probabilistic propositional planning  representations and complexity  in proceedings of the fourteenth national conference on artificial intelligence 
pp           aaai press the mit press 
littman  m  l       b   solving large pomdps  lessons from complexity theory  talk
presented at the darpa ai workshop in providence  ri  slides available at url
http   www cs duke edu mlittman talks darpa   pomdp ps 
lovejoy  w  s          a survey of algorithmic methods for partially observable markov
decision processes  annals of operations research                
lusena  c   goldsmith  j     mundhenk  m          nonapproximability results for markov
decision processes  tech  rep  uk cs dept tr         university of kentucky 
majercik  s  m     littman  m  l       a   maxplan  a new approach to probabilistic
planning  in simmons  r   veloso  m     smith  s   eds    proceedings of the fourth
international conference on artificial intelligence planning  pp         aaai press 
majercik  s  m     littman  m  l       b   using caching to solve larger probabilistic
planning problems  in proceedings of the fifteenth national conference on artificial
intelligence  pp           the aaai press the mit press 
mansell  t  m          a method for planning given uncertain and incomplete information 
in proceedings of the  th conference on uncertainty in artificial intelligence  pp 
         morgan kaufmann publishers 
  

filittman  goldsmith   mundhenk

mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings of
the  th national conference on artificial intelligence  pp          
mundhenk  m   goldsmith  j     allender  e       a   the complexity of policy evaluation
for finite horizon partially observable markov decision processes  in proceedings of
  nd symposium on mathematical foundations of computer science  published in
lecture notes in computer science   springer verlag 
mundhenk  m   goldsmith  j   lusena  c     allender  e       b   encyclopaedia of complexity results for finite horizon markov decision process problems  tech  rep  uk cs
dept tr         university of kentucky 
papadimitriou  c  h          computational complexity  addison wesley  reading  ma 
papadimitriou  c  h     tsitsiklis  j  n          the complexity of markov decision processes  mathematics of operations research                  
platzman  l  k          a feasible computational approach to infinite horizon partiallyobserved markov decision problems  tech  rep  j       georgia institute of technology 
atlanta  ga 
puterman  m  l          markov decision processes discrete stochastic dynamic programming  john wiley   sons  inc   new york  ny 
rabin  m  o          probabilistic automata  information and control                 
roth  d          on the hardness of approximate reasoning  artificial intelligence           
        
simon  j          on some central problems in computational complexity  ph d  thesis 
cornell university  also cornell department of computer science technical report
tr       
smith  d  e     williamson  m          representation and evaluation of plans with loops 
working notes for the      stanford spring symposium on extended theories of
action 
tesauro  g          td gammon  a self teaching backgammon program  achieves masterlevel play  neural computation                 
toda  s          pp is as hard as the polynomial time hierarchy  siam journal on computing              
toran  j          complexity classes defined by counting quantifiers  journal of the acm 
                
vinay  v          counting auxiliary pushdown automata and semi unbounded arithmetic
circuits  in proc   th structure in complexity theory conference  pp           ieee 

  

fi