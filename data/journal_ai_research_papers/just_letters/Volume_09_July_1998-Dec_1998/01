journal artificial intelligence research               

submitted       published     

divide and conquer subgoal ordering algorithm
speeding logic inference
oleg ledeniov
shaul markovitch

olleg cs technion ac il
shaulm cs technion ac il

computer science department
technion   israel institute technology
haifa        israel

abstract

common view programs combination logic control  logic part
defines program must do  control part   it  logic programming paradigm developed intention separating logic control 
recently  extensive research conducted automatic generation control
logic programs  works considered issue automatic generation
control improving eciency logic programs  paper present novel algorithm automatic finding lowest cost subgoal orderings  algorithm works using
divide and conquer strategy  given set subgoals partitioned smaller sets 
based co occurrence free variables  subsets ordered recursively merged 
yielding provably optimal order  experimentally demonstrate utility algorithm testing several domains  discuss possibilities cooperation
existing methods 

   introduction
common view programs combination logic control  kowalski        
logic part defines program must do  control part   it  traditional
programming languages require programmers supply components  logic
programming paradigm developed intention separating logic
control  lloyd         goal paradigm programmer specifies logic
without bothering control  supplied interpreter 
initially  practical logic programming languages  prolog  clocksin   mellish        sterling   shapiro         include means automatic generation
control  result  prolog programmer implicitly define control order
clauses subgoals within clauses  recently  extensive research conducted
automatic generation control logic programs  major part research concerned control affects correctness termination logic programs  de schreye
  decorte        somogyi  henderson    conway      b  cortesi  le charlier    rossi 
       works consider issue automatic generation control
improving eciency logic programs  finding good ordering leads ecient
execution requires deep understanding logic inference mechanism  hence  many
cases  expert programmers able generate ecient programs  problem intensifies recent development field inductive logic programming  muggleton
c      ai access foundation morgan kaufmann publishers  rights reserved 

filedeniov   markovitch

  de raedt         there  logic programs automatically induced learning 
learning algorithms commonly built aim speeding induction process
without considering eciency resulting programs 
goal research described paper design algorithms automatically find ecient orderings subgoal sequences  several researchers explored
problem automatic reordering subgoals logic programs  warren        naish      b 
smith   genesereth        natarajan        markovitch   scott         general subgoal ordering problem known np hard  ullman        ullman   vardi        
smith genesereth        markovitch scott        present search algorithms
finding optimal orderings  algorithms general carry exponential costs
non trivial sets subgoals  natarajan        describes ecient algorithm special
case subgoals set share free variables 
paper present novel algorithm subgoal ordering  call two subgoals
share free variable dependent  unlike natarajan s approach  handle
subgoal sets completely independent  algorithm deal subgoal
set  making maximal use existing dependencies acceleration ordering
process  worst case algorithm   smith genesereth   exponential 
still  practical cases  algorithm exploits subgoal dependencies finds optimal
orderings polynomial time 
start analysis ordering problem demonstrate importance
examples  show compute cost given ordering based
cost number solutions individual subgoals  describe algorithm
natarajan algorithm smith genesereth show two
combined algorithm ecient general two 
show drawbacks combined algorithm introduce new algorithm  avoids
drawbacks  call divide and conquer algorithm  dac algorithm   prove
correctness algorithm  discuss complexity compare combined
algorithm  dac algorithm assumes knowledge cost number solutions
subgoals  knowledge obtained machine learning techniques
employed markovitch scott         finally  test utility algorithm
running set experiments artificial real domains 
dac algorithm subgoal ordering combined many existing methods
logic programming  program transformation  compilation  termination control 
correctness verification  others  discuss possibilities combinations
concluding section 
section   states ordering problem  section   describes existing ordering algorithms
combination  section   presents new algorithm  section   discusses
acquisition control knowledge  section   contains experimental results  section  
contains discussion practical issues  comparison works conclusions 

   background  automatic ordering subgoals
start describing conventions assumptions accepted paper 
demonstrate importance subgoal ordering discuss validity  finally  present
classification ordering methods discuss related work 
  

fithe divide and conquer subgoal ordering algorithm

    conventions assumptions

constant  function predicate symbols programs begin lower case letters 
capital letters reserved variables  braces used denote unordered sets
 e g   fa  b  cg   angle brackets used ordered sequences  e g   ha  b  ci   parallel
lines  k  denote concatenations ordered sequences subgoals  speaking
abstract subgoals  and named predicates concrete programs   denote separate
subgoals capital letters  a  b         ordered sequences subgoals capitalized vectors
  o          sets subgoals calligraphic capitals  b           s   denotes set
 b 
permutations  
assume programs work written pure prolog  i e   without cut
operators  meta logical extra logical predicates  alternatively  assume
pure prolog sub sequences subgoals subject ordering  example  given rule
form
b    b   b      b   b   b  
final part fb    b   b g ordered  without affecting solution set  
work focus upon task finding solutions set subgoals 

    ordering subgoals logic programs
logic program set clauses 



b    b           bn  

 n   

a  b           bn literals  predicates arguments   use clause
proving goal matches a  must prove b  s hold simultaneously 
consistent bindings free variables  solution set variable bindings 
solution set goal bag solutions created program 
computation rule defines subgoal proved next  prolog  computation rule always selects leftmost subgoal goal  subgoal fails  backtracking
performed   proof previous subgoal re entered generate another solution 
detailed definition logic inference process  see lloyd        

theorem   solution set set subgoals depend order

execution 

proof  looking solutions  solution set depend

computation rule chosen  theorems          lloyd         since transposition
subgoals ordered sequence regarded change computation rule  the
subgoals selected different order   transposition change solution
set 
 
theorem implies may reorder subgoals proof derivation  yet
eciency derivation strongly depends chosen order subgoals  following
example illustrates two different orders lead large difference execution
eciency 
  

filedeniov   markovitch

parent abraham isaac  
parent sarah isaac  
parent abraham ishmael  
parent isaac esav  
parent isaac jakov  

    parent clauses    

male abraham  
male isaac  
male ishmael  
male jakov  
male esav  

    male clauses    

brother x y 
male x   parent w x   parent w y   x   y 
father x y 
male x   parent x y  
uncle x y 
parent z y   brother x z  

    rules relations    

figure    small fragment biblical database describing family relationships 

example  
consider biblical family database one listed figure    a similar database
appears book sterling   shapiro         body rule defining
uncle nephew  or uncle niece  relation ordered two ways 
   uncle x y  brother x z   parent z y  
   uncle x y  parent z y   brother x z  
prove goal uncle ishmael y  using first version rule  interpreter
first look ishmael s siblings  and find isaac  siblings  children  esav
jacov   left part figure   shows associated proof tree total   
nodes  use second version rule  interpreter create parentchild pairs available database  test parent whether  or she 
ishmael s sibling  right part figure   shows associated proof tree total
  n                   n     nodes  n number parent child pairs
database  tree contains two success branches n     failure branches  figure
show one example each  two versions rule yield identical solution
sets  first version leads much smaller tree faster execution 
note result true given mode  bound free  head literal 
mode  free bound   uncle x jacov   outcome contrary  second
version rule yields smaller tree 

    categories subgoal ordering methods

assume current conjunctive goal  the current resolvent  fa   a g  assume
use rule  a  a    a     reduce a    according theorem    produced
resolvent  fa     a    a g  executed order  call ordering methods
allow permutation resolvent interleaving ordering methods  since permit
  

fithe divide and conquer subgoal ordering algorithm

uncle x y 

brother x z   parent z y   uncle x y 

uncle ishmael y 

uncle ishmael y 

parent z y   brother ishmael z 

brother ishmael z   parent z y 

z adam 
y cain

male ishmael   parent w ishmael   parent w z  
ishmael     z  parent z y 

brother ishmael adam 
parent w ishmael   parent w z  
ishmael     z  parent z y 
w abraham
parent abraham z   ishmael   z  parent z y 
z ishmael
z isaac
ishmael     ishmael 
parent ishmael y 

isaac     ishmael 
parent isaac y 

parent z y   brother x z  

z isaac 
y jacov


parent child
pairs

male ishmael   parent w ishmael  
parent w adam   ishmael     adam
parent w ishmael   parent w adam  
ishmael     adam
w abraham
parent abraham adam   ishmael    adam

parent isaac y 
y esav
y jacov

brother ishmael isaac 

male ishmael   parent w ishmael  
parent w isaac   ishmael   isaac
parent w ishmael   parent w isaac  
ishmael     isaac
w abraham
parent abraham isaac   ishmael   isaac
ishmael     isaac

figure    two proof trees obtained different orderings single rule example   
interleaving subgoals different rule bodies  ordering performed
rule bodies using reduction  method non interleaving 
example  interleaving methods consider   permutations resolvent  noninterleaving methods consider two orderings  ha     a    a i ha    a    a i 
interleaving ordering methods deal significantly possible orderings noninterleaving methods  means find ecient orderings 
hand  space possible orderings may become prohibitively large  requiring
many computational resources 
subgoal ordering take place various stages proof process  divide
subgoal ordering methods static  semi dynamic dynamic 

static ordering  rule bodies ordered execution starts  ordering takes place execution 

semi dynamic ordering  whenever rule selected reduction  body
ordered  order subgoals change reduction takes place 

dynamic ordering  ordering decision made inference step 
static methods add overhead execution time  however  optimal ordering
rule often depends particular binding variable  known
run time  instance  example   saw first ordering rule better
proving goal uncle ishmael y   yet  goal uncle x jacov  
second ordering yields ecient execution  handle cases statically 
must compute optimal ordering possible binding 
  

filedeniov   markovitch

obviously  static ordering non interleaving  dynamic method
exible  since use updated knowledge variable bindings  carries
largest runtime overhead  since invoked several times use rule body 
semi dynamic method compromise two  powerful
static method  dynamically propose different orderings different instances
rule  carries less overhead dynamic method  invoked
use rule body 
total time proving goal sum ordering time inference time 
interleaving dynamic methods best potential reducing inference time 
may significantly augment ordering time  static methods devote time
ordering  it done off line   limited potential reducing inference time 
algorithms described paper used categories ordering methods 
although experiments described section   implemented semi dynamic 
non interleaving ordering methods  reduction  rule body ordered added
left end resolvent  leftmost literal resolvent selected
next reduction step 

    related work

problem computational ineciency logic inference subject extensive
research  obvious aspect ineciency possible non termination
proof  several researchers developed compile time run time techniques detect
avoid infinite computations  de schreye   decorte         certain success
achieved providing advanced control employment co routining interpredicate synchronization purposes  clark   mccabe        porto        naish        
also  infinite computations avoided pruning infinite branches contain
solutions  vasak   potter        smith  genesereth    ginsberg        bol  apt    klop 
       nail  system  morris        subgoals automatically reordered avoid
nontermination 
still  even proof finite  desirable make ecient  several
researchers studied problem clause ordering  smith        cohen        etzioni 
      laird        mooney   zelle        greiner   orponen         looking
solutions goal  eciency depend clause order  assuming
cuts   indeed  predicate clauses  argument bindings
clauses produce solutions times t    t       tm   solutions predicate
bindings obtained time t    t            tm   regardless order
clauses applied  different clause orderings correspond different orders
branches selected proof tree  traverse entire tree  number
traversal steps depend order branch selection  though order
solutions found depend it 
subgoal ordering  demonstrated example    significantly affect eciency proving goal  two major approaches subgoal ordering  first
approach uses various heuristics order subgoals  example 

choose subgoal whose predicate smallest number matching clauses  minker 
      

  

fithe divide and conquer subgoal ordering algorithm

prefer subgoal constants  minker        
choose subgoal largest size  size defined number
occurrences predicate symbols  function symbols  variables  nie   plaisted 
      

choose subgoal largest mass  mass subgoal depends
frequency arguments sub arguments entire goal  nie   plaisted 
      

choose subgoal least number solutions  warren        nie   plaisted 
      

apply  tests   generators   naish      a  
prefer calls fail quickly  naish      b  
heuristic methods usually execute quickly  may yield suboptimal orderings 
second approach  adopted paper  aims finding optimal orderings  smith   genesereth        natarajan        markovitch   scott         natarajan
proposed ecient way order special sort subgoal set  where subgoals independent   smith genesereth proposed general  inecient algorithm 
following section build unifying framework dealing subgoal ordering
describe variations natarajan s smith genesereth s algorithms  show
two combined increased eciency 

   algorithms subgoal ordering logic programs
goal work presented order subgoals speeding logic programs 
section starts analysis cost executing sequence subgoals  resulting
formula basis subsequent ordering algorithms  discuss dependence
subgoals present existing ordering algorithms independent dependent sets
subgoals  finally  combine algorithms general ecient one 

    cost executing sequence subgoals

subsection analyze cost executing sequence subgoals  analysis
builds mainly work smith genesereth        
let   fa   a        ak g set subgoals b binding  denote sols s  
solution set   define sols      f g  denote ai jb ai whose variables
bound according b  ai j    ai    finally  denote cost ai jb   amount
resources needed proving ai jb   cost ai jb   ect time complexity proving
ai binding b  example  number unification steps natural measure
complexity logic programs  itai   makowsky        
obtain cost finding solutions ordered sequence subgoals

s    ha   a   a        ani 
  

   

filedeniov   markovitch

note proof tree a  traversed once  tree a  traversed
solution generated a    tree a    solution fa   a g  etc 
consequently  total cost proving equation  

cost ha        an i    cost a    
 

x

cost a jb           

b sols fa  g 

n
x

x

cost an jb    

b sols fa      an   g 

x

cost aijb  
i   b sols fa      ai   g 

   

compute equation   one must know cost solution set subgoal
binding  reduce amount information needed  derive equivalent
formula  uses average cost average number solutions 

definition  let b set subgoals  subgoal  define cost a jb average
cost solutions b nsols a jb average number solutions
solutions b 
 
 
p  a   cost ajb  b    
  cost
b
cost a jb     b sols
  b 
     sols b      
j
sols b j
  undefined 
b       sols b     
   

 
 
j 
b  
  jpsols fagj sols
 
f

j
g
 
j
b
b
nsols a jb     b solsjsols
  b 
     sols b      
  undefined   b j
b       sols b     
   

first definition  follows that 

x

cost aijb     jsols fa        ai   g j cost ai jfa     ai  g  
 

b sols fa      ai   g 

 

   

apply second definition recursively  obtain

jsols fa        aig j  
 
 

x

jsols faijbg j
b sols fa      ai   g 
jsols fa        ai   g j nsols ai jfa     ai  g
yi
        nsols aj  jfa    aj   g 
j   

   

note defined sols      f g  thus  equations hold      incorporation
equations     equation   yields

cost ha   a        an i   

  i  
n
x
  
i  

j   

 
 
nsols aj  jfa    aj  ga cost ai  jfa    ai  g   
 

  

 

 

 

   

fithe divide and conquer subgoal ordering algorithm

subgoal ai   average cost multiplied total number solutions
preceding subgoals  define average cost number solutions every
continuous sub sequence equation     k    k     k  k  n 
cost ha        ak i j    cost ha        ak    i j 
   
cost hak        ak i jfa     ak   g  
   nsols ha        ak    i  j 
 
 

 

 

 

 

 

 

 

k
i  
x
  
 

i k 

j  k 

 

nsols aj  jfa     aj  g cost ai  jfa     ai  g  
 

 

 

 

k

nsols ha        ak i j 
nsols hak        ak i jfa     ak   g  
 
nsols ai jfa     ai  g
nsols ha        ak    i j  i k
 

 

 

 

 

 

 

 

 

 

   

 

values cost ai   nsols ai   depend position ai ordered sequence  example  assume want find abraham s sons  using domain
example    unordered conjunctive goal fmale y  parent abraham y g  let
n males database  two them  isaac ishmael  abraham s sons  
nsols male y  j    n
nsols parent abraham y  j     
nsols male y  jfparent abraham y g     nsols parent abraham y  jfmale y g     n
note nsols hmale y  parent abraham y i        nsols hparent abraham y  male y i  
exactly theorem   predicts 
defined cost sequence subgoals  define objective
ordering algorithms 

definition  let set subgoals  define  s   set permutations
  o     s   minimal ordering  denoted min o        cost according
equation   minimal possible permutations  
min o          os     s     cost o    cost os    
total execution time sum time spent ordering 
inference time spent interpreter ordered sequence  paper focus
upon developing algorithms minimizing inference time  elsewhere  ledeniov  
markovitch      a      b  present algorithms attempt reduce total execution
time 
values cost number solutions obtained various ways  exact
computation  estimation bounds  learning  let us assume moment
exists mechanism returns average cost number solutions
subgoal time   section   show control knowledge obtained
inductive learning 

    ordering independent sets subgoals

general subgoal ordering problem np hard  ullman   vardi         however 
special case ordering performed eciently  subgoals
  

filedeniov   markovitch

given set independent  i e  share free variables  section begins
definition subgoal dependence related concepts  show ordering algorithm
independent sets prove correctness 
      dependence subgoals

definition  let b sets subgoals  b called binding set    pair
subgoals directly dependent b  share free variable bound
subgoal b 
pair subgoals indirectly dependent respect b exists third
subgoal directly dependent one b  dependent  directly
indirectly  one b  pair subgoals independent b
dependent b  either directly indirectly   subgoal independent
b independent members b 
two subsets s  s  mutually independent binding set b
every pair subgoals  a   a    a    s  a    s   independent b 
entire set called independent binding set b subgoal pairs
independent b  called dependent otherwise  dependent set subgoals
called indivisible subgoal pairs dependent b  divisible otherwise 
divisibility partition b  dpart s   b   partition subsets
mutually independent indivisible b  except one subset contains
subgoals independent b  easy show dpart s   b  unique 
example  let s    fa  b x    c y    d x     e z    f  z  v    h w  g  respect
s  empty binding set  pair fb x    d x   g directly dependent  fb x    c y  g
indirectly dependent fb x    e z  g independent  represent set subgoals

graph  subgoals vertices directly dependent subgoals connected
edges  dependence equivalent connectivity indivisible subsets equivalent
connected components size greater    divisibility partition partition
graph connected components   lonely  vertices collected together 
special component  figure   shows example graph set s 
empty binding set  whole set divisible four mutually independent subsets 
subsets fe z    f  z  v  g fb x    c y    d x   g indivisible  elements
divisibility partition dpart s       shown dotted lines 
subgoal independent set  average cost number solutions
depend position within ordered sequence 
p
cost ajb  jsols b j cost a 
 
  cost a  
cost a jb   b sols b 
jsols b j
jsols b j

p

b sols b  jsols fajbg j

  jsols b j jsols fag j   jsols fag j 
jsols b j
case omit binding information write cost ai   instead cost ai jfa    ai  g  
nsols ai   instead nsols ai  jfa    ai  g 
practice  program rule bodies rarely feature independent sets literals  example
following clause  states children candy 
nsols a jb  

jsols b j

 

 

 

  

 

fithe divide and conquer subgoal ordering algorithm

fa 

b x   c y   d x y   e z   f z v   h w 


h w 

b x 

e z 
f z v 

g 

c y 

d x y 

figure    example graph representing set subgoals  directly dependent subgoals

connected edges  independent subgoals indivisible subsets equivalent
connected components  surrounded dashed lines   divisibility partition  under
empty binding set  shown dotted lines 
likes x y 

child x   candy y  

often  independent rule bodies appear written
program text  variables bound  initially dependent  rule bodies 
result clause head unification  example  rule
father x y 

male x   parent x y  

used reduce father abraham w   x bound abraham  rule body
becomes independent  rule bodies often become independent substitutions performed course inference process 
      algorithm ordering independent sets sorting

let s  ordered sub sequence subgoals  b set subgoals  denote
 
cn s   jb   nsols s  jb      
cost s  jb
name  cn  ects participation cost nsols definition  subsequence s  independent subgoals  binding information  jb   omitted 
together  average cost  average number solutions  cn value subgoal
called control values subgoal 
independent sets  exists ecient ordering algorithm  listed figure   
complexity algorithm o n    log n    o n   obtain control values n
subgoals  o n log n  perform sorting  knuth         enable division 
must define cost cost ai   always positive  define cost number
unifications performed  always cost ai      reasonable assumption
predicates rule body subgoals defined program   in case  least one
unification performed subgoal   similar algorithms proposed simon
kadane        natarajan        
example   let set independent subgoals fp  q  rg  following control values 
  

filedeniov   markovitch

algorithm  
let   fa   a        an g set subgoals 
 ai    
sort using cn ai     nsols
cost ai   key ai   return result 
figure    algorithm ordering subgoals sorting 
p q
r
cost      
 
nsols    
   
cn
           
compute costs possible orderings  using equation   

cost hp  q  ri                          
cost hp  r  q i                            
cost hq  p  ri                          
cost hq  r  pi                            
cost hr  p  q i                             
cost hr  q  pi                              
minimal ordering hr  p  q i  exactly ordering found much
quickly algorithm   set fp  q  rg  r smallest cn value        
goes p cn p       finally q cn q         
note sorting algorithm ects well known principle  best implementations generate and test programs obtained tests placed early possible
rule body generations late possible  naish      a   course 
cheap tests come first  expensive ones come last  one looks
cn measure  one quickly realizes tests put front  because nsols     
cn       generator subgoals move towards end  nsols      cn      
weakness  test first  principle fact every subgoal easily
tagged test generator  one subgoal nsols     another one nsols     
order obvious even without looking costs  because cn values
different signs   subgoals nsols      nsols     
decision simple  sorting cn correctly handle possible cases 
      correctness proof sorting algorithm independent sets

saw algorithm   found minimal ordering example    going
prove algorithm   always finds minimal ordering independent sets  first
show important lemma used discussion  lemma states
  

fithe divide and conquer subgoal ordering algorithm

substitution sub sequence cheaper permutation makes entire sequence
cheaper 

lemma  
let s    a  kb  kc    s      a  kb    kc    b  b    permutations one another  a 
either empty nsols a        

cost s      cost s         cost b   ja    cost b     ja   
cost s      cost s         cost b   ja    cost b     ja   

proof  a  c  empty 
cost s      cost s        cost a  kb  kc      cost a  kb    kc     


   
  cost a   j    nsols a   j  cost b   ja    nsols a  kb   j  cost c   ja  kb   
 

cost a j    nsols a   j  cost b     ja    nsols a  kb     j  cost c   ja  kb     

theorem    b  b    produce solution sets  hence  third terms
parentheses equal 





cost s      cost s       nsols a   j  cost b   ja    cost b     ja   
since nsols a         sign cost s      cost s      coincides sign cost b   ja   
cost b     ja   
a  c  empty  proof similar 
 
definition  let s    a  kb   kc  kb   kd  ordered sequence subgoals  a   c  d  may
empty sequences   respect s    pair hb      b   i

cn ordered  cn b    ja  cn b    ja  b   c 
 

cn inverted  cn b    ja    cn b    ja  b   c 
 

show two adjacent mutually independent sequences subgoals minimal
ordering must cn ordered 

lemma  
let s    a  kb    kb    kc    s      a  kb    kb    kc    b      b    mutually independent a   
let a  either empty nsols a        

cost s      cost s        cn b    ja    cn b    ja   
cost s      cost s        cn b    ja    cn b    ja   
  

filedeniov   markovitch

proof 
cost s      cost s     lemma
     cost b   kb    ja    cost b   kb    ja 
   cost b    ja    nsols b    ja  cost b    ja  b   
cost b     ja    nsols b     ja  cost b     ja  b 
indep fb      b   g
  
cost b     ja    nsols b     ja  cost b     ja   
cost b     ja    nsols b     ja  cost b     ja 
   nsols b    ja  cost b    ja    cost b    ja   
nsols b     ja  cost b     ja    cost b     ja 
cost b   ja     nsols b     ja      nsols b     ja     
  
 
cost b     ja 
cost b     ja 
   cn b    ja    cn b    ja 
 
 

cost s      cost s    

  

cn b     ja    cn b    ja    similar 

 

independent set  subgoal pairs independent  particular adjacent pairs 
so  minimal ordering independent set  adjacent subgoal pairs must cnordered  otherwise  cost sequence reduced transposition pair 
conclusion expressed following theorem 

theorem  
let independent set  let s  ordering   s  minimal iff subgoals
s  sorted non decreasing order cn values 

proof 

   let s  minimal ordering   s  contains cn inverted adjacent pair subgoals 
transposition pair reduces cost s   lemma     contradicting
minimality s   

   let s  ordering   whose subgoals sorted non decreasing order
cn  let s    minimal ordering   according item    s    sorted
cn  possible difference two sequences internal ordering
sub sequences equal cn values  ordering sub sequence
s  transformed ordering counterpart sub sequence s   
finite number transpositions adjacent subgoals  lemma    transpositions
adjacent independent subgoals equal cn values cannot change cost
sequence  therefore  cost s      cost s      s  minimal ordering  since s   
minimal  
 

corollary   algorithm   finds minimal ordering independent set subgoals 
  

fithe divide and conquer subgoal ordering algorithm

    ordering dependent sets subgoals

algorithm   guarantee finding minimal ordering given set subgoals
dependent  following proposition shows 

proposition   given set subgoals dependent  then 
   result algorithm   always defined 
   even result defined  always minimal ordering set 

proof  claims proved counter examples 
   show set subgoals cannot ordered sorting 
program 
control values 
a x  j  a x  jfb x  g b x  j  b x  jfa x  g
a c   
b c   
cost
 
 
 
 
a c   
b c   
nsols
 
 
 
 
 
 
cn
 
 
 
 

set fa x   b x g two possible orderings  ha x    b x  i hb x    a x  i 
orderings minimal cost  though neither one sorted cn  ordering
cn      first subgoal  cn     second one  sorting cn
impossible here  transpose subgoals  cn values changed 
pair becomes cn inverted again 
   show set subgoals ordered sorting  sorted ordering
minimal 
program 
control values 
a x  j  a x  jfb x  g b x  j  b x  jfa x  g
a c   
cost
 
 
 
 
a c   
 
 
 
 
nsols
b c   
 
 
cn
 
 
b c  
a c    a c   
 
 
let unordered set subgoals fa x   b x g  ordering hb x    a x  i sorted
cn  ha x    b x  i not  ha x    b x  i cheaper hb x    a x  i 
cost ha x    b x  i               

cost hb x    a x  i                

 
since sorting cannot guarantee minimal ordering dependent subgoals  consider alternative ordering algorithms  simplest algorithm checks every possible permutation set returns one minimal cost  listing algorithm
shown figure   
algorithm runs o  n   time  time takes compute control
values one subgoal  n number subgoals 
following observation help reduce ordering time expense additional space  ordered sequences constructed incrementally  adding subgoals
  

filedeniov   markovitch

algorithm  
permutation subgoals  find cost according equation   
store currently cheapest permutation update cheaper
one found 
finally  return cheapest permutation 

figure    algorithm subgoal ordering exhaustive check permutations 

algorithm  
order s  
let p  f g  n jsj
loop kn    tofi n

pk  np  kb fifi p fi   pk    b h  n p 
io
  p        cost p    cost p     
pk p    pk  fifi  p      pk    permutation p 
return single member pn  
figure    ordering algorithm checks permutations ordered prefixes 
right ends ordered prefixes  lemma    cheaper permutation prefix exists 
prefix cannot belong minimal ordering  ordering algorithm build
prefixes increasing lengths  step adding right end prefix one
subgoals appear already  subset keeping cheapest
permutation  if several permutations equal cost  one chosen  
listing algorithm shown figure    step k  pk  stores set prefixes
step k     extended every subgoal appearing already  pk pk   
pk subset subgoals represented cheapest permutation  obviously 
jpk j    nk   one prefix kept every subset size k   prefix length k     
n    k      possible continuations length k  size pk  follows 
 
k
n 
n
jpk  j    k n   n  k        n    k  n     
k        n  k       k  n   k   k         k  k   
prefix  compute cost time  permutation test completed
o n  time  using  example  trie structure  aho et al          subgoals
prefixes sorted lexicographically  step k takes o  n     k  nk    time 
  

fithe divide and conquer subgoal ordering algorithm

whole algorithm runs
n
x

k  

o  n     k  nk      o n  n    

n
x
n
k  

 k      o n  n      n   

  o n   makes o n   n   
smith genesereth        natarajan        point minimal ordered
sequence every adjacent pair subgoals must satisfy adjacency restriction 
general form restriction notation says two adjacent subgoals ak
ak   minimal ordering ha   a       ani must satisfy
cost hak   ak  i jfa    ak  g cost hak     ak i jfa    ak  g 
 

 

 

 

   

restriction follows immediately lemma    however  help find
locally minimal ordering  i e   ordering cannot improved transpositions
adjacent subgoals  possible adjacent subgoal pairs satisfy equation   
ordering still minimal  following example illustrates statement 

example   let unordered set fp x    q x    r x  g  predicates defined
following program 

p c   
q  c   
r c   
p c   f  q  c   
r c   
q  c   f 
f fails    unifications 
ordering hp x    q  x    r x  i satisfies adjacency restriction  equation    
cost q  x    r x   jp x      
cost p x    q  x   j      
cost q  x    p x   j       
cost r x    q  x   jp x      
minimal 

cost hp x    q x    r x  i      
cost hr x    p x    q  x  i      

find globally minimal ordering  seems beneficial combine prefix algorithm
adjacency restriction  prefix satisfy adjacency restriction 
cheaper permutation prefix  adjacency test performed faster
permutation test  since must consider two last subgoals prefix  nevertheless  number prefixes remaining step algorithm  
reduced  prefix rejected due violation adjacency restriction  would
rejected permutation test  furthermore  adjacency restriction test
fail  still perform permutation test avoid local minima  as
example     adjacency test succeeds least half cases  examine
prefix ha         ak   b   b  i  shall examine ha        ak   b    b i  adjacency test
cannot fail both  consequently  addition adjacency test halve total
running time ordering algorithm  leaving o n   n   worst case 
  

filedeniov   markovitch

smith genesereth propose performing best first search space ordered
prefixes  preferring prefixes lower cost  best first search combined
permutation test adjacency restriction  addition  subgoals
prefix independent binding  sorted  sorted result
concatenated prefix  lemma   corollary    produces cheapest
completion prefix  perform completion  need perform
adjacency permutation test  complete sequence minimal  never chosen
cheapest prefix  even added list prefixes  never extracted
therefrom  resulting algorithm shown figure   

algorithm  
order s  

let prefix list    prefix    rest
loop empty rest 
independent restjprefix 

let completion prefixksort by cn restjprefix 
insert by cost completion  prefix list 
else
loop subgoal   rest
let extension prefixksubgoal
adjacency restriction test extension 
permutation test extension 

insert by cost extension  prefix list 
prefix cheapest prefix list 
remove from list prefix  prefix list 
rest snprefix
return prefix

figure    algorithm subgoal ordering  incorporating ideas earlier researchers 
advantage using best first search avoids expanding prefixes whose cost
higher cost minimal ordering  policy used algorithm may 
however  suboptimal even harmful  often happens best completion
cheaper prefix much expensive best completion expensive prefix 
number solutions large  better place subgoals high costs closer
beginning ordering reduce number times cost multiplied 
example  let set fa x    b x  g  cost a x          cost b x      nsols a x   
  nsols b x         minimal ordering starts expensive prefix 
cost ha x    b x  i                 
  

fithe divide and conquer subgoal ordering algorithm

cost hb x    a x  i                 
many prefixes whose cost higher cost minimal ordering 
best first search saves time  number prefixes small  using best first
search increase total time  due need perform insertion prefix
priority queue  according cost 
sample run algorithm   shown later  in section      

   divide and conquer subgoal ordering algorithm

algorithm   presented section     ecient  applicable entire
set subgoals independent  algorithm   handle dependent set subgoals
inecient  algorithm    combination two  exploit independence subgoals better eciency  however  obtained benefit quite limited  section 
present divide and conquer  dac  algorithm  able exploit subgoal independence elaborate way  algorithm divides set subgoals smaller
subsets  orders subsets recursively combines results 

    divisibility trees subgoal sets

subsection define structure represents ways breaking subgoal
set independent parts  algorithm work traversing structure 
definition  let b sets subgoals  divisibility tree b  dtree s   b  
and or tree defined follows 
  leaf s   b 
  independent b
 
 

 
 
dtree s   b      or s   b  fdtree s n fbi g  b   fbi g  j bi   sg    indivisible b
 
  and s   b  fdtree si  b  j si   dpart s   b g    divisible b

node n tree dtree s   b   associated set subgoals  n   s 
associated binding set b n   b   root node   n     s   b n     b   
binding set root specified explicitly  assume empty  and nodes
or nodes define sets children 

 n   independent b n    n leaf 
 n   indivisible b n    n or node  subgoal bi  n  
defines child node whose set subgoals  n   n fbi g binding set
b n     fbi g  call bi binder generated child  note binding
set every node divisibility tree union binders indivisible
ancestors root s binding set 

 n   divisible b n    n and node  subset si
divisibility partition dpart s  n    b n    defines child node associated set
subgoals si binding set b n    divisibility partition defined section       
  

filedeniov   markovitch

   a  b  c x   d x   e x  
n  s n  
b n    

s n      a  b 
b n    

n 

s n      c x   d x   e x  

n  b n    

s n      d x   e x  
s n      c x   d x  
n 
n  b n      e x  
b n      c x   n 
s n      c x   e x  
b n      d x  

figure    divisibility tree fa  b  c x    d x    e x  g empty initial binding set  set
associated node n  divisible  represented and node  children
correspond divisibility subsets   one independent   n     fa  bg  one indivisible   n     fc x    d x    e x  g  n  or node  whose children correspond
three subgoals  each subgoal serves binder one children   sets  n   
 n     n    n   independent respective binding sets 
nodes leaves  assumed subgoals c x    d x   e x   bind x
result proof 

easy show divisibility tree set subgoals unique order
children node  figure   shows divisibility tree set fa  b  c x    d x    e x  g
empty initial binding set  associated sets binding sets written next
nodes 
following lemma expresses important property divisibility trees  subgoals
node independent rest subgoals binding set node 

lemma   let s  set subgoals  every node n dtree s       every
subgoal    n    every subgoal   s  n  s  n    b n     independent
b n   
proof  induction depth n divisibility tree 
inductive base  n root node  s  n  n   empty  exists 
inductive hypothesis  lemma holds   parent node n  
inductive step  let    n      s  n  s  n     b n        m   
lemma holds  thus either independent b m       m   
independent b m    independent b n   
since b m   b n    otherwise  dependent b m       m   
  

fithe divide and conquer subgoal ordering algorithm

and node  dependent b m   
belong element dpart s  m    b m        n    

contradiction 
or node    m   n  n    must binder n  
b n     b m     fy g   b n     contradiction again 
 
lemma relates subgoal independence inside divisibility trees  shall sometimes
need argue independence inside ordered sequences subgoals  following
corollary provides necessary connecting link 

corollary   let s  set subgoals  n node divisibility tree s   s 
ordering s   s    s   ks    b n   s    n   s      n   mutually
independent s   n  n   s   
proof  let    n      s   n  n    independent b n   
preceding lemma  since b n   s     independent s    every subgoal
 n   independent every subgoal s   ns  n   s    therefore   n   s   ns  n  
mutually independent s    

 

    valid orderings divisibility trees

aim ordering algorithm find minimal ordering given set subgoals 
construct orderings following divide and conquer policy  larger sets split
smaller ones  orderings smaller sets combined produce ordering
larger set  implement policy  perform post order traversal divisibility
tree corresponding given set subgoals empty initial binding set 
orderings child nodes combined produce ordering parent node  inner
order subgoals changed  smaller orderings consistent larger orderings 

definition  let g sets subgoals  ordering o  g g ordering
o  consistent  denoted cons o  g  o      order subgoals g o  g
o  same 

divide and conquer process described seems analogous merge sort  knuth 
       there  set numbers split two  or more  subsets  subset independently ordered sequence consistent global order  sequences
merged  possible use similar method subgoal ordering  assume set
subgoals partitioned two mutually independent subsets  b  build
algorithm that  given a  produces ordering consistent minimal ordering
  b  independently b  unfortunately  answer negative  ordering may
consistent minimal ordering   b  time consistent
minimal ordering   b  b     b  
example  let   fa  x    a  x  g  b    fbg  b    fdg control values
specified figure    single minimal ordering   b  ha  x    b  a  x  i 
single minimal ordering a b  hd  a  x    a  x  i  ordering consistent
minimal global orderings 
  

filedeniov   markovitch

program 
a  c   
a  c   
a  c   
a  c   
a  c  

b
b
d 

a  x  
d 

a  c   

control values 
a  x  j  a  x  jfa  x  g a  x  j  a  x  jfa  x  g b
cost
 
 
 
 
   
nsols
 
 
 
 
   

cost b  a  x    a  x                          
cost b  a  x    a  x                          
cost a  x    b  a  x                          
cost a  x    a  x    b                        
cost a  x    b  a  x                          
cost a  x    a  x    b                        

cost d  a  x    a  x                         
cost d  a  x    a  x                          
cost a  x    d  a  x                          
cost a  x    a  x    d                        
cost a  x    d  a  x                          
cost a  x    a  x    d                        

figure    show small program control values defines  compute costs
permutations sets fb  a  x    a  x  g fd  a  x    a  x  g  different orderings
fa  x    a  x  g consistent minimal orderings sets 
since  unlike case merge sort  cannot always identify single ordering
subset consistent minimal ordering whole set  algorithm deal
sets candidate orderings  requirement set contain least
one local ordering consistent global minimal ordering  local ordering exists
  local  ordering ordering set node   global  ordering ordering
set root   set called valid  following definition defines valid
sets formally  together several concepts 
definition  let s  set subgoals n node divisibility tree s  
recall  s   denotes set permutations  
   o     s   binder consistent o  n    s  n     denoted bcn  o  n   o     
consistent  subgoals b n   appear o  subgoals o  n  
bcn  o  n   o        o  b    b n      cons o  b ko  n   o    
o     s   binder consistent node n  denoted bcn  o      binderconsistent ordering  n   
bcn  o        o  n    s  n      bcn  o  n   o    
   o  n    s  n    min consistent o     s    denoted mcn s  o  n   o     
binder consistent  o  minimal 
mcn s  o  n   o       bcn  o  n   o      min o    s   
o  n    s  n    min consistent  denoted mcn s  o  n     min consistent
ordering s  
mcn s  o  n       o     s     mcn s  o  n   o    
 

 

 

 

 

  

fithe divide and conquer subgoal ordering algorithm

   ordering o  n    s  n    mc contradicting  min consistent 
mccn s  o  n       mcn s  o  n   
 

 

   two orderings o     o       s  n    mc equivalent  one min consistent
iff one is 
mcen s  o     o         mcn s  o        mcn s  o      
 

 

 

   set orderings cn  s  n    valid  cn contains min consistent ordering
 when least one min consistent ordering  n   exists  

v alidn s  cn        o  n     s  n      mcn s  o  n         o  n   cn   mcn s  o  n    
 

 

 

important property valid sets valid set orderings root

dtree s      must contain minimal ordering s   indeed  root  n     s  
consistency becomes identity  also  b n        binder consistency becomes

consistency  min consistency becomes minimality  since always exists minimal
ordering s    valid set orderings root must contain minimal ordering s  

    outline divide and conquer algorithm

propose algorithm based producing valid sets orderings  node
divisibility tree produces valid set associated set subgoals  passes
parent node  valid set root node found  compare costs
members  return cheapest one 
set orderings produced algorithm node n called candidate set
n   members called candidate orderings n   simply candidates  find
candidate set n   first consider set possible orderings  n  
consistent candidates n  s children  set called consistency set n  
given candidate sets n  s children  consistency set n defined uniquely 
candidate set n usually unique 
definition  let n node divisibility tree s   consistency set n   denoted
consset n    candidate set n   denoted candset n    defined recursively 

n leaf  consistency set contains permutations  n   
consset n      s  n    

n and node  child nodes n   n        nk   define consistency
set n set possible orderings  n   consistent candidates
n   n        nk  


n

consset n     o  n    s  n    fifi  i    k    o    candset ni    cons o    o  n    
  

filedeniov   markovitch

n or node  child node corresponding every binder    n  

na   consistency set n obtained adding binders first elements
candidates children 

n

consset n     ako  fifi    n    o    candset na   

candidate set n set orderings produced removing mc contradicting

mc equivalent orderings consistency set n   keeping least
one representative group mc equivalent orderings 
candset n   consset n   
 on    consset n   n candset n      mccn s  o  n    
h  

 o  n   candset n     mcen s  o  n   o  n     
 

 

 in words  ordering rejected  either mc contradicting  mcequivalent ordering  rejected  
two kinds orderings removed consset n   retaining validity  mc contradicting mc equivalent orderings  removal mccontradicting ordering cannot change number min consistent orderings set 
remove mc equivalent ordering  even min consistent  minconsistent ordering retained set  exists min consistent ordering set
node  candidate set must contain min consistent ordering  therefore
candidate set valid 
note algorithm treats or node  binder child always
placed first subgoal produced ordering node  higher levels inner
order subgoals ordering change  consistency preserved   therefore 
algorithm produce binder consistent orderings  explains choice
names  binder   binding set   subgoals b n   bind common variables
 n    since stand left global ordering algorithm
produces  particular   n   independent b n    subgoals b n  
bind shared free variables  n   
implement dpart function  use union find data structure  cormen 
leiserson    rivest        chapter      subgoals elements  indivisible sets
groups  beginning  every subgoal constitutes group itself  whenever
discover two subgoals share free variable bound subgoals binding set 
unite groups one  complete procedure  need way determine
variables bound given binding set  section     contains discussion
problem proposes practical solutions  finally  collect indivisible
subgoals separate group  operations implemented o nff n  n   amortized time  ff n  n  inverse ackermann function  considered o   
values n appear realistic logic programs  thus  whole process
finding divisibility partition n subgoals performed o n  average time 
formal listing ordering algorithm discussed shown figure    
algorithm specify explicitly candidate sets created consistency sets  complete algorithm  must provide three filtering procedures
  

fithe divide and conquer subgoal ordering algorithm

algorithm  
order s  

rootcandset

candidateset s      

return cheapest member rootcandset

candidateset s   b 
case  s b 

independent 
let conssetn  s  
let candsetn validleaffilter conssetn  
divisible 
let fs   s         sk g dpart s   b 
loop     k
let ci candidateset
 si   b 
n 

let conssetn
   s  n    j  i          k   o    ci   cons o  i  o  n  
let candsetn validandfilter conssetn   fs         sk g  fc         ck g 
indivisible 
loop  
let c  a  candidateset
n      s n foag  b   fag 
 
let c  a 
askoa j oa   c  a 
 
let conssetn
a s c  a 
let candsetn validorfilter conssetn  
return candsetn

figure     skeleton dac ordering algorithm  type node divisibility tree 

consistency set created refined validity filters  produced candidate
set root valid  hence  cheapest member minimal ordering given
set 

  validleaffilter   validandfilter validorfilter   trivially  define
null filters return sets receive unchanged  case candidate
set every node contain permutations subgoals  surely valid 
will  however  greatly increase ordering time  intention reduce sizes
candidate sets far possible  keeping valid 
following two subsections discuss filtering procedures  section     discusses detection mc contradicting orderings  section     discusses detection mcequivalent orderings  finally  section     present complete ordering algorithm 
incorporating filters skeleton algorithm   
  

filedeniov   markovitch

    detection mc contradicting orderings

subsection show sucient conditions ordering mc contradicting 
orderings safely discarded  leaving set orderings valid  reducing
size  subsection divided three parts  one type node divisibility
tree 
      detection mc contradicting orderings leaves

following lemma shows subgoals min consistent ordering leaf node must
sorted cn 

lemma  
let s  set subgoals  n leaf divisibility tree s   let o  n ordering
 n    subgoals o  n sorted cn b n    o  n mc contradicting 
proof  let o  ordering s   binder consistent o  n   show o  cannot
minimal ordering s   thus o  n min consistent 
o  n sorted cn  i e   contains adjacent cn inverted pair subgoals ha   a i 

 recall pair cn inverted first element larger cn value second
one   section         since o  consistent o  n   write o    x  ka  ky  ka kz   
x    y  z   possibly empty  sequences subgoals  since o  binder consistent
o  n   b n   x   
y  empty  a  a  adjacent o    since b n   x    a  a 
independent x    therefore  cost whole ordered sequence reduced
transposing a  a    according lemma    they adjacent  independent
cn inverted  
y  empty  subgoal y  belongs  n    since otherwise would appear
o  n a  a    corollary    y  mutually independent a  a 
x   

cn y   jx    cn a  jx  then  lemma    transposition y  a  produces
ordering lower cost 
otherwise  cn y   jx  cn a  jx    since pair ha   a i cn inverted  cn a  jx   
cn a  jx    hence  cn y   jx    cn a  jx    transposition y  a  reduces
cost  lemma   
either case  way reduce cost o    therefore  o  cannot minimal 
o  n mc contradicting 
 
      detection mc contradicting orderings and nodes

every member consistency set and node consistent combination
candidates child nodes  k child nodes  child ni sizes
subgoal candidate sets js  ni j   ni jcandset ni j   ci   total
number possible consistent orderings c  c       ck  nn  nn          nnk  k      fortunately 
orderings mc contradicting discarded candidate set 
 

 

 

  

 

fithe divide and conquer subgoal ordering algorithm

following lemma states forbidden insert subgoals two cn inverted
sub sequences  insertion takes place  ordering mc contradicting
safely discarded 

lemma  
let s  set subgoals  n node divisibility tree s    o  ordering
s   binder consistent ordering o  n  n   
o  n contains adjacent cn inverted pair sub sequences ha      a   i  a    a    appear

o  mixed subgoals  a    a    adjacent o    o 
minimal 

proof  let o  ordering s   binder consistent o  n  
o    x  ka   ky  ka   kz   
y  empty  subgoal y  belongs  n    since otherwise would stand
o  n a    a      o  binder consistent o  n   therefore  b n   x   
corollary    y  must mutually independent a    a    x    lemma  
transposition y  either a    a    reduces cost   exactly proof
lemma   
 

pair adjacent subgoals hai   ai  i cn inverted  previous lemma
attempt insert subgoals inside results non minimal global ordering  thereupon
may join ai ai   block ai i     participate larger block 
formal recursive definition block follows  convenience  consider separate
subgoals blocks length   

definition 

   sub sequence a  ordered sequence subgoals block either single
subgoal  a    a    ka     ha     a   i cn inverted pair blocks 
   block maximal  max block  sub sequence larger block 
   let n node divisibility tree  descendant n   o  n    s  n   
o     s  m    two consistent orderings nodes  block a  o 
violated o  n two adjacent subgoals a  adjacent o  n  in
words  alien subgoals inserted subgoals block  
   let n node  descendant  o  n    s  n    o     s  m    two
consistent orderings nodes  o  called projection o  n  
shall usually speak projection ordering child node 
concept max block similar maximal indivisible block introduced simon
kadane        context satisficing search  following corollary presents
result lemma   convenient way 

corollary   let n node divisibility tree  one children  o  n

ordering n   o  projection o  n   o  contains block
violated o  n   o  n mc contradicting 
  

filedeniov   markovitch

proof  let a  smallest block o  violated o  n   according definition
block  a    a    ka      a    a    violated o  n   pair ha     a   i

cn inverted  let o  ordering root node binder consistent o  n   o 
violates a    since o  n violates a    show o  n mc contradicting  must prove
o  minimal 
a   a    violated o    adjacent o    o 
minimal  lemma   
otherwise  a    a   violated o    without loss generality  let a    let a  
smallest sub block a    violated o    according definition block 
a      a    ka       pair ha      a    i cn inverted  a    a    violated
adjacent o    lemma    o  minimal 
 
example  control values subgoals shown figure    ha  x    a  x  i
block  since cn a  x   j                 cn a  x   jfa  x  g                one see
figure  insertion b inside block results non minimal ordering 
already noted above  consistency set and node large 
many orderings  however  blocks projections violated  discard
orderings mc contradicting  remaining orderings  block projection
violated  ordering represented sequence max blocks
projections  projection  max blocks stand cn ascending order  otherwise 
adjacent cn inverted pair blocks  larger block formed  contradicts
maximality   following lemma states  parent and node blocks
must ordered cn values  otherwise  ordering mc contradicting 
lemma   ordering and node contains adjacent cn inverted pair maxblocks projections children  ordering mc contradicting 
proof  blocks violated binder consistent global ordering  global
ordering minimal corollary    blocks violated  proof similar
proof lemma   
 
two sucient conditions detection mc contradicting orderings expressed
corollary   lemma   allow us reduce size candidate set significantly 
assume  example  set current node n split two mutually independent subsets whose candidates ha   a i hb   b i  one candidate child  
six possible orderings  n    shown figure     assume ha   a i
hb   b i blocks  cn ha   a i jb n     cn hb   b i jb n    six consistent orderings 
four       rejected due block violation  one remaining two  number   
puts blocks wrong order  so  one ordering  number    left candidate set n   even neither ha   a i hb   b i blocks  lemma   dictates unique
interleaving elements  max blocks   assuming cn a   jb n      cn a   jb n   fa g
   cn b  jb n      cn b  jb n   fb g 
 

 

      detection mc contradicting orderings or nodes

following lemma states block cheaper permutation  ordering
mc contradicting  and discarded candidate set  
  

fithe divide and conquer subgoal ordering algorithm

  

a  a 

b  b 

  

a  a 

b  b 

  

a  a 

  

b  b 

a  a 

b  b 

  

a  a 

b  b 

  

a  a 

b  b 

figure     possible ways combine ha   a  hb   b i

lemma   let n node divisibility tree s    o  n    s  n     let a  leading
block o  n   o  n   a  kr    permutation a    a      cost a     jb n    
cost a   jb n    o  n mc contradicting 
proof  let o     s    binder consistent o  n   a  violated o    o  cannot

minimal  corollary     otherwise  a  occupies continuous segment o   
replacement cheaper permutation reduces cost global ordering  lemma    
thus  o  cannot minimal 
 
check done leading blocks or nodes 

every ordering leaf node rejected due lemma   must

sorted cn  consequently  contains cn inverted adjacent pair subgoals 
block size   formed 

every ordering and node rejected due corollary  
lemma   must blocks unbroken cn ascending order  consequently 
new blocks cannot formed either 

or nodes  new blocks formed add binder first element
ordering  cn value binder greater subsequent block 
new blocks start binder  must perform permutation test
leading max block ordering 

    detection mc equivalent orderings

previous subsection presented sucient conditions detecting mc contradicting
orderings  subsection specify sucient conditions identifying mc equivalent
orderings  recall two orderings node mc equivalent minimal consistency
one implies minimal consistency other  finding sucient conditions
allow us eliminate orderings without loss validity candidate set  start
defining specialization mc equivalence relation  blockwise equivalence 
show orderings whose max blocks sorted cn blockwise equivalent 
therefore mc equivalent 
  

filedeniov   markovitch

definition  let s  set subgoals n node divisibility tree s   let
o    o    two orderings  n   equal number max blocks  let o 
ordering s    binder consistent o     blocks o    violated 
o  joo   ordering obtained replacing o  every max block o    max 

block o     preserving order max blocks  the i th max block o    replaced
i th max block o     
o    o    blockwise equivalent following condition holds  o    min consistent
o  iff o    min consistent o  joo    
easily seen  two orderings blockwise equivalent  mcequivalent  show transposition adjacent  mutually independent cn equal
max blocks ordering node produces blockwise equivalent ordering  proof
following lemma found appendix a 
 

 
 

lemma  
let s  set subgoals  n node divisibility tree s   o  n   q  ka    ka   kr 
ordering  n    a    a    max blocks  mutually independent cn equal
bindings b n     q    o  n blockwise equivalent o  n    q  ka    ka   kr   
corollary   sorted cn orderings leaf node blockwise equivalent 
example   n     fa  b  c  dg  cn a jb n          cn b  jb n     cn c  jb n         
cn d jb n          orderings ha  b  c  di ha  c  b  di blockwise equivalent 
remove candidate set one  but both  

corollary   orderings and node  blocks projections violated

adjacent max blocks different children projections cn ordered  blockwiseequivalent 

  b 
  c    d 
example  candidates children a  kb  c  kd    a 
max blocks  cn a   jb n          cn b   jb n   a    cn c   jb n         cn d   jb n   c        
orderings a  kb  kc  kd  a  kc  kb  kd  blockwise equivalent  remove
candidate set one  but both  
prove corollaries      note case one mentioned
orderings obtained finite number transpositions adjacent 
mutually independent cn equal max blocks  according lemma    transposition yields blockwise equivalent ordering  easy show blockwise equivalence
transitive 
following corollary states subgoals within block permuted  provided
cost block changed 

corollary   orderings node  identical cost preserving permutations subgoals inside blocks  blockwise equivalent 

proof corollary follows immediately lemma    example  set
fa x    b x  g  control values first counter example proposition   
  

fithe divide and conquer subgoal ordering algorithm

node set
mc contradicting
leaf independent subgoals sorted cn
  lemma  
contains violated blocks
divisible
  corollary  
max blocks sorted cn
  lemma  
leading max block
indivisible cheaper permutation
  lemma  

blockwise equivalent
subgoals sorted cn
  corollary  
max blocks violated 
sorted cn
  corollary  
cost preserving permutations
blocks
  corollary  

table    summary sucient conditions detection mc contradicting blockwiseequivalent orderings 

i e  cn a x  j     cn b x  j          cn a x  jfb x  g    cn b x  jfa x  g      
possible orderings  ha x    b x  i hb x    a x  i  two subgoals united block 
blocks equal cost  global ordering containing block ha x    b x  i 
replace block hb x    a x  i without changing total cost  therefore
ha x    b x  i blockwise equivalent hb x    a x  i 
sucient condition expressed corollary   checked or nodes 
since leaves and nodes new blocks created  argued section       

    revised ordering algorithm

two preceding subsections saw several sucient conditions mc contradiction
mc equivalence  summarized table    results permit us close gaps
algorithm   providing necessary validity filters  filter tests sucient
conditions mc contradiction mc equivalence every ordering consistency
set  sucient conditions hold  ordering rejected  formal listing
procedures shown figure    
generate and test approach described served us well methodological
purposes  obviously practical computational limitations  example 
independent set size n  algorithm creates n  orderings  rejects n     
keeps one  process takes o n  n  time produces ordering
sorted cn  result could obtained o n log n  time  single
sorting  so  instead uncontrolled creation orderings selective rejection  want
perform selective creation orderings  words  want revise algorithm
deal directly candidate sets  instead generating large consistency sets  revised
algorithm produces candidate set node n follows 
n leaf  subgoals  n   sorted cn bindings b n   
produced ordering sole candidate n  
n and node  combination children s candidates candidate n created  max blocks children s candidates ordered
  

filedeniov   markovitch

validleaffilter conssetn  
let candsetn  
loop o  n   conssetn

o  n sorted cn
o  n    candsetn sorted cn
candsetn candsetn   fo  n g
return candsetn

validandfilter conssetn   fs         sk g  fc         ck g 
let candsetn  
loop o  n   conssetn

loop     k
let o  projection o  n si
 i o    ci
max blocks o   s violated o  n  
max blocks o   s ordered cn o  n  
o  n    candsetn consistent o  i s 
candsetn candsetn   fo  n g
return candsetn

validorfilter conssetn  
let candsetn  
loop o  n   conssetn

o  n start block cheaper permutation 
o  n    candsetn   identical o  n
cost preserving permutations blocks 
candsetn candsetn   fo  n g
return candsetn

figure     three filter procedures convert consistency set candidate set  together
algorithm    form complete ordering algorithm  eciency
algorithm improved  shall see algorithm   

cn  candidate produced merging  moving parallel candidates
children extracting max blocks minimal cn 

n or node  candidate child ordering n created
adding binder left end child candidate  results creation
block cheaper permutation  ordering rejected  otherwise 
added candidate set  suces check leading max block 
  

fithe divide and conquer subgoal ordering algorithm

note revised algorithm include test cost preserving permutations
blocks different orderings  expressed corollary     high expense
test 
revised algorithm described contains manipulations blocks  purpose  need easy ecient way detect blocks orderings  since
permit block violation  by corollary     unite subgoals max block
one entity  treat ordinary subgoal  procedure joining subgoals
blocks called folding  resulting sequence max blocks   folded sequence 
subgoals folded block  need unfold block back separate
subgoals  upper levels tree  subgoals joined block  unless
block violated  unfolding operation carried returning
cheapest ordering set  of root node   candidate sets nodes
defined sets folded orderings 
already stated  new blocks created candidates or nodes 
binder added first element ordering  cn value binder
greater cn value first max block child projection  therefore 
revised algorithm build new blocks start binder  max blocks
rest ordering remain child s candidate  first try make block
binder first max block child s candidate  cn ordered 
stop folding  cn inverted  unite larger block  try
unite second max block child s candidate  on  produced
folded ordering contains maximal blocks  first block maximal  since could
expand right  blocks maximal  since maximal
child s candidate 
lemma   states ordering whose leading max block cheaper permutation
mc contradicting  one way detect block exhaustively test permutations  computing comparing costs  procedure expensive  instead 
revised algorithm employ adjacency restriction test  equation     test
applied every pair adjacent subgoals block  adjacent pair cheaper
transposition  whole block cheaper permutation  lemma    since blocks
created concatenation smaller blocks  suces test adjacency restriction
points blocks joined  for adjacent pairs subgoals  tests
performed lower levels  smaller blocks formed   adjacency restriction test guarantee detection not cheapest permutations  as shown
example     detects blocks many cases  works linear time 
final version dac subgoal ordering algorithm presented figure    
complete correctness proof algorithm   found appendix b 

    sample run comparison ordering algorithms
illustrate work dac algorithm  using subgoal set shown figure   
s    fa  b  c x    d x    e x  g  proving c x    d x   e x    assume x
bound  let control values subgoals shown table    column c free 
contains control values subgoal c x   x yet bound preceding
subgoals  i e   binding set contain d x   e x     column c bound 
  

filedeniov   markovitch

algorithm     divide and conquer algorithm
order s  
let rootcandset candidateset s      
return unfold the cheapest element rootcandset 
candidateset s   b 
let fs   s         sk g dpart s   b 
case

k      shared vars s        s independent b  
return fsort by cn s   b g
k      shared vars s         s indivisible b  
loop  
let c  a  candidateset
 s fin fag  b   faog 
n
 
 
let c  a 
fold
 akoa   b  fifi o    c  a 

return a s c   a 
k      s divisible b  
loop     k
let cin candidateset si   b 
return merge fo     o           o  k g  b 

fifi

o      c   o      c         o  k   ck

merge fo     o           o  k g  b 

let min cn candidate o  minimizes cn first max block o    jb     k
let min cn block first max block min cn candidate 
remove first max block min cn candidate 
return min cn blockkmerge fo     o           o  k g  b   min cn block 

fold ha   a       ak i  b 
k   cn a  jb cn a  jbka
return ha   a       ak

 

else
last subgoal a  first subgoal a  satisfy adjacency restriction

let a  block a    a  
return fold ha    a       ak i  b 
else return  

figure     revised version dac algorithm  candidate sets built selectively 

without explicit creation consistency sets  candidate sets contain folded orderings 
unfolding performed returned global ordering  code
unfold sort by cn procedures listed  due straightforwardness 
merging procedure recursively extracts given folded orderings max blocks
minimal cn  folding procedure joins two leading blocks larger one 
long cn inverted 
  

fithe divide and conquer subgoal ordering algorithm


b c free  c bound  d free  d bound  e free  e bound 
cost
    
 
 
  
 
  
  
nsols      
 
   
 
 
   
   
cn
             
    
   
 
     
     
table    control values sample runs ordering algorithms 
contains cost values c x   d x   e x   already bound x   example 
cost c x   jfa d x  g   cost c bound        dac algorithm traverses divisibility tree
s  follows   the names nodes figure    
   root divisibility tree  n   empty binding set b n       
associated subgoal set  n     fa  b  c x    d x    e x  g  set  n   partitioned two subsets b n    one independent   fa  bg  one indivisible  
fc x    d x    e x  g  two subsets correspond two child nodes andnode n   n  n   empty binding sets 
    n   independent b n    therefore  n  leaf  sole candidate
ordering obtained sorting subgoals cn b n    cn a j          
cn b j         thus candset n     fha  big 
    n   indivisible b n    therefore  n  or node  three children
created   one subgoal  n   serving binder 

binder c x   yields child node n  associated set  n     fd x    e x  g
binding set b n     fc x  g   n   independent b n    there 

fore  n  leaf  sole candidate obtained sorting subgoals
cn 
cn d x   jfc x g      cn e x   jfc x  g         
thus  candidate n  he x    d x  i 
binder d x   yields child node n  associated set  n     fc x    e x  g
binding set b n     fd x  g   n   independent b n   
sorting cn produces candidate hc x    e x  i 
binder e x   yields child node n  associated set  n     fc x    d x  g
binding set b n     fe x  g   n   independent b n   
sorting cn produces candidate hc x    d x  i 
   add binder corresponding child s candidate obtain three orderings or node n   hc x    e x    d x  i  hd x    c x    e x  i  he x    c x    d x  i 
   perform folding orderings check violations adjacency
restriction  order determine whether block cheaper permutation 
  

filedeniov   markovitch

first  perform folding hc x    e x    d x  i  pair hc x    e x  i
cn inverted  cn c x   j         cn e x   jfc x  g          thus unite
block  block pass adjacency restriction test  equation    
cost hc x    e x  i j                  
cost he x    c x  i j                    

therefore  ordering mc contradicting discarded 
perform folding hd x    c x    e x  i  cn d x   j         cn c x   jfd x  g  
      pair cn inverted  unite block  block
pass adjacency restriction test 
cost hd x    c x  i j                  
cost hc x    d x  i j                 

ordering rejected too  even folding finished  continue
folding process  shall see subgoal e x   must added
block  since cn hd x    c x  i j                       cn e x   jhd x   c x  i  
      
perform folding he x    c x    d x  i  cn e x   j           cn c x   jfe x g
        pair cn inverted  form block ec x     he x    c x  i 
passes adjacency restriction test 
cost he x    c x  i j                    
cost hc x    e x  i j                  

compute control values new block 
cost ec x   j                   
nsols ec x   j                 
cn ec x   j                         
cn d x   jfec x  g      thus pair hec x    d x  i cn ordered  folding
needed  add folded candidate hec x    d x  i candidate set
n  

   perform merging candidate set n   fha  big  candidate set
n   fhec x    d x  ig  resulting sequence max blocks must sorted cn 

cn a           cn b         cn ec x   j                cn d x   jfec x  g     
merged ordering  hec x    a  d x    bi  added candidate set n  
   compare costs candidates n   output cheapest one  case 
one candidate  hec x    a  d x    bi  algorithm returns candidate
unfolded  he x    c x    a  d x    bi 
  

fithe divide and conquer subgoal ordering algorithm

extension completion
cost
h ai
  
hbi
 
hc x  i
 
hd x  i
  
he x  i
  
hbi
hb  ai
adjacency restriction test fails
hb  c x  i
            
hb  d x  i
             
hb  e x  i
adjacency restriction test fails
hc x  i
hc x    e x    a  d x    bi
                                         
hai
ha  bi
               
ha  c x  i
               
ha  d x  i
                
ha  e x  i
adjacency restriction test fails
hd x  i
hd x    c x    e x    a  bi                                             
ha  bi
ha  b  c x  i
                 
ha  b  d x  i
                  
ha  b  e x  i
adjacency restriction test fails
ha  c x  i
ha  c x    e x    d x    bi
                                    
hb  c x  i
hb  c x    e x    a  d x  i
                                     
ha  d x  i
ha  d x    c x    e x    bi
                                      
he x  i
he x    c x    a  d x    bi                                            
ha  b  c x  i
ha  b  c x    e x    d x  i
                               
hb  d x  i
hb  d x    c x    e x    ai
                                    
he x    c x    a  d x    bi complete ordering

 

cheapest prefix

table    trace sample run algorithm   set figure    left column shows
cheapest prefix extracted list step  middle column   extensions
completions added list  right column   associated costs 

comparison  show task performed algorithm   
algorithm maintains list prefixes  sorted cost values  initially contains
empty sequence  step algorithm extracts list cheapest element 
adds list extensions completions prefix  extensions created
set remaining subgoals dependent  appending remaining subgoals
end prefix  completions created set remaining subgoals
independent  sorting appending entire resulting sequence prefix 
extension added list adjacency restriction test succeeds two
last subgoals  make list operations faster  implement heap structure
 cormen et al         
trace algorithm   set s  shown table    left column shows
cheapest prefix extracted list step  middle column   extensions
completions added list  right column   associated costs 
looks dac algorithm orders given set s  eciently algorithm   
compare several discrete measurements show this  example  algorithm  
  

filedeniov   markovitch

p  x  x  x  x  
p  x  x  x  x  
p  x  x  x  x   
p  x  x  x  x  
p  x  x  x  x   

figure     example worst case ordering  variables initially free  every

subset subgoals indivisible binding rest subgoals  overall
complexity ordering algorithm   o n   

performs   sorting sessions  one   elements  algorithm   performs   sortings
  elements    sortings   elements  adjacency restriction tested  
times algorithm       times algorithm    algorithm   creates totally   different
ordered sub sequences  total length     algorithm   creates    ordered prefixes 
total length    

    complexity analysis

algorithm   algorithm   find minimal ordering  sort independent
subsets subgoals whenever possible  algorithm    however  offers several advantages due
divide and conquer strategy 
let n number subgoals initial set  convenience  assume
time computing control values one subgoal o     otherwise  time
  complexities must multiplied   worst case complexity
algorithm   o n    figure    shows example case n      set
every two subgoals share variable appear subgoals  thus 
subgoals cannot bind it  set root indivisible  matter binder
chosen  sets children indivisible  so  child root  must select
every remaining subgoal binder  on  overall complexity execution
o n    indeed worst case complexity  presence and nodes tree
reduce it 
note even n small  complex rule body  n    free variables
improbable practical programs  also  worst case complexity reduced
o n   n    move divisibility trees divisibility graphs  dags  
identical nodes divisibility tree  same subgoal set  binding set  represented
single vertex  equivalence test tree nodes performed eciently
help trie structures  aho et al          subgoals sorted lexicographically 
let n subgoals  v shared variables appearing subgoals 
already noted section      partition subgoals subsets performed
  

fithe divide and conquer subgoal ordering algorithm

o n  average time  using union find data structure  cormen et al         chapter     

worst possible case  and nodes divisibility tree  apart
root node  whose set divisible dependent set size independent set
size n   m   overall complexity dac algorithm case
 n  m  v     o n 
  divisibility partition
  o  nq  m  log n   m  
  ordering independent subgoals
k
  o   i  
ordering dependent subgoals
q   m   mi    i  log m   k    
  o m q ki  
  folding
    m   i  
  o n ki  
  merging
k maximal possible number bindings performed remaining subset
independent  assume every subgoal binds free variables  which happens
frequently practical logic programs   k   minfv     g  otherwise k       
k equal maximal number or nodes path root leaf
divisibility tree  therefore  height divisibility tree limited k      actually 
tree shallower  since binders bind one shared variable each 
means number shared variables decrease   ornode  simplify formula several common cases  k small
abovementioned assumption holds  every subgoal binds free variables
proof terminates  
v   n   n  m  v    o n mv   n log n 
v n   n  m  v    o n mm     n log n 
v   n   n  m  v    o nv   log n 
v   n   n  m  v    o n m    n log n 
generally  small number v shared variables  complexity algorithm
roughly bounded o nv   log n   particular  subgoals independent  v      
complexity o n log n   practical cases  number shared free variables
rule body relatively small  every subgoal binds free variables  therefore 
algorithm polynomial complexity  note even rule body program
text contains many free variables  usually become bound rule head
unification performed  i e   start ordering instantiated body  

   learning control knowledge ordering

ordering algorithms described previous sections assume availability correct
values average cost number solutions various predicates various argument
bindings  section discuss control knowledge obtained learning 
instead static exploration program text  debray   lin        etzioni        
adopt approach markovitch scott        learn control knowledge
collecting statistics literals proved past  learning
performed on line off line  latter case  ordering system first works
training set queries  collecting statistics  training set built
  

filedeniov   markovitch

distribution user queries seen past  assume distribution queries
received system change significantly time  hence  past distribution
directs system learn relevant knowledge future queries 
proving queries  learning component accumulates information control values  average cost number solutions  various literals  storing separate
value literal practical  two reasons  first large space required
approach  second lack generalization  ordering algorithm quite
likely encounter literals seen before  whose control values
unknown  recall transformed equation   equation    moved
control values single literals average control values sets literals  obtain
precise averages sets  still needed control values individual literals  here 
take different approach  learning using control values general
classes literals  estimated cost  nsols  value class defined average
real cost  nsols  value examples class proved past 
refined classes  smaller variance real control values inside
class  precise cost nsols estimations classes assign members  better orderings obtain  one easy way define classes modes
binding patterns  debray   warren        ullman   vardi         argument denote whether free bound  example  predicate father
possible classes father free free   father bound free   father free bound 
father bound bound   now  receive literal  for example  father abraham x   
easily determine binding pattern  in case  father bound free   retrieve control information stored class  course  find binding pattern
subgoal given binding set  need method determine variables
bound subgoals binding set  problem arose dpart computation
 section       shall discuss practical ways solve problem section     
purpose class definition use regression trees   type decision tree
classifies continuous numeric values discrete classes  breiman et al        
quinlan         two separate regression trees stored every program predicate 
one cost values  one nsols  tests tree nodes defined
various ways  use test  is argument bound    classes literals
defined regression trees coincide classes defined binding patterns 
apply sophisticated tests  syntactic  e g    is third argument term
functor f    semantic  e g    is third argument female     leads
refined classes better estimations  possible regression tree estimating
number solutions predicate father shown figure    
semantic tests arguments require logic inference  in example figure   
  invoking predicate female first argument literal   therefore  must
ecient possible  otherwise retrieval control values take much time 
problem ecient learning control values considered elsewhere  ledeniov
  markovitch      a  
several researchers applied machine learning techniques accelerating logic inference
 cohen        dejong   mooney        langley        markovitch   scott        minton 
      mitchell  keller    kedar cabelli        mooney   zelle        prieditis   mostow 
       works used explanation based learning generalized caching tech  

fithe divide and conquer subgoal ordering algorithm

average        
test  bound arg   

yes



average     
test  female arg   

yes
average     

average   
test  bound arg   



yes

average     
test  bound arg   

average      

yes



average        

average     


average    

figure     regression tree estimates number solutions father arg  arg   
niques avoid repeated computation  others utilized acquired knowledge problem clause selection  none works  however  dealt problem subgoal
reordering 

   experimentation
test effectiveness ordering algorithm  experimented various
domains  compared performance ordering algorithms  experiments
performed randomly created artificial domains  tested performance
system several real domains 

    experimental methodology
experiments described consist training session  followed testing session 
training testing sets queries randomly drawn fixed distribution 
training session collect control knowledge literal classes  testing session
prove queries testing set using different ordering algorithms  compare
performance using various measurements 
goal ordering reduce time spent prolog interpreter
proves queries testing set  time sum time spent ordering
procedure  ordering time  time spent interpreter  inference time   since
cpu time known sensitive irrelevant factors hardware  software
programming quality  show two alternative discrete measurements  total
number clause unifications  total number clause reductions performed 
number reductions ects size proof tree 
experimentation used new version lassy system  markovitch   scott 
       using regression trees learning  ordering algorithms discussed
paper 
  

filedeniov   markovitch

    experiments artificial domains

order ensure statistical significance results comparing different ordering
algorithms  experimented many different domains  purpose  created
set     artificial domains  small fixed set predicates  random
number clauses predicate  random rule lengths  predicates
rule bodies  arguments rule heads bodies randomly drawn fixed
distributions  domain training testing sets  these two sets
intersect  
training examples fed system learning phase  better
estimations control values produces  hand  learning time must limited  seeing certain number training examples  new examples bring
much new information  additional learning becomes wasteful  experimentally
built learning curve shows dependence quality control knowledge
amount training  curve suggests control values learned
approximately     literals  significant improvement quality ordering
new training examples  therefore  subsequent experiments stopped training
    cost values learned  training time always small  one learned cost
value corresponds complete proof literal  thus  every predicate program
four clauses define it      cost values learned      unifications 
small time 
control values learned means regression trees  section     simple
syntactic tests checked whether argument bound whether argument term certain functor  the list functors created automatically
domain loaded   however  shall see  even simple tests succeeded
making good estimations control values 
tested following ordering methods 
random  subgoals permuted randomly control knowledge
used 
algorithm    building ordered prefixes  prefixes permutation
one another  cheapest one retained 
algorithm  a  algorithm    best first search method used define
next processed prefix  similar algorithm used lassy system markovitch
scott        
algorithm  b  algorithm  a  adjacency restriction test added 
similar algorithm described smith genesereth        
algorithm    algorithm  b  whenever subgoals
prefix independent  under binding prefix   sorted result
appended prefix one unit 
algorithm    dac algorithm 
experiments always used bubble sort algorithm sort literals independent sets  algorithm easy implement  known ecient small
  

fithe divide and conquer subgoal ordering algorithm

ordering
method
random
algorithm  
algorithm   a
algorithm   b
algorithm  
algorithm  

unifications reductions ordering inference total ord time
time
time time reductions
        
        
      
                     
       
              
                  
       
              
                  
       
              
                  
       
      
      
                 
       
      
      
                  

table    effect ordering tree sizes cpu time  mean results     artificial
domains  

sets  elements already ordered  nearly ordered  practice  programmers
order program rules optimally  sorting stops early 
since non deterministic nature random method introduces additional noise 
performed artificial domain    experiments method  table
presents average values measurements 
table   shows obtained results     domains  rows correspond ordering
methods used  columns measurements taken  rightmost column shows
ratio ordering time number reductions performed  ects
average ordering time one rule body  inference time measured separately 
set difference total time ordering time 
several observations made 
   using dac ordering algorithm helps reduce total time proving testing
set queries factor     compared random ordering  inference time
reduced factor    
   deterministic ordering methods similar number unifications reductions 
similar inference time  predictable  since find minimal orderings 
small uctuations values explained fact rules
several minimal orderings existing control knowledge  different ordering
algorithms select different minimal orderings  since control knowledge
absolutely precise  real execution costs orderings may different 
leads differences  random ordering method builds much larger trees 
larger inference time 
   compare performance deterministic algorithms          see
dac algorithm performs much better algorithms build ordered
prefixes  latter ones  ordering expensive  smaller inference time
cannot compensate increase ordering time  algorithm    combination
several ideas previous researchers  total time comparable time
random method  though still greater  
  

filedeniov   markovitch

   may seem strange simple random ordering method larger ordering time
sophisticated algorithm    explain this  note random method
creates much larger proof trees  on average   therefore number ordered rules
increases  even cheap operations  random ordering rule  sum
considerable time  average time spent ordering one rule shown
last column table    value small random method 

    experiments real domains

tested ordering algorithm real domains obtained various sources 
domains allow us compare orderings performed algorithm orderings performed human programmers 
following domains used 
moral reasoner  taken machine learning repository university
california  irvine    domain qualitatively simulates moral reasoning  whether
person considered guilty  given various aspects character
crime performed 
depth first planner  program       book  the art prolog   sterling
  shapiro         program implements simple planner blocks world 
biblical family database  database similar described example   
appletalk  domain describing physical layout local computer network
 markovitch        
benchmark  prolog benchmark taken cmu artificial intelligence repository   predicate names informative  example program
manual ordering dicult 
slow reverse  another benchmark program source 
geography  benchmark program cmu repository  domain
contains many geographical facts countries 
table   shows results obtained  ordering used dac algorithm  literal
classes defined binding patterns  seen dac algorithm able speed
logic inference real domains well  note slow reverse domain
programmer s ordering already optimal  thus  applying ordering algorithm
reduce tree sizes  still  overhead ordering significant 

   discussion

concluding section discuss several issues concerning practical implementation
dac algorithm several ways increase eciency  survey
related areas logic programming propose use dac algorithm there 
   url  http   www ics uci edu  mlearn mlrepository html
   url  http   www cs cmu edu afs cs cmu edu project ai repository ai html air html

  

fithe divide and conquer subgoal ordering algorithm

domain

without ordering
ordering
gain ratio
unifications seconds unifications seconds  time time 
moral reasoner
            
           
   
depth first planner
           
          
    
biblical family
             
            
   
appletalk
               
             
   
benchmark
            
            
   
slow reverse
          
          
   
geography
             
            
   
table    experiments real domains 

    practical issues

subsection would address several issues related implementation
applications dac algorithm 
computation dpart function  section        requires procedure computing set variables bound given binding set subgoals  procedure
needed computing control values  section     several possible ways
implement procedure  example 
   easiest way assume every subgoal binds variables appearing
arguments  simplistic assumption sucient many domains  especially
database oriented ones  however  appropriate logic programs used
manipulate complex data structures containing free variables  such difference
lists   assumption used experiments described section   
   dialects prolog logic languages support mode declarations provided
user  somogyi et al       b   declarations available  easy
infer binding status variable upon exiting subgoal 
   even user supply enough mode declarations  often
inferred structure program means static analysis  debray  
warren         note  however  pointed somogyi et al       b  
no one yet demonstrated mode inference algorithm guaranteed find
accurate mode information every predicate program 
   learn sets variables bound classes subgoals using methods similar
described section   learning control values 
several researchers advocate user declarations available  permitted  modes 
declarations elegantly incorporated algorithm prune branches violate
available modes  fix binder or node  compute set variables
become bound it  results violation available mode one
subgoals corresponding child  whole subtree child pruned  note
detect violations even mode subgoal partially unknown
  

filedeniov   markovitch

candidateset s   b 
let fs   s         sk g dpart s   b 
case

   
k      shared vars s         s indivisible b  
loop  
b   fag violate available modes
subgoal n fag

let c  a  candidateset
 s fin fag  b   faog 
n
 
let c  a 
fold ako  a  b  fifi o    c  a 
else let
c   a     don t enter branch 

return a s c    a 

figure     changes algorithm   make use available mode declarations 
rest algorithm remains unchanged 

moment  example  available modes require first argument
unbound  binding argument or node binder trigger pruning 
even binding status arguments yet known  figure    shows
algorithm   changed order incorporate declarations available modes 
correctness requirement treated similar manner  candidate ordering
rejected whenever see violates requirement 
experiments described section   performed prolog interpreter 
possible combine dac algorithm prolog compiler  several ways
achieve goal  one way allow compiler insert code on line learning 
compiled code contain procedures accumulating control values dac
algorithm  alternatively  off line learning implemented  training part
compilation process 
another method combining algorithm existing prolog compilers use
program transformation  process transformed program standard
compiler  elsewhere  ledeniov   markovitch      a  describe method classifying
orderings produced dac algorithm  rule build classification tree 
classes different orderings rule body  tests applied
rule head arguments  type tests described section   learning
control values  figure    shows two examples trees 
given classification tree  write set prolog rules  rule
head original rule  body built tests path
tree root leaf node followed ordering leaf  example  second
tree figure    yields following set rules 
  

fithe divide and conquer subgoal ordering algorithm

classification tree rule
uncle x y  example   

nonvar y   
yes



 parent z y  brother z x  
 brother z x  parent z y  
nonvar x   
yes

possible classification tree rule
head x y 

male x   

p  x   p  y   p  x y  

yes
 p  x  p  x y  p  y  



nonvar y   



yes



 p  y  p  x y  p  x  

 p  x  p  y  p  x y  

 p  x y  p  x  p  y  

figure     examples classification trees learn rule body orderings 

head x y 
head x y 
head x y 
head x y 

nonvar x   male x   p  x   p  x y   p  y  
nonvar x   not male x    p  x   p  y   p  x y  
var x   nonvar y   p  y   p  x y   p  x  
var x   var y   p  x y   p  x   p  y  

table   see dac algorithm helped reduce inference
time factor     total time reduced factor     difference
caused additional computation ordering procedure  danger
benefit obtained ordering outweighed cost ordering process 
manifestation so called utility problem  minton        markovitch   scott 
       systems strongly moded  such mercury   somogyi et al       b 
employ dac algorithm statically compilation time one available modes 
thus reducing run time ordering time zero  mode based approach performs
syntactic tests subgoal arguments  classification tree method  described above 
generalization mode based approach  allowing semantic tests well 
due insucient learning experience lack meaningful semantic tests  quite
possible classification trees contain leaves large degrees error  cases
still need perform ordering dynamically  reduce harmfulness utility
problem case dynamic ordering  use cost sensitive variation dac
algorithm  ledeniov   markovitch      a      b   modified algorithm deals
problem explicit reasoning economy control process  algorithm
anytime  is  stopped moment return currently best ordering
 boddy   dean         learn resource investment function compute expected
return speedup time additional control time  function used determine
stopping condition anytime procedure  implemented framework
found indeed succeeded reducing ordering time  without significant increase
inference time 
  

filedeniov   markovitch

    relationship works

work described paper continuation line research initiated smith
genesereth        continued natarajan        markovitch scott        
line research aims finding ecient ordering set subgoals 
search minimal cost ordering based cost analysis utilizes available information
cost number of solutions individual subgoals 
smith genesereth        performed exhaustive search space
permutations given set subgoals  using adjacency restriction reduce
size search space  equation     restriction applied pairs adjacent
subgoals global ordering entire set  applied independent set
subgoals  adjacency restriction easily transformed sorting restriction 
subgoals minimal ordering must sorted cn values  natarajan        arrived
conclusion presented ecient ordering algorithm independent sets 
dac algorithm uses subgoal dependence break set smaller subsets  independent subsets sorted  dependent subsets recursively ordered  resulting
orderings merged using generalization adjacency restriction manipulates
blocks subgoals  therefore dac algorithm generalization algorithms 
last decade  significant research effort went static analysis  sa 
logic programs  three types sa exploited dac algorithm
reduce ordering time 
major part sa research deals program termination  de schreye   decorte 
       dac algorithm solves termination problem  special case eciency
problem  it always finds terminating ordering  orderings exist   learning 
set limits computation resources available subgoal execution  subgoal
non terminating  in certain mode   learning module associate high cost
particular mode  consequently  dac algorithm allow orderings
mode subgoal  nevertheless  use static termination analysis
mandatory proper operation dac algorithm  exploit analysis
increase eciency learning process ordering process 
learning  limit set computation resources devoted execution
subgoal must high  increase reliability cost estimation  however 
high limit lead significant increase learning time many subgoals
non terminating  termination information obtained sa available  use
avoid entering infinite branches proof trees  ordering  termination information
serve reduce size space orderings searched algorithm  termination
information comes form allowed modes  somogyi et al       b   orderings
violate modes filtered out  modified algorithm shown figure    
termination information comes form partial order subgoals  orderings
violate partial order filtered similar manner 
second type sa research combined dac algorithm correctness analysis  program tested specifications given user 
folon environment  henrard   le charlier        designed support
methodology logic program construction aims reconciling declarative semantics ecient implementation  deville         construction process starts
  

fithe divide and conquer subgoal ordering algorithm

specification  converts logic description finally  prolog program 
rules program correct respect initial specification  system performs transformations reordering literals clause  adding type checking
literals on  de boeck le charlier        mention reordering 
specify ordering algorithm different simple generate and test method  cortesi 
le charlier  rossi        present analyzer verifying correctness prolog
program relative specification provides list input output annotations
arguments parameters used establish program termination  again 
ordering algorithm given explicitly  purpose dac algorithm complementary
purpose folon  could serve auxiliary aid make resulting prolog
program ecient 
recently  mercury language developed university melbourne  somogyi
et al       a      b   mercury strongly typed strongly moded language  type
mode declarations supplied programmer  though recent releases
mercury system already support partial inference types modes   somogyi et al  
    a   compiler checks mode declarations predicates satisfied 
necessary  reorders subgoals rule body ensure mode correctness  and rejects
program neither ordering satisfies mode declaration constraints   compiler
performs reordering  consider eciency issue  often happens
several orderings rule body satisfy mode declaration constraints  cases
mercury compiler could call static version dac algorithm select
ecient ordering  another alternative augment dac algorithm mode declaration
checks  shown figure    
note mercury purely declarative logic programming language  therefore
suitable subgoal reordering prolog  non logical constructs
could destroy declarative semantics give logic programs power  mercury
even i o declarative 
third type relevant sa cost analysis logic programs  debray   lin 
      braem et al         debray et al          cortesi et al         describe cost formula
similar equation   select lowest cost ordering  however  used generate andtest approach sometimes prohibitively expensive  static analysis cost
number solutions used obtain control values  instead learning them 
eciency logic programs increased methods program transformation  pettorossi   proietti               one popular approaches
 rules strategies  approach  consists starting initial program
applying one elementary transformation rules  transformation strategies metarules prescribe suitable sequences applications transformation rules 
one possible transformation rules goal rearrangement rule transforms
program transposing two adjacent subgoals rule body  obviously  ordering
rule body transformed ordering finite number
transpositions  thus  static subgoal ordering considered special case program
transformation goal rearrangement rule used  hand  dynamic
semi dynamic ordering methods cannot represented simple transformation rules 
since make use run time information  expressed bindings rule body subgoals
  

filedeniov   markovitch

obtain unifications rule heads   may order rule body differently
different circumstances 
program transformation technique called compiling control  bruynooghe  de schreye 
  krekels        pettorossi   proietti        follows approach different
trying improve control strategy logic programs  instead enhancing naive
prolog evaluator using better  and often complex  computation rule  program
transformed derived program behaves naive evaluator exactly
initial program would behave enhanced evaluator  forms compiling control
first translate initial program standard representation  for example 
unfolding tree   complex computation rule used  new program
constructed representation  naive computation rule mind 
reordering rule body subgoals regarded moving complex computation
rule selects subgoals order dictated ordering algorithm  case
dac algorithm  computation rule may complex simple use compiling
control methods  nevertheless  easily incorporated special compiling control
method  section     described method program rewriting first builds
classification trees based orderings performed past  uses
classification trees constructing clauses derived program  derived program
eciently executed naive computation rule prolog  technique
fact kind compiling control  important property use knowledge collected
experience  the orderings made past  
one transformation method significantly benefit dac algorithm
unfolding  tamaki   sato         unfolding process subgoals replaced
associated rule bodies  even initial rules ordered optimally human
programmer static ordering procedure  resulting combined sequence may far
optimal  therefore could advantageous use dac algorithm reordering
unfolded rule  rules become longer  potential benefit ordering grows 
danger high complexity ordering procedure overcome using
cost sensitive version dac algorithm  section      

    conclusions
work study problem subgoal ordering logic programs  present
theoretical base practical implementation ideas  show empirical results
confirm theoretical predictions  combine ideas smith genesereth        
simon kadane        natarajan        novel algorithm ordering
conjunctive goals  algorithm aimed minimizing time logic interpreter
spends proof given conjunctive goal 
main algorithm described paper dac algorithm  algorithm    section       works dividing sets subgoals smaller sets  producing candidate
sets orderings smaller sets  combining candidate sets obtain orderings
larger sets  prove algorithm finds minimal ordering given set
subgoals  show eciency practical assumptions  algorithm
employed statically  to reorder rule bodies program text execution
  

fithe divide and conquer subgoal ordering algorithm

starts   semi dynamically  to reorder rule body reduction performed 
dynamically  to reorder resolvent every reduction subgoal rule body  
several researchers  minker        warren        naish      a      b  nie   plaisted 
      proposed various heuristics subgoal ordering  though fast  methods
guarantee finding minimal cost orderings  algorithm provably finds minimal cost
ordering  though ordering may take time heuristic methods 
future seems promising incorporate heuristics dac algorithm  example 
heuristics used grade binders or nodes  rather exhaustively trying
subgoals binders  could try one  several binders  thus reducing ordering
time  also  current version ordering algorithm suitable finding
solutions conjunctive goal  would extend problem finding one
solution  fixed number solutions 
another interesting issue research adaptation dac algorithm
interleaving ordering methods  section       there  subgoals rule body added
ordered resolvent  seems wasteful start complete ordering process 
use information stored existing ordering resolvent  perhaps whole
divisibility tree resolvent stored  nodes updated subgoals
rule body added resolvent 
ordering algorithm needs control knowledge work  control knowledge
average cost number solutions literals  learned training
collecting statistics  make assumption distribution queries received
system change time  thus  training set based distribution
seen past  system learns relevant knowledge future queries  consider
issue learning control values thoroughly another paper  ledeniov   markovitch 
    a   together issues concerning dac algorithm  such minimizing
total time  instead minimizing inference time only  
ullman vardi        showed problem ordering subgoals obtain termination inherently exponential time  problem work substantially
harder  must find order whose execution terminates finite time  one
terminates minimal finite time  impossible find ecient algorithm
cases  dac algorithm  however  ecient practical cases  graph
representing subgoal dependence  figure    sparsely connected 
implemented dac algorithm tested artificial real domains 
experiments show speedup factor    compared random ordering 
   compared alternative ordering algorithms 
dac algorithm useful many practical applications  formal hardware
verification become extremely important semiconductor industry  model
checking currently widely used technique  generally agreed coping
increasing complexity vlsi design requires methods based theorem proving 
main obstacle preventing use automatic theorem proving high computational
demands  dac algorithm may used speeding logic inference  making use
automatic theorem provers practical 
logic gained increasing popularity representation common sense knowledge 
several advantages  including exibility well understood semantics  indeed 
cyc project  lenat        recently moved frame based representation logic  

filedeniov   markovitch

based representation  however  large scale knowledge bases likely present
significant eciency problems inference engines  using automatic subgoal ordering
techniques  described here  may help solve problems 
issue subgoal ordering obtains new significance development inductive logic programming  lavrac   dzeroski        muggleton   de raedt         systems
using approach  foil  quinlan   cameron jones         try build correct
programs fast possible  without considering eciency produced programs 
combining dac algorithm inductive logic programming techniques
synthesis logic programs  such deductive constructive approaches 
looks promising direction 

appendix a  proof lemma  

appendix present proof lemma omitted main text
paper reasons compactness  prove show two auxiliary lemmas 

lemma  

let a    a    two ordered sequences subgoals  b set subgoals  value
cn a   ka   jb lies values cn a    jb cn a    jb a   
 

proof 

denote c    cost a    jb
n    nsols a   jb
cn    cn a   jb
c    cost a    jb a  n    nsols a   jb a  cn    cn a   jb  a 
c      cost a   ka    jb n      nsols a   ka     jb cn      cn a    ka    jb
cn   n          n  n         n         n   n        
 

   

 

 

c   

c   
c   
n
n
    
    
c
 n c
    c  c     c    c  cn   c n  c cn    cc  cn    nc  c  cn 
   
   
   
   
n
c
  c 
 
so  cn    always lies cn  cn   because c    c    positive
    exactly  point cn    divides segment  cn   cn   ratio

sum

 cn      cn       cn    cn        n  c    c  

words  cn    weighted average cn  cn    note c  amount
resources spent proof tree b      n  c    resources spent tree b     
c    sum  so  time  relatively  dedicate proof b      closer
cn    cn   conclusion generalized larger number components
concatenation  the proof induction  
cost a     jb
cn a    ka    k       a  k  jb  
cn a     jb  
cost a    ka    k       a  k  jb
nsols a     jb cost a     jb a   
 
cn a     jb a             
cost a    ka   k       a  k  jb
nsols a    ka    k       a  k   jb cost a  k  jb a        a  k  
 
cn a  k  jb a        a  k  
cost a   ka    k       a  k  jb
  

fithe divide and conquer subgoal ordering algorithm

 

lemma   
let s  set subgoals n node divisibility tree s   let o  n  
q  ka   ka   kr  ordering  n    a    a    cn equal max blocks  cn a     jb n   q   
cn a    jb n   q   a   
let ancestor n o  ordering  m   consistent o  n  
 

a    a    violated  either a    a    max blocks o 
max blocks stand cn equal them  a    a    belong
max block o    o  mc contradicting 
proof  induction distance n     n   a   a  
max blocks  lemma holds  let    n   let   child whose
 
descendant n   inductive hypothesis  lemma holds n     let o 
 
 
 
 
 
 
projection om   a  a  violated om   since violated
o   
a    a   max blocks o  m    inductive hypothesis maxblocks stand cn equal them  or node  new
subgoals enter a    a      and node  insertion new

subgoals possible  violates blocks  places max blocks ordered cn 
o  mc contradicting  corollary   lemma    so  o  mccontradicting  new max blocks inserted a    a    must cn equal
both 
assume a    a    max blocks o    without loss generality 
let a    member larger max block o    show a    must participate
max block 
since a    joined larger block  must exist another block  b    adjacent a    
pair cn inverted  let b  stand left a     in opposite case 
  a   i cn inverted  i e  
proof similar   o    x  kb  ka   ky  ka    kz    pair hb 
 
 
 
 
cn b  jb m   x    cn a  jb m   x   b    lemma    cn b ka  jb m   x    cn a    jb m   x   b   
must add block b  ka    blocks y    cn equal
a      also  cn a    jb m   x   b    cn a     jb m   x   b   a    a    must added
block  thus  a    a    belong max block o   
a   a    belong max block o  m    block either violated
o    not  former case  o  mc contradicting  corollary   
latter case  a    a    belong max block o   
o  m  mc contradicting  o  mc contradicting  the proof easy    
 

prove lemma   

lemma  
let s  set subgoals  n node divisibility tree s  o  n   q  ka    ka   kr 
  

filedeniov   markovitch

ordering  n    a    a    max blocks  mutually independent
cn equal bindings b n     q    o  n blockwise equivalent o  n   
q  ka   ka   kr   

proof 

let s  minimal ordering s  binder consistent o  n   corollary    s 
  
violate blocks o  n   particular a    a      s    x  ka   ky  ka    kz    let s      s  joo  nn  
x  ka    ky  ka    kz    must show s    minimal  implies blockwise equivalence
o  n o  n   
y  empty  cost s      cost s      lemma    a    a    adjacent  mutually
independent cn equal  thus  transposition change cost  
y  empty  corollary   y  mutually independent a    a   
 s  binder consistent o  n   therefore b n   x    consequently y    b n        
y  divided several blocks  one cn equal a    a     since s 
minimal  o  n cannot mc contradicting  claim follows lemma    
lemma    cn y   jx    cn a     jx    cn a    jx    lemma   

cost s      cost x  ka   ky  ka   kz   
  cost x  ka   ka    ky  kz   
  cost x  ka   ka    ky  kz   
  cost x  ka   ky  ka   kz   

 
 
 
 

   swap y  a  
   swap a   a   
   swap a    
cost s     

minimality s    implies blockwise equivalence o  n o  n   

 

appendix b  correctness dac algorithm

section show dac algorithm correct  i e   given set subgoals s  
returns minimal ordering  suces show candidate set root node
dtree s      valid  case  follows definition valid sets  must
contain minimal ordering  algorithm returns one cheapest candidates
root  therefore  candidate set root valid  dac algorithm must return
minimal ordering s  
start defining strong validity sets orderings  prove strong
validity implies validity  finally  use induction prove theorem  showing
candidate set produced node divisibility tree strongly valid 
definition  let s  set subgoals  n node divisibility tree s   set
cn  s  n    strongly valid  every ordering  s  n    ncn either mc contradicting
blockwise equivalent member cn   unless ordering  n   min consistent 

stronglyv alidn s  cn     
  o  n     s  n      mcn s  o  n        o  n    s  n    n cn   mccn s  o  n   
  o  n     cn   mcen s  o  n   o  n      
 

 

 

 

lemma    strongly valid set orderings valid 
  

fithe divide and conquer subgoal ordering algorithm

proof  let s  set subgoals  n node divisibility tree s   c  n  
strongly valid set orderings n  
min consistent ordering n   c  n   valid  definition
valid set  section      
otherwise  exists least one minimal ordering s   binder consistent n  
every ordering  s  n    n c  n   either mc contradicting blockwise equivalent
member c  n    prove c  n   valid  must show contains
ordering o  n   binder consistent minimal ordering s  s   
let s    minimal ordering s   binder consistent n   let o  n  projection
s    n   o  n    c  n    done  o  n   o  n    s    s      otherwise  o  n     s  n    n
c  n    o  n  cannot mc contradicting  it min consistent s      therefore must
blockwise equivalent o  n     c  n    blocks o  n  violated s     since s   
    
minimal  corollary     therefore substitution s       s   joo  n  well defined  s     minimal 
n
since s    minimal o  n  o  n   blockwise equivalent  s     binder consistent
o  n     since s    binder consistent o  n    thereupon s     o  n   satisfy requirements
validity  o  n   o  n     s    s      
 
theorem  
let s  set subgoals  node n divisibility tree s   algorithm  
creates strongly valid candidate set orderings 

proof  induction height n  s subtree 
inductive base  n leaf node  means  n   independent b n   

candidate set n contains one element  whose subgoals sorted cn 
orderings belong  s  n    n candset n   either sorted cn 
hence mc contradicting  lemma     sorted cn  hence blockwiseequivalent candidate  corollary     consequently  candset n   strongly
valid 
inductive hypothesis  children n   algorithm   produces strongly valid candidate sets 
inductive step  internal node divisibility tree either and node ornode 
   n and node  let n   n        nk children n   first show
consset n   strongly valid 
let o  n    s  n    n consset n      k  let o  projection
o  n ni  set projections fo     o           o  k g belong one three
following types  regard o  n  
 a  sets first type contain least one mc contradicting projection 
case o  n mc contradicting too  assume contrary  exists
minimal ordering s  s   binder consistent o  n   let o  mccontradicting projection  since o  consistent o  n   consistent
  

filedeniov   markovitch

s    since b ni     b n    subgoals b ni  appear s 
subgoals  ni    therefore  o  binder consistent s    since s 
minimal  o  min consistent mc contradicting   contradiction 
 b  sets second type contain mc contradicting projections 
o  n block projection violated  max blocks different
projections ordered cn  case  o  n mc contradicting 
corollary   lemma   
 c  sets third type contain mc contradicting projections 
max blocks projections violated o  n sorted cn 
every projection o  either belongs candset ni   not  o     candset ni  
exists o  i    candset ni  o  blockwise equivalent
o  i   because candset ni  strongly valid inductive hypothesis 
o  mc contradicting   o    candset ni   set o  i    o  i 
  
     
let o  n    o  n joo  joo        joo  kk   substitution well defined  since o 
number max blocks o  i    max blocks projections
violated o  n   let s  minimal ordering s   binder consistent
o  n   since s  minimal  blocks o    violated s    since o   
  
blockwise equivalent o       ordering s     s  joo  well defined
minimal  s   positions subgoals b n   change 
thus  o    min consistent s    blockwise equivalence o    o    
  
     
entails minimality ordering s     s   joo    s  joo  joo    continue
  
     
o   s  finally obtain s      s  joo  joo        joo  kk minimal 
  
definition o  n    s      s  joo  nn  note introduced blockwise equivalence
strong validity able perform transition   s    minimal 
therefore o  n blockwise equivalent o  n    o  n    consset n    since
projections candidates child nodes  thereupon  o  n blockwiseequivalent member consset n   
so  consset n   strongly valid  prove candset n   strongly valid 
suces show members consset n   included
candset n   algorithm    either mc contradicting blockwise equivalent
members candset n    orderings three types 
 a  orderings violate blocks children projections  mccontradicting corollary   
 b  orderings violate blocks  max blocks children projections ordered cn  mc contradicting lemma   
 c  orderings violate blocks sorted cn 
combination projections  one consistent ordering n retained
candidate set  rejected  corollary    rejected
orderings blockwise equivalent retained candidate 
consequently  candset n   strongly valid 
 

 

 

 

 
 

  

 

 

 

 

 

 

 

 

 

 

fithe divide and conquer subgoal ordering algorithm

   n or node  again  start showing consset n   strongly
valid 
let o  n    s  n    n consset n    o  n constructed binder h
 tail  sequence t    o  n   h kt    let nh child n corresponds
binder h   inductive hypothesis  candset nh   strongly valid 
t     candset nh    since otherwise o  n   consset n    therefore  t  either mc contradicting  blockwise equivalent t      candset nh   
t  mc contradicting  o  n mc contradicting  proof contradiction  and nodes   t  blockwise equivalent t      o  n   h kt 
blockwise equivalent h kt      consset n    the proof easy   hence 
consset n   strongly valid  orderings consset n   included candset n   dac algorithm cheaper permutations
leading max blocks  therefore mc contradicting  lemma    hence 
candset n   strongly valid 
 

corollary   candidate set found algorithm   root node valid 
corollary   algorithm   finds minimal ordering given set subgoals 

references

aho  a  v   hopcroft  j  e     ullman  j  d          data structures algorithms 
addison wesley 
boddy  m     dean  t          solving time dependent planning problems  sridharan  n  s   ed    proceedings   th international joint conference artificial
intelligence  pp           detroit  mi  usa  morgan kaufmann 
bol  r  n   apt  k  r     klop  j  w          analysis loop checking mechanisms
logic programs  theoretical computer science                
braem  c   le charlier  b   modar  s     van hentenryck  p          cardinality analysis
prolog  bruynooghe  m   ed    logic programming   proceedings     
international symposium  pp           massachusetts institute technology 
mit press 
breiman  l   friedman  j  h   olshen  r  a     stone  c  j          classification
regression trees  wadsworth international group  belmont  ca 
bruynooghe  m   de schreye  d     krekels  b          compiling control  journal
logic programming             
clark  k  l     mccabe  f          control facilities ic prolog  michie  d   ed   
expert systems microelectronic age   pp           university edinburgh 
scotland 
clocksin  w  f     mellish  c  s          programming prolog  third edition   springerverlag  new york 
  

filedeniov   markovitch

cohen  w  w          learning approximate control rules high utility  proceedings
seventh international machine learning workshop  pp           austin  texas 
morgan kaufmann 
cormen  t  h   leiserson  c  e     rivest  r  l          introduction algorithms  mit
press  cambridge  mass 
cortesi  a   le charlier  b     rossi  s          specification based automatic verification
prolog programs  gallagher  j   ed    proceedings  th international workshop logic program synthesis transformation  vol       lncs  pp        
stockholm  sweden  springer verlag 
de boeck  p     le charlier  b          static type analysis prolog procedures ensuring
correctness  deransart  p     maluszynski  j   eds    programming languages
implementation logic programming  vol      lncs  pp           linkoping 
sweden  springer verlag 
de schreye  d     decorte  s          termination logic programs  never ending
story  journal logic programming                   
debray  s   lopez garca  p   hermenegildo  m     lin  n  w          lower bound cost
estimation logic programs  maluszynski  j   ed    proceedings international symposium logic programming  ilps      pp           cambridge  mit
press 
debray  s  k     lin  n  w          cost analysis logic programs  acm transactions
programming languages systems                  
debray  s  k     warren  d  s          automatic mode inference logic programs 
journal logic programming             
dejong  g     mooney  r          explanation based learning  alternative view  machine learning             
deville  y          logic programming  systematic program development  international
series logic programming  addison wesley 
etzioni  o          static  problem space compiler prodigy  dean  thomas
l   mckeown  k   ed    proceedings  th national conference artificial
intelligence  pp           anaheim  california  mit press 
etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence              
greiner  r     orponen  p          probably approximately optimal satisficing strategies 
artificial intelligence                  
henrard  j     le charlier  b          folon  environment declarative construction
logic programs  bruynooghe  m     wirsing  m   eds    proceedings fourth
international symposium programming language implementation logic programming  vol      lncs  pp           leuven  belgium  springer verlag 
  

fithe divide and conquer subgoal ordering algorithm

itai  a     makowsky  j  a          unification complexity measure logic programming  journal logic programming             
knuth  d  e          art computer programming  vol     addison wesley  reading 
mass 
kowalski  r  a          algorithm   logic   control  communications acm        
        
laird  p  d          ecient dynamic optimization logic programs  proceedings
ml   workshop knowledge compilation speedup learning aberdeen 
scotland 
langley  p          learning search  weak methods domain specific heuristics 
cognitive science             
lavrac  n     dzeroski  s          inductive logic programming  techniques applications  artificial intelligence  ellis harwood  new york 
ledeniov  o     markovitch  s       a   controlled utilization control knowledge
speeding logic inference  tech  rep  cis      technion  haifa  israel 
ledeniov  o     markovitch  s       b   learning investment functions controlling
utility control knowledge  proceedings fifteenth national conference
artificial intelligence  pp           madison  wisconsin  morgan kaufmann 
lenat  d  b          cyc  large scale investment knowledge infrastructure  communications acm                 
lloyd  j  w          foundations logic programming  second edition   springer verlag 
berlin 
markovitch  s     scott  p  d          automatic ordering subgoals   machine learning
approach  lusk  e  l     overbeek  r  a   eds    proceedings north american
conference logic programming  pp           cleveland  ohio  mit press 
markovitch  s          information filtering  selection mechanisms learning systems 
ph d  thesis  eecs department  university michigan 
markovitch  s     scott  p  d          information filtering  selection mechanisms
learning systems  machine learning              
minker  j          search strategy selection function inferential relational system 
acm transactions database systems  vol     pp       
minton  s          learning search control knowledge  explanation based approach 
kluwer  boston  ma 
mitchell  t  m   keller  r  m     kedar cabelli  s  t          explanation based generalization  unifying view  machine learning           
  

filedeniov   markovitch

mooney  r  j     zelle  j  m          combining foil ebg speed up logic programs 
bajcsy  r   ed    proceedings thirteenth international joint conference
artificial intelligence  pp             chambery  france  morgan kaufmann 
morris  k  a          algorithm ordering subgoals nail   proceedings
seventh acm sigact sigmod symposium principles database systems  pp 
       austin  tx  acm press  new york 
muggleton  s     de raedt  l          inductive logic programming  theory methods 
journal logic programming                   
naish  l          mu prolog    db reference manual  dept  computer science  univ 
melbourne 
naish  l       a   automatic control logic programs  journal logic programming 
           
naish  l       b   prolog control rules  joshi  a   ed    proceedings  th international joint conference artificial intelligence  pp           los angeles  ca 
morgan kaufmann 
natarajan  k  s          optimizing backtrack search solutions conjunctive problems  mcdermott  j   ed    proceedings   th international joint conference
artificial intelligence  pp           milan  italy  morgan kaufmann 
nie  x     plaisted  d  a          experimental results subgoal ordering  ieee
transactions computers  vol      pp          
pettorossi  a     proietti  m          transformation logic programs  foundations
techniques  journal logic programming                   
pettorossi  a     proietti  m          rules strategies transforming functional
logic programs  acm computing surveys                  
porto  a          epilog  language extended programming  campbell  j   ed   
implementations prolog  ellis harwood 
prieditis  a  e     mostow  j          prolearn  towards prolog interpreter
learns  forbus  kenneth  shrobe  h   ed    proceedings  th national conference artificial intelligence  pp           seattle  wa  morgan kaufmann 
quinlan  j  r          induction decision trees  machine learning            
quinlan  j  r     cameron jones  r  m          induction logic programs  foil
related systems  new generation computing  special issue inductive logic programming                    
simon  h  a     kadane  j  b          optimal problem solving search  all or none solutions  artificial intelligence             
smith  d  e          controlling backward inference  artificial intelligence                  
  

fithe divide and conquer subgoal ordering algorithm

smith  d  e     genesereth  m  r          ordering conjunctive queries  artificial intelligence              
smith  d  e   genesereth  m  r     ginsberg  m  l          controlling recursive inference 
artificial intelligence                  
somogyi  z   henderson  f   conway  t   bromage  a   dowd  t   jeffery  d     al       a  
status mercury system  proc  jicslp     workshop parallelism
implementation technology  constraint  logic programming languages  pp 
         bonn  germany 
somogyi  z   henderson  f     conway  t       b   execution algorithm mercury 
ecient purely declarative logic programming language  journal logic programming                  
sterling  l     shapiro  e          art prolog  second edition   mit press  cambridge  ma 
tamaki  h     sato  t          unfold fold transformation logic programs  tarnlund 
s  
a   ed    proceedings second international conference logic programming  pp           uppsala  sweden 
ullman  j  d     vardi  m  y          complexity ordering subgoals  proceedings
seventh acm sigact sigmod symposium principles database systems 
pp         austin  tx  acm press  new york 
ullman  j  d          principles database systems  computer science press  rockville 
md 
vasak  t     potter  j          metalogical control logic programs  journal logic
programming                 
warren  d  h  d          ecient processing interactive relational database queries
expressed logic  zaniola    delobel  eds    proceedings  th international
conference large data bases  pp           cannes  france  ieee computer
society press 

  


