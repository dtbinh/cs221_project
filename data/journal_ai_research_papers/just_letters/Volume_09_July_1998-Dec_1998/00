journal artificial intelligence research              

submitted       published     

computational complexity probabilistic planning
michael l  littman

mlittman cs duke edu

department computer science  duke university
durham  nc            usa

judy goldsmith

goldsmit cs engr uky edu

martin mundhenk

mundhenk ti uni trier de

department computer science  university kentucky
lexington  ky            usa
fb    theoretische informatik  universitat trier
d       trier  germany

abstract
examine computational complexity testing finding small plans probabilistic planning domains propositional representations  complexity
plan evaluation existence varies plan type sought  examine totally
ordered plans  acyclic plans  looping plans  partially ordered plans three
natural definitions plan value  show problems interest complete
variety complexity classes  pl  p  np  co np  pp  nppp  co nppp  pspace 
process proving certain planning problems complete nppp  introduce
new basic nppp complete problem  e majsat  generalizes standard boolean
satisfiability problem computations involving probabilistic quantities  results suggest
development good heuristics e majsat could important creation
ecient algorithms wide variety problems 

   introduction
recent work artificial intelligence planning addressed problem finding effective plans domains operators probabilistic effects  drummond   bresina 
      mansell        draper  hanks    weld        koenig   simmons        goldman  
boddy        kushmerick  hanks    weld        boutilier  dearden    goldszmidt       
dearden   boutilier        kaelbling  littman    cassandra        boutilier  dean   
hanks         here   effective   successful  plan one reaches goal state
sucient probability  probabilistic propositional planning   operators specified
bayes network extended strips like notation  planner seeks recipe
choosing operators achieve goal configuration user specified probability 
problem closely related solving markov decision process  puterman 
      expressed compact representation 
previous work  goldsmith  lusena    mundhenk        littman      a   examined complexity determining whether effective plan exists completely observable
domains  problem exp complete general form pspace complete limited polynomial depth plans   a polynomial depth  polynomial horizon  plan one
takes polynomial number actions terminating   results 
c      ai access foundation morgan kaufmann publishers  rights reserved 

filittman  goldsmith   mundhenk

plans permitted arbitrarily large objects there restriction valid plan
need sort compact  polynomial size  representation 
place restrictions size valid plans  earlier results
directly applicable problem finding valid plans  possible  example 
given planning domain  valid plans require exponential space  and exponential
time  write down  knowing whether plans exist simply important
intractable express 
present paper  consider complexity practical realistic
problem that determining whether plan exists given restricted form
given restricted size  plans consider take several possible forms used
previous planning work  totally ordered plans  partially ordered plans   totally ordered 
conditional plans   totally order  looping plans  cases  limit attention
plans expressed size bounded polynomial size specification
problem  way  determine plan exists  use information
try write reasonable amount time space 
deterministic planning literature  several authors addressed computational complexity determining whether valid plan exists  determining whether plan
exists given cost  finding valid plans variety assumptions  chapman        bylander        erol  nau    subrahmanian        backstrom 
      backstrom   nebel         results provide lower bounds  hardness results 
analogous probabilistic planning problems since deterministic planning special case 
deterministic planning  optimal plans represented simple sequence operators
 a totally ordered plan   probabilistic planning  good conditional plan often perform better totally ordered  unconditional  plan  therefore  need consider
complexity planning process richer set plan structures 
ease discussion  explicitly describe case planning completely
observable domains  means state world known times
plan execution  spite uncertainty state transitions  know state
system sucient information choosing actions optimally  puterman         however 
representing universal plan often impractical propositional domains
size state space exponential size domain representation 
reason  consider types plan structures based simple finite state machines 
type plans consider necessarily use full state system
make every decision  results carry partially observable domains  although
explore fact detail present work 
computational problems look complete variety complexity classes
ranging pl  probabilistic logspace  pspace  two results deserving special
mention concern problems closely related ones actively addressed
artificial intelligence researchers  first  problem evaluating totally ordered plan
compactly represented planning domain pp complete   compactly represented
   class pp closely related somewhat familiar  p  toda        showed p p   ppp  
roughly speaking  means  p pp equally powerful used oracles  counting
class  p already recognized artificial intelligence community important complexity
class computations involving probabilistic quantities  belief network inference  roth        

 

ficomplexity probabilistic planning

planning domain one described two stage temporal bayes network  boutilier
et al         similar notation 
second  problem determining whether valid totally ordered plan exists
compactly represented planning domain nppp  complete  whereas class np
thought set problems solvable guessing answer checking polynomial time  class nppp thought set problems solvable guessing
answer checking using probabilistic polynomial time  pp  computation  likely
nppp characterizes many problems interest area uncertainty artificial
intelligence  paper earlier work  goldsmith et al         mundhenk  goldsmith   
allender      a  mundhenk  goldsmith  lusena    allender      b  give initial evidence
this 

    planning domain representations
probabilistic planning domain   hs   s    a  t  gi characterized finite set states
  initial state s      finite set operators actions a  set goal states
g   application action state results probabilistic transition

new state s  according probability transition function t  t s  a  s   
probability state s  reached state action taken  objective
choose actions  one another  move initial state s  one goal states
probability threshold    state system known times
 fully observable  used choose action apply 
concerned two main representations planning domains  representations  enumerate states explicitly  propositional representations  sometimes
called compact  structured  factored representations   view states assignments
set boolean state variables propositions  propositional representations represent many domains exponentially compactly representations 
representation  transition function represented collection
jsj jsj matrices   one action  propositional representation  type
jsj jsj matrix would huge  transition function must expressed another way 
probabilistic planning literature  two popular representations propositional planning domains probabilistic state space operators  psos   kushmerick et al        
two stage temporal bayes networks   tbns   boutilier et al          although representations differ type planning domains express naturally  boutilier et al  
       computationally equivalent  planning domain expressed one representation converted polynomial time equivalent planning domain expressed
polynomial increase representation size  littman      a  
work  focus propositional representation called sequential effectstree representation  st   littman      a   syntactic variant  tbns
conditional probability tables represented trees  boutilier et al                representation equivalent  tbns psos simplifies presentation results 
   possible formulate objective one maximizing expected total discounted reward  boutilier et al          two formulations essentially polynomially equivalent  condon         diculty compactly represented domains may require discount factors
exponentially close one equivalence hold  discussed section   
   assume number bits used represent individual probability values isn t large 

 

filittman  goldsmith   mundhenk

st  effect action proposition represented separate decision
tree  given action a  set decision trees different propositions ordered 
decision tree one proposition refer new old values previous propositions  allows st represent probability distribution  leaves
decision tree describe associated proposition changes function state
action  perhaps probabilistically  section     gives simple example representation 
propositional representations  states set goal states g
explicitly enumerated st  instead  define goal set   set propositions
state goal set propositions true considered goal state 
set actions explicitly enumerated st  representation 
st representation planning domain   hs   s    a  t  gi defined
formally   hp  i  a  t  g  we use blackboard bold font stand st representation domain   here  p finite set distinct propositions  set states
power set p  propositions   said  true  s  set p
initial state  set g goal set  set goal states g set states
g s 
transition function represented function t  maps action
ordered sequence jpj binary decision trees  decision trees
distinct label proposition  decision propositions nodes  optionally labeled
sux   new    probabilities leaves  ith decision tree t a i action
defines transition probabilities t s  a  s    follows  ith decision tree  let pi
label proposition  define value leaf node found traversing decision
tree t a i   taking left branch decision proposition  or s  decision
proposition   new  sux  right branch otherwise  finally  let
i 
pi   s   
 
t s  a     
   
      otherwise 


definition constitutes well defined probability distribution s 
s 
insure validity representation  allow  p new  appear
decision proposition t a i p label proposition decision tree t a j
j   i  reason  order decision trees t a  significant  put
another way  proposition new value new value defined
decision tree 
complexity results derive st apply psos   tbns  computationally equivalent representations  hold  succinct representation  
propositional representation popular complexity theory literature  captures
set transition matrices function  commonly represented boolean circuit
computes function  st straightforwardly represented boolean circuit 
and  proof theorem    show represent particular boolean circuits
st  thus  although shown succinct representation formally equivalent st  two representations closely related  proofs give st need
changed slightly work succinct representation  goldsmith  littman   
mundhenk      a      b  mundhenk et al       b   results require restrict
succinct representation generate transition probabilities polynomial
 

ficomplexity probabilistic planning

number bits  results may different circuit based representations
represent probabilities exponential number bits  mundhenk et al       a  

    example domain

help make domain representation ideas concrete  present following
simple probabilistic planning domain based problem building sand castle
beach  total four states domain  described combinations two
boolean propositions  moat castle  propositions appear boldface   proposition
moat signifies moat dug sand  proposition castle signifies
castle built  initial state  moat castle false 
goal set fcastleg 
two actions  dig moat erect castle  actions appear sans serif   figure  
illustrates actions st  executing dig moat moat false causes moat
become true probability      moat already true  dig moat leaves unchanged 
castle proposition affected  dig moat action depicted left half
figure   
second action erect castle  appears right half figure    decision
trees numbered allow sequential dependencies effects expressed 
first decision tree castle  change value already true
erect castle executed  otherwise  probability becomes true dependent
whether moat true  castle built probability     moat true
probability     not  idea building moat first protects castle
destroyed prematurely ocean waves 
second decision tree proposition moat  erect castle cannot make
moat become true  effect moat false  hand  moat
exists  may collapse result trying erect castle  label castle new
diagram refers value castle proposition first decision tree evaluated 
castle already built erect castle selected  moat remains built
probability      castle built  erect castle successfully builds it  moat
remains true  finally  erect castle fails make castle true  moat becomes false
probability     everything destroyed 
note given st representation domain  perform number useful
operations eciently  first  given state action a  generate next state s 
proper probabilities  accomplished calculating value propositions
s  one time order given representation a  ipping coins
probabilities given leaves decision trees  second  given state s  action a 
state s    compute t s  a  s     probability state s  reached state
action taken  via equation   

    plan types representations

consider four classes plans probabilistic domains  totally ordered plans
basic type  finite sequence actions must executed order 
type plan ignores state system  acyclic plans generalize totally ordered plans
include conditional execution actions  partially ordered plans different way
 

filittman  goldsmith   mundhenk

dig moat
   moat

   castle

moat

 t

erect castle
   castle

castle
f

   


 t

   moat

castle
f



 t

 t

moat
f



moat

f

castle



f

   

   

   

 t

f



castle  new


f

 t

   

figure    sequential effects tree  st  representation sand castle domain
generalizing totally ordered plans precise sequence left exible  mcallester
  rosenblitt         looping plans generalize acyclic plans case plan steps
repeated  smith   williamson        lin   dean         type plan
referred plan graph policy graph  kaelbling et al         
following sections  prove computational complexity results concerning
plan types  remainder section provides formal definitions plan
types  illustrated figure   examples sand castle domain 
general form  plan  or policy  controller transducer  program
outputs actions takes input information outcome actions 
work  consider particularly restricted finite state controller based plan representation 
plan p planning domain   hs   s    a  t  gi represented structure
 v  v    e      consisting directed  multi  graph  v  e   initial node v    v  
labeling   v   plan nodes called plan steps  to domain actions  labeling
edges state sets   e   p  s   every v   v outgoing edges 

 
v  v   v v   e  v  v      v  v       v  v        v    v    v   v     v    plan
steps outgoing edges all these terminal steps   actions terminal
steps executed  note function represented direct manner
domains  propositional domains  compact representation needed 
assume propositional domains  edge labels given conjunctions literals 
behavior plan p domain follows  initial time step      time
step    domain state st plan step vt  s  defined planning
domain  v  plan   action  vt   executed  resulting transition domain state
st   probability t st    vt    st      plan step vt   chosen st      vt   vt     
function tells plan  go  next  point  time step index
incremented process repeats  continues terminal step reached
plan 
one understand behavior domain plan p several different ways 
possible sequences states viewed tree  node tree
depth state reachable initial state time step t  alternatively  one view
state time step plan p probability distribution   time
 

 

 

ficomplexity probabilistic planning

step    probability   process state s    probability state s 
time step      pr s          sum probabilities length     paths
s  s   i e  

x




s   s   s       st st   s j   

t sj   aj   sj     

 

aj action selected plan p time j given observed sequence state
transitions s            sj   view useful later proofs 
next  formalize probability domain reaches goal state plan p  
need introduce several notions   legal  sequence states steps applied
called trajectory   i e   p sequence   h si   vi  iki   pairs

t si   vi    si           k     
si      vi   vi       k     
v            vk   terminal steps 
goal trajectory trajectory ends goal state   sk   g   note
goal trajectory finite q thus  calculate probability goal trajectory
   t s    v       given   g   probability
  h si   vi  iki   pr ff    ki  

i  
k
reaches goal state plan p sum probabilities goal trajectories
m 
x
pr m reaches goal state p     
pr ff  
goal trajectory

call value plan 
characterize plan p    v  v    e      basis size structure
underlying graph  v  e    graph  v  e   contains cycles  call acyclic plan  
otherwise looping plan   follows acyclic plan terminal step 
terminal step reached jv j actions taken  plans
used finite horizon control  totally ordered plan  sometimes called  linear
plan   straight line  plan  acyclic plan one outgoing edge
node v   plan simple path 
work  consider partially ordered plans  sometimes called  nonlinear 
plans  express entire family totally ordered plans  representation  steps
plan given partial order  specified  example  directed acyclic graph  
partial order represents set totally ordered plans  totally ordered sequences
plan steps consistent partial order consist steps partially ordered
plan  totally ordered plans value  values need
same  such  choice defining value partially ordered plan 
work  consider optimistic  pessimistic  average interpretations  let
 p  
set totally ordered sequences consistent partial order plan p   optimistic
interpretation 
value p    max pr m reaches goal state p  
p 
 p  

 

filittman  goldsmith   mundhenk

pessimistic interpretation 
value p    min pr m reaches goal state p  
p 
 p  

average interpretation 
x
pr m reaches goal state p  
value p    j
  p  j
p 
 p  
illustrate notions  figure   gives plans type sand castle domain
described earlier  initial nodes marked incoming arrow  terminal steps
represented filled circles    step totally ordered plan figure   a  successfully
builds sand castle probability         acyclic plan given figure   b  
succeeds probability         executes dig moat average      times  note
succeeds often fewer actions average totally ordered plan
figure   a  
figure   c  illustrates partially ordered plan sand castle domain 
plan bears superficial resemblance acyclic plan figure   b   different
interpretation  particular  plan figure   c  represents set totally ordered plans
five  non terminal  plan steps    dig moat steps   erect castle steps   contrast
solid arrows figure   b   indicate ow control  dashed arrows
figure   c  represent ordering constraints  erect castle step must preceded
least two dig moat steps for example 
although         distinct ways arranging five plan steps figure   c  totally ordered plan  two distinct totally ordered plans consistent
ordering constraints 
dig moat   dig moat   dig moat   erect castle   erect castle  

 success probability         

dig moat   dig moat   erect castle   dig moat   erect castle  

 success probability            thus  optimistic success probability partially
ordered plan           pessimistic          note pessimistic interpretation closely related standard interpretation deterministic partial order planning  mcallester   rosenblitt         partially ordered plan considered successful consistent totally ordered plans successful  average success
probability            here    orderings yield poorer plan
described above    yield better one 
looping plan figure   d  terminate succeeds building sand
castle  probability     eventually  course  looping plans
succeed probability    totally ordered plan figure   a  acyclic plan
figure   b  special cases looping plans  instance 
define jp j size plan p number steps contains  define jm j
size domain sum number actions states domain
sum sizes st decision trees propositional domain 
 

ficomplexity probabilistic planning

dig moat

dig moat

erect castle

dig moat

erect castle

dig moat

erect castle

dig moat

 a  totally ordered plan 

 c  partially ordered plan 
not moat 
dig moat

not moat 
dig moat

moat

dig moat

erect castle

not moat 

moat not castle 

moat

moat
dig moat

castle
erect castle

 b  acyclic  conditional  plan 
not moat  not castle 
 d  looping plan 

figure    example plans sand castle domain
consider following decision problems  plan evaluation problem asks  given
domain   plan p size jp j jm j  threshold   whether value greater
  i e   whether
pr m reaches goal state p      
note condition jp j jm j technical one we simply want use jm j
represent size problem  given instance jp j larger jm j 
simply imagine  padding out  jm j make larger  important thing
considering plans roughly size description domain 
size number states  which might considerably larger  
plan existence problem asks  given domain   threshold   size bound z jm j 
whether exists plan p size z value greater   note
bound size target plan  complexity plan generation
plan existence  technique self reduction used construct valid plan using
polynomially many calls oracle decision problem 
decision problems different version type domain  
propositional  type plan category  looping  acyclic  totally ordered 
partially ordered three interpretations   address problems
succeeding sections 

    complexity classes

definitions complexity classes  reductions  standard results complexity
theory  refer reader papadimitriou        
brie y  looking complexity decision problems  those yes no
answers   class p consists problems decided polynomial time  is 
given instance problem  program deciding whether answer yes
runs polynomial time  class np contains problems polynomialtime checkable polynomial size certificates  given instance certificate 
checked time polynomial size instance whether certificate proves
instance np set  means that  answer instance  yes  
 

filittman  goldsmith   mundhenk

shown polynomial time given right key  class co np opposite if
answer  no   shown polynomial time given right key 
problem x c  hard complexity class c every problem c reduced
it  put another way  fast algorithm x used subroutine solve
problem c quickly  problem c  complete c  hard c  
hardest problems class 
interest complete  next give detailed descriptions less
familiar probabilistic counting complexity classes use work 
class  l  a lvarez   jenner        class functions f that 
nondeterministic logarithmically space bounded machine n   number accepting paths
n x equals f  x   class  p defined analogously class functions f
that  nondeterministic polynomial time  bounded machine n   number
accepting paths n x equals f  x   typical complete problems computing
determinant  l computing permanent  p 
function f defined gapl difference f   g   h  l functions g
h   l functions nonnegative integer values definition  gapl functions
may negative integer values  for example  g always returns zero  
probabilistic logspace  gill         pl  class sets exists
nondeterministic logarithmically space bounded machine n x  
number accepting paths n x greater number rejecting paths 
original definition pl  time bound computations  borodin  cook 
pippenger        later showed pl p  jung        proved set computable
probabilistic logspace computable probabilistic logspace pl machine
simultaneous polynomial time bound  apparent contrast p complete sets  sets pl
decidable using fast parallel computations  borodin et al         
probabilistic polynomial time  pp  defined analogously  classic pp complete problem majsat  given boolean formula conjunctive normal form  cnf  
majority assignments satisfy it  according balcazar  daz  gabarro        
pp completeness majsat shown combination results gill       
simon        
polynomial space bounded computations  pspace equals probabilistic pspace 
 pspace class polynomial space computable functions  ladner 
      
note l  nl   l  pl gapl logarithmic space p  np   p  pp 
gapp polynomial time  also  notion completeness use paper relies
many one reductions  case pl  reduction functions logarithmic space 
case np above  polynomial time 
complexity classes c c   class c c consists sets c  turing
reducible sets c     i e   sets accepted resource bounds specified c  
using problem c   subroutine  oracle  instantaneous output  class
c pspace  case npc pspace  therefore nppspace   pspace 
primary oracle defined class consider nppp   equals  np
  closure
pp  toran         seen closure pp polynomial time disjunctive reducibility exponential number queries  each queries computable
polynomial time index list queries   simplify completeness results
 

  

ficomplexity probabilistic planning

class  introduce decision problem call e majsat   exists  majsat  
generalizes standard np complete satisfiability problem pp complete majsat 
e majsat instance defined cnf boolean formula n boolean variables
x            xn number k   n  task decide whether
initial partial assignment variables x            xk majority assignments
extend partial assignment satisfies   prove problem nppp  complete
appendix 
complexity classes consider satisfy following containment properties
relations well known classes 
np pp nppp pspace exp 
l nl pl p co np
co nppp
p properly contained exp  exp complete problems provably intractable 
classes may equal p  although generally believed case 
several observations worth making here  known ph nppp  
ph represents polynomial hierarchy  crude sense  ph close pspace 
and  thus  nppp  completeness results place important problems close pspace 
however  early empirical results  littman      b  show random problem instances pp similar properties random problem instances np  suggesting
pp might close enough np np type heuristics effective 

    results summary

tables     summarize results  explained detail later sections 
general avor main results techniques conveyed follows 
show plan evaluation problem particular complexity class c   take
cross product steps plan states domain look
complexity evaluating absorption probability resulting markov chain  i e  
directed graph probability labeled edges   complexity corresponding planexistence problem bounded npc   problem solved guessing
correct plan non deterministically evaluating it  many cases  npc complete  appropriate complexity class c depends primarily representation
cross product markov chain 
exceptions basic pattern results partially ordered plans section   
appear require distinct set techniques 
worth noting that  although propositional domains exponentially
compact domains  computational complexity solving problems propositional domains always exponentially greater  one instance  evaluating partially
ordered plans average interpretation  complexity actually
propositional domains 
prove results concerning plan evaluation existence compactly represented
plans  pp complete nppp  complete  corollary     plan existence  large enough 
looping plans domains  p complete  theorem     plan evaluation existence
looping plans deterministic propositional domains  pspace complete  theorems  
    plan existence polynomial size looping plans partially observable domains
 np complete  section      
  

filittman  goldsmith   mundhenk

plan type
plan evaluation plan existence
unrestricted
 
p complete
polynomial depth
 
p complete
looping
pl complete
np complete
acyclic
pl complete
np complete
totally ordered
pl complete
np complete
partially ordered  optimistic
np complete
np complete
partially ordered  average
pp complete
np complete
partially ordered  pessimistic co np complete
np complete

reference
p         
p         
section  
section  
section  
section  
section  
section  

table    complexity results representations  p          papadimitriou
tsitsiklis        

plan type
plan evaluation plan existence reference
unrestricted
 
exp complete littman      a 
polynomial depth
 
pspace complete littman      a 
looping
pspace complete pspace complete section  
acyclic
pp complete
nppp  complete section  
totally ordered
pp complete
nppp  complete section  
pp
partially ordered  optimistic
np  complete
nppp  complete section  
partially ordered  average
pp complete
nppp  complete section  
pp
partially ordered  pessimistic co np  complete nppp  complete section  
table    complexity results propositional representations

  

ficomplexity probabilistic planning

   acyclic plans

section  treat complexity generating evaluating acyclic totally
ordered plans 

theorem   plan evaluation problem acyclic totally ordered plans domains pl complete 

proof  first  show pl hardness totally ordered plans  jung        proved
set pl exists logarithmically space bounded polynomially
time bounded nondeterministic turing machine n following property  every
input x  machine n must least half computations input x accepting
x a  machine n transformed probabilistic turing
machine r input x  probability r x  accepts x equals
fraction computations n  x  accepted  given r  planning domain
described follows  state set set configurations r input x  note
configuration consists contents logarithmically space bounded tape 
state  location read write heads  one symbol input output
tapes  thus  configuration represented logarithmically many bits 
polynomially many configurations  state transition probabilities
unique action configuration transition probabilities r  states
obtained accepting configurations goal states  totally ordered plan consists
 step counter  r input x  plan steps takes action a 
probability planning domain plan reaches goal state exactly
probability r x  reaches accepting configuration  thus  evaluating totally
ordered plan pl hard 
since totally ordered plans acyclic plans  proves pl hardness planevaluation problem acyclic plans 
next  show plan evaluation problem pl acyclic plans  let  
hs   s    a  t  gi planning domain  let p   hv  v    e    acyclic plan  let
threshold given  show question  whether probability p
reaches goal state probability greater   equivalently transformed
question whether gapl function greater    transformation done
logarithmic space  shown allender ogihara         follows question
pl 
first  construct markov chain c p   simulates execution
 evaluation  p   note markov chain seen probabilistic
domain one action set actions  since choice actions 
mention construction  state space c v   initial state
 s    v     set goal states g v   transition probabilities tc c
 
t s   v   s     s     v  v    
 
tc   s  v    s    v           
v terminal step node   s  v     s    v    
  
otherwise 
let number plan steps p  i e   jv j  number nodes graph
representing p    since states c contain terminal step p sinks c   follows
  

filittman  goldsmith   mundhenk


pr m reaches goal state p     pr c reaches goal state exactly steps  
let
pc  s  m     pr c reaches goal state exactly steps initial state s  
then  pc   s    v     m  probability want calculate  standard inductive definition pc used evaluate plans dynamic programming

goal state c  
pc  s            ifotherwise 
x
pc  s  k       
tc  s  s   pc  s    k     k     
 sv
 

let h maximum length representation state transition probability tc  
then 

goal state c  
ph  s            otherwise 
x h
ph s  k       
  tc  s  s    ph  s    k     k     
 sv
 

follows pc   s    v     m    ph  s    v     m    hm   note ph  s    v     m  integer
value  therefore  pc   s    v     m    ph   s    v     m    b hm c      order
show pc   s    v     m    decidable pl  suces show ph  s    v     m 
gapl  therefore   unwind  inductive definition ph  let integer
matrix obtained tc t s s     tc  s  s     h   introduce integer valued
show ph composed gapl functions using compositions gapl
closed  tc integer valued  cannot used show this  write
 

ph s  m   

x

 sv

 t   s s   ph s       
 

 

argue ph gapl  entry t s s   logspace computable domain plan p   therefore  powers matrix gapl  shown
vinay         gapl closed multiplication summation polynomially
many summands  follows ph   gapl  finally  use closure properties gapl
allender ogihara         since gapl closed subtraction  follows
plan evaluation acyclic plans pl 
totally ordered plans acyclic plans  plan evaluation problem totally
ordered plans pl 
 

technique forming markov chain taking cross product domain
plan useful later  plan existence problems require different set techniques 

theorem   plan existence problem acyclic totally ordered plans domains np complete 

  

ficomplexity probabilistic planning

proof  first  show containment np  given planning domain   threshold  
size bound z jm j  guess plan correct form size z accept

reaches goal state probability greater plan  note
checking whether plan correct form done polynomial time 
plan evaluation problem pl  theorem     follows plan existence problem
np  i e   nppl   np  
show np hardness plan existence problem  give reduction
np complete satisfiability problem boolean formulae conjunctive normal form 
construct planning domain evaluates boolean formula n variables 
 n      step plan describes assignment values variables  first step 
clause chosen randomly  step      planning domain  checks  whether plan
satisfies appearance variable clause  so  clause marked satisfied 
n     steps  literal satisfied clause  goal state reached
clause  otherwise  transition made goal state  therefore  goal
state reached probability    greater       m  clauses
satisfied the plan describes satisfying assignment 
formally define reduction  similar one presented papadimitriou
tsitsiklis         let cnf formula n variables x            xn clauses
c            cm   let sign appearance variable clause    variable
negated    otherwise  define planning domain      hs   s    a  t  gi



g

  fsat i  j    unsat i  j   j   n        j mg   fs    sacc   srejg 
  fassign i  b  j   n  b   f     gg   fstart  endg 
  fsacc g 
   
 
 
    s      start  s    unsat    j      j m 
 
 
 
     s       start    srej 
 
 
 
 
 
     unsat i  j      assign i  b   s    sat i      j    n 
 
 
 
 
xi appears cj sign b 
 
 
 
 
 
 


  unsat i  j      assign i  b   s    unsat i      j    n 
 
 
 
 
xi appear cj sign b 
 
 
 
 
 
 


  unsat i  j      assign i    b    start   end 
 
 
 
 
srej  i     n  b   f     g 
t s  a  s          ss  
  unsat n      j    s    srej 
 
 
 
 
     sat i  j      assign i  b   s    sat i      j    n 
 
 
 
 
     sat i  j      assign i    b    start   end 
 
 
 
 
s    srej  i     n 
 
 
 
 
     sat n      j      end  s    sacc  
 
 
 
 
     sat n      j       end  s    srej 
 
 
 
 
  s    srej   s    sacc  
 
 
       ifotherwise 
meaning states domain follows  domain state
sat i  j     n    j m  means formula satisfied 
currently checking variable clause j   state sat n      j     j means
we ve finished verifying clause j satisfied  meanings similar
  

filittman  goldsmith   mundhenk

s 

start

   

unsat      

assign      

assign   

sat      

assign    x 

   

   

start

assign   

   

sat      

assign      

sat      

assign    x 

sat      

unsat      

end

end

sacc

unsat      

assign    x 

unsat      

assign    x 

assign      

sat      

unsat      

assign   

unsat      

   

unsat      

assign      
sat      

end

assign   

   

unsat      

end

srej

figure    domain generated boolean formula  x     x        x    x   
 unsat  states  course  s  initial state sacc srej accepting
rejecting states  respectively 
actions domain start end  mark beginning end
assignment  assign i  b    n  b   f     g  assign truth value b
variable i  figure   gives domain generated reduction simple boolean
formula  description reduction     computed time
polynomial jj 
construction     z    n      step plan p reach goal state sacc
p form
start   assign    b      assign    b        assign n  bn     end    
p reaches sacc probability   b            bn satisfying assignment
n variables   shows boolean satisfiability polynomial time reduces
plan existence problem totally ordered acyclic plans  showing np hard 
note bound plan depth  horizon  instead plan size  planexistence problem acyclic plans domains p complete  goldsmith et al       a 
papadimitriou   tsitsiklis         limiting plan size makes problem dicult
possible force planner take action different states 
figuring without sacrificing plan quality challenging 
propositional domains  plan evaluation harder large number states 

theorem   plan evaluation problem acyclic totally ordered plans propositional domains pp complete 

proof  show pp hardness totally ordered plans  give reduction

pp complete problem majsat  given cnf boolean formula   majority
assignments satisfy it 
  

ficomplexity probabilistic planning

evaluate
   xi
   

   xi



   



n    clause 
xa  new


f

xb  new

 t


 




 




 



 t

xbm new

clause  new





xcm new


 t

 

f

f

 t

 t

n m    done

done


f



f

n m    satisfied

xam new

   

xc  new

xd  new

   

n m  clausem

f



n  xi

   



f
 

f

clause  new
   



 t

f
 



clausem new

f



 t

 

f


 t

figure    sequential effects tree representation evaluate
given   construct planning domain      step plan plan
achieves goal probability greater       majority
assignments satisfies   planning domain    consists single action evaluate 
  step plan evaluated  n       propositions    
x  xn  correspond n variables   clause  clausem  
correspond clauses   satisfied  sole element goal set 
done  insures evaluate executed  this important
domain used later theorem   show complexity plan existence   initial
state  propositions false 
evaluate action generates random assignment variables   evaluates
clauses  clausei true literals ith clause true   evaluates entire
formula  satisfied true clauses true   figure   gives st representation
evaluate  xa   xb         represent variables clause i 
construction  majsat    reaches goal state probability
greater       plan consisting single action evaluate 
next show membership pp acyclic plans  showing
planning domain acyclic plan p induce computation tree consisting
paths p   evaluating computation tree accomplished pp
machine 
let b bound number bits used specify probabilities leaves
decision trees representing    consider computation tree defined follows  root
labeled hs    v  i  if  planning domain   probability reaching state s 




   represent numbers polynomial precision binary representation  principle  could introduce
round off errors planning problems specified form 

  

filittman  goldsmith   mundhenk

given action  v  equal   hs   v i  b children labeled hs     v  s   i 
identically labeled child nodes independent defined identically
others  thus  number paths given set labels corresponds probability
trajectory domain plan multiplied   b  h   h depth
plan 
number accepting computations is  therefore    b  h
probability achieving goal   note b inherent planning
domain  rather h  pp machine accepts half final states
accepting          necessary pad computation tree introducing
 dummy  branches accept reject right proportions 
plan existence problem essentially equivalent guessing evaluating valid
plan 

theorem   plan existence problem acyclic totally ordered plans propositional domains nppp  complete 

proof  containment nppp totally ordered acyclic plans follows

fact polynomial size plan guessed polynomial time checked pp
 theorem    
hardness nppp totally ordered acyclic plans shown using
reduction e majsat  shown nppp  hard appendix  reduction echoes
one used pp hardness argument proof theorem   
given cnf boolean formula variables x            xn   number k  construct
planning domain    k  plan exists reach goal probability
greater       assignment variables x            xk
majority assignments remaining variables satisfies   planning domain
   k   consists action evaluate theorem   one action  set xi  
first k variables  proof theorem    n       propositions
   k    initially false  x  xn   correspond n variables   clause 
clausem   correspond clauses   satisfied  done 
insures evaluate executed once  goal set contains satisfied done 
  k  action set xi makes proposition xi true  analogously theorem   
evaluate action generates random assignment remaining variables   evaluates
clauses  clausei true literals clause true   evaluates
entire formula  satisfied true clauses true   sets done true  done
true  action make satisfied true 
pair   k e majsat  exists assignment b        bk first k
variables majority assignments rest variables satisfies  
therefore  plan applying steps set xi bi     followed evaluate action
reaches goal state probability greater       
conversely  assume    k  totally ordered plan p reaches goal state
probability greater      since evaluate action action setting done
true  since action reaches goal done set true  assume without
loss generality p consists sequence steps set xi ends evaluate 
construction  assignment x            xk assigning   exactly variables set p
  

ficomplexity probabilistic planning

assignment majority assignments rest variables
satisfies   therefore   k e majsat 
since every totally ordered plan acyclic  hardness holds acyclic plans 
results  consider compactly represented  propositional 
planning domains plans  compactly represented plans quite useful 
compact acyclic plan acyclic plan names plan steps
encoded set propositional variables step transition function
plan steps represented set decision trees  st 
require plan depth polynomial size representation 
even though total number steps plan might exponential due
logarithmic succinctness encodings 
plan domain cross product technique used proof theorem   generalizes compact acyclic plans  complexity results apply  holds true
probabilistic acyclic plan   acyclic plan make random transitions
plan steps  i e   step transition function stochastic   insights
combined yield following corollary theorems     

corollary   plan evaluation problem compact probabilistic acyclic plans propositional domains pp complete plan existence problem compact probabilistic
acyclic plans propositional domains nppp  complete 

mention probabilistic plans two reasons  first  behavior planning structures  such partially ordered plan evaluation average interpretation 
discussed section    thought generating probabilistic plans  second 
many instances simple probabilistic plans perform nearly well much larger
complicated deterministic plans  notion often exploited field randomized algorithms  work platzman         described lovejoy        shows
idea randomized plans come handy planning partially observable domains 

   looping plans

looping plans applied infinite horizon control  complexity plan existence
plan evaluation domains  theorems      depend presence
absence loops plan 

theorem   plan evaluation problem looping plans domains pl complete 
proof  given domain looping plan p   construct product markov

chain c proof theorem    proof theorem   allender
ogihara         chain constructed exactly one accepting
exactly one rejecting state  states absorbing  probability
reaches goal state p equals probability c reaches accepting state
started initial state  product initial states p  
  

filittman  goldsmith   mundhenk

proof theorem   allender ogihara         shown construction
markov chain computation whether reaches final state probability
greater performed pl 
pl hardness implied theorem    since acyclic plans special case looping
plans 

theorem   plan existence problem looping plans domains np complete

general  p complete size desired plan least size state
action space  i e   z min jsj  jaj   

proof sketch  np completeness follows proof theorem    containment

hardness still hold plans permitted looping 
however  true forced specify plan whose size small
respect size domain  looping plan allowed number states
least large number states actions domain  problem
solved polynomial time 
known markov decision processes maximum probability
reaching goal state equals maximum probability reaching goal state
infinite horizon stationary policy   stationary policy mapping states
actions used repeatedly choose actions time step  known
optimal stationary policy computed polynomial time via linear programming  condon         stationary policy domain   hs   s    a  g   ti
written looping plan  although  course  looping plans correspond stationary
policies 
show fixed stationary policy p     a  two simple ways
looping plan p    v  v    e      represented  first  let v   a  v    p s      v    v 
 v  v      fs   j p s    v  g  follows whenever reaches state s 
action applied according looping plan according p  
second  let v     v    s     v    p v    v  v      fv  g  follows whenever
reaches state s  plan node corresponding state and  therefore 
appropriate action state applied looping plan  therefore 
maximum probability reaching goal state obtained either looping
plans 
since best stationary policy computed polynomial time  best looping
plan computed polynomial time  too  p hardness follows theorem
papadimitriou tsitsiklis        
propositional domains  complexity plan existence plan evaluation looping
plans quite different acyclic case  looping plan evaluation hard 

theorem   plan evaluation problem looping plans deterministic stochastic propositional domains pspace complete 

proof  recall plan evaluation problem domains pl  theorem    

planning domain cn states representation size n  looping plan
  

ficomplexity probabilistic planning

evaluated probabilistic space o log cn     theorem     say probabilistic
space polynomial size input  follows st representation
domain used compute entries transition function polynomial space 
since probabilistic pspace equals pspace  shows plan evaluation problem
looping plans stochastic propositional domains pspace 
remains show pspace hardness deterministic propositional domains  let n
deterministic polynomial space bounded turing machine  moment to moment
computation state  configuration  n expressed polynomial length bit string
encodes contents turing machine s tape  location read write head 
state n  s finite state controller  whether machine accepting
state 
input x  describe construct polynomial time deterministic planning domain  x  single action looping plan reaches goal state  x 
x accepted turing machine n  
given description n x  one can  time polynomial size descriptions
n x  produce description turing machine computes transition
function n   words  input c  configuration n   outputs next
configuration n    in fact  even check whether c valid configuration
computation n  x  simulating computation   argument similar
used cook s theorem  modeled polynomial size circuit  circuit takes
input bit string describing current configuration n outputs next
configuration 
next  argue computation circuit expressed action compute st representation  one proposition  x  bit configuration 
plus one gate circuit  three standard gates   and    or    not 
easily represented decision trees  ordering decision trees compute according topological sort gates circuit  single compute action compute
precisely output circuit  figure   illustrates conversion simple
circuit  gives form  not   i      and   i      or   i    gates 
describe complete reduction  planning domain  x  consists
single action compute set propositions described previous paragraph 
initial state initial configuration turing machine n   goal set
proposition corresponding whether configuration accepting state n  
transitions deterministic one action chosen  follows
goal state reached probability    greater      example 
plan repeatedly chooses compute accepting state reached
polynomial space machine n input x accepts 
similar argument shows looping plan existence actually harder
looping plan evaluation 

theorem   plan existence problem looping plans deterministic stochastic propositional domains pspace complete 
  

filittman  goldsmith   mundhenk

compute
   i 

   i 

c 
c 

c 


i 


i 


c 





i 

c 

f

c 

 t

 t

 t



f

c 

 t

f



 t

f

 t

 t



   c 
c 






c 

i  new
f

 t

   i 

   c 
i  new

c 

c 


f

i  new

 t

   c 

 t


 t

f
 t

i  new


f

i  new

 t



f
 t

 t

f
 t

figure    circuit representation sequential effects tree

proof  hardness pspace follows construction proof

theorem    either one step looping plan successful  not  plan yields
better result 
recall interested determining whether plan size z  
z bounded size domain  reaches goal given probability 
problem pspace plan guessed polynomial time checked
pspace  theorem     nppspace   pspace  result follows 
mentioned earlier  unrestricted infinite horizon plan existence problem
exp complete  littman      a   shows problem determining unrestricted plan
existence exp hard domains require plans larger polynomialsize looping plans 
theorem   shows pspace completeness determining plan existence deterministic domains  closely related pspace completeness result bylander         main difference two results theorem applies
compact plans  polynomial instead exponential  complex operator descriptions  conditional effects instead preconditions add delete lists 
include loops  also  proofs show  pspace hardness retained even planning domains one action  looping makes looping plans hard
work with 

   partially ordered plans
partially ordered plans popular representation allow planning algorithms
defer precise commitment ordering plan steps becomes necessary
  

ficomplexity probabilistic planning

planning process  k step partially ordered plan corresponds set k step totally
ordered plans all consistent given partial order  evaluation
partially ordered plan defined evaluation best  worst  average
member set consistent totally ordered plans  optimistic  pessimistic 
average interpretations  respectively 
plan evaluation problem partially ordered plans different totally
ordered plans  single partial order encode totally ordered plans 
hence  evaluating partially ordered plan involves figuring best  in case optimistic
interpretation  worst  for pessimistic interpretation  member  average  for
average interpretation  combinatorial set 

theorem    plan evaluation problem partially ordered plans domains
np complete optimistic interpretation 
proof sketch  membership np follows fact guess totally

ordered plan consistent given partial order accept domain
reaches goal state probability   remember evaluation
performed pl  theorem     therefore deterministically polynomial time 
hardness proof variation construction used theorem    partiallyordered plan evaluate form given figure    consistent total orders
form
start   assign    b      assign     b      assign    b      assign     b     

  assign n  bn    assign n   bn    end    
bi either       possible plans interpreted assignment

n boolean variables ignoring every second assignment action  construction
theorem   shows turn cnf formula planning domain    
easily modified ignore every second action  thus  best totally ordered plan
consistent given partially ordered plan reaches goal probability  
reaches goal probability greater       m satisfies
clauses satisfiable 

theorem    plan evaluation problem partially ordered plans domains
co np complete pessimistic interpretation 

proof sketch  proof membership co np proof hardness

similar proof theorem     show reduction co np complete set
unsatisfiable formulae cnf  plan evaluate form given figure  
interpreted above  proof theorem    construct planning domain
     take g   fsrejg goal states  state srej reached probability
greater   assignment satisfy one clauses formula  
formula unsatisfiable every assignment least one clauses
satisfied  therefore  probability      reaches goal state given
totally ordered plan greater   plan corresponds unsatisfying
sat

  

filittman  goldsmith   mundhenk

start

assign     

assign      

assign     

assign      

assign     

assign      

   
assign n   

assign n    

end

figure    partially ordered plan hard evaluate
assignment  finally  minimum probability consistent partially ordered
plans greater   unsatisfiable 

theorem    plan evaluation problem partially ordered plans domains

pp complete average interpretation 
proof  average interpretation  must decide whether average evaluation
consistent totally ordered plans greater threshold   decided
pp guessing uniformly totally ordered plan checking consistency given
partially ordered plan polynomial time  guessed totally ordered plan consistent 
evaluated polynomial time  theorem    accepted rejected appropriate 
guessed plan inconsistent  computation accepts probability rejects
probability       leaving average consistent orderings unchanged
respect threshold  
pp hardness shown reduction pp complete majsat  let
formula cnf  show construct domain    partially ordered plan
p      majsat average performance    totally
ordered plan consistent p    greater     
let consist clauses c            cm   contain n variables x            xn   domain
     hs   s    a  t  gi actions
  fassign i  b  j   f           ng  b   f     gg   fstart  check  endg 
action assign i  b  interpreted  assign sign b xi    partially ordered plan
p    plan steps
v   f i  b  h  j   f           ng  b   f     g  h   f           mgg   fstart  check  endg
mapping   v  
       fstart  check  endg    i  b  h     assign i  b  
  

ficomplexity probabilistic planning

order e requires consistent plan start first end last step 
steps arbitrarily ordered  formally 
e   f start  q  j q   v   fstart  endgg   f q  end  j q   v   fstart  endgg 
now  define domain    acts given totally ordered plan p consistent
p     domain    consists cross product following polynomial size
deterministic domains ms   final probabilistic transition added 
describe ms precisely  intuitive definitions  domain
ms satisfied plans form assignment n boolean variables
restriction assignment repeated times  for easy checking   domain
satisfied plans correspond satisfying assignments  composite
two domains satisfied plans correspond satisfying assignments 
define domains formally 
first  ms checks whether totally ordered plan matches regular expression
start  assign      m jassign      m  
 assign n    m jassign n    m  
check   assign      jassign         assign n    jassign n      m  
note constant  let  good  state reached ms plan
matches expression  otherwise  state reached  bad   clarify  actions check simply  use up  extra steps used specifying assignment
partially ordered plan 
next  checks whether sequence actions following check action satisfies
clauses following sense  let a  ak sequence  interprets
subsequence a   j    n an  j    n al  j    m   assign x  bl   assignment b            bn
variables x            xn   checks whether assignment satisfies clause cj  
single clauses satisfied way  reaches state  satisfied  
note ms defined deal final end action 
   consists product domain ms transitions action end
follows  state  bad  q  state q   action end lets go
probabilistically state  accept  state  reject   probability     each 
state  good  satisfied   action end goes state  accept   with probability
    otherwise  action end goes state reject  with probability     set goal
states consists state  accept  
analyze behavior    plan p consistent p     ms
p reaches state  bad      p reaches goal state probability      now 
consider plan p ms reaches state  good  called good plan 
p matches regular expression  therefore  every   f           mg exists
bi   f     g steps s i  bi   h  start check  thus  steps
check end
s        i       s n          s        i       s n      in  m 
consequently  sequence actions defined labeling plan steps
 assign    i   assign    i    assign n    m  
  

filittman  goldsmith   mundhenk

means  checks whether clauses satisfied assignment i   
i e   checks whether i  satisfies   therefore     accepts plan p
probability    plan represents satisfying assignment  probability   otherwise 
note assignment corresponds exactly one good plan  therefore  average
good plans    accepts equals fraction satisfying assignments  
since    accepts  bad  plans probability      yields average
plans consistent p    acceptance probabilities    greater
      majsat 
complexity plan existence problem partially ordered plans identical
totally ordered plans 

theorem    plan existence problem partially ordered plans domains npcomplete pessimistic  optimistic average interpretations  plan existence
problem partially ordered plans propositional domains nppp  complete
pessimistic  optimistic average interpretations 

proof  first  note totally ordered plan special type partially ordered plan

evaluation unchanged pessimistic  optimistic  average interpretation 
particular  one ordering consistent given totally ordered
plan  best  worst  average orderings same  therefore  exists
totally ordered plan value greater   partially ordered plan
value greater  the plan   three interpretations 
conversely  partially ordered plan value greater
three interpretations  totally ordered plan value greater  
value best  worst  average ordering partially ordered
plan always lower bound value best consistent totally ordered plan 
given strong equivalence  complexity plan existence partially ordered
plans direct corollary theorems     
pattern partially ordered plan evaluation domains average
interpretation easier decide either optimistic pessimistic interpretations 
propositional domains  pattern opposite  average interpretation harder
decide either optimistic pessimistic interpretations 

theorem    plan evaluation problem partially ordered plans propositional do 

mains nppp  complete optimistic interpretation  co nppp  complete
pessimistic interpretation  pp complete average interpretation 

proof sketch  optimistic interpretation  membership nppp follows

fact guess single suciently good consistent total order evaluate
pp  theorem     hardness nppp shown using straightforward reduction
e majsat  as proof theorem    
pessimistic interpretation  membership co nppp follows fact
guess worst consistent total order evaluate pp  theorem     hardness
  

ficomplexity probabilistic planning

co nppp shown reducing co nppp version e majsat  e majsat  
proof simple adaptation techniques used  example  theorem   above 
average interpretation  problem shown pp combining
argument proof theorem    showing average consistent totally
ordered plans argument proof theorem   showing evaluate
plan propositional domain pp  alternatively  could express evaluation
partially ordered plan average interpretation compact probabilistic acyclic
plan  corollary   states plans evaluated pp  pp hardness follows directly
theorem    totally ordered plans special case partially ordered plans
evaluating totally ordered plans pp hard 

   applications
help illustrate utility results  section cites several planners
literature analyzes computational complexity problems attack 
give detailed explanations planners themselves  this  refer reader
original papers  focus three planning systems  witness  brown university  
buridan  university washington   treeplan  university british columbia  
process making connections planners  describe work relates
discounted reward criterion  partial observability  domain representations  partial
order conditional planning  policy based planning  approximate planning 

    witness

witness algorithm  cassandra  kaelbling    littman        kaelbling et al        
solves partially observable markov decision processes using dynamic programming approach  basic algorithm finds optimal unrestricted solutions finite horizon problems 
papadimitriou tsitsiklis        showed plan existence problem polynomialhorizon partially observable markov decision processes pspace complete 
extension finite horizon algorithm  kaelbling et al         sketch method
finding optimal looping plans domains  although presented
formal algorithm  unreasonable say pure form problem
extended version witness attacks one finding valid polynomial size looping plan
partially observable domain  similarities problem described
section   domains plans identical form 
apparent differences witness optimizes reward function instead probability
goal satisfaction witness works partially observable domains whereas
results defined terms completely observable domains  apparent
differences insignificant  however  computational complexity point view 
first  witness attempts maximize expected total discounted reward
infinite horizon  sometimes called optimizing time separable value function   argued
condon         problem defined terms sum discounted rewards
recast one goal satisfaction  argument proceeds roughly follows  let        
discount factor r s  a  immediate reward received taking action
state s 
  

filittman  goldsmith   mundhenk

define

 a r s    a   
r  s  a    max r s ra  s    amin
      min r s    a     
 

 a
 

 

 a

 

 

 

this    r   s  a    value plan
respect revised reward function simple linear transformation true value 
now  introduce auxiliary state g goal state create new transition
function t  t   s  a  g          r   s  a  t   s  a  s                 r   s  a  t s  a  s   
s     g  t  well defined transition function probability goal satisfaction
plan transition function t  precisely expected total discounted
reward reward function r  transition function t  thus  problem stated
one optimizing expected total discounted immediate rewards turned
equivalent problem optimizing goal satisfaction slight change transition
function one additional state  means fundamental computational
complexity difference two different types planning objectives 
second apparent difference problem solved extended witness
algorithm described section   partial versus complete observability 
fact  results address partial observability  albeit indirectly  formulation
plan existence problem  plans constrained make conditional branches  in
totally ordered partially ordered cases   branch distinctions made
step transition function  in acyclic looping cases   two choices correspond
unobservable partially observable domains  respectively  partially observable
domain  plan existence problem becomes one finding valid polynomial size finitestate controller subject given observability constraints  nothing complexity
proofs depends presence absence additional observability constraints  therefore 
direct corollary theorem   plan existence problem polynomial horizon
plans unobservable domains np complete  papadimitriou   tsitsiklis       
theorem   plan existence problem polynomial size looping plans partially
observable domains np complete  this new result  
interesting note computational complexity searching size bounded
plans partially observable domains generally substantially less solving
corresponding unconstrained partially observable markov decision process  example 
found plan existence problem acyclic plans propositional domains
nppp  complete  theorem     corresponding unconstrained problem determining existence history dependent policy polynomial horizon  compactly
represented partially observable markov decision process  expspace complete
 theorem      goldsmith et al         theorem     mundhenk et al       b  
gap enormous  expspace exp pspace p  exp already
provably intractable worst case  contrast expspace complete problems 
conceivable good heuristics nppp  complete problems created extensions
recent advances heuristics np complete problems  therefore  hope
devising effective planning algorithms building observations paper
searching optimal size bounded plans instead optimal unrestricted plans  fact  recent planners propositional domains  majercik   littman      a      b 
domains  hansen        motivated results 
  

ficomplexity probabilistic planning

domain type

propositional

propositional

horizon type
polynomial
polynomial
infinite
infinite

size bounded plan unrestricted plan
np complete
nppp  complete
np complete
pspace complete

pspace complete
expspace complete
undecidable
undecidable

table    complexity results plan existence partially observable domains
table   summarizes complexity results planning partially observable domains 
results size bounded plans corollaries theorems            paper  results unrestricted plans due papadimitriou tsitsiklis       
  at  polynomial   goldsmith et al          propositional  polynomial   hanks       
 infinite horizon   last result derived noting isomorphism infinitehorizon problem emptiness problem probabilistic finite state automata 
undecidable  rabin        

    buridan

buridan planner  kushmerick et al         finds partially ordered plans propositional domains pso representation  two identifiable differences
problem solved buridan problem analyzed section    representation
planning problems fact buridan restricted find polynomial size
plans  address differences below 
although  surface  pso different st  either converted
polynomial time polynomial increase domain size  particular 
effect action pso represented single decision tree consisting proposition
nodes  like st  random nodes  easily simulated st using auxiliary propositions  
leaves list propositions become true another list propositions
become false leaf reached  type correlated effect easily
represented st using chain rule probability theory decompose probability
distribution separate probabilities proposition careful use   new 
sux  thus  pso domain converted similar size st domain quickly 
similarly  domain st converted pso polynomial expansion 
conversion complex sketch here  follows proof equivalence st simplified representation called  littman      a   given polynomial
equivalence st pso  complexity results st carry pso  
results described paper concern planning problems bound given
size plan sought  although kushmerick et al         explicitly describe
planner one prefers small plans large plans  design planner
one searches space plans makes notion plan size central
algorithm  indeed  public domain buridan implementation uses plan size part
best first search procedure identifying suciently successful plan  means that 
things equal  shorter plans found larger plans  furthermore 
assure termination  planner considers fixed number plans halting  thus
   precise  true complexity classes closed log space reductions 

  

filittman  goldsmith   mundhenk

putting limit indirectly maximum allowable plan size  so  although buridan
attempt solve precisely problem considered  fair say
problem consider idealization problem attacked buridan  regardless 
lower bounds complexity apply buridan 
kushmerick et al         looked generating suciently successful plans
optimistic interpretation pessimistic interpretation  explicitly examined plan evaluation problem partially ordered plans interpretations 
therefore  theorems       apply buridan 
sophisticated c buridan planner  draper et al         extends buridan
plan partially observable domains produce plans conditional execution 
results work shed light computational complexity problem addressed
c buridan  draper et al         devised representation partially ordered acyclic
 conditional  plans  representation  plan step generates observation label
function probabilistic outcome step  step associated set
context labels dictating circumstances step must executed  plan
step executed context labels consistent observation labels produced
earlier steps  totally ordered form  type plan expressed compact
acyclic plan  corollary   used show plan evaluation plan existence
problems totally ordered version c buridan s conditional plan representation
propositional domains pp complete nppp  complete  respectively 
results above  consider evaluating searching plans partially
ordered plans conditional execution  once  nonetheless 
sorts techniques presented paper applied analyzing problems
attacked c buridan  example  consider plan existence problem c buridan s
partially ordered conditional plans optimistic interpretation  problem asks
whether partially ordered conditional plan total order reaches
goal sucient probability  equivalent asking whether totally
ordered conditional plan reaches goal sucient probability  therefore 
problem nppp  complete  argument previous paragraph 
spite many superficial differences problems analyzed paper
studied creators buridan planners  results quite relevant
understanding work 

    treeplan
family planners designed generate decision tree based representation
stationary policies  mappings state action   boutilier et al         boutilier  
poole        boutilier   dearden        probabilistic propositional domains  refer
planners collectively treeplan planners  again  planners solve
problems identical problems addressed paper closely
related 
planner described boutilier et al         finds solutions maximize expected
total discounted reward compactly represented markov decision processes  the domain
representation used expressively equivalent st   mentioned earlier  difference
maximizing goal satisfaction maximizing expected total discounted reward
  

ficomplexity probabilistic planning

superficial one  problem addressed planner exp complete  littman      a  
although policies used boutilier et al         appears quite dissimilar finitestate controllers described work  policies converted type similarly
sized compact looping plan  an extension type plan described corollary    
conversion stationary policies looping plans described proof
theorem    except resulting plans represented compactly 
later work  boutilier dearden        show possible limit size
representation policy treeplan still obtain approximately optimal
performance  necessary because  general  size decision trees needed
represent optimal policies exponentially large  keeping decision trees
getting large  resulting planner becomes subject extension theorem  
and  therefore  attacks pspace complete problem 
one emphasis boutilier dearden        finding approximately optimal
solutions  hope easier finding optimal solutions 
explore worst case complexity approximation paper  although lusena 
goldsmith  mundhenk        produced strong negative results area 
related issue one using simulation  random sampling  find approximately optimal
solutions probabilistic planning problems  empirical successes obtained
related approach reinforcement learning  tesauro        crites   barto        
but  again  worst case complexity probabilistic planning known
lower approximation simulation 

   conclusions
paper  explored computational complexity plan evaluation plan existence probabilistic domains  found that  compactly represented propositional
domains  restricting size form policies consideration reduced
computational complexity plan existence exp complete unrestricted plans
pspace complete polynomial size looping plans nppp  complete polynomialsize acyclic plans  contrast  domains  restricting form policies
consideration increased computational complexity plan existence p complete
unrestricted plans np complete totally ordered plans  plan
smaller domain operates often unable exploit important markov
properties domain  able characterize precisely complexity
problems examined regard current state knowledge complexity theory 
several problems studied turned nppp  complete  class nppp promises
useful researchers uncertainty artificial intelligence captures
type problems resulting choosing   guessing   solution evaluating
probabilistic behavior  precisely type problem faced planning algorithms
probabilistic domains  captures important problems domains well 
constructing explanations belief networks designing robust communication networks 
provide new conceptually simple nppp  complete problem  e majsat  may
useful explorations direction 
basic structure results plan evaluation complete class c  
plan existence typically npc  complete  basic structure holds determin  

filittman  goldsmith   mundhenk

istic domains  evaluating totally ordered plan propositional domain p complete  for
suciently powerful domain representations  determining existence polynomialsize totally ordered plan npp   np complete 
pragmatic standpoint  intuition searching small plans efficient searching arbitrary size plans suggests exact dynamic programming
algorithms  successful domains  may effective propositional
domains  focus efforts set small plans  algorithm development
energy  therefore  might fruitfully spent devising heuristics problems class nppp
class captures essence searching small plans probabilistic domains some
early results direction appearing  majercik   littman      a      b   complexity theorists recently begun explore classes nppp lie
polynomial hierarchy pspace algorithm designers come classes even
recently  paper marks beginning exploration class problems  much work still done probing algorithmic implications  hope
heuristics nppp could lead powerful methods solving range important
uncertainty sensitive combinatorial problems 

acknowledgements
work supported part grants nsf iri          career  littman  
nsf ccr          goldsmith   gratefully acknowledge andrew klapper  anne condon  matthew levy  steve majercik  chris lusena  mark peot  reviewers helpful
feedback conversations topic 

appendix a  complexity e majsat
e majsat problem is  given pair    k  consisting boolean formula n
variables x            xn number   k n  assignment first k variables
x            xk majority assignments remaining n k variables xk             xn
satisfies  
k   n  precisely boolean satisfiability  classic np complete problem 
asking whether exists assignment variables makes
true  k      e majsat precisely majsat  well known pp complete problem 
asking whether majority total assignments makes true 
deciding instance e majsat intermediate values k different character 
involves np type calculation pick good setting first k variables
pp type calculation see majority assignments remaining variables makes
true  akin searching good answer  plan  schedule  coloring  belief network
explanation  etc   combinatorial space  good  determined computation
probabilistic quantities  type computation described class
nppp   show next e majsat nppp  complete 

theorem   

e majsat

nppp  complete 
  

ficomplexity probabilistic planning

proof  membership nppp follows directly definitions  show completeness
e majsat  first observe  tor
an        nppp np
 closure pp complete

set majsat  thus  nppp computation modeled nondeterministic machine
n that  possible computation  first guesses sequence bits controls
nondeterministic moves  deterministically performs computation input x s 
writes formula qx s variables z            zl query majsat 
finally  n  x  oracle majsat accepts s  qx s   majsat 
given input x  cook s theorem  construct formula x variables
y           yk z           zl every assignment a           ak   b            bl holds
x  a            ak   b            bl     qx a a  b            bl    thus   x   k    e majsat
assignment y            yk   qx s   majsat n  x  accepts 
k

references

allender  e     ogihara  m          relationships among pl   l  determinant 
theoretical informatics applications               
lvarez  c     jenner  b          hard log space counting class  theoretical computer
science            
backstrom  c          expressive equivalence planning formalisms  artificial intelligence 
                
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                  
balcazar  j   daz  j     gabarro  j               structural complexity i ii  eatcs
monographs theoretical computer science  springer verlag 
borodin  a   cook  s     pippenger  n          parallel computation well endowed
rings space bounded probabilistic machines  information control           
        
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions computational leverage  preparation 
boutilier  c     dearden  r          approximating value trees structured dynamic programming  saitta  l   ed    proceedings thirteenth international conference
machine learning 
boutilier  c   dearden  r     goldszmidt  m          exploiting structure policy construction  proceedings fourteenth international joint conference artificial
intelligence  pp            
boutilier  c     poole  d          computing optimal policies partially observable
decision processes using compact representations  proceedings thirteenth
national conference artificial intelligence  pp             aaai press the mit
press 
  

filittman  goldsmith   mundhenk

bylander  t          computational complexity propositional strips planning 
artificial intelligence              
cassandra  a  r   kaelbling  l  p     littman  m  l          acting optimally partially
observable stochastic domains  proceedings twelfth national conference
artificial intelligence  pp            seattle  wa 
chapman  d          planning conjunctive goals  artificial intelligence              
condon  a          complexity stochastic games  information computation 
                
crites  r  h     barto  a  g          improving elevator performance using reinforcement
learning  touretzky  d  s   mozer  m  c     hasselmo  m  e   eds    advances
neural information processing systems   cambridge  ma  mit press 
dearden  r     boutilier  c          abstraction approximate decision theoretic planning  artificial intelligence                    
draper  d   hanks  s     weld  d          probabilistic planning information gathering
contingent execution  proceedings aaai spring symposium decision
theoretic planning  pp        
drummond  m     bresina  j          anytime synthetic projection  maximizing
probability goal satisfaction  proceedings eighth national conference
artificial intelligence  pp           morgan kaufmann 
erol  k   nau  d  s     subrahmanian  v  s          complexity  decidability undecidability results domain independent planning  artificial intelligence            
gill  j          computational complexity probabilistic turing machines  siam journal
computing                 
goldman  r  p     boddy  m  s          epsilon safe planning  proceedings   th
conference uncertainty artificial intelligence  uai     pp          seattle 
wa 
goldsmith  j   littman  m     mundhenk  m       a   complexity plan existence
evaluation probabilistic domains  tech  rep  cs          department computer
science  duke university 
goldsmith  j   littman  m  l     mundhenk  m       b   complexity plan existence
evaluation probabilistic domains  proceedings thirteenth annual conference uncertainty artificial intelligence  uai      pp          san francisco 
ca  morgan kaufmann publishers 
goldsmith  j   lusena  c     mundhenk  m          complexity deterministically
observable finite horizon markov decision processes  tech  rep          department
computer science  university kentucky 
  

ficomplexity probabilistic planning

hanks  s          decision theoretic planning unobservable domains undecidable 
personal communication 
hansen  e  a          finite memory control partially observable systems  ph d  thesis 
university massachusetts 
jung  h          probabilistic time space  proceedings   th icalp  pp          
lecture notes computer science  springer verlag 
kaelbling  l  p   littman  m  l     cassandra  a  r          planning acting
partially observable stochastic domains  artificial intelligence                    
koenig  s     simmons  r  g          risk sensitive planning probabilistic decision
graphs  proceedings  th international conference principles knowledge
representation reasoning  pp          
kushmerick  n   hanks  s     weld  d  s          algorithm probabilistic planning 
artificial intelligence                    
ladner  r          polynomial space counting problems  siam journal computing     
          
lin  s  h     dean  t          generating optimal policies high level plans conditional branches loops  proceedings third european workshop
planning  pp          
littman  m  l       a   probabilistic propositional planning  representations complexity  proceedings fourteenth national conference artificial intelligence 
pp           aaai press the mit press 
littman  m  l       b   solving large pomdps  lessons complexity theory  talk
presented darpa ai workshop providence  ri  slides available url
http   www cs duke edu mlittman talks darpa   pomdp ps 
lovejoy  w  s          survey algorithmic methods partially observable markov
decision processes  annals operations research                
lusena  c   goldsmith  j     mundhenk  m          nonapproximability results markov
decision processes  tech  rep  uk cs dept tr         university kentucky 
majercik  s  m     littman  m  l       a   maxplan  new approach probabilistic
planning  simmons  r   veloso  m     smith  s   eds    proceedings fourth
international conference artificial intelligence planning  pp         aaai press 
majercik  s  m     littman  m  l       b   using caching solve larger probabilistic
planning problems  proceedings fifteenth national conference artificial
intelligence  pp           aaai press the mit press 
mansell  t  m          method planning given uncertain incomplete information 
proceedings  th conference uncertainty artificial intelligence  pp 
         morgan kaufmann publishers 
  

filittman  goldsmith   mundhenk

mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
 th national conference artificial intelligence  pp          
mundhenk  m   goldsmith  j     allender  e       a   complexity policy evaluation
finite horizon partially observable markov decision processes  proceedings
  nd symposium mathematical foundations computer science  published
lecture notes computer science   springer verlag 
mundhenk  m   goldsmith  j   lusena  c     allender  e       b   encyclopaedia complexity results finite horizon markov decision process problems  tech  rep  uk cs
dept tr         university kentucky 
papadimitriou  c  h          computational complexity  addison wesley  reading  ma 
papadimitriou  c  h     tsitsiklis  j  n          complexity markov decision processes  mathematics operations research                  
platzman  l  k          feasible computational approach infinite horizon partiallyobserved markov decision problems  tech  rep  j       georgia institute technology 
atlanta  ga 
puterman  m  l          markov decision processes discrete stochastic dynamic programming  john wiley   sons  inc   new york  ny 
rabin  m  o          probabilistic automata  information control                 
roth  d          hardness approximate reasoning  artificial intelligence           
        
simon  j          central problems computational complexity  ph d  thesis 
cornell university  cornell department computer science technical report
tr       
smith  d  e     williamson  m          representation evaluation plans loops 
working notes      stanford spring symposium extended theories
action 
tesauro  g          td gammon  self teaching backgammon program  achieves masterlevel play  neural computation                 
toda  s          pp hard polynomial time hierarchy  siam journal computing              
toran  j          complexity classes defined counting quantifiers  journal acm 
                
vinay  v          counting auxiliary pushdown automata semi unbounded arithmetic
circuits  proc   th structure complexity theory conference  pp           ieee 

  


