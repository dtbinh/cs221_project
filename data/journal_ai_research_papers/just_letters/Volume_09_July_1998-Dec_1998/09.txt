journal of artificial intelligence research                 

submitted       published      

the automatic inference of state invariants in tim
maria fox
derek long

maria fox dur ac uk
d p long dur ac uk

department of computer science
university of durham  uk

abstract
as planning is applied to larger and richer domains the effort involved in constructing
domain descriptions increases and becomes a significant burden on the human application
designer  if general planners are to be applied successfully to large and complex domains
it is necessary to provide the domain designer with some assistance in building correctly
encoded domains  one way of doing this is to provide domain independent techniques for
extracting  from a domain description  knowledge that is implicit in that description and
that can assist domain designers in debugging domain descriptions  this knowledge can
also be exploited to improve the performance of planners  several researchers have explored
the potential of state invariants in speeding up the performance of domain independent
planners  in this paper we describe a process by which state invariants can be extracted
from the automatically inferred type structure of a domain  these techniques are being
developed for exploitation by stan  a graphplan based planner that employs state analysis
techniques to enhance its performance 

   introduction
stan  long   fox  in press  is a domain independent planner based on the constraint
satisfaction technology of graphplan  blum   furst         its name is derived from the
fact that it performs a variety of pre processing analyses  state analyses  on the domain
description to which it is applied  that assist it in planning eciently in that domain  stan
took part in the aips    planning competition  the first international competition in which
domain independent planners were compared in terms of their performance on well known
benchmark domains  of the four planners that competed in the strips track  three were
based on the graphplan  blum   furst        architecture  the most important difference between stan and the other graphplan based planners was its use of state analysis
techniques  although these techniques were not  at that stage  fully integrated with the
planning algorithm stan gave an impressive performance as can be determined by examination of the competition results  there is a description of the competition  its objectives
and the results  at the aips    planning competition ftp site  see appendix a  
one of the most important of the analyses performed by stan is the automatic inference
of state invariants  as will be described in this paper  state invariants are inferred from the
type structure of the domain that is itself automatically inferred  or enriched  by stan  the
techniques used are completely independent of the planning architecture  so can be isolated
in a pre processing module that we call tim  type inference module   tim can be used
by any planner  regardless of whether it is based on graphplan or on any other underlying
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fifox   long

architecture  tim has been implemented in c   and executables and examples of output
are available at our web site  see appendix a  and in online appendix   
tim takes a domain description in which no type information need be supplied and infers
a rich type structure from the functional relationships between objects in the domain  if type
information is supplied tim can exploit it as the foundation of the type structure and will
often infer an enriched type structure on this basis  state invariants can be extracted from
the way in which the inferred types are partitioned  the consequence is that the domain
designer is relieved of a considerable overhead in the description of the domain  whilst it is
easy to hand code both types and state invariants for simple domains containing few objects
and relations  it becomes progressively more dicult to ensure cross consistency of handcoded invariants as domains become increasingly complex  similarly  the exploitable type
structure of a domain may be much richer than can easily be provided by hand  we have
observed that tim often infers unexpected type partitions that increase the discrimination of
the type structure and provide corresponding benefits to stan s performance  we therefore
see tim as a domain engineering tool  helping to shift the burden of domain design from
the human to the automatic system 
the usefulness of both types and state invariants is well documented  types have been
provided by hand since it was first observed that they reduce the number of operator instantiations that have to be considered in the traversal of a planner s search space  the
elimination of meaningless instantiations is particularly helpful in a system such as graphplan  in which the structure to be traversed is explicitly constructed prior to search  we
believe that the benefits to be obtained from type inference in planning are similar to those
obtained in programing language design  type inference is more powerful than type checking
and can assist in the identification of semantic errors in the specification of the relational
structure of the domain  indeed  we have found tim to be a useful domain debugging
tool  allowing us to identify aws in some published benchmark domains  we also used
tim to reveal the underlying structure of the mystery domain  a disguised transportation
problem domain  used in the planning competition  the mystery domain is described in
appendix c   
the use of domain knowledge can significantly improve the performance of planners 
as shown by a number of researchers  gerevini and schubert      a      b  have considered the automatic inference of some state constraints and demonstrated that a significant
empirical advantage can be obtained from their use  kautz and selman        have handcoded invariants and provided them as part of the domain description used by blackbox 
they demonstrate the performance advantages obtained and acknowledge the importance of
inferring such invariants automatically  mccluskey and porteous        have also demonstrated the important role that hand coded state invariants can play in domain compilation
for ecient planning  earlier work by kelleher and cohn        and morris and feldman
       explores the automatic generation of some restricted invariant forms  we discuss
these  and other  related approaches in section   
in this paper we will describe the type inference process employed by tim and explain
how four different forms of state invariant can be extracted from the inferred type structure 
we will argue that tim is correct since it never infers sentences that are not state invariants 
we will then provide experimental results demonstrating the performance advantages that
can be obtained by the use of types 
   

fiautomatic inference of state invariants

drive

unfuelled  
fuelled

 

drive

at  

load

in  
at

 

unload

figure    a simple transportation domain seen as a collection of fsms 

   the type inference module
one way of viewing strips  fikes   nilsson        domains is as a collection of finite state
machines  fsms  with domain constants traversing the states within them  for example  in
a simple transportation domain there are rockets and packages  with rockets being capable
of being at locations and of moving  by driving  from being at one location to being at
another  and of being fuelled or unfuelled  and of moving between these two states  at can
be seen as forming a one node fsm  and fuelled and unfuelled as forming a two node fsm 
this view is depicted in figure   
   

fifox   long

packages can be at locations or in rockets  and can move between these states in the
resulting two node fsm  in this example  rockets can be in states that involve more than
one fsm  since they can be both at and fuelled  or at and unfuelled  strips domains
have been seen in this way in earlier work  mccluskey   porteous        grant         as
discussed in section   

    types in tim

when two objects participate in identical fsms they are functionally equivalent and can be
seen to be of the same type  the notion of type here is similar to that of sorts in the work of
mccluskey and porteous         a primary objective of the tim module is to automatically
identify the equivalence classes that form the primitive types in a domain description and
to infer the hierarchical type structure of a domain on the basis of the primitive types  the
way this is done is discussed in section      the primitive types are functional equivalence
classes  and the objects of the domain are partitioned into these classes  having identified
the types of the domain objects tim infers the types of the parameters of all of the operators 
state invariants are inferred as a final stage 
the early parts of this process rely on three key abstract data types  the property space 
the attribute space and the transition rule  formal definitions of these components are
provided in section      but we provide informal descriptions here to support the following
definitions  transition rules represent the state transformations that comprise the fsms
traversed by the objects in the domain  property spaces are fsms  together with the objects
that participate in them  the properties these objects can have and the transition rules by
which they can acquire these properties  attribute spaces contain collections of objects that
have  or can acquire  the associated attributes  attributes differ from properties because
they can be acquired  or lost  without the associated loss  or acquisition  respectively  
of another attribute  attribute spaces also contain the transition rules that enable the
acquisition  or loss  of these attributes  once the state and attribute spaces have been
constructed we assign types to the domain objects according to their membership of the
property and attribute spaces  any two objects that belong in identical property and
attribute spaces will be assigned the same type  it is therefore very important to ensure
that the property and attribute spaces are adequately discriminating  otherwise important
type distinctions can be lost  much of the subtlety of the algorithm described in section    
is concerned with maintaining adequate discrimination in the construction of these spaces 
we present the following definitions here to support our informal characterisation of the
roles of types in strips and in tim  the definitions are used again in sections     and     
which discuss how types are assigned to objects and operator parameters 

definition   a type vector is a bit vector in which each bit corresponds to membership  or
otherwise  of a unique state or attribute space  the number of bits in the vector is always
equal to the number of distinct state and attribute spaces 

definition   a type is a set of domain objects each associated with the same type vector 
definition   a type vector  v   in which two distinct bits  si and sj   are set corresponds to

a sub type of the type associated with a vector  v   in which only si is set  all other settings
   

fiautomatic inference of state invariants

being equal   then the type associated with v  can be seen to be a super type of the type
associated with v   

definition   a type structure is a hierarchy of types organised by sub type relationships
between the component types 

definition   a type structure is adequately discriminating if objects are only assigned to
state  and attribute  spaces that characterize their state transitions  and attributes  

definition   a type structure is under discriminating if it fails to distinguish types that
are functionally distinct 

definition   a type structure is over discriminating if functionally identical objects are
assigned to different types 

there are two distinct ways in which types play a role in the specification of a domain 
they can restrict the set of possible operator instances to eliminate all those that are
meaningless in the domain and hence improve eciency by reducing the size of the search
space  and they can eliminate unsound plans that could be constructed if they were not
provided  the following examples clarify the difference between these two roles  the
untyped schema 

drive x y z 
pre 
add 
del 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

permits more instances than the typed schema 

drive x y z 
params 
pre 
add 
del 

x rocket y package z location
at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

but all meaningless instances will be eliminated during search because their preconditions
will not be satisfiable  on the other hand  the typed schema 

y x y z 
params 
pre 
add 
del 

x aircraft y z location
at x y 
at x z 
at x y 

ensures that only aircraft can be own  whilst the untyped schema 
   

fifox   long

y x y z 
pre 
add 
del 

at x y 
at x z 
at x y 

allows ying as a means of travel for any object that can be at a location  including packages 
and other objects  as well as aircraft  tim is capable of automatically inferring all types
playing the restrictive role indicated in the typed drive operator  however  tim cannot infer
type information that is not implicit in the domain description  thus  given the untyped fly
schema  there are no grounds for tim to infer any type restrictions  tim will draw attention
to unintended under discrimination by making packages and aircraft indistinguishable at
the type level  unless there is distinguishing information provided in other schemas  at
the very least tim will make explicit the fact that packages are amongst those objects that
can y  this assists the domain designer in tracking errors and omissions in a domain
description  but unstated intended distinctions cannot be enforced by tim 

    an overview of the tim algorithm

figure   gives a broad outline of the tim algorithm  a more detailed description is given
in appendix b  the role of each component of the algorithm is described  together with a
commentary on discussing related issues and justifications  in sections          and     
broadly  tim begins with an analysis of the domain operators  extracting transition rules
that form the foundations of the property and attribute spaces described previously  these
rules are used to separate properties into equivalence classes from which the property and
attribute spaces are constructed  tim then analyses the initial state in order to assign the
domain objects to their appropriate spaces  this analysis also identifies the initial properties
of individual objects and uses them to form states of the objects in the property spaces  the
initial states in a property space are then extended by the application of the transition rules
in that space to form complete sets of states accounting for all of the states that objects in
that property space can possibly inhabit  as described in section      attribute spaces do
not behave like fsms  as property spaces do  and the extension of these is carried out by a
different procedure  one that can add new objects to these spaces  rather than new states 
tim then assigns types to objects using the pattern of membership of the spaces it has
constructed  finally  tim uses the spaces to determine invariants that govern the behaviour
of the domain and the objects in it 

    constructing the transition rules

we begin by describing the process by which the transition rules are constructed  the
following definitions are required 

definition   a property is a predicate subscripted by a number between   and the arity of
that predicate  every predicate of arity n defines n properties 

definition   a transition rule is an expression of the form 
property   property    property 
   

fiautomatic inference of state invariants

construct base prss  section     
split prss  section     
construct transition rules  section     
seed property and attribute spaces  section     
assign transition rules  section     
analyse initial state  section     
extend property spaces  section     
extend attribute spaces  section     
identify types  section     
construct invariants  section     
figure    outline of the tim algorithm 
in which the three components are bags of zero or more properties called enablers  start and
finish  respectively 

the double arrow     is read enables and the single arrow     is read the transition
from  so 

e s f

is read  e enables the transition from s to f  the properties in s are given up as a result of
the transition  the properties in f are acquired as a result of the transition  the properties
in e are not given up 
if enablers is empty we write 

start   finish
if start is empty we write 

transition rule  

enablers   null   finish
if finish is empty we write 

transition rule  

enablers   start   null
the bag null is the empty bag of properties  its role is to emphasise that  in transition
rule    nothing is given up as a result of the transition and  in transition rule    nothing is
acquired  rules that have a null start and a null finish are discarded because they describe
null transitions 
when the property bags contain more than one element they are separated by commas 
the collection 

pk   qm       rn
   

fifox   long

is interpreted to mean that each of the properties in the collection can be satisfied as
many times as they appear in the collection  the comma is therefore used to separate the
elements of a bag  we use  to denote bag union    to denote bag difference  
 to denote
bag intersection and v to denote bag inclusion 

definition    a property relating structure  prs  is a triple of bags of properties 
the first stage of the algorithm constructs a set of transition rules from a set of operator
schemas  each operator schema is analysed with respect to each parameter in turn and  for
each parameter  a prs is built  the first bag of properties is formed from the preconditions
of the schema  and the number used to form the property is the argument position of
the parameter being considered  for example  if the precondition is on x  y    and the
parameter being considered is x   the property formed is on    this bag  called precs 
contains the enablers that will be used in the formation of the transition rules  the second
bag  called deleted precs  of properties is formed from all of the preconditions that appear
on the delete list of the schema  with respect to this same parameter   the third bag  called
add elements  contains the properties that can be formed from the add list of the schema 
the prs contains no deleted elements component   it is assumed that every element on
the delete list of a strips operator appears in the precondition list  this is a reasonable
restriction given that strips operators do not allow the use of conditional effects  it is
further assumed that every pair of atoms on the delete list of a schema will be distinct for
all legal instantiations of the schema  this does not constitute a significant restriction since
operator schemas can always be easily rephrased whenever this condition is violated 
we now consider the process by which prss are constructed  given the schema 

drive x y z 
pre 
add 
del 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

and considering the parameter x   the following prs will be built 

prs  

precs  
at    fuelled 
deleted precs   at    fuelled 
add elements   at    unfuelled 
by considering the parameter y we obtain 

prs  
precs  
at 
deleted precs   at 
add elements  
and by considering the parameter z we obtain 
   

fiautomatic inference of state invariants

prs  

precs  
location 
deleted precs  
add elements   at 

in constructing these structures we are identifying the state transformations through which
the objects  instantiating the operator parameters  progress  note that objects that instantiate x go from being fuelled and at somewhere to being unfuelled and at somewhere  objects
that instantiate y lose the property of having anything at them and gain nothing as a result of application of this operator  and objects that instantiate z continue being locations
and gain the property of having something at them  we now convert these structures into
transition rules in order to correctly capture these state transformations 
our standard formula for the construction of rules from prss is 

precs   deleted precs   deleted precs   add elements
thus  using the prs   above  we could build the rule 

at    fuelled    at    unfuelled 
a potential problem with this rule is that it causes at  and fuelled  to be linked in state
transformations  so that at  and fuelled  become associated with the same property space
and  as a consequence  objects that can be at places  but that cannot be fuelled  may be

indistinguishable from objects that require fuelling before they can be moved  in fact  we
wish the transition rules to express the fact that being fuelled enables things to go from
being at one place to being at another place  whilst not excluding the possibility that there
may be other enablers of this transition 
we therefore begin a second phase of prs construction by identifying  for special treatment  prss in which a property appears in both the deleted precs and the add elements 
this is a property that is exchanged on application of the operator  that is  the relation
continues to hold between the identified argument and some other object or objects  not
necessarily the same object or objects as before the application of the operator   for example  in prs    the vehicle is at a new location after application of the operator  and no
longer at the old location  we observe that the vehicle must be fuelled to make this transition  to separate the transition from this condition we split the prs  splitting identifies
the exchanged properties in a prs and creates one new prs for each exchange and one
for the unexchanged properties  therefore  splitting a prs always results in at most k    
 and at least k  new prss  where k is the number of exchanges that the prs represents 
by splitting prs   we construct two new prss  one characterizing the exchange of the at
property  and one characterising the fuelled to unfuelled transition 
the first of the new prss is 

prs  

precs  
at    fuelled 
deleted precs   at 
add elements   at 
   

fifox   long

from which the rule

fuelled    at    at 
is constructed  it should be noted that the property of being fuelled is no longer seen as
part of the state transformation but only as an enabler  which is why it does not appear in
the deleted precs bag in the resulting prs 
the second new prs captures the fact that at  can be seen as an enabler for the
transition from fuelled  to unfuelled  

prs  

precs  
at    fuelled 
deleted precs   fuelled 
add elements   unfuelled 

in this prs there are no further splits required since no other properties are exchanged in
it  a more general example is as follows 

prs  

precs  
p   p     pn
deleted precs   p     pi pi k    pm
add elements   p     pi q     qk

from which i prss would be constructed to deal with each of the i exchanged pairs and a
final prs  prs    would be constructed to describe the remainder of the transition making
i     prss in total 

prs  

precs  
p    p     pn
deleted precs   pi k    pm
add elements   q     qk

there is no need to consider additional pairings of add and delete list elements  since these
would not correspond to exchanges of properties  the splitting process is justified in section      the standard rule construction formula can be applied to prs    yielding the
rule
at    fuelled    unfuelled 
it should be observed that  even if the add elements bag contains multiple properties  a
single rule will always be built when the standard construction formula is applied 
on considering the remaining prss    and    it can be observed that they each contain
an empty field  in   the add elements field is empty and in   the deleted precs field is empty 
when a prs has an empty field special treatment is required  from prs   we build the
rule

at    null

to represent the fact that the object that instantiates y gives up the property of having
something at it  and gains nothing in return  from   we build the rule

location    null   at 
   

fiautomatic inference of state invariants

to represent the fact that the object that instantiates z gains the property of having something at it by virtue of being a location  and gives up nothing in return  these rules have
a somewhat different status from the ones that characterize the exchange of properties  in
these cases properties are being lost or gained  without exchange  so can be seen as resources
that can be accumulated or spent by domain objects rather than as states through which
the domain objects pass  for example  a location can acquire the property of having something at it  without relinquishing anything in return  whereas an object that requires fuel
can only become fuelled by relinquishing the property of being unfuelled  and vice versa 
increasing and decreasing resources are identified as attributes and are distinguished from
states  this distinction will later prove to be very important  since the generation of true
state invariants depends upon it being made correctly  properties that can increase and
decrease without exchange are not invariant  and false assertions would be proposed as
invariants if they were treated in the same way as state valued properties 
a rule of the form constructed from prs   must be constructed separately for every
property in the add elements bag because these properties must be individually characterized as increasing resources  rules constructed using null are distinguished as attribute
transition rules  if the null is on the left side of the   the rule is an increasing attribute
transition rule  if the null is on the right hand side then the rule is a decreasing attribute
transition rule 
a final case to consider during rule construction is the case in which a prs has an empty
precs field  this happens if the parameter  with respect to which the prs was constructed 
did not appear in any of the preconditions of the operator schema  in this case a set of
rules is constructed  one for each property  a  in the add elements bag  of the form

null   a
reecting the fact that a is an increasing resource  the deleted precs field will necessarily
also be empty in this case  

definition    a state is a bag of properties 
when it is necessary to distinguish a bag from a set  square brackets will be used to denote
the bag 
definition    a property space is a tuple of four components  a set of properties  a set
of transition rules  a set of states and a set of domain constants 

definition    an attribute space is a tuple of three components  a set of properties  a set

of transition rules and a set of domain constants 

it is helpful to observe here that the state and attribute spaces represent disjoint collections of properties  and that these disjoint collections are formed from the transition
rules by putting the start and finish properties of each rule into the same collection  for
example  given two rules 
e     p   p   p      q    q  
and
e     r   r      s   
   

fifox   long

the collections  p   p   p   q   q   and  r   r   s   would be formed  if a property appears in
the start or finish of both rules then a single collection will be formed from the two rules 
the last stage in the rule construction phase is to identify the basis for the construction
of property and attribute spaces  this is done by uniting the left and right hand sides of the
rules  uniting forms collections of properties that each seed a unique property or attribute
space  it is not yet possible to decide which of the seeds will form attribute spaces  so
treatment of both kinds of space is identical at this stage  the enablers of the rules are
ignored during this process  we do not wish to make enablers automatically fall into the
same property spaces as the states in the transformations they enable  this could result
in incorrect assignment of properties to property and attribute spaces since enablers only
facilitate  and do not participate in  state transformations  the output of this phase is the
collection of rules  with some properties marked as attributes  and the property space seeds
formed from the uniting process  all properties that remain unassigned at this stage are
used to seed separate attribute spaces  one for each such property 
the role played by the second phase of prs construction is to postpone commitment
to the uniting of collections of properties so that the possibility of objects  which can have
these properties  being associated with different property spaces is left open for as long as
possible  it may be that consideration of other schemas provides enough information for
this possibility to be eliminated  as in the following abstract example  but we support as
much type discrimination as possible in the earlier phases of analysis  we consider this
simple example to illustrate the problem 
      postponing property space amalgamation

given a domain description containing the following operator schema 

op  x y z 
pre 
add 
del 

p x y   q x y 
p x z   q x z 
p x y   q x y 

the prs 

precs  
p    q 
deleted precs   p    q 
add elements   p   q 
will be constructed  during the first phase  for x   the properties p  and q  are bound
together in this prs  and the resulting rule would be 

p   q    p    q 
which forces objects that can have property p  to occupy the same property space as objects
that can have property q    since this prs models the exchange of p  we will split it  and
replace it with two new prss 

precs  
p    q 
deleted precs   p 
add elements   p 
   

fiautomatic inference of state invariants

precs  
p    q 
deleted precs   q 
add elements   q 
we do not consider other pairings of p  and q    since these will be found in the prss
of other operator schemas if the domain allows them  the two prss generated lead to the
generation of the rules 

q    p    p 

and

p    q    q 

the two rules indicate that p  and q  should be used to form different property spaces since
they could  in principle  be independent of one another  then objects assigned to these two
spaces can turn out to be of distinct types  however  if we add the following two schemas 

op  x y 
pre 
add 
del 

op  x y z 

q x y 
p x y 
q x y 

pre 
add 
del 

p x y 
q x y 
p x y 

we generate  for x   the prss 

precs  
q 
deleted precs   q 
add elements   p 
and

precs  
p 
deleted precs   p 
add elements   q 
and the rules 
and

q    p 
p    q 

indicating that p  and q  should be united in the same set and hence form a single property
space  and that objects that can have these properties are really of the same type  the
uniting overrides the potential for separate property spaces to be formed but  in the absence
of these two schemas  there would have been insucient information available to determine
the nature of the relationship between the two properties 
   

fifox   long

    constructing the property spaces and synthesising the types

the objective of this stage is to construct the type structure of the domain by identifying
domain objects with distinct property spaces  objects can appear in more than one property
space  giving us a basis for deriving a hierarchical type structure 
the first part of the process involves completing the seeded property spaces  the first
task is to associate transition rules with the appropriate property space seeds  this can be
easily done by picking an arbitrary property of the start or finish component of each rule
and identifying the property space seed to which that property belongs  there can never
be ambiguity because every property belongs to only one seed and uniting ensures that all
of the properties referred to in a rule belong to the same seed  at this point the distinction
between states and attributes becomes important  any property space seed that has an
attribute transition rule associated with it becomes an attribute space and is dealt with
differently from property spaces in certain respects explained below 
the next step is to identify the domain objects associated with each property space and
attribute space 
for each object referred to in the initial state we construct a type vector in which a bit
is set if the corresponding space is inhabited by the object  an object can inhabit more
than one space  habitation is checked for by identifying all of the properties that hold  in
the initial state  of the object being considered and allocating them as states  rather than
as properties  to the appropriate state and attribute spaces  when every domain object has
been considered a unique type identifier is associated with each of the different bit patterns 
the next task is to populate the property spaces with states  the following definitions
are required to support the explanation of this process 

definition    a world state is a collection of propositions characterising the configuration
of the objects in a given planning domain description 

definition    given a world state  w   a property space  p    ps  trs  ss  os   or an
attribute space  p    ps  trs  os   and an object o   os  the p  projection of st for o is
the bag of properties  possessed by o in w   each of which belongs to ps 

the collection of properties of an object  o  in the initial state can be divided into a set of
bags of properties  each bag corresponding to the p  projection of the initial state for o  for
some property or attribute space p   each bag is added to the state set of the corresponding
property space  or discarded if the corresponding space is an attribute space  we now need
to extend the spaces by  for each property space  adding states that can be inferred as
reachable by objects within that space along transitions within that space  this is done for
every state in the space  including states that are newly added during this process  until no
further new states are reachable  the ordering of the properties within states is irrelevant  so
two states are considered equal if they contain the same properties  regardless of ordering
 they are considered order equivalent   since  when we come to use this information in
parts of the process of invariant generation  we will not require knowledge of any inclusion
relations between pairs of states  it is convenient to mark these at this stage  the addition
of reachable states is important for the inference of state invariants  and their use will be
discussed in section      the attribute spaces receive different treatment at this point  the
   

fiautomatic inference of state invariants

important difference to observe is that  since property spaces characterize the exchange
of properties  objects in a property space must start off in the initial state as members
of that property space  however  since attributes can be acquired without exchange  it
is possible for objects that do not have particular attributes in the initial state to acquire
those attributes later  this is only possible if the attribute space has an increasing attribute
transition rule associated with it  we now  therefore  consider each attribute space to see
whether further objects can be added by application of any corresponding increasing rule 
an object can be added to an attribute space if it potentiates all of the enablers of an
increasing rule in that attribute space  an object potentiates an enabling property if it
is a member of the state or attribute space to which that property belongs  membership
of all of these spaces indicates that the object could enter a state in which it satisfies all
of the enabling properties  which would justify an application of the increasing rule  any
enabling property that is not associated with a state or attribute space is a static condition 
so the initial state can be checked to confirm that the property is true of the object being
considered 
a complication arises if any enabling property was itself used to seed an attribute space
 in which case it is itself an attribute   because it is then necessary to identify all of the
objects in its attribute space and consider them for addition to the current attribute space 
of course this could  in principle  initiate a loop in the process but we avoid this by marking
attribute spaces as they are considered and ensuring  by iterating until convergence  that
all of the attribute spaces in the loop are completely assigned  the correctness of this part
of the procedure is discussed in section   
when this is done the state and attribute spaces are complete and the types of the
domain objects can be extracted  the completeness of this construction phase is discussed
in section     

    a worked example

a fully worked example of all stages of the process will help to clarify what is involved 
consider a simplified version of the rocket domain in which there are two operator schemas 

drive x y z 
pre 
add 
del 

load x y z 

at x y   fuelled x   location z 
at x z   unfuelled x 
at x y   fuelled x 

pre 
at x y   at z y 
add 
in x z 
del 
at x y 
and an initial state containing four constants  rocket  package  london and paris  and
the relations  at rocket paris   fuelled rocket  and at package london   it can be observed
that this simplified rocket domain has the rather odd feature that the load schema is not
restricted to loading packages into rockets  this oddity will be highlighted by the analysis
that is constructed  showing how the analysis performed by tim can help in understanding
 and debugging  the behaviour of the domain  from the drive operator schema the following
prss are constructed for variables x   y and z respectively 
   

fifox   long

precs 
at    fuelled 
deleted precs  at    fuelled 
add elements  at    unfuelled 
precs 
at 
deleted precs  at 
add elements 
precs 
location 
deleted precs 
add elements  at 
from the load operator schema the following prss are constructed for variables x   y
and z respectively 
precs 
at 
deleted precs  at 
add elements  in 
precs 
at    at 
deleted precs  at 
add elements 
precs 
at 
deleted precs 
add elements  in 
and the following rules are built  the first prs generates the first two rules and subsequent
prss each generate one rule 
fuelled    at    at 
at    fuelled    unfuelled 

at    null
location    null   at 
at    in 
at    at    null
at    null   in 

we now construct the following united sets of properties 

fat   in g
ffuelled   unfuelled g
fat g
fin g
   

fiautomatic inference of state invariants

these are used to seed property spaces  we first associate the rules with these property
space seeds  resulting in the following assignment 

fat   in g
at    in    fuelled    at    at 
ffuelled   unfuelled g at    fuelled    unfuelled 
fat g
location    null   at    at    at    null 
at    null
fin g
at    null   in 
the last two spaces have been converted into attribute spaces by their association with
attribute transition rules  the resulting spaces can now be supplemented with domain
constants and their legal states  we first identify the subset of the legal states of the
domain objects that are identifiable from the initial state  we do not use the goal state
to provide further information about the properties of objects  the goal state might be
unachievable because objects cannot obtain the required properties  this would invalidate
tim s analysis of the domain  in the initial state the rocket has properties at  and fuelled  
the package has property at    london has property at  and paris has property at    using
this information we associate domain constants with the developing state and attribute
spaces to obtain 

fat   in g
at    in   fuelled    at    at 
frocket  packageg
ffuelled   unfuelled g at    fuelled    unfuelled 
frocketg
fat g
location    null   at    at    at    null  flondon  parisg
at    null
fin g
at    null   in 
the next step is to add the legal states of these objects  which are identifiable so far  to
the property spaces  this results in the following structures  the first two of which can
be extended by inference  as will be explained  into completed property spaces  the last
two will be extended into completed attribute spaces by the addition of objects that can
potentially acquire the associated attributes  also described below  

fat   in g

at    in   fuelled    at    at 

ffuelled   unfuelled g at    fuelled    unfuelled 
fat g
fin g

frocket  packageg
 at   
frocketg
 fuelled  

location    null   at    at    at    null  flondon  parisg
at    null
at    null   in 

the last stage in the construction of the two property spaces is to add any states that
can be inferred as reachable  via transition rules  by objects in the property spaces  for
example  packages can go from being at  to being in   by application of the rule at    in  
and since that rule is available in the property space to which package belongs  and at 
is one of the legal states in that property space  we add in  as a further legal state  in
general  we construct the extension by  for each state in the space  identifying applicable
rules and  for each rule  creating a new state by removing the properties in the start of the
   

fifox   long

rule and adding the properties in the finish of the rule  this is done until all further states
are order equivalent to those already generated  the enablers of the rules are ignored  with
the consequence that some of the new states generated might be unreachable  when this
process is completed in the current example the finished property spaces are as follows 

property space  
fat   in g at    in   fuelled    at    at  frocket  packageg
 at     in  

property space  
ffuelled   unfuelled g at    fuelled    unfuelled  frocketg

 fuelled      unfuelled   

we now consider each attribute space in turn and add domain objects  not already
members  that potentiate their increasing rules  no new domain objects can be added to
the first attribute space since only london and paris can potentiate the increasing rule 
and they are already present  however  when the second attribute space is considered it can
be observed that rocket and package both potentiate the increasing rule and are therefore
both added as new members  the resulting attribute spaces are 

fat g location    null   at   at    at    null  flondon  parisg
at    null
fin g at    null   in 
frocket  packageg
the oddity of the load operator is revealed at this stage  since both package and rocket
have been assigned as members of the in  attribute space  meaning that they both can have
the attribute of having things in them  

the number of distinct bit patterns that are constructed  indicating object membership
of the state and attribute spaces  determines the number of distinct types that exist in the
domain  hence  in this simplified encoding of the rocket domain  there are three distinct
types  the rocket has type         the package has type        and paris and london both
have type         these types are given abstract identifiers  t   t  and t   but might be
more meaningfully interpreted as the types of  movable object requiring fuel  movable object
and location respectively  as expected  london and paris are of type location  whilst the
package is of type movable object and the rocket is of type movable object requiring fuel 
which is a sub type of movable object 
the distinction we have made between state and attribute spaces is further exploited in
the process of inferring state invariants  discussed in section     

    the assignment of types to operator parameters

types are assigned to the parameters of the operators in the following way  given an
operator schema and a collection of property spaces and attribute spaces we allocate a type
vector to each of the variables in the schema  the membership in the state and attribute
spaces of each of the properties of a given variable is recorded by setting the appropriate bits
in the vector for that variable  only the properties that appear in the preconditions of the
   

fiautomatic inference of state invariants

schema are considered  because any object that can satisfy the preconditions of an operator
can have the properties represented by the postconditions and is therefore of the right type
for instantiation of the operator  when a type is associated with the vector the union of all
of its sub types is taken  this union is then the type assigned to the variable  any domain
object  the type of which is a sub type of the type associated with the variable  can then
be used to instantiate that variable  to see how this process works  consider the variable x
in the drive schema above  the precondition properties of x are  at    fuelled   these are
members of the two property spaces   and    therefore  the type vector associated with x
is         it can be observed that the type vector associated with the rocket is         so that
the type of rocket is a sub type of the type of x   this is the only sub type  so the union of
sub types contains only t   the type of rocket  this means that x can be instantiated by
rocket  but not by any other domain constant  since no other domain constant has a type in
the appropriate sub type relation  to type the operator parameters we introduce new type
variables  tk   tn for unused values between k and n  where k is the number of existing types
and n is k plus the number of variables in the schema being considered  the type vector
for variable y will be        and z will have no type vector because location is a static
relation and z does not appear as an argument to any other predicate in the preconditions 
z therefore acquires the same type as london and paris  the only two objects for which
location is true in the initial state  t  is a super type of t   after taking the unions of the
sub types we can now specify the drive schema in the following way 

drive x y z 

params 
x t  y t  z t 
pre 
at x y   fuelled x   location z 
add 
at x z   unfuelled x 
del 
at x y   fuelled x 
stan exploits the sub typing relations that have been inferred when constructing instances of the drive operator  any variable that appears in a schema but does not appear
in its preconditions can be instantiated by objects of any type  this is because the domain
description contains no basis for inferring type restrictions in this case  no variable can
appear on the delete list without appearing on the precondition list  since we assume that
all delete list elements appear as preconditions  so such a variable would have to occur on
the add list  this would mean that  regardless of the properties holding of the object used
to instantiate that variable  in the initial state  it can acquire that add list property freely 
since this acquisition would occur irrespective of the type of the object  such variables are
essentially polymorphic 

    the inference of state invariants

the final phase of the computation of tim is the inference of the state invariants from
the property spaces  the attribute spaces are not used for the inference of invariants 
incorrect invariants would be proposed by tim if attribute spaces were inadvertantly used 
this explains the importance of identifying the attribute spaces in the earlier stages of the
algorithm 
the current version of tim is capable of inferring four kinds of invariant  three of which
are inferred from the property spaces  identity invariants  state membership invariants and
   

fifox   long

invariants characterizing uniqueness of state membership  and one of which is inferred from
the operator schemas and initial state directly  fixed resource invariants   in the simplified
rocket domain  considered above  an example of an identity invariant is 

 x   tk   y  z  at x  y    at x  z    x   z 
a state membership invariant is 

 x   tk   y   tn at x  y     y   tm in x  y  
a uniqueness invariant is 

 x   tk     y   tn at x  y     y   tm in x  y  
to infer the identity invariants each property space is considered in turn  with respect
to their properties and states  if a property  for example pk with p of arity n      occurs
at most once in any state an invariant of the following form  in which y and z are vectors
containing n     values  can be constructed 

 x  y  z  p  y   k    x  yk  n      p  z   k    x  zk  n      y   z 
the form of this invariant can be generalised to deal with the case where there are at most
m     occurrences of pk in any state in the space  in this case we build the following
expression  in which we have assumed that k      for simplicity 

 x  y    ym  p  x  y           p  x  ym     y    y    y    y          ym     ym   
the state membership invariants are of the form 

 x  disjunct         disjunctn 
where each disjunct is constructed from a single state  thus  if a property space contains k
states there will be at most k disjuncts in the invariant constructed for that property space 
only one state membership invariant is constructed for each property space 
given the collection of states in a property space we first identify those that are supersets
of other states in the collection  all supersets are discarded  since the invariants that would
be built from them would be logically equivalent to those built from their subset states 
each remaining state is used to build a single disjunct  if the state being considered contains
a single property  pk with p of arity n  then the expression

 y p  y   k    x  yk  n   
is constructed  of course  if n     then there is no existential quantifier and the disjunct
is just p  x   if the state contains more than one property  say m of them denoted p     p m  
then we build  again  assuming that k     for simplicity  

 y     ym  p   x  y     p   x  y           p m  x  ym  
the uniqueness invariants are constructed in a similar way  for each property space we
begin by analysing the superset states to identify non exclusive pairs of subset states  for
   

fiautomatic inference of state invariants

example  given the subset states fat  g and fin g and the superset state fat    in g  it can
be observed that the two subset states are not mutually exclusive since at  and in  can be
simultaneously held  having done this analysis and identified all mutually exclusive pairs
of states we mark the subset states as unusable for generation of invariants  the remaining
states are considered in all possible pairings  for every pair of states  p  q  we generate
an invariant of the following form assuming  for simplicity  that x is in the first position in
p     p n and q    qm  the form of the invariant is easily generalised  as before 

 x    y    yn  p   x  y     p   x  y           p n  x  yn  
   y    ym  q  x  y     q  x  y           qm  x  ym    
the fourth kind of invariant can be inferred from the structure of the operator schemas
without reference to the property spaces or domain type structure  we call these invariants
fixed resource invariants since they capture the physical limitations of the domain  fixed
resource invariants cannot be inferred from the state and attribute spaces because they describe properties of the domain rather than of objects within it  the following schema from
the gripper domain provides an example of why fixed resource invariants are distinguished
from the other three kinds 

move x y 

pre 
add 
del 

at robot x   room y 
at robot y 
at robot x 

the prss that would be built from this operator are 

precs  
at robot 
deleted precs   at robot 
add elements  
precs  
room 
deleted precs  
add elements   at robot 
and the rules constructed from these are 

at robot    null
and

room    null   at robot 

it can be observed that both of these rules are attribute transition rules and that at robot 
is attribute rather than state valued  this means that no invariants of the first three kinds
discussed would be constructed 
the reason for the lack of invariants of the first three forms is that the encoding of the
robot is embedded in a predicate  so the robot cannot participate directly in state transitions 
an obvious invariant of the robot  which would naturally be true of this domain  is that the
   

fifox   long

robot is always in exactly one room but this cannot be inferred using the techniques so far
described  in fact  this is an axiom about the world  or domain  rather than specific objects
within it  and has to be obtained from information other than the state transformations of
the objects 
it can be seen from the operator schemas for the gripper domain that at robot  is balanced  that is  it is always deleted whenever it is added and added whenever it is deleted 
this means that the number of occurrences of at robot in the initial state determines the
number of occurrences that are possible in any subsequent state  this leads to the construction  for this domain  of the invariant

jfx   at robot x gj    
since there is only one at robot relation in the initial state  the form of fixed resource
invariants is always equational  such an invariant states that the size of the set of combinations of objects satisfying a certain predicate is equal  or  in some cases  less than or equal 
to a certain positive integer  because this integer can be very large it is more convenient to
write an equation than it would be to write a logical expression  the information encoded
in the fixed resource invariants is very useful for identifying unsolvable goal sets without attempting to plan for them  for example  in the icparc version of the three blocks blocks
world  liatsos   richards         in which there are only three table positions  there must
always be exactly three clear surfaces  any goal specifying more than three clear relationships can be identified as unachievable from the fixed resource invariants for that domain 
the fixed resource and uniqueness invariants produced by tim can be seen as providing a
form of multi mutex relations  in contrast to the binary mutex relations inferred during the
construction of the plan graph in graphplan based planners  blum   furst         binary
mutex relations indicate that two actions or facts are mutually incompatible  whilst multimutex relations indicate that larger groups of actions or facts are collectively incompatible 
binary mutex relations  preventing a fact that can be true of only one object from holding
of two different objects simultaneously  can be extracted from the identity invariants that
tim infers  multi mutex relations are more powerful than binary ones  stan can detect
unsolvable goal sets by using the fixed resource and uniqueness invariants even when the
binary mutex relations at the corresponding level do not indicate that any problem exists 
to infer these invariants we examine the predicates in the language to see whether
they are exchanged on the add and delete lists of the operator schemas  if a predicate is
exchanged equally in all schemas  it always appears the same number of times on the add
list as on the delete list of a schema  then the predicate corresponds to a fixed resource 
if a single schema upsets this balance then the predicate is not treated as fixed  given a
fixed resource predicate  it can be inferred that there can never be more combinations of
objects satisfying that predicate than there are in the initial state  because of the slightly
odd encoding of the rocket world considered in this paper  only location is a fixed resource 
at is not fixed because it is not equally exchanged in the load schema  examples of fixed
resource invariants inferred from various standard domains are provided in appendix c 
there are certain circumstances under which it is necessary to infer the weaker invariant
that
jfx   p  x gj  k
   

fiautomatic inference of state invariants

for some positive integer k  if p holds of multiple objects in the initial state then it is
possible for subsequent state transformations  or attribute acquisitions  to result in states
in which two or more instances of p collapse into one  if p holds multiply often in the initial
state  or in any other reachable state  then it is necessary to build the invariant using 
instead of    if p is state valued  and multiple instances never occur in any state in its
property space  then it is safe to assert equality in the construction of the invariant 
automatic inference of the first three kinds of invariants relies on the construction
of the property spaces as discussed in section      as has been discussed  the distinction
between state and attribute spaces is critical for the inference of correct invariants  however 
using just the techniques described so far  tim would lose information from which it could
construct useful invariants  to give an example of how this could occur we now consider
the following simple encoding of the standard blocks world 

move x y z 
pre 
add 
del 

on x y   clear x   clear z 
on x z   clear y   clear table 
on x y   clear z 

in this operator  used by bundy et al          the add list element clear table  makes
reference to a constant  if the operator schema were to be submitted to our analysis in its
current form no prs would be built for the constant  so the rules that would be constructed 
and hence the state and attribute spaces constructed  would fail to record the fact that every
application of move results in a state in which the table is clear  the resulting analysis
would result in incorrect invariants and types  grant        identifies this version of the
move operator as awed  because of the need to maintain state correctness by the addition
of the invariant clear table  to the add list  however  we can analyse this schema correctly
if we first abstract it to remove the constant  yielding the following new schema 

move x y z t 
pre 
add 
del 

on x y   clear x   clear z   table t 
on x z   clear y   clear t 
on x y   clear z 

now  given an initial state in which blockc is on blocka and blockb is on the table 
we add the proposition table table   so that the new precondition can be satisfied  and the
property and attribute spaces that are constructed are as follows 

fon g

clear    on    on 

fblocka  blockb  blockc g
 on   
fon   clear g on    clear   clear    on   fblocka  blockb  blockc  tableg
table    null   clear 

the second of these is an attribute space  so our invariant extraction algorithm is not
applied to it  consequently  the only invariants we can infer are those that characterize
the positions of blocks  every block is on exactly one surface   this is a pity  as there
is information available in the attribute space that could yield useful extra invariants  in
particular  we would like to infer the invariant that every block can be either clear or have
   

fifox   long

something on it  but it cannot be both clear and have something on it  the reason we
cannot infer this as an invariant is because it would be asserted to hold for every object in
the attribute space  including the table  even though it is not actually true of the table  the
table can have things on it and still be clear  
      sub space analysis on property and attribute spaces

the solution to the problem of loss of invariants is to decompose any property or attribute
space that contains k     object types into k sub spaces  a property sub space is structurally identical to a property space  attribute sub spaces are identified but not used  as
no invariants can be obtained from them  property sub spaces can be obtained by analysis on attribute spaces  as the following example will show  the reason for distinguishing
sub spaces from property and attribute spaces is that the properties are not partitioned
in sub spaces as they are in the property and attribute spaces  the original property or
attribute space is not discarded and the sub spaces are not used for determining the types
of objects  the only role of the sub space analysis is to enable the construction of additional
invariants 
we now consider the blocks domain described in the previous section as an example of
the benefits of sub space analysis  at the point of invariant construction the types of the
domain objects have been identified by their property and attribute space membership  so
table is already known to be of a different type to that of the blocks  this is because table is
not a member of the property space for on    therefore  two sub spaces can be constructed
from the attribute space  one for the type       of blocks  and one for the type       of
tables  no sub spaces can be constructed from the property space because it contains only
one type of object  the rules associated with the sub spaces will be all of the rules from the
original attribute space that are enabled by objects of the appropriate type  the second
of the two sub spaces is an attribute sub space because of the inclusion of the increasing
attribute transition rule  at this stage the two sub spaces are as follows 

fon   clear g on    clear   clear    on 
fblocka  blockb  blockc g
fon   clear g table    null   clear   on    clear   ftableg
clear    on 
the attribute sub space will not be used for invariant construction because it contains an
attribute transition rule and would result in incorrect invariants  as is the case for attribute
spaces   so there is nothing to be gained from developing it further  however  the state
sub space is now completed by the addition of the states associated with the objects in the
space  both in the initial state and by extension  the resulting sub spaces are 

fon   clear g on    clear   clear    on 

fblocka  blockb  blockc g
 on      clear  
fon   clear g table    null   clear   on    clear   ftableg
clear    on 
from the new state sub space we can infer the following invariants  using the type name
block to stand for the type vector       we infer the identity invariant 
 x   block    y   z   on y  x    on z  x    y   z  
   

fiautomatic inference of state invariants

the state membership invariant 

 x   block    y   block  on y  x    clear x  
and the unique state invariant 

 x   block     y   block   on y  x    clear x   
although there is an additional invariant  that the table is always clear  we cannot infer
this at present 

    the problem of mixed spaces

it can happen that the encoding of a domain conceals the presence of attributes within
schemas until the point at which property space extension occurs  this can prevent the
property space extension process from terminating  for example  a simple lightswitch domain contains the following two schemas 

switchon x 
pre 
add 
del 

switchoff x 
pre 
add 
del 

off x 
on x   touched x 
off x 
on x 
off x   touched x 
on x 

and an initial state in which switcha is on  two prss are constructed 
precs  
off 
deleted precs   off 
add elements   on    touched 

precs  
on 
deleted precs   on 
add elements   off    touched 
giving rise to two rules 
and

off    on    touched 

on    off   touched 

uniting then seeds one property space containing all three properties  after addition of the
rules the property space is as follows 

fon   off   touched g off    on   touched   fswitchag
on    off    touched   on   
   

fifox   long

it is at the point of extension of the space that the problem arises  the following states
are added   off   touched     on   touched   touched      off   touched   touched   touched    and
so on  we cannot simply avoid adding properties that are already in the state being extended because the two  apparently identical  properties might in general refer to different
arguments 
the problem here is due to the fact that touched  is actually an increasing attribute
but this does not become apparent in the prss  the consequence is that mixed spaces are
constructed  a mixed space is a property space containing hidden attributes  tim detects
hidden attributes by checking  on extension  that no new state contains a state already
generated from the same initial state starting point  thus  on extension of the mixed space
above  tim would detect the hidden attribute when the state  on    touched   touched   is
constructed  because this state contains the state  on    that initiated this extension 
having detected the hidden attribute there are two possibilities  either tim can convert
the mixed space into an attribute space  in which case no invariants will be constructed  or
it can attempt to identify the attribute and split the mixed space into an attribute space
and a property space containing the state valued components of the mixed space  we take
this option and split the state  this allows us to infer invariants concerning the state valued
properties 
tim takes the difference between the including and included states and  for each distinct
property in the difference  processes the rules by cutting any rule containing that property
into two rules  at least one of which will be an attribute rule  the following method is
used to cut the rules  in the following  attr  indicates one or more occurrences of the
attribute valued property and the comma is overloaded to mean both bag conjunction and
bag union  if the rule is of the form 

enablers   start   adds  attr 
then the two new rules will be of the forms 

enablers  start   null   attr 
and
if the rule is of the form 

enablers   start   adds
enablers   attr    precs   adds

then the two new rules are of the forms 

enablers  precs   attr   null
and

enablers  attr   precs   adds

the rule cutting separates the attribute valued properties from the state valued properties 
now pure attribute and property spaces can be constructed  however we do not discard
the original mixed space because it has been used in determining the type structure of
   

fiautomatic inference of state invariants

the domain  any additional type information that could be extracted from the state and
attribute spaces built following this analysis is not currently exploited 
when this analysis is applied to the lightswitch domain  the following new property
space and attribute space are built 
fon   off g off    on   on    off 
fswitchag
 on      off  
ftouched g off    null   touched   on    null   touched  fswitchag
using lightswitch to stand for the type       the following state membership invariant
can be constructed from the property space 
 x   lightswitch   on x    off x  
tim also constructs the uniqueness invariant 
 x   lightswitch    on x    off x  

   properties of tim

the correctness of tim relies on it constructing only necessarily true invariants  the demonstration that only true invariants are constructed guarantees the construction of an adequately discriminating type structure  we cannot guarantee against under discrimination
but we argue that over discrimination does not occur in the type structures generated by
tim  these properties were defined in section     
over discrimination would be the result of distinguishing functionally identical objects
at the type level  this would occur if tim placed objects that participate in identical
state transitions in different property spaces but  because of the underlying partitioning of
properties between property spaces  this cannot happen  further  membership of different
property spaces requires that there be distinguishing state transformations  which there
are not in functionally identical objects  flawed assignment  assigning an object to a
property space without its corresponding state transformations   should simply be seen as
erroneous  rather than as over discrimination  the possibility of this occurring can be
excluded because property and attribute space construction and extension are shown to be
correct in section     
a failure to detect type differences  under discrimination  in the domain will result
in weak invariants  and over discrimination  if it could occur  would lead to over targeted
invariants that would still be true  but only for a subset of the objects they ought to
cover  flawed assignment would clearly lead to the construction of false invariants  underdiscrimination  which can arise  therefore affects the completeness of the state invariant
inference procedure  it can also lead to over generalisation of the operators since the types
assigned to the operator parameters will be equally under discriminating  this can enable meaningless instances to be formed  needlessly increasing the size of the search space
that must be explored by the planner  this clearly raises eciency issues but it does not
undermine the formal properties of the planner that exploits tim 
as observed  the consequence of under discrimination is the construction of weak  but
valid  invariants  the following example illustrates how under discrimination can occur 
given a schema 
   

fifox   long

op x y 
pre 
add 
del 
and an initial state in which

p x y 
q x y 
p x y 

p a  c   p b  c   q b  d 

hold  the following two property spaces are constructed 

fp   q g p    q  fa  bg
 p     q     p   q      q   q   
fp   q g p    q  fc  dg
 q      p   p      q   p      q   q   
given these property spaces it is impossible to distinguish a from b or c from d  even
though analysis of the operator schema and initial state reveal that a is functionally distinct
from b and c from d  it can be seen that  although a must always exchange a p  for a q   
b can have both p  and q  simultaneously  a similar observation can be made for c and
d  however  the process by which invariants are constructed cannot gain access to this
information  an identity invariant constructed for the first property space is 

 x   t   y   z   u   q x  y    q x  z    q x  u    y   z   y   u   z   u 
this invariant is weaker than is ideal  because a can participate in only one q relation  b can
participate in two simultaneously   a state membership invariant for this property space
is 
 x   t     y   t   p x  y      y   t   q x  y  
which understates the case for b  which can have p  and q  simultaneously  no unique
state invariant is constructed for this property space  because p  and q  are not mutually
exclusive 

    correctness and completeness of the transition rule construction phase

the correctness of the algorithm used in tim depends on two elements  firstly  the property
spaces identified by the algorithm must be correctly populated  that is  no objects should
be assigned to property spaces to which they do not belong and every achievable state must
be included in the appropriate property space  secondly  these property spaces must only
support the generation of correct invariants  this second element is examined in section     
an interesting relationship exists between the states in a property space and the invariants generated from the space  incorrect invariants will be contructed if a property space is
missing achievable states  this is because the state membership invariants assert that each
object in the property space must be in one of the states in the property space  if states
are missing then this invariant will be false  we now prove that all achievable states will
be in the appropriate property space 

theorem   given an initial state  i   a collection of operator schemas  o  a property space 
p    ps  trs  ss  os   generated by tim when applied to i and o  and any state  st  which
   

fiautomatic inference of state invariants

is reachable from i by application of a valid linearised plan formed from ground instances
of operator schemas in o  then for any o   os  the p  projection of st for o  stop   is in ss 

proof 

the proof is by induction on the length of the plan that yields the state st  in the base
case the plan contains no operator instances so st   i   the p  projection of i for o is in
ss  by definition of the first phase of the property space construction process described in
section     
suppose st is generated by a plan of length k      with last step a and penultimate
state pre st  let the p  projection of pre st for o be pre stop   by the inductive hypothesis 
this state is in ss  if a does not affect the state of o  then the p  projection of st for o
will be pre stop   and therefore in ss trivially  otherwise  consider the operator schema 
op   o  from which a is formed  as described in section      no constants appear in op
and all variables in the body of op are parameters of op  let the initial collection of prss
constructed from op  for those parameters instantiated with o in the creation of a  be the
set prs     prsn where every prsi has the form 
precs  
pi
deleted precs   di
add elements   ai
and the initial collection is the collection formed prior to splitting 
for each value of i the ith prs will lead to the construction of k     transition rules 
where k is the size of the bag intersection  xi   of di and ai   the k rules will be of the
following form 
 c   xi   pi   fcg   c   c 
and the remaining rule will be of the form 

pi    di   xi      di   xi     ai   xi  
we refer to the latter rule for prsi as the ith complex rule  a subset of the n complex
rules will contain a property in ps in either the start or the finish and will  therefore  be
relevant to the transition from pre st to st  it can be observed that these m complex
rules  prs     prsm without loss of generality  must be in p because of the uniting process
described in     
we define pres a op to be the p  projection of the preconditions of a for o  similarly 
adds a op and dels a op are defined to be the p  projections of the add and delete lists
respectively  by construction of the prss  defined in section     
m
m
  pi
mm
adds a op   ai
mm
dels a op   di

pres a op

 
 

 

   

fifox   long

because of the restriction that delete lists must be a subset of preconditions  and the
fact that a is applicable to pre st  it follows that dels a op v pres a op v pre stop   since
v represents bag inclusion it can be seen that all of the separate bags di are included in
pre stop without overlap 
the extension process involves the iterated application of the rules as explained in
section     and indicated in the pseudo code algorithm presented in appendix b 
for a rule to be applicable to a state its start must be included in the state  therefore
the m complex rules are all applicable  regardless of the sequence of application  to pre stop  
it follows that the state
 pre stop  

mm  di   xi    mm  ai   xi 
 

 

is generated in the extension process  by definition of xi   and the fact that di v pre stop  
this state can be written as 
 pre stop  

mm di   m ai
 

which  as observed above  is just 
 pre stop   dels a op    adds a op
which equals stop by the standard semantics of operator application in strips 

 

the proof demonstrates that splitting  discussed in      does not result in the generation
of invalid invariants  however  splitting can compromise the completeness of the invariantgeneration process  it can result in the inclusion of unreachable states in property spaces 
with the consequence that the identity and state membership invariants that are generated
are weaker than would otherwise be the case  this is further discussed in section     
we now explain the role of splitting in the prs construction phases  each domain
object in a strips domain has an associated finite automaton in which the states consist of
the properties  for example  at    it can have  either initially or as a result of the application
of an arbitrary length sequence of operators  objects that can be observed to be of the
same type will have identical automata at the property level  the prss capture the ways
in which operator applications modify the configurations of individual objects and hence
provide an encoding of these automata 
the prss are built in two phases  in the first phase  all of the parameters in all of the
schemas are considered  so all possible object state transitions are captured  however  some
of these transitions conceal the functional distinctions inherent in the domain description
and would lead to premature amalgamation of property spaces  as was observed in the
discussion of the rocket domain in section      in that example it was observed that use
of our standard formula for the construction of rules from these prss alone would result in
the failure to detect the type distinction between rockets and packages 
the second phase assists the type inference processes in avoiding under discrimination
by distinguishing enablers of a state transformation from the properties that are exchanged
   

fiautomatic inference of state invariants

during the transformation  each prs characterizing the exchange of k properties is split
to form at most k     new prss  the prss   and    given in section      show how two
prss are constructed from a single prs containing a single exchanged property  this is a
simple example  as only one split is required to remove exchanges  in general it might be
necessary to split repeatedly until all exchanges are removed  as shown in the example given
by prs   in section      no non exchange combinations of the properties in deleted precs
and add elements should be considered during splitting  the resulting prss lead to the
construction of transition rules which allow generic state transformations  such as movement
from one location to another  to be separated from the specific nature of the objects that
can make those transformations 
it can be observed that the rules that result from the splitting process are more general
than the rules that would have been obtained from the prs prior to splitting  they
distinguish more precisely between the properties that take part in state transitions and
the properties that simply enable those transitions  allowing finer type distinctions to be
inferred on the basis of the functionalities of the objects in the domain  finer distinctions
are made during the process of seeding property and attribute spaces by uniting  this is
because uniting merges  into single equivalence classes  all of the properties that appear in
both the start and finish of a rule 
we argue that all state transformations are accounted for by the end of this second
phase  the result of the second phase is that the automata formed during the first phase
are separated into collections of simpler automata where possible  so that no transitions
are lost but there is a finer grained encoding of the possible transitions that can be made
by objects with appropriate properties  the prss constructed in this phase support the
construction of rules that allow objects making these transitions to occupy different property
spaces  some of the second phase prss may be under constraining  in the sense that
analysis of subsequent schemas might eliminate the possibilities they are keeping open  as
in example        but the set of prss obtained at the end of the second phase cannot be
over constraining because all of the first phase prss are considered for splitting 
a subtlety concerns the consequence  at the type level  of assigning two functionally
distinct objects to the same state or attribute space  for example  in example      rocket
and package are both assigned to the property space for fin   at  g and the attribute space for
fin g  however  because rocket can be fuelled or unfuelled  and the package cannot  there is
a distinction between them that emerges in the property and attribute membership vectors
associated with the rocket and package objects  membership of the additional property space
for ffuelled   unfuelled g means that rocket is assigned a type that is a sub type of the type
of package and the functional distinctness of rocket and package is recognised  as discussed 
there is an oddity in this encoding that results in the package being assigned membership
of the fin g attribute space  furthermore  at  and in  were united  with the effect that
rockets can make the at    in  transition and can be used to instantiate variables of type
movable object  even when variables of this type are intended only to be instantiated with
the package  there is nothing in the domain description to prevent this interpretation  a
more conventional encoding of the load schema would prevent the rocket from being loaded
into any other object  and this would cause a refinement in the type structure that would
identify loadable objects  and would prohibit the use of the rocket in forming instances of
operators that should be restricted to operating on those objects 
   

fifox   long

the construction of transition rules follows a simple rule whereby any undeleted preconditions are used to enable a transformation from a state in which the deleted preconditions
of a prs hold to one in which the added elements of the prs hold  given the assumption
that all deleted atoms in an operator schema must appear as preconditions in that schema 
these rules correctly characterize strips style state transformations  all possible transformations are captured because of the second phase of prs construction  a complete set of
correct transition rules is therefore constructed 
given the correctness and completeness of the transition rule construction phase  correct
initial allocation of objects to spaces depends simply on correctly checking membership of
the initial properties of the object in the property sets  formed by uniting the rules  that
are used to seed the spaces  extension of the property spaces is done by straightforward
application of the transition rules  so all configurations of properties that can be occupied
by the objects in the property space will have been added by the end of the extension phase 
extension of the attribute spaces is unproblematic in the cases where no potential enabler
is itself an attribute  if one is  then the process by which the attribute space of that enabler
is completed could  it appears  initiate a loop in the attribute space extension process  in
fact  this does not happen as tim is able to detect when a loop has occurred and avoid
repeatedly iterating over it 
the following example illustrates the problem and the way it is solved in tim  suppose
we have three attribute spaces 

attribute space  

fq g p    null   q  fa  bg

attribute space  
fr g q    null   r  fcg

attribute space  
fp g r    null   p  fdg
these spaces are extended by the addition of objects that potentiate their increasing rules 
as discussed in section      no problem arises if the enablers of these rules are states  and
not attributes  but in the extension of attribute space   above the enabler  p    is an attribute 
the attribute space for p  has not yet been extended  so it is necessary to complete that
space before using it to complete    extension of   requires the extension of    for the same
reason  and that requires the extension of   which requires the extension of    and so on 
the way tim avoids re entering this loop is by marking each space  as it is considered  as
having been seen on this iteration  when a marked space is encountered it is not extended
but is used as if it is already complete  then a second iteration is required to extend
any spaces that still require completion  subsequent iterations will be required until the
process converges  our experiments suggest that it is unusual for there to be more than
two iterations required  a worst case upper bound is o  as  where o is the number of
domain constants and as is the number of attribute spaces  which is limited by the number
of properties   and hence quadratic in the size of the domain description 
   

fiautomatic inference of state invariants

if the extension process starts with attribute space    in the above example  attribute
space   will be marked as having been seen on the first iteration  tim then goes on to
extend space   because the extension of space   depends upon space   being complete 
space   is marked as having been seen on this iteration and space   is considered  space  
is marked and space   is revisited  because space   is marked tim infers that a loop has
been entered  its objects are added to space   without extension and the objects of space  
are then added to space    finally  the objects of space   can be added to space   and the
first iteration is complete 

fq g p    null   q  fa  bg   fc  dg
fr g q    null   r  fcg   fa  bg
fp g r    null   p  fdg   fc  a  bg
however  space   is not yet complete  so a second iteration is required  this iteration
starts in the same place as the first and the process is repeated  except that no further
iterations will be required in this example 

    correctness of the state invariants

we now argue for the correctness of the invariant inference procedure by considering each
of the four kinds of invariant in turn  the following arguments rely upon correctly distinguishing property spaces from attribute spaces  since the invariant analysis cannot be
performed on attribute spaces  the only scope for confusing this distinction is in the extension of mixed spaces  but we extract attributes from mixed spaces by checking for inclusion
of existing states in the new states generated during extension  this process was discussed
in section     

definition    given a property space p    ps  trs  ss  os   ss can be partitioned into
three disjoint sets  sssubs and sssups that contain all of the states in ss that are included
 as bags  or that include  as bags   respectively  at least one other state in ss and ssind
that contains all of the independent states in ss that are neither in sssubs nor in sssups  
theorem   given a property space p    ps  trs  ss  os   in which the set of states ss

is a union of the three disjoint sets of states ssind   sssubs and sssups   for each object  o  in
os the following families of invariants will hold 
   identity invariants 
   state membership invariants 
   unique state invariants 
as defined in section     

proof 

we address each kind of invariant in turn  by theorem   every object in os must be in
a state in ss  furthermore  all states of each object in os  with respect to each property in
ps  will be in ss  this follows because the properties are partitioned between the spaces
   

fifox   long

during the seeding process  therefore  the maximum number of occurrences of a property
p in ps  possessed by any object in os in any state of the world  will be bounded by the
maximum number of instances of that property in any state in ss  these maximum values
might not be equal since ss can contain inaccessible states   the identity invariants simply
express this bound on the properties of the objects in os 
every object in os must be in a state in ssind  sssubs   this follows by definition of
these sets in definition    and by theorem    the state membership invariants assert that
every object in os must be in at least one of these states  with each disjunct in the invariant
corresponding to the assertion of membership of one of these states 
to argue for the correctness of the unique state invariants  we observe that the proposed
invariants would only be false if they paired states that were not mutually exclusive  in
this case  either the state extension process would have put properties that could be simultaneously held into the same bag  or such properties would be simultaneously held in the
initial state and hence would appear in the same bag on initial construction of the property
space  in either case  a state will exist in the property space that is a superset of both of
the non exclusive states  however  uniqueness invariants are generated for pairs of states
drawn only from ssind   sssups so these non exclusive pairs of states will not lead to the
generation of incorrect invariants 

 
the fixed resource invariants are always associated with a particular predicate  if atoms
built with that predicate are balanced on the add and delete lists of all of the operator
schemas then the number of occurrences of these atoms in the initial state is fixed over all
subsequent states  this is what the invariant expresses  an invariant is constructed for
every predicate that forms balanced atoms 
since no new techniques are required to infer invariants from sub spaces  no further
argument is required to support correctness of the invariants formed following sub space
analysis 
although theorem   demonstrates the correctness of the invariants inferred by tim it
is possible for weak invariants to be inferred from the presence of unreachable states in ss 
weak identity invariants are inferred if an unreachable state is generated  during extension 
containing more instances of a property than are contained in any reachable state  when
this happens an identity invariant will be generated that is weaker than would be ideal  but
is still valid  further  if a property space contains unreachable states they will cause the
inclusion of additional false disjuncts in the state membership invariants  but since these
false disjuncts will not exclude satisfying assignments their presence will not invalidate
the invariants  unreachable states cause additional tautologous uniqueness invariants to be
generated but do not affect the strength of the invariants that refer only to reachable states 
clearly we cannot hope to identify all of the unreachable states  as such an analysis would
be as hard as planning itself 
because no invariants are generated for attribute spaces tim cannot be claimed to be
complete  sub space analysis rectifies this to some extent by identifying property spaces
that exist within attribute spaces and allowing further invariants to be generated  this
analysis could be further refined 
   

fiautomatic inference of state invariants

    effects of tim on the properties of the planner

tim is itself sound  so no planner that uses tim is in danger of losing soundness as a result 
tim is certainly not complete for all domain axioms because there are invariant properties of

other kinds that cannot be extracted by the current version  for example  kautz and selman
       identify optimality conditions and simplifying assumptions amongst the different
kinds of axioms that might be inferred from a domain  an optimality condition in the
logistics domain might be  a package should not be returned to a location it has been
removed from  a simplifying assumption in the same domain might be  once a truck is
loaded it should immediately move  assuming all necessary loads can be done in parallel  
these constraints require a deeper analysis of the domain than is currently performed by
tim  but we intend to characterise them and infer them in our future work 
we cannot guarantee that the type structure inferred by tim is always fully discriminating  although we do guarantee that it is not over discriminating  however  failure on
tim s part to infer all of the structure that is there to be inferred does not impact on the
completeness of a planner using tim because  in these cases  tim will return an unstructured
domain and the planner can therefore default to reasoning with the unstructured domain
when necessary 

   experimental results

an examination of tim s performance can be carried out on several dimensions  we consider
three specific dimensions here  the viability of the analysis on typical benchmark domains 
the scalability of the analysis and the utility of performing the analysis prior to planning  its
general performance on standard benchmark problems provides an indication of the scale of
the overhead involved in using tim as a preprocessing tool  all experiments were performed
under linux on a    mhz pc with     mb of ram  figure   shows that  even on large
problem instances  the overhead is entirely acceptable  all of the mystery problems listed
in this table are very large  involving initial states containing hundreds of facts  and could
not be solved by stan  ipp  koehler  nebel    dimopoulos        or blackbox  kautz  
selman        in the aips    competition  the nature of the mystery domain is described
in appendix c  this emphasises the relative costs of the preprocessing and planning efforts 
the selection of problems used to construct table   is justified as follows  in the blocks
world we have used a representative example from each of three encodings supplied in the
pddl release  these are  the simple encoding  prob     the att encoding  prob    and the
snlp encoding  prob     the hanoi set contains a collection of reasonably sized problems 
a representative group of relatively large mystery instances was chosen from the pddl
release  the two tyre world instances are the only two strips instances available in the
release  the three logistics problems are the three largest for the simple strips encoding
included in the pddl release 
the second dimension is scalability of the analysis  an analytic examination of the
algorithm can determine an upper bound on performance that is polynomial in all of the
key domain and problem components  including number of operator schemas  number of
literals in operators  numbers of objects and facts in the initial state and the number and
arities of predicates in the language  figure   shows that the performance of tim is roughly
quadratic in the size of the problem specification  in the graph  size is crudely equated with
   

fifox   long

domain and problem
blocks
prob   pddl
prob   pddl
prob   pddl
hanoi
  disc
  disc
  disc
  disc
  disc
mystery
prob    pddl
prob    pddl
prob    pddl
prob    pddl
prob    pddl
tyre world prob   pddl
prob   pddl
logistics
prob   pddl
prob   pddl
prob   pddl

parse time
 
 
 
 
 
 
 
 
  
  
  
  
  
 
 
 
 
 

analysis time
 
 
 
 
 
 
 
 
  
  
  
 
  
 
 
 
 
 

output time total
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
  
  
   
  
  
 
  
  
  
  
  
  
  
 
  
 
  
 
  

figure    table showing tim s performance in milliseconds on standard domains and problems  all timings are elapsed times and minor discrepancies in totals arise from
rounding 

   

fiautomatic inference of state invariants

tim analysis of mystery domain

     
     



    
millisecs     



    
    

 








  
 

   



                                               
size of file

figure    graph showing tim s performance on mystery problems  plotting time against
size  in characters  of problem file  the solid line is a plot of a quadratic function 
the number of characters in the specification file  this graph was constructed by running
tim on all of the strips mystery domain problems in the pddl release  the increasing
sizes of the problem specifications reect increases in any and all of the various categories
of objects in the domain and corresponding facts to describe their initial states 
figure   shows the effect on tim s performance as the number of operator schemas
increases  this graph was constructed using an artificial domain in which each new operator
causes two new state transitions described by two new literals  thus  both number of
operators and number of properties is increasing whilst the number of objects stays constant 
the domain is described in detail in appendix e  the graph indicates the linear growth of
cost of analysis 
the final dimension for evaluating tim is the effect of exploitation of its output by a
planner  gerevini and schubert        and kautz and selman        provide convincing
evidence supporting the powerful role of state invariants in enhancing the performance of
sat based planning  in figure   we demonstrate the power of inferred types by showing the
advantage that stan with tim obtains over stan without tim on untyped rocket domain
problems  figure   shows the effect on performance of increasing the number of packages
to be transported  the time taken by stan with tim grows linearly  whilst stan without
tim follows a cubic curve  if there are p packages in a problem instance then stan with tim
constructs   p     operator instances while stan without tim constructs  p      p      p
instances  this demonstrates that type information is the most significant factor in the
advantage depicted in the graph  figure   demonstrates that a similar improvement is
obtained in the logistics domain  in this graph a series of sub problems were considered in
   

fifox   long

  
  
  
  
  
millisecs   
  
  
  
  
  

tim performance with increasing number of operators

 
 

 
 

 

 
 

 

 

 

 

 

 

 

 
 
  
number of operators

 

 

 

  

  

  

  

figure    graph showing the consequences of increasing the number of schemas and inferrable property spaces 
the effect of tim on the performance of stan

     

 

stan without tim  
stan with tim  

     
    

 

millisecs    
    

 

 

 

 

 

 

  
 
   
  
                          
   
  
   
   

    

 

 

  

  
  
  
number of packages

  

  

  

figure    graph showing comparison between stan with and stan without tim on rocket
domain problems generated from the rocket domain provided in appendix d 
   

fiautomatic inference of state invariants

the effect of tim on the performance of stan

     
     

stan without tim
stan with tim

    
millisecs    
    
    
 

 

   

 

   
 
   
number of sub problems

 

   

 

figure    graph showing comparison between stan with and stan without tim on logistics
domain problems 
which each sub problem involves the independent transportation of a single package between
two cities 
in very simple domains  the overhead of carrying out this analysis can outweigh the
advantages offered  for example  in the movie domain used in the competition stan gained
no benefits from using tim but paid the overhead to the detriment of its performance on
instances from that domain  however  in general we observe that the benefits of this analysis
increase with the increasing complexity of domains 

   related work
although the importance of state invariants for ecient planning has been observed there
has been relatively little work on automatic inference of invariants  the published work that
most closely resembles the research described in this paper is the state constraint inference
system discoplan  of gerevini and schubert         discoplan enables the inference
of sv constraints that correspond to a subset of our identity invariants  the reason that
discoplan is restricted to a subset is that it generates sv constraints only for pairs of literals
 one on the addlist of a schema and the other on the delete list  in which the arguments
vary in only one place  tim can infer identity invariants in which vectors of arguments vary 
as shown in section      discoplan cannot currently infer all singly varying constraints
 although the techniques described by gerevini and schubert      a  are not yet fully
implemented in discoplan   for example  discoplan cannot infer that all blocks can only
   

fifox   long

be on one surface  in its analysis of the blocks world domain cited in the paper  tim can
infer these invariants from its sub space analysis 
gerevini and schubert      a      b  have also examined the potential for inferring
parameter domains that are similar to the operator parameter types inferred by tim  their
domains are inferred by an iterative process of accretion which is similar to the attribute
space extension process of tim  however  the accretion process they describe is synthetic 
in that the parameter domains are synthesised directly from the operator descriptions and
initial state  tim is an analytic system that constructs its types from an analysis of the functional properties of the domain objects  this analytic approach provides a rich information
source from which other structures  including the domain invariants  can be derived 
some of the implicative constraints inferred by discoplan correspond to an implicit
type assignment and would arise in the type structure built by tim  a further implicative
constraint generated by discoplan refers to the separation of functional roles of objects 
in particular  the irreexivity of on  as in 
 x   y   on x  y      x   y  
can be captured using this kind of constraint  tim cannot currently infer these invariants 
because tim uses an analysis based on the state view of objects in the domain it is able
to generate a broader collection of invariants  including state membership and unique state
invariants currently not produced by discoplan 
although discoplan can deal with negative preconditions and tim cannot yet manage
them  the invariants they produce overall are currently less powerful than those inferred by
tim 
apart from the work of gerevini and schubert  there is some older work on the inference
of invariants which also relies on the generation of candidate invariants which are then
confirmed by an inductive process against the domain operators  two examples are the
work of kelleher and cohn        and morris and feldman         the former work
concentrates on identifying directed mutual persistence relations  which hold between pairs
of facts in a domain when  once both are established  the second continues to hold while
the first does  the use of these relations leads to the inference of a collection of constraints
which fall into the uniqueness invariants inferred by tim  in the work described in  morris
  feldman        the authors build invariants by using truth counts which are counts of the
number of propositions from particular identified sets which must be true in any state of
the domain  sets for which this count is   can then be used to build invariants which are a
subset of the state membership and uniqueness invariants  the authors describe methods for
attempting to identify the sets of facts from which to work  this work  in common with that
of kelleher and cohn and of gerevini and schubert  builds invariants by first hypothesising
a possible seed for the invariants and then determining their validity by analysing the effects
of the operators on these seeds  in contrast to this generate and test strategy  tim produces
only correct invariants which it infers from a deep  structural analysis of the domain  the
inference of invariants does not exhaust the possibilities of this analysis  for example 
the type structure is inferred automatically during this analysis  which has been shown to
have dramatic potential for the eciency of planning  the relationship between enablers 
and the state transitions they enable  determines an ordering on the satisfaction of goals 
which also has significance for eciency  further  the state based view of the behaviour of
   

fiautomatic inference of state invariants

domain objects would allow the techniques described by mccluskey and porteous       
to be automated 
mccluskey and porteous        have proposed and explored an object centred approach
to planning  this approach is based on the provision  by a domain engineer  of a rich
collection of state invariants for object sorts participating in functional relationships in the
domain  these invariants are then exploited in a domain compilation phase to facilitate an
ecient planning application to that domain  tim infers precisely the sorts and collections
of state invariants that mccluskey and porteous provide by hand 
grant        generates state invariants from state descriptions  provided by hand  and
then uses these invariants to build operator schemas  his approach is clearly related even
though the objectives of his analysis are different  grant is concerned with the automatic
synthesis of domain descriptions from a rich requirements specification provided by an
expert user  our concern is with reverse engineering a domain description to obtain the information that can help increase the eciency of planners applied to that domain  although
the primary objectives in the use of tim are to enhance the performance of planning within
a domain  tim also provides a valuable tool in the construction of domain descriptions by
revealing the underlying behaviours that the domain engineer has implicitly imposed  and
helping with the debugging of domain descriptions 

   conclusion
tim is a planner independent set of techniques for identifying the underlying structure of a

domain  revealing its type structure and a collection of four different kinds of invariant conditions  one important application of these techniques is as a domain debugging aid during
the construction of large and complex domains  using tim has revealed many anomalies
in domains encoded by us and by others  and has greatly assisted us in understanding
stan s performance on many domains and problems  another important application is in
increasing the eciency of planners by making explicit to the planner information about
the domain that it would otherwise have to infer  from the domain representation  during
planning 
tim generates a rich collection of invariants containing many that are not inferrable by
related systems  as discussed in the previous section  the results presented by gerevini
and schubert        suggest that a marked improvement can be obtained from the use of
invariants in the performance of planners based on sat solving techniques  no analysis
has yet been done to determine what advantages might be obtainable by using invariants in
planners based on other architectures  stan does not yet exploit all of the invariants produced by tim during planning  it uses the type structure and the fixed resource invariants
and we are currently developing an extension of stan that will fully exploit the other kinds
of invariant  we expect to be able to use the uniqueness and identity invariants to shortcut
the effort involved in deducing a significant subset of the necessary mutex relations during
graph construction 
the analysis performed by tim is ecient  growing more slowly than a quadratic function
of the size of the initial state being analysed  our empirical analysis does not consider
the effect on tim s performance of increasing numbers of operator schemas  however  the
argument presented in section   shows that tim s analysis grows linearly with the number
   

fifox   long

of operator schemas  linearly with the number of domain constants and linearly with the
size of the initial state  there are other factors to take into account  but this confirms a
polynomial performance as the size  and related structure  of the domain increases 
the type analysis performed by tim differs  in some important respects  from the various
forms of type analysis performed during the compilation of programs written in strongly
typed languages  in the latter context the type correctness of a program is judged with
respect to an imposed context of basic types  tim infers the basic types from the domain
description so it is impossible for a domain specification not to be well typed  consequently
we do not attempt to type check domain descriptions using tim  this is a direction in which
we hope to move in the near future  because type checking will enable some unsolvable
problems to be detected as unsolvable statically rather than at planning time  we currently
focus only on type inference and the exploitation of the inferred type structure in the
management of the search space of the planner 

   acknowledgements

we would like to thank alfonso gerevini  gerry kelleher and the anonymous referees for
useful discussions and helpful comments on earlier drafts of this paper 

appendix a  ftp and web sites

the aips    planning competition ftp site is at 

http   ftp cs yale edu pub mcdermott aipscomp results html 

our web site  on which stan and tim executables can be found  is at 



http   www dur ac uk  dcs www research stanstuff planpage html

appendix b  the tim algorithm

the following is a pseudo code description of the tim algorithm 
fconstruct base prss  section     g
ps    fg 
for each operator schema  o 
for each variable in o  x 
construct a prs for x from o and add to ps 

fsplit prssg

for each prs in ps  p 
if a property  p  appears in p in both the adds and deleted precs fields
then split p over p  into p  and q and replace p with p  and q in ps 
where to split p over p 
construct prs q with the same precs as p  deleted precs and adds both set to fpg 
construct prs p  from p by removing p from deleted precs and adds of p 

fconstruct transition rules  section     g
ts    fg 

for each prs in ps  p 
construct a transition rule for p and add to ts 

fseed property and attribute spaces  section     g

let each property be initially assigned to a separate equivalence class 
for each rule  r  in ts
merge together  unite  the equivalence classes for all the properties in the start and finish of r 

   

fiautomatic inference of state invariants

construct a separate space for each equivalence class of properties 

fassign transition rules  section     g

for each rule  r  in ts
place r in the space associated with the equivalence class containing the properties
in the start  and finish  of r  s 
if r is an increasing or decreasing rule
then mark s as an attribute space 

fanalyse initial state  section     g

for each object  o  in the domain
identify the bag of initial properties of o  i o  
for each space  s 
construct the bag of properties from i o  which belong to the equivalence class
associated with s  b 
if b is non empty
then add o to the space s 
if s is not an attribute space
then add b as a state in s 

fextend property spaces  section     g

for each property space  p 
while there is an unextended state in p  s 
mark s as extended 
newgen    fg 
for each rule in p  r 
if the start of r is included in s
then add the state snew    s ominus start oplus end  to newgen 
if snewis a superset of any state in newgen
then mark p is an attribute space and exit the analysis of p 
add newgen to the states in p 

fextend attribute spaces  section     g

changes    true 
while changes 
changes    false 
for each unmarked attribute space  a 
extend a where to extend a 
mark a 
for each rule in a  r 
for each property in enablers of r  p 
if p s equivalence class is associated with an unmarked attribute space  a  
then extend a  
add all objects that appear in every space associated with an enabling property for r to a 
if objects are added
then changes    true 

fidentify types  section     g

for each object in the domain  o 
identify the pattern of membership of spaces for o  tt 
associate the type pattern  tt  with o 
for each operator schema  o 
for each argument of o  x 
identify the pattern of membership of spaces for x implied by the properties of x in the
preconditions of o  tt 
associate type pattern  tt  with x in o 

fconstruct invariants  section     g

for each property space  p 
for each property in p  p 
construct an identity invariant for p 
construct a state membership invariant for p 
construct a uniqueness invariant for p 

   

fifox   long

appendix c  example output

the following output was produced by tim and can be found  along with other examples 
on the stan webpage  these examples show the details of the analysis performed on each
of three domains  a flat tyre domain  a mystery domain and a logistics domain  the
analysis is done with respect to an initial state and a set of operator schemas  the operator
schemas used in these three domains are those provided with the pddl strips releases for
these domains  the initial states were taken from the pddl release  the pddl release can
be found at http   www cs yale edu html yale cs hyplans mcdermott html 

c   the tyre world
tim  type inference mechanism   support for stan  state analysis planner
d  long and m  fox  university of durham

reading domain file  domain   pddl
reading problem file  prob   pddl
tim  domain analysis complete for flat tire strips
tim  types 
type
type
type
type
type
type
type
type

t 
t 
t 
t 
t 
t 
t 
t 

 
 
 
 
 
 
 
 

 wrench 
 wheel  
 wheel  
 trunk 
 the hub 
 pump 
 nuts 
 jack 

it will be noticed that the two wheels are separated into different types  this is because
one wheel is intact and the other is not intact  and there is no operator for repairing wheels
that are not intact  the tools have each been given different types  this is because they
each appear as constants in different operators and therefore are functionally distinct 
tim  state invariants 
forall x t    on ground x  or lifted x  
forall x t   not  on ground x  and lifted x  
forall x t    closed x  or open x  
forall x t   not  closed x  and open x  

   

fiautomatic inference of state invariants

forall x t  u t    deflated x  or inflated x  
forall x t  u t   not  deflated x  and inflated x  

the invariants for hubs  below  suggest that almost anything could be on a hub  since
this is not the case the type structure is under discriminating  however  the additional
invariants drawn from the sub space analysis provide enough information  in principle  to
discriminate more fully between the types  this information is not yet being fully exploited 
forall x t   forall y   forall z   on y  x  and on z  x     y    z 
forall x t    exists y  t  u t  u t  u t  u t  u t   on y  x 
or free x  
forall x t   not  exists y  t  u t  u t  u t  u t  u t   on y  x 
and free x  
forall x t   forall y   forall z   tight y  x  and tight z  x     y    z 
forall x t   forall y   forall z   loose y  x  and loose z  x     y    z 
forall x t     exists y  t  u t  u t  u t  u t  u t   tight y  x 
and fastened x  
or  exists y  t  u t  u t  u t  u t  u t   loose y  x 
and fastened x   or unfastened x  
forall x t   not   exists y  t  u t  u t  u t  u t  u t   tight y  x 
and fastened x  
and  exists y  t  u t  u t  u t  u t  u t   loose y  x 
and fastened x   
forall x t   not   exists y  t  u t  u t  u t  u t  u t   tight y  x 
and fastened x   and unfastened x  
forall x t   not   exists y  t  u t  u t  u t  u t  u t   loose y  x 
and fastened x   and unfastened x  

tim  domain invariants 
  x  
  x  
  x  
  x  
  x  
  x  
  x  
  x  
  x  

container x        
hub x        
intact x        
jack x        
nut x        
pump x        
unlocked x        
wheel x        
wrench x        

tim  attribute spaces 

   

fifox   long

the attribute space for the properties in the first of these groups is subjected to a much
more rigorous analysis in the sub space invariants below 
objects  x  in t  u t  u t  u t  u t  u t  can have property 
exists y  t   in x y   
exists y  t   on x y   
exists y  t   tight x y   
exists y  t   loose x y   
have x  
objects  x  in t  can have property 
exists y  t  u t  u t  u t  u t  u t   in y  x  
objects  x  in t  all have property  container x  
objects  x  in t  all have property  hub x  
objects  x  in t  all have property  intact x  
objects  x  in t  all have property  jack x  
objects  x  in t  all have property  nut x  
objects  x  in t  all have property  pump x  
objects  x  in t  all have property  unlocked x  
objects  x  in t  u t  all have property  wheel x  
objects  x  in t  all have property  wrench x  

tim  operator parameter restrictions 
inflate x  t  
put on wheel x  t  u t  x  t  
remove wheel x  t  u t  x  t  
put on nuts x  t  x  t  
remove nuts x  t  x  t  
jack down x  t  
jack up x  t  
tighten x  t  x  t  
loosen x  t  x  t  
put away x  t  u t  u t  u t  u t  u t  x  t  
fetch x  t  u t  u t  u t  u t  u t  x  t  
close container x  t  
open container x  t  
cuss  

tim  additional state invariants  using sub space analysis 

we report here only the additional state invariants that add information to the invariants
already listed  tim currently reports invariants that are subsumed by the earlier collection 
it should be observed that the first wheel is intact but the second is not  and this gives
rise to the following new invariant for wheels of the second type 
   

fiautomatic inference of state invariants

forall x t    deflated x  

the first attribute space  which contains all objects except the trunk and the hub  is now
subjected to sub space analysis yielding a rich new collection of invariants 
forall x t   forall y   forall z   in x y   and in x z      y    z 
forall x t    exists y  t   in x y   or have x  
forall x t   not  exists y  t   in x y   and have x  
forall x t   forall y   forall z   in x y   and in x z      y    z 
forall x t   forall y   forall z   on x y   and on x z      y    z 
forall x t    exists y  t   in x y   or have x 
or exists y  t   on x y   
forall x t   not  exists y  t   in x y   and have x  
forall x t   not  exists y  t   in x y   and exists y  t   on x y   
forall x t   not  have x  and exists y  t   on x y   
forall x t   forall y   forall z   in x y   and in x z      y    z 
forall x t   forall y   forall z   on x y   and on x z      y    z 
forall x t    exists y  t   on x y   or have x 
or exists y  t   in x y   
forall x t   not  exists y  t   on x y   and have x  
forall x t   not  exists y  t   on x y   and exists y  t   in x y   
forall x t   not  have x  and exists y  t   in x y   
forall x t   forall y   forall z   in x y   and in x z      y    z 
forall x t    exists y  t   in x y   or have x  
forall x t   not  exists y  t   in x y   and have x  
forall x t   forall y   forall z   in x y   and in x z      y    z 
forall x t   forall y   forall z   tight x y  
and tight x z      y    z 
forall x t   forall y   forall z   loose x y  
and loose x z      y    z 
forall x t    exists y  t   tight x y  
or exists y  t   loose x y  
or have x  or exists y  t   in x y   
forall x t   not  exists y  t   tight x y  
and exists y  t   loose x y   
forall x t   not  exists y  t   tight x y   and have x  
forall x t   not  exists y  t   tight x y  
and exists y  t   in x y   
forall x t   not  exists y  t   loose x y   and have x  
forall x t   not  exists y  t   loose x y  
and exists y  t   in x y   
forall x t   not  have x  and exists y  t   in x y   

   

fifox   long

c   the mystery domain

the mystery domain was devised by drew mcdermott for the aips    planning competition 
his intention was to conceal the structure of the problem domain by employing an obscure
encoding of a transportation domain  the code replaces locations with the names of foods
and the routes between them with eats relations  the transports are pleasures while cargos
are pains  cargos and transports can be at locations  with the at relation encoded as craves 
a cargo is either at a location or in a transport encoded by the fears relation  transports
have restricted capacity encoded by planets and consume fuel in travelling between locations 
fuel exists in limited quantities at locations measured by provinces  using tim we were
able to decode the domain and identify the roles played by each of the components of the
encoding 
tim  domain analysis complete for mystery strips  prob    pddl 
tim  types 

it should be noted that provinces  types t   t  and t   are divided into three separate
types because they form a sequence  defined by the attacks relation  in which the first and
last have a slightly different functional role to the others  the same is true of the planets
 types t   t  and t   
type t     beef cantelope chocolate flounder guava mutton onion 
pepper rice shrimp sweetroll tuna yogurt 
type t     saturn 
type t     pluto 
type t     neptune 
type t     achievement lubricity 
type t     abrasion anger angina boils depression grief hangover 
laceration 
type t     alsace bosnia guanabara kentucky 
type t     goias 
type t     arizona 

tim  state invariants 
forall x t   forall y   forall z   harmony x y  
and harmony x z      y    z 
forall x t    exists y  t  u t  u t   harmony x y   
forall x t   forall y   forall z   locale x y  
and locale x z      y    z 
forall x t    exists y  t  u t  u t   locale x y   
forall x t  u t   forall y   forall z   fears x y  

   

fiautomatic inference of state invariants

and fears x z      y    z 
forall x t  u t   forall y   forall z   craves x y  
and craves x z      y    z 
forall x t  u t    exists y  t   craves x y  
or exists y  t   fears x y   
forall x t  u t   not  exists y  t   craves x y  
and exists y  t   fears x y   

tim  domain invariants 
   x  x    attacks x  x        
   x  x    eats x  x         
  x   food x         
   x  x    harmony x  x        
   x  x    locale x  x         
   x  x    orbits x  x        
  x   pain x        
  x   planet x        
  x   pleasure x        
  x   province x        

tim  attribute spaces 
objects  x  in t  u t  u t  can have property 
exists y  t   harmony y  x  
objects  x  in t  u t  u t  can have property 
exists y  t   locale y  x  
objects  x  in t  can have property 
exists y  t   fears y  x  
objects  x  in t  can have property 
exists y  t  u t   craves y  x  
objects  x  in t  u t  all have property 
exists y  t  u t   attacks x y   
objects  x  in t  u t  all have property 
exists y  t  u t   attacks y  x  
objects  x  in t  all have property 
exists y  t   eats x y   
objects  x  in t  all have property 
exists y  t   eats y  x  
objects  x  in t  all have property  food x  
objects  x  in t  u t  all have property 
exists y  t  u t   orbits x y   

   

fifox   long

objects  x  in
exists y  t  u
objects  x  in
objects  x  in
objects  x  in
objects  x  in

t  u t  all have property 
t   orbits y  x  
t  all have property  pain x  
t  u t  u t  all have property  planet x  
t  all have property  pleasure x  
t  u t  u t  all have property  province x  

tim  operator parameter restrictions 
succumb x  t  x  t  
feast x  t  x  t  x  t  
overcome x  t  x  t  

tim  additional state invariants  using sub state analysis 

these additional invariants show that the transports are always at a location and never
loaded into other transports 
forall x t   forall y   forall z   craves x y  
and craves x z      y    z 
forall x t    exists y  t   craves x y   

c   the logistics domain
tim  domain analysis complete for logistics strips  prob   pddl 
tim  types 
type t     bos truck la truck pgh truck 
type t     bos po la po pgh po 
type t     bos airport la airport pgh airport 
type t     bos la pgh 
type t     package  package  package  package  package  package  
package  package  
type t     airplane  airplane  

tim  state invariants 
forall x t  u t  u
and at x z      y 
forall x t  u t  u
and in x z      y 
forall x t  u t  u

t   forall y   forall z   at x y  
  z 
t   forall y   forall z   in x y  
  z 
t    exists y  t  u t   at x y  

   

fiautomatic inference of state invariants

or exists y  t  u t   in x y   
forall x t  u t  u t   not  exists y  t  u t   at x y  
and exists y  t  u t   in x y   

tim  domain invariants 
  x   airplane x        
  x   airport x        
  x   city x        
   x  x    in city x  x        
  x   location x        
  x   obj x        
  x   truck x        

tim  attribute spaces 
objects  x  in
exists y  t  u
objects  x  in
exists y  t  u
objects  x  in
objects  x  in
objects  x  in
objects  x  in
objects  x  in
objects  x  in
objects  x  in
objects  x  in

t 
t 
t 
t 
t 
t 
t 
t 
t 
t 
t 
t 

u t  can have property 
u t   at y  x  
u t  can have property 
u t   in y  x  
all have property  airplane x  
all have property  airport x  
all have property  city x  
u t  all have property  exists y  t   in city x y   
all have property  exists y  t  u t   in city y  x  
u t  all have property  location x  
all have property  obj x  
all have property  truck x  

tim  operator parameter restrictions 
drive x  t  x  t  u t  x  t 
fly x  t  x  t  x  t  
unload x  t  u t  u t  x  t 
load plane x  t  x  t  x  t 
load truck x  t  x  t  x  t 

u t  x  t  
u t  x  t  u t  
u t  
u t  

tim  additional state invariants  using sub state analysis 

   

fifox   long

the following invariants add the constraints that trucks and airplanes must always be at a
location and never loaded into one another 
forall x t   forall y   forall z   at x y   and at x z      y    z 
forall x t    exists y  t  u t   at x y   
forall x t   forall y   forall z   at x y   and at x z      y    z 
forall x t    exists y  t  u t   at x y   

appendix d  the rocket domain

the rocket domain used in the construction of figure   is as follows 
 define  domain rocket 
  predicates
 at  x  y 
 in  x  y 
 fuelled  x 
 unfuelled  x 
 loc  x 
 obj  x 
 container  x  
  action fly
 parameters   x  y  z 
 precondition  and  at  x  y   loc  z   fuelled  x  
 effect  and  not  at  x  y    at  x  z   unfuelled  x 
 not  fuelled  x    
  action load
 parameters   x  y  z 
 precondition  and  obj  x   container  y   at  x  z 
 at  y  z  
 effect  and  in  x  y   not  at  x  z    
  action unload
 parameters   x  y  z 
 precondition  and  at  y  z   in  x  y  
 effect  and  at  x  z   not  in  x  y     

appendix e  operator test domain

this domain is an artificial domain used to test the effects of increasing operators and literals
in the domain encoding on the performance of tim  this example is the third instance   the
variation was achieved by adding more operator schemas in the pattern of those included
here 
   

fiautomatic inference of state invariants

 define  domain od 
  predicates
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p   x  y   q   x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y 
 p    x  y   q    x  y  
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y   
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y   
  action o 
 parameters   x  y  z 
 precondition  and  p   x  y   q   x  z  
 effect  and  not  p   x  y    not  q   x  z  
 p   x  z   q   x  y    

the problem instance was fixed as follows 
 define  problem op 
  domain od 
  objects a b c 

   

fifox   long

  init

 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p  a b 
 q  a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c 
 p   a b 
 q   a c  
  goal  and  p  a c   q  a b    

references

blum  a     furst  m          fast planning through plan graph analysis  in ijcai 
bundy  a   burstall  r   weir  s     young  r          artificial intelligence  an introductory course  edinburgh university press 
fikes  r     nilsson  n          strips  a new approach to the application of theoremproving to problem solving  artificial intelligence        
gerevini  a     schubert  l       a   accelerating partial order planners  some techniques for effective search control and pruning  jair            
gerevini  a     schubert  l       b   computing parameter domains as an aid to planning 
in aips    
gerevini  a     schubert  l          inferring state constraints for domain independent
planning  in aaai 
grant  t  j          inductive learning of knowledge based planning operators  ph d 
thesis  rijksuniversiteit limburg de maastricht 
kautz  h     selman  b          the role of domain specific knowledge in the planning
as satisfiability framework  in the fourth international conference on artificial
intelligence planning systems 
   

fiautomatic inference of state invariants

kelleher  g     cohn  a          automatically synthesising domain constraints from
operator descriptions  in proceedings ecai   
koehler  j   nebel  b     dimopoulos  y          extending planning graphs to an adl
subset  in proceedings of  th european conference on planning 
liatsos  v     richards  b          least commitment  an optimal planning strategy  in
proceedings of the   th workshop of the uk planning and scheduling special interest
group 
long  d     fox  m   in press   the ecient implementation of the plangraph in stan  in
jair 
mccluskey  t  l     porteous  j          engineering and compiling planning domain
models to promote validity and eciency  artificial intelligence         
morris  p     feldman  r          automatically derived heuristics for planning search 
in proceedings of the  nd irish conference on artificial intelligence and cognitive
science  school of computer applications  dublin city university 

   

fi