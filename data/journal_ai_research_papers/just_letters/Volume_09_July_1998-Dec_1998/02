journal artificial intelligence research                

submitted        published     

computational aspects reordering plans
christer backstrom

department computer information science
linkopings universitet  s        linkoping  sweden

cba ida liu se

abstract

article studies problem modifying action ordering plan order
optimise plan according various criteria  one criteria make plan
less constrained minimize parallel execution time  three candidate
definitions proposed first criteria  constituting sequence increasing
optimality guarantees  two based deordering plans  means ordering relations may removed  added  third one uses reordering 
arbitrary modifications ordering allowed  shown weakest one
three criteria tractable achieve  two np hard even dicult
approximate  similarly  optimising parallel execution time plan studied
deordering reordering plans  general case  computations
np hard  however  shown optimal deorderings computed polynomial
time class planning languages based notions producers  consumers
threats  includes commonly used planning languages  computing optimal reorderings potentially lead even faster parallel executions  problem
remains np hard dicult approximate even quite severe restrictions 

   introduction
many applications plans  made man computer  executed  important find plans optimal respect cost measure  typically execution
time  examples applications manufacturing error recovery industrial
processes  production planning  logistics robotics  many different kinds computations made improve cost plan only extensively
studied literature  well known frequently used scheduling  plan tells actions  or tasks  order them 
schedule assigns exact release times actions  schedule must obey action
order prescribed plan must often satisfy metric constraints
deadlines earliest release times certain actions  schedule feasible satisfies
metric constraints  usually interesting find schedule optimal
respect  eg feasible schedule shortest total execution time  schedule
missing deadlines actions possible 
principle  planning scheduling follow sequence scheduling
viewed post processing step planning where planning concerned causal
relations qualitative temporal relations actions  scheduling concerned
metric constraints actions  planning systems  eg o plan  currie   tate 
      sipe  wilkins         planning scheduling integrated one
single system  similarly  temporal planners  eg deviser  vere        ixtet  ghallab
  laruelle         often reason metric constraints  make
c      ai access foundation morgan kaufmann publishers  rights reserved 

fibackstro

irrelevant study planning scheduling separate problems  though  seen
vast literature topics  two problems quite different character
studying separately gives important insight integrated systems
discussed  instance  drabble  says often dicult see
o plan plans schedules  easy see o plan works  dicult
see why 
complication understanding difference planning scheduling 
integrated systems systems separated planning scheduling 
certain types computations fall grey zone planning scheduling 
planners good reasoning effects actions causal relationships
actions  usually poor reasoning time temporal relationships
actions  schedulers  hand  primarily designed reason
time resource con icts  capabilities reasoning causal dependencies
actions  problems grey zone require reasoning kinds  neither
planners schedulers handle problems properly  problems
solved  scheduler get sucient information planner
best situation the planner scheduler may fail cooperation find
plan feasible schedule  even plan exists 
article focusses one grey zone problems  namely problem optimising action order plan allow better schedules  whenever two actions con ict
cannot allowed execute parallel  planner must order
actions  however  usually enough information reasoning capabilities
decide two possible orders best one  makes arbitrary choice 
one choices typically allows better schedule one  planner
makes wrong choice may prevent scheduler finding good  even feasible 
schedule  situation arises plans made human expert  since difficult see choice ordering best one large complex plan  planning
systems today usually cannot anything better asking planner new plan
scheduler fails find feasible schedule  expensive unsatisfactory
solution  especially feedback scheduler help planner making
intelligent choice next time  another solution appears literature
use filter planner scheduler attempts modify plan order
put scheduler better position  filters could remove certain over commitments
ordering  referred deordering plan  even change order
certain actions  referred reordering plan 
article intended provide first formal foundation studying type
problems  defines number different optimality criteria plan order modifications 
respect degree over committment ordering respect
parallel execution time  provides computational results computing
modifications  article analyses filtering algorithms suggested literature
order modifications 
remainder article structured follows  section   introduces concepts
computations studied article means example  section   starts
   brian drabble  personal communication  aug       

   

ficomputational aspects reordering plans

theoretical content article  defining two planning formalisms used following
sections  problems making plan least constrained studied section  
candidate definitions concept introduced computational properties investigated  section   defines concepts parallel plans parallel executions
plans  followed section   optimal deorderings reorderings parallel
plans introduced complexity achieving optimality analysed  section  
studies complexity problems affected restricting language 
includes positive result algorithm literature finds optimal deorderings class plans common planning languages  filtering
algorithms literature well planners incorporating ordering optimisation discussed section    finally  section   discusses aspects article
related work  section    concludes brief recapitulation results 

   example
order illustrate concepts operations studied article simple example
assembling toy car used  example variation example used
backstrom klein         much simplified version existing assembly line
toy cars used undergraduate laborations digital control linkoping university
 for description assembly line  see eg  klein  jonsson    backstrom             
stromberg         problem assemble lego  car pre assembled parts
shown figure    chassis  top set wheels  two latter mounted
onto chassis 
top

chassis

car

wheels

figure    schematic assembly process toy car
workpiece ow factory shown figure    three storages  one
type preassembled part  two workstations  number   mounting top
number   mounting wheels  car storage assembled cars  tops
moved top storage workstation   sets wheels moved
   lego trade mark lego company

   

fibackstro

wheels storage workstation    chassis moved chassis storage either
workstation also  possibly parts mounted  two workstations
either workstation car storage  furthermore  mounting wheels
chassis  tyres must ated  workstation   incorporates compressed air container
must pressurized ating tyres  this shown figure  

top
storage

workstation  

chassis
storage
wheels
storage

car
storage
workstation  

figure    schematic lay out toy car factory
article concerned modifying order actions given plan 
consider modifying set actions  hence  example assume
plan assembling toy car given whether plan produced hand
planning algorithm important  assumed assembly plan
contains exactly actions listed table    order  since results
article independent particular planning language used  assumptions
planning language made example either  make things simple 
obvious common sense constraints plans valid used  instance 
part must moved workstation mounted there  wheels must ated
mounted air container must pressurized ating tyres 
furthermore  since chassis one single place time  top cannot
mounted parallel mounting wheels  neither mounting operations
done parallel moving either chassis part mounted 
purpose modifying action order given plan usually optimize
plan aspect  instance  make plan least constrained  consider totally
ordered plan figure  a  producing chassis wheels  subplan
plan assembling car  note since plan totally ordered  pairs actions
ordered  implicit transitive arcs shown figure  plan clearly
over constrained  instance  necessary move set wheels workstation
  pressurizing air container  removing ordering constraint results
plan figure  b  note orderings removed the arc mvw 
existed already original plan  implicit transitivity  plan
orderings removed referred deordering original plan 
   

ficomputational aspects reordering plans

action
mvt 
mvw 
mvc 
mvc 
mvs
mtt
mtw
pac


description
move top workstation  
move wheels workstation  
move chassis workstation  
move chassis workstation  
move chassis car storage
mount top chassis
mount wheels chassis
pressurize air container
ate tyres

duration
 
 
 
 
 
 
 
 
 

table    actions assembly plan
new plan less constrained original plan  since possible move
wheels pressurize air container either order or  perhaps  even parallel 
however  orderings removed  necessary ate wheels
moving chassis workstation  removing ordering results plan
figure  c  least constrained deordering original plan sense
possible remove ordering constraints still valid plan 
is  removing ordering constraint  possible sequence
actions way plan longer intended result  addition
deorderings  one may consider arbitrary modifications ordering relation  is 
removing adding relations  modifications referred reorderings 
three differents least constrainment criteria plans based deorderings reorderings
studied section    plan figure  c happens optimal according
three criteria 

mvw    pac

 

  mvc   mtw

a  total order plan
mvw pppp
q

 


pac

  mvc   mtw

b  less constrained version

mvw pppp
q it ppppq

pac
 mtw

mvc 
c  least constrained
version

figure    three plans mounting wheels
   

fibackstro

making plan least constrained clearly useful certain actions executed
parallel  however  even case parallel execution possible  may still
worth making plan least constrained  although partial order least constrained
plan must strengthened total order execution purposes  need
total order original plan  suppose actions temporal constaints
deadlines earliest release times scheduler post process plan
try finding feasible schedule  may case original plan feasible
schedule  less constrained version sequenced feasible schedule 
idea least constrained plan scheduler many alternative execution
sequences possible choose from 
important reason modifying action ordering plan  however 
execute plan faster executing actions parallel whenever possible  purpose
better use length optimal schedule plan measure  rather
measure ordering itself  suppose following car assembly plan given
hmvw    pac  it  mvc    mtw  mvt    mvc    mtt  mvs i 
actions executed sequentially given order  minimum execution time
sum durations actions     time units  however 
previous example plan over constrained  since several actions could executed
either order  parallel 
possible remove orderings far shown figure  a  further 
still valid plan  the implicit transitive orderings shown figure  
deordered version original assembly plan scheduled execute    time units
exploiting parallelism whenever possible  example schedule shown
figure  b  however  faster execution possible  since plan contains subsequence
actions cannot parallelized total execution time    time
units 
obvious schedule figure  b many actions executed
parallel  gain deordering plan quite small  much better performance
possible arbitrary modifications action ordering allowed  is 
reorderings considered  instance  assembly plan particular reason
wheels mounted top mounted  seen shortly
much time saved reversing order two operations  deordering
cannot this  however  since removing ordering wheel mounting action
 mtw  top mounting action  mtt  would make unordered  would
interpreted two actions could executed parallel  possible 
reason actions must ordered original plan  however 
allowing arbitrary modifications  order two actions reversed 
figure  a shows reordering original plan  plan scheduled
execute    time units  considerable improvement original
plan optimal deordered version it  example optimal schedule shown
figure  b  fact  plan optimal reordering sense ordering
actions results valid plan scheduled execute faster  problems
finding optimal deorderings reorderings plan respect parallel execution
main topic article  studied sections     
   

ficomputational aspects reordering plans

pac
mvw 

mvt 



mtw

mvc 

mtt

mvc 

mvs

a  deordering assembly plan admitting shortest
parallel execution time
pac



mvw 

mtw

mvc 

mtt

mvs

mvc 
mvt 
 

 

  

  

  

  

b  optimal schedule plan

figure    optimal deordering assembly plan
obvious reordering powerful operation deordering  since
reordered plan figure  a allows shorter schedule optimal deordering
figure  a  hand  original plan

hmvt    mvc    mtt  mvs  mvw    pac  it  mvc    mtw i 
deordering would sucient arriving optimal plan figure  a 

   planning formalisms
section defines actions  plans related concepts  basically appear two
different guises article  definitions tractability results mostly cast
general  axiomatic framework order general independent formalism
possible  hardness results  hand  mostly cast specific formalism 
ground tweak  often subject restrictions  order strengthen
results  formalisms defined below  addition these  third formalism
used  definition deferred used  section   
   

fibackstro

pac



mvw 

mvt 

mtt

mvc 

mvc 

mvs

mtw

a  reordering assembly plan admitting shortest
parallel execution time
pac
mvc 



mvw 

mvt  mtt
 

 

mtw

mvs

mvc 
  

  

b  optimal schedule plan

figure    optimal reordering assembly plan

    axiomatic planning framework

axiomatic framework makes minimum assumptions underlying formalism  may instantiated planning formalism defines concept
planning problem domain entities called actions validity test  planning
problem assumed consist planning problem instances  ppis    assumptions inner structure these  validity test truth valued function
taking ppi sequence actions arguments  validity test true ppi
action sequence ha            i  action sequence ha            said solve
  inner structure ppis exact definition validity test crucial specific planning formalism  many results article proven without
making assumptions  results computational complexity certain
problems make assumption complexity validity test  though  based
concepts  notion plans defined usual way 

definition     total order plan  t o  plan  sequence p   ha            ani actions 
alternatively denoted tuple hfa            g    k  l n 
ak al iff k   l  given ppi   p said  valid iff validity test true

p  

   complexity theoretic terminology problems  planning problem instances sense
article sometimes referred planning problems planning literature 

   

ficomputational aspects reordering plans

partial order plan  p o  plan  tuple p   ha  set actions
strict   ie  irre exive  partial order a  validity test extended p o  plans
s t  given ppi   p  valid iff ha    valid every topological sorting    

actions t o  plan must executed specified order  unordered
actions p o  plan may executed either order  is  p o  plan viewed
compact representation set t o  plans  implicit assumption
unordered actions executed parallel  parallel plans defined section   
p o  plans viewed directed acyclic graphs figures transitive arcs often
tacitly omitted enhance readability  furthermore  proofs algorithms article
based definition  ie assuming order plan transitively closed 
many practical planners bother transitive closures  difference
affect results presented here 

    ground tweak formalism

ground tweak  gt  formalism tweak language  chapman        restricted
ground actions  formalism variation propositional strips known
equivalent polynomial transformation common variants propositional strips  backstrom         brief  action precondition postcondition  sets ground literals 
order define gt formalism  following two definitions required  given
set   notion seqs  s   denotes set sequences formed members  
allowing repetition elements including empty sequence  symbol    
used denote sequence concatenation operator  further  given set p propositional
atoms  set lp literals p defined lp   p   f p j p   pg  since
formulae allowed atoms negated atoms  double negation   p
treated identical unnegated atom p  finally  given set literals l  negation
neg l  l defined neg l    f p j p   lg fp j  p   lg l said consistent
iff atom p s t  p   l  p   l 

definition     instance gt planning problem quadruple   hp   o  i  gi



p finite set atoms 
finite set operators form hpre  posti pre  post lp consistent
denote pre post condition respectively 

i  g lp consistent denote initial goal state respectively 
  hpre  posti o  write pre o  post o  denote pre post respectively 
sequence ho              seqs  o  operators called gt plan  or simply plan   
definition     ternary relation valid seqs  o   l  l defined s t  arbitrary ho              seqs  o  s  lp   valid ho            i  s    holds iff either
   n    
p

   

p

fibackstro

   n      pre o   
valid ho            i   s   neg post o       post o       
t o  plan ho              seqs  o  solves iff valid ho            i  i  g  

action unique instance operator  ie set actions may contain several
instances operator  inherits pre  post conditions operator
instantiates  since problems article consider fixed set actions 
atom operator sets frequently tacitly omitted gt ppis  figures 
gt actions shown boxes  precondition literals left postcondition
literals right 

   least constrained plans

seems generally assumed planning community difference t o  plans p o  plans sense t o  plan easily converted
p o  plan vice versa  however  p o  plan trivially converted
t o  plan low order polynomial time topological sorting  less obvious
converse holds  least three algorithms converting t o  plans p o  plans
presented literature  pednault        regnier   fade      a  veloso  perez   
carbonell         all algorithms analyzed later article   claim
t o  plan easily converted p o  plan vacuously true since t o  plan
already p o  plan  definition  hence  computation needs done 
hardly algorithms intended compute  however  order useful 
algorithm must output p o  plan satisfying interesting criterion  ideally
optimality criterion  fact  two algorithms mentioned claimed produce
optimal plans according certain criteria  instance  veloso et al         p       claim
algorithm produce least constrained plans  define mean
term  however  hardly paper literature using term
without definition 
unfortunately  means obvious constitutes intuitive good criterion
p o  plan least constrained and  extent  depends
purpose achieving least constrainment  major motivation producing p o  plans
instead t o  plans  see instance tate        p o  plan post processed
scheduler according criteria  release times deadlines resource
limits  either actions ordered  ideally  optimal sequence or  given criteria
parallel execution  parallel plan executed faster actions
executed sequence  cases  less constrained original plan is  greater
chance arriving optimal schedule optimal parallel execution respectively 
algorithms mentioned motivated goal exploiting possible
parallelism decrease execution time 
interesting make t o  plans partially ordered  make partially
ordered plans partially ordered  is  generalise ordering  algorithm
task presented literature context case based planning
 kambhampati   kedar         since t o  plan special case p o  plans 
section study general problem making partially ordered plans less constrained 
   

ficomputational aspects reordering plans

    least constrainment criteria

is  naturally  infinitude possible definitions least constrainment  seem
reasonable others  however  three intuitively reasonable candidates defined
analyzed below  although definitions possible  questionable whether
considerably better natural definitions  respect purposes mentioned
above  defined without using information usually present t o 
p o  plan 

definition     let p   ha  q   ha   i two p o  plans ppi  then 
   q reordering p wrt  iff p q  valid 
   q deordering p wrt  iff q reordering p  

   q proper deordering p wrt  iff q reordering p  

definition     given ppi two p o  plans p   ha  q   ha   i 
   q minimal constrained deordering p wrt  iff
 a  q deordering p wrt 
 b  proper deordering q wrt   
   q minimum constrained deordering p wrt  iff
 a  q deordering p wrt 
 b  deordering ha     iof q wrt  s t  j    j   j j 
   q minimum constrained reordering p wrt  iff
 a  q reordering p wrt 
 b  reordering ha     iof q wrt  s t  j    j   j j 

note previous publication  backstrom        used terms lc  minimality
minimal constrained deordering lc  minimality minimum constrained reordering 
change terminology done hope gained clarity
lost confusion 
easy see minimum constrainment stronger criterion minimalconstrainment any minimum constrained deordering plan p minimal constrained
deordering p   opposite true  example  consider plan figure  a 
removing ordering constraints action c  result plan figure  b 
still valid  plan order size    there one implicit transitive order 
minimal constrained deordering since deordering made 
minimum constrained deordering  however  since instead breaking ordering constraints
subsequences ab cb  result plan figure  c  valid 
plan ordering size   easily seen minimum constrained
deordering  happens coincide minimum constrained reordering
case  coincidence always case  however  since reordering allowed
   

fibackstro

modifications deordering  minimum deordering obviously never
smaller ordering relation minimum reordering  examples difference
shown already section    figure  a shows minimum constrained deordering
figure  b shows minimum constrained reordering 


 p

p

b

 

q

c

q

 q



a  total order plan
c


p

 p

b

q

 q

q

c





b  minimal deordering

q

 q



p

 p

b

q

b  minimum deordering

figure    difference minimal minimum constrained deorderings 
alternative definitions least constrainment could be  instance  maximize
unorderdness minimize length longest chain modified plan  however  find de  reordering many pairs unordered actions possible
dual computing minimum de  reordering is  thus  already covered  minimizing
length longest chain condition may relevant actions
executed parallel overall execution time minimized  however  since
number ordering constraints quadratic length chain  because transitive
arcs   minimizing size relation often reasonable approximation minimizing chain length  furthermore  minimizing longest chain still rather weak
condition purpose  better study directly problem finding shortest
parallel executions plans  done later article 
another issue whether minimize size ordering relation given 
reduce transitive reductive closure it  since plans may super uous orderings
particular purpose  reasonable standardize matters either add possible
transitive arcs  getting transitive closure  remove transitive arcs  getting
reductive closure  choice two important results
proven  however  minimizing transitive closure give preference plans
many unordered short chains actions plans long chains  seems
coincide better term  least constrained  

    computing least constrained plans
minimal deordering weaker two least constrainment criteria considered 
least costly achieve it one three criteria
satisfied polynomial time modification plan 
   

ficomputational aspects reordering plans

definition     search problem

minimal constrained deordering  mlcd 

defined follows 
given  ppi  valid plan p  
output  minimal constrained deordering p wrt   

theorem    

mlcd solved polynomial time validity p o  plans

tested polynomial time 

proof  consider algorithm mld figure   let q   ha    plan output
algorithm input p   ha  i  plan q obviously valid deordering p wrt 

  obvious termination condition loop
ordering      s t  ha      valid  follows q minimal constrained
deordering  since algorithm obviously runs polynomial time  theorem follows 

 

furthermore  validity testing expensive  dominating cost mld
algorithm 

corollary     validity testing p o  plans solved time o f  n  
function f  n   mlcd solved o maxfn      n  f  n g  time 
  procedure mld
 
input  valid p o  plan p   ha  ppi
 
output  minimal deordering p
  e   s t  ha     feg  i  valid
 
remove e
  return ha    i 

figure    minimal deordering algorithm mld
particular  note plan validation polynomial usual variant propositional strips without conditional actions  nebel   backstrom        theorem      
precisely  proof pertains common propositional strips formalism  cps 
and  thus  holds common variants propositional strips  ground
tweak  backstrom         furthermore  note practice may necessary
compute transitive closure either output plan validating plan
algorithm 
minimum de  reordering stronger criteria minimal deordering 
costly achieve 

definition     decision problem

minimum constrained deordering  mmcd 

defined follows 
given  ppi    valid plan p integer k   
question  deordering ha  p s t  j j k 
   

fibackstro

definition     decision problem

minimum constrained reordering  mmcr 

defined follows 
given  ppi    valid plan p integer k   
question  reordering ha  p s t  j j k 

theorem    

minimum constrained deordering np hard 

proof  proof reduction minimum cover  garey   johnson        p       
np complete  let   fp            pn g set atoms  c   fc            cm g set
subsets k jc j positive integer  cover size k subset c   c s t 
jc  j k  t  c   construct  polynomial time  gt ppi   h   frgi
 valid t o  plan p   ha              pre ai       post ai     ci   m 
pre as     post as     frg  obviously  minimum cover size k
iff exists  valid p o  plan q   hfa              g  s t  j j k  since
 

actions contributing cover need remain ordered wrt 

corollary    

 

minimum constrained reordering np hard 

corollary     

minimum constrained deordering minimum constrained

reordering remain np hard even restricted gt plans actions

positive pre  post conditions 

theorem      validity p o  plans complexity class c 

minimumconstrained deordering minimum constrained reordering np c 

proof  guess solution  verify de  reordering validate using

 

oracle c 

common planning formalisms without conditional actions context dependent
effects  minimal de  reordering np complete 

theorem      validity p o  plans tested polynomial time  minimum 

constrained deordering minimum constrained reordering np complete 

proof  immediate theorems          corollary     

 

follows immediately corresponding search problems  is  problems
generating minimum constrained de  reordering np hard  and even np equivalent
validity testing tractable  
furthermore  mmcd mmcr hard solve optimally  even
approximate  neither problems approximation class apx  crescenzi
  panconesi         ie neither problem approximated within constant factor 
 both elsewhere article term approximation used constructive
sense  results refer existence non existence algorithms producing
approximate solution polynomial time  
   

ficomputational aspects reordering plans

theorem     

minimum constrained deordering minimum  constrained
reordering cannot approximated within constant unless np   dtime  npoly log n   

proof  suppose polynomial time algorithm approximating mmcd within
constant  since reduction proof theorem     preserves solutions exactly 
approximations preserved  hence  minimum cover could approximated within
constant  impossible unless np   dtime  npoly log n    lund   yannakakis 
       contradicts assumption  case mmcr trivial consequence   
using number propositional atoms plan measure size 
bound strengthened         ln jpj arbitrary   unless np   dtime  nlog log n  
substituting result minimum cover  feige        proof above 

   parallel plans

order study problem finding shortest parallel execution plan  formalisms used far quite sucient  since lack capability modelling
actions executed parallel not  impossible say reasonable precision certain action ordering affect parallel execution time  partial order
plans sometimes referred parallel plans literature  misleading  however 
two actions left unordered plan means executed
either order  without affecting validity plan  general case
guarantee plan remain valid executions actions overlap
temporally  cases  unorderedness means parallel overlapping execution
allowed  cases mean that  depending action modelling
underlying domain assumptions  first case  plan must stronger ordering
committment  two actions must overlapping executions must ordered 
thus making plan over committed 
order distinguish two cases  concept parallel plans introduced below 
parallel plan partial order plan extra relation  non concurrency relation 
tells actions must executed parallel  article two actions
considered parallel executions temporal overlap all  plans
unordered actions executed parallel constitute special case definite parallel
plans 

definition     parallel plan triple p   ha     i  ha  p o  plan
  irre exive  symmetric relation a  definite parallel p o plan parallel plan
p   ha     i s t             
intuitively  parallel plan p o  plan extended extra relation     a nonconcurrency relation   expressing actions must executed parallel 
relation primarily intended convey information actions unordered
relation  although allowed relate actions  is   
relation intended capture information whether two actions executed
parallel not  general  two actions ordered plan forbids executing
parallel particular plan  necessarily mean actions could
   

fibackstro

executed parallel different circumstances  planning algorithms frequently produce overcommitted orderings plans  whole purpose article study
problem optimizing plans finding removing overcommitted orderings  hence 
restrictions general relation   addition definition     
instance  b imply a b  however  non concurrency relation
frequently constrained satisfy post exclusion principle 
definition     parallel gt plan p   ha     i satisfies post exclusion principle
iff actions a  b   a  a b whenever atom p s t  p   post a 
 p   post b  
definition plan validity directly inherited p o  plans 
definition     given ppi   parallel plan ha     i  valid iff p o  plan ha 
 valid 
non concurrency relation is  thus  relevant deciding whether plan valid
not  instead  used constraining parallel plans may executed
core concept behind definition parallel executions 
consider  instance  gt plan hfa  b  c g  fha  b ig  fhb  c igi shown
figure    arrows denote ordering relations dashed lines denote nonconcurrency relations   plan valid wrt  ppi   h   fr  sgi  final value atom q
matter  since b  c holds actions b c constrained executed
parallel  may executed either order  is  plan definite  could
post exclusion principle employed  reason  although
a b hold actions b clearly cannot executed parallel  since b
holds  four ways execute plan  either three sequences a b c 
a c b c a b  executing c parallel  followed b  unit length assumed   note plan would longer valid goal contained either q
 q  since final truth value q depends actual execution order  furthermore 
reordering plan would keep ordering constraint b satisfy
validity criterion  necessary constraint a b   would harm
include restriction  complex plans may over constrainment 
several producers atom p choose between  instance  sum up 
non concurrency relation primarily used mark actions must
parallel addition already forbidden parallel validity 
framework parallel plans admits expressing possible parallelism only  necessary
parallelism scope article requires planner access
able make use additional information  perhaps temporal algebra 
furthermore  set non concurrent actions easily expressed making actions
set pairwise non concurrent  formalism sucient say k
actions  more  set may executed parallel  similarly  possible
express action must executed interval  two sets
actions must non overlapping executions 
definition     let p   ha     i parallel plan let function      n denote
duration action  parallel execution p function r      n   denoting
release times actions a  satisfying a  b   a 
   

ficomputational aspects reordering plans



p

q
r

b
 

c  s q
figure    parallel plan
   b  r a    d a  r b 
   a b  either
 a  r a    d a  r b 
 b  r b    d b  r a  
length parallel execution defined maxa a fr a    d a g  ie  latest finishing time action  minimum parallel execution plan parallel execution
minimum length among parallel executions plan  length parallel plan p  
denoted length p    length minimum parallel execution s  p  

p

obviously  every parallel plan parallel execution length a a d a   which
trivial case sequential execution   furthermore  certain cases  hardness results
strengthened restricting duration function 
definition     special case d a        referred unit
time assumption 
deciding whether release time function parallel execution tractable 
theorem     given parallel plan p   ha     i  duration function      n
release time function r      n   decided polynomial time whether r parallel
execution p and  case is  length execution is 
proof  trivial 
 
consider plan figure   three release time functions r    r  r    defined
follows
r  a      r   b       r   c      
r  a      r   b       r   c      
r  a      r   b       r   c       
r  r  parallel executions plan  r  not  furthermore  r 
minimum parallel execution plan  length    however  computing
minimum parallel execution parallel plan dicult general case 
   

fibackstro

definition     decision problem parallel plan length  ppl  defined follows 
given  parallel plan p   ha     i  duration function integer k 
question  p parallel execution length k shorter 

theorem    

parallel plan length np hard 

proof  hardness proven transformation graph k colourability  garey
  johnson        p        np complete  let g   hv  e arbitrary undirected graph  v   fv            vn g  construct  polynomial time  gt ppi follows  define ppi   h   fp            pn gi  define parallel plan p   ha      i 
contains one action ai vertex vi   v   s t  pre ai       post ai    
fpi  qi g   f qj j fvi  vj g   e g  finally  let ai aj iff fvi   vj g   e   satisfies post 

exclusion principle  plan p constructed obviously  valid  easy see
g k colourable iff p parallel execution length k wrt  since colour g
correspond unique release time parallel execution p  
 

corollary    

parallel plan length remains np hard even restricted gt ac 

theorem     

parallel plan length np 

tions empty preconditions assumption unit time post exclusion
principle 

proof  guess parallel execution  verify it  done polynomial time
 

according theorem     

computing minimum parallel execution plan tractable special case definite
plans  however 

theorem     
parallel plans 

parallel plan length solved polynomial time definite

proof  use algorithm dppl  figure     straightforward stratification
 

algorithm directed dags 

   reordering parallel plans
defined concept parallel plan  possible define concepts similar
previous least constrainment criteria appropriate minimizing
execution time parallel plans 

definition     let p   ha     i q   ha       i two parallel plans ppi 
then 

   q parallel reordering p wrt  iff p q  valid 
   

ficomputational aspects reordering plans

 
 
 
 
 
 
 
 
 
  
  
  

procedure dppl

input  definite parallel plan p   ha     i
output  minimum parallel execution r p
construct directed graph g   ha 
 
r a   
    
select node   without predecessors
b   s t  b
r b  max r b   r a    d a  



return r

  fag

figure    algorithm computing minimum parallel execution definite parallel plans 
   q parallel deordering p wrt  iff q parallel reordering p    
   q minimum parallel reordering p wrt  iff
 a  q parallel reordering p wrt 
 b  parallel reordering p wrt  shorter length q 
   q minimum parallel deordering p wrt  iff
 a  q parallel deordering p wrt 
 b  parallel deordering p wrt  shorter length q 

modifying plans satisfy either latter two criteria dicult general case 
however 

definition     decision problem minimum parallel deordering  mmpd  defined follows 
given  ppi   parallel plan p   duration function integer k 
question  p deordering parallel execution length k wrt   

definition     decision problem minimum parallel reordering  mmpr  defined follows 
given  ppi   parallel plan p   duration function integer k 
question  p reordering parallel execution length k wrt   

theorem     minimum parallel deordering np hard 
proof  similar proof theorem      given graph g integer k  construct
ppi plan p   ha     i way proof theorem     
let arbitrary total order a  obviously  p  valid q   ha      i

deordering p s t  deordering p shorter q  hence  q  thus p  
deordering parallel execution length k iff g k colourable 
 
   

fibackstro

corollary    
corollary    

minimum parallel reordering np hard 

minimum parallel deordering minimum parallel reordering remain np hard even restricted totally ordered gt plans as 

sumptions unit time simple concurrency 

note restriction definite input plans covered corollary  output
plans required definite  reordering case remains np hard 

theorem    

minimum parallel reordering remains np hard output

plan restricted definite 

proof  reuse proof theorem     follows  let r shortest parallel execution
plan q assume execution length n  construct order   s t 
actions a  b   a    b iff r a    r b   obviously plan ha       i definite

minimum parallel reordering p   follows p definite parallel reordering
length k iff g k colourable 
 

open question whether minimum deordering remains np hard output
plans must definite  important special case polynomial  proven
next section 

theorem    

minimum parallel deordering minimum parallel reorder 

ing np c validation p o  plans complexity class

c 

proof 

given plan ha     i  duration function parameter k  guess
de reordering   release time function r  verify  using oracle c  
ha       i valid  finally  verify r parallel execution length k 
polynomial according theorem     
 

theorem     minimum parallel de  reordering np complete p o  plans vali 

dated polynomial time 

proof  immediate theorems         corollary     

 

problems mmpd mmpr hard solve optimally 
approximate 

theorem     

minimum parallel deordering minimum parallel reordering cannot approximated within jaj             unless p np 

proof 
suppose polynomial time algorithm approximating mmcd within
jaj             immediate proof theorem    
graph k colourability could approximated within jaj        impossible
unless p np  bellare  goldreich    sudan        

 

reasoning  bound strengthened jaj      assumption
co rp  np  feige   kilian        
   

ficomputational aspects reordering plans

   restricted cases
since problems computing minimum de  reorderings dicult  even
dicult approximate  alternative way tackling could study restricted
cases  one special case already considered restriction definite plans only 
problem mmpr still np complete restriction  open question whether
mmpd np complete  positive result proven  though  effect
mmpd polynomial definite plans large class planning languages  including
commonly used ones  result proven generalising algorithm
literature deordering total order plans 
based  not necessarily true  argument easier generate t o  plan
p o  plan using complex action representations  regnier fade      a      b 
presented algorithm converting t o  plan p o  plan  resulting plan
property unordered actions executed parallel  is  plan
definite  authors algorithm claim algorithm finds pairs
actions executed parallel and  hence  plan post processed
find optimal parallel execution  define mean criterion 
however 
incidentally  algorithm proposed regnier fade special case algorithm earlier proposed problem pednault         make
claims optimality  removing regnier fade s algorithm details relevant
particular implementation planning language  two algorithms coincide
thus presented one single algorithm  prf algorithm   figure     
prf slightly modified original algorithms  first  assume input plan totally ordered  since turns sucient definite partial order
plan  second  prf returns parallel plan  rather p o  plan a harmless modification since additional piece information non concurrency relation 
already given input  either explicitly implicitly  third  prf returns transitive
closure ordering relation  means necessary  motivated  usual 
conforming definitions article 
  procedure prf 
 
input  ppi    valid definite p o  plan ha  non concurrency
relation  
 
output   valid parallel plan
  a  b   s t  b
 
a b
 
order   b 
  return ha        i 

figure     prf algorithm
obviously  prf computes deordering input  unclear whether possible compute minimal definite deordering polynomial time  however  algorithm
   afterwards  algorithms literature referred acronyms consisting
initials authors  case pednault  regnier fade 

   

fibackstro

abstracted general formalism  analysis restricted formalisms reveals performance  language used regnier fade
unnecessarily restricted algorithm shown work considerably
general formalism  based generalising abstracting concepts producers  consumers threats used common planners planning languages  eg strips
tweak  formalism referred producer consumer threat formalism
 pct  
let prod a    denote produces condition   cons a    consumes
threat a    threat   simplify definitions  standard transformation
used simulating initial goal states actions  is  every pct plan
contains action ordered actions consumes nothing produces
initial state  similarly  action ordered actions consumes
goal state produces nothing  means ppi contained within plan
itself  references ppis omitted following  validity plans
defined follows 

definition     t o  pct plan ha            valid iff i    n
conditions s t  cons ai      j     j   s t  prod aj     k 
j k s t  threat ak      p o  pct plan valid iff topological sortings

valid 

chapman s modal truth criterion  mtc   chapman        abstracted
pct formalism analogously used validating p o  plans 

definition     modal truth criterion  mtc  pct plan ha  is 
 ac   cons ac      
 ap  prod ap       ap ac  
 at  threat at      
ac  
 aw  prod aw       aw   aw ac     
theorem     mtc holds pct plan p iff valid 
proof  trivial generalization proofs leading theorem     nebel backstrom

 

       

minimum constraints two actions may executed parallel
required  constraints obeyed planners ai literature 

definition     simple concurrency holds actions a  b s t     b  nonconcurrency relation satisfies following three conditions
   prod a      cons b      a b
   prod a      threat b      a b
   cons a      threat b      a b
   

ficomputational aspects reordering plans

note required two producers  two consumers two threats
condition non concurrent  thus allowing  instance  plans multiple producers  eg
nebel backstrom        fig     kambhampati         axioms prevent
adding restrictions  though  furthermore  note definition states necessary condition non concurrency it perfectly legal add non concurrency
constraints actions plan  may worth noting mtc requires
producers threats ordered correpsonding consumer 
definite plan satisfying simple concurrency criterion always require ordered 
following observation prf immediate algorithm used
proofs below 

observation     ha     i input prf ha       i corresponding
output  holds   b iff b a b 
based lemma  proven prf preserves validity 

lemma     plan input prf valid pct plan   satisfies simple
concurrency criterion  output plan valid 

proof  let p   ha     i input plan q   ha       i output plan  since

p valid  follows theorem     mtc holds p   adding implied
simple concurrency constraints mtc yields following condition 

 ac   cons ac      
 ap  prod ap       ap ac   ap  ac  
 at  threat at      
 ac   ac  at   
 aw  prod aw     at aw    aw  
aw ac   aw  ac      
applying observation     simplified to 

 ac   cons ac      
 ap  prod ap       ap   ac  
 at  threat at      
ac    
 aw  prod aw         aw   aw   ac      
mtc plan q  using theorem      follows q valid 

 

allows proving prf produces definite minimum deorderings definite pct
plans simple concurrency 

theorem     using pct formalism simple concurrency  prf produces
minimum deordered definite version input 
   

fibackstro

proof  let p   ha     i input plan  assumed valid definite 
q   ha       i output plan  obvious   follows lemma    

q valid  q deordering p   remains prove q minimum deordering
p  
suppose p deordering r   ha        i s t  j    j   j   j  then  must
a  b   s t    b     b  assumed   b

transitive arc     since transitive closure anyway computed end
algorithm  since order   produced prf  follows observation    
b a b  latter constraint  necessary either     b
b    holds  former possible since b r deordering p  
contradicts assumption  q must minimum deordering p  
 
since prf polynomial algorithm  follows definite minimum deorderings
definite pct plans computed polynomial time simple concurrency  furthermore  since prf produces definite plans possible actually compute shortest
parallel execution eciently 

theorem     plan input prf valid definite pct plan satisfying
simple concurrency criterion  prf outputs definite minimum deordering plan 

proof  prf runs polynomial time obviously produces definite parallel plans 
hence  follows theorem      minimum parallel execution output plan
found polynomial time  proves theorem 
 

seems likely regnier fade meant optimality claim  although special instance pct formalism  result says nothing
diculty finding minimum reordering plan  since prf considers deorderings 
since minimum deorderings approximate minimum reorderings well  suspected dicult compute latter  following theorem confirms
suspicion  showing latter problem remains np hard quite severe restrictions 
including following two 

definition     gt action toggling iff literals l   post a   case
 l   pre a   gt action unary iff jpost a j     
theorem      minimum parallel reordering remains np hard even restricted

total order gt plans toggling unary actions assumption unit
time  simple concurrency actions redundant 

proof theorem appears appendix a 
minimum reorderings dicult compute minimum deorderings 
produce arbitrarily better results 

theorem     

minimum parallel deordering cannot approximate minimum parallel reordering within jajk constant k   

proof theorem appears appendix a 
   

ficomputational aspects reordering plans

corollary      minimum parallel deordering cannot approximate minimum parallel reordering within jajk constant k   even problems restricted gt plans positive preconditions assumption simple
concurrency 

may  thus  appear though minimum reordering preferable  albeit costly 
operation minimum deordering  however  plan modification followed
scheduling  longer obvious reordering prefer  since scheduling may
take information constraints account  eg upper lower bounds
release time limited resources  feasible schedule original plan may longer
feasible schedule reordering plan  is  feasible solutions
may lost reordering plan  contrast this  deordering plan harmless
since previously feasible schedules preserved deordering  course  de reordered plan may new better schedules old plan 
problems studied article interesting all  however  minimum deordering
safe and  usually cheap  operation  minimum reordering neither must thus
applied care  find reordering plan optimum schedule would
require combining minimum reordering scheduling one single computation 
scope article study combinations  suce observe
computation never cheaper either constituent computations 

   related work
section analyses discusses algorithms suggested literature generalising ordering plan  addition prf algorithm already analysed
preceeding section  planners generate plans optimality avour
ordering discussed 
algorithms analysed use common trick simulating initial
state goal planning instance two extra operators  following way  let
p   ha  plan   hi  gi ppi  gt language  introduce two extra
actions ai   pre ai       post ai       ag   pre ag     g post ag       
define plan q   ha   fai   ag g         fai a  ag j   ag fai ag g 
ai ordered actions ag ordered actions 
plan q representation plan p ppi   combined representation
referred self contained plan  self contained plan valid iff valid wrt 
ppi h    i  trivial convert plan ppi corresponding self contained
plan vice versa  hence  ways representing plan used alternately
without notice 

    vpc algorithm

veloso et al         presented algorithm  here referred vpc    converting
t o  plans  least constrained  p o  plans  use algorithm following context 
first total order planner  nolimit  used produce t o  plan  vpc converts plan
   original publication algorithm named build partial order 

   

fibackstro

  procedure vpc 
 
input  valid self contained t o  plan ha           
a    ai   ag
 
output  self contained valid p o  plan
    n
 
p   pre ai  
 
find max k   s t  p   post ak   
 
k exists
 
order ak ai
 
 p   post ai  
  
  k   s t  p   pre ak  
  
order ak ai
  
primary effect p   post ai  
  
  k s t   p   post ak  
  
order ai ak
  
      n
  
order ai ai ai ag
  
return hfa           ang   i 

figure     vpc algorithm
p o  plan post processed determine actions executed
parallel  action language used strips style language allowing quantifiers
context dependent effects  however  plans produced planner  thus input
vpc  ground without context dependent effects  is  ordinary
propositional strips plans  vpc algorithm presented figure     minor
differences presentation compared original appearance  first  algorithm
presented gt formalism  order minimize number formalisms article 
preconditions assumed positive  thus coinciding original algorithm 
second  original algorithm returns transitive reduction computed order
instead returns transitive closure here  unimportant difference order coincide
definition plans article  furthermore  veloso  pointed
published version vpc algorithm incorrect corrected version exists 
version presented figure    corrected version  proposition primary
effect appears either goal subgoaling chain goal proposition 
vpc greedy algorithm constructs entirely new partial order analysing
action conditions  using original total order guide greedy strategy 
algorithm claimed  veloso et al         p       produce  least constrained  p o  plan 
although definition given means  veloso  confirmed term  least
constrained plan  used  loose sense  optimality claim intended  however 
term defined  impossible know problem algorithm
intended solve judge whether makes improvement using algorithm
all  absence definition authors  algorithm analysed
respect least constrainment criteria defined section    admittedly
   personal communication  oct       
   veloso  ibid 

   

ficomputational aspects reordering plans

p
q
 

b r


p

pq
ppp
pp
qc
p 

pq

q

 p b qr

 q c

p 

figure     p o  plans failure example vpc 
somewhat unfair analysis  reveals interesting facts algorithm 
problems solve  immediate theorem     corollary    
vpc cannot expected produce minimum constrained de  reorderings  perhaps
surprisingly  vpc even guarantee output minimal  constrained
deordering input  problem already proven trivially polynomial  theorem      
illustrated following example 
suppose total order planner given ppi   h   fr  sgi input  may
return either  valid t o  plans ha  b  ci ha  c  bi  action conditions shown
figure     used input vpc  two t o  plans give quite different results the plan ha  c  bi converted p o  plan p  figure    
plan ha  b  ci converted p o  plan p  figure     is  first
case vpc produces plan minimal constrained deordering even
minimum constrained deordering  second case even produce
minimal constrained deordering  
reason vpc may fail produce minimal constrained deordering
uses non admissible greedy strategy  whenever needs find operator achieving
effect required precondition another operator b  chooses last action
ordered b input t o  plan  however  may actions earlier
plan effect better choice 

    kk algorithm

kambhampati kedar        presented algorithm generalising ordering p o  plan  using explanation based generalisation  algorithm based first
constructing validation structure plan use guide generalisation phase  original paper  computations divided two separate
algorithms  exp mtc exp ord gen   compacted one single algorithm  kk  figure      furthermore  version presented restricted ground
gt plans  original algorithm handle partially instantiated plans 
restriction results shown below 
first part kk algorithm constructs validation structure v plan 
is  explanation precondition every action plan  validity criterion
underlying phase simplified version chapmans modal truth criterion  chapman 
   note transitive arcs omitted figures  p  really ordering relation size three 
although example would work plans defined equally reasonable way
ordering relations intransitive  possible construe similar examples case 

   

fibackstro

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  

procedure kk

input  valid self contained p o  plan ha 
output  deordering input plan
comment build validation structure v plan

v

 

let ha            topologically sorted version ha 
  n
p   pre ai  
find min k   s t 
   p   post ak  
   j s t  k   j    p   post aj  
add hak   p  ai v
comment construct generalised ordering   plan
ha  bi  
add ha  bi   either following holds
     ai   ag
   ha  p  bi   v p
   hc  p  ai   v  p   post b 
   hb  p  ci   v  p   post a 

return ha   i

figure     kk algorithm
      without white knights  since algorithm simplified handle ground plans
here  explanation causal link hap   p  ac i  meaning action ap produces
condition p consumed action ac   algorithm constructs exactly one
causal link precondition  chooses earliest producer p preceeding ac
intervening action producing  p producer ac   second phase
algorithm builds generalised ordering   plan based validation
structure  put things simply  orderings original plan kept
either correspond causal link validation structure required prevent
threatening action unordered wrt  actions causal link 
turns kk algorithm fails generating plans guaranteed even minimal constrained deorderings  consider t o  plan ha  b  c  di
action conditions indicated figure     t o  plan valid ppi
h   fr  s  t  ugi  since kk algorithm always chooses earliest possible producer
precondition validation structure  build validation structure
fha  p  di  ha  s  ag i  hb  q  di  hb  t  ag i  hc  r  ag i  hd  u  ag ig  hence  final ordering
produced kk shown figure   a  however  plan minimalconstrained deordering original plan  since deordered shown
figure   b remain valid  example  input plan totally ordered 
case partially ordered input plans  behaviour algorithm depends particular topological order choosen  algorithm may may find minimal constrained
deordering  impossible guarantee succeed plans  similarly 
authors mention one may consider different ways constructing validation struc   

ficomputational aspects reordering plans

ture  would clearly modify behaviour remains open question whether
possible generate  polynomial time  validation structure guarantees
minimal constrained deordering constructed second phase algorithm  finding validation structure guarantees minimum constrained deordering obviously
np hard problem since second phase algorithm polynomial 
ps

ps

zz

b qt

zz  p
q

p
r

u

c q

a  plan produced kk

q

u

b qt

c pq

r

 p

b  minimal deordered version

figure     failure example kk algorithm

    planners optimality guarantees
planning algorithm graphplan  blum   furst        notion time steps
tries pack many non interacting actions possible one single time step  furthermore  graphplan finds shortest plan  using number time steps measure 
assuming unit time actions considered non interacting graphplan
executed parallel  plan shorter parallel execution
plan produced graphplan  is  graphplan produces minimum reordered
parallel plans assumptions  second assumption limitation practice 
since non concurrency relation encoded introducing new atom letting
one interacting actions add one deletes it  unit time assumption serious  however  especially since assumption likely hold
applications  car assembly scenario section    instance  graphplan would
produce plan corresponds plan figure    hence  plan produced
unit time assumption happens coincide optimal plan taking actual
execution times account  fortunate coincidence  however  depending
particular durations actions example  suppose instead durations
actions slightly different pac duration   mvt  duration   
plan produced graphplan  corresponds plan figure   
faster schedule    time units  optimal since plan figure  
scheduled execute    time units particular duration times  furthermore  must remembered graphplan anyway restricted cases
gt equivalent planning language sucient  although recent improvements extend
   

fibackstro

somewhat expressive languages  gazen   knoblock        kohler  nebel  hoffman 
  dimopoulos        
knoblock        modified ucpop planner resource concept makes
avoid unordered interacting actions  means resulting planner produces
definite parallel plans  knoblock modified evaluation heuristic search
take parallel execution time account  thus seems planner might able
produce minimum reordered parallel plans  paper provide sucient details
determine whether case  unclear whether heuristic handle
actions different duration times 
yet another example polynomial time planner sas  iao planning language  jonsson   backstrom        produces plans minimum constrained
reordered  is  restricted formalism clearly possible optimise ordering
polynomial time 

   discussion
previous section listed planning algorithms literature produce
attempt produce plans least constrained minimum parallel reordered 
certain restrictions  though  furthermore  plans always generated
 from scratch   generated modifying already existing plan  referred
case based planning  repairing plan failed execution phase 
cases  old plan may contain many ordering relations obsolete
modified repaired plan  fact  kk algorithm  kambhampati   kedar       
motivated context case based planning  important remember
today  probably long time future  plans generated entirely
computer programs  vast majority plans various applications designed
humans  possibly computer support  already quite small plans  dicult
human see whether ordering constraints optimal not  computer support
analyses vital designing optimal plans  reason  hierarchicaltask network planners  eg o plan  currie   tate        sipe  wilkins         produce
plans reordering actions could lead better schedules  planner often commits
one two possible orderings pair actions based expert knowledge rules 
however  hardly possible human expert design rules situations
guarantee optimal ordering choice made 
coarseness level complexity analysis matter whether tasks
planning  plan optimization scheduling integrated separated since total
resulting complexity cases the latter two computations
np complete will  thus  dominated planning  pspace complete
worse  however  good reasons prevented research community
studying planning scheduling separate problems  since understanding problem
isolation helps understanding overall process  reason  important
study separately problems discussed analysed article  furthermore 
fine grained  practical level might considerable differences eciency
integrating three computations separately  instance  even
three computations take exponential time  problems considered isolation
   

ficomputational aspects reordering plans

may fewer parameters  case may much ecient solve
isolation  hand  solving whole problem may make easier
global optimisation  better depend methods used
various properties actual application  seems unlikely one
methods always better 
shown article  minimum reordering much better optimality
criterion minimum deordering  considering overall parallel execution time 
however  necessarily true considering metric constraints subsequent scheduling  deordering plan add number feasible schedules 
reordering may remove or  worst case  feasible schedules 
hand  reordering may lead new better schedules reachable via deordering 
deordering thus viewed safe and  sometimes  cheap way allow better
schedules  reordering expensive method potential generating
considerably better plans  may make things worse  using reordering
practice cases metric scheduling constraints involved  seems necessary
use feedback scheduler control reordering process  try reorderings  one could imagine reordering algorithm uses either heuristic search
randomized local search methods la gsat  selman  levesque    mitchell        find
reorderings use scheduler evaluation function proposed reorderings 
plan modifications studied article may add considerably optimizations possible traditional scheduling only  still potential
optimization left study modifying action order  set actions  modification already done plan adaptation  generating
new plan old cases  optimizations sense article considered 
preliminary studies action set modifications appear literature  though  fink
yang        study problem removing redundant actions total order plans 
defining spectrum redundancy criteria analysing complexity achieving these 
less clear interesting study action addition  adding actions plan could
obviously improve execution time executed sequentially  however 
case parallel execution plans shown adding actions plan
sometimes allow faster execution  backstrom         finally  allowing removal
addition actions  even greater potential optimising plans seems available 
problems seems yet studied literature 

    conclusions
article studies problem modifying action ordering plan order
optimise plan according various criteria  one criteria make plan
less constrained minimize parallel execution time  three candidate
definitions proposed first criteria  constituting spectrum increasing
optimality guarantees  two based deordering plans  means ordering relations may removed  added  last one builds reordering 
arbitrary modifications ordering allowed  first three candidates 
subset minimal deordering  tractable achieve  two  deordering re   

fibackstro

ordering plan minimize size ordering  np hard even dicult
approximate 
similarly  optimising parallel execution time plan studied deordering
reordering plans  general case  computations np hard
dicult approximate  however  based algorithm literature shown
optimal deorderings computed polynomial time definite plans class
planning languages based notions producers  consumers threats 
includes commonly used planning languages  computing optimal reorderings
potentially lead even faster parallel executions  problem remains np hard
dicult approximate even quite severe restrictions  furthermore  deordering
plan safe respect subsequent scheduling  reordering plan may remove
feasible schedules  making deordering good  often suboptimal  approach practice 

acknowledgements

tom bylander  thomas drakengren  mark drummond  alexander horz  peter jonsson 
bernhard nebel  erik sandewall  sylvie thibeaux anonymous referees provided
helpful comments article previous versions it  research supported
swedish research council engineering sciences  tfr  grants dnr        
       

appendix

theorem      minimum parallel reordering remains np hard even restricted

total order gt plans toggling unary actions assumption unit
time  simple concurrency actions redundant 

proof  proof reduction  sat  garey   johnson        p        let p  
fp            png set atoms c   fc            cm g set clauses p s t 
  m  ci   fli     li     li   g set three literals p  
first define set atoms

q   fpfi   pti   qi j   ng   fci j   ri j j   n    j  g 
define gt ppi   hi  gi initial goal states defined
  neg q 
g   fpfi   pti    qi j   ng   fci j    ri j j   n    j  g
also  atom pi   p   define four actions according table   
further  clause ci   c   define nine actions according table  
  f

l   pk li j    pk
i j

ptk

li j   pk  

let set  n    m actions thus defined  clearly total order
s t  plan p   ha   valid  obvious none actions redundant 
   

ficomputational aspects reordering plans

trivial observation parallel execution r  valid reordering p
must satisfy i    n  either

r afi     r a i     r ati     r a i  

i    m 

r  c  

i k 

r a i     r ati     r a i     r afi   

     
    
r
 ci k
r ci k   
 
 
 
 
i k      r c       r bi k      r c       r bi k      r ci k    
i k 
i k 

    r b  

 

k    k    k  permutation numbers           this interpreted s t 
  c   released either order  simultaneously  analogously
actions ci k
i k 
 
 
    
actions ci k
ci k
 
 
remainder proof shall show p reordered parallel
execution length   iff set c clauses satisfiable 
if  suppose c satisfiable  let truth assignment atoms p satisfies
c   wlg  assume  pi     i  further  clause cj   let lj literal cj
satisfied   disregarding action order moment  choose release time
function r actions follows    n  let

r a i        r ati        r a i        r afi       
further  j     j m  choose k  s t  lj k    cj satisfied  at least one
choice must exist assumption   let lj k  lj k  remaining two literals cj  
assign release times s t    h   
       h      r  b        h   r  c        h     
r cj k
j kh
j kh
h

define partial order   s t  actions a  b   a    b iff r a    r b  
clearly  plan ha     valid reordering p r parallel execution length
  ha    i   note choice could force longer execution 
execution length   case c satisfied setting atoms false  
operator precond  postcond 

afi
ati
a i
a i

 pfi    qi pfi
 pti   qi pti
 qi
qi
qi
 qi

table    generic actions atom pi proof theorem      
   

fibackstro

operator precond 

bi   
bi   
bi   
ci   
ci   
ci   
ci   
ci   
ci   

li     ri      ri      r       ci  
li      ri    ri      r       ci  
li      ri     ri    r       ci  
 ri  
ri  
 ri  
ri  
 ri  
ri  

postcond 

ci  
ci  
ci  
ri  
 ri  
ri  
 ri  
ri  
 ri  

table    generic atoms clause ci proof theorem      
if  suppose c satisfiable  suppose q minimum reordering
p r parallel execution length   shorter q  wlg  assume every
action released early possible r  then  according observation
must hold i    n  either
r afi        r a i        r ati        r a i      

r a i        r ati        r a i        r afi       
hence  exactly one atoms pfi pti true time    let pi denote atom  since
   
r length    follows earlier observation j     j m  r bj k
k    k    hence  lj k   pi i  since q  valid r parallel
execution q  define interpretation s t  i    n 
 
pi   pfi
 pi     f 
t  otherwise  
however  interpretation obviously model c   contradicts assumption 
follows r must length   longer 
concludes proof shows c satisfiable iff p reordering
parallel execution length   not 
 

theorem     

minimum parallel deordering cannot approximate minimum
parallel reordering within jajk constant k   

proof  proof assumes gt plans simple concurrency  first  define generic

actions aki  m   bki cki  m  according table     further  define recursively generic
plans
   
ha
     b 
  c 
             a im      b im   c im    i 
k    
k
pi  m    ha ki   m    m   p i k    m     mi     cmk  
k
 
 
k
k
   m           aim  m   pim  m   cim  m i  k     
 i   m  
 i   m  
   

ficomputational aspects reordering plans

furthermore  arbitrary k  n     define ppi kn   hfpk            pkn g  fq k           qnk gi 
now  prove claim arbitrary k  n      plan p k  n 
   kn  valid 
p     ni
   deordering length less  nk   ki  
   reordering length  k     
proof induction k 
base case  k     choose arbitrary n      plan p    n  obviously kn  valid
deordering itself  length  n  consider reordering q    n 
p    n  actions ordering relation defined s t  i    n 
a i     b i c i     i      n  a i     b i     reordering k  n  valid
parallel execution r    n  length    defined s t  i    n  r    n  a i          
r   n  b i       r    n  c i            this plan shown figure      claim thus
satisfied base case 
induction  suppose claim satisfied l   k  k   prove
claim holds l   k  choose arbitrary n      follows induction
hypothesis none subplans p k    n          pnk    n  deordered 
remain totally ordered  furthermore  i    n  necessary action
aki  n  ordered subplan pik   n  action cki  n  ordered it 
clear i    n order cki  n  aki    n  removed without
making plan invalid  hence  p k  n  deordering itself 
length
n
x
i  

     length pik    n     n     length p k    n   

   n   n  nk    

kx
  
i  

 ni      nk  

kx
  
i  

 ni  

proves deordering case claim 
reordering case  define reordering qk   n  p k  n  actions
ordering relation defined follows  subplan pik    n  p k  n   reorder
actions length   k         possible according induction hypothesis 
further  i    n  j    i     n     j order aki  n  akj     n 
ckj     n  cki  n   or aki    n  akj        ckj        cki  n  case k       hence 
action pre condition

post condition

aki  m  fpki g
fpk i     m             pkim     q ki     m g
bki
fpki g
fqik g
k   g post ck  m     fqk g 
cki  m  fq ki     m             qim


table    generic actions proof theorem      
   

fibackstro

p    n 
a      

a    n 


 
 


  
 
 
p 
    a    
 
 
 
p
 

 
p n  

   
 
   q 

p  

 q  
p  
 q  

 n   

  
r a n   



p n



b  

 

b  

 

b n

   
  

q  

  c     

 

  q  
q      
c      xxxq   
x xxz r c   n 
   
  
 
 
 qn 
 
 
qn      
  cn   





 qn 
  
 



 

 

 
a   n  xxxx  
z
x
 


 
  
   
   
 
 
 q  n   
 
 

x
a n  n 
xxx   x
z

p    n 

pn   n 

x  xxxxz  
    c  n 
   
  

x  xxxxz  
 
   cn n 

figure     reordering q    n  plan p    n  example induction case
proof theorem       solid arrows denote orderings required producerconsumer relationships labelled atom produced consumed 
dashed arrows denote ordering constraints avoid threats labelled possibly con icting atom  
segment type aki  n   pik    n   cki  n  reordered length  k      finally 
i    n  order aki  n  ak i     n  n   or aki  n  ak i     n     case k      
plan qk   n  k  n  valid since subplans p k    n           pnk    n  atoms
common and  thus    relation hold two actions belonging
different subplans  reordered plan executed parallel execution
rik  n  defined s t  rik  n  aki  n        rik  n  cki  n      k     i    n
actions a    qki     n   rik  n  a      rik   n  a         since parallel execution
length  k     reordered plan  claim holds k 
concludes induction  claim holds k      since
p     ni
 nk   ki  
 
k

 k    
  k      k   jaj
k      theorem holds 
 
   

ficomputational aspects reordering plans

references

backstrom  c          finding least constrained plans optimal parallel executions
harder thought  backstrom  c     sandewall  e   eds    current trends
ai planning  ewsp     nd european workshop planning  pp        vadstena 
sweden  ios press 
backstrom  c          executing parallel plans faster adding actions  cohn 
a  g   ed    proceedings   th european conference artificial intelligence
 ecai      pp          amsterdam  netherlands  wiley 
backstrom  c          expressive equivalence planning formalisms  artificial intelligence 
                
backstrom  c     klein  i          parallel non binary planning polynomial time 
reiter  r     mylopoulos  j   eds    proceedings   th international joint conference artificial intelligence  ijcai      pp          sydney  australia  morgan
kaufmann 
bellare  m   goldreich  o     sudan  m          free bits  pcps non approximability 
towards tighter results  proceedings   th annual ieee symposium
foundations computer science  focs      pp          milwaukee  wi  usa 
ieee computer society 
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                    
chapman  d          planning conjunctive goals  artificial intelligence                  
crescenzi  p     panconesi  a          completeness approximation classes  information
computation                  
currie  k     tate  a          o plan  open planning architecture  artificial intelligence                
feige  u     kilian  j          zero knowledge chromatic number    th annual
ieee conference computational compelxity  ccc     philadelphia  pa  usa 
ieee computer society 
feige  u          threshold ln n approximating set cover  preliminary version  
proceedings   th annual acm symposium theory computing  stoc     
pp          philadelphia  pa  usa  acm 
fink  e     yang  q          formalizing plan justifications  proceedings  th conference canadian society computational studies intelligence  cscsi     
pp       vancouver  bc  canada 
garey  m     johnson  d          computers intractability  guide theory
np completeness  freeman  new york 
   

fibackstro

gazen  c     knoblock  c          combining expressivity ucpop eciency
graphplan  steel    alami         pp          
ghallab  m     laruelle  h          representation control ixtet  temporal
planner  hammond         pp        
hammond  k   ed            proceedings  nd international conference artificial
intelligence planning systems  aips      chicago  il  usa  aaai press 
jonsson  p     backstrom  c          state variable planning structural restrictions 
algorithms complexity  artificial intelligence                     
kambhampati  s          multi contributor causal structures planning  formalization
evaluation  artificial intelligence                    
kambhampati  s     kedar  s          unified framework explanation based generalization partially ordered partially instantiated plans  artificial intelligence 
              
klein  i   jonsson  p     backstrom  c          tractable planning assembly line 
ghallab  m     milani  a   eds    new directions ai planning  ewsp    
 rd european workshop planning  frontiers ai applications  pp         
assisi  italy  ios press 
klein  i   jonsson  p     backstrom  c          ecient planning miniature assembly
line  artificial intelligence engineering                
knoblock  c          generating parallel execution plans partial order planner 
hammond        
kohler  j   nebel  b   hoffman  j     dimopoulos  y          extending planning graphs
adl subset  steel    alami         pp          
lund  c     yannakakis  m          hardness approximating minimization problems  journal acm                  
nebel  b     backstrom  c          computational complexity temporal projection  planning plan validation  artificial intelligence                  
pednault  e  p  d          formulating multiagent  dynamic world problems classical
planning framework  georgeff  m     lansky  a  l   eds    reasoning actions plans  proceedings      workshop  pp        timberline  or  usa 
morgan kaufmann 
regnier  p     fade  b       a   complete determination parallel actions temporal
optimization linear plans action  hertzberg  j   ed    european workshop
planning  vol      lecture notes artificial intelligence  pp          sankt
augustin  germany  springer 
   

ficomputational aspects reordering plans

regnier  p     fade  b       b   determination du parallelisme maximal et optimisation
temporelle dans les plans d actions lineaires  revue d intelligence artificielle        
      
selman  b   levesque  h     mitchell  d          new method solving hard satisfiability problems  proceedings   th  us  national conference artificial
intelligence  aaai      pp          san jose  ca  usa  american association
artificial intelligence 
steel  s     alami  r   eds             th european conference planning  ecp     vol 
     lecture notes artificial intelligence  toulouse  france  springer 
stromberg  j  e          styrning av lego bilfabrik  andra omarbetade upplagan  department electrical engineering  linkoping university 
tate  a          interacting goals use  proceedings  th international
joint conference artificial intelligence  ijcai      pp          tbilisi  ussr 
ijcai  william kaufmann 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning parallel
resource allocation  sycara  k  p   ed    workshop innovative approaches
planning  scheduling control  pp          san diego  ca  usa  morgan
kaufmann 
vere  s  a          planning time  windows durations activities goals  ieee
transactions pattern analysis machine intelligence  pami                
wilkins  d  e          practical planning  morgan kaufmann  san mateo  ca 

   


