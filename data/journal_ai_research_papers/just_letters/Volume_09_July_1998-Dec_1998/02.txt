journal of artificial intelligence research                

submitted        published     

computational aspects of reordering plans
christer backstrom

department of computer and information science
linkopings universitet  s        linkoping  sweden

cba ida liu se

abstract

this article studies the problem of modifying the action ordering of a plan in order
to optimise the plan according to various criteria  one of these criteria is to make a plan
less constrained and the other is to minimize its parallel execution time  three candidate
definitions are proposed for the first of these criteria  constituting a sequence of increasing
optimality guarantees  two of these are based on deordering plans  which means that ordering relations may only be removed  not added  while the third one uses reordering  where
arbitrary modifications to the ordering are allowed  it is shown that only the weakest one
of the three criteria is tractable to achieve  the other two being np hard and even dicult
to approximate  similarly  optimising the parallel execution time of a plan is studied both
for deordering and reordering of plans  in the general case  both of these computations are
np hard  however  it is shown that optimal deorderings can be computed in polynomial
time for a class of planning languages based on the notions of producers  consumers and
threats  which includes most of the commonly used planning languages  computing optimal reorderings can potentially lead to even faster parallel executions  but this problem
remains np hard and dicult to approximate even under quite severe restrictions 

   introduction
in many applications where plans  made by man or by computer  are executed  it is important to find plans that are optimal with respect to some cost measure  typically execution
time  examples of such applications are manufacturing and error recovery for industrial
processes  production planning  logistics and robotics  many different kinds of computations can be made to improve the cost of a plan only a few of which have been extensively
studied in the literature  the most well known and frequently used of these is scheduling  a plan tells which actions  or tasks  to do and in which order to do them  while a
schedule assigns exact release times to these actions  the schedule must obey the action
order prescribed by the plan and must often also satisfy further metric constraints such as
deadlines and earliest release times for certain actions  a schedule is feasible if it satisfies all
such metric constraints  it is usually interesting to find a schedule that is optimal in some
respect  eg the feasible schedule having the shortest total execution time  or the schedule
missing the deadlines for as few actions as possible 
in principle  planning and scheduling follow in sequence such that scheduling can be
viewed as a post processing step to planning where planning is concerned with causal
relations and qualitative temporal relations between actions  while scheduling is concerned
with metric constraints on actions  in some planning systems  eg o plan  currie   tate 
      and sipe  wilkins         both planning and scheduling are integrated into one
single system  similarly  temporal planners  eg deviser  vere        and ixtet  ghallab
  laruelle         can often reason also about metric constraints  this does not make it
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fibackstro m

irrelevant to study planning and scheduling as separate problems  though  as can be seen
from the vast literature on both topics  the two problems are of quite different character
and studying them separately gives important insight also into such integrated systems as
was just discussed  for instance  drabble  says that it is often very dicult to see when
o plan plans and when it schedules  it is easy to see that o plan works  but it is dicult
to see why 
a further complication in understanding the difference between planning and scheduling 
both for integrated systems and for systems with separated planning and scheduling  is
that certain types of computations fall into a grey zone between planning and scheduling 
planners are good at reasoning about effects of actions and causal relationships between
actions  but are usually very poor at reasoning about time and temporal relationships
between actions  schedulers  on the other hand  are primarily designed to reason about
time and resource conicts  but have no capabilities for reasoning about causal dependencies
between actions  the problems in the grey zone require reasoning of both kinds  so neither
planners nor schedulers can handle these problems properly  if these problems are not
solved  then the scheduler does not get sucient information from the planner to do the
best of the situation the planner and the scheduler may fail in their cooperation to find a
plan with a feasible schedule  even when such a plan exists 
this article focusses on one of these grey zone problems  namely the problem of optimising the action order of a plan to allow for better schedules  whenever two actions conict
with each other and cannot be allowed to execute in parallel  a planner must order these
actions  however  it usually does not have enough information and reasoning capabilities
to decide which of the two possible orders is the best one  so it makes an arbitrary choice 
one of the choices typically allows for a better schedule than the other one  so if the planner
makes the wrong choice it may prevent the scheduler from finding a good  or even feasible 
schedule  this situation arises also when plans are made by a human expert  since it is difficult to see which choice of ordering is the best one in a large and complex plan  planning
systems of today usually cannot do anything better than asking the planner for a new plan
if the scheduler fails to find a feasible schedule  this is an expensive and unsatisfactory
solution  especially if there is no feedback from the scheduler to help the planner making
a more intelligent choice next time  another solution which appears in the literature is to
use a filter between the planner and scheduler which attempts to modify the plan order to
put the scheduler in a better position  such filters could remove certain over commitments
in the ordering  which will be referred to as deordering the plan  or even change the order
between certain actions  which will be referred to as reordering the plan 
this article is intended to provide a first formal foundation for studying this type of
problems  it defines a number of different optimality criteria for plan order modifications 
both with respect to the degree of over committment in the ordering and with respect to
the parallel execution time  and it also provides computational results for computing such
modifications  the article also analyses some filtering algorithms suggested in the literature
for doing such order modifications 
the remainder of this article is structured as follows  section   introduces the concepts
and computations studied in this article by means of an example  then section   starts the
   brian drabble  personal communication  aug       

   

ficomputational aspects of reordering plans

theoretical content of the article  defining the two planning formalisms used in the following
sections  the problems of making a plan least constrained are studied in section   where
some candidate definitions for this concept are introduced and their computational properties investigated  section   defines the concepts of parallel plans and parallel executions of
plans  this is followed by section   where optimal deorderings and reorderings of parallel
plans are introduced and the complexity of achieving such optimality is analysed  section  
then studies how the complexity of these problems is affected by restricting the language 
this includes the positive result that an algorithm from the literature finds optimal deorderings for a class of plans for most common planning languages  some other filtering
algorithms from the literature as well as some planners incorporating some ordering optimisation are discussed in section    finally  section   discusses some aspects of this article
and some related work  while section    concludes by a brief recapitulation of the results 

   example
in order to illustrate the concepts and operations studied in this article a simple example
of assembling a toy car will be used  the example is a variation of the example used by
backstrom and klein         which is a much simplified version of an existing assembly line
for toy cars used for undergraduate laborations in digital control at linkoping university
 for a description of this assembly line  see eg  klein  jonsson    backstrom             
stromberg         the problem is to assemble a lego  car from pre assembled parts as
shown in figure    there is a chassis  a top and a set of wheels  the two latter to be mounted
onto the chassis 
top

chassis

car

wheels

figure    schematic assembly process for a toy car
the workpiece ow of the factory is shown in figure    there are three storages  one
for each type of preassembled part  two workstations  number   for mounting the top and
number   for mounting the wheels  and there is a car storage for assembled cars  tops can
be moved from the top storage to workstation   and sets of wheels can be moved from the
   lego is a trade mark of the lego company

   

fibackstro m

wheels storage to workstation    chassis can be moved from the chassis storage to either
workstation and also  possibly with other parts mounted  between the two workstations and
from either workstation to the car storage  furthermore  before mounting the wheels on a
chassis  the tyres must be inated  so workstation   incorporates a compressed air container
which must be pressurized before inating the tyres  this is not shown in the figure  

top
storage

workstation  

chassis
storage
wheels
storage

car
storage
workstation  

figure    schematic lay out of the toy car factory
this article is concerned with modifying the order between the actions in a given plan 
and does not consider modifying also the set of actions  hence  the example will assume
that a plan for assembling a toy car is given whether this plan was produced by hand or
by a planning algorithm is not important  it will also be assumed that this assembly plan
contains exactly those actions listed in table    in some order  since most results in this
article are independent of the particular planning language used  no assumptions about
the planning language will be made in this example either  to make things simple  the
obvious common sense constraints on which plans are valid will be used  for instance  a
part must be moved to a workstation before it is mounted there  the wheels must be inated
before being mounted and the air container must be pressurized before inating the tyres 
furthermore  since a chassis can only be at one single place at a time  the top cannot be
mounted in parallel with mounting the wheels  and neither of the mounting operations can
be done in parallel with moving either the chassis or the part to be mounted 
the purpose of modifying the action order in a given plan is usually to optimize the
plan in some aspect  for instance  to make the plan least constrained  consider the totally
ordered plan in figure  a  for producing a chassis with wheels  which is a subplan of the
plan for assembling a car  note that since the plan is totally ordered  all pairs of actions
are ordered  but the implicit transitive arcs are not shown in the figure  this plan is clearly
over constrained  for instance  it is not necessary to move the set of wheels to workstation
  before pressurizing the air container  and removing this ordering constraint results in
the plan in figure  b  note that orderings have only been removed the arc from mvw 
to it existed already in the original plan  but was implicit by transitivity  a plan where
some orderings have been removed will be referred to as a deordering of the original plan 
   

ficomputational aspects of reordering plans

action
mvt 
mvw 
mvc 
mvc 
mvs
mtt
mtw
pac
it

description
move top to workstation  
move wheels to workstation  
move chassis to workstation  
move chassis to workstation  
move chassis to car storage
mount top on chassis
mount wheels on chassis
pressurize air container
inate tyres

duration
 
 
 
 
 
 
 
 
 

table    actions of the assembly plan
this new plan is less constrained than the original plan  since it is now possible to move
the wheels and pressurize the air container in either order or  perhaps  even in parallel 
however  further orderings can be removed  it is not necessary to inate the wheels before
moving the chassis to the workstation  removing also this ordering results in the plan in
figure  c  which is a least constrained deordering of the original plan in the sense that
it is not possible to remove any further ordering constraints and still have a valid plan 
that is  if removing any further ordering constraint  it will be possible to sequence the
actions in such a way that the plan will no longer have its intended result  in addition to
deorderings  one may also consider arbitrary modifications of the ordering relation  that is 
both removing and adding relations  such modifications will be referred to as reorderings 
three differents least constrainment criteria for plans based on deorderings and reorderings
will be studied in section    and the plan in figure  c happens to be optimal according to
all three of these criteria 

mvw    pac

  it

  mvc   mtw

a  a total order plan
mvw pppp
q

  it


pac

  mvc   mtw

b  a less constrained version of a

mvw pppp
q it ppppq

pac
 mtw

mvc 
c  a least constrained
version of a

figure    three plans for mounting the wheels
   

fibackstro m

making a plan least constrained is clearly useful if certain actions can be executed in
parallel  however  even in the case where no parallel execution is possible  it may still be
worth making a plan least constrained  although the partial order of this least constrained
plan must again be strengthened into a total order for execution purposes  this need not be
the same total order as in the original plan  suppose the actions have temporal constaints
like deadlines and earliest release times and that a scheduler will post process the plan to
try finding a feasible schedule  it may then be the case that the original plan has no feasible
schedule  but a less constrained version of it can be sequenced into a feasible schedule  the
idea of a least constrained plan is that the scheduler will have as many alternative execution
sequences as possible to choose from 
the most important reason for modifying the action ordering of a plan  however  is to
execute the plan faster by executing actions in parallel whenever possible  for this purpose
it is better to use the length of the optimal schedule for a plan as a measure  rather than
some measure on the ordering itself  suppose the following car assembly plan is given
hmvw    pac  it  mvc    mtw  mvt    mvc    mtt  mvs i 
if the actions are executed sequentially in the given order  the minimum execution time
is the sum of the durations of the actions  that is    time units  however  just as in the
previous example this plan is over constrained  since several of the actions could be executed
in either order  or in parallel 
it is possible to remove orderings as far as shown in figure  a  but no further  and
still have a valid plan  the implicit transitive orderings are not shown in the figure   this
deordered version of the original assembly plan can be scheduled to execute in    time units
by exploiting parallelism whenever possible  an example of such a schedule is shown in
figure  b  however  no faster execution is possible  since the plan contains a subsequence
of actions which cannot be parallelized and which has a total execution time of    time
units 
it is obvious from the schedule in figure  b that not many actions can be executed in
parallel  and that the gain of deordering the plan is quite small  a much better performance
is possible if arbitrary modifications to the action ordering are allowed  that is  if also
reorderings are considered  for instance  in the assembly plan there is no particular reason
why the wheels should be mounted before the top is mounted  and it will be seen shortly
that much time can be saved by reversing the order of these two operations  a deordering
cannot do this  however  since removing the ordering between the wheel mounting action
 mtw  and the top mounting action  mtt  would make these unordered  this would be
interpreted as if the two actions could be executed in parallel  which is not possible  this
is also the reason why these actions must be ordered in the original plan  however  when
allowing arbitrary modifications  the order between these two actions can be reversed  and
figure  a shows such a reordering of the original plan  this plan can be scheduled to
execute in only    time units  which is a considerable improvement over both the original
plan and the optimal deordered version of it  an example of an optimal schedule is shown
in figure  b  in fact  this plan is an optimal reordering in the sense that no other ordering
of the actions results in a valid plan that can be scheduled to execute faster  the problems
of finding optimal deorderings and reorderings of plan with respect to parallel execution is
the main topic of this article  and are studied in sections   to   
   

ficomputational aspects of reordering plans

pac
mvw 

mvt 

it

mtw

mvc 

mtt

mvc 

mvs

a  a deordering of the assembly plan admitting a shortest
parallel execution time
pac

it

mvw 

mtw

mvc 

mtt

mvs

mvc 
mvt 
 

 

  

  

  

  

b  an optimal schedule for the plan above

figure    an optimal deordering of the assembly plan
it is obvious that reordering is a more powerful operation than deordering  since the
reordered plan in figure  a allows for a shorter schedule than the optimal deordering in
figure  a  on the other hand  if the original plan had been

hmvt    mvc    mtt  mvs  mvw    pac  it  mvc    mtw i 
then deordering would have been sucient for arriving at the optimal plan in figure  a 

   planning formalisms
this section defines actions  plans and related concepts  which basically appear in two
different guises in this article  definitions and tractability results will mostly be cast in a
general  axiomatic framework in order to be as general and independent of formalism as
possible  hardness results  on the other hand  will mostly be cast in a specific formalism 
ground tweak  and often subject to further restrictions  this in order to strengthen the
results  both these formalisms are defined below  in addition to these  a third formalism
will be used  but its definition will be deferred until it is used  in section   
   

fibackstro m

pac

it

mvw 

mvt 

mtt

mvc 

mvc 

mvs

mtw

a  a reordering of the assembly plan admitting a shortest
parallel execution time
pac
mvc 

it

mvw 

mvt  mtt
 

 

mtw

mvs

mvc 
  

  

b  an optimal schedule for the plan above

figure    an optimal reordering of the assembly plan

    the axiomatic planning framework

the axiomatic framework makes only a minimum of assumptions about the underlying formalism  it may be instantiated to any planning formalism that defines some concept of
a planning problem a domain of entities called actions and a validity test  the planning
problem is assumed to consist of planning problem instances  ppis    with no further assumptions about the inner structure of these  the validity test is a truth valued function
taking a ppi and a sequence of actions as arguments  if the validity test is true for a ppi 
and an action sequence ha            an i  then the action sequence ha            an i is said to solve
  while the inner structure of the ppis and the exact definition of the validity test are crucial for any specific planning formalism  many results in this article can be proven without
making any such further assumptions  results on the computational complexity of certain
problems will make an assumption about the complexity of the validity test  though  based
on these concepts  the notion of plans can be defined in the usual way 

definition     a total order plan  t o  plan  is a sequence p   ha            ani of actions 
which can alternatively be denoted by the tuple hfa            an g  i where for    k  l  n 
ak  al iff k   l  given a ppi   p is said to be  valid iff the validity test is true for 

and p  

   this is the complexity theoretic terminology for problems  planning problem instances in the sense of
this article are sometimes referred to as planning problems in the planning literature 

   

ficomputational aspects of reordering plans

a partial order plan  p o  plan  is a tuple p   ha  i where a is a set of actions and
 is a strict   ie  irreexive  partial order on a  the validity test is extended to p o  plans
s t  given a ppi   p is  valid iff ha    i is valid for every topological sorting   of  

the actions of a t o  plan must be executed in the specified order  while unordered
actions in a p o  plan may be executed in either order  that is  a p o  plan can be viewed
as a compact representation for a set of t o  plans  there is no implicit assumption that
unordered actions can be executed in parallel  parallel plans will be defined in section   
p o  plans will be viewed as directed acyclic graphs in figures with the transitive arcs often
tacitly omitted to enhance readability  furthermore  all proofs and algorithms in this article
are based on this definition  ie assuming the order of a plan is transitively closed  while
many practical planners do not bother about transitive closures  this difference does not
affect any of the results presented here 

    the ground tweak formalism

the ground tweak  gt  formalism is the tweak language  chapman        restricted
to ground actions  this formalism is a variation on propositional strips and it is known
to be equivalent under polynomial transformation to most other common variants on propositional strips  backstrom         in brief  an action has a precondition and a postcondition  both being sets of ground literals 
in order to define the gt formalism  the following two definitions are required  given
some set s   the notion seqs  s   denotes the set of all sequences formed by members of s  
allowing repetition of elements and including the empty sequence  the symbol     will be
used to denote the sequence concatenation operator  further  given a set p of propositional
atoms  the set lp of literals over p is defined as lp   p   f p j p   pg  since no other
formulae will be allowed than atoms and negated atoms  a double negation   p will be
treated as identical to the unnegated atom p  finally  given a set of literals l  the negation
neg l  of l is defined as neg l    f p j p   lg fp j  p   lg and l is said to be consistent
iff there is no atom p s t  both p   l and  p   l 

definition     an instance of the gt planning problem is a quadruple    hp   o  i  gi

where

 p is a finite set of atoms 
 o is a finite set of operators of the form hpre  posti where pre  post  lp are consistent
and denote the pre and post condition respectively 

 i  g  lp are consistent and denote the initial and goal state respectively 
for o   hpre  posti  o  we write pre o  and post o  to denote pre and post respectively  a
sequence ho            on i   seqs  o  of operators is called a gt plan  or simply a plan  over  
definition     the ternary relation valid  seqs  o    l   l is defined s t  for arbitrary ho            on i   seqs  o  and s  t  lp   valid ho            on i  s  t   holds iff either
   n     and t  s or
p

   

p

fibackstro m

   n      pre o     s and
valid ho            on i   s   neg post o       post o     t   
a t o  plan ho            on i   seqs  o  solves  iff valid ho            on i  i  g  

an action is a unique instance of an operator  ie a set of actions may contain several
instances of the same operator  and it inherits its pre  and post conditions from the operator
it instantiates  since all problems in this article will consider some fixed set of actions  the
atom and operator sets will frequently be tacitly omitted from the gt ppis  in figures 
gt actions will be shown as boxes  with precondition literals to the left and postcondition
literals to the right 

   least constrained plans

it seems to have been generally assumed in the planning community that there is no difference between t o  plans and p o  plans in the sense that a t o  plan can easily be converted
into a p o  plan and vice versa  however  while a p o  plan can be trivially converted into
a t o  plan in low order polynomial time by topological sorting  it is less obvious that also
the converse holds  at least three algorithms for converting t o  plans into p o  plans have
been presented in the literature  pednault        regnier   fade      a  veloso  perez   
carbonell         all these algorithms will be analyzed later in this article   the claim that
a t o  plan can easily be converted into a p o  plan is vacuously true since any t o  plan is
already a p o  plan  by definition  hence  no computation at all needs to be done  this
is hardly what the algorithms were intended to compute  however  in order to be useful 
such an algorithm must output a p o  plan satisfying some interesting criterion  ideally some
optimality criterion  in fact  two of the algorithms mentioned above are claimed to produce
optimal plans according to certain criteria  for instance  veloso et al         p       claim
their algorithm to produce least constrained plans  they do not define what they mean
by this term  however  and theirs is hardly the only paper in the literature using this term
without further definition 
unfortunately  it is by no means obvious what constitutes an intuitive or good criterion
for when a p o  plan is least constrained and  to some extent  this also depends on the
purpose of achieving least constrainment  the major motivation for producing p o  plans
instead of t o  plans  see for instance tate        is that a p o  plan can be post processed
by a scheduler according to further criteria  such as release times and deadlines or resource
limits  either the actions are ordered into an  ideally  optimal sequence or  given criteria for
parallel execution  into a parallel plan that can be executed faster than if the actions were
executed in sequence  in both cases  the less constrained the original plan is  the greater
is the chance of arriving at an optimal schedule or optimal parallel execution respectively 
both of the algorithms mentioned above are motivated by the goal of exploiting possible
parallelism to decrease execution time 
it is not only interesting to make t o  plans partially ordered  but also to make partially
ordered plans more partially ordered  that is  to generalise the ordering  an algorithm
for this task has been presented in the literature in the context of case based planning
 kambhampati   kedar         since t o  plan are just a special case of p o  plans  this
section will study the general problem of making partially ordered plans less constrained 
   

ficomputational aspects of reordering plans

    least constrainment criteria

there is  naturally  an infinitude of possible definitions of least constrainment  some seem
more reasonable than others  however  three intuitively reasonable candidates are defined
and analyzed below  although other definitions are possible  it is questionable whether
considerably better or more natural definitions  with respect to the purposes mentioned
above  can be defined without using more information than is usually present in a t o  or
p o  plan 

definition     let p   ha  i and q   ha   i be two p o  plans and  a ppi  then 
   q is a reordering of p wrt   iff both p and q are  valid 
   q is a deordering of p wrt   iff q is a reordering of p and   

   q is a proper deordering of p wrt   iff q is a reordering of p and   

definition     given a ppi  and two p o  plans p   ha  i and q   ha   i 
   q is a minimal constrained deordering of p wrt   iff
 a  q is a deordering p wrt   and
 b  there is no proper deordering of q wrt   
   q is a minimum constrained deordering of p wrt   iff
 a  q is a deordering p wrt   and
 b  there is no deordering ha     iof q wrt   s t  j    j   j  j 
   q is a minimum constrained reordering of p wrt   iff
 a  q is a reordering p wrt   and
 b  there is no reordering ha     iof q wrt   s t  j    j   j  j 

note that the previous publication  backstrom        used the terms lc  minimality for
minimal constrained deordering and lc  minimality for minimum constrained reordering 
this change in terminology has been done with the hope that more will be gained in clarity
than is lost by confusion 
it is easy to see that minimum constrainment is a stronger criterion than minimalconstrainment any minimum constrained deordering of a plan p is a minimal constrained
deordering of p   but the opposite is not true  as an example  consider the plan in figure  a 
if removing all ordering constraints from action c  the result is the plan in figure  b  which
is still valid  this plan has an order of size    there is one implicit transitive order  and it
is a minimal constrained deordering since no further deordering can be made  it is not a
minimum constrained deordering  however  since if instead breaking the ordering constraints
between the subsequences ab and cb  the result is the plan in figure  c  which is also valid 
this plan has an ordering of size   and it can easily be seen that it is a minimum constrained
deordering  and that it happens to coincide with the minimum constrained reordering in
this case  this coincidence is not always the case  however  since a reordering is allowed to
   

fibackstro m

do more modifications than a deordering  a minimum deordering can obviously never have
a smaller ordering relation than a minimum reordering  examples of this difference was
shown already in section    where figure  a shows a minimum constrained deordering and
figure  b shows a minimum constrained reordering 
a

 p

p

b

 

q

c

q

 q

d

a  a total order plan
c
a

p

 p

b

q

 q

q

c

d

a

b  a minimal deordering

q

 q

d

p

 p

b

q

b  a minimum deordering

figure    the difference between minimal and minimum constrained deorderings 
other alternative definitions of least constrainment could be  for instance  to maximize
the unorderdness or to minimize the length of the longest chain in the modified plan  however  to find a de  reordering which has as many pairs of unordered actions as possible is the
dual of computing a minimum de  reordering and it is  thus  already covered  minimizing
the length of the longest chain is a condition which may be relevant when actions can be
executed in parallel and the overall execution time is to be minimized  however  since the
number of ordering constraints is quadratic in the length of a chain  because of transitive
arcs   minimizing the size of the relation will often be a reasonable approximation of minimizing the chain length  furthermore  minimizing the longest chain is still a rather weak
condition for this purpose  so it is better to study directly the problem of finding shortest
parallel executions of plans  which will be done later in this article 
another issue is whether to minimize the size of the ordering relation as given  or to
reduce the transitive or reductive closure of it  since plans may have superuous orderings
with no particular purpose  it is reasonable to standardize matters and either add all possible
transitive arcs  getting the transitive closure  or to remove all transitive arcs  getting the
reductive closure  the choice between these two is not important for the results to be
proven  however  minimizing the transitive closure will give a preference to plans with
many unordered short chains of actions over plans with a few long chains  and so seems to
coincide better with the term  least constrained  

    computing least constrained plans
minimal deordering is weaker than the two other least constrainment criteria considered 
but it is the least costly to achieve it is the only one of the three criteria which can be
satisfied by a polynomial time modification to a plan 
   

ficomputational aspects of reordering plans

definition     the search problem

minimal constrained deordering  mlcd  is

defined as follows 
given  a ppi  and a  valid plan p  
output  a minimal constrained deordering of p wrt   

theorem    

mlcd can be solved in polynomial time if validity for p o  plans can be

tested in polynomial time 

proof  consider algorithm mld in figure   and let q   ha    i be the plan output by
the algorithm on input p   ha  i  the plan q is obviously a valid deordering of p wrt 

  it is further obvious from the termination condition in the while loop that there is no
other ordering      s t  ha     i is  valid  it follows that q is a minimal constrained
deordering  since the algorithm obviously runs in polynomial time  the theorem follows 

 

furthermore  if validity testing is expensive  this will be the dominating cost in the mld
algorithm 

corollary     if validity testing for p o  plans can be solved in time o f  n   for some
function f  n   then mlcd can be solved in o maxfn      n  f  n g  time 
  procedure mld
 
input  a valid p o  plan p   ha  i and a ppi 
 
output  a minimal deordering of p
  while there is some e   s t  ha     feg  i is  valid do
 
remove e from 
  return ha    i 

figure    the minimal deordering algorithm mld
in particular  note that plan validation is polynomial for the usual variant of propositional strips without conditional actions  nebel   backstrom        theorem      
more precisely  this proof pertains to the common propositional strips formalism  cps 
and  thus  holds also for the other common variants of propositional strips  like ground
tweak  backstrom         furthermore  note that in practice it may not be necessary
to compute the transitive closure either for the output plan or for validating a plan in the
algorithm 
while minimum de  reordering are stronger criteria than minimal deordering  they are
also more costly to achieve 

definition     the decision problem

minimum constrained deordering  mmcd 

is defined as follows 
given  a ppi   a  valid plan p and an integer k    
question  is there a deordering ha  i of p s t  j  j  k 
   

fibackstro m

definition     the decision problem

minimum constrained reordering  mmcr 

is defined as follows 
given  a ppi   a  valid plan p and an integer k    
question  is there a reordering ha  i of p s t  j  j  k 

theorem    

minimum constrained deordering is np hard 

proof  proof by reduction from minimum cover  garey   johnson        p       
which is np complete  let s   fp            pn g be a set of atoms  c   fc            cm g a set of
subsets of s and k  jc j a positive integer  a cover of size k for s is a subset c    c s t 
jc  j  k and s   t  c t   construct  in polynomial time  the gt ppi    h   frgi and the
 valid t o  plan p   ha            am   as i where pre ai       and post ai     ci for    i  m 
and further pre as     s and post as     frg  obviously  s has a minimum cover of size k
iff there exists some  valid p o  plan q   hfa            am   as g  i s t  j  j  k  since only
 

those actions contributing to the cover need remain ordered wrt  to as

corollary    

 

minimum constrained reordering is np hard 

corollary     

minimum constrained deordering and minimum constrained

reordering both remain np hard even when restricted to gt plans where the actions

have only positive pre  and post conditions 

theorem      if validity for p o  plans is in some complexity class c  then

minimumconstrained deordering and minimum constrained reordering are in np c 

proof  guess a solution  verify that it is a de  reordering and then validate it using an

 

oracle for c 

for most common planning formalisms without conditional actions and context dependent
effects  minimal de  reordering is np complete 

theorem      if validity for p o  plans can be tested in polynomial time  then minimum 

constrained deordering and minimum constrained reordering are np complete 

proof  immediate from theorems     and      and from corollary     

 

it follows immediately that the corresponding search problems  that is  the problems of
generating a minimum constrained de  reordering are also np hard  and even np equivalent
if validity testing is tractable  
furthermore  mmcd and mmcr are not only hard to solve optimally  but even to
approximate  neither of these problems is in the approximation class apx  crescenzi
  panconesi         ie neither problem can be approximated within a constant factor 
 both here and elsewhere in this article the term approximation is used in the constructive
sense  that is the results refer to the existence non existence of algorithms producing an
approximate solution in polynomial time  
   

ficomputational aspects of reordering plans

theorem     

minimum constrained deordering and minimum  constrained
reordering cannot be approximated within a constant unless np   dtime  npoly log n   

proof  suppose there were a polynomial time algorithm a approximating mmcd within
a constant  since the reduction in the proof of theorem     preserves the solutions exactly 
also approximations are preserved  hence  minimum cover could be approximated within
a constant  but this is impossible unless np   dtime  npoly log n    lund   yannakakis 
       which contradicts the assumption  the case for mmcr is a trivial consequence   
if using the number of propositional atoms in the plan as a measure of its size  this
bound can be strengthened to         ln jpj for arbitrary   unless np   dtime  nlog log n  
by substituting such a result for minimum cover  feige        in the proof above 

   parallel plans

in order to study the problem of finding a shortest parallel execution of a plan  the formalisms used so far are not quite sucient  since they lack a capability of modelling when
actions can be executed in parallel or not  it is impossible to say with any reasonable precision how a certain action ordering will affect the parallel execution time  partial order
plans are sometimes referred to as parallel plans in literature  this is misleading  however 
that two actions are left unordered in such a plan means that they can be executed in
either order  without affecting the validity of the plan  but in the general case there is
no guarantee that the plan will remain valid also if the executions of the actions overlap
temporally  in some cases  unorderedness means that parallel or overlapping execution is
allowed  while in other cases it does not mean that  depending on the action modelling and
its underlying domain assumptions  in the first case  the plan must have a stronger ordering
committment  any two actions that must not have overlapping executions must be ordered 
thus making the plan over committed 
in order to distinguish the two cases  a concept of parallel plans will be introduced below 
a parallel plan is a partial order plan with an extra relation  a non concurrency relation 
which tells which actions must not be executed in parallel  in this article two actions are
considered parallel if their executions have any temporal overlap at all  plans where all
unordered actions can be executed in parallel constitute the special case of definite parallel
plans 

definition     a parallel plan is a triple p   ha     i  where ha  i is a p o  plan and
  is an irreexive  symmetric relation on a  a definite parallel p o plan is a parallel plan
p   ha     i s t              
intuitively  a parallel plan is a p o  plan extended with an extra relation     a nonconcurrency relation   expressing which of the actions must not be executed in parallel 
this relation is primarily intended to convey information about actions that are unordered
under the  relation  although it is allowed to relate also such actions  that is  the  
relation is intended to capture information about whether two actions can be executed in
parallel or not  in general  that two actions are ordered in a plan forbids executing them
in parallel in this particular plan  but does not necessarily mean that the actions could not
   

fibackstro m

be executed in parallel under different circumstances  planning algorithms frequently produce overcommitted orderings on plans  and the whole purpose of this article is to study the
problem of optimizing plans by finding and removing such overcommitted orderings  hence 
there are no restrictions in general on the relation   in addition to those in definition     
for instance  a  b does not imply that a b  however  the non concurrency relation will
frequently be constrained to satisfy the post exclusion principle 
definition     a parallel gt plan p   ha     i satisfies the post exclusion principle
iff for all actions a  b   a  a b whenever there is some atom p s t  p   post a  and
 p   post b  
the definition of plan validity is directly inherited from p o  plans 
definition     given a ppi   a parallel plan ha     i is  valid iff the p o  plan ha  i
is  valid 
the non concurrency relation is  thus  not relevant for deciding whether a plan is valid or
not  instead  it is used for constraining how parallel plans may be executed and it is the
core concept behind the definition of parallel executions 
consider  for instance  the gt plan hfa  b  c g  fha  b ig  fhb  c igi which is shown in
figure    arrows denote ordering relations and dashed lines denote nonconcurrency relations   this plan is valid wrt  the ppi    h   fr  sgi  that is the final value of the atom q
does not matter  since b  c holds the actions b and c are constrained not to be executed
in parallel  but may be executed in either order  that is  the plan is not definite  this could
be because the post exclusion principle is employed  or for some other reason  although
a b does not hold the actions a and b clearly cannot be executed in parallel  since a  b
holds  there are four ways to execute this plan  in either of the three sequences a b c 
a c b and c a b  or by executing a and c in parallel  followed by b  unit length is assumed   also note that this plan would no longer be valid if the goal contained either q or
 q  since the final truth value of q depends on the actual execution order  furthermore 
any reordering of the plan would have to keep the ordering constraint a  b to satisfy the
validity criterion  why it is not necessary to have the constraint a b   it would do no harm
here to include this restriction  but in more complex plans it may be an over constrainment 
if there are several producers for the atom p to choose between  for instance  to sum up 
the non concurrency relation should primarily be used to mark which actions must not be
in parallel in addition to those already forbidden to be in parallel because of validity 
this framework for parallel plans admits expressing possible parallelism only  necessary
parallelism is out of the scope of this article and requires a planner having access to and
being able to make use of further additional information  perhaps a temporal algebra 
furthermore  a set of non concurrent actions can easily be expressed by making all actions
in the set pairwise non concurrent  but the formalism is not sucient to say that k of the
actions  but not more  in such a set may be executed in parallel  similarly  it is not possible
to express that an action must executed before or after an interval  or that two sets of
actions must have non overlapping executions 
definition     let p   ha     i be a parallel plan and let the function d   a    n denote
the duration of each action  a parallel execution of p is a function r   a    n   denoting
release times for the actions in a  satisfying that for all a  b   a 
   

ficomputational aspects of reordering plans

a

p

q
r

b
 

c  s q
figure    a parallel plan
   if a  b  then r a    d a   r b  and
   if a b  then either
 a  r a    d a   r b  or
 b  r b    d b   r a  
the length of the parallel execution is defined as maxa a fr a    d a g  ie  the latest finishing time of any action  a minimum parallel execution of plan is a parallel execution with
minimum length among all parallel executions of the plan  the length of a parallel plan p  
denoted length p    is the length of the minimum parallel execution s  for p  

p

obviously  every parallel plan has a parallel execution of length a a d a   which is the
trivial case of sequential execution   furthermore  in certain cases  hardness results will be
strengthened by restricting the duration function 
definition     the special case where d a      for all a   a is referred to as the unit
time assumption 
deciding whether a release time function is a parallel execution is tractable 
theorem     given a parallel plan p   ha     i  a duration function d   a    n and a
release time function r   a    n   it can be decided in polynomial time whether r is a parallel
execution for p and  in the case it is  what the length of this execution is 
proof  trivial 
 
consider the plan in figure   and three release time functions r    r  and r    defined as
follows
r  a      r   b       r   c      
r  a      r   b       r   c      
r  a      r   b       r   c       
both r  and r  are parallel executions of the plan  while r  is not  furthermore  r  is
a minimum parallel execution for the plan  having length    however  computing the
minimum parallel execution of a parallel plan is dicult in the general case 
   

fibackstro m

definition     the decision problem parallel plan length  ppl  is defined as follows 
given  a parallel plan p   ha     i  a duration function d and an integer k 
question  does p have a parallel execution of length k or shorter 

theorem    

parallel plan length is np hard 

proof  hardness is proven by transformation from graph k colourability  garey
  johnson        p        which is np complete  let g   hv  e i be an arbitrary undirected graph  where v   fv            vn g  construct  in polynomial time  a gt ppi as follows  define the ppi    h   fp            pn gi  also define the parallel plan p   ha      i 
where a contains one action ai for each vertex vi   v   s t  pre ai       and post ai    
fpi  qi g   f qj j fvi  vj g   e g  finally  let ai aj iff fvi   vj g   e   which satisfies the post 

exclusion principle  the plan p just constructed is obviously  valid  it is easy to see that
g is k colourable iff p has a parallel execution of length k wrt   since each colour of g
will correspond to a unique release time in the parallel execution of p  
 

corollary    

parallel plan length remains np hard even when restricted to gt ac 

theorem     

parallel plan length is in np 

tions with empty preconditions and under the assumption of unit time and the post exclusion
principle 

proof  guess a parallel execution  then verify it  which can be done in polynomial time
 

according to theorem     

computing a minimum parallel execution of a plan is tractable for the special case of definite
plans  however 

theorem     
parallel plans 

parallel plan length can be solved in polynomial time for definite

proof  use the algorithm dppl  figure     which is a straightforward stratification
 

algorithm for directed dags 

   reordering parallel plans
having defined the concept of parallel plan  it is possible to define concepts similar to
the previous least constrainment criteria which are more appropriate for minimizing the
execution time of parallel plans 

definition     let p   ha     i and q   ha       i be two parallel plans and  a ppi 
then 

   q is a parallel reordering of p wrt   iff both p and q are  valid 
   

ficomputational aspects of reordering plans

 
 
 
 
 
 
 
 
 
  
  
  

procedure dppl

input  a definite parallel plan p   ha     i
output  a minimum parallel execution r for p
construct the directed graph g   ha  i
for all a   a do
r a   
while a      do
select some node a   a without predecessors in a
for all b   a s t  a  b do
r b  max r b   r a    d a  

a

return r

a   fag

figure    algorithm for computing a minimum parallel execution for definite parallel plans 
   q is a parallel deordering of p wrt   iff q is a parallel reordering of p and    
   q is a minimum parallel reordering of p wrt   iff
 a  q is a parallel reordering of p wrt   and
 b  no other parallel reordering of p wrt   is of shorter length than q 
   q is a minimum parallel deordering of p wrt   iff
 a  q is a parallel deordering of p wrt   and
 b  no other parallel deordering of p wrt   is of shorter length than q 

modifying plans to satisfy either of the latter two criteria is dicult in the general case 
however 

definition     the decision problem minimum parallel deordering  mmpd  is defined as follows 
given  a ppi   a parallel plan p   a duration function d and an integer k 
question  does p have a deordering with a parallel execution of length k wrt   

definition     the decision problem minimum parallel reordering  mmpr  is defined as follows 
given  a ppi   a parallel plan p   a duration function d and an integer k 
question  does p have a reordering with a parallel execution of length k wrt   

theorem     minimum parallel deordering is np hard 
proof  similar to the proof of theorem      given a graph g and an integer k  construct
a ppi  and a plan p   ha     i in the same way as in the proof of theorem      but
let  be an arbitrary total order on a  obviously  p is  valid and q   ha      i is a

deordering of p s t  no other deordering of p is shorter than q  hence  q  and thus p   has
a deordering with a parallel execution of length k iff g is k colourable 
 
   

fibackstro m

corollary    
corollary    

minimum parallel reordering is np hard 

minimum parallel deordering and minimum parallel reordering remain np hard even when restricted to totally ordered gt plans and under the as 

sumptions of unit time and simple concurrency 

note that the restriction to definite input plans is covered by this corollary  if output
plans are also required to be definite  then the reordering case remains np hard 

theorem    

minimum parallel reordering remains np hard also when the output

plan is restricted to be definite 

proof  reuse the proof for theorem     as follows  let r be a shortest parallel execution
for the plan q and assume this execution is of length n  construct an order   on a s t 
for all actions a  b   a  a   b iff r a    r b   obviously the plan ha       i is a definite

minimum parallel reordering of p   it follows that p has a definite parallel reordering of
length k iff g is k colourable 
 

it is an open question whether minimum deordering remains np hard when also output
plans must be definite  but an important special case is polynomial  as will be proven in
the next section 

theorem    

minimum parallel deordering and minimum parallel reorder 

ing are in np c if validation of p o  plans is in some complexity class

c 

proof 

given a plan ha     i  a duration function d and a parameter k  guess a
de reordering   and a release time function r  then verify  using an oracle for c   that
ha       i is valid  finally  verify that r is a parallel execution of length  k  which is
polynomial according to theorem     
 

theorem     minimum parallel de  reordering is np complete if p o  plans can be vali 

dated in polynomial time 

proof  immediate from theorems     and     and corollary     

 

the problems mmpd and mmpr are not only hard to solve optimally  but also to
approximate 

theorem     

minimum parallel deordering and minimum parallel reordering cannot be approximated within jaj      for any        unless p np 

proof 
suppose there were a polynomial time algorithm a approximating mmcd within
jaj      for some        then it is immediate from the proof of theorem     that also
graph k colourability could be approximated within jaj        which is impossible
unless p np  bellare  goldreich    sudan        

 

with the same reasoning  this bound can be strengthened to jaj      under the assumption
that co rp  np  feige   kilian        
   

ficomputational aspects of reordering plans

   restricted cases
since the problems of computing minimum de  reorderings are very dicult  and are even
dicult to approximate  an alternative way of tackling them could be to study restricted
cases  one special case already considered is the restriction to definite plans only  while the
problem mmpr is still np complete under this restriction  it is an open question whether
also mmpd is np complete  a positive result can be proven  though  to the effect that
mmpd is polynomial for definite plans for a large class of planning languages  including
most of the commonly used ones  this result will be proven by generalising an algorithm
from the literature for deordering total order plans 
based on the  not necessarily true  argument that it is easier to generate a t o  plan than
a p o  plan when using complex action representations  regnier and fade      a      b 
have presented an algorithm for converting a t o  plan into a p o  plan  the resulting plan
has the property that all its unordered actions can be executed in parallel  that is  the plan
is definite  the authors of the algorithm further claim that the algorithm finds all pairs
of actions that can be executed in parallel and  hence  the plan can be post processed to
find an optimal parallel execution  they do not define what they mean by this criterion 
however 
incidentally  the algorithm proposed by regnier and fade is a special case of an algorithm earlier proposed for the same problem by pednault         who did not make any
claims about optimality  if removing from regnier and fade s algorithm all details relevant
only for their particular implementation and planning language  the two algorithms coincide
and they are thus presented here as one single algorithm  the prf algorithm   figure     
prf is slightly modified from the original algorithms  first  it does not assume that the input plan is totally ordered  since it turns out to be sucient that it is a definite partial order
plan  second  prf returns a parallel plan  rather than a p o  plan a harmless modification since the only additional piece of information is the non concurrency relation  which
is already given as input  either explicitly or implicitly  third  prf returns the transitive
closure of its ordering relation  this is by no means necessary  and is motivated  as usual 
by conforming to the definitions of this article 
  procedure prf 
 
input  a ppi   a  valid definite p o  plan ha  i and a non concurrency
relation  
 
output  a  valid parallel plan
  for all a  b   a s t  a  b do
 
if a b then
 
order a   b 
  return ha        i 

figure     the prf algorithm
obviously  prf computes a deordering of its input  and it is unclear whether it is possible to compute a minimal definite deordering in polynomial time  however  the algorithm
   here and afterwards  the algorithms from the literature will be referred to by acronyms consisting of the
initials of its authors  in this case pednault  regnier and fade 

   

fibackstro m

has been abstracted here to a very general formalism  and an analysis for restricted formalisms reveals more about its performance  the language used by regnier and fade is
unnecessarily restricted so the algorithm will be shown to work for a considerably more
general formalism  based on generalising and abstracting the concepts of producers  consumers and threats used in most common planners and planning languages  eg strips and
tweak  this formalism will be referred to as the producer consumer threat formalism
 pct  
let prod a    denote that a produces the condition   cons a    that a consumes  and
threat a    that a is a threat to   to simplify the definitions  the standard transformation
will be used of simulating the initial and goal states with actions  that is  every pct plan
contains an action ordered before all other actions which consumes nothing and produces
the initial state  similarly  there is an action ordered after all other actions which consumes
the goal state and produces nothing  this means that the ppi is contained within the plan
itself  so all references to ppis can be omitted in the following  validity of plans can then
be defined as follows 

definition     a t o  pct plan ha            an i is valid iff for all i     i  n and all
conditions  s t  cons ai      there is some j      j   i s t  prod aj     and there is no k 
j  k  i s t  threat ak      a p o  pct plan is valid iff all topological sortings of it are

valid 

chapman s modal truth criterion  mtc   chapman        can be abstracted to the
pct formalism and be analogously used for validating p o  plans 

definition     the modal truth criterion  mtc  for a pct plan ha  i is 
 ac   cons ac      
 ap  prod ap       ap  ac  
 at  threat at      
ac  at  
 aw  prod aw       at  aw   aw  ac     
theorem     the mtc holds for a pct plan p iff it is valid 
proof  trivial generalization of the proofs leading to theorem     in nebel and backstrom

 

       

only a minimum of constraints for when two actions may not be executed in parallel
will be required  these constraints are obeyed by most planners in the ai literature 

definition     simple concurrency holds if for all actions a  b s t  a    b  the nonconcurrency relation satisfies the following three conditions
   prod a      cons b      a b
   prod a      threat b      a b
   cons a      threat b      a b
   

ficomputational aspects of reordering plans

note that it is not required that two producers  two consumers or two threats of the same
condition are non concurrent  thus allowing  for instance  plans with multiple producers  eg
nebel and backstrom        fig     and kambhampati         the axioms do not prevent
adding such restrictions  though  furthermore  note that the definition only states a necessary condition for non concurrency it is perfectly legal to add further non concurrency
constraints on the actions in a plan  it may also be worth noting that the mtc requires
producers and threats to be ordered only if there is a correpsonding consumer  while a
definite plan satisfying the simple concurrency criterion always require them to be ordered 
the following observation about prf is immediate from the algorithm and will be used
in the proofs below 

observation     if ha     i is the input to prf and ha       i is the corresponding
output  then it holds that a   b iff a  b and a b 
based on this lemma  it can be proven that prf preserves validity 

lemma     if the plan input to prf is a valid pct plan and   satisfies the simple
concurrency criterion  then the output plan is valid 

proof  let p   ha     i be the input plan and q   ha       i the output plan  since

p is valid  it follows from theorem     that the mtc holds for p   adding the implied
simple concurrency constraints to the mtc yields the following condition 

 ac   cons ac      
 ap  prod ap       ap  ac   ap  ac  
 at  threat at      
 ac  at   ac  at   
 aw  prod aw     at  aw   at  aw  
aw  ac   aw  ac      
by applying observation     this can be simplified to 

 ac   cons ac      
 ap  prod ap       ap   ac  
 at  threat at      
ac   at  
 aw  prod aw       at   aw   aw   ac      
which is the mtc for the plan q  once again using theorem      it follows that q is valid 

 

this allows for proving that prf produces definite minimum deorderings of definite pct
plans under simple concurrency 

theorem     if using the pct formalism and simple concurrency  then prf produces a
minimum deordered definite version of its input 
   

fibackstro m

proof  let p   ha     i be the input plan  which is assumed valid and definite  and
q   ha       i the output plan  it is obvious that    and it follows from lemma     that

q is valid  so q is a deordering of p   it remains to prove that q is a minimum deordering
of p  
suppose that p has a deordering r   ha        i s t  j    j   j   j  then  there must
be some a  b   a s t  a   b  but not a    b  it can be assumed that a   b is not

a transitive arc in     since the transitive closure is anyway computed at the end of the
algorithm  since the order   is produced by prf  it follows from observation     that
a  b and a b  because of the latter constraint  it is necessary that either  a    b or
b    a holds  but only the former is possible since a  b and r is a deordering of p   this
contradicts the assumption  so q must be a minimum deordering of p  
 
since prf is a polynomial algorithm  it follows that definite minimum deorderings of
definite pct plans can be computed in polynomial time under simple concurrency  furthermore  since prf produces definite plans it is possible to actually compute the shortest
parallel execution eciently 

theorem     if the plan input to prf is a valid and definite pct plan satisfying the
simple concurrency criterion  then prf outputs a definite minimum deordering of this plan 

proof  prf runs in polynomial time and obviously produces definite parallel plans 
hence  it follows from theorem      that a minimum parallel execution for the output plan
can be found in polynomial time  which proves the theorem 
 

it seems likely that this is what regnier and fade meant with their optimality claim  although for a special instance of the pct formalism  this result says nothing about the
diculty of finding a minimum reordering of a plan  since prf only considers deorderings 
since minimum deorderings do not approximate minimum reorderings well  it can be suspected that it is more dicult to compute the latter  the following theorem confirms this
suspicion  showing that the latter problem remains np hard under quite severe restrictions 
including the following two 

definition     a gt action a is toggling iff for all literals l   post a   it is also the case
that  l   pre a   a gt action a is unary iff jpost a j     
theorem      minimum parallel reordering remains np hard even when restricted

to total order gt plans with only toggling unary actions and under the assumption of unit
time  simple concurrency and that no actions are redundant 

the proof of this theorem appears in appendix a 
while minimum reorderings are more dicult to compute than minimum deorderings 
they can also produce arbitrarily better results 

theorem     

minimum parallel deordering cannot approximate minimum parallel reordering within jajk for any constant k    

the proof of this theorem appears in appendix a 
   

ficomputational aspects of reordering plans

corollary      minimum parallel deordering cannot approximate minimum parallel reordering within jajk for any constant k    even when the problems are restricted to gt plans with only positive preconditions and under the assumption of simple
concurrency 

it may  thus  appear as though minimum reordering is a preferable  albeit more costly 
operation than minimum deordering  however  if the plan modification is to be followed
by scheduling  it is no longer obvious that a reordering is to prefer  since scheduling may
take further information and constraints into account  eg upper and lower bounds on the
release time and limited resources  a feasible schedule for the original plan may no longer be
a feasible schedule for a reordering of the same plan  that is  some or all feasible solutions
may be lost when reordering a plan  in contrast to this  deordering a plan is harmless
since all previously feasible schedules are preserved in the deordering  of course  the de reordered plan may have new and better schedules than the old plan  which is why the
problems studied in this article are interesting at all  however  while minimum deordering
is a safe and  usually cheap  operation  minimum reordering is neither and must thus be
applied with more care  to find a reordering of a plan with an optimum schedule would
require combining minimum reordering and scheduling into one single computation  but it
is out of the scope of this article to study such combinations  suce it to observe that such
a computation is never cheaper than either of its constituent computations 

   related work
this section analyses and discusses some algorithms suggested in the literature for generalising the ordering of a plan  in addition to the prf algorithm already analysed in the
preceeding section  also some planners that generate plans with some optimality avour
on the ordering are discussed 
some of the algorithms to be analysed use the common trick of simulating the initial
state and the goal of a planning instance by two extra operators  in the following way  let
p   ha  i be a plan and    hi  gi a ppi  both in the gt language  introduce two extra
actions ai   with pre ai       and post ai     i   and ag   with pre ag     g and post ag       
define the plan q   ha   fai   ag g    i where      fai  a  a  ag j a   ag fai  ag g 
that is ai is ordered before all other actions and ag is ordered after all other actions  the
plan q is a representation of both the plan p and the ppi   such a combined representation
will be referred to as a self contained plan  a self contained plan is valid iff it is valid wrt 
to the ppi h    i  it is trivial to convert a plan and a ppi into a corresponding self contained
plan and vice versa  hence  both ways of representing a plan will be used alternately
without further notice 

    the vpc algorithm

veloso et al         have presented an algorithm  here referred to as vpc    for converting
t o  plans into  least constrained  p o  plans  they use the algorithm in the following context 
first a total order planner  nolimit  is used to produce a t o  plan  vpc converts this plan
   in the original publication the algorithm was named build partial order 

   

fibackstro m

  procedure vpc 
 
input  a valid self contained t o  plan ha            an i
where a    ai and an   ag
 
output  a self contained valid p o  plan
  for    i  n do
 
for p   pre ai   do
 
find max k   i s t  p   post ak   
 
if such a k exists then
 
order ak  ai
 
for  p   post ai   do
  
for    k   i s t  p   pre ak   do
  
order ak  ai
  
for each primary effect p   post ai   do
  
for    k  i s t   p   post ak   do
  
order ai  ak
  
for     i   n do
  
order ai  ai and ai  ag
  
return hfa           ang   i 

figure     the vpc algorithm
into a p o  plan which is then post processed to determine which actions can be executed
in parallel  the action language used is a strips style language allowing quantifiers and
context dependent effects  however  the plans produced by the planner  and thus input
to vpc  are ground and without context dependent effects  that is  they are ordinary
propositional strips plans  the vpc algorithm is presented in figure     with a few minor
differences in presentation as compared to its original appearance  first  the algorithm is
presented in the gt formalism  in order to minimize the number of formalisms in this article 
but all preconditions are assumed to be positive  thus coinciding with the original algorithm 
second  while the original algorithm returns the transitive reduction of the computed order
it instead returns the transitive closure here  an unimportant difference in order to coincide
with the definition of plans in this article  furthermore  veloso  has pointed out that the
published version of the vpc algorithm is incorrect and that a corrected version exists 
the version presented in figure    is this corrected version  a proposition is a primary
effect if it appears either in the goal or in the subgoaling chain of a goal proposition 
vpc is a greedy algorithm which constructs an entirely new partial order by analysing
the action conditions  using the original total order only to guide the greedy strategy  the
algorithm is claimed  veloso et al         p       to produce a  least constrained  p o  plan 
although no definition is given of what this means  veloso  has confirmed that the term  least
constrained plan  was used in a  loose sense  and no optimality claim was intended  however 
if this term is not defined  then it is impossible to know what problem the algorithm is
intended to solve or how to judge whether it makes any improvement over using no algorithm
at all  in the absence of such a definition from its authors  the algorithm will be analysed
with respect to the least constrainment criteria defined in section    this is admittedly a
   personal communication  oct       
   veloso  ibid 

   

ficomputational aspects of reordering plans

p
q
 

b r


p 
a 
pq 
ppp
pp
qc s
p 

a pq

q

 p b qr

 q c s

p 

figure     the p o  plans in the failure example for vpc 
somewhat unfair analysis  but it reveals some interesting facts about the algorithm  and
about what problems it does not solve  it is immediate from theorem     and corollary    
that vpc cannot be expected to produce minimum constrained de  reorderings  perhaps
more surprisingly  vpc does not even guarantee that its output is a minimal  constrained
deordering of its input  a problem already proven trivially polynomial  theorem       this
is illustrated by the following example 
suppose a total order planner is given the ppi    h   fr  sgi as input  it may then
return either of the  valid t o  plans ha  b  ci and ha  c  bi  with action conditions as shown
in figure     when used as input to vpc  these two t o  plans will give quite different results the plan ha  c  bi will be converted to the p o  plan p  in figure     while
the plan ha  b  ci will be converted to the p o  plan p  in figure     that is  in the first
case vpc produces a plan which is not only a minimal constrained deordering but even
a minimum constrained deordering  while in the second case it does not even produce a
minimal constrained deordering  
the reason that vpc may fail to produce a minimal constrained deordering is that it
uses a non admissible greedy strategy  whenever it needs to find an operator a achieving
an effect required by the precondition of another operator b  it chooses the last such action
ordered before b in the input t o  plan  however  there may be other actions earlier in the
plan having the same effect and being a better choice 

    the kk algorithm

kambhampati and kedar        have presented an algorithm for generalising the ordering of a p o  plan  using explanation based generalisation  the algorithm is based on first
constructing a validation structure for the plan and then use this as a guide in the generalisation phase  in the original paper  these computations are divided into two separate
algorithms  exp mtc and exp ord gen   but are here compacted into one single algorithm  kk  figure      furthermore  the version presented here is restricted to ground
gt plans  while the original algorithm can also handle partially instantiated plans  this is
no restriction for the results to be shown below 
the first part of the kk algorithm constructs a validation structure v for the plan  that
is  an explanation for each precondition of every action in the plan  the validity criterion
underlying this phase is a simplified version of chapmans modal truth criterion  chapman 
   note that transitive arcs are omitted in the figures  so p  really has an ordering relation of size three 
although this example would not work if plans had been defined in the equally reasonable way that
ordering relations should be intransitive  it is possible to construe similar examples also for this case 

   

fibackstro m

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  

procedure kk

input  a valid self contained p o  plan ha  i
output  a deordering of the input plan
comment build a validation structure v for the plan

v

 

let ha            an i be a topologically sorted version of ha  i
for    i  n do
for p   pre ai   do
find min k   i s t 
   p   post ak   and
   there is no j s t  k   j   i and  p   post aj  
add hak   p  ai i to v
comment construct a generalised ordering   for the plan
for each ha  bi   do
add ha  bi to   if either of the following holds
   a   ai or a   ag
   ha  p  bi   v for some p
   hc  p  ai   v and  p   post b 
   hb  p  ci   v and  p   post a 

return ha   i

figure     the kk algorithm
      without white knights  since the algorithm is simplified to only handle ground plans
here  an explanation is a causal link hap   p  ac i  meaning that the action ap produces the
condition p which is consumed by the action ac   the algorithm constructs exactly one
causal link for each precondition  and it chooses the earliest producer of p preceeding ac
with no intervening action producing  p between this producer and ac   the second phase
of the algorithm builds a generalised ordering   for the plan based on this validation
structure  to put things simply  only those orderings of the original plan are kept which
either correspond to a causal link in the validation structure or that is required to prevent
a threatening action to be unordered wrt  the actions in such a causal link 
it turns out that also the kk algorithm fails in generating plans that are guaranteed to be even minimal constrained deorderings  consider the t o  plan ha  b  c  di
with action conditions as indicated in figure     this t o  plan is valid for the ppi
h   fr  s  t  ugi  since the kk algorithm always chooses the earliest possible producer
of a precondition for the validation structure  it will build the validation structure
fha  p  di  ha  s  ag i  hb  q  di  hb  t  ag i  hc  r  ag i  hd  u  ag ig  hence  the final ordering
produced by kk will be as shown in figure   a  however  this plan is not a minimalconstrained deordering of the original plan  since it can be further deordered as shown in
figure   b and remain valid  in this example  the input plan was totally ordered  in the
case of partially ordered input plans  the behaviour of the algorithm depends on the particular topological order choosen  so the algorithm may or may not find a minimal constrained
deordering  but it is impossible to guarantee that it will succeed for all plans  similarly  the
authors mention that one may consider different ways of constructing the validation struc   

ficomputational aspects of reordering plans

ture  this would clearly also modify the behaviour and it remains an open question whether
it is possible to generate  in polynomial time  a validation structure that guarantees that a
minimal constrained deordering is constructed in the second phase of the algorithm  finding a validation structure that guarantees a minimum constrained deordering is obviously
an np hard problem since the second phase of the algorithm is polynomial 
a ps

a ps

zz

b qt

zz  p
q

p
r

d u

c q

a  plan produced by kk

q

d u

b qt

c pq

r

 p

b  minimal deordered version of a

figure     failure example for the kk algorithm

    planners with optimality guarantees
the planning algorithm graphplan  blum   furst        has a notion of time steps and
tries to pack as many non interacting actions as possible into one single time step  furthermore  graphplan finds the shortest plan  using the number of time steps as the measure 
if assuming unit time and that all actions considered as non interacting by graphplan
can be executed in parallel  then there is no plan having a shorter parallel execution than
the plan produced by graphplan  that is  graphplan produces minimum reordered
parallel plans under these assumptions  the second assumption is no limitation in practice 
since each non concurrency relation can be encoded by introducing a new atom and letting
one of the interacting actions add it while the other one deletes it  the unit time assumption is more serious  however  especially since this assumption is likely not to hold in most
applications  in the car assembly scenario in section    for instance  graphplan would
produce a plan that corresponds to the plan in figure    hence  the plan produced under
the unit time assumption happens to coincide with the optimal plan when taking actual
execution times into account  this is just a fortunate coincidence  however  depending on
the particular durations of actions in this example  suppose instead that the durations of
the actions are slightly different such that pac has duration   and mvt  has duration   
then the plan produced by graphplan  which corresponds to the plan in figure    does
not have a faster schedule than    time units  this is not optimal since the plan in figure  
can be scheduled to execute in    time units for these particular duration times  furthermore  it must be remembered that graphplan is anyway restricted to those cases where
a gt equivalent planning language is sucient  although recent improvements extend it to
   

fibackstro m

somewhat more expressive languages  gazen   knoblock        kohler  nebel  hoffman 
  dimopoulos        
knoblock        has modified the ucpop planner with a resource concept which makes
it avoid unordered interacting actions  this means that the resulting planner produces
definite parallel plans  knoblock further modified the evaluation heuristic of the search to
take parallel execution time into account  it thus seems as if this planner might be able to
produce minimum reordered parallel plans  but the paper does not provide sucient details
to determine whether this is the case  it is also unclear whether the heuristic can handle
actions with different duration times 
yet another example is the polynomial time planner for the sas  iao planning language  jonsson   backstrom        which produces plans which are minimum constrained
reordered  that is  for this restricted formalism it is clearly possible to optimise the ordering
in polynomial time 

   discussion
the previous section listed a few planning algorithms from the literature that produce or
attempt to produce plans which are least constrained or minimum parallel reordered  they
do so only under certain restrictions  though  furthermore  plans are not always generated
 from scratch   but can also be generated by modifying some already existing plan  referred
to as case based planning  or by repairing a plan that has failed during the execution phase 
in such cases  the old plan may contain many ordering relations that will be obsolete in
the modified repaired plan  in fact  the kk algorithm  kambhampati   kedar        is
motivated in the context of case based planning  it is also important to remember that
today  and probably for a long time into the future  very few plans are generated entirely
by computer programs  the vast majority of plans in various applications are designed by
humans  possibly with computer support  already for quite small plans  it is very dicult
for a human to see whether the ordering constraints are optimal or not  so computer support
for such analyses is vital for designing optimal plans  for the same reason  also hierarchicaltask network planners  eg o plan  currie   tate        and sipe  wilkins         produce
plans where reordering actions could lead to better schedules  such a planner often commits
to one of the two possible orderings for a pair of actions based on expert knowledge rules 
however  it is hardly possible for a human expert to design rules that in all situations will
guarantee that the optimal ordering choice is made 
on the coarseness level of complexity analysis it does not matter whether the tasks
of planning  plan optimization and scheduling are integrated or separated since the total
resulting complexity will be the same in both cases the latter two computations are at most
np complete and will  thus  be dominated by the planning  which is pspace complete or
worse  however  for good reasons this has not prevented the research community from
studying planning and scheduling as separate problems  since understanding each problem
in isolation also helps understanding the overall process  for the same reason  it is important
to also study separately the problems discussed and analysed in this article  furthermore 
on a more fine grained  practical level there might be considerable differences in eciency
between integrating the three computations and doing them separately  for instance  even
if all three computations take exponential time  each of the problems considered in isolation
   

ficomputational aspects of reordering plans

may have fewer parameters  in which case it may be much more ecient to solve them in
isolation  on the other hand  solving the whole problem at once may make it easier to
do global optimisation  which is the better will depend both on which methods are used
and on various properties of the actual application  and it seems unlikely that one of the
methods should always be the better 
as has been shown in this article  minimum reordering is a much better optimality
criterion than minimum deordering  if only considering the overall parallel execution time 
however  this is not necessarily true if also considering further metric constraints for subsequent scheduling  deordering a plan can only add to the number of feasible schedules  while
reordering may also remove some or  in the worst case  all feasible schedules  on the other
hand  reordering may also lead to new and better schedules not reachable via deordering 
deordering can thus be viewed as a safe and  sometimes  cheap way to allow for better
schedules  while reordering is an expensive method which has a potential for generating
considerably better plans  but which may also make things worse  if using reordering in
practice in cases where also metric scheduling constraints are involved  it seems necessary
to use feedback from the scheduler to control the reordering process  or to try other reorderings  one could imagine a reordering algorithm which uses either heuristic search or
randomized local search methods a la gsat  selman  levesque    mitchell        to find
reorderings and then use the scheduler as evaluation function for the proposed reorderings 
while the plan modifications studied in this article may add considerably to the optimizations that are possible with traditional scheduling only  there is still a further potential
of optimization left to study modifying not only the action order  but also the set of actions  such modification is already done in plan adaptation  but then only for generating a
new plan from old cases  and optimizations in the sense of this article are not considered 
some preliminary studies of action set modifications appear in the literature  though  fink
and yang        study the problem of removing redundant actions from total order plans 
defining a spectrum of redundancy criteria and analysing the complexity of achieving these 
it is less clear that it is interesting to study action addition  adding actions to a plan could
obviously not improve the execution time of it if it is to be executed sequentially  however 
in the case of parallel execution of plans it has been shown that adding actions to a plan can
sometimes allow for faster execution  backstrom         finally  if allowing both removal
and addition of actions  an even greater potential for optimising plans seems available  but
this problems seems not yet studied in the literature 

    conclusions
this article studies the problem of modifying the action ordering of a plan in order to
optimise the plan according to various criteria  one of these criteria is to make a plan
less constrained and the other is to minimize its parallel execution time  three candidate
definitions are proposed for the first of these criteria  constituting a spectrum of increasing
optimality guarantees  two of these are based on deordering plans  which means that ordering relations may only be removed  not added  while the last one builds on reordering 
where arbitrary modifications to the ordering are allowed  the first of the three candidates 
subset minimal deordering  is tractable to achieve  while the other two  deordering or re   

fibackstro m

ordering a plan to minimize the size of the ordering  are both np hard and even dicult
to approximate 
similarly  optimising the parallel execution time of a plan is studied both for deordering
and reordering of plans  in the general case  both of these computations are np hard and
dicult to approximate  however  based on an algorithm from the literature it is shown
that optimal deorderings can be computed in polynomial time for definite plans for a class
of planning languages based on the notions of producers  consumers and threats  which
includes most of the commonly used planning languages  computing optimal reorderings
can potentially lead to even faster parallel executions  but this problem remains np hard
and dicult to approximate even under quite severe restrictions  furthermore  deordering
a plan is safe with respect to subsequent scheduling  while reordering a plan may remove
feasible schedules  making deordering a good  but often suboptimal  approach in practice 

acknowledgements

tom bylander  thomas drakengren  mark drummond  alexander horz  peter jonsson 
bernhard nebel  erik sandewall  sylvie thibeaux and the anonymous referees provided
helpful comments on this article and previous versions of it  the research was supported
by the swedish research council for engineering sciences  tfr  under grants dnr        
and        

appendix a

theorem      minimum parallel reordering remains np hard even when restricted

to total order gt plans with only toggling unary actions and under the assumption of unit
time  simple concurrency and that no actions are redundant 

proof  proof by reduction from  sat  garey   johnson        p        let p  
fp            png be a set of atoms and c   fc            cm g a set of clauses over p s t  for
   i  m  ci   fli     li     li   g is a set of three literals over p  
first define the set of atoms

q   fpfi   pti   qi j    i  ng   fci j   ri j j    i  n     j   g 
then define a gt ppi    hi  gi with initial and goal states defined as
i   neg q 
g   fpfi   pti    qi j    i  ng   fci j    ri j j    i  n     j   g
also  for each atom pi   p   define four actions according to table   
further  for each clause ci   c   define nine actions according to table   where
  f

l   pk if li j    pk
i j

ptk

if li j   pk  

let a be the set of all  n    m actions thus defined  clearly there is some total order 
s t  the plan p   ha  i is  valid  it is also obvious that none of the actions is redundant 
   

ficomputational aspects of reordering plans

it is a trivial observation that any parallel execution r of any  valid reordering of p
must satisfy that for each i     i  n  either

r afi     r a i     r ati     r a i  
or
and for each i     i  m 

r  c  

i k 

r a i     r ati     r a i     r afi   

     
    
r
 ci k
r ci k   
 
 
 
 
i k      r c       r bi k      r c       r bi k      r ci k    
i k 
i k 

    r b  

 

where k    k    k  is a permutation of the numbers           this is to be interpreted s t  the
  and c   can be released in either order  or simultaneously  and analogously
actions ci k
i k 
 
  and
    
for the actions ci k
ci k
 
 
the remainder of this proof shall show that p can be reordered to have a parallel
execution of length   iff the set c of clauses is satisfiable 
if  suppose c is satisfiable  let i be a truth assignment for the atoms in p that satisfies
c   wlg  assume i  pi     t for all i  further  for each clause cj   let lj be any literal in cj
which is satisfied by i   disregarding the action order for a moment  choose a release time
function r for the actions as follows  for    i  n  let

r a i        r ati        r a i        r afi       
further  for each j      j  m  choose k  s t  lj k    cj is satisfied by i  at least one such
choice must exist by the assumption   let lj k  and lj k  be the remaining two literals in cj  
assign release times s t  for    h    
       h      r  b        h   r  c        h     
r cj k
j kh
j kh
h

now define the partial order   on a s t  for all actions a  b   a  a   b iff r a    r b  
clearly  the plan ha    i is a  valid reordering of p and r is a parallel execution of length
  for ha    i   note that no other choice of i could force a longer execution  while there is
an execution of length   in the case where c is satisfied by setting all atoms false  
operator precond  postcond 

afi
ati
a i
a i

 pfi    qi pfi
 pti   qi pti
 qi
qi
qi
 qi

table    generic actions for each atom pi in the proof of theorem      
   

fibackstro m

operator precond 

bi   
bi   
bi   
ci   
ci   
ci   
ci   
ci   
ci   

li     ri      ri      r       ci  
li      ri    ri      r       ci  
li      ri     ri    r       ci  
 ri  
ri  
 ri  
ri  
 ri  
ri  

postcond 

ci  
ci  
ci  
ri  
 ri  
ri  
 ri  
ri  
 ri  

table    generic atoms for each clause ci in the proof of theorem      
only if  suppose c is not satisfiable  further suppose that q is a minimum reordering
of p and that r is a parallel execution of length   or shorter for q  wlg  assume that every
action is released as early as possible by r  then  according to the observation above it
must hold for each i     i  n  that either
r afi        r a i        r ati        r a i      
or
r a i        r ati        r a i        r afi       
hence  exactly one of the atoms pfi and pti is true at time    let pi denote this atom  since
   
r is of length    it follows from the earlier observation that for all j      j  m  r bj k
for some k     k     hence  lj k   pi for some i  since q is  valid and r is a parallel
execution for q  define an interpretation i s t  for all i     i  n 
 
if pi   pfi
i  pi     f 
t  otherwise  
however  this interpretation is obviously a model for c   which contradicts the assumption 
it follows that r must be of length   or longer 
this concludes the proof and shows that c is satisfiable iff p has a reordering with a
parallel execution of length   or not 
 

theorem     

minimum parallel deordering cannot approximate minimum
parallel reordering within jajk for any constant k    

proof  the proof assumes gt plans and simple concurrency  first  define the generic

actions aki  m   bki and cki  m  according to table     further  define recursively the generic
plans
   
ha
     b 
  c 
             a im      b im   c im    i 
for k    
k
pi  m    ha ki   m    m   p i k    m     mi     cmk  
k
 
 
k
k
   m           aim  m   pim  m   cim  m i  for k     
 i   m  
 i   m  
   

ficomputational aspects of reordering plans

furthermore  for arbitrary k  n     define the ppi kn   hfpk            pkn g  fq k           qnk gi 
now  prove the claim that for arbitrary k  n      the plan p k  n 
   is kn  valid 
p     ni and
   has no deordering of length less than  nk   ki  
   has a reordering of length  k     
proof by induction over k 
base case  k     choose an arbitrary n      the plan p    n  is obviously kn  valid and
has no deordering other than itself  which is of length  n  consider the reordering q    n  of
p    n  with the same actions and with ordering relation  defined s t  for all i     i  n 
a i      b i  c i     and for all i      i  n  a i      b i     this reordering is k  n  valid and
has a parallel execution r    n  of length    defined s t  for all i     i  n  r    n  a i          
r   n  b i       and r    n  c i            this plan is shown in figure      the claim is thus
satisfied for the base case 
induction  suppose the claim is satisfied for all l   k  for some k    and prove that
the claim holds also for l   k  choose an arbitrary n      it follows from the induction
hypothesis that none of the subplans p k    n          pnk    n  can be deordered  so they have
to remain totally ordered  furthermore  for all i     i  n  it is necessary that the action
aki  n  is ordered before the subplan pik   n  and that the action cki  n  is ordered after it 
it is also clear that for no i     i  n can the order cki  n   aki    n  be removed without
making the plan invalid  hence  p k  n  has no other deordering than itself  which is of
length
n
x
i  

     length pik    n     n     length p k    n   

   n   n  nk    

kx
  
i  

 ni      nk  

kx
  
i  

 ni  

which proves the deordering case of the claim 
for the reordering case  define a reordering qk   n  of p k  n  with the same actions and
with ordering relation defined as follows  for each subplan pik    n  of p k  n   reorder its
actions so it has length   k         which is possible according to the induction hypothesis 
further  for each i     i  n  and each j    i     n      j  in order aki  n   akj     n  and
ckj     n   cki  n   or aki    n   akj        and ckj         cki  n  for the case k       hence  each
action pre condition

post condition

aki  m  fpki g
fpk i     m             pkim     q ki     m g
bki
fpki g
fqik g
k   g post ck  m     fqk g 
cki  m  fq ki     m             qim
i
i
table    generic actions for the proof of theorem      
   

fibackstro m

p    n 
a      

a    n 


 
 


  
 
 
p 
    a    
  
 
 
p
 

 
p n  

   
 
   q 

p  

 q  
p  
 q  

 n   

  
r a n   



p n



b  

 

b  

 

b n

   
  

q  

  c     

 

  q  
q      
c      xxxq   
x xxz r c   n 
   
  
 
 
 qn 
 
 
qn      
  cn   





 qn  
  
 



 

 

 
a   n  xxxx  
z
x
  


  
  
   
   
 
 
 q  n    
 
 

x
a n  n  
xxx   x
z

p    n 

pn   n 

x  xxxxz  
    c  n 
   
  

x  xxxxz  
 
   cn n 

figure     the reordering q    n  of the plan p    n  as an example of the induction case in
the proof of theorem       solid arrows denote orderings required by producerconsumer relationships and are labelled with the atom produced consumed 
while dashed arrows denote ordering constraints to avoid threats and are labelled with the possibly conicting atom  
segment of the type aki  n   pik    n   cki  n  is reordered to have length  k      finally  for
each i     i  n  order aki  n   ak i     n  n   or aki  n   ak i     n     for the case k       the
plan qk   n  is k  n  valid since the subplans p k    n           pnk    n  do not have any atoms
in common and  thus  the   relation does not hold between any two actions belonging to
different such subplans  this reordered plan can be executed under the parallel execution
rik  n  defined s t  rik  n  aki  n        rik  n  cki  n      k     and for all i     i  n and
all actions a    qki     n   rik  n  a      rik   n  a         since this is a parallel execution of
length  k     for the reordered plan  the claim holds also for k 
this concludes the induction  so the claim holds for all k      since
p     ni
 nk   ki  
 
k

 k    
  k      k   jaj
for all k      the theorem holds 
 
   

ficomputational aspects of reordering plans

references

backstrom  c          finding least constrained plans and optimal parallel executions is
harder than we thought  in backstrom  c     sandewall  e   eds    current trends in
ai planning  ewsp     nd european workshop on planning  pp        vadstena 
sweden  ios press 
backstrom  c          executing parallel plans faster by adding actions  in cohn 
a  g   ed    proceedings of the   th european conference on artificial intelligence
 ecai      pp          amsterdam  netherlands  wiley 
backstrom  c          expressive equivalence of planning formalisms  artificial intelligence 
                
backstrom  c     klein  i          parallel non binary planning in polynomial time  in
reiter  r     mylopoulos  j   eds    proceedings of the   th international joint conference on artificial intelligence  ijcai      pp          sydney  australia  morgan
kaufmann 
bellare  m   goldreich  o     sudan  m          free bits  pcps and non approximability 
towards tighter results  in proceedings of the   th annual ieee symposium on the
foundations of computer science  focs      pp          milwaukee  wi  usa 
ieee computer society 
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence                    
chapman  d          planning for conjunctive goals  artificial intelligence                  
crescenzi  p     panconesi  a          completeness in approximation classes  information
and computation                  
currie  k     tate  a          o plan  the open planning architecture  artificial intelligence                
feige  u     kilian  j          zero knowledge and the chromatic number  in   th annual
ieee conference on computational compelxity  ccc     philadelphia  pa  usa 
ieee computer society 
feige  u          a threshold of ln n for approximating set cover  preliminary version   in
proceedings of   th annual acm symposium on theory of computing  stoc     
pp          philadelphia  pa  usa  acm 
fink  e     yang  q          formalizing plan justifications  in proceedings of the  th conference of the canadian society for computational studies of intelligence  cscsi     
pp       vancouver  bc  canada 
garey  m     johnson  d          computers and intractability  a guide to the theory of
np completeness  freeman  new york 
   

fibackstro m

gazen  c     knoblock  c          combining the expressivity of ucpop with the eciency
of graphplan  in steel    alami         pp          
ghallab  m     laruelle  h          representation and control in ixtet  a temporal
planner  in hammond         pp        
hammond  k   ed            proceedings of the  nd international conference on artificial
intelligence planning systems  aips      chicago  il  usa  aaai press 
jonsson  p     backstrom  c          state variable planning under structural restrictions 
algorithms and complexity  artificial intelligence                     
kambhampati  s          multi contributor causal structures for planning  a formalization
and evaluation  artificial intelligence                    
kambhampati  s     kedar  s          a unified framework for explanation based generalization of partially ordered and partially instantiated plans  artificial intelligence 
              
klein  i   jonsson  p     backstrom  c          tractable planning for an assembly line 
in ghallab  m     milani  a   eds    new directions in ai planning  ewsp    
 rd european workshop on planning  frontiers in ai and applications  pp         
assisi  italy  ios press 
klein  i   jonsson  p     backstrom  c          ecient planning for a miniature assembly
line  artificial intelligence in engineering                
knoblock  c          generating parallel execution plans with a partial order planner  in
hammond        
kohler  j   nebel  b   hoffman  j     dimopoulos  y          extending planning graphs
to an adl subset  in steel    alami         pp          
lund  c     yannakakis  m          on the hardness of approximating minimization problems  journal of the acm                  
nebel  b     backstrom  c          on the computational complexity of temporal projection  planning and plan validation  artificial intelligence                  
pednault  e  p  d          formulating multiagent  dynamic world problems in the classical
planning framework  in georgeff  m     lansky  a  l   eds    reasoning about actions and plans  proceedings of the      workshop  pp        timberline  or  usa 
morgan kaufmann 
regnier  p     fade  b       a   complete determination of parallel actions and temporal
optimization in linear plans of action  in hertzberg  j   ed    european workshop
on planning  vol      of lecture notes in artificial intelligence  pp          sankt
augustin  germany  springer 
   

ficomputational aspects of reordering plans

regnier  p     fade  b       b   determination du parallelisme maximal et optimisation
temporelle dans les plans d actions lineaires  revue d intelligence artificielle        
      
selman  b   levesque  h     mitchell  d          a new method for solving hard satisfiability problems  in proceedings of the   th  us  national conference on artificial
intelligence  aaai      pp          san jose  ca  usa  american association for
artificial intelligence 
steel  s     alami  r   eds             th european conference on planning  ecp     vol 
     of lecture notes in artificial intelligence  toulouse  france  springer 
stromberg  j  e          styrning av lego bilfabrik  andra omarbetade upplagan  department of electrical engineering  linkoping university 
tate  a          interacting goals and their use  in proceedings of the  th international
joint conference on artificial intelligence  ijcai      pp          tbilisi  ussr 
ijcai  william kaufmann 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning with parallel
resource allocation  in sycara  k  p   ed    workshop on innovative approaches
to planning  scheduling and control  pp          san diego  ca  usa  morgan
kaufmann 
vere  s  a          planning in time  windows and durations for activities and goals  ieee
transactions on pattern analysis and machine intelligence  pami                
wilkins  d  e          practical planning  morgan kaufmann  san mateo  ca 

   

fi