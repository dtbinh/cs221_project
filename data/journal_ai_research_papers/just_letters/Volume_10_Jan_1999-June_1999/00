journal artificial intelligence research               

submitted       published     

order magnitude comparisons distance
ernest davis

davise cs nyu edu

courant institute
new york  ny       usa

abstract
order magnitude reasoning   reasoning rough comparisons sizes quantities   often called  back envelope calculation   implication
calculations quick though approximate  paper exhibits interesting class constraint sets order magnitude reasoning demonstrably fast  specifically 
present polynomial time algorithm solve set constraints form  points
b much closer together points c d   prove algorithm
applied  much closer together  interpreted either referring infinite difference
scale referring finite difference scale  long difference scale greater
number variables constraint set  prove first order theory
constraints decidable 
   introduction
order magnitude reasoning   reasoning rough comparisons sizes quantities  
often called  back envelope calculation   implication calculations
quick though approximate  previous ai work order magnitude reasoning  however 
focussed expressive power inferential structure  computational
leverage  raiman        mavrovouniotis stephanopoulos        davis        weld 
      
paper exhibit interesting case solving set order magnitude
comparisons demonstrably much faster solving analogous set simple order
comparisons  specifically  given set constraints form  points b much
closer together points c d   consistency set determined
low order polynomial time  contrast  easily shown solving set constraints
form  the distance b less equal distance c d 
one dimension np complete  higher dimensions hard solving arbitrary
set algebraic constraints reals 
particular  paper presents following results 
   algorithm  solve constraints s    solves system constraints form  points
b infinitely closer points c d  polynomial time  section    
   improved version algorithm runs time o max n  ff n    ne  s  n
number variables  ff n  inverse ackermann s function  e number
edges mentioned constraint set  size constraint set   section
     
   extended version algorithm allows inclusion non strict constraints
form  points b infinitely apart points c d  
c      ai access foundation morgan kaufmann publishers  rights reserved 

fidavis

running time modified algorithm slower solve constraints 
still polynomial time   section     
   different extension algorithm allows combination order magnitude
constraints distances order comparisons points form  point
precedes point b    section     
   algorithm applied constraints form  the distance
b less   b times distance c d   b given finite value 
long b greater number variables constraint set   section   
   first order theory constraints decidable   section   
preliminary steps  begin small example informal discussion  section
    give formal account order of magnitude spaces  section    present
data structure called cluster tree  expresses order of magnitude distance comparisons  section     conclude paper discussion significance
results  section    

   examples
consider following inferences 

example    wish buy house rent oce space suburb metropolis 
obvious reasons  want house close school  house close
oce  oce close commuter train station  told elmville
train station quite far school  newton close together 
infer able satisfy constraints elmville  may able
newton 
example    empire state building much closer washington monument
versailles  statue liberty much closer empire state building
carnegie hall washington monument 
infer carnegie hall much closer empire state building versailles 
example    carry collection computational tasks covering wide
range diculty  instance
a 
b 
c 
d 
e 
f 

add column     numbers 
sort list        elements 
invert         matrix 
invert           matrix 
given o d e  x   cos et x   x         find x        bit accuracy 
given online collection       photographs gif format  use state ofthe art image recognition software select show man
horseback 

 

fiorder magnitude comparisons distance

g  web search collected     pictures men horseback 
using state of the art image recognition software 
h  using state of the art theorem proving software  find proof medians triangle concurrent 
i  using state of the art theorem proving software  find proof fermat s
little theorem 
plausible suppose that  many cases  say reliably one
task take much longer another  either human judgment using expert
system  instance  task  a  much shorter others  task  b  much
shorter others except  a  possibly  h   task  c  certainly much
shorter  d    f    g    i   however  certain pairs  c   h   c 
 e  would dicult guess whether one much shorter another  whether
comparable diculty 
number independent identical computers  unknown vintage characteristics  schedule tasks kinds  note that  circumstances  way predict absolute time required tasks within
couple orders magnitude  nonetheless  comparative lengths presumably still stand 
given  particular schedule tasks machines  infer relative
order completion times  example  given following schedule
machine m   tasks a b h d 
machine m   tasks c i 
possible predict  a   b  complete  c    c 
complete  d    d  complete  i   possible
predict order  c   h  complete 
three examples  given information form  the distance points
w x much less distance z    examples     
points geometric  example    points start completion times
various tasks  constraints relative lengths put form  the distance
start a  end a  much less distance start c  end c    on 
example    ordering information  start task precedes end 
end  a  equal start  b   on  problem make inferences based
weak kind constraint 
noted examples meant illustrative  rather serious applications  example   extend obvious way class natural 
large problems  example   implausible state knowledge  reasoner
find knowing order of magnitude relations among distances
geometric information  example   contrived  nonetheless  illustrate kinds
situations order of magnitude relations distance arise  express
substantial part knowledge reasoner  inferences based purely
order of magnitude comparisons yield useful conclusions 
methods presented paper involve construing relation  distance much
shorter distance e   distance infinitesimal compared distance
e   shall see  interpretation  systems constraints distances

 

fidavis

solved eciently  logical foundations dealing infinitesimal quantities lie
non standard model real line infinitesimals  developed abraham robinson
         a readable account given keisler         reasoning quantities
infinitely different scale known  order magnitude  reasoning 
reader may ask   since infinitesimals physical reality  value
developing techniques reasoning them   none examples  all 
smaller quantity truly infinitesimal larger one truly infinite  example  
   ratio successive sizes somewhere         example   
    rather large number dicult estimate  one always give
kind upper bound  essentially certain  instance  ratio
times required tasks  a   i  less             use best real valued
estimate instead 
first answer idealization  practically physical reasoning
calculation rest one idealization another  idealization situation calculus
time discrete  idealization solid objects rigid  employed mechanics programs  idealization physical properties density  temperature 
pressure continuous rather local averages atoms  underlies uses
partial differential equations  idealization involved use dirac delta function 
on  idealization short distance infinitesimally smaller
long one simplifies reasoning yields useful results long care taken stay within
appropriate range application 
second answer technique mathematical approximation 
using turn intractable problem tractable one  would analogous
linearizing non linear equation small neighborhood  approximating sum
integral 
circumstances sure approximation gives answer
guaranteed exactly correct  namely actual ratio implicit comparison
 d much smaller e   larger number points involved system
constraints  proven section    broader  less well defined  class
problems approximation  though guaranteed correct  reliable
links reasoning  instance  suppose one consider
instance example   involving couple hundred tasks  apply order of magnitude
reasoning  come answer determined wrong  possible
error would due order of magnitude reasoning  however  seems safe
say that  cases  error likely due mistake estimating
comparative sizes 

   order of magnitude spaces
order of magnitude space  om space  space geometric points  two points
separated distance  two distances e compared relation e 
meaning  distance infinitesimal compared e  or  loosely   distance much
smaller e  
example  let   non standard real line infinitesimals  let  m
corresponding m dimensional space  let point om space point

 

fiorder magnitude comparisons distance

rm   distance two points a  b euclidean distance  non negative
value     relation e holds two distances d  e  d e infinitesimal 
distance operator comparator related number axioms  specified
below  interesting called om triangle inequality  ab bc
much smaller xy  ac much smaller xy  combines ordinary
triangle inequality  the distance ac less equal distance ab plus distance bc 
together rule order of magnitude algebra   if p r q r p q r  
simplify exposition if  rather talking distances  talk
orders magnitude  defined follows  say two distances e
order magnitude neither e e d    condition d e
finite  neither infinitesimal infinite   raiman       uses notation  d co e 
relation   rules order of magnitude calculus  equivalence relation 
hence define order magnitude equivalence class distances
relation  same order magnitude   two points a  b  define function od a  b 
order magnitude distance b  two orders magnitude p  q 
define p q if  representatives   p e   q  e  rules orderof magnitude calculus  holds representatives  holds representatives 
advantage using orders of magnitude function  od   rather distances
distance function  allows us deal logical equality rather
equivalence relation  same order magnitude  
example  non standard real line  let positive infinitesimal value 
values f                         g  order magnitude  o  
values f             e         g different order magnitude o  o   values
f                 g third order magnitude o  o  
definition    order of magnitude space  om space 
consists of 







set points p  
set orders magnitude d 
distinguished value     d 
function  od a  b   mapping two points a  b   p order magnitude 
relation  d e  two orders magnitude d  e  

satisfying following axioms 
a   orders magnitude d  e
e d    e 

  d  exactly one following holds  e 

a   d  e  f   d  e e f f  
 transitivity  together a    means total ordering orders
magnitude  
a     d    
   minimal order magnitude  

 

fidavis

a   points a  b   p   od a  b        b 
 the function od positive definite  
a   points a  b   p   od a  b    od b  a  
 the function od symmetric  
a   points a  b  c   p   order magnitude   d 
od a  b  od b  c  od a  c  d 
 the om triangle inequality  
a   infinitely many different orders magnitude 
a   point a    p order magnitude
a    a        od ai   aj        j  

  d  exists infinite set

example given om space  non standard euclidean space  wild
woolly hard conceptualize  two simpler examples om spaces 
i  let infinitesimal value  define point polynomial integer
coecients             define order of magnitude power  
define n   n  example        define od a  b  smallest power
b  example  od                             
ii  let n infinite value  define point polynomial n integer
coecients  define order magnitude power n   define n p n q
p   q  example  n   n     define od a  b  largest power n b 
example  od     n    n        n      n       n    
shown om space either contains subset isomorphic  i  subset
isomorphic  ii    this special case general rule infinite total
ordering contains either infinite descending chain infinite ascending chain  
use notation  de  abbreviation  d e   e  

   cluster trees
let p finite set points om space  distances different pairs
points p different orders magnitude  om space imposes unique treelike hierarchical structure p   points naturally fall clusters  cluster c
collection points much closer one another point
p outside c   collection clusters p forms strict tree subset
relation  moreover  structure tree comparative sizes different clusters
tree captures order of magnitude relations pair points p  
tree clusters thus powerful data structure reasoning points
om space  is  indeed  central data structure algorithms develop
paper  section  give formal definition cluster trees prove basic
results foundations algorithms 

definition    let p finite set points om space  non empty subset c p
called cluster p every x    c   z   p c   od x  y  od x  z    c cluster 
diameter c   denoted  odiam c     maximum value od x  y  x    c  

 

fiorder magnitude comparisons distance

n 
 
n 

n 

 

 

n 

n 





 

 

 

 

e

g

f

b

c

 

 

 

 

 

figure    cluster tree
note set single element p trivially cluster p   entire set p
likewise cluster p   empty set definition cluster p  

lemma    c clusters p   either c
disjoint 

d  c   c

proof  suppose not  let x   c   d    c d  z   c   since c cluster 
od x  y  od x  z    since cluster  od x  z   od x  y   thus contradiction 

 

virtue lemma    clusters set p form tree  develop representation order magnitude relations p constructing tree whose nodes correspond
clusters p   labelled indication relative size cluster 

definition    cluster tree tree

every leaf distinct symbol 
every internal node least two children 
internal node labelled non negative value  two nodes
may given value   for purposes sections      labels may taken
non negative integers  section    useful allow rational labels  

every leaf tree labelled   
label every internal node tree less label parent 
node n   field  n  symbols  gives set symbols leaves
subtree rooted n   field  n  label  gives integer label node n  

 

fidavis

thus  example  figure    n  label   n  symbols   fa  dg  n  label    
n  symbols   fa  b  c  d  e  f  gg 
shall see  nodes tree represent clusters set points 
labels represent relative sizes diameters clusters 

definition    valuation set symbols function mapping symbol
point om space  cluster tree  valuation valuation  symbols 
n node valuation   write  n   abbreviation
 n  symbols  
define cluster tree expresses order magnitude relations
set points p  
definition    let cluster tree let valuation   let p    t   
set points image   say j t  read satisfies instantiates
  following conditions hold 
i  internal node n    n   cluster p  
ii  cluster c p   node n c    n   
iii  nodes n    label   n  label odiam   m    odiam   n    
iv  label m        odiam m         that is  children assigned
value   
following algorithm generates instantiation
procedure

variable

given cluster tree  

instantiate in   cluster tree 
  om space 
return   array points indexed symbols

g n     array points indexed nodes  

let k number internal nodes  
choose                 k k     different orders magnitude 
   values chosen virtue axiom a     
pick point x  
 
g root      x 
instantiate  t 
          k   g  
return restriction g symbols  
end instantiate 
instantiate  in n   node cluster tree 
  om space          k   orders magnitude 
g   array points indexed nodes  
n leaf
let c        cp children n  
x     g n   
q    n  label 
pick points x        xp
i  j           p     j od xi   xj     q  
   points chosen virtue axiom a     
 

fiorder magnitude comparisons distance



          p
g ci      xi  

instantiate  ci  
          k   g  

endfor
endif end

instantiate  

thus  begin picking orders magnitude corresponding values labels 
pick arbitrary point root tree  recurse nodes
tree  node n   place children points lie separated desired
diameter n   final placement leaves desired instantiation 
lemma    cluster tree
om space  instantiate t 
  returns
instantiation  
proof given appendix 
moreover  clear instantiation generated possible output
instantiate t 
    given instantiation   pick g n   stage
symbol n   
note that  given valuation finite set symbols   exists cluster
tree  symbols   satisfies   essentially unique
isomorphism set labels preserves label   order labels 

   constraints
section  develop first algorithms  algorithm solve constraints tests
collection constraints form  a much closer b c d   consistency  set consistent  algorithm returns cluster tree satisfies
constraints  algorithm builds cluster tree top bottom dealing first
large distances  proceeding smaller smaller distances 
let system constraints form od a  b  od c  d   let cluster
tree  say  s  read  t satisfies    every instantiation satisfies  
section  develop algorithm finding cluster tree satisfies given set
constraints 
algorithm works along following lines  suppose solution satisfying  
let diameter solution  contains constraint od a  b  od c  d  then 
since od c  d  certainly d  follows od a  b  much smaller d 
label ab  short  edge 
two points u v connected path short edges  triangle
inequality edge uv short  i e  much shorter d   thus  compute
connected components h edges labelled short  edges
h likewise labelled short  example  table    edges vz   wx  xy
labelled  short  
hand  shall prove below  edge set h  
reason believe much shorter d  can  fact  safely posit
o m  d  label edges  long  
assume connected component points connected short edges
cluster  child root cluster tree  root cluster tree
given largest label  children given smaller labels   long  edge

 

fidavis

connects symbols two different children root  hence  instantiation tree
make long edge longer short edge 
edges labelled  long    is  h contains complete graph
symbols   inconsistency  edges much shorter longest edge 
instance  table    since vw  wx  xy much smaller zy  follows
triangle inequality vy much smaller zy  since
constraints zy much smaller vz vz much smaller vy 
inconsistency 
algorithm iterates  next smaller scale  since taken care
constraints od a  b  od c  d   cd labelled  long   drop
  let greatest length edges remain   constraint
od a  b  od c  d  new   know od a  b  much shorter d 
label  short   continue above  algorithm halts constraints
satisfied  therefore empty  encounter contradiction 
above 
give formal statement algorithm  algorithm uses undirected
graph variable symbols   given graph g  constraint c
form od a  b  od c  d   refer edge ab  short  c   edge
cd  long  c   shorts system set shorts constraints
longs set longs constraints  edge may
short long appears one side one constraint another
constraint 
procedure

type 

solve constraints in   system constraints form od a  b  od c  d  
return either cluster tree satisfying consistent 
false inconsistent 

node n cluster tree contains
pointers parent children n  
field n label  holding integer label 
field n symbols  holding list symbols leaves n  

variables 

begin

integer 
c constraint  
h  undirected graphs 
n  nodes  

contains constraint form   od a  b  od c  c   return false 

   number variables  
initialize consist single node n  
n  symbols   variables  
repeat

h    connected components shorts  
h contains edges return false  endif 
leaf n
vertices n connected h
n  label    m 
connected component n  symbols h

  



fiorder magnitude comparisons distance

construct node new child n  
 symbols   vertices  

endfor endif endfor

   subset constraints whose long h  
     



empty 

leaf n
n  label      
n  symbols one symbol
create leaf n symbol n  symbols 
label leaf   
endif endfor end solve constraints 

tables     give two examples working procedure solve constraints  table
  shows procedure used establish following constraints
consistent 
empire state building  x  much closer washington monument  w 
notre dame cathedral  v  
bunker hill  y  much closer empire state building eiffel
tower  z   
distance eiffel tower notre dame much less distance
washington monument bunker hill 
table   shows following inference justified 

given  distances statue liberty  v  world trade center
 w   world trade center empire state building  x  
empire state building chrysler building  y  much less
distance chrysler building washington monument  z   
infer  washington monument much nearer chrysler building
statue liberty 
inference carried asserting negation consequent   the washington monument much nearer chrysler building statue liberty  
showing collection constraints inconsistent  note change  much
less   much nearer  example  less   nearer   inference longer
valid 
theorem   states correctness algorithm solve constraints  proof given
appendix 
theorem    algorithm solve constraints s   returns cluster tree satisfying
consistent  returns false inconsistent 
may many cluster trees satisfy given set constraints  among these 
cluster tree returned algorithm solve constraints important property 
fewest possible labels consistent constraints  words  uses
minimum number different orders magnitude solution  therefore  algorithm
used check satisfiability set constraints om space violates

  

fidavis

contains constraints
   od w  x  od x  v  
   od x  y  od y  z   
   od v  z   od w  y  
algorithm proceeds follows 
initialization 
tree initializes single node n  
n  symbols    f v  w  x  y  z g 
first iteration 
shorts f wx  xy  vz g 
computing connected components  h set f wx  xy  wy  vz g 
n  label      
two children n  created 
n   symbols    w  x   
n   symbols    v  z  
xv h   delete constraint     
yz h   delete constraint     
contains constraint    
second iteration 
shorts f vz g 
connected components h fvz g 
n   label      
three children n   created 
n    symbols    w 
n    symbols    x 
n    symbols    z  
wy h   delete constraint     
empty 
cleanup 
n   label      
two children n   created 
n    symbols    v 
n    symbols    z  
 see figure    
table    example computing cluster tree

  

fiorder magnitude comparisons distance

n 
 th iteration
v w x y z

n 

 st iteration

 
v w x y z
n  

n  

w x y

v z

n 
 nd iteration
 
v w x y z
n  
 

n  
w x y
v z

w

x



n 
cleanup
 
v w x y z
n  
 

w

x

n  
w x y

 



v

figure    building cluster tree

  

v z

z

fidavis

contains constraints
od v  w  od z  y  
od w  x  od z  y  
od x  y  od z  y  
od z  y  od v  z   
algorithm proceeds follows 
initialization 
tree initializes single node n  
n  symbols    f v  w  x  y  z g 
first iteration 
shorts f vw  wx  xy  zy  vz g 
h set connected components  complete graph v  w  x  y  z  
algorithm exits returning false
table    example determining inconsistency
axiom a   finitely many different orders magnitude  algorithm returns
different labels number different orders magnitude
space  constraints satisfiable  uses labels space
orders magnitude  constraints unsatisfiable 
proof easier present rewrite algorithm solve constraints following
form  returns number different non zero labels used  actually
construct cluster tree  

num labels s   

function

return
else return

empty

   
     num labels reduce constraints s    
function reduce constraints s  
h    connected components shorts  
h contains edges return false  top level
else return the set constraints whose long h  

easily verified sequence values successive recursive calls
num labels sequence values main loop solve constraints 
therefore num labels returns number different non zero labels tree constructed
solve constraints 
   reader may wonder simpler algorithm presented complicated
algorithm solve constraints  reason proof found system constraints consistent num labels return
constructive solve constraints 

  

false

relies relation num labels

fiorder magnitude comparisons distance

theorem    solutions set constraints   instantiations
solve constraints s   fewest number different values od a  b   a  b range
symbols   number given num labels s   
proof given appendix 

   extensions consequences
next present number modifications algorithm solve constraints  first
ecient implementation  second extends algorithm handle non strict
comparisons  third extend algorithm handle combination order of magnitude
comparisons distance order comparisons  one dimensional space 

    ecient implementation solve constraints
possible implement algorithm solve constraints somewhat eciently
naive encoding description  key observe graph h connected
components computed explicitly  suces compute implicitly using
merge find sets  union find sets   combining suitable back pointers edges
constraints  formulate ecient version algorithm 
use following data structures subroutines 

node n cluster tree contains pointers parents children  field

n  label  holding integer label  field n  symbols  holding list symbols
leaves n   field n  mfsets  holding list connected components
symbols n   described below  connected component implemented
merge find set  mfset  

edge e graph symbols contains two endpoints 

symbol  field e  shorts  list constraints e appears short 
field e  longs  list constraints e appears long 

constraint c two fields  c  short c  long  edges 

pointers lists c  short shorts c  long longs  enabling c removed
constant time constraint lists associated individual edges 

use disjoint set forest implementation mfsets  cormen  leiserson 

rivest        p       merging smaller sets larger path compression 
thus  mfset upward pointing tree symbols  node tree
symbol  tree whole represented symbol root  symbol
following fields 

 
 
 
 

a parent pointer parent mfset tree 
a cluster leaf pointer leaf cluster tree containing a 
root mfset a size holds size mfset 
root mfset  a symbols holds elements
mfset 

  

fidavis

  root mfset a leaf ptr holds pointer pointer
n  mfsets n   a cluster leaf 
describe algorithm 
procedure

variables 

  
  
  
  
  
  
  
  

begin

  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

solve constraints  in   system constraints form od a  b  od c  d   
return either cluster tree satisfying consistent 
false inconsistent 
integer 
a  b symbols 
c constraint  
h undirected graph 
e  f edges 
p mfset 
n  nodes  

contains constraint form   od a  b  od c  c   return false 

h      

constraint c short e long f
add e f h  
add c e  shorts f  longs endfor 
   number variables  
initialize contain root n  
n  symbols    variables  




leaf n   initialize mfsets n   
edge e   ab h
e  shorts non empty find a     find b 
merge find a   find b   endif endfor
every edge e   ab h satisfies find a    find b 

repeat


return false  endif



current leaf n
n  mfsets one element
mfset p n  mfsets
construct node new child n  
 symbols   p  symbols 
endfor endif endfor

edge e   ab h
find a     find b 
constraint c e  longs
delete c  
delete c e  longs 
delete c c  short shorts endfor
delete e h endif endfor
     
empty 




leaf n
n  label      
n  symbols one symbol
  

fiorder magnitude comparisons distance

   
   

create leaf n label   symbol n  symbols 
solve constraints  


endif endfor end

initialize mfsets n   node 
  symbol 
n  mfsets      
n  symbols
a parent    null 
a cluster leaf    n  
a symbols    fag 
a size      
n  mfsets    cons a n  mfsets  
a leaf ptr    n  mfsets 
endfor end initialize mfsets 
procedure
var

merge in a  b   symbol 
 size
 size swap a  b   
a parent    b  
b  size    b  size   a size 
b  symbols    b  symbols   a symbols 
using a leaf ptr  delete a cluster leaf mfsets 
end merge 
procedure

 b

find in   symbol  return symbol 
  symbol 
 parent   null return
   find a parent  
a parent    r     path compression   
return r 
end find 
procedure
var r

else r

let n number symbols   let e number edges  let
number constraints  note n   e n n      e   e e      
running time solve constraints  computed follows  iteration
main loop      splits least one connected components h  
n   iterations  merge find operations loop      take together time
o max nff n   e   ff n  inverse ackermann s function  iteration
inner loop lines       creates one node tree  therefore 
o n  iterations loop entire algorithm  lines        outer
loop require n iterations iteration main loop  loop      
executed exactly course entire execution algorithm
constraint c   hence takes time o s  entire algorithm  steps      
require time o e  iteration main loop  easily verified remaining
operations algorithm take time these  hence overall running time
o max n  ff n   ne  s   

  

fidavis

    adding non strict comparisons
algorithm solve constraints modified deal non strict comparisons
form od a  b  od c  d  by  intuitively  marking edge ab  short  iteration
edge cd found short 
specifically  algorithm solve constraints  make following two changes  first 
revised algorithm takes two parameters    set strict constraints  w   set
non strict constraints  second  replace line
h    connected components shorts

following code 

  
  
  
  
  

h    shorts  
repeat h    connected components h  
weak constraint od a  b  od c  d 
cd h add ab h endif endfor
change made h last iteration 

proof revised algorithm correct slight extension proof
theorem   given appendix 
optimizing algorithm eciency little involved  new
operations must included  four parameters   n 
number symbols  e  number edges mentioned  s  number strict comparison 
w  number non strict comparisons   optimal implementation varies
depending relative sizes  particular  either w  though both  may
much smaller n  cases requires special treatment optimal eciency 
best implementation found case w
 n 
running time o max n    nw  s    details implementation straightforward
sucient interest worth elaborating here 
immediate consequence result couple problems inference
easily computed 

determine whether constraint c consequence set constraints  
form set    c check consistency     c inconsistent sj c  
note negation constraint od a  b  od c  d  constraint
od c  d  od a  b  
determine whether two sets constraints logically equivalent  check
constraint first consequence second  vice versa 

    adding order constraints
example   section   involves combination order of magnitude constraints distances together simple ordering points  points lie one dimensional
line  next show extend algorithm solve constraints deal complex situation 

  

fiorder magnitude comparisons distance

terms axiomatics  adding ordering points involves positing
relation p   q total ordering ordering points related order
magnitude comparisons distances following axiom 
a   points a  b  c   p     b   c od a  b  od a  c  
following rule easily deduced  c disjoint clusters  either every
point c less points d  vice versa 
extending algorithm  begin defining ordered cluster tree cluster
tree where  every internal node n   partial order children n  
b children n ordered b   instantiation tree 
every leaf must precede every leaf b   procedure instantiate  modified
deal ordered cluster trees follows 

instantiate  in n   node cluster tree 
  om space          k   orders magnitude 
g   array points indexed nodes  
n leaf
let c        cp children n topologically sorted order 
x     g n   
q    n  label 
pick points x        xp increasing order
i  j           p     j od xi   xj     q  
   points chosen virtue axiom a     
          p
g ci      xi  
instantiate  ci  
          k   g 
endfor
endif end

instantiate  

algorithm solve constraints modified follows 
procedure

fnewg

variables 

begin

solve constraints  in   system constraints form od a  b  od c  d   
  system constraints form   b 
return either ordered cluster tree satisfying
consistent 
false inconsistent 
integer 
c constraint  
h  undirected graphs 
m  n  p nodes  
a  b  c  symbols 

contains constraint form   od a  b  od c  c  

return false

 

fnewg internally inconsistent  contains cycle  return false 
   number variables  
initialize consist single node n  
n  symbols   variables  
repeat

h    connected component shorts  

  

fidavis

fnewg

h    incorporate order h  o  
h contains edges


return false

leaf n
vertices n connected h
n  label    m 
connected component n  symbols h
construct node new child n  
 symbols   vertices  
endfor endif

fnewg
fnewg
fnewg
fnewg
fnewg



constraint   b  
 symbols b p  symbols
p different children n
add ordering arc p  
endif endfor

endfor

   subset constraints whose long h  
     



empty 

leaf n
n  label      
n  symbols one symbol
create leaf n symbol n  symbols 
label leaf   
endif endfor

end

solve constraints  

fnewg

function

incorporate order in h   undirected graph 
  system constraints form   b 
return undirected graph 

variables 

g   directed graph 
a  b   vertices h  
a  b   connected components h  
v  a    array vertices g indexed connected components h  
  subset vertices g 

connected component h create vertex v  a  g 
constraint   b  
let b connected components h containing b respectively 
   b add arc g v  a  v  b   endif endfor 
strongly connected component g
pair distinct vertices v  a   v  b    
  b   b add edge ab h endfor endfor




endfor

  

fiorder magnitude comparisons distance

end

incorporate order 

function incorporate order serves following purpose  suppose
midst main loop solve constraints   partially constructed cluster tree 
currently working finding sub clusters node n   original
form solve constraints  find connected components shorts order ofmagnitude constraints  let c        cq   know diameter ci
much smaller diameter n   now  suppose  example 
constraints a    a    b    b    c    c    a    c    c    b    c    c    a    b    c   
follows axiom a   c    c    c  must merged single cluster 
whose diameter less diameter n   procedure incorporate order finds
loops constructing graph g whose vertices connected components h
whose arcs ordering relations computing strongly connected
components g   recall two vertices u  v directed graph strongly
connected component cycle u v u   merges together
connected components h lie single strongly connected component g 
proof correctness algorithm solve constraints  analogous structure proof theorem    given appendix 
implementing manner section      algorithm made run
time o max n  ff n   ne  no  s    number constraints o 

   finite order magnitude comparison
section  demonstrated algorithm solve constraints applied systems
constraints form  dist a  b    dist c  d    b   finite b ordinary euclidean
space long number symbols constraint network smaller b  
could sure immediately result must apply finite b  
fundamental property non standard real line sentence first order
theory reals holds infinite values holds suciently large finite
value  sentence holds infinite value holds arbitrarily large
finite values  hence  since answer given algorithm solve constraints works
set constraints constraint  od a  b  od c  d   interpreted  od a  b 
  od c  d  b infinite b    answer must valid suciently large finite b  
interesting find simple characterization b terms   namely 
b larger number symbols  
begin modifying form constraints  interpretation cluster
tree  first  avoid confusion  use four place predicate  much closer a  b  c  d  
rather form  od a  b  od c  d   going give interpretation
 od  function  fix finite value b      interpret  much closer a  b  c  d  
mean  dist a  b    dist c  d    b   
next redefine means valuation instantiate cluster tree 

definition    let cluster tree let valuation symbols   say
 t following holds  symbols a  b  c    let least common
ancestor a  b let n least common ancestor c  d   label   n  label
much closer a  b  c  d  

  

fidavis

procedure  instantiate   generates instantiation cluster tree  modified
follows 
procedure

instantiate in   cluster tree 
  euclidean space  b   real  
return   array points indexed symbols  

let n number nodes  
        n   bn 
choose             n   i    ff 
pick point x  
 
g t      x 
instantiate  t 
          n   g  
return restriction g symbols  
end instantiate 
instantiate  in n   node cluster tree 
  euclidean space 
        n   orders magnitude 
g   array points indexed nodes  
n leaf
let c        cp children n  
x     g n   
q    n  label 
pick points x        xp
i  j           p     j q dist xi   xj     nq
   possible since p n    
          p
g ci      xi  
instantiate  ci  
          n   g 
endfor
endif end

instantiate  

analogue lemma   holds revised algorithm 
lemma     cluster tree instantiation euclidean space  m dimensionality m 
state theorem    asserts correctness algorithm  solve constraints 
new setting 

theorem    let set constraints n variables form  dist a  b   
dist c  d    b    b   n  algorithm solve constraints s   returns cluster tree
satisfying consistent euclidean space  returns false inconsistent 
proofs lemma    theorem   given appendix 
examination proof lemma    shows result depend
relation n b   therefore  solve constraints s   returns tree  
consistent satisfies regardless relation n b   however 
possible consistent solve constraints s   return false n b  
hand  one see proof theorem    particularly lemma     b   n
solve constraints s   returns false inconsistent metric space  however 
metric spaces  m cluster tree returned solve constraints
may instantiation 

  

fiorder magnitude comparisons distance

   first order theory
final result asserts om space rich enough full first order language
order of magnitude distance comparisons decidable  specifically  collection
orders magnitude dense unbounded above  decision algorithm
first order sentences formula   od w  x   od y  z    runs time o  n  n    s 
n number variables sentence length sentence 
basic reason following  observed corollary    cluster
tree determines truth value constraints form  od a  b  od c  d  
a  b  c  symbols tree  is  two instantiations two omspaces agree constraint  require om spaces dense
unbounded  much stronger statement holds  two instantiations
om spaces agree first order formula free symbols relation
 od w  x   od y  z     hence  suces check truth sentence possible
cluster trees variables sentence  since finitely many cluster
trees fixed set variables  taking account relative order labels
numeric values   decidable procedure 
let l first order language equality constant function symbols 
single predicate symbol  much closer a  b  c  d    easily shown l
expressive language function symbol  od  relation symbol  

definition    om space
orders magnitude
following axiom 

dense satisfies

a   orders magnitude     d  exists order magnitude  
       

unbounded satisfies following 
a    every order magnitude   exists        
collection orders magnitude hyperreal
line 
p
satisfied  axiom  a             choose           geometric mean 
          choose          axiom  a     choose        
      

definition    let cluster tree  let l       l    l        lk distinct labels
ascending order  extending label either  a  li i   b  lk      note
lk label root    c   li     li       k 
note k distinct non zero labels   k     different extending
labels  

definition    let cluster tree  let x symbol   cluster tree
 
extends x   formed applying one following operations  a
single application single operation  
   null tree   tree containing single node x 

  

fidavis

   consists single node symbol y  make new node   make x
children   set label either     
   internal node n  including root   make x child n  
   let symbol   let n father  n  label       create new node
extending label  label   n  label  make child n  
make x children  
   let c internal node root  let n father  create
new node extending label c  label    label   n  label 
make child n make x c children  
   let r root   create new node  label   r label      make
r x children   thus root new tree    
 see figure    
note tree n symbols n   internal nodes

n   ways carry step   
n possible ways choose symbol step     n  
label each 

n   different choices c step     n   choices
label each 

one way carry step   
hence  less  n  different extensions x   this almost certainly
overestimate least factor    final algorithm entirely impractical
worthwhile precise  

definition     let cluster tree  let formula l open variables
  satisfies every instantiation satisfies  
theorem    let cluster tree  let open formula l  whose free variables
symbols   let
om space dense unbounded above  algorithm
decide t    returns true satisfies false otherwise 

decide t   cluster tree    formula  return boolean
convert equivalent form logical symbols
   not      and      exists      equals  variable names 
non logical symbol predicate  much closer  
function

case

form x     return  distance x  y         
form  much closer w  x  y  z     return distance w  x      distance y  z     
form     return not decide t    
form     return decide t    decide t    
form  x ff 

  

fiorder magnitude comparisons distance

p

p

p

 

 

 
w

q

q

 

w

q

w

x

 

 

u

u

v

u

v

v

x

operation   

operation   
original

n   p

n   q

p
 
w

q
 

p

p

 

 
w

q
 

operation   

operation   
y v

y u



q

           

 
u

v




     

     

u

u

v

x

w

operation   

x

y w


p

 

 
x


w

p
 

   
operation   
x

w

q
 

c q  n p

q
 
u

u

v

v

v
operation   
r p

figure    extensions cluster tree

  

x

fidavis

extension

  decide t   ff    true


t  x
return true
else return false endif endcase

end

 

decide

distance x    symbol    cluster tree  return
n    common ancestor x  
return n  label 
function

end

integer

distance

proof theorem   given appendix 
running time  remarked above  tree size k  k 
extensions considered  total number cluster trees considered therefore
bounded nk    k     n  n      easily verified logical operators
quantifiers add factor length sentence  hence running
time bounded o  n  n    s  
key lemma  interest itself  states following 
lemma     let cluster tree  let open formula l  whose free variables
symbols   let
om space dense unbounded above  one
instantiation
satisfies every instantiation
satisfies  
is  either true instantiations none  proof given
appendix 
observed conditions
lemma    necessary 
statement false otherwise  example  let
om space described
example i  section    polynomials infinitesimal  
unbounded
above  maximum order of magnitude o     let starting tree figure
   upper left corner   let formula   x od v  w   od w  x     free v w  
valuation fu     v      w    g satisfies   whereas valuation
fu       v        w   g satisfies  

   conclusions
applications specific algorithms undoubtedly limited  aware
practical problems solving systems order of magnitude relations distances
central problem  however  potential applications order of magnitude reasoning
generally widespread  ordinary commonsense reasoning involves distances spanning ratio       fraction inch thousands miles  durations
spanning ratio        fraction second human lifetime  scientific
reasoning spans much greater ranges  explaining dynamics star combines reasoning
nuclear reactions reasoning star whole  differ ratio
       techniques needed compute quantities vastly differing
sizes quite different techniques needed compute quantities similar
sizes  paper small step development analysis computational
techniques 
results significant encouragement give hope
order of magnitude reasoning specifically  qualitative reasoning generally  may lead

  

fiorder magnitude comparisons distance

useful quick reasoning strategies broader range problems  often found
ai moving greater lesser precision mode inference type
knowledge lead quick dirty heuristic techniques  rather slow
dirty techniques  nonmonotonic reasoning notorious example this 
arises well many types automated reasoning  including qualitative spatial
physical reasoning  algorithms developed paper welcome exception
rule  currently studying algorithmic techniques order of magnitude
problems  optimistic finding similar favorable results 

acknowledgements
research supported nsf grant  iri          thanks ji ae shin 
andrew gelsey  reviewers helpful comments 

appendix a  proofs
appendix  give proofs various results asserted body paper 

proof lemma  
lemma    cluster tree
om space  instantiate t 
  returns
instantiation  
proof  let        node n   i n  label  define  n       proof
proceeds following steps 
i  nodes  n   descendant n od g m    g n     n   
proof  child n   immediate construction x        xp
instantiate   else  let n   n    n        nq   path n
  definition cluster tree  follows ni  label   n  label     
therefore  ni    n    thus od g m    g n     by o m  triangle inequality 
maxi     q    od g ni      g ni     maxi     q     ni     since ni   child
ni    n   
ii  let n node   let c  c  two distinct children n   let m 
m  descendants c  c  respectively  od g m     g m        n   
proof  construction x        xp instantiate  n    od g c     g c        n   
part  i    od g m     g c      c     n   likewise od g m     g c    
 n    hence  axiom a    od g m     g m        n   
iii  let b two leaves   let n least common ancestor
b  od g a   g b      n    proof  immediate  ii  
iv  node n   odiam   n       n    proof   iii   two leaves descending
different children n distance order  n    two leaves n
distance order greater  n   

  

fidavis

v  node n    n   cluster  t    proof  let b leaves n  
let c leaf n   let common ancestor b
let j common ancestor c  either n descendant n
j proper ancestor n   therefore part  i    i    j     iii  
od   a    b      i    j     od   a    c   
vi  internal nodes n   label   n  label odiam   m    odiam   n    
proof  immediate  iv  construction  
vii  c cluster  t   node n c    n    proof  let
set symbols corresponding c let n least common ancestor
  let b two symbols different subtrees n  
 iii   od g a   g b      n    let x symbol n  symbols   iii 
od g a   g x    n    hence g x    c  

 
proof theorem  
prove correctness algorithm solve constraints  assume throughout
two variables long constraint distinct 
lemma    let cluster tree let instantiation   let b
symbols   let n least common ancestor b   od   a    b    
odiam   n    
proof  since  a   b  elements  n    follows definition odiam
od   a    b   odiam   n     suppose inequality strict  is  od   a    b  
odiam   n     let c set symbols c od   a    c  
od   a    b    odiam   c      od   a    b   odiam   n     easily shown
 c   cluster  t    therefore  property  ii  definition    must
node  symbols   c   now  certainly ancestor n   since
odiam   m    odiam   n     symbols contains b  contradicts
assumption n least common ancestor b   
corollary    let cluster tree let instantiation   let a  b  c 
symbols   let n least common ancestor c   let
least common ancestor b   od   a    b   od   c    d  
 label   n  label 
proof  immediate lemma   property  iii  definition   instantiation   

lemma    let set constraints form od a  b  od c  d   let h
connected components shorts   consistent  every edge
h 
proof  let valuation satisfying   find edge pq od   p    q  
maximal  now  ab short   is  constraint od a  b  od c  d 
  od   a    b   od   c    d   od   p    q   

  

fiorder magnitude comparisons distance

now  let ab edge h   connected components shorts  
path a    a  a        ak   b edge ai ai   short           k   
thus  om triangle inequality  od   a    b   maxi    k   od   ai     ai      
od   p    q    hence pq    ab  pq h    

lemma    values h iteration supersets values later
iteration 

proof  reset subset end iteration  h defined terms
monotonic manner   

cannot two successive iterations main loop 
proof  contradiction  suppose two successive iterations  h
same  since defined terms   h constructed contain shorts
  since resetting end first iteration change   h must
contain longs well  thus  h contains edges   case 
algorithm terminated failure beginning first iteration   
lemma   

lemma    algorithm solve constraints always terminates 
proof  lemma    algorithm exit failure  iteration
constraints removed   hence  number iterations main loop
original size   everything else algorithm clearly bounded   note
bound number iterations improved section     n    n
number symbols    

lemma    algorithm solve constraints returns false  inconsistent 

proof  algorithm returns false  transitive closure shorts contains
edges   lemma    inconsistent 

lemma     constraint c form od a  b  od c  d  initial value  
edge cd h particular iteration  constraint c start
iteration 
proof  suppose c deleted particular iteration  edge cd 
long c   cannot h iteration  is  possible edge cd persist
h iteration c deleted   note that  lemma    cd
eliminated h   remains h    
lemma     following loop invariant holds  end loop iteration 
values l symbols  l leaf current state tree  exactly
connected components h  

proof  first iteration  initially root r  containing symbols 
child r created connected component h  
let ti hi values h end ith iteration  suppose
invariant holds end kth iteration  lemma    hk   subset hk  
hence  connected component hk   subset connected component hk  

  

fidavis

moreover  connected component j hk either connected component hk  
partitioned several connected components hk     former case  leaf
tk corresponding j unchanged remains leaf tk     latter case  leaf
corresponding j gets assigned one child connected component hk  
subset j   thus  connected components hk   correspond leaves tk      

lemma     procedure solve constraints return false  returns wellformed cluster tree  
proof  using lemma     cleanup section solve constraints creates final
leaves symbols  follows every symbol ends single leaf  
decremented iteration  iteration adds new node children
node  follows label internal node less label father 
hence constraints cluster trees  definition    satisfied   
lemma     let a  b two distinct symbols let cluster tree returned
solve constraints   let n least common ancestor a  b   either n
assigned label first iteration edge ab h   edge ab
final value h loop exited n assigned label final cleanup
section 
proof  above  let hi value h ith iteration 
n root  assigned label first iteration  clearly  b 
different subtrees n   must different connected components h   
suppose n assigned label kth iteration loop k      lemma    
end previous iteration  n  symbols connected component hk    
therefore contained edge ab  since n least common ancestor a  b  follows
b placed two different children n   hence  two different connected
components hk   thus edge ab cannot hk  
suppose n assigned label cleanup section algorithm  lemma
    n  symbols connected component final value h   hence edge ab
final value h    
lemma     let initially contain constraint c form od a  b  od c  d   suppose
solve constraints s   returns cluster tree   let least common ancestor a  b
let n least common ancestor c  d   label   n  label 
proof  suppose n given label given iteration  lemma     cd eliminated
h iteration  lemma     constraint c must start
iteration  hence ab short iteration  therefore h   hence
given label later iteration  therefore given lower label 
easily seen cd cannot h final iteration loop  hence n
assigned label cleanup section   
lemma     suppose solve constraints s   returns cluster tree   instantiation satisfies constraints  
proof  immediate lemma    corollary   

  

fiorder magnitude comparisons distance

theorem    algorithm solve constraints s   returns cluster tree satisfying
consistent  returns false inconsistent 
proof  solve constraints s   returns false  inconsistent  lemma    
return false  returns cluster tree  lemma      since instantiation
 lemma    since every instantiation solution  lemma      follows
consistent satisfies    
proof theorem  
lemma     s  s  consistent sets constraints  s  s 
reduce constraints s    reduce constraints s    
proof  immediate construction  value h case s  superset value
case s    hence reduce constraints s    superset reduce constraints s    
lemma     s  s  consistent sets constraints  s  s  num labels s  
num labels s   
proof induction num labels s    num labels s        statement trivial 
suppose statement holds     num labels s      k 
let num labels s     k     
k       num labels s          num labels reduce constraints s     
k  num labels reduce constraints s      now  suppose s  s    lemma   
reduce constraints s    reduce constraints s     inductive hypothesis
num labels reduce constraints s     num labels reduce constraints s     
num labels s   num labels s     
lemma     let set constraints  let solution   graph g
symbols   let nd g    number different non zero values od a  b 
edge ab g  let edges s   set edges   nd edges s     
num labels s   
proof  induction num labels s    num labels s        statement trivial 
suppose k  statement holds   num labels s      k  suppose
num labels s     k      let pq edge maximal length  set edges e  
let small edges e    set edges ab e
od   a    b   od   p    q    since small edges e   contains edges every order
magnitude e except order magnitude pq  follows
nd small edges e         nd e       let g complete graph symbols
  argument lemma    small edges g    h   h connected
components shorts   computed reduce constraints s    let   set
constraints whose longs small edges g     follows   reduce constraints s   
small edges g    edges s     edges reduce constraints s    
hence nd edges s        nd g      nd small edges g          
nd edges reduce constraints s          by inductive hypothesis 
num labels reduce constraints s          num labels s     

  

fidavis

theorem    solutions set constraints   instantiations
solve constraints s   fewest number different values od a  b   a  b range
symbols   number given num labels s   
proof  immediate lemma    
corollary     let
properties om space except k
different orders magnitude  system constraints solution

tree returned solve constraints s   uses k different labels 
proof  immediate theorems       
proof algorithm non strict comparisons
prove revised algorithm presented section     non strict comparisons
correct  proof slight extension proof theorem    given above 
recall revised algorithm section     replaces line solve constraints
h    connected components shorts
following code 

  
  
  
  
  

h    shorts  
repeat h    connected components h  
weak constraint od a  b  od c  d 
cd h add ab h endif endfor
change made h last iteration 

need following new lemmas proofs 

lemma     let set strict comparisons  let w set non strict comparisons  let h set edges output code    w consistent 
edge h  
proof  proof lemma    let valuation satisfying   w let pq
edge od   p    q   maximal  wish show that  every edge
ab   h   od   a    b   od   p    q    hence ab    pq  proof induction  suppose
holds edges h point code  ab
added h   three cases consider 

ab added step      then  lemma    constraint od a  b  od c  d 
  hence od   a    b   od   c    d   od   p    q   
ab added step      path a    a  a        ak   b edge
ai ai   h           k    inductive hypothesis  od   ai     ai     
od   p    q    om triangle inequality 
od   a    b   maxi    k   od   ai     ai       od   p    q   

ab added step      constraint od a  b  od c  d  w
cd h   inductive hypothesis  od   c    d   od   p    q   
  

fiorder magnitude comparisons distance

 

lemma     let w contain constraint od a  b  od c  d   suppose algorithm
returns cluster tree   let least common ancestor b   let n
least common ancestor c d   label n  label 
proof  lemma     n assigned label first iteration h include
edge cd  previous iterations  since cd h   ab likewise put h  
hence get assigned label n    label n  label 
remainder proof correctness revised algorithm exactly
proof theorem   
validation algorithm solve constraints 
proof correctness algorithm solve constraints  analogous structure
proof theorem    sketch below  details dicult fill in 
    analogue lemma     ordered cluster tree  revised version
instantiate t   returns instantiation   proof exactly lemma
   additional verification instantiate  preserves orderings  
    analogue lemma     let set order of magnitude constraints distances 
let set ordering constraints points  let h graph given
two statements

h    connected components shorts  
h    incorporate order h  o  
consistent  h contain edges  
proof  proof lemma    choose valuation satisfying   let pq
edge od   p    q   maximal  following informal argument
presented section      easily shown pq longer edges
added two statements  hence h  
    analogue lemma     solve constraints  returns false    inconsistent 
proof  immediate     
    analogue lemma      solve constraints  s   o  return false 
returns well formed ordered cluster tree 
proof  merging strongly connected components g  incorporate order always
ensures ordering arcs connected components h form dag 
arcs precisely ones later added among children node n
ordering arcs  thus  ordering arcs children node cluster tree
form dag  otherwise  construction tree lemma    
remainder proof proof theorem   

  

fidavis

proof theorem  
begin proving lemma     revised version  instantiate   given section
     gives instantiation cluster tree euclidean space 
lemma     cluster tree instantiation euclidean space  m dimensionality m 
proof essentially proof lemma    except
keep track real quantities  node n   i n  label  define  n      
proof proceeds following steps 
i    j     j  ffj   immediate construction 
ii  nodes  c   descendant c
dist g m    g c      ffn c    ff    
proof  let c   c    c        cr   path p
c  
dist 
triangle inequality  ri    dist g ci     g ci   
pr  g n m   cg   ffc   i     by
 ff  ff     n c    
i  
iii  let n node   let c  c  two children n   let m  m 
descendants c  c  respectively 
 n      n  ff       dist g m    g m       n n          ff    
proof  triangle inequality 
dist g c     g c     dist g c     g m       dist g m     g m       dist g m     g c     
thus  dist g c    g c     dist g c    g m     dist g m     g c     dist g m     g m     
also  triangle inequality 
dist g m     g m     dist g c    g c       dist g c    g m       dist g m     g c     
construction   n   dist g c    g c       n n   
part  ii           dist g mi   g ci      ffn c    ff      n n    ff   
 c      n   ff 
iv  symbols a  b  c    let p least common ancestor a  b let n
least common ancestor c  d  p  label   n  label
much closer g a   g b   g c   g d   
proof  part  iii   dist g a   g b     n p          ff    
dist g c   g d      n      n  ff      since  p      n   ff since
       n   bn  follows straightforward algebra
dist g a   g b     dist g c   g d     b  

 

next prove analogue lemma   

lemma     let set constraints n variables form
 dist a  b    dist c  d    b    b   n  consistent  edge
connected components shorts  
proof  let valuation satisfying   let pq edge dist   p    q  
maximal  now  ab short   is  constraint much closer a  b  c  d 
  dist   a    b     dist   c    d   b dist   p    q   b  

  

fiorder magnitude comparisons distance

now  let ab edge h   connected components shorts  
simple path a    a  a        ak   b edge ai ai   short
          k    note k n  then  triangle inequality 
dist   a    b  
dist   a      a       dist   a      a               dist   ak       ak   
 k   dist   p    q     b   dist   p    q  

hence pq    ab  pq h    

theorem    let set constraints n variables form  dist a  b    dist c  d 
  b    b   n  algorithm solve constraints s   returns cluster tree satisfying
consistent euclidean space  returns false inconsistent 
proof  note semantics constraints  much closer a  b  c  d   enters
proof theorem   lemmas      remainder proof theorem  
purely relation structure structure tree  hence 
since shown analogues lemmas     hold set constraints
kind  proof completed exactly way   
proof theorem  
lemma     let cluster tree let valuation om space
satisfying  
let x symbol   let point
  let   valuation   fx   ag 
exists extension   x   satisfies    
proof  empty tree  statement trivial  contains single symbol y 
   y  operation     applies  label        y  operation    
applies  label   
otherwise  let symbol od   y   a  minimal   we deal
case ties step  d  below   let f father  
let d od   y   a   let v set orders magnitude od   p    q   
p q range symbols   define l suitable label follows 
  v   l label corresponding d  larger value v
l label root plus       v   value v larger d 
let d  largest value v less d  let d  smallest value v greater
d  let l    l  labels corresponding d    d    let l    l    l      
one following must hold 
a   y    a  f  label    apply operation     n   f  
b   y    f  label       apply operation      label     
c   y     a  od   y   a  less od   z    a  symbol z  
   
apply operation      label set suitable value  
d  one value y        yk od   yi    a    d  easily shown
case internal node q y        yk set symbols
subtree q  three cases consider 

  

fidavis

d i d odiam   q symbols    apply operation     n   q 
d ii   odiam   q symbols    q root  apply operation    
c   q  set  label suitable value d   it easily shown
  odiam   n  symbols    n father q  
d iii   odiam   q symbols    q root  apply operation     

 

lemma     let   fa        ak g finite set points whose diameter order ofmagnitude d  exists point u that            k  od u  ai     d 
proof  let b    a    axiom a   exists infinite collection points b    b       
od bi   bj        j   now  value ai one value bj
od ai   bj   d  two values bj   bj    om triangle
inequality  od bj    bj     d  hence  k different values bj least
ai   let u values bj   since od u  a      od a    ai  
i  follows od u  ai   ai   thus  since od u  ai   od u  ai  
d  follows od u  ai    d   
lemma     let cluster tree  let valuation om space
satisfying  
let   extension x 
dense unbounded above 
value valuation   fx   ag satisfies    
proof  operations         statement trivial 
otherwise  let l extending label   l      set      l  
let order magnitude corresponding l   l    l   l 
l  l  labels consecutive values   let d  d  orders
magnitude corresponding l    l    let chosen d  d   
l greater label tree  choose greater diameter
tree  
  formed operation      using lemma    let point
od a   y     odiam n   n  symbols 
  formed operation      let point od a   y    
d 
  formed operation      let point od a   y    
c  symbols   note that  since  label   n  label    odiam n  symbols   
  formed operation      let point od a   y    
r symbols 
cases  straightforward verify   fx   ag satisfies      
observed section   regarding lemma     conditions
lemma   
necessary  statement false otherwise  example  let
om space
described example i  section    polynomials infinitesimal  

unbounded above  maximum order of magnitude o     let starting tree
figure    upper left corner   let   result applying operation    middle
bottom   let valuation fu     v      w    g  satisfies   cannot
extended valuation satisfies     would require x given value
od v  w  od x  w   value exists within
  point lemma

  

fiorder magnitude comparisons distance

that 
required dense unbounded above  cannot get  stuck 
way 

lemma     let cluster tree  let x variable among symbols  
let open formula l  whose free variables symbols variable
x   let formula  x ff  let
om space dense unbounded above 
exists instantiation
satisfies exists
extension   instantiation     extends satisfies ff 
proof  suppose exists instantiation satisfies  x ff  then 
definition  point
satisfies ff x a   is  instantiation
  fx   ag satisfies ff  let       fx   ag  lemma     cluster tree  
corresponding   extension  
conversely  suppose exists extension   instantiation    
satisfying ff  let restriction   symbols   clearly satisfies
formula  x ff   
lemma     let cluster tree  let open formula l  whose free variables
symbols   let
om space dense unbounded above  one
instantiation
satisfies every instantiation
satisfies  
proof  assume without loss generality logical symbols  
 not      and      exists      equals  variables names  non logical
symbol predicate  much closer   proceed using structural induction
form   note equivalent statement inductive hypothesis is   for formula
  either true every instantiation   false every instantiation
  
base case  atomic formula  x      much closer w  x  y  z   
follows immediately corollary   
let form     true   false   inductive hypothesis  false every instantiation   hence true every
instantiation  
let form     true true  
inductive hypothesis  true every instantiation   hence
true every instantiation  
let form  x ff  true lemma     exists
extension   instantiation     true     inductive
hypothesis  true every instantiation     now    instantiation  
satisfies ff  restriction   variables   clearly satisfies
 x ff  lemma     every instantiation extended instantiation  
    therefore  every instantiation satisfies    
theorem    let cluster tree  let open formula l  whose free variables
symbols   let
om space dense unbounded above  algorithm
decide t    returns true satisfies false otherwise 
proof  immediate proof lemma      

  

fidavis

references
cormen  t h   leiserson  c e   rivest  r l          introduction algorithms  cambridge  ma  mit press
davis  e          order magnitude reasoning qualitative differential equations 
d  weld j  de kleer  eds   readings qualitative reasoning physical systems 
san mateo  ca  morgan kaufmann          
keisler  j          foundations infinitesimal calculus  boston  ma  prindle  webber 
schmidt 
mavrovouniotis  m  stephanopoulos  g           formal order of magnitude reasoning process engineering   d  weld j  de kleer  eds   readings qualitative
reasoning physical systems  san mateo  ca  morgan kaufmann          
raiman  o           order magnitude reasoning   d  weld j  de kleer  eds  
readings qualitative reasoning physical systems  san mateo  ca  morgan kaufmann          
robinson  a          non standard analysis  amsterdam  north holland publishing co 
weld  d           exaggeration   d  weld j  de kleer  eds   readings qualitative
reasoning physical systems  san mateo  ca  morgan kaufmann          

  


