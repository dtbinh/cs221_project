journal of artificial intelligence research               

submitted       published     

order of magnitude comparisons of distance
ernest davis

davise cs nyu edu

courant institute
new york  ny       usa

abstract
order of magnitude reasoning   reasoning by rough comparisons of the sizes of quantities   is often called  back of the envelope calculation   with the implication that the
calculations are quick though approximate  this paper exhibits an interesting class of constraint sets in which order of magnitude reasoning is demonstrably fast  specifically  we
present a polynomial time algorithm that can solve a set of constraints of the form  points
a and b are much closer together than points c and d   we prove that this algorithm can be
applied if  much closer together  is interpreted either as referring to an infinite difference in
scale or as referring to a finite difference in scale  as long as the difference in scale is greater
than the number of variables in the constraint set  we also prove that the first order theory
over such constraints is decidable 
   introduction
order of magnitude reasoning   reasoning by rough comparisons of the sizes of quantities  
is often called  back of the envelope calculation   with the implication that the calculations
are quick though approximate  previous ai work on order of magnitude reasoning  however 
has focussed on its expressive power and inferential structure  not on its computational
leverage  raiman        mavrovouniotis and stephanopoulos        davis        weld 
      
in this paper we exhibit an interesting case where solving a set of order of magnitude
comparisons is demonstrably much faster than solving the analogous set of simple order
comparisons  specifically  given a set of constraints of the form  points a and b are much
closer together than points c and d   the consistency of such a set can be determined in
low order polynomial time  by contrast  it is easily shown that solving a set of constraints
of the form  the distance from a to b is less than or equal to the distance from c to d  in
one dimension is np complete  and in higher dimensions is as hard as solving an arbitrary
set of algebraic constraints over the reals 
in particular  the paper presents the following results 
   the algorithm  solve constraints s    solves a system of constraints of the form  points
a and b are infinitely closer than points c and d  in polynomial time  section    
   an improved version of the algorithm runs in time o max n  ff n    ne  s  where n is
the number of variables  ff n  is the inverse ackermann s function  e is the number of
edges mentioned in the constraint set  and s is the size of the constraint set   section
     
   an extended version of the algorithm allows the inclusion of non strict constraints of
the form  points a and b are not infinitely further apart than points c and d   the
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fidavis

running time for this modified algorithm is slower than that of solve constraints  but
still polynomial time   section     
   a different extension of the algorithm allows the combination of order of magnitude
constraints on distances with order comparisons on the points of the form  point a
precedes point b    section     
   the same algorithm can be applied to constraints of the form  the distance from a
to b is less than   b times the distance from c to d   where b is a given finite value 
as long as b is greater than the number of variables in the constraint set   section   
   the first order theory over such constraints is decidable   section   
as preliminary steps  we begin with a small example and an informal discussion  section
    we then give a formal account of order of magnitude spaces  section    and present
a data structure called a cluster tree  which expresses order of magnitude distance comparisons  section     we conclude the paper with a discussion of the significance of these
results  section    

   examples
consider the following inferences 

example    i wish to buy a house and rent oce space in a suburb of metropolis  for
obvious reasons  i want the house to be close to the school  the house to be close to the
oce  and the oce to be close to the commuter train station  i am told that in elmville
the train station is quite far from the school  but in newton they are close together 
infer that i will not be able to satisfy my constraints in elmville  but may be able to
in newton 
example    the empire state building is much closer to the washington monument than
to versailles  the statue of liberty is much closer both to the empire state building and
to carnegie hall than to the washington monument 
infer that carnegie hall is much closer to the empire state building than to versailles 
example    you have to carry out a collection of computational tasks covering a wide
range of diculty  for instance
a 
b 
c 
d 
e 
f 

add up a column of     numbers 
sort a list of        elements 
invert a          matrix 
invert a            matrix 
given the o d e  x   cos et x   x         find x     to    bit accuracy 
given a online collection of       photographs in gif format  use state ofthe art image recognition software to select all those that show a man on
horseback 

 

fiorder of magnitude comparisons of distance

g  do a web search until you have collected     pictures of men on horseback 
using state of the art image recognition software 
h  using state of the art theorem proving software  find a proof that the medians of a triangle are concurrent 
i  using state of the art theorem proving software  find a proof of fermat s
little theorem 
it is plausible to suppose that  in many of these cases  you can say reliably that one
task will take much longer than another  either by a human judgment or using an expert
system  for instance  task  a  is much shorter than any of the others  task  b  is much
shorter than any of the others except  a  and possibly  h   task  c  is certainly much
shorter than  d    f    g   or  i   however  with certain pairs such as  c  and  h  or  c  and
 e  it would be dicult to guess whether one is much shorter than another  or whether they
are of comparable diculty 
you have a number of independent identical computers  of unknown vintage and characteristics  on which you will schedule tasks of these kinds  note that  under these circumstances  there is no way to predict the absolute time required by any of these tasks within a
couple of orders of magnitude  nonetheless  the comparative lengths presumably still stand 
given  a particular schedule of tasks on machines  infer what you can about the relative
order of completion times  for example  given the following schedule
machine m   tasks a b h d 
machine m   tasks c i 
it should be possible to predict that  a  and  b  will complete before  c   that  c  will
complete before  d   and that  d  will complete before  i   but it will not be possible to
predict the order in which  c  and  h  will complete 
in all three examples  the given information has the form  the distance between points
w and x is much less than the distance between y and z    in examples   and    the
points are geometric  in example    the points are the start and completion times of the
various tasks  and the constraints on relative lengths can be put in the form  the distance
from start a  to end a  is much less than the distance from start c  to end c    and so on 
in example    there is also ordering information  the start of each task precedes its end  the
end of  a  is equal to the start of  b   and so on  the problem is to make inferences based
on this weak kind of constraint 
it should be noted that these examples are meant to be illustrative  rather than serious applications  example   does not extend in any obvious way to a class of natural 
large problems  example   is implausible as a state of knowledge  how does the reasoner
find himself knowing just the order of magnitude relations among distances and no other
geometric information  example   is contrived  nonetheless  these illustrate the kinds of
situations where order of magnitude relations on distance do arise  where they express a
substantial part of the knowledge of the reasoner  and where inferences based purely on the
order of magnitude comparisons can yield useful conclusions 
the methods presented in this paper involve construing the relation  distance d is much
shorter than distance e  as if it were  distance d is infinitesimal as compared to distance
e   as we shall see  under this interpretation  systems of constraints over distances can be

 

fidavis

solved eciently  the logical foundations for dealing with infinitesimal quantities lie in the
non standard model of the real line with infinitesimals  developed by abraham robinson
         a more readable account is given by keisler         reasoning with quantities of
infinitely different scale is known as  order of magnitude  reasoning 
the reader may ask   since infinitesimals have no physical reality  what is the value
of developing techniques for reasoning about them   in none of the examples  after all  is
the smaller quantity truly infinitesimal or the larger one truly infinite  in example   and
   the ratio between successive sizes is somewhere between    and      in example    it
is between     and a rather large number dicult to estimate  but one can always give
some kind of upper bound  it is essentially certain  for instance  that the ratio between the
times required for tasks  a  and  i  is less than             why not use the best real valued
estimate instead 
the first answer is that this is an idealization  practically all physical reasoning and
calculation rest on one idealization or another  the idealization in the situation calculus
that time is discrete  the idealization that solid objects are rigid  employed in most mechanics programs  the idealization that such physical properties as density  temperature  and
pressure are continuous rather than local averages over atoms  which underlies most uses of
partial differential equations  the idealization involved in the use of the dirac delta function 
and so on  our idealization here that a very short distance is infinitesimally smaller than a
long one simplifies reasoning and yields useful results as long as care is taken to stay within
an appropriate range of application 
the second answer is that this is a technique of mathematical approximation  which we
are using to turn an intractable problem into a tractable one  this would be analogous to
linearizing a non linear equation over a small neighborhood  or to approximating a sum by
an integral 
there are circumstances where we can be sure that the approximation gives an answer
that is guaranteed exactly correct  namely if the actual ratio implicit in the comparison
 d is much smaller than e   is larger than the number of points involved in the system of
constraints  this will be proven in section    there is also a broader  less well defined  class
of problems where the approximation  though not guaranteed correct  is more reliable than
some of the other links in the reasoning  for instance  suppose that one were to consider
an instance of example   involving a couple of hundred tasks  apply order of magnitude
reasoning  and come up with an answer that can be determined to be wrong  it is possible
that the error would be due to the order of magnitude reasoning  however  it seems safe
to say that  in most cases  the error is more likely to be due to a mistake in estimating the
comparative sizes 

   order of magnitude spaces
an order of magnitude space  or om space  is a space of geometric points  any two points
are separated by a distance  two distances d and e are compared by the relation d  e 
meaning  distance d is infinitesimal compared to e  or  more loosely   distance d is much
smaller than e  
for example  let   be the non standard real line with infinitesimals  let  m be the
corresponding m dimensional space  then we can let a point of the om space be a point in

 

fiorder of magnitude comparisons of distance

rm   the distance between two points a  b is the euclidean distance  which is a non negative
value in     the relation d  e holds for two distances d  e  if d e is infinitesimal 
the distance operator and the comparator are related by a number of axioms  specified
below  the most interesting of these is called the om triangle inequality  if ab and bc are
both much smaller than xy  then ac is much smaller than xy  this combines the ordinary
triangle inequality  the distance ac is less than or equal to distance ab plus distance bc 
together with the rule from order of magnitude algebra   if p  r and q  r then p q  r  
it will simplify the exposition below if  rather than talking about distances  we talk about
orders of magnitude  these are defined as follows  we say that two distances d and e have
the same order of magnitude if neither d  e nor e  d  in   this is the condition that d e
is finite  neither infinitesimal nor infinite   raiman       uses the notation  d co e  for this
relation   by the rules of the order of magnitude calculus  this is an equivalence relation 
hence we can define an order of magnitude to be an equivalence class of distances under
the relation  same order of magnitude   for two points a  b  we define the function od a  b 
to be the order of magnitude of the distance from a to b  for two orders of magnitude p  q 
we define p  q if  for any representatives d   p and e   q  d  e  by the rules of the orderof magnitude calculus  if this holds for any representatives  it holds for all representatives 
the advantage of using orders of magnitude and the function  od   rather than distances
and the distance function  is that it allows us to deal with logical equality rather than the
equivalence relation  same order of magnitude  
for example  in the non standard real line  let  be a positive infinitesimal value  then
values such as f                         g  are all of the same order of magnitude  o   the
values f             e         g are of a different order of magnitude o   o   the values
f                 g are of a third order of magnitude o   o  
definition    an order of magnitude space  om space  
 consists of 







a set of points p  
a set of orders of magnitude d 
a distinguished value     d 
a function  od a  b   mapping two points a  b   p to an order of magnitude 
a relation  d  e  over two orders of magnitude d  e   d

satisfying the following axioms 
a   for any orders of magnitude d  e
e  d  d   e 

  d  exactly one of the following holds  d  e 

a   for d  e  f   d  if d  e and e  f then d  f  
 transitivity  together with a    this means that  is a total ordering on orders of
magnitude  
a   for any d   d  not d    
   is the minimal order of magnitude  

 

fidavis

a   for points a  b   p   od a  b      if and only if a   b 
 the function od is positive definite  
a   for points a  b   p   od a  b    od b  a  
 the function od is symmetric  
a   for points a  b  c   p   and order of magnitude d   d 
if od a  b   d and od b  c   d then od a  c   d 
 the om triangle inequality  
a   there are infinitely many different orders of magnitude 
a   for any point a    p and order of magnitude d
a    a        such that od ai   aj     d for all i    j  

  d  there exists an infinite set

the example we have given above of an om space  non standard euclidean space  is wild
and woolly and hard to conceptualize  here are two simpler examples of om spaces 
i  let  be an infinitesimal value  we define a point to be a polynomial in  with integer
coecients  such as            we define an order of magnitude to be a power of   we
define m  n if m   n  for example         we define od a  b  to be the smallest power
of  in a b  for example  od                             
ii  let n be an infinite value  we define a point to be a polynomial in n with integer
coecients  we define an order of magnitude to be a power of n   we define n p  n q if
p   q  for example  n    n     we define od a  b  to be the largest power of n in a b  for
example  od     n    n        n      n       n    
it can be shown that any om space either contains a subset isomorphic to  i  or a subset
isomorphic to  ii    this is just a special case of the general rule that any infinite total
ordering contains either an infinite descending chain or an infinite ascending chain  
we will use the notation  de  as an abbreviation for  d  e or d   e  

   cluster trees
let p be a finite set of points in an om space  if the distances between different pairs of
points in p are of different orders of magnitude  then the om space imposes a unique treelike hierarchical structure on p   the points will naturally fall into clusters  each cluster c
being a collection of points all of which are much closer to one another than to any point in
p outside c   the collection of all the clusters over p forms a strict tree under the subset
relation  moreover  the structure of this tree and the comparative sizes of different clusters
in the tree captures all of the order of magnitude relations between any pair of points in p  
the tree of clusters is thus a very powerful data structure for reasoning about points in an
om space  and it is  indeed  the central data structure for the algorithms we will develop in
this paper  in this section  we give a formal definition of cluster trees and prove some basic
results as foundations for our algorithms 

definition    let p be a finite set of points in an om space  a non empty subset c  p is
called a cluster of p if for every x  y   c   z   p c   od x  y   od x  z    if c is a cluster 
the diameter of c   denoted  odiam c     is the maximum value of od x  y  for x  y   c  

 

fiorder of magnitude comparisons of distance

n 
 
n 

n 

 

 

n 

n 

a

d

 

 

 

 

e

g

f

b

c

 

 

 

 

 

figure    cluster tree
note that the set of any single element of p is trivially a cluster of p   the entire set p
is likewise a cluster of p   the empty set is by definition not a cluster of p  

lemma    if c and d are clusters of p   then either c
disjoint 

 d  d  c   or c and d are

proof  suppose not  then let x   c   d  y   c d  z   d c   since c is a cluster 
od x  y   od x  z    since d is a cluster  od x  z    od x  y   thus we have a contradiction 

 

by virtue of lemma    the clusters of a set p form a tree  we now develop a representation of the order of magnitude relations in p by constructing a tree whose nodes correspond
to the clusters of p   labelled with an indication of the relative size of each cluster 

definition    a cluster tree is a tree t such that

 every leaf of t is a distinct symbol 
 every internal node of t has at least two children 
 each internal node of t is labelled with a non negative value  two or more nodes
may be given the same value   for the purposes of sections      labels may be taken
to be non negative integers  in section    it will be useful to allow rational labels  

 every leaf of the tree is labelled   
 the label of every internal node in the tree is less than the label of its parent 
for any node n of t   the field  n  symbols  gives the set of symbols in the leaves in the
subtree of t rooted at n   and the field  n  label  gives the integer label on node n  

 

fidavis

thus  for example  in figure    n  label   and n  symbols   fa  dg  n  label     and
n  symbols   fa  b  c  d  e  f  gg 
as we shall see  the nodes of the tree t represent the clusters of a set of points  and the
labels represent the relative sizes of the diameters of the clusters 

definition    a valuation over a set of symbols is a function mapping each symbol to a
point in an om space  if t is a cluster tree  a valuation over t is a valuation over t  symbols 
if n is any node in t and is a valuation over t   we will write  n   as an abbreviation
for  n  symbols  
we now define how a cluster tree t expresses the order of magnitude relations over a
set of points p  
definition    let t be a cluster tree and let be a valuation over t   let p    t    the
set of points in the image of t under   we say that j t  read satisfies or instantiates
t   if the following conditions hold 
i  for any internal node n of t    n   is a cluster of p  
ii  for any cluster c of p   there is a node n such that c    n   
iii  for any nodes m and n   if m  label   n  label then odiam   m     odiam   n    
iv  if label m        then odiam m         that is  all children of m are assigned the
same value under   
the following algorithm generates an instantiation
procedure

variable

given a cluster tree t  

instantiate in t   cluster tree  
   an om space 
return   array of points indexed on the symbols of t

g n     array of points indexed on the nodes of t  

let k be the number of internal nodes in t  
choose                     k to be k     different orders of magnitude 
   such values can be chosen by virtue of axiom a     
pick a point x   
 
g root of t      x 
instantiate  t  
          k   g  
return the restriction of g to the symbols of t  
end instantiate 
instantiate  in n   a node in a cluster tree  
   an om space          k   orders of magnitude 
in out g   array of points indexed on the nodes of t  
if n is not a leaf then
let c        cp be the children of n  
x     g n   
q    n  label 
pick points x        xp such that
for all i  j           p  if i    j then od xi   xj     q  
   such points can be chosen by virtue of axiom a     
 

fiorder of magnitude comparisons of distance

for

i           p do
g ci      xi  

instantiate  ci   
          k   g  

endfor
endif end

instantiate  

thus  we begin by picking orders of magnitude corresponding to the values of the labels 
we pick an arbitrary point for the root of the tree  and then recurse down the nodes of the
tree  for each node n   we place the children at points that all lie separated by the desired
diameter of n   the final placement of the leaves is then the desired instantiation 
lemma    if t is a cluster tree and 
 is an om space  then instantiate t  
  returns an
instantiation of t  
the proof is given in the appendix 
moreover  it is clear that any instantiation of t can be generated as a possible output
of instantiate t  
    given an instantiation   just pick g n   at each stage to be of some
symbol of n   
note that  given any valuation over a finite set of symbols s   there exists a cluster
tree t such that t  symbols   s and satisfies t   such a t is essentially unique up to an
isomorphism over the set of labels that preserves the label   and the order of labels 

   constraints
in this section  we develop the first of our algorithms  algorithm solve constraints tests
a collection of constraints of the form  a is much closer to b than c is to d   for consistency  if the set is consistent  then the algorithm returns a cluster tree that satisfies the
constraints  the algorithm builds the cluster tree from top to bottom dealing first with the
large distances  and then proceeding to smaller and smaller distances 
let s be a system of constraints of the form od a  b   od c  d   and let t be a cluster
tree  we will say that t  s  read  t satisfies s    if every instantiation of t satisfies s   in
this section  we develop an algorithm for finding a cluster tree that satisfies a given set of
constraints 
the algorithm works along the following lines  suppose we have a solution satisfying s  
let d be the diameter of the solution  if s contains a constraint od a  b   od c  d  then 
since od c  d  is certainly no more than d  it follows that od a  b  is much smaller than d 
we label ab as a  short  edge 
if two points u and v are connected by a path of short edges  then by the triangle
inequality the edge uv is also short  i e  much shorter than d   thus  if we compute the
connected components h of all the edges that have been labelled short  then all these edges
in h can likewise be labelled short  for example  in table    edges vz   wx  and xy can all
be labelled  short  
on the other hand  as we shall prove below  if an edge is not in the set h   then there is
no reason to believe that it is much shorter than d  we can  in fact  safely posit that it is
the same o m  as d  we label all such edges  long  
we can now assume that any connected component of points connected by short edges
is a cluster  and a child of the root of the cluster tree  the root of the cluster tree is then
given the largest label  its children will be given smaller labels  each  long  edge now

 

fidavis

connects symbols in two different children of the root  hence  any instantiation of the tree
will make any long edge longer than any short edge 
if no edges are labelled  long    that is  if h contains the complete graph over the
symbols   then there is an inconsistency  all edges are much shorter than the longest edge 
for instance  in table    since vw  wx  and xy are all much smaller than zy  it follows
by the triangle inequality that vy is much smaller than zy  but since we also have the
constraints that zy is much smaller than vz and that vz is much smaller than vy  we have
an inconsistency 
the algorithm then iterates  at the next smaller scale  since we have now taken care of
all the constraints od a  b   od c  d   where cd was labelled  long   we can drop all those
from s   let d now be the greatest length of all the edges that remain in s   if a constraint
od a  b   od c  d  is in the new s   then we know that od a  b  is much shorter than d  and
we label it  short   we continue as above  the algorithm halts when all the constraints in
s have been satisfied  and s is therefore empty  or when we encounter a contradiction  as
above 
we now give the formal statement of this algorithm  the algorithm uses an undirected
graph over the variable symbols in s   given such a graph g  and a constraint c of the
form od a  b   od c  d   we will refer to the edge ab as the  short  of c   and to the edge
cd as the  long  of c   the shorts of the system s is the set of all shorts of the constraints
of s and the longs of s is the set of all the longs of the constraints  an edge may be both a
short and a long of s if it appears on one side in one constraint and on the other in another
constraint 
procedure

type 

solve constraints in s   a system of constraints of the form od a  b   od c  d  
return either a cluster tree t satisfying s if s is consistent 
or false if s is inconsistent 

a node n of the cluster tree contains
pointers to the parent and children of n  
the field n label  holding the integer label 
and the field n symbols  holding the list of symbols in the leaves of n  

variables 

begin if

m is an integer 
c is a constraint in s  
h  i are undirected graphs 
n  m are nodes of t  

s contains any constraint of the form   od a  b   od c  c   then return false 

m    the number of variables in s  
initialize t to consist of a single node n  
n  symbols   the variables in s  
repeat

h    the connected components of the shorts of s  
if h contains all the edges in s then return false  endif 
for each leaf n of t do
if not all vertices of n are connected in h then
n  label    m 
for each connected component i of n  symbols in h

  

do

fiorder of magnitude comparisons of distance

construct node m as a new child of n in t  
m  symbols   the vertices of i  

endfor endif endfor

s    the subset of constraints in s whose long is in h  
m    m   
until
for

s is empty 

each leaf n of t
n  label      
if n  symbols has more than one symbol
then create a leaf of n for each symbol in n  symbols 
label each such leaf   
endif endfor end solve constraints 

tables   and   give two examples of the working of procedure solve constraints  table
  shows how the procedure can be used to establish that the following constraints are
consistent 
the empire state building  x  is much closer to the washington monument  w 
than to notre dame cathedral  v  
bunker hill  y  is much closer to the empire state building than to the eiffel
tower  z   
the distance from the eiffel tower to notre dame is much less than the distance
from the washington monument to bunker hill 
table   shows that the following inference can be justified 

given  the distances from the statue of liberty  v  to the world trade center
 w   from the world trade center to the empire state building  x   and from
the empire state building to the chrysler building  y  are all much less than
the distance from the chrysler building to the washington monument  z   
infer  the washington monument is not much nearer to the chrysler building
than to the statue of liberty 
this inference is carried out by asserting the negation of the consequent   the washington monument is much nearer to the chrysler building than to the statue of liberty   and
showing that that collection of constraints is inconsistent  note that if we change  much
less  and  much nearer  in this example to  less  and  nearer   then the inference no longer
valid 
theorem   states the correctness of algorithm solve constraints  the proof is given in
the appendix 
theorem    the algorithm solve constraints s   returns a cluster tree satisfying s if s is
consistent  and returns false if s is inconsistent 
there may be many cluster trees that satisfy a given set of constraints  among these 
the cluster tree returned by the algorithm solve constraints has an important property  it
has the fewest possible labels consistent with the constraints  in other words  it uses the
minimum number of different orders of magnitude of any solution  therefore  the algorithm
can be used to check the satisfiability of a set of constraints in an om space that violates

  

fidavis

s contains the constraints
   od w  x   od x  v  
   od x  y   od y  z   
   od v  z    od w  y  
the algorithm proceeds as follows 
initialization 
the tree is initializes to a single node with n  
n  symbols    f v  w  x  y  z g 
first iteration 
the shorts of s are f wx  xy  vz g 
computing the connected components  h is set to f wx  xy  wy  vz g 
n  label      
two children of n  are created 
n   symbols    w  x  y  
n   symbols    v  z  
as xv is not in h   delete constraint    from s  
as yz is not in h   delete constraint    from s  
s now contains just constraint    
second iteration 
the shorts of s are f vz g 
the connected components h is just fvz g 
n   label      
three children of n   are created 
n    symbols    w 
n    symbols    x 
n    symbols    z  
as wy is not in h   delete constraint    from s  
s is now empty 
cleanup 
n   label      
two children of n   are created 
n    symbols    v 
n    symbols    z  
 see figure    
table    example of computing a cluster tree

  

fiorder of magnitude comparisons of distance

n 
 th iteration
v w x y z

n 

 st iteration

 
v w x y z
n  

n  

w x y

v z

n 
 nd iteration
 
v w x y z
n  
 

n  
w x y
v z

w

x

y

n 
cleanup
 
v w x y z
n  
 

w

x

n  
w x y

 

y

v

figure    building a cluster tree

  

v z

z

fidavis

s contains the constraints
od v  w   od z  y  
od w  x   od z  y  
od x  y   od z  y  
od z  y   od v  z   
the algorithm proceeds as follows 
initialization 
the tree is initializes to a single node with n  
n  symbols    f v  w  x  y  z g 
first iteration 
the shorts of s are f vw  wx  xy  zy  vz g 
h is set to its connected components  which is the complete graph over v  w  x  y  z  
the algorithm exits returning false
table    example of determining inconsistency
axiom a   and has only finitely many different orders of magnitude  if the algorithm returns
t and t has no more different labels than the number of different orders of magnitude in
the space  then the constraints are satisfiable  if t uses more labels than the space has
orders of magnitude  then the constraints are unsatisfiable 
the proof is easier to present if we rewrite algorithm solve constraints in the following
form  which returns only the number of different non zero labels used  but does not actually
construct the cluster tree  

num labels s   

function
if
then return
else return

s is empty

   
     num labels reduce constraints s    
function reduce constraints s  
h    connected components of the shorts of s  
if h contains all the edges in s then return false  to top level
else return the set of constraints in s whose long is in h  

it is easily verified that the sequence of values of s in successive recursive calls to
num labels is the same as the sequence of values of s in the main loop of solve constraints 
therefore num labels returns the number of different non zero labels in the tree constructed
by solve constraints 
   the reader may wonder why this simpler algorithm was not presented before the more complicated
algorithm solve constraints  the reason is that the only proof we have found that the system of constraints is consistent if num labels does not return
the constructive solve constraints 

  

false

relies on the relation between num labels and

fiorder of magnitude comparisons of distance

theorem    out of all solutions to the set of constraints s   the instantiations of
solve constraints s   have the fewest number of different values of od a  b   where a  b range
over the symbols in s   this number is given by num labels s   
the proof is given in the appendix 

   extensions and consequences
we next present a number of modifications of the algorithm solve constraints  the first
is a more ecient implementation  the second extends the algorithm to handle non strict
comparisons  the third extend the algorithm to handle a combination of order of magnitude
comparisons on distance with order comparisons  in a one dimensional space 

    an ecient implementation of solve constraints
it is possible to implement algorithm solve constraints somewhat more eciently than the
naive encoding of the above description  the key is to observe that the graph h of connected
components does not have to be computed explicitly  it suces to compute it implicitly using
merge find sets  union find sets   combining this with suitable back pointers from edges to
constraints  we can formulate a more ecient version of the algorithm 
we use the following data structures and subroutines 

 each node n of the cluster tree contains pointers to its parents and children  a field

n  label  holding the integer label  a field n  symbols  holding the list of symbols in
the leaves of n   and a field n  mfsets  holding a list of the connected components of
the symbols in n   as described below  each connected component is implemented as
an merge find set  mfset  

 an edge e in the graph over symbols contains its two endpoints  each of which is a

symbol  a field e  shorts  a list of the constraints in which e appears as a short  and
a field e  longs  a list of the constraints in which e appears as a long 

 a constraint c has two fields  c  short and c  long  both of them edges  it also has

pointers into the lists c  short shorts and c  long longs  enabling c to be removed in
constant time from the constraint lists associated with the individual edges 

 we will use the disjoint set forest implementation of mfsets  cormen  leiserson 

and rivest        p       with merging smaller sets into larger and path compression 
thus  each mfset is a upward pointing tree of symbols  each node of the tree being
a symbol  the tree as a whole is represented by the symbol at the root  a symbol a
has then the following fields 

 
 
 
 

a parent is a pointer to the parent in the mfset tree 
a cluster leaf is a pointer to the leaf in the cluster tree containing a 
if a is the root of the mfset then a size holds the size of the mfset 
if a is the root of the mfset  then a symbols holds all the elements of the
mfset 

  

fidavis

  if a is the root of the mfset then a leaf ptr holds a pointer to the pointer to
a in n  mfsets where n   a cluster leaf 
we can now describe the algorithm 
procedure

variables 

  
  
  
  
  
  
  
  

begin if

  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

solve constraints  in s   a system of constraints of the form od a  b   od c  d   
return either a cluster tree t satisfying s if s is consistent 
or false if s is inconsistent 
m is an integer 
a  b are symbols 
c is a constraint in s  
h is an undirected graph 
e  f are edges 
p is an mfset 
n  m are nodes of t  

s contains any constraint of the form   od a  b   od c  c   then return false 

h      

each constraint c in s with short e and long f
add e and f to h  
add c to e  shorts and to f  longs endfor 
m    the number of variables in s  
initialize t to contain the root n  
n  symbols    the variables in s  
for

do

each leaf n of t   initialize mfsets n   
each edge e   ab in h do
if e  shorts is non empty and find a     find b  then
merge find a   find b   endif endfor
if every edge e   ab in h satisfies find a    find b 

repeat for
for

then return false  endif

for

each current leaf n of t do
if n  mfsets has more than one element then
for each mfset p in n  mfsets do
construct node m as a new child of n in t  
m  symbols   p  symbols 
endfor endif endfor

each edge e   ab in h do
if find a     find b  then
for each constraint c in e  longs do
delete c from s  
delete c from e  longs 
delete c from c  short shorts endfor
delete e from h endif endfor
m    m   
until s is empty 
for

for

each leaf n of t
n  label      
if n  symbols has more than one symbol
  

fiorder of magnitude comparisons of distance

   
   

create a leaf of n with label   for each symbol in n  symbols 
solve constraints  

then
endif endfor end

initialize mfsets n   node 
  symbol 
n  mfsets      
for a in n  symbols do
a parent    null 
a cluster leaf    n  
a symbols    fag 
a size      
n  mfsets    cons a n  mfsets  
a leaf ptr    n  mfsets 
endfor end initialize mfsets 
procedure
var a

merge in a  b   symbol 
 size
 size then swap a  b   
a parent    b  
b  size    b  size   a size 
b  symbols    b  symbols   a symbols 
using a leaf ptr  delete a from a cluster leaf mfsets 
end merge 
procedure
if a
 b

find in a   symbol  return symbol 
  symbol 
 parent   null then return a
   find a parent  
a parent    r     path compression   
return r 
end find 
procedure
var r
if a
else r

let n be the number of symbols in s   let e be the number of edges  and let s be the
number of constraints  note that n    e  n n      and that e    s  e e      
the running time of solve constraints  can be computed as follows  as each iteration of the
main loop      splits at least one of the connected components of h   there can be at most
n   iterations  the merge find operations in the for loop      take together time
at most o max nff n   e   where ff n  is the inverse ackermann s function  each iteration
of the inner for loop lines       creates one node m of the tree  therefore  there are
only o n  iterations of this loop over the entire algorithm  lines        of the outer for
loop require at most n iterations in each iteration of the main loop  the for loop      
is executed exactly once in the course of the entire execution of the algorithm for each
constraint c   and hence takes at most time o s  over the entire algorithm  steps      
require time o e  in each iteration of the main loop  it is easily verified that the remaining
operations in the algorithm take no more time than these  hence the overall running time
is o max n  ff n   ne  s   

  

fidavis

    adding non strict comparisons
the algorithm solve constraints can be modified to deal with non strict comparisons of the
form od a  b   od c  d  by  intuitively  marking the edge ab as  short  on each iteration if
the edge cd has been found to be short 
specifically  in algorithm solve constraints  we make the following two changes  first 
the revised algorithm takes two parameters  s   the set of strict constraints  and w   the set
of non strict constraints  second  we replace the line
h    the connected components of the shorts of s

with the following code 

  
  
  
  
  

h    the shorts of s  
repeat h    the connected components of h  
for each weak constraint od a  b   od c  d 
if cd is in h then add ab to h endif endfor
until no change has been made to h in the last iteration 

the proof that the revised algorithm is correct is only a slight extension of the proof of
theorem   and is given in the appendix 
optimizing this algorithm for eciency is a little involved  not only because of the new
operations that must be included  but also because there are now four parameters   n  the
number of symbols  e  the number of edges mentioned  s  the number of strict comparison 
and w  the number of non strict comparisons   and the optimal implementation varies
depending on their relative sizes  in particular  either s or w  though not both  may be
much smaller than n  and each of these cases requires special treatment for optimal eciency 
the best implementation we have found for the case where both s and w are 
 n  has a
running time of o max n    nw  s    the details of the implementation are straightforward
and not of sucient interest to be worth elaborating here 
an immediate consequence of this result is that a couple of problems of inference are
easily computed 

 to determine whether a constraint c is the consequence of a set of constraints s  
form the set s    c and check for consistency  if s    c is inconsistent then sj c  
note that the negation of the constraint od a  b   od c  d  is the constraint
od c  d   od a  b  
 to determine whether two sets of constraints are logically equivalent  check that each
constraint in the first is a consequence of the second  and vice versa 

    adding order constraints
example   of section   involves a combination of order of magnitude constraints on distances together with simple ordering on points  where the points lie on a one dimensional
line  we next show how to extend algorithm solve constraints to deal with this more complex situation 

  

fiorder of magnitude comparisons of distance

in terms of the axiomatics  adding an ordering on points involves positing that the
relation p   q is a total ordering and that the ordering of points is related to order of
magnitude comparisons of distances through the following axiom 
a   for points a  b  c   p   if a   b   c then od a  b   od a  c  
the following rule is easily deduced  if c and d are disjoint clusters  then either every
point in c is less than all the points in d  or vice versa 
in extending our algorithm  we begin by defining an ordered cluster tree to be a cluster
tree where  for every internal node n   there is a partial order on the children of n   if a
and b are children of n and a is ordered before b   then in an instantiation of the tree 
every leaf of a must precede every leaf of b   procedure instantiate  can then be modified
to deal with ordered cluster trees as follows 

instantiate  in n   a node in a cluster tree  
   an om space          k   orders of magnitude 
in out g   array of points indexed on the nodes of t  
if n is not a leaf then
let c        cp be the children of n in topologically sorted order 
x     g n   
q    n  label 
pick points x        xp in increasing order such that
for all i  j           p  if i    j then od xi   xj     q  
   such points can be chosen by virtue of axiom a     
for i           p do
g ci      xi  
instantiate  ci   
          k   g 
endfor
endif end

instantiate  

algorithm solve constraints is modified as follows 
procedure

fnewg

variables 

begin if

solve constraints  in s   a system of constraints of the form od a  b   od c  d   
o   a system of constraints of the form a   b 
return either an ordered cluster tree t satisfying s
if s is consistent 
or false if s is inconsistent 
m is an integer 
c is a constraint in s  
h  i are undirected graphs 
m  n  p are nodes of t  
a  b  c  d are symbols 

s contains any constraint of the form   od a  b   od c  c  

then return false

 

fnewg if o is internally inconsistent  contains a cycle  then return false 
m    the number of variables in s  
initialize t to consist of a single node n  
n  symbols   the variables in s  
repeat

h    the connected component of the shorts of s  

  

fidavis

fnewg

h    incorporate order h  o  
if h contains all the edges in s
for

then return false

each leaf n of t do
if not all vertices of n are connected in h then
n  label    m 
for each connected component i of n  symbols in h do
construct node m as a new child of n in t  
m  symbols   the vertices of i  
endfor endif

fnewg
fnewg
fnewg
fnewg
fnewg

for

each constraint a   b   o
if a is in m  symbols and b is in p  symbols
where m and p are different children of n
then add an ordering arc from m to p  
endif endfor

endfor

s    the subset of constraints in s whose long is in h  
m    m   
until
for

s is empty 

each leaf n of t
n  label      
if n  symbols has more than one symbol
then create a leaf of n for each symbol in n  symbols 
label each such leaf   
endif endfor

end

solve constraints  

fnewg

function

incorporate order in h   undirected graph 
o   a system of constraints of the form a   b 
return undirected graph 

variables 

g   directed graph 
a  b   vertices in h  
a  b   connected components of h  
v  a    array of vertices of g indexed on connected components of h  
i   subset of vertices of g 

connected component a of h create a vertex v  a  in g 
constraint a   b   o
let a and b be the connected components of h containing a and b respectively 
if a    b then add an arc in g from v  a  to v  b   endif endfor 
for each strongly connected component i of g do
for each pair of distinct vertices v  a   v  b     i do
for each a   a and b   b add the edge ab to h endfor endfor

for each
for each

endfor

  

fiorder of magnitude comparisons of distance

end

incorporate order 

function incorporate order serves the following purpose  suppose that we are in the
midst of the main loop of solve constraints   we have a partially constructed cluster tree 
and we are currently working on finding the sub clusters of a node n   as in the original
form of solve constraints  we find the connected components of the shorts of the order ofmagnitude constraints  let these be c        cq   then we know that the diameter of each ci
is much smaller than the diameter of n   now  suppose  for example  that we have in o the
constraints a    a    b    b    c    c    where a    c    c    b    c    c    and a    b    c    then
it follows from axiom a   that c    c    and c  must all be merged into a single cluster 
whose diameter will be less than the diameter of n   procedure incorporate order finds all
such loops by constructing a graph g whose vertices are the connected components of h
and whose arcs are the ordering relations in o and then computing the strongly connected
components of g   recall that two vertices u  v in a directed graph are in the same strongly
connected component if there is a cycle from u to v to u   it then merges together all of
the connected components of h that lie in a single strongly connected component of g 
the proof of the correctness of algorithm solve constraints  is again analogous in structure to the proof of theorem    and is given in the appendix 
by implementing this in the manner of section      the algorithm can be made to run
in time o max n  ff n   ne  no  s    where o is the number of constraints in o 

   finite order of magnitude comparison
in this section  it is demonstrated that algorithm solve constraints can be applied to systems
of constraints of the form  dist a  b    dist c  d    b   for finite b in ordinary euclidean
space as long as the number of symbols in the constraint network is smaller than b  
we could be sure immediately that some such result must apply for finite b   it is
a fundamental property of the non standard real line that any sentence in the first order
theory of the reals that holds for all infinite values holds for any suciently large finite
value  and that any sentence that holds for some infinite value holds for arbitrarily large
finite values  hence  since the answer given by algorithm solve constraints works over a
set of constraints s when the constraint  od a  b   od c  d   is interpreted as  od a  b 
  od c  d  b for infinite b    the same answer must be valid for suciently large finite b  
what is interesting is that we can find a simple characterization of b in terms of s   namely 
that b is larger than the number of symbols in s  
we begin by modifying the form of the constraints  and the interpretation of a cluster
tree  first  to avoid confusion  we will use a four place predicate  much closer a  b  c  d  
rather than the form  od a  b   od c  d   as we are not going to give an interpretation to
 od  as a function  we fix a finite value b      and interpret  much closer a  b  c  d   to
mean  dist a  b    dist c  d    b   
we next redefine what it means for a valuation to instantiate a cluster tree 

definition    let t be a cluster tree and let be a valuation on the symbols in t   we say
that  t if the following holds  for any symbols a  b  c  d in t   let m be the least common
ancestor of a  b and let n be the least common ancestor of c  d  if m  label   n  label then
much closer a  b  c  d  

  

fidavis

procedure  instantiate   which generates an instantiation of a cluster tree  is modified
as follows 
procedure

instantiate in t   cluster tree  
   euclidean space  b   real  
return   array of points indexed on the symbols of t  

let n be the number of nodes in t  
ff         n   bn 
choose             n such that i   i    ff 
pick a point x   
 
g t      x 
instantiate  t  
          n   g  
return the restriction of g to the symbols of t  
end instantiate 
instantiate  in n   a node in a cluster tree  
   a euclidean space 
        n   orders of magnitude 
in out g   array of points indexed on the nodes of t  
if n is not a leaf then
let c        cp be the children of n  
x     g n   
q    n  label 
pick points x        xp such that
for all i  j           p  if i    j then q  dist xi   xj     nq
   this is possible since p  n    
for i           p do
g ci      xi  
instantiate  ci   
          n   g 
endfor
endif end

instantiate  

the analogue of lemma   holds for the revised algorithm 
lemma     any cluster tree t has an instantiation in euclidean space  m of any dimensionality m 
we can now state theorem    which asserts the correctness of algorithm  solve constraints 
in this new setting 

theorem    let s be a set of constraints over n variables of the form  dist a  b   
dist c  d    b    where b   n  the algorithm solve constraints s   returns a cluster tree
satisfying s if s is consistent over euclidean space  and returns false if s is inconsistent 
the proofs of lemma    and theorem   are given in the appendix 
an examination of the proof of lemma    shows that this result does not depend on
any relation between n and b   therefore  if solve constraints s   returns a tree t   then s
is consistent and t satisfies s regardless of the relation between n and b   however  it is
possible for s to be consistent and solve constraints s   to return false if n  b   on the
other hand  one can see from the proof of theorem    particularly lemma     that if b   n
and solve constraints s   returns false then s is inconsistent in any metric space  however 
there are metric spaces other than  m in which the cluster tree returned by solve constraints
may have no instantiation 

  

fiorder of magnitude comparisons of distance

   the first order theory
our final result asserts that if the om space is rich enough then the full first order language
of order of magnitude distance comparisons is decidable  specifically  if the collection of
orders of magnitude is dense and unbounded above  then there is a decision algorithm for
first order sentences over the formula   od w  x    od y  z    that runs in time o  n  n    s 
where n is the number of variables in the sentence and s is the length of the sentence 
the basic reason for this is the following  as we have observed in corollary    a cluster
tree t determines the truth value of all constraints of the form  od a  b   od c  d   where
a  b  c  d are symbols in the tree  that is  any two instantiations of t in any two omspaces agree on any such constraint  if we further require that the om spaces are dense
and unbounded  then a much stronger statement holds  any two instantiations of t over
such om spaces agree on any first order formula free in the symbols of t over the relation
 od w  x    od y  z     hence  it suces to check the truth of a sentence over all possible
cluster trees on the variables in the sentence  since there are only finitely many cluster
trees over a fixed set of variables  taking into account only the relative order of the labels
and not their numeric values   this is a decidable procedure 
let l be the first order language with equality with no constant or function symbols 
and the single predicate symbol  much closer a  b  c  d    it is easily shown that l is as
expressive as the language with the function symbol  od  and the relation symbol  

definition    an om space 
 with orders of magnitude
following axiom 

d is dense if it satisfies the

a   for all orders of magnitude      in d  there exists a order of magnitude   in d
such that          

 is unbounded above if it satisfies the following 
a    for every order of magnitude   in d there exists   in d such that       
if d is the collection of orders of magnitude in the hyperreal
line  then both of these
p
are satisfied  in axiom  a     if           choose           the geometric mean 
if            choose        where      in axiom  a     choose         where
        

definition    let t be a cluster tree  let l       l    l        lk be the distinct labels in t
in ascending order  an extending label for t is either  a  li for some i   b  lk      note that
lk is the label of the root    c   li     li     for some i between   and k 
note that if t has k distinct non zero labels  then there are  k     different extending
labels for t  

definition    let t be a cluster tree  let x be a symbol not in t   the cluster tree
 
t extends t with x if t   is formed from t by applying one of the following operations  a
single application of a single operation  
   t is the null tree and t   is the tree containing the single node x 

  

fidavis

   t consists of the single node for symbol y  make a new node m   make both x and y
children of m   and set the label of m to be either   or   
   for any internal node n of t  including the root   make x a child of n  
   let y be a symbol in t   and let n be its father  if n  label       create a new node m
with an extending label for t such that m  label   n  label  make m a child of n  
and make x and y children of m  
   let c be an internal node of t other than the root  and let n be its father  create
a new node m with an extending label for t such that c  label   m  label   n  label 
make m a child of n and make x and c children of m  
   let r be the root of t   create a new node m such that m  label   r label      make
r and x children of m   thus m is the root of the new tree t    
 see figure    
note that if t is a tree of n symbols and at most n   internal nodes then

 there are n   ways to carry out step   
 there are n possible ways to choose symbol y in step    and at most  n   for the
label on m in each 

 there are at most n   different choices for c in step    and at most  n   choices
for the label on m in each 

 there is only one way to carry out step   
hence  there are less than  n  different extensions of t by x   this is almost certainly
an overestimate by at least a factor of    but the final algorithm is so entirely impractical
that it is not worthwhile being more precise  

definition     let t be a cluster tree  and let  be a formula of l open in the variables
of t   t satisfies  if every instantiation of t satisfies  
theorem    let t be a cluster tree  let  be an open formula in l  whose free variables
are the symbols of t   let 
 be an om space that is dense and unbounded above  algorithm
decide t    returns true if t satisfies  and false otherwise 

decide t   cluster tree     formula  return boolean
convert  to an equivalent form in which the only logical symbols in  are
   not      and      exists      equals  and variable names 
and the only non logical symbol is the predicate  much closer  
function

case

 has form x   y   return  distance x  y  t        
 has form  much closer w  x  y  z     return distance w  x  t     distance y  z  t    
 has form     return not decide t    
 has form     return decide t    and decide t    
 has form  x ff 

  

fiorder of magnitude comparisons of distance

p

p

p

 

 

 
w

q

q

 

w

q

w

x

 

 

u

u

v

u

v

v

x

operation   

operation   
original t

n   p

n   q

p
 
w

q
 

p

p

 

 
w

q
 

operation   

operation   
y v

y u

m

q

           

 
u

v

m

m
     

     

u

u

v

x

w

operation   

x

y w

m
p

 

 
x
m

w

p
 

   
operation   
x

w

q
 

c q  n p

q
 
u

u

v

v

v
operation   
r p

figure    extensions of a cluster tree

  

x

fidavis

extension

of by   decide t   ff    true

if for some
t  t x
then return true
else return false endif endcase

end

 

decide

distance x  y   symbol  t   cluster tree  return
n    the common ancestor of x and y in t  
return n  label 
function

end

integer

distance

the proof of theorem   is given in the appendix 
running time  as we have remarked above  for a tree t of size k there are at most  k 
extensions of t to be considered  the total number of cluster trees considered is therefore
bounded by nk    k     n  n      it is easily verified that the logical operators other than
quantifiers add at most a factor of s where s is the length of the sentence  hence the running
time is bounded by o  n  n    s  
a key lemma  of interest in itself  states the following 
lemma     let t be a cluster tree  let  be an open formula in l  whose free variables
are the symbols of t   let 
 be an om space that is dense and unbounded above  if one
instantiation of t in 
 satisfies  then every instantiation of t in 
 satisfies  
that is  either  is true for all instantiations of t or for none  the proof is given in the
appendix 
it should be observed that the above conditions on 
 in lemma    are necessary  and
that the statement is false otherwise  for example  let 
 be the om space described in
example i  section    of polynomials over an infinitesimal   then 
 is not unbounded
above  there is a maximum order of magnitude o     let t be the starting tree of figure
   upper left corner   let  be the formula   x od v  w    od w  x     free in v and w  
then the valuation fu     v      w    g satisfies t but not   whereas the valuation
fu       v        w   g satisfies both t and  

   conclusions
the applications of the specific algorithms above are undoubtedly limited  we are not aware
of any practical problems where solving systems of order of magnitude relations on distances
is the central problem  however  the potential applications of order of magnitude reasoning
generally are very widespread  ordinary commonsense reasoning involves distances spanning a ratio of about       from a fraction of an inch to thousands of miles  and durations
spanning a ratio of about        from a fraction of a second to a human lifetime  scientific
reasoning spans much greater ranges  explaining the dynamics of a star combines reasoning
about nuclear reactions with reasoning about the star as a whole  these differ by a ratio
of about        the techniques needed to compute with quantities of such vastly differing
sizes are quite different from the techniques needed to compute with quantities all of similar
sizes  this paper is a small step in the development and analysis of such computational
techniques 
the above results are also significant in the encouragement that they give to the hope
that order of magnitude reasoning specifically  and qualitative reasoning generally  may lead

  

fiorder of magnitude comparisons of distance

to useful quick reasoning strategies in a broader range of problems  it has been often found
in ai that moving from greater to lesser precision in the mode of inference or type of
knowledge does not lead to quick and dirty heuristic techniques  but rather to slow and
dirty techniques  nonmonotonic reasoning is the most notorious example of this  but it
arises as well in many other types of automated reasoning  including qualitative spatial and
physical reasoning  the algorithms developed in this paper are a welcome exception to
this rule  we are currently studying algorithmic techniques for other order of magnitude
problems  and are optimistic of finding similar favorable results 

acknowledgements
this research has been supported by nsf grant  iri          thanks to ji ae shin 
andrew gelsey  and the reviewers for helpful comments 

appendix a  proofs
in this appendix  we give the proofs of the various results asserted in the body of the paper 

proof of lemma  
lemma    if t is a cluster tree and 
 is an om space  then instantiate t  
  returns an
instantiation of t  
proof  let        for any node n   if i n  label  we define  n     i   the proof then
proceeds in the following steps 
i  for any nodes m  n   if m is a descendant of n in t then od g m    g n      n   
proof  if m is a child of n   then this is immediate from the construction of x        xp
in instantiate   else  let n   n    n        nq   m be the path from n to m through
t   by the definition of a cluster tree  it follows that ni  label   n  label  for i     and
therefore  ni     n    thus od g m    g n      by the o m  triangle inequality 
maxi     q    od g ni      g ni      maxi     q     ni     since ni   is the child of
ni     n   
ii  let n be a node in t   let c  and c  be two distinct children of n   and let m 
and m  be descendants of c  and c  respectively  then od g m     g m        n   
proof  by the construction of x        xp in instantiate  n    od g c     g c        n   
by part  i    od g m     g c       c      n   and likewise od g m     g c     
 n    hence  by axiom a    od g m     g m        n   
iii  let a and b be any two leaves in t   and let n be the least common ancestor in t of
a and b  then od g a   g b      n    proof  immediate from  ii  
iv  for any node n   odiam   n       n    proof  from  iii   any two leaves descending
from different children of n are at a distance of order  n    and no two leaves of n
are at a distance of order greater than  n   

  

fidavis

v  for any node n    n   is a cluster of  t    proof  let a and b be leaves of n  
and let c be a leaf of t n   let i be the common ancestor of a and b in t and
let j be the common ancestor of a and c  then i is either n or a descendant of n
and j is a proper ancestor of n   therefore by part  i    i     j    but by  iii  
od   a    b      i     j     od   a    c   
vi  for any internal nodes n  m if m  label   n  label then odiam   m     odiam   n    
proof  immediate from  iv  and the construction of  
vii  if c is a cluster of  t   then there is a node n in t such that c    n    proof  let
s be the set of symbols corresponding to c and let n be the least common ancestor
of all of s   let a and b be two symbols in s that are in different subtrees of n   then
by  iii   od g a   g b      n    let x be any symbol in n  symbols  then by  iii 
od g a   g x     n    hence g x    c  

 
proof of theorem  
we here prove the correctness of algorithm solve constraints  we will assume throughout
that the two variables in the long of any constraint in s are distinct 
lemma    let t be a cluster tree and let be an instantiation of t   let a and b be
symbols of t   let n be the least common ancestor of a and b in t   then od   a    b    
odiam   n    
proof  since  a  and  b  are elements of  n    it follows from the definition of odiam that
od   a    b    odiam   n     suppose the inequality were strict  that is  od   a    b  
 odiam   n     then let c be the set of all the symbols c of t such that od   a    c  
 od   a    b    then odiam   c      od   a    b    odiam   n     it is easily shown
that  c   is a cluster in  t    therefore  by property  ii  of definition    there must be
a node m such that m  symbols   c   now  m is certainly not an ancestor of n   since
odiam   m     odiam   n    but m  symbols contains both a and b  but this contradicts
the assumption that n was the least common ancestor of a and b   
corollary    let t be a cluster tree and let be an instantiation of t   let a  b  c  d be
symbols of t   let n be the least common ancestor of c and d in t   and let m be the
least common ancestor of a and b in t   then od   a    b    od   c    d   if and only if
m  label   n  label 
proof  immediate from lemma   and property  iii  of definition   of instantiation   

lemma    let s be any set of constraints of the form od a  b   od c  d   let h be the
connected components of the shorts of s   if s is consistent  then not every edge of s is in
h 
proof  let be a valuation satisfying s   find an edge pq in s for which od   p    q   is
maximal  now  if ab is a short of s   that is  there is a constraint od a  b   od c  d  in
s   then od   a    b    od   c    d    od   p    q   

  

fiorder of magnitude comparisons of distance

now  let ab be any edge in h   the connected components of the shorts of s   then there
is a path a    a  a        ak   b such that the edge ai ai   is a short of s for i           k   
thus  by the om triangle inequality  od   a    b    maxi    k   od   ai     ai       
od   p    q    hence pq    ab  so pq is not in h    

lemma    the values of s and h in any iteration are supersets of their values in any later
iteration 

proof  s is reset to a subset of itself at the end of each iteration  h is defined in terms of
s in a monotonic manner   

s cannot be the same in two successive iterations of the main loop 
proof  by contradiction  suppose that s is the same in two successive iterations  then h
will be the same  since it is defined in terms of s   h is constructed to contain all the shorts
of s   since the resetting of s at the end of the first iteration does not change s   h must
contain all the longs as well  thus  h contains all the edges in s   but that being the case 
the algorithm should have terminated with failure at the beginning of the first iteration   
lemma   

lemma    algorithm solve constraints always terminates 
proof  by lemma    if the algorithm does not exit with failure  then on each iteration some
constraints are removed from s   hence  the number of iterations of the main loop is at
most the original size of s   everything else in the algorithm is clearly bounded   note that
this bound on the number of iterations is improved in section     to n    where n is the
number of symbols    

lemma    if algorithm solve constraints returns false  then s is inconsistent 

proof  if the algorithm returns false  then the transitive closure of the shorts of s contains
all the edges in s   by lemma    s is inconsistent 

lemma     if constraint c of form od a  b   od c  d  is in the initial value of s   and
edge cd is in h in some particular iteration  then constraint c is in s at the start of that
iteration 
proof  suppose that c is deleted from s on some particular iteration  then edge cd  the
long of c   cannot be in h in that iteration  that is  it is not possible for edge cd to persist
in h in an iteration after c has been deleted from s   note that  by lemma    once cd is
eliminated from h   it remains out of h    
lemma     the following loop invariant holds  at the end of each loop iteration  the
values of l symbols  where l is a leaf in the current state of the tree  are exactly the
connected components of h  

proof  in the first iteration  t is initially just the root r  containing all the symbols  and
a child of r is created for each connected component of h  
let ti and hi be the values of t and h at the end of the ith iteration  suppose that
the invariant holds at the end of the kth iteration  by lemma    hk   is a subset of hk  
hence  each connected component of hk   is a subset of a connected component of hk  

  

fidavis

moreover  each connected component j of hk is either a connected component of hk   or
is partitioned into several connected components of hk     in the former case  the leaf of
tk corresponding to j is unchanged and remains a leaf in tk     in the latter case  the leaf
corresponding to j gets assigned one child for each connected component of hk   that is a
subset of j   thus  the connected components of hk   correspond to the leaves of tk      

lemma     if procedure solve constraints does not return false  then it returns a wellformed cluster tree t  
proof  using lemma     and the cleanup section of solve constraints which creates the final
leaves for symbols  it follows that every symbol in s ends up in a single leaf of t   as m is
decremented on each iteration  and as no iteration adds both a new node and children of
that node  it follows that the label of each internal node is less than the label of its father 
hence the constraints on cluster trees  definition    are satisfied   
lemma     let a  b be two distinct symbols in s and let t be the cluster tree returned
by solve constraints for s   let n be the least common ancestor of a  b in t   then either n
is assigned its label on the first iteration when the edge ab is not in h   or the edge ab is in
the final value of h when the loop is exited and n is assigned its label in the final cleanup
section 
proof  as above  let hi be the value of h in the ith iteration 
if n is the root  then it is assigned its label in the first iteration  clearly  a and b  being
in different subtrees of n   must be in different connected components of h   
suppose n is assigned its label in the kth iteration of the loop for k      by lemma    
at the end of the previous iteration  n  symbols was a connected component of hk     and it
therefore contained the edge ab  since n is the least common ancestor of a  b  it follows that
a and b are placed in two different children of n   hence  they are in two different connected
components of hk   thus the edge ab cannot be in hk  
suppose n is assigned its label in the cleanup section of the algorithm  then by lemma
    n  symbols is a connected component of the final value of h   hence the edge ab was in
the final value of h    
lemma     let s initially contain constraint c of form od a  b   od c  d   suppose that
solve constraints s   returns a cluster tree t   let m be the least common ancestor of a  b
in t and let n be the least common ancestor of c  d  then m  label   n  label 
proof  suppose n is given a label in a given iteration  by lemma     cd is eliminated
from h in that same iteration  by lemma     constraint c must be in s at the start of the
iteration  hence ab is a short of s in the iteration  and is therefore in h   hence m is not
given a label until a later iteration  and therefore is given a lower label 
it is easily seen that cd cannot be in h in the final iteration of the loop  and hence n
is not assigned its label in the cleanup section   
lemma     suppose that solve constraints s   returns a cluster tree t   then any instantiation of t satisfies the constraints s  
proof  immediate from lemma    and corollary   

  

fiorder of magnitude comparisons of distance

theorem    the algorithm solve constraints s   returns a cluster tree satisfying s if s is
consistent  and returns false if s is inconsistent 
proof  if solve constraints s   returns false  then it is inconsistent  lemma     if it does
not return false  then it returns a cluster tree t  lemma      since t has an instantiation
 lemma    and since every instantiation of t is a solution of s  lemma      it follows that
s is consistent and t satisfies s    
proof of theorem  
lemma     if s  and s  are consistent sets of constraints  and s   s  then
reduce constraints s     reduce constraints s    
proof  immediate by construction  the value of h in the case of s  is a superset of its value
in the case of s    and hence reduce constraints s    is a superset of reduce constraints s    
lemma     if s  and s  are consistent sets of constraints  and s   s  then num labels s  
 num labels s   
proof by induction on num labels s    if num labels s        the statement is trivial 
suppose that the statement holds for all s     where num labels s      k 
let num labels s     k     
then k       num labels s          num labels reduce constraints s      so
k  num labels reduce constraints s      now  suppose s   s    by lemma   
reduce constraints s     reduce constraints s     but then by the inductive hypothesis
num labels reduce constraints s      num labels reduce constraints s      so
num labels s    num labels s     
lemma     let s be a set of constraints  and let be a solution of s   for any graph g
over the symbols of s   let nd g    be the number of different non zero values of od a  b 
where edge ab is in g  let edges s   be the set of edges in s   then nd edges s      
num labels s   
proof  by induction on num labels s    if num labels s        then the statement is trivial 
suppose for some k  the statement holds for all s   where num labels s      k  and suppose
num labels s     k      let pq be the edge in s of maximal length  for any set of edges e  
let small edges e    be the set of all edges ab in e for which
od   a    b    od   p    q    since small edges e   contains edges of every order of
magnitude in e except the order of magnitude of pq  it follows that
nd small edges e         nd e       let g be the complete graph over all the symbols
in s   by the same argument as in lemma    small edges g     h   where h is the connected
components of the shorts of s   as computed in reduce constraints s    let s   be the set of
constraints whose longs are in small edges g     it follows that s    reduce constraints s   
now small edges g     edges s      edges reduce constraints s    
hence nd edges s        nd g      nd small edges g          
 nd edges reduce constraints s           by the inductive hypothesis 
num labels reduce constraints s          num labels s     

  

fidavis

theorem    out of all solutions to the set of constraints s   the instantiations of
solve constraints s   have the fewest number of different values of od a  b   where a  b range
over the symbols in s   this number is given by num labels s   
proof  immediate from lemma    
corollary     let 
 have all the properties of an om space except that it has only k
different orders of magnitude  a system of constraints s has a solution in 
 if and only if
the tree returned by solve constraints s   uses no more than k different labels 
proof  immediate from theorems   and     
proof of algorithm for non strict comparisons
we now prove that the revised algorithm presented in section     for non strict comparisons
is correct  the proof is only a slight extension of the proof of theorem    given above 
recall that the revised algorithm in section     replaces the line of solve constraints
h    the connected components of the shorts of s
with the following code 

  
  
  
  
  

h    the shorts of s  
repeat h    the connected components of h  
for each weak constraint od a  b   od c  d 
if cd is in h then add ab to h endif endfor
until no change has been made to h in the last iteration 

we need the following new lemmas and proofs 

lemma     let s be a set of strict comparisons  and let w be a set of non strict comparisons  let h be the set of edges output by the above code  if s   w is consistent  then
there is an edge in s that is not in h  
proof  as in the proof of lemma    let be a valuation satisfying s   w and let pq be
an edge in s such that od   p    q   is maximal  we wish to show that  for every edge
ab   h   od   a    b    od   p    q    and hence ab    pq  proof by induction  suppose
that this holds for all the edges in h at some point in the code  and that ab is now to be
added to h   there are three cases to consider 

 ab is added in step      then  as in lemma    there is a constraint od a  b   od c  d 
in s   hence od   a    b    od   c    d    od   p    q   
 ab is added in step      then there is a path a    a  a        ak   b such that the edge
ai ai   is in h for i           k    by the inductive hypothesis  od   ai     ai      
od   p    q    by the om triangle inequality 
od   a    b    maxi    k   od   ai     ai        od   p    q   

 ab is added in step      then there is a constraint od a  b   od c  d  in w such that
cd is in h   by the inductive hypothesis  od   c    d    od   p    q   
  

fiorder of magnitude comparisons of distance

 

lemma     let w contain the constraint od a  b   od c  d   suppose that the algorithm
returns a cluster tree t   let m be the least common ancestor of a and b in t   and let n
be the least common ancestor of c and d  then m  label  n  label 
proof  by lemma     n is assigned a label in the first iteration where h does not include
the edge cd  in all previous iterations  since cd is in h   ab will likewise be put into h  
hence m does not get assigned a label before n   so m  label  n  label 
the remainder of the proof of the correctness of the revised algorithm is exactly the
same as the proof of theorem   
validation of algorithm solve constraints 
the proof of the correctness of algorithm solve constraints  is again analogous in structure
to the proof of theorem    we sketch it below  the details are not dicult to fill in 
    analogue of lemma     if t is an ordered cluster tree  then the revised version of
instantiate t   returns an instantiation of t   the proof is exactly the same as lemma
   with the additional verification that instantiate  preserves the orderings in t  
    analogue of lemma     let s be a set of order of magnitude constraints on distances 
and let o be a set of ordering constraints on points  let h be the graph given by the
two statements

h    the connected components of the shorts of s  
h    incorporate order h  o  
if s and o are consistent  then h does not contain all the edges of s  
proof  as in the proof of lemma    choose a valuation satisfying s   o and let pq be
an edge in s for which od   p    q   is maximal  following the informal argument
presented in section      it is easily shown that pq is longer than any of the edges
added in these two statements  and hence it is not in h  
    analogue of lemma     if solve constraints  returns false  then s   o is inconsistent 
proof  immediate from     
    analogue of lemma      if solve constraints  s   o  does not return false  then it
returns a well formed ordered cluster tree 
proof  by merging the strongly connected components of g  incorporate order always
ensures that the ordering arcs between connected components of h form a dag  these
arcs are precisely the same ones that are later added among the children of node n as
ordering arcs  thus  the ordering arcs over the children of a node in the cluster tree
form a dag  otherwise  the construction of the tree t is the same as in lemma    
the remainder of the proof is the same as the proof of theorem   

  

fidavis

proof of theorem  
we begin by proving lemma     that the revised version of  instantiate   given in section
     gives an instantiation of a cluster tree in euclidean space 
lemma     any cluster tree t has an instantiation in euclidean space  m of any dimensionality m 
the proof is essentially the same as the proof of lemma    except that we now have
to keep track of real quantities  for any node n   if i n  label  we define  n     i   the
proof then proceeds in the following steps 
i  for any i   j   i   j  ffj i   immediate by construction 
ii  for any nodes m  c   if m is a descendant of c in t then
dist g m    g c      ffn c    ff    
proof  let c   c    c        cr   m be the path from p
c to m through t   then
dist 
the triangle inequality  ri    dist g ci     g ci    
pr  g n m   cg   ffc   i     by
 ff  ff     n c    
i  
iii  let n be a node in t   let c  and c  be two children of n   and let m  and m  be
descendants of c  and c  respectively  then
 n      n  ff       dist g m    g m       n n          ff    
proof  by the triangle inequality 
dist g c     g c      dist g c     g m       dist g m     g m       dist g m     g c     
thus  dist g c    g c     dist g c    g m     dist g m     g c      dist g m     g m     
also  by the triangle inequality 
dist g m     g m      dist g c    g c       dist g c    g m       dist g m     g c     
by construction   n    dist g c    g c       n n   
and by part  ii   for i         dist g mi   g ci      ffn c    ff      n n    ff   
as  c      n   ff 
iv  for any symbols a  b  c  d in t   let p be the least common ancestor of a  b and let n
be the least common ancestor of c  d  if p  label   n  label then
much closer g a   g b   g c   g d   
proof  by part  iii   dist g a   g b     n p          ff    
and dist g c   g d      n      n  ff      since  p      n   ff and since
ff        n   bn  it follows by straightforward algebra that
dist g a   g b     dist g c   g d     b  

 

we next prove the analogue of lemma   

lemma     let s be a set of constraints over n variables of the form
 dist a  b    dist c  d    b    where b   n  if s is consistent  then there is some edge in s
which is not in the connected components of the shorts of s  
proof  let be a valuation satisfying s   let pq be the edge in s for which dist   p    q  
is maximal  now  if ab is a short of s   that is  there is a constraint much closer a  b  c  d 
in s   then dist   a    b     dist   c    d   b  dist   p    q   b  

  

fiorder of magnitude comparisons of distance

now  let ab be any edge in h   the connected components of the shorts of s   then
there is a simple path a    a  a        ak   b such that the edge ai ai   is a short of s for
i           k    note that k  n  then  by the triangle inequality 
dist   a    b   
dist   a      a       dist   a      a               dist   ak       ak    
 k   dist   p    q     b   dist   p    q  

hence pq    ab  so pq is not in h    

theorem    let s be a set of constraints over n variables of the form  dist a  b    dist c  d 
  b    where b   n  the algorithm solve constraints s   returns a cluster tree satisfying s
if s is consistent over euclidean space  and returns false if s is inconsistent 
proof  note that the semantics of the constraints  much closer a  b  c  d   enters into the
proof of theorem   only in lemmas   and    the remainder of the proof of theorem   has to
do purely with the relation between the structure of s and the structure of the tree  hence 
since we have shown that the analogues of lemmas   and   hold in a set of constraints of
this kind  the same proof can be completed in exactly the same way   
proof of theorem  
lemma     let t be a cluster tree and let be a valuation over om space 
 satisfying t  
let x be a symbol not in t   let a be a point in 
  and let   be the valuation   fx   ag 
then there exists an extension t   of t by x such that   satisfies t    
proof  if t is the empty tree  the statement is trivial  if t contains the single symbol y 
then if a    y  then operation     applies with m  label    if a     y  then operation    
applies with m  label   
otherwise  let y be the symbol in t such that od   y   a  is minimal   we will deal
with the case of ties in step  d  below   let f be the father of y in t  
let d od   y   a   let v be the set of all orders of magnitude od   p    q    where
p and q range over symbols in t   we define l to be the suitable label for d as follows  if
d   v   then l is the label in t corresponding to d  if d is larger than any value in v
then l is the label of the root of t plus    if d    v   but some value in v is larger than d 
then let d  be the largest value in v less than d  let d  be the smallest value in v greater
than d  let l    l  be the labels in t corresponding to d    d    and let l    l    l      
one of the following must hold 
a   y    a  and f  label    then apply operation     with n   f  
b   y    a and f  label       then apply operation     with m  label     
c   y     a  but od   y   a  is less than od   z    a  for any other symbol z  
  y in t  
apply operation     with m  label set to the suitable value for d in t  
d  there is more than one value y        yk for which od   yi    a    d  it is easily shown
that in this case there is an internal node q such that y        yk is just the set of symbols
in the subtree of q  there are three cases to consider 

  

fidavis

d i d odiam   q symbols    then apply operation     with n   q 
d ii d   odiam   q symbols    and q is not the root  then apply operation    
with c   q  set m  label to be the suitable value for d   it is easily shown that
d   odiam   n  symbols    where n is the father of q  
d iii d   odiam   q symbols    and q is the root  apply operation     

 

lemma     let a   fa        ak g be a finite set of points whose diameter has order ofmagnitude d  then there exists a point u such that  for i           k  od u  ai     d 
proof  let b    a    by axiom a   there exists an infinite collection of points b    b       
such that od bi   bj     d for i    j   now  for any value ai there can be at most one value bj
such that od ai   bj    d  if there were two such values bj   and bj    then by the om triangle
inequality  od bj    bj      d  hence  all but k different values of bj are at least d from any
of the ai   let u be any of these values of bj   then since od u  a      d and od a    ai    d
for all i  it follows that od u  ai    d for all ai   thus  since od u  ai    d but not od u  ai  
 d  it follows that od u  ai    d   
lemma     let t be a cluster tree  let be a valuation over om space 
 satisfying t  
and let t   be an extension of t by x  if 
 is dense and unbounded above  then there is a
value a such that the valuation   fx   ag satisfies t    
proof  for operations     and     the statement is trivial 
otherwise  let l be an extending label of t   if l      then set d      if l is in t  
then let d be the order of magnitude corresponding to l in t under   if l    l   l 
where l  and l  are labels of consecutive values in t   then let d  and d  be the orders of
magnitude corresponding to l    l  in t under   let d be chosen so that d   d  d   
if l is greater than any label in the tree  then choose d to be greater than the diameter of
the tree under  
if t   is formed from t by operation      then using lemma    let a be a point such that
od a   y     odiam n   for all y in n  symbols 
if t   is formed from t by operation      then let a be a point such that od a   y    
d 
if t   is formed from t by operation      then let a be a point such that od a   y    
d for all y in c  symbols   note that  since m  label   n  label  d   odiam n  symbols   
if t   is formed from t by operation      then let a be a point such that od a   y    
d for all y in r symbols 
in each of these cases  it is straightforward to verify that   fx   ag satisfies t      
as we observed in section   regarding lemma     the conditions on 
 in lemma   
are necessary  and the statement is false otherwise  for example  let 
 be the om space
described in example i  section    of polynomials over an infinitesimal   then 
 is not
unbounded above  there is a maximum order of magnitude o     let t be the starting tree
of figure    upper left corner   and let t   be the result of applying operation    middle
bottom   let be the valuation fu     v      w    g  then satisfies t   but it cannot
be extended to a valuation that satisfies t     as that would require x to be given a value
such that od v  w   od x  w   and no such value exists within 
  the point of the lemma

  

fiorder of magnitude comparisons of distance

is that  if 
 is required to be both dense and unbounded above  then we cannot get  stuck 
in this way 

lemma     let t be a cluster tree  let x be a variable not among the symbols of t  
let ff be an open formula in l  whose free variables are the symbols of t and the variable
x   let  be the formula  x ff  let 
 be an om space that is dense and unbounded above 
then there exists an instantiation of t in 
 that satisfies  if and only if there exists an
extension t   of t and an instantiation   of t   that extends and satisfies ff 
proof  suppose that there exists an instantiation of t that satisfies  x ff  then  by
definition  there is a point a in 
 such that satisfies ff x a   that is  the instantiation
  fx   ag satisfies ff  let       fx   ag  by lemma     the cluster tree t  
corresponding to   is an extension of t  
conversely  suppose that there exists an extension t   of t and an instantiation   of t  
satisfying ff  let be the restriction of   to the symbols of t   then clearly satisfies the
formula  x ff   
lemma     let t be a cluster tree  let  be an open formula in l  whose free variables
are the symbols of t   let 
 be an om space that is dense and unbounded above  if one
instantiation of t in 
 satisfies  then every instantiation of t in 
 satisfies  
proof  we can assume without loss of generality that the only logical symbols in  are  
 not      and      exists      equals  and variables names  and that the only non logical
symbol is the predicate  much closer   we now proceed using structural induction on the
form of   note that an equivalent statement of the inductive hypothesis is   for any formula
  either is true under every instantiation of t   or is false under every instantiation of
t   
base case  if  is an atomic formula  x   y   or  much closer w  x  y  z    then this
follows immediately from corollary   
let  have the form     if  is true under   then is false under   by the inductive hypothesis  is false under every instantiation of t   hence  is true under every
instantiation of t  
let  have the form     if  is true under then both and  are true under   by
the inductive hypothesis  both and  are true under every instantiation of t   hence  is
true under every instantiation of t  
let  have the form  x ff  if  is true under then by lemma     there exists an
extension t   of t and a instantiation   of t   such that ff is true under     by the inductive
hypothesis  ff is true under every instantiation of t     now  if   is an instantiation of t  
that satisfies ff  and  is the restriction of   to the variables in t   then clearly  satisfies
 x ff  but by lemma     every instantiation  of t can be extended to an instantiation  
of t     therefore  every instantiation of t satisfies    
theorem    let t be a cluster tree  let  be an open formula in l  whose free variables
are the symbols of t   let 
 be an om space that is dense and unbounded above  algorithm
decide t    returns true if t satisfies  and false otherwise 
proof  immediate from the proof of lemma      

  

fidavis

references
cormen  t h   leiserson  c e   and rivest  r l          introduction to algorithms  cambridge  ma  mit press
davis  e          order of magnitude reasoning in qualitative differential equations  in
d  weld and j  de kleer  eds   readings in qualitative reasoning about physical systems 
san mateo  ca  morgan kaufmann          
keisler  j          foundations of infinitesimal calculus  boston  ma  prindle  webber 
and schmidt 
mavrovouniotis  m  and stephanopoulos  g           formal order of magnitude reasoning in process engineering   in d  weld and j  de kleer  eds   readings in qualitative
reasoning about physical systems  san mateo  ca  morgan kaufmann          
raiman  o           order of magnitude reasoning   in d  weld and j  de kleer  eds  
readings in qualitative reasoning about physical systems  san mateo  ca  morgan kaufmann          
robinson  a          non standard analysis  amsterdam  north holland publishing co 
weld  d           exaggeration   in d  weld and j  de kleer  eds   readings in qualitative
reasoning about physical systems  san mateo  ca  morgan kaufmann          

  

fi