journal of artificial intelligence research                  

submitted       published     

 squeaky wheel  optimization
david e  joslin

david joslin i  com

i  technologies
    e  las colinas blvd 
irving  tx      

david p  clements

computational intelligence research laboratory
     university of oregon
eugene  or           

clements cirl uoregon edu

abstract

we describe a general approach to optimization which we term  squeaky wheel  optimization  swo   in swo  a greedy algorithm is used to construct a solution which is
then analyzed to find the trouble spots  i e   those elements  that  if improved  are likely
to improve the objective function score  the results of the analysis are used to generate
new priorities that determine the order in which the greedy algorithm constructs the next
solution  this construct analyze prioritize cycle continues until some limit is reached  or
an acceptable solution is found 
swo can be viewed as operating on two search spaces  solutions and prioritizations 
successive solutions are only indirectly related  via the re prioritization that results from
analyzing the prior solution  similarly  successive prioritizations are generated by constructing and analyzing solutions  this  coupled search  has some interesting properties 
which we discuss 
we report encouraging experimental results on two domains  scheduling problems that
arise in fiber optic cable manufacturing  and graph coloring problems  the fact that these
domains are very different supports our claim that swo is a general technique for optimization 

   overview
we describe a general approach to optimization which we term  squeaky wheel  optimization  swo   joslin   clements         the core of swo is a construct analyze prioritize
cycle  illustrated in figure    a solution is constructed by a greedy algorithm  making decisions in an order determined by priorities assigned to the elements of the problem  that
solution is then analyzed to find the elements of the problem that are  trouble makers   the
priorities of the trouble makers are then increased  causing the greedy constructor to deal
with them sooner on the next iteration  this cycle repeats until a termination condition
occurs 
on each iteration  the analyzer determines which elements of the problem are causing
the most trouble in the current solution  and the prioritizer ensures that the constructor
gives more attention to those elements on the next iteration    the squeaky wheel gets the
grease    the construction  analysis and prioritization are all in terms of the elements that

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fijoslin   clements

analyzer
blame

solution

constructor

priorities

prioritizer

figure    the construct analyze prioritize cycle
define a problem domain  in a scheduling domain  for example  those elements might be
tasks  in graph coloring  those elements might be the nodes to be colored 
the three main components of swo are 

constructor  given a sequence of problem elements  the constructor generates a solution

using a greedy algorithm  with no backtracking  the sequence determines the order
in which decisions are made  and can be thought of as a  strategy  or  recipe  for
constructing a new solution   this  solution  may violate hard constraints  

analyzer  the analyzer assigns a numeric  blame  factor to the problem elements that

contribute to aws in the current solution  for example  if minimizing lateness in
a scheduling problem is one of the objectives  then blame would be assigned to late
tasks 
a key principle behind swo is that solutions can reveal problem structure  by analyzing a solution  we can often identify elements of that solution that work well  and
elements that work poorly  a resource that is used at full capacity  for example  may
represent a bottleneck  this information about problem structure is local  in that it
may only apply to the part of the search space currently under examination  but may
be useful in determining where the search should go next 
prioritizer  the prioritizer uses the blame factors assigned by the analyzer to modify
the previous sequence of problem elements  elements that received blame are moved
toward the front of the sequence  the higher the blame  the further the element is
moved 
the priority sequence plays a key role in swo  as a dicult problem element moves
forward in the sequence it is handled sooner by the constructor  it also tends to be handled
better  thus decreasing its blame factor  dicult elements rise rapidly to a place in the
sequence where they are handled well  once there  the blame assigned to them drops 
causing them to slowly sink in the sequence as other parts of the problem that are not
handled as well are given increased priority  eventually  dicult elements sink back to the
point where they are no longer handled well  causing them to receive higher blame and to
move forward in the sequence again  elements that are always easy to handle sink to the
end of the sequence and stay there 
   

fi squeaky wheel  optimization

iteration    priorities  c a b
late  a       b     

 

  

  

c

iteration    priorities  b a c
late  a       c     

 

  

a

  

b
iteration    priorities  a c b
late  b     

 

  

a

  

a

c

  

b

  

  

  

  

task
a
b
c

duration deadline
  
  
  
  
  
  

  

c
  

  

  

b

figure    simple example
to illustrate the swo cycle  consider a simplified scheduling example  suppose we have
a single production line  and three tasks to schedule  a  b and c   only one task can be
performed at a time  execution starts at t      the duration and deadline for each task
is shown in figure    the objective is to minimize the number of late tasks  an optimal
solution will have one late task 
suppose our initial priority sequence is hc  a  b i  and the constructor schedules tasks
in order  at the earliest possible time  the resulting schedule has two late tasks  b and
a   suppose that our analyzer assigns one point of  blame  to each late task  for each
unit of time it is late  in this case  a  b   and c receive        and   units of blame 
respectively  figure   shows the prioritization  the schedule that the constructor builds
from that prioritization  and the late tasks with the blame assigned to each 
for the next cycle  the prioritizer must take the previous priority sequence  and the
blame assigned by the analyzer  and generate a new priority sequence  a simple prioritizer
might just sort the tasks by their numeric blame in descending order  resulting in the new
priority sequence hb  a  c i 
after the second cycle  tasks a and c are late  scoring    and    points of blame 
respectively  the new priority sequence is then ha  c  b i 
the third solution  constructed from this priority sequence  has only one late task  b  
which receives    points of blame  at this point we have an optimal solution  if we continue
running swo  however  as we might expect to do since we typically do not know when we
have reached optimality  swo will attempt to fix what was wrong with the current solution 
here  since task b was late  its priority would be increased  and the resulting solution would
fix that problem at the expense of others   we would also enter a short cycle  alternating
between the last two schedules  we address this by introducing some randomization in the
prioritizer  
although this example is highly simplified  and there would clearly be better and more
sophisticated ways to implement each of the three modules  figure   shows that the behavior
illustrated by the simple example is reected in a real domain  the figure shows the changing
position in the priority sequence of three tasks in the scheduling domain that is described
in detail in the following section  one task   job      starts out with a high priority  and
remains at a relatively high priority level  we can see that when the task is scheduled
effectively  and therefore receives little or no blame  its priority tends to drop  but it does
   

fipriority

 high 

joslin   clements

 low 

job   
job   
job   
 

 

 

 

 

 

 

 

                                  
iteration

figure    examples of priority changes over time
not have to drop very far before it ceases to be scheduled well  acquires a significant level
of blame  and moves quickly back to a higher priority 
the other two tasks shown in the figure behave quite differently  one task   job     
starts out with a relatively high priority  but this task is  easy  to schedule  with little
blame  even when it is scheduled late in the sequence  over successive iterations  the
priority of such a task will tend to decrease steadily  the other task illustrated here   job
     does just the opposite  starting at a low priority and moving fairly steadily toward a
high priority 
the following section discusses the characteristics of swo that make it an effective technique for optimization  we then discuss implementations of swo for scheduling and for
graph coloring problems  the final sections discuss related work  describe directions for
future research  and summarize our findings 

   key ideas

as the experimental results below show  swo is a general approach to optimization  in this
section  we explore a few insights into what makes swo effective 
it is useful to think of swo as searching two coupled spaces  as illustrated in figure   
one search space is the familiar solution space  and the other is priority space  moves in
the solution space are made indirectly  via the re prioritization that results from analyzing
the prior solution  similarly  successive prioritizations are generated by constructing and
analyzing a solution  and then using the blame that results from that analysis to modify
the previous prioritization 
a point in the solution space represents a potential solution to the problem  and a
corresponding point in priority space  derived by analyzing the solution  is an attempt to
capture information about the structure of the search space in the vicinity of the solution 
as swo constructs a new solution from scratch  the priorities can be thought of as providing
   

fi squeaky wheel  optimization

construct

p
analyze 
prioritize

p

s

construct

s
priority space
solution space

figure    coupled search spaces
information about pitfalls common to the current region of the solution space  if some elements of the solution have tended to be sources of diculty over some number of iterations 
increasing their priority makes it more likely that the constructor will handle those elements
in a good way 
one consequence of the coupled search spaces is that a small change in the sequence of
elements generated by the prioritizer may correspond to a large change in the corresponding
solution generated by the constructor  compared to the solution from the previous iteration  moving an element forward in the sequence can significantly change its state in the
resulting solution  in addition  any elements that now occur after it in the sequence must
accommodate that element s state  for example  in the scheduling domain  moving a task
earlier in the priority sequence may allow it to be placed on a different manufacturing line 
thus possibly changing the mix of jobs that can run on that line  and on the line it was
scheduled on in the previous iteration  one small change can have consequences for any
element that follows it  with lower priority tasks having to  fill in the gaps  that are left
after higher priority tasks have been scheduled 
the result is a large move that is  coherent  in the sense that it is similar to what we
might expect from moving the higher priority task  then propagating the effects of that
change by moving lower priority tasks as needed  this single move may correspond to a
large number of moves for a search algorithm that only looks at local changes to the solution 
and it may thus be dicult for such an algorithm to find 
the fact that swo makes large moves in both search spaces is one obvious difference
between swo and traditional local search techniques  such as wsat  selman  kautz    cohen 
       another difference is that with swo  moves are never selected based on their effect
on the objective function  instead  unlike hillclimbing techniques  each move is made in
response to  trouble spots  found in the current solution  the resulting move may be
uphill  but the move is always motivated by those trouble spots 
   

fijoslin   clements

in priority space the only  local optima  are those in which all elements of a solution are
assigned equal blame  swo tends to avoid getting trapped in local optima  because analysis
and prioritization will always  in practice  suggest changes in the sequence  thus changing
the solution generated on the next iteration  this does not guarantee that swo will not
become trapped in a small cycle  however  in our implementations we have introduced
small amounts of randomness in the basic cycle  we also restart swo periodically with a
new initial sequence 
another aspect of local search is that typically each point in the solution space is associated with a single value  the objective function score for that solution  when we talk about
hillclimbing  we generally refer to the  terrain  described by this objective function score 
over the space of solutions  the process of analysis in swo can be thought of as synthesizing
a more complex description of that terrain  by breaking a solution down into its component
elements and assigning a score to each  prioritization then translates the analysis into a
 strategy  that the constructor can use to generate the next solution 
assigning scores to the individual elements of a solution allows swo to take advantage
of the fact that real problems often combine some elements that are dicult to get right 
plus others that are easy  in the scheduling problems presented below  some tasks can be
assigned to just a few production lines  while others allow for much more exibility  some
have due dates close to their release time  while others have a lot of leeway  it is sometimes
possible to identify  dicult  elements of a problem with static analysis  but interactions
can be complex  and elements that are causing diculty in one part of the search space may
be no trouble at all in another  rather than trying to identify elements that are globally
dicult by analyzing the entire problem  swo analyzes individual solutions in order to find
elements that are locally dicult  globally dicult elements tend to be identified over time 
as they are dicult across large parts of the search space 
by assigning blame and adjusting priorities based on identified problems in actual solutions  swo avoids dependence on complex  domain dependent heuristics  it is our belief
that this independence is particularly important in complex domains where even the best
heuristics will miss some key interactions and therefore inhibit the search from exploring
good areas that the heuristic incorrectly labels as unpromising  swo uses actual solutions
to discover which areas of the search space are promising and which are not 

   swo for scheduling
this section describes an application of swo to a fiber optic production line scheduling
problem  derived from data provided by lucent technologies  in this particular plant  a
cable may be assembled on any one of    parallel production lines  for each cable type 
only a subset of the production lines are compatible  and the time required to produce the
cable will depend on which of the compatible lines is selected  each cable also has a setup
time  which depends on its own cable type and that of its predecessor  setups between
certain pairs of cable types are infeasible  task preemption is not allowed  i e  once a cable
has started processing on a line  it finishes without interruption 
each cable is assigned a release time and due date  production cannot begin before the
release time  the objective function includes a penalty for missing due dates  and a penalty
for setup times 
   

fi squeaky wheel  optimization

    implementation

we describe the implementation in terms of the three main components of swo 

constructor  the constructor builds a schedule by adding tasks one at a time  in the

order they occur in the priority sequence  a task is added by selecting a line and a
position relative to the tasks already in that line  a task may be inserted between
any two tasks already in the line or at the beginning or end of that line s schedule 
changes to the relative positions of the tasks already in the line are not considered 
each task in the line is then assigned to its earliest possible start time  subject to the
ordering  i e   a task starts at either its release time  or immediately after the previous
task on that line  whichever is greater 
for each of the possible insertion points in the schedule  relative to the tasks already in
each line  the constructor calculates the effect on the objective function  and the task
is placed at the best scoring location  ties are broken randomly  after all tasks have
been placed  the constructor applies swo to the individual line schedules  attempting
to improve the score for each line by reordering the cables that were assigned to it 

analyzer  to assign blame to each task in the current schedule  the analyzer first calculates

a lower bound on the minimum possible cost that each task could contribute to any
schedule  for example  if a task has a release time that is later than its due date 
then it will be late in every schedule  and the minimum possible cost already includes
that penalty  minimum possible setup costs are also included  for a given schedule 
the blame assigned to each task is its  excess cost   the difference between its actual
cost and its minimum possible cost  excess lateness costs are assigned to tasks that
are late  and excess setup costs are split between adjacent tasks 

prioritizer  once the blame has been assigned  the prioritizer modifies the previous sequence of tasks by moving tasks with non zero blame factors forward in the sequence 
tasks are moved forward a distance that increases with the magnitude of the blame 
to move from the back of the sequence to the front  a task must have a high blame
factor over several iterations  we call this a  sticky sort  

our current implementation has considerable room for improvement  the analysis and
feedback currently being used are very simple  and the construction of schedules could take
various heuristics into account  such as preferring to place a task in a line that has more
 slack   all other things being equal 

    experimental results

we have six sets of test data  ranging in size from    to     tasks  all with    parallel
production lines  the largest problem was the largest that the manufacturer required in
practice  we compare the following solution methods 
swo

applies the swo architecture to the problem  running for a fixed number of iterations
and returning the best schedule it finds 
   

fijoslin   clements

data
set
  
  
  
  
   
   

best
obj
    
    
    
    
    
     

swo

avg
obj
    
    
    
    
    
     

avg
time
  
  
  
   
   
    

tabu

obj
    
    
    
    
     
 

time
   
   
    
    
     
 

ip

obj
    
    
    
    
 
 

time
  
   
    
    
 
 

table    experimental results  scheduling
tabu

ip

uses tabu search  glover   laguna         a local search algorithm in which moves
that increase cost are permitted to avoid getting trapped at local optima  to avoid
cycling  when an  uphill  move is made  it is not allowed to be immediately undone 

applies an integer programming  ip  solver  using an encoding described in     

on the     task problem  swo was far more effective than either tabu or ip  tabu 
for example  failed to find a feasible schedule after running for over    hours  on the
smallest problems  tabu and ip were able to find solutions  but swo outperformed both by
a substantial margin 
table   presents results on each problem for swo  tabu and ip  for swo  ten trials were
run and the results averaged  the tabu and ip implementations were deterministic  so
only the results of a single run are shown  the second column of the table shows the best
objective function value we have ever observed on each problem  the remaining columns
show the objective function value and running times for swo  tabu and ip  all but the ip
experiments were run on a sun sparcstation    model     the ip experiments were run on
an ibm rs     model      a faster machine  
the best values observed have been the result of combining swo with ip  as reported
in      in that work  swo generated solutions  running until it had produced a number of
 good  schedules  an ip solver was then invoked to re combine elements of those solutions
into a better solution  although the improvements achieved by the ip solver were relatively
small  on the order of       it achieved this improvement quickly  and swo was unable to
achieve the same degree of optimization even when given substantially more time  while
noting that the hybrid approach can be more effective than swo alone  and much more
effective than ip alone  here we focus on the performance of the individual techniques 
we also note that our very first  fairly naive implementation of swo for these scheduling
problems already outperformed both tabu and ip  moreover  our improved implementation 
reported above  is still fairly simple  and is successful without relying on domain dependent
heuristics  we take this as evidence that the effectiveness of our approach is not due
to cleverness in the construction  analysis and prioritization techniques  but due to the
effectiveness of the swo cycle at identifying and responding to whatever elements of the
problem happen to be causing diculty in the local region of the search 
   

fi squeaky wheel  optimization

  

  of lines job in that position can run on

 
 
 
 
 

 

 

 

 

 

 

 

 

                                              
position in priority sequence
order based on   of lines job can run on

  
 
 
 
 
 

                                              
position in priority sequence
order after   th iteration  producing a solution       over best known

figure    comparison of heuristic priorities and priorities derived by swo
it is also instructive to compare the results of a good heuristic ordering  with the sequence derived by swo  a good heuristic for this scheduling domain  and the one that is used
to initially populate the priority sequence  is to sort the tasks by the number of production
lines on which a task could be feasibly assigned in an empty schedule  a task that can be
scheduled on many lines is likely to be easier to schedule than one that is compatible with
only a small number of lines  and should therefore be expected to need a lower priority  the
top graph in figure   shows the sequence of tasks  as determined by this heuristic  the
lower graph illustrates the changes in priority of these tasks  after swo has run for fourteen
iterations  enough to improve the solution derived from the sequence to within      percent
of the best known solution  
as the figure illustrates  the heuristic is generally accurate  but swo has had to move
some tasks that are compatible with most of the production lines to positions of relatively
high priority  reecting the fact that contrary to the heuristic  these tasks turned out to be
relatively dicult to schedule well  other tasks that are compatible with only a few production lines are actually easy to schedule well  and have moved to relatively low priorities 

    restarts
the swo solver used to produce the results reported in table   restarted the priority
queue every n   iterations  where n is the number of jobs in the problem  the same noisy
heuristic that was used to initially populate the priority queue was also used to restart
it  this restart cutoff was picked in a rather ad hoc manner  a more careful analysis of
   

fijoslin   clements

iterations
feasible
       
       
per success mean success mean success
mean sample
restart
rate cost
rate cost
rate
cost
size
         
                                     
         
                              
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
          
                             
    
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
           
                             
   

table    experimental results  restarts in the scheduling domain
different restart cutoff values might lead to producing better solutions faster  and to some
additional insight on the workings of swo 
restarts are often used in non systematic search to avoid getting trapped in local optima
or in cycles   see parkes and walser        for an empirical study of wsat and further
references   restarts have also been used in systematic search to escape exponentially large
regions of the search space that do not contain a solution  gomes  selman    kautz        
local optima pose little threat to swo  since it is not directly driven by uphill downhill
considerations  swo  through its use of large coherent moves  also tends to escape unpromising parts of the search space quickly  however  swo is open to getting trapped in a cycle 
and restarts are used as a means to escape them 
for these scheduling problems  swo is unlikely to get into a tight cycle where priority
queues and solutions repeat exactly  this is due to the presence of random tie breaking in
several places  and to the presence of noise in the prioritizer  however  it is our belief that
swo can get trapped in a cycle where similar priority queues and solutions repeat 
we ran a series of experiments with the     task problem to determine the impact of
various restart cutoffs  the results are summarized in table    restart cutoffs ranged from
after every    iterations to after every      iterations  the success rate and mean cost are
shown for each value for each of three different solution qualities  the success rate indicates
the probability that a solution of at least the given quality was found in a given pass  the
mean cost is the average number of total iterations to get a solution of that quality 
for the feasible and       solution thresholds  swo reaches a     percent success rate
well before reaching the maximum restart cutoff of      used in these experiments  in some
sense  it is easy for swo to produce solutions that are at least of these qualities  the results
   

fi squeaky wheel  optimization

for these   thresholds indicate that when it is easy for swo to solve the problem  any cutoff
greater than the average number of uninterrupted iterations it takes to produce a solution
can be used to solve the problem at minimum cost  for such  easy  problems  it appears
that too small a restart cutoff can hurt  but that too big a cutoff will not 
the numbers for the       solution quality threshold  tell a different story  the success
rate is still climbing when the experiment ends  and the mean cost has actually risen above
its minimum  for this solution quality  the restart cutoff that minimizes mean cost falls
around the range of    to      mean costs rise steeply for restart cutoffs below this range 
and slowly for cutoffs larger than that  this is an example of a hard problem for swo  and it
shows that some care needs to be taken when choosing a restart strategy for such problems 
additional research is needed to determine how to set the restart cutoff automatically for
arbitrary problems 
this data indicates that swo does benefit from restarts  up to a point  with the      
threshold  for restart cutoffs up to      each increase in the cutoff in general led to a
superlinear increase in the success rate   this is also another indicator that swo is learning
from iteration to iteration   above     iterations per restart  the success rate initially
climbs sublinearly and then appears to level out  it is an open question what this tells us
about the search space 

   swo for graph coloring
we have also applied swo to a very different domain  graph coloring  here the objective
is to color the nodes of a graph such that no two adjoining nodes have the same color 
minimizing the number of colors 

    implementation

the priority sequence for graph coloring consists of an ordered list of nodes  the solver is
always trying to produce a coloring that uses colors from the target set  which has one less
color than was used to color the best solution so far  again  we describe the implementation
in terms of the three main components of swo 

constructor  the constructor assigns colors to nodes in priority sequence order  if a

node s color in the previous solution is still available  i e  no adjacent node is using
it yet   and is in the target set  then that color is assigned  if that fails  it tries to
assign a color in the current target set  picking the color that is least constraining on
adjacent uncolored nodes  i e  the color that reduces the adjacent nodes  remaining
color choices the least  if none of the target colors are available  the constructor tries
to  grab  a color in the target set from its neighbors  a color can only be grabbed
if all neighbor nodes with that color have at least one other choice within the target
set  if multiple colors can be grabbed  then the least constraining one is picked  if no
color in the target set can be grabbed then a color outside the target set is assigned 
nodes that are early in the priority sequence are more likely to have a wide range of
colors to pick from  nodes that come later may grab colors from earlier nodes  but
only if the earlier nodes have other color options within the target set 
   

fijoslin   clements

swo
ig
dist  impasse
par  impasse
tabu
problem
colors
time colors
time colors
time colors
time colors
time
dsjc     
    
        
        
                          
dsjc     
    
        
        
                             
dsjc     
    
         
                                        
dsjc                        
                                           
c      
                                      
 
 
 
 
c      
            
            
 
 
 
 
 
 
r     
   
   
   
   
   
   
   
    
   
   
r     c
    
        
        
        
         
   
r     
    
        
        
        
         
   
r     
   
   
   
   
   
   
   
    
   
   
r     c
    
         
        
                   
    
r     
    
         
        
         
         
    
dsjr     
    
        
         
        
         
   
dsjr     c
    
         
         
                            
dsjr     
     
          
          
           
                
r      
    
        
         
        
         
   
r      c
                
         
                               
r      
     
                       
                              
at        
    
         
        
                          
at        
    
         
        
                            
at        
    
         
                                       
at                                     
               
 
 
at                           
         
               
 
 
at                           
                             
 
 
latin sqr   
                 
                                          
le      a
    
        
         
                   
    
le      b
    
        
         
                   
    
le      c
    
        
         
                            
le      d
    
        
         
                            
mulsol i  
    
        
        
        
         
   
school 
    
        
         
        
         
    
school  nsh
    
        
        
        
         
    

table    experimental results  graph coloring problems

analyzer  blame is assigned to each node whose assigned color is outside the target set 
with the amount of blame increasing for each additional color that must be added
to the target set  we ran experiments with several different variations of color based
analysis  all of them performed reasonably 

prioritizer  the prioritizer modifies the previous sequence of nodes by moving nodes with
blame forward in the sequence according to how much blame each received  this is
done the same way it is done for the scheduling problems  the initial sequence is a list
of nodes sorted in decreasing degree order  with some noise added to slightly shue
the sort 
   

fi squeaky wheel  optimization

    experimental results
we applied swo to a standard set of graph coloring problems  including random graphs and
application graphs that model register allocation and class scheduling problems  these were
collected for the second dimacs implementation challenge  johnson   trick         which
includes results for several algorithms on these problems  culberson   luo        glover 
parker    ryan        lewandowski   condon        morgenstern         problems range
from     nodes with     edges to      nodes with           edges 
glover et al         is the only paper that is based on a general search technique  tabu
with branch and bound  rather than a graph coloring specific algorithm  this approach
had the worst reported average results in the group  morgenstern        used a distributed
impasse algorithm and had the best overall colorings  but also required that the target
number of colors  as well as several other problem specific parameters be passed to the
solver  lewandowski   condon        also found good solutions for this problem set 
their approach used a hybrid of parallel impasse and systematic search on a    processor
cm    culberson   luo        used an iterated greedy  ig  algorithm that bears some
similarity to swo  ig is the simplest algorithm in the group  its solution quality falls between
the impasse algorithms and tabu but solves the entire set in   to   percent of the time
taken by the other methods  both ig and impasse are discussed further under related
work 
table   compares swo with the results for ig  culberson   luo         distributed
impasse  morgenstern         parallel impasse  lewandowski   condon         and tabu
 glover et al          for each  one column shows the number of colors required for each
problem  and the run time  in cpu seconds   bold face indicates that the number of colors
is within     of the best result in the table 
we used a pentium pro    mhz workstation running linux for the swo graph coloring
experiments  the times shown for the other four algorithms are based on those reported in
 johnson   trick         the results for ig  impasse and tabu are normalized to our times
using the dimacs benchmarking program dfmax  provided for this purpose  therefore 
timing comparisons are only approximate  our machine ran the dfmax r      benchmark
in      seconds  the times reported for the machines used on the other algorithms were
     seconds for the tabu experiments        seconds for ig        seconds for impasse 
and        seconds for parallel impasse  because the dfmax benchmark runs on a single
processor  it is unsuitable for normalizing the times for parallel impasse  we report their
unnormalized times 
a variety of termination conditions were used  swo terminated after      iterations 
ig terminated after      iterations without improvement  distributed impasse used a
wide variety of different termination conditions to solve the different problems  the only
common element across problems was that distributed impasse stopped when the target
number of colors  provided as an input parameter  was reached  the times reported for
parallel impasse are the times it took to find the best solution that was found  not the time
it took the algorithm to terminate  which was always   hours  tabu ran until the algorithm
determined that it could make no further progress  or an hour had passed  whichever came
first 
   

fijoslin   clements

  
tabu

avg  percent over best in group

  

  
iterated greedy

  
squeaky wheel

 

par impasse

dist impasse
 
 

     

     

     
time  cpu seconds 

     

     

     

figure    experimental results  quality of solution vs  time
the tabu numbers are for a single run on each problem  the numbers for the other
algorithms are averages for   runs  parallel impasse     runs  distributed impasse  parallel
impasse  or    runs  swo  ig  distributed impasse  on each problem 
figure   summarizes the performance of each technique on the set of    problems that
all of the algorithms solved  for each solver the graph indicates the average solution quality
and the average amount of time needed to solve the set  the ideal location on the graph
is the origin  producing high quality solutions in very little time  the points shown for the
other techniques are the points reported in each of the papers  the curve shown for swo
shows how it performs when given varying amounts of time to solve the set  as the graph
shows  swo clearly outperforms tabu  the only other general purpose technique  both in
terms of quality and speed  swo also outperforms ig  a graph coloring specific algorithm 
both in terms of quality and speed  the impasse solvers clearly produce the best solutions
in the group  however  impasse is a domain specific method  and both solvers represent
much more programming effort  the swo solver uses a general purpose search technique
and was implemented in less than a month by a single programmer 

    alternate configurations of swo
we note that  as with the scheduling work  our first  naive implementation of swo for graph
coloring produced respectable results  even without color reuse  color grabbing  or the least
constraining heuristic  the first free color found was picked   swo matched ig on   problems
and beat it on     however  on half of the remaining problems ig did better by    or more
colors 
to explore the sensitivity of swo to such implementation details we tried the following
approaches in the constructor and prioritizer  and ran swo using all combinations 
   

fi squeaky wheel  optimization

construction  with or without color grabbing
analysis  either blame all nodes that receive a color outside the target set  or only the

first node  in the priority sequence  that causes a new color outside the target set to
be introduced  if color grabbing is used  the determination of blame is based on the
final color assigned to the node 

the difference in solution quality from the worst combination to the best combination
was less than    percent  even when the alternative of using a standard sort instead of
the  sticky  sort  a fairly fundamental change  was added to the mix  the spread between
worst and best was still under    percent 

   related work

the importance of prioritization in greedy algorithms is not a new idea  the  first fit 
algorithm for bin packing  for example  relies on placing items into bins in decreasing order
of size  garey   johnson         another example is grasp  greedy randomized adaptive
search procedure   feo   resende         grasp differs from our approach in several ways 
first  the prioritization and construction aspects are more closely coupled in grasp  after
each element is added to the solution being constructed  the remaining elements are reevaluated by some heuristic  thus the order in which elements are added to the solution
may depend on previous decisions  second  the order in which elements are selected in each
trial is determined only by the heuristic  and randomization   so the trials are independent 
there is no learning from iteration to iteration in grasp 
doubleback optimization  dbo   crawford        was to some extent the inspiration for
both swo and another similar algorithm  abstract local search  als   crawford  dalal   
walser         in designing swo  we began by looking at dbo  because it had been extremely
successful in solving a standard type of scheduling problem  however  dbo is only useful
when the objective is to minimize makespan  and is also limited in the types of constraints
it can handle  because of these limitations  we began thinking about the principles behind
dbo  looking for an effective generalization of that approach  dbo can  in fact  be viewed
as an instance of swo  dbo begins by performing a  right shift  on a schedule  shifting all
tasks as far to the right as they can go  up to some boundary  in the resulting right shifted
schedule  the left most tasks are  to some extent  those tasks that are most critical  this
corresponds to analysis in swo  tasks are then removed from the right shifted schedule 
taking left most tasks first  this ordering corresponds to the prioritization in swo  as each
task is removed  it is placed in a new schedule at the earliest possible start time  i e   greedy
construction 
like swo  als was the result of an attempt to generalize dbo  als views priority space
 to use the terminology from swo  as a space of  abstract schedules   and performs a local
search in that space  unlike swo  if a prioritization is modified  and the corresponding
move in solution space is downhill  away from optimal   then the modified prioritization
is discarded  and the old prioritization is restored  as is usual with local search  als also
sometimes makes random moves  in order to escape local minima 
als  and also list scheduling  pinson  prins    rullier         are scheduling algorithms
that deal with domains that include precedence constraints on tasks  both accommodate
   

fijoslin   clements

precedence constraints by constructing schedules left to right temporally  a task cannot
be placed in the schedule until all of its predecessors have been placed  in order for the
analysis  prioritization and construction to be appropriately coupled  it is not sucient to
simply increase the priority of a task that is late  because the constructor may not be able
to place that task until after a lot of other decisions have been made  consequently  some
amount of blame must be propagated to the task s predecessors 
the commercial scheduler optiflex  syswerda        uses a genetic algorithm approach
to modify a sequence of tasks  and a constraint based schedule constructor that generates
schedules from those sequences  optiflex can also be viewed as an instance of swo  with
a genetic algorithm replacing analysis  in effect  the  analysis  instead emerges from the
relative fitness of the members of the population 
two graph coloring algorithms also bear some similarity to swo  impasse class coloration neighborhood search  impasse   morgenstern        lewandowski   condon 
       like swo  maintains a target set of colors and produces only feasible colorings  given a
coloring  impasse places any nodes that are colored outside of the target set into an impasse
set  on each iteration a node is selected from the impasse set  using a noisy degree based
heuristic  and assigned a random color from the target set  any neighbor nodes that are
now in conict are moved to the impasse set 
iterated greedy  ig   culberson   luo         like swo  uses a sequence of nodes to
create a new coloring on each iteration  and then uses that coloring to produce a new
sequence for the next iteration  the method used to generate each new sequence differs
from swo  the key observation behind ig is that if all nodes with the same color in the
current solution are grouped together in the next sequence  i e  adjacent to each other in
the sequence   then the next solution will be no worse than the current solution  ig achieves
improvement by manipulating the order in which the groups occur in the new sequence 
using several heuristics including random based on color  descending based on color  and
ascending based on the cardinality of each group  ig learns groupings of nodes as it runs 
but it does not learn about about the diculty of any nodes  a node s place in the sequence
indicates nothing about its expected or detected diculty 

   analysis and future work

this section summarizes several areas of future research suggested by the results reported
in the previous sections 

    scaling

while swo uses fast  greedy algorithms for constructing solutions  and we have demonstrated
its effectiveness on problems of realistic size  the greatest threat to the scalability of swo is
that it constructs a new solution from scratch on each iteration  a partial solution to this
problem is seen in the use of a  history  mechanism for the graph coloring problems  using
the same color for a node as in the previous solution means that in many cases we do not
need to check any of the other possible colors  this significantly speeds up the construction 
a more fundamental solution to this problem would be to develop an incremental version
of swo  the selective reuse of colors in the graph coloring solver is a small step in this
direction  this allows the constructor to avoid spending time evaluating other alternatives
   

fi squeaky wheel  optimization

when the previous choice still works  more generally  it may be possible to look at the
changes made to a prioritization  and modify the corresponding solution in a way that
generates the same solution that would be constructed from scratch based on the new
prioritization  it seems feasible that this could be done for some domains  at least for small
changes to the prioritization  because there may be large portions of a solution that are
unaffected 
a more interesting possibility is based on the view of swo as performing local search
plus a certain kind of propagation  a small change in priorities may correspond to a large
change in the solution  for example  increasing the priority of one task in a scheduling
problem may change its position in the schedule  and  as a consequence  some lower priority
tasks may have to be shued around to accommodate that change  this is similar to what
we might expect from moving the higher priority task  then propagating the effects of that
change by moving lower priority tasks as well  this single move may correspond to a large
number of moves in a search algorithm that only looks at local changes to the schedule  and
may thus be dicult for such an algorithm to find 
based on this view  we are investigating an algorithm we call  priority limited propagation   plp   with plp  local changes are made to the solution  and then propagation is
allowed to occur  subject to the current prioritization  propagation is only allowed to occur
in the direction of lower priority elements  in effect  a small change is made  and then the
consequences of that change are allowed to  ripple  through the plan  because propagation
can only occur in directions of decreasing priority  these ripples of propagation decrease in
magnitude until no more propagation is possible  a new prioritization is then generated by
analyzing the resulting solution   it should be possible to do this analysis incrementally 
as well   the resulting approach is not identical to swo  but has many of its interesting
characteristics 

    coordination of modules
for swo to be effective  it is obvious that analysis  prioritization and construction must all
work together to improve the quality of solutions  we have already discussed the complications that can arise when constraints are placed on the order in which the constructor
can make decisions  as is the case for list scheduling and als  where construction is done
strictly left to right  without more complex analysis  the search spaces can effectively become uncoupled  so that changes in priority don t cause the constructor to fix problems
discovered by analysis 
another way the search can become uncoupled is related to the notion of  excess cost  
discussed for the scheduling implementation  the calculation of excess cost in the analyzer
turned out to be a key idea for improving the performance of swo  however  problems sometimes have tasks that must be handled badly in order to achieve a good overall solution  one
of the scheduling problems described previously has two such  sacrificial  tasks  whenever
a good solution is found  the analyzer assigns high blame to these sacrificial tasks  and the
constructor handles them well on the next iteration  this means that the resulting solution
is of poor overall quality  and it is not until other aws cause other tasks to move ahead of
the sacrificial tasks in the priority sequence that swo can again  briey  explore the space
   

fijoslin   clements

of good solutions  in such cases  to some extent the analysis is actually hurting the ability
of swo to converge on good solutions 
ideally  we would like to generalize the notion of excess cost to recognize sacrificial
tasks  and allow those tasks to be handled badly without receiving proportionate blame 
for problems in which a task must be sacrificed in all solutions  it may be possible to use
a learning mechanism to accomplish this 
however  the notion of a sacrificial task can be more subtle than this  suppose for
example that we are scheduling the construction of two airplanes  p  and p   and that
each has a key task  t  and t   respectively  requiring all of some shared resource  r 
because of the resource conict  we must either give r to t  early in the schedule  starting
construction on plane p  before p   or we must give r to t  early in the schedule  with
the opposite result  whichever of the two tasks is started early will finish on time  but the
other will be late 
suppose we construct a schedule in which t  goes first  and t  is late  thus receiving a
heavy blame factor  swo increases the priority on t   and as a consequence  t  goes first
in the subsequent schedule  but then t  is late  and on the next iteration it will again go
first  we could alternate in this manner forever  and the result would be that swo would
fail to explore either option very effectively  because it would be jumping back and forth
between the option of building plane p  first  and the option of building plane p  first 
without remaining in one region of the search space long enough to refine a solution 
the diculty is that neither t  nor t  can be identified as a sacrificial task  assuming
the two planes are not identical  we cannot simply argue from symmetry that we should
just pick one of the two tasks to be sacrificed  if  however  we could identify a sacrificial
task by the role it plays in a solution  we could achieve what we need  here  the task to be
sacrificed must be the one that belongs to whichever plane is started later  if the analyzer
could reduce the blame assigned to that task in a schedule  whichever task it happens to
be  it would allow swo to explore that region of the search much more effectively 
this problem of interchangeable roles would arise even more clearly with the introduction of conditional elements in a solution  suppose  for example  we have a scheduling
problem in which the constructor may choose to include or not include task instances of
some type  adding however many instances are needed to satisfy a resource requirement 
if those tasks are all instances of the same task type  then they are interchangeable  and
penalizing one may simply cause a shuing of those instances that does not really address
the problem  moreover  with conditional tasks  it is not clear how the analyzer should
assign blame when the set of task instances in the current schedule may be very different
from the set of task instances in successor schedules 
to address these concerns  the notion of prioritization could be generalized to apply to
additional aspects of a problem  in scheduling this might mean not just prioritizing tasks 
but also resources over various time intervals  we also propose that the these prioritizations
be limited to the  fixed  elements of a problem  in scheduling problems  for example  these
may be the non conditional tasks  resources  etc   in our example domains  all of the
elements are fixed in this sense  so this was not an issue  
one intuition behind this proposal is that these are the elements that will tend to define
roles  in the earlier example with tasks t  and t   corresponding to the two planes being
built  the critical element is not either task per se  but actually resource r  early in the
   

fi squeaky wheel  optimization

schedule  if this phase of resource r receives a high priority  and the later phase of resource
r receives a lower priority  then whichever of the two tasks occurs later will be recognized
as less critical  while this does not exactly capture the notion of  role  that we would like 
it comes a lot closer than the current approach  in addition  assigning priorities to the fixed
elements of a problem has the advantage of being applicable to problems with conditional
tasks  research is currently under way to explore this approach 

   

swo

and local search

although the ability to make large  coherent moves is a strength of the approach  it is also
a weakness  swo is poor at making small  tuning  moves in the solution space  but the
coupled search view of swo suggests an obvious remedy  swo could be combined with local
search in the solution space  to look for improvements in the vicinity of good solutions 
similarly  making small changes to a prioritization would generally result in smaller moves
in the solution space than result from going through the full analysis and re prioritization
cycle 
yet another alternative is genetic algorithm techniques for  crossover  and other types
of mutation to a pool of nodes  as is done in optiflex  many hybrid approaches are possible  and we believe that the coupled search view of swo helps to identify some interesting
strategies for combining moves of various sizes and kinds  in both search spaces  adapting
dynamically to relative solution qualities 

   conclusions
our experience has been that it is fairly straightforward to implement swo in a new domain 
because there are usually fairly obvious ways to construct greedy solutions  and to analyze
a solution to assign  blame  to some of the elements  naive implementations of swo tend
to perform reasonably well 
we have found the view of swo as performing a  coupled search  over two different
search spaces to be very informative  it has been helpful to characterize the kinds of moves
that swo makes in each of the search spaces  and the effect this has on avoiding local optima 
etc  we hope that by continuing to gain a deeper understanding of what makes swo work
we will be able to say more about the effective design of swo algorithms 
as the number of directions for future research suggests  we have only begun to scratch
the surface of  squeaky wheel  optimization 

acknowledgments
the authors wish to thank robert stubbs of lucent technologies for providing the data
used for the scheduling experiments  the authors also wish to thank george l  nemhauser 
markus e  puttlitz and martin w  p  savelsbergh with whom we collaborated on using swo
in a hybrid ai or approach  many useful discussions came out of that collaboration  and
without them we would not have had access to the lucent problems  markus also wrote
the framework for the scheduling experiments and the tabu and ip implementations 
   

fijoslin   clements

the authors also thank the members of cirl  and james crawford at i  technologies 
for their helpful comments and suggestions  we would like to thank andrew parkes in
particular for suggestions and insights in the graph coloring domain 
this effort was sponsored by the air force oce of scientific research  air force materiel command  usaf  under grant number f                 by the defense advanced
research projects agency  darpa  and rome laboratory  air force materiel command 
usaf  under agreements f                and f                 and by the national
science foundation under grant number cda         
the u s  government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright annotation thereon  the views and conclusions
contained herein are those of the authors and should not be interpreted as necessarily representing the ocial policies or endorsements  either expressed or implied  of the defense
advanced research projects agency  rome laboratory  the air force oce of scientific
research  the national science foundation  or the u s  government 
most of the work reported in this paper was done while both authors were at cirl 

references

crawford  j   dalal  m     walser  j          abstract local search  in proceedings of the
aips    workshop on planning as combinatorial search  in conjunction with the
fourth international conference on artificial intelligence planning systems  aips    
crawford  j  m          an approach to resource constrained project scheduling  in proceedings of the      artificial intelligence and manufacturing research planning workshop  pp        
culberson  j  c     luo  f          exploring the k colorable landscape with iterated
greedy  in  johnson   trick         pp          
feo  t  a     resende  m  g          greedy randomized adaptive search procedures 
journal of global optimization             
garey  m  r     johnson  d  s          computers and intractability  a guide to the
theory of np completeness  w  h  freeman 
glover  f     laguna  m          tabu search  kluwer 
glover  f   parker  m     ryan  j          coloring by tabu branch and bound  in  johnson
  trick         pp          
gomes  c   selman  b     kautz  h          boosting combinatorial search through randomization  in proceedings of aaai     pp          
johnson  d  s     trick  m  a   eds            cliques  coloring  and satisfiability  second
dimacs implementation challenge        vol     of dimacs series in discrete
mathematics and theoretical computer science  american mathematical society 
   

fi squeaky wheel  optimization

joslin  d     clements  d           squeaky wheel  optimization  in proceedings of aaai    pp          
lewandowski  g     condon  a          experiments with parallel graph coloring heuristics
and applications of graph coloring  in  johnson   trick         pp          
morgenstern  c          distributed coloration neighborhood search  in  johnson   trick 
       pp          
parkes  a     walser  j          tuning local search for satisfiability testing  in proceedings
of aaai     pp          
pinson  e   prins  c     rullier  f          using tabu search for solving the resourceconstrained project scheduling problem  in euro wg pms    euro working
group on project management and scheduling   pp          louvain  belgium 
selman  b   kautz  h  a     cohen  b          local search strategies for satisfiability
testing  in  johnson   trick         pp          
syswerda  g  p          generation of schedules using a genetic procedure   u s  patent
number           

   

fi