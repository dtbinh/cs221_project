journal artificial intelligence research                  

submitted       published     

 squeaky wheel  optimization
david e  joslin

david joslin i  com

i  technologies
    e  las colinas blvd 
irving  tx      

david p  clements

computational intelligence research laboratory
     university oregon
eugene            

clements cirl uoregon edu

abstract

describe general approach optimization term  squeaky wheel  optimization  swo   swo  greedy algorithm used construct solution
analyzed find trouble spots  i e   elements  that  improved  likely
improve objective function score  results analysis used generate
new priorities determine order greedy algorithm constructs next
solution  construct analyze prioritize cycle continues limit reached 
acceptable solution found 
swo viewed operating two search spaces  solutions prioritizations 
successive solutions indirectly related  via re prioritization results
analyzing prior solution  similarly  successive prioritizations generated constructing analyzing solutions   coupled search  interesting properties 
discuss 
report encouraging experimental results two domains  scheduling problems
arise fiber optic cable manufacturing  graph coloring problems  fact
domains different supports claim swo general technique optimization 

   overview
describe general approach optimization term  squeaky wheel  optimization  swo   joslin   clements         core swo construct analyze prioritize
cycle  illustrated figure    solution constructed greedy algorithm  making decisions order determined priorities assigned elements problem 
solution analyzed find elements problem  trouble makers  
priorities trouble makers increased  causing greedy constructor deal
sooner next iteration  cycle repeats termination condition
occurs 
iteration  analyzer determines elements problem causing
trouble current solution  prioritizer ensures constructor
gives attention elements next iteration    the squeaky wheel gets
grease    construction  analysis prioritization terms elements

c      ai access foundation morgan kaufmann publishers  rights reserved 

fijoslin   clements

analyzer
blame

solution

constructor

priorities

prioritizer

figure    construct analyze prioritize cycle
define problem domain  scheduling domain  example  elements might
tasks  graph coloring  elements might nodes colored 
three main components swo are 

constructor  given sequence problem elements  constructor generates solution

using greedy algorithm  backtracking  sequence determines order
decisions made  thought  strategy   recipe 
constructing new solution   this  solution  may violate hard constraints  

analyzer  analyzer assigns numeric  blame  factor problem elements

contribute aws current solution  example  minimizing lateness
scheduling problem one objectives  blame would assigned late
tasks 
key principle behind swo solutions reveal problem structure  analyzing solution  often identify elements solution work well 
elements work poorly  resource used full capacity  example  may
represent bottleneck  information problem structure local 
may apply part search space currently examination  may
useful determining search go next 
prioritizer  prioritizer uses blame factors assigned analyzer modify
previous sequence problem elements  elements received blame moved
toward front sequence  higher blame  element
moved 
priority sequence plays key role swo  dicult problem element moves
forward sequence handled sooner constructor  tends handled
better  thus decreasing blame factor  dicult elements rise rapidly place
sequence handled well  there  blame assigned drops 
causing slowly sink sequence parts problem
handled well given increased priority  eventually  dicult elements sink back
point longer handled well  causing receive higher blame
move forward sequence again  elements always easy handle sink
end sequence stay there 
   

fi squeaky wheel  optimization

iteration    priorities  c a b
late        b     

 

  

  

c

iteration    priorities  b a c
late        c     

 

  



  

b
iteration    priorities  a c b
late  b     

 

  



  



c

  

b

  

  

  

  

task

b
c

duration deadline
  
  
  
  
  
  

  

c
  

  

  

b

figure    simple example
illustrate swo cycle  consider simplified scheduling example  suppose
single production line  three tasks schedule  a  b c   one task
performed time  execution starts      duration deadline task
shown figure    objective minimize number late tasks  optimal
solution one late task 
suppose initial priority sequence hc  a  b i  constructor schedules tasks
order  earliest possible time  resulting schedule two late tasks  b
a   suppose analyzer assigns one point  blame  late task 
unit time late  case  a  b   c receive          units blame 
respectively  figure   shows prioritization  schedule constructor builds
prioritization  late tasks blame assigned each 
next cycle  prioritizer must take previous priority sequence 
blame assigned analyzer  generate new priority sequence  simple prioritizer
might sort tasks numeric blame descending order  resulting new
priority sequence hb  a  c i 
second cycle  tasks c late  scoring       points blame 
respectively  new priority sequence ha  c  b i 
third solution  constructed priority sequence  one late task  b  
receives    points blame  point optimal solution  continue
running swo  however  might expect since typically know
reached optimality  swo attempt fix wrong current solution 
here  since task b late  priority would increased  resulting solution would
fix problem expense others   we would enter short cycle  alternating
last two schedules  address introducing randomization
prioritizer  
although example highly simplified  would clearly better
sophisticated ways implement three modules  figure   shows behavior
illustrated simple example ected real domain  figure shows changing
position priority sequence three tasks scheduling domain described
detail following section  one task   job      starts high priority 
remains relatively high priority level  see task scheduled
effectively  therefore receives little blame  priority tends drop 
   

fipriority

 high 

joslin   clements

 low 

job   
job   
job   
 

 

 

 

 

 

 

 

                                  
iteration

figure    examples priority changes time
drop far ceases scheduled well  acquires significant level
blame  moves quickly back higher priority 
two tasks shown figure behave quite differently  one task   job     
starts relatively high priority  task  easy  schedule  little
blame  even scheduled late sequence  successive iterations 
priority task tend decrease steadily  task illustrated   job
     opposite  starting low priority moving fairly steadily toward
high priority 
following section discusses characteristics swo make effective technique optimization  discuss implementations swo scheduling
graph coloring problems  final sections discuss related work  describe directions
future research  summarize findings 

   key ideas

experimental results show  swo general approach optimization 
section  explore insights makes swo effective 
useful think swo searching two coupled spaces  illustrated figure   
one search space familiar solution space  priority space  moves
solution space made indirectly  via re prioritization results analyzing
prior solution  similarly  successive prioritizations generated constructing
analyzing solution  using blame results analysis modify
previous prioritization 
point solution space represents potential solution problem 
corresponding point priority space  derived analyzing solution  attempt
capture information structure search space vicinity solution 
swo constructs new solution scratch  priorities thought providing
   

fi squeaky wheel  optimization

construct

p
analyze 
prioritize

p



construct


priority space
solution space

figure    coupled search spaces
information pitfalls common current region solution space  elements solution tended sources diculty number iterations 
increasing priority makes likely constructor handle elements
good way 
one consequence coupled search spaces small change sequence
elements generated prioritizer may correspond large change corresponding
solution generated constructor  compared solution previous iteration  moving element forward sequence significantly change state
resulting solution  addition  elements occur sequence must
accommodate element s state  example  scheduling domain  moving task
earlier priority sequence may allow placed different manufacturing line 
thus possibly changing mix jobs run line  line
scheduled previous iteration  one small change consequences
element follows it  lower priority tasks  fill gaps  left
higher priority tasks scheduled 
result large move  coherent  sense similar
might expect moving higher priority task  propagating effects
change moving lower priority tasks needed  single move may correspond
large number moves search algorithm looks local changes solution 
may thus dicult algorithm find 
fact swo makes large moves search spaces one obvious difference
swo traditional local search techniques  wsat  selman  kautz    cohen 
       another difference swo  moves never selected based effect
objective function  instead  unlike hillclimbing techniques  move made
response  trouble spots  found current solution  resulting move may
uphill  move always motivated trouble spots 
   

fijoslin   clements

priority space  local optima  elements solution
assigned equal blame  swo tends avoid getting trapped local optima  analysis
prioritization always  in practice  suggest changes sequence  thus changing
solution generated next iteration  guarantee swo
become trapped small cycle  however  implementations introduced
small amounts randomness basic cycle  restart swo periodically
new initial sequence 
another aspect local search typically point solution space associated single value  objective function score solution  talk
hillclimbing  generally refer  terrain  described objective function score 
space solutions  process analysis swo thought synthesizing
complex description terrain  breaking solution component
elements assigning score each  prioritization translates analysis
 strategy  constructor use generate next solution 
assigning scores individual elements solution allows swo take advantage
fact real problems often combine elements dicult get right 
plus others easy  scheduling problems presented below  tasks
assigned production lines  others allow much exibility 
due dates close release time  others lot leeway  sometimes
possible identify  dicult  elements problem static analysis  interactions
complex  elements causing diculty one part search space may
trouble another  rather trying identify elements globally
dicult analyzing entire problem  swo analyzes individual solutions order find
elements locally dicult  globally dicult elements tend identified time 
dicult across large parts search space 
assigning blame adjusting priorities based identified problems actual solutions  swo avoids dependence complex  domain dependent heuristics  belief
independence particularly important complex domains even best
heuristics miss key interactions therefore inhibit search exploring
good areas heuristic incorrectly labels unpromising  swo uses actual solutions
discover areas search space promising not 

   swo scheduling
section describes application swo fiber optic production line scheduling
problem  derived data provided lucent technologies  particular plant 
cable may assembled one    parallel production lines  cable type 
subset production lines compatible  time required produce
cable depend compatible lines selected  cable setup
time  depends cable type predecessor  setups
certain pairs cable types infeasible  task preemption allowed  i e  cable
started processing line  finishes without interruption 
cable assigned release time due date  production cannot begin
release time  objective function includes penalty missing due dates  penalty
setup times 
   

fi squeaky wheel  optimization

    implementation

describe implementation terms three main components swo 

constructor  constructor builds schedule adding tasks one time 

order occur priority sequence  task added selecting line
position relative tasks already line  task may inserted
two tasks already line beginning end line s schedule 
changes relative positions tasks already line considered 
task line assigned earliest possible start time  subject
ordering  i e   task starts either release time  immediately previous
task line  whichever greater 
possible insertion points schedule  relative tasks already
line  constructor calculates effect objective function  task
placed best scoring location  ties broken randomly  tasks
placed  constructor applies swo individual line schedules  attempting
improve score line reordering cables assigned it 

analyzer  assign blame task current schedule  analyzer first calculates

lower bound minimum possible cost task could contribute
schedule  example  task release time later due date 
late every schedule  minimum possible cost already includes
penalty  minimum possible setup costs included  given schedule 
blame assigned task  excess cost   difference actual
cost minimum possible cost  excess lateness costs assigned tasks
late  excess setup costs split adjacent tasks 

prioritizer  blame assigned  prioritizer modifies previous sequence tasks moving tasks non zero blame factors forward sequence 
tasks moved forward distance increases magnitude blame 
move back sequence front  task must high blame
factor several iterations  call  sticky sort  

current implementation considerable room improvement  analysis
feedback currently used simple  construction schedules could take
various heuristics account  preferring place task line
 slack   things equal 

    experimental results

six sets test data  ranging size        tasks     parallel
production lines  largest problem largest manufacturer required
practice  compare following solution methods 
swo

applies swo architecture problem  running fixed number iterations
returning best schedule finds 
   

fijoslin   clements

data
set
  
  
  
  
   
   

best
obj
    
    
    
    
    
     

swo

avg
obj
    
    
    
    
    
     

avg
time
  
  
  
   
   
    

tabu

obj
    
    
    
    
     
 

time
   
   
    
    
     
 

ip

obj
    
    
    
    
 
 

time
  
   
    
    
 
 

table    experimental results  scheduling
tabu

ip

uses tabu search  glover   laguna         local search algorithm moves
increase cost permitted avoid getting trapped local optima  avoid
cycling   uphill  move made  allowed immediately undone 

applies integer programming  ip  solver  using encoding described     

    task problem  swo far effective either tabu ip  tabu 
example  failed find feasible schedule running    hours 
smallest problems  tabu ip able find solutions  swo outperformed
substantial margin 
table   presents results problem swo  tabu ip  swo  ten trials
run results averaged  tabu ip implementations deterministic 
results single run shown  second column table shows best
objective function value ever observed problem  remaining columns
show objective function value running times swo  tabu ip  ip
experiments run sun sparcstation    model     ip experiments run
ibm rs     model      a faster machine  
best values observed result combining swo ip  reported
     work  swo generated solutions  running produced number
 good  schedules  ip solver invoked re combine elements solutions
better solution  although improvements achieved ip solver relatively
small  order       achieved improvement quickly  swo unable
achieve degree optimization even given substantially time 
noting hybrid approach effective swo alone  much
effective ip alone  focus performance individual techniques 
note first  fairly naive implementation swo scheduling
problems already outperformed tabu ip  moreover  improved implementation 
reported above  still fairly simple  successful without relying domain dependent
heuristics  take evidence effectiveness approach due
cleverness construction  analysis prioritization techniques  due
effectiveness swo cycle identifying responding whatever elements
problem happen causing diculty local region search 
   

fi squeaky wheel  optimization

  

  lines job position run

 
 
 
 
 

 

 

 

 

 

 

 

 

                                              
position priority sequence
order based   lines job run

  
 
 
 
 
 

                                              
position priority sequence
order   th iteration  producing solution       best known

figure    comparison heuristic priorities priorities derived swo
instructive compare results good heuristic ordering  sequence derived swo  good heuristic scheduling domain  and one used
initially populate priority sequence  sort tasks number production
lines task could feasibly assigned empty schedule  task
scheduled many lines likely easier schedule one compatible
small number lines  therefore expected need lower priority 
top graph figure   shows sequence tasks  determined heuristic 
lower graph illustrates changes priority tasks  swo run fourteen
iterations  enough improve solution derived sequence within      percent
best known solution  
figure illustrates  heuristic generally accurate  swo move
tasks compatible production lines positions relatively
high priority  ecting fact contrary heuristic  tasks turned
relatively dicult schedule well  tasks compatible production lines actually easy schedule well  moved relatively low priorities 

    restarts
swo solver used produce results reported table   restarted priority
queue every n   iterations  n number jobs problem  noisy
heuristic used initially populate priority queue used restart
it  restart cutoff picked rather ad hoc manner  careful analysis
   

fijoslin   clements

iterations
feasible
       
       
per success mean success mean success
mean sample
restart
rate cost
rate cost
rate
cost
size
         
                                     
         
                              
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
         
                             
    
          
                             
    
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
          
                             
   
           
                             
   

table    experimental results  restarts scheduling domain
different restart cutoff values might lead producing better solutions faster 
additional insight workings swo 
restarts often used non systematic search avoid getting trapped local optima
cycles   see parkes walser        empirical study wsat
references   restarts used systematic search escape exponentially large
regions search space contain solution  gomes  selman    kautz        
local optima pose little threat swo  since directly driven uphill downhill
considerations  swo  use large coherent moves  tends escape unpromising parts search space quickly  however  swo open getting trapped cycle 
restarts used means escape them 
scheduling problems  swo unlikely get tight cycle priority
queues solutions repeat exactly  due presence random tie breaking
several places  presence noise prioritizer  however  belief
swo get trapped cycle similar priority queues solutions repeat 
ran series experiments     task problem determine impact
various restart cutoffs  results summarized table    restart cutoffs ranged
every    iterations every      iterations  success rate mean cost
shown value three different solution qualities  success rate indicates
probability solution least given quality found given pass 
mean cost average number total iterations get solution quality 
feasible       solution thresholds  swo reaches     percent success rate
well reaching maximum restart cutoff      used experiments 
sense  easy swo produce solutions least qualities  results
   

fi squeaky wheel  optimization

  thresholds indicate easy swo solve problem  cutoff
greater average number uninterrupted iterations takes produce solution
used solve problem minimum cost   easy  problems  appears
small restart cutoff hurt  big cutoff not 
numbers       solution quality threshold  tell different story  success
rate still climbing experiment ends  mean cost actually risen
minimum  solution quality  restart cutoff minimizes mean cost falls
around range         mean costs rise steeply restart cutoffs range 
slowly cutoffs larger that  example hard problem swo 
shows care needs taken choosing restart strategy problems 
additional research needed determine set restart cutoff automatically
arbitrary problems 
data indicates swo benefit restarts  point       
threshold  restart cutoffs      increase cutoff general led
superlinear increase success rate   this another indicator swo learning
iteration iteration       iterations per restart  success rate initially
climbs sublinearly appears level out  open question tells us
search space 

   swo graph coloring
applied swo different domain  graph coloring  objective
color nodes graph two adjoining nodes color 
minimizing number colors 

    implementation

priority sequence graph coloring consists ordered list nodes  solver
always trying produce coloring uses colors target set  one less
color used color best solution far  again  describe implementation
terms three main components swo 

constructor  constructor assigns colors nodes priority sequence order 

node s color previous solution still available  i e  adjacent node using
yet   target set  color assigned  fails  tries
assign color current target set  picking color least constraining
adjacent uncolored nodes  i e  color reduces adjacent nodes  remaining
color choices least  none target colors available  constructor tries
 grab  color target set neighbors  color grabbed
neighbor nodes color least one choice within target
set  multiple colors grabbed  least constraining one picked 
color target set grabbed color outside target set assigned 
nodes early priority sequence likely wide range
colors pick from  nodes come later may grab colors earlier nodes 
earlier nodes color options within target set 
   

fijoslin   clements

swo
ig
dist  impasse
par  impasse
tabu
problem
colors
time colors
time colors
time colors
time colors
time
dsjc     
    
        
        
                          
dsjc     
    
        
        
                             
dsjc     
    
         
                                        
dsjc                        
                                           
c      
                                      
 
 
 
 
c      
            
            
 
 
 
 
 
 
r     
   
   
   
   
   
   
   
    
   
   
r     c
    
        
        
        
         
   
r     
    
        
        
        
         
   
r     
   
   
   
   
   
   
   
    
   
   
r     c
    
         
        
                   
    
r     
    
         
        
         
         
    
dsjr     
    
        
         
        
         
   
dsjr     c
    
         
         
                            
dsjr     
     
          
          
           
                
r      
    
        
         
        
         
   
r      c
                
         
                               
r      
     
                       
                              
at        
    
         
        
                          
at        
    
         
        
                            
at        
    
         
                                       
at                                     
               
 
 
at                           
         
               
 
 
at                           
                             
 
 
latin sqr   
                 
                                          
le      a
    
        
         
                   
    
le      b
    
        
         
                   
    
le      c
    
        
         
                            
le      d
    
        
         
                            
mulsol i  
    
        
        
        
         
   
school 
    
        
         
        
         
    
school  nsh
    
        
        
        
         
    

table    experimental results  graph coloring problems

analyzer  blame assigned node whose assigned color outside target set 
amount blame increasing additional color must added
target set  ran experiments several different variations color based
analysis  performed reasonably 

prioritizer  prioritizer modifies previous sequence nodes moving nodes
blame forward sequence according much blame received 
done way done scheduling problems  initial sequence list
nodes sorted decreasing degree order  noise added slightly shue
sort 
   

fi squeaky wheel  optimization

    experimental results
applied swo standard set graph coloring problems  including random graphs
application graphs model register allocation class scheduling problems 
collected second dimacs implementation challenge  johnson   trick        
includes results several algorithms problems  culberson   luo        glover 
parker    ryan        lewandowski   condon        morgenstern         problems range
    nodes     edges      nodes           edges 
glover et al         paper based general search technique  tabu
branch bound  rather graph coloring specific algorithm  approach
worst reported average results group  morgenstern        used distributed
impasse algorithm best overall colorings  required target
number colors  well several problem specific parameters passed
solver  lewandowski   condon        found good solutions problem set 
approach used hybrid parallel impasse systematic search    processor
cm    culberson   luo        used iterated greedy  ig  algorithm bears
similarity swo  ig simplest algorithm group  solution quality falls
impasse algorithms tabu solves entire set     percent time
taken methods  ig impasse discussed related
work 
table   compares swo results ig  culberson   luo         distributed
impasse  morgenstern         parallel impasse  lewandowski   condon         tabu
 glover et al          each  one column shows number colors required
problem  run time  in cpu seconds   bold face indicates number colors
within     best result table 
used pentium pro    mhz workstation running linux swo graph coloring
experiments  times shown four algorithms based reported
 johnson   trick         results ig  impasse tabu normalized times
using dimacs benchmarking program dfmax  provided purpose  therefore 
timing comparisons approximate  machine ran dfmax r      benchmark
     seconds  times reported machines used algorithms
     seconds tabu experiments        seconds ig        seconds impasse 
       seconds parallel impasse  dfmax benchmark runs single
processor  unsuitable normalizing times parallel impasse  report
unnormalized times 
variety termination conditions used  swo terminated      iterations 
ig terminated      iterations without improvement  distributed impasse used
wide variety different termination conditions solve different problems 
common element across problems distributed impasse stopped target
number colors  provided input parameter  reached  times reported
parallel impasse times took find best solution found  time
took algorithm terminate  always   hours  tabu ran algorithm
determined could make progress  hour passed  whichever came
first 
   

fijoslin   clements

  
tabu

avg  percent best group

  

  
iterated greedy

  
squeaky wheel

 

par impasse

dist impasse
 
 

     

     

     
time  cpu seconds 

     

     

     

figure    experimental results  quality solution vs  time
tabu numbers single run problem  numbers
algorithms averages   runs  parallel impasse     runs  distributed impasse  parallel
impasse     runs  swo  ig  distributed impasse  problem 
figure   summarizes performance technique set    problems
algorithms solved  solver graph indicates average solution quality
average amount time needed solve set  ideal location graph
origin  producing high quality solutions little time  points shown
techniques points reported papers  curve shown swo
shows performs given varying amounts time solve set  graph
shows  swo clearly outperforms tabu  general purpose technique 
terms quality speed  swo outperforms ig  graph coloring specific algorithm 
terms quality speed  impasse solvers clearly produce best solutions
group  however  impasse domain specific method  solvers represent
much programming effort  swo solver uses general purpose search technique
implemented less month single programmer 

    alternate configurations swo
note that  scheduling work  first  naive implementation swo graph
coloring produced respectable results  even without color reuse  color grabbing  least
constraining heuristic  the first free color found picked   swo matched ig   problems
beat     however  half remaining problems ig better   
colors 
explore sensitivity swo implementation details tried following
approaches constructor prioritizer  ran swo using combinations 
   

fi squeaky wheel  optimization

construction  without color grabbing
analysis  either blame nodes receive color outside target set 

first node  in priority sequence  causes new color outside target set
introduced  color grabbing used  determination blame based
final color assigned node 

difference solution quality worst combination best combination
less    percent  even alternative using standard sort instead
 sticky  sort  a fairly fundamental change  added mix  spread
worst best still    percent 

   related work

importance prioritization greedy algorithms new idea   first fit 
algorithm bin packing  example  relies placing items bins decreasing order
size  garey   johnson         another example grasp  greedy randomized adaptive
search procedure   feo   resende         grasp differs approach several ways 
first  prioritization construction aspects closely coupled grasp 
element added solution constructed  remaining elements reevaluated heuristic  thus order elements added solution
may depend previous decisions  second  order elements selected
trial determined heuristic  and randomization   trials independent 
learning iteration iteration grasp 
doubleback optimization  dbo   crawford        extent inspiration
swo another similar algorithm  abstract local search  als   crawford  dalal   
walser         designing swo  began looking dbo  extremely
successful solving standard type scheduling problem  however  dbo useful
objective minimize makespan  limited types constraints
handle  limitations  began thinking principles behind
dbo  looking effective generalization approach  dbo can  fact  viewed
instance swo  dbo begins performing  right shift  schedule  shifting
tasks far right go  boundary  resulting right shifted
schedule  left most tasks are  extent  tasks critical 
corresponds analysis swo  tasks removed right shifted schedule 
taking left most tasks first  ordering corresponds prioritization swo 
task removed  placed new schedule earliest possible start time  i e   greedy
construction 
swo  als result attempt generalize dbo  als views priority space
 to use terminology swo  space  abstract schedules   performs local
search space  unlike swo  prioritization modified  corresponding
move solution space downhill  away optimal   modified prioritization
discarded  old prioritization restored  usual local search  als
sometimes makes random moves  order escape local minima 
als  list scheduling  pinson  prins    rullier         scheduling algorithms
deal domains include precedence constraints tasks  accommodate
   

fijoslin   clements

precedence constraints constructing schedules left to right temporally  task cannot
placed schedule predecessors placed  order
analysis  prioritization construction appropriately coupled  sucient
simply increase priority task late  constructor may able
place task lot decisions made  consequently 
amount blame must propagated task s predecessors 
commercial scheduler optiflex  syswerda        uses genetic algorithm approach
modify sequence tasks  constraint based schedule constructor generates
schedules sequences  optiflex viewed instance swo 
genetic algorithm replacing analysis  effect   analysis  instead emerges
relative fitness members population 
two graph coloring algorithms bear similarity swo  impasse class coloration neighborhood search  impasse   morgenstern        lewandowski   condon 
       swo  maintains target set colors produces feasible colorings  given
coloring  impasse places nodes colored outside target set impasse
set  iteration node selected impasse set  using noisy degree based
heuristic  assigned random color target set  neighbor nodes
con ict moved impasse set 
iterated greedy  ig   culberson   luo         swo  uses sequence nodes
create new coloring iteration  uses coloring produce new
sequence next iteration  method used generate new sequence differs
swo  key observation behind ig nodes color
current solution grouped together next sequence  i e  adjacent
sequence   next solution worse current solution  ig achieves
improvement manipulating order groups occur new sequence 
using several heuristics including random based color  descending based color 
ascending based cardinality group  ig learns groupings nodes runs 
learn diculty nodes  node s place sequence
indicates nothing expected detected diculty 

   analysis future work

section summarizes several areas future research suggested results reported
previous sections 

    scaling

swo uses fast  greedy algorithms constructing solutions  demonstrated
effectiveness problems realistic size  greatest threat scalability swo
constructs new solution scratch iteration  partial solution
problem seen use  history  mechanism graph coloring problems  using
color node previous solution means many cases
need check possible colors  significantly speeds construction 
fundamental solution problem would develop incremental version
swo  selective reuse colors graph coloring solver small step
direction  allows constructor avoid spending time evaluating alternatives
   

fi squeaky wheel  optimization

previous choice still works  generally  may possible look
changes made prioritization  modify corresponding solution way
generates solution would constructed scratch based new
prioritization  seems feasible could done domains  least small
changes prioritization  may large portions solution
unaffected 
interesting possibility based view swo performing local search
plus certain kind propagation  small change priorities may correspond large
change solution  example  increasing priority one task scheduling
problem may change position schedule  and  consequence  lower priority
tasks may shued around accommodate change  similar
might expect moving higher priority task  propagating effects
change moving lower priority tasks well  single move may correspond large
number moves search algorithm looks local changes schedule 
may thus dicult algorithm find 
based view  investigating algorithm call  priority limited propagation   plp   plp  local changes made solution  propagation
allowed occur  subject current prioritization  propagation allowed occur
direction lower priority elements  effect  small change made 
consequences change allowed  ripple  plan  propagation
occur directions decreasing priority  ripples propagation decrease
magnitude propagation possible  new prioritization generated
analyzing resulting solution   it possible analysis incrementally 
well   resulting approach identical swo  many interesting
characteristics 

    coordination modules
swo effective  obvious analysis  prioritization construction must
work together improve quality solutions  already discussed complications arise constraints placed order constructor
make decisions  case list scheduling als  construction done
strictly left to right  without complex analysis  search spaces effectively become uncoupled  changes priority don t cause constructor fix problems
discovered analysis 
another way search become uncoupled related notion  excess cost  
discussed scheduling implementation  calculation excess cost analyzer
turned key idea improving performance swo  however  problems sometimes tasks must handled badly order achieve good overall solution  one
scheduling problems described previously two  sacrificial  tasks  whenever
good solution found  analyzer assigns high blame sacrificial tasks 
constructor handles well next iteration  means resulting solution
poor overall quality  aws cause tasks move ahead
sacrificial tasks priority sequence swo again  brie y  explore space
   

fijoslin   clements

good solutions  cases  extent analysis actually hurting ability
swo converge good solutions 
ideally  would generalize notion excess cost recognize sacrificial
tasks  allow tasks handled badly without receiving proportionate blame 
problems task must sacrificed solutions  may possible use
learning mechanism accomplish this 
however  notion sacrificial task subtle this  suppose
example scheduling construction two airplanes  p  p  
key task  t  t   respectively  requiring shared resource  r 
resource con ict  must either give r t  early schedule  starting
construction plane p  p   must give r t  early schedule 
opposite result  whichever two tasks started early finish time 
late 
suppose construct schedule t  goes first  t  late  thus receiving
heavy blame factor  swo increases priority t   consequence  t  goes first
subsequent schedule  t  late  next iteration go
first  could alternate manner forever  result would swo would
fail explore either option effectively  would jumping back forth
option building plane p  first  option building plane p  first 
without remaining one region search space long enough refine solution 
diculty neither t  t  identified sacrificial task  assuming
two planes identical  cannot simply argue symmetry
pick one two tasks sacrificed  if  however  could identify sacrificial
task role plays solution  could achieve need  here  task
sacrificed must one belongs whichever plane started later  analyzer
could reduce blame assigned task schedule  whichever task happens
be  would allow swo explore region search much effectively 
problem interchangeable roles would arise even clearly introduction conditional elements solution  suppose  example  scheduling
problem constructor may choose include include task instances
type  adding however many instances needed satisfy resource requirement 
tasks instances task type  interchangeable 
penalizing one may simply cause shuing instances really address
problem  moreover  conditional tasks  clear analyzer
assign blame set task instances current schedule may different
set task instances successor schedules 
address concerns  notion prioritization could generalized apply
additional aspects problem  scheduling might mean prioritizing tasks 
resources various time intervals  propose prioritizations
limited  fixed  elements problem  scheduling problems  example 
may non conditional tasks  resources  etc   in example domains 
elements fixed sense  issue  
one intuition behind proposal elements tend define
roles  earlier example tasks t  t   corresponding two planes
built  critical element either task per se  actually resource r  early
   

fi squeaky wheel  optimization

schedule  phase resource r receives high priority  later phase resource
r receives lower priority  whichever two tasks occurs later recognized
less critical  exactly capture notion  role  would like 
comes lot closer current approach  addition  assigning priorities fixed
elements problem advantage applicable problems conditional
tasks  research currently way explore approach 

   

swo

local search

although ability make large  coherent moves strength approach 
weakness  swo poor making small  tuning  moves solution space 
coupled search view swo suggests obvious remedy  swo could combined local
search solution space  look improvements vicinity good solutions 
similarly  making small changes prioritization would generally result smaller moves
solution space result going full analysis re prioritization
cycle 
yet another alternative genetic algorithm techniques  crossover  types
mutation pool nodes  done optiflex  many hybrid approaches possible  believe coupled search view swo helps identify interesting
strategies combining moves various sizes kinds  search spaces  adapting
dynamically relative solution qualities 

   conclusions
experience fairly straightforward implement swo new domain 
usually fairly obvious ways construct greedy solutions  analyze
solution assign  blame  elements  naive implementations swo tend
perform reasonably well 
found view swo performing  coupled search  two different
search spaces informative  helpful characterize kinds moves
swo makes search spaces  effect avoiding local optima 
etc  hope continuing gain deeper understanding makes swo work
able say effective design swo algorithms 
number directions future research suggests  begun scratch
surface  squeaky wheel  optimization 

acknowledgments
authors wish thank robert stubbs lucent technologies providing data
used scheduling experiments  authors wish thank george l  nemhauser 
markus e  puttlitz martin w  p  savelsbergh collaborated using swo
hybrid ai or approach  many useful discussions came collaboration 
without would access lucent problems  markus wrote
framework scheduling experiments tabu ip implementations 
   

fijoslin   clements

authors thank members cirl  james crawford i  technologies 
helpful comments suggestions  would thank andrew parkes
particular suggestions insights graph coloring domain 
effort sponsored air force oce scientific research  air force materiel command  usaf  grant number f                 defense advanced
research projects agency  darpa  rome laboratory  air force materiel command 
usaf  agreements f                f                 national
science foundation grant number cda         
u s  government authorized reproduce distribute reprints governmental purposes notwithstanding copyright annotation thereon  views conclusions
contained herein authors interpreted necessarily representing ocial policies endorsements  either expressed implied  defense
advanced research projects agency  rome laboratory  air force oce scientific
research  national science foundation  u s  government 
work reported paper done authors cirl 

references

crawford  j   dalal  m     walser  j          abstract local search  proceedings
aips    workshop planning combinatorial search  conjunction
fourth international conference artificial intelligence planning systems  aips    
crawford  j  m          approach resource constrained project scheduling  proceedings      artificial intelligence manufacturing research planning workshop  pp        
culberson  j  c     luo  f          exploring k colorable landscape iterated
greedy   johnson   trick         pp          
feo  t  a     resende  m  g          greedy randomized adaptive search procedures 
journal global optimization             
garey  m  r     johnson  d  s          computers intractability  guide
theory np completeness  w  h  freeman 
glover  f     laguna  m          tabu search  kluwer 
glover  f   parker  m     ryan  j          coloring tabu branch bound   johnson
  trick         pp          
gomes  c   selman  b     kautz  h          boosting combinatorial search randomization  proceedings aaai     pp          
johnson  d  s     trick  m  a   eds            cliques  coloring  satisfiability  second
dimacs implementation challenge        vol     dimacs series discrete
mathematics theoretical computer science  american mathematical society 
   

fi squeaky wheel  optimization

joslin  d     clements  d           squeaky wheel  optimization  proceedings aaai    pp          
lewandowski  g     condon  a          experiments parallel graph coloring heuristics
applications graph coloring   johnson   trick         pp          
morgenstern  c          distributed coloration neighborhood search   johnson   trick 
       pp          
parkes  a     walser  j          tuning local search satisfiability testing  proceedings
aaai     pp          
pinson  e   prins  c     rullier  f          using tabu search solving resourceconstrained project scheduling problem  euro wg pms    euro working
group project management scheduling   pp          louvain  belgium 
selman  b   kautz  h  a     cohen  b          local search strategies satisfiability
testing   johnson   trick         pp          
syswerda  g  p          generation schedules using genetic procedure   u s  patent
number           

   


