journal artificial intelligence research                  

submitted       published      

taming numbers durations model checking
integrated planning system
stefan edelkamp

stefan edelkamp cs uni dortmund de

baroper strae    
fachbereich informatik  gb iv
universitat dortmund
      dortmund
germany

abstract
model checking integrated planning system  mips  temporal least commitment heuristic search planner based flexible object oriented workbench architecture 
design clearly separates explicit symbolic directed exploration algorithms
set on line off line computed estimates associated data structures 
mips shown distinguished performance last two international planning competitions  last event description language extended pure propositional
planning include numerical state variables  action durations  plan quality objective
functions  plans longer sequences actions time stamped schedules 
participant fully automated track competition  mips proven
general system  track every benchmark domain efficiently computed plans
remarkable quality  article introduces analyzes important algorithmic
novelties necessary tackle new layers expressiveness benchmark
problems achieve high level performance 
extensions include critical path analysis sequentially generated plans generate
corresponding optimal parallel plans  linear time algorithm compute parallel
plan bypasses known np hardness results partial ordering scheduling plans
respect set actions imposed precedence relations  efficiency
algorithm allows us improve exploration guidance  encountered planning
state corresponding approximate sequential plan scheduled 
one major strength mips static analysis phase grounds simplifies
parameterized predicates  functions operators  infers knowledge minimize
state description length  detects domain object symmetries  latter aspect
analyzed detail 
mips developed serve complete optimal state space planner 
admissible estimates  exploration engines branching cuts  competition
version  however  certain performance compromises made  including floating point
arithmetic  weighted heuristic search exploration according inadmissible estimate
parameterized optimization 

   introduction
practical action planning model checking appear closely related  mips
project targets integration model checking techniques domain independent
action planner  hsf spin experimental model checker  edelkamp  leue    lluchlafuente        looking towards integration planning technology
c
    
ai access foundation  rights reserved 

fiedelkamp

existing model checker  additional synergies exploited automated compilation
protocol software model checking problems planner inputs  edelkamp        
model checking  clarke  grumberg    peled        automated process verify
formal model system satisfies specified temporal property not  illustrative
example  take elevator control system together correctness property requires
elevator eventually stop every call passenger guarantees door
closed  elevator moving  although success checking correctness limited 
model checkers found many errors current hardware software designs  models
often consist many concurrent sub systems  combination either synchronous 
often seen hardware design verification  asynchronous  frequently given communication security protocols  multi threaded programming languages java 
model checking requires exploration large state spaces containing reachable system states  problem known state explosion problem occurs even
sets generated states much smaller set reachable states 
error shows safety property violation  deadlock failed assertion 
corresponds one set target nodes state space graph  roughly speaking 
something bad occured  liveness property violation refers  seeded  cycle
graph  roughly speaking  something good never occur  case elevator
example  eventually reaching target state request button pressed liveness
property  certifying closed doors refers safety property 
two main validation processes model checking explicit symbolic search 
explicit state model checking state refers fixed memory location state
space graph implicitly generated successive expansions state 
symbolic model checking  mcmillan        clarke  mcmillan  dill    hwang        
 fixed length  binary encodings system states used  state represented characteristic function representation  function evaluates true
boolean state variables assigned bit values respect binary
encoding system state  subsequently  characteristic function conjunction
literals plain variable   encoding negated variable    sets
states expressed disjunction individual characteristic functions 
unique symbolic representation sets states boolean formulae binary
decision diagrams  bdds   bryant        often much smaller explicit one  bdds
 ordered  read once branching programs nodes corresponding variables  edges
corresponding variable outcomes  path corresponding assignment
variables resulting evaluation leaves  one reason succinctness
bdds directed acyclic graphs may express exponentially many paths  transition
relation defined two state variable sets  evaluates true  operator
exists transforms state valid successor  sense  bdds exploit regularities
state set often appear well suited regular hardware systems  contrast  many
software systems inherit highly asynchronous irregular structure  use
bdds fixed variable ordering generally flexible enough 
symbolic exploration  set states combined transition relation
compute set possible successor states  i e  image  starting initial
state  iteration image computations eventually explores entire reachable state space 
   

fitaming numbers durations mips

improve efficiency image computations  transition relations often provided
partitioned form 
correspondence action model checking  giunchiglia   traverso       
roughly characterized follows  similar model checkers  action planners implicitly generate large state spaces  exploration approaches based applying
operators current state  states spaces model checking planning problems
often modelled kripke structures  i e  state space graphs states labelled propositional predicates  satisfaction specified property one side corresponds
complete exploration  unsolvable problem side  respect 
goal action planning cast error corresponding trail interpreted
plan  elevator example  goal planning task reach state 
doors open elevator moving  action planning refers safety properties only 
since goal achievement traditional competition planning problems yet
extended temporal properties  however  temporally extended goals increasing
research interest  kabanza  barbeau    st denis        pistore   traverso        lago 
pistore    traverso        
contrast model checkers perform either symbolic explicit exploration  mips
features both  moreover  combines symbolic explicit search planning form
symbolic pattern databases  edelkamp      b   planner mips implements heuristic
search algorithms a   pearl        ida   korf        exploration  include
state to goal approximation search process rank states expanded next 
heuristic search brought considerable gains planning  bonet   geffner       
refanidis   vlahavas        hoffmann   nebel        bertoli  cimatti    roveri      a 
jensen  bryant    veloso        feng   hansen        model checking  yang   dill 
      edelkamp et al         groce   visser        bloem  ravi    somenzi        ruys 
      
including resource variables  fuel level vehicle distance two
different locations  well action duration relatively new aspects competitive
planning  fox   long         input format pddl    restricted variables
finite domain  includes rational  floating point  variables precondition
effects  similar set atoms described propositional predicate  set numerical
quantities described set parameters  notation pddl    
refer parameterized numerical quantities functions  example  fuel level might
parameterized vehicle present problem instance file description 
competition  domains provided different tracks according different layers language expressiveness  i  pure propositional planning  ii  planning numerical
resources  iii  planning numerical resources constant action duration  iv  planning
numerical resources variable action duration  and  cases  v  complex problems usually combining time numbers interesting ways  mips competed
fully automated system performed remarkably well five tracks  solved large
number problems fully automated planner produced solutions
track every benchmark domain 
paper main algorithmic techniques taming rational numbers  objective
functions  action duration described  article structured follows  first 
review development mips system assert main contributions 
   

fiedelkamp

address object oriented heuristic search framework system  subsequently 
introduce terminology allows us give formal definition syntax
semantics grounded mixed numerical propositional planning problem instance 
introduce core contributions  critical path scheduling concurrent plans 
efficient methods detecting using symmetry cuts  pert scheduling produces
optimal parallel plans linear time given sequence operators precedence relation
among them  paper discusses pruning anomalies effect different optimization
criteria  analyze correctness efficiency symmetry detection detail 
article closes related work concluding remarks 

   development mips
competition version mips refers initial work  edelkamp   reffel      a 
heuristic symbolic exploration planning domains cke model checker  biere 
       approach effective sample puzzle solving  edelkamp   reffel       
hardware verification problems  reffel   edelkamp        
implementing propositional planner  first used bdd library called
staticbdd  large node tables allocated prior use  implementation process changed bdd representation mainly improve performance
small planning problems  selected public domain c   bdd package buddy  lindnielsen         flexible  planning process semi automated  edelkamp
  reffel      b   variable encodings provided hand  representations
operators established enumerating possible parameter instances 
state space encoding action transition relation fixed  exploration form
symbolic breadth first search state space could executed  time 
aware work bdd based planning work cimatti et al 
        likely first link planning via symbolic model checking  team used
model checker  nu smv basis atom to variable planning state encoding
scheme top it 
later on  developed parser static analyzer automate inference state
encodings  generation transition relations  extraction solution paths 
order minimize length state encoding  new analyzer clustered atoms
groups  edelkamp   helmert         confirmed attempts  weismuller        
started experimenting pddl specification cke  state minimization fact
crucial  simple encoding using one variable atom appears competitive
respect graphplan based  blum   furst        sat plan based planners  kautz
  selman         subsequently  mips first fully automated planning system based
symbolic model checking technology could deal large domain descriptions 
second international planning competition mips  edelkamp   helmert       
could handle strips  fikes   nilsson        subset pddl language  mcdermott        additional features adl  pednault         namely negative
preconditions  universal  conditional effects  mips one five planning systems
awarded distinguished performance fully automated track  competition
version  edelkamp   helmert        already included explicit heuristic search algorithms
based bit vector state representation relaxed planning heuristic  rph   hoff   

fitaming numbers durations mips

mann   nebel        well symbolic heuristic search based hsp heuristic  bonet
  geffner        one to one atom derivative rph  competition  used
breadth first bi directional symbolic search whenever single state heuristic search engine
got stuck exploration 
planning competitions  explicit  edelkamp      c  symbolic pattern
databases  edelkamp      b  proposed off line estimators completely explored
problem abstractions  roughly speaking  pattern database abstractions slice state vector fluents pieces adjust operators accordingly  completely explored
subspaces serve admissible estimates overall search competitive
relaxed planning heuristic several benchmark domains 
third planning competition new levels planning domain description language  pddl  designed  level   considers pure propositional planning  level  
includes numerical resources objective functions minimized  level   additionally
allows specification actions durations  consequently  mips extended
cope new forms expressiveness 
first results mips planning pddl    problems presented  edelkamp 
    b   preliminary treatment illustrates parsing process two simple benchmark domains  moreover  propositional heuristics manual branching cuts applied
accelerate sequential plan generation  work extended  edelkamp      a  
presented two approximate exploration techniques bound fix numerical
domains  first results symmetry detection based fact groups  critical path scheduling 
any time wrapper produce optimal plans  numerical extension rph 

   architecture mips
figure   shows main components mips data flow input definition
domain problem instance resulting temporal plan output 
shown shaded light gray  mips divided four parts  pre compilation  heuristics 
search algorithms  post compilation  scheduling   henceforth  planning process
coarsely grouped three stages  pre compilation  heuristic search planning 
construction temporal plans  problem domain description files fed
system  analyzed grounded  fixes state space problem solved 
intermediate result implicit  saved file use planners model
checkers  basics pre compilation covered section     
next stage defines planning process  object oriented workbench design
planner allows different heuristic estimates combined different search
strategies access data structures  possible choices listed sections         
temporal planning based  pert  scheduling  issue rearranging sequential
 relaxed  plans addressed detail section     
planning system developed spirit heuristic search framework 
hsf short  edelkamp         allows attachment newly implemented problem
 puzzle  domains already compiled system  similar approach took
model checking within hsf spin  kept extensible general design  fact
characterized action planning protocol validation single agent challenges 
contrast model checking approach  planning devised hierarchy system
   

fiedelkamp

domain pddl

problem pddl

precompiler
static analyzer
ground

symmetry

cluster

intermediate representation
heuristics
explicit pdbs

symbolic pdbs

numerical
rph

search algorithms

relaxed plan

symbolic search

explicit search
rph

bdda   bdd bfs

a   ida   ehc
scheduling
rph

sequential plan

relaxed
temporal plan

scheduler
critical path

temporal plan

pert

figure    architecture mips 

states  implementation numerical states derived class one propositional
states 
similarily  heuristic search algorithms based abstract search class 
main procedures provided search algorithm state expansion
procedure  heuristic search evaluation function  located one hierarchically organized heuristic estimator classes  sense  algorithms mips general
node expanding schemes adapted different problems  additional data
structures horizon list open visited list closed constructed parameters appropriate search algorithms  result  implementations heuristic
search algorithms associated data structures planner mips almost match
model checker 
    example problem
running example paper instance rather simple pddl    problem
zeno travel  illustrated figure    initial configuration drawn left
   

fitaming numbers durations mips



scott

b

dan

c

    



c



   

b

   

    

   

    

ernie

   

    



scott
ernie

dan

figure    instance zeno travel domain initial state  left  goal state s 
 right  

figure goal configuration right  global local numeric variable
assignments shown 
figures     provide domain problem specifications    instance asks
temporal plan fly passengers  dan  scott  ernie  located somewhere small
map  including cities city a  city b  city c  city d  aircraft  plane 
respective target destinations  boarding debarking take constant amount
time  plane fixed fuel capacity  fuel time consumed according
distances cities travel speed  fuel restored refueling
aircraft  result  total amount fuel maintained numerical quantity 
    precompiler
static analyzer takes domain problem instance input  grounds propositional state information infers different forms planner independent static information 
parsing simple lisp parser generates tree lisp entities  reads input files
recognizes domain problem name  cope variable typing  temporarily assert constant typed predicates removed together constant
predicates pre compilation step  thereby  infer type hierarchy
associated mapping objects types 
indexing based number counted objects  indices grounded predicates 
functions actions devised  since example problem eight objects predicates two parameters  reserve            
index positions  similarly  function distance consumes    indices  fuel 
         denotes source fragments omitted sake brevity  given example
action definitions passenger debarking flying airplane 

   

fiedelkamp

 define  domain zeno travel 
  requirements  durative actions  typing  fluents 
  types aircraft person city 
  predicates  at  x    either person aircraft   c   city 
 in  p   person  a   aircraft  
  functions  fuel  a   aircraft   distance  c    city  c    city 
 slow speed  a   aircraft   fast speed  a   aircraft 
 slow burn  a   aircraft   fast burn  a   aircraft 
 capacity  a   aircraft 
 refuel rate  a   aircraft 
 total fuel used   boarding time   debarking time  
  durative action board
 parameters   p   person  a   aircraft  c   city 
 duration     duration boarding time 
 condition  and  at start  at  p  c  
 over  at  a  c   
 effect  and  at start  not  at  p  c   
 at end  in  p  a    
     
  durative action zoom
 parameters   a   aircraft  c   c    city 
 duration     duration     distance  c   c    fast speed  a   
 condition  and  at start  at  a  c   
 at start      fuel  a      distance  c   c    fast burn  a     
 effect  and  at start  not  at  a  c    
 at end  at  a  c   
 at end  increase total fuel used
    distance  c   c    fast burn  a    
 at end  decrease  fuel  a 
    distance  c   c    fast burn  a      
  durative action refuel
 parameters   a   aircraft  c   city 
 duration     duration        capacity  a   fuel  a    refuel rate  a   
 condition  and  at start     fuel  a   capacity  a   
 over  at  a  c   
 effect  at end  assign  fuel  a   capacity  a    
 

figure    zeno travel domain description pddl    

slow speed  fast speed  slow burn  fast burn  capacity  refuel rate
reserve eight index positions  quantities total fuel used  boarding time 
debarking time single fact identifier needed  last least model
duration additional quantity total time  special variable one
overwritten least commitment planning approach scheduling plans
described section   
   

fitaming numbers durations mips

 define  problem zeno travel   
  domain zeno travel 
  objects plane   aircraft
ernie scott dan   person
city a city b city c city d   city 
  init    total fuel used       debarking time        boarding time    
    distance city a city b           distance city b city a      
    distance city b city c           distance city c city b      
    distance city a city c            distance city c city a       
    distance city c city d            distance city d city c       
    fast speed plane                  slow speed plane             
    fuel plane      
    capacity plane      
    fast burn plane          
    slow burn plane          
    refuel rate plane             
 at plane city a   at scott city a   at dan city c   at ernie city c  
  goal  and  at dan city a   at ernie city d   at scott city d   
  metric minimize total time 
 

figure    zeno travel problem instance 
flattening temporal identifiers interpret action integral entity 
timed propositional numerical preconditions merged  similarly 
effects merged  independent time happen  invariant conditions
 over  at  a  c   action board added precondition set 
discuss rationale step section     
grounding propositions fact space exploration relaxed enumeration planning
problem determine superset reachable facts  algorithmically  fifo fact
queue compiled  successively extracted facts front queue matched
operators  time preconditions operator fulfilled  resulting
atoms according positive effect  add  list determined enqueued 
allows us separate constant facts fluents  since latter reached
exploration 
clustering atoms concise encoding propositional part separate fluents
groups  state planning space expressed conjunction  possibly trivial  facts drawn fact group  edelkamp   helmert 
       precisely  let  pi  o            oi    oi               number objects oi
fact  p o          true  establish single valued invariant
 pi  o            oi    oi                    allow better encoding  predicates
merged  example  three groups determine unique position
persons  one five  one group determines position plane  one
four   therefore    dlog  e     dlog  e      bits suffice encode total   
fluents 
   

fiedelkamp

grounding actions fact space exploration determines grounded operators 
preconditions met grounded  symbolic effect lists instantiated 
case determine    instantiated operators  which  simplifications
eliminate duplicates trivial operators  no ops   reduced    
grounding functions simultanous fact space exploration propositional part
problem  heads numerical formulae effect lists grounded 
example case three instantiated formulae fluent  vary time    fuel
plane  initial value     well total fuel used total time initialized zero  numerical predicates fact constants
substituted formula bodies  example  effect  board dan city a 
reduces  increase  total time        zoom plane city a city b 
numerical effects  increase  total time        increase  total fuel used 
        decrease  fuel plane        refuelling  however  reduce
single rational number  example effects  refuel plane city a 
simplify  increase  total time              fuel plane            
 assign  fuel plane        evaluate former assignment especially forward chaining planner  variable  total time  instantiated on the fly 
due fact value quantity  fuel plane  constant
changes time 
symmetry detection regularities planning problem respect transposition domain objects partially determined static analyzer addressed
detail section   
intermediate textual format static analyzer annotated grounded pddllike representation serves interface planners model checkers 
additional resource plan visualization  figures     show parts intermediate
representation inferred zeno travel example 
    heuristics
mips incorporates following heuristic estimates 
relaxed planning heuristic  rph  approximation number planning steps
needed solve propositional planning problem delete effects removed  hoffmann   nebel         heuristic constructive  returns set
operators appear relaxed plan 
numerical relaxed planning heuristic  numerical rph  extension rph
deal numbers combined propositional numerical approximation
scheme allowing multiple operator application 
pattern database heuristic  explicit pdb  different planning space abstractions
found greedy manner  yielding selection pattern databases fit main
memory  contrast rph  pattern database designed disjoint yielding
admissible estimate needed optimal planning a   edelkamp      c  
   

fitaming numbers durations mips

 define  grounded zeno travel zeno travel   
  fluents
 at dan city a 
 at dan city b 
 at dan city c 
 at dan city d 
 at ernie city a   at ernie city b   at ernie city c   at ernie city d 
 at plane city a   at plane city b   at plane city c   at plane city d 
 at scott city a   at scott city b   at scott city c   at scott city d 
 in dan plane 
 in ernie plane   in scott plane  
  variables  fuel plane   total fuel used   total time  
  init
 at dan city c 
 at ernie city c   at plane city a   at scott city a 
    fuel plane           total fuel used         total time     
  goal  at dan city a 
 at ernie city d   at scott city d  
  metric minimize  total time   
  group dan
 at dan city a 
 at dan city b 
 at dan city c 
 at dan city d 
 in dan plane  
  group ernie
 at ernie city a   at ernie city b   at ernie city c   at ernie city d 
 in ernie plane  
  group plane
 at plane city a   at plane city b   at plane city c   at plane city d  
  group scott
 at scott city a   at scott city b   at scott city c   at scott city d 
 in scott plane  

figure    grounded representation zeno travel domain 
symbolic pattern database heuristic  symbolic pdb  symbolic pdbs apply explicit symbolic heuristic search engines  edelkamp      b   due succinct
bdd representation sets states  symbolic pdbs often orders magnitudes
larger explicit ones 
scheduling relaxed plan heuristic  scheduling rph  critical path analysis
scheduling guide plan finding phase  rph  computes length
greedily extracted sequential plan  scheduling rph takes relaxed sequence
operators account  searches suitable parallel arrangement 
turn defines estimator function 
    exploration algorithms
algorithm portfolio includes three main explicit heuristic search algorithms 
a  a  algorithm  hart  nilsson    raphael        variant dijkstras singlesource shortest path exploration scheme executed re weighted state space graph 
lower bound heuristics  a  shown generate optimal plans  pearl        
weighting influence heuristic estimate may accelerate solution finding 
affects optimality  pohl        
   

fiedelkamp

  action board dan plane city a
 condition
 and  at dan city a   at plane city a  
 effect
 and  in dan plane   not  at dan city a  
 increase  total time                
     
  action zoom plane city a city b
 condition
 and
 at plane city a 
     fuel plane                
 effect
 and  at plane city b   not  at plane city a  
 increase  total time              
 increase  total fuel used               
 decrease  fuel plane                 
     
  action refuel plane city a
 condition
 and
 at plane city a 
    fuel plane                
 effect
 and
 increase  total time                      fuel plane                
 assign  fuel plane                 
     
 

figure    grounded representation zeno travel domain  cont   

iterative deepening a   ida   memory limited variant a  suited large
exploration problems evaluation functions small integer range low time
complexity  korf         ida  extended bit state hashing  edelkamp  
meyer        improve duplicate detection respect ordinary transposition
tables  reinefeld   marsland        
 enforced  hill climbing  hc  approach another compromise exploration exploitation  enforced hc searches improved evaluation
breadth first manner commits established action selections final  hoffmann 
       enforced hc complete undirected problem graphs 
mips features following two symbolic search algorithms   
   non deterministic domains  started implementing weak  strong strong cyclic exploration algorithms  cimatti  roveri    traverso        

   

fitaming numbers durations mips

bidirectional symbolic breadth first search  bdd bfs  implementation performs bidirectional blind symbolic search  choosing next search direction favor
faster execution previous iterations  edelkamp   helmert        
symbolic a   bdda   algorithm  edelkamp   reffel        performs guided symbolic search takes  possibly partitioned  symbolic representation heuristic
additional input 
    composition competition version
figure   shaded parts actually used competition version
mips dark gray  used relaxed planning heuristic sequential plan generation 
scheduling relaxed planning heuristic used temporal domains  level  
problems use numerically extended rph  since added system
final weeks competition  experimented  symbolic  pattern databases
mixed results  since pattern databases purely propositional implementation
provide retrieval operators optimal abstract plan  include
competition version 
approach extend relaxed planning heuristic numerical information helps
find plans challenging numerical domains settlers influenced hoffmanns work competing planner metric ff  hoffmann      a   builds relaxed
planning graph computing fixed point state vector restricted monotonically
increasing propositional numerical variables  version integrating numbers
relaxed planning heuristic general hoffmanns contribution  restricted
variable to constant comparisons lacks ability simplify linear constraints 
therefore  omit algorithmic details paper 
decided employ  enforced  hill climbing explicit plan generation done
metric ff probably lpg  instead applied a  weight    merit
states fixed f  s    g s      h s   conservative plan generation
engine chosen avoid unrecognized dead ends  expected present
benchmark problems  objective that  least  completeness preserved 
avoided known incomplete pruning rules  action relevance cuts  hoffmann  
nebel        goal ordering cuts  koehler   hoffmann        
mips   weighted  a  accesses dial weak heap priority queue data
structure  former used propositional planning only  latter applies
general planning scheduling estimates  dial priority queue  dial        linear
run time behavior  maximal value w u  v    h v  h u  edges  u  v 
weighted state space graph  labelled heuristic h  bounded constant  weakheaps  edelkamp   stiegeler        simple efficient relaxations ordinary heaps 
priority queues implemented dynamic tables double sizes
become filled  moreover  mips stores generated expanded states hash table
chaining     compression planning state space  variables
appear objective function neglected hash address calculations state
   alternative storage structure collection persistent trees  bacchus   kabanza         one
predicate  best case  queries update times structure logarithmic number
represented atoms 

   

fiedelkamp

comparisons  general  may lead sub optimal pruning duplicates  however 
benchmark domains destroy optimality  since variables addressed
objective function frequently monotonic synonyms found later search
refer worse solutions 
price paid selecting a   especially planning problems large branching factors  storing frontier nodes space consuming  recent techniques
partial expansion horizon list  yoshizumi  miura    ishida        reduced storage
visited list  korf   zhang        zhou   hansen        included
system  cases  number expanded nodes often large 
computing relaxed planning estimate appeared computational bottleneck 
retrospect  domains chosen  dead ends central  hill
climbers appeared effective finding solutions 
temporal domains introduced additional parameter scale influence
propositional estimates  fp  s    gp  s      hp  s   scheduled ones  fs  s   
gs  s      hs  s    precisely  altered comparison function priority queue 
comparison parallel length priorities invoked propositional difference
values larger in    higher value refers higher influence
scheduling rph      indicates scheduling all  competition produced
data      pure mips        optimized mips   comparisons mips
planners plain version used  since produces solutions 
 edelkamp      a  experimented enumeration approach fix numerical
variables finite domain  any time wrapper optimization objective
functions  options excluded competition version
unpredictable impact planners performance 
    visualization
visualization important ease plan understanding quickly detect inefficiencies
plan generation module  visualization plans mips extended
animation system vega  hipke         client server architecture runs annotated
algorithm server side  visualized client side java frontend 
main purpose server make algorithms accessible tcp ip  able
receive commands multiple clients time  extended vega two
ways  cf  figures      
gannt chart visualization gannt charts representations schedules 
horizontal bars drawn activity  indicating estimated duration cost 
user selects planner executed domain problem file 
interpreted command line options  alternatively  established plans sent
directly visualizer void planner merely mirrors solution file 
benchmark visualization second extension program suite visualize competition domains  moment  sequential plans shown  temporal
plans  refined simulation required  one produced pddl    plan
validator  fortunately  mips temporal plan rescheduling sequential
one 
   

fitaming numbers durations mips

figure    visualization plan gannt chart format 
images represent domain objects collected image web search
engine    generalize specific instances  advised mips planner export
propositional numeric state infomation established plan c like syntax 
turn included header domain visualizer 

   pddl    planning
section elaborate metric temporal planning mips  give formal
description grounded planning instances introduce temporal model
   used google  cf  www google de  searched small gifs

   

fiedelkamp

figure    visualization planning problem instance settlers 

chosen  next look operator dependency resulting action precedence relation 
discuss optimality approach anomalies occur state
space pruning  last least  turn treatment arbitrary plan objective
functions 
table   displays basic terminology sets used paper  currently
successful planning system  mips grounds parameterized information present domain
description  set infer suitable index set  indicated bijective mapping
set finite domain  embedding important deal unique identifiers
entities instead textual internal representation  arrays containing
corresponding information accessed constant time 
   

fitaming numbers durations mips

set
obj
ype
pred
fun c
act

f
v

descriptor
objects
object types
predicates
functions
actions
operators
fluents atoms
variables

example s 
dan  city a  plane       
aircraft  person       
 at  a  c    in  p  a        
 fuel  a    total time        
 board  a  p    refuel  a        
 board plane scott        
 at plane city b        
 fuel plane    total time        

table    basic set definitions 

consequently  several planning systems  mips refers grounded planning
problem representations 
definition    grounded planning instance  grounded planning instance quadruple
p   hs  i  o  gi  set planning states  initial state  g
set goal states  mixed propositional numerical planning problem state
space given
 f ir v   
 f power set f  therefore  state pair  sp   sn   propositional
part sp  f numerical part sn ir v   
sake brevity  assume operators normal form  means
propositional parts  preconditions effects  satisfy standard strips notation  fikes  
nilsson        numerical parts given form arithmetic trees taken
set trees arithmetic operations nodes numerical variables
evaluated constants leaves  however  fundamental difference
general representation preconditions effects  current implementation mips
simplifies adl expressions preconditions takes generic precondition trees
numerical parts  thereby including comparison symbols  logical operators arithmetic
subtrees   
definition    syntax grounded planning operators  operator normal form
           propositional preconditions f  propositional effects    a    
f   add list delete list   numerical preconditions   numerical effects  
numerical precondition c triple c    hc     tc    hc v                
tc   arithmetic tree  numerical effect triple  
 hm     tm    hm v         tm   case  call hm head
numerical effect 
   newer versions mips mixing numerical logical preconditions form  or p    f     
p f f v fact feasible  boolean expressions put negational normal form
disjunction precondition produce different action instantiations 

   

fiedelkamp

obviously                represents associated comparison relation  denotes assignment variable  indicate respective increase decrease
operation 
definition    constraint satisfaction modifier update  let index mapping
variables  vector sn    s            s v    numerical variables satisfies numerical
constraint c    hc     tc   s hc   eval sn   tc   true  eval sn   tc   ir
obtained substituting v v tc s hc   followed simplification tc  
    modifier
vector sn    s            s v    updated vector sn     s             s v 
   hm     tm    
 
s h
  eval sn   tm      
m 
 
s h
  s hm     eval sn   tm      
m 
 
s h
  s hm   eval sn   tm      
m 

next formalize application planning operators given state 
definition    semantics grounded planning operator application  operator  
         applied state    sp   sn    sp  f sn ir v    yields successor
state      sp    sn     f ir v  follows 
sp sn satisfies c sp     sp     vector sn updated
 
propositional update sp     sd     defined standard strips 
example take state    sp   sn  
sp     at ernie city d    at plane city a    at scott city d    in dan plane  
sn     fuel plane              total fuel used                total time         
successor sn     sp    sn    due action  debark dan plane city a 
sp      at dan city a    at ernie city d    at plane city a    at scott city d  
sn      fuel plane              total fuel used                total time         
effect lists order update operations important  example
refuelling aircraft zenotravel  cf  figure    fuel level reset variable
total time updated 
set goal states g often given g    gp   gn   partial propositional state
description gp f  gn set numerical conditions c    hc     tc    moreover 
arithmetic trees tc usually collapses simple leaves labelled numerical constants 
hence  sake simplifying complexity analysis object symmetry
might assume  gn    v   complex goal description limitation planner 
since easily transformed preconditions goal enabling opererator 
   

fitaming numbers durations mips

    temporal model
simplest approach solving temporal planning problem generate sequential
plan  course  option assumes temporal structure contributes
value plan correctness  is  assumes necessary
concurrency valid plan  cases actions achieve conditions start
points delete end points  example  concurrency necessary
part structure valid plan 
definition    sequential plan  solution planning problem p   hs  i  o  gi
form sequential plan ordered sequence operators oi o              k  
transforms initial state one goal states g g  i e   exists
sequence states si s              k   s    i  sk   g si outcome
applying oi si                k  
time stamp ti durational operator oi               k  starting time 
pi 
d oj   
d oi   duration operator oi   ti   j  
sequential plans  time stamps calculated mips using extra variable
total time  variable updated scheduling operators  example sequential plan time stamps shown figure    
minimizing sequential plan length objective first second planning competitions  since graphplan like planners  blum   furst        ipp  koehler 
nebel    dimopoulos        stan  long   fox        already produced parallel plans
 assuming action duration     indeed limiting factor evaluating plan quality 
important reason artificial restriction total ordered plans
easier automatically validate  necessity checking correctness competition 
pddl     domain descriptions include temporal modifiers start  all  end 
label start denotes preconditions effects invocation time
action  refers invariance condition end finalization conditions
consequences action 
figure   show two different options flattening information simple
preconditions effects order derive semantic sequential plans  first
case  top right   compound operator split three smaller parts  one action
invocation  one invariance maintenance  one action termination 
semantics suggested  fox   long        
pddl    effects invariance pattern  i e  b       action
board  quite natural code invariance form conditions  b  perform
actual status change  person boards aircraft city aircraft required
remain city throughout action  moving corridor  status
corridor could encoded invariant would change starting
time action execution 
moreover  found benchmarks uncommon new effects at start
preconditioned termination control invariance maintenance  i e  a   b c     
even though intersection conditions effects formally defined yet 
interpreted executing one construct interfere one  reflects
   

fiedelkamp

pre  eff  pre  eff  pre  eff 
at start

over all

at end

cond 



b

c

eff 

a 

b 

c 

a 

pre 

b b 

c c 

eff 

abc

a  b   c  

figure    compiling temporal modifiers operators 
possible partition operator sub operators a  b  c  a    b     c     dependence
transposition separated conditions effects considered section     
consider example problem more  observe  action board  a 
consists  person airplane  predicate  seen above  b requires plane stay
city boarding  c empty  action zoom  a  contains effect
plane longer location flight started  b c empty 
cases a   b c     
b     a   b c    sequential execution sequence
sub operators  a  a    b  b     c  c     equal execution sequence  a  b  c  a    b     c     
reasoning follows  since b      a  a    b  b     c  c        a  a    b  c  c     
conditions a  b   a  c   allows us exchange order corresponding
items   a  a    b  c  c        a  b  c  a    c      more  apply b     derive
 a  b  c  a    c        a  b  c  a    b     c      consequence remains valid condition
b     weakened b   c    
mips operator representation bottom right figure   chosen  note
intermediate format example problem figures     implicitly assumed
temporal model  sequential planning competition benchmark domains
observed many deficiencies model   
however  applicability model exploiting parallelism limited  example
consider two people lift table two sides once  could done
one person alone  case parallel execution set actions
cannot totally ordered  allowed mips  may argued defining
action requires two different persons certain place would require
equality construct pddl form numerical maintenance number
people room  found another  artificial  example planning problem
total order  consider simple strips planning problem domain    b  
g     a  c         b    a    b      b    c    b     obviously  operators
needed goal achievement  sequential plan length    since b
deleted operators  however  parallel plan could devised  since precondition
fulfilled first time step 
   current versions mips refined model  at start  all  at end information
preserved grounding process attached action  approach allow
dependent operators overlap minimizes number gaps  start start  start end
end end exclusions  domains  improvement yields much better solutions 

   

fitaming numbers durations mips

    operator dependency
definition operator dependency enables computing optimal schedules sequential
plans respect generated action sequence causal operator dependency
structure  operators dependent  or void respect optimizer function  
problem inherently sequential schedule leads improvement 
definition    dependency mutex relation  let l t  denote set leaf variables
tree   two grounded operators            o                    
dependent mutex  one following three conflicts hold 
propositional conflict propositional precondition set one operator nonempty intersection add delete list other  i e    a  d      
 a         
direct numerical conflict head numerical modifier one operator contained
condition one  i e  exists c     h c     t c    
   hm     tm   hm l t c    h c   exists c    hc     tc  
m     h m     t m     h m l tc    hc   
indirect numerical conflict head numerical modifier one operator contained formula body modifier one  i e   exists
   hm     tm   m     h m     t m     hm l t m   h m l tm   
example  operators  board scott plan city a   fly plane city a
city c  propositional conflict fluent  at plane city a    refuel
plane a city a   fly plane city a city c  direct numerical conflict
variable  fuel plane   indirect conflicts subtle  appear
example problem 
use dependency find optimal concurrent arrangement operators
sequential plan  o  dependent o  o  appears o  sequential
plan  o  invoked o  starts  dependence relation reflexive  i e 
conflict o  o  conflict o  moreover  appears restrictive
compared pddl     guidelines mutual exclusion  fox   long        
allows operators partially overlapping even dependent 
however  possible generalize approach  if  according model fox
long  two actions oi represented  ai   a i   bi   bi    ci   ci            
dependency violation o  o  located identifying sub operators
interact  fact may identify eight possible refined conflicts  a  a    
interacts  a  a       a  a     interacts  b  b       a  a     interacts
 c  c       b  b     interacts  a  a       b  b     interacts  c  c       c  c    
interacts  a  a       c  c     interacts  a  a       c  c     interacts
 a  a      asserting duration zero pair  ai   a i    d a   bi   bi     zero
pair  ci   ci     one fix earliest start end time o  respect o   
competition version mips  stick simplified temporal model 
competition domains  improving sequential plans according dependency relation
turned produce plans sufficient quality 
   

fiedelkamp

implementation  dependence relation computed beforehand tabulated
constant time access  improve efficiency pre computation  set leaf
variables maintained array  grounded operator constructed 
original graphplan definition propositional mutex relation close ours 
fixes interference d   a       a          
lemma   d      operator inference graphplan model implied
propositional mips model dependence 
proof  d      two independent operators        o             
 a  d      implies  a  d        turn yields d      condition
a    inferred analogously 
notion dependency related partial order reduction explicit state model
checking  clarke et al          two operators o  o  independent
state following two properties hold 
   neither o  o  disable execution other 
   o  o  commutative  i e  o   o   s     o   o   s   s 
next result indicates state space enumeration approaches refer
property 
theorem    commutativity  two independent  strips  operators        o   
         d    commutative preserve enabled property  i e 
o  enabled enabled o   s  o  enabled o s   
proof  since d      d    a    lemma    let
state   s       let    state   s   d    a     since  a  d       
enabled      since  a         o  enabled     moreover 
s 

o o   s        s   d    a       
     s   d        a   
     d     a   
     d d     a a   
     s       d      a 
     s         d    a    o   o s   

consequence  operator independence indicates possible transpositions two operators o  o  prune exploration sequential plan generation  less restrictive
notion independence  several actions may occur time even one
deletes add effect another provided  knoblock         detect domains
parallelization leads improvement  utilize following sufficient criterion 
   

fitaming numbers durations mips

definition    inherent sequential domains  planning domain said inherently
sequential operator sequential plan either instantaneous  i e  zero
duration  dependent immediate predecessor 
static analyzer checks testing operator pair  benchmark domains desertrats jugs and water inherently sequential  others zenotravel
taxi not 
definition    parallel plan  solution planning problem p   hs  i  o  gi
form parallel plan c     o    t              ok   tk    arrangement operators oi o 
            k   transforms initial state one goal states g g 
oi executed time ti ir   
example parallel plan zenotravel problem depicted figure    
backstom        clearly distinguishes partially ordered plans  o            ok     
relation  o            ok    partial order  reflexive  transitive  antisymmetric   parallel plans  o            ok                  irreflexive  symmetric 
expressing  actions must executed parallel 
definition    precedence ordering  ordering induced operators o            ok
defined
oi oj   oi oj dependent     j k 
precedence partial ordering  since neither reflexive transitive  computing
transitive closure relation  however  precedence could extended partial
ordering  sequential plan o            ok produces acyclic set precedence constraints
oi oj       j k  set operators  important observe 
constraints already topologically sorted according index order            k 
definition     respecting precedence ordering parallel plan  let d o 
ir  duration operator sequential plan  parallel plan c     o    t    
         ok   tk    respects   ti   d oi   tj oi oj       j k 
optimizing plans  backstrom        defines parallel execution time max ti  
d oi     oi  o            ok     oi oj   ti   d oi   tj   oi  oj  
either ti   d oi   tj tj   d oj   ti   two possible choices   actually
apparent approach  since already precedence relation hand
seek optimal arrangement operators  consequently assert one option 
namely ti   d oi   tj true  reducing     order find optimal schedules
sequential plans approach similar  backstrom        would necessary 
would dramatically increase computational complexity  since optimal scheduling
set fixed timed operators np hard  therefore  decided restrict dependency
relation  
definition     optimal parallel plan  optimal parallel plan respect sequence
operators o            ok precedence ordering plan     o    t              ok   tk   
minimal parallel execution time op   max ti   d oi     oi  o            ok    among
parallel plans c     o    t               ok   t k    respect  
   

fiedelkamp

procedure critical path
input  sequence operators o            ok   precedence ordering
output  optimal parallel plan length max ti   d oi     oi  o            ok   
            k 
e oi   d oi  
j               
 oj oi  
e oi     e oj     d oi  
e oi   e oj     d oi  
return max ik e oi  

figure     algorithm compute critical path costs 
many algorithms suggested convert sequential plans partially ordered
ones  pednault        regnier   fade        veloso  perez    carbonell        
interpret totally ordered plan maximal constrained partial ordering  
  oi   oj         j k  search less constrained plans  however  problem
minimum constraint deordering proven np hard  unless so called
validity check polynomial  backstrom         deordering maintains validity
plan lessening constrainedness  i e    new ordering    
since explicit model dependency time  optimal parallel plans
change ordering relation all 
    critical path analysis
project evaluation review technique  pert  critical path analysis algorithm
usually applied project management problems  critical path sequence activities
total time activities path greater equal
path operators  delay tasks critical path leads delay project 
heart pert network tasks needed complete project  showing order
tasks need completed dependencies them 
shown figure     pert scheduling reduces variant dijkstras shortest
path algorithm acyclic graphs  cormen  leiserson    rivest         matter fact 
algorithm returns length critical path inferred partially ordered
plan  however  obtaining temporal plan easy  algorithm  e oi   tentative
earliest end time operator oi               k   earliest starting times ti
operators optimal plan given ti   e oi   d oi   
theorem    pert scheduling  given sequence operators o            ok precedence ordering   optimal parallel plan     o    t              ok   tk    computed
optimal time o k        
proof  proof induction             k   induction hypothesis
iteration value e oi   correct  e g  e oi   earliest end time operator
   

fitaming numbers durations mips

oi   clearly true      since e o      d o     assume hypothesis
true   j   look iteration i  two choices  either j
               oj oi   case inner loop completed  e oi  
set max e oj     d oj     oj oi   j                  hand  e oi  
optimal  since oi cannot start earlier max e oj     oj oi   j                  since
values e oj   already smallest possible induction hypothesis 
j                oj oi   e oi     d oi   base case  therefore 
end  max ik e oi   optimal parallel path length 
time space complexity algorithm critical path clearly o k     
k length sequential plan  using adjacency list representation
efforts reduced time space proportional number vertices edges
dependence graph  size o k         bound optimal  since
input consists  k  operators       dependencies among them 
apply critical path scheduling  even consider temporal model fox
long  allowing overlapping operator execution dependent operators  answer
yes  already seen considering two dependent operators oi oj
fox long model  determine earliest start  and end  time oj respect
fixed start time oi   need  proof theorem   shows
determine earliest end time operators sequentially 
    optimality mips
since mips optimally schedules sequential plans  question remains  system
eventually find optimal plan  competition  system terminates
first sequential plan found  since relaxed planning heuristic admissible 
a  variants cannot guarantee optimal  sequential parallel  plans  however  computing
optimal plans desirable  even due limited computational resources finding optimal
plans hard 
according temporal model  optimal parallel plan  operator either starts
ends start end time another operator  therefore  least finite number
actions optimal plan  possibly exponential finite number possible
parallel plans 
immediately leads following naive plan enumeration algorithm   o i
operator sequences length i  in  generate possible parallel plans  check
individual schedule transforms initial state one goals  take
sequence smallest parallel plan length  since parallel plans computed  yields
complete optimal algorithm  seen example two persons lifting table 
approach expressive applying algorithm finds sequential
plans first  however  algorithm inefficient 
practice  natural assumption parallel plan corresponds least one
 possible many  sequential one s   conversely  partially ordered plan established
generating totally ordered plan first applying scheduling algorithm
find best partial order 
algorithm figure    indicates wrap forward chaining planner
any time performance gradually improves plan quality  general state
   

fiedelkamp

procedure any time
input  planning problem hs  i  o  gi
output  optimal parallel plan length

open
 open     
extract open 
  expand s 
 s   g 
cp critical path  path s       
 cp    
cp
else
change open     
return
figure     general any time search algorithm 
expanding scheme maintains search horizon list open  simplicity maintenance stored nodes list closed shown  algorithm  current best
critical path cost bounds upcoming exploration process  turn updated
time plan found shorter critical path 
criticalpath procedure above  algorithm returns execution time only 
established plan  compute plan meets returned value  
store schedule generating sequence path s     global record  cases 
storing   sufficient  since path pert scheduling restored calling
procedure criticalpath end procedure 
assuming optimal parallel plan schedule sequential plan state
space finite  any time extension cycle avoiding enumeration strategy indeed
complete optimal  reason completeness finite graphs number
acyclic paths g finite every node expansion  algorithm adds new
links traversal tree  newly added link represents new acyclic path  that 
eventually  reservoir paths must exhausted 
valid parallel plans cannot produced pert scheduling
sequential plan  answer no  partial ordering algorithm terminates
optimal schedule  generate corresponding sequential plan preserving
dependency structure  optimal pert scheduling plan respect set
operators imposed precedence relation yield optimal parallel plan 
sequential plans eventually generated  optimal parallel plan found
pert scheduling 
problem enumeration infinite state spaces infinite plateaus
plan objective function constant value  normally increasing length
plan increases cost  however  true benchmark problems  since
   

fitaming numbers durations mips

may infinite sequence events contribute plan objective 
example  loading unloading tanks pre competition test domain desertrats
affect total fuel consumption  minimized one instances 
enumeration schemes contradict known undecidability results numerical planning  helmert         additional information bound maximal
number actions plan number actions executed parallel 
cannot decide whether cycle free enumeration terminate not  hand
solution  any time algorithm eventually find it 
    pruning anomalies
acceleration techniques duplicate detection sequential plan generation
chosen carefully maintain parallel plan length optimality  approach affect
parallel optimality  following example shows  zenotravel problem consider
sequences
 zoom city a city c plane    board dan plane city c  
 refuel plane city c    zoom city c city a plane  
 board scott plane city a    debark dan plane city a    refuel plane city a  

 board scott plane city a    zoom city a city c plane  
 board dan plane city c    refuel plane city c  
 zoom city c city a plane    debark dan plane city a    refuel plane city a 
two sets operators resulting  sequentially generated 
states  however  pert schedule first sequence shorter schedule
second one  boarding scott done parallel final two actions
plan 
small problems  anomalies avoided omitting duplicate pruning 
example figure    depicts sequential plan example problem instance
pert schedule  turns overall optimal parallel plan  another option
store resulting parallel plan state caching instead sequential one  note
order ease generation sequential solutions large planning problem instances 
competition version mips used sequential state pruning 
    heuristic search
main drawback blind path enumeration seemingly slow practical
planning  heuristic search algorithms a  ida  reorder traversal states 
 assuming state caching  affect completeness optimality anytime wrapper  efficiency wrapper directly depends quality path
enumeration  competition version mips omitted any time wrapping  since
optimal solutions required practical run time behavior poor 
instead used a  search engine  terminates first established solution 
question remains  still hope finding near optimal parallel plans  general
result applicable infinite graphs established  pearl         cost every
   

fiedelkamp

  
    
    
    
    
    
    
    
    
    
    
    
    

 zoom plane city a city c       
 board dan plane city c 
    
 board ernie plane city c      
 refuel plane city c 
    
 zoom plane city c city a       
 debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
 zoom plane city a city c       
 refuel plane city c 
    
 zoom plane city c city d       
 debark ernie plane city d      
 debark scott plane city d      

    zoom plane city a city c       
      board dan plane city c 
    
 board ernie plane city c      
      refuel plane city c 
    
      zoom plane city c city a       
      debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
      zoom plane city a city c       
      refuel plane city c 
    
      zoom plane city c city d       
      debark ernie plane city d      
 debark scott plane city d      

figure     sequential plan zeno travel  left  pert schedule  right  

infinite path unbounded  a s cost function f   g   h preserve optimality 
additional rationale choosing a  like exploration mips instead hill climbing
best first  breadth first search  rising influence g value crucial 
find adequate heuristic estimate parallel plans easy  fact
established competitive admissible heuristic  required optimal plan
finding a   choice scheduling extension rph  contrast rph 
new heuristic takes relaxed sequence operators searches suitable parallel
arrangement  turn defines estimator function 
found adding pert schedules path state sequence
actions relaxed plan accurate pert schedule combined paths 
therefore  classical merit function a  like search engines f   g  h generating path
length g heuristic estimate h immediate correspondence parallel planning 
consequently  define heuristic value scheduling rph parallel plan length
combined path minus parallel plan length generating path 
    arbitrary plan objectives
pddl     plan metrics minimizing total  parallel  execution time
specified  influences inferred solutions  figure    depict two plans found
mips objective functions minimizing total fuel used  minimizing
compound           total time         total fuel used    
first case computed optimal value           second case
established          optimized merit  optimizing time  ordering board
zoom actions important  optimizing total fuel reduce speed save fuel
consumption        per flight may board first passenger immediately 
save two refuel actions respect first case 
increasing importance time trade refueling actions time 
zooming flight actions chosen complex minimization criterion 
first attempt include arbitrary plan objectives alter pert scheduling
process  however  results match ones produced validator  long  
   

fitaming numbers durations mips

    zoom plane city a city c       
      board dan plane city c 
    
 board ernie plane city c      
 refuel plane city c 
    
      zoom plane city c city a       
      debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
      fly plane city a city c       
      fly plane city c city d       
      debark ernie plane city d      
 debark scott plane city d      

    board scott plane city a      
     fly plane city a city c       
      board ernie plane city c      
 board dan plane city c 
    
      fly plane city c city a       
      debark dan plane city a      
 refuel plane city a 
       
         fly plane city a city c       
         fly plane city c city d       
         debark ernie plane city d     
 debark scott plane city d     

figure     optimized plans zeno travel according different plan objectives 
fox         final time substituted objective function plan
built 
way mips evaluates objective functions time follows  first schedules
 relaxed final  sequential plan  variable total time temporarily substituted
critical path value objective formula evaluated  avoid conflicts subsequent
expansions  afterwards value total time set back optimal one sequential
plan 

   object symmetries
important feature parameterized predicates  functions action descriptions
domain specification file actions transparent different bindings parameters
objects  disambiguating information present problem instance file 
case typed domains  many planners  including mips  compile type information additional predicates  attach additional preconditions actions enrich
initial states suitable object to type atoms 
consequence  symmetry viewed permutation objects present
current state  goal representation  transparent set operators 
n   n    obj    possible permutations set objects  taking
account type information reduces number possible permutation
n
t                k

 

 

n 
 
t   t          tk  

ti number objects type i              k   moderate sized logistic
domain    cities     trucks    airplanes     packages  results             
             permutations 
reduce number potential symmetries tractable size restrict symmetries
object transpositions  n n      o n    candidates  using
type information number reduces
k
x
ti
i  

 

 

 

k
x

ti  ti      

i  

   

fiedelkamp

following  set typed object transpositions denoted symm 
logistics example   symm                             
    generating object symmetries planning problems
section compute subset symm includes object pairs
entire planning problem symmetric  start object transpositions smallest
entities planning problem 
definition     object transpositions fluents  variables  operators  transposition objects  o  o    symm applied fluent f    p o            ok p    f  written
f  o o     defined  p o             o k p     o i   oi oi
   o  o     oi   o  oi   o 
oi   oi   o                k p    object transpositions  o o    applied variable
v    f o            ok f     v operator    a o            ok a    defined analogously 
example  zenotravel problem  at scott city a  scott dan   
 at dan city a  
lemma   f f  v v  o   o  o    symm  f  o o      f  o  o  
v o o      v o  o   o o o      o o  o   well f  o o    o o      f  
v o o    o o      v  o o o    o o      o 
brute force time complexity computing f  o o    f order o k p   
k p  number object parameters p  however  pre computing o  symm 
 f   sized lookup table  containing index f     f  o o     o  o    symm 
time complexity reduced o    
definition     object transpositions states  let mapping set
             t     object transposition  o o    applied state    sp   sn  
sn    v            vk    k    v   written s o o     equal  sp  o o     sn  o o    
sp  o o       f   f   f sp f     f  o o    
sn  o o       v             vk    vi   vj     i  o o         j  i  j             k  
initial state example problem i dan ernie    i  definition
variables slightly difficult predicates  since  case  variable
contents  availability  must match 
time complexity compute sn  o o    o k   since testing    i  o o     
   j  available time o    building another o  symm   v   sized pre computed
look up table  note times worst case  terminate computation
object symmetry fluent variable contradictory  summarize complexity
results follows 
lemma   worst case time complexity compute s o o    state    sp   sn  
 o  o    symm o  sp      v   using o  symm    f     v    space 
next step lift concept object transposition planning problems 
   

fitaming numbers durations mips

definition     object transpositions domains  planning problem p   hs  o  i  gi
symmetric respect object transposition  o o     abbreviated p o o    
i o o      g g  g o o    g 
since goal descriptions partial  prefer writing g o o    g instead g g 
g o o    g  moreover  assume goal description complexity g bounded
o  gp      v   
zenotravel problem  goal descriptor purely propositional  containing three
facts target location dan  ernie  scott  initial state running
example planning problem contains object symmetry  since i scott ernie    
g dan ernie     g 
applying lemma    o  o    symm yields time complexity needed establish object symmetries 
theorem    time complexity object symmetry detection  worst case run time
determine set object transpositions planning problem p   hs  o  i  gi
symmetric o  symm    gp      ip      v    
    including goal symmetry conditions
symmetries present initial state may vanish reappear exploration
forward chaining planner mips  desertrats domain  example  initial set
supply tanks indistinguishable one loaded truck 
fuel levels supply tanks decrease tanks transported another location 
previously existing symmetries broken  however  two tanks one location become
empty  considered symmetric 
goal conditions  however  change time  initial state transforms
current state c  therefore  pre compiling phase refine set symm
symm   o  o    symm   g o o      g  




usually   symm    much smaller  symm   zenotravel problem instance 
object symmetry left symm  transposition scott ernie 
therefore  efficiently compute set
symm    c    o  o    symm    c o o      c 
symmetries present current state  initial state example
problem zeno travel symm    i      scott ernie share
location state c object pair would included symm    c  
definition requires c o o      c  include symmetric paths
different states  let c     at ernie city c    at scott city d    possible
symmetric plan   at ernie city d    at scott city c   common
goal  viewed differently  complex object symmetries form  o  o     o  o    
detected  example observe c scott ernie  city c city d    c 
respect theorem   additional restriction reduces time complexity
detect remaining object symmetries o  symm      cp      v    
   

fiedelkamp

    pruning operators
planning problem current state c symmetric respect operator
transposition  o o    either application operator application
operator o o o    neglected  significantly reducing branching factor  lemma  
indicates symmetry used reduce exploration 
lemma   operator applicable   s o o    o o o    applicable

o s  o o      o o o    s  
proof  applicable o o o    applicable s o o     since  
s o o     o o o    applicable s 
o o o    s    o o o    s o o       o s  o o    

pre computing o  symm   o   sized table index  o    operator o   
o o o    determined time o     o  o    symm   
definition     pruning set  let index mapping set              t    let
 c  set operators applicable state c s  pruning set  c   c 
defined set operators symmetric counterpart
minimal index  symmetry reduction    c   c  defined  c     c  
theorem    correctness operator pruning  reducing operator set  c     c 
exploration planning problem p   hs  o  i  gi preserves completeness   
proof  suppose expanded state c  reducing operator set  c     c 
exploration planning problem p   hs  o  i  gi preserve completeness 
furthermore  let c state property maximal exploration order 
sequential plan    o          ok   pc   hs  o  c  gi associated
state sequence  s    c          sk g   obviously  oi  si                 k  
choice c o   s         s       s     definition pruning set
 s    exists o     o   o o    minimal index applicable s   
since pc   hs  o  c  gi   pc  o o      hs  o  c o o      c  g o o      gi  
sequential plan o   o o             ok  o o    state sequence  s   o o      s    s   o
o             sk  o o      sk   reaches goal g  contradicts assumption
reducing operator set  c     c  preserve completeness c 
since plan objective refers instantiated predicates objects  similar
initial goal state  symmetry breaking  order preserve optimality  one
additionally check  see object exchange influence plan objective 
practice  objective functions often based non parameterized predicates 
case optimal planning algorithm affected symmetry cuts 
   generally completeness means planner find legal plan  intended here 
use completeness terms discarding legal plans favor equally good symmetric plans 

   

fitaming numbers durations mips

    symmetry reduction mips
main purpose restricted implementation mips reduce run
time object symmetry detection losing effectiveness  especially
impact quantity o  symm     cp    running time considerable 
key observation symmetries present fact groups according
group representatives  shown figure    fact group dan consists facts
 at dan city a    at dan city b    at dan city c    at dan city d    in dan
plane   similarily  ernies group facts  at ernie city a    at ernie city b    at
ernie city c    at ernie city d    in ernie plane   ordering facts
groups chosen way that  except change group representative 
corresponding facts match  together facts groups  operators change
facts groups  stored efficient dictionary 
therefore  restrict object transpositions group representatives  reduces
set objects obj mips considers considerably smaller subset obj    
example problem  obj         obj          many objects  e g  objects
type city zenotravel  selected representatives single attribute invariance
build group 
idea obtain possible transposition fact group representatives  followed
looking respective fact positions current goal state  may happen 
one group fixed representative obj     case  link groups
representative common  symmetry detection test group chains
objects matching current goal position 
above  symmetries based non matching goal predicates excluded beforehand  let rsymm number remaining symmetries object representatives 
assume one representative per group yields running time propositional object
symmetry detection state c o rsymm    cp     remaining comparisons variables v v implemented described previous section  performed
object pairs pass propositional check 
pruning operators  mips marks groups correspond object symmetry
larger index visited  guarantees operator least one
group executed  expanded state matching operator  s 
algorithm checks  whether applied operator present visited group  case
pruned  time complexity o   s     since operator group containment
preprocessed checked constant time 
figure    shows effectiveness symmetry reduction planner mips desertrats domain  scales respect total distance d                       
passed  x axis   direction  number expanded states a 
search mips object symmetry reduction  right bars  without symmetry reduction  left bars  shown logarithmic scale  expected  larger problems symmetry
reduction yields performance gains one order magnitude  d        
yields solutions problems algorithms without symmetry reduction fail due
memory restrictions  d          
   memory bound used example set     gbyte 

   

fiedelkamp

figure     results symmetry pruning desert rats  bars show number states
expanded without with symmetry detection 

   related work
strips problems tackled different planning techniques  notably
sat planning  kautz   selman         ip planning  kautz   walser         cspplanning  rintanen   jungholt         graph relaxation  blum   furst         heuristic
search planning  bonet   geffner        
solving planning problems numerical preconditions effects allowed level  
level   problems undecidable general  helmert         however  structures
provided benchmark problems simpler general problem class 
problems fact solvable 
    temporal planning approaches
system metric ff  hoffmann      a  extends  hoffmann   nebel       
forward chaining heuristic state space planner level   problems  although  mips plan
generator shares several ideas metric ff  hoffmanns system yet extended
deal temporal domains 
planner tp   haslum   geffner        fact scheduling system based grounded
problem instances  cases formula trees numerical conditions assignments
reduce constants  utilizing admissible heuristics  tp  minimizes plan objective
optimal parallel plan length  planner distinctive advantages  handles
numerical preconditions  instantiates numerical conditions fly cope
complex objective functions  besides input restriction  competition  tp 
somewhat limited focus producing optimal solutions 
sapa system  do   kambhampati        domain independent time resource planner cope metrics concurrent actions  sapas general expressivity judged close mips  adapts forward chaining algorithm
 bacchus   ady         planning approaches instantiate actions fly
   

fitaming numbers durations mips

therefore  principle  adapted handle flexible mixed propositional numerical planning problems  search algorithm sapa extends partial concurrent plans
instead parallelizing sequential plans  uses relaxed temporal planning graph
yet unplanned events different heuristic evaluation functions  additional feature 
sapa provides option specifying deadlines 
planner lpg  gerevini   serina        based local search planning graphs 
uses variant planner grounding initial plans generated random walk  subsequent search space lpg consists so called action graphs  gerevini
  serina         temporal module performs action graph modifications transforming
action graph another one  fast plan generation algorithm lpg seems
best explanation speed advantage lpg respect mips 
higher number problems lpg solved domains  optimization lpg governed
lagrange multipliers  temporal domains  actions ordered using precedence graph
maintained search  uses refined dependency relation ours 
may partly explain plan quality fact consistently better mips 
ixtet  laborie   ghallab        general constraint based planning system
input format  planner searches space partial plans allows general
resource temporal constraints posed  internal representation consists
chronicles  time linearly ordered discrete set instants  multi valued state
variables either rigid flexible  contingent  controllable  resources   predicates
temporally qualified expressions  events  assertions  resources   temporal atemporal
constraints  clear compare expressivity chronicles pddl   
constructs  makes difficult link different temporal models determine
technique critical path scheduling applicable ixtet not  opinion
unlikely  since ixtet partial order  note ixtet allows conjunction
predicates  subtasks  constraints conditional expressions  available
pddl     analysis partial plans drives planning process divided
three different modules  feasibility  satisfiability resource conflict resolution 
competition domains ixtet able compete local search heuristic search
planners 
hsts  muscettola        constraint based planning system based temporal activity networks  written lisp crl  nasa used many projects
deep space one  already represent reason metric resources  parallel
activities  general constraints  ixtet input format significantly different
pddl     hsts yet adapted represent reason conditional
branches  however experiences hsts planner showed partial order planning
attractive metric temporal problems  need better search control 
although pddl    guidelines fact allow infinite branching       competition consisted finite branching problems  indicated earlier  paper
concentrates finite branching problems  finite branching  execution time
action fixed  infinite branching  continous range actions available 
problems confronted  real time  model checking long time 
subclasses infinite branching problems timed automata exhibit finite partitioning symbolic representation states  pettersson         technique
shortest path reduction unique reduced normal form obtained 
   

fiedelkamp

implemented temporal network structure  since main data structure
exploring timed automata done model checker uppaal  pettersson        
work  constraints must form xi xj c xi c  example 
set constraints x  x     x  x     x  x     x  x     x  x    
x  x     x  x     x  x     x  x      x  x    shortest path
reduction x  x     x  x     x  x     x  x     x  x     x  x     
x  x     constraint set over constrained  algorithm determine
unsolvability  otherwise feasible solution returned 
critical path analysis timed precedence networks one simpler cases
scheduling  achieved simplification solving sequential path problem first 
note many scheduling techniques apply presented critical path analysis
subcomponent  syslo  deo    kowalik        
    symmetry detection planning model checkers
previous results symmetry reduction planning  e g   guere   alami        
neglect combinatorial explosion possible symmetries least assume
information existing symmetries domain supplied user 
contrast  work shares similarities approach fox   long            
inferring object symmetry information fully automatically  fox longs work based
similarities established tim inference module  fox   long         search
additional information current symmetry level form object transposition
matrix stored updated together state  approach different sense
efficiently computes object symmetries state scratch consumes
extra space per node expansion 
model checking research long tradition symmetry reduction  clarke et al         
recent work  rintanen        connects symmetry detection planning model checking
approaches transition systems sat solving  experiments provided sat
encodings gripper domain  prototypical example symmetry detection   lluchlafuente         model checker hsf spin extended effectively combine heuristic
search symmetry detection  reflects fact  hsf  spins exploration
modelled using  labelled  transition systems  positive empirical results given
non trivial examples petersons mutual exclusion algorithm database manager
protocol 
briefly review fundamental difference object symmetries  as considered
here  state space symmetries  as considered model checking  
latter approach constructs quotient state space problem  p   based congruence relation  equivalence relation called congruence
s    s    s  s  s  operator o s      s   s  
s   s   operator o  o   s      s      o  s     s   
operator mapping s   s  s   s    
bijection   said symmetry  i    i   g  g g g
s  s  transition s  exist transition  s 
 s     set symmetries generates subgroup g a  called symmetry group 
subgroup g a  induces equivalence relation states  defined s 
   

fitaming numbers durations mips

 s    s  g a   equivalence relation called symmetry relation
p induced a  equivalence class called orbit s  denoted  s a  
symmetry relation p congruence p  moreover  reachable  s a
reachable  i a   reduces search goal g g finding state  g  
explore state space respect state  space  symmetry  function canonicalize needed  time new successor node generated  determines representative
element equivalence class  fixing canonical element trivial  many
systems approximate normal form  automatically finding symmetries setting
difficult cast computationally hard graph isomorphism problem 
therefore approaches expect information kind symmetry present
state space graph  one example rotational symmetry  defined right shift
variables state vector 
    model checking planners
     competition  two symbolic planners took part  propplan  fourman 
       bddplan  holldobler   stor         although receive awards
performance  show interesting properties  propplan performs symbolic forward
breadth first search explore propositional planning problems propositions generalized action preconditions generalized action effects  performed well full
adl miconic    elevator domain  koehler         probplan written poly ml
implementation sml  bdd plan based solving entailment problem fluent calculus bdds  time authors acknowledged concise domain
encoding symbolic heuristic search used mips improvements 
model based planner mbp paradigm planning symbolic model checking  giunchiglia   traverso        implemented non deterministic planning
domains  cimatti et al          classified weak  strong  strong cyclic
planning  plans represented state action tables  partially observable
planning  system faced exploring space belief states  power set
original planning space  therefore  contrast successor set generation based action application  observations introduce nodes search tree  bertoli  cimatti 
roveri    traverso      b   since approach hybrid symbolic representation
belief states explicit search within and or search tree  simple heuristics
applied guide search  need heuristics trade information gain
exploration effort apparent conformant planning  bertoli et al       a   recent
work  bertoli   cimatti        proposes improved heuristics belief space planning 
umop system parses non deterministic agent domain language explicitly
defines controllable system uncontrollable environment  jensen   veloso        
planner applies bdd refinement techniques automated transition function
partitioning  new results umop system extend weak  strong strong cyclic
planning adversarial planning  environment actively influences outcome
actions  fact  proposed algorithm combines aspects symbolic search
game playing  umop yet participated planning competition 
recent developments symbolic exploration expected influence automated
planning near future  seta    jensen et al         provide improved imple   

fiedelkamp

mentation symbolic heuristic search algorithm bdda   edelkamp   reffel       
weighted bdda   edelkamp      a   one improvement seta  maintains finer
grained sets states search horizon  kept matrix according matching g  h  values  contrasts plain bucket representation priority
queue based f  values  heuristic function implicitly encoded value differences
grounded actions  since sets states evaluated heuristics state
rather operator dependent remains shown general approach is 
above  planning benchmarks considered seemingly simple single state heuristic search exploration  hoffmann      b  helmert          hansen  zhou    feng       
re implemented bdda  suggest symbolic search heuristics exploration
algorithms probably better implemented algebraic decision diagrams  adds   although authors achieved improvement  edelkamp   reffel        solving
 n     puzzle  established generalization guide symbolic version lao  exploration algorithm  hansen   zilberstein        probabilistic  mdp  planning results
remarkable improvement state of the art  feng   hansen        

   conclusions
competition planning system mips  contributed flexible system
heuristic forward chaining  explicit symbolic search planner finds plans finitebranching numerical problems  planner parses  pre compiles  solves  schedules
problem instances  including complex ones duration  resource variables different
objective functions  main contributions planner
object oriented workbench architecture choose combine different heuristics different search algorithms storage structures  design includes
static analyzer applies efficient fact space exploration distinguish constant
fluent quantities  clusters facts groups  infers static object
symmetries  static analyzer produces intermediate format grounded
simplified planning domain instances 
optimal temporal planning enumeration algorithms  based precedence relation
pert scheduling sequentially generated plans together concise analysis
correctness optimality  well integration pert scheduling mips
computing refined heuristic estimate  guides search phase  favoring
states smaller parallel plan length  mips instantiates numerical pre  postconditions on the fly produces optimized parallel plans 
detection dynamic object symmetries  integration different pruning
methods hash transposition cuts  well different strategies optimizing objective functions implementation tricks made system
efficient 
paper analyzes theoretical properties contributions  sometimes slightly
abstracting actual implementation 
essentially planning numerical quantities durative actions planning
resources time  given framework mixed propositional numerical planning
   

fitaming numbers durations mips

problems presented intermediate format seen normal form temporal
metric planning  paper presents novel temporal planning scheme generates
sequential  totally ordered  plans efficiently schedules respect set
actions imposed causal structure  without falling known np hardness traps
optimized partial ordering sequentially generated plans  smaller problems complete enumeration approach guarantees optimal solutions  improve solution quality
approximate enumeration   numerical  estimate number operators replaced
scheduling relaxed plan state  addressed completeness optimality
different forms exploration  novel study time space complexity dynamic
object symmetry detection given 
model checking always influenced development mips  e g static analysis minimize state description length  symbolic exploration plan extraction 
dependence relation pert schedules according given partial order  bit state
hashing ida   importance symmetry detection  forth  moreover 
successes planning mips exported back model checking  development heuristic search state model checkers parsing promela protocol specifications
indicate 

acknowledgments
author would thank derek long maria fox helpful discussions concerning
paper malte helmert cooperation second planning competition 
list editors anonymous reviewers comments helped lot improve text 
work supported deutsche forschungsgemeinschaft  dfg  projects
heuristic search  ed       directed model checking  ed       

references
bacchus  f     ady  m          planning resources concurrency  forward chaning
approach  proceedings ijcai     pp         
bacchus  f     kabanza  f          using temporal logics express search control knowledge planning  artificial intelligence              
backstrom  c          computational aspects reordering plans  journal artificial
intelligence research           
bertoli  p     cimatti  a          improving heuristics planning search belief space 
proceedings aips     pp         
bertoli  p   cimatti  a     roveri  m       a   heuristic search symbolic model checking  
efficient conformant planning  proceedings ijcai     pp         
bertoli  p   cimatti  a   roveri  m     traverso  p       b   planning nondeterministic
domains partial observability via symbolic model checking  proceedings
ijcai     pp         
biere  a          cke   efficient  calculus model checking  proceedings cav     pp 
       
   

fiedelkamp

bloem  r   ravi  k     somenzi  f          symbolic guided search ctl model checking 
proceedings dac     pp       
blum  a     furst  m  l          fast planning planning graph analysis 
proceedings ijcai     pp           
bonet  b     geffner  h          planning heuristic search  artificial intelligence                
bryant  r  e          symbolic boolean manipulation ordered binary decision diagrams  acm computing surveys                 
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  decision procedure ar  proceedings ecp     pp         
cimatti  a   roveri  m     traverso  p          automatic obdd based generation
universal plans non deterministic domains  proceedings aaai     pp     
    
clarke  e  m   grumberg  o     peled  d  a          model checking  mit press 
clarke  e  m   mcmillan  k  l   dill  d  l     hwang  l  j          symbolic model checking 
     states beyond  information computation                 
cormen  t  h   leiserson  c  e     rivest  r  l          introduction algorithms 
mit press 
dial  r  b          shortest path forest topological ordering  communication
acm                  
do  m  b     kambhampati  s          sapa  domain independent heuristic metric temporal planner  proceedings ecp     pp         
edelkamp  s          datenstrukturen und lernverfahren der zustandsraumsuche  ph d 
thesis  university freiburg  diski  infix 
edelkamp  s       a   directed symbolic exploration application ai planning 
proceedings aaai    spring symposium model based validation intelligence 
pp       
edelkamp  s       b   first solutions pddl  planning problems  proceedings
plansig     pp       
edelkamp  s       c   planning pattern databases  proceedings ecp     pp 
     
edelkamp  s       a   mixed propositional numerical planning model checking integrated planning system  proceeding aips    workshop temporal
planning  pp       
edelkamp  s       b   symbolic pattern databases heuristic search planning  proceedings aips     pp         
edelkamp  s          promela planning  proceedings spin     pp         
edelkamp  s     helmert  m          exhibiting knowledge planning problems minimize state encoding length  proceeding ecp     pp         
   

fitaming numbers durations mips

edelkamp  s     helmert  m          implementation mips  proceedings
aips    workshop model theoretic approaches planning  pp       
edelkamp  s     helmert  m          model checking integrated planning system mips 
ai magazine       
edelkamp  s   leue  s     lluch lafuente  a          directed explicit state model checking
validation communication protocols  international journal software tools
technology  sttt   appear 
edelkamp  s     meyer  u          theory practice time space trade offs memory
limited search  proceedings ki     lecture notes computer science  pp 
        springer 
edelkamp  s     reffel  f          obdds heuristic search  proceedings ki     pp 
     
edelkamp  s     reffel  f       a   deterministic state space planning bdds 
proceedings ecp     preprint  pp         
edelkamp  s     reffel  f       b   deterministic state space planning bdds  tech 
rep       university freiburg 
edelkamp  s     stiegeler  p          implementing heapsort n log n    n
quicksort n log n      n comparisons  acm journal experimental algorithms        
feng  z     hansen  e          symbolic heuristic search factored markov decision
processes  proceedings aaai    
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence            
fourman  m  p          propositional planning  proceedings aips    workshop
model theoretic approaches planning  pp       
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research            
fox  m     long  d          detection exploration symmetry planning
problems  proceedings ijcai     pp         
fox  m     long  d          extending exploitation symmetries planning 
proceedings aips    
fox  m     long  d          pddl     extension pddl expressing temporal
planning domains  journal artificial intelligence research  issue 
gerevini  a     serina  i          fast planning greedy action graphs  proceedings
aaai    
gerevini  a     serina  i          lpg  planner based local search planning graphs
action costs  proceedings aips    
giunchiglia  f     traverso  p          planning model checking  proceedings
ecp     pp      
   

fiedelkamp

groce  a     visser  w          model checking java programs using structural heuristics 
proceedings issta    
guere  e     alami  r          one action enough plan  proceedings ijcai    
hansen  e     zilberstein  s          lao   heuristic search algorithm finds solutions
loops  artificial intelligence            
hansen  e  a   zhou  r     feng  z          symbolic heuristic search using decision
diagrams  proceedings sara    
hart  p  e   nilsson  n  j     raphael  b          formal basis heuristic determination
minimum path cost  ieee transactions systems science cybernetics 
          
haslum  p     geffner  h          heuristic planning time resources  proceedings
ecp     pp         
helmert  m          complexity planning transportation domains  proceedings ecp     pp         
helmert  m          decidability undecidability results planning numerical
state variables  proceedings aips     pp       
hipke  c  a          verteilte visualisierung von geometrischen algorithmen  ph d  thesis 
university freiburg 
hoffmann  j          heuristic domain independent planning use enforced
hill climbing algorithm  proceedings ismis     pp         
hoffmann  j       a   extending numerical state variables  proceedings ecai   
hoffmann  j       b   local search topology planning benchmarks  theoretical analysis 
proceedings aips     pp        
hoffmann  j     nebel  b          fast plan generation heuristic search  journal
artificial intelligence research             
holldobler  s     stor  h  p          solving entailment problem fluent calculus using binary decision diagrams  proceedings aips    workshop modeltheoretic approaches planning  pp       
jensen  r  m   bryant  r  e     veloso  m  m          seta   efficient bdd based
heuristic search algorithm  proceedings aaai    
jensen  r     veloso  m  m          obdd based universal planning synchronized
agents non deterministic domains  journal artificial intelligence research     
       
kabanza  f   barbeau  m     st denis  r          planning control rules reactive agents 
artificial intelligence                
kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings aaai     pp           
kautz  h     walser  j          state space planning integer optimization  proceedings
aaai    
   

fitaming numbers durations mips

knoblock  c          generating parallel execution plans partial order planner 
proceedings aips     pp        
koehler  j          elevator control planning problem  proceedings aips     pp 
       
koehler  j     hoffmann  j          reasonable forced goal orderings use
agenda driven planning algorithm  journal artificial intelligence research 
           
koehler  j   nebel  b     dimopoulos  y          extending planning graphs adl
subset  proceedings ecp     pp         
korf  r  e          depth first iterative deepening  optimal admissible tree search 
artificial intelligence                
korf  r  e     zhang  w          divide and conquer frontier search applied optimal
sequence alignment  proceedings aaai     pp         
laborie  p     ghallab  m          planning sharable resources constraints  proceedings ijcai     pp           
lago  u  d   pistore  m     traverso  p          planning language extended
goals  proceedings aaai    
lind nielsen  j          buddy  binary decision diagram package  release      technical
univeristy denmark  available jln itu dk 
lluch lafuente  a          symmetry reduction heuristic search error detection
model checking  proceedings workshop model checking artificial
intelligence  mochart  
long  d     fox  m          efficient implementation plan graph stan  journal
artificial intelligence research            
long  d     fox  m          encoding temporal planning domains validating temporal plans  workshop uk planning scheduling special interest group
 plansig  
mcdermott  d               ai planning competition  ai magazine         
mcmillan  k  l          symbolic model checking  kluwer academic press 
muscettola  n          hsts  integrating planning scheduling  zweben  m     fox 
m  s   eds    intelligent scheduling  pp          morgan kaufmann 
pearl  j          heuristics  addison wesley 
pednault  e          formulating multiagend  dynamic world problems classical
framework  reasoning action plans  pp        morgan kaufmann 
pednault  e          adl  exploring middleground strips situation calculus  proceedings kr     pp          morgan kaufman 
pettersson  p          modelling verification real time systems using timed automata  theory practice  ph d  thesis  department computer systems  uppsala university 
   

fiedelkamp

pistore  m     traverso  p          planning model checking extended goals nondeterministic domains  proceedings ijcai    
pohl  i          practical theoretical considerations heuristic search algorithms 
machine intelligence          
refanidis  i     vlahavas  i          heuristic planning ressources  proceedings
ecai     pp         
reffel  f     edelkamp  s          error detection directed symbolic model checking 
proceedings fm     pp         
regnier  p     fade  b          determination du parallelisme maximal et optimisation
temporelle dans les plans dactions lineaires  revue dintelligence artificielle        
     
reinefeld  a     marsland  t          enhanced iterative deepening search  ieee transactions pattern analysis machine intelligence                 
rintanen  j          symmetry reduction sat representations transition systems 
proceedings icaps    
rintanen  j     jungholt  h          numeric state variables constraint based planning 
proceedings ecp     pp         
ruys  t  c          optimal scheduling using branch bound spin      proceedings spin     pp      
syslo  m  m   deo  n     kowalik  j  s          discrete optimization algorithms
pascal programs  prentice hall 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning parallel
resource allocation  innovative approaches planning  scheduling control 
pp         
weismuller  m          planen mit einem modellprufer im  kalkul   masters thesis 
universitat ulm 
yang  c  h     dill  d  l          validation guided search state space 
proceedings dac     pp         
yoshizumi  t   miura  t     ishida  t          a  partial expansion large branching
factor problems  proceedings aaai     pp         
zhou  r     hansen  e          sparse memory graph search  proceedings ijcai    

   


