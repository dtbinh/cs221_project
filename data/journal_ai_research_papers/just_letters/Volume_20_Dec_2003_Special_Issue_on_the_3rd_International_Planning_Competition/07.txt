journal of artificial intelligence research                 

submitted        published      

talplanner in the third international planning
competition  extensions and control rules
jonas kvarnstrom
martin magnusson

jonkv ida liu se
marma ida liu se

department of computer and information science
linkoping university
se        linkoping  sweden

abstract
talplanner is a forward chaining planner that relies on domain knowledge in the shape
of temporal logic formulas in order to prune irrelevant parts of the search space  talplanner recently participated in the third international planning competition  which had a
clear emphasis on increasing the complexity of the problem domains being used as benchmark tests and the expressivity required to represent these domains in a planning system 
like many other planners  talplanner had support for some but not all aspects of this increase in expressivity  and a number of changes to the planner were required  after a short
introduction to talplanner  this article describes some of the changes that were made
before and during the competition  we also describe the process of introducing suitable
domain knowledge for several of the competition domains 

   introduction
like most planners  talplanner  kvarnstrom   doherty        doherty   kvarnstrom 
      kvarnstrom  doherty    haslum        doherty   kvarnstrom        kvarnstrom  
doherty        kvarnstrom        allows the user to specify a goal in the shape of a set of
atemporal logic formulas that must be satisfied in the final state that results from executing
a plan  unlike most planners talplanner also allows the specification of a set of temporal
logic formulas that must be satisfied by the entire state sequence generated by a plan 
obviously  these formulas can be used to specify temporally extended goals  such as
safety and maintenance goals that must be upheld throughout the execution of a plan 
however  it is also possible to specify constraints related to traditional measures of plan
quality  such as constraints that forbid certain stupid actions from taking place  as in the
blockhead blocks world planner by kibler and morris        or tlplan by bacchus and
kabanza         which initially inspired the development of talplanner  for example  in
a logistics domain one may specify a temporally extended goal stating that once a package
is at its destination  it is never picked up again  and a goal stating that trucks driving
between two locations always use the shortest path  such constraints can then be processed
by talplanner in order to automatically extract control knowledge that can be used during
a forward chaining search process  as opposed to being used as a filter after a candidate plan
has been generated  given sufficiently strong constraints  the planner can efficiently prune
most of the search tree  making it easier to find a plan among the remaining nodes  often
 as in this article  the search control aspect is in fact the primary reason for introducing a
temporally extended goal  in which case the goal is usually referred to as a control rule 
c
    
ai access foundation  all rights reserved 

fikvarnstrom   magnusson

although forward chaining planners may sometimes suffer from a lack of goal directedness
when compared to other types of planners  the use of explicitly represented domain dependent
knowledge is one way of compensating for this deficiency  more significantly  a forward
chaining planner always has a complete description of the past and current states  which
facilitates the use of complex operator types with complex preconditions and conditional
effects  this expressivity was useful when talplanner participated in the third international planning competition  ipc          which had a clear emphasis on increasing the
complexity of the problem domains used as benchmark tests and the expressivity required
to represent these domains in a planning system  in fact  talplanner already had support
for several new features that had not been present in ipc         such as the use of numeric
state variables and temporally extended actions with variable duration 
nevertheless  several extensions and changes had to be implemented before and during
the competition in order to accommodate the semantics of pddl     the new version of
pddl  planning domain definition language  fox   long        which was used to specify
problem domains and problem instances  these extensions and changes are the first topic
of this article  and after an introduction to talplanner  sections   and     the extensions
will be discussed in section    the second topic is that of describing the domain dependent
control rules that were used for the six benchmark problem domains in the hand tailored
track of the competition  and more importantly  the process of generating those rules and
the reasoning behind them  section     we will also describe some new changes that have
been made to talplanner after the competition  section     finally  we will conclude
with a discussion of the positive and negative sides of using search control knowledge in
talplanner together with some pointers towards possible future research topics 
please see long and fox        for further information about the basic setup of the
competition  detailed descriptions of the planning domains being used  and timing and plan
quality results 

   representation  using tal in talplanner
the semantics of talplanner is based on an extended version of tal c  karlsson  
gustafsson        doherty  gustafsson  karlsson    kvarnstrom         a member of the
tal  temporal action logics  family of narrative based non monotonic linear discrete
metric time logics for reasoning about action and change  tal c has been developed for
modeling domains that may include the use of incomplete information  delayed effects of
actions  finite or infinite chains of indirect effects  interacting concurrent actions  and independent processes not directly triggered by action invocations  consequently  it was seen as
an ideal choice not only for the initial version of talplanner but also for most extensions
that could conceivably be implemented in the foreseeable future 
a tal narrative consists of a set of labeled statements in a high level macro language
l nd   where the basic language has a number of statement classes for observations of fluent
values  labeled obs   action descriptions  acs   action occurrences  occ   domain constraints
 dom   and dependency constraints modeling causal relations and indirect effects  dep  
the formal semantics of l nd  is defined by a translation into an order sorted first order
base language l fl  and by a circumscription policy providing a solution to the frame and
ramification problems  doherty        gustafsson   doherty        doherty et al         
   http   www dur ac uk d p long competition html
   http   www cs toronto edu aips     

   

fitalplanner in ipc       extensions and control rules

the l nd  language is designed to be easily extended for different tasks  such as planning  an extension may take the shape of a new specialized macro or a new type of
statement  as illustrated in figure    a talplanner goal narrative uses a version of l nd 
called l nd    which contains some of the standard classes of l nd  statements together
with several new types of planning related statements  these extensions are accompanied
by extensions to the translation function  so that the new variation of tal can still share
the same base language l fl  
however  talplanner does not use
l nd  
l nd 
this
translation directly during the plantalplanner
tal
tal
ning
process  instead  it makes direct use
plan narrative
goal narrative
of the higher level l nd  goal narrative
in a forward chaining search process and
l fl 
l fl 
generates a plan narrative where a set of
 storder
 storder
timed action occurrences  corresponding
theory t
theory t
to a plan  has been added  and where the
  circ t 
  circ t 
goal is entailed in the final state 
l fl 
  quantifier elimination
l fl 
  q e 
in this section  we will attempt to
 storder
 storder
provide an intuitive understanding of tal
theory
theory goal
and how it is used in domain specifications using concrete examples from the
figure    tal talplanner relation
standard logistics planning domain  where
a set of objects  packages  can be transported by truck between locations in the same city
and by airplane between airports in different cities  the next section contains further information about the search process and the use of control rules  see doherty et al        
for a more detailed description of tal  and see kvarnstrom and doherty        for more
information about talplanner 
notation  all formulas and l nd  statements below will be shown using the input syntax
for talplanner  with the exception of some connectives and quantifiers that may be written
using the ordinary logical symbols for increased clarity  all free variables are implicitly
universally quantified 
    types  objects and state variables
although some planners are restricted to declaring an unstructured set of objects and
representing types as unary predicates  tal is order sorted and allows the user to specify a
hierarchy of object types  sorts   the logistics domain can be modeled using the standard
sort boolean    true  false  together with the seven user specified types  loc  location  has
the subtypes airport and city  while thing has the subtypes obj and vehicle  the latter of
which has the subtypes truck and plane 
talplanner also allows the use of numeric types  in order to keep the semantics of these
types clear  only integers and fixed point numbers  that is  numbers with a fixed number
of decimals  are allowed  and lower and upper bounds must be declared for each numeric
type  all of the standard arithmetic operators are available for the numeric types and are
given an interpretation through semantic attachment 
state variables are represented using tal fluents  which are not restricted to being

   

fikvarnstrom   magnusson

predicates but can take values from an arbitrary user specified sort  for the logistics domain 
one could use two boolean fluents  at thing  loc  and in obj  vehicle   together with a cityvalued fluent city of loc  denoting the city containing the location loc 
    the initial state
given the fluents that were defined above  the initial state of a logistics problem instance
can be specified using l nd  observation statements 
 obs     city of pos    
 city   city of pos    
 city        
 obs     at obj    pos    at truck   pos         
these observations consist of tal c fixed fluent formulas  formulas of the form      denoting the fact that the fluent formula  holds at time    a fluent formula is a boolean
combination of elementary fluent formulas of the form f  
 v  f  v in input notation  
denoting the fact that the fluent f takes on the value v  for boolean fluents  as in the
second observation  the shorthand notation f or f   f in input notation  is allowed  the
notation is also extended for open  closed  and semi open temporal intervals  in addition
to these formulas  the function value   f   denotes the value of f at time   
    the goal  goal statements and goal expressions
a statement class for goals  labeled goal  has been added to l nd    a goal statement
consists of a fluent formula that must hold in any goal state 
 goal at obj    airport    at obj    pos         
the ability to test whether a formula is entailed by the  state based  goal is very useful in
temporally extended goals and domain dependent control rules  therefore  a new macro is
added  the goal expression goal   holds iff the goal of this problem instance  the conjunction of all goal statements  entails the fluent formula   stated differently  goal   is true
if  must be true in every goal state  the translation into l fl  is somewhat complex 
see kvarnstrom and doherty        for further information 
note that a valid plan must end in a goal state  it is not sufficient to visit a goal state
temporarily  which could be the case when an operator has effects at multiple timepoints
 first satisfying the goal and then destroying it  or when concurrent plans are being
created   if such plans were desired for some reason  it would of course be easy to modify
the definition and the planner accordingly  
    operator definitions
since tal c is a logic for reasoning about action and change  it has a notion of actions
that can be used for modeling planning operators  although talplanner does use the
same semantics  the extended planning language l nd  contains a new operator macro
providing a syntax which facilitates the use of resource constraints and other planningoriented concepts that are not present in standard tal c  this is in line with the standard
tal practice of preserving the logical base language l fl  and its semantics but providing
different variations of the high level macro language l nd  that are adapted to special
tasks 
   

fitalplanner in ipc       extensions and control rules

the examples below demonstrate the operator definition syntax using three of the six
logistics operators  further examples will be shown when the ipc      benchmark domains
are discussed 
 operator load truck obj  truck  loc   at s
 precond  s  at obj  loc   at truck  loc 
 effects
 s    at obj  loc     false   s    in obj  truck     true
 operator unload truck obj  truck  loc   at s
 precond  s  in obj  truck   at truck  loc 
 effects
 s    in obj  truck     false   s    at obj  loc     true
 operator drive truck  loc    loc     at s
 precond  s  at truck  loc     city of loc     
 city of loc     loc     loc 
 effects
 s    at truck  loc       false   s    at truck  loc       true
although not used in the simple logistics operators above  talplanner also allows the
use of context dependent and quantified effects as well as prevail conditions  unlike pure
preconditions  prevail conditions are not limited to the invocation state of an operator but
can refer to the entire interval during which the operator is executed  the interval at which
each prevail condition must hold is explicitly specified  which provides additional flexibility
compared to requiring that a precondition must always hold throughout the execution of
an action 
    resources
if talplanner was limited to generating sequential plans  resource consumption and production could be handled using plain operator effects  for example  if loading a truck
requires one unit of space  the amount of available space could be decreased as follows 
 operator load truck obj  truck  loc   at s
 precond  s  at obj  loc   at truck  loc 
 effects
 s    space truck     value s  space truck            
with concurrent planning  this is clearly not sufficient  since multiple parallel invocations
of load truck would still only consume one unit of space  for this reason  talplanner has
explicit support for resources  kvarnstrom et al         
resources can be declared in a manner similar to ordinary fluents  they can have
parameters and can take values in an arbitrary integer or fixed point domain  unlike some
planners  talplanner only provides one type of resource  but provides several types of
resource effects  resources can be produced and consumed  they can also be borrowed
 and automatically returned   either exclusively  meaning that the borrower has exclusive
use of the resource during the specified interval  or non exclusively  where multiple actions
can borrow the same units of a certain resource concurrently  the latter case may appear
strange  but can be useful when one wants to use a resource as a semaphore or mutex 
finally  resources can be assigned a completely new value 

   

fikvarnstrom   magnusson

in the following example  loading a truck always consumes one unit of space 
 operator load truck obj  truck  loc   at s
 precond  s  at obj  loc   at truck  loc 
 effects
 s    at obj  loc     false   s    in obj  truck     true
 resources  s     consume space truck   amount  
unlike ordinary fluents  a resource res has multiple aspects that can be queried and used in
formulas such as operator preconditions or control rules  at any timepoint  there is an initial amount available   init res   a certain amount may be consumed during this time
step   consumed res    produced   produced res    borrowed exclusively   borrowed res  
and borrowed non exclusively   borrowed nonex res    this results in a remaining amount
available   available res    which must be between the minimum   minimum res   and the
maximum   maximum res   allowed  the ability to refer to these aspects directly allows
the user to specify more complex resource constraints than a simple minimum or maximum value for a resource  such as a control rule defining a maximum amount that may be
consumed per time step 
this concludes the description of planning domain definitions in tal  the following
sections will show the structure of talplanners forward chaining search tree and how the
search process is constrained using control rules 

   search and control rules
like any forward chaining planner  talplanner searches for a plan in a tree where the root
corresponds to the initial state and where each outgoing edge corresponds to one of the
operators applicable in its source node  two trivial examples are shown in figure    where
the notation  s t  a means that the action a is executed between time s and time t  for
sequential planning  figure  a   a new action is always added at the time step where the
previous action ended  for concurrent planning  figure  b   talplanner still adds a single
action at a time to the plan  but the constraint on the time where the action is executed
is relaxed  the action must not start before the start of an existing action in the current
plan prefix or after the end of an existing action  when searching the tree  preference is
given to actions invoked at earlier timepoints  in other words  talplanner tries to add
as many applicable actions as possible at the same timepoint before stepping to the next
timepoint  so in figure  b the subtree starting in       a   executing the action a  between
time   and time    would have been explored before backtracking to the subtree starting
with       a   where a  happens to take slightly less time to execute due to differences in
the state where the action is invoked  the search process ends as soon as the planner has
found a plan ending in a state satisfying the goal  the exact definition of the search tree
is available in kvarnstrom and doherty        for sequential talplanner and kvarnstrom
et al         for concurrent talplanner 
although it is common to view each node in a search tree as consisting of a single state 
and an operator as a function from states to states  this is not sufficient for talplanner 
for several reasons  a single operator may generate multiple new states  the evaluation of
a temporally extended goal or domain dependent control rule may require access to the
entire state history beginning in the initial state  and during concurrent planning a future

   

fitalplanner in ipc       extensions and control rules

initial
node

      a 

      a 
      a 

      a 
      a 

 

 

initial
node

      a 

 

 

      a 

      a 

      a 

       a 

      a 
      a 

      a 

goal
node

 

      a 

 

 

goal
node

 

 

 

 

 

      a 

      a 

      a 

      a 

 a  sequential

      a 

 b  concurrent

figure    forward chaining search space
state may be modified by several operators before it reaches its final configuration  for
these reasons  it is more convenient to view each node as consisting of a state sequence  or
 equivalently  a logical model  as indicated in the figure 
a simple forward chaining planner can be implemented by searching this tree using a
standard search algorithm  such as iterative deepening or depth first search  but although
using a complete search algorithm is clearly enough to make the planner complete  it is
equally clear that a certain degree of goal directedness is required to make the search process
efficient  this is achieved using domain dependent control rules 
    using domain dependent control rules
in fully automated planning  the planner is generally only supplied with an initial state  a
set of acceptable goal states  often specified using propositional or first order formulas that
must hold in any goal state   and a set of operators to be used in the plan  it is up to
the planner to determine how to search for a plan efficiently  with the possible exception of
various command line options that can be fine tuned by the user 
however  in some cases the user has additional information about a planning domain that
could be of use to the planner  and this information may be difficult to extract mechanically
from a simple domain specification  if this is the case  it would make sense to allow the user
to supply this information to the planner  although it entails somewhat more work for the
user  it may also lead to finding plans more quickly or finding plans of higher quality 
there are of course many different kinds of additional information that could be given
to the planner  talplanner  inspired by tlplan  bacchus   kabanza        allows the
user to specify a set of first order tal formulas that must be entailed by the final plan 
this serves two separate purposes  first  it allows the specification of complex temporally
extended goals such as safety conditions that must be upheld throughout the execution of
a plan  and second  the additional constraints on the final plan often allow the planner to
prune entire branches of the search tree  since it can be proven that any leaf on the branch
will violate at least one such goal  in many cases this pruning is the main reason for the
use of the formula  in which case it is often called a control rule   allowing the planner to
prune branches efficiently requires some additional analysis  as described in kvarnstrom 
      
   

fikvarnstrom   magnusson

    control rules for the logistics domain
the following are some of the control rules we use for the logistics domain  further control
rule examples will be given when the ipc      benchmark domains are discussed 
first  a package should only be loaded onto a plane if a plane is required to move it 
i e   if the goal requires it to be at a location in another city  second  if we have unloaded a
package from a plane  the package must have arrived in the correct city satisfying the goal 
third  if a package is at its destination  it should not be moved 
 control  name only load when necessary
 t  in obj  plane   at obj  loc  
loc   goal  at obj  loc     t  city of loc   
   city of loc    
 t    in obj  plane 
 control  name only unload when necessary
 t  in obj  plane   at plane  loc  
loc   goal  at obj  loc     t  city of loc   
 city of loc    
 t    in obj  plane 
 control  name objects remain at destinations
 t  at obj  loc   goal  at obj  loc     t    at obj  loc 
note that these rules could of course be expressed on various other logically equivalent
forms  most such variations would have identical performance  since talplanner internally
normalizes many aspects of control formulas during its domain analysis phase 

   the third international planning competition
in the second international planning competition  ipc        the planning domains used
mainly strips expressivity  support for typed objects was not required  and for those
domains that could use adl style quantified and conditional effects  restricted strips
versions were also provided 
although we did expect some increase in expressivity in the third competition  ipc       we were quite surprised by the extent of the changes  fortunately  talplanner
already supported many of the new requirements  and some of the others were easily implemented  despite this we did make some rather significant changes in order to handle the
combination of all these extensions more efficiently  below we will discuss how each of the
new requirements affected talplanner together with a few other improvements that have
been prompted by the domains used in the competition 
    adl style operator definitions
though there were strips versions of most planning domains in ipc       the more
complex versions of the domains required the use of quantified conditional effects  like
most other current planners  talplanner is not limited to strips expressivity and already
had support for this 

   

fitalplanner in ipc       extensions and control rules

    numeric types and arithmetic
all ipc      domains that required numeric values emulated these values using ordinary
objects  in the miconic    elevator domain  for example  floor numbers were emulated using
objects named f   f   and so on  the next floor was not calculated as f     but by using
an explicitly defined predicate above floor  floor  
the same approach was taken in the simplest versions of the ipc      domains  but
there were also numeric versions of these domains where numeric types were required
and where arithmetic operators were used  this was already supported by talplanner 
but unfortunately there was not enough time to write control rules for these domains 
    concurrency
despite the fact that some ipc      domains provided the potential for using concurrent
actions  such as driving several trucks concurrently in the logistics domain  there was no
reward for exploiting this potential  plan quality was measured in terms of the number
of operators in a plan  not in terms of the amount of time required to execute the plan 
consequently  several planners  including talplanner  only generated sequential plans 
even for highly concurrent domains 
in ipc       plan quality was mainly measured in terms of the timepoint at which the
last operator finished executing  the makespan of the plan  in scheduling terms   and any
planner generating sequential plans would have been severely handicapped  fortunately a
concurrent version of talplanner had already been implemented  together with support
for resources  kvarnstrom et al          and could be used in the competition 
although concurrent talplanner had already been applied to a number of domains 
the competition provided us with a more varied set of domains that sometimes exploited
concurrency in slightly different ways  this provided us with new ideas for improvements to
talplanner  and several minor enhancements to talplanners formula analysis algorithms
were implemented during the first phase of the competition  allowing it to handle certain
types of control formulas more efficiently when doing concurrent planning 
    operators with non unit and context dependent duration
in ipc       each plan operator used a single time step  in the simpletime and timed
versions of the ipc      planning domains  operators could have a non unit duration  so
that  for example  walking requires more time than driving  this was already supported
by talplanner  and no changes were required 
in the timed versions of the ipc      planning domains  the durations of some operators could also be context dependent  and could be specified using arithmetic expressions 
requiring support for numeric types as already discussed above  for example  the time
required to drive a truck between two locations could be specified as the distance between
the locations divided by the speed of this particular truck  this was also already supported
by talplanner 
talplanner also permits effects to take place at multiple timepoints within the duration
of an action  although this was not used in the competition 

   

fikvarnstrom   magnusson

    non integer time
some of the ipc      contest domains required operator durations to be calculated with a
precision of at least three decimals  which posed a problem for us  the underlying tal c
logic is based on integer time  and therefore the same is true for talplanner  introducing
non integer time properly would have required changes to the underlying tal semantics 
which could not be done in the time that was available  and therefore we simply multiplied
durations by a thousand  when printing a plan  all time values were divided by a thousand 
    operators with extended duration
in the initial implementation of talplanner  in            it was assumed that although
operators might have extended durations  something interesting would be happening at a
significant proportion of the discrete time steps within that duration  for example  an
operator invoked at t might have a duration of   time steps  where some effects take place
at time t      some at time t      and some at time t      this assumption influenced some
of the algorithms and data structures in talplanner  and appeared reasonable at the time 
since most planning domains in the literature only used single step operators 
nevertheless  it was always our intention to extend these algorithms and structures to
handling plans with sparse effects  where most discrete time steps contain no effects at all 
doing this would not have been difficult  but partly for that very reason  there were more
interesting research issues to be tackled instead  it was continuously postponed 
ipc      finally provided us with a compelling reason to change the data structures 
together with a number of example domains that could be used to test the changes  for
example  an operator in a timed domain from ipc      might have a duration of  say 
        requiring       discrete time steps  where all effects take place at the beginning
or at the end of the action  this led us to implement a new sparse state structure and
change a few algorithms whose time complexity accidentally depended on the duration of
an operator rather than the number of time steps where something actually happened  the
current version of talplanner allows both state structures to be used depending on the
characteristics of each planning domain 
    the no moving targets rule
as already mentioned  talplanners semantics is based on the use of tal  while the planning competition uses pddl     while the semantic differences between these two approaches are usually not a major problem  we did have some trouble with the way the
effects of durative actions are modeled in pddl     in essence  pddl    predicates or
numerical fluents that are affected by the effects of an action are considered to be moving
targets  and the preconditions of another action are not allowed to refer to them at the
same timepoint  instead  a certain intermediate interval  arbitrarily chosen to be      
units of time  is required between the assertion of a fact and the subsequent use of that
fact  even at the beginning of the plan where actions cannot begin exactly at time    in
tal  effects taking place at time t are assumed to give fluents their new values exactly at
that timepoint  and those values can immediately be used  if there is some uncertainty in
the exact time when the effect takes place  one can for example explicitly state that the

   

fitalplanner in ipc       extensions and control rules

value is unknown during the inner part of a certain interval but is known at the end of that
interval  though this is not yet implemented in talplanner  
changing talplanner to use the exact pddl    semantics was out of the question 
since this would change some of the most fundamental assumptions in the planner  instead
it was necessary to come up with a workaround that let us simulate this semantics  there
are several ways this could be done  one method would involve making minor changes to
the action definitions in order to assert the final effects of each action slightly later       
units of time later  to be exact   during the competition we instead implemented a trivial
modification to the way a plan is printed  at any timepoint where something happens in the
plan  for example  where an operator is invoked   an additional delay of       is inserted 
this ensures that all plans are safe according to pddl    semantics but sometimes leads
to generating slightly worse plans than necessary 
    finding shortest paths
in the rover and driverlog domains  vehicles and or people must travel along road networks  where different roads may have different costs  lengths  and where it is essential to
take the shortest path between any two points 
although it is possible to define a shortest path algorithm using talplanners input
language  the formulas become somewhat complicated  finding the shortest path between
two locations in a weighted graph of places and roads seems to be useful in many domains 
and therefore such an algorithm was implemented directly in the planner 
in fact  two algorithms were implemented  one for finding the cost of the shortest
path between two given locations  and one for finding the distance to the closest location
satisfying a given formula  for example the closest location which is a reasonable destination
for a certain truck in the driverlog domain   these functions can be called from control
rules in order to ensure that each step one takes leads to a location which is on some shortest
path to the current destination 

   modeling the competition domains
of the eight planning domains in the third international planning competition  six were intended for hand tailored planners  except for the final domain  umtranslog    all domains
exist in at least four different variations  strips  numeric  where numeric quantities are
involved   simpletime  where operators take constant non unit time   and timed  where
operator durations may depend on the actual parameters in a specific operator invocation  
talplanner participated in all six domains  but due to lack of time for creating control
rules  we limited our participation to the strips  simpletime  and timed versions of the
domains 
in this section we will describe how the domains were translated from pddl    to
talplanner  and discuss some of the control rules that were created to handle the domains
more efficiently  the main focus will be on two domains  zenotravel and satellite  for these
domains we will describe most of the control rules that were used in the competition as well
as the incremental process of creating the rules  omitting only a few technical details and a
couple of complex rules that turned out to have minimal impact on planner performance and
plan quality  for the remaining domains  depots  driverlog  rovers  and umtranslog   
   

fikvarnstrom   magnusson

we will describe the general intuitions behind our control rules  omitting the actual formulas
due to space restrictions  first  though  we will begin with a few comments on the process
of formalizing planning domains 
    using pre defined pddl domains  half the work in twice the time 
in order to create a formal description of a real world planning domain  it is of course always
necessary to have a thorough understanding both of the domain itself and of how plans for
the domain are eventually going to be used  there are several reasons why this is required 
and most of these reasons are equally valid regardless of whether the formalization will
eventually be used as the input to a fully automated planner or to a hand tailored planner
like talplanner 
first  understanding the domain is required in order to determine what aspects of the
domain truly need to be modeled  as types  predicates and functions  and what aspects
can be abstracted away  for example  the standard formalization of the logistics domain
does not model distances between locations  but allows trucks to move between any two
locations in one time step  this is sufficient for some purposes  but a plan that is optimal
given this abstraction may be extremely suboptimal if actually carried out by real trucks 
which usually lack teleportation abilities  similarly  it does not model package sizes or
weights  or cargo capacities for trucks or airplanes  neither does it model truck drivers 
acceptable working hours for drivers  the additional costs incurred by overtime pay  or time
required for maintenance activities such as changing to winter tires once a year  which of
these aspects need to be modeled depends very much on the particular application one has
in mind 
second  a detailed understanding of the domain is required in order to determine what
operators are available to the planner and exactly how their preconditions and effects should
be represented within the abstract logical model of the domain 
and finally  for hand tailored planners  the domain must be understood in order to be
able to guide a search algorithm using domain dependent heuristics or control rules 
usually all of these aspects of a domain are modeled at the same time  and much of the
information and knowledge about the domain that was gathered in order to find a suitable
set of predicates and operators  which is needed even for a fully automated planner  can
be reused in the development of control rules or heuristics for a hand tailored planner 
in the planning competition  however  the task is divided into two parts  the organizers
define a set of domains using pddl     and then it is up to the competitors in the handtailored track to find suitable ways of guiding their planners  in one way  one could say
that the competitors only need to do half the work  since the formalization is already done
and only the task of finding control rules remains  unfortunately it is still necessary to
understand the domain just as thoroughly in order to write control rules  for the more
complex domains  doing this half of the work in isolation might easily take twice the time 
since all the constraints involved in the domain have to be understood from a pddl   
formalization rather than by talking to domain experts  this is especially true for the
complex umtranslog   logistics domain  where a significant amount of time was spent
trying to determine exactly how packages were allowed to move and how they can be
loaded into and unloaded from various kinds of vehicle 

   

fitalplanner in ipc       extensions and control rules

figure    a zenotravel problem instance  strips problem   
another problem caused by having to use a predefined formalization of a planning
domain is that the degree of detail used in the model is determined in advance  in the real
world there would more likely be a minimum level of detail required  and anything above
this level would be acceptable  it may not seem like this should be a problem  intuitively 
adding new details to a planning problem ought to make it harder  and so it would be best
to remain at the minimum level of detail  but this is not always true  especially not when
control rules are involved  this will be seen in the timed zenotravel domain  for example 
where some control rules would be both simpler and more effective if it was possible to refuel
to a specific level  just like in the real world  rather than just having a simple abstract refuel
operator that unconditionally fills the tank completely 
this should not be taken as a complaint against the organization of the competition
 allowing different planners to use different formalizations would of course be completely
infeasible  nevertheless  it does present some additional problems that are not encountered
to the same degree in real world domains and that deserve to be mentioned here 
    the zenotravel domain
in the zenotravel domain  there are a number of aircraft that can fly people between cities 
there are five actions available  persons may board and debark aircraft  and aircraft may fly 
zoom  fly quickly  using more fuel   and refuel  there are no restrictions on how many people
an aircraft can carry  flying and zooming are equivalent except that zooming is generally
faster and uses more fuel  figure   shows an example problem  with arrows pointing out
goal locations 
      zenotravel  strips
below we show the operator definitions for the strips version of the zenotravel domain 
these operators have been more or less directly translated from the pddl representation 
the main difference is that the pddl representation uses pddl    level    with single 

   

fikvarnstrom   magnusson

step actions  which has a stricter concept of mutual exclusion than talplanner does and
automatically enforces certain invariants  such as the fact that an aircraft should not leave
if a person is boarding  because the location of the aircraft is modified by fly and used in
the precondition of board  the tal c semantics used by talplanner is more similar to
pddl    level    with durative actions   where such invariant conditions must be stated
explicitly  this is done using prevail conditions  which are considered to be separate from
true pre conditions  note that in the strips formalization fly and zoom take the same
amount of time  since only single step actions are possible 
 operator
 precond
 prevail
 effects

board person  aircraft  city    at t
 t  at person  city    at aircraft  city  
 t    at aircraft  city  
 t    at person  city      false   t    in person  aircraft     true

 operator
 precond
 prevail
 effects

debark person  aircraft  city    at t
 t  in person  aircraft   at aircraft  city  
 t    at aircraft  city  
 t    in person  aircraft     false   t    at person  city      true

 operator fly aircraft  city    city    flevel    flevel     at t
 precond  t  at aircraft  city     fuel level aircraft  flevel     next flevel    flevel   
 effects
 t    at aircraft  city       false   t    fuel level aircraft  flevel       false 
 t    at aircraft  city       true   t    fuel level aircraft  flevel       true
 operator zoom aircraft  city    city    flevel    flevel    flevel     at t
 precond  t  at aircraft  city     fuel level aircraft  flevel    
next flevel    flevel     next flevel    flevel   
 effects
 t    at aircraft  city       false   t    fuel level aircraft  flevel       false 
 t    at aircraft  city       true   t    fuel level aircraft  flevel       true
 operator
 precond
 prevail
 effects

refuel aircraft  city   flevel  flevel     at t
 t  fuel level aircraft  flevel   next flevel  flevel     at aircraft  city  
 t    at aircraft  city  
 t    fuel level aircraft  flevel     false   t    fuel level aircraft  flevel       true

after translating the operator definitions  it is time to create a set of control rules  there
are basically two ways of doing this  first  one can sit down and think about suitable
properties for a plan  and then write control rules that ensure that these properties will
hold  second  one can instruct the planner to show each branch that is explored in the
search tree  and by observing the output one can identify obviously stupid choices made
by the planner  such as choosing an action instance that inevitably leads to backtracking
or performing actions that are useless given the goals  control rules can then be written to
prevent these branches of the tree from being explored  both of these approaches will be
covered here 
we begin with the first method  attempting to find a number of reasonable control rules
simply by thinking about the properties of the zenotravel domain  given some experience
from other planning domains  this is in fact quite easy  for example  in many domains
there are certain goals such that once they are satisfied  one should never allow them to be
   

fitalplanner in ipc       extensions and control rules

destroyed  in the zenotravel domain  people who are at their destinations never need to
board an aircraft  which gives rise to the following control rule 
 control  name only board when necessary
 t  in person  aircraft    t    in person  aircraft  
city   city     t  at person  city    goal at person  city      city    city   
this tal formula states that if we have a state transition from the person not being in the
aircraft at time t to the person being in the aircraft at time t       that is  if the person just
boarded the aircraft   then there must be a reason why this is allowed  the person must
be in a certain city and there must be a goal that the person should be in another city 
as noted previously control formulas can usually be written in many different forms 
for example  it would have been equally valid to state that if a person is at a city  and
therefore not in an aircraft   and is not required to be somewhere else  then at the next
timepoint that person should still not be on board an aircraft 
 control  name only board when necessary
 t  at person  city    city    goal at person  city      city    city    
 t    in person  aircraft 
note that although it may at first glance appear that a planner would have to be extraordinarily stupid to destroy goals that have already been satisfied  there are also many cases
where temporarily destroying a goal is necessary in order to satisfy other goals  for example  if there is a goal that a certain aircraft should be at a certain location and it has already
reached that destination  it might still have to fly a number of people to their destinations
before it can return to its own destination 
another natural idea  since aircraft do not follow predetermined routes in zenotravel 
as they usually do in real life  would be to say that people should only debark when they
have reached their final destination 
 control  name only debark when in goal city
 t  in person  aircraft    t    in person  aircraft  
city    t  at aircraft  city    goal at person  city     
there is a potential problem with this rule  in some cases an optimal plan might require a
number of people to debark one plane and then board a number of other planes  which could
fly them to their destination concurrently  and this is strictly forbidden by only debark whenin goal city  this is a common problem that occurs for many planning domains  and it is
up to the user to determine what to do depending on the requirements of the application
for which the planner is being used 
there are a number of possible choices  we could ignore this problem and accept suboptimal plans  skip the rule completely and let the planner search through a vastly greater
search space in order to find a plan which is guaranteed to be optimal  or as a compromise 
attempt to create a weaker rule that does cut down the search space to some degree but
gives optimal or closer to optimal plans  during the planning competition the conditions
were somewhat artificial and were not clearly stated  would it be beneficial for a planner
to spend ten times as much effort finding a plan if this plan was only five percent better  on
average  we guessed that this would not be the case  and consequently we chose to include
the control rule as stated above 
   

fikvarnstrom   magnusson

in the future  a better solution would most likely be to prefer those plans where a person
does not debark before reaching his destination but still allow other plans  this alternative
will be discussed in more detail in the conclusions 
given these two rules  we might now continue with the second approach to finding
control rules  we run talplanner on a simple problem instance and consider the operator
sequences the planner examines during the depth first search process  this is the beginning
of such a sequence for the problem instance in figure    the complete plan generated by the
planner contains     operators and requires    time steps  it is shown here in the ipc     
strips result format where the timepoint at which an action is invoked is followed by the
action instance 
  
  
  
  
  
  
  
  

 board person  plane  city  
 board person  plane  city  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 board person  plane  city  
 board person  plane  city  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  

  
  
  
  
  
  
  
  

 debark person  plane  city  
 debark person  plane  city  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 refuel plane  city  fl  fl  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  

    refuel plane  city  fl  fl  
    refuel plane  city  fl  fl  
    fly plane  city  city  fl  fl  
    fly plane  city  city  fl  fl  
     refuel plane  city  fl  fl  
     fly plane  city  city  fl  fl  
      refuel plane  city  fl  fl  
   

the beginning of the operator sequence appears to be reasonable  but after time    airplanes
seem to be flying around randomly  there are no control rules guiding them  so apparently
it was mainly luck that caused the planes to find reasonable cities to fly to at time   and   
to make airplanes more goal directed  we identify three important reasons why an airplane
should move from city to city   that the goal asserts that the aircraft must end up in city 
when the plan is complete  that one of its passengers wants to go to city   or that there is a
person waiting to be picked up by an airplane in city   the following rule formalizes these
three intuitions 
 control  name planes always fly to goal
 t  at aircraft  city     t    at aircraft  city   
city     t    at aircraft  city    
 goal at aircraft  city     
person    t  in person  aircraft   goal at person  city       
person    t  at person  city     goal at person  city         
with these control rules  talplanner can quickly produce a set of plans for the    handcoded problems from the ipc      competition  and although the plans will not be optimal  they will not be nearly as bad as the example given above  together  the plans require
a total of      operators and     time steps  the plan for the example in figure   requires
   operators and   time steps 
nevertheless  there are still some improvements that can be made  the first criterion
is too admissible  it allows a plane to visit its destination even if it still needs to pick up
or drop off passengers  one way of preventing this would be to add the condition that all
passengers must have reached their destinations 
 define  t  all persons arrived 
person  city   goal at person  city      t  at person  city    

   

fitalplanner in ipc       extensions and control rules

 control  name planes always fly to goal
 t  at aircraft  city     t    at aircraft  city   
city     t    at aircraft  city    
  t  all persons arrived  goal at aircraft  city     
person    t  in person  aircraft   goal at person  city       
person    t  at person  city     goal at person  city         
this improves plan quality slightly  and talplanner now requires      operators and    
time steps  but the new control rule is in fact too strict  which can be seen in the following
plan tail for handcoded strips problem number   
   
   
   
   
   
   
   

 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 refuel plane  city  fl  fl  
 refuel plane  city  fl  fl  
 debark person   plane  city  
 debark person   plane  city  
 debark person   plane  city  

   
   
   
   
   
   

 refuel plane  city  fl  fl  
 refuel plane  city  fl  fl  
 refuel plane  city  fl  fl  
 refuel plane  city  fl  fl  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  

in this example  plane  and plane  had to wait until all passengers had debarked from
several other planes until they could go to their final destinations  even though we can
clearly see that there was no real reason for them to wait  because all potential passengers
had already been picked up and plane  and plane  already had enough fuel  we once again
alter the control rule according to this new insight  a plane can go to its final destination
if all passengers on board the plane are headed towards the same destination and there is
no person left to be picked up  that is  all persons have already arrived or are currently on
board planes  
 define  t  all persons arrived or in planes 
person  city   goal at person  city      t  at person  city    aircraft   in person  aircraft     
 control  name planes always fly to goal
 t  at aircraft  city     t    at aircraft  city   
 t    at aircraft  city    
  goal at aircraft  city       t  all persons arrived or in planes 
person    t  in person  aircraft   goal at person  city       
person    t  in person  aircraft   goal at person  city       
person    t  at person  city     goal at person  city        
this yields another minor improvement  and talplanner now requires      operators and
    time steps  for the example used above  the end of the plan now looks as follows 
   
   
   
   

 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 fly plane  city  city  fl  fl  
 refuel plane  city  fl  fl  

   
   
   
   

 debark person   plane  city  
 debark person   plane  city  
 debark person   plane  city  
 fly plane  city  city  fl  fl  

we once more study the plans generated by the current set of rules and quickly identify
another obvious problem  any number of airplanes may fly to the same location to pick up
the same person  once again  it is necessary to find a reasonable balance between finding
optimal plans and finding plans quickly  in the contest  we attempted to find a high quality
   

fikvarnstrom   magnusson

 but probably non optimal  plan as quickly as possible  this was done by ensuring that no
more than one airplane may go to any given place at the same time  if the sole purpose for
going there is to pick up a person who is waiting 
 control  name planes always fly to goal
 t  at aircraft  city     t    at aircraft  city   
city     t    at aircraft  city    
  goal at aircraft  city       t  all persons arrived or in planes 
person    t  in person  aircraft   goal at person  city        
person    t  in person  aircraft   goal at person  city       
person    t  at person  city     goal at person  city       
aircraft     t    at aircraft   city    aircraft     aircraft    
this rule provides a major improvement  and the complete set of plans now requires     
operators and     time steps 
so far  we have controlled where airplanes fly  when people board an airplane  and when
they debark  there are no rules governing refueling  and a quick look at a plan for one of
the larger problem instances reveals that whenever an aircraft has nothing else to do  it will
refuel  this seems a little bit wasteful  but we are satisfied with adding a rule stating that
airplanes must only refuel when their tanks are empty  this rule is not perfect  since an
airplane may miss an opportunity to pre emptively refuel and it can still refuel one fuel
level even if it is not going to fly  but it does provide a significant improvement  bringing
the number of operators down to       the number of time steps is still     
a few minor adjustments were made to these rules before they were used in the competition  these adjustments include a modification to only board when necessary to ensure
that a person who must travel from city to city  will choose a plane that already needs
to visit both city and city    if this is possible  since this is less likely to increase the total
number of flights 
one final change is prompted by the fact that the intended differences in timing between
fly and zoom cannot be modelled correctly in the strips version of the domain  since
all operators must take the same amount of time  the only difference between these two
operators is that zoom uses twice as much fuel  although it would have been possible to
add a control rule ensuring that zoom was not used  it was easier to simply remove the
zoom operator from the domain definition 
      zenotravel  simpletime
the simpletime version of zenotravel is quite similar to the strips version  the only
difference being that actions may have non unit duration and that certain preconditions
must hold throughout the execution of an action  the talplanner operator definitions are
changed accordingly  for example  the board and fly operators can be changed as follows 
 operator board person  aircraft  city    at t
 precond  t  at person  city    at aircraft  city  
 prevail
 t    t     at aircraft  city  
 duration   
 effects
 t    at person  city      false   t     in person  aircraft     true

   

fitalplanner in ipc       extensions and control rules

figure    a zenotravel problem instance  simpletime problem   
 operator fly aircraft  city    city    flevel    flevel     at t
 precond  t  at aircraft  city     fuel level aircraft  flevel     next flevel    flevel   
 duration    
 effects
 t    at aircraft  city       false   t    fuel level aircraft  flevel       false 
 t      at aircraft  city       true   t      fuel level aircraft  flevel       true
if we run the planner on a set of simpletime problem instances  we get almost immediate
results  the planner claims that there is no plan for any of the instances  the reason for
this is  of course  that the control rules must be satisfied in any valid plan  and those rules
were designed with the underlying assumption that actions had unit duration  for example 
consider planes always fly to goal  which states that if a plane leaves a city at time t  it should
be at a meaningful destination at t    when the fly action is invoked the plane must be
at some city city    but beginning at the next time step there will be an interval where the
aircraft is not present in any city at all  until it finally arrives in city      time steps later 
in other words  planes always fly to goal now ensures that the fly operator cannot be used
at all  which is not quite what was originally intended 
one way of solving this problem would be to alter planes always fly to goal to say that if
a plane leaves a city at time t  it should be at a meaningful destination at t      unfortunately  the duration of the flight would then be encoded directly in the control rule instead
of only in the operator  and so it would not work in the timed version  where operators
have variable durations  in fact  it would not even work in simpletime  because the zoom
operator must also be taken into account 
instead  the domain model is augmented with a new fluent flying to aircraft  city  which
keeps track of whether a plane is flying  and if so  what its destination is  to ensure that this
fluent is kept up to date  the following is added to the effects of the fly and zoom operators 
 t    flying to aircraft  city       true   t      flying to aircraft  city       false    for fly
 t    flying to aircraft  city       true   t      flying to aircraft  city       false    for zoom
the planes always fly to goal rule above can now be changed as follows  stating that if an
aircraft ceases to be at city   then it must be flying to a reasonable destination 
 control  name planes always fly to goal
 t  at aircraft  city     t    at aircraft  city   
city     t    flying to aircraft  city            
the same problem arises for boarding  and a new fluent boarding person  aircraft  is added
and used whenever necessary  given these changes  the following are the first steps of the
   

fikvarnstrom   magnusson

plan generated by talplanner for the problem instance in figure    shown in the ipc     
timed result format where the timepoint at which an action is invoked is followed by the
action instance and the duration of the action 
    board person  plane  city       
     fly plane  city  city  fl  fl        
     zoom plane  city  city  fl  fl  fl        
intuitively  flying and zooming plane  at the same time should be impossible  but we have
forgotten to specify this to the planner  both actions have their preconditions satisfied at
time     there are no prevail conditions  and the effects of the actions do not contradict
each other since they take place at different timepoints  fly ends at time      while zoom
ends at time     
there are several ways of specifying that fly and zoom are mutually exclusive  for
example  it would be possible to introduce an interval effect stating that flying to aircraft 
city    must hold throughout the inner execution intervals of these actions  and become false
at the end of each action 
 t   t      flying to aircraft  city       true   t      flying to aircraft  city       false    for fly
 t   t      flying to aircraft  city       true   t      flying to aircraft  city       false    zoom
it would also be possible to use a semaphore resource  an aircraft specific resource with an
initial value of    which can be borrowed exclusively by the fly and zoom actions  when
one of these solutions is used  talplanner finally rewards us with a short and correct plan 
    board person  plane  city       
     fly plane  city  city  fl  fl        
      board person  plane  city       
      debark person  plane  city       
      fly plane  city  city  fl  fl        
      debark person  plane  city       
   plan length    maxtime    
can it be improved  remember that the strips version never made use of the zoom
operator  but in the simpletime version  flying takes     time steps and uses one unit
of fuel  zooming takes     time steps and uses two units of fuel  and refueling one unit
takes    time steps           is more than             and therefore we have the opposite
situation  zoom is always better than fly  commenting out the unwanted fly operator yields
the following plan 
    board person  plane  city       
     zoom plane  city  city  fl  fl  fl        
      board person  plane  city       
      debark person  plane  city       
      zoom plane  city  city  fl  fl  fl        
      debark person  plane  city       
   plan length    maxtime    

   

fitalplanner in ipc       extensions and control rules

      zenotravel  timed
the timed version further complicates the timing of the actions  boarding and disembarking times are constant but problem specific and are defined in the respective problem
definition as two new functions  boarding time and debarking time  refueling always fills the
plane to its maximum capacity  but consumes time relative to the amount of fuel received
and the refuel rate of the aircraft  each aircraft also has a fast speed and a slow speed with
corresponding fast burn and slow burn fuel consumption  the distances between cities are
specified using the distance city   city    function 
in the timed version  operator durations have to be correctly calculated with a precision
of three decimals  prompting the talplanner changes discussed in sections     and     
once these extensions to talplanner had been implemented  few changes were needed to
transform the simpletime domain to the timed version 
the most important difference was perhaps the fact that depending on the speed and fuel
consumption values defined in each problem and the situation where the operator is used  it
is sometimes better to use the fly operator and sometimes better to use the zoom operator 
unlike the strips version where fly was always better and the simpletime domain where
zoom was always better 
so when is zooming better than flying  it may seem like it would be easy to answer
this question  given that we are only interested in minimizing time  just check whether
refueling the aircraft sufficiently to be able to zoom  followed by zooming to the destination 
would be faster than only refueling enough to be able to fly and then flying more slowly to
the destination  this is handled by the first clause in use fly instead of zoom below  the
precondition of fly is then altered to require that use fly instead of zoom be true  and the
precondition of zoom requires that use fly instead of zoom be false  if we had been interested
in minimizing a combination of time and fuel usage  then this could also have been taken
into account 
this is not quite sufficient to handle all problems  though  an airplane has a maximum
fuel capacity  so if its destination is too distant  it may not be able to zoom  this is handled
by the second clause in use fly instead of zoom 
yet another problem is that it is not possible to tie one refueling action to each flight 
as one would expect in the real world  there are two reasons for this problem 
first  airplanes may already have some fuel in the initial state  so in some situations a
plane might zoom to its destination without incurring any additional cost  again assuming
that the time required for executing the plan is the only metric being used  the plane
already had enough fuel anyway and never had to refuel 
second  unlike the simpletime version  an airplane cannot refuel just enough  the
refuel operator always fills the tank completely  this change was most likely introduced in
order to make the planning task easier by reducing the number of possible actions to choose
from  for example  a planner that needs to create all ground instances of each operator
might have some trouble if the refuel operator would take the amount of fuel as a floating
point argument   but despite the probable intention behind this change  it introduces new
problems for our control formulas  if a planes tank is half full and this is enough fuel to
zoom from a to b  it might then have to fill the entire tank before continuing to c  while
if it used the fly operator  it might be able to continue to c without refueling at all  this

   

fikvarnstrom   magnusson

means that one would have to take all possible future flights into account when determining
whether to fly or zoom  if the domain had been modeled in more detail  this problem would
not have existed 
given these two complications  guaranteeing an optimal or near optimal plan using a
control rule is not easy  which is indeed only to be expected  for the competition we decided
to be satisfied with a heuristic compromise  adding a third clause to use fly instead of zoom
ensuring that if zooming would require refueling immediately but flying would not  the fly
operator would be used 
   fly is  probably  better than zoom if 
 define  t  use fly instead of zoom aircraft  city   city   
   if fly is faster wrt speed and refueling 
  t           slow speed aircraft            slow burn aircraft    refuel rate aircraft    
         fast speed aircraft           fast burn aircraft    refuel rate aircraft    
   if zoom is impossible across the given distance 
  t  distance city    city      fast burn aircraft    capacity aircraft   
   if zoom has to refuel immediately but fly does not 
  t  fuel aircraft     distance city    city      slow burn aircraft  
fuel aircraft    distance city    city      fast burn aircraft  
      zenotravel  discussion
finding control rules that yield good  but usually suboptimal  plans is not too difficult in
the zenotravel domain  there are no risks involved in flying a plane to pick up passengers
since all the passengers will always fit in the plane and refueling is possible in any city  in
other words  it is not really possible to get stuck while looking for a solution  also  since
the graph of cities is fully connected  no route planning is necessary 
a fourth version of zenotravel  called numeric  was available in the contest but due to
lack of time we decided not to compete in this domain 
among other things  the numeric version contains an additional constraint on the number of passengers that an aircraft can carry  at a first glance  this constraint may seem to
introduce new problems  however  it is only enforced in the zoom operator  and since the
numeric domain does not make use of durational operators  it suffers from the same problem
as the strips domain  the zoom operator consumes more fuel and limits the number of
passengers  but does not deliver any advantages because it is no faster than flying 
the real difficulty in the numeric version comes from the use of problem specific metrics
that measure the quality of a solution  for example  for one problem the planner may be
required to minimize total time       total fuel used  while for another problem it may be
required to minimize total time only  until now  we have usually been satisfied with finding
plans of good but not optimal quality  and this has been done by tuning control rules 
for example by introducing the use fly instead of zoom function to determine whether fly or
zoom should be used  as discussed above  this tuning is naturally done on the domain level
rather than the problem level  an optimizing version of talplanner is under development 

   

fitalplanner in ipc       extensions and control rules

figure    a depots problem instance  strips problem   
    the depots domain
the depots domain  illustrated in figure    contains locations  trucks  hoists  movable
crates  and pallets whose locations are fixed  trucks move crates between any two locations
and can carry any number of crates at the same time  hoists are distributed among the
locations and load crates into trucks or stack crates on surfaces  pallets or other crates  
the goal is always to bring the crates into a certain configuration of stacks  where each
stack is placed on a specific pallet 
strips  the depots domain is a combination of two other well known planning domains 
the logistics domain and the blocks world  therefore it seems natural to start by taking a
look at existing control rules for those two domains  and to see whether those rules can be
combined easily or whether more complex rules are required due to interactions between
moving and stacking blocks 
we begin with the blocks world part of the problem  the unbounded blocks world was
used as a benchmark domain in ipc       and there talplanner used a modified version
of the rules in bacchus and kabanza        which ensure that the planner only adds blocks
to good towers  stacks that are already in their final position and will not have to be
dismantled later in order to remove a block at a lower level  can these rules be reused in
the depots domain  one prerequisite is the availability of temporary storage for all crates 
since in the worst case every single stack of crates must be torn down completely before it
is possible to start stacking crates on top of each other  fortunately  although there is only
a limited number of pallets  trucks can  somewhat counter intuitively  contain any number
of crates  and the planner can use them as storage  only minor changes were required in
order to handle the two separate types of surfaces  pallets and crates 
continuing with the logistics part  one simple rule can be reused from the standard
logistics domain  only unload a crate at its goal location  its dual rule  only load a crate
if it needs to be moved  is not required  the blocks world rules ensure that a hoist does
not lift a block unless it needs to be moved  and therefore it is already impossible to load
such blocks into a truck 
it remains to ensure that vehicles only drive to those locations where they can be of use 
in the standard logistics domain  a truck can drive to another location if there is a package
   

fikvarnstrom   magnusson

figure    a driverlog problem instance  strips problem   
that needs to be picked up or delivered there  but due to the use of stacks of crates in the
depots domain  the rule must be modified  a vehicle may drive to a location if     there is
a crate there that must be moved to another location      there is a crate there that must
be stacked differently  or     there is a crate in the truck that needs to be at the location 
its destination is ready  and there is no other crate that should also be at the same location
that the truck has not yet picked up 
simpletime  in the simpletime version  lifting and dropping crates still takes one unit of
time  loading takes three units  unloading four  and driving ten  a few changes were made
to ensure mutual exclusion  for example  hoists can only lift one crate at a time  also  a
driving to fluent was introduced to keep track of where trucks are headed  similar to flying to
in zenotravel 
timed  in the timed domain  the time required for loading and unloading a crate depends on how powerful the hoist is and on the weight of the crate  the time required for
driving between two locations depends on the speed of the truck and the distance between
the locations  again  only minor changes were required to handle the domains  although
higher quality plans could certainly have been produced by taking timing into account when
determining which hoists and trucks to use 
    the driverlog domain
driverlog  illustrated in figure    is yet another logistics domain  this time introducing
the concept of truck drivers and road maps  a number of packages are transported between
locations by trucks  there are two sets of routes connecting the locations  links  where
trucks travel  and paths  which drivers can walk along when not driving a truck  a truck
can only have one driver at a time but can load as many packages as is needed 
strips  several control rules used in previous logistics domains were useful for driverlog
with minor modifications  for example  packages should only be loaded into trucks if they
need to be moved  and should not be unloaded until they have reached their final destination 
on the other hand  a number of changes were necessary due to the use of road maps 
most importantly  vehicles were previously only allowed to drive to locations that were immediately useful because there were packages to be picked up or delivered  in the driverlog
   

fitalplanner in ipc       extensions and control rules

domain there may only be direct roads between some locations  specified by a predicate
link from  to    and a truck may have to move through several intermediate locations in
order to reach its destination  consequently the control rules must be relaxed to allow
trucks to visit locations that are not useful in themselves  nevertheless  some degree of
goal directedness is still required  one possible method is to identify for each vehicle the
set of locations where the vehicle might be useful  and to require that it chooses one such
location and then takes the shortest path to its chosen destination  this method was used
in the competition with the help of the built in shortest path algorithm discussed in section     and a control rule stating that each step  each invocation of drive or walk  must
decrease the distance to the current destination  the following definitions will be explained
below 
 define  t  reasonable truck location truck  location  
   omitted due to space constraints
 distfeature driving distance between from  to   domain integer  link link
 mindistfeature driving distance to location satisfying formula
 distfeature driving distance between  domain integer
 define  t  driving distance to reasonable destination truck  location  
driving distance to location satisfying formula location  to 
 t  reasonable truck location truck  to  
a boolean fluent reasonable truck location truck  loc  is defined in terms of a logic formula 
which specifies whether the given location is a reasonable destination for a given truck at the
timepoint when it is evaluated  the driving distance between function accesses the shortest
path algorithm to find the length of the shortest path between from and to  given that
the road links are specified by the link predicate  the driving distance to location satisfyingformula function accesses another version of the shortest path algorithm and is used in
driving distance to reasonable destination in order to find the shortest distance from location
to any location to that satisfies reasonable truck location  since all links have the same cost 
it is then sufficient to require that whenever a truck moves  its driving distance to reasonabledestination decreases 
further changes were required due to the use of drivers  there may not be drivers for
all trucks  so packages should not be loaded into a truck until the planner knows the truck
will have a driver  drivers should not disembark if there are still packages in the truck  or
if there is a goal that the truck must be somewhere else  drivers may have to walk along
paths in order to reach a truck  so just like trucks  drivers must select one useful destination
and then take the shortest path to their chosen destinations 
additional control rules ensure that multiple trucks do not choose the same destination
unnecessarily  and that multiple drivers do not choose to walk to the same location 
simpletime  in the simpletime version  loading and unloading objects takes two units
of time  driving takes ten units  and walking takes twenty units  the operators are changed
accordingly  and a going to fluent is introduced to keep track of drivers and trucks that are
moving towards a new location but have not yet arrived  a few minor adjustments must
be made to the control rules 
timed  in the timed version  the time required to walk or drive between two locations is
   

fikvarnstrom   magnusson

determined by a pair of functions specified in each problem instance  since individual road
segments can have different lengths  the method we used to ensure drivers and trucks used
the shortest path to their current destination is no longer sufficient  and must be modified
slightly  other than this  there are no major changes for the timed version 
    the rovers domain
the rovers domain simulates a simplified planetary exploration expedition  a lander vessel
carries a number of rovers to the planet surface and provides a communication link back to
earth  each rover has a subset of the general capabilities  retrieving soil samples  retrieving
rock samples and capturing images using cameras that support different imaging modes 
the cameras are mounted on the rovers  as are storage compartments  one for each rover 
which can hold one soil sample or one rock sample  data from a sample must be sent to
the lander by a communication link  all missions revolve around navigating waypoints on
the planets surface to collect samples and take images of specified objectives that are only
visible from certain waypoints  the terrain may prevent rovers from going directly between
two waypoints and different rovers handle different terrain so a list of routes each rover can
use is provided 
strips  following a control scheme similar to the one used in driverlog  we limit the
movements of rovers to locations where they can perform some useful action like collecting
a rock sample or capturing an image  the problem of finding a path from one waypoint to
another is also solved in the same way as in driverlog  except that each rover has its own
set of routes between waypoints 
simpletime  the changes in the simpletime version are trivial  operator durations are
changed  a few mutual exclusion relations need to be enforced  and a new fluent calibrating camera  keeps track of whether a certain camera is being calibrated 
timed  the timed version introduces the concept of energy  where each rover has a limited
amount of energy and each action it does consumes some of the energy  this is similar to the
use of fuel in the zenotravel domain  but there is also a major difference  the rovers have
been equipped with solar panels that recharge the rover  but only some of the waypoints
that a rover can go to are directly exposed to the sun  which is a requirement for the solar
panels to work  the airplanes in the zenotravel domain can refuel anywhere  and so fuel
usage is only relevant in terms of minimization of resource usage  whereas a rover that uses
its energy unwisely can get stuck in the shade  unable to do anything or go anywhere  to
prevent this we can either let the planner backtrack and search for a better plan  or we
can introduce stricter rules that keep energy levels in mind when deciding what a rover is
allowed to do  the latter approach is taken below 
the critical point is when a rover does not have enough energy to reach a waypoint in
the sun and recharge  using the shortest path algorithm it is possible for a control rule to
determine the distance to the closest waypoint that is exposed to the sun  in addition to all
waypoints that were previously allowed  it is also reasonable for a rover to go to a waypoint
that is exposed to the sun if the rover does not have enough energy to perform an action
and then go recharge  or if there do not exist any other waypoints that are both affordable
and reasonable to visit 

   

fitalplanner in ipc       extensions and control rules

figure    a satellite problem instance  strips problem   
    the satellite domain
in the satellite domain a number of satellites orbit the earth  each equipped with a set of
scientific imaging instruments  the satellites turn in space  targeting stars  planets and interesting phenomena to capture images of them using different instrument operation modes 
these modes can include regular or infrared imaging and spectrographic or thermographic
readings but are different for each problem  the planners task is to schedule a series of observations so that the satellites are used efficiently  figure   shows a small example problem
instance  with arrows showing the directions in which the satellites are pointing 
directions are not represented as explicit coordinates  instead  satellites can turn to
a new direction by giving the turn to operator an argument specifying the star  planet or
phenomenon that the satellite should point to  instruments first need to be activated using
switch on  then calibrated at a calibration target with the calibrate operator before they
can capture images using take image  each satellite has only enough power to operate one
instrument at a time  so switching active instruments is always initiated by the switch off
operator to deactivate the first instrument 
      satellite  strips
since the task consists of collecting a number of images  we begin by restricting the use of
take image to images that are mentioned in the goal 
 control  name only take pictures of goals
 t  have image direction  mode    t    have image direction  mode  
goal have image direction  mode  
the next step is to restrict the directions in which satellites turn to those that may actually help in collecting the images  the task is split into a control rule  only point ingoal directions  and a definition of goal directions  a satellite is allowed to turn towards a
direction to take a picture  to calibrate an instrument or if a goal specifies that the satellite

   

fikvarnstrom   magnusson

should point in the direction and there is no more work left to do 
 define  t  goal direction satellite  direction  
 t  take image possible satellite  direction  
instrument  
 t  power on instrument   calibrated instrument  
 t  calibration target instrument  direction   on board instrument  satellite    
goal pointing satellite  direction     t  all images collected
the take image possible function checks not only if an image is to be collected but also
that it has not already been taken and that the satellite has the necessary instrumentation
ready  if the active instrument is not calibrated  the satellite may first have to turn towards
another direction and calibrate it 
 define  t  take image possible satellite  direction  
mode   goal  have image direction  mode   
 t  have image direction  mode  
instrument  
 t  power on instrument   calibrated instrument  
 t  on board instrument  satellite   supports instrument  mode    
the switch on and switch off operators are still not regulated by control rules and the
planner quickly takes up the habit of repeatedly flipping the power to different instruments
on and off  once an instrument has been powered on and calibrated  using it as much as
possible before switching to another instrument seems reasonable  a usefulness function 
putting a value on the usefulness of a particular instrument  helps decide which instrument
to power on first 
 define  t  usefulness instrument  
value t   sum  mode    t  supports instrument  mode   mode needed for goal mode      
 define  t  mode needed for goal mode  
direction   goal have image direction  mode     t  have image direction  mode   
add one to the usefulness score of an instrument for each imaging mode that it supports
and that is needed in some goal  this score is then used in a control rule that chooses a
satellites most useful instrument  if it has any 
 control  name use the most useful instrument
 t  power on instrument    t    power on instrument  
 t  usefulness instrument      
satellite  instrument   
 t  usefulness instrument      usefulness instrument  
 t  on board instrument  satellite   on board instrument    satellite   
switching off an instrument is only allowed if the instrument is no longer required 
 control  name dont switch instrument off if you dont have to
 t  power on instrument    t    power on instrument   
 t  mode   supports instrument  mode   mode needed for goal mode   

   

fitalplanner in ipc       extensions and control rules

we have run out of more or less obvious improvements  but analyzing the planner output
reveals one remaining inefficiency  the satellites often simultaneously decide to turn to the
same direction because a picture needs to be taken in that direction  despite the fact that
only one satellite needs to take the picture  this is similar to the situation in the zenotravel
domain where a number of aircraft may concurrently choose to pick up the same passenger 
but there are some differences due to the fact that the only reason for a satellite to point
in a certain direction is in order to calibrate itself or take an image  which makes the task
somewhat easier 
therefore this problem can be solved in a different way  using a resource for mutual
exclusion  this resource  called point towards direction  and having a capacity of    can be
borrowed temporarily by turn to for the duration of the turn  if one satellite turns towards a
specific direction d  no other satellite can turn towards d without causing a resource conflict 
this still leaves one problem  when the first satellite has finished turning  it no longer
owns the point towards d  resource and therefore another satellite can immediately start
turning towards d  it is no longer possible for more than one satellite to turn towards the
same direction at once  but while the first satellite is taking pictures  other satellites can
turn to that direction one by one  until finally all the desired pictures have been taken
in that direction and goal direction sees that there is no longer any valid reason to point
towards d  this can be solved either by changing the definition of goal direction or by letting
take image borrow the same resource 
clearly  this type of swarming problem occurs quite often in concurrent domains and
a more principled solution should be investigated in the future 
      satellite  simpletime
the simpletime version changes the duration of some operators  turning takes five time
units  switching an instrument on takes two units  calibrating it takes five units and taking a picture takes seven units  a couple of helper fluents  turning towards  calibrating 
have image generalized  an image exists or is being taken  and power on generalized  power
is on or a switch on action is being executed  keep track of actions that have begun but not
completed  the affected control rules are updated accordingly 
      satellite  timed
the timed version of the satellite domain includes two new functions  the calibration time
specifies the time required to calibrate  while the slew time function represents the time
required for a satellite to turn between two directions  neither of these changes prompts
any significant changes to the simpletime control 
      satellite  discussion
the satellite domain does not provide a real challenge as long as the planner is only trying
to find a correct plan  finding a short plan is harder  especially in the timed version  and
would require additional analysis to determine in which order images should be collected
and which satellites should be used for each image  doing this using control rules seemed
a bit like overkill  especially since we had not yet created control rules for the complex
umtranslog   domain  for this reason  we decided to be satisfied with what we had done
   

fikvarnstrom   magnusson

so far  and were surprised when the plans we generated turned out to be of considerably
lower quality than those produced by some other planners 
after the contest  we were informed of the reason  or at least the main reason  the
automatic problem generator that created the problem instances randomized the slew times
between every pair of directions and did not check for geometrical consistency that would be
present in a real world situation  we had subconsciously assumed that the problem instances
satisfied the triangle inequality  but this was not the case  and the other planning teams had
discovered this  for example  in handcoded problem     turning a satellite directly between
phenomenon   and groundstation  takes        units of time  while turning it through two
carefully selected intermediate directions requires       units of time 
initial testing shows that taking this into consideration and once again using the built in
shortest path algorithm yields significantly shorter plans when plan length is measured by
the time point at which the goals have been satisfied 
another potential improvement would be to change the last clause in goal direction to
allow satellites to turn towards a direction specified in the goals as soon as one has started
taking the last picture  rather than waiting until one has finished taking the last picture 
    the umtranslog   domain
the umtranslog   domain is another logistics domain  but with    types     predicates 
   functions and    operators  its size and complexity is incomparable to the previously
encountered logistics domains in the contest 
since the formal domain definition was the only information provided about the domain
and there was no high level description  we had to work out all the information about
the domain from the pddl definition  this was not a major problem for the previous
domains  since they were generally quite simple and easy to understand  but it did give
us some problems in umtranslog    a significant amount of time was spent trying to
determine exactly how packages were allowed to move and how they can be loaded into and
unloaded from various kinds of vehicles  in retrospect  it would probably have been better
to do as some other teams did  skip the umtranslog   domain completely and spend that
time on the numeric and complex versions of the other domains 
the domain  trucks  trains or aircraft transport packages between locations but they
must follow strict movement patterns  a few locations are transportation hubs  some are
transportation centers while the rest are ordinary locations  a package is only allowed to
move up and down through this hierarchy once and only move between two locations in the
same layer once  the longest possible route for a package is thus from an ordinary location
to a transportation center to a hub to another hub to a transportation center and finally to
another ordinary location 
the domain groups locations into cities  which are then grouped in regions  trucks
travel between any two locations in the same city or by an existing road route between
two cities  trains and planes always use predefined routes between transportation centers
and hubs  a great number of restrictions further complicate movements  packages must be
compatible with the vehicle they are loaded into  the vehicle must have enough free space 
not be loaded too heavily and not be wider  longer or higher than the route and destination
location accepts  finally  the locations  vehicles and routes must all be available for use 
   

fitalplanner in ipc       extensions and control rules

control rules  as in previous domains  we specify what a reasonable location is and limit
vehicle movements to destinations that are reasonable  a truck might want to pick up
or deliver a package at the location or  if the truck cannot reach the goal location of the
package  unload the package at a transportation center to be picked up by another vehicle 
our control rules do not allow trucks to pick up several packages  this makes finding
optimal solutions impossible in the general case but simplifies the search for acceptable
solutions a great deal  there is an imminent risk that any other packages the truck is
carrying will end up at the wrong location if it is allowed to travel about  picking up more
packages along the way  since all packages must move according to the specified pattern of
transportation centers and hubs  moving a package that has once arrived at a location that
is not a transportation center is not allowed and the package will be stuck there  restricting
trucks to picking up one package at a time avoids this problem 
there is also a large group of loading and unloading rules controlling  among other
things  the opening or closing of valves and doors and loading or unloading of packages 
finally  packages are only loaded into vehicles that are actually able to take them to a useful
location 
creating control rules and meeting the contest deadline left no time to get the domain
working with concurrent planning  instead  we had to make do with sequential planning 
given more time  the set of control rules could definitely be improved  if planning speed
is less of an issue  more search can be allowed and higher quality plans generated  more
and better problem instances would be needed as guidelines when developing better control
rules since the contest problems did not make full use of the intended transportation scheme
with transportation centers and hubs 

   improvements after the competition
though the planning competition ended during the aips      conference in april       
our work on talplanner naturally did not cease there  there are still many improvements
that can be made  and a couple of them that are related to the development of new domains
and control rules have been implemented during the summer of      
    domain visualization
as was discussed in the description of the zenotravel domain  the process of creating control
rules for a planning domain often involves incremental improvements  talplanner is run on
a number of problem instances using one set of control rules  or possibly without any control
rules at all  and the beginning of the resulting search tree is analyzed in order to determine
where bad choices were made and how they can be avoided using new or improved control
rules  this is repeated until the planner consistently finds plans of good quality 
during this process  one must study not only the output of the planner but also the
structure of the particular problem instance being solved  for example  in a driverlog
problem it may be necessary to draw the road network being used in each problem instance
using pen and paper  and then study the paths taken by trucks  people  and packages
through the road network  in order to discover whether improvements would be possible 
but often a particular inefficiency only appears in one or a few out of a large set of problem
instances  and tracing the execution of each plan by hand is obviously a tedious and time
   

fikvarnstrom   magnusson

consuming task that ought to be automated as far as possible 
this led to the development of tpvis  a generic graphical visualization framework for
talplanner  the tpvis framework was used to generate the domain images in this article 
and provides an animated display consisting of a set of nodes  where each node can be
a container or an atomic object  containers may represent vehicles  which can contain
packages   locations  since there can be vehicles  packages or other objects at a location 
or other similar concepts  while atomic nodes may be used for packages  instruments on a
satellite  or any other type of object which should be displayed  edges between nodes can
indicate any form of relationship between objects  the most obvious interpretation being that
two location nodes are connected by some transportation route  a built in layout engine
can generate a layout automatically  or you can manually adjust the visual coordinates of
each node 
the visualization framework is then used by concrete plugins adapted to specific planning domains  the driverlog plugin  for example  displays locations as container nodes 
linked by paths where drivers can walk and links where trucks can drive  trucks are also
containers  contained within a specific location  as shown in figure   on page     
as a plan is being generated  tpvis animates the actual movements of objects between
locations  this creates a better instinctive feel for the domain  and the two dimensional
graph display gives an overview that is difficult to provide using only text output  in
addition to animating a graph  tpvis simultaneously lists the partial plan leading up to
the current state and the problem goals that the planner tries to satisfy  tpvis also provides
a limited form of interactive planning since it  at any point in the planning process  allows
the user to force the planner to backtrack and explore a different search branch 
the development of tpvis was not initiated until after the planning contest  if this
graphical visualization had been available during the work on the contest domains  it would
have saved a lot of time  and possibly a tree or two 
    automatic translation from pddl to talplanner
although it was obvious that there should be an automatic translator from pddl to talplanners input format  there were always more urgent features to be implemented  and we
instead decided to translate the ipc      domains by hand  in retrospect this was a mistake  the risk of making an error somewhere in the translation becomes imminent when
dealing with complex domains such as umtranslog    with    operators  some of which
had highly complex preconditions  also  translating long formulas by hand is quite time
consuming  a semi automatic translator was therefore implemented to decrease the amount
of work involved in the translation process and reduce the risk of introducing errors in the
definition 

   discussion and conclusions
the third international planning competition was a major step forward in terms of the
expressibility required to represent the benchmark domains  and it provided a number of
interesting challenges for any planner that wanted to participate in the competition  in this
article we have described how these challenges affected talplanner and shown a number
of extensions that were made in order to meet the challenges  the article also includes a
   

fitalplanner in ipc       extensions and control rules

number of domain dependent control rules for the competition domains  but rather than
presenting an exhaustive list of pre packaged control rules  we have attempted to place more
emphasis on explaining the incremental analysis process that eventually leads to the final
formulas  going into particular detail for the zenotravel domain 
as could be seen in the examples shown in this paper  control rules are often simple 
natural common sense rules  and not very difficult to generate given some basic knowledge about the planning domain  some rules are more complex  but still not difficult to
understand or verify once someone has spent the effort to generate them  and then  unfortunately  there are a few rules that are quite unintuitive  rules that are too complex to be
easily understood  and rules that occasionally forbid optimal plans 
to some extent  such rules might be avoided by gaining more experience in good practices
for writing control rules  or by extending the expressivity of the language in which control
rules are written so that complex conditions can be expressed more succinctly or in a more
natural manner  or simply by spending a little bit more time on the control rules than
was available during the planning competition when much of our time was spent teaching
or working on the planner implementation  however  another important cause for the
complexity of certain rules is probably that we are attempting to express all search control
knowledge in the same way  as control rules that prune the search tree to such a great
extent that even a simple depth first search algorithm is sufficient for efficiently finding good
plans in the remainder of the tree 
not all search control knowledge can easily be expressed in this manner  but this certainly does not mean that control rules should be abandoned altogether  instead  what we
learn from this experience is that control rules might not be the one and only multi purpose
planning tool that will efficiently and easily solve all our planning problems  instead  just
like one would expect  they are one very useful tool that deserves a place in our toolbox but
should be combined with other approaches to planning  just to mention one rather obvious
example  it would be possible to devise a heuristic forward chaining planner whose search
tree would be pre pruned using control rule techniques from talplanner  control rules
could be written to exclude plans where the heuristic gives a suboptimal result  potentially
providing plans that are closer to optimal  and even for domains where the heuristic search
function provides good plans it may often be more efficient to state a number of constraints
as explicit control rules 
such extensions to talplanner have been considered at least since some time before
the second planning competition in       and it has long been clear to us that this approach should eventually be examined and explored  before we could start working on this 
though  the strengths and weaknesses of control rules had to be explored in more depth 
up to now  our work has therefore focused mostly on investigating how far it is possible to
take talplanner in its current shape  with explicit control rules being the only means for
controlling the search process  this work has proved rather fruitful in itself  and talplanner did well in ipc      as well as in ipc       the planner is now becoming reasonably
mature  and after a few more improvements have been made and the planner has been
released for general use  it might be time to take a step back and consider its relation to
other approaches in more depth than has been done previously in order to investigate the
possible advantages of hybrid approaches 
of course  this does not mean that there is nothing more to be done within the pure
   

fikvarnstrom   magnusson

talplanner framework  on the contrary  there are many additional topics to be pursued 
including investigating the application of talplanner to plan optimization problems  where
the very simplest approaches might involve applying standard optimal graph search algorithms to the pruned search tree generated by talplanner  and extending the planner to
handle incomplete knowledge and non deterministic operators  which of these many topics
will be the next focus of our research has not yet been determined 

acknowledgements
this research is supported in part by the witas project under the wallenberg foundation 

references
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for planning  artificial intelligence                   
doherty  p          reasoning about action and change using occlusion  in cohn  a  g 
 ed    proceedings of the   th european conference on artificial intelligence  ecai     pp          john wiley and sons  available at ftp   ftp ida liu se pub labs 
kplab people patdo ecai   ps gz 
doherty  p   gustafsson  j   karlsson  l     kvarnstrom  j          tal  temporal action
logics  language specification and tutorial  electronic transactions on artificial
intelligence                  available at http   www ep liu se ej etai           
doherty  p     kvarnstrom  j          talplanner  an empirical investigation of a temporal
logic based forward chaining planner  in dixon  c     fisher  m   eds    proceedings of
the  th international workshop on temporal representation and reasoning  pp    
    ieee computer society  available at ftp   ftp ida liu se pub labs kplab people 
patdo time   final ps gz 
doherty  p     kvarnstrom  j          talplanner  a temporal logic based planner  ai
magazine                
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research  this issue 
gustafsson  j     doherty  p          embracing occlusion in specifying the indirect effects
of actions  in aiello  l  c   doyle  j     shapiro  s  c   eds    proceedings of the  th
international conference on principles of knowledge representation and reasoning
 kr      pp        san francisco  morgan kaufmann publishers  available at ftp 
  ftp ida liu se pub labs kplab people patdo final kr   ps gz 
karlsson  l     gustafsson  j          reasoning about concurrent interaction  journal of
logic and computation                
kibler  d     morris  p          dont be stupid  in hayes  p  j   ed    proceedings of the
 th international joint conference on artificial intelligence  ijcai      pp         
kvarnstrom  j     doherty  p          talplanner project page  http   www ida liu se 
patdo aiicssite  kplab projects talplanner  

   

fitalplanner in ipc       extensions and control rules

kvarnstrom  j     doherty  p          talplanner  a temporal logic based forward chaining
planner  annals of mathematics and artificial intelligence             
kvarnstrom  j   doherty  p     haslum  p          extending talplanner with concurrency
and resources  in horn  w   ed    proceedings of the   th european conference on
artificial intelligence  ecai        vol     of frontiers in artificial intelligence and
applications  pp          amsterdam  ios press  available at ftp   ftp ida liu se 
pub labs kplab people patdo www ecai ps gz 
kvarnstrom  j          applying domain analysis techniques for domain dependent control
in talplanner  in ghallab  m   hertzberg  j     traverso  p   eds    proceedings of
the sixth international conference on artificial intelligence planning and scheduling
 aips        pp          aaai press  menlo park  california 
long  d     fox  m          the  rd international planning competition  results and
analysis  journal of artificial intelligence research  this issue 

   

fi