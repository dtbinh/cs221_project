journal of artificial intelligence research                 

submitted        published      

pddl      an extension to pddl for expressing temporal
planning domains
maria fox
derek long

maria fox cis strath ac uk
derek long cis strath ac uk

department of computer and information sciences
university of strathclyde  glasgow  uk

abstract
in recent years research in the planning community has moved increasingly towards
application of planners to realistic problems involving both time and many types of resources  for example  interest in planning demonstrated by the space research community
has inspired work in observation scheduling  planetary rover exploration and spacecraft
control domains  other temporal and resource intensive domains including logistics planning  plant control and manufacturing have also helped to focus the community on the
modelling and reasoning issues that must be confronted to make planning technology meet
the challenges of application 
the international planning competitions have acted as an important motivating force
behind the progress that has been made in planning since       the third competition
 held in       set the planning community the challenge of handling time and numeric
resources  this necessitated the development of a modelling language capable of expressing
temporal and numeric properties of planning domains  in this paper we describe the
language  pddl     that was used in the competition  we describe the syntax of the
language  its formal semantics and the validation of concurrent plans  we observe that
pddl    has considerable modelling power  exceeding the capabilities of current planning
technology  and presents a number of important challenges to the research community 

   introduction
in      drew mcdermott released a planning domain description language  pddl  mcdermott        mcdermott   the aips    planning competition committee         which
has since become a community standard for the representation and exchange of planning
domain models  despite some dissatisfaction in the community with some of the features
of pddl the language has enabled considerable progress to be made in planning research
because of the ease with which systems sharing the standard can be compared and the
enormous increase in availability of shared planning resources  the introduction of pddl
has facilitated the scientific development of planning 
since      there has been a decisive movement in the research community towards application of planning technology to realistic problems  the propositional puzzle domains
of old are no longer considered adequate for demonstrating the utility of a planning system  modern planners must be able to reason about time and numeric quantities  although several members of the community have been working on applications of planning
to real domains of this nature for some time  laborie   ghallab        ghallab   laruelle 
      muscettola        drabble   tate        wilkins        there has always been a gap
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

fifox   long

between the modelling requirements of such domains and what can be expressed in pddl 
application driven planners come equipped with their own modelling conventions and black
arts and  as a consequence  it is difficult to reproduce their results and to make empirical
comparisons with other approaches  both of which are essential for scientific progress to be
made 
the pddl language provides the foundation on which an expressive standard can be
constructed  enabling the domain models of the applications driven community to be shared
and motivating the development of the planning field towards realistic application  the
third international planning competition  which took place in       had the objective
of closing the gap between planning research and application  as organisers of the third
competition the authors therefore took the first step in defining an expressive language
capable of modelling a certain class of temporal and resource intensive planning domains 
this had to be done both with an eye to the future and with awareness of the current
capabilities of planners  it had to be possible for the language to be used by members of
the community  or there would be no competitors   in this paper we describe the resulting
language  pddl     in terms of its syntax  semantics and modelling capabilities 
pddl    has been designed to be backward compatible with the fragment of pddl
that has been in common usage since       this compatibility supports the development
of resources which help to establish a scientific foundation for the field of ai planning 
furthermore  mcdermotts original pddl provides a clean and well understood basis for
development and embodies a number of design principles that we considered it important
to retain  pddl    extends pddl in principled ways to achieve the additional expressive
power following  as far as possible  mcdermotts maxim physics  not advice  mcdermott 
       we take this maxim to mean that a language should focus on expressing the physical
properties of the world  not advice to the planner about how to search the associated
solution spaces  of course  any model of physical systems makes simplifying assumptions
and abstracts behaviours at some level  so no model can be claimed to be purely physics
and free of decisions that could influence the use of the model  we do not attempt to
make strong judgements about what constitutes advice but try to implement the maxim
by keeping the language as simple as possible  we make the following two guarantees of
backward compatibility 
   all existing pddl domains  in common usage  are valid pddl    domains  this is
important to enable existing libraries of benchmark problems to remain valid 
   valid pddl plans are valid pddl    plans 
an important contribution made in the development of pddl    is a means by which
domain designers can provide alternative objective functions that can be used to judge
the value of a plan  the use of numbers in a domain provides a platform for measuring
consumption of critical resources and other parameters  an example of a metric that can be
modelled is that energy consumption must be minimized  this is very important for many
practical applications of planning in which plan quality might be dependent on a number
of interacting domain dependent factors 
the organisation of the paper is as follows  in section   we introduce non specialist
readers to the pddl domain description language used in the planning research community 
  

fipddl     expressing temporal planning domains

this background is given in order to provide the foundations for the numeric and durative
extensions made in developing pddl     the paper then focusses on the specific extensions
introduced  numeric expressions and durative actions  in section   we start by explaining
the syntax of numeric expressions and their use in action descriptions  we then explain 
in section    how metrics can be provided as part of the problem description so that the
quality of a plan involving numeric change can be evaluated in terms appropriate to the
problem domain  we present the syntax in which metrics are expressed and give examples 
in section   the paper introduces the notion of durative action as a way of modelling the
temporal properties of a planning domain  both discretised and continuous durative actions
are considered  the syntax is described and examples of modelling power and limitations are
presented in both cases  having given examples of the syntactic representation of durative
actions we present a formal semantics for both discretised and continuous actions and for
plans  sections         and   provide the details  the semantics gives us a way of tackling
the problem of confirming plan validity  something that becomes an important issue
in the face of concurrent activity  in section    we describe the process by which plans
were validated in the competition and discuss the complexity of the validation question
for pddl     finally  section    describes some related work in the temporal reasoning
community  in order to put the contributions made by pddl    into a wider context  a full
bnf description of pddl    can be found in the appendix 
pddl    was developed for use in the third international planning competition in which
competing planners demonstrated that many discretized temporal and metric models can
now be efficiently handled by both domain independent planners and those using handtailored control rules  for ease of reference in the competition we identified the features of
pddl    with a series of levels of increasing expressive power  thus  the strips fragment of
pddl    was referred to as level    the numeric extensions comprised level    the addition
of discretised durative actions resulted in level    continuous durative actions resulted in
level   and a final level  level    comprised all of the extensions of pddl    and additional
components to support the modelling of spontaneous events and physical processes  level  
is not discussed in this paper but details can be found in earlier work by fox and long        
the competition focussed on the use of levels      and   and did not use levels   or   because
the planning technology was not at that stage sufficiently advanced to handle the additional
complexities  despite the fact that level   was not used in the competition we devote some
discussion to it in this paper  we feel that level   presents some important immediate
challenges for the planning community that affect the extent to which planning can be
applied to real problems 
the purpose of this paper is to provide an overview of the new features introduced
in pddl     discuss the rationale for our language choices and explain some of the issues that have arisen in trying to extend pddl  although we have provided the bnf
for pddl    as an appendix  this paper is not intended to be either a language manual or a tutorial on the use of the language  for examples of the use of the language
and other relevant materials  readers should consult archived resources currently held at
http   www dur ac uk d p long competition html 
  

fifox   long

   pddl background
pddl is an action centred language  inspired by the well known strips formulations of
planning problems  at its core is a simple standardisation of the syntax for expressing this
familiar semantics of actions  using pre  and post conditions to describe the applicability
and effects of actions  the syntax is inspired by lisp  so much of the structure of a domain
description is a lisp like list of parenthesised expressions  an early design decision in
the language was to separate the descriptions of parameterised actions that characterise
domain behaviours from the description of specific objects  initial conditions and goals that
characterise a problem instance  thus  a planning problem is created by the pairing of
a domain description with a problem description  the same domain description can be
paired with many different problem descriptions to yield different planning problems in
the same domain  the parameterisation of actions depends on the use of variables that
stand for terms of the problem instance  they are instantiated to objects from a specific
problem instance when an action is grounded for application  the pre  and post conditions
of actions are expressed as logical propositions constructed from predicates and argument
terms  objects from a problem instance  and logical connectives 
although the core of pddl is a strips formalism  the language extends beyond that 
the extended expressive power includes the ability to express a type structure for the objects
in a domain  typing the parameters that appear in actions and constraining the types of
arguments to predicates  actions with negative preconditions and conditional effects and
the use of quantification in expressing both pre  and post conditions  these extensions are
essentially those proposed as adl  pednault        
although the original definition of the pddl syntax was not accompanied by a formal semantics  the language was really a proposal for a standard syntax for a commonly accepted
semantics and there was little scope for disagreement about the meaning of the language
constructs  two parts of the original language proposal for which this claim fails are an
attempt to offer a standard syntax for describing hierarchical domain descriptions  suitable
for htn planners and the subset of the language concerned with expressing numeric valued
fluents  the former was an ambitious project to construct a syntax in which the entire structure of domains using hierarchical action decompositions could be expressed  in contrast to
strips based planning  the differences between planners using hierarchical decomposition
appear to be deeper  with domain descriptions often containing structures that go beyond
the description of domain behaviours  for example  shop  nau  cao  lotem    munozavila        often uses mechanisms that represent goal agendas and other solution oriented
structures in a domain encoding   this diversity undermined the efforts at standardisation
in hierarchical domain descriptions and this part of the language has never been successfully
explored 
the syntax proposed for expressing numeric valued fluents was not tested in the first
use of the language  in the      competition  and  indeed  it underwent revision in the early
development of the language  the second competition in      also avoided use of numericvalued fluents  so a general agreement about the syntax and semantics of the numericexpressivity of the language remained unnecessary  mcdermotts original pddl provides
support for numbers by allowing numeric quantities to be assigned and updated  the syntax
of numeric valued fluents changed between the pddl manuals     and      mcdermott  
  

fipddl     expressing temporal planning domains

 define  domain jug pouring 
  requirements  typing  fluents 
  types jug 
  functors
 amount  j  jug 
 capacity  j  jug 
   fluent number  
  action empty
 parameters   jug   jug    jug 
 precondition  fluent test
        capacity  jug    amount  jug   
 amount  jug    
 effect  and  change  amount  jug     
 change  amount  jug  
    amount  jug    amount  jug      
 

figure    pouring water between jugs as described in the ai magazine article  mcdermott 
      

the aips    planning competition committee        and the later ai magazine article
on pddl  mcdermott         mcdermott presented a version of numeric fluents used in
pddl in the article in ai magazine        which could be taken as a definitive statement of
the syntax  an example using numeric fluents  presented by mcdermott         is shown
in figure    this action models an action from the well known jugs and water problem 
allowing the water in one jug to be emptied into a second jug provided that the space in
the second jug is large enough to hold the water in the first  the effect is a discrete update
of the values of the current contents of the jugs by an assignment  denoted here by the
change token  
even without the numeric extensions  pddl is an expressive language  capable of capturing a wide variety of interesting and challenging behaviours  figure   illustrates how
pddl can be used to capture a domain in which a vehicle can move between locations 
consuming fuel as it does so 
it can be seen in the example that pddl includes a syntactic representation of the level
of expressivity required in particular domain descriptions through the use of requirements
flags  this gives the opportunity for a planning system to gracefully reject attempts to
plan with domains that make use of more advanced features of the language than the
planner can handle  syntax checking tools can be used to confirm that the requirements
flags are correctly set for a domain and that the types and other features of the language
are correctly employed  an example of a problem description to accompany the vehicle
domain is shown in figure    the example illustrates that the description of an initial
state requires an exhaustive listing of all the  atomic  propositions that hold  symmetric or
transitive relations must be modelled by exhaustive and explicit listing of the propositions
that hold  the use of domain axioms to simplify the description of domains that use such
relationships has been considered  but remains an untested part of pddl and therefore
  

fifox   long

 define  domain vehicle 
  requirements  strips  typing 
  types vehicle location fuel level 
  predicates  at  v   vehicle  p   location 
 fuel  v   vehicle  f   fuel level 
 accessible  v   vehicle  p   p    location 
 next  f   f    fuel level  
  action drive
 parameters   v   vehicle  from  to   location
 fbefore  fafter   fuel level 
 precondition  and  at  v  from 
 accessible  v  from  to 
 fuel  v  fbefore 
 next  fbefore  fafter  
 effect  and  not  at  v  from  
 at  v  to 
 not  fuel  v  fbefore  
 fuel  v  fafter  
 
 

figure    a domain description in pddl 
an unstable part of the syntax  pddl domains are not case sensitive  which is somewhat
anachronistic in the light of standard practice in modern programming languages 
in the following sections we review the extensions made to pddl in its development into
pddl     the version of the language used in the third international planning competition 

   numeric expressions  conditions and effects
one of the first decisions we made in the development of pddl    was to propose a definitive
syntax for the expression of numeric fluents  we based our syntax on the version described
in the ai magazine article  mcdermott         with some minor revisions  discussed below  
numeric expressions are constructed  using arithmetic operators  from primitive numeric
expressions  which are values associated with tuples of domain objects by domain functions  using our proposed syntax for expressing numeric assignments and updates we can
express the jug pouring operator originally described in the pddl    manual and in the ai
magazine article  see figure     in pddl     as presented in figure    in this example the
functions capacity and amount associate the jug objects with numeric values corresponding to their capacity and current contents respectively  as can be seen in the example 
we have used a prefix syntax for all arithmetic operators  including comparison predicates 
in order to simplify parsing  conditions on numeric expressions are always comparisons
between pairs of numeric expressions  effects can make use of a selection of assignment
operations in order to update the values of primitive numeric expressions  these include
direct assignment and relative assignments  such as increase and decrease   numbers
are not distinguished in their possible roles  so values can represent  for example  quantities
of resources  accumulating utility  indices or counters 
  

fipddl     expressing temporal planning domains

 define  problem vehicle example 
  domain vehicle 
  objects
truck car   vehicle
full half empty   fuel level
paris berlin rome madrid   location 
  init
 at truck rome 
 at car paris 
 fuel truck half 
 fuel car full 
 next full half 
 next half empty 
 accessible car paris berlin 
 accessible car berlin rome 
 accessible car rome madrid 
 acessible truck rome paris 
 accessible truck rome berlin 
 accessible truck berlin paris 
 
  goal  and  at truck paris 
 at car rome  
 
 

figure    a problem instance associated with the vehicle domain 

 define  domain jug pouring 
  requirements  typing  fluents 
  types jug 
  functions
 amount  j   jug 
 capacity  j   jug  
  action pour
 parameters   jug   jug    jug 
 precondition         capacity  jug    amount  jug     amount  jug   
 effect  and  assign  amount  jug     
 increase  amount  jug    amount  jug    
 

figure    pouring water between jugs  pddl    style 

  

fifox   long

the differences between the pddl    syntax and the ai magazine syntax are in the
declaration of the functions and in the use of assign instead of change  we decided
to only allow numeric valued functions  making the declaration of function return types
superfluous  we therefore simplified the language by requiring only the declaration of the
function names and argument types  as is required for predicates  we felt that change was
ambiguous when used alongside the operations increase and decrease and that assign
would be clearer 
numeric expressions are not allowed to appear as terms in the language  that is  as
arguments to predicates or values of action parameters   there are two justifications for
this decision  a philosophical one and a pragmatic one  philosophically we take the
view that there are only a finite number of objects in the world  numbers do not exist as
unique and independent objects in the world  but only as values of attributes of objects 
our models are object oriented in the sense that all actions can be seen as methods that
apply to the objects given as their parameters  the object oriented view does not directly
inform the syntax of our representations  but is reflected in the way in which numbers are
manipulated only through their relationships with the objects that are identified and named
in the initial state  pragmatically  many current planning approaches rely on being able
to instantiate action schemas prior to planning  and this is only feasible if there is a finite
number of action instances  the branching of the planners search space  at choice points
corresponding to action selection  is therefore always over finite ranges  the use of numeric
fluent variables conflicts with this because they could occur as arguments to any predicate
and would not define finite ranges 
our decision not to allow numbers to be used as arguments to actions rules out some
actions that might seem intuitively reasonable  for example  an action to fly at a certain
altitude might be expected to take the altitude as a number valued argument  this is only
possible in pddl    if the range of numbers that can be used is finite  from a practical
point of view we think that this is unlikely to be an arduous constraint and that the benefits
of keeping the logical state space finite compensates for any modelling awkwardness that
results 
functions in pddl    are restricted to be of type objectn  r  for the  finite  collection of objects in a planning instance  object and finite function arity n  later extensions
of pddl might introduce functions of type objectn  object  allowing object to be extended by the application of functions to other objects  the advantage of this would be
to allow objects to be referred to by their relationships to known objects   for example 
 ontopof  x  could be used to refer to the object currently on top of an object instantiating  x   unfortunately  such functions present various semantic problems  in particular 
the interpretation of quantified preconditions becomes significantly harder  since the collection of objects is no longer necessarily finite  so extensional interpretations are not possible 
a further difficulty is the identity problem  as objects are manipulated by actions  the
functional expressions that refer to them are also affected  but implicitly  for example  as
objects are moved   ontopof a  can change without any action manipulating it explicitly 
managing the way in which functional terms map to specific objects in the domain  which
might or might not have specific names of their own  appears to introduce considerable
complication into the semantics  we believe that it is important to avoid extending pddl
with elements that are still poorly understood 
  

fipddl     expressing temporal planning domains

   plan metrics
the adoption of a stable numeric extension to the pddl core allowed us to introduce a
further extension into pddl     namely a new  optional  field within the specification of
problems  a plan metric  plan metrics specify  for the benefit of the planner  the basis
on which a plan will be evaluated for a particular problem  the same initial and goal
states might yield entirely different optimal plans given different plan metrics  of course 
a planner might not choose to use the metric to guide its development of a solution but
just to evaluate a solution post hoc  this approach might lead to sub optimal  and possibly
even poor quality plans  but it is a pragmatic approach to the handling of metrics which
was quite widely used in the competition  this issue is discussed further in the companion
paper analysing the results of the  rd ipc in this issue  long   fox      b  
the value total time can be used to refer to the temporal span of the entire plan 
other values must all be built from primitive numeric expressions defined within a domain
and manipulated by the actions of the domain  as a consequence  plan metrics can only
express non temporal metrics in pddl    domains using numeric expressions  any arithmetic expression can be used in the specification of a metric  there is no requirement
that the expression be linear  it is the domain designers responsibility to ensure that plan
metrics are well defined  for example  do not involve divisions by zero   an example of use
of a plan metric is shown in figure   
the implications of having introduced this extension are far reaching and have already
helped to demonstrate some important new challenges for planning systems  particularly
fully automated systems  an enriched descriptive power for the evaluation of plans is a
crucial extension for the practical use of planners  since it is almost never the case that real
plans are evaluated solely by the number of actions they contain 
metrics are described in the problem description  allowing a modeller to easily explore
the effect of different metrics in the construction of solutions to problems for the same
domain  in order to define a metric in terms of a specific quantity it is necessary to
instrument that quantity in the domain description  for example  if the metric is defined in
terms of overall fuel use a fuel use quantity can be initialised to zero in the initial state and
then updated every time fuel is consumed  in the domain shown in figure   it is possible
to minimise a linear combination of fuel used by each of the vehicles such as 
  metric minimize          fuel used car    fuel used truck   

however it is not possible to minimise distance covered since distance is not instrumented  it
would be straightforward to instrument it if desired  simply by adding the appropriate initial
value and incrementing effects to the domain description  since actions cause quantities to
change  instrumenting a value requires modification of the domain description itself  not
just a problem file 
the use of plan metrics is subtle and can have dramatic impact on the plans being
sought  perhaps the simplest case is where all actions increase a metric that must be
minimised  or decrease one that must be maximised  this is the case in the example shown
in figure    where any use of the drive action can only worsen the value of the plan metric
 whether we use the metric shown in the figure or the maximising metric described in the
last paragraph   this situation might appear to be relatively straightforward  a planner
  

fifox   long

 define  domain metricvehicle 
  requirements  strips  typing  fluents 
  types vehicle location 
  predicates  at  v   vehicle  p   location 
 accessible  v   vehicle  p   p    location  
  functions  fuel level  v   vehicle 
 fuel used  v   vehicle 
 fuel required  p   p    location 
 total fuel used  
  action drive
 parameters   v   vehicle  from  to   location 
 precondition  and  at  v  from 
 accessible  v  from  to 
     fuel level  v   fuel required  from  to   
 effect  and  not  at  v  from  
 at  v  to 
 decrease  fuel level  v   fuel required  from  to  
 increase  total fuel used   fuel required  from  to  
 increase  fuel used  v   fuel required  from  to   
 
 
 define  problem metricvehicle example 
  domain metricvehicle 
  objects
truck car   vehicle
paris berlin rome madrid   location 
  init
 at truck rome 
 at car paris 
    fuel level truck      
    fuel level car      
 accessible car paris berlin 
 accessible car berlin rome 
 accessible car rome madrid 
 accessible truck rome paris 
 accessible truck rome berlin 
 accessible truck berlin paris 
    fuel required paris berlin     
    fuel required berlin rome     
    fuel required rome madrid     
    fuel required rome paris     
    fuel required rome berlin     
    fuel required berlin paris     
    total fuel used    
    fuel used car    
    fuel used truck    
 
  goal  and  at truck paris 
 at car rome  
 
  metric minimize  total fuel used  
 

figure    an example of a domain and problem instance describing a plan metric 
  

fipddl     expressing temporal planning domains

must attempt to use as few actions to solve a problem as possible  in fact  even this case
is a little more complex than it appears  there can be rival plans in which one uses
more actions but has lower overall cost than the other  a more complex case arises when
some actions improve the quality metric while others degrade it  for example  if we use the
maximising metric but also add a refuel action to the domain then driving will degrade plan
quality  by reducing the fuel level of a vehicle  but refuelling will improve plan quality  by
increasing the fuel level of a vehicle   in this case  a planner can attempt to use actions to
improve the plan quality without those actions actually contributing to achieving the goals 
for example  refuelling might not be necessary to get the vehicles to their destinations 
but adding refuelling actions would improve the quality of a solution  this process could
involve trading off finite and irreplaceable resources for the increased value of the plan 
this would be the case if  for example  refuelling a vehicle took fuel from a finite reservoir 
alternatively a domain could allow plans of arbitrarily high value to be constructed by
using more and more actions  this would occur in the metric vehicles domain using the
maximising vehicles fuel level metric if refuelling were not constrained  since the domain
does not impose a limit on the fuel capacities of the vehicles 
the case in which plans are constrained by finite availability of resources  is an important
and interesting form of the planning problem  but the case in which plans of arbitrarily
high utility can be constructed  is obviously an ill defined problem  since an optimal plan
does not exist  it is non trivial to determine whether a planning problem provided with a
metric is ill defined  in fact  as helmert shows  helmert         the introduction of numeric
expressions  even in the constrained way that we have adopted in pddl     makes the
planning problem undecidable  the problem of finding a collection of actions which does
not consume irreplaceable resources and has an overall beneficial impact on a plan metric
is at least as hard as the planning problem  therefore it is clear that determining whether
a planning problem is even well defined is undecidable  this does not make it worthless to
consider planning with metrics  of course  but it demonstrates that the modelling problem 
as well as the planning problem  becomes even more complex when metrics are introduced 
one strategy available to planners working with problems subject to plan metrics is to
ignore the metric and simply produce a plan to satisfy the logical goals that a problem
specifies  in this case  the plan quality will simply be the value  according to the metric  of
the plan that happens to be constructed  this strategy is unsophisticated and it is obviously
better for a planner to construct a plan guided by the specified metric  how best to use a
metric to expedite the search process in a fully automated planner is still a research issue 

   durative actions
most recent work on temporal planning  smith   weld        bacchus   kabanza       
do   kambhampati        has been based on various forms of durative action  in order
to facilitate participation in the competition we therefore developed two forms of durative
action allowing the specification only of restricted forms of timed conditions and effects
in their description  although constrained in certain ways  these durative actions are 
nevertheless  more expressive than many of the proposals previously explored  particularly
in the way that they allow concurrency to be exploited  the two forms are discretised
durative actions and continuous durative actions 
  

fifox   long

  durative action load truck
 parameters   t   truck 
  l   location 
  o   cargo 
  c   crane 
 duration     duration   
 condition  and  at start  at  t  l  
 at start  at  o  l  
 at start  empty  c 
 over all  at  t  l  
 at end  holding  c  o  
 effect  and  at end  in  o  t  
 at start  holding  c  o  
 at start  not  at  o  l   
 at end  not  holding  c  o   
 

figure    a durative action for loading a truck  we assume no capacity constraints 

both forms rely on a basic durative action structure consisting of the logical changes
caused by application of the action  we always consider logical change to be instantaneous 
therefore the continuous aspects of a continuous durative action refer only to how numeric
values change over the interval of the action  figure   depicts a basic durative action 
load truck  in which there is no numeric change 
the modelling of temporal relationships in a discretised durative action is done by means
of temporally annotated conditions and effects  all conditions and effects of durative actions
must be temporally annotated  the annotation of a condition makes explicit whether the
associated proposition must hold at the start of the interval  the point at which the action
is applied   the end of the interval  the point at which the final effects of the action are
asserted  or over the interval from the start to the end  invariant over the duration of the
action   the annotation of an effect makes explicit whether the effect is immediate  it
happens at the start of the interval  or delayed  it happens at the end of the interval   no
other time points are accessible  so all discrete activity takes place at the identified start
and end points of the actions in the plan 
invariant conditions in a durative action are required to hold over an interval that is
open at both ends  starting and ending at the end points of the action   these are expressed
using the over all construct seen in figures   and    if one wants to specify that a fact p
holds in the closed interval over the duration of a durative action  then three conditions are
required   at start p    over all p  and  at end p  
we considered adopting the convention that over all constraints should apply to the
start and end points as well as the open interval inside the durative action  but decided
against this because it would then be impossible to express conditions that are actually
only required to hold over this open interval  examples of actions in which conditions are
invariant only over the open interval include the action of loading a truck  the truck must
remain at the loading location throughout the loading interval  but it can start to move
away simultaneously with the loading being completed  the reason is that the start of the
  

fipddl     expressing temporal planning domains

drive action is non mutex with the end of the load so there is a reasonable interpretation of
any plan in which driving starts at the instant that loading is completed  actions that affect
an invariant condition  such as the location of the truck  can be executed simultaneously
with the end point of a durative action only if the invariant is not constrained to hold true
at the end point itself  this highlights an important difference between  over all  and  over
all and at end   if a condition is required as an end precondition as well as an invariant
condition the meaning is that any action that affects the invariant must start after the end
of the action requiring that invariant  for example  if we make  at truck location  an end
precondition of the load operator as well as an invariant  the consequence is that the truck
cannot drive away until after the instant at which the load has completed 
note that  in our definition of the load truck action in figure    we have chosen to make
the condition  holding  c  o  be a start effect and an end precondition but not an invariant
condition  this means that the crane could temporarily cease to hold the cargo at some
time during the interval  as long as it is holding the cargo in time to deposit it at the end
of the loading interval  this makes the action quite flexible  enabling the exploitation of
concurrent uses of the crane where applicable 
the load truck example shows how logical change can be wrapped up into durative
actions that encapsulate much of the detail involved in achieving an effect by a sequence
of connected activities  naturally it would be useful to be able to combine such actions
concurrently within a plan  in the next section we consider the extent to which concurrency
is allowed and the ways in which concurrent plans are interpreted 
    the interpretation of concurrent plans
when time is introduced into the modelling of a domain it is possible for concurrent activity
to occur in a plan  prior to the introduction of time into pddl all plans were interpreted
as sequential  even graphplan concurrent plans were sequenced before being validated 
so concurrency was never an issue  in pddl    plan validity can depend on exploiting
concurrency correctly  actions can overlap and co occur  giving rise to questions over
the interpretation of synchronous behaviour  we discuss the problems arising in precise
synchronization in section     we now explain under what constraints actions can occur
concurrently within a plan involving durative actions and numeric conditions and effects 
the key difference  between durative actions in pddl    and those used by planners prior
to the competition  is that we distinguish between the conditions and effects at the start
and end points of the durative interval and the invariant conditions that might be specified
to hold over the interval  that is  actions can have pre  and postconditions that are local
to the two end points of the action  and a planner can choose to exploit a durative action
for effects it has at its start or at its end  conditions that are invariant are distinguished
from pre conditions  enabling the exploitation of a higher degree of concurrency than is
possible if preconditions are not distinguished from invariants  as in tgp  smith   weld 
       tpsys  garrido  onainda    barber        and tp   haslum   geffner        
we discuss the consequences of these design decisions  together with several examples of
durative actions  in the following sections 
it is important to observe that our view of time is point based rather than interval based 
that is  we see a period of activity in terms of intervals of state separated by time points
  

fifox   long

at which state changing activities occur  all logical state change occurs instantaneously  at
the start or end point of a durative action  propositions are true over half open intervals
that are closed on the left and open on the right  activities might change logical state
or they might update the values of numeric variables  in the discretised view of time we
allow for only a finite number of activities  which we call happenings  between any two time
points  although time itself is considered continuous and actions can be scheduled to begin
at any time point 
for a plan to be considered valid  no logical condition can be both asserted and negated
at the same instant  we impose the further constraint that no logical condition can both
be required to hold and be asserted at the same instant  although this might seem overly
strong we claim that a plan cannot be guaranteed to be valid if the instant at which a
proposition is required is exactly the instant at which it is asserted  we require that  for an
action with precondition p to start at time t  there must be a half open interval immediately
preceding t in which p holds  this is mathematically inconsistent with p being asserted
at the instant at which it is required  we are conservative in our view of the validity of
simultaneous update of and access to a state proposition  for example  if we have two
instantaneous actions  a and b  where a has precondition p and effects  not p   and q 
while b has precondition p  q and effect r  we consider that an attempt to apply a and
b simultaneously in a state in which p holds is ill defined  the reason is that  although
a switches the state from one in which p holds into one in which q holds so one might
suppose the precondition of b to be secure  a is an abstraction of a model in which the
values of p and q are changing and  we argue  any reliance on their values at this point of
change is unstable  we adopt a rule we call no moving targets  by which we mean that no
two actions can simultaneously make use of a value if one of the two is accessing the value
to update it  the value is a moving target for the other action to access  this rule creates
a behaviour for propositions in a planning state that is very much like the behaviour of
variables in shared memory protected by a mutex lock  such as those in posix threads  
with a difference between read and write access to the variable 
validity also requires that no numeric value be accessed and updated simultaneously at
the start or end point of a durative action  in the case of discretised durative actions  all
numeric change is modelled in terms of step functions so numeric values can be accessed 
or updated  during the interval of another durative action acting on that value  we provide
examples in the following section  provided that any updates are consistent with all invariant
properties dependent on the value  in the case of continuous durative actions  values can
be simultaneously accessed and updated during the continuous process of change occurring
in the interval of an action  in both the discretised and continuous cases we allow multiple
simultaneous updates provided the update operations are commutative 
in order to implement the mutual exclusion relation we require non zero separation
between mutually exclusive action end points  in our view  when end points are nonconflicting they can be treated as though it is possible to execute them simultaneously
even though precise synchronicity cannot be achieved in the world  however  when end
points are mutually exclusive the planner should buffer the co occurrence of these points
by explicitly separating them  in this way we ensure that the concurrency in the plan is at
least plausible in the world 
  

fipddl     expressing temporal planning domains

  durative action heat water
 parameters   p   pan 
 duration     duration            temperature  p    heat rate   
 condition  and  at start  full  p  
 at start  onheatsource  p  
 at start  bypan  
 over all  full  p  
 over all  onheatsource  p  
 over all  heating  p  
 at end  bypan   
 effect  and
 at start  heating  p  
 at end  not  heating  p   
 at end  assign  temperature  p        
 

figure    a simple durative action for boiling a pan of water 

planners can exploit considerable concurrency in a domain by ensuring only that conflicting start and end points of actions are separated by a non zero amount  a detailed
specification of the mutual exclusion relation of pddl    is given in section    we further
discuss the implications of non zero separation in section    
    numeric change within discretised durative actions
this section explains how continuous change can sometimes be modelled in pddl    using
durative actions with discrete effects  this is achieved by using step functions to describe
instantaneous changes at the beginnings or ends of the durations of actions  appendix a
details the language constructs involved 
an example of a durative action  illustrating the use of numeric update operations  is
shown in figure    in this example showing a water heating action  the conditions  full  p 
and  onheatsource  p  must hold at the start of the interval as well as during the interval 
to model this we enter these conditions as both at start and over all constraints  the
action achieves as its start effect that the water is heating  and this condition is maintained
invariant over the whole interval of the action  this is an example of an operator that
achieves its own invariant condition  and draws attention to the fact that over all conditions
hold over an interval that is open on the left  as well as on the right  
it should be noted that the actions in figures   and   use fixed duration specifications 
in the case of the water boiling example this means that it is impossible to adjust the length
of time over which the pan is heated and this has an impact on the context in which the
action can be used  in particular  when an assign construct is used to update a numeric
value  it is not possible for concurrent activity to affect the same value or else the model
will be flawed  because the water heating example uses an assign construct no concurrent
activity should affect the temperature of the water  it is the responsibility of the modeller
to ensure that the temperature is neither accessed nor updated during the interval over
which the action is executing 
  

fifox   long

  durative action navigate
 parameters   x   rover  y   waypoint  z   waypoint 
 duration     duration  travel time  y  z  
 condition  and  at start  available  x  
 at start  at  x  y  
 at start      energy  x 
    travel time  y  z   use rate  x    
 over all  visible  y  z  
 over all  can traverse  x  y  z   
 effect  and  at start  decrease  energy  x 
    travel time  y  z   use rate  x    
 at start  not  at  x  y   
 at end  at  x  z    
  durative action recharge
 parameters   x   rover  w   waypoint 
 duration     duration  recharge period  x  
 condition  and  at start  at  x  w  
 at start  in sun  w  
 at start      energy  x   capacity  x   
 over all  at  x  w   
 effect  at end  increase  energy  x      duration  recharge rate  x     

figure    discretised durative actions for a rover to move between locations and to recharge 

we decided to leave it to the modeller to ensure correct behaviour of the assign construct because we did not want to forbid the modelling of truly discontinuous updates  for
example  a durative action that models the deposit of a cheque in a bank account might
have a duration of three days  with a discontinuous update to the account balance at the
end of that interval  it would be inappropriate to prevent actions from accessing the
balance during the three day period  in general  modelling continuous change with discrete
effects is open to various pitfalls  this is the price that is paid for the convenience of not
having to specify the details of the continuous processes 
the use of discretised durative actions in combination with numeric  step function 
updates requires care in modelling  in particular  it relies on the notion of conservative
resource updating  the updating of resource levels is conservative if the consumption of
a resource is modelled as if it happens at the start of a durative action  even though it
actually happens continuously over the duration of the action  and production of a resource
is modelled as if it happens at the end of the durative action even though  again  it might
actually be produced continuously over the interval 
as an example of a discretised durative action  figure   shows how the action of a
rover navigating between two points is modelled  the local precondition of the start of
the period is that the rover be at the start location  local effects include that the rover
consumes an appropriate amount of energy and that it is at the destination  the first of
these is conservative and therefore immediate  while the second is a logical effect that occurs
at the end point  this organisation ensures that no parallel activities will consume energy
that has already been committed to the navigation activity  similarly  the recharge action
  

fipddl     expressing temporal planning domains

projected energy production
actual energy profile
initial energy

energy changing
by production and
consumption

step function model
of energy consumption
by dig action

final stage of digging action
final energy
step function model
of energy produced
by recharge action

zero energy
recharge action
dig action

figure    using discrete actions to model the production and consumption of a resource  in
reality  the recharge activity produces energy continuously and the concurrent dig
activity continuously consumes it  the conservative model using step functions
requires that the energy consumed by digging must be available at the start of
that action  despite not having yet updated the model to show the additional
energy accumulated because of the part of the recharge action so far executed 
the final energy level is consistent with having used a continuous model 

only makes new charge available at the conclusion of the action  so that charge gained
cannot be exploited until after the recharging is complete  the use of conservative updates
ensures that a model does not support invalid concurrency 
figure   illustrates how a recharging and a digging action  that consumes energy  would
interact under a conservative energy consumption model  this model would allow concurrent actions to consume energy provided they did not consume more energy than was left
under the conservative assumption that the dig action consumed all of its demands at
the start and the recharge action produced nothing until the end  note that the example
assumes energy constraints but no capacity constraint 
the use of conservative updates is subtle  if there were a capacity constraint on the
energy level of the rover then one would need to consider two separate resources  the energy
itself and the space available for storage of energy  the dig action would consume energy at
the start and only produce space at the end  while the recharge action would consume space
at the start and produce charge at the end  using this combination it would be possible to
ensure that plans did not consume either resource before it was available 
durative actions can have conditional effects  the antecedents and consequents of a
conditional effect are temporally annotated so that it is possible to specify that the condition
be checked at start or at end  and that the effect be asserted at either of these points  the
  

fifox   long

  durativeaction burnmatch
 parameters   m  match  l  location 
 duration  and     duration        duration    
 condition  and  at start  have  m  
 at start  at  l   
 effect  and  when  at start  dark  l  
 and  at start  not  dark  l   
 at start  light  l    
 at start  not  have  m   
 at start  burning  m  
 at end  not  burning  m   
 when  at start  dark  l  
 and  at end  not  light  l   
 at end  dark  l      
actions

  action pickup
 parameters   l  location  o  object 
 precondition  and  at  l 
 onfloor  o  l 
 light  l  
 effect  and  not  onfloor  o  l  
 have  o   

initial state   onfloor coin   have amatch   at basement   dark basement 
goal   have coin 
problem
plan       burnmatch amatch basement       
     pickup basement coin 
pickup coin

start burnmatch
dark basement

end burnmatch
light basement

   

   

dark basement

   

plan

figure     an example of a problem with a durative action useful for its start effects  the
burning match produces the light necessary to pick up the coin 

semantics makes clear that a well formed durative action with conditional effects cannot
require the condition to be checked after the effect has been asserted  conditional effects
arise in all pddl    variants  we discuss how their occurrence in discretized durative actions
is interpreted in section     
pddl    allows the specification of duration inequalities enabling actions to be described
in which external factors can be involved in determining their temporal extent  in the
match burning example shown in figure    it can be seen that the effect at the start point
is the only one of interest  so a planner would exploit this action for its start rather than its
end effect  the duration inequality specifies that the match will burn for no longer than a
specified upper bound  the model shows that the match can be put out early if the planner
considers it appropriate  we discuss the use of duration inequalities further in section     
  

fipddl     expressing temporal planning domains

    durative actions with continuous effects
the objective of discrete durative actions is to abstract out continuous change and concentrate on the end points of the period over which change takes place  the syntax allows
precise specification of the discrete changes at the end points of durative actions  however 
when a plan needs to manage continuously changing values  as well as discretely changing
ones  the durative action language and semantics need to be more powerful  general durative actions can have continuous as well as discrete effects  these increase  or decrease 
some numeric variable according to a specified rate of change over time for that variable 
when determining how to achieve a goal a planner must be able to access the values of these
continuous quantities at arbitrary points on the time line of the plan  we use  t to refer
to the continuously changing time from the start of a durative action during its execution 
for example  to express the fact that the fuel level of a plane   p  decreases continuously 
as a function of the consumption rate of  p  we write 
 decrease  fuel level  p      t  consumption rate  p   

this is distinctly different from 
 at end  decrease

 fuel level  p 
    flight time  a  b   consumption rate  p    

because the latter is a single update happening at the end point of the flight action  whilst
the former allows the correct calculation of the fuel level of the plane at any point in that
interval  the former is a continuous effect  whilst the latter is a discrete one  continuous
effects are not temporally annotated because they can be evaluated at any time during the
interval of the action   t is local to each durative action  so that each durative action
has access to a purely local clock  another way to interpret the expression representing
continuous change is as a differential equation 
d
 fuel level  p     consumption rate  p 
dt
we chose to use the  t symbol instead of a differential equation because it is possible for two
concurrent actions to be simultaneously modifying the same quantity  in that case  the use
of differential equations would actually form an inconsistent pair of simultaneous equations 
rather than having the intended effect of a combined contribution to the changing value of
the quantity  although all of the expressions describing continuous change take the form of a
product of  t and some quantity  it is possible to express complex change using them with
interdependent concurrent effects  for example  acceleration arises by simply increasing
distance using a quantity describing velocity  while at the same time increasing velocity
using a quantity describing acceleration  when dependencies between the changing terms
include mutual dependencies between terms then the differential equations that arise can
lead to continuous change dictated by exponential  logarithmic and exponential functions 
a plan containing continuous durative actions can assign to  consult  and continuously
modify the same numeric variables concurrently  see example    
in figures    and    the discrete and continuous actions for heating a pan of water are
presented  this simple model ignores heat loss   the discrete action presented in figure   
modifies the version presented in figure   by the use of a duration inequality constraint 
  

fifox   long

example   in the flying and refuelling example shown in figure    it can be seen
that the invariant condition  that the fuel level be greater than  or equal to  zero
during the flight  has to be maintained whilst the fuel is continuously decreasing  this
could be expressed with discrete durative actions by abstracting out the continuous
decrease and making the final value available at the end point of the flight  however 
if a refuel operation happens during the flight time  in mid air  then the fuel level
after the flight will need to be calculated by taking into account both the continuous
rate of consumption and the refuel operation  a discrete action could not calculate
the fuel level correctly because it would only have access to the distance between
the source and destination of the flight  together with the rate of consumption  to
determine the final fuel level  in order to calculate the fuel level correctly it is
necessary to determine the time at which the refuel takes place  and to use the
remaining flight time to calculate the fuel consumed  discrete durative actions do
not give access to time points other than their own start and end points 
discrete durative actions can be used to express the desired combinations of flying
and refuelling by providing additional durative actions  such as fly and refuel  that
encapsulate all of the interactions just described and end up calculating the fuel level
correctly  however  this approach requires more of the domain designer than it does
of the planner  the domain designer must anticipate every useful combination of
behaviours and ensure that appropriate encapsulations are provided 
in contrast with the discrete form  the continuous action  in which the fuel consumption effect is given in terms of  t  is powerful enough to express the fact that the
mid flight refuelling of the plane affects the final fuel level in a way consistent with
maintaining the invariant of the fly action 

  durative action fly
 parameters   p   airplane  a  b   airport 
 duration     duration  flight time  a  b  
 condition  and  at start  at  p  a  
 over all  inflight  p  
 over all      fuel level  p      
 effect  and  at start  not  at  p  a   
 at start  inflight  p  
 at end  not  inflight  p   
 at end  at  p  b  
 decrease  fuel level  p 
    t  fuel consumption rate  p     
  action midair refuel
 parameters   p 
 precondition  inflight  p 
 effect  assign  fuel level  p   fuel capacity  p   

figure     a continuous durative action for flying 

  

fipddl     expressing temporal planning domains

  durative action heat water
 parameters   p   pan 
 duration  at end      duration            temperature  p  
 heat rate    
 condition  and  at start  full  p  
 at start  onheatsource  p  
 at start  bypan  
 over all  full  p  
 over all  onheatsource  p  
 over all  heating  p  
 at end  bypan   
 effect  and
 at start  heating  p  
 at end  not  heating  p   
 at end  increase  temperature  p 
    duration  heat rate     
 

figure     a discrete durative action for heating a pan of water  using a variable duration 

duration inequalities add significant expressive power over duration equalities  duration
constraints that express inequalities are associated with an additional requirements flag
because of the extended expressiveness over fixed duration discrete durative actions 
in both actions  the logical post condition of the start of the period is that the pan is
heating  the conditions that the pan be heating  full and on the heat source are invariant 
although the presence of the agent  by the pan  is only a local precondition of the two
end points and is not invariant  in the first action the duration is modelled by expressing
the following duration inequality constraint 
 at end      duration            temperature  p    heat rate    

and the effect at the end point of the discrete durative action is that the temperature
of the pan is increased by     duration  heat rate    where heat rate is a domain
constant   in the continuous action of figure    the duration constraint is unnecessary
since the invariant
 over all      temperature  p       

is added to ensure that the pan never exceeds boiling 
the durative action in figure    models the heating pan in the face of possible concurrent activities affecting the temperature  the duration inequality allows the planner to
adapt the duration to take account of other temperature affecting activity in a way that
is not possible when the duration is specified using an equality constraint  the duration
constraint ensures that the temperature never exceeds boiling by checking  as a precondition for the updating activity  that the computed temperature increase can be executed
without exceeding the boiling point  if this temperature increase would exceed boiling the
plan is invalid  the temperature at the end of the interval of execution is computed from
the current temperature and the heating rate  together with the duration over which the
heating action has been active  see further discussion in example    
  

fifox   long

example   if a plan attempts to further heat the pan  say by applying a blowtorch
to the pan   during the heat water interval then  provided that the concurrent action
ends before the end of the heat water action  the duration constraint will be seen
to have been violated if the duration has been chosen so that the overall increase
in temperature would exceed boiling  if the concurrent activity ends simultaneously
with the heat water action then the no moving targets rule would be violated because
the duration constraint would attempt to access the temperature at the same time
point as the concurrent action attempted to update it 
figure    depicts these two situations  in this figure  apply blowtorch is a durative
action that applies heat to an object  in this case  the pan   in part  a  of the figure
the duration constraint will be violated if the duration of the heat water action is
sufficient to cause the temperature to increase beyond boiling when combined with
the heat increase caused by the blowtorch  in that case that the plan will be invalid 
the planner can choose a value for duration that avoids this violation  in part  b 
the plan will be determined invalid regardless of the duration of the action because
of the no moving targets rule  notice that this model does not attempt to model the
consequences of continued heating of the pan after the boiling point  so plans with
actions that cause this to occur are simply invalid  however  pddl    can be used
to model more of the physical situation  so that the consequences are explicit and the
planner can choose to exploit them or avoid them accordingly 

 a 

 b 

heatwater

applyblowtorch

heatwater
check duration
constraint

applyblowtorch

increase temperature
of pan

simultaneous change to
and consultation of
temperature

figure     heating a pan with a discrete durative action  concurrently with another heating
activity 

  

fipddl     expressing temporal planning domains

  durative action heat water
 parameters   p   pan 
 duration   
 condition  and  at start  full  p  
 at start  onheatsource  p  
 at start  bypan  
 over all  full  p  
 over all  onheatsource  p  
 over all  heating  p  
 over all      temperature  p       
 at end  bypan   
 effect  and
 at start  heating  p  
 at end  not  heating  p   
 increase  temperature  p      t  heat rate    
 

figure     a continuous durative action for heating a pan of water 
the use of duration inequalities adds significant expressive power even when using discrete durative actions  for example  the plan depicted in part  a  of figure     which
illustrates the use of the water heating action shown in figure    while concurrently heating the pan with a blowtorch  will be considered valid provided that there is a duration
value that satisfies the duration constraint in the water heating action  this brings us very
close to the expressive power available with continuous durative actions because it gives
the planner the power to exploit concurrent interacting activities enacting changes on the
same numeric valued variable  see example     attempting to express continuous change
using only duration inequalities does not give precisely equivalent behaviour  because the
discretisation forces actions that access changing numeric values to be separated  by some
small temporal interval  from the actions that change those values in order to resolve their
mutual exclusion  in a continuous model this is not necessary because the true value of a
numeric variable is available for consultation at any time during the continuous process of
change 
in the discrete semantics presented in section   we exploit the fact that the only changes
that can occur when a plan is executed are at points corresponding to the times of happenings  so the plan can be checked by looking at the activity focussed in this finite happening
sequence  in fact  provided continuous effects are restricted to linear functions of time
with only first order effects  which requires that no continuous effects can affect numeric
expressions contributing to the rate of change of another numeric valued variable   and invariants are restricted to linear functions of changing quantities  it is still possible to restrict
attention to the happening sequence even when using continuous actions 
non linear effects and higher order rates of change create difficulties since it is possible
for an invariant to be satisfied at the end points of an interval  without having necessarily
been satisfied throughout the interval  in these cases it is no longer sufficient to insert
invariant checking actions at fixed mid points in the happening sequence of a plan in order
to validate its behaviour  however  provided that effects are first order and linear  and
invariants are linear in continuously changing values  then  despite the fact that arbitrary
  

fifox   long

example   it is possible with discrete durative actions  with duration inequalities 
to model the effects of adding an egg to the heating water when the water is at  say 
   degrees  we do this by applying two heat water actions  around an add egg action  in such a way that the overall duration of the two heat water actions is exactly
the duration required to boil the water from its original temperature  however  the
way the heat water action is currently modelled means that the heat will be turned
off before the egg is added  and then turned on again to complete the heating  since
the temperature is only updated when the durative action terminates  with continuous durative actions the egg can be added whilst the single heat water action is in
progress since the temperature of the pan is continuously updated  so  discrete durative actions with duration inequalities allow us to approximate continuous activity
by appending a finite sequence of discrete intervals in an appropriate way  the no
moving targets rule means that the end points of these intervals will be separated by
non zero  arbitrarily small  time gaps  this is not required when using continuous
actions because  in contrast to the step function effects of discrete actions  continuous effects are not localised at a single point 

time points within action intervals are accessible to the planner  it is only necessary to gain
access to numeric values at the start  and end points of the actions in the plan that refer
to them  together with finitely many mid points for invariant checking actions  the values
are not required at all other points  this is so because continuous durative actions do not
support the modelling of exogenous events  so it is not necessary to take into account the
exogenous activity of the environment in determining the validity of a plan 
    related approaches
time is an important numerically varying quantity  the simplest way to reason about time
is to adopt a black box durative action model in which change happens at the ends of their
durative intervals  this is the approach taken in the language used by tgp  smith  
weld         for example  in which durative actions encapsulate continuous change so that
the correct values of any affected variables are guaranteed only at the end points of the
implied intervals  all of the logical and numeric effects of a durative action are enacted at
the end of the action and are undefined during the interval of its execution  all undeleted
preconditions must remain true throughout the interval  there is no syntactic distinction
between preconditions and invariant conditions in this action representation  a simplistic
way of ensuring correct action application is to prevent concurrent actions that refer to the
same facts  but this excludes many intuitively valid plans 
a more sophisticated approach allows preconditions to be annotated with time points 
or intervals  so that the requirement that a condition be true at some point  or over some
interval  within the duration of the action can be expressed  this is the approach taken in
sapa  do   kambhampati         for example  using such an annotated precondition it
would be possible to express the requirement that some chemical additive be added within
two minutes of the start of a tank filling action  if effects can also be specified to occur at
arbitrary points within the duration of the action then it is possible to express effects that
  

fipddl     expressing temporal planning domains

occur before the end of the specified duration  it is also possible to distinguish between
conditions that are local to specific points in the duration of the action and those that are
invariant throughout the action 
allowing reference to finitely many time points between the start and end of actions
makes the language more complex without adding to its expressive power  where time
points are strictly scheduled relative to the start of the action the effect can be achieved
through the use of a sequence of linked durative actions  we decided to keep pddl   
simple by restricting access to only the end points of actions 
in tlplan  bacchus   ady        a similar  but more constrained  approach is adopted
in which actions are applied instantaneously but can have delayed effects  the delays for
effects can be arbitrary and different for each effect  however  invariants cannot be specified
because the preconditions are checked at the instant of application and subsequent delayed
effects are separated from the action which initiated them 
several planners have been developed to use networks of temporal constraints  ghallab
  laruelle        jonsson  morris  muscettola    rajan        el kholy   richards       
to handle temporal structure in planning problems  efficient algorithms exist for handling
such constraints  dechter  meiri    pearl        which make them practical for managing
large networks  the domain models constructed using pddl    certainly lend themselves
to treatment by similar techniques  but are not constrained to be handled in this way 

   introduction to the semantics of pddl   
in sections   and   we provide a formal semantics for the numeric extension and temporal
extension of pddl     together these sections contain    definitions  the lengthy treatment
is necessary because the semantics we have developed adds four significant extensions over
classical planning and the semantics lifschitz developed for strips  lifschitz         these
are 
 the introduction of time  so that plans describe behaviour relative to a real time line 
 related to the first extension  the treatment of concurrency  actions can be executed
in parallel  which can lead to plans that contain concurrent interacting processes
 although these processes are encapsulated in durative actions in pddl     
 an extension to handle numeric valued fluents 
 the use of conditional effects  both alone and in conjunction with all of the above
extensions 
the semantics is built on a familiar state transition model  the requirements of the semantics can be reduced to four essential elements 
   to define what is a state  the introduction of both time and numeric values complicate
the usual definition of a state as a set of atoms 
   to define when a state satisfies a propositional formula representing a goal condition
or precondition of an action  an extension of the usual interpretation of a state as a
valuation in which an atom is true if and only if the atom is in the state  the closed
world assumption  is required in order to handle the numeric values in the state 
  

fifox   long

   to define the state transition induced by application of an action  the update rule
for the logical state must be supplemented with an explanation of the consequences
for the numeric part of the state 
   to define when two actions can be applied concurrently and how their concurrent
application affects the application of those actions individually 
the structure of the definitions is as follows  definitions   to     given in section   
define what it means for a plan to be valid when the plan consists of only non durative
actions  definitions   to   set up the basic terminology  the foundational structures and
the framework for handling conditional effects and primitive numeric expressions  definition   meets the first requirement identified above  defining states  definition   meets the
second requirement  defining when a goal description is satisfied in a state  definition   
defines a simple plan  extending the classical notion of a sequence of actions by adding
time  definitions    meets the fourth requirement  by defining when two actions cannot be
executed concurrently  definition    meets the third requirement  defining what we mean
by execution of actions  including concurrent execution of actions  definitions    and   
define the execution of a plan and what it means for a plan to be valid  given the basis laid
in the previous definitions 
in section   the semantics is extended to give meaning to durative actions  we begin
with definition     which defines ground durative actions analogously to definition   for
simple  that is  non durative  actions  similarly  definition    parallels the definition of a
simple plan  definition     and definitions    and    parallel those for the execution and
validity of simple plans  definitions    and      definition    is the critical definition for
the semantics of plans with durative actions  supplying a transformation of temporal plans
into simple plans  whose validity according to the semantics of purely simple plans  can be
used to determine the validity of the original temporally structured plans 

   the semantics of simple plans
the semantics we define in this section extends the essential core of lifschitz strips semantics        to handle temporally situated actions  possibly occurring simultaneously 
with numeric and conditional effects 
definition   simple planning instance a simple planning instance is defined to be a
pair
i    dom  p rob 
where dom    f s  rs  as  arity  is a   tuple consisting of  finite sets of   function symbols 
relation symbols  actions  non durative   and a function arity mapping all of these symbols
to their respective arities  p rob    os  init  g  is a triple consisting of the objects in the
domain  the initial state specification and the goal state specification 
the primitive numeric expressions of a planning instance  p n es  are the terms constructed from the function symbols of the domain applied to  an appropriate number of  
objects drawn from os  the dimension of the planning instance  dim  is the number of
distinct primitive numeric expressions that can be constructed in the instance 
  

fipddl     expressing temporal planning domains

the atoms of the planning instance  atms  are the  finitely many  expressions formed
by applying the relation symbols in rs to the objects in os  respecting arities  
init consists of two parts  initlogical is a set of literals formed from the atoms in atms 
initnumeric is a set of propositions asserting the initial values of a subset of the primitive
numeric expressions of the domain  these assertions each assign to a single primitive
numeric expression a constant real value  the goal condition is a proposition that can
include both atoms formed from the relation symbols and objects of the planning instance
and numeric propositions between primitive numeric expressions and numbers 
as is a collection of action schemas  non durative actions  each expressed in the syntax
of pddl  the primitive numeric expression schemas and atom schemas used in these action
schemas are formed from the function symbols and relation symbols  used with appropriate
arities  defined in the domain applied to objects in os and the schema variables 
the semantics shows how instantiated action schemas can be interpreted as state transitions  in a similar way to the familiar state transition semantics defined by lifschitz  an
important difference is that states can no longer be seen as simply sets of propositions  but
must also account for the numeric expressions appearing in the planning instance and the
time at which the state holds  this is achieved by extending the notion of state 
definition   logical states and states given the finite collection of atoms for a planning instance i  atmsi   a logical state is a subset of atmsi   for a planning instance
with dimension dim  a state is a tuple in  r  p atmsi    rdim
   where r   r     and
 denotes the undefined value  the first value is the time of the state  the second is the
logical state and the third value is the vector of the dim values of the dim primitive numeric
expressions in the planning instance 
the initial state for a planning instance is     initlogical   x  where x is the vector of values
in r corresponding to the initial assignments given by initnumeric  treating unspecified
values as   
undefined values are included in the numeric ranges because there are domains in which
some terms start undefined but can nevertheless be initialised and exploited by actions 
to interpret actions as state transition functions it is necessary to achieve two steps 
firstly  since  in pddl     plans are only ever constructed from fully instantiated action
schemas  the process by which instantiation affects the constructs of an action schema must
be defined and  secondly  the machinery that links primitive numeric expressions to elements
of the vector of real values in a state and that allows interpretation of the numeric updating
behaviours in action effects must be defined  since the mechanisms that support the second
of these steps also affect the process in the first  the treatment of numeric effects is described
first 
definition   assignment proposition the syntactic form of a numeric effect consists
of an assignment operator  assign  increase  decrease  scale up or scale down   one
primitive numeric expression  referred to as the lvalue  and a numeric expression  which
is an arithmetic expression whose terms are numbers and primitive numeric expressions  
referred to as the rvalue 
  

fifox   long

the assignment proposition corresponding to a numeric effect is formed by replacing
the assignment operator with its equivalent arithmetic operation  that is  increase p q 
becomes    p    p q   and so on  and then annotating the lvalue with a prime 
a numeric effect in which the assignment operator is either increase or decrease
is called an additive assignment effect  one in which the operator is either scale up or
scale down is called a scaling assignment effect and all others are called simple assignment
effects 
a numeric effect defines a function of the numeric values in the state to which an action
is applied determining the value of a primitive numeric expression in the resulting state 
for the convenience of a uniform treatment of numeric expressions appearing in pre  and
post conditions  we transform the functions into propositions that assert the equality of the
post condition value and the expression that is intended to define it  that is  rather than
writing an effect  increase p q  as a function f  p    p   q  we write it as the proposition
   p     p q    the priming distinguishes the postcondition value of a primitive numeric
expression from its precondition value  a convention commonly adopted in describing state
transition effects on numeric values   the binding of the primitive numeric expressions to
their values in states is defined in the following definition 
definition   normalisation let i be a planning instance of dimension dimi and let
indexi   p n esi              dim 
be an  instance dependent  correspondence between the primitive numeric expressions and
i
 
integer indices into the elements of a vector of dimi real values  rdim

the normalised form of a ground proposition  p  in i is defined to be the result of substituting for each primitive numeric expression f in p  the literal xindexi  f     the normalised
form of p will be referred to as n  p   numeric effects are normalised by first converting
them into assignment propositions  primed primitive numeric expressions are replaced with
their corresponding primed literals  x is used to represent the vector hx        xn i 
in definition    the replacement of primitive numeric expressions with indexed literals
allows convenient and consistent substitution of the vector of actual parameters for the
vector of literals x appearing in a state 
with the machinery supporting treatment of numeric expressions complete  it is now
possible to consider the process of instantiating action schemas  this process is managed
in two steps  the first step is to remove constructs that we treat as syntactic sugar in the
definition of a domain  these are conditional effects and quantified formulae  we handle
both of these by direct syntactic transformations of each action schema into a set of action
schemas considered to be equivalent  the transformation is similar to that described by
gazen and knoblock         although it would be possible to give a semantic interpretation
of the application of conditional effects directly  the transformation allows us to significantly
simplify the question of what actions can be performed concurrently 
definition   flattening actions given a planning instance  i  containing an action
schema a  asi   the set of action schemas f latten a   is defined to be the set s  initially
containing a and constructed as follows 
  

fipddl     expressing temporal planning domains

 while s contains an action schema  x  with a conditional effect   when p q   create
two new schemas which are copies of x  but without this conditional effect  and conjoin
the condition p to the precondition of one copy and q to the effects of that copy  and
conjoin  not p  to the precondition of the other copy  add the modified copies to s 
 while s contains an action schema  x  with a formula containing a quantifier  replace
x with a version in which the quantified formula   q   var        vark   p  in x is
replaced with the conjunction  if the quantifier  q  is forall  or disjunction  if q is
exists  of the propositions formed by substituting objects in i for each variable in
var        vark in p in all possible ways 
these steps are repeated until neither step is applicable 
once flattened  actions can be grounded by the usual substitution of objects for parameters 
definition   ground action given a planning instance  i  containing an action schema
a  asi   the set of ground actions for a  gaa   is defined to be the set of all the structures 
a  formed by substituting objects for each of the schema variables in each schema  x  in
f latten a  where the components of a are 
 name is the name from the action schema  x  together with the values substituted for
the parameters of x in forming a 
 prea   the precondition of a  is the propositional precondition of a  the set of ground
atoms that appear in prea is referred to as gprea  
 adda   the positive postcondition of a  is the set of ground atoms that are asserted as
positive literals in the effect of a 
 dela   the negative postcondition of a is the set of ground atoms that are asserted as
negative literals in the effect of a 
 npa   the numeric postcondition of a  is the set of all assignment propositions corresponding to the numeric effects of a 
the following sets of primitive numeric expressions are defined for each ground action 
a  gaa  
 la    f  f appears as an lvalue in a 
 ra    f  f is a primitive numeric expression in an rvalue in a or appears in p rea  
 la    f  f appears as an lvalue in an additive assignment effect in a 
some comment is appropriate on the last definition  an action precondition might be
considered to have two parts  its logical part and its numeric expression dependent part 
unfortunately  these can be interdependent  for example 
 or  clear  x       room in  y   space for  z   
  

fifox   long

might be a precondition of an action  in order to handle such conditions  we need to check
whether they are satisfied given not only the current logical state  but also the current
values of the domain numeric expressions  the inclusion of a numeric component in the
state makes it necessary to ensure the correct substitution of the numeric values for the
expressions used in the action precondition  this is achieved using the normalisation process
from definition   in definition    in contrast  the postcondition of an action cannot contain
interlocked numeric and logical effects  so it is possible to separate the effects into the
distinct numeric and logical components 
definition   valid ground action let a be a ground action  a is valid if no primitive
numeric expression appears as an lvalue in more than one simple assignment effect  or in
more than one different type of assignment effect 
definition   ensures that an action does not attempt inconsistent updates on a numeric
value  unlike logical effects of an action which cannot conflict  it is possible to write
a syntactic definition of an action in which the effects are inconsistent  for example by
assigning two different values to the same primitive numeric expression 
definition   updating function let a be a valid ground action  the updating function
for a is the composition of the set of functions 
dim
 npfp   rdim
  r   p  n p a  

such that npfp  x    x  where for each primitive numeric expression x i that does not appear
as an lvalue in n  p   x i   xi and n  p  x     x    x    x  is satisfied 
the notation n  p  x     x    x    x  should be read as the result of normalising p and
then substituting the vector of actual values x  for the parameters x  and actual values x
for formal parameters x 
definition   defines the function describing the update effects of an action  the function
ensures that all of the reals in the vector describing the numeric state remain unchanged if
they are not affected by the action  this is the numeric state equivalent of the persistence
achieved for propositions by the strips assumption   for other values in the vector  the
normalisation process is used to substitute the correctly indexed vector elements for the
primitive numeric expressions appearing as lvalues  which are the primed vector elements
corresponding to values in the post action state  and rvalues  the unprimed values appearing
in the pre action state   the tests that must be satisfied in order to ensure correct behaviour
of the functions in the composition simply confirm that the arithmetic on the rvalues is
correctly applied to arrive at the lvalues  the requirement that the action be valid ensures
that the composition of the functions in definition   is well defined  since all of the functions
in the set commute  so the composition can be carried out in any order 
the various sets of primitive numeric expressions defined in the definition   allow us
to conveniently express the conditions under which two concurrent actions might interfere
with one another  in particular  we are concerned not to allow concurrent assignment to the
same primitive numeric expression  or concurrent assignment and inspection  we do allow
concurrent increase or decrease of a primitive numeric expression  to allow this we will
  

fipddl     expressing temporal planning domains

have to apply collections of concurrent updating functions to the primitive numeric expressions  this can be allowed provided that the functions commute  additive assignments do
commute  but other updating operations cannot be guaranteed to do so  except if they do
not affect the same primitive numeric expressions or rely on primitive numeric expressions
that are affected by other concurrent assignment propositions  it would be possible to make
a similar exception for scaling effects  but additive assignment effects have a particularly
important role in durative actions that is not shared by scaling effects  so for simplicity
we allow concurrent updates only with these effects  we use the three sets of primitive
numeric expressions to determine whether we are in a safe situation or not  within a single
action it is possible for the rvalues and lvalues to intersect  that is  an action can update
primitive numeric expressions using current values of primitive numeric expressions that
are also updated by the same action  all rvalues will have the values they take in the state
prior to execution and all lvalues will supply the new values for the state that follows 
definition   satisfaction of propositions given a logical state  s  a ground propositional formula of pddl     p  defines a predicate on rdim
   num s  p   as follows 
num s  p  x 

iff

s    n  p  x    x 

where s    q means that q is true under the interpretation in which each atom  a  that is not
a numeric comparison  is assigned true iff a  s  each numeric comparison is interpreted
using standard equality and ordering for reals and logical connectives are given their usual
interpretations  p is satisfied in a state  t  s  x  if num s  p  x  
comparisons involving   including direct equality between two  values are all undefined  so that enclosing propositions are also undefined and not satisfied in any state 
definition    applicability of an action let a be a ground action  a is applicable in
a state s if the p rea is satisfied in s 
    semantics of a simple plan
a simple plan  in pddl     is a sequence of timed actions  where a timed action has the
following syntactic form 
t    action p        pn  
in this notation t is a positive rational number in floating point syntax and the expression
 action p        pn   is the name and actual parameters of the action to be executed at that
point in time  in more complex plans simple and durative actions  with or without numericvalued effects or preconditions  can co occur  the semantics of such plans is discussed in
section    no special separators are required to separate timed actions in the sequence
and the actions are not required to be presented in time sorted order  it is possible for
multiple actions to be given the same time stamp  indicating that they should be executed
concurrently  it should be emphasised that the earliest point at which activity occurs within
a plan must be strictly after time    this constraint follows from the decision to make the
initial state be the state existing at time    together with the decision  in the semantics 
that actions have their effects in the interval that is closed on the left  starting at the time
when the action is applied  while preconditions are tested in the interval that is open on the
right that precedes the action 
  

fifox   long

in order to retain compatibility with the output of current planners the following concession is made  if the plan is presented as a sequence of actions with no time points  then
it is inferred that the first action is applied at time   and the succeeding actions apply in
sequence at integral time points one unit apart 
a simple plan is a slight generalisation of the more familiar strips style classical plan 
since actions are labelled with the time at which they are to be executed 
definition    simple plan a simple plan  sp   for a planning instance  i  consists of a
finite collection of timed simple actions which are pairs  t  a   where t is a rational valued
time and a is an action name 
the happening sequence   ti  i     k for sp is the ordered sequence of times in the set
of times appearing in the timed simple actions in sp   all ti must be greater than    it is
possible for the sequence to be empty  an empty plan  
the happening at time t  et   where t is in the happening sequence of sp   is the set of
 simple  action names that appear in timed simple actions associated with the time t in sp  
a plan thus consists of a sequence of happenings  each being a set of action names applied
concurrently at a specific time  the sequence being ordered in time  the times at which these
happenings occur forms the happening sequence  it should be noted that action names are
ambiguous when action schemas contain conditional effects  the consequence of flattening
is to have split these actions into multiple actions with identical names  differentiated by
their preconditions  however  at most one of each set of actions with identical names can
be applicable in a given logical state  since the precondition of each action in such a set
will necessarily be inconsistent with the precondition of any other action in the set  due to
the way in which the conditional effects are distributed between the pairs of action schemas
they induce 
in order to handle concurrent actions we need to define the situations in which the
effects of those actions are consistent with one another  this issue was first discussed in
section      the mutual exclusion rule for pddl    is an extension of the idea of action
mutex conditions for graphplan  blum   furst         the extension handles two extra
features  the extended expressive power of the language  to include arbitrary propositional
connectives  and the introduction of numeric expressions  we make a very conservative
condition for actions to be executed concurrently  which ensures that there is no possibility
of interaction  this rules out cases where intuition might suppose that concurrency is
possible  for example  the actions 
  action a
 precondition  or p q 
 effect  r  
  action b
 precondition  p 
 effect  and  not p   s   

could  one might suppose  be executed simultaneously in a state in which both p and q hold 
the following definition asserts  however  that the two actions are mutex  the reason we
have chosen such a constrained definition is because checking for mutex actions must be
  

fipddl     expressing temporal planning domains

tractable and handling the case implied by this example would appear to require checking
the consequence of interleaving preconditions and effects in all possible orderings  the
condition on primitive numeric expressions has already been discussed  it determines
that the update effects can be executed concurrently and that they do not affect values
which are then tested by preconditions  regardless of whether the results of those tests
matter to the satisfaction of their enclosing proposition   this is the rule of no moving
targets  no concurrent actions can affect the parts of the state relevant to the precondition
tests of other actions in the set  regardless of whether those effects might be harmful or
not  it might be considered odd that the preconditions of one action cannot refer to literals
in the add effects of a concurrent action  we require this because preconditions can be
negative  in which case their interaction with add effects is analogous to the interaction
between positive preconditions and delete effects  the no moving targets rule makes the
cost of determining whether a set of actions can be applied concurrently polynomial in the
size of the set of actions and their pre  and post conditions 
definition    mutex actions two grounded actions  a and b are non interfering if
gp rea   addb  delb     gp reb   adda  dela     
adda  delb   addb  dela   
la  rb   ra  lb   
la  lb  la  lb
if two actions are not non interfering they are mutex 
the last clause of this definition asserts that concurrent actions can only update the
same values if they both do so by additive assignment effects 
we are now ready to define the conditions under which a simple plan is valid  we can
separate the executability of a plan from whether it actually achieves the intended goal 
we will say that a plan is valid if it is executable and achieves the final goal  executability
is defined in terms of the sequence of states that the plan induces by sequentially executing
the happenings that it defines 
definition    happening execution given a state   t  s  x  and a happening  h  the
activity for h is the set of grounded actions
ah    a the name for a is in h  a is valid and p rea is satisfied in  t  s  x  
the result of executing a happening  h  associated with time th   in a state  t  s  x  is
undefined if  ah    
   h  or if any pair of actions in ah is mutex  otherwise  it is the state
 
 
 th   s   x   where
 
 
s     s  
dela   
adda
aah

and

x 

aah

is the result of applying the composition of the functions  npfa   a  ah   to x 

since the functions  npfa   a  ah   must affect different primitive numeric expressions 
except where they represent additive assignment effects  these functions will commute and
  

fifox   long

therefore the order in which the functions are applied is irrelevant  therefore  the value of
x  is well defined in this last definition  the requirement that the activity for a happening
must have the same number of elements as the happening itself is simply a constraint that
ensures that each action name in the happening leads to a valid action that is applicable in
the appropriate state  we have already seen that conditional effects induce the construction
of families of grounded actions  but that at most one of each family can be applicable in
a state  if none of them is applicable for a given name  then this must mean that the
precondition is unsatisfied  regardless of the conditional effects  in this case  we are asserting
that the attempt to apply the action has undefined interpretation 
definition    executability a simple plan  sp   for a planning instance  i  is executable
if it defines a happening sequence   ti  i     k   and there is a sequence of states   si  i     k  
such that s  is the initial state for the planning instance and for each i           k  si   is
the result of executing the happening at time ti in sp  
the state sk   is called the final state produced by sp and the state sequence  si  i     k  
is called the trace of sp   note that an executable plan produces a unique trace 
definition    validity of a simple plan a simple plan  for a planning instance  i  is
valid if it is executable and produces a final state s  such that the goal specification for i is
satisfied in s 

   the semantics of durative actions
plans with durative actions with discrete effects can be given a semantics in terms of the
semantics of simple plans  handling durative actions that have continuous effects is more
complex  we discuss this further in section   
durative actions appearing in a plan must be given with an additional field indicating
the duration  this is given with the syntax 
t    action p        pn    d 
where d is a rational valued duration  written in floating point syntax 
durative actions are introduced into the framework we have defined so far by generalising
definition   to include durative action schemas  the definition of the grounded action must
now be extended to define the form of grounded durative actions  however  this definition
can be given in such a way that we associate with each durative action two simple  nondurative  actions  corresponding to the end points of the durative action  these simple
actions can  together  simulate almost all of the behaviour of the durative action  the only
aspects that are not captured in this pair of simple actions are the duration of the durative
action and the invariants that must hold over that duration  these two elements can 
however  be simply handled in a minor extension to the semantics of simple plans  and this
is the approach we adopt  by taking this route we avoid any difficulties in establishing the
effects of interactions between durative actions  this is all handled by the semantics for the
concurrent activity within a simple plan  as we will see  one difficulty in this account is the
handling of durative actions with conditional effects that contain conditions and effects that
are associated with different times or conditions that must hold over the entire duration of
  

fipddl     expressing temporal planning domains

the action  since these cases complicate the semantics we will postpone treatment of them
until the next section and begin with durative actions without conditional effects 
the mapping from durative actions to non durative actions has the important consequence that the mutex relation implied between non durative actions is  advantageously 
weaker than the strong mutex relation used in  for example  tgp  smith   weld        
two durative actions can be applied concurrently provided that the end points of one action
do not interact either with the end points  if simultaneous  or the invariants of the other
action 
definition    grounded durative actions durative actions are grounded in the same
way as simple actions  see definition     by replacing their formal parameters with constants from the planning instance and expanding quantified propositions  the definition of
durative actions requires that the condition be a conjunction of temporally annotated propositions  each temporally annotated proposition is of the form  at start p    at end p 
or  over all p   where p is an unannotated proposition  similarly  the effects of a durative action  without continuous or conditional effects  are a conjunction of temporally
annotated simple effects 
the duration field of da defines a conjunction of propositions that can be separated into
da and dc da   the duration conditions for the start and end of da  with terms being
dcstart
end
arithmetic expressions and  duration  the separation is conducted in the obvious way 
da and at end conditions into dc da  
placing at start conditions into dcstart
end
each grounded durative action  da  with no continuous effects and no conditional effects
defines two parameterised simple actions dastart and daend   where the parameter is the
 duration value  and a single additional simple action dainv   as follows 
dastart  daend   has precondition equal to the conjunction of the set of all propositions  p  such that  at start p    at end p   is a condition of da  together with
da  dc da    and effect equal to the conjunction of all the simple effects  e  such that
dcstart
end
 at start e    at end e   is an effect of da  respectively  
dainv   is defined to be the simple action with precondition equal to the conjunction of
all propositions  p  such that  over all p  is a condition of da  it has an empty effect 
every conjunct in the condition of da contributes to the precondition of precisely one
of dastart   daend or dainv   every conjunct in the effect of da contributes to the effect of
precisely one of dastart or daend   for convenience  dastart  daend   dainv   will be used
to refer to both the entire  respective  simple action and also to just its name 
the actions dastart and daend are parameterised by  duration and this parameter
must be substituted with the correct duration value in order to arrive at the two simple
actions corresponding to the start and end of a durative action 
definition    plans a plan  p   with durative actions  for a planning instance  i  consists
of a finite collection of timed actions which are pairs  each either of the form  t  a   where t is
a rational valued time and a is a simple action name  an action schema name together with
the constants instantiating the arguments of the schema  or of the form  t  a t      where t is
a rational valued time  a is a durative action name and t  is a non negative rational valued
duration 
  

fifox   long

definition    induced simple plan if p is a plan then the happening sequence for p
is  ti  i     k   the ordered sequence of time points formed from the set of times 
 t    t  a   p or  t  a t      p or  t  t    a t      p  
the induced simple plan for a plan p   simplify p    is the set of pairs defined as follows 
  t  a  for each  t  a   p where a is a simple  non durative  action name 
  t  astart   duration    t     and  t   t    aend   duration    t      these expressions are
simple timed actions  the square brackets denote substitution of t  for  duration in
this case  for all pairs  t  a t      p   where a is a durative action name 
   ti   ti        ainv   for each pair  t  a t      p and for each i such that t  ti   t   t   
where ti and ti   are in the happening sequence for p  
the process of transforming a plan into a simple plan involves introducing actions to
represent the end points of the intervals over which the durative actions in the plan are
applicable  duration constraints convert into simple preconditions on start or end actions 
requiring the substitution of a numeric value for the  duration field to complete the conversion into simple actions  the complication to this process is that invariants cannot
be associated with the end points  but must be checked throughout the interval  this is
achieved by adding to the simple plan a collection of special actions responsible for checking the invariants  these actions are added between each pair of happenings in the original
plan lying between the start and end point of the durative action  because the semantics of
simple plans requires that the preconditions of actions in the plan be satisfied  even though
they might have no effects  the consequence of putting these monitoring actions into the
simple plan is to ensure that the original plan is judged valid only if the invariants remain
true  firstly  after the start of the durative action and  subsequently  after each happening
that occurs throughout the duration of the durative action  one possibility is to make these
monitoring actions occur at the same times as the updating actions  but this would require
values to be accessed at the same time as they might be being updated  violating the no
moving targets rule  in order to avoid this problem the monitoring actions are interleaved
with the updating actions by inserting them midway between pairs of successive happenings
in the interval over which each durative action is executed  only happenings in the original plan need be considered when carrying out this insertion  since the invariant checking
actions themselves cannot have any effect on the states in which they are checked 
alternative treatments of invariants are possible  but an important advantage of the
approach we have taken is that the semantics rests  finally  on a state transition model in
a form that is familiar to the planning community  that is  plans can be seen as recipes
for state transition sequences  with each state transition being a function from the current
state of the world to the next  however  durative actions complicate this picture because
they rely on a commitment  once a durative action has been started  to follow it through to
completion  that commitment involves some sort of communication across the duration of
the plan  the communication can be managed by structures outside the plan  that examine
   care should be taken in reading this definition  the last disjunct allows the time corresponding to the
end of execution of a durative action to be included as a happening time 

  

fipddl     expressing temporal planning domains

the trace  or by artificial modification of the plan itself to ensure that states carry extra
information from the start to the end of the durative action  the latter approach has the
disadvantage that as durative actions become more complex the artificial components that
must be added to the plan become more intrusive  this is particularly apparent in the
treatment of conditional effects that require conditions tested at the start of a durative
action  or across its duration  but effects that are triggered at the end  since these cases
require some sort of memory in the state to remember the status of the tested conditions
from the start of the durative action to the end point  these memory conditions allow
us to avoid embedding an entire execution history in a state by substituting an ad hoc
memory of the history for just those propositions and at just those times it is required  the
management of conditional effects of this form  in the mapping from durative actions to
simple actions  is discussed further in section     
we can now conclude the definitions supporting the validity of a plan with durative
actions 
definition    executability of a plan a plan  p  for a planning instance   is executable if the induced simple plan for p   simplify p   is executable  producing the trace
 si    ti   si   vi   i     k  
definition    validity of a plan a plan  p  for a planning instance   is valid if it is
executable and if the goal specification is satisfied in the final state produced by its induced
simple plan 
    durative actions with conditional effects
we now explain how the mapping described in the previous section is extended to deal with
durative actions containing conditional effects 
first  we observe that temporally annotated conditions and effects can be accumulated 
because the temporal annotation distributes through logical conjunction  therefore  we
can convert conditional effects so that their conditions are simple conjunctions of at most
one at start condition  at most one at end condition and at most one over all condition  it
should be noted that we do not allow logical connectives other than conjunction in combining temporally annotated propositions  allowing other connectives would create significant
further complexity in the semantics and create potentially paradoxical opportunities for
communication from future states to earlier states  similarly to conditions  durative action
effects can be reduced to a conjunction of at most one at start effect and at most one at end
effect  treatment of conditional effects then divides into three cases  the first case is very
straightforward  any effect in a durative action of the form  when  at t p   at t q   
where the condition and the effect bear the same single temporal annotation  can be transformed into a simple conditional effect of the form  when p q  attached to the start or end
simple action according to whether t is start or end  since this case is straightforward we
will not explicitly extend the previous definitions to cope with it  the second case is one in
which the condition of a condition effect has at start conditions and the effect has at end
effects 
note that we consider conditional effects in which the effects occur at the start  but
with conditions dependent on the state at the end or over the duration of the action  to be
  

fifox   long

meaningless  this is because they reverse the expected behaviour of causality  where cause
precedes effect  in any attempt to validate a plan by constructing a trace such reversed
causality would be a huge problem  since we could not determine the initial effects of applying a durative action until we had seen what conditions held over the subsequent interval
and conclusion of its activity  but  equally  we could not see what the effects of activity during the interval would be without seeing the initial effects of applying the durative action 
this paradox is created by the opportunity for an action to change the past 
to handle this second case we need to modify the state after the start of the durative action to remember whether the start conditions were satisfied and communicate this to the
end of the durative action where it can then be simply looked up in the  then  current state
to determine whether the conditional effect should be applied  we apply a transformation to
conditional effects of the form  when  and  at start ps   at end pe    at end q  
into a conditional effect added to the start simple action   when ps  mps     and a conditional effect added to the end simple action   when  and pe  mps    q   where mps is a
special new proposition  unique to the particular conditional effect of the particular application of the durative action being transformed  by ensuring that this proposition is unique
in this way  there is no possibility of any other action in the plan interfering with it  so it
represents an isolated memory of the fact that ps held in the state at which the durative
action was started  if a conditional effect does not have at end conditions  the same transformation can be applied  simply ignoring pe in the previous discussion  figure    depicts
the transformation of a single durative action  a  with a conditional effect  into a collection
of level   actions  complete with the appropriate memory proposition  in this case called
p    
the importance of the memory introduced in this transformation is explained in figures    and     figure    shows the ambiguity that results from not remembering how a
state  on the trajectory of a plan  was reached  the figure illustrates that if one is in a
state  p  q  r  at the point when durative action a  as described in figure     ends  it is
impossible to determine from the state alone whether r should be added or not  this is
because it is possible to have reached the state  p  q  r  by at least two different paths 
with at least one path having seen a started in a state in which p held and at least one path
having seen a started in a state in which p did not hold  using an action  achieve p   with p
as its only effect   the state  p  q  r  does not contain any information to disambiguate
which path was used to reach it  and hence cannot determine the correct value of r after
a ends 
the third  and final  case is where the durative action has conditional effects of the form 
 when  and  at start ps   over all pi   at end pe    at end q   

again  if the effect has no at start or at end conditions the following transformation can be
applied simply ignoring ps or pe as appropriate  in this case we need to construct a transformation that remembers not only whether ps held in the state at which the durative
action is first applied  but also whether pi holds throughout the interval from the start to
the end of the durative action  unlike the invariants of durative actions  these conditions
are not required to hold for the plan to be valid  but only determine what effects will occur at
the end of the durative action  the idea is to use intervening monitoring actions  rather as
we did for invariants in definition     this is achieved by adding a further effect to the start
  

fipddl     expressing temporal planning domains

initial durative action
  durative action a
 parameters   
 duration     duration   
 condition   
 effect  when  and  at start p   at end q  
 at end r   

transformation to simple actions
  action a start
 parameters   
 precondition   
 effect  when p p   

  action a end
 parameters   
 precondition   
 effect  when  and p  q  r  

expansion of conditional effects
  action a start
 parameters   
 precondition  p 
 effect  p   

  action a start
 parameters   
 precondition  not p 
 effect    

  action a end
 parameters   
 precondition  and p  q 
 effect  r  

  action a end
 parameters   
 precondition  or  not p    not q  
 effect    

transformation of plan to simple plan
plan

plan

  a   

  a start
  a end

figure     conversion of a durative action into non durative actions and their grounded
forms 

  

fifox   long

p q  r

  a start
  a end
p q  r

p q
r 

  a start
 p q

  achieve p

 p q
 r

 r

figure     flawed state space resulting from failure to record the path traversed when conditional effects span the interval of a durative action  the arc labelled achieve p
indicates the possible application of some action that achieves the proposition
p 
  a start
p q
 r  p 

p  p
q  r

  a end

  achieve p
 p q
 r  p 

  a start

 p q
 r  p 

p q
r p 
  a end
p q 
 r  p 

p q
 r  p 

figure     correct state space showing use of memory proposition p   the arc labelled
achieve p indicates the possible application of some action that achieves the
proposition p 

action   mpi    then  the monitoring  simple  actions that are required have no precondition  but a single conditional effect   when  and  mpi    not pi    not  mpi      once
again  mpi is a special new proposition unique to the conditional effect for the application
instance of the durative action being transformed  the monitoring actions are added at all
the intermediate points that are used for the monitoring actions in definition     the same
transformation used in the second case above is required again for the at start condition 
ps  so  when ps  mps    is added as a conditional effect to the start simple action  finally 
we add a conditional effect to the end  simple  action   when  and  mps    mpi   pe  q  
the effect of this machinery is to ensure that if the proposition pi becomes false at any time
between the start and end of the durative action then mpi will be deleted  but otherwise at
the end of the durative action mps will hold precisely if ps held at the start of the action
and mpi will hold precisely if pi has held over the entire duration of the durative action 
therefore  the conditional effect of the end action achieves the intuitively correct behaviour
of asserting its conditional effect precisely when the at start condition held at the start of
the durative action  the at end condition holds at the end of the durative action and its
over all condition has held throughout the duration of the action 
the addition of these new memory checking actions means that it is no longer true
to claim that the added actions cannot change the state  however  memory propositions
are unique to the task of communication for a single action instance  so the effects that
memory checking actions might have on these have no implications for other invariants 
   

fipddl     expressing temporal planning domains

   the semantics of continuous durative actions
the introduction of continuous durative actions complicates the semantics  it is no longer
possible to handle invariants by insertion of simple actions between other happenings in a
plan to test their continued satisfaction  in fact  continuous effects can  in principle  cause
an invariant to be satisfied over some parts of an interval and not over others  ignoring
invariants for a moment  updates to numeric values caused by continuous effects can be
applied as discrete updates at time points within the interval over which they apply  these
updates behave slightly differently to the discrete updates we have seen in durative actions
with discrete effects  since it is possible for a continuous update to affect a variable that is
concurrently affected by a discrete update  or examined by a precondition  without creating
an inconsistency  for example  if the water heating action in figure    is applied with the
concurrent addition of an egg to the pan with a precondition that the temperature of the
water is between    and    degrees then the value of the temperature can be examined at
the moment of application of the action adding the egg  this is because the temperature
change is actually happening over the interval between the start of the heating and the
point at which the egg is added  rather than as a discrete update at the point the egg is
added  the temperature is not actually changed at the instant of the addition of the egg 
in this section we summarise the semantics for continuous actions  where the semantics
for discrete durative actions is defined in terms of the familiar state transition semantics 
the continuous semantics introduces a different formulation 
definition    a continuous durative action a continuous effect is an effect expression that includes the symbol  t  a continuous durative action is a durative action with at
least one continuous effect 
definition    continuous update function let c be a set of ground continuous effects
for a planning instance  i  and st    t  s  x  be a state  the continuous update function
defined by c for state st is the function fc   r  rn   where n is dimi   such that 
dfc
 g
dt
and
fc       x
where g is the update function generated for an action a with 
n pa       op  p q      op  p     t q    c 
definition    shows how the continuous effects of several continuous durative actions can
be combined to create a single system of simultaneous differential equations whose solution 
given an appropriate starting point  defines the evolution of the continuously varying values 
definition    induced continuous plan let i be a planning instance that includes
continuous durative actions and p be a plan for i  the induced continuous plan for p is a
triple   s  invs  cts   where s is simplif y p    invs is the set of invariant constraints 
invs     q  t  t   d     t  a d    p and  over all q  is an invariant for a 
   

fifox   long

let ti and ti   be two consecutive times in the happening sequence for simplif y p    the
set of active continuous effects over  ti   ti     is 
 q    t  a d    p   ti   ti       t  t   d  and q is a continuous effect of a 
and cts is the set of systems of continuous effects 
cts     c  ti   ti       c is the set of active continuous effects over  ti   ti     
the components of a continuous plan separate out the invariant conditions and continuous effects from the rest of the simple plan in order to allow correct application of the
continuous updates and to allow confirmation that the invariants hold in the face of the
continuous effects 
definition    trace let i be a planning instance that includes continuous durative actions  p be a plan for i   sp  inv  cts  be the induced continuous plan for p    ti  i     k
be the happening sequence for s and s  be the initial state for i  the trace for p is the
sequence of states  si  i     k   defined as follows 
 if there is no element  c  ti   ti      cts then si   is the state resulting from applying
the happening at ti in the simple plan sp to the state si  
 if  c  ti   ti      cts then let ti be the the state formed by substituting f  ti    ti   for
the numeric part of state si   where f is the continuous update function defined by c
for state si   then si   is the state resulting from applying the happening at ti in the
simple plan sp to the state ti   if f is undefined for any element in cts then so is
the trace 
definition    defines a trace in a similar fashion to the traces for simple plans and plans
with durative actions  the key difference is the need to apply the continuous updates  these
are handled by solving the systems of simultaneous differential equations across each interval
in which they are active and then applying the result to update the numeric values across
that interval  of course  this is easier to describe than it is to do  since solving arbitrary
simultaneous differential equations algorithmically is not generally possible  under certain
constraints this semantics can be implemented in order to confirm the validity of a plan
automatically 
definition    invariant safe let i be a planning instance that includes continuous durative actions  p be a plan for i   s  inv  cts  be the induced continuous plan for p and
 si  i     k   be the trace for p   for each  c  ti   ti      cts let fi be the continuous update
function defined by c for si   p is invariant safe if  for each fi that is defined and for each
 q  t  u   inv such that   ti   ti        i   t  u   then x  i  num s  q  fi  x   where s is
the logical state in si  
in this definition  the symbols        are used to mean that the interval i can be closed or
open at either end 
   

fipddl     expressing temporal planning domains

from a semantic point of view  invariants must be checked at every point in the interval over which they apply  when the interval contains only finitely many discrete changes
then the obligation can be met by considering only the finite number of points at which
change occurs  a fact that is exploited for discrete durative action plan semantics in definition      when there is continuous change the obligation is much harder to meet  in
practice  the invariants can be checked by examining the possible roots of the function describing continuous change  but finding those roots can be very difficult in general  again 
suitable constraints on the forms of differential equations expressed in a domain can make
the validation problem tractable 
the last two definitions simply assemble the components to arrive at analogous definitions to those for executability and validity of simple plans and plans with durative actions 
definition    executability of a plan a plan p containing continuous durative actions 
for planning instance i  with induced continuous plan  s  invs  cts   p is executable if the
trace for p is defined   si  i     k     and it is invariant safe 
definition    plan validity a plan p containing durative actions  for planning instance
i is valid if it is executable  with trace  si  i     k   and sk   satisfies the goal in i 

    plan validation
plan validation is an important part of the use of pddl  particularly in its role for the
competition  with approximately      plans to consider in the competition in       it can
be seen that automation is essential  the validation problem is tractable for propositional
versions of pddl because plans are finite and can be validated simply by simulation of their
execution  the issue is more complicated for pddl    because the potential for concurrent
activity  possibly in the face of numeric change  makes it necessary to ensure that invariant
properties are protected and that concurrent activity is non interfering 
when durative actions are used there is a question over whether a plan should be
considered valid if it does not contain all of the end points of the actions initiated in the
plan  when an action is exploited in a plan for the effect it has at the end of its duration
it is clear that that end point will be present in the plan  but when an action was selected
for its start effect this is less clear  a match striking action is performed for its start effect 
not in order to have a burned out match at the end of a brief interval  it could be argued
that  having obtained the desired start effect the end of the action is irrelevant and the
plan can terminate  as soon as all goals are achieved  without ensuring that all initiated
actions end safely  indeed  the plan search process in sapa  do   kambhampati        can
terminate whilst there are still queued events awaiting the advancement of time  however 
it is possible to conceive of situations in which the end point of an action  incorporated
only for its start effect  introduces inconsistencies in the plan so that its inclusion would
make the plan invalid  in these cases it seems that plan validity could be compromised by
ignoring end effects 
in order to avoid having to resolve these complexities  we have taken the view that a
pddl    plan is valid only if all action start and end points are explicit within the plan 
having identified that this is the case we then proceed to confirm that all happenings within
the plan are mutex free 
   

fifox   long

plan validation is decidable for domains including discretized and  under certain constraints  continuous durative actions because all activity is encapsulated with the durative
actions explicitly identified by a plan  this makes the trace induced by a plan finite and
hence checkable  we therefore observe that the validation problem for pddl    is decidable
even when actions contain duration inequalities  this is because the work in determining
how the duration inequalities should be solved has already been completed in the finished
plan so validation of the plan can proceed by simulation of its execution  as is the case
for pddl plans  the problem is tractable for domains without continuous effects  but the
introduction of continuous effects can  in principle  allow expression of domains with very
complex functions describing numeric change  howey   long         under the assumption
that continuous effects are restricted to description in terms of simple linear or quadratic
functions  without any interactions between concurrent continuous effects  plan validity is
tractable  the cost in practice is increased however  since it may be necessary to solve
polynomials in order to check invariants  validation of plans containing more complex
expressions of change is being explored 
although plan validity checking is tractable  there is a subtlety that arises because of
the need to represent plans syntactically and the difficulties involved in expressing numbers with arbitrary precision  in principle  all of the values that are required to describe
valid plans are algebraic  assuming we constrain continuous effects as indicated above  
and therefore finitely representable  in practice  expecting planners to handle numbers as
algebraic expressions seems unnecessarily complicated and it is far more reasonable to assume that numbers will be represented as finite precision floating point values  indeed  the
syntax we have adopted for the expression of plans restricts planners to expressing times
as finite precision floating point values  with this constraint  and because of limitations on
the precision of floating point computations in implementations of plan validation systems 
it is necessary to take a more pragmatic view of the validation process and accept that
numeric conditions will have to be evaluated to a certain tolerance  otherwise  it can occur
that there is no way to report a plan to the necessary degree of accuracy for it to have a
valid interpretation under the semantics we defined in section    in most cases  a plan that
specifies time points to  for example  four significant digits  is a reasonable abstraction of the
execution time activity that will be needed to control the flow system  no plan can specify
time points absolutely precisely  so abstraction is forced upon the planner by the fact that
it is working with models of the world and not the physical world itself  the problem  then 
is one of the relationship between the theoretical semantics and the pragmatic concerns of
automated validation 
in figure    this relationship is depicted in terms of what kinds of plans can be automatically validated  the left side of the picture describes the theoretical semantics  with
the arrow indicating the link between plans and their interpretation under the theoretical
semantics  for example  it is possible to construct
a domain and problem for which a plan

that requires an action to happen at time   is a meaningful semantic object  but for which
a plan that specifies that theaction happen at time      is not a meaningful semantic object
because      is not equal to    these two plans are distinct  and only one is correct  under
the assumed constraints   the right side of the picture depicts the pragmatic validation of
syntactic plan objects  the two control plans  though distinct in the semantics  can map to
the same syntactic object if we assume that the validation is subject to a tolerance of      
   

fipddl     expressing temporal planning domains

semantic interpretation of plans

validation of plans

mapping semantics to pragmatic
realisation in automated validation process

semantic plan objects


 
 
  fifffi 
 
 
   





    ff 
 
   



  
 


mapping semantic plans to their syntactic
counterparts 



syntactic plan objects

a specific pair of mappings

figure     the pragmatic mapping between semantics of plans and their validation by
automated computational processes  the shaded area contains plans that cannot
be interpreted within the theoretical semantics  it can be seen that a plan in
this collection is indistinguishable from a meaningful plan when mapped to the
syntactic side of the picture 

these plans both map to the syntactic object in which      approximates the value   
this syntactic plan can be validated using the pragmatic validation processes necessary for
automatic validation of describable syntactic plans  which will check for validity subject
to the tolerance of       the pragmatic constraints on the representations of plans  the
expectations about representations of numeric values in planners and validators and their
consequences are all reasonable assumptions given that the models against which we check
validity are  in any case  abstractions  at some non zero tolerance  of the world  in practice 
it is a problem to accept plans at specified tolerance levels only in pathological cases  while
arithmetic precision in computer representations of floats has an immediate and negative
impact if one tries to take the stronger line that plans should only be accepted if they are
strictly valid according to the formally precise evaluation of expressions 
finally  there is an interesting philosophical issue that arises and is discussed by henzinger and his co authors               it is  in fact  not possible to achieve exact precision
in the measurement of time or other continuous numeric quantities  henzinger et al  have
considered this problem through the development of robust automata  robust automata
only accept a trace if there exists a tube of traces within a distance      of the original
trace  all of which are acceptable by the original acceptance criteria  these are called fuzzy
tubes indicating that time is fuzzily  rather than precisely  detectable  this idea offers a path
to a formal semantics that is closer to defining plans that are robust to the imprecision in
an executives ability to measure time  unfortunately  checking fuzzy tubes is intractable 
we currently compromise by adopting an  value  used as the tolerance in checking that
numeric values fulfil numeric constraints during plan execution  to also represent the minimum separation of conflicting end points within plans  this is consistent with the idea that
if the planner assumes that an executive is willing to abstract to the indicated tolerance
level in the checking of preconditions for actions then it is unreasonable to suppose that a
plan can make use of finer grained measurements in determining when actions should be
   

fifox   long

applied  at the moment the value of  is set in the validation process  and only communicated informally to planner engineers  but it might be better to allow a domain designer
to define an  appropriate for use in the particular domain  there remain several issues
concerning the correct management of the buffers during validation  particularly the usual
problem concerning the transitivity of fuzzy closeness  which are important issues for
temporal reasoning as a whole and are not restricted to the planning context  we do not
yet have solutions to all of these problems 

    related work  representing and reasoning about time
representation of  and reasoning with  statements about time and the temporal extent of
propositions has long been a subject of research in ai including planning research  allen 
      mcdermott        sandewall        kowalski   sergot        laborie   ghallab 
      muscettola        bacchus   kabanza         important issues raised during the
extension of pddl to handle temporal features have  of course  already been examined by
other researchers  for example in shanahans work        on continuous change within the
event calculus  in shohams work        and reichgelts work        on temporal reasoning and work on non reified temporal systems  bacchus  tenenberg    koomen        
vila        provides an excellent survey of work in temporal reasoning in ai  in this section
we briefly review some of the central issues that have been addressed  and their treatment
in the literature  and set pddl    in the context of research in temporal logics 
several researchers in temporal logics have considered the problems of reasoning about
concurrency  continuous change and temporal extent  these works have focussed on the
problem of reasoning about change when the world is described using arbitrary logical
formulae  and most have been concerned with making meta level statements  such as that
effect cannot precede cause   the need to handle complex logical formulae makes the
frame problem difficult to resolve  and an approach based on circumscription  mccarthy 
      and default reasoning  reiter        is typical  the strips assumption provides a
simple solution to the frame problem when states are described using atomic formulae 
the classical planning assumption is that states can be described atomically but this is
not a general view of the modelling of change  although simplifying  this assumption is
surprisingly expressive  the bench mark domains introduced in the third international
planning competition suggest that atomic modelling is powerful enough to capture some
complex domains which closely approximate real problems  the temporal reasoning issues
we confront are not simplified as a consequence of having made a simplifying assumption
about how states are updated  we remain concerned with the major issues of temporal
reasoning  concurrency  continuous change and temporal extent 
in the development of pddl    we made a basic decision to consider the end points of
durative actions as instantaneous state transitions  this allows us to concentrate on the
truth of propositions at points instead of over intervals  the decision to consider actions in
this way is similar to that made by many temporal reasoning researchers  shanahan       
mccarthy   hayes        mcdermott         in the context of pddl    the approach has
the advantage of smoothly integrating with the classical planning view of actions as state
transitions  nevertheless  allen has shown that a temporal ontology based on intervals
can be a basis for planning  allen              and several planning systems have been
   

fipddl     expressing temporal planning domains

strongly influenced by the intervals approach  muscettola        rabideau  knight  chien 
fukunaga    govindjee         allen later moved away from his initial position that instants
are not required  introducing the notion of moments  hayes   allen         which are a
concept that attempts to reconcile the stance that nothing is instantaneous  so there should
only be intervals  and the observation that changes in values of discrete valued variables 
such as propositional variables  apparently cannot avoid changing at instants  this view is
consistent with the approach we take in the modelling of continuous durative actions  and
with the view of change as consisting of both discrete and continuous aspects  henzinger 
      
in the remainder of this section we compare the pddl extensions that we propose with
previous work in temporal reasoning by considering the three central issues identified above 
our objective is not to claim that our extensions improve on previous work  but instead to
demonstrate that the implementation of solutions to these three problems within the pddl
framework makes their exploitation directly accessible to planning in a way that they are
not when embedded within a logic and accompanying proof theory 
     continuous change
several temporal reasoning frameworks began with consideration of discrete change and 
later  were extended to handle continuous change  for example  shanahan        extended
the event calculus of kowalski and sergot        to enable the modelling of continuous
change  this process of extension mirrors the situation faced in extending pddl  where a
system modelling discrete change already existed  it is  therefore  interesting to compare
the use of pddl    with the use of systems such as the extended event calculus 
in his sink filling example shanahan        discusses the issues of termination of events
 self termination and termination by other events   identification of the level of water in the
sink during the filling process and the effect on the rate of change in the level of water in
a sink when it is being filled from two sources simultaneously  the behaviour of the filling
process and its effects on the state of the sink over time are modelled as axioms which would
allow an inference engine to predict the state of the sink at points during the execution of
the process 
pddl    allows the representation of the complex interactions that arise when a sink is
filled from multiple independently controlled water sources by means of concurrent durative
actions with continuous effects that encapsulate the initiation of the filling process  from
a single water source  the change in the level of water in the sink and the termination
of the process when the water source is turned off  this model is robust  since it easily
accommodates multiple water sources  simply modifying the rate of flow appropriately by
commutative updates  since the actions have additive effects and the model provides the
rate at which water enters the tank from a source  it is possible to compute the level of
water in the sink at any point in the filling interval at which a concurrent action might
consult the level  in contrast to shanahans extension to the event calculus  this approach
does not require that the filling process be  at least from the point of view of the logical
axiomatisation  terminated and restarted at a new rate when a water source is opened or
closed  since the process simply remains active throughout  the change in rate of filling is
   

fifox   long

then reflected in a piecewise linear profile for the depth of water in the sink  just as it is in
shanahans model 
it is not possible to model the multiple water sources situation if the filling process is
completely encapsulated within a discretized durative action  in the discretized action the
true level of water is not accessible during the filling process but only at its end or its start 
step function behaviour only coarsely approximates true behaviour  so the consequence is
that complex interactions cannot be properly modelled 
one of the important consequences of continuous behaviour is the triggering of events  in
shanahans extensions this is achieved through the axiomatisation of causal relationships 
events are not distinguished syntactically from actions  but only by the fact that their
happening is axiomatically the consequence of certain conditions  in pddl    some events
 such as the flooding of the sink if the filling continues after its capacity has been reached 
can be modelled by using a combination of conditional effects and duration inequalities 
however  not all events can be modelled in this way  since it is not always possible to predict
when spontaneous events will occur  pddl    could be extended to allow the expression
of causal axioms  but an alternative approach is to modify the language to enable the
representation of events within the action oriented tradition  this can be achieved by
breaking up continuous durative actions into their instantaneous start and end points and
the processes they encapsulate  this would enable the execution of a process to be initiated
by a start action and ended by an instantaneous state transition that is either an action
under the control of the planner or an event  a simple extension to the language is needed
to distinguish actions from events and to prevent the planner from deliberately selecting
an event  we refer to this approach as the start process stop model  and we have extended
pddl    to support it  fox   long         the resulting language  pddl   is more difficult
to plan with than pddl     and there are still open questions  concerning the complexity
of the plan validation problem for this language  which remain topics for future work 
     concurrency
the opportunity for concurrent activities complicates several aspects of temporal reasoning 
firstly  it is necessary to account for which actions can be concurrent and secondly it is
necessary to describe how concurrent activities interact in their effects on the world 
in most formalisms the first of these points is achieved by relying on the underlying logic
to deliver an inconsistency when an attempt is made to apply two incompatible actions simultaneously  for example  the axioms of the event calculus will yield the simultaneous
truth and falsity of a fluent if incompatible actions are applied simultaneously and consequently yield an inconsistency  unfortunately  recognising inconsistency is  in general 
undecidable  for a sufficiently expressive language  in pddl    we adopt a solution that
exploits the restricted form of the action centred formalism  defining the circumstances in
which two actions could lead to inconsistency and rejecting the simultaneous application
of such actions  we favour a conservative restriction on compatibility of actions  the no
moving targets rule   in order to support efficient determination of incompatibility  rather
than a more permissive but elusive ruling  an alternative approach  adopted by bacchus in
tlplan         for example  is to allow multiple actions to occur at the same instant  but
nevertheless to be executed in sequence  we find this solution counter intuitive and  more
   

fipddl     expressing temporal planning domains

importantly  consider that it would be impossible to use a plan of this sort as an instruction
to an executive  no executive could be equipped to execute actions simultaneously and yet
in a specified order  our view is that if the order of execution matters then the executive
must ensure that the actions are sequenced and can only do so within the limitations of its
capability to measure time and react to its passing 
shanahan        discusses gelfonds        example of the soup bowl in which the
problem concerns raising a soup bowl without spilling the soup  two actions  lift left and
lift right  can be applied to the bowl  if either is applied on its own the soup will spill  but 
it is argued  if they are applied simultaneously then the bowl is raised from the table and
no soup spills  shanahan considers this example within the event calculus  where he uses
an explicit assertion of the interaction between the lift left and lift right actions to ensure
that the spillage effect is cancelled when the pair is executed together  the assumption is
that the two actions can be executed at precisely the same moment and that the reasoner
can rely on the successful simultaneity in order to exploit the effect 
in pddl    we take the view that precise simultaneity is outside the control of any
physical executive  a plan is interpreted as an instruction to some executive system and
we hold that no executive system is capable of measuring time and controlling its activity
at arbitrarily fine degrees of accuracy  in particular  it is not possible for an executive to
ensure that two actions that must be independently initiated are executed simultaneously 
if a plan were to rely on such precision in measurement then  we claim  it could not be
executed with any reliable expectation of success and should not  therefore  be considered
a valid plan 
pddl    supports the modelling of the soup bowl situation in the following way  two
durative actions  lift left and lift right  both independently initiate tilting intervals which 
when complete  will result in spillage of the soup if their effects have not been counteracted 
provided that the two lift actions start within an appropriate tolerance of one another the
tilting will be corrected and the spillage avoided without the need to model cancellation
of effects  we argue that an executive can execute the two actions to within a fine but
non zero tolerance of one another  and can therefore successfully lift the bowl  the event
calculus model presented by shanahan insists on precise synchronization of the two actions 
incorrectly allowing it to be inferred that the soup will be spilled even if the time that
elapses between the two lifts is actually small enough to allow for correction of the tilting
of the bowl  worse  shanahans axioms would allow lack of precise synchronization to be
exploited to achieve spillage  using an amount of time smaller than that correctly describing
the physical situation being modelled 
if one considers it unnecessary to model the precise interaction between the two lifts 
one has the alternative in pddl    to abstract out the interaction and see the soup bowl
lifting action as a single discretized action that achieves the successful raising of the bowl 
     temporal extent
a common concern in temporal reasoning frameworks  discussed in detail by vila and
others  vila        van bentham         is the divided instant problem  this is the problem
that is apparent when considering what happens at the moment of transition from  say 
truth to falsity of a propositional variable  the question that must be addressed is whether
   

fifox   long

the proposition is true  false  undefined or inconsistently both true and false at the instant
of transition  clearly the last of these possibilities is undesirable  the solution we adopt is
a combination of the pragmatic and the philosophically principled  the pragmatic element
is that we choose to model actions as instantaneous transitions with effects beginning at the
instant of application  thus  the actions mark the end points of intervals of persistence of
state which are closed on the left and open on the right  this ensures that the intervals nest
together without inconsistency and the truth values of propositions are always defined  the
same half open half closed solution is adopted elsewhere  for example  shanahan       
observes that a similar approach is used in the event calculus  although there the intervals
are closed on the right  although the two choices are effectively equivalent  we slightly
prefer the closed on the left choice since this allows the validation of a plan to conclude
with the state at the point of execution of its final action  making the determination of the
temporal span of the plan unambiguous 
from a philosophical point of view the truth value of the proposition at the instant of
application of an action cannot be exploited by any other action  by virtue both of the
no moving targets rule and our position  outlined above  that a valid plan cannot depend
on precise synchronisation of actions  this forces actions that require a proposition as a
precondition to sit at the open end of a half open interval in which the proposition holds 
     planning with time
in classical planning models  time is treated as relative  that is  the only temporal structuring in a plan  and in reasoning about a plan  is in the ordering between actions  this is most
clearly emphasised by the issues that dominated planning research in the late     s and
early     s  when classical planning was mainly characterised by the exploration of partial
plan spaces  in planners such as tweak  chapman         snlp  mcallester   rosenblitt 
      and ucpop  penberthy   weld         partial plans include a collection of actions
representing the activity thus far determined to be part of a possible plan and a set of
temporal constraints on those actions  the temporal constraints used in a partial plan are
all of the form a   b where a and b are time points corresponding to the application of
actions 
classical linear planners  fikes   nilsson        russell   norvig        rely on the
simple fact that a total ordering on the points at which actions are applied can be trivially
embedded into a time line  again  the duration between actions is not considered  the role
of time in planning becomes far more significant once metric time is introduced  with metric
time it is possible to associate specific durations with actions  to set deadlines or windows
of opportunity  the problems associated with relative time have still to be resolved in a
metric time framework  but new problems are introduced  in particular  durations become
explicit  so it is necessary to decide what the durations attach to  actions or states  further 
explicit temporal extents make it more important to confront the issue of concurrency in
order to best exploit the measured temporal resources available to a planner 
in contrast to the simple ordering constraints required for relative time  metric time
requires more powerful constraint management  most metric time constraint handlers are
built around the foundations laid by dechter  meiri and pearl         for example  ixtet
uses extensions of temporal constraint networks  laborie   ghallab         the language
   

fipddl     expressing temporal planning domains

that ixtet uses to represent planning domains is similar to pddl    as described in this
paper  but more expressive because it allows access to time points within the interval of a
durative action  this added expressive power is obtained at the cost of increased semantic
complexity and  consequently  increased difficulty in the validation of plans  however  there
are many similarities between the modelling of discretised durative actions in pddl    and
in ixtet  and similar modelling conventions are also found in the languages of sapa  do  
kambhampati        and oplan  drabble   tate        
one of the earliest planners to consider the use of metric time was deviser  vere        
which was developed from nonlin  tate         in deviser  metric constraints on the times
at which actions could be applied and deadlines for the achievements of goals were both
expressible and the planner could construct plans respecting metric temporal constraints
on the interactions between actions  cesta and oddi        have explored various developments of temporal constraint network algorithms to achieve efficient implementation
for planning and galipienso and sanchis        consider extensions to manage disjunctive
temporal constraints efficiently  which is a particularly valuable expressive element for plan
construction as was observed above  since constraints preventing overlap of intervals translate into disjunctive constraints on time points  hsts  muscettola        also relies on a
temporal constraint manager 
in systems that use continuous real valued time it is possible to make use of linear
constraint solvers to handle temporal constraints  in particular  constraints dictated by
the relative placement of actions with durations on a timeline can be approached in this
way  long   fox      a   an alternative timeline that is often used is a discretised line
based on integers  the advantage of this approach is that it is possible to advance time
to a next value after considering activity at any given time point  the next modality can
be interpreted in a continuous time framework by taking it to mean the state following the
next logical change  regardless of the time at which this occurs  bacchus   kabanza        
in planning problems in which no events can occur other than the actions dictated by the
planner and no continuous change is modelled  plans are finite structures and therefore
change can occur at only a finite number of time points during its execution  this makes
it possible to embed the execution of the plan into the integer valued discrete time line
without any loss of expressiveness 
various researchers have considered the problem of modelling continuous change  pednault        proposes explicit description of the functions that govern the continuous change
of metric parameters  attached to actions that effect instantaneous change to initiate the
processes  however  his approach is not easy to use in describing interacting continuous
processes  for example  if water is filling a tank at a constant rate and then an additional
water source is added to increase the rate of filling then the action initiating the second
process must combine the effects of the two water sources  this means that the second
action cannot be described simply in terms of its direct effect on the world  to increase
the rate of flow into the tank  but with reference to the effects of other actions that
have already affected the rate of change of the parameter  shanahan        also uses this
approach  with the consequence that processes are modelled as stopping and then restarting
with new trajectories as each interacting action is applied 
in zeno  penberthy   weld         actions have effects that are described in terms of
derivatives  this approach makes it easier to describe interacting processes  but complicates
   

fifox   long

the management of processes by making it necessary to solve differential equations  the
complication has not deterred other authors from taking this approach  mcdermott       
takes this approach in his process planner 
the introduction of continuous processes into the planning problem represents a considerable complication  even over a model that includes temporal features and supports
concurrency  it is an area of active research and the community has not yet agreed on
matters of representation  let alone semantics  there remain many open problems for the
planning community to address  both in the development of languages and planning algorithms and also in in the development of plan verification tools that can embody a widely
accepted semantics 

    conclusions
recent developments in ai planning research have been leading the community closer to
the application of planning technology to realistic problems  this has necessitated the
development of a representation language capable of modelling domains with temporal and
metric features  the approach we have taken towards the development of such a language
is to extend mcdermotts pddl domain representation standard to support temporal and
metric models 
the development of the pddl sequence towards greater expressive power is important
to the planning community because pddl has provided a common foundation for a great
deal of recent research effort  the problems involved in modelling the behaviour of domains
with both discrete and continuous behaviours have been well explored in the temporal logic
and model checking communities but there have been no widely adopted models within
the planning community  our work on pddl    provides a way of making the relevant
developments in these communities accessible to planning  furthermore  pddl    begins
to bridge the gap between basic research and applications oriented planning by providing
the expressive power necessary to capture real problems 
pddl    has the expressive power to represent a class of deterministic mixed discretecontinuous domains as planning domains  the language introduces a form of durative action
based on three connected parts  the initiation of an interval in which numeric change
might occur and its explicit termination by means of an action that produces the state
corresponding to the end of the durative interval  this form of action allows the modelling
of both discrete and continuous behaviours  discretized change can be represented by
means of step functions  whilst continuous change can be modelled using the  t variable 
the language provides solutions to the critical issues of concurrency  continuous change
and temporal extent  the semantics of the language is derived from the familiar state
transition semantics of strips  extended to interpret invariants holding over intervals in
which continuous functions might also be active  our semantics allows us to interpret more
plans than we can efficiently validate  we describe the criteria that a plan must satisfy in
order to be practically verifiable 
this paper has focussed primarily on a discussion of the numeric and discretised temporal features of pddl     however  the modelling capability of discretized durative actions
is in some respects limited and it is important for the planning community to address the
challenges presented by continuous change  indeed  even using the continuous actions of
   

fipddl     expressing temporal planning domains

pddl    it is not possible to model episodes of change being terminated by spontaneous
events in the world rather than by the deliberate choice of the planner  the future goals
of the community should include addressing domains that require the continuous actions of
pddl     then confronting the challenges of planning within more dynamic environments in
which intervals of change can be terminated by the world as well as by the deliberate action
of the planner  this will constitute an important step towards planning within dynamic
and unpredictable environments 

acknowledgements
we would like to thank the members of the committee for the third international planning
competition  in particular  discussions with drew mcdermott  fahiem bacchus  david
smith and hector geffner in turns infuriated  intrigued and delighted us and contributed
immeasurably to the strengths of this paper  many others have offered comments and
insights that have allowed us to develop the work we present here  we would like to thank
jorg hoffmann  malte helmert  antonio garrido  stefan edelkamp  nicola muscettola 
mark boddy  keith golden  jeremy frank  ari jonsson  julie porteous  alex coddington 
stephen cresswell  luke murray  keith halsey and richard howey for the many helpful
discussions we have shared 

   

fifox   long

appendix a  bnf specification of pddl   
this appendix contains a complete bnf specification of the pddl    language  this is not
a strict superset of pddl  x  for example  the use of local variables within action schemas
has been left out of this specification  it is not a widely used part of the language and has
not been used in any of the competition domains  the interpretation of local variables as
proposed by mcdermott is subtle  since it demands confirmation that a unique instantiation
exists for each such variable  it is non trivial to confirm that this is the case during plan
validation for domains with significant expressive power and the fact that it has been largely
ignored suggests that it is poorly understood  other changes are discussed in the following
sections 
a   domains
domain structures remain essentially as specified in pddl  x  the main alterations are
to introduce a slightly modified syntax for numeric fluent expressions and to remove the
syntax for hierarchical expansions  the latter is not necessarily abandoned  but it has not 
to the best of our knowledge  been used in any publicly available planning systems or even
domains  in the original pddl specification  a distinction was drawn between strict pddl
and non strict pddl  where strict pddl must follow the ordering of the fields specified below 
while non strict pddl is not restricted in this way  in practice  there are relatively few fields
that it is intuitive to accept in arbitrary orders  it is natural to expect declarations to
precede use of symbols and for preconditions to precede effects  however  declarations of
constants  predicates and function symbols are not naturally ordered  so in the current
definition of pddl the ordering of all fields must follow the specification below  with the
exception of these three fields which are legal in any order with respect to one another 
although the group must follow types  if there are any  and precede action specifications 
 domain 

     define  domain  name  
  require def  
  types def   typing
  constants def  
  predicates def  
  functions def   fluents
 structure def   
 require def 
      requirements  require key    
 require key 
    see section a  
 types def 
      types  typed list  name   
 constants def 
      constants  typed list  name   
 predicates def 
      predicates  atomic formula skeleton    
 atomic formula skeleton 
      predicate   typed list  variable   
 predicate 
     name 
 variable 
      name 
 atomic function skeleton 
      function symbol   typed list  variable   
 function symbol 
     name 
 functions def 
    fluents   functions  function typed list
 atomic function skeleton   
 structure def 
     action def 
 structure def 
    durativeactions  durative action def 

   

fipddl     expressing temporal planning domains

a slight modification has been made to the type syntax  it is no longer possible to
nest either expressions  a possibility that was never exploited  but complicates parsing  
numbers are no longer considered to be an implicit type  the extension to numbers is now
handled only through functional expressions  this ensures that there are only finitely many
ground action instances  a desirable consequence is that action selection choice points need
never include choice over arbitrary numeric ranges  the use of finite ranges of integers
for specifying actions is useful  see mystery or freecell for example  and an extension of
the standard syntax to allow for a more convenient representation of these cases could be
useful  the syntax of function declarations allows functions to be declared with types  at
present the syntax is restricted to number types  since we do not have a semantics for other
functions  but the syntax offers scope for possible extension  where types are not given for
the function results they are assumed to be numbers 
 typed list  x  
 typed list  x  
 primitive type 
 type 
 type 

    x
    typing x     type   typed list x  
     name 
     either  primitive type    
     primitive type 

 function typed list  x       x
 function typed list  x       typing x     function type 
 function typed list x  
 function type 
    number

a   actions
the bnf for an action definition is given below  again  this has been simplified by removing
generally unused constructs  mainly hierarchical expansions   it should be emphasised that
this removal is not intended to be a permanent exclusion  hierarchical expansion syntax
has proved a difficult element of the language both to agree on and to exploit  as the other
levels of the language stabilise we hope to return to this layer and redevelop it 
 action def 

      action  action symbol 
 parameters    typed list  variable    
 action def body  
 action symbol 
     name 
 action def body        precondition  gd  
  effect  effect  

goal descriptions have been extended to include fluent expressions 
 gd 
 gd 
 gd 
 gd 

      
     atomic formula term  
    negativepreconditions  literal term  
     and  gd   

   

fifox   long

 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 f comp 
 literal t  
 literal t  
 atomic formula t  
 term 
 term 
 f exp 
 f exp 
 f exp 
 f exp 
 f head 
 f head 
 binary op 
 binary op 
 binary op 
 binary op 
 binary comp 
 binary comp 
 binary comp 
 binary comp 
 binary comp 
 number 

    disjunctivepreconditions  or  gd   
    disjunctivepreconditions  not  gd  
    disjunctivepreconditions  imply  gd   gd  
    existentialpreconditions
 exists   typed list variable      gd   
 universalpreconditions
   
 forall   typed list variable      gd   
 fluents
   
 f comp 
      binary comp   f exp   f exp  
     atomic formula t  
     not  atomic formula t   
      predicate  t  
     name 
     variable 
     number 
      binary op   f exp   f exp  
        f exp  
     f head 
      function symbol   term   
     function symbol 
     
    
    
     
     
     
     
      
      
    any numeric literal
 integers and floats of form n n  

effects have been extended to include functional expression updates  the syntax proposed here is a little different from the syntax proposed in the earlier version of pddl  the
syntax of conditional effects proposed by fahiem bacchus for aips      has been adopted 
in which the nesting of conditional effects is not supported  the assignment operators are
prefix forms  simple assignment is called assign  previously this was change  and operators corresponding to c update assignments              and     are given the names
increase  decrease  scale up and scale down respectively  the prefix form has been
adopted in preference to an infix form in order to preserve consistency with the lisp like
syntax and the non c names to help the c and c   programmers to remember that the
operators are to be used in prefix form   we prefer assign to the original change because
the introduction of increase and so on makes the nature of a change more ambiguous 
 effect 
 effect 
 effect 
 c effect 
 c effect 
 c effect 
 p effect 
 p effect 
 p effect 

      
     and  c effect   
     c effect 
    conditionaleffects  forall   variable     effect  
    conditionaleffects  when  gd   cond effect  
     p effect 
      assign op   f head   f exp  
     not  atomic formula term   
     atomic formula term  

   

fipddl     expressing temporal planning domains

 p effect 
 cond effect 
 cond effect 
 assign op 
 assign op 
 assign op 
 assign op 
 assign op 

    fluents   assign op   f head   f exp  
     and  p effect   
     p effect 
    assign
    scale up
    scale down
    increase
    decrease

a   durative actions
durative action syntax is built on a relatively conservative extension of the existing action
syntax 
 durative action def        durative action  da symbol 
 parameters    typed list  variable    
 da def body  
 da symbol 
     name 
 da def body 
     duration  duration constraint 
 condition  da gd 
 effect  da effect 

the conditions under which a durative action can be executed are more complex than for
standard actions  in that they specify more than the conditions that must hold at the point
of execution  they also specify the conditions that must hold throughout the duration of the
durative action and also at its termination  to distinguish these components we introduce a
simple temporal qualifier for the preconditions  the use of the name precondition would
be somewhat misleading given that the conditions described can include constraints on what
must hold after the action has begun  this has motivated the adoption of  condition
to describe the collection of constraints that must hold in order to successfully apply a
durative action  the logical form of conditions for durative actions has been restricted
to conjunctions of temporally annotated expressions  but there is clearly scope for future
extension to allow more complex formulae 
 da gd 
 da gd 
 da gd 
 timed gd 
 timed gd 
 time specifier 
 time specifier 
 interval 

   
   
   
   
   
   
   
   

  
 timed gd 
 and  timed gd    
 at  time specifier   gd  
 over  interval   gd  
start
end
all

the duration   duration  of a durative action can be specified to be equal to a given
expression  which can be a function of numeric expressions   or else it can be constrained
with inequalities  this latter allows for actions where the conclusion of the action can
be freely determined by the executive without necessarily having further side effects  for
example  a walk between two locations could be made to take as long as the executive
   

fifox   long

considered convenient  provided it was at least as long as the time taken to walk between
the locations at the fastest walking speed possible  constraints that do not specify the
exact duration of a durative action might prove harder to handle  so we have introduced a
label   duration inequalities  to signal that a domain makes use of them  a duration
constraint is supplied to dictate or limit the temporal extent of the durative action  the
duration is an implicit parameter of the durative action and must be supplied in a plan
that uses durative actions  to denote this  a durative action is denoted in a plan by
t  name arg    argn  d  where d is the  non negative  rational valued  duration in
floating point format  n n   duration constraints can be explicitly temporally annotated to
indicate that they should be evaluated in the context of the start or end point of the action 
or else they can be left unannotated  in which case the default is that they are evaluated in
the context at the start of the action  as indicated in definition     
 duration constraint 
 duration constraint 
 duration constraint 
 simple duration constraint 
 simple duration constraint 
 d op 
 d op 
 d op 
 d value 
 d value 

   

 durationinequalities

 and  simple duration constraint    
  
 simple duration constraint 
  d op   duration  d value  
 at  time specifier 
 simple duration constraint  
    durationinequalities   
    durationinequalities   
     
     number 
    fluents  f exp 
   
   
   
   

in addition to logical effects  which can occur at the start or end of a durative action 
durative actions can have numeric effects that refer to the literal  duration  more sophisticated durative actions can also make use of functional expressions describing effects that
occur over the duration of the action  this allows functional expressions to be updated by
a continuous function of time  rather than only step functions 
 da effect 
 da effect 
 da effect 
 da effect 
 da effect 
 da effect 
 timed effect 
 timed effect 
 timed effect 
 f assign da 
 f exp da 
 f exp da 
 f exp da 
 f exp da 

      
     and  da effect   
     timed effect 
    conditionaleffects  forall   variable     da effect  
    conditionaleffects  when  da gd   timed effect  
    fluents   assign op   f head   f exp da  
     at  time specifier   a effect  
     at  time specifier   f assign da  
    continuouseffects   assign op t   f head   f exp t  
      assign op   f head   f exp da  
      binary op   f exp da   f exp da  
        f exp da  
    durationinequalities  duration
     f exp 

note that the  duration term can only be used to define functional expression updating
effects if the duration constraints requirement is set  this is because in other cases the
duration value is available as an expression  whereas when duration constraints are provided
the duration can  sometimes  be freely selected within constrained boundaries 
   

fipddl     expressing temporal planning domains

 assign op t 
 assign op t 
 f exp t 
 f exp t 
 f exp t 

   
   
   
   
   

increase
decrease
    f exp   t 
    t  f exp  
 t

the symbol  t is used to represent the period of time that a given durative action has
been active  it is therefore a local clock value for each duration  independent of similar
clocks for each other duration  there has been discussion with members of the committee
about the use of the expression using  t  it was proposed that an expression declaring
the rate of change alone could be used  we decided against this on the grounds that the
assertion of a rate of change suggests that the rate of change is determined by one process
effect alone  in fact  it is intended that if multiple active processes affect the same fluent
then these effects are accumulated  using the expression that directly defines the amount
by which each process contributes to the change in a fluent value over time we do not appear
to assert  inconsistently  that a fluent has multiple simultaneous rates of change 
a   problems
planning problems specifications have been modified to exclude several generally unused
constructs  named initial situations and expansion information   we have removed the
length specification because it is at odds with the intention to supply physics  not advice 
furthermore  the advice this field offers over emphasises a very coarse plan metric  instead 
we have introduced an optional metric field  which can be used to supply an expression that
should be optimized in the construction of a plan  the field states whether the metric is
to be minimized or maximized  of course  a planner is free to ignore this field and make
the assumption that plans with fewest steps will be considered good plans  however  we
consider this extension to be a crucial one in the development of a more widely applicable
planning language  we have provided the variable total time that takes the value of the
total execution time for the plan  this allows us to conveniently express the intention to
minimize total execution time 
we anticipate that extensions of the plan metric syntax will prove necessary in the
longer term  but believe that this version already provides a significant new challenge to
the community  problem specifications are still somewhat impoverished in terms of the
ability to easily specify temporal constraints on goals and other non standard features of
initial and goal states  again  we anticipate the need for extension  but have chosen to leave
a clean sheet for future developments 
 problem 

     define  problem  name  
  domain  name  
  require def  
  object declaration   
 init 
 goal 
  metric spec  
  length spec    
 object declaration        objects  typed list  name   
 init 
      init  init el   
 init el 
     literal name  

   

fifox   long

 init el 
 goal 
 metric spec 
 optimization 
 optimization 
 ground f exp 
 ground f exp 
 ground f exp 
 ground f exp 
 ground f exp 
 ground f exp 
 length spec 

    fluents     f head   number  
      goal  gd  
      metric  optimization   ground f exp  
    minimize
    maximize
      binary op   ground f exp   ground f exp  
        ground f exp  
     number 
      function symbol   name   
    total time
     function symbol 
      length    serial  integer   
   parallel  integer    
the length spec is deprecated 

a   requirements
here is a table of all requirements in pddl     some requirements imply others  some are
abbreviations for common sets of requirements  if a domain stipulates no requirements  it
is assumed to declare a requirement for  strips 
requirement
 strips
 typing
 negative preconditions
 disjunctive preconditions
 equality
 existential preconditions
 universal preconditions
 quantified preconditions
 conditional effects
 fluents
 adl

 durative actions
 duration inequalities
 continuous effects

description
basic strips style adds and deletes
allow type names in declarations of variables
allow not in goal descriptions
allow or in goal descriptions
support   as built in predicate
allow exists in goal descriptions
allow forall in goal descriptions
   existential preconditions
   universal preconditions
allow when in action effects
allow function definitions and use of effects using
assignment operators and arithmetic preconditions 
   strips    typing
   negative preconditions
   disjunctive preconditions
   equality
   quantified preconditions
   conditional effects
allows durative actions 
note that this does not imply  fluents 
allows duration constraints in durative
actions using inequalities 
allows durative actions to affect fluents
continuously over the duration of the actions 

   

fipddl     expressing temporal planning domains

references
allen  j          towards a general theory of action and time  artificial intelligence     
       
allen  j          planning as temporal reasoning  in proceedings of kr     pp      
bacchus  f     ady  m          planning with resources and concurrency  a forward chaining approach  in proceedings of ijcai    pp         
bacchus  f     kabanza  f          planning for temporally extended goals  annals of
mathematics and artificial intelligence          
bacchus  f     kabanza  f          using temporal logic to express search control knowledge
for planning  artificial intelligence                   
bacchus  f   tenenberg  j     koomen  j          a non reified temporal logic for ai 
artificial intelligence            
blum  a     furst  m          fast planning through plan graph analysis  in proceedings
of ijcai    
cesta  a     oddi  a          gaining efficiency and flexibility in the simple temporal problem  in chittaro  l   goodwin  s   hamilton  h     montanari  a   eds    proceedings
of time   
chapman  d          planning for conjunctive goals  artificial intelligence             
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence     
do  m  b     kambhampati  s          sapa  a domain independent heuristic metric temporal planner  in proceedings of ecp    
drabble  b     tate  a          the use of optimistic and pessimistic resource profiles to
inform search in an activity based planner  in proceedings of aips     aaai press 
el kholy  a     richards  b          temporal and resource reasoning in planning  the
parcplan approach  in proceedings of ecai   
fikes  r     nilsson  n          strips  a new approach to the application of theoremproving to problem solving  artificial intelligence                
fox  m     long  d          pddl    planning with time and metric resources  tech 
rep  department of computer science         university of durham  uk  available
at  http   www dur ac uk d p long competition html 
galipienso  m     sanchis  f          representation and reasoning with disjunction temporal constraints  in proceedings of time   
garrido  a   onainda  e     barber  f          time optimal planning in temporal problems  in proceedings of ecp   
gazen  b     knoblock  c          combining the expressivity of ucpop with the efficiency
of graphplan  in proceedings of ecp     pp         
gelfond  m   lifschitz  v     rabinov  a          what are the limitations of the situation
calculus   in boyer  r   ed    essays in honor of woody bledsoe  pp          kluwer
academic 
   

fifox   long

ghallab  m     laruelle  h          representation and control in ixtet  a temporal
planner  in proceedings of aips   
gupta  v   henziner  t     jagadeesan  r          robust timed automata  in hart    
hybrid and real time systems  lncs       pp          springer verlag 
haslum  p     geffner  h          heuristic planning with time and resources  in proceedings
of ecp    toledo 
hayes  p     allen  j          short time periods  in proceedings of ijcai     pp         
helmert  m          decidability and undecidability results for planning with numerical
state variables  in proceedings of aips    
henzinger  t          the theory of hybrid automata  in proceedings of the   th annual symposium on logic in computer science  invited tutorial   pp          ieee
computer society press 
henzinger  t     raskin  j  f          robust undecidability of timed and hybrid systems 
in proceedings of the  rd international workshop on hybrid systems  computation
and control  lncs        pp          springer verlag 
howey  r     long  d          validating plans with continuous effects  tech  rep   dept 
computer science  university of durham 
jonsson  a   morris  p   muscettola  n     rajan  k          planning in interplanetary
space  theory and practice  in proceedings of aips    
kowalski  r     sergot  m          a logic based calculus of events  new generation
computing          
laborie  p     ghallab  m          planning with sharable resource constraints  in proceedings of ijcai     morgan kaufmann 
lifschitz  e          on the semantics of strips  in proceedings of      workshop 
reasoning about actions and plans 
long  d     fox  m       a   exploiting a graphplan framework in temporal planning  in
proceedings of icaps   
long  d     fox  m       b   an overview and analysis of the results of the  rd international
planning competition  journal of artifical intelligence research  this issue 
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings of
aaai    vol     pp          anaheim  california  usa  aaai press mit press 
mccarthy  j          circumscription  a form of non monotonic reasoning  artificial
intelligence           
mccarthy  j     hayes  p          some philosophical problems from the standpoint of
artificial intelligence  in meltzer  b     michie  d   eds    machine intelligence    pp 
        edinburgh university press 
mcdermott  d          a temporal logic for reasoning about processes and plans  cognitive
science            
mcdermott  d          the      ai planning systems competition  ai magazine         
   

fipddl     expressing temporal planning domains

mcdermott  d          reasoning about autonomous processes in an estimated regression
planner  in proceedings of icaps    
mcdermott  d     the aips    planning competition committee        
pddlthe planning domain definition language 
tech  rep   available at 
www cs yale edu homes dvm 
muscettola  n          hsts  integrating planning and scheduling  in zweben  m     fox 
m   eds    intelligent scheduling  pp          morgan kaufmann  san mateo  ca 
nau  d   cao  y   lotem  a     munoz avila  h          shop  simple hierarchical ordered
planner  in proceedings of ijcai   
pednault  e          formulating multiagent  dynamic world problems in the classical planning framework  in georgeff  m     lansky  a   eds    proceedings of the timberline
oregon workshop on reasoning about actions and plans 
pednault  e          adl  exploring the middle ground between strips and the situation
calculus  in proceedings of kr     pp         
penberthy  j     weld  d          temporal planning with continuous change  in proceedings
of aaai     aaai mit press 
penberthy  j     weld  d          ucpop  a sound  complete  partial order planner for
adl  in proceedings of kr    pp          los altos  ca  kaufmann 
rabideau  g   knight  r   chien  s   fukunaga  a     govindjee  a          iterative repair
planning for spacecraft operations in the aspen system  in international symposium
on artificial intelligence robotics and automation in space  i sairas  
reichgelt  h          a comparison of first order and modal theories of time  in jackson 
p   reichgelt  h     van harmelen  f   eds    logic based knowledge representation 
pp          mit press 
reiter  r          a logic for default reasoning  artificial intelligence            
russell  s     norvig  p          artificial intelligence  a modern approach  prentice hall 
sandewall  e          features and fluents  the representation of knowledge about dynamical
systems  volume i  oxford university press 
shanahan  m          representing continuous change in the event calculus  in proceedings
of ecai    pp         
shanahan  m          the event calculus explained  in wooldridge  m     veloso  m 
 eds    artificial intelligence today  pp          springer lecture notes in artificial
intelligence no       
shoham  y          ten requirements for a theory of change  new generation computing 
          
smith  d     weld  d          temporal planning with mutual exclusion reasoning  in
proceedings of ijcai     stockholm  pp         
tate  a          generating project networks  in proceedings of ijcai   
van bentham  j          the logic of time  kluwer academic press  dordrecht 
   

fifox   long

vere  s          planning in time  windows and durations for activities and goals  ieee
transactions on pattern analysis and machine intelligence    
vila  l          a survey on temporal reasoning in artificial intelligence  ai communications         
wilkins  d          practical planning  extending the classical ai planning paradigm 
morgan kaufmann publishers inc   san francisco  ca 

   

fi