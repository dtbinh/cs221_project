journal of artificial intelligence research                  

submitted        published      

shop   an htn planning system
dana nau

nau cs umd edu

dept  of computer science  and institute for systems research
university of maryland  college park  md       usa

tsz chiu au

chiu cs umd edu

dept  of computer science
university of maryland  college park  md       usa

okhtay ilghami

okhtay cs umd edu

dept  of computer science
university of maryland  college park  md       usa

ugur kuter

ukuter cs umd edu

dept  of computer science
university of maryland  college park  md       usa

j  william murdock

murdockj us ibm com

ibm watson research center
   skyline dr 
hawthorne  ny       usa

dan wu

dandan cs umd edu

dept  of computer science
university of maryland  college park  md       usa

fusun yaman

fusun cs umd edu

dept  of computer science
university of maryland  college park  md       usa

abstract
the shop  planning system received one of the awards for distinguished performance
in the      international planning competition  this paper describes the features of
shop  which enabled it to excel in the competition  especially those aspects of shop 
that deal with temporal and metric planning domains 

   introduction
shop   simple hierarchical ordered planner    nau  munoz avila  cao  lotem    mitchell 
       is a domain independent planning system based on hierarchical task network  htn 
planning  in the      international planning competition  shop  received one of the top
four awards  one of the two awards for distinguished performance  this paper describes
some of the characteristics of shop  that enabled it to excel in the competition 
like its predecessor shop  nau  cao    munoz avila         shop  generates the
steps of each plan in the same order that those steps will later be executed  so it knows
the current state at each step of the planning process  this reduces the complexity of
reasoning by eliminating a great deal of uncertainty about the world  thereby making it
easy to incorporate substantial expressive power into the planning system  like shop 
c
    
ai access foundation  all rights reserved 

finau  au  ilghami  kuter  murdock  wu    yaman

shop  can do axiomatic inference  mixed symbolic numeric computations  and calls to
external programs 
shop  also has capabilities that go significantly beyond those of shop 
 shop  allows tasks and subtasks to be partially ordered  thus plans may interleave
subtasks from different tasks  this often makes it possible to specify domain knowledge in a more intuitive manner than was possible in shop 
 shop  incorporates many features from pddl  such as quantifiers and conditional
effects 
 if there are alternative ways to satisfy a methods precondition  shop  can sort the
alternatives according to a criterion specified in the definition of the method  this
gives a convenient way for the author of a planning domain to tell shop  which parts
of the search space to explore first  in principle  such a technique could be used with
any planner that plans forward from the initial state 
 so that shop  can handle temporal planning domains  we have a way to translate
temporal pddl operators into shop  operators that maintain bookkeeping information for multiple timelines within the current state  in principle  this technique
could be used with any non temporal planner that has sufficient expressive power 
the rest of this paper is organized as follows  section   gives some background on htn
planning  and section   describes shop s features and planning algorithm  section  
describes how to write domain descriptions for shop   in particular  section     discusses
basic problem solving strategies  and sections     and     describe aspects of shop  that
are specific to handling temporal and metric domain features  section   discusses shop s
performance in the competition  section   discusses related work  and section   gives a
summary and conclusion  appendix a contains a shop  domain description for one of the
problem domains in the planning competition 

   htn planning
htn planning is like classical ai planning in that each state of the world is represented by
a set of atoms  and each action corresponds to a deterministic state transition  however 
htn planners differ from classical ai planners in what they plan for  and how they plan
for it 
the objective of an htn planner is to produce a sequence of actions that perform some
activity or task  the description of a planning domain includes a set of operators similar
to those of classical planning  and also a set of methods  each of which is a prescription for
how to decompose a task into subtasks  smaller tasks   figure   gives a simple example 
given a planning domain  the description of a planning problem will contain an initial state
like that of classical planningbut instead of a goal formula  the problem specification will
contain a partially ordered set of tasks to accomplish 
planning proceeds by using the methods to decompose tasks recursively into smaller
and smaller subtasks  until the planner reaches primitive tasks that can be performed directly using the planning operators  for each nonprimitive task  the planner chooses an
   

fishop   an htn planning system

task 
preconditions 

task 

 transport  p 

 at  p  x 
 destination p  y 
 available truck  t 

 transport two  p  q 

preconditions 

subtasks 

 package  p 
 package  q 

subtasks 

 dispatch  t  x   load  t  p   move  t  x  y   return  t  x 

task 

 transport  p   transport  q 

task 

 dispatch  t  x 

subtasks   reserve  t   move  t home  x 

 return  t  x 

subtasks   move  t  x home 

 free  t 

figure    methods for transporting a package  p  transporting two packages  p and  q 
dispatching a truck  t  and returning the truck  arrows are ordering constraints 
the shaded subtasks are primitive tasks that are accomplished by the following
planning operators   load  t  p  loads  p onto  t   move  t  x  y  moves  t from
 x to  y   reserve  t  deletes  available truck  t  to signal that the truck is in use 
 free  t  adds  available truck  t  to signal that the truck is no longer in use 

 transport two p  p  
 package p  
 package p  

 transport p  

 transport p  
 at p  l  
 destination p  l  
 available truck t  

 dispatch t  l  

 dispatch t  l  

 load t  p  
 reserve t  

 at p  l  
 destination p  l  
 available truck t  

 return t  l  
 load t  p  

 move t  l  l  

 reserve t  

 move t  home l  

 move t  home l  

 return t  l  

 move t  l  l  
 free t  

 move t  l  home 

 free t  
 move t  l  home 

figure    a plan for accomplishing  transport two p  p   from the following initial state 
  package p     at p  l     destination p  l     available truck t     at t  home  
 package p     at p  l     destination p  l     available truck t     at t  home   
   

finau  au  ilghami  kuter  murdock  wu    yaman

applicable method  instantiates it to decompose the task into subtasks  and then chooses
and instantiates methods to decompose the subtasks even further  as illustrated in figure   
if the plan later turns out to be infeasible  the planning system will need to backtrack and
try other methods 
htn methods generally describe the standard operating procedures that one would
normally use to perform tasks in some domain  e g   see figure    most htn practitioners
would argue that such representations are more appropriate for many real world domains
than are classical planning operators  as they better characterize the way that users think
about problems 
like most other htn planners  shop  is hand tailorable  its planning engine is
domain independent  but the htn methods may be domain specific  and the planner can
be customized to work in different problem domains by giving it different sets of htn
methods  the ability to use domain specific problem solving knowledge can dramatically
improve a planners performance  and sometimes make the difference between solving a
problem in exponential time and solving it in polynomial time  e g   gupta   nau       
slaney   thiebaux         in experimental studies  e g   nau et al               bacchus
  kabanza         hand tailorable planners have quickly solved planning problems orders
of magnitude more complicated than those typically solved by fully automated planning
systems in which the domain specific knowledge consists only of the planning operators 

   features of shop 
this section describes shop s planning algorithm and some of shop s distinctive features 
    basic elements of a domain description
a domain description is a description of a planning domain  consisting of a set of methods 
operators  and axioms  below we describe each of these briefly  additional details appear
in section   
      tasks
a task represents an activity to perform  syntactically  a task consists of a task symbol
followed by a list of arguments  a task may be either primitive or compound  a primitive
task is one that is supposed to be accomplished by a planning operator  the task symbol
is the name of the planning operator to use  and the tasks arguments are the parameters
for the operator  a compound task is one that needs to be decomposed into smaller tasks
using a method  any method whose head unifies with the task symbol and its arguments
may potentially be applicable for decomposing the task  the details are discussed in the
following subsections 
      operators
each operator indicates how a primitive task can be performed  the operators are very
similar to pddl operators  each operator o has a head head o  consisting of the operators
name and a list of parameters  a precondition expression pre o  indicating what should be
   

fishop   an htn planning system

  method
  head
 transport person  p  c  
  precondition
 and
 at  p  c  
 aircraft  a 
 at  a  c  
 different  c   c   
  subtasks
  ordered
 move aircraft  a  c  
 board  p  a  c  
 move aircraft  a  c  
 debark  p  a  c    
figure    a shop  method for a simplified version of the zenotravel domain 
true in the current state in order for the operator to be applicable  and a delete list del o 
and add list add o  giving the operators negative and positive effects  like in pddl  the
preconditions and effects may include logical connectives and quantifiers  the operators
also can do numeric computations and assignments to local variables  an example appears
later in figure      just as in pddl  no two operators can have the same name  thus for
each primitive task  all applicable actions are instances of the same operator 
each operator also has an optional cost expression  the default value is     this expression can be arbitrarily complicated and can use any of the variables that appear in the
operators head and precondition  the cost of a plan is the sum of the costs of the operator
instances 
      methods
each method indicates how to decompose a compound task into a partially ordered set of
subtasks  each of which can be compound or primitive  the simplest version of a method
has three parts  the task for which the method is to be used  the precondition that the
current state must satisfy in order for the method to be applicable  and the subtasks that
need to be accomplished in order to accomplish that task 
as an example  figure   is a simplified version of a shop  method for one of the
domains in the aips      planning competition  the zenotravel domain  this method
gives a way to transport a person  p by aircraft from one location  c  to another location
 c  if the aircraft is not already at  c    the  ordered keyword specifies that the subtasks
are totally ordered  first move the aircraft to  c   then board the person  then move the
aircraft to  c   then debark the person   to specify an unordered set of subtasks  we would
   any symbol that begins with a question mark is a variable name 
   the method in the figure would have the same meaning if  ordered were omitted  if the list of subtasks
does not begin with  ordered or  unordered  shop  assumes  ordered 

   

finau  au  ilghami  kuter  murdock  wu    yaman

    head
 enough fuel  plane  current position  destination  speed 
  tail
 and  distance  current position  destination  dist 
 fuel  plane  fuel level 
 fuel burn  speed  rate 
 eval      fuel level     rate  dist     
figure    a shop  axiom for a simplified version of the zenotravel domain 
use the keyword  unordered rather than  ordered  more complicated partial orderings can be
specified using nested combinations of  ordered and  unordered  
more generally  a method m may have the form
  method head m  p  t  p  t         
where head m  is a task called the head of m  each pi is a precondition expression and each
ti is a partially ordered set of subtasks  the meaning of this is analogous to an if then else 
it tells shop  that if p  is satisfied then t  should be used  otherwise if p  is satisfied then
t  should be used  and so forth  to keep the descriptions in this paper simple  we will
assume without loss of generality that there is only one precondition expression pre m  and
one set of subtasks sub m  
in general  there may be several alternative ways of accomplishing head m   there may
be more than one method whose head is head m   more than one set of variable bindings
that satisfy pre m   more than one ordering consistent with sub m   or more than one
possible way to accomplish some of the subtasks in sub m   these alternatives produce
branches in shop s search space 
      axioms
the precondition of each method or operator may include conjunctions  disjunctions  negations  universal and existential quantifiers  implications  numerical computations  and external function calls  furthermore  axioms can be used to infer preconditions that are not
explicitly asserted in the current state  the axioms are generalized versions of horn clauses 
written in a lisp like syntax  for example      head tail  says that head is true if tail is true 
the tail of the clause may contain anything that may appear in the precondition of an
operator or method 
as an example  the axiom shown in figure   says that a plane has enough fuel to reach
 destination if the following conditions are satisfied  the distance to travel is  dist  the fuel
level is  fuel level  the burn rate is  rate  and  fuel level is not less than the product of  rate
and  distance  the last of these conditions is handled using an external function call  as
described below 
   this notation does not allow every possible possible partial ordering  but that has not been a problem
in practice  and this notation is less clumsy than those that allow every possible partial ordering 

   

fishop   an htn planning system

procedure shop  s  t  d 
p   the empty plan
t    t  t   no other task in t is constrained to precede t 
loop
if t    then return p
nondeterministically choose any t  t 
if t is a primitive task then
a    a      a is a ground instance of an operator in d   is a substitution that unifies  head a   t   and s satisfies as preconditions 
if a    then return failure
nondeterministically choose a pair  a     a
modify s by deleting del a  and adding add a 
append a to p
modify t by removing t and applying 
t    t  t   no task in t is constrained to precede t 
else
m    m      m is an instance of a method in d   unifies  head m   t  
pre m  is true in s  and m and  are as general as possible 
if m    then return failure
nondeterministically choose a pair  m     m
modify t by removing t  adding sub m   constraining each task
in sub m  to precede the tasks that t preceded  and applying 
if sub m      then
t    t  sub m    no task in t is constrained to precede t 
else t    t  t   no task in t is constrained to precede t 
repeat
end shop 
figure    a simplified version of the shop  planning procedure 

if the tail of a clause  or the precondition of an operator or method  contains a negation 
it is handled in the same way as in prolog  the theorem prover takes  not a  to be true if
it cannot prove a 

      external function calls
external function calls are useful  for example  to do numeric evaluations  e g   in the
zenotravel domain  to check the requirement that the available fuel must be greater than
or equal to the product of the burn rate and the distance to be traveled   for example  in
the competition  shop  used a graph algorithm library to compute the shortest paths in
a graph  in principle  it would be possible to implement the graph algorithms as a set of
methods  however  writing them as external functions allows them to run faster  and also
makes it possible to access predefined code libraries 
   

finau  au  ilghami  kuter  murdock  wu    yaman

    the shop  algorithm
figure   shows a simplified version of the shop  planning procedure  the arguments
include the initial state s  a partially ordered set of tasks t   and a domain description d 
as we mentioned earlier  shop  plans for tasks in the same order that they will be
executed  in order to do this  it nondeterministically chooses a task t  t that has no
predecessors  t is the first task that shop  will start working on  at this point  there are
two cases 
the first case is if t is primitive  i e   if t can be accomplished directly using an action
 i e   an instance of a planning operator   in this case  shop  finds an action a that
matches t and whose preconditions are satisfied in s  and applies a to s  if no such action
exists  then this branch of the search space fails  
the second case is where t is compound  i e   a method needs to be applied to t to
decompose it into subtasks  in this case  shop  nondeterministically chooses a method
instance m that will decompose t into subtasks  if no such method instance exists  then this
branch of the search space fails  
if there is a solution plan that involves m  then the actions in p will be the leaf nodes
of a decomposition tree dp such as the tree shown in figure    the precondition formula
pre m  must be true in the state that immediately precedes the first action a in dp that is
a descendant of m  in order to ensure that pre m  is true in the correct state  shop  needs
to generate the leftmost branch of d all the way down to the bottom  and evaluate pre m 
in the state just before a  the last three lines of the loop ensure that this will happen  by
telling shop  that if the current method m has any subtasks  shop  should generate one
of those subtasks before generating any other subtasks in the task network 
for example  shop  could begin generating the plan in figure   by first decomposing
 transport two p  p   into  transport p   and  transport p    and then nondeterministically
choosing to decompose  transport p   into   dispatch t  l     pickup t  p     move t  l 
l     having done that  shop  would be required to decompose  dispatch t  l    before
decomposing  transport p    in order to guarantee that  dispatch t  l   and  reserve t  
occur in the same state of the world in which  available t   was evaluated  the operator
for  reserve t   makes t  unavailable  thus ensuring that when  transport p   is decomposed
later  the decomposition will use truck t  rather than t  
    additional features
shop  has several additional features in addition to the basic ones described earlier  this
section describes the most significant ones 
      sorting the variable bindings
when shop  evaluates a methods precondition  it gets a list of all of the possible sets
of variable bindings that satisfy the expression in the current state  each set of variable
bindings can lead to a different branch in shop s search tree  this nondeterministic choice
is implemented in shop  via depth first backtracking  for shop  to find a good solution
and to find it quickly  it is important to decide which set of variable bindings to try first 
for this purpose  shop  has a sort by construct that sorts the list of variable bindings by a specified criterion  this is especially useful when the planning problem is an
   

fishop   an htn planning system

  method
  head
 transport person  p  c  
  precondition
  sort by  cost   
 and  at  p  c  
 aircraft  a 
 at  a  c  
 different  c   c  
 cost of  a  c   c   cost   
  subtasks
  move aircraft  a  c  
 board  p  a  c  
 move aircraft  a  c  
 debark  p  a  c    
figure    using sort by in a shop  method for the simplified zenotravel domain 
optimization problem  e g   a problem in which the objective is to find a plan having the
least possible cost  with the sort by construct  we can write a heuristic function to estimate
the anticipated cost of each set of variable bindings  and sort the sets of variable bindings
according to their heuristic function values so that shop  will try most promising one first 
for example  if we have the precondition
 and  at  here   distance  here  there  d  
then there may be several different combinations of  here   there  and  d that satisfy this
precondition  the expression
  sort by  d     and  at  here   distance  here  there  d   
will cause shop  to consider the variable bindings in decreasing order of the value of  d 
as a more complicated example  recall the precondition of the method in figure   
there may be several sets of variable bindings that satisfy this precondition in the current
state  the reformulation of the precondition in figure   tells shop  to sort the sets of
variable bindings in increasing order of the  cost variable  this way  shop  will look first
at the alternative that has the lowest  cost value 
      branch and bound optimization
shop  allows the option of using branch and bound optimization to search for a leastcost plan  this option generally results in spending additional planning time in order to
search for plans of superior quality  when using the branch and bound option  one can also
specify a time limit for the search  if the search takes longer than the time limit  shop 
terminates the search and returns the best plan it has found so far  this functionality was
partly inspired by anytime algorithms  boddy   dean        
   

finau  au  ilghami  kuter  murdock  wu    yaman

      pddl operator translation
shop s planning procedure can be proved to be sound and complete across a large set of
planning problems  in the sense that if a set of methods and operators is capable of generating a solution for some problem  then the planning procedure is guaranteed to generate
a correct plan  nau et al          however  while such a proof tells us that the planning
algorithm should work correctly if the domain description is correct  it does not tell us
whether our domain description represents the same planning domain as a given set of
pddl planning operators 
in the aips      planning competition  that problem caused difficulty for shop s
predecessor shop  the shop team was developing domain descriptions for shop purely
by hand  and made some mistakes in writing two of the domains  thus shop found
incorrect solutions for some of the problems in those domains  so the judges disqualified
shop from those domains 
while developing shop   we wrote a translator program to translate pddl operators
into shop  domain descriptions  the domain descriptions produced by the translator
program are not sufficient for efficient planning with shop   they need to be modified by
hand in order to put in the domain knowledge  as described in section    however  the
translator program can at least provide a correct starting point 

      debugging facilities
shop  also includes several debugging facilities  the most important of these is a tracing
mechanism  one can tell shop  to trace any set of operators  methods  and axioms  for
example  in figure    we have given names  namely case  and case   to the two different
clauses of a method  we can tell shop  to trace either of these clauses or both of them 
shop  will print messages each time it enters and exits a clause that is being traced 
depending on the particular tracing options that one selects  the messages may include
things such as the argument list  the current state of the world  and information about
whether the operator  method or axiom succeeds or fails 

      protected conditions and anti interleaving
shop s planning operators include a way to specify protected conditions  this feature is
described briefly in nau et al          but we will not bother to describe it here because
we did not use it during the planning competition  in cases where we wanted to protect
conditions from possible threats  we found it more convenient either to make use of flags
similar to the available truck flag in figure    or to use the following anti interleaving
feature of shop  
if a method m has subtasks t            tk   and if any ti begins with the keyword  immediate 
this tells shop  that it should plan to do ti immediately after ti  finishes  without trying to
interleave other tasks between ti  and ti   several examples of this appear in the appendix 
   

fishop   an htn planning system

task for each person  transport the person to his her destination
 these tasks are unordered  thus their subtasks may be interleaved 
task for each plane  transport the plane to its destination
 these tasks are unordered  thus their subtasks may be interleaved 
method for transporting a person 
if the person is already at their desired destination then do nothing
else
select a plane
if the plane is not at the persons current position then move it there
hold the plane at the current position
board the person onto the plane
move the plane to the destination
debark the person at the destination
method for transporting a plane 
if the plane is already at its desired destination then do nothing
else move the plane to the destination
figure    abstract tasks and methods for a simplified version of the zenotravel domain 

   developing domain descriptions for shop 
    basics
the first step in developing a domain description for shop  is to formulate some abstract
tasks and methods that constitute a reasonable problem solving strategy  as an example  we
will use a simplified version of zenotravel  one of the domains in the planning competition  
the problem is to transport people from their current locations to their destination  by the
use of any available airplanes  figure   shows a set of abstract tasks and methods for
transporting people and moving airplanes 
once we have an abstract strategy like the one in figure    we can implement it as
a shop  domain description consisting of methods  operators and axioms  for example 
the method for transporting a person is shown in figure    there may be more than one
value of  p that satisfies the precondition  plane  p   if so  then which plane to use will
be a nondeterministic branching point for shop   at nondeterministic branching points 
the domain description may include some heuristics to guide shop s search  section    
discusses some of the ways to write such heuristics 
in the method for the transport with plane task  one of the preconditions will be whether
a planes fuel level will be enough to get the plane from its current position to its destination 
figure   shows an axiom for this precondition 
actions  such as boarding people onto planes  debarking them from planes  and refueling
the planes  can be modeled as operators in shop   for example  the shop  operator for
boarding is given in figure   
   

finau  au  ilghami  kuter  murdock  wu    yaman

  method
  head
 transport person  person  destination 
case    a label for use in debugging
  preconditions
 and  at  person  current position 
 same  current position  destination  
  subtasks
  
case    a label for use in debugging
  preconditions
 and  at  person  current position 
 plane  p  
  subtasks
  transport with plane  person  p  destination   
figure    a shop  implementation of one of the methods in figure   
  operator
  head
 board  person  plane 
  preconditions
 and  at  person  place   at  plane  place  
  delete list
  at  person  place  
  add list
  in  person  plane   
figure    a shop  operator for the simplified zenotravel domain 

    writing temporal domains
shop s operators are at least as expressive as level   actions in pddl  but shop  does
not explicitly support the durative actions in level   of pddl  nor does shop  have an
explicit mechanism for reasoning about durative and concurrent actions 
however  shop  still has enough expressive power to represent durative and concurrent
actions  because it knows the current state at each step of the planning process and since its
operators can assign values to variables and can do numeric calculations  this has allowed
us to develop a preprocessing technique that we call multi timeline preprocessing  mtp  
mtp is a technique for translating pddl operators into shop  operators that keep track
of temporal information in the current state 
the pseudocode in figure    is an algorithmic description of what mtp does  in
principle  mtp could be automatedbut in practice  we have always done it by hand 
because it only needs to be done once for each planning domain 
   

fishop   an htn planning system

for every operator o in the planning domain
add two parameters  start and  duration to o
in os precondition
add an assignment  duration  d
where d is a formula for calculating os duration
add an assignment  start  s
where s is a formula that takes the maximum of the write times of
all dynamic properties in os precondition and the read times of all
dynamic properties in os effects
for each dynamic property p in os effects
add effects to change the value of write time p  to  start   duration
for each dynamic property that appears in o
add effects to change read time p  to the maximum
of read time p  and  start   duration
figure     multi timeline preprocessing  mtp  
to keep the description of mtp simple  let us suppose that in each state s  every atom
 p c        cn   represents a single valued property  i e   there is at most one cn such that  p c 
      cn  cn   is true in s  a property is dynamic if an operator may change the value of cn  
for example  if the initial state contains  at plane  city   but if there is an operator that
moves plane  to a different location  then the location of plane  is dynamic 
for each property p that changes over time  mtp modifies the operators to keep track 
within the current state  of the times at which the property changes and the times at which
various preconditions depend on the property  the idea is that for each dynamic property
p  the current state will contain two time stamps  read time p   which is the last time that
any action read the value of p  and write time p   which is the last time that any action
modified the value of p  mtp modifies the operators in such a way that whenever an
operator reads  i e   accesses  a dynamic property  the operator will update the propertys
read time  and if an operator writes  i e   modifies  a dynamic property  it will update the
propertys write time  thus  instead of a single global time  the current state will contain
many local times  namely a read time and a write time for each dynamic property 
mtp also inserts preconditions into each action to ensure that the action begins on or
after the read time of each property that it writes and the write time of each property that
it reads  this prevents two actions from overlapping in time if one of them writes to a
property and the other reads from it  for example  a boarding operator and a fly operator
on the same plane may not overlap  because the boarding operator requires that the plane
be located in a particular city and the fly operator changes the location of the plane 
figure    shows one of the shop  operators produced by mtp for the zenotravel
domain  the operator involves two dynamic properties  a vehicles fuel level and its location 
the operator reads both of these properties  so it may not start before their write times 
however  it only writes one of them  the fuel level   so it may start before the read time
of the vehicles location  thus refueling may be performed concurrently with any other
actions that depend on the vehicles location  but cannot be performed concurrently with
any actions that modify the fuel level or that modify the vehicles location 
   

finau  au  ilghami  kuter  murdock  wu    yaman

  operator   refuel  plane  city  start  duration 
  preconditions
  aircraft  plane 
 city  city 
 at  plane  city 
 fuel  plane  fuel level 
 capacity  plane  fuel cap 
 refuel rate  plane  rate 
 assign  duration        fuel cap  fuel level   rate  
 write time fuel  plane  t  
 write time at  plane  t  
 read time fuel  plane  t  
 assign  start  eval  max  t   t   t    
 assign  end  eval     start  duration   
 read time at  plane  t  
 assign  new value  eval  max  t   end    
  delete list
  fuel  plane  fuel level 
 write time fuel  plane  t  
 read time fuel  plane  t  
 read time at  plane  t   
  add list
  fuel  plane  fuel cap 
 write time fuel  plane  end 
 read time fuel  plane  end 
 read time at  plane  new value   
figure     a sample shop  operator produced by mtp 
    writing domains that include optimization
in previous planning competitions  the planning benchmarks compared only the speed of
the planners and the length of the output plans  so domain designers concentrated on trying
to find a reasonably short plan as quickly as possible  in contrast  most of the problems
in this years competition included a linear objective function that needed to be optimized 
the best plan was no longer the one that minimizes the number of steps  but instead was the
one that minimized the objective function value  we tried three approaches for searching
for optimal plans 
   structure the shop  methods in such a way as to take shop  more or less directly
toward a plan that minimizes the objective function 
   write methods  operators  and axioms to generate plans quickly  and use the sort by
feature to tell shop  to sort the alternatives and try the most promising ones first 
   assign costs to the operators  and use a branch and bound search to find the best
plan within the execution time limit 
   

fishop   an htn planning system

the first approach works well if it is easy to tell which alternative will be best at each
node of the search space  for example  if you know that in all problem instances the
objective will be to minimize the total fuel used  then a perfect heuristic for the zenotravel
domain is to always use the fly action instead of the zoom action  however  this approach
doesnt work so well if it isnt immediately obvious which alternative is best  for example 
if the objective is to minimize the total time  then a naive approach would be always to use
the zoom action rather than the fly action  since the zoom action is faster  however  the
zoom action is not always the best choice  because it requires more fuel and thus can cause
delays for refueling 
the second approach is an extension of the first approach  consider again the example
in zenotravel domain where the objective is to minimize the total fuel used  in addition
to making the planes fly instead of zoom  using a closer plane to transport a person also
reduces the total fuel used  we can set this preference using the sort by feature of shop  
in the precondition of the method for transporting a person we can sort the available planes
according to the fuel they will use in order to pick up this person  this is a greedy approach 
at each decision point we can sort the alternatives by cost  and go with the alternative that
has the lowest objective function value  thus  this approach is not guaranteed to find the
optimal solution  however  if combined with suitable heuristics  this approach results in
near optimal plans  in the competition we used this technique extensively  and it produced
satisfactory plans even for the largest problems 
the third approach makes use of branch and bound optimization  as explained in section
       the main idea is to quickly define methods that will let you find a plan which may
be poor in quality and then let shop  perform branch and bound search in the plan space
to find the least cost plan or the best plan it can find within the execution time limit 
for the third approach  there is a challenge in setting up the cost of each operator  for
example  if the objective function requires minimizing the total time  then in order to take
concurrency into account  the cost of an action a should not always be equal to its duration 
for example  suppose the latest event in the current partial plan is for a plane to arrive
at an airport at time t  and two passengers need to board the plane  then we need to
add two boarding actions to the plan  recall that in the zenotravel domain  all boarding
actions take the same amount of time  tb   and can be performed concurrently  however 
shop  needs to add the actions to the plan one at a time  the first boarding action will
increase the total time by tb   so its cost is tb   however  the second boarding action will not
increase the total time of the plan  so its cost is    now  suppose we add a refuel action
to the plan  this action can be done concurrently with the boarding actions  so its cost is
max    tr  tb    where tr is the time needed to refuel 
it is possible to combine two or more of the above approaches  however  in our experience  using optimization  the third approach  did not provide much benefit for domain
descriptions that already included the other two approaches  in these situations  shop 
would frequently find an optimal or nearly optimal plan even without optimization  which
meant that the additional amount of time needed by branch and bound optimization would
produce little or no benefit  branch and bound optimization would perhaps be more useful
in planning domains where the cost of a plan is something other than the sum of the costs
of the operators  however  such domains did not occur in the planning competition 
   

finau  au  ilghami  kuter  murdock  wu    yaman

in the international planning competition  we did not use the optimization approach
in any official competition trial  for all of the competition domains  in our preliminary
testing of shop  with optimization and no time limits  shop  was unable to find solutions
within the amount of time that we were willing to let it run  except on the very smallest
problems  one way to overcome this difficulty would have been to use time limits  but in
our preliminary tests  this never provided significant improvements in cost across an entire
problem set  one reason for this lack of improvement was that we spent a great deal of
effort crafting the methods used in the competition  we think the third approach would
be more useful in cases where it is not immediately clear how to implement the first two
approaches  and one does not want to spend too much time devising a sophisticated domain
description 

   competition results
fourteen planning systems competed in the      international planning competition 
shop  received a distinguished performance award  one of the top four awards 
shop   along with tlplan and talplanner  was one of three planners that solved
problems in both the hand tailored and fully automated tracks  shop  was able to
solve problems in the strips  numeric  hardnumeric  simpletime  time  and complex
domains  shop  solved more problems than any other planner in the competition  it
solved     out of     problems  for a     success ratio 
of the other two hand tailorable planners  tlplan solved     problems  nearly as many
as shop   since talplanner didnt do numeric domains  it solved only     problems  but
that still was several hundred more problems than the fully automated planners solved 
in general  shop  tended to be slower than talplanner and tlplanner  although
there was one domain  satellite hardnumeric  where shop  was consistently the fastest 
the speeds of the three hand tailorable planners generally appeared to be polynomially
related to each other  probably because these planners domain knowledge enabled them
to find solutions without doing very much backtracking  all three hand tailorable planners
were generally much faster than most of the fully automated planners 
none of the three hand tailorable planners dominated the other two in terms of plan
quality  for each of them  there were situations where its solutions were significantly better
or significantly worse than the other two 

   related work
the following subsections discuss htn planning  ordered task decomposition  and the other
hand tailorable planners that participated in the competition 
    htn planning
htn planning was first developed more than    years ago  sacerdoti        tate        
historically  most of the htn planning researchers have focused on practical applications 
examples include production line scheduling  wilkins         crisis management and logistics  currie   tate        tate  drabble    kirby        biundo   schattenberg        
planning and scheduling for spacecraft  aarup  arentoft  parrod  stader    stokes       
   

fishop   an htn planning system

estlin  chien    wang         equipment configuration  agosta         manufacturability
analysis  hebbar  smith  minis    nau        smith  hebbar  nau    minis         evacuation planning  munoz avila  aha  nau  weber  breslow    yaman         and the game
of bridge  smith  nau    throop      a      b  
the development of a formal semantics for htn planning  erol  nau    hendler       
erol  hendler    nau        has shown that it is strictly more expressive than classical
ai planning  there are some problems that can be expressed as htn planning problems
but not as classical planning problems   even if one places restrictions on htn planning
to restrict its expressive power to that of classical planning  it generally is much easier to
translate classical planning problems into htn planning problems than vice versa  lotem 
nau    hendler        
    ordered task decomposition
ordered task decomposition  nau  smith    erol        is a special case of htn planning in
which the planning algorithm always builds plans forward from the initial state of the world 
in other words  an ordered task decomposition planner plans for tasks in the same order
that the tasks will later be performed  the first applications of ordered task decomposition
were tailor made for specific application domains  the best known example is the code
for declarer play that helped bridge baron win the      world championship of computer
bridge  smith et al       b  
shop  is based on shop  nau et al          a previous domain independent orderedtask decomposition planner that requires the subtasks of each method  and also the initial
set of tasks for the planning problem  to be totally ordered rather than partially ordered 
thus in shop  subtasks of different tasks cannot be interleaved  shop  extends shop by
allowing the subtasks of each method to be partially ordered  experiments have shown that
this can allow shop  to create plans more efficiently than shop  using domain descriptions
simpler than those needed by shop  nau et al          both shop and shop  are
available as open source software at hhttp   www cs umd edu projects shopi 
    tlplan and talplanner
like shop   tlplan  bacchus   kabanza        and talplanner  doherty   kvarnstrom        competed in the hand tailored track of the aips      planning competition 
tlplan and talplanner are similar in many respects  both of them do a forward chaining
search in which they apply planning operators to the current state to generate its successors  thus  like shop   they both know the current state of the world at every step of the
planning process  to control their search  both planners use control rules that are written
declaratively in temporal logic  these rules provide domain specific knowledge to tell the
planner which states are bad states  so that the planner can backtrack and try other
   more specifically  htn planning is turing complete  even undecidable problems can be expressed as
htn planning problems  it remains turing complete even if we restrict the tasks and the logical atoms
to be purely propositional  i e   to have no arguments at all   in contrast  classical planning only
represents planning problems for which the solutions are regular sets  planners such as tlplan  bacchus
  kabanza        and talplanner  doherty   kvarnstrom        overcome this limitation of classical
planning by extending the formalism to include function symbols 

   

finau  au  ilghami  kuter  murdock  wu    yaman

paths in the search space  one difference between tlplan and talplanner is that tlplan
uses a linear modal tense logic  while talplanner use tal  a narrative based linear temporal logic used for reasoning about action and change in incompletely specified dynamic
environments 
the main difference between both of these planners and shop  is the kind of control
knowledge they use  tlplan and talplanner use their temporal formulas to tell which
part of the search space should be avoided  whereas shop  uses its htn methods to tell
which parts of the search space should be explored  shop s search space consists only of
those nodes that are reachable using its htn methods  whereas tlplan and talplanner
can explore any part of the search space that avoids the bad states and their successors 
it is hard to say which type of control knowledge is more effective  bacchus and kabanza
       argue that the two types are useful in different situations and that combining them
is a useful topic for future research 

   summary and conclusions
the primary difference between shop  and most other htn planners is that shop  plans
for tasks in the same order that they will be executed  and thus it knows the current state
at each step of the planning process  this reduces the complexity of reasoning by removing
a great deal of uncertainty about the world  which has made it easy for us to incorporate substantial expressive power into shop   in addition to the usual htn methods
and operators  shop s domain descriptions may include axioms  mixed symbolic numeric
conditions  and external function calls  the planning procedure is turing complete  and is
sound and complete over a large class of planning problems  nau et al         
like other htn planning systems  shop  plans by decomposing tasks into subtasks 
a key idea in using any htn planner is to design a set of methods that encode something
akin to standard operating procedures that capture multi step techniques for refining a
task  some kinds of domain characteristics are much more natural to express in an htn
formalism than in action based formalism  see lotem et al         for a description of some
of the issued involved 
as an example  consider the um translog   domain  which we wrote for use as a problem
domain in the aips      planning competition  wu   nau         um translog   is
a straightforward generalization of the um translog domain  andrews  kettler  erol   
hendler         the generalizations include numeric information such as distances  fuel
usage  and so forth  it was relatively straightforward to formulate um translog   as an
htn planning domain  however  it was much more difficult to figure out how to formulate
um translog   as a pddl domain for use by other competitors in the planning competition 
that task took several months to accomplish 
as with most other htn planning systems  shop s development was originally motivated not by the planning competition but instead to try to solve practical planning
problems  for example  jshop  a java implementation of shop s predecessor shop 
is the generative planning component of the hicap system for planning evacuation operations  munoz avila et al          and we are currently incorporating shop  into hicap
as a replacement for jshop  we are very pleased that shop s capabilities also gave it
the ability to excel in the international planning competition 
   

fishop   an htn planning system

acknowledgments
this work was supported in part by the following grants  contracts  and awards  air force
research laboratory f                 army research laboratory daal    k      naval
research laboratory n        g     and the university of maryland general research
board  the opinions expressed in this paper are those of authors and do not necessarily
reflect the opinions of the funders 
we also wish to thank the anonymous reviewers  whose comments helped us to make
significant improvements to this paper 

appendix a  shop  domain description for the zenotravel domain
 numeric version 
in the aips      planning competition  there were four different versions of the zenotravel
domain  the strips version  the numeric version  the simple time version  and the time
version  we developed shop  domain descriptions for all four versions 
what follows is our domain description for the numeric version of the zenotravel domain  the operators in our domain description are translated from the original pddl
coding using a rough approximation of the mtp process in figure    
 defdomain zenotravel
 
     same  x  x     
     different  x  y    not  same  x  y    
    possible person in  city 
  person  p   at  p  city   goal  p  city  
 different  city   city   
  operator    cost  end 
  maxtime  max 
 assign  newmax  eval  if     max  end   end  max    
  maxtime  max  
  maxtime  newmax  
    newmax  max  
  method  board  p  a  c 
  write time  a  start  
   board  p  a  c  start   
  immediate   cost  call    start      
  operator   board  p  a  c  start  duration 
  person  p   aircraft  a   city  c 
 at  a  c   at  p  c   onboard  a  num 
 read time  a  pmax   assign  new num     num    
 assign  newpmax  max  pmax     start  duration     l     
  onboard  a  num   read time  a  pmax   at  p  c   dest  a  c  
  onboard  a  new num   read time  a  newpmax   in  p  a  
   

finau  au  ilghami  kuter  murdock  wu    yaman

      
  method  debark  p  a  c 
  write time  a  start  
   debark  p  a  c  start   
  immediate   cost  call    start      
  operator   debark  p  a  c  start  duration 
  person  p   aircraft  a   city  c 
 at  a  c   in  p  a   onboard  a  num 
 read time  a  pmax   assign  new num     num    
 assign  newpmax  max  pmax     start  duration     l     
  onboard  a  num   read time  a  pmax   in  p  a   dest  a  c  
  onboard  a  new num   read time  a  newpmax   at  p  c  
      
  method  refuel  a  c 
  write time  a  start   read time  a  pmax 
 capacity  a  cap   fuel  a  fuel 
 eval     cap  fuel  
 assign  duration   
 assign  end     start  duration     l   
 assign  newpmax  max  pmax  end   
    ra   read time  a  pmax  
  read time  a  newpmax   
  immediate  refuel  a  c  start  duration 
  immediate   cost  end   
  operator   refuel  a  c  start  duration 
  aircraft  a   city  c   at  a  c 
 fuel  a  fuel   capacity  a  cap  
  fuel  a  fuel  
  fuel  a  cap  
      
  method  zoom  a  c   c  
  write time  a  astart   read time  a  pmax 
 distance  c   c   dist 
 fuel  a  fuel   fast burn  a  burn 
 eval      fuel     dist  burn   
 assign  duration   
 assign  start  max  pmax  astart  
 assign  end     start  duration     l    
    ra   write time  a  astart   read time  a  pmax  
  read time  a     write time  a  end   
  immediate  zoom  a  c   c   start  duration 
  immediate   cost  end   
  operator   zoom  a  c   c   start  duration 
  aircraft  a   city  c    city  c    onboard  a  num 
 zoom limit  a  limit   eval      num  limit  
   

fishop   an htn planning system

 at  a  c    distance  c   c   dist   fast burn  a  burn 
 total fuel used  total fuel 
 assign  new total     total fuel     dist  burn   
 fuel  a  fuel 
 assign  new fuel     fuel     dist  burn    
  at  a  c    total fuel used  total fuel   fuel  a  fuel   
  at  a  c    total fuel used  new total   fuel  a  new fuel  
      
  method  fly  a  c   c  
  write time  a  astart   read time  a  pmax 
 distance  c   c   dist 
 fuel  a  fuel   slow burn  a  burn 
 eval      fuel     dist  burn   
 assign  duration   
 assign  start  max  pmax  astart  
 assign  end     start  duration     l    
    ra   write time  a  astart   read time  a  pmax  
  read time  a     write time  a  end   
  immediate  fly  a  c   c   start  duration 
  immediate   cost  end   
  operator   fly  a  c   c   start  duration 
  aircraft  a   city  c    city  c  
 at  a  c    distance  c   c   dist   slow burn  a  burn 
 total fuel used  total fuel 
 assign  new total     total fuel     dist  burn   
 fuel  a  fuel 
 assign  new fuel     fuel     dist  burn    
  at  a  c   total fuel used  total fuel  fuel  a  fuel  
  at  a  c   total fuel used  new total  fuel  a  new fuel  
      
  operator    preprocessing  problem name 
  totaltime coeff  tc   fuelused coeff  fc 
 eval  setf  tc   tc  
 eval  setf  fc   fc   
  
  
  
  operator    assert  g  
  
  
 g
  
  operator    ra  d  a  
  
 d
 a
  
   

finau  au  ilghami  kuter  murdock  wu    yaman

    
      main methods
     
  method  transport person  p  c 
case    at  p  c  
   
  method  transport person  p  c  
case    sort by  num   
  at  p  c  
 at  a  c  
 aircraft  a 
 onboard  a  num   
    assert   dest  a  c    
  immediate board  p  a  c  
   assert   dest  a  c    
  immediate upper move aircraft no style  a  c  
  immediate debark  p  a  c    
  method  transport person  p  c  
case    sort by  cost   
  at  p  c  
 aircraft  a 
 at  a  c  
 different  c   c  
 forall   c    dest  a  c     same  c  c    
 imply   different  c   c   
 not  possible person in  c    
 travel cost info  a  c   c   cost  style   
    assert   dest  a  c    
  immediate upper move aircraft  a  c   style 
  immediate board  p  a  c  
   assert   dest  a  c    
  immediate upper move aircraft no style  a  c  
  immediate debark  p  a  c    
  method  upper move aircraft  a  c  style 
case    at  a  c  
  
case    at  a  somecity  
  move aircraft  a  somecity  c  style   
  method  upper move aircraft no style  a  c 
case    at  a  c  
  
case    sort by  cost   
  at  a  somecity 
 travel cost info  a  somecity  c  cost  style   
  move aircraft  a  somecity  c  style   
   

fishop   an htn planning system

     travel cost info  a  from  to  cost slow 
case 
  capacity  a  cap   distance  from  to  dist 
 slow burn  a  burn   eval     cap     dist  burn   
 assign  cost most positive fixnum  
case 
  distance  from  to  dist   fuel  a  fuel 
 slow burn  a  burn 
 eval      fuel     dist  burn   
 assign  cost  float   
    tc 
    fc 
    dist  burn   
     
case 
  capacity  a  cap  distance  from  to  dist 
 slow burn  a  burn 
 assign  cost  float   
       tc    
    fc 
    dist  burn   
      
     travel cost info  a  from  to  cost fast 
case 
  capacity  a  cap   distance  from  to  dist 
 fast burn  a  burn   eval     cap     dist  burn   
 assign  cost most positive fixnum  
case 
  distance  from  to  dist   fuel  a  fuel 
 zoom limit  a  limit   onboard  a  num   eval     num  limit  
 fast burn  a  burn 
 eval      fuel     dist  burn   
 assign  cost  float   
    tc 
    fc 
    dist  burn   
     
case 
  capacity  a  cap  distance  from  to  dist 
 fast burn  a  burn 
 zoom limit  a  limit   onboard  a  num   eval     num  limit  
 assign  cost  float   
       tc    
    fc 
    dist  burn   
      

   

finau  au  ilghami  kuter  murdock  wu    yaman

  method  move aircraft  a  c   c  slow 
  fuel  a  fuel   distance  c   c   dist 
 slow burn  a  burn 
 eval     fuel     dist  burn    
  fly  a  c   c   
  
  refuel  a  c  
  immediate fly  a  c   c    
  method  move aircraft  a  c   c  fast 
  fuel  a  fuel   distance  c   c   dist 
 fast burn  a  burn 
 eval     fuel     dist  burn    
  zoom  a  c   c   
  
  refuel  a  c  
  immediate zoom  a  c   c    
  method  transport aircraft  a  c 
  not  no use  a   
    assert   no use  a   
  immediate upper move aircraft no style  a  c 
  immediate   ra   no use  a        

references
aarup  m   arentoft  m  m   parrod  y   stader  j     stokes  i          optimum aiv 
a knowledge based planning and scheduling system for spacecraft aiv  in intelligent
scheduling  pp          morgan kaufmann 
agosta  j  m          formulation and implementation of an equipment configuration
problem with the sipe   generative planner  in proc  aaai    spring symposium
on integrated planning applications  pp      
andrews  s   kettler  b   erol  k     hendler  j          um translog  a planning domain
for the development and benchmarking of planning systems  tech  rep  cs tr      
dept  of computer science  university of maryland 
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for planning  artificial intelligence      
biundo  s     schattenberg  b          from abstract crisis to concrete relief  a preliminary
report on flexible integration on nonlinear and hierarchical planning  in proceedings
of the european conference on planning 
boddy  m     dean  t          solving time dependent planning problems  in sridharan 
n  s   ed    proceedings of the eleventh international joint conference on artificial
intelligence  pp          detroit  mi  usa  morgan kaufmann 
currie  k     tate  a          o plan  the open planning architecture  artificial intelligence               
   

fishop   an htn planning system

doherty  p     kvarnstrom  j          talplanner  a temporal logic based planner  ai
magazine                
erol  k   hendler  j     nau  d          complexity results for hierarchical task network
planning  annals of mathematics and artificial intelligence           
erol  k   nau  d     hendler  j          htn planning  complexity and expressivity  in
aaai    
estlin  t  a   chien  s  a     wang  x          an argument for a hybrid htn operatorbased approach to planning  in proc  fourth european conference on planning  ecp     pp         
gupta  n     nau  d  s          on the complexity of blocks world planning  artificial
intelligence                   
hebbar  k   smith  s   minis  i     nau  d          plan based evaluation of designs for
microwave modules  in proc  asme design technical conference 
lotem  a   nau  d     hendler  j          using planning graphs for solving htn problems 
in aaai     pp         
munoz avila  h   aha  d   nau  d   weber  r   breslow  l     yaman  f          sin 
integrating case based reasoning with task decomposition  in ijcai      
nau  d   cao  y     munoz avila  h          shop  simple hierarchical ordered planner 
in ijcai     pp         
nau  d   munoz avila  h   cao  y   lotem  a     mitchell  s          total order planning
with partially ordered subtasks  in ijcai       seattle 
nau  d  s   smith  s  j  j     erol  k          control strategies in htn planning  theory
versus practice  in aaai    iaai    proceedings  pp           
sacerdoti  e  d          the nonlinear nature of plans  in allen  j   hendler  j     tate  a 
 eds    readings in planning  pp          morgan kaufmann  originally appeared
in proc  ijcai     pp          
slaney  j     thiebaux  s          blocks world revisited  artificial intelligence            
       
smith  s  j   hebbar  k   nau  d     minis  i          integrating electrical and mechanical
design and process planning  in mantyla  m   finger  s     tomiyama  t   eds   
knowledge intensive cad  vol     pp         
smith  s  j   nau  d  s     throop  t       a   success in spades  using ai planning
techniques to win the world championship of computer bridge  in aaai    iaai    
pp           
smith  s  j  j   nau  d  s     throop  t       b   computer bridge  a big win for ai
planning  ai magazine                
tate  a          generating project networks  in ijcai     pp         
tate  a   drabble  b     kirby  r          o plan   an architecture for command  planning and control  morgan kaufmann 
   

finau  au  ilghami  kuter  murdock  wu    yaman

wilkins  d  e          practical planning  extending the classical ai planning paradigm 
morgan kaufmann  san mateo  ca 
wu  d     nau  d          um translog    a planning domain designed for aips      
tech  rep  cs tr       umiacs tr          university of maryland 

   

fi