journal of artificial intelligence research                  

submitted       published      

taming numbers and durations in the model checking
integrated planning system
stefan edelkamp

stefan edelkamp cs uni dortmund de

baroper strae    
fachbereich informatik  gb iv
universitat dortmund
      dortmund
germany

abstract
the model checking integrated planning system  mips  is a temporal least commitment heuristic search planner based on a flexible object oriented workbench architecture 
its design clearly separates explicit and symbolic directed exploration algorithms from the
set of on line and off line computed estimates and associated data structures 
mips has shown distinguished performance in the last two international planning competitions  in the last event the description language was extended from pure propositional
planning to include numerical state variables  action durations  and plan quality objective
functions  plans were no longer sequences of actions but time stamped schedules 
as a participant of the fully automated track of the competition  mips has proven to be
a general system  in each track and every benchmark domain it efficiently computed plans
of remarkable quality  this article introduces and analyzes the most important algorithmic
novelties that were necessary to tackle the new layers of expressiveness in the benchmark
problems and to achieve a high level of performance 
the extensions include critical path analysis of sequentially generated plans to generate
corresponding optimal parallel plans  the linear time algorithm to compute the parallel
plan bypasses known np hardness results for partial ordering by scheduling plans with
respect to the set of actions and the imposed precedence relations  the efficiency of this
algorithm also allows us to improve the exploration guidance  for each encountered planning
state the corresponding approximate sequential plan is scheduled 
one major strength of mips is its static analysis phase that grounds and simplifies
parameterized predicates  functions and operators  that infers knowledge to minimize the
state description length  and that detects domain object symmetries  the latter aspect is
analyzed in detail 
mips has been developed to serve as a complete and optimal state space planner 
with admissible estimates  exploration engines and branching cuts  in the competition
version  however  certain performance compromises had to be made  including floating point
arithmetic  weighted heuristic search exploration according to an inadmissible estimate and
parameterized optimization 

   introduction
practical action planning and model checking appear to be closely related  the mips
project targets the integration of model checking techniques into a domain independent
action planner  with the hsf spin experimental model checker  edelkamp  leue    lluchlafuente        we are looking towards the integration of planning technology into an
c
    
ai access foundation  all rights reserved 

fiedelkamp

existing model checker  additional synergies are exploited in the automated compilation of
protocol software model checking problems into planner inputs  edelkamp        
model checking  clarke  grumberg    peled        is the automated process to verify if
a formal model of a system satisfies a specified temporal property or not  as an illustrative
example  take an elevator control system together with a correctness property that requires
an elevator to eventually stop on every call of a passenger or that guarantees that the door is
closed  while the elevator is moving  although the success in checking correctness is limited 
model checkers have found many errors in current hardware and software designs  models
often consist of many concurrent sub systems  their combination is either synchronous  as
often seen in hardware design verification  or asynchronous  as frequently given in communication and security protocols  or in multi threaded programming languages like java 
model checking requires the exploration of very large state spaces containing all reachable system states  this problem is known as the state explosion problem and occurs even
when the sets of generated states is much smaller than the set of all reachable states 
an error that shows a safety property violation  like a deadlock or a failed assertion 
corresponds to one of a set of target nodes in the state space graph  roughly speaking 
something bad has occured  a liveness property violation refers to a  seeded  cycle in the
graph  roughly speaking  something good will never occur  for the case of the elevator
example  eventually reaching a target state where a request button was pressed is a liveness
property  while certifying closed doors refers to a safety property 
the two main validation processes in model checking are explicit and symbolic search 
in explicit state model checking each state refers to a fixed memory location and the state
space graph is implicitly generated by successive expansions of state 
in symbolic model checking  mcmillan        clarke  mcmillan  dill    hwang        
 fixed length  binary encodings of system states are used  so that each state can be represented by its characteristic function representation  this function evaluates to true if
and only if all boolean state variables are assigned to bit values with respect to the binary
encoding of the system state  subsequently  the characteristic function is a conjunction of
literals with a plain variable for a   in the encoding and a negated variable for a    sets of
states are expressed as the disjunction of all individual characteristic functions 
the unique symbolic representation of sets of states as boolean formulae through binary
decision diagrams  bdds   bryant        is often much smaller than the explicit one  bdds
are  ordered  read once branching programs with nodes corresponding to variables  edges
corresponding to variable outcomes  and each path corresponding to an assignment to the
variables with the resulting evaluation at the leaves  one reason for the succinctness of
bdds is that directed acyclic graphs may express exponentially many paths  the transition
relation is defined on two state variable sets  it evaluates to true  if and only if an operator
exists that transforms a state into a valid successor  in some sense  bdds exploit regularities
of the state set and often appear well suited to regular hardware systems  in contrast  many
software systems inherit a highly asynchronous and irregular structure  so that the use of
bdds with a fixed variable ordering is generally not flexible enough 
for symbolic exploration  a set of states is combined with the transition relation to
compute the set of all possible successor states  i e  the image  starting with the initial
state  iteration of image computations eventually explores the entire reachable state space 
   

fitaming numbers and durations in mips

to improve the efficiency of image computations  transition relations are often provided in
partitioned form 
the correspondence between action and model checking  giunchiglia   traverso       
can be roughly characterized as follows  similar to model checkers  action planners implicitly generate large state spaces  and both exploration approaches are based on applying
operators to the current state  states spaces in model checking and in planning problems are
often modelled as kripke structures  i e  state space graphs with states labelled by propositional predicates  the satisfaction of a specified property on the one side corresponds to
a complete exploration  and an unsolvable problem on the other side  in this respect  the
goal in action planning can be cast as an error with the corresponding trail interpreted as a
plan  in the elevator example  the goal of a planning task is to reach a state  in which the
doors are open and the elevator is moving  action planning refers to safety properties only 
since goal achievement in traditional and competition planning problems have not yet been
extended with temporal properties  however  temporally extended goals are of increasing
research interest  kabanza  barbeau    st denis        pistore   traverso        lago 
pistore    traverso        
in contrast to model checkers that perform either symbolic or explicit exploration  mips
features both  moreover  it combines symbolic and explicit search planning in the form of
symbolic pattern databases  edelkamp      b   the planner mips implements heuristic
search algorithms like a   pearl        and ida   korf        for exploration  which include
state to goal approximation into the search process to rank the states to be expanded next 
heuristic search has brought considerable gains to both planning  bonet   geffner       
refanidis   vlahavas        hoffmann   nebel        bertoli  cimatti    roveri      a 
jensen  bryant    veloso        feng   hansen        and model checking  yang   dill 
      edelkamp et al         groce   visser        bloem  ravi    somenzi        ruys 
      
including resource variables  like the fuel level of a vehicle or the distance between two
different locations  as well as action duration are relatively new aspects for competitive
planning  fox   long         the input format pddl    is not restricted to variables of
finite domain  but also includes rational  floating point  variables in both precondition and
effects  similar to a set of atoms described by a propositional predicate  a set of numerical
quantities can be described by a set of parameters  through the notation of pddl     we
refer to parameterized numerical quantities as functions  for example  the fuel level might
be parameterized by the vehicle that is present in the problem instance file description 
in the competition  domains were provided in different tracks according to different layers of language expressiveness  i  pure propositional planning  ii  planning with numerical
resources  iii  planning with numerical resources and constant action duration  iv  planning
with numerical resources and variable action duration  and  in some cases  v  complex problems usually combining time and numbers in more interesting ways  mips competed as a
fully automated system and performed remarkably well in all five tracks  it solved a large
number of problems and was the only fully automated planner that produced solutions in
each track of every benchmark domain 
in this paper the main algorithmic techniques for taming rational numbers  objective
functions  and action duration are described  the article is structured as follows  first 
we review the development of the mips system and assert its main contributions  then
   

fiedelkamp

we address the object oriented heuristic search framework of the system  subsequently  we
introduce some terminology that allows us to give a formal definition of the syntax and
the semantics of a grounded mixed numerical and propositional planning problem instance 
we then introduce the core contributions  critical path scheduling for concurrent plans 
and efficient methods for detecting and using symmetry cuts  pert scheduling produces
optimal parallel plans in linear time given a sequence of operators and a precedence relation
among them  the paper discusses pruning anomalies and the effect of different optimization
criteria  we analyze the correctness and efficiency of symmetry detection in detail  the
article closes with related work and concluding remarks 

   the development of mips
the competition version of mips refers to initial work  edelkamp   reffel      a  in
heuristic symbolic exploration of planning domains with the cke model checker  biere 
       this approach was effective in sample puzzle solving  edelkamp   reffel        and
in hardware verification problems  reffel   edelkamp        
for implementing a propositional planner  we first used our own bdd library called
staticbdd  in which large node tables are allocated prior to their use  during the implementation process we changed the bdd representation mainly to improve performance for
small planning problems  we selected the public domain c   bdd package buddy  lindnielsen         which is more flexible  the planning process was semi automated  edelkamp
  reffel      b   variable encodings were provided by hand  while the representations of
all operators were established by enumerating all possible parameter instances  once the
state space encoding and action transition relation were fixed  exploration in the form of
a symbolic breadth first search of the state space could be executed  at that time  we
were not aware of any other work in bdd based planning such as the work of cimatti et al 
        which is likely the first link to planning via symbolic model checking  the team used
the model checker  nu smv as the basis with an atom to variable planning state encoding
scheme on top of it 
later on  we developed a parser and a static analyzer to automate the inference of state
encodings  the generation of the transition relations  and the extraction of solution paths 
in order to minimize the length of the state encoding  the new analyzer clustered atoms into
groups  edelkamp   helmert         as confirmed by other attempts  weismuller        
who started experimenting with pddl specification in cke  state minimization is in fact
crucial  the simple encoding using one variable for each atom appears not to be competitive
with respect to graphplan based  blum   furst        and sat plan based planners  kautz
  selman         subsequently  mips was the first fully automated planning system based
on symbolic model checking technology that could deal with large domain descriptions 
in the second international planning competition mips  edelkamp   helmert       
could handle the strips  fikes   nilsson        subset of the pddl language  mcdermott        and some additional features from adl  pednault         namely negative
preconditions and  universal  conditional effects  mips was one of five planning systems to
be awarded for distinguished performance in the fully automated track  the competition
version  edelkamp   helmert        already included explicit heuristic search algorithms
based on a bit vector state representation and the relaxed planning heuristic  rph   hoff   

fitaming numbers and durations in mips

mann   nebel        as well as symbolic heuristic search based on the hsp heuristic  bonet
  geffner        and a one to one atom derivative of rph  in the competition  we used
breadth first bi directional symbolic search whenever the single state heuristic search engine
got stuck in its exploration 
in between the planning competitions  explicit  edelkamp      c  and symbolic pattern
databases  edelkamp      b  were proposed as off line estimators for completely explored
problem abstractions  roughly speaking  pattern database abstractions slice the state vector of fluents into pieces and adjust the operators accordingly  the completely explored
subspaces then serve as admissible estimates for the overall search and are competitive with
the relaxed planning heuristic in several benchmark domains 
for the third planning competition new levels of the planning domain description language  pddl  were designed  level   considers pure propositional planning  level   also
includes numerical resources and objective functions to be minimized  level   additionally
allows the specification of actions with durations  consequently  mips has been extended
to cope with these new forms of expressiveness 
first results of mips in planning pddl    problems are presented in  edelkamp 
    b   the preliminary treatment illustrates the parsing process in two simple benchmark domains  moreover  propositional heuristics and manual branching cuts were applied
to accelerate sequential plan generation  this work was extended in  edelkamp      a  
where we presented two approximate exploration techniques to bound and to fix numerical
domains  first results on symmetry detection based on fact groups  critical path scheduling 
an any time wrapper to produce optimal plans  and a numerical extension to rph 

   architecture of mips
figure   shows the main components of mips and the data flow from the input definition
of the domain and the problem instance to the resulting temporal plan in the output  as
shown shaded in light gray  mips is divided into four parts  pre compilation  heuristics 
search algorithms  and post compilation  scheduling   henceforth  the planning process
will be coarsely grouped into three stages  pre compilation  heuristic search planning  and
the construction of temporal plans  the problem and domain description files are fed into
the system  analyzed and grounded  this fixes the state space problem to be solved  the
intermediate result is implicit  but can be saved in a file for use by other planners and model
checkers  the basics of pre compilation are covered in section     
the next stage defines the planning process  the object oriented workbench design
of the planner allows different heuristic estimates to be combined with different search
strategies and access data structures  possible choices are listed in sections     and     
temporal planning is based on  pert  scheduling  this issue of rearranging sequential
 relaxed  plans is addressed in detail in section     
the planning system was developed in the spirit of the heuristic search framework 
hsf for short  edelkamp         which allows attachment of newly implemented problem
 puzzle  domains to an already compiled system  similar to the approach that we took
in model checking within hsf spin  we kept the extensible and general design  in fact
we characterized both action planning and protocol validation as single agent challenges 
in contrast to the model checking approach  for planning we devised a hierarchy of system
   

fiedelkamp

domain pddl

problem pddl

precompiler
static analyzer
ground

symmetry

cluster

intermediate representation
heuristics
explicit pdbs

symbolic pdbs

numerical
rph

search algorithms

relaxed plan

symbolic search

explicit search
rph

bdda   bdd bfs

a   ida   ehc
scheduling
rph

sequential plan

relaxed
temporal plan

scheduler
critical path

temporal plan

pert

figure    architecture of mips 

states  the implementation for numerical states is a derived class of the one for propositional
states 
similarily  the heuristic search algorithms are all based on an abstract search class  the
main procedures that have to be provided to the search algorithm are a state expansion
procedure  and a heuristic search evaluation function  both located in one of the hierarchically organized heuristic estimator classes  in this sense  algorithms in mips are general
node expanding schemes that can be adapted to very different problems  additional data
structures for the horizon list open and the visited list closed are constructed as parameters of the appropriate search algorithms  as a result  the implementations of the heuristic
search algorithms and the associated data structures in the planner mips almost match
those in our model checker 
    example problem
the running example for the paper is an instance of a rather simple pddl    problem in
zeno travel  it is illustrated in figure    the initial configuration is drawn to the left of
   

fitaming numbers and durations in mips

a

scott

b

dan

c

    

a

c

d

   

b

   

    

   

    

ernie

   

    

d

scott
ernie

dan

figure    an instance for the zeno travel domain with initial state  left  and goal state s 
 right  

the figure and the goal configuration to its right  some global and local numeric variable
assignments are not shown 
figures   and   provide the domain and problem specifications    the instance asks for
a temporal plan to fly passengers  dan  scott  and ernie  located somewhere on a small
map  including the cities city a  city b  city c  and city d  with an aircraft  plane 
to their respective target destinations  boarding and debarking take a constant amount of
time  the plane has a fixed fuel capacity  fuel and time are consumed according to the
distances between the cities and the travel speed  fuel can be restored by refueling the
aircraft  as a result  the total amount of fuel is also maintained as a numerical quantity 
    precompiler
the static analyzer takes the domain and problem instance as an input  grounds its propositional state information and infers different forms of planner independent static information 
parsing our simple lisp parser generates a tree of lisp entities  it reads the input files
and recognizes the domain and problem name  to cope with variable typing  we temporarily assert constant typed predicates to be removed together with other constant
predicates in a further pre compilation step  thereby  we infer a type hierarchy and
an associated mapping of objects to types 
indexing based on the number of counted objects  indices for the grounded predicates 
functions and actions are devised  since in our example problem we have eight objects and the predicates at and in have two parameters  we reserve              
index positions  similarly  the function distance consumes    indices  while fuel 
         denotes that source fragments were omitted for the sake of brevity  in the given example these
are the action definitions for passenger debarking and flying the airplane 

   

fiedelkamp

 define  domain zeno travel 
  requirements  durative actions  typing  fluents 
  types aircraft person city 
  predicates  at  x    either person aircraft   c   city 
 in  p   person  a   aircraft  
  functions  fuel  a   aircraft   distance  c    city  c    city 
 slow speed  a   aircraft   fast speed  a   aircraft 
 slow burn  a   aircraft   fast burn  a   aircraft 
 capacity  a   aircraft 
 refuel rate  a   aircraft 
 total fuel used   boarding time   debarking time  
  durative action board
 parameters   p   person  a   aircraft  c   city 
 duration     duration boarding time 
 condition  and  at start  at  p  c  
 over all  at  a  c   
 effect  and  at start  not  at  p  c   
 at end  in  p  a    
     
  durative action zoom
 parameters   a   aircraft  c   c    city 
 duration     duration     distance  c   c    fast speed  a   
 condition  and  at start  at  a  c   
 at start      fuel  a      distance  c   c    fast burn  a     
 effect  and  at start  not  at  a  c    
 at end  at  a  c   
 at end  increase total fuel used
    distance  c   c    fast burn  a    
 at end  decrease  fuel  a 
    distance  c   c    fast burn  a      
  durative action refuel
 parameters   a   aircraft  c   city 
 duration     duration        capacity  a   fuel  a    refuel rate  a   
 condition  and  at start     fuel  a   capacity  a   
 over all  at  a  c   
 effect  at end  assign  fuel  a   capacity  a    
 

figure    zeno travel domain description in pddl    

slow speed  fast speed  slow burn  fast burn  capacity  and refuel rate each
reserve eight index positions  for the quantities total fuel used  boarding time 
debarking time only a single fact identifier is needed  last but not least we model
duration as an additional quantity total time  this special variable is the only one
that is overwritten in the least commitment planning approach when scheduling plans
as described in section   
   

fitaming numbers and durations in mips

 define  problem zeno travel   
  domain zeno travel 
  objects plane   aircraft
ernie scott dan   person
city a city b city c city d   city 
  init    total fuel used       debarking time        boarding time    
    distance city a city b           distance city b city a      
    distance city b city c           distance city c city b      
    distance city a city c            distance city c city a       
    distance city c city d            distance city d city c       
    fast speed plane                  slow speed plane             
    fuel plane      
    capacity plane      
    fast burn plane          
    slow burn plane          
    refuel rate plane             
 at plane city a   at scott city a   at dan city c   at ernie city c  
  goal  and  at dan city a   at ernie city d   at scott city d   
  metric minimize total time 
 

figure    zeno travel problem instance 
flattening temporal identifiers we interpret each action as an integral entity  so that
all timed propositional and numerical preconditions can be merged  similarly  all
effects are merged  independent of time at which they happen  invariant conditions
like  over all  at  a  c   in the action board are added into the precondition set 
we discuss the rationale for this step in section     
grounding propositions fact space exploration is a relaxed enumeration of the planning
problem to determine a superset of all reachable facts  algorithmically  a fifo fact
queue is compiled  successively extracted facts at the front of the queue are matched
to the operators  each time all preconditions of an operator are fulfilled  the resulting
atoms according to the positive effect  add  list are determined and enqueued  this
allows us to separate off constant facts from fluents  since only the latter are reached
by exploration 
clustering atoms for a concise encoding of the propositional part we separate fluents
into groups  so that each state in the planning space can be expressed as a conjunction of  possibly trivial  facts drawn from each fact group  edelkamp   helmert 
       more precisely  let  pi  o            oi    oi             on   be the number of objects oi
for which the fact  p o        on   is true  we establish a single valued invariant at i
if  pi  o            oi    oi             on        to allow for a better encoding  some predicates
like at and in are merged  in the example  three groups determine the unique position
of the persons  one of five  and one group determines the position of the plane  one
of four   therefore     dlog  e      dlog  e      bits suffice to encode the total of   
fluents 
   

fiedelkamp

grounding actions fact space exploration also determines all grounded operators  once
all preconditions are met and grounded  the symbolic effect lists are instantiated  in
our case we determine    instantiated operators  which  by some further simplifications
that eliminate duplicates and trivial operators  no ops   are reduced to    
grounding functions simultanous to fact space exploration of the propositional part of
the problem  all heads of the numerical formulae in the effect lists are grounded  in
the example case only three instantiated formulae are fluent  vary with time    fuel
plane  with initial value     as well as total fuel used and total time both initialized with zero  all other numerical predicates are in fact constants that can be
substituted in the formula bodies  in the example  the effect in  board dan city a 
reduces to  increase  total time       while  zoom plane city a city b  has
the numerical effects  increase  total time        increase  total fuel used 
       and  decrease  fuel plane        refuelling  however  does not reduce to
a single rational number  for example the effects in  refuel plane city a  only
simplify to  increase  total time              fuel plane             and
 assign  fuel plane        to evaluate the former assignment especially for a forward chaining planner  the variable  total time  has to be instantiated on the fly 
this is due to the fact that the value of the quantity  fuel plane  is not constant
and itself changes over time 
symmetry detection regularities of the planning problem with respect to the transposition of domain objects is partially determined in the static analyzer and is addressed
in detail in section   
the intermediate textual format of the static analyzer in annotated grounded pddllike representation serves as an interface for other planners or model checkers  and as an
additional resource for plan visualization  figures   and   show parts of the intermediate
representation as inferred in the zeno travel example 
    heuristics
mips incorporates the following heuristic estimates 
relaxed planning heuristic  rph  approximation of the number of planning steps
needed to solve the propositional planning problem with all delete effects removed  hoffmann   nebel         the heuristic is constructive  that is it returns the set of
operators that appear in the relaxed plan 
numerical relaxed planning heuristic  numerical rph  our extension to rph to
deal with with numbers is a combined propositional and numerical approximation
scheme allowing multiple operator application 
pattern database heuristic  explicit pdb  different planning space abstractions are
found in a greedy manner  yielding a selection of pattern databases that fit into main
memory  in contrast to rph  pattern database can be designed to be disjoint yielding
an admissible estimate as needed for optimal planning in a   edelkamp      c  
   

fitaming numbers and durations in mips

 define  grounded zeno travel zeno travel   
  fluents
 at dan city a 
 at dan city b 
 at dan city c 
 at dan city d 
 at ernie city a   at ernie city b   at ernie city c   at ernie city d 
 at plane city a   at plane city b   at plane city c   at plane city d 
 at scott city a   at scott city b   at scott city c   at scott city d 
 in dan plane 
 in ernie plane   in scott plane  
  variables  fuel plane   total fuel used   total time  
  init
 at dan city c 
 at ernie city c   at plane city a   at scott city a 
    fuel plane           total fuel used         total time     
  goal  at dan city a 
 at ernie city d   at scott city d  
  metric minimize  total time   
  group dan
 at dan city a 
 at dan city b 
 at dan city c 
 at dan city d 
 in dan plane  
  group ernie
 at ernie city a   at ernie city b   at ernie city c   at ernie city d 
 in ernie plane  
  group plane
 at plane city a   at plane city b   at plane city c   at plane city d  
  group scott
 at scott city a   at scott city b   at scott city c   at scott city d 
 in scott plane  

figure    grounded representation of zeno travel domain 
symbolic pattern database heuristic  symbolic pdb  symbolic pdbs apply to explicit and symbolic heuristic search engines  edelkamp      b   due to the succinct
bdd representation of sets of states  symbolic pdbs are often orders of magnitudes
larger than explicit ones 
scheduling relaxed plan heuristic  scheduling rph  critical path analysis through
scheduling guide the plan finding phase  like rph  which computes the length of the
greedily extracted sequential plan  scheduling rph also takes the relaxed sequence
of operators into account  but searches for a suitable parallel arrangement  which in
turn defines the estimator function 
    exploration algorithms
the algorithm portfolio includes three main explicit heuristic search algorithms 
a  the a  algorithm  hart  nilsson    raphael        is a variant of dijkstras singlesource shortest path exploration scheme executed on a re weighted state space graph 
for lower bound heuristics  a  can be shown to generate optimal plans  pearl        
weighting the influence of the heuristic estimate may accelerate solution finding  but
also affects optimality  pohl        
   

fiedelkamp

  action board dan plane city a
 condition
 and  at dan city a   at plane city a  
 effect
 and  in dan plane   not  at dan city a  
 increase  total time                
     
  action zoom plane city a city b
 condition
 and
 at plane city a 
     fuel plane                
 effect
 and  at plane city b   not  at plane city a  
 increase  total time              
 increase  total fuel used               
 decrease  fuel plane                 
     
  action refuel plane city a
 condition
 and
 at plane city a 
    fuel plane                
 effect
 and
 increase  total time                      fuel plane                
 assign  fuel plane                 
     
 

figure    grounded representation of zeno travel domain  cont   

iterative deepening a   ida   the memory limited variant of a  is suited to large
exploration problems with evaluation functions of small integer range and low time
complexity  korf         ida  can be extended with bit state hashing  edelkamp  
meyer        to improve duplicate detection with respect to ordinary transposition
tables  reinefeld   marsland        
 enforced  hill climbing  hc  the approach is another compromise between exploration and exploitation  enforced hc searches with an improved evaluation in a
breadth first manner and commits established action selections as final  hoffmann 
       enforced hc is complete in undirected problem graphs 
mips also features the following two symbolic search algorithms   
   for non deterministic domains  we have started implementing the weak  strong and strong cyclic exploration algorithms of  cimatti  roveri    traverso        

   

fitaming numbers and durations in mips

bidirectional symbolic breadth first search  bdd bfs  the implementation performs bidirectional blind symbolic search  choosing the next search direction to favor
the faster execution from the previous iterations  edelkamp   helmert        
symbolic a   bdda   the algorithm  edelkamp   reffel        performs guided symbolic search and takes a  possibly partitioned  symbolic representation of the heuristic
as an additional input 
    composition of the competition version
in figure   we have shaded the parts that were actually used in the competition version of
mips in dark gray  we used the relaxed planning heuristic for sequential plan generation 
the scheduling relaxed planning heuristic was used in temporal domains  only in level  
problems did we use the numerically extended rph  since it was added to the system in the
final weeks of the competition  we experimented with  symbolic  pattern databases with
mixed results  since pattern databases are purely propositional in our implementation and
do not provide the retrieval of operators in the optimal abstract plan  we did not include
them in the competition version 
our approach to extend the relaxed planning heuristic with numerical information helps
to find plans in challenging numerical domains like settlers and was influenced by hoffmanns work on his competing planner metric ff  hoffmann      a   it builds a relaxed
planning graph by computing a fixed point of a state vector restricted to monotonically
increasing propositional and numerical variables  our version for integrating numbers into
the relaxed planning heuristic is not as general as hoffmanns contribution  it is restricted
to variable to constant comparisons and lacks the ability to simplify linear constraints 
therefore  we omit the algorithmic details in this paper 
we decided not to employ  enforced  hill climbing for explicit plan generation as is done
in metric ff and probably lpg  instead we applied a  with weight    that is the merit for
all states s  s was fixed as f  s    g s       h s   the more conservative plan generation
engine was chosen to avoid unrecognized dead ends  which we expected to be present in
benchmark problems  our objective was that  at least  completeness should be preserved 
we also avoided known incomplete pruning rules  like action relevance cuts  hoffmann  
nebel        and goal ordering cuts  koehler   hoffmann        
in mips   weighted  a  accesses both a dial and a weak heap priority queue data
structure  the former is used for propositional planning only  while the latter applies to
general planning with scheduling estimates  a dial priority queue  dial        has linear
run time behavior  if the maximal value w u  v    h v   h u  of all edges  u  v  in the
weighted state space graph  labelled with heuristic h  is bounded by a constant  weakheaps  edelkamp   stiegeler        are simple and efficient relaxations to ordinary heaps 
priority queues have been implemented as dynamic tables that double their sizes if they
become filled  moreover  mips stores all generated and expanded states in a hash table
with chaining     as a further compression of the planning state space  all variables that
appear in the objective function are neglected from hash address calculations and state
   an alternative storage structure is a collection of persistent trees  bacchus   kabanza         one for
each predicate  in the best case  queries and update times for the structure are logarithmic in the number
of represented atoms 

   

fiedelkamp

comparisons  in general  this may lead to a sub optimal pruning of duplicates  however 
for most benchmark domains this will not destroy optimality  since variables addressed in
the objective function are frequently monotonic and synonyms found later in the search
refer to worse solutions 
the price to be paid for selecting a   especially in planning problems with large branching factors  is that storing all frontier nodes is space consuming  recent techniques for
partial expansion of the horizon list  yoshizumi  miura    ishida        or reduced storage
of the visited list  korf   zhang        zhou   hansen        have not been included to
the system  in most cases  the number of expanded nodes was often not that large  while
computing the relaxed planning estimate appeared to be the computational bottleneck 
in retrospect  in the domains that were chosen  dead ends were not central  so that hill
climbers appeared to be more effective at finding solutions 
in temporal domains we introduced an additional parameter  to scale the influence
between propositional estimates  fp  s    gp  s       hp  s   and scheduled ones  fs  s   
gs  s       hs  s    more precisely  we altered the comparison function for the priority queue 
so that a comparison of parallel length priorities was invoked if the propositional difference
of values was not larger than   in    a higher value of  refers to a higher influence of the
scheduling rph  while      indicates no scheduling at all  in the competition we produced
data with       pure mips   and       optimized mips   in most comparisons of mips
to other planners the plain version is used  since it produces more solutions 
in  edelkamp      a  we experimented with an enumeration approach to fix numerical
variables to a finite domain  and with an any time wrapper for optimization of objective
functions  these options were excluded from the competition version because of their
unpredictable impact on the planners performance 
    visualization
visualization is important to ease plan understanding and to quickly detect inefficiencies
in the plan generation module  for visualization of plans with mips we extended the
animation system vega  hipke         a client server architecture that runs an annotated
algorithm on the server side  which is visualized on the client side in a java frontend  the
main purpose of the server is to make algorithms accessible through tcp ip  it is able to
receive commands from multiple clients at the same time  we have extended vega in two
ways  cf  figures   and    
gannt chart visualization gannt charts are representations for schedules  in which
horizontal bars are drawn for each activity  indicating estimated duration cost  the
user selects any planner to be executed and the domain and problem file  which are
interpreted as command line options  alternatively  established plans can be sent
directly to the visualizer with a void planner that merely mirrors the solution file 
benchmark visualization the second extension is a program suite to visualize all competition domains  at the moment  only sequential plans are shown  for temporal
plans  a refined simulation is required  like the one produced by the pddl    plan
validator  fortunately  in mips each temporal plan is a rescheduling of a sequential
one 
   

fitaming numbers and durations in mips

figure    visualization of a plan in gannt chart format 
the images that represent domain objects were collected with an image web search
engine    to generalize from specific instances  we advised the mips planner to export
propositional and numeric state infomation of an established plan in c like syntax 
which in turn is included as a header by the domain visualizer 

   pddl    planning
in this section we elaborate on metric and temporal planning in mips  we give a formal
description on grounded planning instances and introduce the temporal model that we have
   we used google  cf  www google de  and searched for small gifs

   

fiedelkamp

figure    visualization of a planning problem instance of settlers 

chosen  next we look at operator dependency and the resulting action precedence relation 
we discuss optimality of the approach and some anomalies that can occur during state
space pruning  last but not least  we turn to the treatment of arbitrary plan objective
functions 
table   displays the basic terminology for sets used in this paper  as in most currently
successful planning system  mips grounds parameterized information present in the domain
description  for each set we infer a suitable index set  indicated by a bijective mapping 
from each set to a finite domain  this embedding is important to deal with unique identifiers
of entities instead of their textual or internal representation  the arrays containing the
corresponding information can then be accessed in constant time 
   

fitaming numbers and durations in mips

set
obj
t ype
pred
fun c
act
o
f
v

descriptor
objects
object types
predicates
functions
actions
operators
fluents atoms
variables

example s 
dan  city a  plane       
aircraft  person       
 at  a  c    in  p  a        
 fuel  a    total time        
 board  a  p    refuel  a        
 board plane scott        
 at plane city b        
 fuel plane    total time        

table    basic set definitions 

consequently  like several other planning systems  mips refers to grounded planning
problem representations 
definition    grounded planning instance  a grounded planning instance is a quadruple
p   hs  i  o  gi  where s is the set of planning states  i  s is the initial state  g  s is
the set of goal states  in a mixed propositional and numerical planning problem the state
space s is given by
s   f  ir v   
where  f is the power set of f  therefore  a state s  s is a pair  sp   sn   with propositional
part sp   f and numerical part sn  ir v   
for the sake of brevity  we assume the operators are in normal form  which means that
propositional parts  preconditions and effects  satisfy standard strips notation  fikes  
nilsson        and numerical parts are given in the form of arithmetic trees t taken from
the set of all trees t with arithmetic operations in the nodes and numerical variables and
evaluated constants in the leaves  however  there is no fundamental difference for a more
general representation of preconditions and effects  the current implementation in mips
simplifies adl expressions in the preconditions and takes generic precondition trees for the
numerical parts  thereby including comparison symbols  logical operators and arithmetic
subtrees   
definition    syntax of grounded planning operators  an operator o  o in normal form
o            has propositional preconditions   f  propositional effects     a   d   
f   with add list a and delete list d   numerical preconditions   and numerical effects   a
numerical precondition c   is a triple c    hc     tc    where hc  v                  
and tc  t   where t is an arithmetic tree  a numerical effect m   is a triple m  
 hm     tm    where hm  v           and tm  t   in this case  we call hm the head of
the numerical effect 
   in newer versions of mips mixing numerical and logical preconditions of the form  or p    f      with
p  f and f  v is in fact feasible  boolean expressions are put into negational normal form and a
disjunction in the precondition will produce different action instantiations 

   

fiedelkamp

obviously                  represents the associated comparison relation   denotes an assignment to a variable  while  and  indicate a respective increase or decrease
operation 
definition    constraint satisfaction and modifier update  let  be the index mapping
for variables  a vector sn    s            s v    of numerical variables satisfies a numerical
constraint c    hc     tc     if s hc    eval sn   tc   is true  where eval sn   tc    ir is
obtained by substituting all v  v in tc by s hc   followed by a simplification of tc  
    by modifier
a vector sn    s            s v    is updated to the vector sn     s             s v 
m    hm     tm      if
 
 s h
  eval sn   tm   for     
m 
 
 s h
  s hm     eval sn   tm   for      and
m 
 
 s h
  s hm    eval sn   tm   for     
m 

we next formalize the application of planning operators to a given state 
definition    semantics of grounded planning operator application  an operator o  
          o applied to a state s    sp   sn    sp   f and sn  ir v    yields a successor
state s      sp    sn      f  ir v  as follows 
if   sp and sn satisfies all c   then sp     sp   d    a and the vector sn is updated
for all m    
the propositional update sp     sd   d    a is defined as in standard strips  as an
example take the state s    sp   sn   with
sp     at ernie city d    at plane city a    at scott city d    in dan plane  
sn     fuel plane              total fuel used                total time         
the successor sn     sp    sn    of s due to action  debark dan plane city a  with
sp      at dan city a    at ernie city d    at plane city a    at scott city d  
sn      fuel plane              total fuel used                total time         
in some effect lists the order of update operations is important  for example when
refuelling the aircraft in zenotravel  cf  figure    the fuel level has to be reset after variable
total time is updated 
the set of goal states g is often given as g    gp   gn   with a partial propositional state
description gp  f  and gn as a set of numerical conditions c    hc     tc    moreover 
the arithmetic trees tc usually collapses to simple leaves labelled with numerical constants 
hence  only for the sake of simplifying the complexity analysis for object symmetry we
might assume that  gn     v   complex goal description are no limitation to the planner 
since they can easily transformed to preconditions of an goal enabling opererator 
   

fitaming numbers and durations in mips

    temporal model
the simplest approach for solving a temporal planning problem is to generate a sequential
plan  of course  this option assumes that the temporal structure contributes only to the
value of the plan and not to its correctness  that is  it assumes that there is no necessary
concurrency in a valid plan  in cases in which actions achieve conditions at their start
points and delete them at their end points  for example  concurrency can be a necessary
part of the structure of a valid plan 
definition    sequential plan  a solution to a planning problem p   hs  i  o  gi in the
form of a sequential plan s is an ordered sequence of operators oi  o  i              k  
that transforms the initial state i into one of the goal states g  g  i e   there exists a
sequence of states si  s  i              k   with s    i  sk   g such that si is the outcome
of applying oi to si    i              k  
the time stamp ti for a durational operator oi   i              k  is its starting time  if
pi 
d oj   
d oi   is the duration of operator oi   then ti   j  
for sequential plans  time stamps are calculated in mips using the extra variable
total time  this variable is updated when scheduling operators  an example of a sequential plan with time stamps is shown in figure    
minimizing sequential plan length was the only objective in the first and second planning competitions  since graphplan like planners  blum   furst        like ipp  koehler 
nebel    dimopoulos        and stan  long   fox        already produced parallel plans
 assuming action duration     this was indeed a limiting factor in evaluating plan quality 
the most important reason for this artificial restriction was that total ordered plans were
easier to automatically validate  a necessity for checking correctness in a competition 
pddl     domain descriptions include temporal modifiers at start  over all  and at end 
where the label at start denotes the preconditions and effects at invocation time of the
action  over all refers to an invariance condition and at end to the finalization conditions
and consequences of the action 
in figure   we show two different options for flattening this information to simple
preconditions and effects in order to derive the semantic for sequential plans  in the first
case  top right   the compound operator is split into three smaller parts  one for action
invocation  one for invariance maintenance  and one for action termination  this is the
semantics suggested by  fox   long        
in pddl    there are no effects in the invariance pattern  i e  b       as in action
board  it is quite natural to code invariance in the form of conditions  b  that perform no
actual status change  when a person boards an aircraft in a city the aircraft is required to
remain at the city throughout the action  when moving through a corridor  the status of
being in the corridor that could be encoded in the invariant would change at the starting
time of the action execution 
moreover  we found that in the benchmarks it is uncommon that new effects in at start
are preconditioned for termination control or invariance maintenance  i e  a    b  c     
even though the intersection of conditions and effects are not formally defined yet  this can
be interpreted as executing one construct does not interfere with the other one  this reflects
   

fiedelkamp

pre  eff  pre  eff  pre  eff 
at start

over all

at end

cond 

a

b

c

eff 

a 

b 

c 

a a 

pre 

b b 

c c 

eff 

abc

a  b   c  

figure    compiling temporal modifiers into operators 
a possible partition of an operator into sub operators a  b  c  a    b     and c     dependence
and transposition of such separated conditions and effects are considered in section     
if we consider the example problem once more  we observe  that in the action board  a 
consists of the at  person airplane  predicate  as seen above  b requires the plane to stay
at the city of boarding  while c is empty  in action zoom  a  contains the effect that the
plane is no longer at the location where the flight started  and b and c are both empty  in
all cases we have a    b  c     
if b      and a    b  c     then the sequential execution of the sequence of
sub operators  a  a    b  b     c  c     is equal to the execution sequence  a  b  c  a    b     c     
the reasoning is as follows  since b      we have  a  a    b  b     c  c        a  a    b  c  c     
conditions a   b    and a   c    allows us to exchange the order of the corresponding
items  so that  a  a    b  c  c        a  b  c  a    c      once more  we apply b      to derive
 a  b  c  a    c        a  b  c  a    b     c      the consequence remains valid if the condition
b      is weakened to b    c    
in mips the operator representation at the bottom right of figure   was chosen  note
that the intermediate format of the example problem in figures   and   implicitly assumed
this temporal model  for sequential planning in the competition benchmark domains we
have not observed many deficiencies with this model   
however  the applicability of the model for exploiting parallelism is limited  for example
consider two people that lift a table from two sides at once  which could not be done with
just one person alone  in this case we have a parallel execution of a set of actions that
cannot be totally ordered  this is not allowed in mips  it may be argued that defining
such an action that requires two different persons to be at a certain place would require
the equality construct in pddl or some form of numerical maintenance of the number of
people in the room  but we found another  artificial  example of a planning problem with
no total order  consider the simple strips planning problem domain with i    b  
g     a  c    and o      b    a    b      b    c    b     obviously  both operators
are needed for goal achievement  but there is no sequential plan of length    since b is
deleted in both operators  however  a parallel plan could be devised  since all precondition
are fulfilled at the first time step 
   in current versions of mips we have refined the model  where at start  over all  and at end information
is preserved through the grounding process and is attached to each action  the approach does allow
dependent operators to overlap and minimizes the number of  gaps  between start start  start end and
end end exclusions  in some of the domains  this improvement yields much better solutions 

   

fitaming numbers and durations in mips

    operator dependency
the definition of operator dependency enables computing optimal schedules of sequential
plans with respect to the generated action sequence and its causal operator dependency
structure  if all operators are dependent  or void with respect to the optimizer function  
the problem is inherently sequential and no schedule leads to any improvement 
definition    dependency mutex relation  let l t  denote the set of all leaf variables in
the tree t  t   two grounded operators o            and o                        in o are
dependent mutex  if one of the following three conflicts hold 
propositional conflict the propositional precondition set of one operator has a nonempty intersection with the add or the delete list of the other  i e      a   d       
or  a  d          
direct numerical conflict the head of a numerical modifier of one operator is contained
in some condition of the other one  i e  there exists a c     h c     t c       and an
m    hm     tm     with hm  l t c     h c   or there exists a c    hc     tc     and
an m     h m     t m       with h m  l tc     hc   
indirect numerical conflict the head of the numerical modifier of one operator is contained in the formula body of the modifier of the other one  i e   there exists an
m    hm     tm     and m     h m     t m       with hm  l t m   or h m  l tm   
as an example  the operators  board scott plan city a  and  fly plane city a
city c  have a propositional conflict on the fluent  at plane city a   while  refuel
plane a city a  and  fly plane city a city c  have a direct numerical conflict on
the variable  fuel plane   indirect conflicts are more subtle  and do not appear in the
example problem 
we will use dependency to find an optimal concurrent arrangement of the operators in
the sequential plan  if o  is dependent on o  and o  appears before o  in the sequential
plan  o  has to be invoked before o  starts  the dependence relation is reflexive  i e  if o
is in conflict with o  then o  is in conflict with o  moreover  it appears restrictive when
compared to the pddl     guidelines for mutual exclusion  fox   long         which
allows operators to be partially overlapping even if they are dependent 
however  it is possible to generalize our approach  if  according to the model of fox
and long  the two actions oi are represented as  ai   a i   bi   bi    ci   ci     i          the
dependency violation between o  and o  can be located by identifying the sub operators
that interact  in fact we may identify eight possible refined conflicts in which  a   a    
interacts with  a   a       a   a     interacts with  b   b       a   a     interacts with
 c   c       b   b     interacts with  a   a       b   b     interacts with  c   c       c   c    
interacts with  a   a       c   c     interacts with  a   a      or  c   c     interacts with
 a   a      by asserting duration zero for the pair  ai   a i    d a  for  bi   bi     and again zero
for the pair  ci   ci     one can fix the earliest start and end time of o  with respect to o   
in the competition version of mips  we stick to the simplified temporal model  for
the competition domains  improving sequential plans according to this dependency relation
turned out to produce plans of sufficient quality 
   

fiedelkamp

in our implementation  the dependence relation is computed beforehand and tabulated
for constant time access  to improve the efficiency of pre computation  the set of leaf
variables is maintained in an array  once the grounded operator is constructed 
the original graphplan definition of the propositional mutex relation is close to ours 
it fixes interference as d    a        and  a        d     
lemma   if d   and d       operator inference in the graphplan model is implied
by the propositional mips model of dependence 
proof  if d   and d       for two independent operators o        and o              
   a   d       implies d   a   d        which in turn yields a  d      the condition
a   d    is inferred analogously 
the notion of dependency is also related to partial order reduction in explicit state model
checking  clarke et al          where two operators o  and o  are independent if for each
state s  s the following two properties hold 
   neither o  or o  disable the execution of the other 
   o  and o  are commutative  i e  o   o   s     o   o   s   for all s 
the next result indicates that both state space enumeration approaches refer to the
same property 
theorem    commutativity  two independent  strips  operators o        and o   
          with d   and d     are commutative and preserve the enabled property  i e 
if o and o  are enabled in s then o is enabled in o   s  and o  is enabled in o s   
proof  since d   and d       we have a d     and a  d    by lemma    let
be the state   s   d    a   and let s    be the state   s   d     a     since  a   d         
o is enabled in s      and since  a  d          o  is enabled in s     moreover 
s 

o o   s        s   d     a      d    a
     s   d      d    a     a
  s    d   d     a   a  
  s    d  d      a  a   
     s   d     d     a    a 
     s   d    a     d     a    o   o s   

as a consequence  operator independence indicates possible transpositions of two operators o  and o  to prune exploration in sequential plan generation  a less restrictive
notion of independence  in which several actions may occur at the same time even if one
deletes an add effect of another is provided in  knoblock         to detect domains for
which parallelization leads to no improvement  we utilize the following sufficient criterion 
   

fitaming numbers and durations in mips

definition    inherent sequential domains  a planning domain is said to be inherently
sequential if each operator in any sequential plan is either instantaneous  i e  with zero
duration  or dependent on its immediate predecessor 
the static analyzer checks this by testing each operator pair  while some benchmark domains like desertrats and jugs and water are inherently sequential  others like zenotravel
and taxi are not 
definition    parallel plan  a solution to a planning problem p   hs  i  o  gi in the
form of a parallel plan c     o    t              ok   tk    is an arrangement of operators oi  o 
i              k   that transforms the initial state i into one of the goal states g  g  where
oi is executed at time ti  ir   
an example of a parallel plan for the zenotravel problem is depicted in figure    
backstom        clearly distinguishes partially ordered plans  o            ok      with the
relation    o            ok    being a partial order  reflexive  transitive  and antisymmetric   from parallel plans  o            ok         with            irreflexive  symmetric 
expressing  which actions must not be executed in parallel 
definition    precedence ordering  an ordering d induced by the operators o            ok
is defined by
oi d oj    oi and oj are dependent and    i   j  k 
precedence is not a partial ordering  since it is neither reflexive nor transitive  by computing
the transitive closure of the relation  however  precedence could be extended to a partial
ordering  a sequential plan o            ok produces an acyclic set of precedence constraints
oi d oj      i   j  k  on the set of operators  it is also important to observe  that the
constraints are already topologically sorted according to d with the index order            k 
definition     respecting precedence ordering in parallel plan  for o  o let d o  
ir  be the duration of operator o in a sequential plan  in a parallel plan c     o    t    
         ok   tk    that respects d   we have ti   d oi    tj for oi d oj      i   j  k 
for optimizing plans  backstrom        defines parallel execution time as max ti  
d oi     oi   o            ok     so that if oi  oj   then ti   d oi    tj   and if oi  oj   then
either ti   d oi    tj or tj   d oj    ti   these two possible choices in   are actually not
apparent in our approach  since we already have a precedence relation at hand and just
seek the optimal arrangement of operators  consequently we assert that only one option 
namely ti   d oi    tj can be true  reducing   to d   in order to find optimal schedules
of sequential plans an approach similar to  backstrom        would be necessary  this
would dramatically increase the computational complexity  since optimal scheduling of a
set of fixed timed operators is np hard  therefore  we decided to restrict the dependency
relation to d  
definition     optimal parallel plan  an optimal parallel plan with respect to a sequence
of operators o            ok and precedence ordering d is a plan       o    t              ok   tk   
with minimal parallel execution time op t   max ti   d oi     oi   o            ok    among
all parallel plans c     o    t               ok   t k    that respect d  
   

fiedelkamp

procedure critical path
input  sequence of operators o            ok   precedence ordering d
output  optimal parallel plan length max ti   d oi     oi   o            ok   
for all i              k 
e oi    d oi  
for all j              i    
if  oj d oi  
if e oi     e oj     d oi  
e oi    e oj     d oi  
return max ik e oi  

figure     algorithm to compute critical path costs 
many algorithms have been suggested to convert sequential plans into partially ordered
ones  pednault        regnier   fade        veloso  perez    carbonell         most
of them interpret a totally ordered plan as a maximal constrained partial ordering   
  oi   oj        i   j  k  and search for less constrained plans  however  the problem of
minimum constraint deordering has also been proven to be np hard  unless the so called
validity check is polynomial  backstrom         where deordering maintains validity of the
plan by lessening its constrainedness  i e     for a new ordering    
since we have an explicit model of dependency and time  optimal parallel plans will not
change the ordering relation d at all 
    critical path analysis
the project evaluation and review technique  pert  is a critical path analysis algorithm
usually applied to project management problems  a critical path is a sequence of activities
such that the total time for activities on this path is greater than or equal to any other
path of operators  a delay in any tasks on the critical path leads to a delay in the project 
the heart of pert is a network of tasks needed to complete a project  showing the order
in which the tasks need to be completed and the dependencies between them 
as shown in figure     pert scheduling reduces to a variant of dijkstras shortest
path algorithm in acyclic graphs  cormen  leiserson    rivest         as a matter of fact 
the algorithm returns the length of the critical path and not the inferred partially ordered
plan  however  obtaining the temporal plan is easy  in the algorithm  e oi   is the tentative
earliest end time of operator oi   i              k   while the earliest starting times ti for all
operators in the optimal plan are given by ti   e oi    d oi   
theorem    pert scheduling  given a sequence of operators o            ok and a precedence ordering d   an optimal parallel plan       o    t              ok   tk    can be computed in
optimal time o k     d    
proof  the proof is by induction on i              k   the induction hypothesis is that
after iteration i the value e oi   is correct  e g  e oi   is the earliest end time of operator
   

fitaming numbers and durations in mips

oi   this is clearly true for i      since e o      d o     we now assume that the hypothesis
is true    j   i and look at iteration i  there are two choices  either there is a j 
            i     with oj d oi   for this case after the inner loop is completed  e oi   is
set to max e oj     d oj     oj d oi   j              i       on the other hand  e oi   is
optimal  since oi cannot start earlier than max e oj     oj d oi   j              i       since
all values e oj   are already the smallest possible by the induction hypothesis  if there is
no j              i     with oj d oi   then e oi     d oi   as in the base case  therefore  at
the end  max ik e oi   is the optimal parallel path length 
the time and space complexity of the algorithm critical path are clearly in o k     
where k is the length of the sequential plan  using an adjacency list representation these
efforts can be reduced to time and space proportional to the number of vertices and edges
in the dependence graph  which are of size o k     d     the bound is optimal  since the
input consists of  k  operators and    d    dependencies among them 
can we apply critical path scheduling  even if we consider the temporal model of fox
and long  allowing overlapping operator execution of dependent operators  the answer is
yes  we have already seen that when considering two dependent operators oi and oj in the
fox and long model  we can determine the earliest start  and end  time of oj with respect
to the fixed start time of oi   this is all that we need  the proof of theorem   shows that
we can determine the earliest end time for the operators sequentially 
    on the optimality of mips
since mips optimally schedules sequential plans  the question remains  will the system
eventually find an optimal plan  in the competition  the system terminates when the
first sequential plan is found  since the relaxed planning heuristic is not admissible  all
a  variants cannot guarantee optimal  sequential or parallel  plans  however  computing
optimal plans is desirable  even if  due to limited computational resources  finding optimal
plans is hard 
according to our temporal model  in an optimal parallel plan  each operator either starts
or ends at the start or end time of another operator  therefore  at least for a finite number
of actions in the optimal plan  we have a possibly exponential but finite number of possible
parallel plans 
this immediately leads to the following naive plan enumeration algorithm  for all  o i
operator sequences of length i  i  in  generate all possible parallel plans  check for each
individual schedule if it transforms the initial state into one of the goals  and take the
sequence with smallest parallel plan length  since all parallel plans are computed  this yields
a complete and optimal algorithm  as seen in the example of two persons lifting a table 
this approach can be more expressive than applying any algorithm that finds sequential
plans first  however  the algorithm is very inefficient 
in practice  the natural assumption is that each parallel plan corresponds to at least one
 possible many  sequential one s   conversely  each partially ordered plan can be established
by generating a totally ordered plan first and then applying a scheduling algorithm to it to
find its best partial order 
the algorithm in the figure    indicates how to wrap a forward chaining planner so
that it has any time performance and gradually improves plan quality  the general state
   

fiedelkamp

procedure any time
input  planning problem hs  i  o  gi
output  optimal parallel plan length 

open  i
while  open     
s  extract open 
for all s    expand s 
if  s    g 
cp  critical path  path s      d  
if  cp    
  cp
else
change open  s    
return 
figure     general any time search algorithm 
expanding scheme maintains the search horizon in the list open  for simplicity the maintenance of stored nodes in the list closed is not shown  in the algorithm  the current best
critical path cost  bounds the upcoming exploration process  in turn  is updated each
time a plan is found with a shorter critical path 
as in the criticalpath procedure above  the algorithm returns the execution time only 
and not the established plan  to compute the plan that meets the returned value   we also
store the schedule of the generating sequence path s     in a global record  in most cases 
storing s   is sufficient  since the path and its pert scheduling can be restored by calling
procedure criticalpath at the end of the procedure 
assuming that each optimal parallel plan is a schedule of a sequential plan and the state
space is finite  the any time extension for a cycle avoiding enumeration strategy is indeed
complete and optimal  the reason for completeness in finite graphs is that the number of
acyclic paths in g is finite and with every node expansion  such an algorithm adds new
links to its traversal tree  each newly added link represents a new acyclic path  so that 
eventually  the reservoir of paths must be exhausted 
are there also valid parallel plans that cannot be produced by pert scheduling of a
sequential plan  the answer is no  if a partial ordering algorithm terminates with an
optimal schedule  we can generate a corresponding sequential plan while preserving the
dependency structure  optimal pert scheduling of this plan with respect to the set of
operators and the imposed precedence relation will yield the optimal parallel plan  if all
sequential plans are eventually generated  the optimal parallel plan will also be found by
pert scheduling 
the problem of enumeration in infinite state spaces is that there can be infinite plateaus
where the plan objective function has a constant value  normally increasing the length of
a plan increases the cost  however  this is not true in all benchmark problems  since there
   

fitaming numbers and durations in mips

may be an infinite sequence of events that do not contribute to the plan objective  for
example  loading and unloading tanks in the pre competition test domain desertrats does
not affect total fuel consumption  which has to be minimized in one of the instances 
enumeration schemes do not contradict known undecidability results in numerical planning  helmert         if we have no additional information like a bound on the maximal
number of actions in a plan or on the number of actions that can be executed in parallel  we
cannot decide whether a cycle free enumeration will terminate or not  on the other hand
if there is a solution  the any time algorithm will eventually find it 
    pruning anomalies
acceleration techniques like duplicate detection in sequential plan generation have to be
chosen carefully to maintain parallel plan length optimality  this approach does affect
parallel optimality  as the following example shows  in the zenotravel problem consider
the sequences
 zoom city a city c plane    board dan plane city c  
 refuel plane city c    zoom city c city a plane  
 board scott plane city a    debark dan plane city a    refuel plane city a  
and
 board scott plane city a    zoom city a city c plane  
 board dan plane city c    refuel plane city c  
 zoom city c city a plane    debark dan plane city a    refuel plane city a 
the two sets of operators are the same and so are the resulting  sequentially generated 
states  however  the pert schedule for the first sequence is shorter than the schedule for
the second one  because boarding scott can be done in parallel with the final two actions
in the plan 
for small problems  such anomalies can be avoided by omitting duplicate pruning  as
an example figure    depicts a sequential plan for the example problem instance and its
pert schedule  which turns out to be the overall optimal parallel plan  another option is
to store the resulting parallel plan for state caching instead of the sequential one  note that
in order to ease generation of sequential solutions for large planning problem instances  in
the competition version of mips we used sequential state pruning 
    heuristic search
the main drawback of blind path enumeration is that it is seemingly too slow for practical
planning  heuristic search algorithms like a  and ida  reorder the traversal of states 
and  assuming no state caching  do not affect completeness and optimality of the anytime wrapper  the efficiency of the wrapper directly depends on the quality of the path
enumeration  in the competition version of mips we omitted any time wrapping  since
optimal solutions were not required and the practical run time behavior is poor 
instead we used an a  search engine  that terminates on the first established solution 
the question remains  is there still hope of finding near optimal parallel plans  a general
result also applicable for infinite graphs was established by  pearl         if the cost of every
   

fiedelkamp

  
    
    
    
    
    
    
    
    
    
    
    
    

 zoom plane city a city c       
 board dan plane city c 
    
 board ernie plane city c      
 refuel plane city c 
    
 zoom plane city c city a       
 debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
 zoom plane city a city c       
 refuel plane city c 
    
 zoom plane city c city d       
 debark ernie plane city d      
 debark scott plane city d      

    zoom plane city a city c       
      board dan plane city c 
    
 board ernie plane city c      
      refuel plane city c 
    
      zoom plane city c city a       
      debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
      zoom plane city a city c       
      refuel plane city c 
    
      zoom plane city c city d       
      debark ernie plane city d      
 debark scott plane city d      

figure     a sequential plan for zeno travel  left  and its pert schedule  right  

infinite path is unbounded  a s cost function f   g   h will preserve optimality  this is
additional rationale for choosing an a  like exploration in mips instead of hill climbing or
best first  as in breadth first search  the rising influence of the g value is crucial 
to find an adequate heuristic estimate for parallel plans is not easy  in fact we have
not established a competitive and admissible heuristic  which is required for optimal plan
finding in a   our choice was a scheduling extension to rph  in contrast to the rph  the
new heuristic takes the relaxed sequence of operators and searches for a suitable parallel
arrangement  which in turn defines the estimator function 
we found that adding pert schedules for the path to a state and for the sequence of
actions in the relaxed plan is not as accurate as the pert schedule of the combined paths 
therefore  the classical merit function of a  like search engines f   g  h of generating path
length g and heuristic estimate h has no immediate correspondence for parallel planning 
consequently  we define the heuristic value of scheduling rph as the parallel plan length
of the combined path minus the parallel plan length of the generating path 
    arbitrary plan objectives
in pddl     plan metrics other than minimizing total  parallel  execution time can be
specified  this influences the inferred solutions  in figure    we depict two plans found
by mips for the objective functions of minimizing total fuel used  and minimizing the
compound           total time         total fuel used    
for the first case we computed an optimal value of           while for the second case we
established          as the optimized merit  when optimizing time  the ordering of board
and zoom actions is important  when optimizing total fuel we reduce speed to save fuel
consumption to        per flight but we may board the first passenger immediately  we
also save two refuel actions with respect to the first case 
when increasing the importance of time we can trade refueling actions for time  so that
both zooming and flight actions are chosen for the complex minimization criterion 
the first attempt to include arbitrary plan objectives was to alter the pert scheduling
process  however  the results did not match the ones produced by the validator  long  
   

fitaming numbers and durations in mips

    zoom plane city a city c       
      board dan plane city c 
    
 board ernie plane city c      
 refuel plane city c 
    
      zoom plane city c city a       
      debark dan plane city a 
    
 board scott plane city a      
 refuel plane city a 
    
      fly plane city a city c       
      fly plane city c city d       
      debark ernie plane city d      
 debark scott plane city d      

    board scott plane city a      
     fly plane city a city c       
      board ernie plane city c      
 board dan plane city c 
    
      fly plane city c city a       
      debark dan plane city a      
 refuel plane city a 
       
         fly plane city a city c       
         fly plane city c city d       
         debark ernie plane city d     
 debark scott plane city d     

figure     optimized plans in zeno travel according to different plan objectives 
fox         in which the final time is substituted in the objective function after the plan
has been built 
the way mips evaluates objective functions with time is as follows  first it schedules the
 relaxed or final  sequential plan  variable total time is temporarily substituted for the
critical path value and the objective formula is evaluated  to avoid conflicts in subsequent
expansions  afterwards value total time is set back to the optimal one in the sequential
plan 

   object symmetries
an important feature of parameterized predicates  functions and action descriptions in the
domain specification file is that actions are transparent to different bindings of parameters
to objects  disambiguating information is only present in the problem instance file 
in the case of typed domains  many planners  including mips  compile all type information into additional predicates  attach additional preconditions to actions and enrich the
initial states by suitable object to type atoms 
as a consequence  a symmetry is viewed as a permutation of objects that are present in
the current state  in the goal representation  and transparent to the set of operators 
there are n   n    obj    possible permutations of the set of objects  taking into
account all type information reduces the number of all possible permutation to
n
t    t             t k

 

 

n 
 
t   t          tk  

where ti is the number of objects with type i  i              k   in a moderate sized logistic
domain with    cities     trucks    airplanes  and    packages  this results in               
               permutations 
to reduce the number of potential symmetries to a tractable size we restrict symmetries
to object transpositions  for which we have at most n n        o n    candidates  using
type information this number reduces to
k
x
ti
i  

 

 

 

k
x

ti  ti       

i  

   

fiedelkamp

in the following  the set of typed object transpositions is denoted by symm  for the
logistics example  we have  symm                             
    generating object symmetries for planning problems
in this section we compute the subset of symm that includes all object pairs for which the
entire planning problem is symmetric  we start with object transpositions for the smallest
entities of a planning problem 
definition     object transpositions for fluents  variables  and operators  a transposition of objects  o  o     symm applied to a fluent f    p o            ok p     f  written as
f  o  o     is defined as  p o             o k p     with o i   oi if oi 
   o  o     oi   o  if oi   o 
and oi   o if oi   o    i              k p    object transpositions  o  o    applied to a variable
v    f o            ok f      v or to an operator o    a o            ok a     o are defined analogously 
for example  in the zenotravel problem we have  at scott city a  scott  dan   
 at dan city a  
lemma   for all f  f  v  v  o  o  and  o  o     symm  f  o  o      f  o   o  
v o  o      v o   o   and o o  o      o o   o   as well as f  o  o    o  o      f  
v o  o    o  o      v  and o o  o    o  o      o 
the brute force time complexity for computing f  o  o     f is of order o k p    where
k p  is the number of object parameters in p  however  by pre computing a o  symm  
 f   sized lookup table  containing the index of f     f  o  o    for all  o  o     symm 
this time complexity can be reduced to o    
definition     object transpositions for states  let  be the mapping from set t to
             t     an object transposition  o  o    applied to state s    sp   sn    s with
sn    v            vk    k    v   written as s o  o     is equal to  sp  o  o     sn  o  o     with
sp  o  o       f    f   f  sp  f     f  o  o    
and sn  o  o       v             vk    with vi   vj  if    i  o  o         j  for i  j              k  
in the initial state of the example problem we have i dan  ernie    i  the definition
for variables is slightly more difficult than for predicates  since  in this case  the variable
contents  not just their availability  must match 
the time complexity to compute sn  o  o    is o k   since testing    i  o  o     
   j  is available in time o    by building another o  symm    v   sized pre computed
look up table  note that these times are worst case  we can terminate the computation of
an object symmetry if a fluent or variable is contradictory  we summarize the complexity
results as follows 
lemma   the worst case time complexity to compute s o  o    for state s    sp   sn    s
and  o  o     symm is o  sp      v   using o  symm     f     v    space 
the next step is to lift the concept of object transposition to planning problems 
   

fitaming numbers and durations in mips

definition     object transpositions for domains  a planning problem p   hs  o  i  gi
is symmetric with respect to the object transposition  o  o     abbreviated as p o  o     if
i o  o      i and  g  g  g o  o     g 
since goal descriptions are partial  we prefer writing g o  o     g instead of  g  g 
g o  o     g  moreover  we assume the goal description complexity for g to be bounded
by o  gp      v   
for the zenotravel problem  the goal descriptor is purely propositional  containing three
facts for the target location of dan  ernie  and scott  in the initial state of the running
example the planning problem contains no object symmetry  since i scott  ernie     i
and g dan  ernie     g 
applying lemma   for all  o  o     symm yields the time complexity needed to establish all object symmetries 
theorem    time complexity for object symmetry detection  the worst case run time to
determine the set of all object transpositions for which a planning problem p   hs  o  i  gi
is symmetric is o  symm     gp      ip      v    
    including goal symmetry conditions
symmetries that are present in the initial state may vanish or reappear during exploration in
a forward chaining planner like mips  in the desertrats domain  for example  the initial set
of supply tanks is indistinguishable so that only one should be loaded into the truck  once
the fuel levels of the supply tanks decrease or tanks are transported to another location 
previously existing symmetries are broken  however  when two tanks in one location become
empty  they can once again be considered symmetric 
goal conditions  however  do not change over time  only the initial state i transforms
into the current state c  therefore  in a pre compiling phase we refine the set symm to
symm    o  o     symm   g o  o      g  


 

usually   symm    is much smaller than  symm   for the zenotravel problem instance 
the only object symmetry left in symm  is the transposition of scott and ernie 
therefore  we can efficiently compute the set
symm    c     o  o     symm    c o  o      c 
of symmetries that are present in the current state  in the initial state i of the example
problem of zeno travel we have symm    i      but once scott and ernie share the
same location in a state c this object pair would be included in symm    c  
the definition requires c o  o      c  this does not include symmetric paths from
different states  let c     at ernie city c    at scott city d    it is possible that
there is a symmetric plan for   at ernie city d    at scott city c   to a common
goal  viewed differently  complex object symmetries of the form  o   o     o   o     are not
detected  for the example we observe c scott  ernie  city c  city d    c 
with respect to theorem   this additional restriction reduces the time complexity to
detect all remaining object symmetries to o  symm       cp      v    
   

fiedelkamp

    pruning operators
if a planning problem with current state c  s is symmetric with respect to the operator
transposition  o  o    then either the application of operator o  o or the application
of operator o o  o    is neglected  significantly reducing the branching factor  lemma  
indicates how symmetry is used to reduce exploration 
lemma   if operator o is applicable in s and s   s o  o    then o o  o    is applicable
in s and
o s  o  o      o o  o    s  
proof  if o is applicable in s then o o  o    is applicable in s o  o     since s  
s o  o     o o  o    is applicable in s  and
o o  o    s    o o  o    s o  o       o s  o  o    

by pre computing an o  symm    o   sized table the index  o    of operator o   
o o  o    can be determined in time o    for each  o  o     symm   
definition     pruning set  let  be the index mapping from set t to              t    and let
 c  be the set of operators that are applicable in state c  s  the pruning set  c    c 
is defined as the set of all operators that have a symmetric counterpart and that are not of
minimal index  the symmetry reduction    c    c  is defined as  c     c  
theorem    correctness of operator pruning  reducing the operator set  c  to    c 
during the exploration of planning problem p   hs  o  i  gi preserves completeness   
proof  suppose that for some expanded state c  reducing the operator set  c  to    c 
during the exploration of planning problem p   hs  o  i  gi does not preserve completeness 
furthermore  let c be the state with this property that is maximal in the exploration order 
then there is a sequential plan     o          ok   in pc   hs  o  c  gi with associated
state sequence  s    c          sk  g   obviously  oi   si     i              k   by the
choice of c we have o    s         s       s     by the definition of the pruning set
 s    there exists o     o   o  o    of minimal index that is applicable in s   
since pc   hs  o  c  gi   pc  o  o      hs  o  c o  o      c  g o  o      gi   we have
a sequential plan o   o  o             ok  o  o    with state sequence  s   o  o      s    s   o 
o             sk  o  o      sk   that reaches the goal g  this contradicts the assumption that
reducing the operator set  c  to    c  does not preserve completeness for all c 
since the plan objective refers to instantiated predicates and objects  similar to the
initial and goal state  it can be symmetry breaking  in order to preserve optimality  one
has to additionally check  to see if the object exchange will influence the plan objective 
in practice  objective functions are often based on non parameterized predicates  in which
case an optimal planning algorithm will not be affected by symmetry cuts 
   generally completeness means that a planner can find any legal plan  this is not what is intended here 
we use completeness here in terms of discarding legal plans in favor to equally good symmetric plans 

   

fitaming numbers and durations in mips

    symmetry reduction in mips
the main purpose of the restricted implementation in mips is to further reduce the run
time for object symmetry detection by losing some but not all of its effectiveness  especially
the impact of quantity o  symm      cp    for the running time can be considerable 
the key observation is that symmetries are also present in fact groups according to their
group representatives  as shown in figure    the fact group of dan consists of the facts
 at dan city a    at dan city b    at dan city c    at dan city d   and  in dan
plane   similarily  ernies group has facts  at ernie city a    at ernie city b    at
ernie city c    at ernie city d   and  in ernie plane   the ordering of the facts in
the groups can be chosen in a way that  except for the change in the group representative 
corresponding facts match  together with the facts in the groups  the operators that change
facts of the groups  are stored in an efficient dictionary 
therefore  we restrict object transpositions to group representatives  this reduces the
set of objects obj that mips considers to a considerably smaller subset obj     in the
example problem we have  obj        and  obj          many objects  e g  the objects of
type city in zenotravel  were not selected as representatives for a single attribute invariance
to build a group 
the idea is to obtain a possible transposition of fact group representatives  followed by
looking at the respective fact positions of the current and goal state  it may happen  that
more than one group has fixed representative o  obj     in this case  we link groups that
have representative o in common  for symmetry detection we test the group chains of both
objects for a matching current and goal position 
as above  symmetries based on non matching goal predicates can be excluded beforehand  let rsymm be the number of remaining symmetries of object representatives 
assume that one representative per group yields a running time for propositional object
symmetry detection in state c of o rsymm    cp     the remaining comparisons of variables v  v are implemented as described in the previous section  but are to be performed
only for those object pairs that pass the propositional check 
for pruning operators  mips marks all groups that correspond to an object symmetry
and that have larger index as visited  this guarantees that an operator of at least one
group is executed  for each expanded state s and each matching operator o   s  the
algorithm checks  whether an applied operator is present in a visited group  in which case
it is pruned  the time complexity is o   s     since operator group containment can be
preprocessed and checked in constant time 
figure    shows the effectiveness of symmetry reduction of the planner mips in the desertrats domain  which scales with respect to the total distance d  d                       
that has to be passed  x axis   in the y direction  the number of expanded states in an a 
search of mips with object symmetry reduction  right bars  and without symmetry reduction  left bars  is shown on a logarithmic scale  as expected  for larger problems symmetry
reduction yields performance gains of more than one order magnitude  d         it also
yields solutions to problems where all algorithms without symmetry reduction fail due to
memory restrictions  d          
   the memory bound we used for this example was set to     gbyte 

   

fiedelkamp

figure     results in symmetry pruning in desert rats  bars show the number of states
expanded without with symmetry detection 

   related work
strips problems have been tackled with different planning techniques  most notably
by sat planning  kautz   selman         ip planning  kautz   walser         cspplanning  rintanen   jungholt         graph relaxation  blum   furst         and heuristic
search planning  bonet   geffner        
solving planning problems with numerical preconditions and effects as allowed in level  
and level   problems is undecidable in general  helmert         however  the structures
of the provided benchmark problems are simpler than the general problem class  so these
problems are in fact solvable 
    temporal planning approaches
the system metric ff  hoffmann      a  extends ff  hoffmann   nebel        as a
forward chaining heuristic state space planner for level   problems  although  mips plan
generator shares several ideas with metric ff  hoffmanns system has not yet been extended
to deal with temporal domains 
planner tp   haslum   geffner        is in fact a scheduling system based on grounded
problem instances  for these cases all formula trees in numerical conditions and assignments
reduce to constants  utilizing admissible heuristics  tp  minimizes the plan objective of
optimal parallel plan length  our planner has some distinctive advantages  it handles
numerical preconditions  instantiates numerical conditions on the fly and can cope with
complex objective functions  besides its input restriction  in the competition  tp  was
somewhat limited by its focus on producing only optimal solutions 
the sapa system  do   kambhampati        is a domain independent time and resource planner that can cope with metrics and concurrent actions  sapas general expressivity can be judged to be close to that of mips  it adapts the forward chaining algorithm
of  bacchus   ady         both planning approaches instantiate actions on the fly and
   

fitaming numbers and durations in mips

can therefore  in principle  be adapted to handle flexible mixed propositional and numerical planning problems  the search algorithm in sapa extends partial concurrent plans
instead of parallelizing sequential plans  it uses a relaxed temporal planning graph for the
yet unplanned events for different heuristic evaluation functions  as an additional feature 
sapa provides the option of specifying deadlines 
the planner lpg  gerevini   serina        is based on local search in planning graphs 
it uses a variant of the ff planner for grounding and initial plans are generated through random walk  the subsequent search space of lpg consists of so called action graphs  gerevini
  serina         the temporal module performs action graph modifications transforming
an action graph into another one  the fast plan generation algorithm in lpg seems to be
the best explanation for the speed advantage that lpg has with respect to mips  and the
higher number of problems lpg solved in some domains  optimization in lpg is governed
by lagrange multipliers  in temporal domains  actions are ordered using a precedence graph
that is maintained during search  which uses a more refined dependency relation than ours 
this may partly explain why plan quality was in fact consistently better than in mips 
ixtet  laborie   ghallab        is a general constraint based planning system with its
own input format  the planner searches in the space of partial plans and allows general
resource and temporal constraints to be posed  the internal representation consists of
chronicles  with time as a linearly ordered discrete set of instants  and multi valued state
variables that are either rigid or flexible  contingent  controllable  resources   predicates as
temporally qualified expressions  events  assertions  resources   and temporal and atemporal
constraints  it is not clear how to compare the expressivity of chronicles with pddl   
constructs  this makes it difficult to link the different temporal models and to determine if
the technique of critical path scheduling will be applicable to ixtet or not  in our opinion
this is unlikely  since ixtet is partial order  note that ixtet further allows conjunction
of predicates  subtasks  constraints and conditional expressions  which are not available in
pddl     the analysis of partial plans that drives the planning process is divided into
three different modules  feasibility  satisfiability and resource conflict resolution  in the
competition domains ixtet was not able to compete with local search and heuristic search
planners 
hsts  muscettola        is a constraint based planning system based on temporal activity networks  written in lisp and crl  at nasa it has been used in many projects
like deep space one  it can already represent and reason about metric resources  parallel
activities  and general constraints  as in ixtet the input format is significantly different
from pddl     hsts has not yet been adapted to represent or reason with conditional
branches  however experiences with the hsts planner showed partial order planning to be
attractive for metric temporal problems  but with a need for better search control 
although the pddl    guidelines in fact do allow infinite branching  the      competition consisted only of finite branching problems  as we indicated earlier  this paper
also concentrates on finite branching problems  with finite branching  execution time of an
action is fixed  while with infinite branching  a continous range of actions is available 
these problems have been confronted by  real time  model checking for a long time 
some subclasses of infinite branching problems like timed automata exhibit a finite partitioning through a symbolic representation of states  pettersson         by the technique
of shortest path reduction a unique and reduced normal form can be obtained  we have
   

fiedelkamp

implemented this temporal network structure  since this is the main data structure when
exploring timed automata as done by the model checker uppaal  pettersson         for
this to work  all constraints must have the form xi  xj  c or xi  c  for example  the
set of constraints x   x      x   x      x   x      x   x      x   x     
x   x      x   x      x   x      x   x       and x   x     has the shortest path
reduction x   x      x   x      x   x      x   x      x   x      x   x      
and x   x      if the constraint set is over constrained  the algorithm will determine
unsolvability  otherwise a feasible solution is returned 
critical path analysis for timed precedence networks is one of the simpler cases for
scheduling  we have achieved a simplification by solving the sequential path problem first 
note that many other scheduling techniques apply the presented critical path analysis as a
subcomponent  syslo  deo    kowalik        
    symmetry detection in planning and model checkers
most previous results in symmetry reduction in planning  e g   guere   alami        
neglect the combinatorial explosion of possible symmetries or at least assume that the
information on existing symmetries in the domain is supplied by the user 
in contrast  our work shares similarities with the approach of fox   long             in
inferring object symmetry information fully automatically  fox and longs work is based on
similarities established by the tim inference module  fox   long         during the search
additional information on the current symmetry level in the form of an object transposition
matrix is stored and updated together with each state  our approach is different in the sense
that it efficiently computes object symmetries for each state from scratch and it consumes
no extra space per node expansion 
model checking research has a long tradition in symmetry reduction  clarke et al         
in recent work  rintanen        connects symmetry detection in planning to model checking
approaches for transition systems and sat solving  experiments are provided for sat
encodings of the gripper domain  a prototypical example for symmetry detection  in  lluchlafuente         our model checker hsf spin is extended to effectively combine heuristic
search with symmetry detection  it also reflects the fact that  hsf  spins exploration can
be modelled using  labelled  transition systems  positive empirical results are given for
non trivial examples like petersons mutual exclusion algorithm and the database manager
protocol 
we briefly review the fundamental difference between object symmetries  as considered
here  and state space symmetries  as considered in model checking  
the latter approach constructs a quotient state space problem  p   based on a congruence relation  where an equivalence relation  of s is called a congruence if for all
s    s    s   s with s   s  and operator o  o with o s      s   there is an s    s with
s    s   and an operator o   o with o   s      s     we have  o  s     s    if and only if there
is an operator o  o mapping s to s  so that s   s  and s    s    
a bijection    s  s is said to be a symmetry if  i    i   g   g for all g  g
and for any s  s   s with transition from s to s  there exist a transition from  s  to
 s     any set a of symmetries generates a subgroup g a  called a symmetry group  the
subgroup g a  induces an equivalence relation a on states  defined as s a s  if and only
   

fitaming numbers and durations in mips

if  s    s  and   g a   such an equivalence relation is called a symmetry relation on
p induced by a  the equivalence class of s is called the orbit of s  denoted as  s a   any
symmetry relation on p is a congruence on p  moreover  s is reachable if and only if  s a
is reachable from  i a   this reduces the search for goal g  g to finding state  g  
to explore a state space with respect to a state  space  symmetry  a function canonicalize is needed  each time a new successor node is generated  it determines a representative
element for each equivalence class  fixing the canonical element is not trivial  so that many
systems approximate this normal form  automatically finding symmetries in this setting
is also difficult and can be cast as a computationally hard graph isomorphism problem 
therefore all approaches expect information on the kind of symmetry that is present in
the state space graph  one example is a rotational symmetry  defined by a right shift of
variables in the state vector 
    model checking planners
in the      competition  two other symbolic planners took part  propplan  fourman 
       and bddplan  holldobler   stor         although they did not receive any awards
for performance  they show interesting properties  propplan performs symbolic forward
breadth first search to explore propositional planning problems with propositions for generalized action preconditions and generalized action effects  it performed well in the full
adl miconic    elevator domain  koehler         probplan is written in the poly ml
implementation of sml  bdd plan is based on solving the entailment problem in the fluent calculus with bdds  at that time the authors acknowledged that the concise domain
encoding and symbolic heuristic search used in mips were improvements 
in the model based planner mbp the paradigm of planning as symbolic model checking  giunchiglia   traverso        has been implemented for non deterministic planning
domains  cimatti et al          which can be classified into weak  strong  and strong cyclic
planning  with plans that are represented as state action tables  for partially observable
planning  a system is faced with exploring the space of belief states  the power set of the
original planning space  therefore  in contrast to the successor set generation based on action application  observations introduce and nodes into the search tree  bertoli  cimatti 
roveri    traverso      b   since the approach is a hybrid of symbolic representation of
belief states and explicit search within the and or search tree  simple heuristics have
been applied to guide the search  the need for heuristics that trade information gain for
exploration effort is also apparent in conformant planning  bertoli et al       a   recent
work  bertoli   cimatti        proposes improved heuristics for belief space planning 
the umop system parses a non deterministic agent domain language that explicitly
defines a controllable system in an uncontrollable environment  jensen   veloso        
the planner also applies bdd refinement techniques such as automated transition function
partitioning  new results for the umop system extend weak  strong and strong cyclic
planning to adversarial planning  in which the environment actively influences the outcome
of actions  in fact  the proposed algorithm combines aspects of both symbolic search and
game playing  umop has not yet participated in a planning competition 
more recent developments in symbolic exploration are expected to influence automated
planning in the near future  with seta    jensen et al         provide an improved imple   

fiedelkamp

mentation of the symbolic heuristic search algorithm bdda   edelkamp   reffel       
and weighted bdda   edelkamp      a   one improvement is that seta  maintains finer
grained sets of states in the search horizon  these are kept in a matrix according to matching g  and h  values  this contrasts with the plain bucket representation of the priority
queue based on f  values  the heuristic function is implicitly encoded with value differences
of grounded actions  since sets of states are to be evaluated and some heuristics are state
rather than operator dependent it remains to be shown how general this approach is  as
above  the planning benchmarks considered are seemingly simple for single state heuristic search exploration  hoffmann      b  helmert          hansen  zhou    feng       
also re implemented bdda  and suggest that symbolic search heuristics and exploration
algorithms are probably better implemented with algebraic decision diagrams  adds   although the authors achieved no improvement to  edelkamp   reffel        in solving the
 n      puzzle  the established generalization to guide a symbolic version of the lao  exploration algorithm  hansen   zilberstein        for probabilistic  mdp  planning results
in a remarkable improvement in the state of the art  feng   hansen        

   conclusions
with the competition planning system mips  we have contributed a flexible system for a
heuristic forward chaining  explicit and symbolic search planner that finds plans in finitebranching numerical problems  the planner parses  pre compiles  solves  and schedules
problem instances  including complex ones with duration  resource variables and different
objective functions  the main contributions of the planner are
 the object oriented workbench architecture to choose and combine different heuristics with different search algorithms and storage structures  the design includes the
static analyzer that applies efficient fact space exploration to distinguish constant
from fluent quantities  that clusters facts into groups  and that infers static object
symmetries  the static analyzer produces the intermediate format of grounded and
simplified planning domain instances 
 optimal temporal planning enumeration algorithms  based on a precedence relation
and pert scheduling of sequentially generated plans together with a concise analysis
of correctness and optimality  as well as the integration of pert scheduling in mips
for computing a refined heuristic estimate  this guides the search phase  favoring
states with smaller parallel plan length  mips instantiates numerical pre  and postconditions on the fly and produces optimized parallel plans 
 the detection of dynamic object symmetries  the integration of different pruning
methods such as hash and transposition cuts  as well as different strategies for optimizing objective functions and further implementation tricks that made the system
efficient 
the paper analyzes theoretical properties of the contributions  sometimes by slightly
abstracting from the actual implementation 
essentially planning with numerical quantities and durative actions is planning with
resources and time  the given framework of mixed propositional and numerical planning
   

fitaming numbers and durations in mips

problems and the presented intermediate format can be seen as a normal form for temporal
and metric planning  the paper presents a novel temporal planning scheme that generates
sequential  totally ordered  plans and efficiently schedules them with respect to the set of
actions and the imposed causal structure  without falling into known np hardness traps for
optimized partial ordering of sequentially generated plans  for smaller problems the complete enumeration approach guarantees optimal solutions  to improve solution quality in
approximate enumeration  the  numerical  estimate for the number of operators is replaced
by scheduling the relaxed plan in each state  we addressed completeness and optimality of
different forms of exploration  a novel study of the time and space complexity of dynamic
object symmetry detection is given 
model checking has always influenced the development of mips  e g in the static analysis to minimize the state description length  in symbolic exploration and plan extraction  in
the dependence relation for pert schedules according to a given partial order  in bit state
hashing for ida   in the importance of symmetry detection  an so forth  moreover  the
successes of planning with mips can be exported back to model checking  as the development of heuristic search state model checkers and parsing of promela protocol specifications
indicate 

acknowledgments
the author would like to thank derek long and maria fox for helpful discussions concerning
this paper and malte helmert for his cooperation in the second planning competition  the
list of editors and anonymous reviewers comments helped a lot to improve the text 
the work is supported by deutsche forschungsgemeinschaft  dfg  in the projects
heuristic search  ed       and directed model checking  ed       

references
bacchus  f     ady  m          planning with resources and concurrency  a forward chaning
approach  in proceedings of ijcai     pp         
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for planning  artificial intelligence              
backstrom  c          computational aspects of reordering plans  journal of artificial
intelligence research           
bertoli  p     cimatti  a          improving heuristics for planning as search in belief space 
in proceedings of aips     pp         
bertoli  p   cimatti  a     roveri  m       a   heuristic search symbolic model checking  
efficient conformant planning  in proceedings of ijcai     pp         
bertoli  p   cimatti  a   roveri  m     traverso  p       b   planning in nondeterministic
domains under partial observability via symbolic model checking  in proceedings of
ijcai     pp         
biere  a          cke   efficient  calculus model checking  in proceedings of cav     pp 
       
   

fiedelkamp

bloem  r   ravi  k     somenzi  f          symbolic guided search for ctl model checking 
in proceedings of dac     pp       
blum  a     furst  m  l          fast planning through planning graph analysis  in
proceedings of ijcai     pp           
bonet  b     geffner  h          planning as heuristic search  artificial intelligence                
bryant  r  e          symbolic boolean manipulation with ordered binary decision diagrams  acm computing surveys                 
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  a decision procedure for ar  in proceedings of ecp     pp         
cimatti  a   roveri  m     traverso  p          automatic obdd based generation of
universal plans in non deterministic domains  in proceedings of aaai     pp     
    
clarke  e  m   grumberg  o     peled  d  a          model checking  mit press 
clarke  e  m   mcmillan  k  l   dill  d  l     hwang  l  j          symbolic model checking 
     states and beyond  information and computation                 
cormen  t  h   leiserson  c  e     rivest  r  l          introduction to algorithms  the
mit press 
dial  r  b          shortest path forest with topological ordering  communication of the
acm                  
do  m  b     kambhampati  s          sapa  a domain independent heuristic metric temporal planner  in proceedings of ecp     pp         
edelkamp  s          datenstrukturen und lernverfahren in der zustandsraumsuche  ph d 
thesis  university of freiburg  diski  infix 
edelkamp  s       a   directed symbolic exploration and its application to ai planning  in
proceedings of aaai    spring symposium on model based validation of intelligence 
pp       
edelkamp  s       b   first solutions to pddl  planning problems  in proceedings of
plansig     pp       
edelkamp  s       c   planning with pattern databases  in proceedings of ecp     pp 
     
edelkamp  s       a   mixed propositional and numerical planning in the model checking integrated planning system  in proceeding of aips    workshop on temporal
planning  pp       
edelkamp  s       b   symbolic pattern databases in heuristic search planning  in proceedings of aips     pp         
edelkamp  s          promela planning  in proceedings of spin     pp         
edelkamp  s     helmert  m          exhibiting knowledge in planning problems to minimize state encoding length  in proceeding of ecp     pp         
   

fitaming numbers and durations in mips

edelkamp  s     helmert  m          on the implementation of mips  in proceedings of
aips    workshop on model theoretic approaches to planning  pp       
edelkamp  s     helmert  m          the model checking integrated planning system mips 
ai magazine       
edelkamp  s   leue  s     lluch lafuente  a          directed explicit state model checking
in the validation of communication protocols  international journal on software tools
for technology  sttt   to appear 
edelkamp  s     meyer  u          theory and practice of time space trade offs in memory
limited search  in proceedings of ki     lecture notes in computer science  pp 
        springer 
edelkamp  s     reffel  f          obdds in heuristic search  in proceedings of ki     pp 
     
edelkamp  s     reffel  f       a   deterministic state space planning with bdds  in
proceedings of ecp     preprint  pp         
edelkamp  s     reffel  f       b   deterministic state space planning with bdds  tech 
rep       university of freiburg 
edelkamp  s     stiegeler  p          implementing heapsort with n log n     n and
quicksort with n log n      n comparisons  acm journal of experimental algorithms        
feng  z     hansen  e          symbolic heuristic search for factored markov decision
processes  in proceedings of aaai    
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence            
fourman  m  p          propositional planning  in proceedings of aips    workshop on
model theoretic approaches to planning  pp       
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificial intelligence research            
fox  m     long  d          the detection and exploration of symmetry in planning
problems  in proceedings of ijcai     pp         
fox  m     long  d          extending the exploitation of symmetries in planning  in
proceedings of aips    
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research  this issue 
gerevini  a     serina  i          fast planning through greedy action graphs  in proceedings
of aaai    
gerevini  a     serina  i          lpg  a planner based on local search for planning graphs
with action costs  in proceedings of aips    
giunchiglia  f     traverso  p          planning as model checking  in proceedings of
ecp     pp      
   

fiedelkamp

groce  a     visser  w          model checking java programs using structural heuristics 
in proceedings of issta    
guere  e     alami  r          one action is enough to plan  in proceedings of ijcai    
hansen  e     zilberstein  s          lao   a heuristic search algorithm that finds solutions
with loops  artificial intelligence            
hansen  e  a   zhou  r     feng  z          symbolic heuristic search using decision
diagrams  in proceedings of sara    
hart  p  e   nilsson  n  j     raphael  b          a formal basis for heuristic determination
of minimum path cost  ieee transactions on on systems science and cybernetics 
          
haslum  p     geffner  h          heuristic planning with time and resources  in proceedings
of ecp     pp         
helmert  m          on the complexity of planning in transportation domains  in proceedings of ecp     pp         
helmert  m          decidability and undecidability results for planning with numerical
state variables  in proceedings of aips     pp       
hipke  c  a          verteilte visualisierung von geometrischen algorithmen  ph d  thesis 
university of freiburg 
hoffmann  j          a heuristic for domain independent planning and its use in an enforced
hill climbing algorithm  in proceedings of ismis     pp         
hoffmann  j       a   extending ff to numerical state variables  in proceedings of ecai   
hoffmann  j       b   local search topology in planning benchmarks  a theoretical analysis 
in proceedings of aips     pp        
hoffmann  j     nebel  b          fast plan generation through heuristic search  journal
of artificial intelligence research             
holldobler  s     stor  h  p          solving the entailment problem in the fluent calculus using binary decision diagrams  in proceedings of aips    workshop on modeltheoretic approaches to planning  pp       
jensen  r  m   bryant  r  e     veloso  m  m          seta   an efficient bdd based
heuristic search algorithm  in proceedings of aaai    
jensen  r     veloso  m  m          obdd based universal planning for synchronized
agents in non deterministic domains  journal of artificial intelligence research     
       
kabanza  f   barbeau  m     st denis  r          planning control rules for reactive agents 
artificial intelligence                
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proceedings of aaai     pp           
kautz  h     walser  j          state space planning by integer optimization  in proceedings
of aaai    
   

fitaming numbers and durations in mips

knoblock  c          generating parallel execution plans with a partial order planner  in
proceedings of aips     pp        
koehler  j          elevator control as a planning problem  in proceedings of aips     pp 
       
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
koehler  j   nebel  b     dimopoulos  y          extending planning graphs to an adl
subset  in proceedings of ecp     pp         
korf  r  e          depth first iterative deepening  an optimal admissible tree search 
artificial intelligence                
korf  r  e     zhang  w          divide and conquer frontier search applied to optimal
sequence alignment  in proceedings of aaai     pp         
laborie  p     ghallab  m          planning with sharable resources constraints  in proceedings of ijcai     pp           
lago  u  d   pistore  m     traverso  p          planning with a language for extended
goals  in proceedings of aaai    
lind nielsen  j          buddy  binary decision diagram package  release      technical
univeristy of denmark  available from jln itu dk 
lluch lafuente  a          symmetry reduction and heuristic search for error detection in
model checking  in proceedings of the workshop on model checking and artificial
intelligence  mochart  
long  d     fox  m          efficient implementation of the plan graph in stan  journal
of artificial intelligence research            
long  d     fox  m          encoding temporal planning domains and validating temporal plans  in workshop of the uk planning and scheduling special interest group
 plansig  
mcdermott  d          the      ai planning competition  ai magazine         
mcmillan  k  l          symbolic model checking  kluwer academic press 
muscettola  n          hsts  integrating planning and scheduling  in zweben  m     fox 
m  s   eds    intelligent scheduling  pp          morgan kaufmann 
pearl  j          heuristics  addison wesley 
pednault  e          formulating multiagend  dynamic world problems in the classical
framework  in reasoning about action and plans  pp        morgan kaufmann 
pednault  e          adl  exploring the middleground between strips and situation calculus  in proceedings of kr     pp          morgan kaufman 
pettersson  p          modelling and verification of real time systems using timed automata  theory and practice  ph d  thesis  department of computer systems  uppsala university 
   

fiedelkamp

pistore  m     traverso  p          planning as model checking for extended goals in nondeterministic domains  in proceedings of ijcai    
pohl  i          practical and theoretical considerations in heuristic search algorithms 
machine intelligence          
refanidis  i     vlahavas  i          heuristic planning with ressources  in proceedings of
ecai     pp         
reffel  f     edelkamp  s          error detection with directed symbolic model checking 
in proceedings of fm     pp         
regnier  p     fade  b          determination du parallelisme maximal et optimisation
temporelle dans les plans dactions lineaires  revue dintelligence artificielle        
     
reinefeld  a     marsland  t          enhanced iterative deepening search  ieee transactions on pattern analysis and machine intelligence                 
rintanen  j          symmetry reduction for sat representations of transition systems  in
proceedings of icaps    
rintanen  j     jungholt  h          numeric state variables in constraint based planning 
in proceedings of ecp     pp         
ruys  t  c          optimal scheduling using branch and bound with spin      in proceedings of spin     pp      
syslo  m  m   deo  n     kowalik  j  s          discrete optimization algorithms with
pascal programs  prentice hall 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning with parallel
resource allocation  in innovative approaches to planning  scheduling and control 
pp         
weismuller  m          planen mit einem modellprufer im  kalkul   masters thesis 
universitat ulm 
yang  c  h     dill  d  l          validation with guided search of the state space  in
proceedings of dac     pp         
yoshizumi  t   miura  t     ishida  t          a  with partial expansion for large branching
factor problems  in proceedings of aaai     pp         
zhou  r     hansen  e          sparse memory graph search  in proceedings of ijcai    

   

fi