journal of artificial intelligence research                  

submitted       published      

conformant planning via symbolic model checking
cimatti irst itc it

alessandro cimatti

itc irst

  via sommarive           povo  trento  italy

roveri irst itc it

marco roveri

itc irst

  via sommarive           povo  trento  italy

dsi  university of milano  via comelico           milano  italy

abstract

we tackle the problem of planning in nondeterministic domains  by presenting a new
approach to conformant planning  conformant planning is the problem of finding a sequence of actions that is guaranteed to achieve the goal despite the nondeterminism of the
domain  our approach is based on the representation of the planning domain as a finite
state automaton  we use symbolic model checking techniques  in particular binary decision diagrams  to compactly represent and eciently search the automaton  in this paper
we make the following contributions  first  we present a general planning algorithm for
conformant planning  which applies to fully nondeterministic domains  with uncertainty in
the initial condition and in action effects  the algorithm is based on a breadth first  backward search  and returns conformant plans of minimal length  if a solution to the planning
problem exists  otherwise it terminates concluding that the problem admits no conformant
solution  second  we provide a symbolic representation of the search space based on binary
decision diagrams  bdds   which is the basis for search techniques derived from symbolic
model checking  the symbolic representation makes it possible to analyze potentially large
sets of states and transitions in a single computation step  thus providing for an ecient
implementation  third  we present cmbp  conformant model based planner   an ecient
implementation of the data structures and algorithm described above  directly based on
bdd manipulations  which allows for a compact representation of the search layers and an
ecient implementation of the search steps  finally  we present an experimental comparison of our approach with the state of the art conformant planners cgp  qbfplan and
gpt  our analysis includes all the planning problems from the distribution packages of
these systems  plus other problems defined to stress a number of specific factors  our approach appears to be the most effective  cmbp is strictly more expressive than qbfplan
and cgp and  in all the problems where a comparison is possible  cmbp outperforms its
competitors  sometimes by orders of magnitude 
   introduction

in recent years  there has been a growing interest in planning in nondeterministic domains 
rejecting some fundamental  and often unrealistic  assumptions of classical planning  domains are considered where actions can have uncertain effects  exogenous events are possible 
and the initial state can be only partly specified  the challenge is to find a strong plan 
that is guaranteed to achieve the goal despite the nondeterminism of the domain  regardless
of the uncertainty on the initial condition and on the effect of actions  conditional planning  cassandra  kaelbling    littman        weld  anderson    smith        cimatti 
roveri    traverso      b  tackles this problem by searching for a conditional course of
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

ficimatti   roveri
actions  that depends on information that can be gathered at run time  in certain domains 
however  run time information gathering may be too expensive or simply impossible  conformant planning  goldman   boddy        is the problem of finding an unconditioned
course of actions  i e  a classical plan  that does not depend on run time information gathering to guarantee the achievement of the goal  conformant planning has been recognized
as a significant problem in artificial intelligence since the work by michie         the blind
robot problem requires to program the activity for a sensorless agent  which can be positioned in any location of a given room  so that it will be guaranteed to achieve a given
goal  conformant planning can be also seen as a problem of control for a system with
an unobservable and unknown state  such as a microprocessor at power up  or a software
system under black box testing 
because of uncertainty  a plan is associated to potentially many different executions 
which must be all taken into account in order to guarantee goal achievement  this makes
conformant planning significantly harder than classical planning  rintanen      a  de giacomo   vardi         despite this increased complexity  several approaches to conformant
planning have been recently proposed  based on  extensions of  the main planning techniques for classical planning  the most interesting are cgp  smith   weld        based
on graphplan  qbfplan  rintanen      a  which extends the sat plan approach to
qbf  and gpt  bonet   geffner        which encodes conformant planning as heuristic
search  in this paper  we propose a new approach to conformant planning  based on symbolic model checking  mcmillan         symbolic model checking is a formal verification
technique  which allows one to analyze finite state automata of high complexity  relying on
symbolic techniques  binary decision diagrams  bdds   bryant        in particular  for
the compact representation and ecient search of the automaton  our approach builds on
the planning via model checking paradigm presented by cimatti and his colleagues       
    b      a   where finite state automata are used to represent complex  nondeterministic
planning domains  and planning is based on  extensions of  the basic model checking steps 
we make the following contributions 

 first  we present a general algorithm for conformant planning  which applies to any

nondeterministic domain with uncertain action effects and initial condition  expressed
as a nondeterministic finite state automaton  the algorithm performs a breadth first
search  exploring plans of increasing length  until a plan is found or no more candidate
plans are available  the algorithm is complete  i e  it returns with failure if and only
if the problem admits no conformant solution  if the problem admits a solution  the
algorithm returns a conformant plan of minimal length 

 second  we provide a symbolic representation of the search space based on binary

decision diagrams  which allows for the application of search techniques derived from
symbolic model checking  the symbolic representation makes it possible to analyze
sets of transitions in a single computation step  these sets can be compactly represented and eciently manipulated despite their potentially large cardinality  this
way it is possible to overcome the enumerative nature of the other approaches to
conformant planning  for which the degree of nondeterminism tends to be a limiting
factor 
   

ficonformant planning via symbolic model checking

 third  we developed cmbp  conformant model based planner   which is an ecient

implementation of the data structures and algorithm described above  cmbp is developed on top of mbp  the planner based on symbolic model checking techniques
developed by cimatti  roveri and traveso      b      a   cmbp implements several
new techniques  directly based on bdd manipulations  to compact the search layers
and optimize termination checking 
 finally  we provide an experimental evaluation of the state of the art conformant planners  comparing cmbp with cgp  qbfplan and gpt  because of the difference in
expressivity  not all the problems which can be tackled by cmbp can also be represented in the other planners  however  for the problems where a direct comparison
was possible  cmbp outperforms its competitors  in particular  it features a better
qualitative behavior  not directly related to the number of initial states and uncertain
action effects  and more stable with respect to the use of heuristics 
the paper is structured as follows  in section   we review the representation of  nondeterministic  planning domains as finite state automata  in section   we provide the
intuitions and a formal definition of conformant planning in this setting  in section   we
present the planning algorithm  and in section   we discuss the symbolic representation
of the search space  which allows for an ecient implementation  in section   we present
the cmbp planner  and in section   we present the experimental results  in section   we
discuss some further related work  in section   we draw the conclusions and discuss future
research directions 
   planning domains as finite state automata

we are interested in complex  nondeterministic planning domains  where actions can have
preconditions  conditional effects  and uncertain effects  and the initial state can be only
partly specified  in the rest of this paper  we use a very simple though paradigmatic domain
for explanatory purposes  a variation of moore s bomb in the toilet domain  mcdermott 
       from now on called btuc   bt with uncertain clogging   there are two packages 
and one of them contains an armed bomb  it is possible to dunk either package in the
toilet  actions dunk  and dunk     provided that the toilet is not clogged  dunking either
package has the uncertain effect of clogging the toilet  furthermore  dunking the package
containing the bomb has the effect of disarming the bomb  the action f lush has the effect
of unclogging the toilet 
we represent such domains as finite state automata  figure   depicts the automaton for
the btuc domain  each state is given a number  and contains all the propositions holding
in that state  for instance  state   represents the state where the bomb is in package    is
not defused  and the toilet is not clogged  given that there is only one bomb  we write in 
as an abbreviation for the negation of in    arrows between states depict the transitions of
the automaton  representing the possible behavior of actions  the transition from state  
to state   labeled by f lush represents the fact that the action f lush  if executed in state
   only has the effect of removing the clogging  the execution of dunk  in state    which
has the uncertain effect of clogging the toilet  is represented by the multiple transitions to
states   and    since there is no transition outgoing from state   and labelled by dunk   
   

ficimatti   roveri
flush
flush

dunk  
in    
defused
 clogged

in    
 defused
 clogged

dunk   
dunk  

dunk  
flush

flush
in    
 defused
clogged

in    
defused
clogged

flush
flush

dunk  
in    
defused
 clogged

 

in  
 defused
 clogged

dunk   
dunk  

dunk  
flush

flush
in    
defused
clogged

in    
 defused
clogged

figure    the automaton for the btuc domain
state   does not satisfy the preconditions of action dunk    i e  dunk  is not applicable in
state   
we formally define nondeterministic planning domains as follows 
definition    planning domain  a planning domain is a   tuple d    p   s   a  r  

where p is the  finite  set of atomic propositions  s   p is the set of states 
 finite  set of actions  and r  s  a  s is the transition relation 

a is the

intuitively  a proposition is in a state if and only if it holds in that state  in the following
we assume that a planning domain d is given  we use s  s  and s   to denote states of d 
and ff to denote actions  r s  ff  s    holds iff when executing the action ff in the state s the
state s  is a possible outcome  we say that an action ff is applicable in s iff there is at least
one state s  such that r s  ff  s    holds  we say that an action ff is deterministic in s iff
there is a unique state s  such that r s  ff  s    holds  an action ff has an uncertain outcome
in s if there are at least two distinct states s  and s   such that r s  ff  s    and r s  ff  s    
hold  as described by cimatti and his colleagues         the automaton for a given domain
can be eciently built starting from a compact description given in an expressive high level
action language  for instance ar  giunchiglia  kartha    lifschitz        
   conformant planning

conformant planning  goldman   boddy        can be described as the problem of finding
a sequence of actions that is guaranteed to achieve the goal regardless of the nondeterminism
of the domain  that is  for all possible initial states  and for all uncertain action effects 
the execution of the plan results in a goal state 
consider the following problem for the btuc domain  initially  the bomb is armed but
its position and the status of the toilet are uncertain  i e  the initial state can be any of the
states in f          g   the goal is to reach a state where the bomb is defused  and the toilet
   

ficonformant planning via symbolic model checking

in    
 defused
 clogged

in    
 defused
clogged

in    
 defused
 clogged

in    
 defused
clogged

in    
defused
 clogged

flush

flush

flush

flush

in    
defused
 clogged

flush

flush
in    
 defused
 clogged

dunk  

in    
defused
clogged

in    
defused
 clogged

dunk  

in    
defused
clogged

in    
 defused
 clogged

dunk  

in    
defused
 clogged

flush
in    
 defused
 clogged

dunk  

in    
 defused
 clogged

in    
 defused
clogged

flush

in    
defused
clogged

flush

flush

flush

in    
defused
 clogged

in    
defused
 clogged

flush

figure    a conformant solution for the btuc problem
is not clogged  i e  the set of goal states is f    g  a conformant plan solving this problem
is
f lush  dunk    f lush   dunk    f lush
   
figure   outlines the possible executions of the plan  for all possible initial states and
uncertain action effects  the initial uncertainty lies in the fact that the domain might be
in any of the states in f          g   the possible initial states of the planning domain are
collected into a set by a dashed line  we call such a set a belief state  intuitively  a belief
state expresses a condition of uncertainty about the domain  by collecting together all the
states which are indistinguishable from the point of view of an agent reasoning about the
domain  the first action  f lush  is used to remove the possible clogging  this reduces the
uncertainty to the belief state f    g  despite the remaining uncertainty  i e  it is still not
known in which package the bomb is   action dunk  is now guaranteed to be applicable
because its precondition is met in both states  dunk  has the effect of defusing the bomb if
it is contained in package    and has the uncertain effect of clogging the toilet  the resulting
belief state is f          g   the following action  f lush  removes the clogging  reducing the
uncertainty to the belief state f    g  and guarantees the applicability of dunk    after
dunk    the bomb is guaranteed to be defused  but the toilet might be clogged again  states
  and   in the belief state f          g    the final f lush reduces the uncertainty to the belief
state f    g  and guarantees the achievement of the goal 
in general  in order for a plan to be a conformant solution  no action must be executed
in states which do not satisfy the preconditions  and any state that can result from the
execution of the plan  for all the initial states and for all the uncertain action effects  is
a goal state  the main diculty in achieving these conditions is that no information is
 assumed to be  available at run time  therefore  at planning time we face the problem of
reasoning about action execution in a belief state  i e  under a condition of uncertainty 
definition    action applicability  let bs  s be a belief state  the action ff is
applicable in bs iff bs      and ff is applicable in every state s   bs 
   

ficimatti   roveri
in order for an action to be applicable in a belief state  we require that its preconditions
must be guaranteed notwithstanding the uncertainty  in other words  we reject  reckless 
plans  which take the chance of applying an action without the guarantee of its applicability 
this choice is strongly motivated in practical domains  where possibly fatal consequences
can follow from the attempt to apply an action when its preconditions might not be satisfied
 e g  starting to fix an electrical device without being sure that it is not powered   the effect
of action execution from an uncertain condition is defined as follows 
definition    action image  let bs  s be a belief state  and let ff be an action applicable in bs  the image  also called execution  of ff in bs  written image  ff  bs   is defined

as follows 

image  ff  bs    

fs  j there exists s   bs such that r s  ff  s   g

notice that the image of an action combines the uncertainty in the belief state with the uncertainty on the action effects   consider for instance that image  dunk    f    g  f          g   
in the following  we write image  ff  s  instead of image  ff  fsg  
plans are elements of a   i e  finite sequences of actions  we use  for the   length
plan   and  to denote generic plans  and    for plan concatenation  the notions of
applicability and image generalize to plans as follows 
definition    plan applicability and image  let    a   and let bs  s    is applicable in bs iff one of the following holds 
       and bs      
      ff    ff is applicable in bs  and  is applicable in image  ff  bs  
the image  also called execution  of  in bs  written image    bs   is defined as 
   image    bs     bs 
   image  ff     bs     image    image  ff  bs   

a planning problem is formally characterized by the set of initial and goal states  the
following definition captures the intuitive meaning of conformant plan given above 
definition    conformant planning  let d    p   s   a  r  be a planning domain  a
planning problem for d is a triple  d  i   g    where      i  s and      g  s  
the plan  is a conformant plan for  that is  a conformant solution to  the planning
problem  d  i   g   iff the following conditions hold 

 i   is applicable in i  
 ii  image    i    g  
in the following  when clear from the context  we omit the domain from the planning
problem  and we simply write  i   g   
   

ficonformant planning via symbolic model checking
   the conformant planning algorithm

our conformant planning algorithm is based on the exploration of the space of plans  limiting
the exploration to plans which are conformant by construction  the algorithm builds belief
state plan  bsp  pairs of the form hbs   i  where bs is a non empty belief state and 
is a plan  the idea is to use a bsp pair to associate each explored plan with the maximal
belief state where it is applicable  and from which it is guaranteed to result in goal states 
the exploration is based on the basic function spreimage  ff  bs   that  given a belief state
bs and an action ff  returns the belief state containing all the states where ff is applicable 
and whose image under ff is contained in bs 
definition    strong pre image  let      bs  s be a belief state and let ff be an
action  the strong pre image of bs under ff  written spreimage  ff  bs   is defined as
follows 

spreimage  ff  bs     fs j ff is applicable in s  and image  ff  s 

 bsg

if spreimage  ff  bs  is not empty  then ff is applicable in it  and it is a conformant solution to the problem  spreimage  ff  bs   bs   therefore  if the plan  is a conformant
solution for the problem  bs  g    then the plan ff   is a conformant solution to the problem
 spreimage  ff  bs   g   
figure   depicts the space of bsp pairs built by the algorithm while solving the btuc
problem  the levels are built from the goal  on the right  towards the initial states  on the
left  at level    the only bsp pair is hf    g   i  composed by the set of goal states indexed
by the   length plan    notice that  is a conformant solution to every problem with goal set
f    g and initial states contained in f    g   the dashed arrows represent the application
of spreimage   at level    only the bsp pair hf          g   f lushi is built  since the strong
pre image of the belief state   for the actions dunk  and dunk  is empty  at level    there
are three bsp pairs  with  overlapping  belief states bs    bs  and bs    indexed  respectively 
by the length   plans dunk    f lush  f lush  f lush and dunk    f lush   a plan associated
with a belief state bsi is a sequence of actions labeling the path from bsi to bs     notice
that bs  is equal to bs    and therefore deserves no further expansion  the expansion of
belief states   and   gives the belief states   and    both obtained by the strong pre image
under f lush  while the strong pre image under actions dunk  and dunk  returns empty
belief states  the further expansion of bs  results in three belief states  the one resulting
from the strong pre image under f lush is not reported  since it is equal to bs    belief state
  is also equal to bs    and deserves no further expansion  belief state   can be obtained by
expanding both bs  and bs    at level    the expansion produces bs     which contains all
the initial states  therefore  both of the corresponding plans are conformant solutions to
the problem 
the conformant planning algorithm conformantplan is presented in figure    it
takes as input the planning problem in the form of the set of states i and g  the domain
d is assumed to be globally available   the algorithm performs a backwards breadth first
search  exploring bsp pairs corresponding to plans of increasing length at each step  the
status of the search  each level in figure    is represented by a bsp table  i e  a set of bsp
pairs
bspt   fhbs      i          hbsn   n ig
   

ficimatti   roveri
level

 

 

 

 

 

 

in    
 defused
 clogged

in    
 defused
 clogged
dunk  

in    
 defused
 clogged

in    
defused
 clogged

in    
 defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
 defused
 clogged
flush

in    
defused
 clogged

dunk  

bs  

in    
defused
clogged

in    
 defused
clogged

in    
defused
 clogged
bs  

in    
 defused
 clogged

in    
 defused
 clogged

in    
 defused
clogged

in    
 defused
 clogged

flush

in    
defused
 clogged

in    
defused
 clogged

in    
defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
defused
 clogged

dunk  
in    
defused
clogged

in    
defused
clogged

bs  

in    
 defused
 clogged

flush

in    
defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
defused
clogged

in    
defused
clogged

flush

in    
defused
 clogged

in    
defused
 clogged
bs  

dunk  

bs  

in    
defused
 clogged

in    
 defused
clogged

bs  

bs  

 

in  
defused
 clogged

in    
defused
 clogged

in    
 defused
 clogged

 

in  
defused
clogged

bs   

in    
 defused
 clogged

in    
defused
 clogged

flush

in    
defused
clogged
dunk  

in    
defused
 clogged

dunk  

in    
defused
 clogged

in    
defused
 clogged

bs  

in    
defused
 clogged

in    
defused
clogged
bs  

bs  

figure    the bsp tables for the btuc problem
where the i are plans of the same length  such that i    j for all    j   i  n  we
call bsi the belief set indexed by i   when no ambiguity arises  we write bspt i   for
bsi  the array bsptables is used to store the bsp tables representing the levels of the
search  the algorithm first checks  line    if there are plans of length    i e  if  is a
solution  if no conformant plan of such length exists   p lans      in line     then the
while loop is entered  at each iteration  conformant plans of increasing length are explored
 lines   to     the step at line   expands the bsp table in bsptables i    and stores the
resulting bsp table in bsptables i   bsp pairs which are redundant with respect to the
current search are eliminated from bsptables i   line     the possible solutions contained
in bsptables i  are extracted and stored in p lans  line     the loop terminates if either a
plan is found  p lans        or the space of conformant plans has been completely explored
 bsptables i       
the definitions of the basic functions used in the algorithm are reported in figure   
the function expandbsptable expands the bsp table provided as argument  containing
conformant plans of length i    and returns a bsp table with conformant plans of length
i  each bsp in the input bsp table is expanded by expandbsppair  for each possible
   

ficonformant planning via symbolic model checking

 
 
 
 
 
 
 
 
 
 
  
  
  
  

function conformantplan i  g  
begin

i     
bsptables       f hg   i g 
plans    extractsolution i   bsptables     
while   bsptables i           p lans       do
i    i     
bsptables i     expandbsptable bsptables i     
bsptables i     prunebsptable bsptables i   bsptables  i  
plans    extractsolution i   bsptables i   

done
if  bsptables i       then
return fail 
else return plans 
end

figure    the conformant planning algorithm 
action ff  the strong pre image of bs is computed  and if the resulting belief state bs  is
not empty  i e  there is a belief state from which ff guarantees the achievement of bs  then
the plan  is extended with ff and hbs    ff   i is returned  the expansion of a bsp table
is the union of the expansions of each bsp pair  the function extractsolution takes as
input a bsp table and returns the  possibly empty  set of plans which index a belief states
containing i   prunebsptable takes as input the bsp table to be pruned  an array of
previously constructed bsp tables bsptables  and an index of the current step  it removes
from the bsp table in the input the plans which are not worth being explored because the
corresponding belief states have already been visited 
the algorithm has the following properties  first  it always terminates  this follows
from the fact that the set of explored belief sets  stored in bsptables  is monotonically
increasing   at each step we proceed only if at least one new belief state is generated 
because of its finiteness  the set of accumulated belief states is contained in  s which is
finite   a fix point is eventually reached  second  it is correct  i e  when a plan is returned
it is a conformant solution to the given problem  the correctness of the algorithm follows
from the properties of spreimage   each plan is associated with a belief state for which it
is conformant  i e  where it is guaranteed to be applicable and from which it results in a
belief state contained in the goal  third  the algorithm is optimal  i e  it returns plans of
minimal length  this property follows from the breadth first style of the search  finally 
the algorithm is able to decide whether a problem admits no solution  returning fail in such
cases  indeed  a conformant solution is always associated with a belief state containing the
initial states  spreimage generates the maximal belief state associated with a conformant
plan  each new belief state generated in the exploration is compared with the initial states
to check if it is a solution  and a plan is pruned only if an equivalent plan has already been
explored 
   

ficimatti   roveri

 bspt    

expandbsptable

 
hbs   i bspt

 hbs   i 

expandbsppair

 hbs   i     fhbs    ff   ij such that bs    spreimage  ff  bs      g

expandbsppair

 bspt  bsptables  i    
fhbs   i   bspt j for all j   i  there is no hbs     i   bsptables j   such that  bs    bs g
prunebsptable

 i   bspt     f j there exists hbs   i   bspt such that i  bsg

extractsolution

figure    the primitives used by the conformant planning algorithm 
   conformant planning via symbolic model checking

model checking is a formal verification technique based on the exploration of finite state
automata  clarke  emerson    sistla         symbolic model checking  mcmillan        is
a particular form of model checking using binary decision diagrams to compactly represent
and eciently analyze finite state automata  the introduction of symbolic techniques into
model checking led to a breakthrough in the size of model which could be analyzed  burch
et al          and made it possible for model checking to be routinely applied in industry 
especially in logic circuits design  for a survey see clarke   wing        
in the rest of this section  we will provide an overview of binary decision diagrams 
and we will describe the representation of planning domains  based on the bdd based
representation of finite state automata used in model checking  then  we will discuss the
extension which allows to symbolically represent bsp tables and their transformations  thus
allowing for an ecient implementation of the algorithm described in the previous section 
    binary decision diagrams

a reduced ordered binary decision diagram  bryant               improperly called bdd 
is a directed acyclic graph  dag   the terminal nodes are either t rue or f alse  each nonterminal node is associated with a boolean variable  and two bdds  called left and right
branches  figure    a  depicts a bdd for  a    b       a    b       a    b     at each
non terminal node  the right  left  respectively  branch is depicted as a solid  dashed  resp  
line  and represents the assignment of the value t rue  f alse  resp   to the corresponding
variable  a bdd represents a boolean function  for a given truth assignment to the variables
in the bdd  the value of the function is determined by traversing the graph from the root
to the leaves  following each branch indicated by the value assigned to the variables   the
   a path from the root to a leaf can visit nodes associated with a subset of all the variables of the bdd 
see for instance the path associated with a     b  in figure   a  

   

ficonformant planning via symbolic model checking

a 

a 

b 

a 

b 

a 

a 

b 

b 

b 

b 

a 

b 

b 

a 

a 

a 

b 

b 

b 

a 

b 

b 

b 

b 

b 

b 

b 

b 

true

false

true

false

 a 

b 

 b 

figure    two bdds for the formula  a    b       a    b       a    b    
reached leaf node is labeled with the resulting truth value  if v is a bdd  its size jvj is the
number of its nodes  if n is a node  var n  indicates the variable indexing node n 
bdds are a canonical representation of boolean functions  the canonicity follows by
imposing a total order   over the set of variables used to label nodes  such that for any
node n and respective non terminal child m  their variables must be ordered  i e  var n   
var m   and requiring that the bdd contains no isomorphic subgraphs 
bdds can be combined with the usual boolean transformations  e g  negation  conjunction  disjunction   given two bdds  for instance  the conjunction operator builds and
returns the bdd corresponding to the conjunction of its arguments  substitution can also
be represented as bdd transformations  in the following  if v is a variable  and  and are
bdds  we indicate with  v    the bdd resulting from the substitution of v with in   if
v  and v  are vectors of  the same number of  distinct variables  we indicate with  v   v   
the parallel substitution in  of the variables in vector v  with the  corresponding  variables
in v   
bdds also allow for transformations described as quantifications  in the style of quantified boolean formulae  qbf   qbf is a definitional extension to propositional logic  where
propositional variables can be universally and existentially quantified  in terms of bdd
computations  a quantification corresponds to a tranformation mapping the bdd of  and
the variable vi being quantified into the bdd of the resulting  propositional  formula  if 
is a formula  and vi is one of its variables  the existential quantification of vi in   written
 vi  v            vn    is equivalent to  v           vn   vi f alse     v           vn   vi t rue   analogously  the universal quantification  vi   v            vn   is equivalent to  v            vn   vi  f alse  
   

ficimatti   roveri
 v            vn   vi  t rue   in qbf  quantifiers can be arbitrarily applied and nested  in general  a qbf formula has an equivalent propositional formula  but the conversion is subject
to an exponential blow up 
the time complexity of the algorithm for computing a truth functional boolean transformation f   op  f  is o jf  j  jf  j   as far as quantifications are concerned  the time
complexity is quadratic in the size of the bdd being quantified  and linear in the number
of variables being quantified  i e  o jvj  jf j     bryant              
bdd packages are ecient implementations of such data structures and algorithms  brace
et al         somenzi        yang et al         coudert et al          basically  a bdd package deals with a single multi rooted dag  where each node represents a boolean function 
memory eciency is obtained by using a  unique table   and by sharing common subgraphs
between bdds  the unique table is used to guarantee that at each time there are no isomorphic subgraphs and no redundant nodes in the multi rooted dag  before creating a
new node  the unique table is checked to see if the node is already present  and only if this
is not the case a new node is created and stored in the unique table  the unique table
allows to perform the equivalence check between two bdds in constant time  since two
equivalent functions always share the same subgraph   brace et al         somenzi        
time eciency is obtained by maintaining a  computed table   which keeps track of the
results of recently computed transformations  thus avoiding the recomputation 
a critical computational factor with bdds is the order of the variables used   figure  
shows an example of the impact of a change in the variable ordering on the size of a bdd  
for a certain class of boolean functions  the size of the corresponding bdd is exponential in
the number of variables for any possible variable ordering  bryant         in many practical
cases  however  finding a good variable ordering is rather easy  beside affecting the memory
used to represent a boolean function  finding a good variable ordering can have a big impact
on computation times  since the complexity of the transformation algorithms depends on
the size of the operands  most bdd packages provide heuristic algorithms for finding good
variable orderings  which can be called to try to reduce the overall size of the stored bdds 
the reordering algorithms can also be activated dynamically by the package  during a bdd
computation  when the total number of nodes in the package reaches a predefined threshold
 dynamic reoredering  
    symbolic representation of planning domains
a planning domain  p   s   a  r  can be represented symbolically using bdds  as follows  a

set of  distinct  bdd variables  called state variables  is devoted to the representation of the
states s of the domain  each of these variables has a direct association with a proposition
of the domain in p used in the description of the domain  for instance  for the btuc
domain  each of in    defused and clogged is associated with a unique bdd variable  in
the following we write x for the vector of state variables  because the particular order is
irrelevant but for performance issues  in the rest of this section we will not distinguish a
proposition and the corresponding bdd variable 
a state is a set of propositions of p  specifically  the propositions which are intended
to hold in it   for each state s  there is a corresponding assignment to the state variables
x   i e  the assignment where each variable corresponding to a proposition p   s is assigned
   

ficonformant planning via symbolic model checking
to t rue  and each other variable is assigned to f alse  we represent s with the bdd   s  
having such an assignment as its unique satisfying assignment  for instance           in   
defused   clogged  is the bdd representing state    while          in     defused  
clogged represents state    and so on   without loss of generality  in the following we do
not distinguish a propositional formula from the corresponding bdd   this representation
naturally extends to any set of states q  s as follows 
  q    

   s 

s q

in other words  we associate a set of states with the generalized disjunction of the bdds
representing each of the states  notice that the satisfying assignments of the   q  are
exactly the assignment representations of the states in q  this representation mechanism
is very natural  for instance  the bdd   i   representing the the set of initial states of
the btuc i    f          g is  defused  while for the set of goal states g    f    g the
corresponding bdd is defused    clogged  a bdd is also used to represent the set s of
all the states of the domain automaton  in the btuc    s     t rue because s    p   in a
different formulation  where two independent propositions in  and in  are used to represent
the position of a bomb    s   would be the bdd in     in   
in general  a bdd represents the set of  states which correspond to  its models  as
a consequence  set theoretic transformations are naturally represented by propositional
operations  as follows 
  snq 
     s        q 
  q    q         q        q   
  q    q         q        q   

the main eciency of this symbolic representation lies in the fact that the cardinality
of the represented set is not directly related to the size of the bdd  for instance    g   uses
two  non terminal  nodes to represent two states  while   i   uses one node to represent four
states  as limit cases    s   and   fg  are  the leaf bdds  t rue and f alse  respectively  as
a further advantage  symbolic representation is extremely ecient in dealing with irrelevant
information  notice  for instance  that only the variable defused occurs in   f          g   
for this reason  a symbolic representation can have a dramatic improvement over an explicit 
enumerative representation  this is what allows symbolic  bdd based model checkers to
handle finite state automata with a very large number of states  see for instance burch
et al          in the following  we will collapse a set of states and the bdd representing it 
another set of bdd variables  called action variables  written ff   is used to represent
actions  we use one action variable for each possible action in a  intuitively  a bdd action
variable is true if and only if the corresponding action is being executed  if we assume that
a sequential encoding is used  i e  no concurrent actions are allowed  we also use a bdd 
seq ff    to express that exactly one of the action variables must be true at each time    for
   in the specific case of sequential encoding  an alternative approach using only dlog jaje is possible  an
assignment to the action variables denotes a specific action to be executed  two assignments being
mutually exclusive  the constraint seq ff   needs not to be represented  when the cardinality of the
set of actions is not a power of two  the standard solution is to associate more than one assignment to
certain values  this optimized solution  which is actually used in the implementation  is not described
here for the sake of simplicity 

   

ficimatti   roveri
the btuc problem  where a contains three actions  we use the three bdd variables dunk   
dunk  and f lush  while we express the serial encoding constraint with the following bdd 

seq ff      dunk    dunk    f lush     dunk    dunk       dunk    f lush     dunk    f lush 

as for state variables  we are referring to bdd action variables with symbolic names for
the sake of simplicity  in practice  they will be internally represented as integers  but their
position in the ordering of the bdd package is totally irrelevant in logical terms 
a bdd in the variables x and ff represents a set of state action pairs  i e  a relation
between states and actions  for instance  the applicability relation in the btuc  i e   all
actions are possible in all states  except for dunking actions which require the toilet not
to be clogged  is represented by the bdd   clogged    dunk    dunk      notice that it
represents a set of    state action pairs  each associating a state with an applicable action 
a transition is a   tuple composed of a state  the initial state of the transition   an
action  the action being executed   and a state  the resulting state of the transition   to
represent transitions  another vector x   of bdd variables  called next state variables  is
allocated in the bdd package  we write     s  for the representation of the state s in the
next state variables  with     q  we denote the construction of the bdd corresponding to
the set of states q  using each variable in the next state vector x   instead of each current
state variables x   we require that jx j   jx   j  and assume that the i th variable in x and the
i th variable in x   correspond  we define the representation of a set of states in the next
variables as follows 
    s       s  x  xx   
we call the operation  x  xx     forward shifting   because it transforms the representation of
a set of  current  states in the representation of a set of  next  states  the dual operation
 x    xx  is called backward shifting  in the following  we call x current state variables to
distinguish them from next state variables  a transition is represented as an assignment
to x   ff and x     for the btuc  the transition corresponding to the application of action
dunk  in state   resulting in state   is represented by the following bdd
  h   dunk     i            dunk          
the transition relation r of the automaton corresponding to a planning domain is
simply a set of transitions  and is thus represented by a bdd in the bdd variables x   ff and
x    where each satisfying assignment represents a possible transition 
 
  r     seq ff       t 
t r

in the rest of this paper  we assume that the bdd representation of a planning domain
is given  in particular  we assume as given the vectors of variables x  xx   ffff  the encoding
functions  and      and we simply call s   r  i and g the bdd representing the states of the
domain  the transition relation  the initial states and the goal states  respectively  we write
 v  to stress that the bdd  depends on the variables in v  with this representation  it
is possible to reason about plans  simulating symbolically the execution of sets of actions in
sets of states  by means of qbf transformations  the bdd representing the applicability
relation can be directly obtained with the following computation 
ff      x    r x  ffff xx   
applicable x  ff
   

ficonformant planning via symbolic model checking
the resulting bdd  applicable x  ffff   represents the set of state action pairs such that
the action is applicable in the state  the bdd representing the states reachable from q in
one step is obtained with the following computation 

 x  ff  r x  ffff xx    q x   x   xx 
notice that  with this single operation  we symbolically simulate the effect of the application
of any applicable action in a to any of the states in q  similarly  the following transformation allows to symbolically compute the spreimage of a set of states q under all possible
actions in one single computation 

 x   r x  ffff xx      q x   x xx      

 x  ffff 

applicable

the resulting bdd represents all the state action pairs hx   ffi such that ff is applicable in
x and the execution of ff in x results in states in q 
    symbolic search in the space of belief states

the main strength of the symbolic approach is that it allows to perform a symbolic breadthfirst search  and it provides a way for compactly representing and eciently expanding the
frontier  for instance  plans can be constructed by symbolic breadth first search in the
space of states  repeatedly applying the strong pre image to the goal states  cimatti et al  
    b   however  the machinery presented in the previous section cannot be directly applied
to tackle conformant planning  the basic difference is that with conformant planning we are
searching in the space of belief states    and therefore the frontier of the search is basically
a set of sets of states  we introduce a way to symbolically represent bsp tables  basically 
this can be seen as a construction on demand  based on the algorithm steps  of increasingly
large portions of the space of belief states  the key intuition is that a bsp table

fhfs             s n  g    i          hfsk            skn g   k ig
k

is represented as a relation between plans  of the same length  and states  by associating
the plan directly with each state in the belief state indexed by the plan  as follows 

fhs      i          hs n     i          hsk    k i          hskn   k ig
k

   

we use additional variables to represent the plans in the bsp tables  in order to represent
plans of increasing length  at each step of the algorithm  a vector of new bdd variables 
called plan variables  is introduced  the vector of plan variables introduced at the i th step
of the algorithm is written   i   with j  i j   jff j  and is used to encode the i th to last action
in the plan   at step one of the algorithm  we introduce the vector of plan variables     
to represent the action corresponding to each   length possible conformant plan  the bsp
   in principle  the machinery for symbolic search could be used to do conformant planning if applied to
the determinization of the domain automaton  i e  an automaton having  s as its state space  however 
this would require the introduction of an exponential number of state variables  which is impractical
even for very small domains 
   the search being performed backwards  plans need to be reversed once found 

   

ficimatti   roveri
table bspt  at level   is built by expandbsptable by performing the following bdd
computation starting from the bsp table at level    i e  g  x   
  x     r x  ffff xx      g  x   x  xx       applicable x  ffff   ff       
the computation collects those state action pairs hx   ff i such that  the action represented
by  ff is applicable in  the state represented by  x   and such that all the resulting  states
represented by  x   are goal states  then we replace the vector of action variables ff with
the first vector of plan variables       the resulting bdd  bspt x         represents a bsp
table containing plans of length one in the form of a relation between states and plans as
in      in the general case  after step i    the bsp table bspti     associating belief states
to plans of length i    is represented by a bdd in the state variables x and in the plan
variables   i                   the computation performed by expandbsptable at step i is
implemented as the following bdd transformation on bspti  
  x     r x  ffff xx      bspti    x    i                   x  xx       applicable x  ffff   ff    i     
the next state variables in r and in bspti    resulting from the forward shifting  disappear
because of the universal quantification  the action variables ff are renamed to the newly
introduced plan variables   i   so that in the next step of the algorithm the construction can
be repeated 
extractsolution extracts the assignments to plan variables such that the corresponding set contains the initial states  in terms of bdd transformations  extractsolution is
implemented as follows 
 x  i  x    bspti x   i                
   
the result is a bdd in the plan variables   i                if the bdd is f alse  then there are
no solutions of length i  otherwise  each of the satisfying assignments to the resulting bdd
represents a conformant solution to the problem 
to guarantee the termination of the algorithm  at each step the bsp table returned
by expandbsptable is simplified by prunebsptable by removing all the belief states
which do not deserve further expansion  this requires the comparison of the belief states
contained in the bsp table with the belief states contained in each of the bsp tables built at
previous levels  this is one of the crucial steps in terms of eciency  an earlier implementation of this step with logical bdd transformations  following directly from the set theoretical
definition of prunebsptable  was extremely inecient  cimatti   roveri         furthermore  we noticed that the serial encoding could yield bsp tables containing a large
number of equivalent plans  all indexing exactly the same belief state  often these equivalent plans only differ in the order of some independent actions  and this is a potential source
of combinatorial explosion  this occurs even in the simple version of the btuc  in figure   
two equivalent conformant plans are associated with bs     therefore  we developed a new
implementation which could tackle these two problems by operating directly on the bsp
table  the idea is depicted in figure    initially  the cache contains bs    bs  and bs    the
simplification performs a traversal of the bdd  by accumulating the subtrees representing
belief states  comparing them with the ones built at previous levels  and inserting the new
ones in the cache  in figure    bs    bs  and bs     each time a path is identified which
   

ficonformant planning via symbolic model checking
bsp table

bs 

bs 

bs 

pruned bsp table

bs 

bs 

bs 

cached belief states
bs 

bs 

bs 

cached belief states

bs 

bs 

bs 

bs 

bs 

bs 

bs 

figure    an example of pruning of a bsp table
represents a plan indexing an already cached belief state  the plan is redundant and the
corresponding path is pruned   the cost of the simplification is linear in the size of the bsp
being simplified and is highly effective in pruning 
   cmbp  a bdd based conformant planner

cmbp  conformant model based planner  is a conformant planner implementing the data
structures and algorithms for conformant planning described in the previous sections  cmbp
inherits the features of mbp  cimatti et al             b      a   a planner based on
symbolic model checking techniques  mbp is built on top of nusmv  a symbolic model
checker jointly developed by itc irst and cmu  cimatti et al          and uses the
cudd  somenzi        state of the art bdd package  mbp is a two stage system  in
the first stage  an internal bdd based representation of the domain is built  while in the
second stage planning problems can be solved  currently  planning domains are described
by means of the high level action language ar  giunchiglia et al          ar allows to
specify  conditional and uncertain  effects of actions by means of high level assertions  for
instance  figure   shows the ar description of the btuc problem   the semantics of
ar yields a serial encoding  i e  exactly one action is assumed to be executed at each

   this pruning mechanism is actually weaker than the earlier one  cimatti   roveri         here we
require that the same belief state must not be expanded twice during the search  while in the earlier
version we prune belief states contained in previously explored ones  this may increase the number of
explored belief states  however  it allows for a much more ecient implementation  without impacting
on the properties of the algorithm 
     and   stand for negation and conjunction  respectively  the description is slightly edited for the sake of
readability  in particular  mbp currently does not accept parameterized ar descriptions  in practice we
use a script language to generate ground instances of different complexity from a parameterized problem
description 

   

ficimatti   roveri

domain btuc
actions dunk    dunk    flush 
fluents in    in    defused  clogged   boolean 
inertial clogged  defused  in    in   
always in        in   
flush causes  clogged 
for i in         
dunk  i  has preconditions  clogged 
dunk  i  causes defused if in  i  
dunk  i  possibly changes clogged 
 
initially  defused 
conformant defused    clogged 

figure    an ar description for the btuc problem
time  the automaton corresponding to an ar description is obtained by means of the
minimization procedure by giunchiglia         this procedure solves the frame problem
and the ramification problem  and is eciently implemented in mbp  cimatti et al         
because of the separation between the domain construction and the planning phases  mbp
is not bound to ar  standard deterministic domains specified in pddl  ghallab et al  
      can also be given to mbp by means of a  prototype  compiler  we are also starting
to investigate the potential use of the c action language  giunchiglia   lifschitz        
which allows to represent domains with parallel actions 
different planning algorithms can be applied to the specified planning problems  they
operate solely on the automaton representation  and are completely independent of the
particular language used to specify the domain  mbp allows for automatic construction of
conditional plans under total observability  by implementing the algorithms for strong planning  cimatti et al       b   and for strong cyclic plannig  cimatti et al       a  daniele 
traverso    vardi         in cmbp  we implemented the ideas described in the previous
sections  the primitives to construct and prune bsp tables required a lot of tuning  in
particular with the ordering of bdd variables  we found a general ordering strategy which
works reasonably well  action variables are positioned at the top of the ordering  followed by
plan variables  followed by state variables  with current state and next state variables interleaved  the specific ordering within action variables  plan variables  and state variables is
determined by the standard mechanism implemented in nusmv  cmbp implements several
algorithms for conformant planning  in addition to the backward algorithm presented in
   

ficonformant planning via symbolic model checking
section    cmbp implements an algorithm based on forward search  which allows to exploit
the initial knowledge of the problem  sometimes resulting in significant speed ups  cimatti
  roveri         backward and forward search can also be combined  to tackle the exponential growth of the search time with the depth of search  for all these algorithms 
different options enable and disable different versions of the termination check 
   experimental evaluation

in this section we present an experimental evaluation of our approach  which was carried
out by comparing cmbp with state of the art conformant planners  we first describe the
other conformant planners considered in the analysis  and then we present the experimental
comparison that was carried out 
    other conformant planners

cgp  smith   weld        extends the ideas of graphplan  blum   furst              to
deal with uncertainty  basically  a planning graph is built of every possible sequence of possible worlds  and constraints among planning graphs are propagated to ensure conformance 
the cgp system takes as input domains described in an extension of pddl  ghallab et al  
       where it is possible to specify uncertainty in the initial state  cgp inherits from
graphplan the ability to deal with parallel actions  cgp was the first ecient conformant planner  it was shown to outperform several other planners such as buridan  peot 
      and udtpop  kushmerick  hanks    weld         the detailed comparison reported by smith and weld        leaves no doubt on the superiority of cgp with respect
to these systems  therefore  we compared cmbp with cgp and did not consider the other
systems analyzed by smith and weld         cmbp is more expressive than cgp in two
respects  first  cgp can only handle uncertainty in the initial state  for instance  cgp
cannot analyze the btuc domain presented in section    smith and weld        describe
how the approach can be extended to actions with uncertain effects  second  cgp cannot
conclude that a planning problem has no conformant solutions 
qbfplan is  our name for  the planning system by rintanen      a   qbfplan generalizes the idea of sat based planning  kautz  mcallester    selman        kautz   selman 
            to nondeterministic domains  by encoding problems in qbf  the qbfplan
approach is not limited to conformant planning  but can be used to do conditional planning
under uncertainty  also under partial observability  different encodings  corresponding to
different structures in the resulting plan  can be synthesized  in this paper  we are only
considering encodings which enforce the resulting plan to be a sequence  given a bound on
the length of the plan  first a qbf encoding of the problem is generated  and then a qbf
solver  rintanen      b  is called  if no solution is found  a new encoding for a longer plan
must be generated and solved  qbfplan is able to handle actions with uncertain effects 
this is done by introducing auxiliary  choice  variables  the assignments to which the different possible outcomes of actions correspond  these variables are universally quantified
to ensure conformance of the solution  differently from e g  blackbox  kautz   selman 
       qbfplan does not have a heuristic to guess the  right  length of the plan  given
a limit in the length of the plan  it generates all the encodings up to the specified length 
and repeatedly calls the qbf solver on encodings of increasing length until a plan is found 

   

ficimatti   roveri
as cgp  qbfplan cannot conclude that a planning problem has no conformant solutions 
similarly to cmbp  qbfplan relies on a symbolic representation of the problem  although
qbf transformations are performed by a theorem prover rather than with bdds 
gpt  bonet   geffner        is a general planning framework  where the conformant
planning problem is seen as deterministic search problem in the space of belief states  gpt
uses an explicit representation of the search space  where each belief state is represented
as a separate data structure  the search is based on the a algorithm  nilsson        
driven by domain dependent heuristics which are automatically generated from the problem
description  gpt accepts problem descriptions in a syntax based on pddl  extended to deal
with probabilities and uncertainty  it is possible to represent domains with uncertain action
effects  although the representation of actions resulting in a large number of different states
is rather awkward   as for the planning algorithm  gpt is able to conclude that a given
planning problem has no conformant solution by exhaustively exploring the space of belief
states 
    experiments and results

the evaluation was performed by running the systems on a number of parameterized problem domains  we considered all the problems from the cgp and gpt distributions  plus
other problems which were defined to test specific features of the planners  we considered
domains with uncertainty limited to the initial state  and domains with uncertain action
effects  besides problems admitting a solution  we also considered problems not admitting
a solution  in which case we measured the effectiveness of the plannner in returning with
failure 
given their different expressivity  it was not possible to run all the systems on all the
examples  cmbp was run on all the classes of examples  while gpt was run on all but one 
cgp was run only on the problems which admit a solution  and with uncertainty limited
to the initial condition  qbfplan was run on all the examples for which an encoding was
already available from the qbfplan distribution  this is only a subset of the problems
expressible in cgp  the main limiting factor was the low level of the input format of
qbfplan  problem descriptions must be specified as ml code which generates the qbf
encodings  writing new encodings turned out to be a very dicult task  especially due to
the lack of documentation 
we ran cgp  qbfplan and cmbp on an intel    mhz pentium ii     mb ram 
running linux  the comparison between cmbp and gpt was run on a sun ultra sparc
   mhz     mb ram running solaris  gpt was available as a binary   however  the
performance of the two machines is comparable   the run times for cmbp were almost
identical  cpu time was limited to      sec  two hours  for each test  to avoid swapping 
the memory limit was fixed to the physical memory of the machine  in the following  we
write     or       for a test that did not complete within the above time and memory
limits  respectively  the performance of the systems are reported in tables listing only the
search time  this excludes the time needed by qbfplan to generate the encodings  the
time spent by cmbp to construct the automaton representation into bdd  and the time
needed by gpt to generate the source code of its internal representation  and to compile
it  overall  the most significant time ignored is the automaton construction of cmbp 
   

ficonformant planning via symbolic model checking
currently  the automaton construction is not fully optimized  even in the most complex
examples  however  the construction never required more than a couple of minutes  
      bomb in the toilet

bomb in the toilet  the first domain we tackled is the classical bomb in the toilet 
where there is no notion of clogging  we call the problem bt p   where the parameter p

is the number of packages  the only uncertainty is in the initial condition  where it is not
known which package contains the bomb  the goal is to defuse the bomb  the results for
the bt problem are shown in table    the columns relative to cmbp are the length of the
plan  jpj   the number of cached belief states and the number of hits in the cache   bs and
 nbs respectively   the time  expressed in seconds  needed for searching the automaton
under pentium linux  time l   and under sparc solaris  time s    in the following  when
clear from the context  the execution platform is omitted  the columns relative to cgp are
the number of levels in the planning graphs  jlj  and the search time  the column relative
to gpt is the search time 
bt   
bt   
bt   
bt   
bt   
bt   
bt   
bt   
bt    

jpj

 
 
 
 
 
 
 
 
  

cmbp

 bs  bsh
   
      
       
        
        
         
          
          
           

time l 
     
     
     
     
     
     
     
     
     

time s 
     
     
     
     
     
     
     
     
     

jlj
 
 
 
 
 
 
 
 
 

cgp

time
     
     
     
     
     
     
     
     
     

gpt

time
     
     
     
     
     
     
     
     
     

table    results for the bt problems 
the bt problem is intrinsically parallel  i e  the depth of the planning graph is always
one  because all the packages can be dunked at the same time  cgp inherits from graphplan the ability to deal with parallel actions eciently  and therefore it is almost insensitive
to the problem size  for this problem cgp outperforms both cmbp and gpt  notice that
the number of levels explored by cgp is always    while the length of the plan produced by
cmbp and cgp grows linearly  cmbp performs slightly better than gpt 
bomb in the toilet with clogging  we call btc p  the extension of the bt p  where
dunking a package  always  clogs the toilet  ushing can remove the clogging  and no clogging is a precondition for dunking a package  again  p is the number of packages  the toilet
is initially not clogged  with this modification  the problem no longer allows for a parallel
solution  the results for this problem are listed in table    the impact of the depth of
the plan length becomes significant for all systems  both cmbp and gpt outperform cgp 
in this case cmbp performs better than gpt  especially on large instances  see btc      
   more precisely  the maximum time in building the automaton was required for the bmtc       examples
    secs    the ring     example     secs    the bmtc      examples     secs    and the bmtc      
examples     secs    for most of the other examples  the time required for the automaton construction
was less than    seconds 

   

ficimatti   roveri
qbfplan

btc   
btc   
btc   
btc   
btc   
btc   
btc   
btc   
btc    

jpj

 
 
 
 
  
  
  
  
  

cmbp

cgp

 bs  bsh time l  time s  jlj time
   
     
       
     
       
     
       
     
       
     
       
     
        
     
       
     
         
     
        
     
         
     
        
     
          
     
               
           
     
               
           
     
                

btc                       

      

      

gpt

time
     
     
     
     
     
     
     
     
     
       

btc   
jpj time
 
    
 
    
 
    
 
    
 
    
 
    
 
    
 
     
 
     
  
     
           

btc    
time
 
    
 
    
 
    
 
    
 
    
 
    
 
     
 
     
 
      
  
      
          
          
  
 

jpj

   
   
  
 
            

table    results for the btc problems 
the comparison with qbfplan is limited to the   and    package instances  the ones available from the distribution package   the performance of qbfplan is reported in the left
table in table    each line reports the time needed to decide whether there is a plan of
length i  the performance of qbfplan is rather good when tackling an encoding admitting a solution  in table   these entries are labeled by       for instance  in the btc    
qbfplan finds the solution solving the encodings at depth    reasonably fast  however 
when a solution cannot be found  i e  the qbf formula admits no model  the performance
of qbfplan degrades significantly  for the depth    encoding  we let the solver run for   
cpu hours and it did not complete the search   because of the difference in performance 
and the diculty in writing new domains  in the rest of the comparison we will not consider
qbfplan 
bomb in multiple toilets  the next domain  called bmtc p t   is the generalization
of the btc problem to the case of multiple toilets  p is the number of packages  while t
is the number of toilets   the problem becomes more parallelizable when the number of
toilets increases  furthermore  we considered three versions of the problem with increasing
uncertainty in the initial states  in the first class of tests   low uncertainty  columns   the
only uncertainty is the position of the bomb which is unknown  while toilets are known to
be not clogged  the  mid uncertainty  and  high uncertainty  columns show the results
in presence of more uncertainty in the initial state  in the second  third  respectively  class
of tests  the status of every odd  every  resp   toilet can be either clogged or not clogged 
this increases the number of possible initial states 
the results are reported in table    for the comparison with cgp  and in table  
 for the comparison with gpt   the is column represents the number of initial states of
the corresponding problem  cgp is able to fully exploit the parallelism of the problem 
however  cgp is never able to explore more than   levels in the planning graph  with depth
decreasing with the number of initial states  the results also show that cmbp and gpt
are much less sensitive to the number of initial states than cgp  with increasing initial
   

fi p t 
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      

bmtc

is
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  

 
 
 
 
  
  
  
  
  
 
 
 
 
 
  
  
  
  
 
 
 
 
 
  
  
  
  
 
 
 
 
 
 
  
  
  
 
 
 
 
 
 
  
  
  

jpj

low uncertainty
cmbp
 bs  bsh time
             
             
              
               
                
                
                 
                  
                  
             
              
               
                
                
                  
                  
                  
                   
             
              
                
                
                 
                  
                  
                   
                     
              
                
                
                 
                  
                  
                   
                     
                     
              
                
                
                  
                  
                   
                     
                     
               e           
time
     
     
     
     
     
       
       
 
     
     
     
     
     
        
 

cgp

   

mid uncertainty
cmbp
is
 bs  bsh time
 
             
 
              
 
              
  
               
  
                
  
                
  
                 
  
                  
  
                  
 
             
  
              
  
               
  
                
  
                
  
                 
  
                 
  
                 
  
                  
 
             
  
               
  
                
  
                
  
                  
  
                  
  
                  
  
                  
  
                    
  
              
  
                
  
                
  
                 
  
                  
  
                  
  
                    
  
                     
  
                     
  
              
  
                
  
                 
  
                  
  
                  
  
                    
  
                     
                  e          
                  e           
     
     
     
 

       
       
        
        
        
 
 

       
       
       
        
 
 

 
 
 
 

     
     
     
 

 
 
 
 

 
 
 
 
 

time
     
     
     
      
 

cgp

jlj

table    results for the bmtc problems 

 
     
 
     
 
     
 
     
 
     
 
     
 
     
 
 
 
     
 
     
 
     
 
     
 
     
        
        
         
         
 
     
 
     
 
     
 
     
 
     
         
          
          
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

jlj

high uncertainty
cmbp
is
 bs  bsh time
 
             
  
              
  
              
  
               
  
                
  
                
  
                 
  
                  
  
                  
  
              
  
              
  
               
  
                
  
                
  
                  
  
                  
  
                  
  
                   
  
              
  
               
  
                
  
                
  
                  
   
                  
   
                  
   
                   
   
                     
  
              
  
                
   
                
   
                 
   
                  
   
                  
   
                    
   
                     
   
                     
   
                
   
                
   
                 
   
                  
   
                  
   
                    
   
                     
                   e          
                   e           
     
     
      
 

     
     
 

time
     
      
       
 

cgp

         
          
          
 
 

        
         
         
          
 
 

 
 
 
 

 
 
 

 
 
 
 

jlj

conformant planning via symbolic model checking

ficimatti   roveri
bmtc

 p t 
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      

low unc 

cmbp

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
      
      
       

gpt

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
      
     
     
     
     
     
      
      
       
       

high unc 

cmbp

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
       
     
     
     
     
     
      
      
      
       

gpt

time
     
     
     
     
     
     
     
     
      
     
     
     
     
     
      
      
       
       
     
     
      
      
       
       
   

table    results for the bmtc problems 
uncertainty  cgp is almost unable to solve what were trivial problems  gpt performs better
than cgp  but it suffers from the explicit representation of the search space 
bomb in the toilet with uncertain clogging  the btuc p  domain is the domain
described in section    where clogging is an uncertain outcome of dunking a package  this
kind of problem cannot be expressed in cgp  the results for cmbp and gpt are reported
in table    although cmbp performs better than gpt  by a factor of two to three   there
is no significant difference in the behavior  it is interesting to compare the results of cmbp
for the btc and btuc problems  for gpt a slight difference is noticeable  resulting from
the increased branching factor in the search space due to the uncertainties in the effects of
action executions  in the performance of cmbp  the number of uncertainties is not a direct
factor   for example  in the btc     and btuc      the performance is almost the same 
      ring of rooms

simple ring of room  we considered another domain  where a robot can move in a
ring of rooms  each room has a window  which can be either open  closed or locked  the
robot can move  either clockwise or counterclockwise   close the window of the room where
it is  and lock it if closed  the goal is to have all windows locked 
   

ficonformant planning via symbolic model checking
cmbp

jpj

btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc    
btuc    

 bs  bsh
   
       
       
        
         
         
          
           
           
               

 
 
 
 
  
  
  
  
  
  

time
     
     
     
     
     
     
     
     
     
      

gpt

time
     
     
     
     
     
     
     
     
     
       

table    results for the btuc problems 
n  

n

 

 

in the problem ring r   where r is the number of rooms  the uncertainty is only in the
initial condition  both the position of the robot and the status of the windows can be
uncertain  these problems do not have a parallel solution  and have a large number of initial
states  r   r    corresponding to full uncertainty on the position of the robot and on the
status of each window  the results  are reported on the left in table    cmbp outperforms
ring   
ring   
ring   
ring   
ring   
ring   
ring   
ring   
ring    

jpj

 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
        
         
          
           
            
             
              

time
     
     
     
     
     
     
     
      
       

jlj
 
 

cgp

time
     
 

gpt

time
     
     
     
     
     
      
       
   

is
 
 
 
 
  

cgp on ring   

jlj
 
 
 
 
 

time
     
     
     
     
 

jlj
 
 
 
 
 

time
     
     
     
       
 

table    the results for the ring problems 
both cgp and gpt  although gpt performs much better than cgp  both cgp and gpt
suffer from the increasing complexity of the problem  on the right in table    we plot  for
the ring    problem  the dependency of cgp on the number of initial states combined
with the number of levels to be explored  different goals were provided which require the
exploration of different levels   it is clear that the number of initial states and the depth of
the search are both critical factors for cgp 
   the times reported for cgp refer to a scaled down version of the problem  where locking is not taken
into account  and thus the maximum number of initial states is r   r  

   

ficimatti   roveri
ring of rooms with uncertain action effects  we considered a variation of the

ring domain  called uring  first introduced by cimatti and roveri         which is not
expressible in cgp  if a window is not locked and the robot is not performing an action
which will determine its status  e g  closing it   then the window can open or close nondeterministically  for instance  while the robot is moving from room   to room    the windows in
room   and   could be open or closed by the wind  this domain is clearly designed to stress
the ability of a planner to deal with actions having a large number of resulting states  in the
worst case  e g  a move action performed when no window is locked   there are  r possible
resulting states  although seemingly artificial  this captures the fact that environments can
be in practice highly nondeterministic  we tried to compare cmbp and gpt on the uring
problem  in principle gpt is able to deal with uncertainty in the action effects  however 
we failed to codify the uring in the gpt language  because it requires a conditional description of uncertain effects  therefore  we experimented with a variation of the ring
domain featuring a higher degree of nondeterminism  called ndring in the following  the
ndring domain contains an increasing number of additional propositions  called in the
following noninertial propositions  which are initially unknown and are nondeterministically
altered by each action  if i is the number of noninertial propositions  each action has  i
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring    

jpj

 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
        
         
          
           
            
             
              

time    
     
     
     
     
     
     
     
      
       

time    
     
     
     
     
      
       
   

gpt

time    
     
     
     
      
      
   

time    
     
     
      
      
   

time    
     
      
      
   

table    the results for the ndring problems 
possible outcomes  the results are listed in table    with columns labeled with time i  
the growing branching factor during the search has a major impact on the performance of
gpt  while cmbp is insensitive to this kind of uncertainty   the performance of cmbp for
a lower number of noninertial propositions are not reported because they are basically the
same  
the uring problem was run only on cmbp  the results are listed in table    it can
be noticed that the performances of cmbp improve significantly with respect to the ring
problem  this can be explained considering that  despite the larger number of transitions 
the number of explored belief states is significantly smaller  see the bs cache statistics in
tables   and    
      square and cube

the following domains are the square n  and cube n  from the gpt distribution  bonet
  geffner         these problems consist of a robot navigating in a square or cube of side
n  in both domains there are actions for moving the robot in all the possible directions 
moving the robot against a boundary leaves the robot in the same position  the original
   

ficonformant planning via symbolic model checking

uring   
uring   
uring   
uring   
uring   
uring   
uring   
uring   
uring    

jpj
 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
       
        
        
         
          
          
           

time
     
     
     
     
     
     
     
     
      

table    results for the uring problems 
problems  called corner in the following  require the robot to reach a corner  starting
from a completely unspecified position  we introduced two variations  in the first  called
face  the initial position is any position of a given side  face  of the square  cube   while
the goal is to reach the central position of the opposite side  face   in the second  called
center  the initial position is completely unspecified  and the goal is the center of the
square  cube   for the corner problem  a simple heuristic is to perform only steps towards
the corner  thus pruning half of the actions  the variations are designed not to allow for a
simple heuristic   for instance  in the center problem  no action can be eliminated 
square i 
square   
square   
square   
square   
square    
square    
square    
square    
square    
square    
cube i 
cube   
cube   
cube   
cube   
cube   
cube   
cube   
cube   
cube    
cube    

jpj

 
 
 
  
  
  
  
  
  
  

jpj

 
 
  
  
  
  
  
  
  
  

corner
cmbp
 bs  bsh time
           
             
             
              
              
               
               
               
               
                

corner
cmbp
 bs  bsh time
            
             
              
               
               
                
                
                
                
                  

gpt

time
     
     
     
     
     
     
     
     
     
     

gpt

time
     
     
     
     
     
     
     
     
     
     

jpj

 
 
  
  
  
  
  
  
  
  

jpj

 
 
  
  
  
  
  
  
  
  

face
cmbp
 bs  bsh time
           
             
              
               
               
                
                
                
                
                 

gpt

time
     
     
     
     
     
     
     
     
     
     

jpj

 
 
  
  
  
  
  
  
  
  

center
cmbp
 bs  bsh time
           
              
               
                
                
                 
                 
                 
                 
                 

gpt

time
     
     
     
     
     
     
      
      
      
      

face
center
cmbp
gpt
cmbp
gpt
 bs  bsh time time jpj  bs  bsh time time
                    
                  
                     
                   
                         
                      
                         
                       
                                                    
                                                     
                                                      
                                                        
                                                
   
                     
                            

table    results for the square and cube problems 
the results for these problems are reported in table    the tests were run only with
cmbp and gpt  the experiments highlight that the eciency of gpt strongly depends on
the quality of the heuristic function  if  as in the first set of experiments  the heuristics are
   

ficimatti   roveri
effective  then gpt is almost as good as cmbp  otherwise  gpt degrades significantly  in
general  finding heuristics which are effective in the belief space appears to be a nontrivial
problem  cmbp appears to be more stable    as it performs a blind  breadth first search 
and relies on the cleverness of the symbolic representation to achieve eciency 
      omelette

finally  we considered the omelette i  problem  levesque         the goal is to have i
good eggs and no bad ones in one of two bowls of capacity i  there is an unlimited number of
eggs  each of which can be unpredictably good or bad  the eggs can be grabbed and broken
into a bowl  the content of a bowl can be discarded  or poured to the other bowl  breaking
a rotten egg in a bowl has the effect of spoiling the bowl  a bowl can always be cleaned
by discarding its content  the problem is originally presented as a partial observability
problem  with a sensing action allowing to test if a bowl is spoiled or not  we considered
the variation of the problem without sensing action  in this case no conformant solution
exists  we used the omelette problems to test the ability of cmbp and gpt to discover
that the problem admits no conformant solution  the results are reported in table     the
table shows that cmbp is very effective in checking the absence of a conformant solution 
and outperforms gpt by several orders of magnitude 
omelette   
omelette   
omelette   
omelette   
omelette   
omelette   
omelette   
omelette    
omelette    
omelette    
omelette    

  steps
 
  
  
  
  
  
  
  
  
  
  

cmbp
 bs  bsh
       
       
       
       
       
       
       
       
        
        
         

time
     
     
     
     
     
     
     
     
     
     
     

gpt
time
     
     
     
     
     
      
      
      
       
   

table     results for the omelette problems 
    summarizing remarks

overall  cmbp appears to implement the most effective approach to conformant planning 
both in terms of expressivity and performance  cgp is only able to deal with uncertainties
in the initial states  and cannot conclude that the problem does not admit a conformant
solution  the main problem in cgp seems to be its enumerative approach to uncertainties 
and the increased number of initial states severely affects the performance  see table   and
table    
qbfplan is in principle able to deal with uncertain action effects  but cannot conclude
that the problem does not admit a conformant solution  from the small number of ex   consider also that the problems are increasingly more dicult  see for instance the plan length  

   

ficonformant planning via symbolic model checking
periments that we could perform  the approach implemented by qbfplan is limited by
the satplan style of search  the intermediate results obtained while solving an encoding
at depth k are not reused while solving encodings of increasing depth  furthermore  the
solver appears to be specialized in finding a model  rather than in proving unsatisfiability 
however  the latter ability is needed in all encodings but the final one 
gpt is a very expressive system  which allows eciently dealing with a wide class of
planning problems  as far as conformant planning is concerned  it is as expressive as
cmbp  it allows dealing with uncertain action effects  and can conclude that a problem
does not have a conformant solution  however  cmbp appears to outperform gpt in
several respects  first  the behaviour of gpt appears to be directly related to the number
of possible outcomes in an action  furthermore  the eciency of gpt depends on the
effectiveness of the heuristic functions  which can be sometimes dicult to devise  and
cannot help when the problem does not admit a solution 
the main strength of cmbp is its independence on the number of uncertainties  which
is achieved with the use of symbolic techniques  being fully symbolic  cmbp does not
exhibit the enumerative behaviour of its competitors  compared to the original approach
described by cimatti and roveri         a substantial improvement of the performance
has been obtained by the new implementation of the pruning step  a disclaimer is in
order  it is well known that bdd based computations are subject to a blow up in memory
requirements when computing certain classes of boolean functions  e g  multipliers  bryant 
       it would be trivial to make up an example where the performance of cmbp degrades
exponentially  however  in none of the examples we considered  which included all the
examples in the distribution of cgp and gpt  this phenomenon occurred 
   other related work

the term conformant planning was first introduced by goldman         while presenting a
formalism for constructing conformant plans based on an extension of dynamic logic  recently  ferraris and giunchiglia        presented another conformant planner based on sat
techniques  the system is not available for a direct comparison with cmbp  the effectiveness of the approach is dicult to evaluate  as only a limited testing is described  ferraris  
giunchiglia         the performance is claimed to be comparable with cgp  however  the
results are reported only for the enconding corresponding to the solution  and the behaviour
of qbfplan reported in table   suggests that this kind of analysis might be limited 
several works share the idea of planning based on automata theory  the most closely
related are the works in the lines of planning via model checking  cimatti et al          upon
which our work is based  this approach allows  for instance  to automatically construct
universal plans which are guaranteed to achieve the goal in a finite number of steps  cimatti
et al       b   or which implement trial and error strategies  cimatti et al       a  daniele
et al          these results are obtained under the hypothesis of total observability  while
here run time observation is not available  the main difference is that a substantial extension is required to lift symbolic techniques to search in the space of belief states  de
giacomo and vardi        analyze several forms of planning in the automata theoretic
framework  goldman  musliner and pelican        present a method where model checking
in timed automata is interleaved with the plan formation activity  to make sure that the
   

ficimatti   roveri
timing constraints are met  finally  hoey and his colleagues        use algebraic decision
diagrams to tackle the problem of stochastic planning 
   conclusions and future work

in this paper we presented a new approach to conformant planning  based on the use
of symbolic model checking techniques  the algorithm is very general  and applies to
complex planning domains  with uncertainty in the initial condition and in action effects 
which can be described as finite state automata  the algorithm is based on a breadthfirst  backward search  and returns conformant plans of minimal length  if a solution to the
planning problem exists  otherwise  it terminates with failure  the algorithm is designed
to take full advantage of the symbolic representation based on bdds  the implementation
of the approach in the cmbp system has been highly optimized  in particular in the crucial
step of termination checking  we performed an experimental comparison of our approach
with the state of the art conformant planners cgp  qbfplan and gpt  cmbp is strictly
more expressive than qbfplan and cgp  on all the problems for which a comparison
was possible  cmbp outperformed its competitors in terms of run times  sometimes by
orders of magnitude  thanks to the use of symbolic data structures  cmbp is able to deal
eciently with problems with large numbers of initial states and action outcomes  on
the other hand  the qualitative behavior of cgp and gpt seems to depend heavily on the
enumerative nature of their algorithms  differently from gpt  cmbp is independent of the
effectiveness of the heuristic used to drive the search 
the research presented in this paper will be extended in the following directions  first 
we are investigating an alternative approach to conformant planning  where the breadthfirst style of the search is given up  these techniques appear to be extremely promising  
preliminary experiments have led to speed ups of up to two orders of magnitude over the
results presented in this paper for problems which admit a solution  second  we will tackle
the problem of conditional planning under partial observability  under the hypothesis that
a limited amount of information can be acquired at run time  as conformant planning  this
problem can be seen as search in the belief space  however  it appears to be significantly
complicated by the need for dealing with run time observation and conditional plans  finally  we are considering the extension of the domain construction of the planner with more
expressive input language  such as c   and invariant detection techniques 
acknowledgements

fausto giunchiglia provided continuous encouragement and feedback on this work  we
thank piergiorgio bertoli  blai bonet  marco daniele  hector geffner  enrico giunchiglia 
jussi rintanen  david smith  paolo traverso  dan weld for valuable discussions on conformant planning and various comments on this paper  david smith provided the code of
cgp  a large number of examples  and the time out mechanism used in the experimental
evaluation  jussi rintanen made qbfplan available under linux 
   

ficonformant planning via symbolic model checking
references

blum  a  l     furst  m  l          fast planning through planning graph analysis  in
proc  ijcai 
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial intelligence                  
bonet  b     geffner  h          planning with incomplete information as heuristic se
arch in belief space  in chien  s   kambhampati  s     knoblock  c   eds     th
international conference on artificial intelligence planning and scheduling  pp     
    aaai press 
brace  k   rudell  r     bryant  r          ecient implementation of a bdd package  in   th acm ieee design automation conference  pp        orlando  florida 
acm ieee  ieee computer society press 
bryant  r  e          graph based algorithms for boolean function manipulation  ieee
transactions on computers  c                 
bryant  r  e          on the complexity of vlsi implementations and graph representations
of boolean functions with application to integer multiplication  ieee transactions
on computers                  
bryant  r  e          symbolic boolean manipulation with ordered binary decision diagrams  acm computing surveys                  
burch  j  r   clarke  e  m   mcmillan  k  l   dill  d  l     hwang  l  j          symbolic
model checking       states and beyond  information and computation         
        
cassandra  a   kaelbling  l     littman  m          acting optimally in partially observable
stochastic domains  in proc  of aaai     aaai press 
cimatti  a   clarke  e   giunchiglia  f     roveri  m          nusmv   a new symbolic
model checker  international journal on software tools for technology transfer
 sttt         
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  a decision procedure for ar  in steel  s     alami  r   eds    proceeding
of the fourth european conference on planning  no       in lecture notes in artificial
intelligence  pp          toulouse  france  springer verlag  also itc irst technical
report          itc irst trento  italy 
cimatti  a     roveri  m          conformant planning via model checking  in biundo 
s   ed    proceeding of the fifth european conference on planning  lecture notes
in artificial intelligence durham  united kingdom  springer verlag  also itc irst
technical report          itc irst trento  italy 
   

ficimatti   roveri
cimatti  a     roveri  m          forward conformant planning via symbolic model
checking  in proceeding of the aips k workshop on model theoretic approaches to
planning breckenridge  colorado 
cimatti  a   roveri  m     traverso  p       a   automatic obdd based generation of
universal plans in non deterministic domains  in proceeding of the fifteenth national
conference on artificial intelligence  aaai     madison  wisconsin  aaai press 
also irst technical report          trento  italy 
cimatti  a   roveri  m     traverso  p       b   strong planning in non deterministic
domains via model checking  in proceeding of the fourth international conference
on artificial intelligence planning systems  aips     carnegie mellon university 
pittsburgh  usa  aaai press 
clarke  e  m     wing  j  m          formal methods  state of the art and future directions 
acm computing surveys                  
clarke  e   emerson  e     sistla  a          automatic verification of finite state concurrent systems using temporal logic specifications  acm transactions on programming
languages and systems                 
coudert  o   madre  j  c     touati  h          tiger version     user guide  digital
paris research lab 
daniele  m   traverso  p     vardi  m  y          strong cyclic planning revisited  in
biundo  s   ed    proceeding of the fifth european conference on planning  lecture
notes in artificial intelligence durham  united kingdom  springer verlag 
de giacomo  g     vardi  m          automata theoretic approach to planning for temporally extended goals  in biundo  s   ed    proceeding of the fifth european conference on planning  lecture notes in artificial intelligence durham  united kingdom 
springer verlag 
ferraris  p     giunchiglia  e          planning as satisfiability in nondeterministic domains  in proceedings of seventeenth national conference on artificial intelligence
 aaai     austin  texas  aaai press 
ghallab  m   howe  a   knoblock  c   mcdermott  d   ram  a   weld  d     wilkins 
d          pddl   the planning domain definition language  tech  rep  cvc
tr        dcs tr       yale center for computational vision and control 
giunchiglia  e          determining ramifications in the situation calculus  in in fifth
international conference on principles of knowledge representation and reasoning
 kr     cambridge  massachusetts  morgan kaufmann publishers 

giunchiglia  e   kartha  g  n     lifschitz  v          representing action  indeterminacy
and ramifications  artificial intelligence                  
   

ficonformant planning via symbolic model checking
giunchiglia  e     lifschitz  v          an action language based on causal explanation 
preliminary report  in proceedings of the   th national conference on artificial intelligence  aaai     and of the   th conference on innovative applications of artificial
intelligence  iaai      pp          menlo park  aaai press 

goldman  r  p   musliner  d  j     pelican  m  j          using model checking to
plan hard real time controllers  in proceeding of the aips k workshop on modeltheoretic approaches to planning breckenridge  colorado 
goldman  r     boddy  m          expressive planning and explicit knowledge  in
proceedings of the  rd international conference on artificial intelligence planning
systems  aips      pp           aaai press 

hoey  j   st aubin  r   hu  a     boutilier  c          spudd  stochastic planning using decision diagrams  in proceedings of the fifteenth conference on uncertainty in
articial intelligence         pp           aaai press 
kautz  h     selman  b          blackbox  a new approach to the application of
theorem proving to problem solving  in working notes of the workshop on planning
as combinatorial search pittsburgh  pa  usa 
kautz  h  a   mcallester  d     selman  b          encoding plans in propositional logic 
in proc  kr    
kautz  h  a     selman  b          pushing the envelope  planning  propositional logic 
and stochastic search  in proc  aaai    
kushmerick  n   hanks  s     weld  d  s          an algorithm for probabilistic planning 
artificial intelligence                    
levesque  h  j          what is planning in the presence of sensing   in proceedings of the
thirteenth national conference on artificial intelligence and the eighth innovative
applications of artificial intelligence conference  pp            menlo park  aaai

press   mit press 
mcdermott  d          a critique of pure reason  computational intelligence             
    
mcmillan  k          symbolic model checking  kluwer academic publ 
michie  d          machine intelligence at edinburgh  in on machine intelligence  pp 
         edinburgh university press 
nilsson  n          principles of artificial intelligence  morgan kaufmann publishers  inc  
los altos  ca 
peot  m          decision theoretic planning  ph d  thesis  dept  engineering economic
systems   stanford university 
rintanen  j       a   constructing conditional plans by a theorem prover  journal of
artificial intellegence research              
   

ficimatti   roveri
rintanen  j       b   improvements to the evaluation of quantified boolean formulae 
in dean  t   ed      th iinternational joint conference on artificial intelligence  pp 
           morgan kaufmann publishers 
smith  d  e     weld  d  s          conformant graphplan  in proceedings of the   th
national conference on artificial intelligence  aaai     and of the   th conference
on innovative applications of artificial intelligence  iaai      pp          menlo

park  aaai press 
somenzi  f          cudd  cu decision diagram package   release        department of
electrical and computer engineering   university of colorado at boulder 
weld  d  s   anderson  c  r     smith  d  e          extending graphplan to handle
uncertainty and sensing actions  in proceedings of the   th national conference on
artificial intelligence  aaai     and of the   th conference on innovative applications of artificial intelligence  iaai      pp          menlo park  aaai press 

yang  b   bryant  r  e   o hallaron  d  r   biere  a   coudert  o   janssen  g   ranjan 
r  k     somenzi  f          a performance study of bdd based model checking  in
proceedings of the formal methods on computer aided design  pp          

   

fi