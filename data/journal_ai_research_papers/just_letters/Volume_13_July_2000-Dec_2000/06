journal artificial intelligence research                  

submitted       published      

conformant planning via symbolic model checking
cimatti irst itc it

alessandro cimatti

itc irst

  via sommarive           povo  trento  italy

roveri irst itc it

marco roveri

itc irst

  via sommarive           povo  trento  italy

dsi  university milano  via comelico           milano  italy

abstract

tackle problem planning nondeterministic domains  presenting new
approach conformant planning  conformant planning problem finding sequence actions guaranteed achieve goal despite nondeterminism
domain  approach based representation planning domain finite
state automaton  use symbolic model checking techniques  particular binary decision diagrams  compactly represent eciently search automaton  paper
make following contributions  first  present general planning algorithm
conformant planning  applies fully nondeterministic domains  uncertainty
initial condition action effects  algorithm based breadth first  backward search  returns conformant plans minimal length  solution planning
problem exists  otherwise terminates concluding problem admits conformant
solution  second  provide symbolic representation search space based binary
decision diagrams  bdds   basis search techniques derived symbolic
model checking  symbolic representation makes possible analyze potentially large
sets states transitions single computation step  thus providing ecient
implementation  third  present cmbp  conformant model based planner   ecient
implementation data structures algorithm described above  directly based
bdd manipulations  allows compact representation search layers
ecient implementation search steps  finally  present experimental comparison approach state of the art conformant planners cgp  qbfplan
gpt  analysis includes planning problems distribution packages
systems  plus problems defined stress number specific factors  approach appears effective  cmbp strictly expressive qbfplan
cgp and  problems comparison possible  cmbp outperforms
competitors  sometimes orders magnitude 
   introduction

recent years  growing interest planning nondeterministic domains 
rejecting fundamental  and often unrealistic  assumptions classical planning  domains considered actions uncertain effects  exogenous events possible 
initial state partly specified  challenge find strong plan 
guaranteed achieve goal despite nondeterminism domain  regardless
uncertainty initial condition effect actions  conditional planning  cassandra  kaelbling    littman        weld  anderson    smith        cimatti 
roveri    traverso      b  tackles problem searching conditional course
c      ai access foundation morgan kaufmann publishers  rights reserved 

ficimatti   roveri
actions  depends information gathered run time  certain domains 
however  run time information gathering may expensive simply impossible  conformant planning  goldman   boddy        problem finding unconditioned
course actions  i e  classical plan  depend run time information gathering guarantee achievement goal  conformant planning recognized
significant problem artificial intelligence since work michie         blind
robot problem requires program activity sensorless agent  positioned location given room  guaranteed achieve given
goal  conformant planning seen problem control system
unobservable unknown state  microprocessor power up  software
system black box testing 
uncertainty  plan associated potentially many different executions 
must taken account order guarantee goal achievement  makes
conformant planning significantly harder classical planning  rintanen      a  de giacomo   vardi         despite increased complexity  several approaches conformant
planning recently proposed  based  extensions of  main planning techniques classical planning  interesting cgp  smith   weld        based
graphplan  qbfplan  rintanen      a  extends sat plan approach
qbf  gpt  bonet   geffner        encodes conformant planning heuristic
search  paper  propose new approach conformant planning  based symbolic model checking  mcmillan         symbolic model checking formal verification
technique  allows one analyze finite state automata high complexity  relying
symbolic techniques  binary decision diagrams  bdds   bryant        particular 
compact representation ecient search automaton  approach builds
planning via model checking paradigm presented cimatti colleagues       
    b      a   finite state automata used represent complex  nondeterministic
planning domains  planning based  extensions of  basic model checking steps 
make following contributions 

first  present general algorithm conformant planning  applies

nondeterministic domain uncertain action effects initial condition  expressed
nondeterministic finite state automaton  algorithm performs breadth first
search  exploring plans increasing length  plan found candidate
plans available  algorithm complete  i e  returns failure
problem admits conformant solution  problem admits solution 
algorithm returns conformant plan minimal length 

second  provide symbolic representation search space based binary

decision diagrams  allows application search techniques derived
symbolic model checking  symbolic representation makes possible analyze
sets transitions single computation step  sets compactly represented eciently manipulated despite potentially large cardinality 
way possible overcome enumerative nature approaches
conformant planning  degree nondeterminism tends limiting
factor 
   

ficonformant planning via symbolic model checking

third  developed cmbp  conformant model based planner   ecient

implementation data structures algorithm described above  cmbp developed top mbp  planner based symbolic model checking techniques
developed cimatti  roveri traveso      b      a   cmbp implements several
new techniques  directly based bdd manipulations  compact search layers
optimize termination checking 
finally  provide experimental evaluation state of the art conformant planners  comparing cmbp cgp  qbfplan gpt  difference
expressivity  problems tackled cmbp represented planners  however  problems direct comparison
possible  cmbp outperforms competitors  particular  features better
qualitative behavior  directly related number initial states uncertain
action effects  stable respect use heuristics 
paper structured follows  section   review representation  nondeterministic  planning domains finite state automata  section   provide
intuitions formal definition conformant planning setting  section  
present planning algorithm  section   discuss symbolic representation
search space  allows ecient implementation  section   present
cmbp planner  section   present experimental results  section  
discuss related work  section   draw conclusions discuss future
research directions 
   planning domains finite state automata

interested complex  nondeterministic planning domains  actions
preconditions  conditional effects  uncertain effects  initial state
partly specified  rest paper  use simple though paradigmatic domain
explanatory purposes  variation moore s bomb toilet domain  mcdermott 
       from called btuc   bt uncertain clogging   two packages 
one contains armed bomb  possible dunk either package
toilet  actions dunk  dunk     provided toilet clogged  dunking either
package uncertain effect clogging toilet  furthermore  dunking package
containing bomb effect disarming bomb  action f lush effect
unclogging toilet 
represent domains finite state automata  figure   depicts automaton
btuc domain  state given number  contains propositions holding
state  instance  state   represents state bomb package   
defused  toilet clogged  given one bomb  write in 
abbreviation negation in    arrows states depict transitions
automaton  representing possible behavior actions  transition state  
state   labeled f lush represents fact action f lush  executed state
   effect removing clogging  execution dunk  state   
uncertain effect clogging toilet  represented multiple transitions
states      since transition outgoing state   labelled dunk   
   

ficimatti   roveri
flush
flush

dunk  
in    
defused
 clogged

in    
 defused
 clogged

dunk   
dunk  

dunk  
flush

flush
in    
 defused
clogged

in    
defused
clogged

flush
flush

dunk  
in    
defused
 clogged

 

in  
 defused
 clogged

dunk   
dunk  

dunk  
flush

flush
in    
defused
clogged

in    
 defused
clogged

figure    automaton btuc domain
state   satisfy preconditions action dunk    i e  dunk  applicable
state   
formally define nondeterministic planning domains follows 
definition    planning domain  planning domain   tuple    p     a  r  

p  finite  set atomic propositions   p set states 
 finite  set actions  r transition relation 



intuitively  proposition state holds state  following
assume planning domain given  use s  s  s   denote states d 
denote actions  r s  ff  s    holds iff executing action state
state s  possible outcome  say action applicable iff least
one state s  r s  ff  s    holds  say action deterministic iff
unique state s  r s  ff  s    holds  action uncertain outcome
least two distinct states s  s   r s  ff  s    r s  ff  s    
hold  described cimatti colleagues         automaton given domain
eciently built starting compact description given expressive high level
action language  instance ar  giunchiglia  kartha    lifschitz        
   conformant planning

conformant planning  goldman   boddy        described problem finding
sequence actions guaranteed achieve goal regardless nondeterminism
domain  is  possible initial states  uncertain action effects 
execution plan results goal state 
consider following problem btuc domain  initially  bomb armed
position status toilet uncertain  i e  initial state
states f          g   goal reach state bomb defused  toilet
   

ficonformant planning via symbolic model checking

in    
 defused
 clogged

in    
 defused
clogged

in    
 defused
 clogged

in    
 defused
clogged

in    
defused
 clogged

flush

flush

flush

flush

in    
defused
 clogged

flush

flush
in    
 defused
 clogged

dunk  

in    
defused
clogged

in    
defused
 clogged

dunk  

in    
defused
clogged

in    
 defused
 clogged

dunk  

in    
defused
 clogged

flush
in    
 defused
 clogged

dunk  

in    
 defused
 clogged

in    
 defused
clogged

flush

in    
defused
clogged

flush

flush

flush

in    
defused
 clogged

in    
defused
 clogged

flush

figure    conformant solution btuc problem
clogged  i e  set goal states f    g  conformant plan solving problem

f lush  dunk    f lush   dunk    f lush
   
figure   outlines possible executions plan  possible initial states
uncertain action effects  initial uncertainty lies fact domain might
states f          g   possible initial states planning domain
collected set dashed line  call set belief state  intuitively  belief
state expresses condition uncertainty domain  collecting together
states indistinguishable point view agent reasoning
domain  first action  f lush  used remove possible clogging  reduces
uncertainty belief state f    g  despite remaining uncertainty  i e  still
known package bomb is   action dunk  guaranteed applicable
precondition met states  dunk  effect defusing bomb
contained package    uncertain effect clogging toilet  resulting
belief state f          g   following action  f lush  removes clogging  reducing
uncertainty belief state f    g  guarantees applicability dunk   
dunk    bomb guaranteed defused  toilet might clogged  states
    belief state f          g    final f lush reduces uncertainty belief
state f    g  guarantees achievement goal 
general  order plan conformant solution  action must executed
states satisfy preconditions  state result
execution plan  for initial states uncertain action effects 
goal state  main diculty achieving conditions information
 assumed be  available run time  therefore  planning time face problem
reasoning action execution belief state  i e  condition uncertainty 
definition    action applicability  let bs belief state  action
applicable bs iff bs      applicable every state   bs 
   

ficimatti   roveri
order action applicable belief state  require preconditions
must guaranteed notwithstanding uncertainty  words  reject  reckless 
plans  take chance applying action without guarantee applicability 
choice strongly motivated practical domains  possibly fatal consequences
follow attempt apply action preconditions might satisfied
 e g  starting fix electrical device without sure powered   effect
action execution uncertain condition defined follows 
definition    action image  let bs belief state  let action applicable bs  image  also called execution  bs  written image  ff  bs   defined

follows 

image  ff  bs    

fs  j exists   bs r s  ff  s   g

notice image action combines uncertainty belief state uncertainty action effects   consider instance image  dunk    f    g  f          g   
following  write image  ff  s  instead image  ff  fsg  
plans elements   i e  finite sequences actions  use   length
plan  denote generic plans    plan concatenation  notions
applicability image generalize plans follows 
definition    plan applicability image  let     let bs   applicable bs iff one following holds 
     bs      
     ff    applicable bs  applicable image  ff  bs  
image  also called execution  bs  written image    bs   defined as 
   image    bs     bs 
   image  ff    bs     image    image  ff  bs   

planning problem formally characterized set initial goal states 
following definition captures intuitive meaning conformant plan given above 
definition    conformant planning  let    p     a  r  planning domain 
planning problem triple  d    g              g  
plan conformant plan  that is  conformant solution to  planning
problem  d    g   iff following conditions hold 

 i  applicable  
 ii  image    i   g  
following  clear context  omit domain planning
problem  simply write  i   g   
   

ficonformant planning via symbolic model checking
   conformant planning algorithm

conformant planning algorithm based exploration space plans  limiting
exploration plans conformant construction  algorithm builds belief
state plan  bsp  pairs form hbs   i  bs non empty belief state
plan  idea use bsp pair associate explored plan maximal
belief state applicable  guaranteed result goal states 
exploration based basic function spreimage  ff  bs   that  given belief state
bs action ff  returns belief state containing states applicable 
whose image contained bs 
definition    strong pre image  let      bs belief state let
action  strong pre image bs ff  written spreimage  ff  bs   defined
follows 

spreimage  ff  bs     fs j applicable s  image  ff  s 

bsg

spreimage  ff  bs  empty  applicable it  conformant solution problem  spreimage  ff  bs   bs   therefore  plan conformant
solution problem  bs  g    plan ff  conformant solution problem
 spreimage  ff  bs   g   
figure   depicts space bsp pairs built algorithm solving btuc
problem  levels built goal  right  towards initial states 
left  level    bsp pair hf    g   i  composed set goal states indexed
  length plan    notice conformant solution every problem goal set
f    g initial states contained f    g   dashed arrows represent application
spreimage   level    bsp pair hf          g   f lushi built  since strong
pre image belief state   actions dunk  dunk  empty  level   
three bsp pairs   overlapping  belief states bs    bs  bs    indexed  respectively 
length   plans dunk    f lush  f lush  f lush dunk    f lush   a plan associated
belief state bsi sequence actions labeling path bsi bs     notice
bs  equal bs    therefore deserves expansion  expansion
belief states     gives belief states      obtained strong pre image
f lush  strong pre image actions dunk  dunk  returns empty
belief states  expansion bs  results three belief states  one resulting
strong pre image f lush reported  since equal bs    belief state
  equal bs    deserves expansion  belief state   obtained
expanding bs  bs    level    expansion produces bs     contains
initial states  therefore  corresponding plans conformant solutions
problem 
conformant planning algorithm conformantplan presented figure   
takes input planning problem form set states g  the domain
assumed globally available   algorithm performs backwards breadth first
search  exploring bsp pairs corresponding plans increasing length step 
status search  each level figure    represented bsp table  i e  set bsp
pairs
bspt   fhbs      i          hbsn   n ig
   

ficimatti   roveri
level

 

 

 

 

 

 

in    
 defused
 clogged

in    
 defused
 clogged
dunk  

in    
 defused
 clogged

in    
defused
 clogged

in    
 defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
 defused
 clogged
flush

in    
defused
 clogged

dunk  

bs  

in    
defused
clogged

in    
 defused
clogged

in    
defused
 clogged
bs  

in    
 defused
 clogged

in    
 defused
 clogged

in    
 defused
clogged

in    
 defused
 clogged

flush

in    
defused
 clogged

in    
defused
 clogged

in    
defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
defused
 clogged

dunk  
in    
defused
clogged

in    
defused
clogged

bs  

in    
 defused
 clogged

flush

in    
defused
clogged

in    
defused
 clogged

in    
defused
 clogged

in    
defused
clogged

in    
defused
clogged

flush

in    
defused
 clogged

in    
defused
 clogged
bs  

dunk  

bs  

in    
defused
 clogged

in    
 defused
clogged

bs  

bs  

 

in  
defused
 clogged

in    
defused
 clogged

in    
 defused
 clogged

 

in  
defused
clogged

bs   

in    
 defused
 clogged

in    
defused
 clogged

flush

in    
defused
clogged
dunk  

in    
defused
 clogged

dunk  

in    
defused
 clogged

in    
defused
 clogged

bs  

in    
defused
 clogged

in    
defused
clogged
bs  

bs  

figure    bsp tables btuc problem
plans length     j   j   i n 
call bsi belief set indexed   ambiguity arises  write bspt i  
bsi  array bsptables used store bsp tables representing levels
search  algorithm first checks  line    plans length    i e 
solution  conformant plan length exists   p lans      line    
loop entered  iteration  conformant plans increasing length explored
 lines       step line   expands bsp table bsptables i    stores
resulting bsp table bsptables i   bsp pairs redundant respect
current search eliminated bsptables i   line     possible solutions contained
bsptables i  extracted stored p lans  line     loop terminates either
plan found  p lans        space conformant plans completely explored
 bsptables i       
definitions basic functions used algorithm reported figure   
function expandbsptable expands bsp table provided argument  containing
conformant plans length    returns bsp table conformant plans length
i  bsp input bsp table expanded expandbsppair  possible
   

ficonformant planning via symbolic model checking

 
 
 
 
 
 
 
 
 
 
  
  
  
  

function conformantplan i  g  
begin

    
bsptables       f hg   g 
plans    extractsolution i   bsptables     
  bsptables i           p lans      
       
bsptables i     expandbsptable bsptables i     
bsptables i     prunebsptable bsptables i   bsptables  i  
plans    extractsolution i   bsptables i   

done
 bsptables i      
return fail 
else return plans 
end

figure    conformant planning algorithm 
action ff  strong pre image bs computed  resulting belief state bs 
empty  i e  belief state guarantees achievement bs 
plan extended hbs    ff  returned  expansion bsp table
union expansions bsp pair  function extractsolution takes
input bsp table returns  possibly empty  set plans index belief states
containing   prunebsptable takes input bsp table pruned  array
previously constructed bsp tables bsptables  index current step  removes
bsp table input plans worth explored
corresponding belief states already visited 
algorithm following properties  first  always terminates  follows
fact set explored belief sets  stored bsptables  monotonically
increasing   step proceed least one new belief state generated 
finiteness  the set accumulated belief states contained  s
finite   fix point eventually reached  second  correct  i e  plan returned
conformant solution given problem  correctness algorithm follows
properties spreimage   plan associated belief state
conformant  i e  guaranteed applicable results
belief state contained goal  third  algorithm optimal  i e  returns plans
minimal length  property follows breadth first style search  finally 
algorithm able decide whether problem admits solution  returning fail
cases  indeed  conformant solution always associated belief state containing
initial states  spreimage generates maximal belief state associated conformant
plan  new belief state generated exploration compared initial states
check solution  plan pruned equivalent plan already
explored 
   

ficimatti   roveri

 bspt    

expandbsptable

 
hbs   i bspt

 hbs   i 

expandbsppair

 hbs   i     fhbs    ff  ij bs    spreimage  ff  bs      g

expandbsppair

 bspt  bsptables  i    
fhbs     bspt j j   i  hbs       bsptables j    bs    bs g
prunebsptable

 i   bspt     f j exists hbs     bspt bsg

extractsolution

figure    primitives used conformant planning algorithm 
   conformant planning via symbolic model checking

model checking formal verification technique based exploration finite state
automata  clarke  emerson    sistla         symbolic model checking  mcmillan       
particular form model checking using binary decision diagrams compactly represent
eciently analyze finite state automata  introduction symbolic techniques
model checking led breakthrough size model could analyzed  burch
et al          made possible model checking routinely applied industry 
especially logic circuits design  for survey see clarke   wing        
rest section  provide overview binary decision diagrams 
describe representation planning domains  based bdd based
representation finite state automata used model checking  then  discuss
extension allows symbolically represent bsp tables transformations  thus
allowing ecient implementation algorithm described previous section 
    binary decision diagrams

reduced ordered binary decision diagram  bryant               improperly called bdd 
directed acyclic graph  dag   terminal nodes either rue f alse  nonterminal node associated boolean variable  two bdds  called left right
branches  figure    a  depicts bdd  a    b       a    b       a    b    
non terminal node  right  left  respectively  branch depicted solid  dashed  resp  
line  represents assignment value rue  f alse  resp   corresponding
variable  bdd represents boolean function  given truth assignment variables
bdd  value function determined traversing graph root
leaves  following branch indicated value assigned variables  
   path root leaf visit nodes associated subset variables bdd 
see instance path associated a     b  figure   a  

   

ficonformant planning via symbolic model checking

a 

a 

b 

a 

b 

a 

a 

b 

b 

b 

b 

a 

b 

b 

a 

a 

a 

b 

b 

b 

a 

b 

b 

b 

b 

b 

b 

b 

b 

true

false

true

false

 a 

b 

 b 

figure    two bdds formula  a    b       a    b       a    b    
reached leaf node labeled resulting truth value  v bdd  size jvj
number nodes  n node  var n  indicates variable indexing node n 
bdds canonical representation boolean functions  canonicity follows
imposing total order   set variables used label nodes 
node n respective non terminal child m  variables must ordered  i e  var n   
var m   requiring bdd contains isomorphic subgraphs 
bdds combined usual boolean transformations  e g  negation  conjunction  disjunction   given two bdds  instance  conjunction operator builds
returns bdd corresponding conjunction arguments  substitution
represented bdd transformations  following  v variable 
bdds  indicate  v    bdd resulting substitution v  
v  v  vectors  the number of  distinct variables  indicate  v   v   
parallel substitution variables vector v   corresponding  variables
v   
bdds allow transformations described quantifications  style quantified boolean formulae  qbf   qbf definitional extension propositional logic 
propositional variables universally existentially quantified  terms bdd
computations  quantification corresponds tranformation mapping bdd
variable vi quantified bdd resulting  propositional  formula 
formula  vi one variables  existential quantification vi   written
 vi  v            vn    equivalent  v           vn   vi f alse     v           vn   vi t rue   analogously  universal quantification  vi   v            vn   equivalent  v            vn   vi  f alse  
   

ficimatti   roveri
 v            vn   vi  t rue   qbf  quantifiers arbitrarily applied nested  general  qbf formula equivalent propositional formula  conversion subject
exponential blow up 
time complexity algorithm computing truth functional boolean transformation f   op  f  o jf  j jf  j   far quantifications concerned  time
complexity quadratic size bdd quantified  linear number
variables quantified  i e  o jvj jf j     bryant              
bdd packages ecient implementations data structures algorithms  brace
et al         somenzi        yang et al         coudert et al          basically  bdd package deals single multi rooted dag  node represents boolean function 
memory eciency obtained using  unique table   sharing common subgraphs
bdds  unique table used guarantee time isomorphic subgraphs redundant nodes multi rooted dag  creating
new node  unique table checked see node already present 
case new node created stored unique table  unique table
allows perform equivalence check two bdds constant time  since two
equivalent functions always share subgraph   brace et al         somenzi        
time eciency obtained maintaining  computed table   keeps track
results recently computed transformations  thus avoiding recomputation 
critical computational factor bdds order variables used   figure  
shows example impact change variable ordering size bdd  
certain class boolean functions  size corresponding bdd exponential
number variables possible variable ordering  bryant         many practical
cases  however  finding good variable ordering rather easy  beside affecting memory
used represent boolean function  finding good variable ordering big impact
computation times  since complexity transformation algorithms depends
size operands  bdd packages provide heuristic algorithms finding good
variable orderings  called try reduce overall size stored bdds 
reordering algorithms activated dynamically package  bdd
computation  total number nodes package reaches predefined threshold
 dynamic reoredering  
    symbolic representation planning domains
planning domain  p     a  r  represented symbolically using bdds  follows 

set  distinct  bdd variables  called state variables  devoted representation
states domain  variables direct association proposition
domain p used description domain  instance  btuc
domain  in    defused clogged associated unique bdd variable 
following write x vector state variables  particular order
irrelevant performance issues  rest section distinguish
proposition corresponding bdd variable 
state set propositions p  specifically  propositions intended
hold it   state s  corresponding assignment state variables
x   i e  assignment variable corresponding proposition p   assigned
   

ficonformant planning via symbolic model checking
rue  variable assigned f alse  represent bdd  s  
assignment unique satisfying assignment  instance          in   
defused   clogged  bdd representing state            in     defused  
clogged represents state    on   without loss generality  following
distinguish propositional formula corresponding bdd   representation
naturally extends set states q follows 
 q    

   s 

s q

words  associate set states generalized disjunction bdds
representing states  notice satisfying assignments  q 
exactly assignment representations states q  representation mechanism
natural  instance  bdd  i   representing set initial states
btuc    f          g  defused  set goal states g    f    g
corresponding bdd defused    clogged  bdd used represent set
states domain automaton  btuc   s     rue    p  
different formulation  two independent propositions in  in  used represent
position bomb   s   would bdd in     in   
general  bdd represents set  states correspond to  models 
consequence  set theoretic transformations naturally represented propositional
operations  follows 
 snq 
    s        q 
 q    q        q       q   
 q    q        q       q   

main eciency symbolic representation lies fact cardinality
represented set directly related size bdd  instance   g   uses
two  non terminal  nodes represent two states   i   uses one node represent four
states  limit cases   s    fg   the leaf bdds  rue f alse  respectively 
advantage  symbolic representation extremely ecient dealing irrelevant
information  notice  instance  variable defused occurs  f          g   
reason  symbolic representation dramatic improvement explicit 
enumerative representation  allows symbolic  bdd based model checkers
handle finite state automata large number states  see instance burch
et al          following  collapse set states bdd representing it 
another set bdd variables  called action variables  written   used represent
actions  use one action variable possible action a  intuitively  bdd action
variable true corresponding action executed  assume
sequential encoding used  i e  concurrent actions allowed  use bdd 
seq ff    express exactly one action variables must true time   
   specific case sequential encoding  alternative approach using dlog jaje possible 
assignment action variables denotes specific action executed  two assignments
mutually exclusive  constraint seq ff   needs represented  cardinality
set actions power two  standard solution associate one assignment
certain values  optimized solution  actually used implementation  described
sake simplicity 

   

ficimatti   roveri
btuc problem  contains three actions  use three bdd variables dunk   
dunk  f lush  express serial encoding constraint following bdd 

seq ff      dunk    dunk    f lush     dunk    dunk       dunk    f lush     dunk    f lush 

state variables  referring bdd action variables symbolic names
sake simplicity  practice  internally represented integers 
position ordering bdd package totally irrelevant logical terms 
bdd variables x represents set state action pairs  i e  relation
states actions  instance  applicability relation btuc  i e  
actions possible states  except dunking actions require toilet
clogged  represented bdd   clogged    dunk    dunk      notice
represents set    state action pairs  associating state applicable action 
transition   tuple composed state  the initial state transition  
action  the action executed   state  the resulting state transition  
represent transitions  another vector x   bdd variables  called next state variables 
allocated bdd package  write    s  representation state
next state variables     q  denote construction bdd corresponding
set states q  using variable next state vector x   instead current
state variables x   require jx j   jx   j  assume i th variable x
i th variable x   correspond  define representation set states next
variables follows 
   s      s  x  xx   
call operation  x  xx     forward shifting   transforms representation
set  current  states representation set  next  states  dual operation
 x    xx  called backward shifting  following  call x current state variables
distinguish next state variables  transition represented assignment
x   x     btuc  transition corresponding application action
dunk  state   resulting state   represented following bdd
 h   dunk     i           dunk         
transition relation r automaton corresponding planning domain
simply set transitions  thus represented bdd bdd variables x  
x    satisfying assignment represents possible transition 
 
 r     seq ff      t 
t r

rest paper  assume bdd representation planning domain
given  particular  assume given vectors variables x  xx   ffff  encoding
functions     simply call   r  g bdd representing states
domain  transition relation  initial states goal states  respectively  write
 v  stress bdd depends variables v  representation 
possible reason plans  simulating symbolically execution sets actions
sets states  means qbf transformations  bdd representing applicability
relation directly obtained following computation 
ff      x    r x  ffff xx   
applicable x  ff
   

ficonformant planning via symbolic model checking
resulting bdd  applicable x  ffff   represents set state action pairs
action applicable state  bdd representing states reachable q
one step obtained following computation 

 x  ff  r x  ffff xx    q x   x   xx 
notice that  single operation  symbolically simulate effect application
applicable action states q  similarly  following transformation allows symbolically compute spreimage set states q possible
actions one single computation 

 x   r x  ffff xx      q x   x xx      

 x  ffff 

applicable

resulting bdd represents state action pairs hx   ffi applicable
x execution x results states q 
    symbolic search space belief states

main strength symbolic approach allows perform symbolic breadthfirst search  provides way compactly representing eciently expanding
frontier  instance  plans constructed symbolic breadth first search
space states  repeatedly applying strong pre image goal states  cimatti et al  
    b   however  machinery presented previous section cannot directly applied
tackle conformant planning  basic difference conformant planning
searching space belief states    therefore frontier search basically
set sets states  introduce way symbolically represent bsp tables  basically 
seen construction demand  based algorithm steps  increasingly
large portions space belief states  key intuition bsp table

fhfs             s n  g    i          hfsk            skn g   k ig
k

represented relation plans  of length  states  associating
plan directly state belief state indexed plan  follows 

fhs      i          hs n     i          hsk    k i          hskn   k ig
k

   

use additional variables represent plans bsp tables  order represent
plans increasing length  step algorithm  vector new bdd variables 
called plan variables  introduced  vector plan variables introduced i th step
algorithm written  i   j  i j   jff j  used encode i th last action
plan   step one algorithm  introduce vector plan variables    
represent action corresponding   length possible conformant plan  bsp
   principle  machinery symbolic search could used conformant planning applied
determinization domain automaton  i e  automaton  s state space  however 
would require introduction exponential number state variables  impractical
even small domains 
   search performed backwards  plans need reversed found 

   

ficimatti   roveri
table bspt  level   built expandbsptable performing following bdd
computation starting bsp table level    i e  g  x   
  x     r x  ffff xx      g  x   x  xx       applicable x  ffff   ff       
computation collects state action pairs hx    the action represented
by  applicable  the state represented by  x   resulting  states
represented by  x   goal states  replace vector action variables
first vector plan variables      resulting bdd  bspt x         represents bsp
table containing plans length one form relation states plans
     general case  step    bsp table bspti     associating belief states
plans length    represented bdd state variables x plan
variables  i                   computation performed expandbsptable step
implemented following bdd transformation bspti  
  x     r x  ffff xx      bspti    x    i                   x  xx       applicable x  ffff   ff    i     
next state variables r bspti    resulting forward shifting  disappear
universal quantification  action variables renamed newly
introduced plan variables  i   next step algorithm construction
repeated 
extractsolution extracts assignments plan variables corresponding set contains initial states  terms bdd transformations  extractsolution
implemented follows 
 x  i  x    bspti x   i                
   
result bdd plan variables  i                bdd f alse 
solutions length i  otherwise  satisfying assignments resulting bdd
represents conformant solution problem 
guarantee termination algorithm  step bsp table returned
expandbsptable simplified prunebsptable removing belief states
deserve expansion  requires comparison belief states
contained bsp table belief states contained bsp tables built
previous levels  one crucial steps terms eciency  earlier implementation step logical bdd transformations  following directly set theoretical
definition prunebsptable  extremely inecient  cimatti   roveri         furthermore  noticed serial encoding could yield bsp tables containing large
number equivalent plans  indexing exactly belief state  often equivalent plans differ order independent actions  potential source
combinatorial explosion  occurs even simple version btuc  in figure   
two equivalent conformant plans associated bs     therefore  developed new
implementation could tackle two problems operating directly bsp
table  idea depicted figure    initially  cache contains bs    bs  bs   
simplification performs traversal bdd  accumulating subtrees representing
belief states  comparing ones built previous levels  inserting new
ones cache  in figure    bs    bs  bs     time path identified
   

ficonformant planning via symbolic model checking
bsp table

bs 

bs 

bs 

pruned bsp table

bs 

bs 

bs 

cached belief states
bs 

bs 

bs 

cached belief states

bs 

bs 

bs 

bs 

bs 

bs 

bs 

figure    example pruning bsp table
represents plan indexing already cached belief state  plan redundant
corresponding path pruned   cost simplification linear size bsp
simplified highly effective pruning 
   cmbp  bdd based conformant planner

cmbp  conformant model based planner  conformant planner implementing data
structures algorithms conformant planning described previous sections  cmbp
inherits features mbp  cimatti et al             b      a   planner based
symbolic model checking techniques  mbp built top nusmv  symbolic model
checker jointly developed itc irst cmu  cimatti et al          uses
cudd  somenzi        state of the art bdd package  mbp two stage system 
first stage  internal bdd based representation domain built 
second stage planning problems solved  currently  planning domains described
means high level action language ar  giunchiglia et al          ar allows
specify  conditional uncertain  effects actions means high level assertions 
instance  figure   shows ar description btuc problem   semantics
ar yields serial encoding  i e  exactly one action assumed executed

   pruning mechanism actually weaker earlier one  cimatti   roveri        
require belief state must expanded twice search  earlier
version prune belief states contained previously explored ones  may increase number
explored belief states  however  allows much ecient implementation  without impacting
properties algorithm 
       stand negation conjunction  respectively  description slightly edited sake
readability  particular  mbp currently accept parameterized ar descriptions  practice
use script language generate ground instances different complexity parameterized problem
description 

   

ficimatti   roveri

domain btuc
actions dunk    dunk    flush 
fluents in    in    defused  clogged   boolean 
inertial clogged  defused  in    in   
always in        in   
flush causes  clogged 
        
dunk  i  preconditions  clogged 
dunk  i  causes defused in  i  
dunk  i  possibly changes clogged 
 
initially  defused 
conformant defused    clogged 

figure    ar description btuc problem
time  automaton corresponding ar description obtained means
minimization procedure giunchiglia         procedure solves frame problem
ramification problem  eciently implemented mbp  cimatti et al         
separation domain construction planning phases  mbp
bound ar  standard deterministic domains specified pddl  ghallab et al  
      given mbp means  prototype  compiler  starting
investigate potential use c action language  giunchiglia   lifschitz        
allows represent domains parallel actions 
different planning algorithms applied specified planning problems 
operate solely automaton representation  completely independent
particular language used specify domain  mbp allows automatic construction
conditional plans total observability  implementing algorithms strong planning  cimatti et al       b   strong cyclic plannig  cimatti et al       a  daniele 
traverso    vardi         cmbp  implemented ideas described previous
sections  primitives construct prune bsp tables required lot tuning 
particular ordering bdd variables  found general ordering strategy
works reasonably well  action variables positioned top ordering  followed
plan variables  followed state variables  current state next state variables interleaved  specific ordering within action variables  plan variables  state variables
determined standard mechanism implemented nusmv  cmbp implements several
algorithms conformant planning  addition backward algorithm presented
   

ficonformant planning via symbolic model checking
section    cmbp implements algorithm based forward search  allows exploit
initial knowledge problem  sometimes resulting significant speed ups  cimatti
  roveri         backward forward search combined  tackle exponential growth search time depth search  algorithms 
different options enable disable different versions termination check 
   experimental evaluation

section present experimental evaluation approach  carried
comparing cmbp state of the art conformant planners  first describe
conformant planners considered analysis  present experimental
comparison carried out 
    conformant planners

cgp  smith   weld        extends ideas graphplan  blum   furst             
deal uncertainty  basically  planning graph built every possible sequence possible worlds  constraints among planning graphs propagated ensure conformance 
cgp system takes input domains described extension pddl  ghallab et al  
       possible specify uncertainty initial state  cgp inherits
graphplan ability deal parallel actions  cgp first ecient conformant planner  shown outperform several planners buridan  peot 
      udtpop  kushmerick  hanks    weld         detailed comparison reported smith weld        leaves doubt superiority cgp respect
systems  therefore  compared cmbp cgp consider
systems analyzed smith weld         cmbp expressive cgp two
respects  first  cgp handle uncertainty initial state  instance  cgp
cannot analyze btuc domain presented section    smith weld        describe
approach extended actions uncertain effects  second  cgp cannot
conclude planning problem conformant solutions 
qbfplan  our name for  planning system rintanen      a   qbfplan generalizes idea sat based planning  kautz  mcallester    selman        kautz   selman 
            nondeterministic domains  encoding problems qbf  qbfplan
approach limited conformant planning  used conditional planning
uncertainty  partial observability  different encodings  corresponding
different structures resulting plan  synthesized  paper 
considering encodings enforce resulting plan sequence  given bound
length plan  first qbf encoding problem generated  qbf
solver  rintanen      b  called  solution found  new encoding longer plan
must generated solved  qbfplan able handle actions uncertain effects 
done introducing auxiliary  choice  variables  assignments different possible outcomes actions correspond  variables universally quantified
ensure conformance solution  differently e g  blackbox  kautz   selman 
       qbfplan heuristic guess  right  length plan  given
limit length plan  generates encodings specified length 
repeatedly calls qbf solver encodings increasing length plan found 

   

ficimatti   roveri
cgp  qbfplan cannot conclude planning problem conformant solutions 
similarly cmbp  qbfplan relies symbolic representation problem  although
qbf transformations performed theorem prover rather bdds 
gpt  bonet   geffner        general planning framework  conformant
planning problem seen deterministic search problem space belief states  gpt
uses explicit representation search space  belief state represented
separate data structure  search based algorithm  nilsson        
driven domain dependent heuristics automatically generated problem
description  gpt accepts problem descriptions syntax based pddl  extended deal
probabilities uncertainty  possible represent domains uncertain action
effects  although representation actions resulting large number different states
rather awkward   planning algorithm  gpt able conclude given
planning problem conformant solution exhaustively exploring space belief
states 
    experiments results

evaluation performed running systems number parameterized problem domains  considered problems cgp gpt distributions  plus
problems defined test specific features planners  considered
domains uncertainty limited initial state  domains uncertain action
effects  besides problems admitting solution  considered problems admitting
solution  case measured effectiveness plannner returning
failure 
given different expressivity  possible run systems
examples  cmbp run classes examples  gpt run one 
cgp run problems admit solution  uncertainty limited
initial condition  qbfplan run examples encoding
already available qbfplan distribution  subset problems
expressible cgp  main limiting factor low level input format
qbfplan  problem descriptions must specified ml code generates qbf
encodings  writing new encodings turned dicult task  especially due
lack documentation 
ran cgp  qbfplan cmbp intel    mhz pentium ii     mb ram 
running linux  comparison cmbp gpt run sun ultra sparc
   mhz     mb ram running solaris  gpt available binary   however 
performance two machines comparable   run times cmbp almost
identical  cpu time limited      sec  two hours  test  avoid swapping 
memory limit fixed physical memory machine  following 
write           test complete within time memory
limits  respectively  performance systems reported tables listing
search time  excludes time needed qbfplan generate encodings 
time spent cmbp construct automaton representation bdd  time
needed gpt generate source code internal representation  compile
it  overall  significant time ignored automaton construction cmbp 
   

ficonformant planning via symbolic model checking
currently  automaton construction fully optimized  even complex
examples  however  construction never required couple minutes  
      bomb toilet

bomb toilet  first domain tackled classical bomb toilet 
notion clogging  call problem bt p   parameter p

number packages  uncertainty initial condition 
known package contains bomb  goal defuse bomb  results
bt problem shown table    columns relative cmbp length
plan  jpj   number cached belief states number hits cache   bs
 nbs respectively   time  expressed seconds  needed searching automaton
pentium linux  time l   sparc solaris  time s    following 
clear context  execution platform omitted  columns relative cgp
number levels planning graphs  jlj  search time  column relative
gpt search time 
bt   
bt   
bt   
bt   
bt   
bt   
bt   
bt   
bt    

jpj

 
 
 
 
 
 
 
 
  

cmbp

 bs  bsh
   
      
       
        
        
         
          
          
           

time l 
     
     
     
     
     
     
     
     
     

time s 
     
     
     
     
     
     
     
     
     

jlj
 
 
 
 
 
 
 
 
 

cgp

time
     
     
     
     
     
     
     
     
     

gpt

time
     
     
     
     
     
     
     
     
     

table    results bt problems 
bt problem intrinsically parallel  i e  depth planning graph always
one  packages dunked time  cgp inherits graphplan ability deal parallel actions eciently  therefore almost insensitive
problem size  problem cgp outperforms cmbp gpt  notice
number levels explored cgp always    length plan produced
cmbp cgp grows linearly  cmbp performs slightly better gpt 
bomb toilet clogging  call btc p  extension bt p 
dunking package  always  clogs toilet  ushing remove clogging  clogging precondition dunking package  again  p number packages  toilet
initially clogged  modification  problem longer allows parallel
solution  results problem listed table    impact depth
plan length becomes significant systems  cmbp gpt outperform cgp 
case cmbp performs better gpt  especially large instances  see btc      
   precisely  maximum time building automaton required bmtc       examples
    secs    ring     example     secs    bmtc      examples     secs    bmtc      
examples     secs    examples  time required automaton construction
less    seconds 

   

ficimatti   roveri
qbfplan

btc   
btc   
btc   
btc   
btc   
btc   
btc   
btc   
btc    

jpj

 
 
 
 
  
  
  
  
  

cmbp

cgp

 bs  bsh time l  time s  jlj time
   
     
       
     
       
     
       
     
       
     
       
     
        
     
       
     
         
     
        
     
         
     
        
     
          
     
               
           
     
               
           
     
                

btc                       

      

      

gpt

time
     
     
     
     
     
     
     
     
     
       

btc   
jpj time
 
    
 
    
 
    
 
    
 
    
 
    
 
    
 
     
 
     
  
     
           

btc    
time
 
    
 
    
 
    
 
    
 
    
 
    
 
     
 
     
 
      
  
      
          
          
  
 

jpj

   
   
  
 
            

table    results btc problems 
comparison qbfplan limited      package instances  the ones available distribution package   performance qbfplan reported left
table table    line reports time needed decide whether plan
length i  performance qbfplan rather good tackling encoding admitting solution  in table   entries labeled       instance  btc    
qbfplan finds solution solving encodings depth    reasonably fast  however 
solution cannot found  i e  qbf formula admits model  performance
qbfplan degrades significantly  for depth    encoding  let solver run   
cpu hours complete search   difference performance 
diculty writing new domains  rest comparison consider
qbfplan 
bomb multiple toilets  next domain  called bmtc p t   generalization
btc problem case multiple toilets  p number packages 
number toilets   problem becomes parallelizable number
toilets increases  furthermore  considered three versions problem increasing
uncertainty initial states  first class tests   low uncertainty  columns  
uncertainty position bomb unknown  toilets known
clogged   mid uncertainty   high uncertainty  columns show results
presence uncertainty initial state  second  third  respectively  class
tests  status every odd  every  resp   toilet either clogged clogged 
increases number possible initial states 
results reported table    for comparison cgp  table  
 for comparison gpt   column represents number initial states
corresponding problem  cgp able fully exploit parallelism problem 
however  cgp never able explore   levels planning graph  depth
decreasing number initial states  results show cmbp gpt
much less sensitive number initial states cgp  increasing initial
   

fi p t 
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      

bmtc


 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  

 
 
 
 
  
  
  
  
  
 
 
 
 
 
  
  
  
  
 
 
 
 
 
  
  
  
  
 
 
 
 
 
 
  
  
  
 
 
 
 
 
 
  
  
  

jpj

low uncertainty
cmbp
 bs  bsh time
             
             
              
               
                
                
                 
                  
                  
             
              
               
                
                
                  
                  
                  
                   
             
              
                
                
                 
                  
                  
                   
                     
              
                
                
                 
                  
                  
                   
                     
                     
              
                
                
                  
                  
                   
                     
                     
               e           
time
     
     
     
     
     
       
       
 
     
     
     
     
     
        
 

cgp

   

mid uncertainty
cmbp

 bs  bsh time
 
             
 
              
 
              
  
               
  
                
  
                
  
                 
  
                  
  
                  
 
             
  
              
  
               
  
                
  
                
  
                 
  
                 
  
                 
  
                  
 
             
  
               
  
                
  
                
  
                  
  
                  
  
                  
  
                  
  
                    
  
              
  
                
  
                
  
                 
  
                  
  
                  
  
                    
  
                     
  
                     
  
              
  
                
  
                 
  
                  
  
                  
  
                    
  
                     
                  e          
                  e           
     
     
     
 

       
       
        
        
        
 
 

       
       
       
        
 
 

 
 
 
 

     
     
     
 

 
 
 
 

 
 
 
 
 

time
     
     
     
      
 

cgp

jlj

table    results bmtc problems 

 
     
 
     
 
     
 
     
 
     
 
     
 
     
 
 
 
     
 
     
 
     
 
     
 
     
        
        
         
         
 
     
 
     
 
     
 
     
 
     
         
          
          
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

jlj

high uncertainty
cmbp

 bs  bsh time
 
             
  
              
  
              
  
               
  
                
  
                
  
                 
  
                  
  
                  
  
              
  
              
  
               
  
                
  
                
  
                  
  
                  
  
                  
  
                   
  
              
  
               
  
                
  
                
  
                  
   
                  
   
                  
   
                   
   
                     
  
              
  
                
   
                
   
                 
   
                  
   
                  
   
                    
   
                     
   
                     
   
                
   
                
   
                 
   
                  
   
                  
   
                    
   
                     
                   e          
                   e           
     
     
      
 

     
     
 

time
     
      
       
 

cgp

         
          
          
 
 

        
         
         
          
 
 

 
 
 
 

 
 
 

 
 
 
 

jlj

conformant planning via symbolic model checking

ficimatti   roveri
bmtc

 p t 
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     
      

low unc 

cmbp

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
      
      
       

gpt

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
      
     
     
     
     
     
      
      
       
       

high unc 

cmbp

time
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
       
     
     
     
     
     
      
      
      
       

gpt

time
     
     
     
     
     
     
     
     
      
     
     
     
     
     
      
      
       
       
     
     
      
      
       
       
   

table    results bmtc problems 
uncertainty  cgp almost unable solve trivial problems  gpt performs better
cgp  suffers explicit representation search space 
bomb toilet uncertain clogging  btuc p  domain domain
described section    clogging uncertain outcome dunking package 
kind problem cannot expressed cgp  results cmbp gpt reported
table    although cmbp performs better gpt  by factor two three  
significant difference behavior  interesting compare results cmbp
btc btuc problems  gpt slight difference noticeable  resulting
increased branching factor search space due uncertainties effects
action executions  performance cmbp  number uncertainties direct
factor   example  btc     btuc      performance almost same 
      ring rooms

simple ring room  considered another domain  robot move
ring rooms  room window  either open  closed locked 
robot move  either clockwise counterclockwise   close window room
is  lock closed  goal windows locked 
   

ficonformant planning via symbolic model checking
cmbp

jpj

btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc   
btuc    
btuc    

 bs  bsh
   
       
       
        
         
         
          
           
           
               

 
 
 
 
  
  
  
  
  
  

time
     
     
     
     
     
     
     
     
     
      

gpt

time
     
     
     
     
     
     
     
     
     
       

table    results btuc problems 
n  

n

 

 

problem ring r   r number rooms  uncertainty
initial condition  position robot status windows
uncertain  problems parallel solution  large number initial
states  r  r    corresponding full uncertainty position robot
status window  results  reported left table    cmbp outperforms
ring   
ring   
ring   
ring   
ring   
ring   
ring   
ring   
ring    

jpj

 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
        
         
          
           
            
             
              

time
     
     
     
     
     
     
     
      
       

jlj
 
 

cgp

time
     
 

gpt

time
     
     
     
     
     
      
       
   


 
 
 
 
  

cgp ring   

jlj
 
 
 
 
 

time
     
     
     
     
 

jlj
 
 
 
 
 

time
     
     
     
       
 

table    results ring problems 
cgp gpt  although gpt performs much better cgp  cgp gpt
suffer increasing complexity problem  right table    plot  for
ring    problem  dependency cgp number initial states combined
number levels explored  different goals provided require
exploration different levels   clear number initial states depth
search critical factors cgp 
   times reported cgp refer scaled down version problem  locking taken
account  thus maximum number initial states r  r  

   

ficimatti   roveri
ring rooms uncertain action effects  considered variation

ring domain  called uring  first introduced cimatti roveri        
expressible cgp  window locked robot performing action
determine status  e g  closing it   window open close nondeterministically  instance  robot moving room   room    windows
room     could open closed wind  domain clearly designed stress
ability planner deal actions large number resulting states 
worst case  e g  move action performed window locked    r possible
resulting states  although seemingly artificial  captures fact environments
practice highly nondeterministic  tried compare cmbp gpt uring
problem  principle gpt able deal uncertainty action effects  however 
failed codify uring gpt language  requires conditional description uncertain effects  therefore  experimented variation ring
domain featuring higher degree nondeterminism  called ndring following 
ndring domain contains increasing number additional propositions  called
following noninertial propositions  initially unknown nondeterministically
altered action  number noninertial propositions  action  i
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring   
ndring    

jpj

 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
        
         
          
           
            
             
              

time    
     
     
     
     
     
     
     
      
       

time    
     
     
     
     
      
       
   

gpt

time    
     
     
     
      
      
   

time    
     
     
      
      
   

time    
     
      
      
   

table    results ndring problems 
possible outcomes  results listed table    columns labeled time i  
growing branching factor search major impact performance
gpt  cmbp insensitive kind uncertainty   the performance cmbp
lower number noninertial propositions reported basically
same  
uring problem run cmbp  results listed table   
noticed performances cmbp improve significantly respect ring
problem  explained considering that  despite larger number transitions 
number explored belief states significantly smaller  see bs cache statistics
tables      
      square cube

following domains square n  cube n  gpt distribution  bonet
  geffner         problems consist robot navigating square cube side
n  domains actions moving robot possible directions 
moving robot boundary leaves robot position  original
   

ficonformant planning via symbolic model checking

uring   
uring   
uring   
uring   
uring   
uring   
uring   
uring   
uring    

jpj
 
 
  
  
  
  
  
  
  

cmbp

 bs  bsh
      
       
       
        
        
         
          
          
           

time
     
     
     
     
     
     
     
     
      

table    results uring problems 
problems  called corner following  require robot reach corner  starting
completely unspecified position  introduced two variations  first  called
face  initial position position given side  face  square  cube  
goal reach central position opposite side  face   second  called
center  initial position completely unspecified  goal center
square  cube   corner problem  simple heuristic perform steps towards
corner  thus pruning half actions  variations designed allow
simple heuristic   instance  center problem  action eliminated 
square i 
square   
square   
square   
square   
square    
square    
square    
square    
square    
square    
cube i 
cube   
cube   
cube   
cube   
cube   
cube   
cube   
cube   
cube    
cube    

jpj

 
 
 
  
  
  
  
  
  
  

jpj

 
 
  
  
  
  
  
  
  
  

corner
cmbp
 bs  bsh time
           
             
             
              
              
               
               
               
               
                

corner
cmbp
 bs  bsh time
            
             
              
               
               
                
                
                
                
                  

gpt

time
     
     
     
     
     
     
     
     
     
     

gpt

time
     
     
     
     
     
     
     
     
     
     

jpj

 
 
  
  
  
  
  
  
  
  

jpj

 
 
  
  
  
  
  
  
  
  

face
cmbp
 bs  bsh time
           
             
              
               
               
                
                
                
                
                 

gpt

time
     
     
     
     
     
     
     
     
     
     

jpj

 
 
  
  
  
  
  
  
  
  

center
cmbp
 bs  bsh time
           
              
               
                
                
                 
                 
                 
                 
                 

gpt

time
     
     
     
     
     
     
      
      
      
      

face
center
cmbp
gpt
cmbp
gpt
 bs  bsh time time jpj  bs  bsh time time
                    
                  
                     
                   
                         
                      
                         
                       
                                                    
                                                     
                                                      
                                                        
                                                
   
                     
                            

table    results square cube problems 
results problems reported table    tests run
cmbp gpt  experiments highlight eciency gpt strongly depends
quality heuristic function  if  first set experiments  heuristics
   

ficimatti   roveri
effective  gpt almost good cmbp  otherwise  gpt degrades significantly 
general  finding heuristics effective belief space appears nontrivial
problem  cmbp appears stable    performs blind  breadth first search 
relies cleverness symbolic representation achieve eciency 
      omelette

finally  considered omelette i  problem  levesque         goal
good eggs bad ones one two bowls capacity i  unlimited number
eggs  unpredictably good bad  eggs grabbed broken
bowl  content bowl discarded  poured bowl  breaking
rotten egg bowl effect spoiling bowl  bowl always cleaned
discarding content  problem originally presented partial observability
problem  sensing action allowing test bowl spoiled not  considered
variation problem without sensing action  case conformant solution
exists  used omelette problems test ability cmbp gpt discover
problem admits conformant solution  results reported table    
table shows cmbp effective checking absence conformant solution 
outperforms gpt several orders magnitude 
omelette   
omelette   
omelette   
omelette   
omelette   
omelette   
omelette   
omelette    
omelette    
omelette    
omelette    

  steps
 
  
  
  
  
  
  
  
  
  
  

cmbp
 bs  bsh
       
       
       
       
       
       
       
       
        
        
         

time
     
     
     
     
     
     
     
     
     
     
     

gpt
time
     
     
     
     
     
      
      
      
       
   

table     results omelette problems 
    summarizing remarks

overall  cmbp appears implement effective approach conformant planning 
terms expressivity performance  cgp able deal uncertainties
initial states  cannot conclude problem admit conformant
solution  main problem cgp seems enumerative approach uncertainties 
increased number initial states severely affects performance  see table  
table    
qbfplan principle able deal uncertain action effects  cannot conclude
problem admit conformant solution  small number ex   consider problems increasingly dicult  see instance plan length  

   

ficonformant planning via symbolic model checking
periments could perform  approach implemented qbfplan limited
satplan style search  intermediate results obtained solving encoding
depth k reused solving encodings increasing depth  furthermore 
solver appears specialized finding model  rather proving unsatisfiability 
however  latter ability needed encodings final one 
gpt expressive system  allows eciently dealing wide class
planning problems  far conformant planning concerned  expressive
cmbp  allows dealing uncertain action effects  conclude problem
conformant solution  however  cmbp appears outperform gpt
several respects  first  behaviour gpt appears directly related number
possible outcomes action  furthermore  eciency gpt depends
effectiveness heuristic functions  sometimes dicult devise 
cannot help problem admit solution 
main strength cmbp independence number uncertainties 
achieved use symbolic techniques  fully symbolic  cmbp
exhibit enumerative behaviour competitors  compared original approach
described cimatti roveri         substantial improvement performance
obtained new implementation pruning step  disclaimer
order  well known bdd based computations subject blow up memory
requirements computing certain classes boolean functions  e g  multipliers  bryant 
       would trivial make example performance cmbp degrades
exponentially  however  none examples considered  included
examples distribution cgp gpt  phenomenon occurred 
   related work

term conformant planning first introduced goldman         presenting
formalism constructing conformant plans based extension dynamic logic  recently  ferraris giunchiglia        presented another conformant planner based sat
techniques  system available direct comparison cmbp  effectiveness approach dicult evaluate  limited testing described  ferraris  
giunchiglia         performance claimed comparable cgp  however 
results reported enconding corresponding solution  behaviour
qbfplan reported table   suggests kind analysis might limited 
several works share idea planning based automata theory  closely
related works lines planning via model checking  cimatti et al          upon
work based  approach allows  instance  automatically construct
universal plans guaranteed achieve goal finite number steps  cimatti
et al       b   implement trial and error strategies  cimatti et al       a  daniele
et al          results obtained hypothesis total observability 
run time observation available  main difference substantial extension required lift symbolic techniques search space belief states  de
giacomo vardi        analyze several forms planning automata theoretic
framework  goldman  musliner pelican        present method model checking
timed automata interleaved plan formation activity  make sure
   

ficimatti   roveri
timing constraints met  finally  hoey colleagues        use algebraic decision
diagrams tackle problem stochastic planning 
   conclusions future work

paper presented new approach conformant planning  based use
symbolic model checking techniques  algorithm general  applies
complex planning domains  uncertainty initial condition action effects 
described finite state automata  algorithm based breadthfirst  backward search  returns conformant plans minimal length  solution
planning problem exists  otherwise  terminates failure  algorithm designed
take full advantage symbolic representation based bdds  implementation
approach cmbp system highly optimized  particular crucial
step termination checking  performed experimental comparison approach
state art conformant planners cgp  qbfplan gpt  cmbp strictly
expressive qbfplan cgp  problems comparison
possible  cmbp outperformed competitors terms run times  sometimes
orders magnitude  thanks use symbolic data structures  cmbp able deal
eciently problems large numbers initial states action outcomes 
hand  qualitative behavior cgp gpt seems depend heavily
enumerative nature algorithms  differently gpt  cmbp independent
effectiveness heuristic used drive search 
research presented paper extended following directions  first 
investigating alternative approach conformant planning  breadthfirst style search given up  techniques appear extremely promising  
preliminary experiments led speed ups two orders magnitude
results presented paper problems admit solution  second  tackle
problem conditional planning partial observability  hypothesis
limited amount information acquired run time  conformant planning 
problem seen search belief space  however  appears significantly
complicated need dealing run time observation conditional plans  finally  considering extension domain construction planner
expressive input language  c   invariant detection techniques 
acknowledgements

fausto giunchiglia provided continuous encouragement feedback work 
thank piergiorgio bertoli  blai bonet  marco daniele  hector geffner  enrico giunchiglia 
jussi rintanen  david smith  paolo traverso  dan weld valuable discussions conformant planning various comments paper  david smith provided code
cgp  large number examples  time out mechanism used experimental
evaluation  jussi rintanen made qbfplan available linux 
   

ficonformant planning via symbolic model checking
references

blum  a  l     furst  m  l          fast planning planning graph analysis 
proc  ijcai 
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial intelligence                  
bonet  b     geffner  h          planning incomplete information heuristic se
arch belief space  chien  s   kambhampati  s     knoblock  c   eds     th
international conference artificial intelligence planning scheduling  pp     
    aaai press 
brace  k   rudell  r     bryant  r          ecient implementation bdd package    th acm ieee design automation conference  pp        orlando  florida 
acm ieee  ieee computer society press 
bryant  r  e          graph based algorithms boolean function manipulation  ieee
transactions computers  c                 
bryant  r  e          complexity vlsi implementations graph representations
boolean functions application integer multiplication  ieee transactions
computers                  
bryant  r  e          symbolic boolean manipulation ordered binary decision diagrams  acm computing surveys                  
burch  j  r   clarke  e  m   mcmillan  k  l   dill  d  l     hwang  l  j          symbolic
model checking       states beyond  information computation         
        
cassandra  a   kaelbling  l     littman  m          acting optimally partially observable
stochastic domains  proc  aaai     aaai press 
cimatti  a   clarke  e   giunchiglia  f     roveri  m          nusmv   new symbolic
model checker  international journal software tools technology transfer
 sttt         
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  decision procedure ar  steel  s     alami  r   eds    proceeding
fourth european conference planning  no       lecture notes artificial
intelligence  pp          toulouse  france  springer verlag  itc irst technical
report          itc irst trento  italy 
cimatti  a     roveri  m          conformant planning via model checking  biundo 
s   ed    proceeding fifth european conference planning  lecture notes
artificial intelligence durham  united kingdom  springer verlag  itc irst
technical report          itc irst trento  italy 
   

ficimatti   roveri
cimatti  a     roveri  m          forward conformant planning via symbolic model
checking  proceeding aips k workshop model theoretic approaches
planning breckenridge  colorado 
cimatti  a   roveri  m     traverso  p       a   automatic obdd based generation
universal plans non deterministic domains  proceeding fifteenth national
conference artificial intelligence  aaai     madison  wisconsin  aaai press 
irst technical report          trento  italy 
cimatti  a   roveri  m     traverso  p       b   strong planning non deterministic
domains via model checking  proceeding fourth international conference
artificial intelligence planning systems  aips     carnegie mellon university 
pittsburgh  usa  aaai press 
clarke  e  m     wing  j  m          formal methods  state art future directions 
acm computing surveys                  
clarke  e   emerson  e     sistla  a          automatic verification finite state concurrent systems using temporal logic specifications  acm transactions programming
languages systems                 
coudert  o   madre  j  c     touati  h          tiger version     user guide  digital
paris research lab 
daniele  m   traverso  p     vardi  m  y          strong cyclic planning revisited 
biundo  s   ed    proceeding fifth european conference planning  lecture
notes artificial intelligence durham  united kingdom  springer verlag 
de giacomo  g     vardi  m          automata theoretic approach planning temporally extended goals  biundo  s   ed    proceeding fifth european conference planning  lecture notes artificial intelligence durham  united kingdom 
springer verlag 
ferraris  p     giunchiglia  e          planning satisfiability nondeterministic domains  proceedings seventeenth national conference artificial intelligence
 aaai     austin  texas  aaai press 
ghallab  m   howe  a   knoblock  c   mcdermott  d   ram  a   weld  d     wilkins 
d          pddl   planning domain definition language  tech  rep  cvc
tr        dcs tr       yale center computational vision control 
giunchiglia  e          determining ramifications situation calculus  fifth
international conference principles knowledge representation reasoning
 kr     cambridge  massachusetts  morgan kaufmann publishers 

giunchiglia  e   kartha  g  n     lifschitz  v          representing action  indeterminacy
ramifications  artificial intelligence                  
   

ficonformant planning via symbolic model checking
giunchiglia  e     lifschitz  v          action language based causal explanation 
preliminary report  proceedings   th national conference artificial intelligence  aaai       th conference innovative applications artificial
intelligence  iaai      pp          menlo park  aaai press 

goldman  r  p   musliner  d  j     pelican  m  j          using model checking
plan hard real time controllers  proceeding aips k workshop modeltheoretic approaches planning breckenridge  colorado 
goldman  r     boddy  m          expressive planning explicit knowledge 
proceedings  rd international conference artificial intelligence planning
systems  aips      pp           aaai press 

hoey  j   st aubin  r   hu  a     boutilier  c          spudd  stochastic planning using decision diagrams  proceedings fifteenth conference uncertainty
articial intelligence         pp           aaai press 
kautz  h     selman  b          blackbox  new approach application
theorem proving problem solving  working notes workshop planning
combinatorial search pittsburgh  pa  usa 
kautz  h  a   mcallester  d     selman  b          encoding plans propositional logic 
proc  kr    
kautz  h  a     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proc  aaai    
kushmerick  n   hanks  s     weld  d  s          algorithm probabilistic planning 
artificial intelligence                    
levesque  h  j          planning presence sensing   proceedings
thirteenth national conference artificial intelligence eighth innovative
applications artificial intelligence conference  pp            menlo park  aaai

press   mit press 
mcdermott  d          critique pure reason  computational intelligence             
    
mcmillan  k          symbolic model checking  kluwer academic publ 
michie  d          machine intelligence edinburgh  machine intelligence  pp 
         edinburgh university press 
nilsson  n          principles artificial intelligence  morgan kaufmann publishers  inc  
los altos  ca 
peot  m          decision theoretic planning  ph d  thesis  dept  engineering economic
systems   stanford university 
rintanen  j       a   constructing conditional plans theorem prover  journal
artificial intellegence research              
   

ficimatti   roveri
rintanen  j       b   improvements evaluation quantified boolean formulae 
dean  t   ed      th iinternational joint conference artificial intelligence  pp 
           morgan kaufmann publishers 
smith  d  e     weld  d  s          conformant graphplan  proceedings   th
national conference artificial intelligence  aaai       th conference
innovative applications artificial intelligence  iaai      pp          menlo

park  aaai press 
somenzi  f          cudd  cu decision diagram package   release        department
electrical computer engineering   university colorado boulder 
weld  d  s   anderson  c  r     smith  d  e          extending graphplan handle
uncertainty sensing actions  proceedings   th national conference
artificial intelligence  aaai       th conference innovative applications artificial intelligence  iaai      pp          menlo park  aaai press 

yang  b   bryant  r  e   o hallaron  d  r   biere  a   coudert  o   janssen  g   ranjan 
r  k     somenzi  f          performance study bdd based model checking 
proceedings formal methods computer aided design  pp          

   


