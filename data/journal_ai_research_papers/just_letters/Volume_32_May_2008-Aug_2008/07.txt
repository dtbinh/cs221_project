journal of artificial intelligence research                  

submitted        published      

the ultrametric constraint and its
application to phylogenetics
neil c a  moore

ncam cs st andrews ac uk

computer science  university of st  andrews  scotland

patrick prosser

pat dcs gla ac uk

computing science  glasgow university  scotland

abstract
a phylogenetic tree shows the evolutionary relationships among species  internal nodes
of the tree represent speciation events and leaf nodes correspond to species  a goal of
phylogenetics is to combine such trees into larger trees  called supertrees  whilst respecting
the relationships in the original trees  a rooted tree exhibits an ultrametric property  that
is  for any three leaves of the tree it must be that one pair has a deeper most recent common
ancestor than the other pairs  or that all three have the same most recent common ancestor 
this inspires a constraint programming encoding for rooted trees  we present an efficient
constraint that enforces the ultrametric property over a symmetric array of constrained
integer variables  with the inevitable property that the lower bounds of any three variables
are mutually supportive  we show that this allows an efficient constraint based solution
to the supertree construction problem  we demonstrate that the versatility of constraint
programming can be exploited to allow solutions to variants of the supertree construction
problem 

   introduction
one of the grand challenges of phylogenetics is to build the tree of life  tol   a representation of the evolutionary history of every living thing  to date  biologists have catalogued
about     million species  yet estimates of the total number of species range from   to    
million  of the     million species identified only about        have been placed in the tol
so far  pennisi         there are applications for the tol  to help understand how pathogens
become more virulent over time  how new diseases emerge  and to recognise species at risk of
extinction  pennisi        mace  gittleman    purvis         one approach to building the
tol is divide and conquer  combining smaller trees such as those available from treebase
 treebase        into so called supertrees  bininda emonds        to approach a more
complete tol 
to date  supertree construction has been dominated by imperative techniques  semple
  steel        semple  daniel  hordijk  page    steel        daniel        bordewich 
evans    semple        ng   wormald        bryant   steel        page        but
recently new declarative approaches have emerged using constraint programming  gent 
prosser  smith    wei        prosser        beldiceanu  flener    lorca        and answer
set programming  wu  you    lin         one of the properties of rooted trees that suits
these approaches is that trees are by their nature ultrametric  in rooted trees the root node
has depth    and the depth of other nodes is   plus the depth of their parent  taking any
c
    
ai access foundation  all rights reserved 

fimoore   prosser

three leaves a  b and c in pairs it must be that one pair has a deeper most recent common
ancestor  mrca  than the other pairs  or that all three pairs have the same mrca  and this
is what we mean by ultrametric  that for any three there is a tie for the minimum  in fact 
if we know the depth of the mrca of all pairs of leaves the structure of the tree is uniquely
determined  this inspires a constraint programming encoding for rooted trees  using the
ultrametric constraint that we will define later  we explore solutions to the phylogenetic
supertree problem and its variants  in so doing  we show the practicality of an ultrametric
encoding for rooted tree problems  as well as arguing that this is a valuable addition to the
set of techniques for supertree problems 
the paper is organised as follows  first  we introduce constraint programming and the
supertree construction problem  we then propose a specialised ultrametric constraint  in
terms of its propagation procedures  that maintains bounds z  consistency  bessiere       
on three variables  we show that this specialised constraint is required because models that
use toolkit primitives cannot guarantee the ultrametric property on the supertree problem via propagation alone  furthermore  the space complexity of such models becomes
prohibitive  the ultrametric constraint is then extended to maintain the property over a
symmetric matrix of variables  we then go on to show that this constraint can be efficiently
applied to the problem of supertree construction  in particular that applying propagation to
this model gives a polynomial time procedure for supertree construction  we then demonstrate this on real data and give justification that there has been an improvement in time
and space over previous constraint encodings  one of the benefits of the constraint programming approach is that variants of the supertree problem can be addressed within this
one model  we justify this assertion by proposing a constraint solution finding essential
relations in the supertree  daniel         addressing ancestral divergence dates  semple
et al         bryant  semple    steel         modelling nested taxa  page        daniel  
semple        and coping with conflicting data 

   background
in this section we give necessary definitions and descriptions of the constraint satisfaction
problem  tsang         constraint programming  and the supertree problem 
    constraint programming and the csp
constraint programming  cp   rossi  van beek    walsh        is a declarative style of
programming where problems are modelled as a csp  i e   as a set of variables that have
to be assigned values from those variables domains to satisfy a set of constraints  values
might typically be integers drawn from finite domains  real numbers from ranges  or more
complex entities like sets or graphs  we will only be considering integers 
definition    a constraint satisfaction problem  csp  is a triple  v  d  c  where v is a set
of n variables  v            vn    d    dom v             dom vn    is a collection of domains  each a
totally ordered set of integer values  and c    c            ce   is a set of e constraints  each with a
scope of variables scope c     vc            vck   and a relation rel c   dom vc        dom vck   
an assignment of value x  dom v  to variable vi  v is denoted by  vi   x   a constraint
c  c is satisfied by an assignment   vc    xc              vck   xck    when scope c     vc            vck  
   

fithe ultrametric constraint and phylogenetics

and  xc            xck    rel c   a set of assignments   v    x              vn   xn    involving every
variable in the problem is a solution when it satisfies all the constraints in c 
a constraint solver finds a solution to a csp via a process of constraint propagation and
search  constraint propagation is an inferencing process that takes place when a variable
is initialised or loses values  propagation maintains a level of consistency  such as arcconsistency  mackworth         across the variables  removing values from domains that
cannot occur in any solution  i e   removing unsupported values   we use the definitions of
 generalized  arc consistency   g ac  due to bessiere        
definition    given a csp  v  d  c   a constraint c  c with scope c     vc            vck   
and a variable v  scope c   a value x  dom v  is consistent with respect to c  alternatively 
supported by c  iff there exists a satisfying assignment      vc    a              vck   ak    for c
such that  v  x    and i  ai  dom vci    the domain dom v  is  generalized  arcconsistent on c iff all values in dom v  are consistent with respect to c  and the csp is
 generalized  arc consistent when all variable domains are  generalized  arc consistent on
all constraints in c 
arc consistency can be established on a csp using an algorithm such as ac   mackworth         for sake of exposition we assume all constraints in c are binary and
that for each constraint c we have a counterpart c such that scope c     va   vb   and
scope c      vb   va   with rel c     rel   c   for example  if we have the constraint
cxy   x   y then we also have the constraint cyx   y   x  at the heart of ac  is the revise
function  which takes a binary constraint c as its argument and delivers a boolean result 
the function removes from dom va   all values that have no support in dom vb   w r t  the
constraint c  and returns true if any removals take place  initially all constraints are added
to a set s  constraints are iteratively removed from s and revised  if revise ckm   returns
true then s becomes s   cik  cik  c  i    k  i    m   this step can be considered as
the propagation of a domain reduction on variable vk to variables constrained by vk   the
iteration terminates when s is empty or a variables domain becomes empty  when s is
empty the arc consistency algorithm has reached a fixed point  i e   a further application
of the arc consistency process will have no effect on the domains of the variables  and the
problem has been made arc consistent  when a domain empties  we have shown the there
are no solutions globally and hence we can stop  the ac  algorithm has o e  d    time
complexity  where e is the number of constraints and d the size of the largest domain  however other algorithms can achieve a time bound of o e  d     yuanlin   yap        bessiere
  regin        
we demonstrate arc consistency with the example of figure   by smith         we
have three constrained integer variables x  y and z  each with an integer domain        
and binary constraints cxy   x   y     cyz   y   z is even  and czx   z    x      since the
constraints are binary we can represent the problem as a constraint graph  where nodes are
vertices and edges are constraints  initially the constraint cxy is revised with respect to x
and the values        are removed from dom x   then cxy is revised w r t  y and dom y 
becomes         cyz is then revised w r t  y with no effect and then revised w r t  z  again with
no effect  revising czx w r t  z reduces dom z  such that it becomes         consequently
the constraint cyz is added into the set of constraints pending revision  constraint czx is
   

fimoore   prosser

y       

se

y

zi

 

y 
n

x 

ve

x
      

z       

z    x    

figure    a binary constraint satisfaction problem 
import choco problem 
import choco contradictionexception 
import choco integer   
public class bmstut  
public static void main string   args  throws contradictionexception  
problem pb
  new problem   
intdomainvar x
  pb makeenumintvar  x           x in       
intdomainvar y
  pb makeenumintvar  y           y in       
intdomainvar z
  pb makeenumintvar  z           y in       
intdomainvar even   pb makeenumintvar  even  new int                 
pb post pb gt pb minus y    x   
   x   y    
pb post pb gt pb plus pb mult   x     z       z    x    
pb post pb eq even pb plus y z    
   y   z is even
pb solve   

   solve using mac

 
 

figure    a jchoco constraint program for the csp of figure   
revised w r t  x and then cyz w r t  to y  both with no effect  the revision set at that point
is empty and arc consistency has been established with variable domains dom x           
dom y            and dom z           
solving a csp may involve search  i e   we might need to try different values for variables in order to determine if a solution exists  typically a constraint solver will begin by
establishing arc consistency  and then repeatedly select a variable and assign it a value from
its domain  instantiate it   this effectively reduces that variables domain to a singleton 
and arc consistency is then re established  if this succeeds another instantiation is made 
but if it fails we backtrack by undoing the most recent instantiation  this is called mac 
for maintaining arc consistency  sabin   freuder        
figure   shows a constraint program for the problem in figure   using the choco constraint programming toolkit for the java language  choco         and it finds solution
x      y      and z     first 
constraint toolkits tend to be based around the ac  algorithm  van hentenryck  deville 
  teng         allowing propagators to be specialised for specific constraints resulting in
improved efficiency and adaptability  ac  amends set s from ac  to contain triples of
the form  v  c    where v  scope c  and  is the set of values lost by v  consequently
   

fithe ultrametric constraint and phylogenetics

revision is more efficient because propagation can focus of values that may have lost support 
rather than having to check every value for support  in an object oriented toolkit language
a constraint has associated propagation methods that should be implemented  and these
methods are activated when a domain event occurs on a variable involved in that constraint 
domain events can be the initialisation of a variable  an increase in the lower bound  a
decrease in the upper bound  the removal of a value between the bounds  or the instantiation
of that variable  this is an exhaustive list  however some toolkits allow only one event 
that one or more values have been lost and the propagator writer must then determine
what action to take  to give examples of using a toolkit with specialised constraints  when
modelling a routing problem we might have a constrained integer variable for each location
to be visited  with a domain of values corresponding to the index of the next destination  the
so called single successor model   a subtour elimination constraint  caseau   laburthe 
      might then be used to ensure that only legal tours are produced  and regins alldifferent constraint  regin        could be added to increase domain filtering  in a pick
up and delivery variant  side constraints could be added to ensure that some locations are
visited before others  for a job shop scheduling problem we might have a model that uses
    variables to decide the relative order of pairs of activities that share a resource  and we
might increase propagation by adding carlier and pinsons edge finding constraint        
the constraint programming approach is general and practical for modelling and solving
problems  and provides a framework for the combination of problem specific algorithms in
one solver  this allows us to solve many classes of problems efficiently and to model even
more problems via the addition of side constraints 
    the supertree problem
supertree construction is a problem in phylogenetics where we are to combine leaf labelled
species trees  where the sets of leaf labels intersect  into a single tree that respects all
arboreal relationships in each input tree  bininda emonds         species trees describe
part of the evolutionary history of a set of species  labels on leaves correspond to existing
species and internal nodes represent divergence events in evolutionary history where one
species split into at least two other species  species trees may also be annotated with dates
on internal nodes  representing the time at which the divergence event happened 
we now define the term displays  which makes precise what we mean by respects
arboreal relationships  supertree t  displays a tree t  if and only if t  is equivalent to t 
 i e  they induce the same hierarchy on the leaf labels  where t  is obtained by the following
steps  semple   steel        
   let l be the set of leaves of t  that are in t   
   let t  be the unique subtree of t  that connects all leaves in l 
   to obtain t    wherever there is a subpath  p            pk   of a path from the root to a
leaf in t  where p            pk  are all interior nodes of degree    contract this into a
single edge 
the problem is then to produce a rooted species tree t from a forest of input trees f  so
that t contains all the species in f and displays every tree in f   figures   and   illustrate
the displays property 
   

fimoore   prosser

 
 

t 

 
 

 
 

t 

 
 

b

c

d

 
 

a

d

a

d

e

   
 
 

a

 

 
 
 
 
   
 
   
 

 
 

e

 
 
 
 
   
 
   
 

t

t   t
 
 

 
 

 
 

   
 
   
   
   
 

a

 
 

l  a d e 

d

e

e

figure    an example of a tree t  that displays a tree t 

 
 

t 

 
 

l  a d e 

 
 

 
 

   
 
   
   
   
 

a

d

c

b

e

t    t  

 
 

 
 
 
 
   
 
   
 

a

   
 
 

a
t 

 
 

t 

 
 

d

d

e

 
 

e

 
 
 
 
   
 
   
 

a

d

e

figure    an example of a tree t  that does not display tree t 

   

fithe ultrametric constraint and phylogenetics

we say that two trees t  and t  are compatible  incompatible  if there exists  doesnt
exist  a third tree t  that displays t  and t    variants on the supertree problem that
have previously been published and solved in the specialist bioinformatics literature include
finding all solutions    counting solutions  finding conserved relationships in all supertrees
 daniel         incorporating nested taxa  semple et al          incorporating ancestral divergence dates  semple et al         and the possibility of contradictory input data  semple
  steel        

   the ultrametric constraint
the ultrametric constraint was first proposed by gent et al         within the context of
supertree construction  bininda emonds         and was implemented using toolkit primitives  we review this encoding and show that in most constraint toolkits this is inefficient
in terms of both space and time  this motivates the creation of a specialised ultrametric
propagator over three variables  that maintains the ultrametric property over the bounds
of those variables  it is presented by describing the necessary propagation methods  we
then extend it to a specialised propagator that maintains the ultrametric property on a
symmetric matrix of variables 
    previous work on the ultrametric constraint
first  we give a definition of the ultrametric constraint 
definition    an ultrametric constraint on three variables  henceforth  um    x  y and z
constrains them such that 
 x   y   z    y   x   z    z   x   y    x   y   z 

   

this constraint ensures that there is a tie for the least element of the three  i e   either
all three are the same  or two are the same and the other is greater  the constraint was
proposed by gent et al          used again by prosser        and both times implemented
as a literal translation of equation   using toolkit primitives  evidence obtained from the
jchoco  eclipse and ilog constraint programming toolkits shows that no propagation
is done to lower bounds by this combination of primitive constraints  this is due to the disjunctive constraints since in many constraint programming toolkits propagation is delayed
until only one of the disjuncts can be true  this is known as delayed disjunction consistency
 van hentenryck  saraswat    deville         consequently  in the above encoding values
that cannot occur in any satisfying assignment might not be pruned from the domain of a
variable  consider the case for three variables  x             y         and z       the
domains of the variables are already at a fixed point with respect to delayed disjunction
consistency but there is no ultrametric assignment where x takes the value    i e   delayeddisjunction propagation does not achieve arc consistency  as we shall see later  finding
a solution to the supertree problem using toolkit constraints can result in a backtracking
search  and we prefer to avoid this  of course  higher levels of consistency would overcome
this  such as constructive disjunction consistency  van hentenryck et al          singleton
   there may be multiple supertrees for the same set of input trees 

   

fimoore   prosser

arc consistency  debruyne   bessiere        or the filtering algorithm of lhomme        
however  the cost of these is greater in the average case than delayed disjunction  preventing their use in toolkits  in fact for the um   constraint it is especially unfortunate that
the lower bounds may not be trimmed properly 
lemma    in the um   constraint  when lower bounds are supported  i e   form an ultrametric instantiation with values in the other constrained variables   they support each other 
proof  consider three supported lower bounds  suppose for a contradiction that the two
least of these are distinct  one of these is distinct lowest and it cannot be supported on
account of the fact that it is not equal to anything or larger than anything  therefore by
contradiction the two least must be equal  however the other lower bound is at least as
large as these  so the lower bounds are mutually supportive 
this lemma will have important implications for the species tree model to be presented
in detail in section    in particular  the lower bounds of a bounds z  consistency model
form a solution  where bounds z  consistency  bessiere        is defined as follows
definition    given  v  d  c  and constraint c  c with scope c     vc            vck    a tuple
    xc            xck   is a bound support when   rel c  and for all xci     min dom vci    
xci  max dom vci     a constraint c is bounds z  consistent if for all vci  scope c  there
exist bound supports involving both min dom vci    and max dom vci     a csp is bounds z consistent when every constraint c  c is bounds z  consistent 
we will henceforth abbreviate bound support to support and bounds z  consistency to
bc z   bc z  differs from ac because it puts weaker conditions on the values that comprise
the support  rather than them having to be in the domain  they need to only be between
the lower and upper bounds of the domain  this means that bc z  prunes a subset of
the values that ac can  in general  weaker levels of consistency such as bc z  are useful
because in certain problems they can prune the same number of values as ac more easily 
or fewer values much more quickly  in our case  bc z  is interesting because this level of
consistency is just enough to ensure that the problem can be solved by propagation with
no search  as we shall see 
    design of a bc z  um   propagator
in this section we describe a um   propagator that enforces bc z   namely um   bcz 
      analysis of lower and upper bounds
in this section we dont take account of domains becoming empty  since we analyse lower
and upper bounds in isolation a lower bound may pass an upper bound or vice versa 
thereby emptying a domain  if this happens then the propagator described in section      
will not enforce bc z   rather it will terminate  this is not a problem  because a domain
becoming empty means that there is no solution and to continue would be a waste of time 
concordantly  in this section  when we analyse lower bounds we will assume the upper
bound is  so that the domain cannot become null for this reason  and vice versa 
   

fithe ultrametric constraint and phylogenetics

code style  variables v    v    v    s  m and l below are constrained integer variables  and are synonymous with their domains  consequently a variable x can be considered as a domain where x lb
and x ub return references to lower and upper bounds respectively  sortonlowerbounds x y z 
returns a tuple of references to variables x  y and z in non decreasing order of their lower bounds 
sortonupperbounds is analogous  let  s m  l         names the references s  m and l  as a
result of s lb  m  lb  the lower bound of s is assigned equal to the value of the lower bound of m  
although if m  lb subsequently changes they will be distinct again  the expression x b y returns the
intersection of their domains  max x lb y lb        min x up y up   

algorithm um   bcz
lbfix v   v   v   
a 
let  s  m  l   sortonlowerbounds v    v    v   
a 
if  s lb   m  lb  then
a   
s lb  m  lb
ubfix v   v   v   
a 
let  s  m  l   sortonupperbounds v    v    v   
a 
if  s ub   m  ub  then
a   
if  s b l     then
a   
m  ub  s ub
a   
else if  s b m     then
a   
l ub  s ub
min event v   v   v   
a 
lbfix v   v   v   
a 
if all domains are non empty then
a   
ubfix v   v   v   
max event v   v   v   
a 
ubfix v   v   v   
fix event v   v   v   
a 
lbfix v   v   v   
a 
if all domains are non empty then
a   
ubfix v   v   v   

figure    algorithm for um   bcz propagator

   

fimoore   prosser

   

   
l
m
s

   

   
l
s m

s m l

m l
s

figure    cases in the analysis of lbfix

l
   

l
m m
s s

l m
   

   

s

   

figure    cases in the analysis of ubfix
the procedure lbfix in figure   takes as input three variables and removes any unsupported values at the lower bounds of the domain  the intuition for the algorithm achieving
this is that each one needs to be involved in a tie for least element  hence if the smallest
lower bound is strictly less than the others then it must be unsupported 
the possible states of lower bounds when lbfix is invoked are summarised in figure   
either all three are different  case     all three are the same  case    or two are the same and
one different  cases   and     these give relationships between bounds at a point in time
when some lower bound may be unsupported  the boxes in figure   are shaded as follows 
regions shaded black are removed by propagation whereas gray regions are supported  what
the diagrams are not supposed to suggest is that  for example in case    the bounds differ
by    rather when two bounds are lined up they are the same bound and when one is
different from another they are different by some non zero but unspecified amount  hence
they describe relationships and not actual values 
the following shows that lbfix removes all unsupported values and does not remove
any supported values 
lemma    after lbfix is invoked all lower bounds of the argument variables are supported
w r t  the um   constraint and no supported values are removed 
proof  for cases   and    figure    the condition on line a  is satisfied  so line a   
is executed  this results in the removal of the unsupported range and by inspection the
remaining bounds are mutually supportive  in cases   and    the condition on line a  is
failed and so no changes are made to the domains  the bounds are mutually supportive 
the procedure ubfix in figure   does the same job to upper bounds that lbfix does
to lower bounds  the following lemma justifies this assertion and the cases used in the
proof are shown in figure   
lemma    after ubfix is invoked either
   

fithe ultrametric constraint and phylogenetics

 all upper bounds of the argument variables are supported w r t  the um   bcz constraint and no supported values are removed  or
 a domain is null as a result of removing unsupported values 

proof  let s  m and l be the domains with smallest  middle and largest upper bounds 
breaking ties arbitrarily  let s  m and l be these upper bounds 
first we will prove that in case    figure    the shaded region in m is supported if and
only if l b s      potentially  the bound can be supported by
 equal values in s and l at least as small as it  i e   s b l       or
 an equal value in either s or l  and a value at least as large in the remaining domain 
however  notice that the latter is impossible due to the fact that only l contains an equal
value  and s has no value as large as this 
similar arguments can establish that the shaded regions in l in case    m in case   and
l in case   are supported if and only if m b s      l b s     and m b s      respectively 
now we will establish the lemma for each of the cases         and   
cases   and   the condition on line a  is false  and so no domains are changed  the
upper bounds are mutually supportive in each case 
case   and shaded region of m is unsupported from above l b s     hence
ubfix line a    will be executed and the unsupported region removed  now the upper
bounds l  l  s  m and s  s are mutually supportive 
case   and shaded region of m is supported from above lb s      if the shaded
region of l is also supported then m b s     and so neither line a    nor a    is executed
and no changes are made to the domains  the upper bound of s is also supported  by
m  l  m  m and s  s  if the shaded region of l is not supported then m b s   
and so line a    is executed resulting in the removal of the region  the new bounds s  s 
m  m and s  l are mutually supportive 
case   and shaded regions of m and l supported from above  l b s     and
m b s      hence no domain changes result from executing ubfix  l  l and s  s are
supported by l  l  s  m and s  s  m  m is supported by s  l  m  m and s  s 
case   and shaded regions of m and l are unsupported from above  l b s   
and m b s    and so line a    of ubfix is executed and this results in m becoming null 
case    shaded region of m supported but shaded region of l not supported
from above lb s     and m b s     so that a    is executed to remove the unsupported
region  the new bounds of s  s  m  m and s  l are mutually supportive 
case    shaded region of l supported but shaded region of m not supported
symmetric with previous case 

note that there is no analog of lemma   for upper bounds since  for example  the bounds
of x              y          and z       are all supported  but not mutually supportive 
   

fimoore   prosser

      the propagation algorithm
having presented lbfix and ubfix we are now in a position to present the complete propagation algorithm  the propagator works with arbitrary domains and it enforces bc z  
except when a domain becomes empty  in which case it does no further work  the algorithm
is described by the action taken when any of three domain events occur 
min the domain has lost its lower bound since propagator was last invoked 
max the domain has lost its upper bound since propagator was last invoked 
fix the domain is a singleton  i e   the variable is instantiated and upper and lower bounds
are equal 
i e  we only consider events on the bounds of the variables  the algorithm is listed in lines
a  a  of figure    intuitively these procedures work because  as we will show  a change
to an upper bound can affect the support for other upper bounds  but a change in a lower
bound can affect support for both lower and other upper bounds  hence we need only run
lbfix when a lower bound may have changed  but ubfix must be run for a change of either
lower or upper bounds  whilst it would be correct to cycle between trimming upper and
lower bounds until a fixed point is reached  i e  no more changes occur   we can guarantee
a fixed point more easily 
lemma    it is possible for a change in a lower bound to result in the loss of support for
another lower bound 
proof  all the bounds in the diagram have support  but when the black shaded lower
bound is lost the dark gray shaded lower bound loses support 

lemma    it is possible for a change in a lower bound to result in the loss of support for
an upper bound 
proof  all the bounds in the diagram have support  but when the black shaded lower
bound is lost the dark gray shaded upper bound loses support 

lemma    it is possible for the loss of an upper bound to cause the loss of support for
another upper bound 
   

fithe ultrametric constraint and phylogenetics

proof  all the bounds in the diagram have support  but when the black shaded upper
bound is lost the dark gray shaded upper bound loses support 

corollary    it is impossible for a change in an upper bound to result in the loss of support
for a lower bound 
proof  by lemma   a lower bound retains support as long as the other lower bounds are
intact  hence losing an upper bound has no effect 
why the asymmetry between upper and lower bounds  it is due to the asymmetry in
the definition of um   bcz and has the practical repercussion that bc z  lower bounds
must be mutually supportive whereas bc z  upper bounds may not be and may require
support from other values including lower bounds 
corollary   suggests that a further improvement on the algorithm in figure   is to
execute line a  and a  if and only if any lower bound lost is the only remaining support
for an upper bound  however  the conditionals intrinsic in ubfix amount to much the
same thing and there is little point in repeating them 
the point of these theorems has been to build up a complete proof of correctness and
bc z  status 
theorem    the code for min  max and fix events listed in figure   does not remove any
values involved in bound supports for the um   bcz constraint  and  if all the domains are
non null after propagation  the resultant domains will be bc z  
proof  first we must establish that no values are removed during propagation that could be
involved in a support  and that the result domains are subsets of the input domains  the
former is immediate from lemmas   and    because values are only removed as a result of
executing lbfix and ubfix  the latter is immediate from inspection of lbfix and ubfix 
because they only ever make lower bounds larger and upper bounds smaller 
the final thing to establish is that bc z  is enforced  unless a domain becomes null 
if any domain becomes empty as a result of running the algorithm then the theorem is
trivially true 
if no domain becomes empty then we must show that all the bounds are supported  for
lower bounds  by lemma   and corollary   we know that only the loss of a lower bound
can result in the need to change a lower bound during propagation  lower bounds can
change as a result of either fix or min events  hence the propagator in figure   runs lbfix
in either event  when lbfix runs it leaves all lower bounds supported  as was shown in
lemma    for upper bounds  by lemmas   and   we know that the loss of either a lower
or upper bound can result in the loss of an upper bound  hence upper or lower bounds can
change as a result of any event  and lower bounds can also change as a result of lbfix 
hence the propagator runs ubfix in all events  and it runs after lbfix has finished  if
necessary  when ubfix runs it leaves all upper bounds supported provided no domain
becomes empty  as was shown in lemma   
   

fimoore   prosser

 
 
 
 
 
 
 
 
 
 
 
 

 a 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 b 

figure    propagation done when   domains are singleton
the propagation algorithm runs in     time  this is because all of the operations in
lbfix  ubfix  min  max and fix events are      provided that our domain representation
allows access to the upper and lower bounds in      this can be guaranteed if domain
reductions only occur at the bounds  as is the case here  or if domains are represented using
one of the structures proposed by van hentenryck et al         
    entailment
schulte and carlsson        define entailment as when all possible constractions of the
domains in a constraints scope are consistent  if we can detect that this has happened we
can stop running the propagator henceforth  since it cannot prune any more values 
definition    a propagator is entailed by domains d    d            dn   when any set of
domains that are subsets of these  i e   any e    e            en   s t  i ei  di   are at a fixed
point 
we now describe a sufficient condition for the um   bcz constraint to be entailed  i e   the
um   bcz constraint becomes entailed as soon as two variables have singleton domains 
theorem    um   bcz becomes entailed as soon as two variables have singleton domains 
proof  consider the possible scenarios  either the two singletons are the same  case  a  in
figure    or they are distinct  case  b  in figure     the domains before propagation are
shown in figure   as boxes  the domains after propagation are shaded gray  clearly all
remaining choices for the third variable are valid instantiations and since the propagation
algorithm is safe they cannot be removed by further propagation and by definition the
propagation will be at a fixed point 
    ultrametric matrix constraint
the supertree model presented in section   makes use of the ultrametric constraint  however
in this context the desired end product is to constrain a whole matrix to be an ultrametric
matrix  and not merely to constrain three variables 
   

fithe ultrametric constraint and phylogenetics

code style  let  i  j   index v  declares i and j to be the indices of variable v in the matrix m that
the constraint is over 

algorithm um matrix bcz
min event v 
a 
let  i  j   index v 
a 
for k          n do
a   
if k    i and k    j then
a   
min event mij   mik   mjk  
a   
max event mij   mik   mjk  
max event v 
a 
let  i  j   index v 
a 
for k          n do
a   
if k    i and k    j then
a   
max event mij   mik   mjk  
fix event v 
a 
let  i  j   index v 
a 
for k          n do
a   
if k    i and k    j then
a   
min event mij   mik   mjk  
a   
max event mij   mik   mjk  

figure    algorithm for um matrix bcz propagator

definition    a symmetric matrix m is an ultrametric matrix if and only if for every set
of three distinct indices i  j and k  there is a tie for the minimum of mij   mik and mjk  
and mii     for all i 
the ultrametric matrix constraint can be achieved for matrix m by posting the constraint um   bcz m
ij   mik   mjk   over all choices of distinct i  j and k  but at a cost of

introducing n  constraints  in practical constraint solvers any model containing this constraint will have  n    space complexity  since the solver must have a list of all  n   
constraints stored somewhere  however  when a domain event occurs for any matrix variable mij it is straightforward to iterate over all k indices doing the same propagation as
um matrix bcz from figure    this replaces a  n    space list representation of the set
of um   bcz constraints by a     code representation  hence we propose the ultrametric
matrix constraint propagator um matrix bcz in figure   
this propagator mimics part of the ac  algorithm  mackworth        since it  a 
receives a propagation event on a variable   b  identifies which constraints are over that
variable  and  c  arranges for the propagation to be carried out  any events caused as a
result are queued and dispatched by the underlying propagator as normal and this may
cause um matrix bcz to be run again  each variable can be involved in up to n   
constraints  since each variable has two indices in the matrix and we have a constraint
involving each choice of three different indices 
n
 

the algorithm propagates in  n  time  which is more expensive per event than using
um   constraints  but a factor of n fewer propagators wake up as a result of each event 
   

fimoore   prosser

a

b

c

a

c

b

b

c

a

a

b

c

figure     the four possible relationships between three leaf nodes in a tree  i e  the three
triples  ab c   ac b  and  bc a  and the fan  abc  

   supertree construction
we now review imperative solutions to the supertree construction problem  review the first
constraint programing solution  gent et al          and present a new encoding that exploits
the specialised um matrix bcz constraint 
    imperative solutions to the supertree problem
the earliest imperative techniques are due to bryant and steel        and ng and wormald
        both present a onetree algorithm which is based on the build algorithm of
aho  sagiv  szymanski  and ullman         onetree is based on the observation that
in a tree any three leaf nodes define a unique relation with respect to their most recent
common ancestor  mrca   such that mrca a  b  is the interior node furthest from the root
that has both leaf nodes a and b as descendants  we abuse notation by writing mrca a  b   
mrca c  d  when the former has a greater depth than the latter  and similarly mrca a  b   
mrca c  d  if they have the same depth  given three different leaf nodes species  labelled
a  b  and c  one of the following four relations must hold 
   

mrca a  b    mrca a  c    mrca b  c 

   

mrca a  c    mrca a  b    mrca c  b 

   

mrca b  c    mrca b  a    mrca c  a 

   

mrca a  b    mrca a  c    mrca b  c 

we now say that in          and     we have the triples  ab c   ac b  and  bc a  where
 xy z can be read as x is closer to y than z  and in     we have the fan  abc   i e   in
a fan the relationship between species is unresolved as we dont specify which pair is most
closely related  this is shown in figure     prior to applying the onetree algorithm two
 or more  species trees are broken up into triples and fans using the breakup algorithm
 ng   wormald         resulting in a linear sized encoding of those trees  the supertree is
then constructed  if possible  using this encoding as input 
figure    shows an example of the breakup algorithm process  two variants of the
process are shown  at the top we have a hard breakup  where fans are considered as hard
evidence that must be respected  hard polytomies as described by ng and wormald       
and below a soft breakup where fans are taken as a lack of evidence  soft polytomies as
described by bryant and steel         for hard breakup the algorithm is modified such
   

fithe ultrametric constraint and phylogenetics

e

a

b

c

b

c

g

break up

break up

break up

 a b c 
 a b d 
 a c d 
 b c d 

 cd e

 de f

 ef g

d

d

e

c

e

a

f

break up

f

f

g

d

e

f

g

e

f

g

d

break up

break up

break up

break up

 ab e 
 bc e

 cd e

 de f

 ef g

e

g

c

  abc   abd  
 
 bcd   cd e 
 de f  ef g 

f

g

d

e

f

g

e

f

  ab e  bc e 
 
 cd e  de f 
 ef g 

g

d

figure     example execution of the breakup algorithm  on the top  a hard breakup 
and below a soft breakup  no fans produced 

code style  the function sortedinteriornodes t   delivers the set of interior nodes of the tree t in nonincreasing order of depth in that tree  degree v  delivers the out degree of node v  function child v  i 
delivers the ith child of interior node v  uncleorcousin l  delivers a leaf node that is descended from
a sibling of the parent of leaf node l  function becomesleaf v  l  transforms interior node v into a leaf
node labelled as l  removechild l  v  removes the leaf node l from the list of children of interior node v 

algorithm hardbreakup
hardbreakup t  
 
let v  sortedinteriornodes t  
 
let s  
 
let i   
 
while notroot v  i    degree v  i       do
 
let v  v  i 
 
let c   child v    
 
if degree v     
 
then let c   child v    
 
let c   uncleorcousinof c   
  
s  s   triple c    c    c    
  
v  becomesleaf v  c   
  
ii  
  
else for j    to degree v     do
  
for k  j     to degree v     do
  
let c   child v  j 
  
let c   child v  k 
  
s  s   fan c    c    c    
  
v  removechild c    v 
   return s

figure     hard breakup of a tree t   producing triples and fans 

that when encountering a kfan this is broken up into n    fans  and in a soft breakup a
fan is broken into a linear number of rooted triples  algorithms for hard and soft breakups
are given in figures    and     and are used by the imperative onetree algorithm here
and the constraint programming models 
   

fimoore   prosser

algorithm softbreakup
softbreakup t  
 
let v  sortedinteriornodes t  
 
let s  
 
let i   
 
while notroot v  i   do
 
let v  v  i 
 
let c   child v    
 
let c   child v    
 
let c   uncleorcousinof c   
 
s  s   triple c    c    c    
  
if degree v     
  
then v  becomesleaf v  c   
  
ii  
  
else v  removechild c    v 
   return s

figure     soft breakup of a tree t   producing only triples 

c

a

b

c

e

c

b

a

c

d

d

e

b

e

figure     a toy input  left  and single solution to the supertree problem  right   input
trees are distorted to make relationships in resultant supertree more obvious 

a toy set of input triples and single solution are shown in figure     the triples have
been drawn to reflect how the solution is compatible with them 
ng and wormald        give the complexity of onetree as o h n   where h n   
n n   t   bn  n   t   f    n is the number of labels  t the number of triples  f the number
of fans  b is the sum of the squares of the number of leaves in the fans  and  is the inverse
ackermann function  and is less than   for all conceivable inputs and so behaves like a
constant   therefore if the input trees are fully resolved  i e   have no fans  then running
   

fithe ultrametric constraint and phylogenetics

time complexity is o n    but in the worst case complexity grows to o n     this should be
contrasted with the o t  n  complexity of bryant and steels onetree        
    a constraint encoding using toolkit constraints
this second stage  i e   onetree equivalent  was first solved as a constraint program by
gent et al          the encoding takes advantage of an equivalence between ultrametric
trees and ultrametric matrices 
definition    let m be a real symmetric n  n matrix  an ultrametric tree for m is a
rooted tree t such that 
   t has n leaves  each corresponding to a unique row of m 
   each internal node of t has at least   children 
   for any two leaves i and j  mij is the label of the most recent common ancestor of i
and j  and
   along any path from the root to a leaf  the labels strictly increase 
theorem    a symmetric matrix m has an ultrametric tree t if and only if it is an
ultrametric matrix  furthermore  the tree t uniquely determines the matrix m and the
matrix m uniquely determines the tree t  
proof  a proof is given by gusfield        
there is a clear correspondence between definition   and the description of a species
tree given in section    a species tree t is an ultrametric tree for matrix m   where mij is
the depth of the mrca of species i and j or mij is the divergence date of those two species 
for this reason we can use an ultrametric matrix model to solve the supertree problem 
      the model of gent et al 
given as input a forest f with n distinct leaf labels  a symmetric
constrained integer variables is created with domains             n    
diagonal  variable mij is the depth of the mrca of species i and j 
are posted to make the whole matrix ultrametric thus ensuring that
ultrametric 
mij   mik   mjk
 mik   mij   mjk
 mjk   mij   mik
 mij   mik   mjk

n  n matrix m of
or     on the main
initially  constraints
any resulting tree is

   

for each i   j   k  the input trees are then broken up into triples and fans using either of
the breakup algorithms of figures    and     for each triple  ij k produced the constraint
mij   mik   mjk
   

   

fimoore   prosser

 
a
b
c
d
e
f
g

 
 e g 
 
 c d 

a

a b c d e f g
             
   
 
 
 
 
 
 
 
 
 
 

 b f 

figure     one iteration of an algorithm to convert an ultrametric matrix to a tree
is posted and for each   fan  ijk 
mij   mik   mjk

   

is posted  these constraints break the disjunctions of equation    the model has  n  n   
variables and
t f  

 
n
  o n      o n       n       n   
 

   

constraints  where t is the number of triples and f the number of fans  there are o n    of
each because each one breaks the disjunction in at most one constraint from equation   
and there are  n    of those 
      converting back to tree representation
the final step is to use an algorithm based on the constructive proof by gusfield        of
the  direction of theorem   to build a tree from the matrix m produced by a constraint
solver  we will not describe this algorithm in detail  but for the sake of intuition it works
as follows
 pick an arbitrary leaf s  let the number of distinct entries in row s be d 
 partition the other leaves into sets p            pd based on their entry in row s 
 solve the problem recursively on each pi by ignoring all the rows and columns in the
matrix d not in pi  
 combine into overall solution by attaching subproblem solutions at the correct depth
on the path to s 
figure    shows one recursion of the algorithm with a choice of leaf a and shows that
row a fully describes the path to a in the corresponding tree 
   

fithe ultrametric constraint and phylogenetics

algorithm cpbuild
cpbuild f  
  let  v  d  c   cpmodel f  
  for t  f do
 
for t  breakup t   do c  post t  c 
  if propagate v d c  then return umtotree v d 
  else fail  

figure     build a supertree from forest f using the ultrametric constraint model 
      time complexity of the model of gent et al 
breakup  and the procedures to build a constraint model and to convert an ultrametric
matrix to a tree are all polynomial time  however the complexity of backtracking search
 
over o n    variables with o n  size domains is worst case o nn    this is an upper bound
on the time taken to solve the supertree problem  we have not attempted to derive a lesser
upper bound on the time complexity  since  as we will show in the following section  our
new model has provably achieved a polynomial time bound 
    a constraint encoding using the new propagator design
this issue of potentially exponential solution time model of section     is worrying  but in
our experiments the time taken to solve instances has not been a major issue  conversely
the memory requirements are a problem in practice  but not in theory  the model requires
 n    space for n species  but the constant factor is inhibiting  posting the constraint of
equation   literally  using toolkit propagators  as described in section   uses    propagators in the jchoco toolkit  this requires roughly    times the runtime memory of a
single propagator  since each corresponds to a single java object  and each of these have
comparable footprints  as we will show in the empirical study of section    this prevents
modest instances from being loaded on typical current workstations 

using the new propagator of section   we replace these n  propagators with a single
compact propagator and as a result memory usage is reduced asymptotically from  n   
to  n    since now the model memory is dominated by the  n    space needed for the
matrix m   also reducing the amount of space to be initialised delivers a proportional
saving in build time  but most importantly  using the new constraint provides a solution
to exponential time complexity  because enforcing bc z  on the model allows a solution to
be read out of the lower bound of each domain  theorem   is a proof of correctness for this
algorithm 
figure    gives a schema for the constraint programming algorithm for supertree construction  cpbuild  the algorithm takes as input a forest f of trees  in line   a constraint
model is produced  i e   an n  n symmetric array of constrained integers variables is created  where there are n unique species in the forest  and the um matrix bcz constraint
is then posted over those variables  lines   and   breaks these input trees into their triples
and fans using either of the breakup algorithms given in figures    and     and posts them
into the model as constraints  propagators for the constraints are executed to a fixed point
in line    if this succeeds a tree is created from the lower bounds of the ultrametric matrix
otherwise we fail 
   

fimoore   prosser

lemma    if the propagator for every constraint in a model enforces bc z  and furthermore the lower bounds are mutually supportive  then after executing all propagators to a
fixed point  either the lower bounds are a solution  or we have an empty domain and fail 
proof  if we reduce each domain to just the lower bound after a fixed point is obtained
then each bound is supported because they are mutually supportive by supposition  hence
every constraint is simultaneously satisfied by these singleton domains and  by definition 
we have a solution 
theorem    cpbuild is a polynomial time solution to the supertree problem 
proof  the only constraints involved in the model are those for triples and fans and ultrametric constraints  by theorem   we know that all lower bounds are supported after the
propagators run  and by lemma   we know that the lower bounds are mutually supportive  the same is true of the disjunction breaking propagators  hence by lemma    and as
shown in figure     we can either read out a solution or fail  we can enforce bc z  on the
problem in polynomial time as shown below 
immediate from this is that we can preserve the polynomial time solution with the
addition of a polynomial number of side constraints  so long as these additional constraints
preserve the property that lower bounds are mutually supportive  in fact  csps such as
these with ordered domains where all constraints have the property that lower bounds are
mutually supportive belong to a known tractable class called min closed  jeavons   cooper 
      
      time complexity of cpbuild
the algorithm can be implemented to run in o n    time using a variation on the ac 
algorithm  ac   mackworth        begins with a queue containing all constraints  it
repeatedly removes a constraint until none remain and runs the associated propagator 
any constraints over affected variables are re queued  if necessary  once the queue empties 
all propagators are at a fixed point  we need o n    constraints so the worst case complexity
is
o n   
   z  

 

build initial q

o n o n   
   z  

worst case re queues with   value removed at a time

 

o   
   z  

propagation time

or o n    overall  this matches the worst case complexity of onetree  ng   wormald 
       our constraint solution has its worst case when the problem is unsolvable  since
when it is unsolvable domains are emptied by propagation  whereas for solvable instances
propagation reaches a fixed point sooner 

   empirical study
we present an empirical study to determine if any practical improvements have been
achieved in constraint solutions to the supertree problem and  if so  what size of improvement  experiments were run using a    ghz pentium   processor with    mb of memory 
using sun java build          b    the constraint toolkit used was jchoco version        
   

fithe ultrametric constraint and phylogenetics

input trees were broken up using a hard breakup  consequently in all cases fans were treated
as hard polytomies   
our benchmark is real life seabird data previously used by kennedy and page       
and beldiceanu et al         and we present statistics on various techniques for producing supertrees  namely onetree  and the cp solutions of section    entries toolkit and
cpbuild   for completeness we reproduce the results of beldiceanu et al         over the
same data set  and tabulate this as treecon  treecon uses a single successor model 
where constrained integer variables represent nodes within a tree  and domains correspond
to possible successors    a unique variable represents the root and loops on itself  i e  
vroot   root   and leaf nodes have an indegree of zero  precedence and incomparability
constraints are then generated from the input trees 
the treecon results were encoded in the same constraint programming toolkit as ours
but on a processor that was approximately twice as fast   ghz   we do not correct the times
to compensate for this factor  we mark in bold results that differ very significantly between
the cpbuild and treecon results  specifically those whose runtimes would undoubtedly
be a factor of    different on the same processor  results are reported for combinations of
seabird trees  input trees named a to g  and the following data is tabulated below 
data the combination attempted 
n total distinct species in input trees
sol t iff supertree is possible
technique type of algorithm used to solve
build time in milliseconds to initialise cp model
solve time in milliseconds to first solution  if any
total   build   solve
nodes number of nodes in search tree
mem model memory in mb
in the table  dnl means that the model could not be loaded  as it was too large  and dnf
means that it could not be solved within    mins  but succeeded in loading  we have not
provided the memory usage of onetree  however it is smaller than that of any of the
constraint encodings 
the most obvious thing to note is how much faster the imperative approach is compared
to the constraint techniques  why is this  primarily it is due to the lower complexity of
onetree in the absence of fans  we have not investigated if we can benefit from this  
and partly due to the generality of the constraint programming approach  the imperative
approach is highly specialised to only one class of problem whereas the constraint approach
sits within a toolkit  and runs on top of a general purpose constraint maintenance system 
we should not expect that the constraint approach will compete in raw speed but what we
later demonstrate  in section    is that the approach benefits from its versatility  i e   the
   in a later section we use soft breakup 
   an alternative constraint model of a tree might use     variables corresponding to potential edges
within an adjacency matrix  prosser   unsworth         or indeed the cp graph  computation domain
 dooms        

   

fimoore   prosser

costs of space and time is repaid by the ease of accommodating variants of the problem into
the same model 
data
ab

n
  

sol
t

ac

  

f

ad

  

t

ae

  

f

af

  

t

ag

  

t

bc

  

f

bd

  

t

be

  

f

bf

  

t

bg

  

t

cd

  

t

ce

  

t

cf

  

t

cg

  

f

technique
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon

build
    
   

solve
   
   

    
   

   
   

    
   

   
   

dnl
   

dnl
    

    
   

   
   

    
   

   
   

    
   

     
   

    
   

   
   

dnl
   

dnl
     

    
   

   
  

    
   

   
   

     
   

    
   

dnl
   

dnl
    

    
   

   
   

    
   

   
   

   

total
    
   
   
  
    
   
   
  
    
   
   
  
dnl
    
     
  
    
   
   
  
    
   
   
  
     
   
  
 
    
   
   
  
dnl
     
   
  
    
   
   
 
    
   
    
  
     
   
   
  
dnl
    
     
  
    
   
   
  
    
   
    

nodes
  
  

mem
     
    

 
 

     
    

  
  

      
    

dnl
 

     
    

  
  

     
    

  
  

      
    

   
 

     
    

  
  

     
    

dnl
 

     
    

  
  

     
    

  
  

     
    

  
  

      
    

dnl
  

     
    

  
  

     
    

 
 

     
    

fithe ultrametric constraint and phylogenetics

de

   

f

df

  

t

dg

  

f

ef

  

f

eg

  

f

fg

  

f

abdf

  

t

abdg

  

f

acdf

  

f

acdg

  

f

ace

  

f

onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
onetree

dnl
   

dnl
    

    
   

   
   

     
   

    
   

dnl
   

dnl
    

dnl
   

dnl
    

    
   

dnl
   

     
   

    
   

     
   

dnf
    

     
   

    
   

dnl
   

dnl
    

dnl
   

dnl
    

  
dnl
    
    
  
    
   
   
  
     
   
   
  
dnl
    
    
  
dnl
    
    
  
dnl
   
  
  
     
   
    
  
dnf
    
   
  
     
   
    
  
dnl
    
     
  
dnl
    
  

dnl
 

     
    

  
  

     
    

 
 

      
    

dnl
 

     
    

dnl
 

     
    

dnl
 

     
    

  
  

      
    

dnf
 

      
    

 
 

      
    

dnl
 

     
    

dnl
 

     
    

the most impressive aspect of the matrix model of section     over that of section    
is the improvement in memory requirements  so that all instances can now be loaded comfortably  this also has a dramatic impact on the build time  these improvements dominate
the reduction in solve time in practice  the toolkit model is outperformed by cpbuild by
an order of magnitude on each instance  moreover  there are two cases of search occurring
in the toolkit model  on data sets bc and abdg  whereas cpbuild never has to search 
the polynomial time complexity is due to the provable absence of search 
our results also compare well against those of beldiceanu et al          there is one
case  be  where cpbuild is an order of magnitude slower than treecon  so far we do not
have an explanation for this  there are four cases when treecon is significantly worse
than cpbuild  no results are available for treecon over the data set ace  it should be
noted that beldiceanu et al  do not yet have a complete filtering algorithm for this problem
based on their constraint model and  from personal communication  although the treecon
   

fimoore   prosser

figure     supertree with largest compatible data sets of birds abdf  this took    ms to
model and    ms to solve using cpbuild 

model never backtracked over the birds data set there is as yet no proof that the complexity
of their model is polynomial  it should also be noted that we see cpbuild taking more time
on unsolvable instances than solvable instances  as predicted 
figure    shows the supertree  displayed with treeview  page         produced from
the largest compatible forest  a  b  d  f    this supertree has    leaves and takes about
  second to produce  although the result is not printed in the table  finding the forest
 a  b  c  d  e  f  g  incompatible takes about    seconds in total      seconds to build the
model and    seconds to determine incompatibility  
   

fithe ultrametric constraint and phylogenetics

   versatility of the constraint model
one of the strengths of constraint programming is its versatility  given a constraint model
of a core problem this model can then be enhanced to address variants of the original pure
problem  we demonstrate this versatility with respect to the ultrametric model  presenting
four variants of the supertree problem  a  incorporating ancestral divergence dates into
the model   b  nested taxa   c  determining if an induced triple or fan is common to all
supertrees  and  d  coping with incompatibilities 
    ancestral divergence dates
semple et al         and bryant et al         add temporal information to the input trees 
interior nodes may be labelled with integer ranks such that if interior node v  is a proper
descendant of v  then rank v      rank v     resulting in a ranked phylogenetic tree  additionally relative divergence dates may be expressed in the form div c d  predates div a b 
and this is interpreted as the divergence of species c and d predates that of species a and b 
the rankedtree algorithm  bryant et al         takes as input a collection of precedence
constraints derived from input ranked species trees and predates relations  the algorithm
outputs a ranked tree that respects those relations or returns not compatible 
this is trivial to incorporate into the constraint model  if trees have been ranked then
for each pair of species  i  j  in the leaf set we instantiate the constrained integer variable
mij to the value of mrca i  j   for a predates relation div c d  predates div a b  we post
the constraint mcd   mab   this is done before step   of cpbuild  figure      i e   ranks
and predates relations become side constraints  similarly time bounds on speciation events
are posted as unary constraints  i e  in a dated phylogenetic tree upper and lower divergence
bounds are given on interior nodes  such that l a  b  and u a  b  give respectively the lower
and upper bounds on the divergence dates of species a and b  in the constraint program
the following two side constraints are then posted  again  before step     l a  b   mab and
mab  u a  b  
a demonstration of ranked trees is given in figure     on the left we have two ranked
species trees of cats used recently by semple et al         and originally by janczewski 
modi  stephens  and obrien         the branch lengths of the source trees have been
translated into rankings and added to the interior vertices of those trees  on the right we
have one of the    possible resultant supertrees  in total    of the    solutions contain
interior nodes with ranges  if interior nodes are labelled with specific values rather than
ranges then    solutions are produced  some of which are structurally identical  this goes
some way to addressing the issue of enumerating all supertrees compactly  raised as a
challenge by semple et al          in figure    we show the effect of adding a predates
constraint to a supertree construction  the data has previously been used by bryant et al 
       in their figures   and   
    nested taxa
a taxon  plural  taxa  is a group of organisms comprising a single common ancestor and its
descendents  dawkins   wong         for example the species lion and the class birds
are taxa  so far  all our species trees have been leaf labelled  however this is restrictive
   

fimoore   prosser

figure     two ranked trees of cats  on the right one of the    possible supertrees produced
by cpbuild  displayed using pages treeview 

figure     two input trees t      a  c   x  and t     b  x  with a resultant supertree shown
in the  rd position  the tree on the far right is a supertree from t  and t 
with the side constraint div a c  predates div a b   produced by cpbuild and
displayed using pages treeview 

   

fithe ultrametric constraint and phylogenetics

p

p

q

q

p

q

a

b

c

d

e

g

b

f

d

e

a

g

b

c

f

d

e

figure     two input rooted x trees t  and t   left  and an output tree t   right  that
perfectly displays them 

because trees may be annotated with taxa names on both leaves and internal nodes  giving
nested taxa  for example  figure    shows tree t  with an internal node labelled p which
has descendents a and b  i e   the a and b taxa are nested within the p taxon  problems
related to creating compatible supertrees for this type of data were raised by page       
and defined and solved by daniel and semple         a set of input trees and possible
solution to the problem are shown in figure     notice that all labels are conserved in the
solution  all ancestral relationships are conserved and  for any labels li and lj from the same
input tree  li is ancestor of lj in the input tree if and only if li is ancestor of lj in the solution
tree  this is an instance of the problem higher taxa compatibility defined by daniel and
semple        and semple et al          where the result tree must perfectly display all of
the input trees  we now define the problem more formally 
definition    a rooted x tree  daniel   semple        is a species tree where internal
nodes as well as leaves may be labelled from the set x 
in the following we will be slightly loose and may use a label l to identify the labelled node 
as well as the label itself  e g   descendants of l means the same as descendants of the
node labelled l 
definition    a rooted x tree t perfectly displays a rooted x   tree t  when
   x   x 
   t  displays t   neglecting internal labels 
   if a is a descendant of b in t  then a is a descendant of b in t   and
   if a is not a descendant of b in t  then a is not a descendant of b in t  
a rooted x tree t perfectly displays a forest of phylogenetic trees f    t            tn   when it
perfectly displays every ti  
      constraint encoding
our constraint encoding is implemented by the addition of variables and side constraints
to the standard model of section    we describe how to transform the input to make the
constraint solution simpler  and then describe the variables and constraints needed 
   

fimoore   prosser

t 

t 

t 

p

q

p

q

q
a

b

c

d

e

f

p

e

g

f

a

b

c

e

g

f

figure     two input trees t  and t  with an enclosing taxon p   by a process of substitution t  is replaced with t   

substitution taxon p in figure    appears on an internal node of t    we will call such
a label an enclosing taxon  note also that it appears on a leaf in t    the input trees
are preprocessed to replace any tree with an enclosing taxon p on a leaf by the same tree
with any single subtree rooted at p substituted in its place  there must be such a subtree
elsewhere in the input forest  or we have a contradiction that m is an enclosing taxon  this
process does not add or remove any information  since the relationships between m and
everything in the tree still holds  and the new relationships between the taxa in the subtree
at m and the rest of the tree were always implicit in the input 
the aim of this process was just to obtain a set of inputs where enclosing taxa appear
on internal nodes only  because without loss of generality our constraint encoding assumes
that this is the case  figure    shows an example of the substitution process applied to
trees t  and t    and t  would be replaced with t   
variables and constraints the variables added are one integer variable vl per enclosing
taxa label l  each with a domain of             n      the value of this variable in a solution
is the tree depth of the internal node which it labels  and the labels position in the final
tree is determined because it must be at the unique node of that depth on a path from one
of its nested taxa to the root  see figure    and suppose for the sake of argument that
we have an enclosing taxa m which labels b  and the variable lm     in a solution  the
unique location where the label m can go is at the root node 
properties     and     from definition   above are immediate from the properties of
the earlier model which is the foundation for this one  before explaining how to enforce
property     we introduce some notations for convenience  function desc l  f   returns the
set of all descendants of label l in any tree t in the forest f   and notdesc l  t   returns the
set of labels that are not descendants of l in tree t  
we first need a constraint that l must label every single species that it labels in an input 
for every enclosing label l  post the following set of constraints 
 vl  mij   i  desc l  f    j  desc l  f    i    j 

   

so that the label must settle at least as shallow as any mrca of its descendants in input  and
hence they must remain descendants  notice that it is necessary to consider pairs of species
from distinct input trees  an alternative of taking pairs from the same tree does not work 
because it is necessary for all pairs to be under the same internal node l  rather than two
   

fithe ultrametric constraint and phylogenetics

distinct nodes that happen to be at the correct depth  next  the label must be constrained
so that no label that was not already a descendant becomes one  for each x tree t and
enclosing label l  x  post the following set of constraints 
 vl   mij   i  desc l   t     j  notdesc l  t   

   

so that the label l must be placed strictly deeper than any mrca of a descendant and
something thats not a descendant  i e   no non descendents of l can be a descendent in the
result  as an illustration we list the generated constraints for the example of figure    
   equation   and l   p    vp  mab   vp  mag   vp  mbg  
   equation   and l   q   vq  mde   vq  mdf   vq  mef  
   equation    l   p and t   t    t      vp   mac   vp   mad   vp   mae   vp  
mbc   vp   mbd   vp   mbe   vp   mgf   vp   mgd   vp   mge   vp   mbf  
   equation    l   q and t   t    t      vq   mad   vq   mae   vq   mbd   vq  
mbe   vp   mcd   vq   mce   vq   mgf   vp   mbf   vp   mgd   vp   mge  
the number of new constraints created by both equations   and   is bounded by the
number of distinct pairs of species  i e   n    new constraints 
    necessity
there may be many possible supertrees for a given input forest  one question is then 
what relationships are common to all supertrees  the problem of determining if a derived
induced triple  or fan  in a supertree is necessary  i e   common to all possible supertrees  is
introduced by  daniel        along with the polynomial time decision procedure necessity 
the algorithm necessity in figure    takes as arguments a forest f of trees  assumed
to be compatible  and a rooted triple or fan  and determines if  occurs in every supertree
that displays the trees in f   the algorithm is a simple modification of cpbuild  where
lines   to   are essentially the same  in line   the negation of the triple  is posted to the
problem  where  is posted as
mik    mjk  mij  mik  mij  mik

   

when     ij k and posted as
mij    mik  mij    mjk  mik    mjk

   

when     ijk   a call is then made to propagate to make the problem arc consistent  line
    and if this fails then  is necessary  otherwise it is not necessary  the algorithm has the
same complexity as cpbuild 
    coping with conflict
when a supertree cannot be produced from a pair of trees some of the input triples and fans
must be in conflict with one another  either directly or indirectly  junkers quickxplain
method  junker        discovers a minimal subset of constraints that when posted and
propagated result in a failure  this set is not necessarily the smallest possible set but is
   

fimoore   prosser

algorithm necessity
necessity f    
  let  v  d  c   cpmodel f  
  for t  f do
 
for t  breakup t   do c  post t  c 
  c  post   c 
  return propagate v  d  c 

figure     does the triple fan  occur in every supertree that displays the trees in f  
minimal in the sense that the removal of any element from this set will not constitute a
sound explanation  and the addition of any constraint would be redundant  when the set of
constraints are input triples and fans  this minimal set is semantically a collection of input
data that is incompatible  junker        state that this method can be achieved by a worst
case of  k  log   n k     k propagations    where k is the size of the minimal explanation
found and n is the number of constraints 
an alternative approach is to satisfy as many of the input triples and fans as is possible
within a reasonable amount of time  i e   polynomial time  semple and steel propose such
an algorithm  mincutsupertree         and this has been refined by page         we
now propose a similar scheme within the constraint programming framework  we call
this algorithm greedybuild and it works as follows  we associate a constrained integer
variable x  with a domain of         to each triple and fan  if the variable is assigned the
value   then the triple  or fan  is respected  otherwise it is ignored  therefore for a triple
 ij k we post the constraint of equation    and for a   fan  ijk  the constraint of equation
   

 x      mij   mik   mjk     x       mik    mjk  mij  mik  mij  mik   

    

 x      mij   mik   mjk     x       mij    mik  mij    mjk  mik    mjk   

    

greedybuild then instantiates in turn each of the x variables  i e  the decision variables 
preferring the value   to the value    and after each instantiation the problem is made arcconsistent  the algorithm is shown in figure     in line   a constraint model is produced 
i e   an n  n symmetric array of constrained integers variables is created  where there are n
unique species in the forest  and the um matrix bcz constraint is then posted over those
variables  the variable x of line   is then the set of decision variables  the input trees
are broken up as before  and a new variable x is created for each triple or fan  in line
  the constraints of equations    and    are posted into the model  the loop of lines   
to    in turn select a decision variable  set it to its lowest possible value  and then make
the problem arc consistent  this might in turn cause uninstantiated variables to have the
value   removed from their domain if their associated triple or fan conflicts with the triple
   our bc z  propagator is o     however  so the time complexity is the same as the number of
propagations 

   

fithe ultrametric constraint and phylogenetics

algorithm greedybuild
greedybuild f  
 
let  v  d  c   cpmodel f  
 
let x  
 
for t  f do
 
for t  breakup t   do
 
let x  newv ar      
 
let c  newconstraint  t  x        t  x      
 
x  x   x 
 
v  v   x 
 
c  post c  c 
   for x  x do
  
instantiate x 
  
propagate v  d  c 
   return umtotree v  d 

figure     greedily build a supertree from forest f using the ultrametric constraint model 

or fan that has just been enforced  this process terminates without failure  because any
conflicting triples or fans are essentially ignored  in line    the ultrametric matrix is then
converted to a tree  the complexity of greedybuild is then o  t   f    n    where there
are t triples and f fans 
greedybuild was applied to the forest of bird data  a  b  c  d  e  f  g  from section    using a soft breakup  this data is incompatible when we use cpbuild  however
greedybuild produces the supertree in figure     this supertree contains     species 
softbreakup produced     triples  and of those    were rejected  it took less than  
seconds to build the model and about     seconds to solve that model  this should be
compared to cpbuild over the same data set  taking     seconds to build the model and
   seconds to determine incompatibility  greedybuild was also applied to the data set
abdf  producing the identical supertree to cpbuild  in comparable time     ms to build
the model and    ms to solve  
having executed greedybuild the decision variables in the set x  lines          and
    can be analysed to identify the set of triples and fans that have been excluded from the
supertree  i e   if an x variable has been instantiated with the value   then its corresponding
triple or fan has been ignored 
note that we do not claim any biological significance in the arbitrary order we use
to suppress triples  greedybuild could be amended to follow the order of mincutsupertree but we have not investigated this  greedybuild can also be enhanced as
follows  currently if a triple or fan exists in multiple input trees then it occurs only once
as a constraint  this information could be exploited by weighting the decision variables to
take into consideration the relative weight of evidence for a triple or fan  e g   the number of
times that a triple or fan occurs as input  the decision variables can then be instantiated
in non increasing order of weight  i e   a variable ordering heuristic can be used  in the
extreme greedybuild can be modified to become optbuild where a full backtracking
search is performed with the objective of minimising the sum of the decision variables  but
   

fimoore   prosser

figure     supertree with largest data set of birds  abcdefg  with     species  this
took about   seconds to model and     seconds to solve using greedybuild 
displayed using rod pages treeview 

   

fithe ultrametric constraint and phylogenetics

at a potentially exponential cost in time  this would return the tree with the fewest possible
input triples suppressed 
    summary
with little effort  the constraint model has been adapted to deal with ancestral divergence
dates and nested taxa  both have been achieved by adding side constraints  this has an
added advantage with respect to ancestral divergence as it can result in a more compact
enumeration of output trees when interior nodes are labelled with ranges rather than specific
values 
when input trees conflict we propose two options  use quickxplain to determine the
cause of that conflict or greedily build a supertree using greedybuild  bryant et al        
state that they have essentially an all or nothing approach to supertree construction when
using rankedtree and what is needed is something akin to mincutsupertree  i e 
when trees are incompatible build a supertree that violates the minimum number of triples
or fans  and do this in polynomial time  page        semple   steel         this has since
been done by bordewich et al         and can also be done in our constraint model by
incorporating the constraints identified in section     into greedybuild 
although not shown  it is obvious that ancestral divergence data and nested taxa can
be combined in the one model  simply by adding all the necessary constraint and auxiliary
variables for both variants into the one model  this  again  could be done in greedybuild 
but would require some heuristic or rule to be used when deciding what constraints to ignore
when the input trees and side constraints are incompatible 
in our opinion  deriving  combining and analysing the results of imperative algorithms
for supertree problems is much more difficult than the above  most algorithms for variants
required far more complex data structures and tailored algorithms for processing them 
moreover  to combine the algorithms once produced seems practically impossible on account
of their intricacy  finally constraint programming provides various generic methods like
quickxplain out of the box that turn out to be of interest in supertree problems 

   conclusion
we have presented a new constraint propagator for the ultrametric constraint over three
integer variables  and shown how this can be extended to a symmetric matrix of constrained
integer variables  when bounds z  consistency is established on the symmetric array the
lower bounds of variables give mutual support  this is sufficient for modelling and solving
the supertree construction problem in o n    time and o n    space  comparable to the complexity of onetree  ng   wormald        but inferior to that of the algorithm of bryant
and steel         so  why bother with the cpbuild approach when efficient imperative
approaches already exist  the answer lies in the versatility of constraint programming 
rather than develop a new algorithm for a new variant of the supertree problem we add
side constraints to a base model  and we have shown that a polynomial time bound can
often be achieved  we have done this for ancestral divergence dates and nested taxa  we
have shown how our model can be used to deliver necessary triples and fans  and we have
proposed greedybuild as a way of dealing with incompatible trees 
   

fimoore   prosser

acknowledgments
we would like to thank pierre flener and xavier lorca  barbara smith  ian gent and christine wei wu  charles semple  mike steel and rod page  muffy calder and joe sventek 
stanislav zivny  chris unsworth  and our three anonymous reviewers co authors 

references
aho  a   sagiv  y   szymanski  t     ullman  j          inferring a tree from lowest
common ancestors with an application to the optimization of relational expressions 
siam j  comput                 
beldiceanu  n   flener  p     lorca  x          combining tree partitioning  precedence 
and incompatibility constraints  constraints          
bessiere  c     regin  j  c          refining the basic constraint propagation algorithm 
in ijcai  pp         
bessiere  c          constraint propagation  in handbook of constraint programming  elsevier  chapter   
bininda emonds  o          phylogenetic supertrees  combining information to reveal the
tree of life  springer 
bordewich  m   evans  g     semple  c          extending the limits of supertree methods 
annals of combinatorics           
bryant  d     steel  m          extension operations on sets of leaf labeled trees  advances in applied mathematics             
bryant  d   semple  c     steel  m          supertree methods for ancestral divergence
dates and other applications  in bininda emonds  o   ed    phylogenetic supertrees 
combining information to reveal the tree of life  pp          computational biology
series kluwer 
carlier  j     pinson  e          adjustment of heads and tails for the jobshop scheduling
problem  european journal of operational research             
caseau  y     laburthe  f          solving small tsps with constraints  in proceedings
international conference on logic programming  pp      
choco         http   www choco constraints net  home of the choco constraint programming system  
daniel  p          supertree methods  some new approaches  masters thesis  department
of mathematics and statistics  university of canterbury 
daniel  p     semple  c          supertree algorithms for nested taxa  in bininda emonds 
o   ed    phylogenetic supertrees  combining information to reveal the tree of life 
pp          computational biology series kluwer 
   

fithe ultrametric constraint and phylogenetics

dawkins  r     wong  y          the ancestors tale  weidenfeld and nicholson 
debruyne  r     bessiere  c          some practicable filtering techniques for the constraint
satisfaction problem  in proceedings of ijcai    pp         
dooms  g          the cp graph  computation domain in constraint programming 
ph d  thesis  universite catholique de louvain  faculte des sciences appliquees 
gent  i   prosser  p   smith  b     wei  w          supertree construction with constraint
programming  in principles and practice of constraint programming  pp         
springer 
gusfield  d          algorithms on strings  trees  and sequences  computer science and
computational biology  cambridge university press  new york  ny  usa 
janczewski  d   modi  w   stephens  j     obrien  s          molecular evolution of
mitochondrial   s rna and cytochrome b sequences in the pantherine lineage of
felidae  mol  biol  evol              
jeavons  p  g     cooper  m  c          tractable constraints on ordered domains  artif 
intell                  
junker  u          quickxplain  preferred explanations and relaxations for overconstrained problems  in proceedings aaai      pp         
kennedy  m     page  r          seabird supertrees  combining partial estimates of procellariiform phylogeny  the auk            
lhomme  o          an efficient filtering algorithm for disjunction of constraints  in
principles and practice of constraint programming  pp          springer 
mace  g  m   gittleman  j  l     purvis  a          preserving the tree of life  science 
              
mackworth  a          consistency in networks of relations  artificial intelligence    
      
ng  m  p     wormald  n  c          reconstruction of rooted trees from subtrees  discrete
appl  math                  
page  r          treeview  an application to display phylogenetic trees on personal
computers  computer applications in the biosciences             
page  r          taxonomy  supertrees  and the tree of life  in bininda emonds  o   ed   
phylogenetic supertrees  combining information to reveal the tree of life  pp         
computational biology series kluwer 
page  r  d  m          modified mincut supertrees  in wabi     proceedings of the second
international workshop on algorithms in bioinformatics  pp         london  uk 
springer verlag 
   

fimoore   prosser

pennisi  e          modernizing the tree of life  science                
prosser  p          supertree construction with constraint programming  recent progress
and new challenges  in wcb     workshop on constraint based methods for bioinformatics  pp       
prosser  p     unsworth  c          rooted tree and spanning tree constraints  in   th
ecai workshop on modelling and solving problems with constraints 
regin  j  c          a filtering algorithm for constraints of difference in csps  in proceedings aaai    pp         
rossi  f   van beek  p     walsh  t          handbook of constraint programming  elsevier 
sabin  d     freuder  e          contradicting conventional wisdom in constraint satisfaction  in proceedings of ecai     pp         
schulte  c     carlsson  m          finite domain constraint programming systems  in
handbook of constraint programming  elsevier  chapter    
semple  c   daniel  p   hordijk  w   page  r     steel  m          supertree algorithms for
ancestral divergence dates and nested taxa  bioinformatics                    
semple  c     steel  m          a supertree method for rooted trees  discrete appl  math  
                  
smith  b  m          a tutorial on constraint programming  technical report       
university of leeds 
treebase         http   www treebase org  treebase  a database of phylogenetic knowledge  
tsang  e          foundations of constraint satisfaction  academic press 
van hentenryck  p   deville  y     teng  c  m          a generic arc consistency algorithm
and its specializations  artificial intelligence             
van hentenryck  p   saraswat  v     deville  y          design  implementation  and
evaluation of the constraint language cc fd   journal of logic programming         
    
wu  g   you  j  h     lin  g          quartet based phylogeny reconstruction with answer
set programming  ieee acm transactions on computational biology and bioinformatics            
yuanlin  z     yap  r  h  c          making ac   an optimal algorithm  in ijcai  pp 
       

   

fi