journal of artificial intelligence research          

submitted        published      

m dpop  faithful distributed implementation of
efficient social choice problems
adrian petcu
boi faltings

adrian   petcu   epfl   ch
boi   faltings   epfl   ch

artificial intelligence lab  ecole polytechnique federale de lausanne 
station          lausanne  switzerland

david c  parkes

parkes   eecs   harvard   edu

school of engineering and applied sciences  harvard university
   oxford street  cambridge  ma       usa

abstract
in the efficient social choice problem  the goal is to assign values  subject to side constraints  to
a set of variables to maximize the total utility across a population of agents  where each agent has
private information about its utility function  in this paper we model the social choice problem as
a distributed constraint optimization problem  dcop   in which each agent can communicate with
other agents that share an interest in one or more variables  whereas existing dcop algorithms
can be easily manipulated by an agent  either by misreporting private information or deviating from
the algorithm  we introduce m dpop  the first dcop algorithm that provides a faithful distributed
implementation for efficient social choice  this provides a concrete example of how the methods of
mechanism design can be unified with those of distributed optimization  faithfulness ensures that
no agent can benefit by unilaterally deviating from any aspect of the protocol  neither informationrevelation  computation  nor communication  and whatever the private information of other agents 
we allow for payments by agents to a central bank  which is the only central authority that we
require  to achieve faithfulness  we carefully integrate the vickrey clarke groves  vcg  mechanism with the dpop algorithm  such that each agent is only asked to perform computation  report
information  and send messages that is in its own best interest  determining agent is payment
requires solving the social choice problem without agent i  here  we present a method to reuse
computation performed in solving the main problem in a way that is robust against manipulation
by the excluded agent  experimental results on structured problems show that as much as     of
the computation required for solving the marginal problems can be avoided by re use  providing
very good scalability in the number of agents  on unstructured problems  we observe a sensitivity
of m dpop to the density of the problem  and we show that reusability decreases from almost
     for very sparse problems to around     for highly connected problems  we close with a discussion of the features of dcop that enable faithful implementations in this problem  the challenge
of reusing computation from the main problem to marginal problems in other algorithms such as
adopt and optapo  and the prospect of methods to avoid the welfare loss that can occur because
of the transfer of payments to the bank 

   introduction
distributed optimization problems can model environments where a set of agents must agree on a
set of decisions subject to side constraints  we consider settings in which each agent has its own
preferences on subsets of these decisions  the agents are self interested  and each one would like to
obtain the decision that maximizes its own utility  however  the system as whole agrees  or some
social designer determines  that a solution should be selected to maximize the total utility across all
c
    
ai access foundation  all rights reserved 

fip etcu   faltings     parkes

agents  thus  this is a problem of efficient social choice  as motivation  we have in mind massively
distributed problems such as meeting scheduling  where the decisions are about when and where
to hold each meeting  or allocating airport landing slots to airlines  where the decisions are what
airline is allocated what slot  or scheduling contractors in construction projects 
one approach to solve such problems is with a central authority that computes the optimal solution  in combination with an incentive mechanism such as the vickrey clarke groves  vcg 
mechanism  jackson         we can also prevent manipulation through the misreporting of preferences  however  in many practical settings it is hard to bound the problem so that such a central
authority is feasible  consider meeting scheduling  while each agent only participates in a few
meetings  it is in general not possible to find a set of meetings that has no further constraints with
any other meetings and thus can be optimized separately  similarly  contractors in a construction
project simultaneously work on other projects  again creating an web of dependencies that is hard to
optimize in a centralized fashion  privacy concerns also favor decentralized solutions  greenstadt 
pearce    tambe        
algorithms for distributed constraint reasoning  such as abt and awc  yokoo   hirayama 
       aas  silaghi  sam haroud    faltings         dpop  petcu   faltings      b  and
adopt  modi  shen  tambe    yokoo         can deal with large problems as long as the influence of each agent on the solution is limited to a bounded number of variables  however  the
current techniques assume cooperative agents  and do not provide robustness against misreports of
preferences of deviations from the algorithm by self interested agents  this is a major limitation  in
recent years  faithful distributed implementation  parkes   shneidman        has been proposed as
a framework within which to achieve a synthesis of the methods of  centralized  md with distributed
problem solving  faithfulness ensures that no agent can benefit by unilaterally deviating from any
aspect of the protocol  neither information revelation  computation  nor communication  and whatever the private information of other agents  until now  distributed implementation has been applied
to lowest cost routing  shneidman   parkes        feigenbaum  papadimitriou  sami    shenker 
       and policy based routing  feigenbaum  ramachandran    schapira         on the internet 
but not to efficient social choice  a problem with broad applicability 
in this paper  we make the following contributions 
 we show how to model the problem of efficient social choice as a dcop  and adapt the
dpop algorithm to exploit the local structure of the distributed model and achieve the same
scalability as would be possible in solving the problem on a centralized problem graph 
 we provide an algorithm whose first stage is to faithfully generate the dcop representation
from the underlying social choice problem  once the dcop representation is generated  the
next stages of our m dpop algorithm are also faithful  and form an ex post nash equilibrium
of the induced non cooperative game 
 in establishing that dcop models of social choice problems can be solved faithfully  we
observe that the communication and information structure in the problem are such that no
agent can prevent the rest of the system  in aggregate  from correctly determining the marginal
impact that allowing for the agents  reported  preferences has on the total utility achieved by
the other agents  this provides the generality of our techniques to other dcop algorithms 
 part of achieving faithfulness requires solving the dcop with each agents  reported  preferences ignored in turn  and doing so without this agent able to interfere with this computational
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

process  we provide an algorithm with this robustness property  that is nevertheless able to
reuse  where possible  intermediate results of computation from solving the main problem
with all agents 
 in experimental analysis  on structured meeting scheduling problems that are a common
benchmark in the literature  we demonstrate that as much as     of the computation required
for solving the marginal problems can be avoided through reuse  results are also provided for
unstructured resource allocation problems     and show m dpop to be sensitive to problem
density  for loose problems  up to around     of the computation can be reused  and this
decreases for highly connected problems 
the m dpop algorithm defines a strategy for each agent in the extensive form game induced by
the dcop for efficient social choice  in particular  the m dpop algorithm defines the messages that
an agent should send  and the computation that an agent should perform  in response to messages
received from other agents  in proving that m dpop forms a game theoretic equilibrium  we show
that no agent can benefit by unilaterally deviating  whatever the utility functions of other agents and
whatever the constraints  although not as robust as a dominant strategy equilibrium  because this  ex
post  equilibrium requires every other agent to follow the algorithm  parkes and shneidman       
have earlier commented that this appears to be the necessary cost of decentralization 
the total payment made by each agent to the bank is always non negative and m dpop never
runs at a deficit  i e  the bank always receives a non negative net payment from the agents   in some
settings  this transfer of utility to the bank is undesirable and would be best avoided  we provide
some statistics for the problem domains studied that show that this loss can represent as much as
    of the total utility achieved from the solution in some problems studied  while the payments
cannot be naively redistributed back to agents without breaking faithfulness  extant work on redistribution mechanisms for vcg payments suggests that this can be mitigated  guo   conitzer       
faltings        cavallo        moulin        bailey         we defer this extension to m dpop 
the details of which are surprisingly involved and interesting in their own right  to future work 
the reuse of computation  in solving the marginal problems with each agent removed in turn  is
especially important in settings of distributed optimization because motivating scenarios are those
for which the problem size is massive  perhaps spanning multiple organizations and encompassing
thousands of decisions  for example  consider project scheduling  inter firm logistics  intra firm
meeting scheduling  etc  with appropriate problem structure  dcop algorithms in these problems
can scale linearly in the size of the problem  for instance  dpop is able to solve such problems
through a single back and forth traversal over the problem graph  but without re use the additional
cost of solving each marginal problem would make the computational cost quadratic rather than
linear in the number of agents  which could be untenable in such massive scale applications 
the rest of this paper is organized as follows  after preliminaries  section     in section   we
describe the dpop  petcu   faltings      b  algorithm for distributed constraint optimization 
which is the focus of our study  section   introduces our model of self interested agents and defines
the  centralized  vcg mechanism  section     provides a simple method  simple m dpop to make
dpop faithful and serves to illustrate the excellent fit between the information and communication
structure of dcops and faithful vcg mechanisms  in section   we describe our main algorithm  mdpop  in which computation is re used in solving the marginal problems with each agent removed
   we consider distributed combinatorial auctions  with instances randomly generated using a distribution in the cats
problem suite  leyton brown   shoham        

   

fip etcu   faltings     parkes

in turn  we present experimental results in section    in section   we discuss adapting other dcop
algorithms for social choice  adopt and optapo  see section       and about the waste due to
payments in section      we conclude in section   
    related work
this work draws on two research areas  distributed algorithms for constraint satisfaction and optimization  and mechanism design for coordinated decision making in multi agent systems with
self interested agents  we briefly overview the most relevant results in these areas 
      c onstraint s atisfaction

and

o ptimization

constraint satisfaction and optimization are powerful paradigms that can model a wide range of
tasks like scheduling  planning  optimal process control  etc  traditionally  such problems were
gathered into a single place  and a centralized algorithm was applied to find a solution  however 
social choice problems are naturally distributed  and often preclude the use of a centralized entity to
gather information and compute solutions 
the distributed constraint satisfaction  discsp   yokoo  durfee  ishida    kuwabara       
sycara  roth  sadeh koniecpol    fox        collin  dechter    katz              solotorevsky 
gudes    meisels        and the distributed constraint optimization  dcop   modi et al        
zhang   wittenburg        petcu   faltings      b  gershman  meisels    zivan        formalisms were introduced to enable distributed solutions  the agents involved in such problems
must communicate with each other to find a solution to the overall problem  unknown to any one
of them   briefly  these problems consist of individual subproblems  each agent holds its own subproblem   which are connected with  some of  its peers subproblems via constraints that limit what
each individual agent can do  the goal is to find feasible solutions to the overall problem  in the
case of discsp   or optimal ones in the case of dcop 
many distributed algorithms for dcop have been introduced  none of which deals with selfinterested agents  the most well known ones are adopt  dpop and optapo 
 adopt  modi et al         is a backtracking based  bound propagation algorithm  adopt
is completely decentralized and message passing is asynchronous  while adopt has the
advantage of requiring linear memory  and linear size messages  its applicability for large
problems   is questionable due to the fact that it produces a number of messages which is
exponential in the depth of the dfs tree chosen 
 optapo  mailler   lesser        is a centralized distributed hybrid that uses mediator nodes
to centralize subproblems and solve them in dynamic and asynchronous mediation sessions 
the authors show that its message complexity is significantly smaller than adopts  however  it is designed for cooperative settings  and in settings with self interested agents like the
social choice problem  it is unclear whether agents would agree revealing their constraints
and utility functions to  possibly many  other agents  such that they can solve the partially
centralized subproblems 
 dpop  petcu   faltings      b  is a complete algorithm based on dynamic programming
which generates only a linear number of messages  in dpop  the size of the messages depends
   the largest adopt experiments that we are aware of comprise problems with around    agents and    variables 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

on the structure of the problem  the largest message is exponential in the induced width of
the problem  see section        as with adopt  dpop maintains the full distribution of the
problem  these features suggest that dpop is a good foundation for an efficient distributed
implementation of a vcg based mechanism for social choice problems 
a further discussion about the features of these algorithms and their applicability to social choice
problems is provided in section    in this paper  we will focus on dpop and provide appropriate
modifications and payments so that it can be effective for environments with self interested agents 
in section     we will also provide a brief discussion about the opportunites and challenges in
applying our methodology to adopt and optapo 
      m echanism d esign

and

d istributed i mplementation

there is a long tradition of using centralized incentive mechanisms within distributed ai  going
back at least to the work of ephrati and rosenschein        who considered the use of the vcg
mechanism to compute joint plans  see also the work of sandholm        and parkes et al        
for more recent discussions  also noteworthy is the work of rosenschein and zlotkin             
on rules of encounter  which provided non vcg based approaches for task allocation in systems
with two agents 
on the other hand  there are very few known methods for distributed problem solving in the
presence of self interested agents  for example  while t raco n et  sandholm        improved
upon the c ontract n et system  davis   smith        of negotiation based  distributed task reallocation  by providing better economic realism  t raco n et was nevertheless studied for simple 
myopically rational agent behaviors and its performance with game theoretic agents was never analyzed  this remains true for more recent works  endriss  maudet  sadri    toni        dunne 
wooldridge    laurence        dunne         similarly  wellmans work on market oriented programming  wellman              considers the role of virtual markets in the support of optimal
resource allocation  but is developed for a model of price taking agents  i e  agents that treat
current prices as though they are final   rather than game theoretic agents 
the first step in providing a more satisfactory synthesis of distributed algorithms with md was
provided by the agenda of distributed algorithmic mechanism design  damd   due to the work
of feigenbaum and colleagues  feigenbaum et al         feigenbaum   shenker         these
authors  fpss  provided an efficient algorithm for lowest cost interdomain routing on the internet 
terminating with optimal routes and the payments of the vcg mechanism  the up shot was that
agents in this case autonomous systems running network domains could not benefit by misreporting information about their own transit costs  but missing from this analysis was any consideration
about the robustness of the algorithm itself to manipulation  distributed implementation  parkes
  shneidman        introduces this additional requirement  an algorithm is faithful if an agent
cannot benefit by deviating from any of its required actions  including information revelation  computation and message passing  a number of principles for achieving faithfulness in an ex post nash
equilibrium are provided by parkes and shneidman         by careful incentive design and a small
amount of cryptography they are able to remove the remaining opportunities for manipulation from
the lowest cost routing algorithm of fpss  building on this  feigenbaum et al         recently provide a faithful method for policy based interdomain routing  better capturing the typical business
agreements between internet domains 
   

fip etcu   faltings     parkes

ours is the first work to achieve faithfulness for general dcop algorithms  demonstrated here
via application to efficient social choice  in other work  monderer and tennenholtz        consider a distributed single item allocation problem  but focus on  faithful  communication and do
not provide distributed computation  izmalkov et al         adopt cryptographic primitives such
as ballot boxes to show how to convert any centralized mechanisms into a di on a fully connected
communication graph  there interest is in demonstrating the theoretical possibility of ideal mechanism design without a trusted center  our work has a very different focus  we seek computational
tractability  do not require fully connected communication graphs  and make no appeal to cryptographic primitives  on the other hand  we are content to retain desired behavior in some equilibrium
 remaining consistent with the md literature  while izmalkov et al  avoid the introduction of any
additional equilibria beyond those that exist in a centralized mechanism 
we briefly mention two other related topics  of note is the well established literature on iterative
vcg mechaisms  mishra   parkes        ausubel  cramton    milgrom        bikhchandani 
de vries  schummer    vohra         these provide a partially distributed implementation for
combinatorial allocation problems  with the center typically issuing demand queries of agents
via prices  these prices triggering computation on the part of agents in generating a demand set in
response  these auctions can often be interpreted as decentralized primal dual algorithms  parkes
  ungar        de vries   vohra         the setting differs from ours in that there remains a center
that performs computation  solving a winner determination problem in each round  and each agent
communicates directly with the center and not peer to peer  mualem        initiates an orthogonal
direction within computer science related to the topic of nash implementation  jackson        in
economics  but her approach relies on information that is part private and part common knowledge 
so that no one agent has entirely private information about its preferences 

   preliminaries  modeling social choice
we assume that the social choice problem consists of a finite but possibly large number of decisions
that all have to be made at the same time  each decision is modeled as a variable that can take
values in a discrete and finite domain  each agent has private information about the variables on
which it places relations  each relation associated with an agent defines the utility of that agent for
each possible assignment of values to the variables in the domain of the relation  there may also be
hard constraints that restrict the space of feasible joint assignments to subsets of variables 
definition    social choice problem   scp  an efficient social choice problem can be modeled as
a tuple   a  x   d  c  r   such that 
 x    x         xm   is the set of public decision variables  e g  when and where to hold
meetings  to whom should resources be allocated  etc  
 d    d         dm   is the set of finite public domains of the variables x  e g  list of possible
time slots or venues  list of agents eligible to receive a resource  etc  
 c    c         cq   is a set of public constraints that specify the feasible combinations of values
of the variables involved  a constraint cj is a function cj   dj       djk       
that returns   for all allowed combinations of values of the involved variables  and  for
disallowed ones  we denote by scope cj   the set of variables associated with constraint cj  
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

 a    a         an   is a set of self interested agents involved in the optimization problem 
x ai    x is a  privately known    set of variables in which agent ai is interested and
on which it has relations 
 r    r         rn   is a set of private relations  where ri is the set of relations specified by
agent ai and relation rij  ri is a function rij   dj       djk  r specified by agent
ai   which denotes the utility ai receives for all possible values on the involved variables
 j            jk    negative values mean costs   we denote by scope rij   the domain of variables
that rij is defined on 
the private relations of each agent may  themselves  be induced by the solution to local optimization problems on additional  private decision variables and with additional  private constraints 
these are kept local to an agent and not part of the scp definition 
the optimal solution to the scp is a complete instantiation x  of all variables in x   s t 
x
x
ri  x   
cj  x  
   
x   arg max
xd

i      n 

cj c

rj  x  is agent ai s total utility for assignment x  this is the natural
where ri  x   
rij ri i
problem of social choice  the goal is to find a solution that maximizes the total utility of all agents 
while respecting hard constraints  notice that the second sum is  if x is infeasible and precludes
this outcome  we assume throughout that there is a feasible solution  in introducing the vcg
mechanism we will require the solution to the scp with the influence of each agents relations
removed in turn  for this  let scp  a  denote the main problem
in eq     
pand scp  ai   denote
p
the marginal problem without agent ai   i e  maxxd j  i rj  x    cj c cj  x   note that
all decision variables remain  the only difference between scp  a  and scp  ai   is that the
preferences of agent ai are ignored in solving scp  ai   
for variable xj   refer to the agents ai for which xj  x ai   as forming the community for
xj   we choose to emphasize the following assumptions 
p

 each agent knows the variables in which it is interested  together with the domain of any such
variable and the hard constraints that involve the variable 
 each decision variable is supported by a community mechanism that allows all interested
agents to report their interest and learn about each other  for example  such a mechanism can
be implemented using a bulletin board 
 for each constraint cj  c  every agent ak in a community xl  scope cj    i e  with
xl  x ak    can read the membership lists of all other communities xm  scope cj   for
xm    xl   in other words  every agent involved in a hard constraint knows about all other
agents involved in that hard constraint 
 each agent can communicate directly with all agents in all communities in which it is a
member  and with all other agents involved in the same shared hard constraints  no other
communication between agents is required 
   note that the private knowledge of variables of interest is not a requirement  the algorithms we present work with
both public and private knowledge of variables of interest  what is required is that agents interested in the same
variable know about each other   see assumptions below 

   

fip etcu   faltings     parkes

figure    an operator placement problem   a  a centralized model  each variable is a server load possible
values are feasible combinations of services to be run by each server   and the edges correspond
to relations and represent agent preferences    b  a decentralized  dcop  model with replicated
variables  each agent has a local replica of variables of interest and inter agent edges denote
equality constraints that ensure agreement  the preferences modeled by relations are now hyperedges local to the respective agents 

in section   we will establish that the step of identifying the scp  via the community mechanism  is itself faithful so that self interested agents will choose to volunteer the communities of
which they are a member  and only those communities  
    modeling social choice as constraint optimization
we first introduce a centralized  constraint optimization problem  cop  model of the efficient social choice problem  this model is represented as a centralized problem graph  given this  we
then model this as a distributed constraint optimization problem  dcop   along with an associated
distributed problem graph  the distributed problem graph makes explicit the control structure of
the distributed algorithm that is ultimately used by the multi agent system to solve the problem 
both sections are illustrated by reference to an overlay network optimization problem  huebsch 
hellerstein  lanham  et al         faltings  parkes  petcu    shneidman        pietzuch  ledlie 
shneidman  roussopoulos  welsh    seltzer        
overlay n etwork o ptimization consider the problem of optimal placement of data aggregation and processing operators on an overlay network such as a large scale sensor network  huebsch
et al         pietzuch et al          in this application  there are multiple users and multiple servers 
each user is associated with a query and has a client machine located at a particular node on an
overlay network  a query has an associated set of data producers  known to the user and located
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

at nodes on the network  each query also requires a set of data aggregation and processing operators  which should be placed on server nodes between the nodes with data producers and the
users node  each user assigns a utility to different assignments of operators to servers to represent her preferences for different kinds of data aggregation  examples of in network operators for
data aggregation include database style join operators  e g   a user may desire volcano data x
and earthquake data y joined and sent to them  to address this  a specific operator that we call
volcanoxearthquakey join is created and put into the network  naturally  each user prefers to
have their operators placed on the best servers in the network  without regard to the costs incurred  overloading servers  denying service to other users  etc  the problem is to find the optimal
allocation of operators to servers  subject to capacity and compatibility constraints 
faltings et al         model this problem as one of efficient social choice  a distributed algorithm  to be executed by user clients situated on network nodes  is used to determine the assignment
of data aggregation and processing operators to server nodes 
      a c entralized cop m odel as a m ulti g raph
viewed as a centralized problem  the scp can be defined as a constraint optimization problem on a
multigraph  i e  a graph in which several distinct edges can connect the same set of nodes  we denote
this cop  a   and provide an illustration in figure   a   the decision variables are the nodes  and
relations defined over subsets of the variables form edges of the multigraph  hyperedges that connect
more than two vertices at once in the case of a relation involving more than two variables  there
can be multiple edges that involve the same set of variables  with each edge corresponding to the
relations of a distinct agent on the same set of variables  the hard constraints are also be represented
as edges on the graph 
example    centralized model for overlay optimization  the example in figure   a  contains
  users ai and   servers sj   for simplicity reasons  assume that each user ai has one single operator oi that they want to have executed on some server  according to prerequisites and compatibility
issues  assume that s  can execute both o  and o    but not o    similarly  assume that s  can execute
both o  and o    but not o    and s  can execute any combination of at most two out of the three operators  agents have preferences about where their operators are executed  e g  because of proximity
to data sources  computational capabilities of the servers  cost of electricity  etc   for example  a 
extracts utility    when o  is executed by s    and utility   when o  is executed by s   
to model the problem as an optimization problem  we use the following 
   variables  for each server si   we create a variable si that denotes the set of operators that si
will execute 
   values  each variable si can take values from the set of all possible combinations of operators
the server can execute  for example  s     null  o    o    o    o     where null means the
server executes no operator  oi that it executes operator oi   and o    o  that it executes both
o  and o   
   constraints  restrict the possible combinations of assignments  example  no two servers
should execute the same operator 
   relations  allow agents to express preferences about combinations of assignments  a  models
its preference for the placement of o  by using the relation r     defined over the variables s 
   

fip etcu   faltings     parkes

and s    this relation associates an utility value to each combination of assignments to s 
and s   in total           combinations  as follows 
   to all combinations where o  is executed neither on s    or on s   e g  hs    o    s   
o  i 
    to all combinations where o  is executed only on s   e g  hs    o    s    o    o  i 
   to all combinations where o  is executed only on s   e g  hs    o    s    o  i 
we depict variables as nodes in a graph  and constraints and relations as  hyper edges  see
figure   a    the problem can get arbitrarily complex  with multiple operators per agent  groups of
servers being able to execute only certain groups of compatible operators  etc 
      a d ecentralized cop  dcop  m odel u sing r eplicated variables
it is useful to define an alternate graphical representation of the scp  with the centralized problem
graph replaced with a distributed problem graph  this distributed problem graph has a direct correspondence with the dpop algorithm for solving dcops  we denote by dcop  a  the problem
with all agents included  which corresponds to the main social choice problem  scp  a   similarly 
dcop  ai   is the problem with agent ai removed  which corresponds to scp  ai    in our
distributed model  each agent has a local replica of the variables in which it is interested   for each
public variable  xv  x ai    in which agent ai is interested  the agent has a local replica  denoted
xvi   agent ai then models its local problem cop  x ai    ri    by specifying its relations rij  ri
on the locally replicated variables 
refer to figure   b  for the translation of the centralized problem from figure   a  into a dcop
model  each agent has as local variables the loads of the servers that are of interest to itself  i e 
servers that can execute one of its operators  e g  s   represents a  s local replica of the variable
representing server s     local edges correspond to local all different constraints between an agents
variables and ensure that it does not execute its operator on several servers at the same time  equality
constraints between local replicas of the same value ensure global agreement about what operators
will run on which servers 
agents specify their relations via local edges on local replicas  for example  agent a  with
its relation on the load of servers s  and s  can now express a preference for the placement of its
operator o  with relation r     which can assign e g  utility   to s  executing o    and utility    to s 
executing o   
we can begin to understand the potential for manipulation by self interested agents through this
example  notice that although the globally optimal solution may require assigning o  to s    this is
less preferable to a    providing utility   instead of     therefore  in the absence of an incentive
mechanism  a  could benefit from a simple manipulation  declare utility   for hs    o  i  thus
changing the final assignment to a suboptimal one that is nevertheless better for itself 
   an alternate model designates an owner agent for each decision variable  each owner agent would then centralize
and aggregate the preferences of other agents interested in its variable  subsequently  the owner agents would use a
distributed optimization algorithm to find the optimal solution  this model limits the reusability of computation from
the main problem in solving the marginal problems in which each agent is removed in turn because when excluding
the owner agent of a variable  one needs to assign ownership to another agent and restart the computational process
in regards to this variable and other connected variables  this reuse of computation is important in making m dpop
scalable  our approach is disaggregated and facilitates greater reuse 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

the neighborhood of each local copy xvi of a variable is composed of three kinds of variables 
neighbors xvi     siblings xvi    local neighbors xvi    hard neighbors xvi   

   

the siblings are local copies of xv that belong to other agents aj    ai also interested in xv  
siblings xvi      xvj   aj    ai and xv  x aj   

   

all siblings of xvi are connected pairwise with an equality constraint  this ensures that all
agents eventually have a consistent value for each variable  the second set of variables are the
local neighbors of xvi from the local optimization problem of ai   these are the local copies of the
other variables that agent ai is interested in  which are connected to xvi via relations in ai s local
problem 
local neighbors xvi      xui   xu  x ai    and rij  ri s t  xui  scope ri   

   

we must also consider the set of hard constraints that contain in their scope the variable xv and
some other public variables  hard  xv      cs  c xv  scope cs     these constraints connect
xv with all the other variables xu that appear in their scope  which may be of interest to some
other agents as well  consequently  xvi should be connected with all local copies xtj of the other
variables xt that appear in these hard constraints 
hard neighbors xvi      xtj  cs  hard  xv   s t  xt  scope cs    and xt  x aj   

   

in general  each agent can also have private variables  and relations or constraints that involve
private variables  and link them to the public decision variables  for example  consider a meeting
scheduling application for employees of a company  apart from the work related meetings they
schedule together  each one of the employees also has personal items on her agenda  like appointments to the doctor  etc  decisions about the values for private variables and information about
these local relations and constraints remain private  these provide no additional complications and
will not be discussed further in the paper 
    example social choice problems
before continuing to present our main results we describe three additional problems of social choice
that serve to motivate our work  in fact  the problem of efficient social choice is fundamental to
microeconomics and political science  mas colell  whinston    green         each problem that
we present is both large scale and distributed  and involves actors in the system that are businesses
and cannot be expected to cooperate  either in revealing their preferences or in following the rules
of a distributed algorithm 
a irport s lot a llocation   as airports become more congested  governments are turning to
market based approaches to allocate landing and takeoff slots  for instance  the u s  federal aviation administration recently commisioned a study on the use of an auction to allocate slots at
new yorks congested laguardia airport  ball  donohue    hoffman         this problem is large
scale when it expands to include airports throughout the u s   and eventually the world  exhibits
self interest  airlines are profit maximizing agents with private information about their utilities for
   

fip etcu   faltings     parkes

different slot allocations   and is one in which privacy is a major concern because of the competitiveness of the airline industry  a typical policy goal is to maximize the total utility of the allocation 
i e  one of efficient social choice  this problem motivates our study of combinatorial auctions in
section    a combinatorial auction  ca  is one in which a set of heterogeneous  indivisible goods
are to be allocated to agents  each of which has values expressed on sets of goods  e g   i only want
the  am slot if i also get the   am slot or i am indifferent between the  am and the     am slot 
the airport slot allocation problem motivated the first paper on cas  rassenti  smith    bulfin 
       in which it was recognized that airlines would likely need to express utilities on sets of slots
that correspond to the right to fly a schedule in and out of an airport 
o pen  access w ireless n etworks   most wireless spectrum today is owned and operated as
closed networks  for example by cellular companies such as t mobile and at t  however there is
plenty of debate about creating open access wireless networks in which bandwidth must be available
for use on any phone and any software   some have recently proposed using an auction protocol to
allow service providers to bid in a dynamic auction for the right to use spectrum for a given period of
time to deliver services   taken to its logical conclusion  and in an idea anticipated by rosenschein
and zlotkin        for wired telephony  this suggests a secondary market for wireless spectrum and
corresponds to a problem of efficient social choice  allocate spectrum to maximize the total utility
of consumers  this problem is large scale  exhibits self interest  and is inherently decentralized 
t he m eeting s cheduling p roblem   consider a large organization with dozens of departments  spread across dozens of sites  and employing tens of thousands of people  employees from
different sites and departments want to setup thousands of meetings each week  due to privacy
concerns among different departments  centralized problem solving is not desirable  furthermore 
although the organization as a whole desires to minimize the cost of the whole process  each department and employee is self interested in that it wishes to maximize its own utility  an artificial
currency is created for this purpose and a weekly assignment is made to each employee  employees
express their preferences for meeting schedules in units of this currency 
refer to figure   for an example of such a problem  where   agents want to setup   meetings 
figure   b  shows that each agent has as local variables the time slots corresponding to the meetings
it participates in  e g  m   represents a  s local replica of the variable representing meeting m    
local edges correspond to local all different constraints between an agents variables and ensure
that it does not participate in several meetings at the same time  equality constraints between local
replicas of the same value ensure global agreement  agents specify their relations via local edges on
local replicas  for example  agent a  with its relation on the time of meeting m  can now express a
preference for a meeting later in the day with relation r     which can assign low utilities to morning
time slots and high utilities to afternoon time slots  similarly  if a  prefers holding meeting m 
after meeting m    then it can use the local relation r   to assign high utilities to all satisfactory
combinations of timeslots and low utility otherwise  for example  hm     am  m      am i
gets utility     and hm     am  m     am i gets utility   
   in a breakthrough ruling  the u s  federal communications commission  fcc  will require open access
for around one third of the spectrum to be auctioned in early    
but it stopped short of mandating that this spectrum be made available in a wholesale market to would be service providers 
see
http   www fcc gov           mhz news release        pdf
   google proposed such an auction in a filing made to the fcc on may   st       
see
http   gullfoss  fcc gov prod ecfs retrieve cgi native or pdf pdf id document            

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

figure    a meeting scheduling problem   a  a centralized model  each vertex is a meeting variable  red
edges correspond to hard constraints on non overlap for meetings that share a participant  that
for agent a  is a hyperedge because it particpates in every meeting   blue edges correspond to
relations and represent agent preferences    b  a decentralized  dcop  model with replicated
variables  each agent has a local replica of variables of interest and inter agent edges denote
equality constraints that ensure agreement  the hard constraint for non overlap between meetings
m    m  and m  is now a local hyperedge to agent a     c  a dfs arrangement of the decentralized
problem graph  used by the dpop algorithm to control the order of problem solving 

in the experimental results presented in section   we adopt meeting scheduling as prototypical
of structured social choice problems with the problem instances associated with an organizational
hierarchy  meeting scheduling was introduced in section      for a second set of experiments we
consider combinatorial auctions  cas   in which agents bid for bundles of goods  and there we
consider a set of problem instances that are unstructured and provide a comparison point to that of
meeting scheduling  cas provide a nice abstraction of the kinds of allocation problems that exist in
the airport and wireless network domains 

   cooperative case  efficient social choice via dpop
in this section  we review dpop  petcu   faltings      b   which is a general purpose distributed
optimization algorithm  dpop  distributed pseudotree optimization protocol  is based on dynamic
programming and adapts dechters  dechter        general bucket elimination scheme to the distributed case  its main advantage is that it only generates a linear number of messages  this is in
contrast to other optimization algorithms like adopt  modi et al         and ensures minimal network overhead produced by message exchange  on the other hand  a concern in dpop can be the
size of individual messages since this grows exponentially with a parameter of the constraint graph
called the induced width  see section         nevertheless  for problems that exhibit local structure 
dpop typically scales to much larger problems  and is orders of magnitude more efficient  than
   

fip etcu   faltings     parkes

other techniques  petcu   faltings      b         to simplify the exposition  we first illustrate
dpop in a general dcop context  and then show how to instantiate dpop for social choice problems  in particular  we explain how to leverage the structure provided by local replicas  we consider
only cooperative agents throughout this section 
    the dpop algorithm for dcops
this section presents the dpop algorithm for generic dcops  to simplify the exposition  we
assume  in this section only  that each agent ai represents a single variable xi   and that the
constraint graph is given 
dpop is composed of three phases 
 phase one constructs a dfs arrangement  dfs  a   which defines the control flow of message passing and computation in dpop 
 phase two is a bottom up utility propagation along the tree constructed in phase    in this
phase utilities for different values of variables are aggregated to reflect optimal decisions that
will be made in subtrees rooted at each node in the tree 
 phase three is a top down value assignment propagation along the tree constructed in phase
   in this phase decisions are made based on the aggregate utility information from phase   
in describing these phases we refer to figure   for a running example  we also introduce an
explicit numerical example to illustrate phases two and three in more detail 
      dpop p hase o ne   dfs t ree g eneration
this first phase performs a depth first search  dfs  traversal of the problem graph  thereby constructing a dfs arrangement of the problem graph  the dfs arrangement is subsequently used to
provide control flow in dpop and guide the variable elimination order  when the underlying problem graph is a tree then the dfs arrangement will also be a tree  in general  the dfs arrangement is
a graph that we define as the union of a set of tree edges and additional back edges  which connect
some of the nodes with their ancestors  
definition    dfs arrangement  a dfs arrangement of a graph g defines a rooted tree on a
subset of the edges  the tree edges  with the remaining edges included as back edges  the tree
edges are defined so that adjacent nodes in g fall in the same branch of the tree 
figure   shows an example dfs arrangement  the tree edges are shown as solid lines  e g 
      and the back edges are shown as dashed lines  e g                two nodes xi and xv are
said to be in the same branch of the dfs arrangement if there is a path from the higher node to the
lower node along tree edges  e g   nodes x  and x   in figure    dfs arrangements have already
been investigated as a means to boost search in constraint optimization problems  freuder   quinn 
      modi et al         dechter   mateescu         their advantage is that they allow algorithms
to exploit the relative independence of nodes lying in different branches of the dfs arrangement
   for simplicity  we assume in what follows that the original problem is connected  however there is no difficulty
in applying dpop to disconnected problems  the dfs arrangement becomes a dfs forest  and agents in each
connected component can simply execute dpop in parallel in a separate control thread  the solution to the overall
problem is just the union of optimal solutions for each independent subproblem 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

figure    a dfs arrangement for a problem graph  tree edges are shown in solid and back edges are
dashed  the dfs arrangement is constructed by initializing token passing from x    any k ary
constraints  such as c    are treated as if they are cliques 

 i e  nodes that are not direct descendants or ancestors of one another   in that it is possible to
perform search in parallel on independent branches and then combine the results 
we introduce some definitions related to dfs arrangements 
definition    dfs concepts  given a node xi in the dfs arrangement  we define 
 parent pi   children ci   xi s ancestor descendants connected to xi via tree edges  e g 
p    x    c     x    x      
 pseudo parents pp i   xi s ancestors connected to xi via back edges  pp      x     
 pseudo children pc i   xi s descendants connected to xi via back edges  e g  pc    
 x     
 separator sep i of xi   ancestors of xi which are directly connected with xi or with descendants of xi  e g  sep      x    and sep       x    x    x     
 tree neighbors tn i of xi are the nodes linked to xi via tree edges  that is tn i   pi  ci
 e g  tn      x    x    x      
removing the nodes in sep i completely disconnects the subtree rooted at xi from the rest of
the problem  in case the problem is a tree  then sep i    pi    xi  x   in the general case  sep i
contains pi   all pp i and all the pseudoparents of descendants of xi where these pseudoparents are
also ancestors of xi   for example  in figure    the separator of node x  contains its parent x    and
its pseudoparent x    it is both necessary and sufficient for the values on variables  x    x    to be
set before the problem rooted at node x  is independent from the rest of the problem  separators
play an important role in dpop because contingent solutions must be maintained when propagating
utility information up the dfs arrangement for different possible assignments to separator variables 
constructing the dfs tree generating dfs trees in a distributed manner is a task that has
received a lot of attention  and there are many algorithms available  for example collin and
dolev         barbosa         cidon         cheung        to name just a few  for the purposes of executing dpop  we can assume for example the algorithm of cheung         which we
briefly outline below  when we instantiate dpop for scps  we will present our own adaptation of
this dfs generation algorithm to exploit the particulars of scp 
the simple dfs construction algorithm starts with all agents labeling internally their neighbors
as not visited  one of the agents in the graph is designated as the root  using for example a leader
   

fip etcu   faltings     parkes

election algorithm such as that of abu amara          or by simply picking the agent with the
lowest id  the root then initiates the propagation of a token  which is a unique message that will be
circulated to all the agents in the graph  thus visiting them  initially  the token contains just the
id of the root  the root sends it to one of its neighbors  and waits for its return before sending it to
each one of its  still  unvisited neighbors  when an agent xi first receives the token  it marks the
sender as its parent  all neighbors of xi contained in the token are marked as xi s pseudoparents
 pp i   
after this  xi adds its own id to the token  and sends the token in turn to each one of its notvisited neighbors xj   which become its children  every time an agent receives the token from one
of its neighbors  it marks the sender as visited  the token can return either from xj  the child to
whom xi has sent it in the first place   or from another neighbor  xk   in the latter case  it means
that there is a cycle in the subtree  and xk is marked as a pseudochild 
when a dead end is reached  the last agent backtracks by sending the token back to its parent 
when all its neighbors are marked visited  xi has finished exploring all its subtree  xi then removes
its own id from the token  and sends the token back to its parent  the process is finished for xi  
when the root has marked all its neighbors visited  the entire dfs construction process is over 
handling non binary constraints  no special treatment is required to construct neighbors to a
variable that correspond to k ary constraints  for k      for example  in figure    left   there is a
  ary constraint c  involving  x    x    x    x      by eq     this implies that  x    x    x    x    
are neighbors  and in the dfs construction process and they will appear along the same branch in
the tree  this produces the result in figure    right  
      dpop p hase t wo   util p ropagation  i nference  
phase two is a bottom to top pass on the dfs arrangement in which utility information is aggregated
and propagated from the leaves towards the root from each node to its parent and through tree edges
but not back edges  at a high level  the leaves start by computing and sending util messages to
their parents  where a util message informs the parent about its local utility for solutions to the
rest of the problem  minimally specified in terms of its local utility for different value assignments
to separator variables  subsequently each node propagates a util message that represents the
contingent utility of the subtree rooted at its node for assignments of values to separator variables 
in more detail  all nodes perform the following steps 
   wait for util messages from all their children  and store them 
   perform an aggregation  join messages from children  and also the relations they have with
their parents and pseudoparents 
   perform an optimization  project themselves out of the resulting join by picking their optimal
values for each combination of values of the other variables in the join 
   send the result to parent as a new util message 
   in cases where the problem is initially disconnected  then it is required to choose multiple roots  one for each connected component  a standard leader election algorithm  when executed by all agents in the problem  will elect
exactly as many leaders as there are connected components 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

a util message sent by a node xi to its parent pi is a multidimensional matrix which informs
pi how much utility  ui  sep i   the subtree rooted at xi receives for different assignments of values
to variables that define the separator sep i for the subtree  one of these variables  by definition  is the
variable managed by parent pi   this util message already represents the result of optimization 
where variables local to the subtree have been optimized for different assignments of separator
variables  to compute a util message a node uses two operations  aggregation and optimization 
aggregations apply the join operator and optimizations apply the project operator as described
by petcu and faltings      b   and briefly summarized here 
let utilij and utilkj denote util messages sent from nodes xi and xk to their parent
node xj   we denote by dim utilkj   the set of dimensions of such a matrix  i e  the set of
variables in the separator of sending node xk   assuming xj is the node receiving these messages 
we define 
definition    join operator  the  operator  join   utilij  utilkj is the join of two
util matrices  this is also a matrix with dim utilij    dim utilkj   as dimensions  the
value of each cell in the join is the sum of the corresponding cells in the two source matrices 
definition    project operator  the  operator  projection   if xj  dim utilij   
utilij xj is the projection through optimization of the utilij matrix along the xj axis 
for each instantiation of the variables in  dim utilij     xj    all the corresponding values from
utilij  one for each value of xj   are tried  and the maximal one is chosen  the result is a matrix
with one less dimension  xj   
notice that the subtree rooted at xi is influenced by the rest of the problem only through xi s
separator variables  therefore  a util message contains the optimal utility obtained in the subtree
for each instantiation of variables sep i and the separator size plays a crucial role in bounding the
message size 
example    util propagation  figure   shows a simple example of a util propagation  the
problem has a tree structure  figure   a    with   relations r     r     and r   detailed in figure   b  
the relations are between variables  x    x      x    x    and  x    x    respectively  these are all
individual variables and there are no local replicas  in the util phase x  and x  project themselves out of r   and r     respectively  the results are the highlighed cells in r   and r   in figure   b  
for instance  the optimal value for x  given that x     a is to assign x     c and this has utility
   these projections define the util messages they send to x    x  receives the messages from x 
and x    and joins them together with its relation with x   adds the utilities from the messages into
the corresponding cells of r      it then projects itself out of this join  for instance  the optimal value
for x  given x     b is x     a because            max                        the result
is depicted in figure   d   this is the util message that x  receives from x    each value in the
message represents the total utility of the entire problem for each value of x    we return to this
example below in the context of the third phase of value propagation 
non binary relations and constraints  as with binary constraints relations  a k ary constraint
is introduced in the util propagation only once  by the lowest node in the dfs arrangement that is
part of the scope of the constraint  for example  in figure    the constraint c  is introduced in the
util propagation only once  by x     while computing its message for its parent  x   
   

fip etcu   faltings     parkes

figure    numerical example of util propagation   a  a simple dcop problem in which there are three
relations r     r   and r   between  x    x      x    x    and  x    x    respectively   b  projections of
x  and x  out of their relations with x    the results are sent to x  as util     and util  
respectively   c  x  joins util   and util   with its own relation with x     d  x  projects
itself out of the join and sends the result to x   

      dpop p hase t hree   value p ropagation
phase three is a top to bottom pass that assigns values to variables  with decisions made recursively
from the root down to the leaves  this value propagation phase is initiated by the root agent
x  once it has received util messages from all of its children  based on these util messages 
the root assigns to variable x  the value v  that maximizes the sum of its own utility and that
communicated by all its subtrees  it then sends a value x r  v    message to every child  the
process continues recursively to the leaves  with agents xi assigning the optimal values to their
variables  at the end of this phase  the algorithm finishes  with all variables being assigned their
optimal values 
example    value propagation  return to the example in figure    once x  receives the util
message from node x  it can simply choose the value for x  that produces the largest utility for the
whole problem  x    a  x    a and x    c produce the same result in this example  so either one
can be chosen   now in the value assignment propagation phase x  informs x  of its choice via a
message value  x   a   node x  then assigns optimal value x    c and the process continues
with a message v alu e x   c  sent to its children  x  and x    the children assign x    b and
x    a and the algorithm terminates with an optimal solution hx    a  x    c  x    b  x    ai
and total utility of    
      c omplexity a nalysis of dpop
dpop produces a number of messages that scales linearly in the size of the problem graph  i e 
linearly in the number of nodes and edges in the dcop model  petcu   faltings      b   the
complexity of dpop lies in the size of the util messages  note that the tokens passed around in
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

constructing the dfs a  and the value messages are of size linear in the problem graph   petcu
and faltings      b  show that the size of the largest util message is exponential in a parameter
called the induced width  kloks        dechter        
the induced width  denoted w  of a constraint graph given by a chosen dfs arrangement is a
structural parameter that equals the size of the largest separator of any node in the dfs arrangement
 see definition     
w   max  sep i   
xi x

   

in the example from figure    the induced width of the graph given this particular dfs ordering
is w      given by sep      x    x    x     intuitively  the more a problem has a tree like structure 
the lower its induced width  in particular  if the problem graph is a tree then it will have an induced
width equal to   because the dfs arrangement will always be a tree  problem graphs that are cliques 
on the other hand  have an induced width equal to the number of nodes minus    irrespective of the
dfs tree arrangement 
proposition    dpop complexity   petcu   faltings      b  the number of messages passed in
dpop is  m   n     and  n     for phases one  two and three respectively  where n and m are
the number of nodes and edges in the dcop model with replicated variables  the maximal number
of utility values computed by any node in dpop is o dw      and the largest util message has
o dw   entries  where w is the induced width of the dfs ordering used 
in the case of trees  dpop generates util messages of dimension equal to the domain size of
the variable defining the parent of each node  in the case of cliques  the maximal message size in
dpop is exponential in n     not all dfs arrangements yield the same width  and it is desirable to
construct dfs arrangements that provide low induced width  however  finding the tree arrangement
with the lowest induced width is an np hard optimization problem  arnborg         nevertheless 
good heuristics have been identified for finding tree arrangements with low width  kloks       
bayardo   miranker        bidyuk   dechter        petcu   faltings            b   although
most were designed and explored in a centralized context  some of them  notably max degree and
maximum cardinality set  are easily amenable to a distributed environment 
    dpop applied to social choice problems
in this section  we instantiate dpop for efficient social choice problems  specifically  we first show
how the optimization problem is constructed by agents from their preferences and potential variables
of interest  subsequently  we show the changes we make to dpop to adapt it to the scp domain 
the most prominent such adaptation exploits the fact that several variables represent local replicas
of the same variable  and can be treated as such both during the util and the value phases  this
adaptation improves efficiency significantly  and allows complexity claims to be stated in terms of
the induced width of the centralized cop problem graph rather than the distributed cop problem
graph  see section        
      i nitialization   c ommunity f ormation
to initialize the algorithm  each agent first forms the communities around its variables of interest 
x ai    and defines a local optimization problem cop i  x ai    ri   with a replicated variable xvi
   

fip etcu   faltings     parkes

for each xv  x ai    shorthand xvi  cop i denotes that agent ai has a local replica of variable
xv   each agent owns multiple nodes and we can conceptualize each node as having an associated virtual agent operated by the owning agent  each such virtual agent is responsible for the
associated variable 
all agents subscribe to the communities in which they are interested  and learn which other
agents belong to these communities  neighboring relations are established for each local variable
according to eq     as follows  all agents in a community xv connect their corresponding local
copies of xv with equality constraints  by doing so  the local problems cop i  x ai    ri   are
connected with each other according to the interests of the owning agents  local relations in each
cop i  x ai    ri   connect the corresponding local variables  hard constraints connect local copies
of the variables they involve  thus  the overall problem graph is formed 
for example  consider again figure   b   the decision variables are the start times of the three
meetings  each agent models its local optimization problem by creating local copies of the variables
in which it is interested and expressing preferences with local relations  formally  the initialization
process is described in algorithm   
algorithm    dpop init  community formation and building dcop  a  
dpop init a  x   d  c  r  
  each agent ai models its interests as cop i  x ai    ri    a set of relations ri imposed on
a set x ai   of variables xvi that each replicate a public variable xv  x ai  
  each agent ai subscribes to the communities of xv  x ai  
  each agent ai connects its local copies xvi  x ai   with the corresponding local copies
of other agents via equality constraints

      dfs t raversal
the method for dfs traversal is described in algorithm    the algorithm starts by choosing one of
the variables  x    as the root  this can be done randomly  for example using a distributed algorithm
for random number generation  with a leader election algorithm like ostrovski         or by simply
picking the variable with the lowest id  the agents involved in the community for x  then randomly
choose one of them  ar as the leader  the local copy x r of variable x  becomes the root of the
dfs  making the assumption that virtual agents act on behalf of each variable in the problem 
the functioning of the token passing mechanism is similar to that described in section        with
additional consideration given to the community structure  once a root has been chosen  the agents
participate in a distributed depth first traversal of the problem graph  for convenience  we describe
the dfs process as a token passing algorithm in which all members within a community can observe
the release or pick up of the token by the other agents  the neighbors of each node are sorted  in
line    to prioritize for copies of variables held by other agents  and then other local variables  and
finally other variables linked through hard constraints 
example   consider the meeting scheduling example in figure    assume that m  was chosen as
the start community and a  was chosen within the community as the leader  a  creates an empty
token dfs    and adds m   s id to the token  dfs    m       as in eq     neighbors m      
 m     m     m     m      a  sends the token dfs    m     to the first unvisited neighbor from this
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

algorithm    dpop phase one  dfs construction 
inputs  each ai knows its cop i   and neighbors xvi    xvi  cop i
outputs  each ai knows p  xvi    pp  xvi    c xvi    pc  xvi    xvi  cop i  
 
 
 

 
 
 
 

 
 
  

procedure initialization
the agents choose one of the variables  x    as the root 
agents in x  s community elect a leader  ar  
ar initiates the token passing from x r to construct the dfs
procedure token passing  performed by each virtual agent xvi  cop i  
if xvi is root then p  xvi     null  create empty token dfs    
else dfs   handle incoming tokens  
let dfs    dfs   xvi  
sort neighbors xvi   by siblings xvi    then local neighbors xvi    then
hard neighbors xvi    set c xvi      null 
forall xl  neighbors xvi   s t  xl not visited yet do
c xvi      c xvi    xl   send dfs to xl wait for dfs token to return 
send dfs token back to p  xvi   
procedure handle incoming tokens     run by each virtual agent xvi  cop i

  
  
  
  

  

wait for any incoming dfs message  let xl be the sender
mark xl as visited 
if this is the first dfs message  i e  xl is my parent  then
p  xvi      xl   pp  xvi       xk    xl  xk  neighbors xvi    dfs    pp  xvi      
else
if xl 
  c xvi    i e  this is a dfs coming from a pseudochild  then
pc  xvi      pc  xvi    xl

list  i e  m     which belongs to a    a  receives the token and adds its copy of m   now dfs  
 m     m       a  then sends the token to m   s first unvisited neighbor  m    which belongs to a    
agent a  receives the token and adds its own copy of m  to it  now dfs    m     m     m      
m   s neighbor list is neighbors m        m     m     m      since the token that a  has received
already contains m   and m     this means that they were already visited  thus  the next variable
to visit is m     which happens to be a variable that also belongs to a    the token is passed
to m   internally  no message exchange required   and m   is added to the token  now dfs  
 m     m     m     m      
the process continues  exploring sibling variables from each community in turn  and then passing on to another community  and so on  eventually all replicas of a variable are arranged in a
chain and have equality constraints  back edges  with all the predecessors that are replicas of the
same variable  when a dead end is reached  the last agent backtracks by sending the token back to
its parent  in our example  this happens when a  receives the token from a  in the m  community 
then  a  sends back the token to a  and so on  eventually  the token returns on the same path all
the way to the root and the process completes 
   

fip etcu   faltings     parkes

      h andling

the

p ublic h ard c onstraints  

social choice problems  as defined in definition   can contain side constraints  in the form of publicly known hard constraints  that represent domain knowledge such as a resource can be allocated
only once  this hotel can accomodate     people  no person can be in more than one meeting
at the same time  etc  these constraints are not owned by any agent  but are available to all agents
interested in any variable involved in the domain of any such constraint  handling these constraints
is essentially unchanged from handling the non binary constraints in standard dpop  as described in
section       for the dfs construction phase  and in section       for the util phase  specifically 
dfs construction  neighboring relationships as defined in eq    require for each local variable
that other local copies that share a hard constraint are considered as neighbors  because of the
prioritization in line   of algorithm    for dfs construction   the dfs traversal is mostly made
according to the structure defined by the relations of the agents and most hard constraints will
appear as backedges in the dfs arrangement of the problem graph 
util propagation  hard constraints are introduced in the util propagation phase by the lowest
agent in the community of the variable from the scope of the hard constraint  i e  the agent with the
variable that is lowest in the dfs ordering  for example  if there was a constraint between m  and
m  in figure   to specify that m  should occur after m  then this becomes a backedge between the
  communities and would be assigned to a  for handling 
      h andling r eplica variables
our distributed model of scp replicates each decision variable for every interested agent and connects all these copies with equality constraints  by handling replica variables carefully we can
avoid increasing the induced width k of the dcop model when compared to the induced width
w of the centralized model  with no further adaptation  the util messages in dpop on the distributed problem graph would be conditioned on as many variables as there are local copies of an
original variable  however  all the local copies represent the same variable and must be assigned the
same value  thus  sending many combinations where different local copies of the same variable take
different values is wasteful  therefore  we handle multiple replicas of the same variable in util
propagation as though they are the single  original variable  and condition relations on just this one
value  this is realized by updating the join operator as follows 
definition    updated join operator for scp  defined in two steps 
step    consider all util messages received as in input  for each one  consider each variable
xvi on which the message is conditioned  and that is also a local copy of an original variable xv  
rename xvi from the input util message as xv   i e  the corresponding name from the original
problem 
step    apply the normal join operator for dpop 
applying the updated join operator makes all local copies of the same variable become indistinguishable from each other  and merges them into a single dimension in the util message and
avoids this exponential blow up 
example   consider the meeting scheduling example in figure    the centralized model in figure   a  has a dfs arrangement that yields induced width   because it is a clique with   nodes 
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

nevertheless  the corresponding dcop model in figure   b  has induced width    as can be seen
in the dfs arrangement from figure   c   in which sep m      m     m     m      applying dpop to
this dfs arrangement  m   would condition its util message utilm   m   on all variables in its
separator   m     m     m      however  both m   and m   represent the same variable  m    therefore  m   can apply the updated join operator  which leverages the equality constraint between the
two local replicas and collapse them into a single dimension  called m    in its message for m    
the result it that the outgoing message only has   dimensions   m    m      and it takes much less
space  this is possible because all   agents involved  i e  a    a  and a  know that m     m   and
m   represent the same variable 
with this change  the value propagation phase is modified so that only the top most local
copy of any variable solve an optimization problem and compute the best value  announcing this
result to all the other local copies which then assume the same value 
      c omplexity a nalysis of dpop a pplied to s ocial c hoice
by this special handling of replica variables  dpop applied to scps will scale with the induced
width of the centralized problem graph  and independently of the number of agents involved and in
the number of local replica variables 
consider a dfs arrangement for the centralized model of the scp that is equivalent to the
dfs arrangement for the dcop model  equivalent here means that the original variables from
scp are visited in the same order in which their corresponding communities are visited during the
distributed dfs construction   recall that the distributed dfs traversal described in section      
visits all local copies from a community from dcop before moving on to the next community   let
w denote the induced width of this dfs arrangement of the centralized scp  similarly  let k denote
the induced width of the dfs arrangement of the distributed model  let d   maxm  dm   denote
the maximal domain of any variable  then  we have the following 
theorem    dpop complexity for scp  the number of messages passed in dpop in solving a
scp is  m   n     and  n     for phases one  two and three respectively  where n and m are
the number of nodes and edges in the dcop model with replicated variables  the maximal number
of utility values computed by any node in dpop is o dw      and the largest util message has
o dw     entries  where w is the induced width of the centralized problem graph 
p roof  the first part of the claim  number of messages  follows trivially from proposition    for
the second part  message size and computation   given a dfs arrangement of a dcop  applying
proposition   trivially gives that in the basic dpop algorithm  the maximal amount of computation
on any node is o dk      and the largest util message has o dk   entries  where k is the induced width of the dcop problem graph  to improve this analysis we need to consider the special
handling of the replica variables 
consider the util messages which travel up along the dfs tree  and whose sets of dimensions
contain the separators of the sending nodes  recall that the updated join collapses all local replicas
into the original variables  the union of the dimensions of the util messages to join in the dpop
on the dcop model becomes identical to the set of dimensions of the nodes in the dpop on the
centralized model  thus  each node in the dcop model performs the same amount of computation
as its counterpart on the centralized model  it follows that the computation required in dpop scales
as o dw     rather than o dk     by this special handling 
   

fip etcu   faltings     parkes

there remains one additional difference between dpop on the dfs arrangement for the centralized scp versus dpop on the dfs arrangement for the dcop  a variable xv that is replicated
across multiple agents can only be projected out from the util propagation through local optimization by the top most agent handling a local replica of xv   this is the first node at which all
relevant information is in place to support this optimization step  in particular  whenever a node
with the maximal separator set is not also associated with the top most replica of its variable then
it must retain dependence on the value assigned to its variable in the util message that it sends to
its parent  this increases the worst case message size of dpop to o dw      as opposed to o dw  
for the normal dpop  computation remains o dw     because the utility has to be determined for
each value of xv anyway  and before projecting xv out   
to see the effect on message size described in the proof  in which a local variable cannot be
immediately removed during util propagation  consider again the problem from figure    suppose now that agent a  is also involved in meeting m    this introduces an additional back edge
m    m   in the dfs arrangement for the decentralized model shown in figure   c   the dfs
arrangement of the cop model that corresponds to the decentralized model is simply a traversal
of the cop in the order in which the communities are visited during the distributed dfs construction  this corresponds to a chain  m   m   m    the introduction of the additional back edge
m    m   in the distributed dfs arrangement does not change the dfs of the cop model  and its
width remains w      however  as m   is not the top most copy of m    agent a  cannot project
m  out of its outgoing util message  the result is that it sends a util message with w        
dimensions  as opposed to just w     

   handling self interest  a faithful algorithm for social choice
having adapted dpop to remain efficient for scps  we now turn to the issue of self interest  without further modification  an agent can manipulate dpop by misreporting its private relations and
deviating from the algorithm in various ways  in the setting of meeting scheduling  for example 
an agent might benefit by misrepresenting its local preferences  i have massively more utility for
the meeting occurring at  pm than at  am   incorrectly propagating utility information of other
 competing  agents  the other person on my team has very high utility for the meeting at  pm  
or by incorrectly propagating value decisions  it has already been decided that some other meeting
involving the other person on my team will be at  am so this meeting must be at  pm  
by introducing carefully crafted payments  by leveraging the information and communication
structure inherent to dcops for social choice  and by careful partitioning of computation so that
each agent is only asked to reveal information  perform optimization  and send messages that are
in its own interest  we are able to achieve faithfulness  this will mean that each agent will choose 
even when self interested  to follow the modified algorithm  we first define the vcg mechanism
for social choice and illustrate its ability to prevent manipulation in centralized problem solving in
a simple example  with this in place  we next review the definitions of faithful distributed implementation and the results of a useful principle  the partition principle  we then describe the simple
m dpop algorithm  without reuse of computation  and prove its faithfulness 
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

    review  mechanism design and the vcg mechanism
mechanism design  md  addresses the problem of optimizing some criteria  frequently social welfare  in the presence of self interested agents that each have private information relevant to the
problem at hand  in the standard story  agents report private information to a center  that solves
an optimization problem and enforces the outcome 
the second price  sealed bid  vickrey  auction is a simple example of a mechanism  each agent
makes a claim about its value for an item to an auctioneer  who allocates the item to the highest
bidder for the second highest price  krishna         the vickrey auction is useful because it is
non manipulable  in that the weakly dominant strategy of each agent is to report its true value  and
efficient  in that the item is allocated to the agent with the highest value 
in our setting of efficient social choice  we will assume the existence of a currency so that agents
can make payments  and make the standard assumption of quasilinear utility functions  so that agent
ai s net utility is 
ui  x  p    ri  x   p 

   

for an assignment x  d to variables x and payment p 
center  i e   its net utility
p r to the
j
 x  
minus the amount of
r
is that defined by its utility for the assignment  ri  x   
j
ri ri i
its payment  one of the most celebrated results of md is provided by the vickrey clarke groves
 vcg  mechanism  which generalizes vickreys second price auction to the problem of efficient
social choice 
definition    vcg mechanism for efficient social choice  given knowledge of public constraints c  and public decision variables x   the vickrey clarke groves  vcg  mechanism works
as follows 
 each agent  ai   makes a report ri about its private relations 
 the centers decision  x    is that which solves scp  a  given the reports r    r            rn   
 each agent ai   makes payment
tax  ai    

x



rj  xi
   rj  x     

   

j  i

   for each a   is the solution to scp  a   given reports r
to the center  where xi
i
i
i  
 r            ri    ri             rn   

each agent makes a payment that equals the negative marginal externality that its presence
imposes on the rest of the system  in terms of the impact of its preferences on the solution to the
scp 
the vcg mechanism has a number of useful properties 
 strategyproofness  each agents weakly dominant strategy  i e  its utility maximizing strategy whatever the strategies and whatever the private information of other agents  is to truthfully report its preferences to the center  this is the sense in which the vcg mechanism is
non manipulable 
   

fip etcu   faltings     parkes

 efficiency  in equilibrium  the mechanism makes a decision that maximizes the total utility
to agents over all feasible solutions to the scp 
 participation 
in p
equilibrium  the utility to agent ai   ri  x     tax  ai      ri  x     
p


j  i rj  xi    is non negative  by the principle of optimality  and therej  i rj  x    
fore agents will choose to participate 
 no deficit 
the payment
made by agent ai is non negative in the scp  because
p
p


j  i rj  x   by the principle of optimality  and therefore the entire
j  i rj  xi   
mechanism runs at a budget surplus 
to begin to understand why the vcg mechanism is strategyproof  notice that the first term in
tax  ai   is independent of ai s report  the second term  when taken together
with the agents own
p

true utility from the decision  provides ai with net utility ri  x     j  i rj  x     this is the
total utility for all agents  and to maximize this the agent should simply report its true preference
information  because the center will then explicitly solve this problem in picking x   
example   return to the example in figure    we can make this into a scp by associating agents
a    a  and a  with relations r     r   and r   on variables  x    x      x    x     and  x    x    respectively  breaking ties as before  the solution to scp  a  is   x    a  x    c  x    b  x   
a   with utility             to agents a    a  and a  respectively  removing agent a    the solution
would be   x      x    a  x    c  x    a   with utility          to agents a  and a    the  
indicates that agents a  and a  are indifferent to the value on x    removing agent a    the solution
would be   x    c  x    b  x      x    c    with utility          to agents a  and a    removing agent a    the solution would be   x    a  x    c  x    b  x        with utility         
to agents a  and a    the vcg mechanism would assign   x    a  x    c  x    b  x    a   
with payments                                                                  collected from
agents a    a  and a  respectively  a  has no negative impact on agents a  and a  and does not
incur a payment  the other agents make payments  the presence of a  helps a  but hurts a  by
more  while the presence of a  hurts both a  and a    the only conflict in this problem is about the
value assigned to variable x    agents a    a  and a  each prefer that x  be assigned to b  c and
a respectively  in the chosen solution  only agent a  gets its best outcome  considering the case of
a    it can force either a or b to be selected by reporting a suitably high utility for this choice  but
for x    a it must pay   while for x    b it must pay    and in either case it weakly prefers the
current outcome in which it makes zero payment 
having introduced the vcg mechanism  it is important to realize that the vcg mechanism
provides the only known  general purpose  method that exists to solve optimization problems in
the presence of self interest and private information  on the positive side  it is straightforward to
extend the vcg mechanism  and the techniques of our paper  to maximize a linear weighted sum
of the utility of each agent  where these weights are fixed and known  for instance by a social
planner  jackson         roberts        on the other hand  established that the groves mechanisms  of which the vcg mechanism is the most important special case  are the only non trivial
strategyproof mechanisms in the domain of social choice unless there is some known structure to
agent preferences  e g   everyone prefers earlier meetings  or more of a resource is always weakly
preferred to less  together with another technical assumption  roberts theorem has also been extended by lavi et al         to domains with this kind of structure  for instance to combinatorial
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

auctions  we see that there is a very real sense in which it is only possible to address self interested
in dcops when maximizing something like the total utility of participants 
    faithful distributed implementation
our goal in faithful distributed implementation is to distribute the computation required to solve
the scp and determine payments to the population of agents  but to do this while retaining an
analog to strategyproofness  this can be challenging because it opens up additional opportunities
for manipulation beyond those in the centralized vcg mechanism 
in presenting our results  we introduce the following additional assumptions over and above
those made so far 
 agents are rational but helpful  meaning that although self interested  they will follow a protocol whenever there is no deviation that will make them strictly better off  given the behavior
of other agents  
 each agent is prevented from posing as several independent agents by an external technique
 perhaps cryptographic  for providing strong  perhaps pseudonymous  identities 
 catastrophic failure will occur if all agents in the community of a variable do not eventually
choose the same value for the variable 
 there is a trusted bank  connected with a trusted communication channel to each agent  and
with the authority to collect payments from each agent 
the property of rational but helpful is required in being able to rely upon agents to compute the
payments that other agents should make  strong identities is required to avoid known vulnerabilities
of the vcg mechanism as shown by yokoo  sakurai and matsubara         wherein agents can
sometimes do better by participating under multiple identities  catastrophic failure ensures that
the decision determined by the protocol is actually executed  it prevents a hold out problem 
where an unhappy agent refuses to adopt the consensus decision  an alternative solution would
be to have agents report the final decision to a trusted party  responsible for enforcement  by a
trusted communication channel  we mean that each agent can send a message to the bank without
interference by any other agent  these messages are only sent by an agent upon termination of
m dpop  to inform the bank about other agents payments  the bank is also assumed in other work
on distributed md  feigenbaum et al               shneidman   parkes         and is the only
trusted entity that we require  its purpose is to ensure that payments can be used to align incentives 
to provide a formal definition of a distributed implementation we need the concept of a local
state  the local state of an agent ai corresponds to the sequence of messages that the agent has
received and sent  together with the initial information available to an agent  including both its own
relations  and public information such as constraints   given this  a distributed implementation 
dm    g    s    is defined in terms of three components  shneidman   parkes        parkes  
shneidman        
 strategy space    which defines the set of feasible strategies i   available to agent ai  
where strategy i defines the message s  that agent ai will send in every possible local state 
 suggested protocol  s    s            sn    which defines a strategy that is parameterized by the
private relations ri of agent ai  
   

fip etcu   faltings     parkes

 outcome rule  g    g    g     where g    n  d defines the assignment of values  g      d 
to variables x given a joint strategy                  n    n   and g    n  rn defines the
payment g  i     r made by each agent ai given joint strategy   n  
by defining the message s  that are sent in every state  a strategy i   encompasses all
computation performed internally to an agent  all information that an agent reveals about its private
inputs  e g  its relations   and all decisions that an agent makes about how to propagate information
received as messages from other agents   the suggested protocol si corresponds to an algorithm 
which takes as input the private information available to an agent and relevant details about the
agents local state  and generates a message or messages to send to neighbors in the network  when
applied to distributed input r    r            rn   and the known parts of the input such as hard
constraints c  the protocol s induces a particular execution trace of the algorithm  this in turn
induces the outcome g    for    s r   where g     is the final assignment of values  information
about which is distributed across agents  and g     is the vector of payments that the bank will
collect from agents   
the main question that we ask  given a distributed algorithm and its corresponding suggested
protocol  is whether the suggested protocol forms an ex post nash equilibrium of the induced game 
definition    ex post nash equilibrium   given distributed implementation dm    g    s   
the suggested protocol s    s            sn   is an an ex post nash equilibrium  epne  if  for all agents
ai   all relations ri   all relations of other agents ri   and all alternate strategies i   
ri  g   si  ri    si  ri      g   si  ri    si  ri     ri  g   i   si  ri      g   i   si  ri   
   
in an epne  no agent ai can benefit by deviating from protocol  si   whatever the particular
instance of dcop  i e  for all private relations r    r            rn     so long as the other agents also
choose to follow the protocol  it is this latter requirement that makes epne weaker than dominantstrategy equilibrium  in which si would be the best protocol for agent i even if the other agents
followed an arbitrary protocol 
definition    faithfulness  distributed implementation  dm     g    s    is ex post faithful if
suggested protocol s is an ex post nash equilibrium 
that is  when a suggested protocol  s  is said to be ex post faithful  or simply faithful  then it is
in the best interest of every agent ai to follow all aspects of the algorithm  information revelation 
computation and message passing  whatever the private inputs of the other agents  as long as every
other agent follows the algorithm 
   the idea that each agent only has a limited set of possible messages that can be sent in a local state  as implied by
the notion of a  restricted  strategy space   is justified in the following sense  agents in the model are autonomous
and self interested and  of course  free to send any message in any state  but on the other hand  and if the suggested
protocol is followed by every other agent  then only some messages will be semantically meaningful to the recipient
agent s  and trigger a meaningful change in local state in the recipient agent s   i e  a change in local state that will
changes the future  external  behavior of the recipient agent  in this way  the strategy space characterizes the complete
set of interesting behaviors available to an agent given that the other agents follow the suggested protocol  this is
sufficient  from a technical perspecitve  to define an ex post nash equilibrium 
    the outcome rule must be well defined for any unilateral deviation from s  i e  where any one agent deviates and does
not follow the suggested protocol  either the protocol still reaches a terminal state so that decisions and payments
are defined  or the protocol reaches some bad state with suitably negative utility to all participants  such as livelock
or deadlock  we neglect this latter possibility for the rest of our analysis  but it can be easily treated by introducing
special notation for this bad outcome 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

    the partition principle applied to efficient social choice
one cannot achieve a faithful di for efficient scp by simply running dpop  n     times on the
same problem graph  once for the main problem and then with each agents effect nullified in turn
by asking it to simply propagate messages  agent ai would seek to do the following   a  interfere
with the computational process for scp  ai    to make the solution as close as possible to that
to scp  a   so that its marginal impact appears small  and  b  otherwise decrease its payment  for
example by increasing the apparent utility of other agents for the solution to scp  a   and in turn
increases the value of the second term in its vcg payment  eq     
this opportunity for manipulation was recognized by parkes and shneidman        in a more
general setting  who proposed the partition principle as a method for achieving faithfulness in distributed vcg mechanisms  instantiated here in the context of efficient scps 
definition     partition principle  a distributed algorithm  corresponding to suggested protocol
s  satisfies the partition principle in application to efficient social choice  if 
    correctness  an optimal solution is obtained for scp  a  and scp  ai   when every agent
follows s  and the bank receives messages that instruct it to collect the correct vcg payment
from every agent 
    robustness  agent ai cannot influence the solution to scp  ai    or the report s  that
the bank receives about the negative externality that ai imposes on the rest of the system
conditioned on solutions to scp  a  and scp  ai   
    enforcement  the decision that corresponds to scp  a  is enforced  and the bank collects
the payments as instructed 
theorem    parkes   shneidman        a distributed algorithm for efficient social choice that
satisfies the partition principle is an ex post faithful distributed implementation 
for some intuition behind this result  note that the opportunity for manipulation by an agent
ai is now restricted to   a  influencing the solution computed to scp  a   and  b  influencing the
payments made by other agents  agent ai cannot prevent the other agents from correctly solving
scp  ai   or from correctly reporting the negative externality that ai imposes on the other agents
by its presence  as long as the other agents follow the algorithm  then ex post faithfulness follows
from the strategyproofness of the vcg mechanism because the additional opportunity for manipulation  over and above that available from misreporting preferences in the centralized context  is to
change  either increase or reduce  the amount of some other agents payment  this is opportunity
 b   opportunity  a  is not new  an agent can always influence the solution in the context of a
centralized vcg mechanism by misreporting its preferences 
remark  as has been suggested in previous work  the weakening from dominant strategy equilibrium in the centralized vcg mechanism  to ex post nash equilibrium in a distributed implementation  can be viewed as the cost of decentralization  the incentive properties necessarily rely on
the payments that are collected which rely in turn on the computation performed by other agents
and in turn on the strategy followed by other agents   
    an exception is provided by izmalkov et al          who are able to avoid this through the use of cryptographic
primitives  in their case best thought of as physical devices such as ballot boxes 

   

fip etcu   faltings     parkes

    simple m dpop
algorithm   describes simple m dpop  in this variation the main problem  scp  a  is solved 
followed by the social choice problem  scp  ai   with each agent removed in turn    once these

n     problems are solved  every agent aj knows the local part of the solution to x  and xi
for all ai    aj   which is the part of the solution that affects its own utility  this provides enough
information to allow the system of agents without some agent ai   for any ai   to each send a message
to the bank about a component of the payment that agent ai should make 
algorithm    simple m dpop 
  run dpop for dcop  a  on dfs  a   find x 
  forall ai  a do

 
build dfs  ai    run dpop for dcop  ai   on dfs  ai    find xi
    r  x    and report to bank 
 
all agents aj p
   ai compute tax j  ai     rj  xi
j
 
bank deducts j  i tax j  ai   from ai s account
 

each ai assigns values in x  as the solution to its local copi

the computation of payments
p is disaggregated across the agents  the tax payment collected
from agent ai is tax  ai     j  i tax j  ai    where

tax j  ai     rj  xi
   rj  x    

    

is the component of the payment that occurs because of the negative effect that agent ai has on the
utility of agent aj   this information is communicated to the bank by agent aj in the equilibrium 
the important observation  in being able to satisfy the partition principle  is that these components of ai s payment satisfy a locality property  so that each agent aj can compute this component of ai s payment with just its private information about its relations and its local information
 that affect its own utility  all of this information is availabout the parts of solutions x  and xi
able upon termination of simple m dpop  correctly determining this payment  once we condition
   does not rely on any aspect of any other agents algorithm  including that
on solutions x  and xi
  
of ai  
figure   provides an illustration of simple m dpop on the earlier meeting scheduling example 
and shows how the marginal problems  and the dfs arrangements for each such problem  are
related to the main problem 
theorem   the simple m dpop algorithm is a faithful distributed implementation of efficient social choice and terminates with the outcome of the vcg mechanism 
p roof  to prove this we establish that simple m dpop satisfies the partition principle and then
by appeal to theorem    first  dpop computes optimal solutions to scp  a  and scp  ai   for
    simple m dpop is presented for a setting in which the main problem and the subproblems are connected but extends
immediately to disconnected problems  indeed  it may be that the main problem is connected but one or more
subproblems are disconnected  to see that there are no additional incentive concerns notice that it is sufficient to
recognize that the correctness and robustness properties of the partition principle would be retained in this case 
    a similar disaggregation was identified by feigenbaum et al         for lowest cost interdomain routing on the
internet  shneidman and parkes        subsequently modified the protocol by those authors so that agents other than
ai had enough information to report the payments to be made by agent ai  

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

figure    simple m dpop  each agent ai is excluded in turn from the optimization dcop  ai    this is
illustrated on the meeting scheduling example 

all ai  a when every agent follows the protocol  this is immediate because of the correctness
of the dcop model of scp and the correctness of dpop  the correct vcg payments are collected
when every agent follows the algorithm by the correctness of the disaggregation of vcg payments
in eq      second  agent ai cannot influence the solution to scp  ai   because it is not involved
in that computation in any way  the dfs arrangement is constructed  and the problem solved  by
the other agents  who completely ignore ai and any messages that agent ai might send   any hard
constraints that ai may have handled in scp  a  are reassigned automatically to some other agent
in scp  ai   as a consequence of the fact that the dfs arrangement is reconstructed   dpop
still solves scp  ai   correctly in the case that the problem graph corresponding to scp  ai  
becomes disconnected  in this case the dfs arrangement is a forest   the robustness of the value of
the reports from agents    ai about the negative externality imposed by ai   conditioned on solutions
to scp  a  and scp  ai    follows from the locality property of payment terms tax j  ai   for all
aj    ai   for enforcement  the bank is trusted and empowered to collect payments  and all agents
will finally set local copies of variables as in x  to prevent catastrophic failure  agent ai will
not deviate as long as other agents do not deviate  moreover  if agent ai is the only agent that is
interested in a variable then its value is already optimal for agent ai anyway   
the partition principle  and faithfulness  has sweeping implications  not only will each agent
follow the subtantive aspects of simple m dpop  but each agent will also choose to faithfully participate in the community discovery phase  in any algorithm for choosing a root community  and in
selecting a leader agent in phase one of dpop   
    one can also observe that is not useful for an agent to misreport the local utility of another agent aj while sending
util messages around the system  on one hand  such a deviation could of course change the selection of x  or

xk
for some k     i  j  and thus the payments by other agents or the solution ultimately selected  but  by deviating

   

fip etcu   faltings     parkes

remark on antisocial behavior  note that reporting exaggerated taxes hurts other agents but
does not increase ones own utility so this is excluded by our assumption that the agents are selfinterested but helpful 

   m dpop  reusing computation while retaining faithfulness
in this section  we present our main result  which is the m dpop algorithm  in simple m dpop  the
computation to solve the main problem is completely isolated from the computation to solve each
of the marginal problems  in comparison  in m dpop we re use computation already performed in
solving the main problem in solving the marginal problems  this enables the algorithm to scale well
to problems where each agents influence is limited to a small part of the entire problem because
little additional computation is required beyond that of dpop  these problems in which an agents
influence is limited are precisely those of interest because they are also those for which the induced
tree width is small and for which dpop scales 
the challenge that we face  in facilitating this re use of computation  is to retain the incentive
properties that are provided by the partition principle  a possible new manipulation is for agent
ai to deviate in the computation in dcop  a   with the intended effect to change the solution
to dcop  ai   via the indirect impact of the computation performed in dcop  a  when it is
reused in solving dcop  ai    to prevent this  we have to determine which util messages in
dcop  a  could not have been influenced by agent ai  
example   refer to figure    here agent ai controls only x  and x     then it has no way of
influencing the messages sent in the subtrees rooted at  x     x     x    x    x    x      we want to
be able to reuse as many of these util messages as possible  in solving the problem with agent
ai removed we will strive to construct a dfs i arrangement for problem dcop  ai   that is as
similar as possible to the dfs for the main problem  this is done with the goal of maximizing the
re use of computation across problems  see figure   b   notice that this is now a dfs forest  with
three distinct connected components  the util messages that were sent by the shaded nodes can be
re used in solving dcop  ai    these are all the util messages sent by nodes in the subtrees that
were not influenced by agent ai except for  x     x     x    and also x    which now has a different
local dfs arrangement 
m dpop uses the safe reusability idea suggested by this example  see algorithm    in its first
stage  m dpop solves the main problem just as in simple m dpop  once this is complete  each
marginal problem dcop  ai   is solved in parallel  to solve dcop  ai    a dfs i forest  it
will be a forest in the case that dcop  ai   becomes disconnected  is constructed as a modification
to dfs  a   retaining as much of the structure of dfs  a  as possible  a new dpop  ai  
execution is performed on the dfs i and u t il messages are determined to be either reusable or
not reusable by the sender of the message based on the differences between dfs i and dfs  a  
we will explain below how dfs i is constructed 
in this way the agent cannot change the utility information that is finally used in determining its own payments  this
is because it is agent aj itself that computes the marginal effect of agent ai on its local solution  and component
tax j  ai   of agent ai s payment 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

figure    reconstructing dfs  ai   from dfs  a  in m dpop  the result is in general a dfs forest  the
bold nodes from main dfs initiate dfs i propagation  the one initiated by x  is redundant
and eventually stopped by x    the ones from x  and x   are useful  as their subtrees become
really disconnected after removing ai   x   does not initiate any propagation since it has x 
as a pseudoparent  x  is not controlled by ai   and will eventually connect to x     notice that
x   x  and x   x   are turned into tree edges 

    phase one of m dpop for a marginal problem  constructing dfs i
given a graph dcop  a  and a dfs arrangement dfs  a  of dcop  a   if one removes a set of
nodes x ai    dcop  a   the ones that belong to ai    then we need an algorithm that constructs
a dfs arrangement  dfs i   for dcop  a    x ai    we want to achieve the following properties 
   dfs i must represent a correct dfs arrangement for the graph dcop  ai    a dfs forest
in the case dcop  ai   becomes disconnected  
   dfs i must be constructed in a way that is non manipulable by ai   i e  without allowing
agent ai to interfere with its construction 
   dfs i should be as similar as possible to dfs  a   this allows for reusing util messages
from dpop  a   and saves on computation and communication 
the main difficulty stems from the fact that removing the nodes that represent variables of interest to agent ai from dfs  a  can create disconnected subtrees  we need to reconnect and possibly
rearrange the  now disconnected  subtrees of dfs  a  whenever this is possible  return to the example in figure    removing agent ai and nodes x  and x   disrupts the tree in two ways  some
subtrees become completely disconnected from the rest of the problem  e g  x    x    x     
some other ones remain connected only via back edges  thus forming an invalid dfs arrangement
   

fip etcu   faltings     parkes

algorithm    m dpop  faithfully reuses computation from the main problem 
  run dpop for dcop  a  on dfs  a   find x 
  forall ai  a do
in parallel
 

create dfs i with algorithm   by adjusting dfs  a 

 

run dpop for dcop  ai   on dfs i  
if leaves in dfs i observe no changes in their dfs i then
they send null utili messages

 

 

 
 

else they compute their utili messages anew  as in dpop
subsequently  all nodes xk  df s i do 
if xk receives only null utili msgs   pk   pki  p pk   p pki  ck   cki   then
xk sends a null utili message
else
node xk computes its utili message  reusing 
forall xl  n eighbors xk   s t  xl sent utili   null do
xk reuses the util message xl had sent in dcop  a 
compute and levy taxes as in simple m dpop 
each ai assigns values in x  as the solution to its local copi  

 e g  x   x   x     the basic principle we use is to reconnect disconnected parts via back edges
from dfs  a  whenever possible  this is intended to preserve as much of the structure of as possible  for example  in figure    the back edge x   x  is turned into a tree edge  and x  becomes
x  s child  node x  remains x  s child 
the dfs i reconstruction algorithm is presented in algorithm    the high level overview is
as follows  in bold we state the purpose of each step  
    similarity to dfs  a     all nodes retain the dfs data structures from constructing
dfs  a   i e   the lists of their children  pseudo parents children  and their parents from
dfs  a   they will use this data as a starting point for building the dfs arrangements 
dfs  ai    for marginal problems 
    at least one traversal of each connected component on a dfs forest   the root of
dfs  a  and the children   of removed nodes each initiate a dfs i token passing as in
dfs  a   except for these changes 
 each node xk sends the token only to neighbors not owned by ai  
 the order in which xk sends the token to its neighbors is based on dfs  a   first xk s
children from dfs  a   then its pseudochildren  then its pseudoparents  and then its
parent  this order helps preserve structure from dfs  a  into dfs  ai   
    children which have pseudoparents above the excluded node  for instance x   in figure    do not initiate dfs token
passing because it would be redundant  they would eventually receive a dfs token from their pseudoparent 

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

algorithm    reconstruction of dfs i from dfs  a  
all data structures for the dfs i are denoted with superscript i  

procedure token passing for dfs i  executed by all nodes xk 
  x ai     
 
 

 
 
 

forall xl  neighbors xk   s t  xl belongs to ai do
remove xl from neighbors xk   and from ck   pc k   pp k   i e  send nothing to ai
sort neighbors xk   in this order  ck   pc k   pp k   pk   mimic dfs  a 
if xk is root  or pk  x ai    i e  executed by the root and children of ai   then
initiate dfs i as in normal dfs  algorithm   
else do process incoming tokens  
send dfs i  xk   back to pki    xk s subtree completely explored
procedure process incoming tokens  

 
 
 
 
  
  

wait for any incoming dfs i token  let xl be its sender
if xl  ai then ignore message
else
if this is first token received then
i
i
pki   xl   pp i
k    xj    pk  xj  neighbors xi    dfs  
i
i
rootk   first node in the token dfs

  

else
let xr be the first node in dfs i
i
traversal then
if xr    rooti
k   i e  this is another dfs
if depth of xr in dfs  a    depth of root i
k in dfs  a  then
i
i
i
i
reset pk   pp k   ck   pc k   override redundant dfs from lower root
i
i
pki   xl   pp i
k    xj    pk  xj  neighbors xi    dfs  
i
root k   xr

  

continue as in algorithm  

  
  
  
  
  

    unique traversal of each connected component on a dfs forest   each node xk retains
its root path in dfs  a  and knows its depth in the dfs arrangement  when a new token
dfs i arrives 
 if it is the first dfs i token that arrives  then the sender  let this be xl   is marked as
the parent of xk in dfs i   pki   xl   notice that xl could be different from the
parent of xk from dfs  a   xk stores the first node from the received token dfs i  
as root i
k   the  provisional  root of the connected component to which xk belongs in
dcop  ai   
 if this is not the first dfs i token that arrives  then there are two possibilities 
 the token received is part of the same dfs i traversal process  xk recognizes
this by the fact that the first node in the newly received token is the same as the
previously stored root i
k   in this case  xk proceeds as normal  as in algorithm   
marks the sender as pseudochild  etc 
   

fip etcu   faltings     parkes

 the token received is part of another dfs i traversal process  initiated by another
node than root i
k  see below in text for when this could happen   let xr be the first
node in the newly received token  xk recognizes this situation by the fact that xr
i
is not the same as the previously stored rooti
traversal
k   in this case  the dfs
initiated by the higher node in dfs  a  prevails  and the other one is dropped  to
determine which traversal to pursue and which one to drop  xk compares the depths
i
of rooti
k and xr in dfs  a   if xr is higher  then it becomes the new rootk   xk
overrides all the previous dfs i information with the one from the new token  it
then continues the token passing with the new token as in algorithm   
to see why it is necessary to also start propagations from the children of removed nodes  step
    consider again the example from figure    removing x   and x  completely disconnects the
subtree  x    x    x     x    x     x      had x  not started a propagation  this subtree would not
have been visited at all since there are no connections between the rest of the problem and any
nodes in the subtree      
lemma    dfs correctness  algorithm   constructs a correct dfs arrangement  or forest  
dfs i for dcop  ai   given a correct dfs arrangement dfs  a  for dcop  a  
p roof  first  since a dfs i is started from each child of a node that was controlled by ai   and also
from the root  it is ensured that each connected component is dfs traversed at least once  follows
from step     second  each dfs process is similar to a normal dfs construction  in that each node
sends the token to all its neighbors  except for the ones controlled by ai    it is just that they do so in
a pre specified order  the one given by dfs  a    it follows that all nodes in a connected component
will eventually be visited  follows from step     third  higher priority dfs traversals override the
lower priority ones  i e  dfs traversals initiated by nodes higher in the tree have priority   again by
step    eventually one single dfs traversal is performed in a single connected component   
lemma    dfs robustness  the dfs arrangement  dfs i   constructed by algorithm   is nonmanipulable by agent ai   for any input dfs arrangement from the solution phase to dcop  a  
p roof  this follows directly from step    since ai does not participate in the process at all  its
neighbors do not send it any messages  see algorithm    line     and any messages it may send are
simply ignored  see algorithm    line     
in fact  no additional links are created while constructing dfs i   the only possible changes
are that some edges can reverse their direction  parents children or pseudoparents pseudochildren
    some of the dfs traversals initiated in step   are redundant and the same part of the problem graph can be visited
more than once  the simple overriding rule in step   ensures that only a single dfs i tree is eventually adopted
in each connected component  namely the one that is initiated by the highest node in the original dfs  a   for
example  in figure    x  starts an unnecessary dfs i propagation  which is eventually stopped by x    which
receives a higher priority dfs i token from x    since x  knows that x  is higher in dfs  a  than x    it drops
the propagation initiated by x    and relays only the one initiated by x    it does so by sending x  the token for
dfs i received from x  to which it adds itself  upon receiving the new token from x    node x  realizes that
x  is its new parent in dfs i   thus  the redundant propagation initiated by x  is eliminated and the result is a
consistent dfs subtree for the single connected component p   
    a simple time out mechanism can be used to ensure that each agent knows when its provisional dfs ordering is final
 i e  no higher priority dfs traversals will arrive in the future  

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

can switch places   and existing back edges can turn into tree edges  again  one can see this in
figure     
    phase two of m dpop for a marginal problem  utili propagations
once dfs i is built  the marginal problem without ai is then solved on dfs i   utility propagation proceeds as in normal dpop except that nodes determine whether the util message that was
sent in dpop  a  can be reused  this is signaled to their parent by sending a special null util
message  more specifically  the process is as follows 
 the leaves in dfs i initiate utili propagations 
   if the leaves in dfs i observe no changes in their local dfs i arrangement as compared to dfs  a  then the util message they sent in dcop  a  remains valid and
they announce this to their parents by sending instead a null utili message 
   otherwise  a leaf node computes its util message anew and sends it to their  new 
parent in dfs i  
 all other nodes wait for incoming utili messages and 
   if every incoming messages a node xk receives from its children is null and there are
no changes in the parent pseudoparents then it can propagate a null utili message
to its parent 
   otherwise  xk has to recompute its utili message  it does so by reusing all the util
messages that it received in dcop  a  from children that have sent it null messages in
dcop  ai   and joining these with any new util messages received 
for example  consider dcop  ai   in figure    where x   and x   are children of x     x  
has to recompute a util message and send it to its new parent x    to do this  it can reuse the
messages sent by x   and x   in dcop  a   because neither of these sending subtrees contain ai  
  
by doing so  x   reuses the effort spent in dcop  a  to compute the messages util  
     util    
  
util  
   and util    
theorem   the m dpop algorithm is a faithful distributed implementation of efficient social
choice and terminates with the outcome of the vcg mechanism 
p roof  from the partition principle and appeal to theorem    and in turn to theorem     first 
agent ai cannot prevent the construction of a valid dfs i for dcop  ai    lemmas   and    
second  agent ai cannot influence the execution of dpop on dcop  ai   because all messages
that ai influenced in the main problem dcop  a  are recomputed by the system without ai   the
rest of the proof follows as for simple m dpop  leveraging the locality of the tax payment messages
and the enforcement provided by the bank and via the catastrophic failure assumption   
    a simple alternative is to have children of all nodes xki that belong to ai   create a bypass link to the first ancestor of
xki that does not belong to ai   for example  in figure    x  and x  could each create a link with x  to bypass x 
completely in dfs  ai    however  additional communication links may be required in this approach 

   

fip etcu   faltings     parkes

   experimental evaluation  understanding the effectiveness of m dpop
we present the results of our experimental evaluation of dpop  simple m dpop and m dpop in
two different domains  distributed meeting scheduling problems  ms   and combinatorial auctions
 cas   in the first set of experiments we investigate the performance of m dpop on a structured
constraint optimization problem  ms  which has received a lot of attention in cooperative distributed
constraint optimization  in the second set of experiments  cas   we investigate unstructured domains  and observe the performance  specifically the ability to re use computation in computing
payments  of m dpop with respect to problem density  cas provide an abstract model of many
real world allocation problems and are much studied in mechanism design  cramton  shoham   
steinberg        
    distributed meeting scheduling
in distributed meeting scheduling  we consider a set of agents working for a large organization and
representing individuals  or groups of individuals  and engaged in scheduling meetings for some
upcoming period of time  although the agents themselves are self interested  the organization as
a whole requires an optimal overall schedule  that minimizes cost  alternatively  maximizes the
utility of the agents   this makes it necessary to use a faithful distributed implementation such as
m dpop  in enabling this  we suppose that the organization distributes a virtual currency to each
agent  perhaps using this currency allocation to prioritize particular participants   all relations held
by agents and defining an agents utility for a solution to the scheduling problem are thus stated in
units of this currency 
each agent ai has a set of local replicate variables xji for each meeting mj in which it is
involved  the domain of each variable xj  and thus local replicas xji   represents the feasible
time slots for the meeting  an equality constraint is included between replica variables to ensure
that meeting times are aligned across agents  since an agent cannot participate in more than one
meeting at once there is an all different constraint on all variables xij belonging to the same agent 
this is modeled as a clique constraint between these meeting variables  each agent assigns a utility
to each possible time for each meeting by imposing a unary relation on each variable xji   each such
relation is private to ai   and denotes how much utility ai associates with starting meeting mj at
each time t  dj   where dj is the domain for meeting mj   the social objective is to find a schedule
in which the total utility is maximized while satisfying the all different constraints for each agent 
following maheswaran et al          we model the organization by providing a hierarchical
structure  in a realistic organization  the majority of interactions are within departments  and only
a small number are across departments and even then these interactions will typically take place
between two departments adjacent in the hierarchy  this hierarchical organization provides structure
to our test instances  with high probability  around      we generate meetings within departments 
and with a lower probability  around      we generate meetings between agents belonging to
parent child departments  we generated random problems having this structure  with an increasing
number of agents  from    to     agents  each agent participates in   to   meetings  and has a
uniform random utility between   and    for each possible schedule for each meeting in which it
participates  the problems are generated such that they have feasible solutions   
    the test instances can be found at http   liawww epfl ch people apetcu research mdpop msexperiments tgz

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

for each problem size  we averaged the results over     different instances  we solved the main
problems using dpop and the marginal ones using simple m dpop  and m dpop respectively  all
experiments were performed in the frodo multiagent simulation environment  petcu         on
a    ghz  gb ram laptop  frodo is a simulated multiagent system  where each agent executes
asynchronously in its own thread  and communicates with its peers only via message exchange 
the experiments were geared towards showing how much effort m dpop is able to reuse from
the main to the marginal problems  figure     shows the absolute computational effort in terms
of number of messages  figure     a    and in terms of the total size of the messages exchanged 
in bytes  figure     b    the curves for dpop represent just the number of messages  total size
of messages  respectively  required for solving the cooperative problem  the curves for simplem dpop and m dpop represent the total number  size  respectively  of util messages  for both
main and marginal economies 
we notice several interesting facts  first  the number of messages required by dpop increases
linearly with the number of agents because dpops complexity in terms of number of messages is
always linear in the size of the problem  on the other hand  the number of messages of simple mdpop increases roughly quadratically with the number of agents  since it solves a linear number
of marginal economies from scratch using dpop  each requiring a linear number of messages 
the performance of m dpop lies somewhere between the dpop and simple m dpop with more
advantage achieved over simple m dpop as the size of the problem increases  culminating with
almost an order of magnitude improvement over simple m dpop for the largest problem sizes  i e 
with     agents in the problem   similar observations can be made about the total size of the util
messages  also a good measure of computation  traffic and memory requirements  by inspecting
figure     b   for both metrics we find that the performance of m dpop is only slightly superlinear in the size of the problem 
figure   shows the percentage of the additional effort required for solving the marginal problems
that can be reused from the main problem  i e  the probability that a util message required in solving a marginal problem can be taken directly from the message already used in the main problem 
we clearly see that as the problem size increases we can actually reuse more and more computation
from the main problem  the intuition behind this is that in large problems  each individual agent
is localized in a particular area of the problem  this translates into the agent being localized in a
specific branch of the tree  thus rendering all computation performed in other branches reusable for
the marginal problem that corresponds to that respective agent  looking also at the percentage of
reuse when defined in terms of message size rather than the number of messages we see that this is
also trending upwards as the size of the problem increases 
    combinatorial auctions
combinatorial auctions  cas  are a popular means to allocate resources to multiple agents  in cas 
bidders can bid on bundles of goods  as opposed to bidding on single goods   combinatorial bids
can model both complementarity and substitutability among the goods  i e  when the valuation for
the bundle is more  respectively less than the sum of the valuations for individual items  in our
setting the agents are distributed  geographically or logically   and form a problem graph in which
neighbors are agents with whom their bids overlap  the objective is to find the feasible solution  i e 
declare bids as winning or losing such that no two winning bids share a good  that maximizes the
total utility of the agents 
   

fip etcu   faltings     parkes

      

 e   

     
  of messages

dpop
simple m dpop
m dpop

total size of util messages

dpop
simple m dpop
m dpop

    

   

 e   

      

     

  

    
  

  

  

  

  

  

  

  

      

  

  

number of agents

  

  

  

  

  

  

      

number of agents

 a  number of messages

 b  total size of util messages  in valuations 

figure    meeting scheduling problem  measures of absolute computational effort  in terms of the number

  of effort for marginals reused from main

of messages sent and the total size of the util messages  in dpop  simple m dpop and mdpop  the curves for dpop represent effort spent just on the main problem  while the ones for
simple m dpop and m dpop represent total effort over the main and the marginal problems 

  
  
  
  
  
  
  
  

total information
number of messages

  
  

  

  

  

  

  

  

  

  

   

number of agents

figure    meeting scheduling problem  percentage of effort required for the marginal problems that is
reused by m dpop from the main problem  reuse is measured both in terms of the percentage
of the util messages that can be reused  dashed  and also in terms of the total size of the util
messages that are reused as a fraction of the total util message size  solid  

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

cas are adopted here as a stylized model of distributed allocation problems such as airport slot
allocation and wireless spectrum allocation as discussed in the introduction  the ca instances also
provide a counterpoint to the meeting scheduling problems because they represent problems with
less structure  in our dcop model  each agent holds a variable for each one of its bids  with two
possible values    when the bid is rejected  and   when the bid is accepted  any pair of overlapping
bids  bids that share at least one good  is connected by a at most one constraint that specifies
that they cannot be both accepted  when multiple bids are submitted by an agent then they can be
connected by additional constraints to capture the bid logic  for instance exclusive or constraints if
only one bid can be accepted 
we generated random problems using cats  leyton brown  pearson    shoham         using
the l  distribution from sandholm         l  is the constant distribution in which each agent
demands a bundle of   goods  selected uniformly at random  and with a value distributed uniformly
on         in our simulations we consider a market with    goods and vary the number of agents
between   and     we recorded the performance of dpop  simple mdpop and m dpop in the
graphs from figures   and     figure   shows that as the density of the problems increase  all three
algorithms require more effort in solving them  both in terms of number of messages  and in terms
of total information exchange  
figure    shows how reusability varies with problem density  one can see that for loose problems the reusability is very good  close to      for problems with   agents  as the density of the
problems increases with the number of agents  reusability decreases as well  and is around     for
the most dense problems  with    agents  we explain this phenomenon as follows  for very loose
problems  many goods and few bidders   the bids are mostly non overlapping  which in turn ensures
that removing individual agents for solving the marginal problems does not affect the computation
performed while solving the main problem  at the other end of the spectrum  very dense problems
tend to be highly connected  which produces dfs trees which are very similar to chains  in such a
case  removing agents which are close to the bottom of the chain invalidates much of the computation performed while solving the main problem  therefore  only a limited amount of computation
can be reused 
while noting that l  is recognized as one of the hardest problem distributions in the cats
suite  leyton brown et al          we remark that we need to limit our experiments to this distribution because other problems have a large induced tree width  and high density problem graphs  
consider for example a problem in which every agent bids for a bundle that overlaps with every
other agent  the problem graph is a clique and dpop does not scale  while we leave a detailed
examination for future work  a recent extension of dpop  h dpop  kumar  petcu    faltings 
       can immediately address this issue  in h dpop  consistency techniques are used in order
to compactly represent util messages  and on tightly constrained problems  orders of magnitude
improvements over dpop are reported  see section      

   discussion
in this section we discuss alternatives for improving the computational performance of m dpop 
the possibility of faithful variations of other dcop algorithms  adopt  modi et al         and
optapo  mailler   lesser          and the loss in utility for the agents that can occur due to the
transfer of payments to the bank  mentioning an approach to address this problem 
   

fip etcu   faltings     parkes

     

 e   
total size of util messages

dpop
simple m dpop
m dpop
  of messages

    

   

  

dpop
simple m dpop
m dpop

 e   
 e   
      
     
    
   
  

 

 
 

  

  
  
  
  
number of agents

  

  

 

 a  number of messages

  

  
  
  
  
number of agents

  

  

 b  total size of util messages  in valuations 

figure    combinatorial auctions problems  measures of absolute computational effort  in terms of the

  of effort for marginals reused from main

number of messages sent and the total size of the util messages  in dpop  simple m dpop and
m dpop  the curves for dpop represent effort spent just on the main problem  while the ones
for simple m dpop and m dpop represent effort on both the main and the marginal problems 
the higher the number of agents  and thus bids  and thus constraints in the problem graph and
problem density   the greater the computational effort to solve the problem 

   
  
  
  
  
  
  
  
total information
number of messages

  
  
 

  

  

  

  

  

  

  

number of agents

figure     combinatorial auctions problems  percentage of effort required for the marginal problems that
is reused by m dpop from the main problem  reuse is measured both in terms of the percentage
of the util messages that can be reused  dashed  and also in terms of the total size of the util
messages that are reused as a fraction of the total util message size  solid  

   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

    algorithmic alternatives for improved performance
m dpop scales very well with problem size as long as the induced width of the problem remains
low  this is a characteristic m dpop inherits from dpop  on which it is based  for problems
with high induced width  dpop m dpop require producing  sending and storing large messages 
which may be unfeasible or undesirable  to mitigate this problem  several advances to the basic
dpop algorithm have been recently proposed  some of these new algorithms sacrifice optimality in
return for computational tractability  which makes them difficult to combine with a vcg payment
mechanism in such a way that faithfulness be guaranteed  nevertheless  h dpop  kumar et al  
      and mb dpop  petcu   faltings        employ two different techniques that preserve the
optimality guarantees  and can be fitted to m dpop 
h dpop leverages the observation that many real problems contain hard constraints that significantly reduce the space of feasible assignments  for example  in auctions  it is not possible to
allocate an item to more than one bidder  in meeting scheduling  it is not possible to set two different start times for a given meeting  unfortunately  dpop does not take advantage of the pruning
power of these hard constraints  and sends messages that explicitly represent all value combinations  including many infeasible ones  h dpop addresses this issue by using constraint decision
diagrams  cdd  introduced by cheng and yap        to compactly represent util messages by
excluding unfeasible combinations  performance improvements of several orders of magnitude can
be achieved  especially on highly constrained problems  kumar et al         
mb dpop  petcu   faltings        uses the idea of cycle cutsets  dechter        to explore
parts of the search space sequentially  dense parts of the problem are explored by iterating through
assignments of a subset of nodes designated as cycle cuts  and for each assignment performing
a limited util propagation similar to the one from dpop  easy parts of the problem are explored
with one shot util messages  exactly as in dpop  mb dpop offers thus a configurable tradeoff
between the number of the messages exchanged  and the size of these messages and the memory
requirements 
    achieving faithfulness with other dcop algorithms
the partition principle  described in section      is algorithm independent  the question as to
whether another  optimal dcop algorithm can be made faithful therefore revolves  critically  around
whether the algorithm will satisfy the robustness requirement of the partition priciple  we make the
following observations 
 robustness in the first sense  i e  that no agent ai can influence the solution to the efficient scp without agent ai   is always achievable at the cost of restarting computation on the
marginal problem with each agent removed in turn  just as we proposed for simple m dpop 
 robustness in the second sense  i e  that no agent ai can influence the report s  that the bank
receives about the negative externality that ai imposes on the rest of the system  conditioning
on the solutions to the main problem and the problem without ai   requires that the dcop
algorithm terminates with every agent knowing the part of the solution that is relevant in
defining its own utility  the robustness property then follows by disaggregation of payments 
thus  if one is content to restart the dcop algorithm multiple times  then the same kinds of
results that we provide for simple m dpop are generally available  this is possible because of
   

fip etcu   faltings     parkes

the already mentioned locality property of payments  which follows from the disaggregation of
the vcg payment across agents in eq       and because of the information and communication
structure of dcop 
the other useful property of dcop in the context of self interested agents  and worth reemphasizing  is that it is possible to retain faithfulness even when one agent plays a pivotal role in
connecting the problem graph  suppose that problem  dcop  ai    becomes disconnected without ai   but  if this is the case then its optimal solution is represented by the union of the optimal
solutions in each connected subcomponent of the problem  and no information needs to flow between disconnected components either for the purpose of solving the problem or for the purpose of
reporting the components of agent ai s tax 
we discuss in the following two sections the adaptation of the two other most prominent complete dcop algorithms  adopt  modi et al         and optapo  mailler   lesser        
we discuss in the following two sections the adaptation of the two other most prominent complete dcop algorithms  adopt  modi et al         and optapo  mailler   lesser         we
consider the computational aspects of making these algorithms faithful  specifically the issues related to the efficient handling of replica variables and to providing for reusability from the main to
the marginal problems 
      u sing adopt

for

faithful   e fficient s ocial c hoice

adopt is a polynomial space search algorithm for dcop that is guaranteed to find the globally
optimal solution while allowing agents to execute asynchronously and in parallel  the agents in
adopt make local decisions based on conservative cost estimates  adopt also works on a dfs
arrangement  constructed as detailed in section        roughly speaking  the main process that is
executed in adopt is a backtrack search on the dfs tree 
adaptation of adopt to the dcop model with replicated variables  adopts complexity
is given by the number of messages  which is exponential in the height of the dfs tree  similar to
dpop  using the dcop model with replicated variables could artificially increase the complexity
of the solving process  specifically  the height of the dfs tree is increased when using replicated
variables compared to the centralized problem graph  adopt can be modified to exploit the special
structure of these replicated local variables in a similar way as dpop  specifically  adopt should
explore sequentially only the values of the original variable  and ignore assignments where replicas
of the same variable take different values  this works by allowing just the agent that owns the
highest replica of each variable to freely choose values for the variable  this agent then announces
the new value of the variable to all other agents owning replicas of the variable  these other agents
would then consider just the announced value for their replicas  add their own corresponding utilities  and continue the search process  using this special handling of the replica variables  the
resulting complexity is no longer exponential in the height of the distributed dfs tree  but in the
height of the dfs tree obtained by traversing the original problem graph  for example  in figure    it is sufficient to explore the values of m     and directly assign these values to m   and m  
via value messages  without trying all the combinations of their values  this reduces adopts
complexity from exponential in    to exponential in   
reusability of computation in adopt  turning to the re use of computation from the main to
the marginal problems  we note that because adopt uses a dfs arrangement then it is easy to
identify which parts of the dfs arrangement for the main problem are impossible for an agent to
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

manipulate  and therefore can be reused while computing the solution to the marginal problem
with that agent removed  however  a major difference between dpop and adopt is that in dpop 
each agent stores its outgoing util message  and thus has available all the utilities contingent to
all assignments of the variables in the agents separator  this makes it possible for the agent to
simply reuse that information in all marginal economies where the structure of the dfs proves that
this is safe  in contrast  adopt does not store all this information because of its linear memory
policy  this in turn makes it impossible to reuse computation from the main problem to the marginal
problems  all marginal problems have to be solved from scratch  and thus the performance would
scale poorly as problem size increases and even in structured problems such as meeting scheduling 
we see two alternatives for addressing this problem   a  renounce linear memory guarantees 
and use a caching scheme like for example in ncbb  chechetka   sycara         this would allow
for a similar reusability as in m dpop  where previously computated utilities can be extracted from
the cache instead of having to be recomputed  alternatively   b  one can devise a scheme where
the previously computed best solution can be saved as a reference  and subsequently used as an
approximation while solving the marginal problems  this could possibly provide better bounds and
thus allow for better pruning  such that some computation could be saved  both these alternatives
are outside the scope of this paper  and considered for future work 
      u sing o ptapo

for

faithful   e fficient s ocial c hoice

optapo  mailler   lesser        is the other most popular algorithm for dcop  similar to the
adaptations of dpop and adopt to social choice  optapo can also be made to take advantage of
the special features of the dcop model with replicated variables  its complexity then would not
be artificially increased by the use of this dcop model  optapo has the particularity that it uses
mediator agents to centralize subproblems and solve them in dynamic and asynchronous mediation sessions  i e  partial centralization  the mediator agents then announce their results to the other
agents  who have previously sent their subproblems to the mediators  this process alone would
introduce additional possibility for manipulation in a setting with self interested agents  however 
using the vcg mechanism addresses this concern and agents will choose to behave correctly according to the protocol 
as with adopt  the main issue with using optapo for faithful social choice is the reusability
of computation from the main to the marginal problems  specifically  consider that while solving the
main problem  a mediator agent ai has centralized and aggregated the preferences of a number of
other agents  while solving mediation problems as dictated by the optapo protocol  subsequently 
when trying to compute the solution to the marginal problem without agent ai   all this computation
has to go to waste  as it could have been manipulated by ai while solving the main problem  furthermore  since optapos centralization process is asynchronous and conflict driven as opposed
to structure driven as in m dpop  it is unclear whether any computation from the main problem
could be safely reused in any of the marginal problems  to make matters worse  experimental studies  davin   modi        petcu   faltings        show that in many situations  optapo ends up
relying on a single agent in the system to centralize and solve the whole problem  this implies
that while solving the marginal problem without that agent  one can reuse zero effort from the main
problem 
   

fip etcu   faltings     parkes

    loss in utility due to wasting the vcg taxes
in the vcg mechanism  each agents net utility is the difference between the utility it derives from
the optimal solution and the vcg tax it has to pay  the net utility of the whole group of agents is
the sum of individual net utilities of the agents  i e  the total utility from the assignment of values
to variables but net of the total payment made by agents to the bank  this loss in utility while
using m dpop can be as great as     of the total utility of the optimal solution in the meeting
scheduling domain  as the problem size increases  more and more money has to be burnt in the
form of vcg taxes  similar waste has been observed by others  e g   faltings         also in the
context of efficient social choice 
one cannot naively redistribute the payment back to the agents  for instance sharing the payments equally across all agents would break faithfulness  for example  agent ai would prefer for
the other agents to make greater payments  in order to receive a larger repayment from the bank 
the faithfulness properties of m dpop would unravel  on the other hand  when the problem has
inherent structure then it is possible to redistribute some fraction of the payments back to agents 
this idea of careful redistribution was suggested in bailey         and subsequently extended by
cavallo         guo and conitzer        and moulin         another approach  advocated for example by faltings         is to simply preclude an agent from the problem and transfer the payments
to this agent  all this work is in a centralized context 
an important issue for future work  then  is to study the budget surplus that accrues to the bank
in m dpop and seek to mitigate this welfare loss in a setting of distributed implementation  we
defer any further discussion of this topic to future work  in which we will investigate methods to
leverage structure in the problem in redistributing the majority of these payments back to agents
without compromising either efficiency or faithfulness 

   conclusions
we have developed m dpop  which is a faithful  distributed algorithm with which to solve efficient
social choice problems in multi agent systems with private information and self interest  no agent
can improve its utility either by misreporting its local information or deviating from any aspect of
the algorithm  e g   computation  message passing  information revelation   the only centralized
component is that of a bank that is able to receive messages about payments and collect payments 
in addition to promoting efficient decisions  we minimize the amount of additional computational
effort required for computing the vcg payments by reusing effort from the main problem  a first
set of experimental results shows that a significant amount of the computation required in all the
marginal problems can be reused from the main problem  sometimes above      this provides
near linear scalability in massive  distributed social choice problems that have local structure so
that the maximal induced tree width is small  a second set of experiments performed on problems
without local structure shows that as the problem density increases  the amount of effort required increases  and the reusability of computation decreases  these results suggest that m dpop is a very
good candidate for solving loose problems that exhibit local structure such that the induced width
remains small  in addition to addressing the need to reduce the total payments made by agents to the
bank  one issue for future work relates to the need to provide robustness when faced with adversarial
or faulty agents  the current solution is fragile in this sense  with its equilibrium properties relying
on other agents following the protocol  some papers  lysyanskaya   triandopoulos        aiyer 
alvisi  clement  dahlin  martin    porth        shneidman   parkes        provide robustness to
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

mixture models  e g  some rational  some adversarial  but we are not aware of any work with these
mixture models in the context of efficient social choice  another interesting direction is to find ways
to allow for approximate social choice  for example with memory limited dpop variations  petcu
  faltings      a  while retaining incentive properties  perhaps in approximate equilibria  future
research should also consider the design of distributed protocols that are robust against false name
manipulations in which agents can participate under multiple pseudonyms  yokoo et al         
and seek to mitigate the opportunities for collusive behavior and the possibility of multiple equilibria that can exist in incentive mechanisms  ausubel   milgrom        andelman  feldman   
mansour        katz   gordon        

acknowledgments
parkes is supported in part by national science foundation grants iis          iis         and an
alfred p  sloan foundation award  petcu was supported by the swiss national science foundation
grant                  the authors would like to thank wei xue for valuable feedback on several
parts of the paper  we thank jeffrey shneidman for his feedback on an early version of this paper 
we also thank aaron bernstein for valuable insights on the dfs reconstruction process  the three
anonymous reviewers also provided excellent suggestions for improving the exposition of this work 
an earlier version of this paper appeared in the proc  fifth international joint conference on
autonomous agents and multiagent systems  aamas        

references
abu amara  h  h          fault tolerant distributed algorithm for election in complete networks  ieee
trans  comput                 
aiyer  a  s   alvisi  l   clement  a   dahlin  m   martin  j  p     porth  c          bar fault tolerance for
cooperative services  in   th acm symposium on operating systems principles 
andelman  n   feldman  m     mansour  y          strong price of anarchy  in acm siam symposium on
discrete algorithms       soda    
arnborg  s          efficient algorithms for combinatorial problems on graphs with bounded decomposability
  a survey  bit             
ausubel  l   cramton  p     milgrom  p          the clock proxy auction  a practical combinatorial auction
design  in cramton et al   cramton et al          chap    
ausubel  l     milgrom  p          the lovely but lonely vickrey auction  in cramton et al   cramton et al  
       chap    
bailey  m  j          the demand revealing process  to distribute the surplus  publicchoice         
ball  m   donohue  g     hoffman  k          auctions for the safe  efficient  and equitable allocation of
airspace system resources  in cramton  shoham  s   ed    combinatorial auctions  mit press 
barbosa  v          an introduction to distributed algorithms  the mit press 
bayardo  r     miranker  d          on the space time trade off in solving constraint satisfaction problems   in proceedings of the   th international joint conference on artificial intelligence  ijcai    
montreal  canada 
bidyuk  b     dechter  r          on finding minimal w cutset  in auai     proceedings of the   th
conference on uncertainty in artificial intelligence  pp        arlington  virginia  united states 
auai press 
   

fip etcu   faltings     parkes

bikhchandani  s   de vries  s   schummer  j     vohra  r  v          linear programming and vickrey
auctions  in dietrich  b     vohra  r   eds    mathematics of the internet  e auction and markets  pp 
       ima volumes in mathematics and its applications  springer verlag 
cavallo  r          optimal decision making with minimal waste  strategyproof redistribution of vcg payments  in proc  of the  th int  joint conf  on autonomous agents and multi agent systems  aamas    
chechetka  a     sycara  k          an any space algorithm for distributed constraint optimization  in
proceedings of aaai spring symposium on distributed plan and schedule management 
cheng  k  c  k     yap  r  h  c          constrained decision diagrams   in proceedings of the national
conference on artificial intelligence  aaai     pp          pittsburgh  usa 
cheung  t  y          graph traversal techniques and the maximum flow problem in distributed computation  
ieee trans  software eng                
cidon  i          yet another distributed depth first search algorithm  inf  process  letters                
collin  z   dechter  r     katz  s          on the feasibility of distributed constraint satisfaction  in
proceedings of the   th international joint conference on artificial intelligence  ijcai     pp     
     sidney  australia 
collin  z   dechter  r     katz  s          self stabilizing distributed constraint satisfaction  chicago journal
of theoretical computer science 
collin  z     dolev  s          self stabilizing depth first search  information processing letters        
       
cramton  p   shoham  y     steinberg  r   eds            combinatorial auctions  mit press 
davin  j     modi  p  j          impact of problem centralization in distributed constraint optimization
algorithms  in aamas     proceedings of the fourth international joint conference on autonomous
agents and multiagent systems  pp            new york  ny  usa  acm press 
davis  r     smith  r  g          negotiation as a metaphor for distributed problem solving  artificial
intelligence        
de vries  s     vohra  r  v          combinatorial auctions  a survey  informs journal on computing        
       
dechter  r          constraint processing  morgan kaufmann 
dechter  r     mateescu  r          and or search spaces for graphical models  artificial intelligence  to
appear 
dunne  p  e          extremal behaviour in multiagent contract negotiation  journal of artificial intelligence
research  jair            
dunne  p  e   wooldridge  m     laurence  m          the complexity of contract negotiation  artificial
intelligence journal                 
endriss  u   maudet  n   sadri  f     toni  f          negotiating socially optimal allocations of resources 
journal of artificial intelligence research             
ephrati  e     rosenschein  j          the clarke tax as a consensus mechanism among automated agents 
in proceedings of the national conference on artificial intelligence  aaai     pp          anaheim 
ca 
faltings  b          a budget balanced  incentive compatible scheme for social choice  in workshop on
agent mediated e commerce  amec  vi  springer lecture notes in computer science 
faltings  b   parkes  d   petcu  a     shneidman  j          optimizing streaming applications with selfinterested users using m dpop  in comsoc    international workshop on computational social
choice  pp          amsterdam  the netherlands 
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

feigenbaum  j   papadimitriou  c   sami  r     shenker  s          a bgp based mechanism for lowest cost
routing  in proceedings of the      acm symposium on principles of distributed computing  pp 
       
feigenbaum  j   ramachandran  v     schapira  m          incentive compatible interdomain routing  in
proceedings of the  th conference on electronic commerce  pp         
feigenbaum  j     shenker  s          distributed algorithmic mechanism design  recent results and
future directions  in proceedings of the  th international workshop on discrete algorithms and
methods for mobile computing and communications  pp      
freuder  e  c     quinn  m  j          taking advantage of stable sets of variables in constraint satisfaction
problems  in proceedings of the  th international joint conference on artificial intelligence  ijcai    pp            los angeles  ca 
gershman  a   meisels  a     zivan  r          asynchronous forward bounding for distributed constraints
optimization  in proceedings of the   th european conference on artificial intelligence  ecai     
riva del garda  italy 
greenstadt  r   pearce  j  p     tambe  m          analysis of privacy loss in distributed constraint optimization  in proc  of twenty first national conference on artificial intelligence  aaai     
guo  m     conitzer  v          worst case optimal redistribution of vcg payments  in proceedings of the
 th acm conference on electronic commerce  ec      pp       
huebsch  r   hellerstein  j  m   lanham  n   et al          querying the internet with pier  in vldb 
izmalkov  s   micali  s     lepinski  m          rational secure computation and ideal mechanism design 
in focs     proceedings of the   th annual ieee symposium on foundations of computer science 
pp          washington  dc  usa  ieee computer society 
jackson  m  o          mechanism theory  in the encyclopedia of life support systems  eolss publishers 
jackson  m  o          a crash course in implementation theory  social choice and welfare                
katz  j     gordon  s  d          rational secret sharing  revisited  in proc  security and cryptography for
networks 
kloks  t          treewidth  computations and approximations  vol      of lecture notes in computer
science  springer 
krishna  v          auction theory  academic press 
kumar  a   petcu  a     faltings  b          h dpop  using hard constraints to prune the search space  in
ijcai     distributed constraint reasoning workshop  dcr    pp        hyderabad  india 
lavi  r   mualem  a     nisan  n          towards a characterization of truthful combinatorial auctions  in
proc    th annual symposium on foundations of computer science 
leyton brown  k   pearson  m     shoham  y          towards a universal test suite for combinatorial
auction algorithms  in proceedings of acm conference on electronic commerce  ec     pp     
    
leyton brown  k     shoham  y          a test suite for combinatorial auctions  in cramton  p   shoham 
y     steinberg  r   eds    combinatorial auctions  chap      mit press 
lysyanskaya  a     triandopoulos  n          rationality and adversarial behavior in multi party computation  in   th annual int  cryptology conference  crypto    
maheswaran  r  t   tambe  m   bowring  e   pearce  j  p     varakantham  p          taking dcop to the
real world  efficient complete solutions for distributed multi event scheduling  in aamas    
mailler  r     lesser  v          solving distributed constraint optimization problems using cooperative mediation  proceedings of third international joint conference on autonomous agents and multiagent
systems  aamas                  
   

fip etcu   faltings     parkes

mailler  r     lesser  v          asynchronous partial overlay  a new algorithm for solving distributed
constraint satisfaction problems  journal of artificial intelligence research  jair  
mas colell  a   whinston  m  d     green  j  r          microeconomic theory  oxford university press 
mishra  d     parkes  d          ascending price vickrey auctions for general valuations  journal of
economic theory              
modi  p  j   shen  w  m   tambe  m     yokoo  m          adopt  asynchronous distributed constraint
optimization with quality guarantees  ai journal              
monderer  d     tennenholtz  m          distributed games  from mechanisms to protocols  in proc    th
national conference on artificial intelligence  aaai      pp       
moulin  h          efficient  strategy proof and almost budget balanced assignment  tech  rep   rice university 
mualem  a          on decentralized incentive compatible mechanisms for partially informed environments 
in proc  acm conf  on electronic commerce  ec  
ostrovsky  r   rajagopalan  s     vazirani  u          simple and efficient leader election in the full information model  in stoc     proceedings of the twenty sixth annual acm symposium on theory of
computing  pp          new york  ny  usa  acm press 
parkes  d  c   kalagnanam  j  r     eso  m          achieving budget balance with vickrey based payment
schemes in exchanges  in proc    th international joint conference on artificial intelligence  ijcai     pp           
parkes  d  c     shneidman  j          distributed implementations of vickrey clarke groves mechanisms 
in proc   rd int  joint conf  on autonomous agents and multi agent systems  pp         
parkes  d  c     ungar  l  h          iterative combinatorial auctions  theory and practice  in proc    th
national conference on artificial intelligence  aaai      pp       
petcu  a          frodo  a framework for open and distributed constraint optimization  technical
report no            swiss federal institute of technology  epfl   lausanne  switzerland  http 
  liawww epfl ch frodo  
petcu  a     faltings  b       a   a dpop  approximations in distributed optimization  in proceedings
of the eleventh international conference on principles and practice of constraint programming
 cp     pp          sitges  spain 
petcu  a     faltings  b       b   dpop  a scalable method for multiagent constraint optimization  in
proceedings of the   th international joint conference on artificial intelligence  ijcai     pp     
     edinburgh  scotland 
petcu  a     faltings  b          pc dpop  a partial centralization extension of dpop  in in proceedings of
the second international workshop on distributed constraint satisfaction problems  ecai    riva
del garda  italy 
petcu  a     faltings  b          mb dpop  a new memory bounded algorithm for distributed optimization  in proceedings of the   th international joint conference on artificial intelligence  ijcai    
hyderabad  india 
pietzuch  p   ledlie  j   shneidman  j   roussopoulos  m   welsh  m     seltzer  m          network aware
operator placement for stream processing systems  in icde 
rassenti  s  j   smith  v  l     bulfin  r  l          a combinatorial mechanism for airport time slot allocation  bell journal of economics             
roberts  k          the characterization of implementable rules  in laffont  j  j   ed    aggregation and
revelation of preferences  pp          north holland  amsterdam 
rosenschein  j  s     zlotkin  g          designing conventions for automated negotiation  ai magazine 
fall 
   

fim dpop  faithful d istributed i mplementation of e fficient s ocial c hoice p roblems

sandholm  t          algorithm for optimal winner determination in combinatorial auctions  artificial
intelligence           
sandholm  t  w          an implementation of the contract net protocol based on marginal cost calculations  in proc    th national conference on artificial intelligence  aaai      pp         
sandholm  t  w          limitations of the vickrey auction in computational multiagent systems  in second
international conference on multiagent systems  icmas      pp         
shneidman  j     parkes  d  c          rationality and self interest in peer to peer networks  in  nd int 
workshop on peer to peer systems  iptps    
shneidman  j     parkes  d  c          specification faithfulness in networks with rational nodes  in proc 
  rd acm symp  on principles of distributed computing  podc     st  johns  canada 
silaghi  m  c   sam haroud  d     faltings  b          asynchronous search with aggregations  in
aaai iaai  pp          austin  texas 
solotorevsky  g   gudes  e     meisels  a          modeling and solving distributed constraint satisfaction
problems  dcsps   in proceedings of the second international conference on principles and practice
of constraint programming  cp     pp          cambridge  massachusetts  usa 
sycara  k   roth  s  f   sadeh koniecpol  n     fox  m  s          distributed constrained heuristic search 
ieee transactions on systems  man  and cybernetics                  
wellman  m  p          a market oriented programming environment and its application to distributed multicommodity flow problems  journal of artificial intelligence research         
wellman  m  p          market oriented programming  some early lessons  in clearwater  s  h   ed   
market based control  a paradigm for distributed resource allocation  chap     pp        world
scientific 
yokoo  m   durfee  e  h   ishida  t     kuwabara  k          distributed constraint satisfaction for formalizing distributed problem solving  in international conference on distributed computing systems  pp 
       
yokoo  m     hirayama  k          algorithms for distributed constraint satisfaction  a review  autonomous
agents and multi agent systems               
yokoo  m   sakurai  y     matsubara  s          the effect of false name bids in combinatorial auctions 
new fraud in internet auctions  games and economic behavior                
zhang  w     wittenburg  l          distributed breakout algorithm for distributed constraint optimization
problems   dbarelax  in proceedings of the international joint conference on autonomous agents
and multi agent systems  aamas      melbourne  australia 
zlotkin  g     rosenschein  j  s          mechanisms for automated negotiation in state oriented domains 
journal of artificial intelligence research            

   

fi