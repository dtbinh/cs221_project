journal artificial intelligence research                  

submitted        published      

ultrametric constraint
application phylogenetics
neil c a  moore

ncam cs st andrews ac uk

computer science  university st  andrews  scotland

patrick prosser

pat dcs gla ac uk

computing science  glasgow university  scotland

abstract
phylogenetic tree shows evolutionary relationships among species  internal nodes
tree represent speciation events leaf nodes correspond species  goal
phylogenetics combine trees larger trees  called supertrees  whilst respecting
relationships original trees  rooted tree exhibits ultrametric property 
is  three leaves tree must one pair deeper recent common
ancestor pairs  three recent common ancestor 
inspires constraint programming encoding rooted trees  present efficient
constraint enforces ultrametric property symmetric array constrained
integer variables  inevitable property lower bounds three variables
mutually supportive  show allows efficient constraint based solution
supertree construction problem  demonstrate versatility constraint
programming exploited allow solutions variants supertree construction
problem 

   introduction
one grand challenges phylogenetics build tree life  tol   representation evolutionary history every living thing  date  biologists catalogued
    million species  yet estimates total number species range      
million      million species identified        placed tol
far  pennisi         applications tol  help understand pathogens
become virulent time  new diseases emerge  recognise species risk
extinction  pennisi        mace  gittleman    purvis         one approach building
tol divide conquer  combining smaller trees available treebase
 treebase        so called supertrees  bininda emonds        approach
complete tol 
date  supertree construction dominated imperative techniques  semple
  steel        semple  daniel  hordijk  page    steel        daniel        bordewich 
evans    semple        ng   wormald        bryant   steel        page       
recently new declarative approaches emerged using constraint programming  gent 
prosser  smith    wei        prosser        beldiceanu  flener    lorca        answer
set programming  wu  you    lin         one properties rooted trees suits
approaches trees nature ultrametric  rooted trees root node
depth    depth nodes   plus depth parent  taking
c
    
ai access foundation  rights reserved 

fimoore   prosser

three leaves a  b c pairs must one pair deeper recent common
ancestor  mrca  pairs  three pairs mrca 
mean ultrametric  three tie minimum  fact 
know depth mrca pairs leaves structure tree uniquely
determined  inspires constraint programming encoding rooted trees  using
ultrametric constraint define later  explore solutions phylogenetic
supertree problem variants  doing  show practicality ultrametric
encoding rooted tree problems  well arguing valuable addition
set techniques supertree problems 
paper organised follows  first  introduce constraint programming
supertree construction problem  propose specialised ultrametric constraint 
terms propagation procedures  maintains bounds z  consistency  bessiere       
three variables  show specialised constraint required models
use toolkit primitives cannot guarantee ultrametric property supertree problem via propagation alone  furthermore  space complexity models becomes
prohibitive  ultrametric constraint extended maintain property
symmetric matrix variables  go show constraint efficiently
applied problem supertree construction  particular applying propagation
model gives polynomial time procedure supertree construction  demonstrate real data give justification improvement time
space previous constraint encodings  one benefits constraint programming approach variants supertree problem addressed within
one model  justify assertion proposing constraint solution finding essential
relations supertree  daniel         addressing ancestral divergence dates  semple
et al         bryant  semple    steel         modelling nested taxa  page        daniel  
semple        coping conflicting data 

   background
section give necessary definitions descriptions constraint satisfaction
problem  tsang         constraint programming  supertree problem 
    constraint programming csp
constraint programming  cp   rossi  van beek    walsh        declarative style
programming problems modelled csp  i e   set variables
assigned values variables domains satisfy set constraints  values
might typically integers drawn finite domains  real numbers ranges 
complex entities sets graphs  considering integers 
definition    constraint satisfaction problem  csp  triple  v  d  c  v set
n variables  v            vn       dom v             dom vn    collection domains 
totally ordered set integer values  c    c            ce   set e constraints 
scope variables scope c     vc            vck   relation rel c  dom vc        dom vck   
assignment value x dom v  variable vi v denoted  vi   x   constraint
c c satisfied assignment   vc    xc              vck   xck    scope c     vc            vck  
   

fithe ultrametric constraint phylogenetics

 xc            xck   rel c   set assignments   v    x              vn   xn    involving every
variable problem solution satisfies constraints c 
constraint solver finds solution csp via process constraint propagation
search  constraint propagation inferencing process takes place variable
initialised loses values  propagation maintains level consistency  arcconsistency  mackworth         across variables  removing values domains
cannot occur solution  i e   removing unsupported values   use definitions
 generalized  arc consistency   g ac  due bessiere        
definition    given csp  v  d  c   constraint c c scope c     vc            vck   
variable v scope c   value x dom v  consistent respect c  alternatively 
supported c  iff exists satisfying assignment     vc    a              vck   ak    c
 v  x  i  ai dom vci    domain dom v   generalized  arcconsistent c iff values dom v  consistent respect c  csp
 generalized  arc consistent variable domains  generalized  arc consistent
constraints c 
arc consistency established csp using algorithm ac   mackworth         sake exposition assume constraints c binary
constraint c counterpart c scope c     va   vb  
scope c      vb   va   rel c     rel   c   example  constraint
cxy   x   constraint cyx     x  heart ac  revise
function  takes binary constraint c argument delivers boolean result 
function removes dom va   values support dom vb   w r t 
constraint c  returns true removals take place  initially constraints added
set s  constraints iteratively removed revised  revise ckm   returns
true becomes  cik  cik c    k    m   step considered
propagation domain reduction variable vk variables constrained vk  
iteration terminates empty variables domain becomes empty 
empty arc consistency algorithm reached fixed point  i e   application
arc consistency process effect domains variables 
problem made arc consistent  domain empties  shown
solutions globally hence stop  ac  algorithm o e d    time
complexity  e number constraints size largest domain  however algorithms achieve time bound o e d     yuanlin   yap        bessiere
  regin        
demonstrate arc consistency example figure   smith        
three constrained integer variables x  z  integer domain        
binary constraints cxy   x      cyz     z even  czx   z    x      since
constraints binary represent problem constraint graph  nodes
vertices edges constraints  initially constraint cxy revised respect x
values        removed dom x   cxy revised w r t  dom y 
becomes         cyz revised w r t  effect revised w r t  z 
effect  revising czx w r t  z reduces dom z  becomes         consequently
constraint cyz added set constraints pending revision  constraint czx
   

fimoore   prosser

      

se



zi

 

y 
n

x 



x
      

z       

z    x    

figure    binary constraint satisfaction problem 
import choco problem 
import choco contradictionexception 
import choco integer   
public class bmstut  
public static void main string   args  throws contradictionexception  
problem pb
  new problem   
intdomainvar x
  pb makeenumintvar  x           x       
intdomainvar
  pb makeenumintvar  y                 
intdomainvar z
  pb makeenumintvar  z                 
intdomainvar even   pb makeenumintvar  even  new int                 
pb post pb gt pb minus y    x   
   x      
pb post pb gt pb plus pb mult   x     z       z    x    
pb post pb eq even pb plus y z    
     z even
pb solve   

   solve using mac

 
 

figure    jchoco constraint program csp figure   
revised w r t  x cyz w r t  y  effect  revision set point
empty arc consistency established variable domains dom x           
dom y            dom z           
solving csp may involve search  i e   might need try different values variables order determine solution exists  typically constraint solver begin
establishing arc consistency  repeatedly select variable assign value
domain  instantiate it   effectively reduces variables domain singleton 
arc consistency re established  succeeds another instantiation made 
fails backtrack undoing recent instantiation  called mac 
maintaining arc consistency  sabin   freuder        
figure   shows constraint program problem figure   using choco constraint programming toolkit java language  choco         finds solution
x           z     first 
constraint toolkits tend based around ac  algorithm  van hentenryck  deville 
  teng         allowing propagators specialised specific constraints resulting
improved efficiency adaptability  ac  amends set ac  contain triples
form  v  c    v scope c  set values lost v  consequently
   

fithe ultrametric constraint phylogenetics

revision efficient propagation focus values may lost support 
rather check every value support  object oriented toolkit language
constraint associated propagation methods implemented 
methods activated domain event occurs variable involved constraint 
domain events initialisation variable  increase lower bound 
decrease upper bound  removal value bounds  instantiation
variable  exhaustive list  however toolkits allow one event 
one values lost propagator writer must determine
action take  give examples using toolkit specialised constraints 
modelling routing problem might constrained integer variable location
visited  domain values corresponding index next destination  the
so called single successor model   subtour elimination constraint  caseau   laburthe 
      might used ensure legal tours produced  regins alldifferent constraint  regin        could added increase domain filtering  pick
delivery variant  side constraints could added ensure locations
visited others  job shop scheduling problem might model uses
    variables decide relative order pairs activities share resource 
might increase propagation adding carlier pinsons edge finding constraint        
constraint programming approach general practical modelling solving
problems  provides framework combination problem specific algorithms
one solver  allows us solve many classes problems efficiently model even
problems via addition side constraints 
    supertree problem
supertree construction problem phylogenetics combine leaf labelled
species trees  sets leaf labels intersect  single tree respects
arboreal relationships input tree  bininda emonds         species trees describe
part evolutionary history set species  labels leaves correspond existing
species internal nodes represent divergence events evolutionary history one
species split least two species  species trees may annotated dates
internal nodes  representing time divergence event happened 
define term displays  makes precise mean respects
arboreal relationships  supertree t  displays tree t  t  equivalent t 
 i e  induce hierarchy leaf labels  t  obtained following
steps  semple   steel        
   let l set leaves t  t   
   let t  unique subtree t  connects leaves l 
   obtain t    wherever subpath  p            pk   path root
leaf t  p            pk  interior nodes degree    contract
single edge 
problem produce rooted species tree forest input trees f 
contains species f displays every tree f   figures     illustrate
displays property 
   

fimoore   prosser

 
 

t 

 
 

 
 

t 

 
 

b

c



 
 









e

   
 
 



 

 
 
 
 
   
 
   
 

 
 

e

 
 
 
 
   
 
   
 



 
 
 

 
 

 
 

   
 
   
   
   
 



 
 

l  a d e 



e

e

figure    example tree t  displays tree t 

 
 

t 

 
 

l  a d e 

 
 

 
 

   
 
   
   
   
 





c

b

e

t     

 
 

 
 
 
 
   
 
   
 



   
 
 


t 

 
 

t 

 
 





e

 
 

e

 
 
 
 
   
 
   
 





e

figure    example tree t  display tree t 

   

fithe ultrametric constraint phylogenetics

say two trees t  t  compatible  incompatible  exists  doesnt
exist  third tree t  displays t  t    variants supertree problem
previously published solved specialist bioinformatics literature include
finding solutions    counting solutions  finding conserved relationships supertrees
 daniel         incorporating nested taxa  semple et al          incorporating ancestral divergence dates  semple et al         possibility contradictory input data  semple
  steel        

   ultrametric constraint
ultrametric constraint first proposed gent et al         within context
supertree construction  bininda emonds         implemented using toolkit primitives  review encoding show constraint toolkits inefficient
terms space time  motivates creation specialised ultrametric
propagator three variables  maintains ultrametric property bounds
variables  presented describing necessary propagation methods 
extend specialised propagator maintains ultrametric property
symmetric matrix variables 
    previous work ultrametric constraint
first  give definition ultrametric constraint 
definition    ultrametric constraint three variables  henceforth  um    x  z
constrains that 
 x     z   y   x   z   z   x   y   x     z 

   

constraint ensures tie least element three  i e   either
three same  two greater  constraint
proposed gent et al          used prosser        times implemented
literal translation equation   using toolkit primitives  evidence obtained
jchoco  eclipse ilog constraint programming toolkits shows propagation
done lower bounds combination primitive constraints  due disjunctive constraints since many constraint programming toolkits propagation delayed
one disjuncts true  known delayed disjunction consistency
 van hentenryck  saraswat    deville         consequently  encoding values
cannot occur satisfying assignment might pruned domain
variable  consider case three variables  x                   z     
domains variables already fixed point respect delayed disjunction
consistency ultrametric assignment x takes value    i e   delayeddisjunction propagation achieve arc consistency  shall see later  finding
solution supertree problem using toolkit constraints result backtracking
search  prefer avoid this  course  higher levels consistency would overcome
this  constructive disjunction consistency  van hentenryck et al          singleton
   may multiple supertrees set input trees 

   

fimoore   prosser

arc consistency  debruyne   bessiere        filtering algorithm lhomme        
however  cost greater average case delayed disjunction  preventing use toolkits  fact um   constraint especially unfortunate
lower bounds may trimmed properly 
lemma    um   constraint  lower bounds supported  i e   form ultrametric instantiation values constrained variables   support other 
proof  consider three supported lower bounds  suppose contradiction two
least distinct  one distinct lowest cannot supported
account fact equal anything larger anything  therefore
contradiction two least must equal  however lower bound least
large these  lower bounds mutually supportive 
lemma important implications species tree model presented
detail section    particular  lower bounds bounds z  consistency model
form solution  bounds z  consistency  bessiere        defined follows
definition    given  v  d  c  constraint c c scope c     vc            vck    tuple
   xc            xck   bound support rel c  xci   min dom vci   
xci max dom vci     constraint c bounds z  consistent vci scope c 
exist bound supports involving min dom vci    max dom vci     csp bounds z consistent every constraint c c bounds z  consistent 
henceforth abbreviate bound support support bounds z  consistency
bc z   bc z  differs ac puts weaker conditions values comprise
support  rather domain  need
lower upper bounds domain  means bc z  prunes subset
values ac can  general  weaker levels consistency bc z  useful
certain problems prune number values ac easily 
fewer values much quickly  case  bc z  interesting level
consistency enough ensure problem solved propagation
search  shall see 
    design bc z  um   propagator
section describe um   propagator enforces bc z   namely um   bcz 
      analysis lower upper bounds
section dont take account domains becoming empty  since analyse lower
upper bounds isolation lower bound may pass upper bound vice versa 
thereby emptying domain  happens propagator described section      
enforce bc z   rather terminate  problem  domain
becoming empty means solution continue would waste time 
concordantly  section  analyse lower bounds assume upper
bound domain cannot become null reason  vice versa 
   

fithe ultrametric constraint phylogenetics

code style  variables v    v    v    s  l constrained integer variables  synonymous domains  consequently variable x considered domain x lb
x ub return references lower upper bounds respectively  sortonlowerbounds x y z 
returns tuple references variables x  z non decreasing order lower bounds 
sortonupperbounds analogous  let  s m  l        names references s  l 
result s lb  lb  lower bound assigned equal value lower bound  
although  lb subsequently changes distinct again  expression x b returns
intersection domains  max x lb y lb        min x up y up   

algorithm um   bcz
lbfix v   v   v   
a 
let  s  m  l  sortonlowerbounds v    v    v   
a 
 s lb    lb 
a   
s lb  lb
ubfix v   v   v   
a 
let  s  m  l  sortonupperbounds v    v    v   
a 
 s ub    ub 
a   
 s b l    
a   
 ub s ub
a   
else  s b    
a   
l ub s ub
min event v   v   v   
a 
lbfix v   v   v   
a 
domains non empty
a   
ubfix v   v   v   
max event v   v   v   
a 
ubfix v   v   v   
fix event v   v   v   
a 
lbfix v   v   v   
a 
domains non empty
a   
ubfix v   v   v   

figure    algorithm um   bcz propagator

   

fimoore   prosser

   

   
l



   

   
l
s m

s m l

m l


figure    cases analysis lbfix

l
   

l



l
   

   



   

figure    cases analysis ubfix
procedure lbfix figure   takes input three variables removes unsupported values lower bounds domain  intuition algorithm achieving
one needs involved tie least element  hence smallest
lower bound strictly less others must unsupported 
possible states lower bounds lbfix invoked summarised figure   
either three different  case     three  case    two
one different  cases       give relationships bounds point time
lower bound may unsupported  boxes figure   shaded follows 
regions shaded black removed propagation whereas gray regions supported 
diagrams supposed suggest that  example case    bounds differ
   rather two bounds lined bound one
different another different non zero unspecified amount  hence
describe relationships actual values 
following shows lbfix removes unsupported values remove
supported values 
lemma    lbfix invoked lower bounds argument variables supported
w r t  um   constraint supported values removed 
proof  cases      figure    condition line a  satisfied  line a   
executed  results removal unsupported range inspection
remaining bounds mutually supportive  cases      condition line a 
failed changes made domains  bounds mutually supportive 
procedure ubfix figure   job upper bounds lbfix
lower bounds  following lemma justifies assertion cases used
proof shown figure   
lemma    ubfix invoked either
   

fithe ultrametric constraint phylogenetics

upper bounds argument variables supported w r t  um   bcz constraint supported values removed 
domain null result removing unsupported values 

proof  let s  l domains smallest  middle largest upper bounds 
breaking ties arbitrarily  let s  l upper bounds 
first prove case    figure    shaded region supported
l b      potentially  bound supported
equal values l least small  i e   b l      
equal value either l  value least large remaining domain 
however  notice latter impossible due fact l contains equal
value  value large this 
similar arguments establish shaded regions l case    case  
l case   supported b      l b    b      respectively 
establish lemma cases           
cases     condition line a  false  domains changed 
upper bounds mutually supportive case 
case   shaded region unsupported l b     hence
ubfix line a    executed unsupported region removed  upper
bounds l l  mutually supportive 
case   shaded region supported lb      shaded
region l supported b    neither line a    a    executed
changes made domains  upper bound supported 
l  s  shaded region l supported b  
line a    executed resulting removal region  new bounds s 
l mutually supportive 
case   shaded regions l supported above  l b   
b      hence domain changes result executing ubfix  l l
supported l l  s  supported l  s 
case   shaded regions l unsupported above  l b  
b   line a    ubfix executed results becoming null 
case    shaded region supported shaded region l supported
lb    b     a    executed remove unsupported
region  new bounds s  l mutually supportive 
case    shaded region l supported shaded region supported
symmetric previous case 

note analog lemma   upper bounds since  example  bounds
x                       z       supported  mutually supportive 
   

fimoore   prosser

      propagation algorithm
presented lbfix ubfix position present complete propagation algorithm  propagator works arbitrary domains enforces bc z  
except domain becomes empty  case work  algorithm
described action taken three domain events occur 
min domain lost lower bound since propagator last invoked 
max domain lost upper bound since propagator last invoked 
fix domain singleton  i e   variable instantiated upper lower bounds
equal 
i e  consider events bounds variables  algorithm listed lines
a  a  figure    intuitively procedures work because  show  change
upper bound affect support upper bounds  change lower
bound affect support lower upper bounds  hence need run
lbfix lower bound may changed  ubfix must run change either
lower upper bounds  whilst would correct cycle trimming upper
lower bounds fixed point reached  i e  changes occur   guarantee
fixed point easily 
lemma    possible change lower bound result loss support
another lower bound 
proof  bounds diagram support  black shaded lower
bound lost dark gray shaded lower bound loses support 

lemma    possible change lower bound result loss support
upper bound 
proof  bounds diagram support  black shaded lower
bound lost dark gray shaded upper bound loses support 

lemma    possible loss upper bound cause loss support
another upper bound 
   

fithe ultrametric constraint phylogenetics

proof  bounds diagram support  black shaded upper
bound lost dark gray shaded upper bound loses support 

corollary    impossible change upper bound result loss support
lower bound 
proof  lemma   lower bound retains support long lower bounds
intact  hence losing upper bound effect 
asymmetry upper lower bounds  due asymmetry
definition um   bcz practical repercussion bc z  lower bounds
must mutually supportive whereas bc z  upper bounds may may require
support values including lower bounds 
corollary   suggests improvement algorithm figure  
execute line a  a  lower bound lost remaining support
upper bound  however  conditionals intrinsic ubfix amount much
thing little point repeating them 
point theorems build complete proof correctness
bc z  status 
theorem    code min  max fix events listed figure   remove
values involved bound supports um   bcz constraint  and  domains
non null propagation  resultant domains bc z  
proof  first must establish values removed propagation could
involved support  result domains subsets input domains 
former immediate lemmas      values removed result
executing lbfix ubfix  latter immediate inspection lbfix ubfix 
ever make lower bounds larger upper bounds smaller 
final thing establish bc z  enforced  unless domain becomes null 
domain becomes empty result running algorithm theorem
trivially true 
domain becomes empty must show bounds supported 
lower bounds  lemma   corollary   know loss lower bound
result need change lower bound propagation  lower bounds
change result either fix min events  hence propagator figure   runs lbfix
either event  lbfix runs leaves lower bounds supported  shown
lemma    upper bounds  lemmas     know loss either lower
upper bound result loss upper bound  hence upper lower bounds
change result event  lower bounds change result lbfix 
hence propagator runs ubfix events  runs lbfix finished 
necessary  ubfix runs leaves upper bounds supported provided domain
becomes empty  shown lemma   
   

fimoore   prosser

 
 
 
 
 
 
 
 
 
 
 
 

 a 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 b 

figure    propagation done   domains singleton
propagation algorithm runs     time  operations
lbfix  ubfix  min  max fix events      provided domain representation
allows access upper lower bounds      guaranteed domain
reductions occur bounds  case here  domains represented using
one structures proposed van hentenryck et al         
    entailment
schulte carlsson        define entailment possible constractions
domains constraints scope consistent  detect happened
stop running propagator henceforth  since cannot prune values 
definition    propagator entailed domains    d            dn   set
domains subsets these  i e   e    e            en   s t  i ei di   fixed
point 
describe sufficient condition um   bcz constraint entailed  i e  
um   bcz constraint becomes entailed soon two variables singleton domains 
theorem    um   bcz becomes entailed soon two variables singleton domains 
proof  consider possible scenarios  either two singletons  case  a 
figure    distinct  case  b  figure     domains propagation
shown figure   boxes  domains propagation shaded gray  clearly
remaining choices third variable valid instantiations since propagation
algorithm safe cannot removed propagation definition
propagation fixed point 
    ultrametric matrix constraint
supertree model presented section   makes use ultrametric constraint  however
context desired end product constrain whole matrix ultrametric
matrix  merely constrain three variables 
   

fithe ultrametric constraint phylogenetics

code style  let  i  j  index v  declares j indices variable v matrix
constraint over 

algorithm um matrix bcz
min event v 
a 
let  i  j  index v 
a 
k         n
a   
k    k    j
a   
min event mij   mik   mjk  
a   
max event mij   mik   mjk  
max event v 
a 
let  i  j  index v 
a 
k         n
a   
k    k    j
a   
max event mij   mik   mjk  
fix event v 
a 
let  i  j  index v 
a 
k         n
a   
k    k    j
a   
min event mij   mik   mjk  
a   
max event mij   mik   mjk  

figure    algorithm um matrix bcz propagator

definition    symmetric matrix ultrametric matrix every set
three distinct indices i  j k  tie minimum mij   mik mjk  
mii     i 
ultrametric matrix constraint achieved matrix posting constraint um   bcz m
ij   mik   mjk   choices distinct i  j k  cost

introducing n  constraints  practical constraint solvers model containing constraint  n    space complexity  since solver must list  n   
constraints stored somewhere  however  domain event occurs matrix variable mij straightforward iterate k indices propagation
um matrix bcz figure    replaces  n    space list representation set
um   bcz constraints     code representation  hence propose ultrametric
matrix constraint propagator um matrix bcz figure   
propagator mimics part ac  algorithm  mackworth        since  a 
receives propagation event variable   b  identifies constraints
variable   c  arranges propagation carried out  events caused
result queued dispatched underlying propagator normal may
cause um matrix bcz run again  variable involved n  
constraints  since variable two indices matrix constraint
involving choice three different indices 
n
 

algorithm propagates  n  time  expensive per event using
um   constraints  factor n fewer propagators wake result event 
   

fimoore   prosser



b

c



c

b

b

c





b

c

figure     four possible relationships three leaf nodes tree  i e  three
triples  ab c   ac b   bc a  fan  abc  

   supertree construction
review imperative solutions supertree construction problem  review first
constraint programing solution  gent et al          present new encoding exploits
specialised um matrix bcz constraint 
    imperative solutions supertree problem
earliest imperative techniques due bryant steel        ng wormald
        present onetree algorithm based build algorithm
aho  sagiv  szymanski  ullman         onetree based observation
tree three leaf nodes define unique relation respect recent
common ancestor  mrca   mrca a  b  interior node furthest root
leaf nodes b descendants  abuse notation writing mrca a  b   
mrca c  d  former greater depth latter  similarly mrca a  b   
mrca c  d  depth  given three different leaf nodes species  labelled
a  b  c  one following four relations must hold 
   

mrca a  b    mrca a  c    mrca b  c 

   

mrca a  c    mrca a  b    mrca c  b 

   

mrca b  c    mrca b  a    mrca c  a 

   

mrca a  b    mrca a  c    mrca b  c 

say              triples  ab c   ac b   bc a  where
 xy z read x closer z      fan  abc   i e  
fan relationship species unresolved dont specify pair
closely related  shown figure     prior applying onetree algorithm two
 or more  species trees broken triples fans using breakup algorithm
 ng   wormald         resulting linear sized encoding trees  supertree
constructed  if possible  using encoding input 
figure    shows example breakup algorithm process  two variants
process shown  top hard breakup  fans considered hard
evidence must respected  hard polytomies described ng wormald       
soft breakup fans taken lack evidence  soft polytomies
described bryant steel         hard breakup algorithm modified
   

fithe ultrametric constraint phylogenetics

e



b

c

b

c

g

break

break

break

 a b c 
 a b d 
 a c d 
 b c d 

 cd e

 de f

 ef g





e

c

e



f

break

f

f

g



e

f

g

e

f

g



break

break

break

break

 ab e 
 bc e

 cd e

 de f

 ef g

e

g

c

  abc   abd  
 
 bcd   cd e 
 de f  ef g 

f

g



e

f

g

e

f

  ab e  bc e 
 
 cd e  de f 
 ef g 

g



figure     example execution breakup algorithm  top  hard breakup 
soft breakup  no fans produced 

code style  function sortedinteriornodes t   delivers set interior nodes tree nonincreasing order depth tree  degree v  delivers degree node v  function child v  i 
delivers ith child interior node v  uncleorcousin l  delivers leaf node descended
sibling parent leaf node l  function becomesleaf v  l  transforms interior node v leaf
node labelled l  removechild l  v  removes leaf node l list children interior node v 

algorithm hardbreakup
hardbreakup t  
 
let v sortedinteriornodes t  
 
let
 
let  
 
notroot v  i   degree v  i      
 
let v v  i 
 
let c  child v    
 
degree v     
 
let c  child v    
 
let c  uncleorcousinof c   
  
 triple c    c    c    
  
v becomesleaf v  c   
  
ii  
  
else j   degree v   
  
k j     degree v   
  
let c  child v  j 
  
let c  child v  k 
  
 fan c    c    c    
  
v removechild c    v 
   return

figure     hard breakup tree   producing triples fans 

encountering kfan broken n    fans  soft breakup
fan broken linear number rooted triples  algorithms hard soft breakups
given figures        used imperative onetree algorithm
constraint programming models 
   

fimoore   prosser

algorithm softbreakup
softbreakup t  
 
let v sortedinteriornodes t  
 
let
 
let  
 
notroot v  i  
 
let v v  i 
 
let c  child v    
 
let c  child v    
 
let c  uncleorcousinof c   
 
 triple c    c    c    
  
degree v     
  
v becomesleaf v  c   
  
ii  
  
else v removechild c    v 
   return

figure     soft breakup tree   producing triples 

c



b

c

e

c

b



c





e

b

e

figure     toy input  left  single solution supertree problem  right   input
trees distorted make relationships resultant supertree obvious 

toy set input triples single solution shown figure     triples
drawn reflect solution compatible them 
ng wormald        give complexity onetree o h n   h n   
n n     bn  n     f    n number labels  number triples  f number
fans  b sum squares number leaves fans  inverse
ackermann function  and less   conceivable inputs behaves
constant   therefore input trees fully resolved  i e   fans  running
   

fithe ultrametric constraint phylogenetics

time complexity o n    worst case complexity grows o n    
contrasted o t n  complexity bryant steels onetree        
    constraint encoding using toolkit constraints
second stage  i e   onetree equivalent  first solved constraint program
gent et al          encoding takes advantage equivalence ultrametric
trees ultrametric matrices 
definition    let real symmetric n n matrix  ultrametric tree
rooted tree that 
   n leaves  corresponding unique row m 
   internal node least   children 
   two leaves j  mij label recent common ancestor
j 
   along path root leaf  labels strictly increase 
theorem    symmetric matrix ultrametric tree
ultrametric matrix  furthermore  tree uniquely determines matrix
matrix uniquely determines tree  
proof  proof given gusfield        
clear correspondence definition   description species
tree given section    species tree ultrametric tree matrix   mij
depth mrca species j mij divergence date two species 
reason use ultrametric matrix model solve supertree problem 
      model gent et al 
given input forest f n distinct leaf labels  symmetric
constrained integer variables created domains             n   
diagonal  variable mij depth mrca species j 
posted make whole matrix ultrametric thus ensuring
ultrametric 
mij   mik   mjk
mik   mij   mjk
mjk   mij   mik
mij   mik   mjk

n n matrix
    main
initially  constraints
resulting tree

   

  j   k  input trees broken triples fans using either
breakup algorithms figures        triple  ij k produced constraint
mij   mik   mjk
   

   

fimoore   prosser

 

b
c

e
f
g

 
 e g 
 
 c d 



b c e f g
             
   
 
 
 
 
 
 
 
 
 
 

 b f 

figure     one iteration algorithm convert ultrametric matrix tree
posted   fan  ijk 
mij   mik   mjk

   

posted  constraints break disjunctions equation    model  n  n   
variables
t f  


n
  o n      o n       n       n   
 

   

constraints  number triples f number fans  o n   
one breaks disjunction one constraint equation   
 n    those 
      converting back tree representation
final step use algorithm based constructive proof gusfield       
direction theorem   build tree matrix produced constraint
solver  describe algorithm detail  sake intuition works
follows
pick arbitrary leaf s  let number distinct entries row d 
partition leaves sets p            pd based entry row s 
solve problem recursively pi ignoring rows columns
matrix pi  
combine overall solution attaching subproblem solutions correct depth
path s 
figure    shows one recursion algorithm choice leaf shows
row fully describes path corresponding tree 
   

fithe ultrametric constraint phylogenetics

algorithm cpbuild
cpbuild f  
  let  v  d  c  cpmodel f  
  f
 
breakup t   c post t  c 
  propagate v d c  return umtotree v d 
  else fail  

figure     build supertree forest f using ultrametric constraint model 
      time complexity model gent et al 
breakup  procedures build constraint model convert ultrametric
matrix tree polynomial time  however complexity backtracking search
 
o n    variables o n  size domains worst case o nn    upper bound
time taken solve supertree problem  attempted derive lesser
upper bound time complexity  since  show following section 
new model provably achieved polynomial time bound 
    constraint encoding using new propagator design
issue potentially exponential solution time model section     worrying 
experiments time taken solve instances major issue  conversely
memory requirements problem practice  theory  model requires
 n    space n species  constant factor inhibiting  posting constraint
equation   literally  using toolkit propagators  described section   uses    propagators jchoco toolkit  requires roughly    times runtime memory
single propagator  since corresponds single java object 
comparable footprints  show empirical study section    prevents
modest instances loaded typical current workstations 

using new propagator section   replace n  propagators single
compact propagator result memory usage reduced asymptotically  n   
 n    since model memory dominated  n    space needed
matrix   reducing amount space initialised delivers proportional
saving build time  importantly  using new constraint provides solution
exponential time complexity  enforcing bc z  model allows solution
read lower bound domain  theorem   proof correctness
algorithm 
figure    gives schema constraint programming algorithm supertree construction  cpbuild  algorithm takes input forest f trees  line   constraint
model produced  i e   n n symmetric array constrained integers variables created  n unique species forest  um matrix bcz constraint
posted variables  lines     breaks input trees triples
fans using either breakup algorithms given figures        posts
model constraints  propagators constraints executed fixed point
line    succeeds tree created lower bounds ultrametric matrix
otherwise fail 
   

fimoore   prosser

lemma    propagator every constraint model enforces bc z  furthermore lower bounds mutually supportive  executing propagators
fixed point  either lower bounds solution  empty domain fail 
proof  reduce domain lower bound fixed point obtained
bound supported mutually supportive supposition  hence
every constraint simultaneously satisfied singleton domains and  definition 
solution 
theorem    cpbuild polynomial time solution supertree problem 
proof  constraints involved model triples fans ultrametric constraints  theorem   know lower bounds supported
propagators run  lemma   know lower bounds mutually supportive  true disjunction breaking propagators  hence lemma   
shown figure     either read solution fail  enforce bc z 
problem polynomial time shown below 
immediate preserve polynomial time solution
addition polynomial number side constraints  long additional constraints
preserve property lower bounds mutually supportive  fact  csps
ordered domains constraints property lower bounds
mutually supportive belong known tractable class called min closed  jeavons   cooper 
      
      time complexity cpbuild
algorithm implemented run o n    time using variation ac 
algorithm  ac   mackworth        begins queue containing constraints 
repeatedly removes constraint none remain runs associated propagator 
constraints affected variables re queued  necessary  queue empties 
propagators fixed point  need o n    constraints worst case complexity

o n   
   z  

 

build initial q

o n o n   
   z  

worst case re queues   value removed time

 

o   
   z  

propagation time

o n    overall  matches worst case complexity onetree  ng   wormald 
       constraint solution worst case problem unsolvable  since
unsolvable domains emptied propagation  whereas solvable instances
propagation reaches fixed point sooner 

   empirical study
present empirical study determine practical improvements
achieved constraint solutions supertree problem and  so  size improvement  experiments run using    ghz pentium   processor    mb memory 
using sun java build          b    constraint toolkit used jchoco version        
   

fithe ultrametric constraint phylogenetics

input trees broken using hard breakup  consequently cases fans treated
hard polytomies   
benchmark real life seabird data previously used kennedy page       
beldiceanu et al         present statistics various techniques producing supertrees  namely onetree  cp solutions section    entries toolkit
cpbuild   completeness reproduce results beldiceanu et al        
data set  tabulate treecon  treecon uses single successor model 
constrained integer variables represent nodes within tree  domains correspond
possible successors    unique variable represents root loops  i e  
vroot   root   leaf nodes indegree zero  precedence incomparability
constraints generated input trees 
treecon results encoded constraint programming toolkit
processor approximately twice fast   ghz   correct times
compensate factor  mark bold results differ significantly
cpbuild treecon results  specifically whose runtimes would undoubtedly
factor    different processor  results reported combinations
seabird trees  input trees named g  following data tabulated below 
data combination attempted 
n total distinct species input trees
sol iff supertree possible
technique type algorithm used solve
build time milliseconds initialise cp model
solve time milliseconds first solution 
total   build   solve
nodes number nodes search tree
mem model memory mb
table  dnl means model could loaded  as large  dnf
means could solved within    mins  succeeded loading 
provided memory usage onetree  however smaller
constraint encodings 
obvious thing note much faster imperative approach compared
constraint techniques  this  primarily due lower complexity
onetree absence fans  we investigated benefit this  
partly due generality constraint programming approach  imperative
approach highly specialised one class problem whereas constraint approach
sits within toolkit  runs top general purpose constraint maintenance system 
expect constraint approach compete raw speed
later demonstrate  in section    approach benefits versatility  i e  
   later section use soft breakup 
   alternative constraint model tree might use     variables corresponding potential edges
within adjacency matrix  prosser   unsworth         indeed cp graph  computation domain
 dooms        

   

fimoore   prosser

costs space time repaid ease accommodating variants problem
model 
data
ab

n
  

sol


ac

  

f

ad

  



ae

  

f

af

  



ag

  



bc

  

f

bd

  





  

f

bf

  



bg

  



cd

  



ce

  



cf

  



cg

  

f

technique
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon

build
    
   

solve
   
   

    
   

   
   

    
   

   
   

dnl
   

dnl
    

    
   

   
   

    
   

   
   

    
   

     
   

    
   

   
   

dnl
   

dnl
     

    
   

   
  

    
   

   
   

     
   

    
   

dnl
   

dnl
    

    
   

   
   

    
   

   
   

   

total
    
   
   
  
    
   
   
  
    
   
   
  
dnl
    
     
  
    
   
   
  
    
   
   
  
     
   
  
 
    
   
   
  
dnl
     
   
  
    
   
   
 
    
   
    
  
     
   
   
  
dnl
    
     
  
    
   
   
  
    
   
    

nodes
  
  

mem
     
    

 
 

     
    

  
  

      
    

dnl
 

     
    

  
  

     
    

  
  

      
    

   
 

     
    

  
  

     
    

dnl
 

     
    

  
  

     
    

  
  

     
    

  
  

      
    

dnl
  

     
    

  
  

     
    

 
 

     
    

fithe ultrametric constraint phylogenetics

de

   

f

df

  



dg

  

f

ef

  

f

eg

  

f

fg

  

f

abdf

  



abdg

  

f

acdf

  

f

acdg

  

f

ace

  

f

onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
onetree

dnl
   

dnl
    

    
   

   
   

     
   

    
   

dnl
   

dnl
    

dnl
   

dnl
    

    
   

dnl
   

     
   

    
   

     
   

dnf
    

     
   

    
   

dnl
   

dnl
    

dnl
   

dnl
    

  
dnl
    
    
  
    
   
   
  
     
   
   
  
dnl
    
    
  
dnl
    
    
  
dnl
   
  
  
     
   
    
  
dnf
    
   
  
     
   
    
  
dnl
    
     
  
dnl
    
  

dnl
 

     
    

  
  

     
    

 
 

      
    

dnl
 

     
    

dnl
 

     
    

dnl
 

     
    

  
  

      
    

dnf
 

      
    

 
 

      
    

dnl
 

     
    

dnl
 

     
    

impressive aspect matrix model section     section    
improvement memory requirements  instances loaded comfortably  dramatic impact build time  improvements dominate
reduction solve time practice  toolkit model outperformed cpbuild
order magnitude instance  moreover  two cases search occurring
toolkit model  on data sets bc abdg  whereas cpbuild never search 
polynomial time complexity due provable absence search 
results compare well beldiceanu et al          one
case  be  cpbuild order magnitude slower treecon  far
explanation this  four cases treecon significantly worse
cpbuild  results available treecon data set ace 
noted beldiceanu et al  yet complete filtering algorithm problem
based constraint model and  personal communication  although treecon
   

fimoore   prosser

figure     supertree largest compatible data sets birds abdf  took    ms
model    ms solve using cpbuild 

model never backtracked birds data set yet proof complexity
model polynomial  noted see cpbuild taking time
unsolvable instances solvable instances  predicted 
figure    shows supertree  displayed treeview  page         produced
largest compatible forest  a  b  d  f    supertree    leaves takes
  second produce  although result printed table  finding forest
 a  b  c  d  e  f  g  incompatible takes    seconds total      seconds build
model    seconds determine incompatibility  
   

fithe ultrametric constraint phylogenetics

   versatility constraint model
one strengths constraint programming versatility  given constraint model
core problem model enhanced address variants original pure
problem  demonstrate versatility respect ultrametric model  presenting
four variants supertree problem  a  incorporating ancestral divergence dates
model   b  nested taxa   c  determining induced triple fan common
supertrees   d  coping incompatibilities 
    ancestral divergence dates
semple et al         bryant et al         add temporal information input trees 
interior nodes may labelled integer ranks interior node v  proper
descendant v  rank v      rank v     resulting ranked phylogenetic tree  additionally relative divergence dates may expressed form div c d  predates div a b 
interpreted divergence species c predates species b 
rankedtree algorithm  bryant et al         takes input collection precedence
constraints derived input ranked species trees predates relations  algorithm
outputs ranked tree respects relations returns compatible 
trivial incorporate constraint model  trees ranked
pair species  i  j  leaf set instantiate constrained integer variable
mij value mrca i  j   predates relation div c d  predates div a b  post
constraint mcd   mab   done step   cpbuild  figure      i e   ranks
predates relations become side constraints  similarly time bounds speciation events
posted unary constraints  i e  dated phylogenetic tree upper lower divergence
bounds given interior nodes  l a  b  u a  b  give respectively lower
upper bounds divergence dates species b  constraint program
following two side constraints posted  again  step     l a  b  mab
mab u a  b  
demonstration ranked trees given figure     left two ranked
species trees cats used recently semple et al         originally janczewski 
modi  stephens  obrien         branch lengths source trees
translated rankings added interior vertices trees  right
one    possible resultant supertrees  total       solutions contain
interior nodes ranges  interior nodes labelled specific values rather
ranges    solutions produced  structurally identical  goes
way addressing issue enumerating supertrees compactly  raised
challenge semple et al          figure    show effect adding predates
constraint supertree construction  data previously used bryant et al 
       figures     
    nested taxa
taxon  plural  taxa  group organisms comprising single common ancestor
descendents  dawkins   wong         example species lion class birds
taxa  far  species trees leaf labelled  however restrictive
   

fimoore   prosser

figure     two ranked trees cats  right one    possible supertrees produced
cpbuild  displayed using pages treeview 

figure     two input trees t      a  c   x  t     b  x  resultant supertree shown
 rd position  tree far right supertree t  t 
side constraint div a c  predates div a b   produced cpbuild
displayed using pages treeview 

   

fithe ultrametric constraint phylogenetics

p

p

q

q

p

q



b

c



e

g

b

f



e



g

b

c

f



e

figure     two input rooted x trees t  t   left  output tree t   right 
perfectly displays them 

trees may annotated taxa names leaves internal nodes  giving
nested taxa  example  figure    shows tree t  internal node labelled p
descendents b  i e   b taxa nested within p taxon  problems
related creating compatible supertrees type data raised page       
defined solved daniel semple         set input trees possible
solution problem shown figure     notice labels conserved
solution  ancestral relationships conserved and  labels li lj
input tree  li ancestor lj input tree li ancestor lj solution
tree  instance problem higher taxa compatibility defined daniel
semple        semple et al          result tree must perfectly display
input trees  define problem formally 
definition    rooted x tree  daniel   semple        species tree internal
nodes well leaves may labelled set x 
following slightly loose may use label l identify labelled node 
well label itself  e g   descendants l means descendants
node labelled l 
definition    rooted x tree perfectly displays rooted x  tree
   x x 
   displays   neglecting internal labels 
   descendant b descendant b  
   descendant b descendant b  
rooted x tree perfectly displays forest phylogenetic trees f    t            tn  
perfectly displays every ti  
      constraint encoding
constraint encoding implemented addition variables side constraints
standard model section    describe transform input make
constraint solution simpler  describe variables constraints needed 
   

fimoore   prosser

t 

t 

t 

p

q

p

q

q


b

c



e

f

p

e

g

f



b

c

e

g

f

figure     two input trees t  t  enclosing taxon p   process substitution t  replaced t   

substitution taxon p figure    appears internal node t    call
label enclosing taxon  note appears leaf t    input trees
preprocessed replace tree enclosing taxon p leaf tree
single subtree rooted p substituted place  must subtree
elsewhere input forest  contradiction enclosing taxon 
process add remove information  since relationships
everything tree still holds  new relationships taxa subtree
rest tree always implicit input 
aim process obtain set inputs enclosing taxa appear
internal nodes only  without loss generality constraint encoding assumes
case  figure    shows example substitution process applied
trees t  t    t  would replaced t   
variables constraints variables added one integer variable vl per enclosing
taxa label l  domain             n     value variable solution
tree depth internal node labels  labels position final
tree determined must unique node depth path one
nested taxa root  see figure    suppose sake argument
enclosing taxa labels b  variable lm     solution 
unique location label go root node 
properties         definition   immediate properties
earlier model foundation one  explaining enforce
property     introduce notations convenience  function desc l  f   returns
set descendants label l tree forest f   notdesc l    returns
set labels descendants l tree  
first need constraint l must label every single species labels input 
every enclosing label l  post following set constraints 
 vl mij   desc l  f   j desc l  f      j 

   

label must settle least shallow mrca descendants input 
hence must remain descendants  notice necessary consider pairs species
distinct input trees  alternative taking pairs tree work 
necessary pairs internal node l  rather two
   

fithe ultrametric constraint phylogenetics

distinct nodes happen correct depth  next  label must constrained
label already descendant becomes one  x tree
enclosing label l x  post following set constraints 
 vl   mij   desc l   t    j notdesc l    

   

label l must placed strictly deeper mrca descendant
something thats descendant  i e   non descendents l descendent
result  illustration list generated constraints example figure    
   equation   l   p    vp mab   vp mag   vp mbg  
   equation   l   q   vq mde   vq mdf   vq mef  
   equation    l   p  t    t      vp   mac   vp   mad   vp   mae   vp  
mbc   vp   mbd   vp   mbe   vp   mgf   vp   mgd   vp   mge   vp   mbf  
   equation    l   q  t    t      vq   mad   vq   mae   vq   mbd   vq  
mbe   vp   mcd   vq   mce   vq   mgf   vp   mbf   vp   mgd   vp   mge  
number new constraints created equations     bounded
number distinct pairs species  i e   n    new constraints 
    necessity
may many possible supertrees given input forest  one question then 
relationships common supertrees  problem determining derived
induced triple  or fan  supertree necessary  i e   common possible supertrees 
introduced  daniel        along polynomial time decision procedure necessity 
algorithm necessity figure    takes arguments forest f trees  assumed
compatible  rooted triple fan determines occurs every supertree
displays trees f   algorithm simple modification cpbuild 
lines     essentially same  line   negation triple posted
problem  posted
mik    mjk mij mik mij mik

   

   ij k posted
mij    mik mij    mjk mik    mjk

   

   ijk   call made propagate make problem arc consistent  line
    fails necessary  otherwise necessary  algorithm
complexity cpbuild 
    coping conflict
supertree cannot produced pair trees input triples fans
must conflict one another  either directly indirectly  junkers quickxplain
method  junker        discovers minimal subset constraints posted
propagated result failure  set necessarily smallest possible set
   

fimoore   prosser

algorithm necessity
necessity f   
  let  v  d  c  cpmodel f  
  f
 
breakup t   c post t  c 
  c post   c 
  return propagate v  d  c 

figure     triple fan occur every supertree displays trees f  
minimal sense removal element set constitute
sound explanation  addition constraint would redundant  set
constraints input triples fans  minimal set semantically collection input
data incompatible  junker        state method achieved worst
case  k log   n k     k propagations    k size minimal explanation
found n number constraints 
alternative approach satisfy many input triples fans possible
within reasonable amount time  i e   polynomial time  semple steel propose
algorithm  mincutsupertree         refined page        
propose similar scheme within constraint programming framework  call
algorithm greedybuild works follows  associate constrained integer
variable x  domain         triple fan  variable assigned
value   triple  or fan  respected  otherwise ignored  therefore triple
 ij k post constraint equation      fan  ijk  constraint equation
   

 x     mij   mik   mjk    x      mik    mjk mij mik mij mik   

    

 x     mij   mik   mjk    x      mij    mik mij    mjk mik    mjk   

    

greedybuild instantiates turn x variables  i e  decision variables 
preferring value   value    instantiation problem made arcconsistent  algorithm shown figure     line   constraint model produced 
i e   n n symmetric array constrained integers variables created  n
unique species forest  um matrix bcz constraint posted
variables  variable x line   set decision variables  input trees
broken before  new variable x created triple fan  line
  constraints equations       posted model  loop lines   
   turn select decision variable  set lowest possible value  make
problem arc consistent  might turn cause uninstantiated variables
value   removed domain associated triple fan conflicts triple
   bc z  propagator o     however  time complexity number
propagations 

   

fithe ultrametric constraint phylogenetics

algorithm greedybuild
greedybuild f  
 
let  v  d  c  cpmodel f  
 
let x
 
f
 
breakup t  
 
let x newv ar      
 
let c newconstraint  t x       t x      
 
x x  x 
 
v v  x 
 
c post c  c 
   x x
  
instantiate x 
  
propagate v  d  c 
   return umtotree v  d 

figure     greedily build supertree forest f using ultrametric constraint model 

fan enforced  process terminates without failure 
conflicting triples fans essentially ignored  line    ultrametric matrix
converted tree  complexity greedybuild o  t   f   n   
triples f fans 
greedybuild applied forest bird data  a  b  c  d  e  f  g  section    using soft breakup  data incompatible use cpbuild  however
greedybuild produces supertree figure     supertree contains     species 
softbreakup produced     triples     rejected  took less  
seconds build model     seconds solve model 
compared cpbuild data set  taking     seconds build model
   seconds determine incompatibility  greedybuild applied data set
abdf  producing identical supertree cpbuild  comparable time     ms build
model    ms solve  
executed greedybuild decision variables set x  lines         
    analysed identify set triples fans excluded
supertree  i e   x variable instantiated value   corresponding
triple fan ignored 
note claim biological significance arbitrary order use
suppress triples  greedybuild could amended follow order mincutsupertree investigated this  greedybuild enhanced
follows  currently triple fan exists multiple input trees occurs
constraint  information could exploited weighting decision variables
take consideration relative weight evidence triple fan  e g   number
times triple fan occurs input  decision variables instantiated
non increasing order weight  i e   variable ordering heuristic used 
extreme greedybuild modified become optbuild full backtracking
search performed objective minimising sum decision variables 
   

fimoore   prosser

figure     supertree largest data set birds  abcdefg      species 
took   seconds model     seconds solve using greedybuild 
displayed using rod pages treeview 

   

fithe ultrametric constraint phylogenetics

potentially exponential cost time  would return tree fewest possible
input triples suppressed 
    summary
little effort  constraint model adapted deal ancestral divergence
dates nested taxa  achieved adding side constraints 
added advantage respect ancestral divergence result compact
enumeration output trees interior nodes labelled ranges rather specific
values 
input trees conflict propose two options  use quickxplain determine
cause conflict greedily build supertree using greedybuild  bryant et al        
state essentially all or nothing approach supertree construction
using rankedtree needed something akin mincutsupertree  i e 
trees incompatible build supertree violates minimum number triples
fans  polynomial time  page        semple   steel         since
done bordewich et al         done constraint model
incorporating constraints identified section     greedybuild 
although shown  obvious ancestral divergence data nested taxa
combined one model  simply adding necessary constraint auxiliary
variables variants one model  this  again  could done greedybuild 
would require heuristic rule used deciding constraints ignore
input trees side constraints incompatible 
opinion  deriving  combining analysing results imperative algorithms
supertree problems much difficult above  algorithms variants
required far complex data structures tailored algorithms processing them 
moreover  combine algorithms produced seems practically impossible account
intricacy  finally constraint programming provides various generic methods
quickxplain box turn interest supertree problems 

   conclusion
presented new constraint propagator ultrametric constraint three
integer variables  shown extended symmetric matrix constrained
integer variables  bounds z  consistency established symmetric array
lower bounds variables give mutual support  sufficient modelling solving
supertree construction problem o n    time o n    space  comparable complexity onetree  ng   wormald        inferior algorithm bryant
steel         so  bother cpbuild approach efficient imperative
approaches already exist  answer lies versatility constraint programming 
rather develop new algorithm new variant supertree problem add
side constraints base model  shown polynomial time bound
often achieved  done ancestral divergence dates nested taxa 
shown model used deliver necessary triples fans 
proposed greedybuild way dealing incompatible trees 
   

fimoore   prosser

acknowledgments
would thank pierre flener xavier lorca  barbara smith  ian gent christine wei wu  charles semple  mike steel rod page  muffy calder joe sventek 
stanislav zivny  chris unsworth  three anonymous reviewers co authors 

references
aho  a   sagiv  y   szymanski  t     ullman  j          inferring tree lowest
common ancestors application optimization relational expressions 
siam j  comput                 
beldiceanu  n   flener  p     lorca  x          combining tree partitioning  precedence 
incompatibility constraints  constraints          
bessiere  c     regin  j  c          refining basic constraint propagation algorithm 
ijcai  pp         
bessiere  c          constraint propagation  handbook constraint programming  elsevier  chapter   
bininda emonds  o          phylogenetic supertrees  combining information reveal
tree life  springer 
bordewich  m   evans  g     semple  c          extending limits supertree methods 
annals combinatorics           
bryant  d     steel  m          extension operations sets leaf labeled trees  advances applied mathematics             
bryant  d   semple  c     steel  m          supertree methods ancestral divergence
dates applications  bininda emonds  o   ed    phylogenetic supertrees 
combining information reveal tree life  pp          computational biology
series kluwer 
carlier  j     pinson  e          adjustment heads tails jobshop scheduling
problem  european journal operational research             
caseau  y     laburthe  f          solving small tsps constraints  proceedings
international conference logic programming  pp      
choco         http   www choco constraints net  home choco constraint programming system  
daniel  p          supertree methods  new approaches  masters thesis  department
mathematics statistics  university canterbury 
daniel  p     semple  c          supertree algorithms nested taxa  bininda emonds 
o   ed    phylogenetic supertrees  combining information reveal tree life 
pp          computational biology series kluwer 
   

fithe ultrametric constraint phylogenetics

dawkins  r     wong  y          ancestors tale  weidenfeld nicholson 
debruyne  r     bessiere  c          practicable filtering techniques constraint
satisfaction problem  proceedings ijcai    pp         
dooms  g          cp graph  computation domain constraint programming 
ph d  thesis  universite catholique de louvain  faculte des sciences appliquees 
gent  i   prosser  p   smith  b     wei  w          supertree construction constraint
programming  principles practice constraint programming  pp         
springer 
gusfield  d          algorithms strings  trees  sequences  computer science
computational biology  cambridge university press  new york  ny  usa 
janczewski  d   modi  w   stephens  j     obrien  s          molecular evolution
mitochondrial   s rna cytochrome b sequences pantherine lineage
felidae  mol  biol  evol              
jeavons  p  g     cooper  m  c          tractable constraints ordered domains  artif 
intell                  
junker  u          quickxplain  preferred explanations relaxations overconstrained problems  proceedings aaai      pp         
kennedy  m     page  r          seabird supertrees  combining partial estimates procellariiform phylogeny  auk            
lhomme  o          efficient filtering algorithm disjunction constraints 
principles practice constraint programming  pp          springer 
mace  g  m   gittleman  j  l     purvis  a          preserving tree life  science 
              
mackworth  a          consistency networks relations  artificial intelligence    
      
ng  m  p     wormald  n  c          reconstruction rooted trees subtrees  discrete
appl  math                  
page  r          treeview  application display phylogenetic trees personal
computers  computer applications biosciences             
page  r          taxonomy  supertrees  tree life  bininda emonds  o   ed   
phylogenetic supertrees  combining information reveal tree life  pp         
computational biology series kluwer 
page  r  d  m          modified mincut supertrees  wabi     proceedings second
international workshop algorithms bioinformatics  pp         london  uk 
springer verlag 
   

fimoore   prosser

pennisi  e          modernizing tree life  science                
prosser  p          supertree construction constraint programming  recent progress
new challenges  wcb     workshop constraint based methods bioinformatics  pp       
prosser  p     unsworth  c          rooted tree spanning tree constraints    th
ecai workshop modelling solving problems constraints 
regin  j  c          filtering algorithm constraints difference csps  proceedings aaai    pp         
rossi  f   van beek  p     walsh  t          handbook constraint programming  elsevier 
sabin  d     freuder  e          contradicting conventional wisdom constraint satisfaction  proceedings ecai     pp         
schulte  c     carlsson  m          finite domain constraint programming systems 
handbook constraint programming  elsevier  chapter    
semple  c   daniel  p   hordijk  w   page  r     steel  m          supertree algorithms
ancestral divergence dates nested taxa  bioinformatics                    
semple  c     steel  m          supertree method rooted trees  discrete appl  math  
                  
smith  b  m          tutorial constraint programming  technical report       
university leeds 
treebase         http   www treebase org  treebase  database phylogenetic knowledge  
tsang  e          foundations constraint satisfaction  academic press 
van hentenryck  p   deville  y     teng  c  m          generic arc consistency algorithm
specializations  artificial intelligence             
van hentenryck  p   saraswat  v     deville  y          design  implementation 
evaluation constraint language cc fd   journal logic programming         
    
wu  g   you  j  h     lin  g          quartet based phylogeny reconstruction answer
set programming  ieee acm transactions computational biology bioinformatics            
yuanlin  z     yap  r  h  c          making ac   optimal algorithm  ijcai  pp 
       

   


