journal artificial intelligence research          

submitted        published      

m dpop  faithful distributed implementation
efficient social choice problems
adrian petcu
boi faltings

adrian   petcu   epfl   ch
boi   faltings   epfl   ch

artificial intelligence lab  ecole polytechnique federale de lausanne 
station          lausanne  switzerland

david c  parkes

parkes   eecs   harvard   edu

school engineering applied sciences  harvard university
   oxford street  cambridge        usa

abstract
efficient social choice problem  goal assign values  subject side constraints 
set variables maximize total utility across population agents  agent
private information utility function  paper model social choice problem
distributed constraint optimization problem  dcop   agent communicate
agents share interest one variables  whereas existing dcop algorithms
easily manipulated agent  either misreporting private information deviating
algorithm  introduce m dpop  first dcop algorithm provides faithful distributed
implementation efficient social choice  provides concrete example methods
mechanism design unified distributed optimization  faithfulness ensures
agent benefit unilaterally deviating aspect protocol  neither informationrevelation  computation  communication  whatever private information agents 
allow payments agents central bank  central authority
require  achieve faithfulness  carefully integrate vickrey clarke groves  vcg  mechanism dpop algorithm  agent asked perform computation  report
information  send messages best interest  determining agent payment
requires solving social choice problem without agent i  here  present method reuse
computation performed solving main problem way robust manipulation
excluded agent  experimental results structured problems show much    
computation required solving marginal problems avoided re use  providing
good scalability number agents  unstructured problems  observe sensitivity
m dpop density problem  show reusability decreases almost
     sparse problems around     highly connected problems  close discussion features dcop enable faithful implementations problem  challenge
reusing computation main problem marginal problems algorithms
adopt optapo  prospect methods avoid welfare loss occur
transfer payments bank 

   introduction
distributed optimization problems model environments set agents must agree
set decisions subject side constraints  consider settings agent
preferences subsets decisions  agents self interested  one would
obtain decision maximizes utility  however  system whole agrees  or
social designer determines  solution selected maximize total utility across
c
    
ai access foundation  rights reserved 

fip etcu   faltings     parkes

agents  thus  problem efficient social choice  motivation  mind massively
distributed problems meeting scheduling  decisions
hold meeting  allocating airport landing slots airlines  decisions
airline allocated slot  scheduling contractors construction projects 
one approach solve problems central authority computes optimal solution  combination incentive mechanism vickrey clarke groves  vcg 
mechanism  jackson         prevent manipulation misreporting preferences  however  many practical settings hard bound problem central
authority feasible  consider meeting scheduling  agent participates
meetings  general possible find set meetings constraints
meetings thus optimized separately  similarly  contractors construction
project simultaneously work projects  creating web dependencies hard
optimize centralized fashion  privacy concerns favor decentralized solutions  greenstadt 
pearce    tambe        
algorithms distributed constraint reasoning  abt awc  yokoo   hirayama 
       aas  silaghi  sam haroud    faltings         dpop  petcu   faltings      b 
adopt  modi  shen  tambe    yokoo         deal large problems long influence agent solution limited bounded number variables  however 
current techniques assume cooperative agents  provide robustness misreports
preferences deviations algorithm self interested agents  major limitation 
recent years  faithful distributed implementation  parkes   shneidman        proposed
framework within achieve synthesis methods  centralized  md distributed
problem solving  faithfulness ensures agent benefit unilaterally deviating
aspect protocol  neither information revelation  computation  communication  whatever private information agents  now  distributed implementation applied
lowest cost routing  shneidman   parkes        feigenbaum  papadimitriou  sami    shenker 
       policy based routing  feigenbaum  ramachandran    schapira         internet 
efficient social choice  problem broad applicability 
paper  make following contributions 
show model problem efficient social choice dcop  adapt
dpop algorithm exploit local structure distributed model achieve
scalability would possible solving problem centralized problem graph 
provide algorithm whose first stage faithfully generate dcop representation
underlying social choice problem  dcop representation generated 
next stages m dpop algorithm faithful  form ex post nash equilibrium
induced non cooperative game 
establishing dcop models social choice problems solved faithfully 
observe communication information structure problem
agent prevent rest system  aggregate  correctly determining marginal
impact allowing agents  reported  preferences total utility achieved
agents  provides generality techniques dcop algorithms 
part achieving faithfulness requires solving dcop agents  reported  preferences ignored turn  without agent able interfere computational
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

process  provide algorithm robustness property  nevertheless able
reuse  possible  intermediate results computation solving main problem
agents 
experimental analysis  structured meeting scheduling problems common
benchmark literature  demonstrate much     computation required
solving marginal problems avoided reuse  results provided
unstructured resource allocation problems     show m dpop sensitive problem
density  loose problems  around     computation reused 
decreases highly connected problems 
m dpop algorithm defines strategy agent extensive form game induced
dcop efficient social choice  particular  m dpop algorithm defines messages
agent send  computation agent perform  response messages
received agents  proving m dpop forms game theoretic equilibrium  show
agent benefit unilaterally deviating  whatever utility functions agents
whatever constraints  although robust dominant strategy equilibrium   ex
post  equilibrium requires every agent follow algorithm  parkes shneidman       
earlier commented appears necessary cost decentralization 
total payment made agent bank always non negative m dpop never
runs deficit  i e  bank always receives non negative net payment agents  
settings  transfer utility bank undesirable would best avoided  provide
statistics problem domains studied show loss represent much
    total utility achieved solution problems studied  payments
cannot naively redistributed back agents without breaking faithfulness  extant work redistribution mechanisms vcg payments suggests mitigated  guo   conitzer       
faltings        cavallo        moulin        bailey         defer extension m dpop 
details surprisingly involved interesting right  future work 
reuse computation  solving marginal problems agent removed turn 
especially important settings distributed optimization motivating scenarios
problem size massive  perhaps spanning multiple organizations encompassing
thousands decisions  example  consider project scheduling  inter firm logistics  intra firm
meeting scheduling  etc  appropriate problem structure  dcop algorithms problems
scale linearly size problem  instance  dpop able solve problems
single back and forth traversal problem graph  without re use additional
cost solving marginal problem would make computational cost quadratic rather
linear number agents  could untenable massive scale applications 
rest paper organized follows  preliminaries  section     section  
describe dpop  petcu   faltings      b  algorithm distributed constraint optimization 
focus study  section   introduces model self interested agents defines
 centralized  vcg mechanism  section     provides simple method  simple m dpop make
dpop faithful serves illustrate excellent fit information communication
structure dcops faithful vcg mechanisms  section   describe main algorithm  mdpop  computation re used solving marginal problems agent removed
   consider distributed combinatorial auctions  instances randomly generated using distribution cats
problem suite  leyton brown   shoham        

   

fip etcu   faltings     parkes

turn  present experimental results section    section   discuss adapting dcop
algorithms social choice  adopt optapo  see section       waste due
payments section      conclude section   
    related work
work draws two research areas  distributed algorithms constraint satisfaction optimization  mechanism design coordinated decision making multi agent systems
self interested agents  briefly overview relevant results areas 
      c onstraint atisfaction



ptimization

constraint satisfaction optimization powerful paradigms model wide range
tasks scheduling  planning  optimal process control  etc  traditionally  problems
gathered single place  centralized algorithm applied find solution  however 
social choice problems naturally distributed  often preclude use centralized entity
gather information compute solutions 
distributed constraint satisfaction  discsp   yokoo  durfee  ishida    kuwabara       
sycara  roth  sadeh koniecpol    fox        collin  dechter    katz              solotorevsky 
gudes    meisels        distributed constraint optimization  dcop   modi et al        
zhang   wittenburg        petcu   faltings      b  gershman  meisels    zivan        formalisms introduced enable distributed solutions  agents involved problems
must communicate find solution overall problem  unknown one
them   briefly  problems consist individual subproblems  each agent holds subproblem   connected  some of  peers subproblems via constraints limit
individual agent do  goal find feasible solutions overall problem  in
case discsp   optimal ones case dcop 
many distributed algorithms dcop introduced  none deals selfinterested agents  well known ones adopt  dpop optapo 
adopt  modi et al         backtracking based  bound propagation algorithm  adopt
completely decentralized message passing asynchronous  adopt
advantage requiring linear memory  linear size messages  applicability large
problems   questionable due fact produces number messages
exponential depth dfs tree chosen 
optapo  mailler   lesser        centralized distributed hybrid uses mediator nodes
centralize subproblems solve dynamic asynchronous mediation sessions 
authors show message complexity significantly smaller adopts  however  designed cooperative settings  settings self interested agents
social choice problem  unclear whether agents would agree revealing constraints
utility functions  possibly many  agents  solve partially
centralized subproblems 
dpop  petcu   faltings      b  complete algorithm based dynamic programming
generates linear number messages  dpop  size messages depends
   largest adopt experiments aware comprise problems around    agents    variables 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

structure problem  largest message exponential induced width
problem  see section        adopt  dpop maintains full distribution
problem  features suggest dpop good foundation efficient distributed
implementation vcg based mechanism social choice problems 
discussion features algorithms applicability social choice
problems provided section    paper  focus dpop provide appropriate
modifications payments effective environments self interested agents 
section     provide brief discussion opportunites challenges
applying methodology adopt optapo 
      echanism esign



istributed mplementation

long tradition using centralized incentive mechanisms within distributed ai  going
back least work ephrati rosenschein        considered use vcg
mechanism compute joint plans  see work sandholm        parkes et al        
recent discussions  noteworthy work rosenschein zlotkin             
rules encounter  provided non vcg based approaches task allocation systems
two agents 
hand  known methods distributed problem solving
presence self interested agents  example  raco n et  sandholm        improved
upon c ontract n et system  davis   smith        negotiation based  distributed task reallocation  providing better economic realism  raco n et nevertheless studied simple 
myopically rational agent behaviors performance game theoretic agents never analyzed  remains true recent works  endriss  maudet  sadri    toni        dunne 
wooldridge    laurence        dunne         similarly  wellmans work market oriented programming  wellman              considers role virtual markets support optimal
resource allocation  developed model price taking agents  i e  agents treat
current prices though final   rather game theoretic agents 
first step providing satisfactory synthesis distributed algorithms md
provided agenda distributed algorithmic mechanism design  damd   due work
feigenbaum colleagues  feigenbaum et al         feigenbaum   shenker        
authors  fpss  provided efficient algorithm lowest cost interdomain routing internet 
terminating optimal routes payments vcg mechanism  up shot
agents case autonomous systems running network domains could benefit misreporting information transit costs  missing analysis consideration
robustness algorithm manipulation  distributed implementation  parkes
  shneidman        introduces additional requirement  algorithm faithful agent
cannot benefit deviating required actions  including information revelation  computation message passing  number principles achieving faithfulness ex post nash
equilibrium provided parkes shneidman         careful incentive design small
amount cryptography able remove remaining opportunities manipulation
lowest cost routing algorithm fpss  building this  feigenbaum et al         recently provide faithful method policy based interdomain routing  better capturing typical business
agreements internet domains 
   

fip etcu   faltings     parkes

first work achieve faithfulness general dcop algorithms  demonstrated
via application efficient social choice  work  monderer tennenholtz        consider distributed single item allocation problem  focus  faithful  communication
provide distributed computation  izmalkov et al         adopt cryptographic primitives
ballot boxes show convert centralized mechanisms di fully connected
communication graph  interest demonstrating theoretical possibility ideal mechanism design without trusted center  work different focus  seek computational
tractability  require fully connected communication graphs  make appeal cryptographic primitives  hand  content retain desired behavior equilibrium
 remaining consistent md literature  izmalkov et al  avoid introduction
additional equilibria beyond exist centralized mechanism 
briefly mention two related topics  note well established literature iterative
vcg mechaisms  mishra   parkes        ausubel  cramton    milgrom        bikhchandani 
de vries  schummer    vohra         provide partially distributed implementation
combinatorial allocation problems  center typically issuing demand queries agents
via prices  prices triggering computation part agents generating demand set
response  auctions often interpreted decentralized primal dual algorithms  parkes
  ungar        de vries   vohra         setting differs remains center
performs computation  solving winner determination problem round  agent
communicates directly center peer to peer  mualem        initiates orthogonal
direction within computer science related topic nash implementation  jackson       
economics  approach relies information part private part common knowledge 
one agent entirely private information preferences 

   preliminaries  modeling social choice
assume social choice problem consists finite possibly large number decisions
made time  decision modeled variable take
values discrete finite domain  agent private information variables
places relations  relation associated agent defines utility agent
possible assignment values variables domain relation  may
hard constraints restrict space feasible joint assignments subsets variables 
definition    social choice problem   scp  efficient social choice problem modeled
tuple   a  x   d  c  r   that 
x    x         xm   set public decision variables  e g  hold
meetings  resources allocated  etc  
   d         dm   set finite public domains variables x  e g  list possible
time slots venues  list agents eligible receive resource  etc  
c    c         cq   set public constraints specify feasible combinations values
variables involved  constraint cj function cj   dj     djk      
returns   allowed combinations values involved variables 
disallowed ones  denote scope cj   set variables associated constraint cj  
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

   a           set self interested agents involved optimization problem 
x ai   x  privately known    set variables agent ai interested
relations 
r    r         rn   set private relations  ri set relations specified
agent ai relation rij ri function rij   dj     djk r specified agent
ai   denotes utility ai receives possible values involved variables
 j            jk    negative values mean costs   denote scope rij   domain variables
rij defined on 
private relations agent may  themselves  induced solution local optimization problems additional  private decision variables additional  private constraints 
kept local agent part scp definition 
optimal solution scp complete instantiation x variables x   s t 
x
x
ri  x   
cj  x  
   
x arg max
xd

i      n 

cj c

rj  x  agent ai total utility assignment x  natural
ri  x   
rij ri
problem social choice  goal find solution maximizes total utility agents 
respecting hard constraints  notice second sum x infeasible precludes
outcome  assume throughout feasible solution  introducing vcg
mechanism require solution scp influence agents relations
removed turn  this  let scp  a  denote main problem
eq     
pand scp  ai   denote
p
marginal problem without agent ai   i e  maxxd j  i rj  x    cj c cj  x   note
decision variables remain  difference scp  a  scp  ai  
preferences agent ai ignored solving scp  ai   
variable xj   refer agents ai xj x ai   forming community
xj   choose emphasize following assumptions 
p

agent knows variables interested  together domain
variable hard constraints involve variable 
decision variable supported community mechanism allows interested
agents report interest learn other  example  mechanism
implemented using bulletin board 
constraint cj c  every agent ak community xl scope cj    i e 
xl x ak    read membership lists communities xm scope cj  
xm    xl   words  every agent involved hard constraint knows
agents involved hard constraint 
agent communicate directly agents communities
member  agents involved shared hard constraints 
communication agents required 
   note private knowledge variables interest requirement  algorithms present work
public private knowledge variables interest  required agents interested
variable know   see assumptions below 

   

fip etcu   faltings     parkes

figure    operator placement problem   a  centralized model  each variable server load possible
values feasible combinations services run server   edges correspond
relations represent agent preferences    b  decentralized  dcop  model replicated
variables  agent local replica variables interest inter agent edges denote
equality constraints ensure agreement  preferences modeled relations hyperedges local respective agents 

section   establish step identifying scp  via community mechanism  faithful self interested agents choose volunteer communities
member  and communities  
    modeling social choice constraint optimization
first introduce centralized  constraint optimization problem  cop  model efficient social choice problem  model represented centralized problem graph  given this 
model distributed constraint optimization problem  dcop   along associated
distributed problem graph  distributed problem graph makes explicit control structure
distributed algorithm ultimately used multi agent system solve problem 
sections illustrated reference overlay network optimization problem  huebsch 
hellerstein  lanham  et al         faltings  parkes  petcu    shneidman        pietzuch  ledlie 
shneidman  roussopoulos  welsh    seltzer        
overlay n etwork ptimization consider problem optimal placement data aggregation processing operators overlay network large scale sensor network  huebsch
et al         pietzuch et al          application  multiple users multiple servers 
user associated query client machine located particular node
overlay network  query associated set data producers  known user located
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

nodes network  query requires set data aggregation processing operators  placed server nodes nodes data producers
users node  user assigns utility different assignments operators servers represent preferences different kinds data aggregation  examples in network operators
data aggregation include database style join operators  e g   user may desire volcano data x
earthquake data joined sent them  address this  specific operator call
volcanoxearthquakey join created put network  naturally  user prefers
operators placed best servers network  without regard costs incurred  overloading servers  denying service users  etc  problem find optimal
allocation operators servers  subject capacity compatibility constraints 
faltings et al         model problem one efficient social choice  distributed algorithm  executed user clients situated network nodes  used determine assignment
data aggregation processing operators server nodes 
      c entralized cop odel ulti g raph
viewed centralized problem  scp defined constraint optimization problem
multigraph  i e  graph several distinct edges connect set nodes  denote
cop  a   provide illustration figure   a   decision variables nodes 
relations defined subsets variables form edges multigraph  hyperedges connect
two vertices case relation involving two variables 
multiple edges involve set variables  edge corresponding
relations distinct agent set variables  hard constraints represented
edges graph 
example    centralized model overlay optimization  example figure   a  contains
  users ai   servers sj   simplicity reasons  assume user ai one single operator oi want executed server  according prerequisites compatibility
issues  assume s  execute o  o    o    similarly  assume s  execute
o  o    o    s  execute combination two three operators  agents preferences operators executed  e g  proximity
data sources  computational capabilities servers  cost electricity  etc   example  a 
extracts utility    o  executed s    utility   o  executed s   
model problem optimization problem  use following 
   variables  server si   create variable si denotes set operators si
execute 
   values  variable si take values set possible combinations operators
server execute  example  s     null  o    o    o    o     null means
server executes operator  oi executes operator oi   o    o  executes
o  o   
   constraints  restrict possible combinations assignments  example  two servers
execute operator 
   relations  allow agents express preferences combinations assignments  a  models
preference placement o  using relation r     defined variables s 
   

fip etcu   faltings     parkes

s    relation associates utility value combination assignments s 
s   in total          combinations  follows 
  combinations o  executed neither s    s   e g  hs    o    s   
o  i 
   combinations o  executed s   e g  hs    o    s    o    o  i 
  combinations o  executed s   e g  hs    o    s    o  i 
depict variables nodes graph  constraints relations  hyper edges  see
figure   a    problem get arbitrarily complex  multiple operators per agent  groups
servers able execute certain groups compatible operators  etc 
      ecentralized cop  dcop  odel u sing r eplicated variables
useful define alternate graphical representation scp  centralized problem
graph replaced distributed problem graph  distributed problem graph direct correspondence dpop algorithm solving dcops  denote dcop  a  problem
agents included  corresponds main social choice problem  scp  a   similarly 
dcop  ai   problem agent ai removed  corresponds scp  ai   
distributed model  agent local replica variables interested  
public variable  xv x ai    agent ai interested  agent local replica  denoted
xvi   agent ai models local problem cop  x ai    ri    specifying relations rij ri
locally replicated variables 
refer figure   b  translation centralized problem figure   a  dcop
model  agent local variables loads servers interest itself  i e 
servers execute one operators  e g  s   represents a  local replica variable
representing server s     local edges correspond local all different constraints agents
variables ensure execute operator several servers time  equality
constraints local replicas value ensure global agreement operators
run servers 
agents specify relations via local edges local replicas  example  agent a 
relation load servers s  s  express preference placement
operator o  relation r     assign e g  utility   s  executing o    utility    s 
executing o   
begin understand potential manipulation self interested agents
example  notice although globally optimal solution may require assigning o  s   
less preferable a    providing utility   instead     therefore  absence incentive
mechanism  a  could benefit simple manipulation  declare utility   hs    o  i  thus
changing final assignment suboptimal one nevertheless better itself 
   alternate model designates owner agent decision variable  owner agent would centralize
aggregate preferences agents interested variable  subsequently  owner agents would use
distributed optimization algorithm find optimal solution  model limits reusability computation
main problem solving marginal problems agent removed turn excluding
owner agent variable  one needs assign ownership another agent restart computational process
regards variable connected variables  reuse computation important making m dpop
scalable  approach disaggregated facilitates greater reuse 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

neighborhood local copy xvi variable composed three kinds variables 
neighbors xvi     siblings xvi   local neighbors xvi   hard neighbors xvi   

   

siblings local copies xv belong agents aj    ai interested xv  
siblings xvi      xvj   aj    ai xv x aj   

   

siblings xvi connected pairwise equality constraint  ensures
agents eventually consistent value variable  second set variables
local neighbors xvi local optimization problem ai   local copies
variables agent ai interested in  connected xvi via relations ai local
problem 
local neighbors xvi      xui   xu x ai    rij ri s t  xui scope ri   

   

must consider set hard constraints contain scope variable xv
public variables  hard  xv      cs c xv scope cs     constraints connect
xv variables xu appear scope  may interest
agents well  consequently  xvi connected local copies xtj
variables xt appear hard constraints 
hard neighbors xvi      xtj  cs hard  xv   s t  xt scope cs    xt x aj   

   

general  agent private variables  relations constraints involve
private variables  link public decision variables  example  consider meeting
scheduling application employees company  apart work related meetings
schedule together  one employees personal items agenda  appointments doctor  etc  decisions values private variables information
local relations constraints remain private  provide additional complications
discussed paper 
    example social choice problems
continuing present main results describe three additional problems social choice
serve motivate work  fact  problem efficient social choice fundamental
microeconomics political science  mas colell  whinston    green         problem
present large scale distributed  involves actors system businesses
cannot expected cooperate  either revealing preferences following rules
distributed algorithm 
irport lot llocation   airports become congested  governments turning
market based approaches allocate landing takeoff slots  instance  u s  federal aviation administration recently commisioned study use auction allocate slots
new yorks congested laguardia airport  ball  donohue    hoffman         problem large
scale expands include airports throughout u s   eventually world  exhibits
self interest  airlines profit maximizing agents private information utilities
   

fip etcu   faltings     parkes

different slot allocations   one privacy major concern competitiveness airline industry  typical policy goal maximize total utility allocation 
i e  one efficient social choice  problem motivates study combinatorial auctions
section    combinatorial auction  ca  one set heterogeneous  indivisible goods
allocated agents  values expressed sets goods  e g   want
 am slot get   am slot indifferent  am     am slot 
airport slot allocation problem motivated first paper cas  rassenti  smith    bulfin 
       recognized airlines would likely need express utilities sets slots
correspond right fly schedule airport 
pen  access w ireless n etworks   wireless spectrum today owned operated
closed networks  example cellular companies t mobile at t  however
plenty debate creating open access wireless networks bandwidth must available
use phone software   recently proposed using auction protocol
allow service providers bid dynamic auction right use spectrum given period
time deliver services   taken logical conclusion  idea anticipated rosenschein
zlotkin        wired telephony  suggests secondary market wireless spectrum
corresponds problem efficient social choice  allocate spectrum maximize total utility
consumers  problem large scale  exhibits self interest  inherently decentralized 
eeting cheduling p roblem   consider large organization dozens departments  spread across dozens sites  employing tens thousands people  employees
different sites departments want setup thousands meetings week  due privacy
concerns among different departments  centralized problem solving desirable  furthermore 
although organization whole desires minimize cost whole process  department employee self interested wishes maximize utility  artificial
currency created purpose weekly assignment made employee  employees
express preferences meeting schedules units currency 
refer figure   example problem    agents want setup   meetings 
figure   b  shows agent local variables time slots corresponding meetings
participates  e g  m   represents a  local replica variable representing meeting m    
local edges correspond local all different constraints agents variables ensure
participate several meetings time  equality constraints local
replicas value ensure global agreement  agents specify relations via local edges
local replicas  example  agent a  relation time meeting m  express
preference meeting later day relation r     assign low utilities morning
time slots high utilities afternoon time slots  similarly  a  prefers holding meeting m 
meeting m    use local relation r   assign high utilities satisfactory
combinations timeslots low utility otherwise  example  hm     am  m      am
gets utility     hm     am  m     am gets utility   
   breakthrough ruling  u s  federal communications commission  fcc  require open access
around one third spectrum auctioned early    
stopped short mandating spectrum made available wholesale market would service providers 
see
http   www fcc gov           mhz news release        pdf
   google proposed auction filing made fcc may   st       
see
http   gullfoss  fcc gov prod ecfs retrieve cgi native pdf pdf id document            

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

figure    meeting scheduling problem   a  centralized model  each vertex meeting variable  red
edges correspond hard constraints non overlap meetings share participant  that
agent a  hyperedge particpates every meeting   blue edges correspond
relations represent agent preferences    b  decentralized  dcop  model replicated
variables  agent local replica variables interest inter agent edges denote
equality constraints ensure agreement  hard constraint non overlap meetings
m    m  m  local hyperedge agent a     c  dfs arrangement decentralized
problem graph  used dpop algorithm control order problem solving 

experimental results presented section   adopt meeting scheduling prototypical
structured social choice problems problem instances associated organizational
hierarchy  meeting scheduling introduced section      second set experiments
consider combinatorial auctions  cas   agents bid bundles goods 
consider set problem instances unstructured provide comparison point
meeting scheduling  cas provide nice abstraction kinds allocation problems exist
airport wireless network domains 

   cooperative case  efficient social choice via dpop
section  review dpop  petcu   faltings      b   general purpose distributed
optimization algorithm  dpop  distributed pseudotree optimization protocol  based dynamic
programming adapts dechters  dechter        general bucket elimination scheme distributed case  main advantage generates linear number messages 
contrast optimization algorithms adopt  modi et al         ensures minimal network overhead produced message exchange  hand  concern dpop
size individual messages since grows exponentially parameter constraint graph
called induced width  see section         nevertheless  problems exhibit local structure 
dpop typically scales much larger problems  orders magnitude efficient 
   

fip etcu   faltings     parkes

techniques  petcu   faltings      b         simplify exposition  first illustrate
dpop general dcop context  show instantiate dpop social choice problems  particular  explain leverage structure provided local replicas  consider
cooperative agents throughout section 
    dpop algorithm dcops
section presents dpop algorithm generic dcops  simplify exposition 
assume section agent ai represents single variable xi  
constraint graph given 
dpop composed three phases 
phase one constructs dfs arrangement  dfs  a   defines control flow message passing computation dpop 
phase two bottom up utility propagation along tree constructed phase   
phase utilities different values variables aggregated reflect optimal decisions
made subtrees rooted node tree 
phase three top down value assignment propagation along tree constructed phase
   phase decisions made based aggregate utility information phase   
describing phases refer figure   running example  introduce
explicit numerical example illustrate phases two three detail 
      dpop p hase ne   dfs ree g eneration
first phase performs depth first search  dfs  traversal problem graph  thereby constructing dfs arrangement problem graph  dfs arrangement subsequently used
provide control flow dpop guide variable elimination order  underlying problem graph tree dfs arrangement tree  general  dfs arrangement
graph define union set tree edges additional back edges  connect
nodes ancestors  
definition    dfs arrangement  dfs arrangement graph g defines rooted tree
subset edges  the tree edges  remaining edges included back edges  tree
edges defined adjacent nodes g fall branch tree 
figure   shows example dfs arrangement  tree edges shown solid lines  e g 
     back edges shown dashed lines  e g              two nodes xi xv
said branch dfs arrangement path higher node
lower node along tree edges  e g   nodes x  x   figure    dfs arrangements already
investigated means boost search constraint optimization problems  freuder   quinn 
      modi et al         dechter   mateescu         advantage allow algorithms
exploit relative independence nodes lying different branches dfs arrangement
   simplicity  assume follows original problem connected  however difficulty
applying dpop disconnected problems  dfs arrangement becomes dfs forest  agents
connected component simply execute dpop parallel separate control thread  solution overall
problem union optimal solutions independent subproblem 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

figure    dfs arrangement problem graph  tree edges shown solid back edges
dashed  dfs arrangement constructed initializing token passing x    k ary
constraints  c    treated cliques 

 i e  nodes direct descendants ancestors one another   possible
perform search parallel independent branches combine results 
introduce definitions related dfs arrangements 
definition    dfs concepts  given node xi dfs arrangement  define 
parent pi   children ci   xi ancestor descendants connected xi via tree edges  e g 
p    x    c     x    x      
pseudo parents pp   xi ancestors connected xi via back edges  pp      x     
pseudo children pc   xi descendants connected xi via back edges  e g  pc    
 x     
separator sep xi   ancestors xi directly connected xi descendants xi  e g  sep      x    sep       x    x    x     
tree neighbors tn xi nodes linked xi via tree edges  tn   pi ci
 e g  tn      x    x    x      
removing nodes sep completely disconnects subtree rooted xi rest
problem  case problem tree  sep    pi    xi x   general case  sep
contains pi   pp pseudoparents descendants xi pseudoparents
ancestors xi   example  figure    separator node x  contains parent x   
pseudoparent x    necessary sufficient values variables  x    x   
set problem rooted node x  independent rest problem  separators
play important role dpop contingent solutions must maintained propagating
utility information dfs arrangement different possible assignments separator variables 
constructing dfs tree generating dfs trees distributed manner task
received lot attention  many algorithms available  example collin
dolev         barbosa         cidon         cheung        name few  purposes executing dpop  assume example algorithm cheung        
briefly outline below  instantiate dpop scps  present adaptation
dfs generation algorithm exploit particulars scp 
simple dfs construction algorithm starts agents labeling internally neighbors
not visited  one agents graph designated root  using example leader
   

fip etcu   faltings     parkes

election algorithm abu amara          simply picking agent
lowest id  root initiates propagation token  unique message
circulated agents graph  thus visiting them  initially  token contains
id root  root sends one neighbors  waits return sending
one  still  unvisited neighbors  agent xi first receives token  marks
sender parent  neighbors xi contained token marked xi pseudoparents
 pp   
this  xi adds id token  sends token turn one notvisited neighbors xj   become children  every time agent receives token one
neighbors  marks sender visited  token return either xj  the child
xi sent first place   another neighbor  xk   latter case  means
cycle subtree  xk marked pseudochild 
dead end reached  last agent backtracks sending token back parent 
neighbors marked visited  xi finished exploring subtree  xi removes
id token  sends token back parent  process finished xi  
root marked neighbors visited  entire dfs construction process over 
handling non binary constraints  special treatment required construct neighbors
variable correspond k ary constraints  k      example  figure    left  
  ary constraint c  involving  x    x    x    x      eq     implies  x    x    x    x    
neighbors  dfs construction process appear along branch
tree  produces result figure    right  
      dpop p hase wo   util p ropagation  i nference  
phase two bottom to top pass dfs arrangement utility information aggregated
propagated leaves towards root node parent tree edges
back edges  high level  leaves start computing sending util messages
parents  util message informs parent local utility solutions
rest problem  minimally specified terms local utility different value assignments
separator variables  subsequently node propagates util message represents
contingent utility subtree rooted node assignments values separator variables 
detail  nodes perform following steps 
   wait util messages children  store them 
   perform aggregation  join messages children  relations
parents pseudoparents 
   perform optimization  project resulting join picking optimal
values combination values variables join 
   send result parent new util message 
   cases problem initially disconnected  required choose multiple roots  one connected component  standard leader election algorithm  executed agents problem  elect
exactly many leaders connected components 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

util message sent node xi parent pi multidimensional matrix informs
pi much utility  ui  sep   subtree rooted xi receives different assignments values
variables define separator sep subtree  one variables  definition 
variable managed parent pi   util message already represents result optimization 
variables local subtree optimized different assignments separator
variables  compute util message node uses two operations  aggregation optimization 
aggregations apply join operator optimizations apply project operator described
petcu faltings      b   briefly summarized here 
let utilij utilkj denote util messages sent nodes xi xk parent
node xj   denote dim utilkj   set dimensions matrix  i e  set
variables separator sending node xk   assuming xj node receiving messages 
define 
definition    join operator  operator  join   utilij utilkj join two
util matrices  matrix dim utilij   dim utilkj   dimensions 
value cell join sum corresponding cells two source matrices 
definition    project operator  operator  projection   xj dim utilij   
utilij xj projection optimization utilij matrix along xj axis 
instantiation variables  dim utilij     xj    corresponding values
utilij  one value xj   tried  maximal one chosen  result matrix
one less dimension  xj   
notice subtree rooted xi influenced rest problem xi
separator variables  therefore  util message contains optimal utility obtained subtree
instantiation variables sep separator size plays crucial role bounding
message size 
example    util propagation  figure   shows simple example util propagation 
problem tree structure  figure   a      relations r     r     r   detailed figure   b  
relations variables  x    x      x    x     x    x    respectively 
individual variables local replicas  util phase x  x  project r   r     respectively  results highlighed cells r   r   figure   b  
instance  optimal value x  given x     assign x     c utility
   projections define util messages send x    x  receives messages x 
x    joins together relation x   adds utilities messages
corresponding cells r      projects join  instance  optimal value
x  given x     b x               max                        result
depicted figure   d   util message x  receives x    value
message represents total utility entire problem value x    return
example context third phase value propagation 
non binary relations constraints  binary constraints relations  k ary constraint
introduced util propagation once  lowest node dfs arrangement
part scope constraint  example  figure    constraint c  introduced
util propagation once  x     computing message parent  x   
   

fip etcu   faltings     parkes

figure    numerical example util propagation   a  simple dcop problem three
relations r     r   r    x    x      x    x     x    x    respectively   b  projections
x  x  relations x    results sent x  util     util  
respectively   c  x  joins util   util   relation x     d  x  projects
join sends result x   

      dpop p hase hree   value p ropagation
phase three top to bottom pass assigns values variables  decisions made recursively
root leaves  value propagation phase initiated root agent
x  received util messages children  based util messages 
root assigns variable x  value v maximizes sum utility
communicated subtrees  sends value x r v   message every child 
process continues recursively leaves  agents xi assigning optimal values
variables  end phase  algorithm finishes  variables assigned
optimal values 
example    value propagation  return example figure    x  receives util
message node x  simply choose value x  produces largest utility
whole problem  x     x    x    c produce result example  either one
chosen   value assignment propagation phase x  informs x  choice via
message value  x  a   node x  assigns optimal value x    c process continues
message v alu e x  c  sent children  x  x    children assign x    b
x    algorithm terminates optimal solution hx    a  x    c  x    b  x    ai
total utility    
      c omplexity nalysis dpop
dpop produces number messages scales linearly size problem graph  i e 
linearly number nodes edges dcop model  petcu   faltings      b  
complexity dpop lies size util messages  note tokens passed around
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

constructing dfs a  value messages size linear problem graph   petcu
faltings      b  show size largest util message exponential parameter
called induced width  kloks        dechter        
induced width  denoted w  constraint graph given chosen dfs arrangement
structural parameter equals size largest separator node dfs arrangement
 see definition     
w   max  sep   
xi x

   

example figure    induced width graph given particular dfs ordering
w      given sep      x    x    x     intuitively  problem tree like structure 
lower induced width  particular  problem graph tree induced
width equal   dfs arrangement always tree  problem graphs cliques 
hand  induced width equal number nodes minus    irrespective
dfs tree arrangement 
proposition    dpop complexity   petcu   faltings      b  number messages passed
dpop  m   n     n    phases one  two three respectively  n
number nodes edges dcop model replicated variables  maximal number
utility values computed node dpop o dw      largest util message
o dw   entries  w induced width dfs ordering used 
case trees  dpop generates util messages dimension equal domain size
variable defining parent node  case cliques  maximal message size
dpop exponential n    dfs arrangements yield width  desirable
construct dfs arrangements provide low induced width  however  finding tree arrangement
lowest induced width np hard optimization problem  arnborg         nevertheless 
good heuristics identified finding tree arrangements low width  kloks       
bayardo   miranker        bidyuk   dechter        petcu   faltings            b   although
designed explored centralized context   notably max degree
maximum cardinality set  easily amenable distributed environment 
    dpop applied social choice problems
section  instantiate dpop efficient social choice problems  specifically  first show
optimization problem constructed agents preferences potential variables
interest  subsequently  show changes make dpop adapt scp domain 
prominent adaptation exploits fact several variables represent local replicas
variable  treated util value phases 
adaptation improves efficiency significantly  allows complexity claims stated terms
induced width centralized cop problem graph rather distributed cop problem
graph  see section        
      nitialization   c ommunity f ormation
initialize algorithm  agent first forms communities around variables interest 
x ai    defines local optimization problem cop  x ai    ri   replicated variable xvi
   

fip etcu   faltings     parkes

xv x ai    shorthand xvi cop denotes agent ai local replica variable
xv   agent owns multiple nodes conceptualize node associated virtual agent operated owning agent  virtual agent responsible
associated variable 
agents subscribe communities interested  learn
agents belong communities  neighboring relations established local variable
according eq     follows  agents community xv connect corresponding local
copies xv equality constraints  so  local problems cop  x ai    ri  
connected according interests owning agents  local relations
cop  x ai    ri   connect corresponding local variables  hard constraints connect local copies
variables involve  thus  overall problem graph formed 
example  consider figure   b   decision variables start times three
meetings  agent models local optimization problem creating local copies variables
interested expressing preferences local relations  formally  initialization
process described algorithm   
algorithm    dpop init  community formation building dcop  a  
dpop init a  x   d  c  r  
  agent ai models interests cop  x ai    ri    set relations ri imposed
set x ai   variables xvi replicate public variable xv x ai  
  agent ai subscribes communities xv x ai  
  agent ai connects local copies xvi x ai   corresponding local copies
agents via equality constraints

      dfs raversal
method dfs traversal described algorithm    algorithm starts choosing one
variables  x    root  done randomly  example using distributed algorithm
random number generation  leader election algorithm ostrovski         simply
picking variable lowest id  agents involved community x  randomly
choose one them  ar leader  local copy x r variable x  becomes root
dfs  making assumption virtual agents act behalf variable problem 
functioning token passing mechanism similar described section       
additional consideration given community structure  root chosen  agents
participate distributed depth first traversal problem graph  convenience  describe
dfs process token passing algorithm members within community observe
release pick token agents  neighbors node sorted  in
line    prioritize copies variables held agents  local variables 
finally variables linked hard constraints 
example   consider meeting scheduling example figure    assume m  chosen
start community a  chosen within community leader  a  creates empty
token dfs   adds m   id token  dfs    m       eq     neighbors m      
 m     m     m     m      a  sends token dfs    m     first unvisited neighbor
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

algorithm    dpop phase one  dfs construction 
inputs  ai knows cop   neighbors xvi    xvi cop
outputs  ai knows p  xvi    pp  xvi    c xvi    pc  xvi    xvi cop  
 
 
 

 
 
 
 

 
 
  

procedure initialization
agents choose one variables  x    root 
agents x  community elect leader  ar  
ar initiates token passing x r construct dfs
procedure token passing  performed virtual agent xvi cop  
xvi root p  xvi     null  create empty token dfs   
else dfs   handle incoming tokens  
let dfs    dfs  xvi  
sort neighbors xvi   siblings xvi    local neighbors xvi   
hard neighbors xvi    set c xvi      null 
forall xl neighbors xvi   s t  xl visited yet
c xvi      c xvi   xl   send dfs xl wait dfs token return 
send dfs token back p  xvi   
procedure handle incoming tokens     run virtual agent xvi cop

  
  
  
  

  

wait incoming dfs message  let xl sender
mark xl visited 
first dfs message  i e  xl parent 
p  xvi      xl   pp  xvi       xk    xl  xk neighbors xvi   dfs    pp  xvi     
else
xl
  c xvi    i e  dfs coming pseudochild 
pc  xvi      pc  xvi   xl

list  i e  m     belongs a    a  receives token adds copy m   now dfs  
 m     m       a  sends token m   first unvisited neighbor  m    which belongs a    
agent a  receives token adds copy m   now dfs    m     m     m      
m   neighbor list neighbors m        m     m     m      since token a  received
already contains m   m     means already visited  thus  next variable
visit m     happens variable belongs a    token passed
m   internally  no message exchange required   m   added token  now dfs  
 m     m     m     m      
process continues  exploring sibling variables community turn  passing another community  on  eventually replicas variable arranged
chain equality constraints  back edges  predecessors replicas
variable  dead end reached  last agent backtracks sending token back
parent  example  happens a  receives token a  m  community 
then  a  sends back token a  on  eventually  token returns path
way root process completes 
   

fip etcu   faltings     parkes

      h andling



p ublic h ard c onstraints  

social choice problems  defined definition   contain side constraints  form publicly known hard constraints  represent domain knowledge resource allocated
once  hotel accomodate     people  person one meeting
time  etc  constraints owned agent  available agents
interested variable involved domain constraint  handling constraints
essentially unchanged handling non binary constraints standard dpop  described
section       dfs construction phase  section       util phase  specifically 
dfs construction  neighboring relationships defined eq    require local variable
local copies share hard constraint considered neighbors 
prioritization line   algorithm    for dfs construction   dfs traversal mostly made
according structure defined relations agents hard constraints
appear backedges dfs arrangement problem graph 
util propagation  hard constraints introduced util propagation phase lowest
agent community variable scope hard constraint  i e  agent
variable lowest dfs ordering  example  constraint m 
m  figure   specify m  occur m  becomes backedge
  communities would assigned a  handling 
      h andling r eplica variables
distributed model scp replicates decision variable every interested agent connects copies equality constraints  handling replica variables carefully
avoid increasing induced width k dcop model compared induced width
w centralized model  adaptation  util messages dpop distributed problem graph would conditioned many variables local copies
original variable  however  local copies represent variable must assigned
value  thus  sending many combinations different local copies variable take
different values wasteful  therefore  handle multiple replicas variable util
propagation though single  original variable  condition relations one
value  realized updating join operator follows 
definition    updated join operator scp  defined two steps 
step    consider util messages received input  one  consider variable
xvi message conditioned  local copy original variable xv  
rename xvi input util message xv   i e  corresponding name original
problem 
step    apply normal join operator dpop 
applying updated join operator makes local copies variable become indistinguishable other  merges single dimension util message
avoids exponential blow up 
example   consider meeting scheduling example figure    centralized model figure   a  dfs arrangement yields induced width   clique   nodes 
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

nevertheless  corresponding dcop model figure   b  induced width    seen
dfs arrangement figure   c   sep m      m     m     m      applying dpop
dfs arrangement  m   would condition util message utilm   m   variables
separator   m     m     m      however  m   m   represent variable  m    therefore  m   apply updated join operator  leverages equality constraint
two local replicas collapse single dimension  called m    message m    
result outgoing message   dimensions   m    m      takes much less
space  possible   agents involved  i e  a    a  a  know m     m  
m   represent variable 
change  value propagation phase modified top local
copy variable solve optimization problem compute best value  announcing
result local copies assume value 
      c omplexity nalysis dpop pplied ocial c hoice
special handling replica variables  dpop applied scps scale induced
width centralized problem graph  independently number agents involved
number local replica variables 
consider dfs arrangement centralized model scp equivalent
dfs arrangement dcop model  equivalent means original variables
scp visited order corresponding communities visited
distributed dfs construction   recall distributed dfs traversal described section      
visits local copies community dcop moving next community   let
w denote induced width dfs arrangement centralized scp  similarly  let k denote
induced width dfs arrangement distributed model  let   maxm  dm   denote
maximal domain variable  then  following 
theorem    dpop complexity scp  number messages passed dpop solving
scp  m   n     n    phases one  two three respectively  n
number nodes edges dcop model replicated variables  maximal number
utility values computed node dpop o dw      largest util message
o dw     entries  w induced width centralized problem graph 
p roof  first part claim  number messages  follows trivially proposition   
second part  message size computation   given dfs arrangement dcop  applying
proposition   trivially gives basic dpop algorithm  maximal amount computation
node o dk      largest util message o dk   entries  k induced width dcop problem graph  improve analysis need consider special
handling replica variables 
consider util messages travel along dfs tree  whose sets dimensions
contain separators sending nodes  recall updated join collapses local replicas
original variables  union dimensions util messages join dpop
dcop model becomes identical set dimensions nodes dpop
centralized model  thus  node dcop model performs amount computation
counterpart centralized model  follows computation required dpop scales
o dw     rather o dk     special handling 
   

fip etcu   faltings     parkes

remains one additional difference dpop dfs arrangement centralized scp versus dpop dfs arrangement dcop  variable xv replicated
across multiple agents projected util propagation local optimization top most agent handling local replica xv   first node
relevant information place support optimization step  particular  whenever node
maximal separator set associated top most replica variable
must retain dependence value assigned variable util message sends
parent  increases worst case message size dpop o dw      opposed o dw  
normal dpop  computation remains o dw     utility determined
value xv anyway  projecting xv out   
see effect message size described proof  local variable cannot
immediately removed util propagation  consider problem figure    suppose agent a  involved meeting m    introduces additional back edge
m   m   dfs arrangement decentralized model shown figure   c   dfs
arrangement cop model corresponds decentralized model simply traversal
cop order communities visited distributed dfs construction  corresponds chain  m  m  m    introduction additional back edge
m   m   distributed dfs arrangement change dfs cop model 
width remains w      however  m   top copy m    agent a  cannot project
m  outgoing util message  result sends util message w        
dimensions  opposed w     

   handling self interest  faithful algorithm social choice
adapted dpop remain efficient scps  turn issue self interest  without modification  agent manipulate dpop misreporting private relations
deviating algorithm various ways  setting meeting scheduling  example 
agent might benefit misrepresenting local preferences  i massively utility
meeting occurring  pm  am   incorrectly propagating utility information
 competing  agents  the person team high utility meeting  pm  
incorrectly propagating value decisions  it already decided meeting
involving person team  am meeting must  pm  
introducing carefully crafted payments  leveraging information communication
structure inherent dcops social choice  careful partitioning computation
agent asked reveal information  perform optimization  send messages
interest  able achieve faithfulness  mean agent choose 
even self interested  follow modified algorithm  first define vcg mechanism
social choice illustrate ability prevent manipulation centralized problem solving
simple example  place  next review definitions faithful distributed implementation results useful principle  partition principle  describe simple
m dpop algorithm without reuse computation prove faithfulness 
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

    review  mechanism design vcg mechanism
mechanism design  md  addresses problem optimizing criteria  frequently social welfare  presence self interested agents private information relevant
problem hand  standard story  agents report private information center  solves
optimization problem enforces outcome 
second price  sealed bid  vickrey  auction simple example mechanism  agent
makes claim value item auctioneer  allocates item highest
bidder second highest price  krishna         vickrey auction useful
non manipulable  weakly dominant strategy agent report true value 
efficient  item allocated agent highest value 
setting efficient social choice  assume existence currency agents
make payments  make standard assumption quasilinear utility functions  agent
ai net utility is 
ui  x  p    ri  x  p 

   

assignment x variables x payment p
center  i e   net utility
p r
j
 x  
minus amount
r
defined utility assignment  ri  x   
j
ri ri
payment  one celebrated results md provided vickrey clarke groves
 vcg  mechanism  generalizes vickreys second price auction problem efficient
social choice 
definition    vcg mechanism efficient social choice  given knowledge public constraints c  public decision variables x   vickrey clarke groves  vcg  mechanism works
follows 
agent  ai   makes report ri private relations 
centers decision  x   solves scp  a  given reports r    r            rn   
agent ai   makes payment
tax  ai    

x



rj  xi
  rj  x    

   

j  i

    solution scp  a   given reports r
center  xi


 
 r            ri    ri             rn   

agent makes payment equals negative marginal externality presence
imposes rest system  terms impact preferences solution
scp 
vcg mechanism number useful properties 
strategyproofness  agents weakly dominant strategy  i e  utility maximizing strategy whatever strategies whatever private information agents  truthfully report preferences center  sense vcg mechanism
non manipulable 
   

fip etcu   faltings     parkes

efficiency  equilibrium  mechanism makes decision maximizes total utility
agents feasible solutions scp 
participation 
p
equilibrium  utility agent ai   ri  x   tax  ai      ri  x    
p


j  i rj  xi    non negative  principle optimality  therej  i rj  x   
fore agents choose participate 
no deficit 
payment
made agent ai non negative scp 
p
p


j  i rj  x   principle optimality  therefore entire
j  i rj  xi  
mechanism runs budget surplus 
begin understand vcg mechanism strategyproof  notice first term
tax  ai   independent ai report  second term  taken together
agents
p

true utility decision  provides ai net utility ri  x     j  i rj  x   
total utility agents  maximize agent simply report true preference
information  center explicitly solve problem picking x  
example   return example figure    make scp associating agents
a    a  a  relations r     r   r   variables  x    x      x    x      x    x    respectively  breaking ties before  solution scp  a    x    a  x    c  x    b  x   
  utility             agents a    a  a  respectively  removing agent a    solution
would   x      x    a  x    c  x      utility          agents a  a     
indicates agents a  a  indifferent value x    removing agent a    solution
would   x    c  x    b  x      x    c    utility          agents a  a    removing agent a    solution would   x    a  x    c  x    b  x        utility         
agents a  a    vcg mechanism would assign   x    a  x    c  x    b  x      
payments                                                               collected
agents a    a  a  respectively  a  negative impact agents a  a 
incur payment  agents make payments  presence a  helps a  hurts a 
more  presence a  hurts a  a    conflict problem
value assigned variable x    agents a    a  a  prefer x  assigned b  c
respectively  chosen solution  agent a  gets best outcome  considering case
a    force either b selected reporting suitably high utility choice 
x    must pay   x    b must pay    either case weakly prefers
current outcome makes zero payment 
introduced vcg mechanism  important realize vcg mechanism
provides known  general purpose  method exists solve optimization problems
presence self interest private information  positive side  straightforward
extend vcg mechanism  and techniques paper  maximize linear weighted sum
utility agent  weights fixed known  instance social
planner  jackson         roberts        hand  established groves mechanisms vcg mechanism important special case non trivial
strategyproof mechanisms domain social choice unless known structure
agent preferences  e g   everyone prefers earlier meetings  resource always weakly
preferred less  together another technical assumption  roberts theorem extended lavi et al         domains kind structure  instance combinatorial
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

auctions  see real sense possible address self interested
dcops maximizing something total utility participants 
    faithful distributed implementation
goal faithful distributed implementation distribute computation required solve
scp determine payments population agents  retaining
analog strategyproofness  challenging opens additional opportunities
manipulation beyond centralized vcg mechanism 
presenting results  introduce following additional assumptions over and above
made far 
agents rational helpful  meaning although self interested  follow protocol whenever deviation make strictly better  given behavior
agents  
agent prevented posing several independent agents external technique
 perhaps cryptographic  providing strong  perhaps pseudonymous  identities 
catastrophic failure occur agents community variable eventually
choose value variable 
trusted bank  connected trusted communication channel agent 
authority collect payments agent 
property rational helpful required able rely upon agents compute
payments agents make  strong identities required avoid known vulnerabilities
vcg mechanism shown yokoo  sakurai matsubara         wherein agents
sometimes better participating multiple identities  catastrophic failure ensures
decision determined protocol actually executed  prevents hold out problem 
unhappy agent refuses adopt consensus decision  alternative solution would
agents report final decision trusted party  responsible enforcement 
trusted communication channel  mean agent send message bank without
interference agent  messages sent agent upon termination
m dpop  inform bank agents payments  bank assumed work
distributed md  feigenbaum et al               shneidman   parkes        
trusted entity require  purpose ensure payments used align incentives 
provide formal definition distributed implementation need concept local
state  local state agent ai corresponds sequence messages agent
received sent  together initial information available agent  including
relations  public information constraints   given this  distributed implementation 
dm    g       defined terms three components  shneidman   parkes        parkes  
shneidman        
strategy space    defines set feasible strategies available agent ai  
strategy defines message s  agent ai send every possible local state 
suggested protocol     s            sn    defines strategy parameterized
private relations ri agent ai  
   

fip etcu   faltings     parkes

outcome rule  g    g    g     g    n defines assignment values  g     d 
variables x given joint strategy                 n   n   g    n rn defines
payment g  i    r made agent ai given joint strategy n  
defining message s  sent every state  strategy encompasses
computation performed internally agent  information agent reveals private
inputs  e g  relations   decisions agent makes propagate information
received messages agents   suggested protocol si corresponds algorithm 
takes input private information available agent relevant details
agents local state  generates message messages send neighbors network 
applied distributed input r    r            rn   known parts input hard
constraints c  protocol induces particular execution trace algorithm  turn
induces outcome g      s r   g     final assignment values  information
distributed across agents  g     vector payments bank
collect agents   
main question ask  given distributed algorithm corresponding suggested
protocol  whether suggested protocol forms ex post nash equilibrium induced game 
definition    ex post nash equilibrium   given distributed implementation dm    g      
suggested protocol    s            sn   ex post nash equilibrium  epne  if  agents
ai   relations ri   relations agents ri   alternate strategies  
ri  g   si  ri    si  ri     g   si  ri    si  ri    ri  g   i   si  ri     g   i   si  ri   
   
epne  agent ai benefit deviating protocol  si   whatever particular
instance dcop  i e  private relations r    r            rn     long agents
choose follow protocol  latter requirement makes epne weaker dominantstrategy equilibrium  si would best protocol agent even agents
followed arbitrary protocol 
definition    faithfulness  distributed implementation  dm     g       ex post faithful
suggested protocol ex post nash equilibrium 
is  suggested protocol  s  said ex post faithful  or simply faithful 
best interest every agent ai follow aspects algorithm information revelation 
computation message passing whatever private inputs agents  long every
agent follows algorithm 
   idea agent limited set possible messages sent local state implied
notion  restricted  strategy space justified following sense  agents model autonomous
self interested and  course  free send message state  hand  suggested
protocol followed every agent  messages semantically meaningful recipient
agent s  trigger meaningful change local state recipient agent s   i e  change local state
changes future  external  behavior recipient agent  way  strategy space characterizes complete
set interesting behaviors available agent given agents follow suggested protocol 
sufficient  technical perspecitve  define ex post nash equilibrium 
    outcome rule must well defined unilateral deviation s  i e  one agent deviates
follow suggested protocol  either protocol still reaches terminal state decisions payments
defined  protocol reaches bad state suitably negative utility participants  livelock
deadlock  neglect latter possibility rest analysis  easily treated introducing
special notation bad outcome 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

    partition principle applied efficient social choice
one cannot achieve faithful di efficient scp simply running dpop  n     times
problem graph  main problem agents effect nullified turn
asking simply propagate messages  agent ai would seek following   a  interfere
computational process scp  ai    make solution close possible
scp  a   marginal impact appears small   b  otherwise decrease payment 
example increasing apparent utility agents solution scp  a   turn
increases value second term vcg payment  eq     
opportunity manipulation recognized parkes shneidman       
general setting  proposed partition principle method achieving faithfulness distributed vcg mechanisms  instantiated context efficient scps 
definition     partition principle  distributed algorithm  corresponding suggested protocol
s  satisfies partition principle application efficient social choice  if 
    correctness  optimal solution obtained scp  a  scp  ai   every agent
follows s  bank receives messages instruct collect correct vcg payment
every agent 
    robustness  agent ai cannot influence solution scp  ai    report s 
bank receives negative externality ai imposes rest system
conditioned solutions scp  a  scp  ai   
    enforcement  decision corresponds scp  a  enforced  bank collects
payments instructed 
theorem    parkes   shneidman        distributed algorithm efficient social choice
satisfies partition principle ex post faithful distributed implementation 
intuition behind result  note opportunity manipulation agent
ai restricted to   a  influencing solution computed scp  a    b  influencing
payments made agents  agent ai cannot prevent agents correctly solving
scp  ai   correctly reporting negative externality ai imposes agents
presence  long agents follow algorithm  ex post faithfulness follows
strategyproofness vcg mechanism additional opportunity manipulation  available misreporting preferences centralized context 
change  either increase reduce  amount agents payment  opportunity
 b   opportunity  a  new  agent always influence solution context
centralized vcg mechanism misreporting preferences 
remark  suggested previous work  weakening dominant strategy equilibrium centralized vcg mechanism  ex post nash equilibrium distributed implementation  viewed cost decentralization  incentive properties necessarily rely
payments collected rely turn computation performed agents
turn strategy followed agents   
    exception provided izmalkov et al          able avoid use cryptographic
primitives  case best thought physical devices ballot boxes 

   

fip etcu   faltings     parkes

    simple m dpop
algorithm   describes simple m dpop  variation main problem  scp  a  solved 
followed social choice problem  scp  ai   agent removed turn   

n     problems solved  every agent aj knows local part solution x xi
ai    aj   part solution affects utility  provides enough
information allow system agents without agent ai   ai   send message
bank component payment agent ai make 
algorithm    simple m dpop 
  run dpop dcop  a  dfs  a   find x
  forall ai

 
build dfs  ai    run dpop dcop  ai   dfs  ai    find xi
  r  x   report bank 
 
agents aj p
   ai compute tax j  ai     rj  xi
j
 
bank deducts j  i tax j  ai   ai account
 

ai assigns values x solution local copi

computation payments
p disaggregated across agents  tax payment collected
agent ai tax  ai     j  i tax j  ai   

tax j  ai     rj  xi
  rj  x   

    

component payment occurs negative effect agent ai
utility agent aj   information communicated bank agent aj equilibrium 
important observation  able satisfy partition principle  components ai payment satisfy locality property  agent aj compute component ai payment private information relations local information
affect utility  information availabout parts solutions x xi
able upon termination simple m dpop  correctly determining payment  condition
  rely aspect agents algorithm  including
solutions x xi
  
ai  
figure   provides illustration simple m dpop earlier meeting scheduling example 
shows marginal problems  and dfs arrangements problem 
related main problem 
theorem   simple m dpop algorithm faithful distributed implementation efficient social choice terminates outcome vcg mechanism 
p roof  prove establish simple m dpop satisfies partition principle
appeal theorem    first  dpop computes optimal solutions scp  a  scp  ai  
    simple m dpop presented setting main problem subproblems connected extends
immediately disconnected problems  indeed  may main problem connected one
subproblems disconnected  see additional incentive concerns notice sufficient
recognize correctness robustness properties partition principle would retained case 
    similar disaggregation identified feigenbaum et al         lowest cost interdomain routing
internet  shneidman parkes        subsequently modified protocol authors agents
ai enough information report payments made agent ai  

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

figure    simple m dpop  agent ai excluded turn optimization dcop  ai   
illustrated meeting scheduling example 

ai every agent follows protocol  immediate correctness
dcop model scp correctness dpop  correct vcg payments collected
every agent follows algorithm correctness disaggregation vcg payments
eq      second  agent ai cannot influence solution scp  ai   involved
computation way  dfs arrangement constructed  problem solved 
agents  completely ignore ai messages agent ai might send   any hard
constraints ai may handled scp  a  reassigned automatically agent
scp  ai   consequence fact dfs arrangement reconstructed   dpop
still solves scp  ai   correctly case problem graph corresponding scp  ai  
becomes disconnected  in case dfs arrangement forest   robustness value
reports agents    ai negative externality imposed ai   conditioned solutions
scp  a  scp  ai    follows locality property payment terms tax j  ai  
aj    ai   enforcement  bank trusted empowered collect payments  agents
finally set local copies variables x prevent catastrophic failure  agent ai
deviate long agents deviate  moreover  agent ai agent
interested variable value already optimal agent ai anyway   
partition principle  faithfulness  sweeping implications  agent
follow subtantive aspects simple m dpop  agent choose faithfully participate community discovery phase  algorithm choosing root community 
selecting leader agent phase one dpop   
    one observe useful agent misreport local utility another agent aj sending
util messages around system  one hand  deviation could course change selection x

xk
k     i  j  thus payments agents solution ultimately selected  but  deviating

   

fip etcu   faltings     parkes

remark antisocial behavior  note reporting exaggerated taxes hurts agents
increase ones utility excluded assumption agents selfinterested helpful 

   m dpop  reusing computation retaining faithfulness
section  present main result  m dpop algorithm  simple m dpop 
computation solve main problem completely isolated computation solve
marginal problems  comparison  m dpop re use computation already performed
solving main problem solving marginal problems  enables algorithm scale well
problems agents influence limited small part entire problem
little additional computation required beyond dpop  problems agents
influence limited precisely interest induced
tree width small dpop scales 
challenge face  facilitating re use computation  retain incentive
properties provided partition principle  possible new manipulation agent
ai deviate computation dcop  a   intended effect change solution
dcop  ai   via indirect impact computation performed dcop  a 
reused solving dcop  ai    prevent this  determine util messages
dcop  a  could influenced agent ai  
example   refer figure    agent ai controls x  x     way
influencing messages sent subtrees rooted  x     x     x    x    x    x      want
able reuse many util messages possible  solving problem agent
ai removed strive construct dfs arrangement problem dcop  ai  
similar possible dfs main problem  done goal maximizing
re use computation across problems  see figure   b   notice dfs forest 
three distinct connected components  util messages sent shaded nodes
re used solving dcop  ai    util messages sent nodes subtrees
influenced agent ai except  x     x     x    x    different
local dfs arrangement 
m dpop uses safe reusability idea suggested example  see algorithm    first
stage  m dpop solves main problem simple m dpop  complete 
marginal problem dcop  ai   solved parallel  solve dcop  ai    dfs forest  it
forest case dcop  ai   becomes disconnected  constructed modification
dfs  a   retaining much structure dfs  a  possible  new dpop  ai  
execution performed dfs u il messages determined either reusable
reusable sender message based differences dfs dfs  a  
explain dfs constructed 
way agent cannot change utility information finally used determining payments 
agent aj computes marginal effect agent ai local solution  component
tax j  ai   agent ai payment 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

figure    reconstructing dfs  ai   dfs  a  m dpop  result general dfs forest 
bold nodes main dfs initiate dfs propagation  one initiated x  redundant
eventually stopped x    ones x  x   useful  subtrees become
really disconnected removing ai   x   initiate propagation since x 
pseudoparent  x  controlled ai   eventually connect x     notice
x  x  x  x   turned tree edges 

    phase one m dpop marginal problem  constructing dfs
given graph dcop  a  dfs arrangement dfs  a  dcop  a   one removes set
nodes x ai   dcop  a   the ones belong ai    need algorithm constructs
dfs arrangement  dfs   dcop  a    x ai    want achieve following properties 
   dfs must represent correct dfs arrangement graph dcop  ai    a dfs forest
case dcop  ai   becomes disconnected  
   dfs must constructed way non manipulable ai   i e  without allowing
agent ai interfere construction 
   dfs similar possible dfs  a   allows reusing util messages
dpop  a   saves computation communication 
main difficulty stems fact removing nodes represent variables interest agent ai dfs  a  create disconnected subtrees  need reconnect possibly
rearrange  now disconnected  subtrees dfs  a  whenever possible  return example figure    removing agent ai nodes x  x   disrupts tree two ways 
subtrees become completely disconnected rest problem  e g  x   x   x     
ones remain connected via back edges  thus forming invalid dfs arrangement
   

fip etcu   faltings     parkes

algorithm    m dpop  faithfully reuses computation main problem 
  run dpop dcop  a  dfs  a   find x
  forall ai
parallel
 

create dfs algorithm   adjusting dfs  a 

 

run dpop dcop  ai   dfs  
leaves dfs observe changes dfs
send null utili messages

 

 

 
 

else compute utili messages anew  dpop
subsequently  nodes xk df do 
xk receives null utili msgs  pk   pki p pk   p pki ck   cki  
xk sends null utili message
else
node xk computes utili message  reusing 
forall xl n eighbors xk   s t  xl sent utili   null
xk reuses util message xl sent dcop  a 
compute levy taxes simple m dpop 
ai assigns values x solution local copi  

 e g  x  x  x     basic principle use reconnect disconnected parts via back edges
dfs  a  whenever possible  intended preserve much structure possible  example  figure    back edge x  x  turned tree edge  x  becomes
x  child  node x  remains x  child 
dfs reconstruction algorithm presented algorithm    high level overview
follows  in bold state purpose step  
    similarity dfs  a     nodes retain dfs data structures constructing
dfs  a   i e   lists children  pseudo parents children  parents
dfs  a   use data starting point building dfs arrangements 
dfs  ai    marginal problems 
    at least one traversal connected component dfs forest   root
dfs  a  children   removed nodes initiate dfs token passing
dfs  a   except changes 
node xk sends token neighbors owned ai  
order xk sends token neighbors based dfs  a   first xk
children dfs  a   pseudochildren  pseudoparents 
parent  order helps preserve structure dfs  a  dfs  ai   
    children pseudoparents excluded node  instance x   figure    initiate dfs token
passing would redundant  would eventually receive dfs token pseudoparent 

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

algorithm    reconstruction dfs dfs  a  
data structures dfs denoted superscript  

procedure token passing dfs  executed nodes xk
  x ai     
 
 

 
 
 

forall xl neighbors xk   s t  xl belongs ai
remove xl neighbors xk   ck   pc k   pp k   i e  send nothing ai
sort neighbors xk   order  ck   pc k   pp k   pk   mimic dfs  a 
xk root  pk x ai    i e  executed root children ai  
initiate dfs normal dfs  algorithm   
else process incoming tokens  
send dfs  xk   back pki    xk subtree completely explored
procedure process incoming tokens  

 
 
 
 
  
  

wait incoming dfs token  let xl sender
xl ai ignore message
else
first token received


pki   xl   pp
k    xj    pk  xj neighbors xi   dfs  


rootk   first node token dfs

  

else
let xr first node dfs

traversal
xr    rooti
k   i e  another dfs
depth xr dfs  a    depth root
k dfs  a 




reset pk   pp k   ck   pc k   override redundant dfs lower root


pki   xl   pp
k    xj    pk  xj neighbors xi   dfs  

root k   xr

  

continue algorithm  

  
  
  
  
  

    unique traversal connected component dfs forest   node xk retains
root path dfs  a  knows depth dfs arrangement  new token
dfs arrives 
first dfs token arrives  sender  let xl   marked
parent xk dfs   pki   xl   notice xl could different
parent xk dfs  a   xk stores first node received token dfs  
root
k    provisional  root connected component xk belongs
dcop  ai   
first dfs token arrives  two possibilities 
token received part dfs traversal process  xk recognizes
fact first node newly received token
previously stored root
k   case  xk proceeds normal  algorithm   
marks sender pseudochild  etc 
   

fip etcu   faltings     parkes

token received part another dfs traversal process  initiated another
node root
k  see text could happen   let xr first
node newly received token  xk recognizes situation fact xr

previously stored rooti
traversal
k   case  dfs
initiated higher node dfs  a  prevails  one dropped 
determine traversal pursue one drop  xk compares depths

rooti
k xr dfs  a   xr higher  becomes new rootk   xk
overrides previous dfs information one new token 
continues token passing new token algorithm   
see necessary start propagations children removed nodes  step
    consider example figure    removing x   x  completely disconnects
subtree  x    x    x     x    x     x      x  started propagation  subtree would
visited since connections rest problem
nodes subtree      
lemma    dfs correctness  algorithm   constructs correct dfs arrangement  or forest  
dfs dcop  ai   given correct dfs arrangement dfs  a  dcop  a  
p roof  first  since dfs started child node controlled ai  
root  ensured connected component dfs traversed least  follows
step     second  dfs process similar normal dfs construction  node
sends token neighbors  except ones controlled ai   
pre specified order  the one given dfs  a    follows nodes connected component
eventually visited  follows step     third  higher priority dfs traversals override
lower priority ones  i e  dfs traversals initiated nodes higher tree priority  
step    eventually one single dfs traversal performed single connected component   
lemma    dfs robustness  dfs arrangement  dfs   constructed algorithm   nonmanipulable agent ai   input dfs arrangement solution phase dcop  a  
p roof  follows directly step    since ai participate process all 
neighbors send messages  see algorithm    line     messages may send
simply ignored  see algorithm    line     
fact  additional links created constructing dfs   possible changes
edges reverse direction  parents children pseudoparents pseudochildren
    dfs traversals initiated step   redundant part problem graph visited
once  simple overriding rule step   ensures single dfs tree eventually adopted
connected component  namely one initiated highest node original dfs  a  
example  figure    x  starts unnecessary dfs propagation  eventually stopped x   
receives higher priority dfs token x    since x  knows x  higher dfs  a  x    drops
propagation initiated x    relays one initiated x    sending x  token
dfs received x  adds itself  upon receiving new token x    node x  realizes
x  new parent dfs   thus  redundant propagation initiated x  eliminated result
consistent dfs subtree single connected component p   
    simple time out mechanism used ensure agent knows provisional dfs ordering final
 i e  higher priority dfs traversals arrive future  

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

switch places   existing back edges turn tree edges  again  one see
figure     
    phase two m dpop marginal problem  utili propagations
dfs built  marginal problem without ai solved dfs   utility propagation proceeds normal dpop except nodes determine whether util message
sent dpop  a  reused  signaled parent sending special null util
message  specifically  process follows 
leaves dfs initiate utili propagations 
   leaves dfs observe changes local dfs arrangement compared dfs  a  util message sent dcop  a  remains valid
announce parents sending instead null utili message 
   otherwise  leaf node computes util message anew sends  new 
parent dfs  
nodes wait incoming utili messages and 
   every incoming messages node xk receives children null
changes parent pseudoparents propagate null utili message
parent 
   otherwise  xk recompute utili message  reusing util
messages received dcop  a  children sent null messages
dcop  ai   joining new util messages received 
example  consider dcop  ai   figure    x   x   children x     x  
recompute util message send new parent x    this  reuse
messages sent x   x   dcop  a   neither sending subtrees contain ai  
  
so  x   reuses effort spent dcop  a  compute messages util  
     util    
  
util  
   util    
theorem   m dpop algorithm faithful distributed implementation efficient social
choice terminates outcome vcg mechanism 
p roof  partition principle appeal theorem    and turn theorem     first 
agent ai cannot prevent construction valid dfs dcop  ai    lemmas      
second  agent ai cannot influence execution dpop dcop  ai   messages
ai influenced main problem dcop  a  recomputed system without ai  
rest proof follows simple m dpop  leveraging locality tax payment messages
enforcement provided bank via catastrophic failure assumption   
    simple alternative children nodes xki belong ai   create bypass link first ancestor
xki belong ai   example  figure    x  x  could create link x  bypass x 
completely dfs  ai    however  additional communication links may required approach 

   

fip etcu   faltings     parkes

   experimental evaluation  understanding effectiveness m dpop
present results experimental evaluation dpop  simple m dpop m dpop
two different domains  distributed meeting scheduling problems  ms   combinatorial auctions
 cas   first set experiments investigate performance m dpop structured
constraint optimization problem  ms  received lot attention cooperative distributed
constraint optimization  second set experiments  cas   investigate unstructured domains  observe performance specifically ability re use computation computing
payments m dpop respect problem density  cas provide abstract model many
real world allocation problems much studied mechanism design  cramton  shoham   
steinberg        
    distributed meeting scheduling
distributed meeting scheduling  consider set agents working large organization
representing individuals  groups individuals  engaged scheduling meetings
upcoming period time  although agents self interested  organization
whole requires optimal overall schedule  minimizes cost  alternatively  maximizes
utility agents   makes necessary use faithful distributed implementation
m dpop  enabling this  suppose organization distributes virtual currency
agent  perhaps using currency allocation prioritize particular participants   relations held
agents defining agents utility solution scheduling problem thus stated
units currency 
agent ai set local replicate variables xji meeting mj
involved  domain variable xj  and thus local replicas xji   represents feasible
time slots meeting  equality constraint included replica variables ensure
meeting times aligned across agents  since agent cannot participate one
meeting all different constraint variables xij belonging agent 
modeled clique constraint meeting variables  agent assigns utility
possible time meeting imposing unary relation variable xji  
relation private ai   denotes much utility ai associates starting meeting mj
time dj   dj domain meeting mj   social objective find schedule
total utility maximized satisfying all different constraints agent 
following maheswaran et al          model organization providing hierarchical
structure  realistic organization  majority interactions within departments 
small number across departments even interactions typically take place
two departments adjacent hierarchy  hierarchical organization provides structure
test instances  high probability  around      generate meetings within departments 
lower probability  around      generate meetings agents belonging
parent child departments  generated random problems structure  increasing
number agents         agents  agent participates     meetings 
uniform random utility      possible schedule meeting
participates  problems generated feasible solutions   
    test instances found http   liawww epfl ch people apetcu research mdpop msexperiments tgz

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

problem size  averaged results     different instances  solved main
problems using dpop marginal ones using simple m dpop  m dpop respectively 
experiments performed frodo multiagent simulation environment  petcu        
   ghz  gb ram laptop  frodo simulated multiagent system  agent executes
asynchronously thread  communicates peers via message exchange 
experiments geared towards showing much effort m dpop able reuse
main marginal problems  figure     shows absolute computational effort terms
number messages  figure     a    terms total size messages exchanged 
bytes  figure     b    curves dpop represent number messages  total size
messages  respectively  required solving cooperative problem  curves simplem dpop m dpop represent total number  size  respectively  util messages 
main marginal economies 
notice several interesting facts  first  number messages required dpop increases
linearly number agents dpops complexity terms number messages
always linear size problem  hand  number messages simple mdpop increases roughly quadratically number agents  since solves linear number
marginal economies scratch using dpop  requiring linear number messages 
performance m dpop lies somewhere dpop simple m dpop
advantage achieved simple m dpop size problem increases  culminating
almost order magnitude improvement simple m dpop largest problem sizes  i e 
    agents problem   similar observations made total size util
messages  good measure computation  traffic memory requirements  inspecting
figure     b   metrics find performance m dpop slightly superlinear size problem 
figure   shows percentage additional effort required solving marginal problems
reused main problem  i e  probability util message required solving marginal problem taken directly message already used main problem 
clearly see problem size increases actually reuse computation
main problem  intuition behind large problems  individual agent
localized particular area problem  translates agent localized
specific branch tree  thus rendering computation performed branches reusable
marginal problem corresponds respective agent  looking percentage
reuse defined terms message size rather number messages see
trending upwards size problem increases 
    combinatorial auctions
combinatorial auctions  cas  popular means allocate resources multiple agents  cas 
bidders bid bundles goods  as opposed bidding single goods   combinatorial bids
model complementarity substitutability among goods  i e  valuation
bundle more  respectively less sum valuations individual items 
setting agents distributed  geographically logically   form problem graph
neighbors agents bids overlap  objective find feasible solution  i e 
declare bids winning losing two winning bids share good  maximizes
total utility agents 
   

fip etcu   faltings     parkes

      

 e   

     
  messages

dpop
simple m dpop
m dpop

total size util messages

dpop
simple m dpop
m dpop

    

   

 e   

      

     

  

    
  

  

  

  

  

  

  

  

      

  

  

number agents

  

  

  

  

  

  

      

number agents

 a  number messages

 b  total size util messages  in valuations 

figure    meeting scheduling problem  measures absolute computational effort  in terms number

  effort marginals reused main

messages sent total size util messages  dpop  simple m dpop mdpop  curves dpop represent effort spent main problem  ones
simple m dpop m dpop represent total effort main marginal problems 

  
  
  
  
  
  
  
  

total information
number messages

  
  

  

  

  

  

  

  

  

  

   

number agents

figure    meeting scheduling problem  percentage effort required marginal problems
reused m dpop main problem  reuse measured terms percentage
util messages reused  dashed  terms total size util
messages reused fraction total util message size  solid  

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

cas adopted stylized model distributed allocation problems airport slot
allocation wireless spectrum allocation discussed introduction  ca instances
provide counterpoint meeting scheduling problems represent problems
less structure  dcop model  agent holds variable one bids  two
possible values    bid rejected    bid accepted  pair overlapping
bids  bids share least one good  connected one constraint specifies
cannot accepted  multiple bids submitted agent
connected additional constraints capture bid logic  instance exclusive or constraints
one bid accepted 
generated random problems using cats  leyton brown  pearson    shoham         using
l  distribution sandholm         l  constant distribution agent
demands bundle   goods  selected uniformly random  value distributed uniformly
        simulations consider market    goods vary number agents
      recorded performance dpop  simple mdpop m dpop
graphs figures       figure   shows density problems increase  three
algorithms require effort solving  both terms number messages  terms
total information exchange  
figure    shows reusability varies problem density  one see loose problems reusability good  close      problems   agents  density
problems increases number agents  reusability decreases well  around    
dense problems     agents  explain phenomenon follows  loose
problems  many goods bidders   bids mostly non overlapping  turn ensures
removing individual agents solving marginal problems affect computation
performed solving main problem  end spectrum  dense problems
tend highly connected  produces dfs trees similar chains 
case  removing agents close bottom chain invalidates much computation performed solving main problem  therefore  limited amount computation
reused 
noting l  recognized one hardest problem distributions cats
suite  leyton brown et al          remark need limit experiments distribution problems large induced tree width  and high density problem graphs  
consider example problem every agent bids bundle overlaps every
agent  problem graph clique dpop scale  leave detailed
examination future work  recent extension dpop h dpop  kumar  petcu    faltings 
      immediately address issue  h dpop  consistency techniques used order
compactly represent util messages  tightly constrained problems  orders magnitude
improvements dpop reported  see section      

   discussion
section discuss alternatives improving computational performance m dpop 
possibility faithful variations dcop algorithms  adopt  modi et al        
optapo  mailler   lesser          loss utility agents occur due
transfer payments bank  mentioning approach address problem 
   

fip etcu   faltings     parkes

     

 e   
total size util messages

dpop
simple m dpop
m dpop
  messages

    

   

  

dpop
simple m dpop
m dpop

 e   
 e   
      
     
    
   
  

 

 
 

  

  
  
  
  
number agents

  

  

 

 a  number messages

  

  
  
  
  
number agents

  

  

 b  total size util messages  in valuations 

figure    combinatorial auctions problems  measures absolute computational effort  in terms

  effort marginals reused main

number messages sent total size util messages  dpop  simple m dpop
m dpop  curves dpop represent effort spent main problem  ones
simple m dpop m dpop represent effort main marginal problems 
higher number agents  and thus bids  thus constraints problem graph
problem density   greater computational effort solve problem 

   
  
  
  
  
  
  
  
total information
number messages

  
  
 

  

  

  

  

  

  

  

number agents

figure     combinatorial auctions problems  percentage effort required marginal problems
reused m dpop main problem  reuse measured terms percentage
util messages reused  dashed  terms total size util
messages reused fraction total util message size  solid  

   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

    algorithmic alternatives improved performance
m dpop scales well problem size long induced width problem remains
low  characteristic m dpop inherits dpop  based  problems
high induced width  dpop m dpop require producing  sending storing large messages 
may unfeasible undesirable  mitigate problem  several advances basic
dpop algorithm recently proposed  new algorithms sacrifice optimality
return computational tractability  makes difficult combine vcg payment
mechanism way faithfulness guaranteed  nevertheless  h dpop  kumar et al  
      mb dpop  petcu   faltings        employ two different techniques preserve
optimality guarantees  fitted m dpop 
h dpop leverages observation many real problems contain hard constraints significantly reduce space feasible assignments  example  auctions  possible
allocate item one bidder  meeting scheduling  possible set two different start times given meeting  unfortunately  dpop take advantage pruning
power hard constraints  sends messages explicitly represent value combinations  including many infeasible ones  h dpop addresses issue using constraint decision
diagrams  cdd  introduced cheng yap        compactly represent util messages
excluding unfeasible combinations  performance improvements several orders magnitude
achieved  especially highly constrained problems  kumar et al         
mb dpop  petcu   faltings        uses idea cycle cutsets  dechter        explore
parts search space sequentially  dense parts problem explored iterating
assignments subset nodes designated cycle cuts  assignment performing
limited util propagation similar one dpop  easy parts problem explored
one shot util messages  exactly dpop  mb dpop offers thus configurable tradeoff
number messages exchanged  size messages memory
requirements 
    achieving faithfulness dcop algorithms
partition principle  described section      algorithm independent  question
whether another  optimal dcop algorithm made faithful therefore revolves  critically  around
whether algorithm satisfy robustness requirement partition priciple  make
following observations 
robustness first sense  i e  agent ai influence solution efficient scp without agent ai   always achievable cost restarting computation
marginal problem agent removed turn  proposed simple m dpop 
robustness second sense  i e  agent ai influence report s  bank
receives negative externality ai imposes rest system  conditioning
solutions main problem problem without ai   requires dcop
algorithm terminates every agent knowing part solution relevant
defining utility  robustness property follows disaggregation payments 
thus  one content restart dcop algorithm multiple times  kinds
results provide simple m dpop generally available  possible
   

fip etcu   faltings     parkes

already mentioned locality property payments  follows disaggregation
vcg payment across agents eq       information communication
structure dcop 
useful property dcop context self interested agents  worth reemphasizing  possible retain faithfulness even one agent plays pivotal role
connecting problem graph  suppose problem  dcop  ai    becomes disconnected without ai   but  case optimal solution represented union optimal
solutions connected subcomponent problem  information needs flow disconnected components either purpose solving problem purpose
reporting components agent ai tax 
discuss following two sections adaptation two prominent complete dcop algorithms  adopt  modi et al         optapo  mailler   lesser        
discuss following two sections adaptation two prominent complete dcop algorithms  adopt  modi et al         optapo  mailler   lesser        
consider computational aspects making algorithms faithful  specifically issues related efficient handling replica variables providing reusability main
marginal problems 
      u sing adopt



faithful   e fficient ocial c hoice

adopt polynomial space search algorithm dcop guaranteed find globally
optimal solution allowing agents execute asynchronously parallel  agents
adopt make local decisions based conservative cost estimates  adopt works dfs
arrangement  constructed detailed section        roughly speaking  main process
executed adopt backtrack search dfs tree 
adaptation adopt dcop model replicated variables  adopts complexity
given number messages  exponential height dfs tree  similar
dpop  using dcop model replicated variables could artificially increase complexity
solving process  specifically  height dfs tree increased using replicated
variables compared centralized problem graph  adopt modified exploit special
structure replicated local variables similar way dpop  specifically  adopt
explore sequentially values original variable  ignore assignments replicas
variable take different values  works allowing agent owns
highest replica variable freely choose values variable  agent announces
new value variable agents owning replicas variable  agents
would consider announced value replicas  add corresponding utilities  continue search process  using special handling replica variables 
resulting complexity longer exponential height distributed dfs tree 
height dfs tree obtained traversing original problem graph  example  figure    sufficient explore values m     directly assign values m   m  
via value messages  without trying combinations values  reduces adopts
complexity exponential    exponential   
reusability computation adopt  turning re use computation main
marginal problems  note adopt uses dfs arrangement easy
identify parts dfs arrangement main problem impossible agent
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

manipulate  therefore reused computing solution marginal problem
agent removed  however  major difference dpop adopt dpop 
agent stores outgoing util message  thus available utilities contingent
assignments variables agents separator  makes possible agent
simply reuse information marginal economies structure dfs proves
safe  contrast  adopt store information linear memory
policy  turn makes impossible reuse computation main problem marginal
problems  marginal problems solved scratch  thus performance would
scale poorly problem size increases even structured problems meeting scheduling 
see two alternatives addressing problem   a  renounce linear memory guarantees 
use caching scheme example ncbb  chechetka   sycara         would allow
similar reusability m dpop  previously computated utilities extracted
cache instead recomputed  alternatively   b  one devise scheme
previously computed best solution saved reference  subsequently used
approximation solving marginal problems  could possibly provide better bounds
thus allow better pruning  computation could saved  alternatives
outside scope paper  considered future work 
      u sing ptapo



faithful   e fficient ocial c hoice

optapo  mailler   lesser        popular algorithm dcop  similar
adaptations dpop adopt social choice  optapo made take advantage
special features dcop model replicated variables  complexity would
artificially increased use dcop model  optapo particularity uses
mediator agents centralize subproblems solve dynamic asynchronous mediation sessions  i e  partial centralization  mediator agents announce results
agents  previously sent subproblems mediators  process alone would
introduce additional possibility manipulation setting self interested agents  however 
using vcg mechanism addresses concern agents choose behave correctly according protocol 
adopt  main issue using optapo faithful social choice reusability
computation main marginal problems  specifically  consider solving
main problem  mediator agent ai centralized aggregated preferences number
agents  solving mediation problems dictated optapo protocol  subsequently 
trying compute solution marginal problem without agent ai   computation
go waste  could manipulated ai solving main problem  furthermore  since optapos centralization process asynchronous conflict driven opposed
structure driven m dpop  unclear whether computation main problem
could safely reused marginal problems  make matters worse  experimental studies  davin   modi        petcu   faltings        show many situations  optapo ends
relying single agent system centralize solve whole problem  implies
solving marginal problem without agent  one reuse zero effort main
problem 
   

fip etcu   faltings     parkes

    loss utility due wasting vcg taxes
vcg mechanism  agents net utility difference utility derives
optimal solution vcg tax pay  net utility whole group agents
sum individual net utilities agents  i e  total utility assignment values
variables net total payment made agents bank  loss utility
using m dpop great     total utility optimal solution meeting
scheduling domain  problem size increases  money burnt
form vcg taxes  similar waste observed others  e g   faltings        
context efficient social choice 
one cannot naively redistribute payment back agents  instance sharing payments equally across agents would break faithfulness  example  agent ai would prefer
agents make greater payments  order receive larger repayment bank 
faithfulness properties m dpop would unravel  hand  problem
inherent structure possible redistribute fraction payments back agents 
idea careful redistribution suggested bailey         subsequently extended
cavallo         guo conitzer        moulin         another approach  advocated example faltings         simply preclude agent problem transfer payments
agent  work centralized context 
important issue future work  then  study budget surplus accrues bank
m dpop seek mitigate welfare loss setting distributed implementation 
defer discussion topic future work  investigate methods
leverage structure problem redistributing majority payments back agents
without compromising either efficiency faithfulness 

   conclusions
developed m dpop  faithful  distributed algorithm solve efficient
social choice problems multi agent systems private information self interest  agent
improve utility either misreporting local information deviating aspect
algorithm  e g   computation  message passing  information revelation   centralized
component bank able receive messages payments collect payments 
addition promoting efficient decisions  minimize amount additional computational
effort required computing vcg payments reusing effort main problem  first
set experimental results shows significant amount computation required
marginal problems reused main problem  sometimes      provides
near linear scalability massive  distributed social choice problems local structure
maximal induced tree width small  second set experiments performed problems
without local structure shows problem density increases  amount effort required increases  reusability computation decreases  results suggest m dpop
good candidate solving loose problems exhibit local structure induced width
remains small  addition addressing need reduce total payments made agents
bank  one issue future work relates need provide robustness faced adversarial
faulty agents  current solution fragile sense  equilibrium properties relying
agents following protocol  papers  lysyanskaya   triandopoulos        aiyer 
alvisi  clement  dahlin  martin    porth        shneidman   parkes        provide robustness
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

mixture models  e g  rational  adversarial  aware work
mixture models context efficient social choice  another interesting direction find ways
allow approximate social choice  example memory limited dpop variations  petcu
  faltings      a  retaining incentive properties  perhaps approximate equilibria  future
research consider design distributed protocols robust false name
manipulations agents participate multiple pseudonyms  yokoo et al         
seek mitigate opportunities collusive behavior possibility multiple equilibria exist incentive mechanisms  ausubel   milgrom        andelman  feldman   
mansour        katz   gordon        

acknowledgments
parkes supported part national science foundation grants iis          iis        
alfred p  sloan foundation award  petcu supported swiss national science foundation
grant                  authors would thank wei xue valuable feedback several
parts paper  thank jeffrey shneidman feedback early version paper 
thank aaron bernstein valuable insights dfs reconstruction process  three
anonymous reviewers provided excellent suggestions improving exposition work 
earlier version paper appeared proc  fifth international joint conference
autonomous agents multiagent systems  aamas        

references
abu amara  h  h          fault tolerant distributed algorithm election complete networks  ieee
trans  comput                 
aiyer  a  s   alvisi  l   clement  a   dahlin  m   martin  j  p     porth  c          bar fault tolerance
cooperative services    th acm symposium operating systems principles 
andelman  n   feldman  m     mansour  y          strong price anarchy  acm siam symposium
discrete algorithms       soda    
arnborg  s          efficient algorithms combinatorial problems graphs bounded decomposability
  survey  bit             
ausubel  l   cramton  p     milgrom  p          clock proxy auction  practical combinatorial auction
design  cramton et al   cramton et al          chap    
ausubel  l     milgrom  p          lovely lonely vickrey auction  cramton et al   cramton et al  
       chap    
bailey  m  j          demand revealing process  distribute surplus  publicchoice         
ball  m   donohue  g     hoffman  k          auctions safe  efficient  equitable allocation
airspace system resources  cramton  shoham  s   ed    combinatorial auctions  mit press 
barbosa  v          introduction distributed algorithms  mit press 
bayardo  r     miranker  d          space time trade off solving constraint satisfaction problems   proceedings   th international joint conference artificial intelligence  ijcai    
montreal  canada 
bidyuk  b     dechter  r          finding minimal w cutset  auai     proceedings   th
conference uncertainty artificial intelligence  pp        arlington  virginia  united states 
auai press 
   

fip etcu   faltings     parkes

bikhchandani  s   de vries  s   schummer  j     vohra  r  v          linear programming vickrey
auctions  dietrich  b     vohra  r   eds    mathematics internet  e auction markets  pp 
       ima volumes mathematics applications  springer verlag 
cavallo  r          optimal decision making minimal waste  strategyproof redistribution vcg payments  proc   th int  joint conf  autonomous agents multi agent systems  aamas    
chechetka  a     sycara  k          any space algorithm distributed constraint optimization 
proceedings aaai spring symposium distributed plan schedule management 
cheng  k  c  k     yap  r  h  c          constrained decision diagrams   proceedings national
conference artificial intelligence  aaai     pp          pittsburgh  usa 
cheung  t  y          graph traversal techniques maximum flow problem distributed computation  
ieee trans  software eng                
cidon  i          yet another distributed depth first search algorithm  inf  process  letters                
collin  z   dechter  r     katz  s          feasibility distributed constraint satisfaction 
proceedings   th international joint conference artificial intelligence  ijcai     pp     
     sidney  australia 
collin  z   dechter  r     katz  s          self stabilizing distributed constraint satisfaction  chicago journal
theoretical computer science 
collin  z     dolev  s          self stabilizing depth first search  information processing letters        
       
cramton  p   shoham  y     steinberg  r   eds            combinatorial auctions  mit press 
davin  j     modi  p  j          impact problem centralization distributed constraint optimization
algorithms  aamas     proceedings fourth international joint conference autonomous
agents multiagent systems  pp            new york  ny  usa  acm press 
davis  r     smith  r  g          negotiation metaphor distributed problem solving  artificial
intelligence        
de vries  s     vohra  r  v          combinatorial auctions  survey  informs journal computing        
       
dechter  r          constraint processing  morgan kaufmann 
dechter  r     mateescu  r          and or search spaces graphical models  artificial intelligence 
appear 
dunne  p  e          extremal behaviour multiagent contract negotiation  journal artificial intelligence
research  jair            
dunne  p  e   wooldridge  m     laurence  m          complexity contract negotiation  artificial
intelligence journal                 
endriss  u   maudet  n   sadri  f     toni  f          negotiating socially optimal allocations resources 
journal artificial intelligence research             
ephrati  e     rosenschein  j          clarke tax consensus mechanism among automated agents 
proceedings national conference artificial intelligence  aaai     pp          anaheim 
ca 
faltings  b          budget balanced  incentive compatible scheme social choice  workshop
agent mediated e commerce  amec  vi  springer lecture notes computer science 
faltings  b   parkes  d   petcu  a     shneidman  j          optimizing streaming applications selfinterested users using m dpop  comsoc    international workshop computational social
choice  pp          amsterdam  netherlands 
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

feigenbaum  j   papadimitriou  c   sami  r     shenker  s          bgp based mechanism lowest cost
routing  proceedings      acm symposium principles distributed computing  pp 
       
feigenbaum  j   ramachandran  v     schapira  m          incentive compatible interdomain routing 
proceedings  th conference electronic commerce  pp         
feigenbaum  j     shenker  s          distributed algorithmic mechanism design  recent results
future directions  proceedings  th international workshop discrete algorithms
methods mobile computing communications  pp      
freuder  e  c     quinn  m  j          taking advantage stable sets variables constraint satisfaction
problems  proceedings  th international joint conference artificial intelligence  ijcai    pp            los angeles  ca 
gershman  a   meisels  a     zivan  r          asynchronous forward bounding distributed constraints
optimization  proceedings   th european conference artificial intelligence  ecai     
riva del garda  italy 
greenstadt  r   pearce  j  p     tambe  m          analysis privacy loss distributed constraint optimization  proc  twenty first national conference artificial intelligence  aaai     
guo  m     conitzer  v          worst case optimal redistribution vcg payments  proceedings
 th acm conference electronic commerce  ec      pp       
huebsch  r   hellerstein  j  m   lanham  n   et al          querying internet pier  vldb 
izmalkov  s   micali  s     lepinski  m          rational secure computation ideal mechanism design 
focs     proceedings   th annual ieee symposium foundations computer science 
pp          washington  dc  usa  ieee computer society 
jackson  m  o          mechanism theory  encyclopedia life support systems  eolss publishers 
jackson  m  o          crash course implementation theory  social choice welfare                
katz  j     gordon  s  d          rational secret sharing  revisited  proc  security cryptography
networks 
kloks  t          treewidth  computations approximations  vol      lecture notes computer
science  springer 
krishna  v          auction theory  academic press 
kumar  a   petcu  a     faltings  b          h dpop  using hard constraints prune search space 
ijcai     distributed constraint reasoning workshop  dcr    pp        hyderabad  india 
lavi  r   mualem  a     nisan  n          towards characterization truthful combinatorial auctions 
proc    th annual symposium foundations computer science 
leyton brown  k   pearson  m     shoham  y          towards universal test suite combinatorial
auction algorithms  proceedings acm conference electronic commerce  ec     pp     
    
leyton brown  k     shoham  y          test suite combinatorial auctions  cramton  p   shoham 
y     steinberg  r   eds    combinatorial auctions  chap      mit press 
lysyanskaya  a     triandopoulos  n          rationality adversarial behavior multi party computation    th annual int  cryptology conference  crypto    
maheswaran  r  t   tambe  m   bowring  e   pearce  j  p     varakantham  p          taking dcop
real world  efficient complete solutions distributed multi event scheduling  aamas    
mailler  r     lesser  v          solving distributed constraint optimization problems using cooperative mediation  proceedings third international joint conference autonomous agents multiagent
systems  aamas                  
   

fip etcu   faltings     parkes

mailler  r     lesser  v          asynchronous partial overlay  new algorithm solving distributed
constraint satisfaction problems  journal artificial intelligence research  jair  
mas colell  a   whinston  m  d     green  j  r          microeconomic theory  oxford university press 
mishra  d     parkes  d          ascending price vickrey auctions general valuations  journal
economic theory              
modi  p  j   shen  w  m   tambe  m     yokoo  m          adopt  asynchronous distributed constraint
optimization quality guarantees  ai journal              
monderer  d     tennenholtz  m          distributed games  mechanisms protocols  proc    th
national conference artificial intelligence  aaai      pp       
moulin  h          efficient  strategy proof almost budget balanced assignment  tech  rep   rice university 
mualem  a          decentralized incentive compatible mechanisms partially informed environments 
proc  acm conf  electronic commerce  ec  
ostrovsky  r   rajagopalan  s     vazirani  u          simple efficient leader election full information model  stoc     proceedings twenty sixth annual acm symposium theory
computing  pp          new york  ny  usa  acm press 
parkes  d  c   kalagnanam  j  r     eso  m          achieving budget balance vickrey based payment
schemes exchanges  proc    th international joint conference artificial intelligence  ijcai     pp           
parkes  d  c     shneidman  j          distributed implementations vickrey clarke groves mechanisms 
proc   rd int  joint conf  autonomous agents multi agent systems  pp         
parkes  d  c     ungar  l  h          iterative combinatorial auctions  theory practice  proc    th
national conference artificial intelligence  aaai      pp       
petcu  a          frodo  framework open distributed constraint optimization  technical
report no            swiss federal institute technology  epfl   lausanne  switzerland  http 
  liawww epfl ch frodo  
petcu  a     faltings  b       a   a dpop  approximations distributed optimization  proceedings
eleventh international conference principles practice constraint programming
 cp     pp          sitges  spain 
petcu  a     faltings  b       b   dpop  scalable method multiagent constraint optimization 
proceedings   th international joint conference artificial intelligence  ijcai     pp     
     edinburgh  scotland 
petcu  a     faltings  b          pc dpop  partial centralization extension dpop  proceedings
second international workshop distributed constraint satisfaction problems  ecai    riva
del garda  italy 
petcu  a     faltings  b          mb dpop  new memory bounded algorithm distributed optimization  proceedings   th international joint conference artificial intelligence  ijcai    
hyderabad  india 
pietzuch  p   ledlie  j   shneidman  j   roussopoulos  m   welsh  m     seltzer  m          network aware
operator placement stream processing systems  icde 
rassenti  s  j   smith  v  l     bulfin  r  l          combinatorial mechanism airport time slot allocation  bell journal economics             
roberts  k          characterization implementable rules  laffont  j  j   ed    aggregation
revelation preferences  pp          north holland  amsterdam 
rosenschein  j  s     zlotkin  g          designing conventions automated negotiation  ai magazine 
fall 
   

fim dpop  faithful istributed mplementation e fficient ocial c hoice p roblems

sandholm  t          algorithm optimal winner determination combinatorial auctions  artificial
intelligence           
sandholm  t  w          implementation contract net protocol based marginal cost calculations  proc    th national conference artificial intelligence  aaai      pp         
sandholm  t  w          limitations vickrey auction computational multiagent systems  second
international conference multiagent systems  icmas      pp         
shneidman  j     parkes  d  c          rationality self interest peer peer networks   nd int 
workshop peer to peer systems  iptps    
shneidman  j     parkes  d  c          specification faithfulness networks rational nodes  proc 
  rd acm symp  principles distributed computing  podc     st  johns  canada 
silaghi  m  c   sam haroud  d     faltings  b          asynchronous search aggregations 
aaai iaai  pp          austin  texas 
solotorevsky  g   gudes  e     meisels  a          modeling solving distributed constraint satisfaction
problems  dcsps   proceedings second international conference principles practice
constraint programming  cp     pp          cambridge  massachusetts  usa 
sycara  k   roth  s  f   sadeh koniecpol  n     fox  m  s          distributed constrained heuristic search 
ieee transactions systems  man  cybernetics                  
wellman  m  p          market oriented programming environment application distributed multicommodity flow problems  journal artificial intelligence research         
wellman  m  p          market oriented programming  early lessons  clearwater  s  h   ed   
market based control  paradigm distributed resource allocation  chap     pp        world
scientific 
yokoo  m   durfee  e  h   ishida  t     kuwabara  k          distributed constraint satisfaction formalizing distributed problem solving  international conference distributed computing systems  pp 
       
yokoo  m     hirayama  k          algorithms distributed constraint satisfaction  review  autonomous
agents multi agent systems               
yokoo  m   sakurai  y     matsubara  s          effect false name bids combinatorial auctions 
new fraud internet auctions  games economic behavior                
zhang  w     wittenburg  l          distributed breakout algorithm distributed constraint optimization
problems   dbarelax  proceedings international joint conference autonomous agents
multi agent systems  aamas      melbourne  australia 
zlotkin  g     rosenschein  j  s          mechanisms automated negotiation state oriented domains 
journal artificial intelligence research            

   


