journal artificial intelligence research                  

submitted        published      

engineering note
flucap  heuristic search planner first order mdps
steffen holldobler
eldar karabaev
olga skvortsova

sh iccl tu dresden de
eldar iccl tu dresden de
skvortsova iccl tu dresden de

international center computational logic
technische universitat dresden  dresden  germany

abstract
present heuristic search algorithm solving first order markov decision processes  fomdps   approach combines first order state abstraction avoids evaluating states individually  heuristic search avoids evaluating states  firstly 
contrast existing systems  start propositionalizing fomdp
perform state abstraction propositionalized version apply state abstraction directly fomdp avoiding propositionalization  kind abstraction referred
first order state abstraction  secondly  guided admissible heuristic  search
restricted states reachable initial state  demonstrate usefulness techniques solving fomdps system  referred flucap
 formerly  fcplanner   entered probabilistic track      international planning competition  ipc      demonstrated advantage planners
problems represented first order terms 

   introduction
markov decision processes  mdps  adopted representational computational model decision theoretic planning problems much recent work  e g   barto 
bradtke  singh         basic solution techniques mdps rely dynamic
programming  dp  principle  boutilier  dean    hanks         unfortunately  classical dynamic programming algorithms require explicit enumeration state space grows
exponentially number variables relevant planning domain  therefore 
algorithms scale complex ai planning problems 
however  several methods avoid explicit state enumeration developed
recently  one technique  referred state abstraction  exploits structure factored mdp representation solve problems efficiently  circumventing explicit state space
enumeration  boutilier et al          another technique  referred heuristic search 
restricts computation states reachable initial state  e g   rtdp
barto et al          envelope dp dean  kaelbling  kirman  nicholson       
lao feng hansen         one existing approach combines techniques symbolic lao algorithm feng hansen        performs heuristic
search symbolically factored mdps  exploits state abstraction  i e   manipulates sets
states instead individual states  precisely  following spudd approach hoey 
st aubin  hu  boutilier         mdp components  value functions  policies 
admissible heuristic functions compactly represented using algebraic decision diagrams
c
    
ai access foundation  rights reserved 

fiholldobler  karabaev   skvortsova

 adds   allows computations lao algorithm performed efficiently using
adds 
following ideas symbolic lao   given initial state  use admissible heuristic
restrict search states reachable initial state  moreover 
exploit state abstraction order avoid evaluating states individually  thus 
work much spirit symbolic lao extends important way 
whereas symbolic lao algorithm starts propositionalization fomdp 
performs state abstraction propositionalized version means
propositional adds  apply state abstraction directly structure fomdp 
avoiding propositionalization  kind abstraction referred first order state
abstraction 
recently  following work boutilier  reiter  price         holldobler skvortsova
       developed algorithm  referred first order value iteration  fovi 
exploits first order state abstraction  dynamics mdp specified probabilistic fluent calculus established holldobler schneeberger        
first order language reasoning states actions  precisely  fovi produces
logical representation value functions policies constructing first order formulae
partition state space clusters  referred abstract states  effect 
algorithm performs value iteration top clusters  obviating need explicit
state enumeration  allows problems represented first order terms
solved without requiring explicit state enumeration propositionalization 
indeed  propositionalizing fomdps impractical  number propositions grows considerably number domain objects relations 
dramatic impact complexity algorithms depends directly number propositions  finally  systems solving fomdps rely propositionalizing
states propositionalize actions problematic first order domains 
number ground actions grows dramatically domain size 
paper  address limitations proposing approach solving fomdps
combines first order state abstraction heuristic search novel way  exploiting
power logical representations  algorithm viewed first order generalization lao   contribution show perform heuristic search
first order mdps  circumventing propositionalization  fact  show
improve performance symbolic lao providing compact first order mdp representation using probabilistic fluent calculus instead propositional adds  alternatively 
approach considered way improve efficiency fovi algorithm
using heuristic search together symbolic dynamic programming 

   first order representation mdps
recently  several representations propositionally factored mdps proposed 
including dynamic bayesian networks boutilier et al         adds hoey et al 
        instance  spudd algorithm hoey et al         used solve
mdps hundreds millions states optimally  producing logical descriptions value
functions involve hundreds distinct values  work demonstrates large
   

fiflucap  heuristic search planner first order mdps

mdps  described logical fashion  often solved optimally exploiting logical
structure problem 
meanwhile  many realistic planning domains best represented first order terms 
however  existing implemented solutions first order mdps rely propositionalization  i e   eliminate variables outset solution attempt instantiating terms
possible combinations domain objects  technique impractical
number propositions grows dramatically number domain objects
relations 
example  consider following goal statement taken colored blocksworld
scenario  blocks  addition unique identifiers  associated colors 
g   x        x    red x    green x    blue x    red x    red x   
red x    green x    green x    ower x            x     
ower x            x    represents fact eight blocks comprise one tower 
assume number blocks domain color distribution agrees
goal statement  namely eight blocks a  b          h domain 
four red  three green one blue  then  full propositionalization
goal statement g results              different ground towers 
exactly many ways arranging four red  three green one blue block tower
eight blocks required color characteristics 
number ground combinations  hence  complexity reasoning propositional planner  depends dramatically number blocks and  importantly 
number colors domain  fewer colors domain contains  harder
solve propositional planner  example  goal statement g    g
above  eight blocks color  results            ground towers 
grounded 
address limitations  propose concise representation fomdps within
probabilistic fluent calculus logical approach modelling dynamically changing
systems based first order logic  first  briefly describe basics theory
mdps 
    mdps
markov decision process  mdp   tuple  z  a  p  r  c   z finite set
states  finite set actions  p   z z         written p z    z  a   specifies
transition probabilities  particular  p z    z  a  denotes probability ending
state z   given agent state z action executed  r   z r realvalued reward function associating state z immediate utility r z   c   r
real valued cost function associating cost c a  action a  sequential
decision problem consists mdp problem finding policy   z
maximizes total expected discounted reward received executing policy
infinite  or indefinite  horizon 
value state z  starting z following policy afterwards 
computed following system linear equations 
x
v  z    r z    c  z    
p z    z   z  v  z     
z   z

   

fiholldobler  karabaev   skvortsova

    discount factor  take equal   indefinite horizon problems
only  i e   goal reached system enters absorbing state
rewards costs accrued  optimal value function v satisfies 
x
v  z    r z    max c a   
p z    z  a v  z       
aa

z   z

z z 
competition  expected total reward model used optimality criterion  without discounting  care required design planning problems
ensure expected total reward bounded optimal policy  following
restrictions made problems used planning competition 
   problem goal statement  identifying set absorbing goal states 
   positive reward associated transitioning goal state 
   cost associated action 
   done action available states  could used end accumulation reward 
conditions ensure mdp model planning problem positive bounded
model described puterman         positive reward transitioning
goal state  since goal states absorbing  is  outgoing transitions 
maximum value state bounded goal reward  furthermore  done action
ensures action available state guarantees non negative future
reward 
    probabilistic fluent calculus
fluent calculus  fc  holldobler schneeberger        originally set
first order logic program equality using slde resolution sole inference rule 
probabilistic fluent calculus  pfc  extension original fc expressing
planning domains actions probabilistic effects 
states
formally  let denote set function symbols  distinguish two function symbols
  namely binary function symbol   associative  commutative  admits
unit element  constant    let            non variable  terms
called fluents  function names fluents referred fluent names  example 
on x  table  fluent meaning informally block x table 
fluent name  fluent terms defined inductively follows    fluent term 
fluent fluent term  f g fluent term  f g fluent terms  example 
on b  table  holding x  fluent term denoting informally block b table
block x robots gripper  words  freely occurring variables
assumed existentially quantified 
   

fiflucap  heuristic search planner first order mdps

assume fluent may occur state  moreover  function
symbols  except binary operator  constant    fluent names constants 
disallowed  addition  binary function symbol allowed appear
outermost connective fluent term  denote set fluents f set fluent
terms lf   respectively  abstract state defined pair  p  n    p lf
n lf   denote individual states z  z    z  etc   abstract states z  z    z  etc 
set abstract states lp n  
interpretation f  denoted i  pair       domain set
finite sets ground fluents f  interpretation function assigns
fluent term f set f abstract state z    p  n   set z
follows 
f    d    f d 
z    d    p n n  
   n  i   
substitution  example  figure   depicts interpretation abstract
state z
z    on x  a  on a  table    on y  x   holding x      
informally read  exists block x block
table  block x exists block x  
robot holds  since z contains finite sets ground fluents satisfy
p  part satisfy elements n  part  subtract sets ground
fluents belong ni n set ground fluents correspond
p  part  thus  bold area figure   contains exactly sets ground
fluents  or  individual states  satisfy p  part z none elements
n  part  example  individual state z     on b  a   on a  table   belongs z  
whereas z     on b  a   on a  table   holding c   not  words  abstract states
characterized means conditions must hold ground instance thereof
and  thus  represent clusters individual states  way  abstract states embody
form state space abstraction  kind abstraction referred first order state
abstraction 
actions
actions first order terms starting action function symbol  example 
action picking block x another block might denoted pickup  x    
formally  let na denote set action names disjoint   action space tuple
   a  pre   eff    set terms form a p            pn    referred
actions  na pi either variable  constant  pre   lp n
precondition a  eff   lp n effect a 
far  described deterministic actions only  actions pfc may
probabilistic effects well  similar work boutilier et al          decompose
stochastic action deterministic primitives natures control  referred natures
choices  use relation symbol choice   model natures choice  consider action
pickup  x    
choice  pickup  x     a 
 a   pickups  x      pickupf  x      
   

fiholldobler  karabaev   skvortsova

 on b a   on a table  
 on c a   on a table   on b d  
 on b a   on a table   holding c  
 on c a   on a table   on b c  
 on b a   on a table  
 on c a   on a table   on b d  
 on b a   on a table   holding c  
 on c a   on a table   on b c  

 b 

 a 
 on b a   on a table  

 on c a   on a table   on b d  
 on b a   on a table   holding c  
 on c a   on a table   on b c  

 c 
figure     a  interpretation fluent term f   on x  a  on a  table    b  bold area
interpretation abstract state z      on x  a  on a  table    on y  x    
 c  bold area interpretation abstract state z    on x  a 
on a  table    on y  x   holding x       

   

fiflucap  heuristic search planner first order mdps

pickups  x    pickupf  x    define two natures choices action pickup  x    
viz   succeeds fails  example  natures choice pickups defined
follows 
pre  pickups  x         on x    e   on w  x   
eff  pickups  x         holding x    on x       
fluent e denotes empty robots gripper  simplicity  denote set
natures choices action ch  a      aj  choice  a  aj     please note nowhere
action descriptions restrict domain discourse pre specified set
blocks 
natures choices aj associated action define probability
prob  aj   a  z  denoting probability one natures choices aj chosen
state z  example 
prob  pickups  x     pickup  x     z       
states probability successful execution pickup action state z
    
next step  define reward function state  example  might
want give reward     states block x block   
otherwise 
reward  z        z v  on x  a    
reward  z      z  v  on x  a      
v denotes subsumption relation  described detail section       
one observe specified reward function without explicit state enumeration  instead  state space divided two abstract states depending whether
not  block x block a  likewise  value functions specified respect
abstract states only  contrast classical dp algorithms  states
explicitly enumerated  action costs analogously defined follows 
cost pickup  x        
penalizing execution pickup  action value   
inference mechanism
herein  show perform inferences  i e   compute successors given abstract state 
action schemata directly  avoiding unnecessary grounding  note computation
predecessors performed similar way 
let z    p  n   abstract state  a p            pn   action parameters
p            pn   preconditions pre  a     pp   np   effects eff  a     pe   ne    let
substitutions  action a p            pn   forward applicable  simply applicable  z
  denoted forward  z  a       following conditions hold 
 f    pp u     ac  p
 f   np np  n n   p n u     ac   p np    
   

fiholldobler  karabaev   skvortsova

u  u  new ac  variables ac  equational theory
represented following system associativity  commutativity  unit element
equations 
eac       x  y  z  x  y z     x   z
 x    x   x
 x  x     x
  
words  conditions  f    f   guarantee z contains positive
negative preconditions action a  action forward applicable z
zsucc    p     n     
p       pe u   
n      n   np ne

   

referred a successor z denoted succ z  a      
example  consider action pickups  x    defined above  take z    p  n    
 on b  table  on x    b  e   on x    x       action pickups  x    forward applicable
z    x   x      b  u    on b  table      x    w  u        thus 
zsucc   succ z  pickups  x            p     n    
p     holding x    on b  table  n      on x    b    

   first order lao 
present generalization symbolic lao algorithm feng hansen        
referred first order lao  folao    solving fomdps  symbolic lao
heuristic search algorithm exploits state abstraction solving factored mdps  given
initial state  symbolic lao uses admissible heuristic focus computation
parts state space reachable initial state  moreover  specifies mdp
components  value functions  policies  admissible heuristics using propositional adds 
allows symbolic lao manipulate sets states instead individual states 
despite fact symbolic lao shows advantageous behaviour comparison
classical non symbolic lao hansen zilberstein        evaluates states
individually  suffers important drawback  solving fomdps  symbolic
lao propositionalizes problem  approach impractical large fomdps 
intention show improve performance symbolic lao providing
compact first order representation mdps heuristic search performed
without propositionalization  precisely  propose switch representational
formalism fomdps symbolic lao propositional adds probabilistic fluent
calculus  folao algorithm presented figure   
symbolic lao   folao two phases alternate complete solution
found  guaranteed optimal  first  expands best partial policy
evaluates states fringe using admissible heuristic function  performs
dynamic programming states visited best partial policy  update values
possibly revise current best partial policy  note focus partial policies
map subcollection states actions 
   

fiflucap  heuristic search planner first order mdps

policyexpansion       g 
e    f   
f rom     
repeat

 succ z  aj        
  
zf rom aj ch a 

 a          z 
f    f  to g 
e    e f rom
f rom    g e
 f rom    
e    e f
g    g f
return  e  f  g 
fovi e  a  prob  reward  cost    v  
repeat
v      v
loop z e
loop
loop   forward  z  a     
q z  a   
p     reward z    cost a  

prob aj   a  z  v    succ z  aj       
aj ch a 

end loop
end loop
v  z     max q z  a     
 a   

end loop
v    normalize v  
r    kv v   k
stopping criterion
   extractp olicy v  
return  v    r 
folao  a  prob  reward  cost        h   
v    h
g   
z     initialize arbitrary action
repeat
 e  f  g     policyexpansion       g 
 v    r     fovi e  a  prob  reward  cost    v  
 f     r
return    v  

figure    first order lao algorithm 
policy expansion step  perform reachability analysis find set f states
yet expanded  reachable set   initial states
following partial policy   set states g contains states expanded
far  expanding partial policy mean defined larger set
states dynamic programming step  symbolic lao   reachability analysis adds
performed means image operator symbolic model checking  computes
   

fiholldobler  karabaev   skvortsova

set successor states following best current policy  instead  folao   apply
succ operator  defined equation    one observe since reachability
analysis folao performed abstract states defined first order entities 
reasoning successor states kept first order level  contrast  symbolic
lao would first instantiate   possible combinations objects  order
able perform computations using propositional adds later on 
contrast symbolic lao   dynamic programming step performed using
modified version spudd  employ modified first order value iteration algorithm
 fovi   original fovi holldobler skvortsova        performs value iteration
entire state space  modify computes states reachable
initial states  precisely  set e states visited best current partial policy  way  improve efficiency original fovi algorithm
using reachability analysis together symbolic dynamic programming  fovi produces
pfc representation value functions policies constructing first order formulae
partition state space abstract states  effect  performs value iteration
top abstract states  obviating need explicit state enumeration 
given fomdp value function represented pfc  fovi returns best partial
value function v   best partial policy residual r  order update values
states z e  assign values current value function successors
z  compute successors respect natures choices aj   residual r
computed absolute value largest difference current newly
computed value functions v   v   respectively  note newly computed value
function v taken normalized form  i e   result normalize procedure
described section        extraction best partial policy straightforward 
one simply needs extract maximizing actions best partial value function v  
symbolic lao   folao converges  optimal policy three conditions met      current policy unexpanded states      residual
r less predefined threshold       value function initialized admissible heuristic  original convergence proofs lao symbolic lao hansen
zilberstein        carry straightforward way folao  
calling folao   initialize value function admissible heuristic
function h focuses search subset reachable states  simple way create
admissible heuristic use dynamic programming compute approximate value
function  therefore  order obtain admissible heuristic h folao   perform
several iterations original fovi  start algorithm initial value function
admissible  since step fovi preserves admissibility  resulting value
function admissible well  initial value function assigns goal reward
state thereby overestimating optimal value  since goal reward maximal possible
reward 
since computations folao performed abstract states instead individual
states  fomdps solved avoiding explicit state action enumeration propositionalization  first order reasoning leads better performance folao comparison
symbolic lao   shown section   
   

fiflucap  heuristic search planner first order mdps

    z    
z 

a  

a  

z 
f g
z 

    z     z    
f    z  z    
e     z     z     z   
g    z  z    

    z    

z 

z 

g

fovia    z     z     z    

a 

a  

z 

a  

f
z 

    z    
z 

    z     z    
f    z  
e    z  

b 

    z     z    
z   f     z   z  z  
 
 
 
 
 
 
z
z
z
 
e
 
   z    z    
 
 
 
 
z
 
z
z
g
g
   z    z    
 
 
a  

z 
z 

z 
a  

f

c 

z 

fovia     z     z     z     z     z      

figure    policy expansion 

    policy expansion
policy expansion step folao similar one symbolic lao
algorithm  therefore  illustrate expansion procedure means example  assume start initial state z  two nondeterministic actions a  a 
applicable z    two outcomes a     a   a     a     respectively  without loss
generality  assume current best policy chooses a  optimal action
state z    construct successors z  z  z  respect outcomes a  
a   action a   
fringe set f well set g states expanded far contain states z 
z  only  whereas  set e states visited best current partial policy gets
state z  addition  see figure  a  next step  fovi performed set e 
assume values updated way a  becomes optimal action
z    thus  successors z  recomputed respect optimal action
a    see figure  b 
one observe one a   successors z    namely z    element
set g thus  contained already fringe f previous expansion
step  hence  state z  expanded value recomputed  shown
figure  c  states z  z  a   successors z    assumption a 
optimal action z    result  fringe set f contains newly discovered
states z    z  z  perform fovi e    z    z    z    z    z     state z 
contained e  belong best current partial policy 
   

fiholldobler  karabaev   skvortsova

dynamic programming step performed states visited best
current partial policy 
    first order value iteration
folao   first order value iteration algorithm  fovi  serves two purposes  first 
perform several iterations fovi order create admissible heuristic h folao  
second  dynamic programming step folao   apply fovi states visited
best partial policy order update values possibly revise current
best partial policy 
original fovi holldobler skvortsova        takes finite state space
abstract states  finite set stochastic actions  real valued reward cost functions 
initial value function input  produces first order representation optimal
value function policy exploiting logical structure fomdp  thus  fovi
seen first order counterpart classical value iteration algorithm bellman
       
      normalization
following ideas boutilier et al          fovi relies normalization state
space represents value function  normalization state space  mean
equivalence preserving procedure reduces size state space  would
effect state space contains redundant entries  usually case symbolic
computations 
although normalization considered important issue  done
hand far  best knowledge  preliminary implementation approach boutilier et al         performs rudimentary logical simplifications
authors suggest using automated first order theorem prover normalization task 
holldobler skvortsova        developed automated normalization procedure
fovi that  given state space  delivers equivalent one contains redundancy 
technique employs notion subsumption relation 
formally  let z     p    n    z     p    n    abstract states  z  said
subsumed z    written z  v z    exist substitutions
following conditions hold 
 s    p  u     ac  p 
 s   n  n   n  n    p  n  u     ac   p  n     
u  u  new ac  variables  motivation notion subsumption
abstract states inherited notion  subsumption first order clauses
robinson        difference abstract states contain complicated negative parts contrast first order clauses 
example  consider two abstract states z  z  defined follows 
z     on x    a  on a  table    red y     
z     on x    a    red x       
   

fiflucap  heuristic search planner first order mdps

n
 
 
 
 
 
 
 
 
 
 

number states
supdate
snorm
 
 
  
  
  
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  

time  msec
update norm
   
 
   
 
   
  
    
  
    
  
    
  
    
   
    
   
    
   
    
   

runtime  msec

runtime w o norm  msec

   
   
   
    
    
    
    
    
    
    

   
   
    
     
     
      
n a
n a
n a
n a

table    representative timing results first ten iterations fovi 
z  informally asserts block x  block table
blocks red  whereas z  informally states block x  block
x  red  show z  v z    relation holds since conditions  s  
 s   satisfied  indeed 
 on x    a  u     ac  on x    a  on a  table 

 on x    a  on a  table  red y    u       on x    a  on a  table  red x    
   x    x    u    on a  table      y    x    u       
one note subsumption language abstract states inherits complexity bounds  subsumption  kapur   narendran         namely  deciding subsumption two abstract states np complete  general  however  karabaev et al 
       recently developed efficient algorithm delivers solutions subsumption problem case abstract states fluent terms 
purpose normalization  convenient represent value function
set pairs form hz  i  z abstract state real value  essence 
normalization algorithm seen exhaustive application following simplification rule value function v  
hz    hz   
z  v z 
hz   
table   illustrates importance normalization algorithm providing representative timing results first ten iterations fovi  experiments carried
problem taken colored blocksworld scenario consisting ten blocks 
even relatively simple problem fovi normalization switched
scale beyond sixth iteration 
results table   demonstrate normalization iteration
fovi dramatically shrinks computational effort next iterations  columns
labelled supdate snorm show size state space performing value updates
   

fiholldobler  karabaev   skvortsova

normalization  respectively  example  normalization factor  i e   ratio
number supdate states obtained performing one update step
number snorm states obtained performing normalization step  seventh
iteration       means ninety percent state space contained
redundant information  fourth fifth columns table   contain time update
norm spent performing value updates normalization  respectively 
total runtime runtime  normalization switched on  given sixth column 
seventh column labelled runtime w o norm depicts total runtime fovi
normalization switched off  would sum values seventh column
values sixth column sixth iteration inclusively  subtract latter
former divide result total time norm needed performing normalization
first six iterations  would obtain normalization gain three
orders magnitude 

   experimental evaluation
demonstrate advantages combining heuristic search together first order
state abstraction system  referred flucap  successfully entered
probabilistic track      international planning competition  ipc       experimental results obtained using redhat linux running    ghz pentium iv
machine  gb ram 
table    present performance comparison flucap together symbolic
lao examples taken colored blocksworld  bw  scenario introduced
ipc     
main objective investigate whether first order state abstraction using logic
could improve computational behaviour planning system solving fomdps 
colored bw problems main interest since ones represented
first order terms hence ones allowed us make use first order
state abstraction  therefore  concentrated design domain dependent
planning system tuned problems taken blocksworld scenario 
colored bw problems differ classical bw ones that  along
unique identifier  block assigned specific color  goal formula  specified firstorder terms  provides arrangement colors instead arrangement blocks 
outset solving colored bw problem  symbolic lao starts propositionalizing components  namely  goal statement actions  that  abstraction
using propositional adds applied  contrast  flucap performs first order abstraction colored bw problem directly  avoiding unnecessary grounding  following 
show abstraction technique affects computation heuristic function 
create admissible heuristic  flucap performs twenty iterations fovi symbolic
lao performs twenty iterations approximate value iteration algorithm similar
apricodd st aubin  hoey  boutilier         columns labelled h time
nas show time needed computing heuristic function number abstract
states covers  respectively  comparison flucap  symbolic lao needs evaluate
fewer abstract states heuristic function takes considerably time  one
   

fiflucap  heuristic search planner first order mdps

flucap

flucap

    
   
    
   
    
    
     
    
          
    
     
n a
     
    
     
          
n a
n a
n a
n a
n a
n a
n a
n a
n a
n a

lao 

lao 

flucap

fovi

flucap

lao 

flucap

                  
                  
                  
                    
                    
                   
                   
                   
                   
n a n a      n a
n a n a       n a
n a n a           
n a n a      n a
n a n a      n a

   
   
   
    
   
   
     
     
    
     
     
     
    
    

  
  
  
  
  
  
   
   
   
n a
n a
n a
n a
n a

   
   
  
    
   
   
    
    
   
    
    
    
    
     

    
   
   
    
    
   
     
    
    
n a
n a
    
n a
n a

    
    
    
    
    
    
    
    
    
n a
n a
n a
n a
n a

    
    
    
    
    
    
    
    
    
    
     
    
       
       

   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    performance comparison flucap  denoted flucap  symbolic lao
 denoted lao    cells n a denote fact planner
deliver solution within time limit one hour  nas ngs number
abstract ground states  respectively 

conclude abstract states symbolic lao enjoy complex structure
flucap 
note that  comparison fovi  flucap restricts value iteration smaller
state space  intuitively  value function  delivered fovi  covers larger
state space  time allocated heuristic search flucap
used performing additional iterations fovi  results column labelled  
justify harder problem  that is  colors contains   higher
percentage runtime spent normalization  almost test problems  effort spent
normalization takes three percent total runtime average 
order compare heuristic accuracy  present column labelled ngs
number ground states heuristic assigns non zero values to  one see
heuristics returned flucap symbolic lao similar accuracy  flucap
takes much less time compute them  reflects advantage plain first order
abstraction comparison marriage propositionalization abstraction using
propositional adds  examples  gain several orders magnitude h time 
column labelled total time presents time needed solve problem 
time  planner must execute    runs initial state goal state  one hour block
allocated problem  note that  comparison flucap  time required
heuristic search symbolic lao  i e   difference total time h time  grows
considerably faster size problem  reflects potential employing
   

 

fovi

  
  

   
   
   
   
   
   
   
   
   
n a
n a
n a
n a
n a

ngs     

nas
flucap

 

   
   
   
   
   
   
   
   
   
   
   
   
   
   

h time  sec 
lao 

 

   
   
   
   
   
   
   
   
   
n a
n a
n a
n a
n a

total time  sec 

flucap

 

fovi

 

c
 
 
 
 
 
 
 
 
 
 
 
 
 
 

flucap

b

total av  reward
lao 

problem

fiholldobler  karabaev   skvortsova

b
  
  
  
  
  
  
  
  
  

total av  reward     
     
     
     
     
     
     
     
     
n a

total time  sec 
     
     
     
     
      
      
      
      
n a

h time  sec 
    
     
     
     
     
      
     
     
n a

nas
   
   
    
    
    
    
    
    
n a

ngs     
   
       
       
       
        
        
        
        
n a

table    performance flucap larger instances one color blocksworld problems 
cells n a denote fact planner deliver solution within
time limit 

first order abstraction instead abstraction based propositional adds heuristic
search 
average reward obtained    runs  shown column total av  reward 
planners evaluation score  reward value close      which maximum possible
reward  simply indicates planner found reasonably good policy  time
number blocks b increases    running time symbolic lao increases roughly
   times  thus  could scale problems seven blocks 
contrast flucap could solve problems seventeen blocks  note
number colors c problem affects efficiency abstraction technique 
flucap  c decreases  abstraction rate increases which  turn  reflected
dramatic decrease runtime  opposite holds symbolic lao  
addition  compare flucap two variants  first one  denoted fovi 
performs heuristic search all  rather  employs fovi compute  optimal
total value function policy extracted  second one  denoted flucap  
performs trivial heuristic search starting initial value function admissible
heuristic  expected  flucap combines heuristic search fovi demonstrates
advantage plain fovi trivial heuristic search  results illustrate
significance heuristic search general  flucap vs  fovi  importance heuristic
accuracy  particular  flucap vs  flucap    fovi flucap scale problems
seven blocks 
table   presents performance results flucap larger instances one color
bw problems number blocks varying twenty thirty four  believe
flucap scale problems larger size implementation yet
well optimized  general  believe flucap system sensitive
size problem propositional planners are 
experiments targeted one color problems are 
one hand  simplest ones us and  hand  bottleneck propositional
planners  structure one color problems allows us apply first order state abstraction full power  example     blocks problem flucap operates
    thousand abstract states explode          individual states proposition   

fiflucap  heuristic search planner first order mdps

total av  reward     
umass

michigan

purdue 

purdue 

purdue 

caracas

toulouse

c
 
 
 
 
 
 
 
 
 

dresden

b
 
 
  
 
 
  
  
  
  

canberra

problem

     
     
     
     
     
     
     
     
     

     
     
     
     
     
n a
n a
n a
n a

n a
n a
n a
     
n a
n a
n a
n a
n a

n a
n a
n a
n a
n a
n a
n a
n a
n a

     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
     
     
   
     
     
n a
   

n a
n a
n a
     
     
     
     
n a
n a

n a
n a
n a
     
n a
n a
n a
n a
n a

table    official competition results colored non colored blocksworld scenarios 
may        n a entries table indicate either planner
successful solving problem attempt solve it 

alization  propositional planner must highly optimized order cope
non trivial state space 
note additional colors larger instances  more    blocks  bw problems
cause dramatic increase computational time  consider problems
unsolved  one observe number abstract states nas increases
number blocks non monotonically problems generated randomly 
example     blocks problem happens harder    blocks one  finally 
note results appear tables     obtained using new version
evaluation software rely propositionalization contrast initial
version used competition 
table   presents competition results ipc      flucap competitive
comparison planners colored bw problems  flucap perform
well non colored bw problems problems propositional ones  that
is  goal statements initial states ground  flucap yet incorporate
optimization techniques applied modern propositional planners  contestants
indicated origin  example  dresden   flucap  umass   symbolic lao etc 
pickup action cost    gain five points total reward means
plan contains ten fewer actions average  competition domains log files
available online appendix younes  littman  weissman  asmuth        
although empirical results presented work obtained
domain dependent version flucap  recently developed  karabaev et al  
      efficient domain independent inference mechanism core domainindependent version flucap 
   

fiholldobler  karabaev   skvortsova

   related work
follow symbolic dp  sdp  approach within situation calculus  sc  boutilier
et al         using first order state abstraction fomdps  one difference
representation language  use pfc instead sc  course symbolic value iteration  state space may contain redundant abstract states dramatically affect
algorithms efficiency  order achieve computational savings  normalization must performed remove redundancy  however  original work boutilier et al        
done hand  best knowledge  preliminary implementation
sdp approach within sc uses human provided rewrite rules logical simplification 
contrast  holldobler skvortsova        developed automated normalization
procedure fovi incorporated competition version flucap brings
computational gain several orders magnitude  another crucial difference
algorithm uses heuristic search limit number states policy computed 
rebel algorithm kersting  van otterlo  de raedt        relates folao
uses representation language simpler situation calculus 
feature makes state space normalization computationally feasible 
motivation  approach closely connected relational envelope based planning
 rebp  gardiol kaelbling        represents mdp dynamics compact set
relational rules extends envelope method dean et al          however  rebp
propositionalizes actions first  afterwards employs abstraction using equivalenceclass sampling  contrast  folao directly applies state action abstraction
first order structure mdp  respect  rebp closer symbolic lao
folao   moreover  contrast pfc  action descriptions rebp allow negation
appear preconditions effects  organization  folao   symbolic lao  
similar real time dp barto et al         online search algorithm mdps 
contrast  folao works offline 
algorithms classified deductive approaches solving fomdps 
characterized following features      model based     
aim exact solutions      logical reasoning methods used compute abstractions 
note fovi aims exact solution fomdp  whereas folao   due
heuristic search avoids evaluating states  seeks approximate solution 
therefore  would appropriate classify folao approximate deductive
approach fomdps 
another vein  research developing inductive approaches solving
fomdps  e g   fern  yoon  givan         authors propose approximate
policy iteration  api  algorithm  replace use cost function approximations
policy representations api direct  compact state action mappings  use
standard relational learner learn mappings  effect  fern et al  provide policylanguage biases enable solution large relational mdps  inductive approaches
characterized following features      model free      aim
approximate solutions      abstract model used generate biased samples
underlying fomdp abstract model altered based them 
recent approach gretton thiebaux        proposes inductive policy construction algorithm strikes middle ground deductive inductive tech   

fiflucap  heuristic search planner first order mdps

niques  idea use reasoning  particular first order regression  automatically
generate hypothesis language  used input inductive solver 
approach gretton thiebaux related sdp approach sense
first order domain specification language well logical reasoning employed 

   conclusions
proposed approach combines heuristic search first order state abstraction solving fomdps efficiently  approach seen two fold 
first  use dynamic programming compute approximate value function serves
admissible heuristic  heuristic search performed find exact solution
states reachable initial state  phases  exploit
power first order state abstraction order avoid evaluating states individually 
experimental results show  approach breaks new ground exploring efficiency
first order representations solving mdps  comparison existing mdp planners
must propositionalize domain  e g   symbolic lao   solution scales better larger
fomdps 
however  plenty remaining done  example  interested
question extent optimization techniques applied modern propositional
planners combined first order state abstraction  future competitions 
would face problems goal and or initial states partially defined
underlying domain contains infinitely many objects 
current version folao targeted problems allow efficient
first order state abstraction  precisely  problems polynomially translated pfc  example colored bw domain  existentially closed
goal descriptions linearly translated equivalent pfc representation  whereas
universally closed goal descriptions would require full propositionalization  thus  current version pfc less first order expressive than  e g   situation calculus  future 
would interesting study extensions pfc language  particular  find
trade off pfcs expressive power tractability solution methods
fomdps based pfc 

acknowledgements
grateful anonymous reviewers thorough reading previous versions paper  thank zhengzhu feng fruitful discussions
providing us executable symbolic lao planner  greatly appreciate
david e  smith patience encouragement  valuable comments helped
us improve paper  olga skvortsova supported grant within graduate programme grk     specification discrete processes systems processes
operational models logics auspices deutsche forschungsgemeinschaft
 dfg  
   

fiholldobler  karabaev   skvortsova

references
barto  a  g   bradtke  s  j     singh  s  p          learning act using real time dynamic
programming  artificial intelligence                  
bellman  r  e          dynamic programming  princeton university press  princeton  nj 
usa 
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions computational leverage  journal artificial intelligence research 
        
boutilier  c   reiter  r     price  b          symbolic dynamic programming firstorder mdps  nebel  b   ed    proceedings seventeenth international conference artificial intelligence  ijcai       pp          morgan kaufmann 
dean  t   kaelbling  l   kirman  j     nicholson  a          planning time constraints
stochastic domains  artificial intelligence           
feng  z     hansen  e          symbolic heuristic search factored markov decision processes  dechter  r   kearns  m     sutton  r   eds    proceedings eighteenth
national conference artificial intelligence  aaai       pp          edmonton 
canada  aaai press 
fern  a   yoon  s     givan  r          approximate policy iteration policy language
bias  thrun  s   saul  l     scholkopf  b   eds    proceedings seventeenth annual conference neural information processing systems  nips       vancouver 
canada  mit press 
gardiol  n     kaelbling  l          envelope based planning relational mdps  thrun 
s   saul  l     scholkopf  b   eds    proceedings seventeenth annual conference
neural information processing systems  nips       vancouver  canada  mit
press 
gretton  c     thiebaux  s          exploiting first order regression inductive policy
selection  chickering  m     halpern  j   eds    proceedings twentieth conference uncertainty artificial intelligence  uai       banff  canada  morgan
kaufmann 
hansen  e     zilberstein  s          lao   heuristic search algorithm finds solutions
loops  artificial intelligence            
hoey  j   st aubin  r   hu  a     boutilier  c          spudd  stochastic planning using
decision diagrams  laskey  k  b     prade  h   eds    proceedings fifteenth conference uncertainty artificial intelligence  uai       pp         
stockholm  morgan kaufmann 
holldobler  s     schneeberger  j          new deductive approach planning  new
generation computing            
holldobler  s     skvortsova  o          logic based approach dynamic programming 
proceedings workshop learning planning markov processes
advances challenges nineteenth national conference artificial intelligence  aaai     pp        san jose  ca  aaai press 
   

fiflucap  heuristic search planner first order mdps

kapur  d     narendran  p          np completeness set unification matching
problems  siekmann  j  h   ed    proceedings eighth international conference automated deduction  cade       pp          oxford  england  springer
verlag 
karabaev  e   ramme  g     skvortsova  o          efficient symbolic reasoning firstorder mdps  proceedings workshop planning  learning monitoring
uncertainty dynamic worlds seventeenth european conference
artificial intelligence  ecai       riva del garda  italy  appear 
kersting  k   van otterlo  m     de raedt  l          bellman goes relational  brodley 
c  e   ed    proceedings twenty first international conference machine
learning  icml       pp          banff  canada  acm 
puterman  m  l          markov decision processes   discrete stochastic dynamic programming  john wiley   sons  inc   new york  ny 
robinson  j          machine learning logic based resolution principle  journal
association computing machinery               
st aubin  r   hoey  h     boutilier  c          apricodd  approximate policy construction using decision diagrams  leen  t  k   dietterich  t  g     tresp  v   eds   
proceedings fourteenth annual conference neural information processing
systems  nips       pp            denver  mit press 
younes  h   littman  m   weissman  d     asmuth  j          first probabilistic track
international planning competition  journal artificial intelligence research 
           

   


