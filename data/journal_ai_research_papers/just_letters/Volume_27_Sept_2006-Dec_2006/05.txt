journal of artificial intelligence research                 

submitted         published        

understanding algorithm performance on an
oversubscribed scheduling application
laura barbulescu

laurabar cs cmu edu

the robotics institute
carnegie mellon university
pittsburgh  pa       usa

adele e  howe
l  darrell whitley
mark roberts

howe cs colostate edu
whitley cs colostate edu
mroberts cs colostate edu

computer science department
colorado state university
fort collins  co       usa

abstract
the best performing algorithms for a particular oversubscribed scheduling application 
air force satellite control network  afscn  scheduling  appear to have little in common  yet  through careful experimentation and modeling of performance in real problem
instances  we can relate characteristics of the best algorithms to characteristics of the
application  in particular  we find that plateaus dominate the search spaces  thus favoring algorithms that make larger changes to solutions  and that some randomization in
exploration is critical to good performance  due to the lack of gradient information on
the plateaus   based on our explanations of algorithm performance  we develop a new
algorithm that combines characteristics of the best performers  the new algorithms performance is better than the previous best  we show how hypothesis driven experimentation
and search modeling can both explain algorithm performance and motivate the design of
a new algorithm 

   introduction
effective solution of the air force satellite control network  afscn  oversubscribed
scheduling problem runs counter to what works well for similar scheduling problems  other
similar oversubscribed problems  e g   united states air force  usaf  air mobility command  amc  airlift  kramer   smith        and scheduling telescope observations  bresina 
       are well solved by heuristically guided constructive or repair based search  the best
performing solutions to afscn are a genetic algorithm  genitor   squeaky wheel optimization  swo  and randomized next descent local search  we have not yet found a
constructive or repair based solution that is competitive 
the three best performing solutions to afscn appear to have little in common  making
it difficult to explain their superior performance  genitor combines two candidate solutions
preserving elements of each  swo creates an initial greedy solution and then attempts to
improve the scheduling of all tasks known to contribute detrimentally to the current evaluation  randomized local search makes incremental changes based on observed immediate
gradients in schedule evaluation  in this paper  we examine the performance of these differc
    
ai access foundation  all rights reserved 

fibarbulescu  howe  whitley    roberts

ent algorithms  identify factors that do or do not help explain the performance and leverage
the explanations to design a new search algorithm that is well suited to the characteristics
of this application 
our target application is an oversubscribed scheduling application with alternative resources  afscn  air force satellite control network  access scheduling requires assigning
access requests  communication relays to u s a  government satellites  to specific time slots
on an antenna at a ground station  it is oversubscribed in that not all tasks can be accommodated given the available resources  to be considered to be oversubscribed  at least
some problem instances need to overtax the available resources  for our application though 
it appears that most problem instances specify more tasks than can be feasibly scheduled 
the application is challenging and shares characteristics with other applications such as
earth observing satellites  eos   it is important in that a team of human schedulers have
laboriously performed the task every day for at least    years with minimal automated
assistance 
all of the algorithms are designed to traverse essentially the same search space  solutions
are represented as permutations of tasks  which a greedy schedule builder converts into a
schedule by assigning start time and resources to the tasks in the order in which they
appear in the permutation  we find that this search space is dominated by large flat
regions  plateaus   additionally  the size of the plateaus increases dramatically as the best
solution is approached  the presence of the plateaus indicates that each algorithm needs
to effectively manage them in order to find improving solutions 
we have explored a number of different hypotheses to explain the performance of each
algorithm  some of these hypotheses include the following 
genitor  a genetic algorithm  identifies patterns of relative task orderings  similar to backbones from sat  singer  gent    smaill         which are preserved in the members of
the population  this is in effect a type of classic building block hypothesis  goldberg 
      
swo starts extremely close to the best solution and so need not enact much change  this
hypothesis also implies that it is relatively easy to modify good greedy solutions to
find the best known solutions 
randomized local search performs essentially a random walk on the plateaus to find
exits leading to better solutions  given the distribution of solutions and lack of gradient
information  this may be as good a strategy as any 
we tested each of these hypotheses  there is limited evidence for the existence of building
blocks or backbone structure  and while squeaky wheel optimization does quickly find
good solutions  it cannot reliably find best known solutions  therefore  while the first
two hypotheses were somewhat supported by the data  the hypotheses were not enough to
explain the observed performance 
the third hypothesis appears to be the best explanation of why the particular local
search strategy we have used works so well  in light of this  we formulated another hypothesis 
swo and genitor make long leaps in the search space  which allow them to relatively
quickly traverse the plateaus 
   

fiunderstanding algorithm performance

this last hypothesis appears to well explain the performance of the two methods  for
the genetic algorithm the leaps are naturally longer during the early phases of search when
parent solutions are less similar 
based on these studies  we constructed a new search algorithm that exploits what we
have learned about the search space and the behavior of successful algorithms  attenuated
leap local search makes multiple changes to the solution before evaluating a candidate
solution  in addition  the number of changes decreases proportionately with expected proximity to the solution  the number of multiple changes  or the length of the leap  is larger
early in the search  and reduces  shortens  as better solutions are found  we find that this
algorithm performs quite well  it quickly finds best known solutions to all of the afscn
problems 

   afscn scheduling
the u s a  air force satellite control network is currently responsible for coordinating
communications between civilian and military organizations and more than     usaf managed satellites  space ground communications are performed using    antennas located at
nine tracking stations around the globe     figure   shows a map of the current configuration
of afscn  this map shows one fewer tracking station and antennae than are in our data 
due to those resources apparently having been taken off line recently  customer organizations submit task requests to reserve an antenna at a tracking station for a specified time
period based on the visibility windows between target satellites and tracking stations  two
types of task requests can be distinguished  low altitude and high altitude orbits  the low
altitude tasks specify requests for access to low altitude satellites  such requests tend to
be short  e g      minutes  and have a tight visibility window  high altitude tasks specify
requests for high altitude satellites  the durations for these requests are more varied and
usually longer  with large visibility windows 
approximately     requests are typically received for a single day  separate schedules
are produced by a staff of human schedulers at schriever air force base for each day  of the
    requests  often about     conflicts remain after the first pass of scheduling  conflicts
are defined as requests that cannot be scheduled  since they conflict with other scheduled
requests  this means that     requests remain unscheduled after an initial schedule is
produced  
from real problem data  we extract a description of the problem specification in terms of
task requests to be scheduled with their corresponding type  low or high altitude   duration 
time windows and alternative resources  the afscn data also include information about
satellite revolution numbers  optional site equipment  tracking station maintenance times
 downtimes   possible loss of data due to antenna problems  various comments  etc   we do
not incorporate such information in our problem specification  the information about the
type of the task  low or high altitude  as well as the identifier for the satellite involved are
included in the task specification  however  we do not know how the satellite identifier
   the u s a  government is planning to make the afscn the core of an integrated satellite control
network for managing satellite assets for other u s a  government agencies as well  e g   nasa  noaa 
other dod affiliates  by       when the system first becomes operational  the remote tracking stations
will be increased and enhanced to accommodate the additional load 

   

fibarbulescu  howe  whitley    roberts

figure    map of the current afscn network including tracking stations  control and relay 
the figure was produced for u s a  space and missile systems center  smc  

corresponds to an actual satellite and so rely on precomputed visibility information which
is present in the requests 
a problem instance consists of n task requests  each task request t i      i  n  specifies
a required processing duration tidur   each task request also specifies a number of j   
pairs of the form  rj   tijwin    each identifying a particular alternative resource  antenna
rj   and time window tijwin for the task  the duration of the task is the same for all
possible alternative resources  the start and end of the visibility time window is specific
to each alternative resource  therefore while the duration is the same  the time windows
can be different for the alternative resources  once a resource is assigned to the request 
the duration needs to be allocated within the corresponding time window  we denote the
lower and upper bounds of each time window j corresponding to request i by t ijwin  lb 
and tijwin  ub   respectively  for each task  only one of the alternative antennas needs to be
chosen  also  the tasks cannot be preempted once processing is initiated 
while requests are made for a specific antenna  often a different antenna at the same
tracking station may serve as an alternate because it has the same capabilities  we assume
that all antennas at a tracking station can serve as alternate resources  while this is not
always the case in practice  the same assumption was made by previous research from the air
   

fiunderstanding algorithm performance

force institute of technology  afit      a low altitude request specifies as possible resources
the antennas present at a single tracking station  for visibility reasons  only one tracking
station can accommodate such a request   usually there are two or three antennas present
at a tracking station  and therefore  only two or three possible resources are associated with
each of these requests  high altitude requests specify all the antennas present at all the
tracking stations that satisfy the visibility constraints  as many as    possible alternatives
are specified in our data 
previous research and development on afscn scheduling focused on minimizing the
number of request conflicts for afscn scheduling  or alternatively  maximizing the number
of requests that can be scheduled without conflict  those requests that cannot be scheduled
without conflict are bumped out of the schedule  this is not what happens when humans
carry out afscn scheduling    satellites are valuable resources  and the afscn operators
work to fit in every request  what this means in practice is that after negotiation with the
customers  some requests are given less time than requested  or shifted to less desirable 
but still usable time slots  in effect  the requests are altered until all requests are at least
partially satisfied or deferred to another day  by using an evaluation function that minimizes
the number of request conflicts  an assumption is being made that we should fit in as many
requests as possible before requiring human schedulers to figure out how to place those
requests that have been bumped 
however  given that all requests need to be eventually scheduled  we designed a new
evaluation criterion that schedules all the requests by allowing them to overlap and minimizing the sum of overlaps between conflicting tasks  this appears to yield schedules that are
much closer to those that human schedulers construct  when conflicting tasks are bumped
out of the schedule  large and difficult to schedule tasks are most likely to be bumped 
placing these requests back into a negotiated schedule means deconstructing the minimal
conflict schedule and rebuilding a new schedule  thus  a schedule that minimizes conflicts
may not help all that much when constructing the negotiated schedule  whereas a schedule
that minimizes overlaps can suggest ways of fitting tasks into the schedule  for example
by reducing a tasks duration by two or three minutes  or shifting a start outside of the
requested window by a short amount of time 
we obtained    days of data for the afscn application     the first seven days are from
a week in      and were given to us by colonel james moore at the air force institute of
technology  these data were used in the first research projects on afscn  we obtained an
additional five days of data from schedulers at schriever air force base  table   summarizes
the characteristics of the data  the best known solutions were obtained by performing long
runs over hundreds of experiments  using various algorithms and allowing for hundreds

   in fact  large antennas are needed for high altitude requests  while smaller antennas can handle the low
altitude requests  depending on the type of antennas present at a tracking station  not all antennas can
always serve as alternate resources for a request 
   we met with the several of the schedulers at schriever to discuss their procedure and have them crosscheck our solution  we appreciate the assistance of brian bayless and william szary in setting up the
meeting and giving us data 
   we have approval to make public some  but not all of the data 
see http   www cs colostate edu sched data html for details on obtaining the problems 

   

fibarbulescu  howe  whitley    roberts

id
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

date
        
        
        
        
        
        
        
        
        
        
        
        

  requests
   
   
   
   
   
   
   
   
   
   
   
   

  high
   
   
   
   
   
   
   
   
   
   
   
   

  low
   
   
   
   
   
   
   
   
   
   
   
   

best conflicts
 
 
 
 
 
 
 
  
  
  
  
  

best overlaps
   
  
  
 
  
  
  
   
   
   
   
   

table    problem characteristics for the    days of afscn data used in our experiments 
id is used in other tables  best conflicts and best overlaps are the best known
values for each problem for these two objective functions 

of thousands of evaluations  we have not found better solutions than these     we will refer
to the problems from      as the a problems  and to the more recent problems  as the r
problems 

   related scheduling research
the afscn application is a multiple resource  oversubscribed problem  examples of other
such applications are usaf air mobility command  amc  airlift scheduling  kramer  
smith         nasas shuttle ground processing  deale et al          scheduling telescope
observations  bresina        and satellite observation scheduling  frank  jonsson  morris 
  smith        globus  crawford  lohn    pryor        
amc scheduling assigns delivery missions to air wings  kramer   smith         their
system adopts an iterative repair approach by greedily creating an initial schedule ordering
the tasks by priority and then attempting to insert unscheduled tasks by retracting and
re arranging conflicting tasks 
the gerry scheduler was designed to manage the large set of tasks needed to prepare
a space shuttle for its next mission  zweben  daun    deale         tasks are described
in terms of resource requirements  temporal constraints and required time windows  the
original version used constructive search with dependency directed backtracking  which was
not adequate to the task  a subsequent version employed constraint directed iterative repair 
in satellite scheduling  customer requests for data collection need to be matched with
satellite and tracking station resources  the requests specify the instruments required 
the window of time when the request needs to be executed  and the location of the sensing communication event  these task constraints need to be coordinated with resource
   all the best known values can be obtained by running genitor with the population size increased to    
and allowing        evaluations per run 

   

fiunderstanding algorithm performance

constraints  these include the windows of visibility for the satellites  maintenance periods
and downtimes for the tracking stations  etc  typically  more requests need to be scheduled
than can be accommodated by the available resources  a general description of the satellite
scheduling domain is provided by jeremy frank et al         
pemberton        solves a simple one resource satellite scheduling problem in which
the requests have priorities  fixed start times and fixed durations  the objective function
maximizes the sum of the priorities of the scheduled requests  a priority segmentation algorithm is proposed  which is a hybrid algorithm combining a greedy approach with branchand bound  wolfe and sorensen        define a more complex one resource problem  the
window constrained packing problem  wcp   which specifies for each request the earliest
start time  latest final time and the minimum and maximum duration  the objective function is complex  combining request priority with the position of the scheduled request in its
required window and the number of requests scheduled  two greedy heuristic approaches
and a genetic algorithm are implemented  the genetic algorithm is found to perform best 
globus et al         compare a genetic algorithm  simulated annealing  squeaky wheel
optimization  joslin   clements        and hill climbing on a simplified  synthetic form
of the satellite scheduling problem  two satellites with a single instrument  and find that
simulated annealing excels and that the genetic algorithm performs relatively poorly  for
a general version of satellite scheduling  eos observation scheduling   frank et al        
propose a constraint based planner with a stochastic greedy search algorithm based on
bresinas heuristic biased stochastic sampling  hbss  algorithm  bresina         hbss
was originally applied to scheduling astronomy observations for telescopes 
lematre et al         research the problem of scheduling the set of photographs for agile
eos  roadef challenge         task constraints include the minimal time between two
successive acquisitions  pairings of requests such that images are acquired twice in different
time windows  and hard requirements that certain images must always be acquired  they
find that a local search approach performs better than a hybrid algorithm combining branchand bound with various domain specific heuristics 
the afscn application was previously studied by researchers from the air force institute of technology  afit   gooley        and schalck        described algorithms based
on mixed integer programming  mip  and insertion heuristics  which achieved good overall performance           of all requests scheduled  parish        used the genitor
 whitley        genetic algorithm  which scheduled roughly     of all task requests  outperforming the mip approaches  all three of these researchers used the afit benchmark
suite consisting of seven problem instances  representing actual afscn task request data
and visibilities for seven consecutive days from october    to           later  jang       
introduced a problem generator employing a bootstrap mechanism to produce additional
test problems that are qualitatively similar to the afit benchmark problems  jang then
used this generator to analyze the maximum capacity of the afscn  as measured by the
aggregate number of task requests that can be satisfied in a single day 
while the general decision problem of afscn scheduling with minimal conflicts is n pcomplete  special subclasses of afscn scheduling are polynomial  burrowbridge       
considers a simplified version of afscn scheduling  where each task specifies only one resource  antenna  and only low altitude satellites are present  the objective is to maximize
the number of scheduled tasks  due to the orbital dynamics of low altitude satellites  the
   

fibarbulescu  howe  whitley    roberts

task requests in this problem have negligible slack   i e   the window size is equal to the
request duration  assuming that only one task can be scheduled per time window  the wellknown greedy activity selector algorithm  cormen  leiserson    rivest        is used to
schedule the requests since it yields a solution with the maximal number of scheduled tasks 
to schedule low altitude requests on one of the multiple antennas present at a particular
ground station  we extended the greedy activity selector algorithm for multiple resource
problems  we proved that this extension of the greedy activity selector optimally schedules the low altitude requests for the general problem of afscn scheduling  barbulescu 
watson  whitley    howe      b  

   algorithms
we implemented a variety of algorithms for afscn scheduling  iterative repair  heuristic
constructive search  local search  a genetic algorithm  ga   and squeaky wheel optimization  swo   as will be shown in section    we found that randomized next descent local
search  the ga and swo work best for afscn scheduling 
we also considered constructive search algorithms based on texture  beck  davenport 
davis    fox        and slack  smith   cheng        constraint based scheduling heuristics 
we implemented straightforward extensions of such algorithms for our application  the
results were poor  the number of request tasks combined with the presence of multiple
alternative resources for each task make the application of such methods impractical  we
do not report the performance values for the constructive search methods because these
methods depend critically on the heuristics  we are uncomfortable concluding that the
methods are poor because we may not have found good enough heuristics for them  we
also tried using a commercial off the shelf satellite scheduling package and had similarly
poor results  we do not report performance values for the commercial system because it
had not been designed specifically for this application and we did not have access to the
source to determine the reason for the poor performance 
    solution representation
permutation based representations are frequently used when solving scheduling problems
 e g   whitley  starkweather  fuquay        syswerda        wolfe  sorensen        aickelin  dowsland        globus et al          all of our algorithms  except iterative repair 
encode solutions using a permutation  of the n task request ids  i e       n    a schedule
builder is used to generate solutions from a permutation of request ids  the schedule builder
considers task requests in the order that they appear in   each task request is assigned
to the first resource available from the sequence of resource and window pairs provided in
the task description  this is the first feasible resource in the sequence   the earliest possible
starting time is then chosen for this resource  when minimizing the number of conflicts 
if the request cannot be scheduled on any of the alternative resources  it is dropped from
the schedule  i e   bumped   when minimizing the sum of overlaps  if a request cannot be
scheduled without conflict on any of the alternative resources  we assign it to the resource
   

fiunderstanding algorithm performance

on which the overlap with requests scheduled so far is minimized    note that our schedule
builder does favor the order in which the alternative resources are specified in the request 
even though no preference is specified for any of the alternatives 
    iterative repair
iterative repair methods have been successfully used to solve various oversubscribed scheduling problems  e g   hubble space telescope observations  johnston   miller        and space
shuttle payloads  zweben et al         rabideau  chien  willis    mann         nasas
aspen  a scheduling and planning environment  framework  chien et al          employs both constructive and repair based methods and has been used to model and solve
real world space applications such as scheduling eos  more recently  kramer and smith
       used repair based methods to solve the airlift scheduling problem for the usaf air
mobility command 
in each case  a key component to the implementation was a domain appropriate ordering heuristic to guide the repairs  for afscn scheduling  gooleys algorithm       
uses domain specific knowledge to implement a repair based approach  we implement an
improvement to gooleys algorithm that is guaranteed to yield results at least as good as
those produced by the original version 
gooleys algorithm has two phases  in the first phase  the low altitude requests are
scheduled  mainly using mixed integer programming  mip   because there is a large number
of low altitude requests  the requests are divided into two blocks  mip procedures are
first used to schedule the requests in the first block  then mip is used to schedule the
requests in the second block  which are inserted in the schedule around the requests from
the first block  finally  an interchange procedure attempts to optimize the total number
of low altitude requests scheduled  this is needed because the low altitude requests are
scheduled in disjoint blocks  once the low altitude requests are scheduled  their start time
and assigned resources remain fixed  in our implementation  we replaced this first phase
with a greedy algorithm  barbulescu et al       b  proven to schedule the optimal number
of low altitude requests    our greedy algorithm modifies the well known activity selector
algorithm  cormen et al         for multiple resource problems  the algorithm still schedules
the requests in increasing order of their due date  however it specifies that each request is
scheduled on the resource for which the idle time before its start time is the minimum 
our version accomplishes the same function as gooleys first phase  but does so with a
guarantee that the optimal number of low altitude requests are scheduled  thus  the result
is guaranteed to be equal to or better than gooleys original algorithm 
in the second phase  the high altitude requests are inserted in the schedule  without
rescheduling any of the low altitude requests   an order of insertion for the high altitude
requests is computed  the requests are sorted in decreasing order of the ratio of the duration
of the request to the average length of its time windows  this is similar to the flexibility
measure defined by kramer and smith       for amc   ties are broken based on the number
of alternative resources specified  fewer alternatives scheduled first   after all the high
   if two or more non scheduled tasks overlap with each other  this mutual overlap is not part of the sum
of overlaps  only the overlap with scheduled requests is considered 
   our algorithm optimally solves the problem of scheduling only the low altitude requests  in polynomial
time 

   

fibarbulescu  howe  whitley    roberts

altitude requests have been considered for insertion  an interchange procedure attempts to
accommodate the unscheduled requests  by rescheduling some of the high altitude requests 
for each unscheduled high altitude request  a list of candidate requests for rescheduling
is computed  such that after a successful rescheduling operation  the unscheduled request
can be placed in the spot initially occupied by such a candidate   a heuristic measure is
used to determine which requests from the candidate list should be rescheduled  for the
chosen candidates  if no scheduling alternatives are available  the same procedure is applied
to identify requests that can be rescheduled  this interchange procedure is defined with
two levels of recursion and is called three satellite interchange 
    randomized local search  rls 
we implemented a hill climber we call randomized local search  which starts from a randomly generated solution and iteratively moves toward a better or equally good neighboring solution  because it has been successfully applied to a number of well known
scheduling problems  we selected a domain independent move operator  the shift operator  from a current solution   a neighborhood is defined by considering all  n      
pairs  x  y  of positions in   subject to the restriction that y    x     the neighbor
 
 corresponding to the position pair  x  y  is produced by shifting the job at position
x into the position y  while leaving all other relative job orders unchanged  if x   y 
then                  x       x             y    x    y             n    if x   y  then
                 y       x    y         x       x             n   
given the large neighborhood size  we use the shift operator in conjunction with nextdescent hill climbing  our implementation completely randomizes which neighbor to examine next  and does so with replacement  at each step  both x and y are chosen randomly 
this general approach has been termed stochastic hill climbing by ackley         if the
value of the randomly chosen neighbor is equal or better than the value of the current
solution  it becomes the new current solution 
it should be emphasized that randomized local search  or stochastic hill climbing  can
sometimes be much more effective than steepest descent local search or next descent local
search where the neighbors are checked in a predefined order  as opposed to random order  
forrest and mitchell        showed that a random mutation hill climber  much like our rls
or ackleys stochastic hill climber  found solutions much faster than steepest descent local
search on a problem they called the royal road function  the random mutation hill
climber also found solutions much faster than a hill climber that generated and examined
the neighbors systematically  in a predefined order   random mutation hill climber was
also much more effective than a genetic algorithm for this problem  despite the existence
of what would appear to be natural building blocks in the function  it is notable that
the royal road function is a staircase like function  where each step in the staircase is
a plateau 
    genetic algorithm
genetic algorithms were found to perform well on the afscn scheduling problem in some
early studies  parish         genetic algorithms have also been found to be effective in other
oversubscribed scheduling applications  such as scheduling f    flight simulators  syswerda 
   

fiunderstanding algorithm performance

      or an abstraction of nasas eos problem  wolfe   sorensen         for our studies 
we used the version of genitor originally developed for a warehouse scheduling application
 starkweather et al          this is also the version used by parish for afscn scheduling 
like all genetic algorithms  genitor maintains a population of solutions  in our implementation  we fixed the population size to be      in each step of the algorithm  a pair of parent
solutions is selected  and a crossover operator is used to generate a single child solution 
which then replaces the worst solution in the population  selection of parent solutions is
based on the rank of their fitness  relative to other solutions in the population  following
parish        and starkweather et al          we used syswerdas        position based
crossover operator 
syswerdas position based crossover operator starts by selecting a number of random
positions in the second parent  the corresponding selected elements will appear in exactly
the same positions in the offspring  the remaining positions in the offspring are filled with
elements from the first parent in the order in which they appear in this parent 
parent    a b c d e f g h i j
parent    c f a j h d i g b e
selected elements 
   
 
 
offspring  c f a e g d h i b j
for our implementation  we randomly choose the number of positions to be selected 
such that it is larger than one third of the total number of positions and smaller than two
thirds of the total number of positions 
    squeaky wheel optimization
squeaky wheel optimization  swo   joslin   clements        repeatedly iterates through
a cycle composed of three phases  first  a greedy solution is built  based on priorities associated with the elements in the problem  then  the solution is analyzed  and the elements
causing trouble are identified based on their contribution to the objective function  third 
the priorities of such trouble makers are modified  such that they will be considered earlier during the next iteration  the cycle is then repeated  until a termination condition is
met 
we constructed the initial greedy permutation for swo by sorting the requests in increasing order of their flexibility  our flexibility measure is similar to that defined for the
amc application  kramer   smith         the duration of the request divided by the
average time window on the possible alternative resources  we break ties based on the
number of alternative resources available  for requests with equal flexibilities and numbers
of alternative resources  the earlier request is scheduled first  for multiple runs of swo 
we restarted it from a modified permutation created by performing    random swaps in the
initial greedy permutation 
when minimizing the sum of overlaps  we identified the overlapping requests as the
trouble spots in the schedule  note that for any overlap  we considered one request to
be scheduled  the other request  or requests  if more than two requests are involved  is
the overlapping request  we sorted the overlapping requests in increasing order of their
contribution to the sum of overlaps  we associated with each such request a distance to
   

fibarbulescu  howe  whitley    roberts

move forward  based on its rank in the sorted order  we fixed the minimum distance of
moving forward to one and the maximum distance to five  this seems to work better than
other possible values we tried   the distance values are equally distributed among the ranks 
we moved the requests forward in the permutation in increasing order of their contribution
to the sum of overlaps  requests with smaller overlaps are moved first  we tried versions
of swo where the distance to move forward is proportional with the contribution to the
sum of overlaps or is fixed  however  these versions performed worse than the rank based
distance implementation described above  when minimizing conflicts in the schedule all
conflicts have an equal contribution to the objective function  therefore we decided to move
them forward for a fixed distance of five  we tried values between two and seven but five
was best  
    heuristic biased stochastic sampling  hbss 
hbss  bresina        is an incremental construction algorithm in which multiple rootto leaf paths are stochastically generated  at each step  the hbss algorithm needs to
heuristically choose the next request to schedule from the unscheduled requests  we used
the flexibility measure as described for swo to rank the unscheduled requests  we compute
the flexibility for each request and order them in decreasing order of the flexibility  each
request is then given a rank according to this ordering  first request has rank    second
request rank    etc    a bias function is applied to the ranks  as noted by bresina       
p       the choice of bias function reflects the confidence one has in the heuristics accuracy
  the higher the confidence  the stronger the bias  the flexibility heuristic is an effective
greedy heuristic for constructing solutions in afscn scheduling  therefore we used a
relatively strong bias function  an exponential bias  for each rank r  the bias is computed 
bias r    er   the probability to select the unscheduled request with rank r is then
computed as 
bias r 
p  r    p
iunscheduled bias rank i  
where unscheduled represents the set of unscheduled requests 
our implementation of hbss does not re compute the flexibility of the unscheduled tasks
every time we choose the next request to be scheduled  in other words  hbss is building a
permutation of requests and then the schedule builder produces the corresponding schedule 
in terms of cpu time  this means that the time required by hbss to build a solution is
similar to those of the other algorithms  dominated by the number of evaluations   a version
re computing the flexibility of the unscheduled tasks as tasks are scheduled would be a lot
more expensive  in fact  for eos which is a similar oversubscribed scheduling problem 
globus et al         found that updating the heuristic values in hbss while scheduling
was hundreds of times slower than the permutation based techniques  required far more
memory  and produced very poor schedules 

   

fiunderstanding algorithm performance

   what works well 
a first step to understanding how best to solve a problem is to assess what methods perform
best  the results of running each of the algorithms are summarized in tables   and  
respectively  for genitor  randomized local search  rls  and squeaky wheel optimization
 swo   we report the best and mean value and the standard deviation observed over   
runs  with      evaluations per run  for hbss  the statistics are taken over         samples 
both genitor and rls were initialized from random permutations 
the best known values for the sum of overlaps  see table    were obtained by running
genitor with the population size increased to     and up to        evaluations  over hundreds of experiments using numerous algorithms  we have not found better solutions than
these  when we report that an algorithm is better than genitor it means that it was better
than genitor when both algorithms were limited to      evaluations 
with the exception of gooleys algorithm  the cpu times are dominated by the number
of evaluations and therefore are similar  on a dell precision     with      ghz xeon
running linux     runs with      evaluations per run take between    and     seconds  for
more precise values  see barbulescu et al         
the increase in the number of requests received for a day in the more recent r problems
causes an increase in the number and percentage of unscheduled requests  for the a problems  at most eight task requests  or      of the tasks  are not scheduled  between      
and     of the task requests are scheduled  for the r problems  at most     or      of
the tasks  are not scheduled  between       and       of the tasks requests are scheduled 
to compare algorithm performance  our statistical analyses include genitor  swo  and
rls  we also include in our analyses the algorithms swo move  a variant of swo we
explore in section         and alls  a variant of local search we present in section     we
judge significant differences of the final evaluations using an anova for the five algorithms
on each of the recent days of data  all anovas came back significant  so we are justified
in performing pair wise tests  we examined a single tailed  two sample t test as well as the
non parametric wilcoxon rank sum test  the wilcoxon test significance results were the
same as the t test except in two pairs  so we only present p values from the t test that are
close to our rejection threshold of p       per pair wise test    
when minimizing conflicts  many of the algorithms find solutions with the best known
values  pair wise t tests show that genitor and rls are not significantly different for r  
r   and r   genitor significantly outperforms rls on r   p          and r   p          
swo does not perform significantly different from rls for all five days and significantly
outperforms genitor on r   genitor significantly outperforms swo on r  and r   however 
some adjusting of the parameters used to run swo may fix this problem  it is in fact
surprising how well swo performs when minimizing the conflicts  given that we chose a
very simple implementation  where all the tasks in conflict are moved forward with a fixed
distance  hbss performs well for the a problems  however  it fails to find the best known
values for r   r  and r   the original solution to the problem  gooleys  only computes a
single solution  its results can be improved by a sampling variant  see section        
   five algorithms imply  at worst     pair wise comparisons per day of data  to control the experimentwise error  we use a  very conservative  but simple  bonferroni adjustment  this adjustment is known to
increase the probability of a type ii error  favoring false acceptance that the distributions are similar  
at         we judge two algorithms as significantly different if p       

   

fibarbulescu  howe  whitley    roberts

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
 
 
 
 
 
 
 
  
  
  
  
  

genitor
mean
   
 
    
    
   
    
 
    
    
     
     
     

sd
    
 
    
    
   
    
 
    
    
    
    
    

min
 
 
 
 
 
 
 
  
  
  
  
  

rls
mean
   
   
   
   
   
    
    
    
    
    
     
    

sd
    
 
   
    
    
    
    
    
    
    
    
    

min
 
 
 
 
 
 
 
  
  
  
  
  

swo
mean
 
 
 
    
 
 
 
    
     
  
    
  

sd
   
   
   
    
   
   
   
    
    
   
    
 

min
 
 
 
 
 
 
 
  
  
  
  
  

hbss
mean
    
    
    
    
    
    
    
     
     
     
     
     

gooley
sd
    
    
    
    
    
    
    
    
    
    
    
    

  
 
 
 
 
 
 
  
  
  
  
  

table    performance of genitor  rls  swo  hbss and gooleys algorithm in terms of
the best and mean number of conflicts  statistics for genitor  local search and
swo are collected over    independent runs  with      evaluations per run  for
hbss          samples are considered  min numbers in boldface indicate best
known values 

when minimizing overlaps  rls finds the best known solutions for all but two of the
problems  it significantly outperforms genitor on r  and r   significantly under performs
on r   and does not significantly differ in performance on r  and r   rls and swo do not
perform significantly different except for r  where rls under performs  swo significantly
outperforms genitor on all five days  however  if run beyond      evaluations  genitor
continues to improve the solution quality but swo fails to find better solutions  hbss
finds best known solutions to only a few problems  for comparison  we computed the
overlaps corresponding to the schedules built using gooleys algorithm and present them
in the last column of table    however  gooleys algorithm was not designed to minimize
overlaps 
    progress toward the solution
swo and genitor apply different criteria to determine solution modifications  rls randomly chooses the first shift resulting in an equally good or improving solution  to assess
the effect of the differences  we tracked the best value obtained so far when running the
algorithms  for each problem  we collected the best value found by swo  genitor and rls
in increments of     evaluations  for      evaluations  we averaged these values over   
runs of swo  rls  and genitor  respectively 
a typical example for each objective function is presented in figures   and    for
both objective functions  the curves are similar  as is relative performance  swo quickly
finds a good solution  then its performance levels off  rls progresses quickly during the
first half of the search  while genitor exacts smaller improvements  in the second half of
the search though  rls takes longer to find better solutions  while genitor continues to
steadily progress toward the best solution  the best so far for genitor does not improve
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor
mean
     
  
    
   
    
    
    
     
     
     
     
     

sd
   
   
   
   
   
   
   
    
    
    
    
   

min
   
  
  
 
  
  
  
   
   
   
   
   

rls
mean
      
     
    
     
     
     
     
      
     
      
      
     

sd
    
    
    
    
    
   
    
     
     
     
     
    

min
   
  
  
 
  
  
  
   
   
   
   
   

swo
mean
   
    
    
    
  
    
  
     
     
     
     
     

sd
   
   
   
   
   
   
   
    
   
   
   
   

min
   
  
  
 
  
  
  
    
   
   
   
   

hbss
mean
     
    
    
    
    
    
     
      
     
     
     
     

gooley
sd
    
    
    
    
    
    
    
    
    
    
    
    

   
   
   
   
   
   
   
    
    
   
    
   

table    performance of genitor  local search  swo  hbss and gooleys algorithm in
terms of the best and mean sum of overlaps  all statistics are collected over   
independent runs  with      evaluations per run  for hbss          samples are
considered  min numbers in boldface indicate best known values 

as quickly as the best so far for rls  this is not unexpected  the best solution in the
genitor population isnt likely to improve frequently in the beginning of the run  in a
sense  tracking the evolution of the median in the population when running genitor would
be more indicative of its progress  we use the best so far to allow for a uniform comparison
of the three algorithms 
we observe two differences in the objective functions  first  when minimizing the number of conflicts  both genitor and rls eventually equal or outperform swo  for minimizing
overlaps  genitor and rls take longer to find good solutions  after      evaluations  swo
found the best solutions  second  when minimizing the number of conflicts  toward the
end of the run  genitor outperforms rls  when minimizing overlaps  rls performs better than genitor  best known solutions for the r problems when minimizing overlaps can
be obtained by running rls for        evaluations in    runs  running swo for       
evaluations in    runs results in small improvements  and on just two of the problems 

   hypotheses for explaining algorithm performance
genitor  swo and rls are the most successful algorithms we have tested on the afscn
problem  although each operate in the same search space  permutations   they traverse the
space rather differently  the puzzle is how can all three be apparently well suited to this
problem  to solve the puzzle  first  we describe why plateaus are the dominant feature of the
search space  we show that the greedy schedule builder is the main reason for the presence
of the plateaus  then  we test hypotheses that appear to follow from the dominance of the
plateaus and the characteristics of each algorithm 
in our study  the greedy schedule builder as well as the objective function are part of the
problem specification  therefore  when formulating and testing our hypotheses  we consider
the search space features  such as the plateaus or the number of identical solutions  fixed 
   

fi  

genitor
rls
swo

  

average best so far number of bumps

average best so far number of bumps

barbulescu  howe  whitley    roberts

  

  

  

  
 

   

    

    
    
    
evaluations

    

    

  
  
  
  
  
  
    

    

genitor
rls
swo

  

    

    

    
    
    
evaluations

    

    

    

figure    evolutions of the average best value for conflicts obtained by swo  rls and
genitor during      evaluations  over    runs  the left figure depicts the improvement in the average best value over the first      evaluations  the last
     evaluations are depicted in the right figure  note that the scale is different
on the y axis  the curves were obtained for r  

   

genitor
rls
swo

    

average best so far sum of overlaps

average best so far sum of overlaps

    

    
    
    
   
   
   

 

   

    

    
evaluations

    

    

    

genitor
rls
swo

   
   
   
   
   
   
   
    

    

    
    
evaluations

    

    

figure    evolutions of the average best value for sum of overlaps obtained by swo  rls
and genitor during      evaluations  over    runs  the left figure depicts the
improvement in the average best value over the first      evaluations  the last
     evaluations are depicted in the right figure  note that the scale is different
on the y axis  the curves were obtained for r  

    redundancy of the search space
more than a third of the neighbors in rls result in exactly the same schedule for both the
overlaps and minimal conflicts evaluation functions  barbulescu et al       a  barbulescu 
whitley    howe      c   more than     of neighbors in rls result in the same evaluation
 see section       the afscn search space is dominated by plateaus for three reasons 
   

fiunderstanding algorithm performance

the main reason for the presence of plateaus is the greedy schedule builder  each request
is scheduled on the first available resource from its list of possible alternatives  for example 
consider a permutation of n  from the total of n requests  if the last request x is inserted
in the first position in the permutation and the schedule builder is applied  a schedule s is
obtained  we now scan the permutation of n    requests from left to right  successively
inserting x in the second position  then the third and so on  building the corresponding
schedule  as long as none of the requests appearing before x in the permutation require
the particular spot occupied by x in s as their first feasible alternative to be scheduled  the
same schedule s will be obtained  this happens for two reasons     the requests are inserted
in the schedule in the order in which they appear in the permutation and    the greedy
schedule builder considers the possible alternatives in the order in which they are specified
and accepts the first alternative for which the request can be scheduled  let k     be the
first position to insert x that will alter s  this means that the first feasible alternative to
schedule the request in position k overlaps with the spot occupied by x in s  when x
is inserted in position k      a new schedule s  is obtained  the same schedule s  will be
built by inserting x in subsequent positions  until encountering a request for which its first
feasible alternative overlaps with the spot occupied by x in s   etc  this example also
shows that shifting in a permutation might not change the corresponding schedule 
to address the presence of the plateaus in the search space as a result of the greedy
schedule builder  we could have used some randomization scheme to diversify the scheduler 
however  randomization when implementing a schedule builder can result in problems because of the unpredictability of the value assigned to a permutation  for example  shaw and
fleming        argue that the use of randomization in a schedule builder can be detrimental to the performance of a genetic algorithm when an indirect representation is used  for
which the chromosomes are not schedules  as is the case of genitor for afscn scheduling  
they support this idea by noting that in general  genetic algorithms rely on the preservation
of the good fitness values  also  for swo  randomization in the schedule builder changes
the significance of reprioritization from one iteration to the next one  if the scheduler is
randomized  the new order of requests is very likely to result in a schedule that is not
the repaired version of the previous one  if the same permutation of requests can be
transformed into multiple different schedules because of the nondeterministic nature of the
scheduler  the swo mechanism will not operate as intended 
a second reason for the plateaus in the search space is the presence of time windows 
if a request x needs to be scheduled sometime at the end of the day  even if it appears
in the beginning of the permutation  it will still occupy a spot in the schedule towards the
end  assuming it can be scheduled  and therefore  after most of the other requests  which
appeared after x in the permutation  
a third reason is the discretization of the objective function  clearly  the range of
conflicts is a small number of discrete values  with a weak upper bound of the number
of tasks   the range for overlaps is still discrete but is larger than for conflicts  using
overlaps as the evaluation function  approximately    times more unique objective function
values are observed during search compared to searches where the objective is to minimize
conflicts  the effect of the discretization can be seen in the differing results using the two
objective functions  thus  one reason for including both in our studies is to show some of
the effects of the discretization 
   

fibarbulescu  howe  whitley    roberts

    does genitor learn patterns of request ordering 
we hypothesize that genitor performs well because it discovers which interactions between
the requests matter  we examine sets of permutations that correspond to schedules with the
best known values and identify chains of common request orderings in these permutations 
similar in spirit to the notion of backbone in sat  e g   singer et al          the presence
of such chains would support the hypothesis that genitor is discovering patterns of request
orderings  this is a classic building block hypothesis  some pattern that is present in
parent solutions contributes to their evaluation in some critical way  these patterns are
then recombined and inherited during genetic recombination  goldberg        
      common request orderings
one of the particular characteristics of the afscn scheduling problem is the presence of
two categories of requests  the low altitude requests have fixed start times and specify only
one to three alternative resources  the high altitude requests implicitly specify multiple
possible start times  because their corresponding time windows are usually longer than the
duration that needs to be scheduled  and up to    possible alternative resources  clearly
the low altitude requests are more constrained  this suggests a possible solution pattern 
where low altitude requests would be scheduled first 
to explore the viability of such a pattern  we implemented a heuristic that schedules
the low altitude requests before the high altitude ones  we call this heuristic the split
heuristic  we incorporated the split heuristic in the schedule builder  given a permutation
of requests  the new schedule builder first schedules only the low altitude requests  in the
order in which they appear in the permutation  without modifying the position of the low
altitude requests in the schedule  the high altitude requests are then inserted in the schedule 
again in the order in which they appear in the permutation  the idea of scheduling low
altitude requests before high altitude requests was the basis of gooleys heuristic        
also  the split heuristic is similar to the contention measures defined by frank et al         
some of the results we obtained using the split heuristic are surprising  when minimizing
conflicts  best known valued schedules can be obtained quickly for the a problems by simply
sampling a small number of random permutations  the results obtained by sampling    
random permutations are shown in table   
while such performance of the split heuristic does not transfer to the r problems or when
minimizing the number of overlaps  the results in table   offer some indication of a possible
request ordering pattern in good solutions  is genitor in fact performing well because it
discovers that scheduling low before high altitude requests produces good solutions 
as a more general explanation for genitors performance  we hypothesize that genitor
is discovering patterns of request ordering  certain requests that must come before other
requests  to test this  we identify common request orderings present in solutions obtained
from multiple runs of genitor  we ran      trials of genitor and selected the solutions
corresponding to best known values  first  we checked for request orderings of the form
requesta before requestb which appear in all the permutations corresponding to best
known solutions for the a problems and corresponding to good solutions for the r problems 
the results are summarized in table    the sol  value columns show the value of the
solutions chosen for the analysis  out of      solutions   the number of solutions  out of
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 

best
known
 
 
 
 
 
 
 

random sampling s
min mean stdev
 
   
    
 
 
 
 
   
    
 
    
    
 
    
    
 
   
    
 
 
 

table    results of running random sampling with the split heuristic  random samplings  in    experiments  by generating     random permutations per experiment for
minimizing conflicts 

      corresponding to the chosen value is shown in the   of solutions columns  when
analyzing the common pairs of request orderings for minimizing the number of conflicts  we
observed that most pairs specified a low altitude request appearing before a high altitude
one  therefore  we separate the pairs into two categories  pairs specifying a low altitude
request before a high altitude requests  column   low high  pair count  and the rest
 column  other pairs   for the a problems  the results clearly show that most common
pairs of ordering requests specify a low altitude request before a high altitude request  for
the r problems  more other pairs can be observed  in part  this might be due to the
small number of solutions corresponding to the same value  only    out of      for r  when
minimizing conflicts   the small number of solutions corresponding to the same value is also
the reason for the big pair counts reported when minimizing overlaps for the r problems 
we know that for the a problems the split heuristic results in best known solutions when
minimizing conflicts  therefore  the results in table   are somewhat surprising  we expected
to see more low before high common pairs of requests for the a problems when minimizing
the number of conflicts  instead  the pair counts are similar for the two objective functions 
genitor seems to discover patterns of request interaction  and most of them specify a low
altitude request before a high altitude request 
the results in table   are heavily biased by the number of solutions considered     indeed 
let s denote the number of solutions of identical value  the number in column   of solutions  
also  let n denote the total number of requests  suppose there are no preferences of orderings
between the tasks in good solutions  for a request ordering a before b there is a probability
of     that it will be present in one of the solutions  and therefore  a probability of     s that
it will be present in all s solutions  given that there exist n   n     possible precedences 
the expected number of common orderings if no preferences of orderings between tasks
exist is n n      s   for the a problems and for r   s         the expected number
of common orderings assuming no preferences of orderings between tasks exist is smaller
than n n            which is negligible  therefore  the number of actually detected common
   we wish to thank the anonymous reviewer of an earlier version of this work for this insightful observation 
the rest of the paragraph is based on his her comments 

   

fibarbulescu  howe  whitley    roberts

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

sol 
value
 
 
 
 
 
 
 
  
  
  
  
  

minimizing conflicts
  of
 low high 
solutions pair count
   
  
    
  
   
  
   
   
   
  
   
   
    
  
  
    
   
  
   
  
   
  
   
  

other
pairs
 
 
 
 
 
  
 
   
 
  
  
  

sol 
value
   
  
  
 
  
  
  
   
   
   
   
   

minimizing overlaps
  of
 low high 
solutions pair count
   
  
   
  
   
  
   
   
   
  
   
   
   
  
  
    
  
    
  
    
  
    
   
   

other
pairs
 
 
  
 
  
  
  
    
   
   
   
  

table    common pairs of request orderings found in permutations corresponding to best
known good genitor solutions for both objective functions 

precedences  approximately    to     for low before high pairs and anywhere from   to
   for the others  seem to be actual request patterns  this is also the case for the other
r problems  indeed  for example  for r   when s       the expected number of common
orderings if no preferences of orderings between tasks exist is      while the number of
actually detected precedences is      for low before high and      for the other pairs 
the experiment above found evidence to support the hypothesis that genitor solutions
exhibit patterns of low before high altitude requests  given this result  we next investigate
if the split heuristic  always scheduling low before high altitude requests  can enhance the
performance of genitor  to answer this question  we run a second experiment using genitor 
where the split heuristic schedule builder is used to evaluate every schedule generated during
the search 
table   shows the results of using the split heuristic with genitor on the r problems 
genitor with the split heuristic fails to find the best known solution for r  and r   this
is not surprising  in fact  we can show that scheduling all the low altitude requests before
high altitude requests may prevent finding the optimal solutions 
the results for minimizing sum of overlaps are shown in table    with the exception
of a   a  and a   genitor using the split heuristic fails to find best known solutions for
the a problems  for the r problems  using the split heuristic actually improves the results
obtained by genitor for r  and r   it should be noted that the r  and r  solutions are
not as good as those found by rls using      evaluation however  thus a search that
hybridizes the genetic algorithm with a schedule builder using the split heuristic sometimes
helps and sometimes hurts in terms of finding good solutions 
we attempted to identify longer chains of common request ordering  we were not successful  while genitor does seem to discover patterns of request ordering  multiple different
patterns of request orderings can result in the same conflicts  or even the same schedule  
   

fiunderstanding algorithm performance

day
r 
r 
r 
r 
r 

best
known
  
  
  
  
  

genitor with new
schedule builder
min mean stdev
  
  
 
  
  
 
  
  
 
  
  
 
  
  
 

table    minimizing conflicts  results of running genitor with the split heuristic in    trials 
with      evaluations per trial 

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

best
known
   
  
  
 
  
  
  
   
   
   
   
   

genitor with new
schedule builder
min mean stdev
   
   
   
  
  
   
  
  
   
 
 
   
  
  
   
  
  
   
  
  
   
               
               
               
              
   
   
   

table    minimizing sum of overlaps  results of running genitor with the split heuristic
using the split heuristic schedule builder to evaluate each schedule  the results
are based on    experiments  with      evaluations per experiment 

we could think of these patterns as building blocks  genitor identifies good building blocks
 orderings of requests resulting in good partial solutions  and propagates them into the final
population  and the final solution   such patterns are essential in building a good solution 
however  the patterns are not ubiquitous  not all of them are necessary  and  therefore 
attempts to identify them across different solutions produced by genitor have failed 
   

fibarbulescu  howe  whitley    roberts

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

minimizing conflicts
best known min mean stdev
 
 
   
   
 
 
   
   
 
 
    
    
 
 
    
    
 
 
    
    
 
 
    
    
 
 
   
   
  
         
    
  
  
    
   
  
         
    
  
  
     
    
  
  
    
   

minimizing overlaps
best known min mean stdev
   
          
    
  
  
     
    
  
  
     
    
 
 
     
    
  
  
     
    
  
  
    
    
  
  
     
    
   
                
   
   
     
   
   
   
     
    
   
                
   
          
    

table    statistics for the results obtained in    runs of swo initialized with random
permutations  i e   randomstartswo   with      evaluations per run  the mean
and best value from    runs as well as the standard deviations are shown  the
entries with a  indicate values that are better than the corresponding swo values 
for each problem  the best known solution for each objective function is also
included 

    is swos performance due to initialization 
the graphs of search progress for swo  figures   and    show that it starts with much
better solutions than do the other algorithms  the initial greedy solution for swo translated into best known values for five problems  a   a   a   a  and r   when minimizing
the number of conflicts and for two problems  a  and r   when minimizing overlaps 
how important is the initial greedy permutation for swo  to answer this question  we
replaced the initial greedy permutation  and its variations in subsequent iterations of swo 
with random permutations and then used the swo mechanism to iteratively move forward
the requests in conflict  we call this version of swo randomstartswo  we compared the
results produced by randomstartswo with results from swo to assess the effects of the
initial greedy solution  the results produced by randomstartswo are presented in table   
the entries with a  indicate that randomstartswo produced a better result than swo 
with the exception of r   when minimizing the number of conflicts  best known values are
obtained by randomstartswo for all the problems  in fact  for r  and r   the best results
obtained are slightly better than the best found by swo  when minimizing the sum of
overlaps  best known values are obtained for the a problems  only for the r problems  the
performance of swo worsens when it is initialized with a random permutation  however 
randomstartswo still performs better or as well as genitor  with the exception of r 
when minimizing the number of conflicts and r  for overlaps  for both objective functions 
these results suggest that the initial greedy permutation is not the main performance factor
for swo  the performance of randomstartswo is competitive with that of genitor 
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

total
neighbors
      
     
     
      
     
     
     
      
      
      
      
      

minimizing
random perms
mean
avg  
       
    
       
    
     
    
     
    
     
    
       
    
       
    
      
    
      
    
      
    
      
    
      
    

conflicts
optimal perms
mean
avg  
       
    
       
    
       
    
       
    
       
    
       
    
       
    
      
    
      
    
      
    
      
    
      
    

minimizing
random perms
mean
avg  
       
    
       
    
       
    
       
    
       
    
       
    
     
    
      
    
      
    
      
    
      
    
      
    

overlaps
optimal perms
mean
avg  
       
    
       
    
       
    
     
    
       
    
       
    
       
    
      
    
      
    
      
    
      
    
      
    

table    statistics for the number of neighbors resulting in schedules of the same value
as the original  over    random and optimal permutations  for both objective
functions

    is rls performing a random walk 
rls spends most of the time traversing plateaus in the search space  by accepting nonimproving moves   in this section  we study the average length of random walks on the
plateaus encountered by local search  we show that as search progresses the random walks
become longer before finding an improvement  mirroring the progress of rls  we note that
a similar phenomenon has been observed for sat  frank  cheeseman    stutz        
more than a third of all shifting pairs of requests result in schedules identical with
the current solution  barbulescu et al       a      c   however  an even larger number of
neighbors result in different schedules with the same value as the current solution  this
means that most of the accepted moves during search are non improving moves  search ends
up randomly walking on a plateau until an exit is found  we collected results about the
number of schedules with the same value as the original schedule  when perturbing the solutions in all possible pairwise changes  note that these schedules include the ones identical
with the current solution  the results are summarized in table    we report the average
percentage of neighbors identical in value with the original permutation  the results show
that     more than     of the shifts result in schedules with the same value as the original one  when minimizing conflicts  when minimizing overlaps  more than      usually
around      of the shifts result in same value schedules     best known solutions have
slightly more same value neighbors than do random permutations  the difference is statistically significant when minimizing overlaps  this suggests that the plateaus corresponding
to good values in the search space might be larger in size than the plateaus corresponding
to random permutations 
to assess the size of the plateaus and their impact on rls  we performed random walks
at fixed intervals during rls  at every     evaluations of rls  we identified the current
   

fibarbulescu  howe  whitley    roberts

solution crt  for each such crt  we performed     iterations of local search starting from
crt and stopping as soon as a better solution or a maximum number of equally good
solutions were encountered  for the a problems  best known solutions are often found early
in the search  most of the     iterations of local search started from such a crt would reach
the maximum number of equally good solutions  therefore  we chose a limit of      steps
on the plateau for the a problems and      steps for the r problems  we averaged the
number of equally good solutions encountered during the     trials of search performed for
each crt  this represents the average number of steps needed to find an exit from a plateau 
figure   displays the results obtained for r   similar behavior was observed for the rest
of the problems  note that we used a log scale on the y axis for the graph corresponding to
minimizing overlaps  most of the     walks performed from the current solution of value    
end up taking the maximum number of steps allowed        without finding an exit from the
plateau  also  the random walk steps counts only equal moves  the number of evaluations
needed by rls  x axis  is considerably higher due to needing to check detrimental moves
before accepting equal ones  the results show that large plateaus are present in the search
space  improving moves lead to longer walks on lower plateaus  which when detrimental
moves are factored in  appears to mirror the performance of rls 
    

     

ls

   

   

ls
       

    
  

  

    
  

  

    
   

  

  

   
  

  

  

    
average number steps plateau

average number steps plateau

    

  

  

  

  

   

   
   

   

   

   

   

   

   

   
    

   

  

   

    
   
 

  
  
 

  
    

    

    

    
evals

    

    

    

    

 

 

    

    

    

    
evals

    

    

    

    

figure    average length of the random walk on plateaus when minimizing conflicts  left 
or overlaps  right  for a single local search run on r   the labels on the graphs
represent the value of the current solution  note the log scale on the y axis for
the graph corresponding to minimizing overlaps  the best known value for this
problem is    when minimizing conflicts and     when minimizing overlaps 

for the afscn scheduling problems  most of the states on a plateau have at least one
neighbor that has a better value  this neighbor represents an exit   however  the number of
such exits is a very small percentage of the total number of neighbors  and therefore  local
search has a very small probability of finding an exit  using the terminology introduced
by frank et al          most of the plateaus encountered by search in the afscn domain
would be classified as benches  meaning that exits to states at lower levels are present  if
there are no exits from a plateau  the plateau is a local minimum  determining which of the
plateaus are local minima  by enumerating all the states on the plateau and their neighbors 
   

fiunderstanding algorithm performance

is prohibitive because of the large size of the neighborhoods and the large number of equally
good neighbors present for each state in the search space  instead  we focus on the average
length of the random walk on a plateau as a factor in local search performance  the length
of the random walk on the plateau depends on two features  the size of the plateau and
the number of exits from the plateau  preliminary investigations show that the number of
improving neighbors for a solution decreases as the solution becomes better   therefore we
conjecture that there are more exits from higher level plateaus than from the lower level
ones  this would account for the trend of needing more steps to find an exit when moving
to lower plateaus  corresponding to better solutions   it is also possible that the plateaus
corresponding to better solutions are larger in size  however  enumerating all the states on
a plateau for the afscn domain is impractical  following a technique developed by frank
et al         just the first iteration of breadth first search would result in approximately
      n      states on the same plateau  
    are long leaps instrumental 
as in other problems with large plateaus  e g   research published by gent and walsh 
     on sat   we hypothesize that long leaps in the search space are instrumental for an
algorithm to perform well on afscn scheduling  swo is moving forward multiple requests
that are known to be problematic  the position crossover mechanism in genitor can be
viewed as applying multiple consecutive shifts to the first parent  such that the requests in
the selected positions of the second parent are moved into those selected positions of the
first  in a sense  each time the crossover operator is applied  a multiple move is proposed for
the first parent  we hypothesize that this multiple move mechanism present in both swo
and genitor allows them to make long leaps in the space and thus reach solutions fast 
note that if we knew exactly which requests to move  moving forward only a small
number of requests  or even only one  might be all that is needed to reach the solutions
quickly  finding which requests to move is difficult  in fact we studied the performance of
a more informed move operator that only moves requests into positions which guarantee
schedule changes  roberts et al          we found surprising results  the more informed
move operator performs worse than the random unrestricted shift employed by rls  we
argue that the multiple moves are a desired algorithm feature as they make it more likely
that one of the moves will be the right one 
to investigate our hypothesis about the role of multiple moves when traversing the
search space  we perform experiments with a variable number of moves at each step for
both genitor and swo  for genitor  we vary the number of crossover positions allowed 
for swo  we vary the number of requests in conflict moved forward 
      the effect of multiple moves on genitor
to test the effect of multiple moves on genitor  we change syswerdas position crossover
by imposing a fixed number of selected positions in the second parent  see section     for a
description of syswerdas position crossover   we call this implementation genitor k where
k is the number of selected positions  recall that our implementation of syswerdas position
crossover randomly selects a number of positions that is larger than one third and smaller
than two thirds of the total number of positions  if multiple moves are indeed a factor in
   

fibarbulescu  howe  whitley    roberts

average best so far sum of overlaps

    

genitor
genitor   
genitor   
genitor    
genitor    
genitor    
genitor    

    
    
    
    
    
    
    
    

 

   

    

              
evaluations

average best so far sum of overlaps

    

    

    

    

genitor
genitor   
genitor   
genitor    
genitor    
genitor    
genitor    

    
    
    
    
    
    
   
    

    

    

              
evaluations

    

    

    

figure    evolutions of the average best value obtained by genitor and its versions with a
fixed number of selected positions for crossover  during      evaluations  over   
runs  the graphs were obtained for r   best solution value is     

performance then increasing the number of selected positions up to a point should result in
finding improvements faster  if only a few positions are selected  the offspring will be very
similar to the first parent  if the number of selected positions is large  close to the number
of total requests  the offspring will be very similar to the second parent  if the offspring is
very similar to one of its two parents  we expect a slower rate in finding improvements to the
current best solution  therefore  both for small and for large k values  we expect genitor k
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
  
 
 
 
 
 
 
  
  
  
  
  

genitor   
mean stdev
     
    
    
    
    
    
     
   
   
    
     
   
    
    
    
    
     
    
    
    
    
    
     
    

min
 
 
 
 
 
 
 
  
  
  
  
  

genitor   
mean stdev
    
    
    
    
    
    
    
    
    
    
    
    
   
    
    
    
     
    
    
    
     
    
     
    

min
 
 
 
 
 
 
 
  
  
  
  
  

genitor    
mean stdev
    
    
   
   
   
   
    
    
    
    
    
    
   
   
     
    
    
    
     
    
     
    
     
    

genitor    
min mean stdev
 
    
   
 
   
   
 
   
   
 
    
    
 
   
   
 
    
    
 
   
   
  
     
    
  
    
    
  
     
    
  
    
   
  
    
   

table     performance of genitor k  where k represents the fixed number of selected positions for syswerdas position crossover  in terms of the best and mean number
of conflicts  statistics are taken over    independent runs  with      evaluations
per run  min numbers in boldface indicate best known values 

to find improvements at a much slower rate than genitor or genitor k with average k values
 values closer to half of the number of requests  
for our study  we run genitor k with k                                 and      we
allowed      evaluations per run and performed    runs for each problem  the results are
summarized in tables    and    for minimizing the number of conflicts and in tables   
and    for minimizing the sum of overlaps  note that for a  and a  there are     and    
requests to schedule respectively  therefore genitor k with k       and k       cannot be
run for these two problems  also note that for example  k       does not mean that there
are     differences in the selected positions between the two parents  the offspring is likely
to be very similar to its parents  regardless of the value of k  when the parents are similar 
when minimizing the number of conflicts  the worst results are produced by k       for
k       the results improve  best knowns are found for all of the a problems  however  for r  
r   and r   the best knowns are not found  starting with k       up to k       genitor k
finds best known solutions for all the problems  the means and standard deviations are also
very similar for all these k values  the smallest means and standard deviations correspond
to k       for the a problems and k       for the r problems  with the exception of r 
for which k       produces better results   for k        the best knowns are not found
anymore for the a problems      is very close to the size of the five a problems for which
it is feasible to run genitor      the decay in performance is not as significant for the r
problems  there is an increase in the means and standard deviations for k       and k       
however  best knowns are still found for four out of the five problems  note that k      
would have been a lot closer to the total number of requests for the r problems  we believe
the performance would have degraded more for the r problems for larger k values  when
minimizing overlaps  we observe trends that are very similar to the ones for minimizing the
number of conflicts  k      produces poor results  followed by k       similar results are
   

fibarbulescu  howe  whitley    roberts

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
 
 
 
 
 
 
 
  
  
  
  
  

genitor    
mean stdev
    
    
   
   
   
   
   
   
   
    
    
    
   
   
     
    
     
    
     
   
     
    
    
   

min
 
 
 
 
 
 
 
  
  
  
  
  

genitor    
mean stdev
   
   
    
    
    
    
    
    
    
    
   
    
    
    
     
    
    
    
    
    
  
   
     
    

min
 
 
 
 
  
  
  
  
  
  

genitor    
mean stdev
    
    
     
    
   
   
    
    
     
    
     
    
    
    
     
    
     
    
     
    

genitor    
min mean stdev
  
     
    
  
     
    
  
     
   
  
     
    
  
    
    

table     performance of genitor k  where k represents the fixed number of selected positions for syswerdas position crossover  in terms of the best and mean number
of conflicts  statistics are collected over    independent runs  with      evaluations per run  min numbers in boldface indicate best known values  the
dashes indicate that the permutation solutions for a  and a  are shorter than
         and      respectively   and therefore cannot select     positions in these
permutations 

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
   
  
  
  
  
  
  
    
   
   
   
   

genitor   
mean stdev
      
     
     
     
      
     
     
     
    
     
      
     
      
     
              
      
     
     
     
       
     
      
    

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor   
mean stdev
            
     
    
     
    
     
   
     
    
    
    
    
    
            
      
    
            
            
            

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor    
mean stdev
     
    
     
    
    
    
    
    
     
    
     
   
    
    
            
     
    
           
            
      
    

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor    
mean stdev
     
    
     
    
     
    
    
    
     
   
     
    
     
   
            
            
           
           
      
    

table     performance of genitor k  where k represents the fixed number of selected positions for syswerdas position crossover  in terms of the best and mean sum of
overlaps  statistics are collected over    independent runs  with      evaluations
per run  min numbers in boldface indicate best known values 

produced by k                       k       results in the smallest means and standard
deviations for the a problems  while k       and k       produce best results for the r
problems  for k       and k        similarly to minimizing the number of conflicts  the
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor    
mean stdev
     
    
    
    
    
   
   
   
    
   
     
   
     
   
           
            
            
           
       
    

min
   
  
  
 
  
  
  
   
   
   
   
   

genitor    
mean stdev
      
    
    
   
     
    
     
    
     
    
     
    
     
    
            
            
            
            
      
   

min
   
   
  
  
  
   
   
   
   
   

genitor    
mean stdev
            
            
            
           
           
     
    
            
      
    
         
     
    

min
   
   
   
   
   

genitor    
mean stdev
            
      
    
            
            
   
    

table     performance of genitor k  where k represents the fixed number of selected positions for syswerdas position crossover  in terms of the best and mean sum of
overlaps  statistics are taken over    independent runs  with      evaluations
per run  min numbers in boldface indicate best known values 

means and standard deviations increase and so do the best solutions found  best knowns
are only found for r  
in terms of the evolution to the solution  we observe very similar trends for the two
objective functions  a typical examples is presented in figure    minimizing overlaps for
r    genitor k with k      is slower in finding improvements than k      which is slower
than k        k       up to k       are performing similarly and also similar to the
original genitor implementation  k       is still moving through the space at a rate thats
similar to genitors  only for k       does the performance start to decay 
the original implementation of the crossover operator  with a variable number of selected position  was shown to work well not only for our domain but also for other scheduling
applications  syswerda        watson  rana  whitley    howe        syswerda   palmucci         for our test problems  the results in this subsection show that the number of
crossover positions influences the performance of genitor  both in terms of best solutions
found and in terms of the rate of finding improvements  for a small number of crossover
positions     or      the solutions found are not competitive  and the improvements are
found at a slower rate than in the original genitor implementation  similarity to genitors
original performance is obtained for k values between     and      higher k values result
in a decay in performance  these results also offer an empirical motivation for the choice
of the number of crossover positions in the original genitor implementation  indeed  in
the original implementation  the crossover uses a number of positions randomly selected
between one third and two thirds of the total number of requests  this translates for the
sizes of problems in our sets to a number of positions that is approximately between    
and     
   

fibarbulescu  howe  whitley    roberts

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

minimizing conflicts
min mean stdev
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
        
   
       
   
     
 
       
   
     
 

minimizing overlaps
min mean stdev
       
 
     
 
     
 
 
 
 
     
 
     
 
     
 
              
             
             
              
       
 

table     performance of a modified version of swo where only one request is moved
forward for a constant distance    for both minimizing conflicts and minimizing
the sum of overlaps  the request is randomly chosen  all statistics are collected
over    independent runs  with      evaluations per run  a  indicates that the
best value is better than the corresponding swo result  min numbers in boldface
indicate best known values 

      the effect of multiple moves on swo
we hypothesize that the multiple moves present in swo are necessary for its performance 
to test this hypothesis  we start by investigating the effect of moving forward only one
request  this is somewhat similar to the shifting operator present in rls  a request is shifted
forward in the permutation  however  to implement the swo reprioritization mechanism 
we restrict both the chosen request to be moved and the position where it gets moved  for
minimizing the conflicts  one of the bumped requests is randomly chosen  for minimizing
overlaps  one of the requests contributing to the sum of overlaps is randomly chosen  for
both minimizing the conflicts and minimizing the sum of overlaps the chosen request is
moved forward for a constant distance of five      we call this new algorithm swo move 
the results obtained by running swo move for    runs with      evaluations per run are
presented in table     the entries with a  indicate that the value produced by swo move
is better than the corresponding swo result  the initial solutions are identical to the
solutions produced using the flexibility heuristic for initializing swo 
when minimizing conflicts  swo move performs as well as swo  in fact  it finds the
best known solution for r  as well   when minimizing the sum of overlaps  the performance
of swo for the r problems worsens significantly when only one task is moved forward  previously  we implemented swo move for minimizing overlaps by moving forward the request
that contributes most to the total overlap  barbulescu et al       c   randomly choosing
    we tried other values  on average  a value of five seems to work best 

   

fiunderstanding algorithm performance

day
r 
r 
r 
r 

min
   
   
   
   

k   
mean
     
     
      
      

stdev
     
    
    
    

min
   
   
   
   

k   
mean
      
      
     
     

stdev
    
    
    
    

min
   
   
   
   

k   
mean
      
      
      
      

stdev
    
    
    
   

min
   
   
   
   

k   
mean
      
      
     
     

stdev
    
    
    
    

table     performance of a modified version of swo where k of the requests contributing
to the sum of overlaps are moved forward for a constant distance    all statistics
are collected over    independent runs  with      evaluations per run 

the request to be moved forward improved the performance of swo move  randomization
is useful because swo can become trapped in cycles  joslin   clements         however 
the improvement is not enough to equal the performance of swo when minimizing overlaps
for the new days of data  in fact  longer runs of swo move with a random choice of the
request to be moved     runs with        evaluations  produce solutions that are still worse
than those obtained by swo  these results support the conjecture that the performance
of swo is due to the simultaneous moves of requests 
we attribute the discrepancy in the swo move performance for the two objective
functions to the difference in the discretization of the two search spaces  when minimizing
conflicts  swo move only needs to identify the requests that cannot be scheduled  more
fine tuning is needed when minimizing the sum of overlaps  besides identifying the requests
that cannot be scheduled  swo move also needs to find the positions for these requests in
the permutation such that the sum of overlaps is minimized  we conjecture that this fine
tuning is achieved by simultaneously moving forward multiple requests 
next  we investigate the changes in performance when an increasing number of requests
 from the requests contributing to the objective function  are moved forward  we design
an experiment where a constant number of the requests involved in conflicts are moved
forward  to do this  we need to decide how many requests to move and which ones  moving
two or three requests forward results in small improvements over the results in table    
therefore  we run multiple versions of swo moving k requests forward  with k          
        we determined empirically that when moving multiple requests  more than five 
forward  choosing them at random as opposed to based on their contribution to the sum
of overlaps hurts algorithm performance  to determine which requests are moved forward 
at each step we sort the requests contributing to the sum of overlaps in decreasing order of
their contribution and only move forward the first k  or all of them  if k is greater than the
number of requests contributing to the sum of overlaps  
the results obtained for r   r   r  and r  are summarized in table     for the a
problems  all these new swo versions find best known solutions  we did not include r 
in this study because the swo greedy initial permutation computed for r  corresponds to
a best known value schedule  the results show a general performance improvement as k
grows from    to     k      and k      produce similar performance for r   r  and r  
for r   k      results in better performance than k       k      results in worsening
performance for r  and r   note that the algorithm performance for r  does not change
   

fibarbulescu  howe  whitley    roberts

when k        this is not surprising  since good solutions  in terms of overlaps  for this
problem correspond to schedules with a small number of overlapping tasks  moving forward
   requests or more means moving most of the requests in conflict once good solutions are
found  the results indicate that for the problems in our set  when minimizing overlaps  if
swo is allowed to only move forward a constant number k of requests  k      seems to be
a good choice 
the results in this section support the hypothesis that moving multiple requests forward
is necessary to obtain good swo performance  first  we showed that moving only one
request forward  or a small number of requests  smaller than    for the r problems  results
in inferior swo performance  second  as the number of requests moved forward is increased
 from    up   the performance of swo improves 

   new algorithm  attenuated leap local search
the empirical data and analyses suggest that the key to competitive performance on this
application is moving as quickly as possible across the plateaus  two of the competitive
algorithms  genitor and swo  perform multiple moves  a simpler algorithm  rls  actually
finds more best known solutions in      evaluations  even though it does not perform multiple moves  rls does however  perform a significant number of neutral moves between
solutions with the same evaluation  given this  we conjecture that a version of local search
that performs multiple moves before evaluating the result may be even better suited to this
application  the intuition behind this conjecture is that the search should sample at greater
distances  i e   longer than a single move  to more quickly find exits from plateaus 
we modified the rls move operator as follows  choose a number of pairs of positions
and apply shifting to these pairs  one after another  without building the schedule after
each shift  build the schedule only after shifting has been applied for the designated number
of pairs  in our first version  we tried a static number of shifts     turned out to be the
best value   however  it performed no better and sometimes worse than the original move
operator  we next conjectured that as search progresses to better solutions  the number
of shifts should also decrease because the probability of finding detrimental moves  rather
than improving  increases significantly as well  the better the solution  the fewer exits are
expected and the harder they are to find 
we implemented a multiple move hill climber with a variable move count operator  given
a decay rate  we start by shifting ten requests  then nine  eight etc  we chose to decrement
the number of shifts for every     evaluations  we call this version of hill climbing attenuated
leap local search  alls   this is similar to the idea behind the temperature dependent
hill climbing move operator implemented by globus et al          for which the number of
requests to move is chosen by random but biased such that a large number of requests are
moved early in the search while later only a few requests are moved      hill climbing with
the temperature dependent operator produced better results for eos than simply choosing
a random number of requests to move 
alls performs remarkably well  as shown in table     it finds best known values
for all problems using conflicts and all but two of the problems using overlaps  as does
    the operator is similar to the temperature dependent behavior in simulated annealing  this explains the
name of the operator 

   

fiunderstanding algorithm performance

average best so far number of bumps

  

genitor
rls
swo
alls

  
  
  
  
  
  
  
  
  

 

   

    

    
    
    
evaluations

average best so far number of bumps

  

    

    

    

genitor
rls
swo
alls

    
  
    
  
    
  
    
  
    

    

    

              
evaluations

    

    

    

figure    evolutions of the average best value obtained by genitor  rls  swo and alls
during      evaluations  over    runs  the improvement over the first     
evaluations is shown in the top figure  the last      evaluations are depicted in
the bottom figure  note that the scale is different on the y axis  the graphs were
obtained for r   best solution value is    
rls   additionally  it finds better best values than all the algorithms in our set for the
two problems with non best solutions  in fact  a single tailed  two sample t test comparing
alls to rls shows that alls finds statistically significantly better solutions  p         
on both conflicts and overlaps for the five more recent days 
   

fibarbulescu  howe  whitley    roberts

average best so far number of overlaps

    

genitor
rls
swo
alls

    
    
    
    
    
    
    
   
   
   

 

   

    

              
evaluations

average best so far number of overlaps

   

    

    

    

genitor
rls
swo
alls

   
   
   
   
   
   
   
   
   
    

    

    

              
evaluations

    

    

    

figure    evolutions of the average best value obtained by genitor  rls  swo and alls
during      evaluations  over    runs  the improvement over the first     
evaluations is shown in the top figure  the last      evaluations are depicted in
the bottom figure  note that the scale is different on the y axis the graphs were
obtained for r   best solution value is     
in section    we discussed a comparison across all algorithms  again at p          
under this much more restrictive performance comparison  alls still outperforms rls 
swo and genitor for most of the pair wise tests  both when minimizing conflicts and when
minimizing overlaps  alls significantly outperforms all other algorithms on r   when
   

fiunderstanding algorithm performance

day
a 
a 
a 
a 
a 
a 
a 
r 
r 
r 
r 
r 

minimizing conflicts
min mean stdev
 
   
   
 
   
   
 
   
   
 
    
    
 
   
   
 
   
   
 
   
   
        
    
  
    
   
  
    
    
        
    
  
    
   

minimizing overlaps
min mean stdev
         
    
  
    
   
  
     
   
 
    
    
  
     
    
  
    
   
  
    
   
                
                
                
                
               

table     statistics for the results obtained in    runs of alls  with       evaluations per
run  the best and mean values as well as the standard deviations are shown 
bold indicates best known values 

minimizing conflicts  alls outperforms for all but five of the twelve pair wise tests on the
other four days  for which the difference was not significant   the exceptions are  r   r  
r   and r  for genitor and r  for rls  when minimizing overlaps  alls significantly
outperforms genitor for r   rls for r   genitor for r  and swo for r   the rest of the
pair wise comparisons were not statistically significant at p          it is clear that alls
is at least as good as the best algorithms and outperforms them on most days of data 
alls also finds improving solutions faster than both genitor and rls  see figures  
and   for r  on both conflicts and overlaps   alls achieves such good performance by
combining the power of finding good solutions fast using multiple moves in the beginning
of the search with the accuracy of locating the best solutions using one move shifting at the
end of the search 
in     we showed that as the solutions improve the random walks on plateaus become
longer  two hypotheses support this observation     the plateaus are bigger    the plateaus
are harder to escape because there are fewer exits  these two hypotheses are consistent if
the missing exits are replaced by moves of equal value  they are not consistent if the exits
are replaced by worse moves  our alls design implicitly assumes the latter  if the exits
were replaced by equal moves then as the search progresses more moves would be needed
per each large step     in fact  we ran some tests where we increased the number of moves
as search progresses and we found that this can significantly worsen the performance  for
example  for r  when minimizing overlaps  shifting initially ten requests and then increasing
the number of shifted requests by   every     iterations  instead of decreasing it as in alls 
    we wish to thank the anonymous reviewer for this insightful observation 

   

fibarbulescu  howe  whitley    roberts

results in a minimum overlap of      with a mean of        and a standard deviation of
       which is significantly worse than the corresponding alls result 

   conclusion
a key algorithm characteristic for afscn appears to be multiple moves  in fact  this
observation might hold for other oversubscribed scheduling problems as well  globus et
al   globus et al         found that when solving the oversubscribed problem of scheduling
fleets of eos using hill climbing  moving only one request at a time was inefficient  their
temperature dependent hill climbing operator proved to work better than simply choosing
a random number of requests to move  as in our domain  a permutation representation and
a greedy deterministic schedule builder are used  we conjecture that their schedule builder
also results in multiple permutations being mapped to the same schedule  and therefore
that plateaus are present in the eos search space as well  the fact that moving more
than one request improved the results suggests that our conjecture could also hold for eos
scheduling  multiple moves might speed up plateau traversal for this domain as well 
we developed and tested four hypotheses explaining the performance of three competitive algorithms for a real scheduling application  we found that all of the hypotheses held
to varying degrees  based on the evidence  we designed a new algorithm that combined
what appeared to be critical elements of the best performing algorithms and produced an
algorithm that performed better than the original ones  our results suggest that multiple moves are a useful algorithm feature to obtain good performance results for afscn
scheduling  alternatively  it is possible that in fact only one move during each iteration
would be enough to obtain good performance  but it is difficult to identify which request to
move  future research in this direction will examine heuristics such as combining hbss and
swo to decide which request to move forward  as well as heuristics to find where to move
the request to guarantee a change in the schedule  also as future research  we will be testing
other oversubscribed scheduling applications to determine to what extent our analyses and
results generalize  do they exhibit the same characteristics and are they amenable to the
same kind of solution 

acknowledgments

this research was supported in part by a grant from the air force office of scientific research  air force materiel command  usaf under grant number f                 adele
howe was also supported by the national science foundation under grant no  iis         
any opinions  findings  and conclusions or recommendations expressed in this material are
those of the author s  and do not necessarily reflect the views of the national science
foundation  the u s  government is authorized to reproduce and distribute reprints for
governmental purposes notwithstanding any copyright notation thereon 
   

fiunderstanding algorithm performance

references
ackley  d          a connectionist machine for genetic hillclimbing  kluwer academic
publishers 
aickelin  u     dowsland  k          an indirect genetic algorithm for a nurse scheduling
problem  computers   operations research                 
barbulescu  l   howe  a   whitley  l     roberts  m       a   trading places  how to
schedule more in a multi resource oversubscribed scheduling problem  in proceedings
of the international conference on planning and scheduling  whistler  ca 
barbulescu  l   watson  j   whitley  d     howe  a       b   scheduling space ground
communications for the air force satellite control network  journal of scheduling 
       
barbulescu  l   whitley  l     howe  a       c   leap before you look  an effective strategy
in an oversubscribed problem  in proceedings of the nineteenth national artificial
intelligence conference  san jose  ca 
beck  j   davenport  a   davis  e     fox  m          the odo project  toward a unified
basis for constraint directed scheduling  journal of scheduling           
bresina  j          heuristic biased stochastic sampling  in proceedings of the thirteenth
national conference on artificial intelligence  pp          portland  or 
burrowbridge  s  e          optimal allocation of satellite network resources  in masters
thesis  virginia polytechnic institute and state university 
chien  s   rabideau  g   knight  r   sherwood  r   engelhardt  b   mutz  d   estlin  t  
smith  b   fisher  f   barrett  t   stebbins  g     tran  d          aspen   automating space mission operations using automated planning and scheduling  in  th
international spaceops symposium  space operations   toulouse  france  
cormen  t   leiserson  c     rivest  r          introduction to algorithms  mit press 
cambridge  ma 
deale  m   yvanovich  m   schnitzuius  d   kautz  d   carpenter  m   zweben  m   davis 
g     daun  b          the space shuttle ground processing scheduling system  in
zweben  m     fox  m   eds    intelligent scheduling  pp          morgan kaufmann 
forrest  s     mitchell  m          relative building block fitness and the building block
hypothesis  in whitley  l  d   ed    foundations of genetic algorithms    pp     
     morgan kaufmann 
frank  j   cheeseman  p     stutz  j          when gravity fails  local search topology 
journal of artificial intelligence research            
frank  j   jonsson  a   morris  r     smith  d          planning and scheduling for fleets
of earth observing satellites  in proceedings of the sixth international symposium on
artificial intelligence  robotics  automation and space 
gent  i     walsh  t          unsatisfied variables in local search  in hybrid problems 
hybrid solutions  pp        ios press amsterdam 
   

fibarbulescu  howe  whitley    roberts

globus  a   crawford  j   lohn  j     pryor  a          scheduling earth observing satellites
with evolutionary agorithms  in international conference on space mission challenges for information technology  pasadena  ca 
globus  a   crawford  j   lohn  j     pryor  a          a comparison of techniques for
scheduling earth observing satellites  in proceedings of the sixteenth innovative applications of artificial intelligence conference  san jose  ca 
goldberg  d          genetic algorithms in search  optimization and machine learning 
addison wesley  reading  ma 
gooley  t          automating the satellite range scheduling process  in masters thesis 
air force institute of technology 
jang  k          the capacity of the air force satellite control network  in masters
thesis  air force institute of technology 
johnston  m     miller  g          spike  intelligent scheduling of hubble space telescope
observations  in morgan  m  b   ed    intelligent scheduling  pp          morgan
kaufmann publishers 
joslin  d  e     clements  d  p          squeaky wheel optimization  in journal of
artificial intelligence research  vol      pp         
kramer  l     smith  s          maximizing flexibility  a retraction heuristic for oversubscribed scheduling problems  in proceedings of   th international joint conference
on artificial intelligence  acapulco  mexico 
lematre  m   verfaillie  g     jouhaud  f          how to manage the new generation of
agile earth observation satellites  in  th international spaceops symposium  space
operations   toulouse  france 
parish  d          a genetic algorithm approach to automating satellite range scheduling  in masters thesis  air force institute of technology 
pemberton  j          toward scheduling over constrained remote sensing satellites  in
proceedings of the second nasa international workshop on planning and scheduling
for space  san francisco  ca 
rabideau  g   chien  s   willis  j     mann  t          using iterative repair to automate
planning and scheduling of shuttle payload operations  in innovative applications of
artificial intelligence  iaai      orlando fl 
roadef challenge        
french society of operations research and decision analisys roadef challenge      
http   www prism uvsq fr 
vdc roadef challenges       
roberts  m   whitley  l   howe  a     barbulescu  l          random walks and neighborhood bias in oversubscribed scheduling  in multidisciplinary international conference
on scheduling  mista      new york  ny 
schalck  s          automating satellite range scheduling  in masters thesis  air force
institute of technology 
   

fiunderstanding algorithm performance

shaw  k     fleming  p          use of rules and preferences for schedule builders in
genetic algorithms for production scheduling  proceedings of the aisb   workshop
on evolutionary computation  lecture notes in computer science               
singer  j   gent  i     smaill  a          backbone fragility and the local search cost
peak  in journal of artificial intelligence research  vol      pp         
smith  s     cheng  c          slack based heuristics for constraint satisfaction problems 
in proceedings of the eleventh national conference on artificial intelligence  aaai     pp          washington  dc  aaai press 
starkweather  t   mcdaniel  s   mathias  k   whitley  d     whitley  c          a comparison of genetic sequencing operators  in booker  l     belew  r   eds    proc  of
the  th intl  conf  on gas  pp        morgan kaufmann 
syswerda  g          schedule optimization using genetic algorithms  in davis  l   ed   
handbook of genetic algorithms  chap      van nostrand reinhold  ny 
syswerda  g     palmucci  j          the application of genetic algorithms to resource
scheduling  in booker  l     belew  r   eds    proc  of the  th intl  conf  on gas 
morgan kaufmann 
watson  j  p   rana  s   whitley  d     howe  a          the impact of approximate evaluation on the performance of search algorithms for warehouse scheduling  journal
of scheduling             
whitley  d   starkweather  t     fuquay  d          scheduling problems and traveling
salesmen  the genetic edge recombination operator  in schaffer  j  d   ed    proc 
of the  rd intl  conf  on gas  morgan kaufmann 
whitley  l  d          the genitor algorithm and selective pressure  why rank based
allocation of reproductive trials is best  in schaffer  j  d   ed    proc  of the  rd
intl  conf  on gas  pp          morgan kaufmann 
wolfe  w  j     sorensen  s  e          three scheduling algorithms applied to the earth
observing systems domain  in management science  vol         pp         
zweben  m   daun  b     deale  m          scheduling and rescheduling with iterative
repair  in zweben  m     fox  m   eds    intelligent scheduling  morgan kaufmann 

   

fi