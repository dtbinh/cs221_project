journal artificial intelligence research                  

submitted        published      

local consistency sat solvers
peter jeavons
justyna petke

peter jeavons cs ox ac uk
justyna petke cs ox ac uk

department computer science  university oxford
wolfson building  parks road  oxford  ox   qd  uk

abstract
local consistency techniques k consistency key component specialised
solvers constraint satisfaction problems  paper show power
using k consistency techniques constraint satisfaction problem precisely captured
using particular inference rule  call negative hyper resolution  standard
direct encoding problem boolean clauses  show current clauselearning sat solvers discover expected polynomial time inconsistency
deduced given set clauses using negative hyper resolvents fixed size 
combine two results show that  without explicitly designed so  current
clause learning sat solvers efficiently simulate k consistency techniques  fixed values
k  give experimental results show feature allows clause learning
sat solvers efficiently solve certain families constraint problems challenging
conventional constraint programming solvers 

   introduction
one oldest central ideas constraint programming  going right back
montanaris original paper       idea using local consistency techniques prune
search space  bessiere         idea arc consistency introduced mackworth
        generalised k consistency freuder         modern constraint solvers
generally employ specialised propagators prune domains variables achieve
form generalised arc consistency  typically attempt enforce higher levels
consistency  path consistency 
contrast  software tools developed solve propositional satisfiability problems 
known sat solvers  generally use logical inference techniques  unit propagation
clause learning  prune search space 
one surprising empirical findings last years remarkably good performance general sat solvers solving constraint satisfaction problems 
apply tools constraint satisfaction problem one first translate instance set clauses using form boolean encoding  tamura  taga  kitagawa 
  banbara        walsh         encoding techniques tend obscure structure original problem  may introduce large number boolean variables
clauses encode quite easily stated constraints  nevertheless  quite cases 
approaches out performed traditional constraint solving tools  van dongen 
lecoutre    roussel              petke   jeavons        
c
    
ai access foundation  rights reserved 

fijeavons   petke

paper draw number recent analytical approaches try account
good performance general sat solvers many forms constraint problems 
building results atserias  bulatov  dalmau         atserias dalmau
        hwang mitchell         show power using k consistency
techniques constraint problem precisely captured using single inference rule
standard boolean encoding problem  refer inference rule negativehyper resolution  show conclusions deduced enforcing k consistency
deduced sequence negative hyper resolution inferences involving boolean clauses
original instance negative hyper resolvents k literals  furthermore 
using approach atserias  fichte  thurley         pipatsrisawat
darwiche         show current clause learning sat solvers mimic effect
deductions polynomial expected time  even random branching strategy  hence
show that  although explicitly designed so  running clause learning
sat solver straightforward encoding constraint problem efficiently simulates
effects enforcing k consistency values k 

   preliminaries
section give background definitions used throughout
rest paper 
    constraint satisfaction problems k consistency
definition   instance constraint satisfaction problem  csp  specified
triple  v  d  c  
v finite set variables 
   dv   v v   set dv set possible values variable v 
called domain v 
c finite set constraints  constraint c pair  ri   si  
si ordered list mi variables  called constraint scope 
ri relation arity mi   called constraint relation 
given csp instance  v  d  c   partial assignment mapping f

subset w v dv f  v  dv v w   partial assignment satisfies
constraints instance if   r   v    v            vm    c vj w
j                 m   f  v     f  v            f  vm    r  partial assignment satisfies
constraints instance called partial solution  instance  set
variables partial assignment f defined called domain f   denoted
dom f    partial solution g extends partial solution f dom g  dom f  
g v    f  v  v dom f    partial solution domain v called solution 
one way derive new information csp instance  may help determine
whether solution  use form constraint propagation enforce
   note partial solutions extend solutions 

   

filocal consistency sat solvers

level local consistency  bessiere         example  possible use notion
k consistency  defined below  note several different equivalent ways
define enforce k consistency described literature  bessiere        cooper       
freuder         presentation follows atserias et al          inspired
notion existential k pebble games introduced kolaitis vardi        
definition    atserias et al         csp instance p   k consistency closure
p set h partial assignments obtained following algorithm 
   let h collection partial solutions f p  dom f    k     
   every f h  dom f    k every variable v p   g h
g extends f v dom g   remove f extensions h 
   repeat step   h unchanged 
note computing k consistency closure according definition corresponds
precisely enforcing strong  k    consistency according definitions given bessiere
        cooper         freuder        
throughout paper  shall assume domain possible values
variable csp instance finite  straightforward show fixed k 
fixed maximum domain size  k consistency closure instance p
computed polynomial time  atserias et al         cooper        
note solution p must extend element k consistency closure
p   hence  k consistency closure p empty  k  p solutions 
converse true general  holds certain special cases  class
instances whose structure tree width bounded k  atserias et al          class
instances whose constraint relations     all relations  defined cooper  cohen 
jeavons         connected row convex relations  defined deville  barette 
hentenryck         special kinds instances possible determine
polynomial time whether solution exists simply computing k consistency
closure  appropriate choice k  moreover  solution exists 
constructed polynomial time selecting variable turn  assigning possible
value  re computing k consistency closure  retaining assignment gives
non empty result 
following result gives useful condition determining whether k consistency
closure csp instance empty 
lemma    kolaitis   vardi        k consistency closure csp instance p
non empty exists non empty family h partial solutions p
that 
   f h   dom f    k     
   f h f extends g  g h 
   f h   dom f    k  v
  dom f   variable p  
g h g extends f v dom g  
set partial solutions h satisfying conditions described lemma   sometimes
called strategy instance p  barto   kozik        kolaitis   vardi        
   

fijeavons   petke

    encoding csp instance propositional formula
one possible approach solving csp instance encode propositional formula
suitable set boolean variables  use program decide satisfiability
formula  many programs  known sat solvers  available
often efficiently handle problems thousands  sometimes even millions  boolean
variables  zhang   malik        
several different ways encoding csp instance propositional formula
proposed  prestwich        tamura et al         walsh        
consider one common family encodings  known sparse encodings  this term
introduced hoos         csp instance p    v  d  c   sparse encoding
introduces set boolean variables form xvi v v dv  
boolean variable xvi assigned true original variable v assigned
value i  say partial assignment f falsifies clause c c consists entirely
literals form xvf  v    variables v dom f    otherwise  say partial
assignment f satisfies clause c 
example   let p csp instance v    u  v  w   du   dv           dw  
          c contains single ternary constraint scope  u  v  w  specifying
u v   w  sparse encoding p introduce seven boolean variables 
xu    xu    xv    xv    xw    xw    xw   
sparse encodings usually contain certain clauses known at least one at most one
clauses  ensure variable v assigned value  say i  value 
w
j    i  assigned v  at least one clauses form idv xvi variable
v  at most one clauses represented set binary clauses xvi xvj
i  j dv    j 
example   case csp instance example   at least one clauses are 
xu  xu    xv  xv    xw  xw  xw 
at most one clauses are 
xu  xu    xv  xv    xw  xw    xw  xw    xw  xw 
various different sparse encodings differ way encode constraints
csp instance  two methods commonly used  first one encodes disallowed
variable assignments   so called conflicts no goods  direct encoding  prestwich 
w
       instance  generates clause vs xvf  v  partial assignment f
satisfy constraint  r  s  c  using direct encoding  ternary constraint
example   would encoded following clauses 
xu  xv  xw   
xu  xv  xw   
xu  xv  xw   
xu  xv  xw   
   

filocal consistency sat solvers

xu  xv  xw   
xu  xv  xw   
xu  xv  xw   
xu  xv  xw   
another way translating constraints clauses encode allowed variable
assignments   so called supports  used basis encoding
binary csp instances  known support encoding  gent         defined follows 
pair variables v  w scope constraint  value dv  
w
support encoding contain clause xvi ja xwj   dw set
values variable w compatible assignment v   i  according
constraint 
note support encoding defined binary csp instances only  however 
non binary constraints decomposed binary ones without introducing new
variables  instance  ternary constraint example   decomposed two
binary constraints specifying u v v   w  using support encoding 
binary constraints would represented following clauses 
xu  xv  xv    xu  xv    xv  xu    xv  xu  xu   
xv  xw  xw    xv  xw    xw    xw  xv    xw  xv  xv   
    inference rules
given set clauses often deduce clauses applying certain inference
rules  example  two clauses form c  x c  x   possibly
empty  clauses c    c    variable x  deduce clause c  c   
form inference known propositional resolution  resultant clause called
resolvent  robinson        
next section  shall establish close connection k consistency
algorithm form inference called negative hyper resolution  buning   lettmann 
       define follows 
definition   collection clauses form ci xi                   r 
clause c  x  x  xr   xi boolean variable  c 
ci  possibly empty  disjunction negative literals  deduce clause
c  c  cr  
call form inference negative hyper resolution resultant clause
c  c  cr negative hyper resolvent 
case c  empty  negative hyper resolution rule equivalent
nogood resolution rule described hwang mitchell        well h  k rule
introduced de kleer        nogood recording scheme described schiex
verfaillie        
note inference obtained negative hyper resolution obtained
sequence standard resolution steps  however  reason introducing negative hyperresolution allows us deduce clauses need single step without needing
introduce intermediate clauses  which may contain r   literals
   

fijeavons   petke

negative hyper resolvent   restricting size clauses use way
able obtain better performance bounds sat solvers results below 
example   assume collection clauses form ci xi                   r 
clause c  x  x  xr   specified definition    ci   c   
negative hyper resolvent set clauses c   
clause c  obtained sequence standard resolution steps  follows 
first resolve c  x  x  xr c  xr obtain c  x  x  xr   
resolve next clause  c  xr    clauses  finally
obtain c    however  case intermediate clause c  x  x  xr  contains
r   literals negative hyper resolvent 
example   note no good clauses direct encoding binary csp instance
obtained single negative hyper resolution step appropriate support
clause support encoding together appropriate collection at most one clauses 
let dw set values variable w compatible assignment
w
v   i  support encoding contain clause c   xvi ja xwj  
values k dw incompatible assignment v   i  form
negative hyper resolvent c at most one clauses xwk xwj j a 
obtain corresponding no good clause  xvi xwk  
negative hyper resolution derivation clause c set initial clauses
sequence clauses c    c            cm   cm   c ci follows negativehyper resolution rule collection clauses  either contained
else occurs earlier sequence  width derivation defined
maximum size clauses ci   cm empty clause  say
derivation negative hyper resolution refutation  

   k consistency negative hyper resolution
pointed many authors enforcing local consistency form
inference relations analogous use resolution rule clauses  bacchus       
bessiere        hwang   mitchell        rish   dechter         precise strength
standard resolution inference rule direct encoding csp instance considered
work walsh         shown unit resolution  where one
clauses resolved consists single literal   corresponds enforcing weak form
local consistency known forward checking  hwang mitchell        pointed
standard resolution rule restriction clause length able simulate
inferences made k consistency algorithm  atserias dalmau        showed
standard resolution rule restricted clauses k literals  known kresolution rule  characterised terms boolean existential  k     pebble game 
follows csp instances boolean domains form inference corresponds
enforcing k consistency  alternative proof k resolution achieves k consistency
instances boolean domains given book hooker        thm        
extend results little  show csp instances arbitrary
finite domains  applying negative hyper resolution rule direct encoding obtain
   

filocal consistency sat solvers

clauses k literals corresponds precisely enforcing k consistency  similar
relationship stated work de kleer         complete proof given 
note bound  k  impose size negative hyper resolvents 
independent domain size  words  using inference rule need
consider inferred clauses size k  even though make use clauses
encoding whose size equal domain size  may arbitrarily large 
theorem   k consistency closure csp instance p empty direct
encoding set clauses negative hyper resolution refutation width k 
proof broken two lemmas inspired lemmas     work
atserias dalmau        
lemma   let p csp instance  let direct encoding set clauses 
negative hyper resolution refutation width k less  k consistency
closure p non empty 
proof  let v set variables p   v v domain dv   let
x    xvi   v v  dv   corresponding set boolean variables   let
set clauses negative hyper resolution derivation width k 
definition negative hyper resolution  every non empty clause consists entirely
negative literals 
let h set partial assignments p domain size k    
falsify clause direct encoding 
consider element f h  definition h  f falsify clause
  definition direct encoding  every element h partial solution
p   furthermore  f extends g  g element h  g makes fewer
assignments f hence cannot falsify additional clauses f  
negative hyper resolution refutation width k 
contain empty clause  h contains  at least  partial solution empty domain 
hence h empty 
let f element h  dom f    k let v variable p
dom f    partial assignment g extends f dom g   
dom f    v  either g h else exists clause
falsified g  since g partial assignment  clause c falsified g 
must consist entirely negative literals  hence literals c must either form
xwf  w  w dom f    else xvg v    moreover  clause must contain
literal xvg v    else would already falsified f  
assume  contradiction  h contain assignment g extends f
dom g    dom f    v   case  that  dv   contains
clause ci consisting negative literals form xwf  w  w dom f    together
literal xvi   consider clause  c  negative hyper resolvent
w
clauses ci at least one clause idv xvi   clause c consists entirely
negative literals form xwf  w  w dom f    width
 dom f    k  hence element   however c falsified f   contradicts
choice f   hence shown f h  dom f    k 
   

fijeavons   petke

variables v v   dom f    g h g extends f
v dom g  
shown h satisfies conditions required lemma    conclude
k consistency closure p non empty 
 

lemma   let p csp instance  let direct encoding set clauses 
k consistency closure p non empty  negative hyper resolution
refutation width k less 
proof  let v set variables p   v v domain dv   let
x    xvi   v v  dv   corresponding set boolean variables  
lemma    k consistency closure p non empty  exists nonempty set h partial solutions p satisfies three properties described
lemma   
consider negative hyper resolution derivation width k 
show induction length derivation elements h falsify
clause derivation  first note elements h partial solutions 
satisfy constraints p   hence falsify clause   establishes
base case  assume  induction  clauses derivation earlier
clause c falsified element h 
note that  apart at least one clauses  clauses consist entirely
negative literals  hence may assume  without loss generality  c negativehyper resolvent set clauses    ci xvi   dv   at least one clause
w
idv xvi   fixed variable v 
f h falsifies c  literals c must form xwf  w   
w dom f    since width derivation k  c contains k literals 
hence may assume  dom f    k  then  choice h  must
exist extension g f h v dom g   g falsify
clause   contradicts inductive hypothesis  hence f h falsifies c  and 
particular  c cannot empty 
follows negative hyper resolution derivation width k contain
empty clause 
 
note proof theorem   applies sparse encoding contains
at least one clauses variable  clauses purely negative 
call encoding negative sparse encoding  well direct encoding 
negative sparse encodings exist  example  may use negative clauses involve
subset variables scope constraints  to forbid tuples possible
extensions complete scope disallowed constraint   another example
negative sparse encoding well known variant direct encoding
at most one clauses omitted 
corollary   k consistency closure csp instance p empty
negative sparse encoding p negative hyper resolution refutation width k 
   

filocal consistency sat solvers

   negative hyper resolution sat solvers
section adapt machinery atserias et al          pipatsrisawat
darwiche        show fixed k  existence negative hyper resolution
refutation width k likely discovered sat solver polynomial time using
standard clause learning restart techniques  even totally random branching
strategy 
note previous results power clause learning sat solvers generally
assumed optimal branching strategy  beame  kautz    sabharwal        pipatsrisawat
  darwiche          shown solvers potentially capable doing  rather
likely achieve practice  important exception paper
atserias et al          gives analysis likely behaviour  relies
existence standard resolution proof bounded width  show results
atserias et al  extended hyper resolution proofs  shorter
narrower associated standard resolution proofs 
make use following terminology atserias et al          clause
c  boolean variable x  truth value         restriction c assignment
x   a  denoted c x a   defined constant    assignment satisfies clause 
else clause obtained deleting c literals involving variable x 
sequence assignments form  x    a    x    a            xr   ar   write c s
denote result computing restriction c assignment turn  c s
empty  say assignments falsify clause c  set clauses  
write  s denote set  c s   c         
current sat solvers operate following way  atserias et al         pipatsrisawat   darwiche         maintain database clauses current state
s  partial assignment truth values boolean variables clauses
  high level description algorithms used update clause database
state  derived description given atserias et al   shown algorithm    a similar framework  using slightly different terminology  given pipatsrisawat   darwiche 
      
consider run algorithm shown algorithm    started initial
database   empty state s    either halts discovers conflict  i e    s   
run called complete round started   represent sequence
states s            sm   algorithm maintains  note state si extends
state si  single assignment boolean variable  may either decision
assignment implied assignment 
generally  round initial segment s    s            sr complete round started
  state sr either  sr contains empty clause   sr
contain unit clause  clause c  say round s    s            sr satisfies c
c sr      say round falsifies c c sr empty 
s    s            sr round started    sr contains empty clause 
algorithm either reports unsatisfiability learns new clause  round called
conclusive  round conclusive call inconclusive     note s    s            sr
inconclusive round started    sr contain empty clause 
   note complete round assigns variables reports satisfiability called inconclusive 

   

fijeavons   petke

contain unit clauses  hence  clause c   sr falsifies
literals c except one  must satisfy remaining literal  hence satisfy c 
property clauses captured following definition 
definition    atserias et al         let set clauses  c non empty clause 
l literal c  say absorbs c l every inconclusive round started
falsifies c    l  satisfies c 
absorbs c literal l c  simply say absorbs c 
note closely related notion introduced pipatsrisawat darwiche       
clauses absorbed set clauses   referred   empowering
respect    the exact relationship   empowering absorption discussed
atserias et al         
explore relationship absorption negative hyper resolution 
example   let direct encoding csp instance p    v  d  c   v  
 u  v  w   du   dv   dw          c contains two binary constraints  one forbids
assignment value   u v simultaneously  forbids simultaneous
assignment value   u   w  let c contain ternary constraint
forbids assignment value   three variables simultaneously 
    xu  xu    xv  xv    xw  xw   
xu  xu    xv  xv    xw  xw   
xu  xv    xu  xw    xu  xv  xw    
clause xv  xw  contained   obtained negative hyperresolution clauses xu  xu    xu  xv    xu  xw   
clause absorbed   since every inconclusive round sets xv    true must
set xw    f alse unit propagation  every inconclusive round sets xw    true
must set xv    f alse unit propagation 
example   indicates clauses obtained negative hyper resolution
set clauses sometimes absorbed   next result clarifies situation
holds 
lemma   negative hyper resolvent set disjoint clauses absorbed set
clauses 
proof  let c negative hyper resolvent set clauses    ci xi    
              r  clause c     c  x  x  xr   ci  possibly empty 
disjunction negative literals    r  c   c  c  cr definition   
definition    must show c   absorbs c literals  assume
one literals c falsified  since set clauses c   assumed
disjoint  remaining literal l must belong exactly one clauses set 
two cases consider 
   l belongs clause c     clauses one literals falsified 
remaining literal xi clauses set true  unit propagation 
hence literals c   falsified  except l  l set true  unit propagation 
   

filocal consistency sat solvers

   l belongs one clauses ci xi   remaining clauses
one literals falsified  corresponding literals xj set true  unit
propagation  hence literals c   falsified  except xi   xi set true 
unit propagation  literals ci xi falsified  except l  l set
true unit propagation 
 
next example shows negative hyper resolvent set clauses
disjoint necessarily absorbed clauses 
example   recall set clauses given example    direct encoding
csp instance three variables  u  v  w   domain        
clause xu  xv  contained   obtained negative hyperresolution clauses xw  xw    xu  xv  xw    xu  xw   
clause absorbed   since inconclusive round sets xv    true
necessarily ensure xu    f alse unit propagation 
basic approach shall use establish main results show
clauses obtained bounded width negative hyper resolution given set
clauses  immediately absorbed  such one example    likely
become absorbed quite quickly additional clauses added
process clause learning  hence clause learning sat solver likely fairly rapidly
absorb clauses derived original database clauses negativehyper resolution  particular  empty clause derived negative hyperresolution  solver fairly rapidly absorb literal complement 
hence report unsatisfiability  see proof theorem   details  
following key properties absorption established atserias et al         
lemma    atserias et al         let   sets clauses  let c c  
non empty clauses 
   c belongs   absorbs c 
   c c   absorbs c  absorbs c    
     absorbs c    absorbs c 
allow analysis  need make assumptions learning scheme 
restart policy branching strategy used sat solver 
learning scheme rule creates adds new clause database
whenever conflict  clause called conflict clause  literals
falsified assignment current state  literal falsified i th decision
assignment  later implied assignment  i      th decision assignment 
said falsified level i  conflict clause contains exactly one literal falsified
maximum possible level  called asserting clause  pipatsrisawat   darwiche 
      zhang  madigan  moskewicz    malik        
assumption   learning scheme chooses asserting clause 
   

fijeavons   petke

algorithm   framework typical clause learning sat solver
input    set clauses 
  partial assignment truth values variables 
  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   

 s   
 s
conflict
contains decision assignments
print unsatisfiable halt
else
apply learning scheme add new clause
restart policy says restart
set  
else
select recent conflict causing unreversed decision assignment
reverse decision  remove later assignments
end
end
else  l   s literal l
unit propagation
add implied assignment x   satisfies l
else
decision
apply branching strategy choose decision assignment x  
add decision assignment
end
end
print satisfiable output

learning schemes current use satisfy assumption  pipatsrisawat   darwiche        zhang et al          including learning schemes called  uip decision  zhang et al         
make particular assumption restart policy  however  main result
phrased terms bound expected number restarts  algorithm restarts
r conflicts  bound expected number restarts simply multiplied
r get bound expected number conflicts  means results
strongest algorithm restarts immediately conflict  case 
r     bound bound expected number conflicts  existing satsolvers typically employ aggressive restart policy  note remark
work pipatsrisawat darwiche        p      clear trend
towards frequent restarts modern sat solvers 
branching strategy determines decision assignment chosen inconclusive round complete  current sat solvers strategy based
heuristic measure variable activity  related occurrence variable
conflict clauses  moskewicz  madigan  zhao  zhang    malik         however  simplify
probabilistic analysis  make following assumption 

   

filocal consistency sat solvers

assumption   branching strategy chooses variable uniformly random amongst
unassigned variables  assigns value true 
noted atserias et al          analysis give applied
branching strategy randomly chooses making heuristic based
decision randomly based decision  precisely  allow  say  c     rounds nonrandom decisions random ones  number required restarts conflicts
would appear multiplied factor c 
algorithm behaves according description algorithm    satisfies
assumptions above  called standard randomised sat solver 
theorem   set non empty clauses n boolean variables negativehyper resolution refutation width k length m  expected number restarts
requiredby standard randomised sat solver discover unsatisfiable less
mnk   nk  
proof  let c    c            cm negative hyper resolution refutation width k  
cm first occurrence empty clause  since clause non empty 
cm must derived negative hyper resolution collection negative literals
x    x          xd purely positive clause x  x  xd  
consider standard randomised sat solver started database  
unit clauses xi absorbed current database  then  definition   
inconclusive round algorithm must assign variables xi false  hence falsify
clause x  x  xd   since happens even decision assignments made 
sat solver report unsatisfiability 
remains bound expected number restarts required clause
ci absorbed      m  let ci negative hyper resolvent clauses
  x   together clause c   c x x x
ci    ci            cir   form cij
j
i 
 
 
 
r
  c   possibly empty  disjunction negative literals  assume
clause cij absorbed j                 r 
absorbs ci   learning restarts needed  assume
absorb ci   definition    means exists literal l
inconclusive round r started falsifies ci    l  satisfy ci   note
r must leave literal l unassigned  one assignment would satisfy ci
    hence force literals x used
would falsify c  cij
j
negative hyper resolution step satisfied  cij absorbed   ci 
would falsified  contradicting fact r inconclusive 
hence  branching strategy chooses falsify literals ci    l  whenever
choice  construct inconclusive round r  l unassigned  since
decision assignments r  assigned values r  implied assignments
r  must assigned values  r  shown r leaves l
unassigned   branching strategy chooses falsify remaining literal l ci  
algorithm would construct conclusive round r   ci  falsified 
   see lemmas         work atserias et al         formal statement proof
assertion 

   

fijeavons   petke

decision assignments falsify literals ci   hence  assumption    algorithm would
learn asserting clause c   add obtain new set    
since c   asserting clause  contains exactly one literal  l    falsified
highest level r     hence  inconclusive round r started   falsifies ci    l 
falsify one literal c     hence force remaining literal l  satisfied 
unit propagation  new implied assignment l  propagates force l true 
r satisfies ci   hence   absorbs ci l  not  branching strategy
choose falsify remaining literal l ci   cause new asserting
clause learned added   since new asserting clause forces new literal
satisfied falsifying ci    l  process repeated fewer n times
certain   absorbs ci l 
consider sequence k random branching choices  first k  
falsify literal ci    l   final choice falsifies l  shown
associated round reach conflict  add asserting clause   random
branching strategy  described assumption    probability happens
least probability first k   random choices consist fixed set variables
 in order   final choice variable associated l  number
random choices fall fixed set follows hypergeometric distribution  overall
 
probability n   nk   
     k nk   
 k  
obtain upper bound expected number restarts  consider worst case
require n asserting clauses added absorb clause ci k
literals l  since require upper bound 
treat round independent
n
trial success probability p      k k    consider worst case
achieve  m   nk successes ensure ci     absorbed  case
total number restarts follow negative binomial distribution  expected value
 m   nk p  hence cases expected number restarts less mnk   nk    
tighter bound number restarts obtained focus decision
learning scheme  atserias et al         zhang et al          next result indicates 
theorem   set non empty clauses n boolean variables negative hyperresolution refutation width k length m  expected number restarts required
standard randomised sat solver
using decision learning scheme discover

unsatisfiable less nk  
proof  proof similar proof theorem    except decision learning scheme additional feature literals chosen conflict clause falsify
subset current decision assignments  hence situation consider 
decision assignments falsify literals clause ci   learning scheme learn
subset ci   hence immediately absorb ci   lemma          hence maximum
number learnt clausesrequired
reduced  m   nk  m     probability

increased    k nk      nk   giving tighter bound 
 
note similar argument shows standard deviation number restarts
less standard deviation negative binomial distribution parameters
   

filocal consistency sat solvers




   nk   less nk   hence  chebyshevs inequality  one tailed version  
probability standard randomised sat solver using decision learning scheme

discover unsatisfiable  m   m  nk restarts greater     

   k consistency sat solvers
combining theorem   theorem   obtain following result linking k consistency
sat solvers 
theorem   k consistency closure csp instance p empty  expected
number restarts required standard randomised sat solver using decision learning scheme discover direct encoding p unsatisfiable o n k d k    n
number variables p maximum domain size 
proof  length negative hyper resolution refutation width k bounded
pk
n
number possible no goods length
k

p
 


i     hence 



theorem   theorem   obtain bound


n
i  

pk

nd
k  

o n k d k     

hence standard randomised sat solver suitable learning strategy decide
satisfiability csp instance tree width k o n k d k   expected restarts 
even set restart immediately conflict  particular  satisfiability
tree structured binary csp instance  i e   tree width    decided
solver o n  d    expected conflicts  comparable growth rate
optimal arc consistency algorithm binary constraints  note result cannot
obtained directly work atserias et al          direct encoding
instance tree width k set clauses whose tree width may high dk 
moreover  standard randomised sat solver decide satisfiability csp
instance  structure  within polynomial bounds  constraint relations
satisfy certain algebraic properties ensure bounded width  barto   kozik        
examples constraint types include     all relations  defined cooper et al 
        connected row convex relations  defined deville et al         
decided   consistency 
shown gent        support encoding binary csp instance
made arc consistent  that is    consistent  applying unit propagation alone  hence 
standard sat solver mimic effect enforcing arc consistency encoding
making decisions restarts  combining theorem   observation
example   direct encoding obtained support encoding negativehyper resolution  obtain following corollary concerning support encoding
higher levels consistency 
corollary   k    k consistency closure binary csp instance p
empty  expected number restarts required standard randomised satsolver using decision learning scheme discover support encoding p
unsatisfiable o n k d k    n number variables p maximum
domain size 
   

fijeavons   petke

csp literature describes many variations notion consistency 
paper considered k consistency only  note results generalised
types consistency singleton arc consistency  bessiere        
extension singleton arc consistency follows recent discovery family
csp instances solvable enforcing singleton arc consistency  instances
bounded width  chen  dalmau    gruien         words  instances
solved enforcing k consistency  fixed k  hence  theorem   
solved polynomial expected time standard randomised sat solver 

   experimental results
polynomial upper bounds obtain paper asymptotic  apply
values n  k  however  conservative  likely met
easily practice 
investigate existing sat solver actually performs  measured runtime
minisat solver  een   sorensson         version        family csp instances
decided fixed level consistency  comparison  ran experiments two state of the art constraint solvers  used minion  gent  jefferson   
miguel         version       g   finite domain solver  nethercote et al         
version     
match simplified assumptions analysis closely  ran
set experiments core version minisat order get solver uses
unit propagation conflict directed learning restarts  modified solver
follow random branching strategy described above  solver delete learnt
clauses uses extreme restart policy makes restart whenever encounters
conflict  uses learning scheme minisat  refer modified solver
simple minisat 
characteristic feature instances tested relatively low tree width 
used toulbar  solver  sanchez et al          solver implements btd
 backtracking tree decomposition  technique shown efficient
practice  contrast earlier methods proposed attempt exploit
tree decompositions input problem  jegou   terrioux         problem
finding tree decomposition minimal width  i e   tree width  np hard  btd
technique uses approximations  described jegou   terrioux         note
toulbar  designed solving optimization problems  namely weighted csps 
wcsps  wcsp instance  certain partial assignments associated cost  however 
toulbar  solver used solve standard csps simply setting costs   
results  times given elapsed times lenovo      n    laptop
intel core   duo processor running     ghz  gb ram  generated
instance run five times mean times mean number restarts shown   
example   consider family instances specified two parameters  w d 
  d  w   w variables arranged groups size w  domain          d   
   minisat simple minisat run different seeds five runs instance 
instances marked   run only  runtime simple minisat instances
exceeded   hours  moreover  toulbar  run parameter b     enables btd 

   

filocal consistency sat solvers

impose constraint arity  w pair successive groups  requiring
sum values assigned first two groups strictly smaller
sum values assigned second  ensures instances generated
unsatisfiable  instance w         shown diagrammatically defined
using specification language minizinc  nethercote et al         figure    a   b 
respectively    similar format used toulbar    instance encoded
format shown figure    c   note hard constraint cost    

 a  graphical representation 

chain
x     
x     
x     
x     
x     
x     
x     
x     
hard  x    x    x    x   
hard  x    x    x    x   
hard  x    x    x    x   

array       var        x  
array       var        x  
constraint
forall i       
x  i    x  i    x  i        x  i       
solve satisfy 
 b  specification minizinc 

 c  specification cp format 

figure    example csp instance w          tree width     

structure instances described example   simple tree decomposition
path nodes  node corresponding constraint scope  hence tree width
instances  w   shown unsatisfiable enforcing   w   consistency  atserias et al          however  instances cannot solved efficiently
using standard propagation algorithms prune individual domain values 
structure direct encoding instances tree decomposition
node corresponding constraint scope original csp instance  however 
direct encoding introduces boolean variables represent variable
   order run instance cp solver one must usually use translator convert original
model  minizinc distribution provides mzn fzn translator minion one use tailor
 available http   www cs st andrews ac uk andrea tailor   
   cp wcsp translator description cp wcsp formats available
http   carlit toulouse inra fr cgi bin awki cgi softcsp 

   

fijeavons   petke

original instance  tree width encoded sat instances larger approximately
factor d  fact  wd    see figure    

 a  tree decomposition original instance 

 b  tree decomposition direct
encoding 

figure    tree decompositions csp instance figure   
table   shows runtimes simple minisat original minisat solver
family instances  along times two state of the art cp solvers
wcsp solver toulbar   far best solver set instances toulbar  
explicitly designed exploit low tree width constructing tree decomposition 
class instances considering  widths tree decompositions found
toulbar  matched tree widths instances tested  i e    w    
however  note minisat remarkably effective solving chains
inequalities  compared minion g    even though use minisat requires
encoding instance large number clauses much larger tree width
original  although simplified version minisat solver takes little longer
current highly optimised version  still performs well instances
comparison conventional cp solvers  moreover  number restarts  and hence
number conflicts  appears grow polynomially size instance
 see figure     cases actual number restarts much lower polynomial
upper bound expected number restarts given theorem   
best theoretical upper bounds expected run time obtained
decision learning scheme  theorem     standard version minisat uses
 uip learning scheme conflict clause minimization  allow direct comparison
theoretical upper bounds  implemented decision scheme simpleminisat   uip learning scheme generally found efficient
practice  zhang et al          switched conflict clause minimization simpleminisat order compare two standard learning schemes ran set
experiments  counted number restarts two modified solvers instances
form described example     see table   
   

filocal consistency sat solvers

group
size
 w 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

domain
size
 d 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 

csp
variables
 n 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

minion

g  

 sec 
     
     
     
     
     
      
     min
     min
     min
     
     
     min
     min
     min
     
     min
     min

 sec 
     
     
     
     
     
       
     min
     min
     min
     
     
     
     min
     min
     
      
     min

toulbar 

minisat

 sec 
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
      

 sec 
     
     
     
     
     
     
     
     
     
     
     
     
      
       
     
     
         

simpleminisat
 sec 
     
     
     
     
     
     
     
      
       
     
     
      
       
     min
     
       
     min

simpleminisat
restarts
  
   
   
     
     
      
      
      
       
   
     
      
       
       
     
       
          

table    average performance solvers instances example   
group
size
 w 

domain
size
 d 

csp
variables
 n 

no  clauses
direct
encoding

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
   
     
     
     
      
      
      
       
   
     
      
       
       
   
      

simpleminisat
 uip
 sec 
     
     
     
     
     
     
      
      
       
     
     
      
         
    hours
     
       

simpleminisat
 uip
restarts
  
   
     
     
      
      
      
       
       
   
     
      
       
          
     
       

simpleminisat
decision
 sec 
     
     
     
     
     
     
      
      
       
     
     
      
         
    hours
     
       

simpleminisat
decision
restarts
  
   
     
     
      
      
      
       
       
   
     
      
       
          
     
       

table    average performance simple minisat  uip decision learning schemes instances example   

   

fijeavons   petke

figure    log log plot number restarts conflicts used simple minisat

instances example    solid lines show growth function d w  nd w
 
 
n number csp variables  empirically derived polynomial
function appears fit experimental data well  much lower
upper bound expected number restarts calculated theorem  
o d w  n w    

   

filocal consistency sat solvers

although performance simple minisat decision learning scheme
 uip scheme significantly worse performance original simpleminisat solver  twice many restarts required instance  hence 
theoretical upper bounds still easily met standard learning schemes 

   conclusions
shown notion k consistency precisely captured single
inference rule direct encoding csp instance  restricted deriving clauses
k literals  used show clause learning sat solver purely
random branching strategy simulate effect enforcing k consistency expected
polynomial time  fixed k  sufficient ensure solvers able
solve certain problem families much efficiently conventional cp solvers relying
gac propagation 
principle clause learning sat solvers much more  known that 
appropriate branching strategy restart policy  able p simulate general
resolution  beame et al         pipatsrisawat   darwiche         general resolution
proofs exponentially shorter negative hyper resolution proofs considered  hwang   mitchell         practice  seems current clause learning
sat solvers highly tuned learning schemes  branching strategies restart policies
often able exploit structure boolean encoding csp instance even
effectively local consistency techniques  hence considerable work remains done
understanding relevant features instances able exploit  order
predict effectiveness solving different kinds csp instances 

acknowledgments
would thank albert atserias marc thurley comments conference
version paper  well anonymous referees  provision epsrc
doctoral training award justyna petke gratefully acknowledged 
preliminary version paper appeared proceedings   th international
conference principles practice constraint programming   cp     

references
atserias  a   bulatov  a  a     dalmau  v          power k consistency 
international colloquium automata  languages programming   icalp   
pp         
atserias  a     dalmau  v          combinatorial characterization resolution width 
journal computer system sciences                 
atserias  a   fichte  j  k     thurley  m          clause learning algorithms many
restarts bounded width resolution  journal artificial intelligence research
 jair              
bacchus  f          gac via unit propagation  principles practice constraint
programming   cp    pp         
   

fijeavons   petke

barto  l     kozik  m          constraint satisfaction problems bounded width 
symposium foundations computer science   focs    pp         
beame  p   kautz  h  a     sabharwal  a          towards understanding harnessing
potential clause learning  journal artificial intelligence research  jair  
           
bessiere  c          constraint propagation  rossi  f   van beek  p     walsh  t   eds   
handbook constraint programming  chap     elsevier 
buning  h     lettmann  t          propositional logic  deduction algorithms  cambridge tracts theoretical computer science  cambridge university press 
chen  h   dalmau  v     gruien  b          arc consistency friends  computing
research repository   corr  abs           
cooper  m  c          optimal k consistency algorithm  artificial intelligence         
     
cooper  m  c   cohen  d  a     jeavons  p          characterising tractable constraints 
artificial intelligence                 
de kleer  j          comparison atms csp techniques  international joint
conference artificial intelligence   ijcai    pp         
deville  y   barette  o     hentenryck  p  v          constraint satisfaction connected
row convex constraints  international joint conference artificial intelligence ijcai        pp         
een  n     sorensson  n          extensible sat solver  theory applications
satisfiability testing   sat    pp         
freuder  e  c          synthesizing constraint expressions  communications acm 
                
gent  i  p          arc consistency sat  european conference artificial intelligence
  ecai    pp         
gent  i  p   jefferson  c     miguel  i          minion  fast scalable constraint solver 
european conference artificial intelligence   ecai    pp        
hooker  j  n          integrated methods optimization  international series operations research   management science   springer verlag new york  inc   secaucus 
nj  usa 
hoos  h  h          sat encodings  search space structure  local search performance 
international joint conference artificial intelligence   ijcai    pp         
hwang  j     mitchell  d  g            way vs  d way branching csp  principles
practice constraint programming   cp    pp         
jegou  p     terrioux  c          hybrid backtracking bounded tree decomposition
constraint networks  artificial intelligence                
kolaitis  p  g     vardi  m  y          game theoretic approach constraint satisfaction  conference artificial intelligence   aaai     innovative applications
artificial intelligence conference   iaai    pp         
   

filocal consistency sat solvers

mackworth  a  k          consistency networks relations  artificial intelligence        
      
montanari  u          networks constraints  fundamental properties applications
picture processing  information sciences           
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering efficient sat solver  design automation conference   dac    pp 
       
nethercote  n   stuckey  p  j   becket  r   brand  s   duck  g  j     tack  g         
minizinc  towards standard cp modelling language  principles practice
constraint programming   cp    pp         
petke  j     jeavons  p          tractable benchmarks constraint programming  technical report rr        department computer science  university oxford 
pipatsrisawat  k     darwiche  a          power clause learning sat solvers
restarts  principles practice constraint programming   cp    pp         
prestwich  s  d          cnf encodings  biere  a   heule  m   van maaren  h     walsh 
t   eds    handbook satisfiability  pp        ios press 
rish  i     dechter  r          resolution versus search  two strategies sat  journal
automated reasoning                   
robinson  j  a          machine oriented logic based resolution principle  journal
acm               
sanchez  m   bouveret  s   de givry  s   heras  f   jegou  p   larrosa  j   ndiaye  s   rollon 
e   schiex  t   terrioux  c   verfaillie  g     zytnicki  m          max csp competition       toulbar  solver description  proceedings third international
csp solver competition 
schiex  t     verfaillie  g          nogood recording static dynamic constraint
satisfaction problems  international conference tools artificial intelligence
  ictai    pp       
tamura  n   taga  a   kitagawa  s     banbara  m          compiling finite linear csp
sat  constraints                 
van dongen  m   lecoutre  c     roussel  o           rd international csp solver competition  instances results available http   www cril univ artois fr cpai    
van dongen  m   lecoutre  c     roussel  o           th international csp solver competition  instances results available http   www cril univ artois fr cpai    
walsh  t          sat v csp  principles practice constraint programming cp    pp         
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning boolean satisfiability solver  international conference computeraided design   iccad    pp         
zhang  l     malik  s          quest efficient boolean satisfiability solvers 
computer aided verification   cav    pp       

   


