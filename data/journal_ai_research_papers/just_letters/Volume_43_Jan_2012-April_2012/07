journal artificial intelligence research                 

submitted        published      

completeness guarantees incomplete ontology
reasoners  theory practice
bernardo cuenca grau
boris motik
giorgos stoilos
ian horrocks

bernardo cuenca grau cs ox ac uk
boris motik cs ox ac uk
giorgos stoilos cs ox ac uk
ian horrocks cs ox ac uk

department computer science  university oxford
wolfson building  parks road  ox   qd  oxford

abstract
achieve scalability query answering  developers semantic web applications
often forced use incomplete owl   reasoners  fail derive answers
least one query  ontology  data set  lack completeness guarantees  however 
may unacceptable applications areas health care defence 
missing answers adversely aect applications functionality  furthermore  even
application tolerate level incompleteness  often advantageous
estimate many kind answers lost 
paper  present novel logic based framework allows one check whether
reasoner complete given query q ontology is  whether reasoner
guaranteed compute answers q w r t  arbitrary data set a  since
ontologies typical queries often fixed application design time  approach allows
application developers check whether reasoner known incomplete general
actually complete kinds input relevant application 
present technique that  given query q  ontology   reasoners
r  r  satisfy certain assumptions  used determine whether 
data set a  reasoner r  computes answers q w r t  reasoner r   
allows application developers select reasoner provides highest degree
completeness q compatible applications scalability requirements 
results thus provide theoretical practical foundation design future
ontology based information systems maximise scalability minimising even
eliminating incompleteness query answers 

   introduction
ecient management querying large amounts data core problem growing
range applications fields diverse biology  sidhu  dillon  chang    sidhu        
medicine  golbreich  zhang    bodenreider         geography  goodwin         astronomy
 derriere  richard    preite martinez         agriculture  soergel  lauser  liang  fisseha 
keizer    katz         defence  lacy  aviles  fraser  gerber  mulvehill    gaskill 
       order facilitate interoperability  applications often use standard data
models query languages  particular  rdf  hayes        provides standard model
semistructured data  sparql  prudhommeaux   seaborne        standard query
language rdf  ontology languages owl  horrocks  patel schneider   
van harmelen        owl    cuenca grau  horrocks  motik  parsia  patel schneider 
c
    
ai access foundation  rights reserved 

ficuenca grau  motik  stoilos   horrocks

  sattler      b  used describe background knowledge application
domain  thus  answering sparql queries rdf data sets structured using owl
ontology key service ontology based information systems 
important question design systems selection appropriate
reasoner  systems pellet  sirin  parsia  cuenca grau  kalyanpur    katz        
hermit  motik  shearer    horrocks      b   racer  haarslev   moller       
based  hyper tableau algorithms provably completethat is  guaranteed compute answers query  ontology  data set  completeness  however 
comes cost scalability  answering queries owl   ontologies high computational complexity  glimm  horrocks  lutz    sattler        ortiz  calvanese    eiter 
      calvanese  de giacomo  lembo  lenzerini    rosati        lutz  toman    wolter 
       thus  complete systems often fail meet scalability demands applications
manage data sets consisting hundreds millions even billions assertions 
scalability query answering ensured restricting expressive power
ontology language level makes provably complete reasoning tractable 
led development three profiles owl    motik  cuenca grau  horrocks  wu 
fokoue    lutz      a   owl   el  owl   rl  owl   ql  query answering
three profiles implemented polynomial time w r t  size data  and even
logarithmic space case owl   ql   appealing theoretical properties
spurred development specialised reasoners quonto  acciarri  calvanese 
de giacomo  lembo  lenzerini  palmieri    rosati        target specific profiles
typically reject ontologies fall outside target profile 
dierent solution scalability problem adopted reasoners oracles semantic data store  wu  eadon  das  chong  kolovski  annamalai    srinivasan 
       sesame  broekstra  kampman    van harmelen         jena  mcbride  brian        
owlim  kiryakov  ognyanov    manov         minerva  ma  yang  qiu  xie  pan    liu 
       dle jena  meditskos   bassiliades         virtuoso  erling   mikhailov        
reasoners accept owl   ontologies inputthat is  never reject inputs 
furthermore  best knowledge  systems intended sound 
means results query indeed correct answers  finally  reasoners
typically use scalable reasoning techniques  various  deductive  database algorithms 
consequence  reasoners incomplete  reasoner  least one query  ontology  data set exist reasoner return answers query 
reasoners actually designed complete particular profile
owl    typically owl   rl due close connection datalog  
often additionally handle certain kinds axiom fall outside target profile 
since incomplete reasoners handle large data sets  often provide best practical choice developers ontology based applications  example  owlim used
reasoning backend bbcs      world cup website  oracles reasoner
used university texas health science center improve large scale public
health surveillance  order verify selected reasoner meets applications
requirements  developers typically resort empirical testing  check reasoners answers w r t  application ontology queries representative data sets 
although primarily intended testing performance  benchmark suites lehigh
   

ficompleteness guarantees incomplete ontology reasoners

university benchmark  lubm   guo  pan    heflin        university ontology
benchmark  uobm   ma et al         used completeness testing 
empirical completeness testing  however  several important limitations  first  tests
generic  data sets used testing typically fixed and or repetitive structure  skew test results  second  test data exhaustive  completeness
tested w r t  limited number data sets  finally  query answers may verifiable  since complete reasoners fail handle large data sets  often cannot compute
control answers needed check answers produced incomplete reasoner 
consequence  empirical completeness tests provide limited assurance reasoners
ability meet requirements given application 
paper  present radically dierent approach solving problems 
observed that  given query q ontology   even reasoner complete
language   reasoner may able correctly answer q w r t  arbitrary data
set a  case  say reasoner  q    complete  given ontology based
applications often use limited set queries fixed ontology  or least queries
ontology evolve relatively slowly   scalable reasoner generally incomplete 
 q    complete relevant combinations q   may provide solid foundation
ontology based applications  allowing enjoy best worlds  regardless
data set encountered  applications enjoy completeness guarantees normally
available computationally intensive complete reasoners  time
exhibiting scalability levels normally available sacrificing completeness  develop
approach testing  q    completeness given reasoner  proceed follows 
section   develop logic based framework allows us establish formally
provable  q    completeness guarantees  following two notions central
framework  first  order abstract away implementation details concrete
reasoners  introduce notion abstract reasoner idealised reasoner captures intended behaviour salient features  such soundness monotonicity 
class concrete reasoners  second  introduce notion test suitea finite set
data sets queries  intuitively  given q   goal construct test suite
that  reasoner correctly answers queries data sets test suite 
reasoner guaranteed  q    complete 
unfortunately  show section      certain q   impossible
construct finite test suite provide aforementioned completeness guarantees 
therefore  investigate assumptions q    reasoner testing  q   completeness becomes practically feasible 
section     consider case q rewritten union
conjunctive queries rthat is  answering q w r t data set equivalent
evaluating r a  expressed owl   ql  rewriting r computed
using algorithm calvanese et al          additionally  algorithm perez urbina 
motik  horrocks        sometimes compute r even syntactically outside
fragment  show r converted test suite er used
testing  q    completeness reasoner satisfies basic assumptions 
roughly speaking  reasoners answers depend names individuals
occurring data set  answers must increase monotonically new data added 
size test er polynomial size longest conjunctive query r 
   

ficuenca grau  motik  stoilos   horrocks

feasible compute correct answers tests using complete reasoner 
number tests er   however  exponential size r  may lead
problems practice  remedy  section     strengthen assumptions require
reasoner drop answers merging individualsthat is  reasoner returns
given inputs q    a   possibly noninjective  mapping reasoner
returns  a  given inputs q     a and show  q    completeness
reasoners checked using test suite ir obtained r linear transformation 
q rewritable union conjunctive queries eectively prevents stating recursive axioms  overcome restriction  section     consider first order reproducible reasonersthat is  reasoners whose behaviour q   
seen computing certain answers q w r t   possibly unknown  first order
theory ft a  since ft datalog program  reasoners based deductive
databases first order reproducible  addition  require q rewritable
datalog  extension datalog allows existential quantifiers disjunction rule heads  many cases  transformed datalog  program
using equivalence preserving transformations  furthermore  algorithm perez urbina
et al         many cases produce plain datalog rewriting  show
transform datalog  rewriting q test suite used test
 q    completeness first order reproducible reasoners 
section   turn attention comparing incomplete reasoners  roughly speaking  given q   reasoner r  complete reasoner r  if  data set a 
reasoner r  computes answers q w r t  computed r   
show comparing incomplete reasoners infeasible general  therefore  introduce
notion compact reasonersthat is  reasoners whose behaviour q   
seen first selecting subset using complete reasoner evaluate
q w r t  a  thus  class compact reasoners captures reasoners reduce
input ontology set axioms match certain parameters  fitting
language fragments  q rewritten union conjunctive queries
r  show test suite ir used compare compact reasoners 
implemented approaches computing test suites  tested completeness several well known reasoners  see section     show test suites
eciently computed realistic ontologies  furthermore  able guarantee
 q    completeness evaluated reasoners many queries ontologies  finally 
 q    completeness guarantee could provided  able compute
counter examplea small data set reasoner hand incomplete 

   preliminaries
section briefly introduce description logics  dls   baader  mcguinness  nardi   
patel schneider       a family knowledge representation formalisms underpin
owl owl   ontology languages  describe description logics wider
framework first order logic since many results hold arbitrary first order theories 
introduce datalog  datalog languages  define syntax
semantics unions conjunctive queries  ucqs   finally  introduce notions
ucq  datalog  datalog  rewritings  underpin many techniques 
   

ficompleteness guarantees incomplete ontology reasoners

    description logics first order logic
results paper hold arbitrary first order theories  rather description logics  work  however  motivated description logics ontologies  use
dl terminology throughout paper  example  often talk tboxes
aboxes instead first order theories sets facts 
definitions paper implicitly parameterised signature   p    
consists countably infinite disjoint sets predicates p individuals  commonly
called constants first order logic    predicate associated nonnegative
arity  predicates zero arity commonly called propositional symbols  notions
variables  terms  atoms  first order formulae  sentences defined usual  fitting 
       consider function symbols article assume formulae
function free  atom false  true  interpretations written    
atom fact contain variables  use standard first order notions
satisfiability  unsatisfiability  entailment  written     sets first order sentences 
assume p contains special equality inequality predicates  
respectively  atoms form  t    t     t    t    commonly written t  t 
t  t    respectively  make technical assumption distinct predicates
rather than  common first order logic  t  t  abbreviation  t  t    
furthermore  assume theory uses axiomatises semantics
follows      instantiated predicate p arity n   n 
x  y  x x  

   

x  y  x x 

   

x            xi           xn   yi   p  x            xi           xn   xi yi p  x            yi           xn   

   

x  x x 

   

x  y  z  x z x z 

   

note that  according assumption  set facts satisfiable  example 
set atoms  a b  b  satisfiable since b b positive variable free
atoms semantically independent other  moreover  axiom     required
obtain expected contradiction 
individual renaming  often renaming  partial function  
maps individuals individuals  domain range written dom  
rng    unless otherwise noted  assume dom   finite  object containing
individuals  such formula  set formulae  tuple individuals   ind  
set individuals occurring      obtained simultaneously replacing
individual ind   dom    a  
use notion substitutions first order logic  is  substitution
mapping variables terms  term  atom  formula  result applying
substitution written    
tbox finite set first order sentences contains axioms        whenever
and or used  abox finite set facts  note definition allows
atoms form b b aboxes  furthermore  since aboxes contain
positive atoms  abox  when considered without tbox  satisfiable 
   

ficuenca grau  motik  stoilos   horrocks

dl name
el
fl
alc
  h 
  r 
  s 
  i 
  q 
  o 

roles
r
r
r

concepts
  a  c  c    r c
  a  c  c    r c
    a  c  c  c    c  c    r c  r c
r self

tbox axioms
c  c 
c  c 
c  c 
r  r 
rs
trans r 

r
ns c  ns c
 a 

table    syntax standard description logics  typical extensions el  alc  fl
named appending calligraphic letters  h  r  s  i  q  and or o  
description logic dl  usually infinite  recursive set tboxes satisfying
following conditions 
dl renaming    t   dl 
dl   dl 

dl  say dl tbox  finally  fol largest description logic
contains finite sets first order sentences signature question 
next present overview dls commonly considered literature  typically  predicates dl signatures required unary binary  former
commonly called atomic concepts latter commonly called atomic roles  dls
typically use specialised syntax  summarised table    provides set constructors
constructing complex concepts roles simpler ones  well dierent kinds
axioms  using translation table    concepts translated first order
formulae one free variable  roles translated first order formulae two
free variables  axioms translated first order sentences  note translation uses counting quantifiers n n   expressed using ordinary
quantifiers equality well known transformations 
rest paper  commonly write tboxes aboxes dl syntax  however 
simplify presentation  identify written dl syntax  t    a  
    datalog 
next introduce fragment first order logic called datalog  extension
datalog cal  gottlob  lukasiewicz  marnette  pieris         datalog  rule
 or commonly rule  r formula form      bj atom dierent
whose free variables contained x 
       x  y       

  and    m  formula  x  yi   conjunction atoms dierent
whose free variables contained x yi  
   

ficompleteness guarantees incomplete ontology reasoners

mapping dl roles first order logic
 r  x  y    r x  y 
 r   x  y    r y  x 
mapping dl concepts first order logic
   x  y   
   x  y   
 a  x  y    a x 
  a   x  y    x
 c  x  y     c  x  y 
 c d  x  y     c  x  y   d  x  y 
 c d  x  y     c  x  y   d  x  y 
 r c  x  y    y   r  x  y   c  y  x  
 r self  x  y    r x  x 
 r c  x  y    y   r  x  y   c  y  x  
  ns c  x  y    n y   s  x  y   c  y  x  
  ns c  x  y    n y   s  x  y   c  y  x  
mapping tbox axioms first order logic
 c d    x   c  x  y   d  x  y  
 r s    x  y   r  x  y   s  x  y  
 trans r     x  y  z   r  x  y   r  y  z   r  x  z  
 r     x  y  z   r  x  y   s  y  z   t  x  z  
mapping abox axioms first order logic
 c a      c  a  y 
 r a  b     r a  b 
 a b    b
 a b    b
table    translation dl syntax first order logic

x  b        bn




i  

yi  i  x  yi   

   

rule safe variable x occurs bj   unless otherwise noted  rules
assumed safe  brevity  outer quantifier x commonly left implicit 
body r
set atoms body r     b            bn    head r formula
head r   
yi  i  x  yi    datalog  program finite set safe datalog  rules 
i  
note that  since treated ordinary predicates  occur rules  provided
semantics appropriately axiomatised  furthermore  note latter
achieved using datalog  rules 
let r datalog  rule  then  r datalog rule head r  contains existential
quantifier  also  r datalog rule      finally  r datalog rule    
head r single atom without existential quantifiers  ceri  gottlob    tanca        
several places paper  check whether set first order sentences entails
datalog  rule  accomplished using following simple result 
   

ficuenca grau  motik  stoilos   horrocks

proposition      let f set first order sentences  let r datalog  rule
form      then  substitution mapping free variables r distinct
individuals occurring f r  f    r
f   b              bn      




i  

yi  i   x   yi  

proof  let x tuple free variables r let arbitrary substitution
mapping variables x distinct individuals occurring f r  claim
proposition follows following equivalences 
f    x  b        bn




yi  i  x  yi   

i  



f   x b        bn
f  x  b        bn

f   b           bn  
f   b              bn   






yi  i  x  yi     unsatisfiable

 skolem  x 




i  

yi  i   x   yi    unsatisfiable

yi  i   x   yi    unsatisfiable

i  



f   b              bn      

yi  i  x  yi     unsatisfiable

i  



i  

i  






yi  i   x   yi   

    queries
order achieve high degree generality  define query q finite set firstorder sentences containing distinct query predicate q  intuitively  query predicate q
determines answers q  order simplify notation  typically assume
association q query predicate implicit  e g   may require query
contain precisely one predicate   assume query predicate occurs
tbox abox 
tuple constants certain answer query q query predicate q
respect tbox abox arity agrees arity q
q    q a   set certain answers q w r t  denoted
cert q    a   query predicate q propositional  i e   query boolean  
cert q    a  either empty contains tuple zero length  cases 
commonly write cert q    a    f cert q    a    t  respectively 
use special boolean query checks first order theory unsatisfiability 
thus  cert     a    unsatisfiable 
query q query predicate q union conjunctive queries  ucq 
datalog program rule contains q head body  ucq q
conjunctive query  cq  contains exactly one rule 
   

ficompleteness guarantees incomplete ontology reasoners

union conjunctive queries q ground if  rule r q  variable occurring body r occurs head r  roughly speaking  computing
cert q    a  ground q  variables q matched individuals
a  unnamed objects whose existence guaranteed existential quantifiers 
many state art reasoners used practice support ground ucqs  note
q    a x  q x   r x  y  q x  y   ground ucq  fact  q even valid
first order theory since predicate q unique arity  obtain ucq  one
pad head first rulethat is  one introduce special fresh individual null
rewrite rules q    a x  q x  null    r x  y  q x  y   
properties first order logic entailment  cert satisfies following properties
query q  tboxes   aboxes  
   monotonicity  imply
cert     a    implies cert         t 
cert q    a  cert q      

   invariance renamings  renaming tuple individuals a 
cert     a    implies cert    t     a     t 

cert q    a  implies  a  cert  q    t     a   
    rewritings
intuitively  rewriting query q w r t  tbox another query captures
information relevant answering q arbitrary abox  calvanese
et al         artale  calvanese  kontchakov    zakharyaschev        perez urbina et al  
       practice  ucqs  calvanese et al         datalog  perez urbina et al        
widely used target languages query rewriting  sake generality 
however  paper use notion datalog  rewriting 
definition      let q query let tbox  datalog  rewriting  or simply
rewriting  q w r t  triple r   rd   r   rq
rd datalog  program containing q    rd  
r datalog program head r    r r  
rq ucq whose query predicate q 
following properties hold abox a 
cert     a    cert   rd r   a  
cert     a    f  cert q    a    cert rq   rd r   a  
rewriting r datalog rewriting rd datalog program  furthermore  rewriting r
ucq rewriting rd     r usually written r   r   rq  
   

ficuenca grau  motik  stoilos   horrocks

note definition     requires    rd hold  precludes rewritings consisting
axioms unsound w r t    example  let q    a x  q x      
then  rd    b x  a x   satisfy definition rewriting since formula
b x  a x  logical consequence  
wide range q  datalog  rewriting q w r t  computed using
straightforward equivalence preserving transformations   optimised
eliminating axioms irrelevant answering q  furthermore  several
algorithms computing ucq datalog rewritings proposed literature 
example  calvanese et al         showed compute ucq rewriting cases
expressed logic dl lite family  approach extended
owl   ql profile owl    motik et al       a   similarly  perez urbina et al        
proposed algorithm computing simplest possible datalog rewriting
expressed description logic elhio 
rewritings produced known algorithms often contain predicates occur
q  predicates sometimes called fresh  example  many rewriting
algorithms normalise tboxes replacing complex concepts fresh atomic concepts 
rewriting r   rd   r   rq obtained way unlikely satisfy requirement
   rd   however  predicates occurring r often eliminated
via unfolding  example  let q    a x  q x      r s b a   assume
rewriting algorithm produces
rd    s x  y  b x  c x   r x  y  c y  a x   
satisfy definition      predicate c unfolded rd replaced
rd    r x  y  s y  z  b z  a x   
   rd holds  unfolding  however  may always possible  e g   might
case fresh predicates occur recursive axioms   may limit applicability results presented paper 

   completeness guarantees incomplete reasoners
section  introduce formal framework allow us establish completeness guarantees incomplete reasoners  results restricted particular
description logic  applicable tboxes satisfy following criterion 
definition      tbox admissible description logic dl exists
dl tbox  checking tbox satisfiability answering boolean ucqs w r t 
arbitrary abox decidable dl 
    concrete abstract reasoners
concrete reasoners complex software systems dier greatly functionality
supported interfaces  use range dierent implementation techniques 
make results general independent specific implementation techniques 
introduce notion abstract reasoner  abstract reasoner thought
   

ficompleteness guarantees incomplete ontology reasoners

idealised reasoner captures intended behaviour salient features class
concrete reasoners  concrete reasoner belonging class may use arbitrary algorithms 
long observable behaviour mirrors abstract reasoner 
definition      abstract reasoner ans description logic dl computable function takes input arbitrary dl tbox   arbitrary abox a  either
special unsatisfiability query arbitrary ucq q  return value ans defined
follows 
ans     a  either f 
ans     a    t  ans q    a  interest arbitrary 
ans     a    f  ans q    a  finite set tuples individuals 
arity tuple equal arity query predicate q 
abstract reasoner ans dl said applicable tbox dl tbox 
intuitively  ans     a  asks abstract reasoner check whether unsatisfiable  ans q    a  asks abstract reasoner evaluate q w r t  a 
unsatisfiable  tuple constants arity query predicate q
answer q a  therefore  result ans q    a  interest
ans     a    fthat is  ans identifies satisfiable 
example      consider abstract reasoners rdf  rdfs  rl  classify which  given
input ucq q  tbox   abox a  compute answer q w r t 
described next 
abstract reasoner rdf ignores evaluates q w r t  a  precisely  rdf     a    f
rdf q    a    cert q    a   thus  rdf captures behaviour rdf reasoners 
abstract reasoner rdfs evaluates q w r t  datalog program prdfs constructed translating rdfs axiom equivalent datalog rule 
precisely  rdfs     a    f rdfs q    a    cert q  prdfs   a   thus  rdfs captures
behaviour rdfs reasoners sesame 
abstract reasoner rl evaluates q w r t  datalog program prl constructed
translating owl   rl axiom equivalent datalog rule  precisely 
rl     a    cert   prl   a  rl q    a    cert q  prl   a   thus  rl captures behaviour
owl   rl reasoners jena oracles semantic data store 
abstract reasoner classify first classifies using complete owl   dl reasoner  is 
computes tbox containing subclass axiom b    b 
b atomic concepts occurring   abstract reasoner proceeds rl 
considers instead   precisely  classify     a    rl      
classify q    a    rl q    a   way  classify captures behaviour owl  
rl reasoners minerva dle jena try complete materialising
certain consequences  


ideal abstract reasoner one that  arbitrary ucq q  tbox  
abox a  ans     a    cert     a   ans q    a    cert q    a  whenever
ans     a    f  next introduce discuss several properties abstract reasoners
   

ficuenca grau  motik  stoilos   horrocks

likely aect close come ideal may relevant
applicability results 
following notion soundness describes abstract reasoners return answers
logically follow q    a 
definition      abstract reasoner ans dl sound following conditions hold
ucq q  dl tbox   abox a 
ans     a    implies cert     a    t 
ans     a    f implies ans q    a  cert q    a  
following notion monotonicity describes abstract reasoners extending
input tbox abox never leads dropping answers  consider weaker
notion  q    monotonicity  input query q tbox fixed 
definition      abstract reasoner ans dl monotonic following conditions
hold ucq q  dl tboxes   aboxes
 
ans     a    implies ans         t 
ans     a    f ans         f imply ans q    a  ans q      
given ucq q dl tbox   ans  q    monotonic following conditions
hold aboxes  
ans     a    implies ans         t 
ans     a    f ans         f imply ans q    a  ans q      
discussed section      logical consequences first order theory invariant
renaming merging individuals  define analogous properties abstract
reasoners  first introduce notions  stable  q    stable renamingsthat is 
renamings leave individuals occurring  respectively  q   unchanged 
definition      let q query  let tbox  let renaming  then  stable  a    individual dom   ind t    furthermore   q    stable
 a    individual dom   ind q   
following notion weak faithfulness describes abstract reasoners whose answers
invariant replacement individuals fresh individuals  furthermore  weak
 q    faithfulness relaxes property case q fixed 
definition      abstract reasoner ans dl weakly faithful following conditions hold ucq q  dl tbox   abox a  injective renaming   tuple a 
ans     a    ind t a  dom   imply ans    t     a     t 
ans     a    f  ind q a  dom    ans q    a  imply
ans    t     a     f  a  ans  q    t     a   
   

ficompleteness guarantees incomplete ontology reasoners

given ucq q dl tbox   ans weakly  q    faithful following conditions
hold abox a  injective renaming   tuple a 
ans     a    t  ind t a  dom     stable imply ans      a     t 

ans     a    f  ind q a  dom     q    stable  ans q    a 
imply ans      a     f  a  ans q     a   
following notion strong faithfulness describes abstract reasoners whose answers
invariant merging individuals  furthermore  strong  q    faithfulness relaxes
property case q fixed 
definition      abstract reasoner ans dl strongly faithful following conditions hold ucq q  dl tbox   abox a  renaming   tuple a 
ans     a    implies ans    t     a     t 
ans     a    f  ans q    a   ans    t     a     f imply
 a  ans  q    t     a   
given ucq q dl tbox   ans strongly  q    faithful following conditions hold abox a  renaming   tuple a 
ans     a     stable imply ans      a     t 
ans     a    f   q    stable  ans q    a   ans      a     f imply
 a  ans q     a   
results present rest paper applicable abstract
reasoners satisfy various combinations properties  minimum  require
 q    monotonicity weak  q    faithfulness  abstract reasoners described example     satisfy properties  testing case concrete reasoners may 
however  infeasible practice  indeed  aware technique would allow one check whether concrete reasoner satisfies required properties  believe 
however  concrete reasoners commonly used practice intended sound 
monotonic  least weakly faithful  strong faithfulness reasonable assumption cases  concrete reasoner fails satisfy properties
certain inputs  likely due implementation bugs  thus  consequent failure
completeness seen bug  detecting situations viewed
part general problem testing software systems 
next present several examples abstract reasoners satisfy
mentioned properties 
example      consider abstract reasoner behaves rdf whenever number
assertions input abox smaller certain threshold  returns
empty set answers larger aboxes  intuitively  abstract reasoner characterises
concrete rdf reasoner processes inputs certain size  reasoner
 q    monotonic arbitrary q  

   

ficuenca grau  motik  stoilos   horrocks

example       consider abstract reasoner behaves rdf  that  trust
reasons  removes input abox assertions whose individuals blacklisted
 e g   come untrusted source   abstract reasoner weakly  q   faithful arbitrary q  

example      suggests that  abstract reasoner weakly faithful 
make decisions depend specific names individuals 
example       consider abstract reasoner rl  that  given input ucq q  tbox
  abox a  proceeds follows  first  rl  computes abox obtained
evaluating datalog program prl example     a  second  rl  computes
query q  obtained q adding body rule r q inequality x
pairs distinct variables x occurring r  third  rl  evaluates q 
considering databasethat is  finite first order interpretation
individual mapped  and thus dierent individuals distinct   thus  rl  characterises concrete reasoners evaluate queries matching dierent variables dierent
individuals  abstract reasoner rl  sound  monotonic  weakly faithful 
strongly faithful  example  given query q    r x  y  q x    abox    r a  b   
renaming    a c  b c   rl   q    a     a   rl   q     a      
example      suggests that  abstract reasoner strongly faithful 
allow distinct variables queries axioms mapped individuals 
next identify classes abstract reasoners use throughout paper  note
soundness required  contributes generality results 
definition       given ucq q tbox   cwq t  csq t   class  q   monotonic weakly  strongly   q    faithful abstract reasoners applicable  
finally  note abstract reasoners introduced example     sound  monotonic  strongly  and therefore weakly  faithful  consequently  concrete reasoners
based reasoning techniques outlined example     considered sound  monotonic 
strongly faithful  modulo implementation bugs 
    completeness abstract reasoners
next define central notion abstract reasoner completeness given query q
tbox   intuitively   q    complete abstract reasoner indistinguishable
complete abstract reasoner applied q    arbitrary abox a 
definition       let dl description logic  let ans abstract reasoner dl 
then  ans  q    complete ucq q dl tbox following conditions
hold abox a 
cert     a    t  ans     a    t 
cert     a    f ans     a    f  cert q    a  ans q    a  
finally  ans complete  q    complete ucq q dl tbox  
   

ficompleteness guarantees incomplete ontology reasoners

example       consider el tbox consisting following axioms  translation
axioms first order logic shown symbol 
takesco mathco st



mathst takesco mathco



calcco mathco



st prof



x  y  takesco x  y  mathco y  st x  
x  calcco x  mathco x  

   
   

x  mathst x  y  takesco x  y  mathco y       
x  st x  prof x   

    

axiom     states everyone taking maths course student  axiom     states
calculus course maths course  axiom     states maths student takes
maths course  axiom      states person student
professor  axiom     rdfs axiom  axioms apart     owl
  rl axioms  consider query      retrieves students taking maths course 
q    st x  takesco x  y  mathco y  q x  

    

none abstract reasoners rdf  rdfs  rl  classify example     complete
general answering ucqs el tboxes  furthermore  q previous
paragraph  abstract reasoners rdf  rdfs  rl  q    complete  return
empty set answers abox    mathst c    contrast  following sections
show abstract reasoner classify  q    completethat is  returns
certain answers q    arbitrary abox a 

    test suites
checking  q    completeness concrete reasoner applying reasoner possible
aboxes comparing reasoners answers complete reasoner clearly
infeasible practice since infinitely many candidate input aboxes  obtain
practical approach  need finite number tests  formalise idea using
following definition 
definition       let tbox   test suite pair     sq
finite set aboxes cert     a     
sq finite set pairs a  abox cert     a    f
ucq 
abstract reasoner ans applicable passes  test suite ans satisfies
following two conditions 
  ans     a    t 
a  sq   ans     a    f  cert y    a  ans y    a  
let q ucq  let c class abstract reasoners applicable   then 
exhaustive c q ans c passes  q    complete 
 test suite q simple q query occurring sq   then  sq commonly written set aboxes  a  q sq commonly abbreviated sq  
   

ficuenca grau  motik  stoilos   horrocks

intuitively   test suite     sq determines tests abstract reasoner
subjected to  reasoner pass s  must correctly identify abox
unsatisfiable  aboxquery pair a  sq reasoner must
correctly answer w r t  a 
given q   goal identify  test suite exhaustive qthat
is  test suite abstract reasoner passes guaranteed  q   complete  depending properties abstract reasoners  however  dierent test suites
may may achieve goal  therefore  notion exhaustiveness relative
class abstract reasoners c  exhaustive class abstract reasoners c 
used test arbitrary abstract reasoner c  note depends
target class abstract reasoners  actual abstract reasoner tested 
order words  construction depends properties one assume hold
target abstract reasoner  furthermore  abstract reasoner contained c
passes s  general imply  q    completeness guarantee 
example       let q specified example       let a  a 
following aboxes 
a     takesco c  d   mathco d  
a     takesco c  d   calcco d  
a     mathst c  

a     takesco c  c   mathco c  
a     takesco c  c   calcco c  
a     st c   prof c  

following sections  show q simple  test suite     sq defined
   a    sq    a            a    exhaustive class cwq t q  consequently 
used test abstract reasoners example     
particular  note abstract reasoners rdf rdfs fail tests sq  
abstract reasoner rl fails test a  sq   furthermore  failed tests provide counterexample  q    completeness  contrast  abstract reasoner classify example
     passes tests s  implies abstract reasoner indeed  q    complete 
finally  consider variant abstract reasoner classify that  similarly abstract
reasoner described example      returns empty set answers input abox
contains than  say  ten assertions  abstract reasoner  q    monotonic
hence belong cwq t   abstract reasoner clearly passes s  however  since
belong cwq t   passing  correctly  imply abstract reasoner
 q    complete 

next state following property  proof trivial 

proposition       let q ucq  let tbox  let c  c  classes
abstract reasoners applicable c  c   
    test suite exhaustive c  q  exhaustive c  q 
    test suite exists exhaustive c  q   test suite exists
exhaustive c  q 
therefore  proving existence  test suite exhaustive q  general
result one applies largest possible class abstract reasoners  furthermore 
   

ficompleteness guarantees incomplete ontology reasoners

following section identify cases  test suite exhaustive q
found  proposition      suces provide nonexistence results smallest
possible class abstract reasoners 
finish section pointing important practically relevant property
q simple  test suites  illustrated example      
proposition       let     sq q simple  test suite let ans abstract
reasoner applicable   ans pass s  ans  q    complete 
proof  abox sq ans satisfy conditions definition
     counterexample  q    completeness ans 
thus  q simple  test suite exhaustive c q provides sucient necessary test  q    completeness abstract reasoners c  contrast 
q simple  show section     provides sucient 
necessary test  q    completeness abstract reasoners c 
    negative results
sections      resp  section      identify restrictions ucq q tbox
guarantee existence  test suites exhaustive cwq t  resp  csq t   q 
presenting positive results  first outline limits  q    completeness testing
thus justify restrictions use following sections 
      monotonicity weak faithfulness
approaches testing  q    completeness abstract reasoners applicable
reasoners  q    monotonic weakly  q    faithful  section  provide
formal justification requirements form following two theorems 
theorem      shows exhaustive test suites exist consider class
abstract reasoners satisfying properties section     apart  q   monotonicity  includes soundness  strong faithfulness  which implies weak faithfulness   monotonicity w r t  tbox only 
theorem      shows exhaustive test suites exist consider class
abstract reasoners satisfying properties defined section     exception
 q    weak faithfulness  properties include soundness monotonicity 
negative results theorems           strong  hold smallest
classes abstract reasoners define based notions introduced section      by
proposition       smaller class abstract reasoners  general negative
result   hold regardless q considered  modulo minor technicality 
unlike theorem       theorem      requires satisfiable  
proof theorem      intuitively understood follows  first assume
 test suite exhaustive q class abstract reasoners
theorem applies  then  specify abstract reasoner ans right thing  i e  
returns correct answer  given input query q  tbox  
   

ficuenca grau  motik  stoilos   horrocks

arbitrary abox containing many assertions largest test abox s 
otherwise  ans returns sound  incomplete answer  finally show following
three properties ans 
abstract reasoner ans belongs relevant class abstract reasoners 
abstract reasoner ans passes s 
abstract reasoner ans incomplete least one input abox 
three properties show exhaustive q relevant class
abstract reasoners  intuitively  means class abstract reasoners large 
allowing abstract reasoners treat input erratic way 
theorem       let q arbitrary ucq  let arbitrary admissible tbox 
then   test suite exists exhaustive q class sound strongly
faithful abstract reasoners applicable satisfying following conditions tbox
abox a 
ans     a    implies ans     a    t 
ans     a    f ans     a    f imply ans q    a  ans q    a  
proof  consider arbitrary  test suite     sq   let n maximum number
assertions abox s  furthermore  let ans abstract reasoner takes
input ucq qin   fol tbox tin   abox   result ans   tin    
determined follows 
   try find renaming dom     ind t    t   tin  
exists  return f 
   contains n assertions  check satisfiability  t   using
sound complete reasoner  return  t   unsatisfiable 
   return f 
furthermore  result ans qin   tin     determined follows 
   try find renaming dom     ind q     t   tin    q    qin  
exists  return  
   contains n assertions  compute cert  q    t      using sound
complete reasoner return result 
   return  
since admissible  checks steps     performed finite time  furthermore  step   realised enumerating mappings ind t   ind tin    step
  realised analogously  consequently  ans implemented terminates
inputs  see ans sound monotonic w r t  tbox  consider arbitrary
input qin   tin   tin   tin tin  
   

ficompleteness guarantees incomplete ontology reasoners

assume ans   tin       t  then  qin   tin   abstract reasoner
returns step    t   unsatisfiable  then  since  t   tin  
tin unsatisfiable well  required soundness  furthermore 
since  t   tin tin   qin   tin   abstract reasoner returns step  
well  ans   tin       t  required monotonicity w r t  tbox 
assume ans qin   tin      then  qin   tin   abstract reasoner
returns step    therefore cert  q    t       then  since
 q    qin  t   tin   cert qin   tin      required soundness  furthermore  since  t   tin tin   qin   tin   abstract reasoner
returns step   well  ans qin   tin      required monotonicity w r t 
tbox 
see ans strongly faithful  consider arbitrary renaming   renaming
exists  q    qin  t   tin   clearly renaming exists
 q     qin    t    tin    consequently  ans   tin     returns step   
ans    tin     ain    returns step   well  similarly  ans qin   tin     returns step
   ans  qin     tin     ain    returns step   well  clearly  ans strongly faithful 
finally  straightforward see ans passes s 
let abox containing least n     assertions cert q    a     
clearly exists  unsatisfiable  ans     a    f  furthermore 
satisfiable  ans q    a      consequently  ans  q    complete  thus 
exhaustive q class abstract reasoners considered theorem 
next prove theorem       proof similar proof theorem      
main dierence abstract reasoner ans construct  particular  given test
suite s  take ans return correct answer query q  tbox  
abox contains individuals occurring s  otherwise  abstract reasoner
returns sound  incomplete answer  again  class abstract reasoners
large  allowing ans treat inputs erratic way 
unlike theorem       following theorem requires satisfiable  understand
why  consider arbitrary unsatisfiable tbox ucq q  let     sq
 test suite defined       i e   contains single empty abox  sq    i e  
sq contains aboxes   consider arbitrary monotonic abstract reasoner ans
passes   since ans passes s  ans         t  then  since ans monotonic 
arbitrary abox ans     a    well  turn implies ans
 q    complete  failure satisfy weak faithfulness thus irrelevant unsatisfiable 
theorem       let arbitrary admissible satisfiable tbox let q
arbitrary ucq  then   test suite exists exhaustive q class
sound monotonic abstract reasoners applicable  
proof  consider arbitrary  test suite     sq   let set individuals
occurring s  q    furthermore  let ans abstract reasoner takes
input ucq qin   fol tbox tin   abox   result ans   tin    
determined follows 
   tin   return f 
   

ficuenca grau  motik  stoilos   horrocks

   let ain i set assertions mention individuals i 
   check satisfiability ain i using sound complete reasoner  return
ain i unsatisfiable  return f otherwise 
furthermore  given ucq qin   result ans qin   tin     determined follows 
   tin q  
qin   return  
   let ain i set assertions mention individuals i 
   compute cert q    ain i   using sound complete reasoner return result 
ans implemented terminates inputs shown
proof theorem       furthermore  soundness ans follows following
two observations 
assume ans   tin       t  then  abstract reasoner returns step   since
ain i unsatisfiable  then  since tin ain i  
tin unsatisfiable well  required 
assume ans qin   tin      then  abstract reasoner returns step   
therefore cert q    ain i    then  since q   qin   tin  
ain i   cert qin   tin      required 
monotonicity  consider arbitrary tin tin tin  
clearly  tin ain i ain i   then  monotonicity first order logic 
ans   tin       implies ans   tin       t  ans q  tin     ans q  tin      finally  straightforward see ans passes s 
consider arbitrary abox ind a    cert q    a     
clearly exists  unsatisfiable  since abox constructed step   empty
satisfiable  ans     a    f  furthermore  satisfiable  since
abox constructed step   empty  ans q    a  cannot contain individuals occurring
i  consequently  ans  q    complete  thus  exhaustive q
class abstract reasoners considered theorem 
      monotonicity weak faithfulness suffice
next  show  q    monotonicity  q    faithfulness general guarantee
existence  test suite exhaustive q  particular  theorem      shows that 
contains single recursive axiom  test suite exists exhaustive class
sound  monotonic  strongly faithful abstract reasoners  and proposition     
csq t cwq t well  ucq q   although result applicable
particular q   straightforward adapt proof tbox recursive
axiom relevant given query  example       however  shows concept
relevance rather dicult formalise  even entails recursive axiom  axiom
necessarily relevant answering query  order complicate matters
further  state following result fixed q   hope proof clearly
illustrates limitations incurred recursive axioms 
   

ficompleteness guarantees incomplete ontology reasoners

theorem       q    a x  q x      r a a    test suite exists
exhaustive q class sound  monotonic  strongly faithful abstract
reasoners applicable  

proof  consider arbitrary  test suite     sq   since  test suite 
contains aboxes unsatisfiable  clearly  abox exists
stated theorem      let sq arbitrary  finite  set pairs a 
abox ucq  let n maximum number assertions abox
sq   furthermore  consider following abox  ai   aj     j n     
an      r a    a             r an   an      a an     
next construct abstract reasoner pevaln following properties 
 p   a  sq   cert y    a  pevaln  y    a  
 p   a  pevaln  q    an     
 p   pevaln sound  monotonic  strongly faithful 
note a  cert q    an      three properties imply exhaustive
q class abstract reasoners considered theorem 
abstract reasoner pevaln accepts input fol tbox tin abox  
result pevaln    tin     determined follows 
   return f 

furthermore  given ucq qin   result pevaln  qin   tin     determined follows 
   tin q  
qin   return  
   asat   
   repeat following computation n times 
asat    asat   a x     substitution s t    r x  y     a y    asat  
   return cert q    asat   

abstract reasoner pevaln clearly satisfies property  p   deriving assertion a a   
requires n   iterations loop step    furthermore  pevaln satisfies  p  
every abox occurring sq contains n individuals seen
rule r x  y  a y  a x   pevaln applies n times input abox  
finally show  p    abstract reasoner pevaln clearly sound  furthermore 
renaming  t      q    q  pevaln clearly strongly faithful 
show pevaln monotonic  consider arbitrary tin   tin    
tin tin   since pevaln    tin       f input  following
relevant cases 
pevaln returns step   input qin   tin     case either tin
q   qin   since tin tin   clearly pevaln returns step   input qin   tin  
  monotonicity holds 
   

ficuenca grau  motik  stoilos   horrocks

pevaln returns step   input qin   tin     then  pevaln return either
step   step   input qin   tin   former case  monotonicity holds
trivially  latter case  pevaln  qin   tin     pevaln  qin   tin     follows
directly fact  
following example shows presence recursive axioms preclude existence  test suite exhaustive q 
example       consider q defined follows 
q    a x  b x  q x  
   r a a  b r a 
note contains axiom mentioned theorem       however  note
   b a 
r      b x  q x  

ucq rewriting q w r t    section     show existence ucq rewriting q w r t  guarantees existence q simple  test suite exhaustive cwq t
 and hence csq t   q  example         b a     one  test suite 
intuitively     b consequence relevant answering q  hence 
   b a  q    a x  q x    cert q    a    cert q     a 
arbitrary abox a  hence  recursive axiom irrelevant answering q 
therefore presence preclude existence  test suite exhaustive
cwq t q 

    testing  q    monotonic weakly  q    faithful abstract reasoners

section  identify sucient condition guarantees existence q simple
 test suite exhaustive cwq t q  proposition       result applies csq t
well  roughly speaking  always computed instantiating rules
ucq rewriting q w r t  suitable way  requirement q ucqrewritable w r t  invalidates negative result theorem      since ucq rewriting
q    a x  q x   w r t     r a a  exists 
result allows one compute q simple  test suites exhaustive q numerous
practically relevant cases  particular  ucq rewriting guaranteed exist
expressed dls underpinning ql profile owl    motik et al       a  calvanese
et al          furthermore  illustrated example       ucq rewriting may exist even
expressed fragments owl   owl   el  motik et al       a 
baader  brandt    lutz         practice  rewritings computed using systems
quonto  acciarri et al         requiem  perez urbina et al         
establish desired result two steps  first  section       present general
characterisation q simple  test suites exhaustive cwq t q  then  section
      use characterisation establish desired connection rewritings
q simple  test suites exhaustive q 
   

ficompleteness guarantees incomplete ontology reasoners

      characterisation simple exhaustive test suites
next prove q simple  test suite     sq exhaustive cwq t q
contains isomorphic copy data pattern  i e   subset abox 
produce certain answer q w r t    preserves identity
individuals occurring q  show sucient 
necessary condition existence exhaustive  test suite  observe that 
contain one copy data pattern  always find abstract reasoner
cwq t passes misses certain answers obtained via missing data pattern
therefore  q    complete 
theorem       let q ucq  let admissible tbox  let     sq
q simple  test suite  then  exhaustive cwq t q following
properties satisfied abox a 
   unsatisfiable  exist abox injective  stable
renaming dom     ind t    a   a 
   satisfiable  tuple cert q    a  exist abox
sq   tuple b cert q       injective  q    stable renaming
 b    a  dom     ind q     a   a 
proof     let arbitrary q simple  test suite satisfies properties     
next show exhaustive cwq t q  consider arbitrary abstract reasoner
ans cwq t passes sthat is  ans satisfies following two properties 
 a  ans          
 b  ans         f implies cert q      ans q      sq  
next show ans  q    completethat is  ans satisfies two conditions
definition      arbitrary abox a  arbitrary a  following
two possibilities  depending satisfiability a 
assume unsatisfiable  since satisfies property    exist abox
injective  stable renaming s t  dom     ind t    a   a 
condition  a  ans         t  since ans weakly  q    faithful  injective
 stable  dom     ind t    ans      a      t  finally  since ans
 q    monotonic  a   a  ans     a    t  required definition      
assume satisfiable ans     a    f  furthermore  consider arbitrary tuple cert q    a   since satisfies property    exist abox sq  
tuple b cert q       injective  q    stable renaming  b    a 
dom     ind q     a   a  since  a   a  ans     a    f  ans
 q    monotonic  ans      a      f  furthermore  ind t   dom   
injective  q    stable  ans weakly  q    faithful  ans      a      f implies ans         f  then  condition  b  cert q      ans q      
b ans q       since ans weakly  q    faithful  injective  q    stable 
dom     ind q     b  ans q     a     since  b    a 
   

ficuenca grau  motik  stoilos   horrocks

ans q     a     finally  since ans  q    monotonic  a   a 
ans q    a   required definition      

   assume exhaustive cwq t q  next show properties    
satisfied arbitrary abox a  end  consider particular abstract reasoner
ans prove ans cwq t ans passes s  abstract reasoner
help us identify abox  tuple  renaming required prove properties     
let ans abstract reasoner takes input ucq qin   fol tbox tin  
abox   result ans   tin     determined follows 
    
tin   return f 

   abox   following 
 a  check satisfiability using sound  complete  terminating
reasoner 
 b  unsatisfiable  injective  stable renaming exists
dom     ind t    a     return t 
   return f 
furthermore  result ans qin   tin     determined follows 
    
tin q  
qin   return  
       
   tuple constants occurring arity equal arity query
predicate q  sq following 
 a  compute c    cert q      using sound  complete terminating reasoner 
 b  tuple b c injective  q    stable renaming exist
 b    a  dom     ind q     a     add out 
   return out 
next show ans belongs cwq t   end  prove ans terminates
inputs   q    monotonic weakly  q    faithful 
termination  since admissible  checking satisfiability computation
cert q      decidable  relevant sound  complete terminating reasoners
exist  furthermore  checking whether  stable  resp   q    stable  injective renaming
exists done enumerating renamings ind t    resp  ind q   
ind t    resp  ind q     therefore  ans implemented
terminates input 
 q    monotonicity  consider arbitrary input qin   tin      
assume ans   tin       t  tin abstract reasoner terminates
step   b    then  since  a     tin
abstract reasoner terminates step   b   ans   tin       t 
required 
   

ficompleteness guarantees incomplete ontology reasoners

assume ans   tin       f ans   tin       f  consider arbitrary
tuple ans qin   tin      added step   b  sq
  then  since  a     qin   tin   abstract reasoner
adds step   b   ans qin   tin      required 
weak  q    faithfulness  consider arbitrary input qin   tin     arbitrary
injective renaming  
assume ans   tin       t  dom   ind t a    stable  thus 
tin abstract reasoner terminates step   b    let
renaming  c      c   c ind t    clearly 
dom      ind t    renaming  stable injective   a    ain   
thus  tin  ain   abstract reasoner terminates step   b   therefore
ans   tin    ain      t  required 
assume ans   tin       f  dom   ind q a    q    stable 
consider arbitrary truple ans qin   tin      added step
  b  sq     b  let renaming defined s t   c      c  
individual c ind q    clearly  dom      ind q   
renaming  q    stable injective   a    ain     b     a   thus 
qin   tin    ain   abstract reasoner terminates step   b  clearly
 a  ans qin   tin    ain     required 
concludes proof ans cwq t   furthermore  ans clearly passes s  then 
since exhaustive cwq t q  abstract reasoner ans  q    complete  next
prove main claim theorem  end  consider arbitrary abox a 
following possibilities  depending satisfiability a 
assume unsatisfiable  ans     a    t  abstract reasoner
returns step   b  abox  stable renaming
 a   dom     ind t    thus  property   holds required 
assume satisfiable  consider arbitrary tuple cert q    a  
ans     a    f ans q    a   added step   b 
abox sq   tuple b cert q       injective  q    stable renaming
 b    a  dom     ind q     a   a  thus  property  
holds required 
following example illustrates theorem      
example       let q specified example       let     sq
specified example       show section        exhaustive cwq t q 
consider abox    st a   mathst b   takesco a  b      clearly  satisfiable cert q    a     b   theorem       certain answer obtained
evaluating q w r t  abox sq   indeed  note abox a  sq isomorphic
subset    mathst b   via renaming    b c   applying q
a  produces c  isomorphic b via  
   

ficuenca grau  motik  stoilos   horrocks

note that  remove a  s  longer  test suite
exhaustive q  example  abstract reasoner rl example      would pass
test suite  would return required certain answers applied a   and 
consequently  applied either  

      computing test suites exhaustive cwq t

based theorem       section show  test suite exhaustive cwq t
q obtained instantiating ucq rewriting r q w r t  is  replacing
variables r individuals possible ways  please note instantiation
must full  sense possible replacements must considered 
class cwq t contain abstract reasoners rl  example     
strongly faithful may incorrectly handle case distinct variables bound
individuals 
definition       let set individuals  let r datalog rule  let
substitution  then  instantiation substitution r w r t   x 
variable x occurring r  latter holds  instantiation r w r t  abox
ar      b    b body r   
let q ucq  let tbox  let r   r   rq ucq rewriting q w r t 
  let maximum number distinct variables occurring rule r  let
set containing individuals occurring r  q    well fresh individuals 
r i
r i
full instantiation r w r t  pair er i   er i
er i
q
  eq e
smallest sets aboxes
ar er i
r r instantiation substitution r w r t  i 
ar er i
q r rq instantiation substitution r w r t 
cert   r   ar     f 
er i clearly unique renaming fresh individuals i  typically left
r
implicit  one talks full instantiation er   er
  eq r 
example       let q specified example       let r   r   rq
r    st x  prof x    rq consists following datalog rules 
takesco x  y  mathco y  q x 
takesco x  y  calcco y  q x 
mathst x  q x 

then  r ucq rewriting q w r t    one see q simple  test suite
    sq example      full instantiation r 


following theorem shows full instantiation ucq rewriting q w r t 
q simple  test suite exhaustive cwq t q  according theorem 
 test suite example      exhaustive cwq t q 
   

ficompleteness guarantees incomplete ontology reasoners

theorem       let q ucq  let admissible tbox  let r   r   rq
r
ucq rewriting q w r t    let er   er
  eq full instantiation r  then 
er q simple  test suite exhaustive cwq t q 

proof  let set individuals er obtained from  first show er
q simple  test suitethat is  satisfies two properties definition      
consider arbitrary abox er
  then  rule r r instantiation
substitution r exist   ar   clearly cert    r   a    t  since r
ucq rewriting  unsatisfiable  required 
consider arbitrary abox er
q   then  cert   r   a    f definition      
since r ucq rewriting  satisfiable  required 
next show er satisfies properties     theorem      arbitrary
abox a 
 property    assume unsatisfiable  since r ucq rewriting 
definition     cert   r   a    t  then  rule r r substitution
exist ar cert    r   ar     t  let injective renaming
individual c occurring r  c    c  individual
occurring ar r  d  fresh individual i 
exists since number variables r smaller equal number fresh individuals
i  let instantiation substitution r  x      x   variable
r
x occurring r  ar er
holds since e full instantiation r w r t  i  let
injective renaming coincides inverse individual occurring
ar   r    exists since injective range contains individual
occurring ar   r    clearly  ar     ar holds   ar   a  furthermore 
clearly  stable  thus  property     satisfied ar er
 
 property    assume satisfiable  consider arbitrarily chosen tuple
cert q    a   since r ucq rewriting  definition     cert   r   a    f
cert rq   r   a   then  clearly cert rq     a  well  then  rule r rq
substitution exist ar cert  r     ar    let injective
renaming individual c occurring r  q   c    c 
individual occurring ar r  q   d  fresh
individual i  clearly exists since number variables r smaller equal
number fresh individuals i  let instantiation substitution r
r
 x      x   variable x occurring r  ar er
q holds since e
full instantiation r w r t  i  let injective renaming coincides
inverse individual occurring ar   r  q    exists since
injective range contains individual occurring ar   r  q   
furthermore  clearly tuple b cert  r     ar   exists  head r     q b   since
r ucq rewriting ar satisfiable  b cert q    ar    furthermore 
since injective   b    clearly holds  then  property     satisfied ar er
q 

  b 
   

ficuenca grau  motik  stoilos   horrocks

      minimising exhaustive test suites
practice  clearly beneficial compute test suites small possible 
goal achieved applying known techniques minimising ucq rewritings
 calvanese et al         perez urbina  horrocks    motik         theorem      
smallest rewriting instantiated obtain exhaustive test suite 
state art query rewriting systems employ subsumption condensation techniques order reduce size rewriting  datalog rule r subsumes datalog rule
r substitution exists  r  r   intuitively  r general r  
rewriting contains rules r r   r safely removed rewriting 
furthermore  rule r contains distinct unifiable body atoms bi bj   condensation
r rule  r  general unifier bi bj   rewriting contains
rule r  r  subsumes r  rule safely replaced  r   following
example illustrates techniques used obtain small test suites 
example       let q specified example       let r rewriting
q w r t  example       r   r   rq rq consists following
rules ucq rewriting q w r t   
takesco x  y  takesco x  z  mathco y  q x 

    

takesco x  y  calcco y  q x 

    

mathst x  q x 

    

takesco x  x  calcco x  mathco x  q x 

    

st x  mathst x  q x 

    

theorem       full instantiation r  test suite exhaustive cwq t
q  rewriting r   however  contains redundancy hence resulting test suite
unnecessarily large  particular  applying condensation query       subsumption
queries            subsumption queries            obtain
simpler rewriting r 

finally  note test suites obtained via full instantiation contain isomorphic
aboxes  clearly  isomorphic copies abox safely eliminated test
suite without losing exhaustiveness cwq t q 
    testing  q    monotonic strongly  q    faithful abstract reasoners

due full instantiation  test suites obtained definition      exponentially larger
rewriting generated from  result  even rewritings moderate size
yield test suites containing thousands aboxes  intuitively  full instantiation required
obtain test suite exhaustive class cwq t class contains abstract
reasoners rl  example       correctly handle case
distinct variables query matched individual 
section  show test suites exhaustive class csq t obtained
injective instantiation rewritingthat is  replacing variable distinct
fresh individual  test suites obtained way linear size rewriting 
thus substantially smaller test suites obtained full instantiation 
   

ficompleteness guarantees incomplete ontology reasoners

example       let q specified example       let     sq
q simple  test suite example       furthermore  consider abstract reasoner rl 
example      weakly  strongly  q    faithful  easy check
rl  returns complete answers a  a    a  a    therefore  theorem
      exhaustive cwq t q  must include sq aboxes a  a   
respectively obtained aboxes a  a  merging individual c 
strongly  q    faithful abstract reasoners  however  correctly handle inputs obtained
merging individuals  based observation  section show q simple
 test suite     sq sq    a    a    a     obtained injectively instantiating
rewriting r example       exhaustive csq t q 



section      first develop characterisation q simple  test suites
exhaustive csq t q  result analogous theorem      

theorem       let q ucq  let admissible tbox  let     sq
q simple  test suite  then  exhaustive csq t q following
properties satisfied abox a 
   unsatisfiable  exist abox  stable renaming
dom     ind t    a   a 
   satisfiable  tuple cert q    a  exist abox
sq   tuple b cert q        q    stable renaming  b    a 
dom     ind q     a   a 
proof     let arbitrary q simple  test suite satisfies properties     
next show exhaustive csq t q  consider arbitrary abstract reasoner
ans csq t passes sthat is  ans satisfies following two properties 
 a  ans          
 b  ans         f implies cert q      ans q      sq  
next show ans  q    completethat is  ans satisfies two conditions
definition      arbitrary abox a  arbitrary a  following
two possibilities  depending satisfiability a 
assume unsatisfiable  since satisfies property    exist abox
 stable renaming dom     ind t    a   a 
condition  a  ans         t  since ans strongly  q    faithful stable  ans      a      t  finally  since ans  q    monotonic  a   a 
ans     a    t  required definition      
assume satisfiable ans     a    f  furthermore  consider arbitrary tuple cert q    a   since satisfies property    exist abox sq  
tuple b cert q        q    stable renaming  b    a   a   a 
dom     ind q    since  a   a  ans     a    f  ans  q    monotonic 
ans      a      f  furthermore   q    stable ans strongly faithful  ans      a      f implies ans         f  then  condition  b 
cert q      ans q       b ans q       ans strongly  q    faithful
   

ficuenca grau  motik  stoilos   horrocks

 q    stable   b  ans q     a     since  b    a  ans q     a    
finally  since ans  q    monotonic  a   a  ans q    a   required
definition      
   assume exhaustive csq t q  next show properties    
satisfied arbitrary abox a  end  consider particular abstract reasoner
ans prove ans csq t ans passes s  abstract reasoner
help us identify abox  tuple  renaming required prove properties     
let ans abstract reasoner takes input ucq qin   fol tbox tin  
abox   result ans   tin     determined follows 
    
tin   return f 
   abox   following 
 a  check satisfiability using sound  complete  terminating
reasoner 
 b  unsatisfiable   stable renaming exists
dom     ind t    a     return t 
   return f 
furthermore  result ans qin   tin     determined follows 
    
tin q  
qin   return  
       
   tuple constants occurring arity equal arity query
predicate q  sq following 
 a  compute c    cert q      using sound  complete terminating reasoner 
 b  tuple b c  q    stable renaming exist  b    a 
dom     ind q     a     add out 

   return out 
next show ans belongs csq t   proofs ans terminates
 q    monotonic analogous proofs theorem       show strong  q   faithfulness  consider arbitrary qin   tin     arbitrary renaming  
assume ans   tin        stable  thus  tin abstract
reasoner terminates step   b    let renaming
 c      c   c ind t    clearly  dom      ind t   
renaming  stable   a    ain    thus  tin  ain   abstract
reasoner terminates step   b   ans   tin    ain      t  required 
assume ans   tin       f  q    stable  consider arbitrary
tuple ans qin   tin      added step   b  sq  
   

ficompleteness guarantees incomplete ontology reasoners

  b  let renaming defined  c      c   individual c ind q    clearly  dom      ind q    mapping
 q    stable   a    ain     b     a   thus  qin   tin    ain  
abstract reasoner terminates step   b    a  ans qin   tin    ain     required 
concludes proof ans csq t   furthermore  ans clearly passes s  then 
since exhaustive csq t q  abstract reasoner ans  q    complete  main
claim theorem shown theorem      
next use theorem      show q simple  test suite exhaustive
q obtained injective instantiation ucq rewriting q w r t   

csq t

definition       let q ucq  let tbox  let r   r   rq ucq rewriting
q w r t    let substitution mapping variable occurring r distinct
r 
fresh individual  injective instantiation r w r t  pair ir    ir 
  iq
ir 
ir 
smallest sets aboxes
q

ar ir 
r r  

ar ir 
r rq cert   r   ar     f 
q
ir  clearly unique renaming fresh individuals   typically left
r
implicit  one talks injective instantiation ir   ir
  iq r 
theorem       let q ucq  let admissible tbox  let r   r   rq
r
ucq rewriting q w r t    let ir   ir
  iq injective instantiation r 
then  ir q simple  test suite exhaustive csq t q 

proof  let substitution ir obtained from  first show ir
q simple  test suitethat is  satisfies two properties definition      
r
consider arbitrary ir
  then  rule r r exist     clearly
cert    r   a    t  since r ucq rewriting  unsatisfiable  required 

consider arbitrary ir
q   then  cert   r   a    f definition       since r
ucq rewriting  satisfiable  required 
next show ir satisfies properties     theorem      arbitrary
abox a 
 property    assume unsatisfiable  since r ucq rewriting 
definition     cert   r   a    t  then  rule r r substitution
exist ar cert    r   ar     t  let renaming
individual c occurring r  c    c  variable x r
  x      x   clearly   ar     ar    ar   a  furthermore  clear
 stable  thus  property     holds ar ir
 
 property    assume satisfiable  consider arbitrarily chosen tuple
cert q    a   since r ucq rewriting  definition     cert   r   a    f
cert rq   r   a   then  clearly cert rq     a  well  then  rule r rq
   

ficuenca grau  motik  stoilos   horrocks

substitution exist ar cert  r     ar    let renaming
individual c occurring r  q   c    c 
variable x r   x      x   clearly   ar     ar    ar   a  furthermore 
clear  q    stable  finally  clearly tuple b cert  r     ar   exists
 head r     q b   since r ucq rewriting ar satisfiable 
b cert q    ar    furthermore   b    clearly holds  then  property     satisfied

ar ir
 
 
b 
q
    dealing recursive axioms
negative result theorem       which applies cwq t csq t   depends
presence recursive axiom tbox  thus  positive results sections    
    require input ucq rewritable w r t  input tbox  eectively
prohibits recursion tbox axioms  instead disallowing recursive axioms  section
overcome limitation theorem      placing additional requirements
abstract reasoners requiring first order reproducible  intuitively  latter
means reasoners behaviour seen complete reasoning unknown
first order theory  abstract reasoners allowed partially evaluate recursive
axioms  invalidates approach used prove theorem      
show  test suite exhaustive q class first order reproducible
abstract reasoners obtained instantiating datalog  rewriting q w r t   
rewritings exist wide range tboxes queries  turn allows
results applicable range practically interesting cases  contrast test
suites computed ucq rewriting  however  test suites obtained datalog 
rewriting may q simple  fact  show section       that  certain q
   test suite exhaustive q class first order reproducible abstract
reasoners exists  test suite q simple  important practicallyrelevant consequence   test suite q simple  first order reproducible abstract
reasoner passes guaranteed  q    complete  however  abstract reasoner
pass s  general cannot conclude reasoner  q    complete 
      first order reproducible abstract reasoners
state art concrete reasoners oracles reasoner  jena  owlim  minerva  virtuoso  dle jena implemented rdf triple stores extended deductive
database features  given input  reasoners first precompute assertions
follow preprocessing step  practice  step commonly implemented  a technique seen as  evaluating datalog program a 
preprocessing  reasoners answer arbitrary ucq q simply evaluating
q precomputed set assertions 
motivated observation  next introduce new class first order reproducible
abstract reasonersthat is  abstract reasoners whose behaviour conceived complete reasoning unknown first order theory  note theory required
datalog program  example  contain existential quantifiers  used
capture behaviour concrete reasoners jena owlim  bishop  kiryakov 
   

ficompleteness guarantees incomplete ontology reasoners

ognyano  peikov  tashev    velkov        handle existential quantifiers input
introducing fresh individuals 
definition       abstract reasoner ans description logic dl first order reproducible if  dl tbox   set first order sentences ft exists that 
abox a 
ans     a    cert   ft   a  

ans     a    f  ucq q  ans q    a    cert q  ft   a  

ft contains predicates and or individuals occurring   assumed
internal ans accessible queries  tboxes  aboxes  test suites  on 
given tbox   cft class first order reproducible abstract reasoners applicable
 
example       abstract reasoners rdf  rdfs  rl classify example     firstorder reproducible  indeed  theory ft empty case rdf  precisely prdfs
prl cases rdfs rl  respectively  finally  abstract reasoner classify  theory
ft union prl program containing axiom x  a x  b x  
atomic subsumption b entailed input tbox 


please note first order reproducible abstract reasoner ans need actually construct ft   matters  possibly unknown  theory ft exists
characterises reasoners behaviour specified definition      
since qft    qft whenever   first order reproducible abstract
reasoner  q    monotonic arbitrary q   furthermore  straightforward
see first order reproducible abstract reasoner strongly  q    faithful 
consequently  cft csq t ucq q tbox  
next show negative result theorem      directly apply
class cft   particular  show abstract reasoner pevaln used prove
theorem      first order reproducible  intuitively  pevaln understood
partial evaluation datalog programthat is  rules program applied
facts fixed number times rather fixpoint reached 
proposition       positive integer n  abstract reasoner pevaln defined
proof theorem      first order reproducible 
proof  let    r a a   let q    a x  q x    consider arbitrary nonnegative integer n  furthermore  assume pevaln cft   then  finite set first order
sentences ft exists pevaln  q    a    cert q  ft   a  abox a 
let k positive integer  furthermore  let rk datalog rule let ak
abox defined follows  a            ak arbitrary distinct fixed individuals occurring
q ft  
rk   r x    x          r xk    xk   a xk   a x   
ak    r a    a             r ak    ak    a ak   
following condition holds proposition     
ft    rk

ft ak    a a   
   

    

ficuenca grau  motik  stoilos   horrocks

definition pevaln  
a  pevaln  q    ak     k n 
a  pevaln  q    ak   k   n 
since pevaln  q    a    cert q  ft   a  
a  cert q  ft   ak     k n 
a  cert q  ft   ak   k   n 
since q contains atom a x  body 
ft ak    a a      k n 
ft ak    a a    k   n 
condition      
ft    rk   k n
ft    rk k   n 
this  however  contradicts obvious observation r     rk k   
note proof proposition      relies fact theory ft depends
input tbox  input query  shown next  defined first order
reproducible abstract reasoners allowing ft depend input query 
negative result theorem      would applied 
definition       abstract reasoner ans dl first order q reproducible if 
ucq q dl tbox   finite set first order sentences fq t exists that 
abox a 
ans     a    cert   fq t   a  
ans     a    f  ans q    a    cert q  fq t   a  
theorem       q    a x  q x      r a a    test suite exists
exhaustive q class sound  monotonic  strongly faithful  qreproducible abstract reasoners applicable  
proof  prove claim  suces show that  nonnegative integer n 
abstract reasoner pevaln defined proof theorem      first order q reproducible 
consider arbitrary nonnegative integer n  arbitrary dl tbox   arbitrary
ucq q   define fq  t that  q   q  fq  t     otherwise 
fq  t consists following n rules 
a x    q x   

r x    x    a x    q x   
   

r x    x    r x    x          r xn    xn   a xn   q x   
   

ficompleteness guarantees incomplete ontology reasoners

clearly  pevaln          cert   fq  t       f ucq q   dl tbox
abox   required  furthermore  q either q   q
abox   pevaln  q         cert q   fq  t         finally 
q   q    abox   clearly pevaln  q        
cert q   fq  t      required 
      simple vs  non simple test suites
proposition      section     shows q simple  test suite exhaustive
q class abstract reasoners provides sucient necessary test  q   completeness  next show analogous result hold contains recursive
axioms  even consider first order reproducible abstract reasoners  theorem       prove claim fixed q since concept relevant recursive
axioms might dicult formalise  however  proof easily adapted
ucqs tboxes  result essentially states  test suite exists provides
necessary sucient condition  q    completeness abstract reasoner
cft   consequently  proposition       test suite exhaustive cft q
q simple  furthermore  section       show compute  test suite exhaustive
cft q  following claim hold vacuously 
theorem       let q    a x  b x  q x    let    r a a   let c
class sound  monotonic  strongly faithful  first order reproducible abstract reasoners applicable   then   test suite exists satisfies following two properties 
   exhaustive c q 
   abstract reasoner ans c  ans  q    complete ans passes s 
proof  assume  test suite     sq exists satisfies properties    
theorem  let n maximal number assertions occurring abox s 
next define two abstract reasoners ans  ans    straightforward check
sound  monotonic  strongly faithful  first order reproducible 
given arbitrary fol tbox tin   abstract reasoner ans  uses datalog program
ft in defined follows 
tin   ft in    
tin   ft in contains following n rules 
r   
r   
r   

b x    a x    a x   
b x    r x    x    a x    a x   
b x    r x    x    r x    x    a x    a x   
   
rn   b x    r x    x          r xn    xn   a xn   a x   
given arbitrary fol tbox tin   abstract reasoner ans  uses datalog program
defined follows  predicate z private ft in  and hence aect
soundness abstract reasoner  
ft in

   

ficuenca grau  motik  stoilos   horrocks

tin   ft in    
tin   ft in contains ft in well following rules 
rz    r x    x          r xn   xn     a xn     z x   
rz   
r x    x    z x    z x   
rz   
z x  b x  a x 
let arbitrary abox containing n assertions  next show
that  assertion containing predicate z  ft in   
ft in         direction trivial since ft in ft in   consider   
direction  furthermore  since rz  rule ft in   ft in contain
z head  claim nontrivial form a a    individual a  occurring a  since antecedent rz  satisfied a    b a   
ft in    z a     then  latter implied rz  rz    individuals
a    a            ak   k exist r ai   ai         k  a ak   a 
since contains n assertions  w l o g  assume k n  then  since
ft in contains rule rk   ft in    a a    well  proves claim  consequence claim fact aboxes contain n assertions 
cert   ft in   a    cert   ft in   a    cert y  ft in   a    cert y  ft in   a 
a  sq  
let    b a     r a    a             r an   an      a an       cert q    a     a   
cert q  ft in   a      ans   q    complete  since exhaustive c q 
abstract reasoner ans  pass s  claim previous paragraph  abstract
reasoner ans  pass either  next show ans   q    complete 
contradicts assumption satisfies property   thus proves claim
theorem 
consider arbitrary abox containing assertions  clearly  a  cert q    a 
individuals a    a            ak   k exist b a    a  r ai   ai    
    k  a ak   a  assume k n  since rk ft in  
ft in    a a    thus a  cert q  ft in   a   contrast  assume k   n  since
rz  ft in   ft in    z akn     since rz  ft in   ft in    z ai  
  k n    finally  since rz  ft in   ft in    a a     then 
a  cert q  ft in   a   required 
corollary theorem       next show testing abstract reasoners cft
cannot done general using q simple test suites 
corollary       q    a x  b x  q x      r a a   q simple test suite exists exhaustive q class sound  monotonic  strongly
faithful  first order reproducible abstract reasoners applicable  
proof  q simple  test suite exhaustive q class mentioned
theorem  proposition      abstract reasoner ans class
pass  q    complete  contradicts theorem      
   

ficompleteness guarantees incomplete ontology reasoners

theorem      eectively says that  abstract reasoner ans cft pass test suite s  cannot conclude ans  q    complete  please note holds
ans fails test form a  q  
y  q   y  counterexample
 q    completeness ans  thus  may show ans  q    complete 
guaranteed so  illustrated following example 
example       let q    a x  b x  q x   let    r a a  r c c   furthermore  let     sq general test suite defined follows 
sq    

  a c    
  a x  b x  q x     
  r c  d   a d       a c  q    
  r c  d   c d       c c  q  
 

let r   rd     q rd    r x  y  a y  a x   r x  y  c y  c x    clearly 
r rewriting q w r t    section       show compute r using
variant injective instantiation way guarantees exhaustiveness cft q 
let ans  cft abstract reasoner defined ft     r x  y  a y  a x   
reasoner pass since cert  c c  q    ft     r c  d   c d      f  note  however  reasoner  q    complete  thus  test suite q simple  passing
sucient  necessary condition  q    completeness  fact  note
contains tbox theorem       theorem cannot reduce
correctly identifies reasoners cft  q    complete 
practice  however  one try mitigate fundamental theoretical limitation
eliminating irrelevant axioms rewriting r thus increasing likelihood
obtaining  test suite  q    complete abstract reasoner pass  example 
using techniques cuenca grau  horrocks  kazakov  sattler      a 
extract module r relevant query  example previous paragraph 
would remove rule r x  y  c y  c x  r  injective instantiation
produce test suite     sq sq defined follows 
sq    

  a c    
  a x  b x  q x     
  r c  d   a d       a c  q  
 

abstract reasoner ans  previous paragraph passes thus guaranteed
 q    complete 
let ans  abstract reasoner defined ft     b x  r x  y  a y  a x   
clearly  abstract reasoner ans   q    complete  ans  pass sq  
latter  however  cannot immediately conclude  q    complete  test
fails involve original query q  possible remedy  try unfold
r certain level injectively instantiate result hope obtaining  test
suite identify ans   q    complete  particular  first unfolding
r produces following query 
b x  r x  y  a y  q x 

instantiating rewriting produces following test suite  prove
ans   q    complete 
sq    

  b c   r c  d   a d       a x  b x  q x     
   

ficuenca grau  motik  stoilos   horrocks

another round unfolding  however  produces following query 
b x  r x  y  r y  z  a z  q x 
instantiating query produces following test suite 

q   

  b c   r c  d   r d  e   a e       a x  b x  q x     

ans  pass
q   conclude ans   q    complete 



better understand example       consider first order reproducible abstract reasoner
ans  arbitrary ucq q  tbox r   rd     rq datalog rewriting
q w r t    datalog program rd rq equivalent  possibly infinite  ucq ruq
obtained rd rq via exhaustive unfolding  following possibilities 
first  assume ans  q    complete  since rd rq equivalent ruq  
certain answer q w r t  arbitrary abox produced r ruq  
then  injective instantiation ar r provide us counterexample
 q    completeness ans  thus  prove ans  q    complete
generating elements ruq fair manner  i e   without indefinitely delaying
generation element ruq   checking whether cert q    ar   ans q    ar   
guaranteed eventually encounter r ruq invalidates condition
thus proves ans  q    complete 
second  assume ans  q    complete  using approach  determine cert q    ar   ans q    ar   holds r ruq   ruq finite  i e  
unfolding rd rq terminates   ruq ucq rewriting q w r t   
results section     conclude ans indeed  q    complete  if  however  ruq infinite  never obtain sucient assurance  q    complete
ans  following section show possible remedy problem 
      testing first order reproducible abstract reasoners
section  show compute  test suite     sq exhaustive cft
q datalog  rewriting r   rd   r   rq q w r t    since first order
reproducible abstract reasoners strongly faithful  need consider injective
instantiations r  thus  rules r rq instantiated section     
rule r rd   however  instantiated pair a  sq abox obtained
instantiating body r boolean ucq obtained instantiating head
r  intuitively  tests allow us check whether  unknown  first order theory ft
captures behaviour abstract reasoner entails r 
definition       let q ucq query predicate q  let admissible tbox 
let r   rd   r   rq datalog  rewriting q w r t    let substitution
mapping variable occurring r distinct fresh individual  injective instanr 
r 
tiation r w r t  pair ir    ir 
smallest set aboxes
  iq
ir 
smallest set pairs abox ucq
q
ar ir 
r r  

   

ficompleteness guarantees incomplete ontology reasoners

ar   q ir 
r rq cert   rd r   ar     f 
q
ar   ir 
r rd form     cert   rd r   ar     f 
q
ucq    i   x   yi   q     m  propositional query
predicate q  
ir  clearly unique renaming fresh individuals   typically left
r
implicit  one talks injective instantiation ir   ir
  iq r 
example       consider query q    a x  q x   el tbox consisting
following axioms  whose translation first order logic shown symbol 
r a b



bc



ad



r c



c r d



x  y  r x  y  a y  b x  
x  y  r x  y  c y  a x  
x  b x  c x  

x  c x  y  r x  y  d y   
x  a x  d x   

then  r   rd   r   rq defined next datalog rewriting q w r t   
rd     r x  y  a y  b x   r x  y  c y  a x   b x  c x   
r     a x  d x   

rq     a x  q x   

r
injective instantiation ir   ir
  iq r shown below 

ir
      a c   d c     

ir
  a x  q x     
q       a c    
  r c  d   a d       b c  q    
  r c  d   c d       a c  q    
  b c    
  c c  q  
 



show injective instantiation datalog  rewriting q w r t 
 test suite exhaustive cft q 
theorem       let q ucq  let tbox  let r   rd   r   rq datalog 
r
r
rewriting q w r t    let ir   ir
  iq injective instantiation r  then 
 test suite exhaustive cft q 
proof  let substitution ir obtained from  first show ir  test
suite 
r
consider arbitrary ir
  then  rule r r exist     clearly
cert    r   a    t  cert   rd r   a    well  since r datalog  rewriting q w r t    unsatisfiable  required 

   

ficuenca grau  motik  stoilos   horrocks

consider arbitrary ir
q   then  cert   rd r   a    f definition      
 
since r datalog
rewriting q w r t    satisfiable 
required 
show ir exhaustive cft q  consider arbitrary abstract reasoner
ans cft passes ir is  ans satisfies following two properties 
 a  ans         ir
 
 b  ans         f implies cert y      ans y      y  ir
q 
since ans first order reproducible  set first order sentences ft exists that 
abox a 
ans     a    cert   ft   a  
ans     a    f  ans q    a    cert q  ft   a  
assumption ft definition      fact maps variables fresh
individuals  rng   ind ft      
let r d r d smallest sets rules satisfying following conditions
rule r rd  
cert   ft   ar     implies r r d   r obtained r replacing head
 
cert   ft   ar     f implies r r d  
furthermore  let r q r q sets rules obtained rq analogous way 
since r d r d obtained rd replacing head formulae   clearly
r d r d    rd   analogously  r q r q    rq  

next show ft    r   latter holds ft    r rule r r  
consider arbitrary rule r r   note head r      then  definition     
r
r
ar ir
   a  ans         t  definition      cert   ft      
hence ft ar      finally  since rng   ind ft       proposition    
ft    r  required 
next show ft    r d   latter holds ft    r rule r r d  
consider arbitrary rule r r d   note head r      then  definition r d
cert   ft   ar     hence ft ar      finally  since rng   ind ft      
proposition     ft    r  required 
completely analogous way previous paragraph  possible show
ft    r q  
next show ft    r d   latter holds ft    r rule
r r d   consider arbitrary rule r r d form      definition r d
cert   ft   ar     f  definition      ans     ar     f  then  definition
     ar   ir
x   yi   q     m   note
q ucq    i   
   r definition      proposition     ar   
x   yi   
i     
definition fact q occur   ar    q  
   

ficompleteness guarantees incomplete ontology reasoners

then  cert y    ar     t  latter observation  ans     ar     f   b  imply
ans y    ar     t  definition      cert y  ft   ar     t  since q occurs

 note predicate occurring
ft private ft   q cannot
r
occur ft    ft    i     x   yi    finally  since rng   ind ft      
proposition     ft    r  required 
next show q ft    r q   latter holds q ft    r
rule r r q   consider arbitrary rule r r q   note head r  atom predicate
q  definition r q cert   ft   ar     f  definition     
ans     ar     f  furthermore  definition       cert   rd r   ar     f 
let tuple arguments  head r    then  definition     
ar   q ir
cert  r     ar    cert rq   rd r   ar  
q   clearly 
monotonicity first order logic  since r rewriting q w r t    definition     cert q    ar    latter observation  ans     ar     f   b 
imply ans q    ar    definition      cert q  ft   ar    hence 
ft ar    q a   finally  since rng   ind ft       proposition    
ft    r  required 
following table summarises entailment relationships various first order
theories obtained thus far 
ft    r
q ft    r q

ft    r d
r q r q    rq

ft    r d
r d r d    rd

ft    r q

clearly  implies following entailments 
ft    rd r

q ft    rd r rq

complete proof theorem show ans  q    complete 
end  consider arbitrary abox a  following possibilities  depending
satisfiability a 
assume unsatisfiable  cert   rd r   a    definition
     mentioned entailments  cert   ft   a    t  consequently 
ans     a    definition       required 
assume satisfiable ans     a    f  consider arbitrary tuple
cert q    a   then  cert   rd r   a    f cert rq   rd r   a 
definition      mentioned entailments  cert q  ft   a  
hence  ans q    a  definition       required 
note size test suite obtained theorem      linear size
rewriting  which  believe  makes approach suitable use practice 
      testing ground queries
shown section        abstract reasoner ans cft pass  test suite
q simple  cannot always conclude ans  q    complete 
practical point view  would highly beneficial identify situations passing
would show ans indeed incomplete q   furthermore  applications
   

ficuenca grau  motik  stoilos   horrocks

prototypical queries known design time  would design completeness
tests query independentthat is  test abstract reasoner completeness
w r t  regardless input data query  section  show
achieve two goals focusing ground queries  restriction unreasonable
practice  since sparql query equivalently expressed ground ucq 
first define query independent notion exhaustiveness test suite 
definition       let tbox  let  test suite  let c class abstract
reasoners applicable   then  exhaustive c ground ucqs ans c
passes  q    complete ground ucq q 
then  define notion ground rewriting rewriting captures
query answers w r t    regardless input ground query aboxand show
instantiate ground rewritings 

definition       ground rewriting tbox pair r   rd   r that 
ground ucq q  triple rd   r   q datalog rewriting w r t  q 

injective instantiation ir r defined ir   ir r   rd   r    
note definition      implies variable occurring head rule
r occurs rule body  tools requiem kaon  easily
adapted compute ground rewriting tbox practice  next show
injective instantiation ground rewriting yields  test suite provides us
sucient necessary check completeness w r t  ground ucqs 

theorem       let tbox  let r   rd   r ground rewriting  
then  following two claims hold 
   ir exhaustive cft ground ucqs 
   abstract reasoner ans cft pass ir  q    complete
ground ucq q 

proof   property    consider arbitrary abstract reasoner ans cft passes ir   let
ft first order theory characterises behaviour ans  proof
theorem       fact ans passes ir implies ft    rd r   furthermore  consider
arbitrary ground ucq q arbitrary abox a  ans  q    complete
shown proof theorem       minor dierence cert q    a 
implies cert q  rd r   a  definition      
 property    note that  since r ground rewriting   definition      ucqs
ir ground  thus  abstract reasoner ans cft pass ir   clearly
shows ans  q    complete ground ucq q 

   comparing incomplete abstract reasoners
section  investigate techniques that  given query q tbox   allow us
determine whether abstract reasoner ans  complete abstract reasoner
ans  is  whether aboxes a  abstract reasoner ans  computes answers
q abstract reasoner ans    idea formalised following definition 
   

ficompleteness guarantees incomplete ontology reasoners

definition      let q ucq  let tbox  let ans  ans  abstract
reasoners applicable   then  ans  q t ans  following conditions hold
abox a 
   cert     a    ans       a    imply ans       a    t 
   cert     a    f  ans       a    f  ans       a    f imply
ans   q    a  cert q    a  ans   q    a  cert q    a  
furthermore  ans   q t ans  ans  q t ans  abox exists least one
following two conditions holds 
   cert     a    t  ans       a    f  ans       a    t 
   cert     a    f  ans       a    f  ans       a    f 
ans   q    a  cert q    a  ans   q    a  cert q    a  
example      consider abstract reasoners rdf  rdfs  rl  classify introduced example     query q tbox example       clearly following 
rdf q t rdfs q t rl q t classify
furthermore  two abstract reasoners  abox exists distinguishes
abstracts reasoners w r t  q   example  abox    takesco c  d   mathsco d   
rdfs q        rl q         c   result  following 
rdf  q t rdfs  q t rl  q t classify



would check whether ans  q t ans  ans   q t ans  given pair
abstract reasoners subjecting reasoners finite set tests  towards goal 
r
next define relations r
q t  q t compare abstract reasoners w r t  given
finite set r aboxes  ideally  given q   would compute finite r
r
r
q t  q t coincide q t  q t abstract reasoners class c
interest  ideas captured following definitions 
definition      let q ucq  let tbox  let r finite set aboxes  let
ans  ans  abstract reasoners applicable  
then  ans  r
q t ans  conditions     definition     hold abox
r
r  furthermore  ans   r
q t ans  ans  q t ans  either condition   condition
  definition     holds abox r 
definition      let q ucq  let tbox  let c class abstract reasoners
applicable   finite set r aboxes  q    representative c following
conditions hold ans    ans  c 
   ans  r
q t ans  ans  q t ans   
   

ficuenca grau  motik  stoilos   horrocks

   ans   r
q t ans  ans   q t ans   
show next  prove r  q    representative  suces show
implication condition   implication condition   definition     
proposition      let q ucq  let tbox  let c class abstract reasoners
applicable   let r finite set aboxes
   ans  r
q t ans  implies ans  q t ans   
   ans   q t ans  implies ans   r
q t ans   
then  r  q    representative c 
proof  note ans  q t ans  trivially implies ans  r
q t ans    thus  condition  
proposition clearly implies condition   definition      furthermore  abox r
satisfies condition     definition      condition     definition     holds well 
consequently  conditions     proposition imply condition   definition     
obvious question whether q simple  test suite exhaustive class
c q  q    representative c  following example shows
necessarily case 
example      let q specified example       let r    a            a   
aboxes specified example       shown section    q simple  test suite
    sq    a    sq    a            a    exhaustive cwq t q 
let trivial abstract reasoner returns empty set input  consider rdf based abstract reasoner rdf example      ignores tbox
evaluates query directly abox  clearly  trivial q t rdf  furthermore 
trivial  q t rdf since    st c   takesco c  d   mathco d   rdf q    a     c 
whereas trivial q    a      abstract reasoners  however  return empty set
answers aboxes r thus rdf r
q t trivial  hence  using r cannot
dierentiate two abstract reasoners 

    negative result
following strong result shows that  numerous tboxes   finite set aboxes
exists dierentiate two arbitrary abstract reasoners class sound 
first order reproducible  monotonic  strongly faithful reasoners  note result
stronger negative result theorem       applies smaller class abstract
reasoners tboxes imply least one concept subsumption 
theorem      let arbitrary tbox mentioning atomic role r atomic
concepts b    b  let q    b x  q x    then  finite set
aboxes exists  q    representative class sound  monotonic  strongly
faithful  first order reproducible abstract reasoners applicable  
   

ficompleteness guarantees incomplete ontology reasoners

proof  assume finite set aboxes r exists  q    representative class
sound  monotonic  strongly faithful  first order reproducible abstract reasoners
applicable   let n maximum number assertions abox r 
arbitrary integer k    let ansk first order reproducible abstract reasoner
that  given fol tbox tin   uses following datalog program ftkin  
ftkin

 




tin     b
a x    r x    x          r xk    xk   b x    tin    b

clearly  ansk sound  monotonic  strongly faithful  furthermore  ansk      a    f
abox a  next show ansn    q    a  ansn    q    a  abox
r  consider arbitrary a  ansn    q    a   then  individuals a    a            an   exist
r a        n      since contains n assertions
rule ftn   contains n     body atoms  ai   aj   jthat is 
contains r cycle  then  rule ftn   matched mapping x 
a    a  ansn    q    a   therefore  ansn   r
q t ansn    
   a a     r a    a             r an   an       however  a  ansn    q    a 
ansn    q    a      thus  ansn   q t ansn   hold  contradicts assumption r exhaustive class abstract reasoners theorem 
    compact abstract reasoners
theorem     suggests need make additional assumptions abstract reasoners wish compare using finite set aboxes  section  show
representative sets aboxes computed practice restrict
abstract reasoners call  q    compact  intuitively  abstract reasoner
processes q    computing certain answers q  a  subset
  subset depends q  words  behaviour compact
abstract reasoners simulated following process  select subset axioms
input tbox processed  compute certain answers w r t 
selected fragment tbox  class  q    compact abstract reasoners thus captures properties concrete reasoners jena oracles semantic data store
discard axioms input tbox fall outside certain fragment  e g   existential
restrictions right hand implications  encode remaining axioms
suitable set rules 
definition      let q ucq  let tbox  abstract reasoner ans applicable
 q    compact tbox exists following properties hold
abox a 
   cert     a    implies ans     a    t 
   cert     a    f implies ans     a    f ans q    a    cert q    a  
abstract reasoner ans compact  q    compact ucq q tbox
ans applicable  finally  ccq t class  q    compact strongly
 q    faithful abstract reasoners applicable  
   

ficuenca grau  motik  stoilos   horrocks

example      abstract reasoners defined example      q    compact
query q el tbox example       indeed  abstract reasoner rdf subset
given     abstract reasoner rdfs          abstract reasoner
rl                     abstract reasoner classify    

abstract reasoners ansk defined proof theorem      q   compact query tboxes theorem     applies 

proposition       let q    b x  q x   let    a b  c r    then 
k    abstract reasoner ansk proof theorem      q    compact 
proof  let q stated theorem consider arbitrary k    let a 
a  aboxes defined follows 
a     a a    

a     a a     r a    a             r ak    ak   

clearly  following 
ansk  q    a     

ansk  q    a       a   

one straightforwardly check  however  following holds  
cert q    a      cert q    a   
thus  ansk  q    compact 
thus  negative result theorem     immediately apply class
containing compact abstract reasoners 
    comparing compact abstract reasoners
section  show set aboxes  q    representative ccq t
obtained computing  subset   q simple  test suite exhaustive

csq t   minor complication arises due fact contain fewer individuals

  deal cases correctly  aboxes st allowed contain

individuals occurring   aboxes stq allowed contain
individuals occurring q   assumption without loss generality 

given  q    test suite st   one replace individuals q

fresh individuals  result replacement  q    test suite exhaustive csq t  
theorem       let q ucq  let tbox  furthermore    let




st   st   stq q simple  test suite exhaustive csq t q


abox st contains individual ind t     ind t   abox stq contains
individual ind t     ind q    then  set r aboxes defined



r 
st stq


 q    representative ccq t  
   

ficompleteness guarantees incomplete ontology reasoners

proof  assume r satisfies conditions theorem  let ans  ans 
arbitrary abstract reasoners ccq t   next show ans  ans  satisfy two
properties proposition     
property   proposition     

ans  r
q t ans  implies ans  q t ans 

property   proposition     

ans   q t ans  implies ans   r
q t ans 

since ans   q    compact  tbox exists satisfies conditions
definition      assume ans  r
q t ans    next show conditions    
definition     satisfied arbitrary abox a 
 condition    assume cert     a    ans       a    t  contrapositive property   definition      cert     a    t  since r contains aboxes

q simple  test suite exhaustive csq t q  theorem     
exist abox r  stable renaming dom     ind t  
 a   a  since contain individuals ind t     ind t    renaming
 stable  definition  test suite  cert         t  furthermore  property  

definition     ans           t  since ans  r
q t ans  ans           t 

since ans  strongly  q    faithful  stable  ans        a      t  finally  since  a   ans   q    monotonic  ans       a    t  required 
 condition    assume cert     a    f  ans       a    f  ans       a    f 
consider arbitrary tuple ans q    a  cert q    a   contrapositive
property   definition      cert     a    f  then  property   definition      cert q    a   since r contains aboxes q
simple  test suite exhaustive csq t q  theorem      exist
abox r  tuple b cert q        q    stable renaming
dom     ind q     a   a   b    a  since contain individuals ind t     ind q    renaming  q    stable  definition
 q    test suite  cert         f  furthermore  property   definition    
b ans   q       since ans  r ans  b ans   q       since ans  strongly
q t
 q    faithful  q    stable  ans   q     a     finally  since
 a   ans   q    monotonic  ans   q    a   required 
assume ans   q t ans    definition      ans  q t ans  abox
exists satisfying conditions     definition      clearly  ans  r
q t ans    hence 
remains shown r contains abox satisfies conditions    
definition      since ans   q    compact  tbox exists satisfies
conditions definition     
 condition    assume cert     a    t  assume ans       a   
ans       a    f  proof condition    identify abox r
 stable renaming ans            a   a  since ans   q   monotonic ans       a    f  ans        a      f  furthermore  since ans 
strongly  q    faithful  stable  ans           f  then 
condition   definition     satisfied r 
 condition    assume cert     a    f ans       a    ans       a    f 
consider arbitrary tuple  ans   q    a  cert q    a     ans   q    a  
proof condition    identify abox r   q    stable renaming  
   

ficuenca grau  motik  stoilos   horrocks

tuple b cert q       a   a   b    a  b ans   q       since ans 
 q    monotonic ans   q    a   ans   q     a     furthermore  since
ans  strongly  q    faithful  q    stable  b ans   q      
then  condition   definition     satisfied r 
theorems           immediately suggest approach computing set aboxes
 q    representative ccq t   first  compute ucq rewriting q w r t 
subset   then  instantiate rule rewriting using injective
instantiation mapping  finally  compute r union aboxes test suites 
nave procedure  however  practical since requires computing exponential
number ucq rewritings  next present practical approach computing
set aboxes  q    representative ccq t   intuitively  instead computing
exponentially many rewritings  one compute single ucq rewriting q w r t 
subset closed is  contains rewriting subset  
definition       ucq rewriting r   r   rq q w r t  subset closed
tuple r   r   rq exists r r   rq rq r
ucq rewriting q w r t   
following corollary immediate consequence theorems                  

corollary       let q ucq  let tbox  let r subset closed ucq rewriting
r
q w r t    let ir   ir
  iq injective instantiation r  then  set
q t
r
aboxes r   ir
 
iq  q    representative cc

practical query rewriting systems requiem optimised produce small
ucq rewriting possible  output typically subset closed  therefore 
technique requires modification ucq rewriting algorithms implemented existing systems  illustrated following example  required modification typically
involves disabling  at least partially  subsumption based optimisations 
example       let q specified example       let     sq
 test suite example       system requiem compute r
given q   note  however  r subset closed  example  ucq
rewriting q w r t    q  subset rq   rewriting made
subset closed extending rq following rules 
st x  takesco x  y  mathco x  y  q x 
st x  takesco x  y  calcco x  y  q x 
mathst x  st x  q x 

systems requiem  however  typically discard rules applying subsumption
optimisations described section       

following example shows  subset closed ucq rewriting q w r t  can 
worst case  exponentially larger minimal ucq rewritings q w r t   
example       let q    c x  q x    let following tbox 
   b ai     n   a        c 
   

ficompleteness guarantees incomplete ontology reasoners

furthermore  let r   r   rq r   rq contains following rules 
c x  q x 

b x  q x 

a   x         x  q x 
clearly  r ucq rewriting q w r t    however  number rules subset closed
ucq rewriting q w r t  exponential n 


   evaluation
implemented techniques computing exhaustive test suites comparing incomplete concrete reasoners prototype tool called sygenia   tool uses requiem
computing ucq datalog rewritings  
considered two evaluation scenarios  first one uses well known lehigh
university benchmark  lubm   guo et al          consists relatively small
tbox academic domain     test queries  data generator  second one
uses small version galen  rector   rogers       a complex ontology commonly
used medical applications 
evaluated following concrete reasoners  sesame v    prl   dle jena v     
owlim v        minerva v      jena v       three variants  micro  mini 
max  
    computing exhaustive test suites
given ucq q tbox   tool uses requiem compute datalog rewriting
r q   r ucq rewriting  tool computes simple test suite
either full injective instantiation  see sections          respectively   otherwise 
tool computes non simple test suite instantiating r described section       
      simple test suites
case lubm benchmark     test queries leads ucq rewriting w r t  tbox   therefore  computed ucq rewriting query q
benchmark using requiem instantiated it  fully injectively  thus obtaining
q simple  test suites exhaustive q cwq t csq t   respectively 
times needed compute test suites size test suite shown table
   denotes total number aboxes corresponding test suites 
  
  
  
  
  
  
  
  

http   code google com p sygenia 
http   www cs ox ac uk projects requiem home html
http   www openrdf org 
http   lpis csd auth gr systems dle jena 
http   www ontotext com owlim 
http   www alphaworks ibm com tech semanticstk
http   jena sourceforge net 
since requiem currently support individuals queries  replaced individuals
queries distinguished variables 

   

ficuenca grau  motik  stoilos   horrocks

q t
cw

csq t

q 
time    

 
time    

 

q  q  q  q  q  q  q  q  q   q   q   q   q  
                       
 
                         
                                     
     
 
                                                     
 
 
  
        
  
     
 
 
 
 

table    computation simple test suites lubm  times given seconds 

q t
cw

csq t

time

time


q 
  
     
   
  

q 
  
      
 
   

q 
  
      
  
   

q 
   
  
   
  

table    computation simple test suites galen  times given seconds 
shown table  simple test suites could computed times ranging     
  seconds  cwq t csq t   optimisations implemented requiem ensure
ucq rewritings relatively small  resulting test suites consist
relatively small number aboxes  notice  however  significant dierence
numbers aboxes test suites obtained via injective instantiation  which range  
    average      obtained via full instantiation  which range
         average       furthermore  rule rewriting contains
  atoms  therefore abox test suite contains   assertions 
case galen  used following sample queries  requiem
compute ucq rewriting 
q 
q 
q 
q 

 
 
 
 

haemoglobinconcentrationprocedure x  q x 
plateletcountprocedure x  q x 
lymphocytecountprocedure x  q x 
hollowstructure x  q x 

instantiated ucq rewriting fully injectively  times needed compute test suites size test suite shown table   
shown table  simple test suites galen computed times ranging
       seconds average    seconds  thus  computing test suites
galen time consuming lubm  unsurprising since tbox
galen significantly complex lubm  number aboxes
test suites ranged        case injective instantiations   
        case full instantiations  again  note significant dierence
sizes two kinds test suites  cases  however  individual abox
small  largest one containing    assertions 
      non simple test suites
computed non simple test suites cases ucq rewriting exists 
already mentioned  lubm queries ucq rewritable  therefore  manually added
following query  requiem computes recursive datalog rewriting 
   

ficompleteness guarantees incomplete ontology reasoners

time  s 


cft

lubm
q  
   
  

q 
   
  

galen
q  q 
       
  
  

q 
   
  

table    general test suites computed datalog rewritings lubm galen 
system
completeness guarantee completeness w r t  lubm data set
jenamax dle jena
q  q  
q  q  
owlim
q  q    q    q    q   q  
q  q  
jena mini micro
q  q    q    q    q   q  
q  q  
minerva
q  q    q    q  
q  q  
sesame
q    q    q     q  
q  q    q     q  

table    completeness guarantees ucq rewritable queries lubm
q    

organization x  q x 

due complex structure galen tbox  test queries ucq rewritable
easily identified  evaluated following four 
q 
q 
q 
q 

 
 
 
 

westergrenesrprocedure x  q x 
arthroscopicprocedure x  q x 
truecavity x  q x 
bacterialcellwall x  q x 

times needed compute test suites size test suite shown table   
    completeness guarantees
already discussed  existing concrete reasoners captured strongly  q    faithful
abstract reasoners  hence  order establish completeness guarantees concrete
reasoners  restricted tests test suites computed using injective instantiations 
      results simple test suites
results original queries lubm benchmark shown table   
concrete reasoner  first column table shows queries
able prove completeness using techniques  i e   queries complete
arbitrary data set   second column table shows queries
concrete reasoner computes answers canonical lubm data set one university 
results clearly show completeness w r t  data set lubm benchmark
guarantee completeness arbitrary data sets  example  owlim  minerva 
jena mini micro complete queries w r t  lubm data set  and
systems even complete expressive uobm benchmark   however  certain
queries  systems found incomplete data set test suites 
jena max dle jena systems guaranteed complete
   lubm queries regardless data setthat is  systems behave exactly
complete owl reasoner lubm queries lubm tbox  according jenas
   

ficuenca grau  motik  stoilos   horrocks

documentation  jena max supports types axioms used lubm tbox  hence
expected complete lubm tbox queries  interestingly  tested
lubm data sets  jena max could compute answers many
queries  used smaller lubm data sets instead  demonstrates additional
advantage approach  require reasoning w r t  large data sets  since
aboxes test suites typically contain small number assertions  regarding dlejena  according technical description  meditskos   bassiliades         system
uses complete dl reasoner materialise certain subsumptions preprocessing step
uses jena saturate abox  much abstract reasoner classify
example      hence  dle jena least complete jena mini and  addition 
able draw inferences jena mini missing  see below  
owlim complete lubm queries involve reasoning existential
quantifiers consequent implications  well known latter supported
system  jena mini micro exhibited exactly behaviour owlim 
despite fact jena mini handle larger fragment owl owlim  clearly 
lubm tbox queries suciently complex reveal dierences
owlim  jena mini micro 
minerva guaranteed complete six queries  dle jena  uses
dl reasoner materialise entailed subsumptions atomic concepts  uses
custom method saturating abox  investigating several aboxes test
suites concluded minerva cannot correctly handle  at least  inverse role axioms 
example  cannot find entailment   r r   r a  b       r b  a  
finally  sesame complete four queries  unsurprising since sesame
rdfs reasoner thus complete small fragment owl   dl 
next discuss results tests based galen ontology test queries
q  q    could run jena max since galen heavily uses existential restrictions 
 according jenas documentation  might cause problems  minerva
system provided completeness guarantee least one query  q    
minerva precomputes subsumption relationships atomic concepts depend
existential restrictions right hand side tbox axioms  systems
handle  also  unlike lubm  version galen used contain
inverse roles  minerva performed much better ontology  systems
identified incomplete test queries 
      results non simple test suites
results test queries ucq rewritable summarised table    symbol
indicates concrete reasoner found complete given query  furthermore  whenever concrete reasoner failed test suite  tried prove reasoner
incomplete discussed examples section        cases successful 
symbol indicates concrete reasoner identified incomplete
given query  finally  symbol indicates concrete reasoner ran memory 
case lubm  able establish completeness guarantees w r t  query
q   owlim  jena micro  dle jena  jena max  note systems
handle recursive tbox statements  completeness q   surprising  rdfs 
   

ficompleteness guarantees incomplete ontology reasoners

owlim
jena max
jena micro
dle jena
minerva
sesame

lubm
q  







q 






galen
q  q 











q 






table    completeness guarantees datalog rewritable queries

csq t

q  q  q  q  q  q  q  q  q  q   q   q   q   q  
time                                                        
r
                                   
        

table    representative sets aboxes lubm  times given seconds 
however  cannot express recursive tbox statements involving roles  sesamean rdfs
reasonerfails compute certain answers tests 
case galen  completeness guaranteed query q  owlim  jena micro 
dle jena  minerva  additionally query q  minerva  already mentioned 
answers queries galen depend positive occurrences existential restrictions
axioms  systems cannot handle  could run jena max galen 
    comparing incomplete concrete reasoners
implemented techniques comparing reasoners section      end 
modified requiem compute subset closed rewritings  injectively
instantiated obtain  q    representative sets aboxes r 
      tests lubm
shown table    representative sets aboxes could computed seconds
lubm queries  exception q    requiem terminate
disabling rule subsumption optimisations  size representative sets ranged
      aboxes  expected  representative sets contain aboxes
exhaustive test suites query tbox  see table    
combinations system query tests section     identified
system incomplete shown table    table shows proportion certain
answers system returned applied lubm data set  aboxes r 
aboxes test suite used section     check systems completeness 
shown table  owlim jena micro exhibited behaviour
almost complete  contrast  sesame least complete queries  furthermore 
please note dierence values obtained r s  particular 
sesame compute certain answer q  s  whereas system able
compute certain answers q  aboxes  e g   lubm data set  
aboxes cannot distinguish sesame trivial reasoner always
returns empty set answers  however  set r make distinction 
   

ficuenca grau  motik  stoilos   horrocks

lubm

r

q 
 
    
   

q 
 
    
    

lubm

r

q 
 
    
    

q 
 
    
    

minerva
q 
q  
q  
 
 
 
              
              
sesame
q 
q 
q 
q 
 
              
 
               
                     
q 
 
    
    

q  
 
   
    

owlim   jmicro
q 
q 
q  
 
 
 
    
    
    
    
    
    

q 
    
 
 

q  
    
     
     

q  
 
    
     

q  
 
   
    

table    reasoner comparison lubm

csq t

time
r

q 
  
   

q 
  
   

q 
  
   

q 
 
   

table     representative sets aboxes galen
      tests galen
shown table     representative sets aboxes galen could computed
times ranging      seconds  set contains small number aboxes 
system query  table    shows proportion certain answers returned
system r test suite section      minerva complete
system  jena micro better dle jena  apart query q     dle jena
owlim behaved almost way  again apart query q     expected 
sesame least complete system 
discrepancies owlim  jena micro  dle jena minerva rather
surprising  owlim jena theoretically support features owl  furthermore 
dle jena extension jena  meditskos   bassiliades        dle jena
least complete jena  case lubm  order explain discrepancies 
analysed test suites queries q  q    precisely  selected aboxes
owlim fails return certain answers jena micro complete 
identified minimal set tbox axioms entail certain answers  analysis
revealed that  query q    owlim fails find entailment
 device a   hollowtopology b   hastopology a  b      hollowstructure a  

follows following galen axioms 

hollowtopology topology hasstate hollow
device solidstructure

hollowstructure solidstructure hastopology  topology hasstate hollow 

although existential restrictions appear several axioms  observe reasoning
existential variables actually required  first third axioms imply  by simple
structural transformation  following axiom 
solidstructure hastopology hollowtopology hollowstructure
   

ficompleteness guarantees incomplete ontology reasoners

sesame
owlim
dle jena
jmicro
minerva

q 

r
         
         
         
         
         

q 

r
      
         
         
         
         

q 

r
      
         
         
         
         

q 

r
         
         
        
         
 
 

table     reasoner comparison galen
axiom entails required answer  systems deal axioms form 
however  unlike jena micro  owlim appears incapable dealing cases 
regarding dle jena  according technical description  meditskos   bassiliades 
       system replaced several inference rules jena queries dl reasoner  strictly extend jena  investigation exhaustive test suite
query q  revealed dle jena returns many answers based existential
restrictions right hand side tbox axioms jena misses  however  investigation revealed dle jena misses several inferences jenas tbox reasoner
capture  probably due replacement jenas inference rules 
explains dle jena performs worse minerva galen 
results clearly show behaviour systems greatly depends given
application scenario  example  dle jena complete lubm queries 
perform equally well galen  contrast  minerva perform well
lubm  complete system galen  results thus allow application
developers conduct thorough comparison reasoning systems given application 

   conclusion
paper proposed theoretical framework practical techniques establishing formally provable algorithmically verifiable completeness guarantees incomplete ontology reasoners  approach radically departs ad hoc evaluation based
well known benchmarks  provides solid foundation striking balance
scalability completeness practical applications 
approach opens numerous exciting possibilities future research 
example  work opens door design ontology based information systems
optimised class ontologies  queries  data relevant particular application  information systems could maximise scalability reasoning still ensuring
completeness query answers  even rich ontologies sophisticated queries 

acknowledgments
extended version paper incomplete semantic web reasoner 
giorgos stoilos  bernardo cuenca grau  ian horrocks published aaai     
paper completeness guarantees incomplete reasoners authors
published iswc      
   

ficuenca grau  motik  stoilos   horrocks

research supported eu project seals  fp  ict         
epsrc projects exoda  ep h          hermit  ep f           b  cuenca
grau supported royal society university research fellowship 

references
acciarri  a   calvanese  d   de giacomo  g   lembo  d   lenzerini  m   palmieri  m    
rosati  r          quonto  querying ontologies  proceedings   th national
conference artificial intelligence  aaai       pp            aaai press  
mit press 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          dl lite family
relations  j  artificial intelligence research  jair           
baader  f   mcguinness  d   nardi  d     patel schneider  p          description logic
handbook  theory  implementation applications  cambridge university press 
baader  f   brandt  s     lutz  c          pushing el envelope  proceedings
  th international joint conference ai  ijcai      pp          morgankaufmann publishers 
bishop  b   kiryakov  a   ognyano  d   peikov  i   tashev  z     velkov  r         
owlim  family scalable semantic repositories  semantic web              
broekstra  j   kampman  a     van harmelen  f          sesame  generic architecture
storing querying rdf rdf schema  proceedings  st international
semantic web conference  iswc        pp       
cal  a   gottlob  g   lukasiewicz  t   marnette  b     pieris  a          datalog    
family logical knowledge representation query languages new applications 
proc    th annual ieee symposium logic computer science  lics  
pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable
reasoning ecient query answering description logics  dl lite family 
journal automated reasoning                 
ceri  s   gottlob  g     tanca  l          always wanted know datalog
 and never dared ask   ieee trans  knowledge data engineering                
cuenca grau  b   horrocks  i   kazakov  y     sattler  u       a   modular reuse
ontologies  theory practice  journal artificial intelligence research         
    
cuenca grau  b   horrocks  i   motik  b   parsia  b   patel schneider  p     sattler  u 
     b   owl    next step owl  journal web semantics  jws         
       
derriere  s   richard  a     preite martinez  a          ontology astronomical
object types virtual observatory  proc    th meeting iau 
virtual observatory action  new science  new technology  next generation
facilities  pp        prague  czech republic 
   

ficompleteness guarantees incomplete ontology reasoners

erling  o     mikhailov  i          rdf support virtuoso dbms  pellegrini  t  
auer  s   tochtermann  k     schaert  s   eds    networked knowledge   networked
media  pp       springer berlin   heidelberg 
fitting  m          first order logic automated theorem proving   nd edition  texts
computer science  springer 
glimm  b   horrocks  i   lutz  c     sattler  u          conjunctive query answering
description logic shiq  proceedings international joint conference
ai  ijcai   pp         
golbreich  c   zhang  s     bodenreider  o          foundational model anatomy
owl  experience perspectives  journal web semantics                
goodwin  j          experiences using owl ordnance survey  proc 
owl  experiences directions workshop  owled        galway  ireland 
guo  y   pan  z     heflin  j          lubm  benchmark owl knowledge base
systems  journal web semantics                
haarslev  v     moller  r          racer system description  gore  r   leitsch  a    
nipkow  t   eds    proc   st int  joint conf  automated reasoning  ijcar
       vol       lnai  pp          siena  italy  springer 
hayes  p          rdf semantics  world wide web consortium  w c  recommendation 
horrocks  i   patel schneider  p  f     van harmelen  f          shiq rdf
owl  making web ontology language  journal web semantics             
kiryakov  a   ognyanov  d     manov  d          owlim a pragmatic semantic repository
owl   dean  m   guo  y   jun  w   kaschek  r   krishnaswamy  s   pan  z    
sheng  q  z   eds    wise workshops  pp         
lacy  l   aviles  g   fraser  k   gerber  w   mulvehill  a     gaskill  r          experiences
using owl military applications  proc  owl  experiences directions
workshop  owled        galway  ireland 
lutz  c   toman  d     wolter  f          conjunctive query answering description
logic el using relational database system  proceedings   st international
joint conference ai  ijcai   pp           
ma  l   yang  y   qiu  z   xie  g  t   pan  y     liu  s          towards complete owl
ontology benchmark  proceedings  rd european semantic web conference
 eswc        pp         
mcbride  brian         jena  implementing rdf model syntax specification 
international workshop semantic web      
meditskos  g     bassiliades  n          combining dl reasoner rule engine
improving entailment based owl reasoning  proceedings  th international
semantic web conference  iswc        pp         
motik  b   cuenca grau  b   horrocks  i   wu  z   fokoue  a     lutz  c       a   owl  
web ontology language profiles  w c recommendation 
   

ficuenca grau  motik  stoilos   horrocks

motik  b   shearer  r     horrocks  i       b   hypertableau reasoning description
logics  j  artificial intelligence research  jair                      
ortiz  m   calvanese  d     eiter  t          data complexity query answering expressive description logics via tableaux  journal automated reasoning               
perez urbina  h   horrocks  i     motik  b          ecient query answering owl   
proceedings  th international semantic web conference  iswc        vol 
     lncs  pp          springer 
perez urbina  h   motik  b     horrocks  i          tractable query answering rewriting
description logic constraints  journal applied logic                
prudhommeaux  e     seaborne  a          sparql query language rdf  world
wide web consortium  w c   w c recommendation 
rector  a  l     rogers  j          ontological practical issues using description
logic represent medical concept systems  experience galen  barahona 
p   bry  f   franconi  e   henze  n     sattler  u   eds    reasoning web  second
international summer school       pp         
sidhu  a   dillon  t   chang  e     sidhu  b  s          protein ontology development
using owl  proc  owl  experiences directions workshop  owled
       galway  ireland 
sirin  e   parsia  b   cuenca grau  b   kalyanpur  a     katz  y          pellet  practical
owl dl reasoner  journal web semantics              
soergel  d   lauser  b   liang  a   fisseha  f   keizer  j     katz  s          reengineering
thesauri new applications  agrovoc example  j  digital information 
      
wu  z   eadon  g   das  s   chong  e  i   kolovski  v   annamalai  m     srinivasan  j 
        implementing inference engine rdfs owl constructs user defined
rules oracle  proceedings      ieee   th international conference
data engineering  icde      pp            ieee computer society 

   


