journal artificial intelligence research                  

submitted        published      

reformulating situation calculus event
calculus general theory stable models
answer set programming

joohyung lee
ravi palla

joolee asu edu
ravi palla asu edu

school computing  informatics 
decision systems engineering
arizona state university
tempe  az        usa

abstract
circumscription logic programs stable model semantics two wellknown nonmonotonic formalisms  former served basis classical logic based
action formalisms  situation calculus  event calculus temporal action
logics  latter served basis family action languages  language
several descendants  based discovery circumscription stable
model semantics coincide class canonical formulas  reformulate situation
calculus event calculus general theory stable models  present
translation turns reformulations answer set programs  efficient
answer set solvers applied compute situation calculus event calculus 

   introduction
circumscription  mccarthy              logic programs stable model semantics  gelfond   lifschitz        two well known nonmonotonic formalisms  one
oldest nonmonotonic formalisms  circumscription found many applications commonsense reasoning model based diagnoses  e g   mccarthy        shanahan        besnard
  cordier         stable model semantics mathematical basis answer set programming  asp   marek   truszczynski        niemela        lifschitz        
widely applied thanks availability several efficient implementations  known
answer set solvers 
two nonmonotonic formalisms applied overlapping classes
problems  minimal model reasoning ensured circumscription coincide stable
model reasoning  moreover  formalisms different roots  circumscription
defined terms translation classical  second order  logic  stable models proposed
gelfond lifschitz        defined terms grounding fixpoints
style reiters default logic  reiter         differences part account fact
two formalisms formed rather disparate traditions knowledge representation
research  particular  area temporal reasoning  former served basis
classical logic based action calculi  situation calculus  mccarthy   hayes       
reiter         event calculus  shanahan        temporal action logics  doherty 
c
    
ai access foundation  rights reserved 

filee   palla

gustafsson  karlsson    kvarnstrom         whereas latter served basis
family action languages  language  gelfond   lifschitz        several
descendants translated logic programs stable model semantics 
however  recent generalization stable model semantics shed new light
relationship circumscription stable models  first order stable model semantics defined ferraris  lee lifschitz              characterizes stable models
first order sentence models  in sense first order logic  sentence
satisfy stability condition  expressed second order formula similar
one used define circumscription  since logic programs viewed special
class first order sentences stable model semantics  definition extends
stable model semantics gelfond lifschitz        full first order level without
limiting attention herbrand models  essentially characterization independently given lin zhou         via logic knowledge justified assumption  lin
  shoham         definitions equivalent definition quantified equilibrium logic given pearce valverde         defined terms logic
here and there  heyting        
new definition stable model motivates us investigate relationship
stable model reasoning minimal model reasoning  particular  focus
relationship area temporal reasoning  show situation calculus
event calculus reformulated first order stable model semantics 
asp  theoretically interesting  practically useful allows us
leverage efficient answer set solvers computing circumscriptive action theories 
this  develop two technical results  first  show circumscription
first order stable model semantics coincide class canonical formulas 
largest syntactic class identified far two semantics coincide  general
enough cover several circumscriptive action formalisms  situation calculus 
event calculus  temporal action logics  result allows us reformulate
action formalisms first order stable model semantics  minimal model reasoning
sometimes leads unintuitive results  circumscriptive action formalisms carefully
designed avoid cases  result implies minimal model reasoning
action formalisms viewed stable model reasoning 
second  identify class almost universal formulas  turned
syntax logic program preserving stable models  turns reformulations situation calculus event calculus first order stable model
semantics fall class formulas  introduce system f lp turns formulas
class logic programs  and  conjunction result canonical formulas  use
combination f lp answer set solvers compute situation calculus
event calculus 
work makes explicit relationship classical logic logic program traditions temporal reasoning  interestingly  development event calculus
spanned traditions  original version event calculus  kowalski   sergot        formulated logic programs  stable model semantics  that
time invention stable model semantics   extensive developments later carried classical logic foundation via circumscription  e g  
shanahan                    miller   shanahan        mueller         relation
   

fireformulating situation calculus event calculus

logic program formulation remained implicit  based reduction circumscription completion  sat based event calculus systems implemented  one shanahan
witkowski        another mueller         latter system called dec
reasoner   outperforms former thanks efficient general compilation
method propositional logic  system handles large fragment event
calculus  still cannot handle recursive disjunctive axioms since completion cannot
applied axioms  asp based approach hand handle
full version event calculus assumption domain given finite 
thanks efficiency asp solvers  experiments indicate asp based event
calculus reasoner significantly faster dec reasoner  appendix b  
similar logic programming tradition event calculus  situation calculus  mccarthy   hayes        reiter        implemented prolog  based
fact clarks completion semantics accounts definitional axioms  unlike
event calculus  best knowledge  efficient propositional solvers
applied directly compute models situation calculus theories  paper 
reformulate lins causal action theories        reiters basic action theories       
first order stable model semantics asp  basic action theories  provide
asp based encoding method obtains reiters successor state axioms effect
axioms generic inertia axioms adopted asp  idea close reiters
frame default        
paper organized follows  next section reviews definitions circumscription first order stable model semantics  presents definition
canonical formula  based this  sections     reformulate event calculus
situation calculus first order stable model semantics  section   shows translation
turns almost universal formulas logic programs accepted asp
solvers  sections     use result turn reformulations event calculus
situation calculus given sections     input language asp solvers 
complete proofs given appendix c 

   circumscription first order stable model semantics
assume following set primitive propositional connectives quantifiers 
 falsity            
understand f abbreviation f   symbol   stands   f g
stands  f g   g f   
    review  circumscription
let p list distinct predicate constants p            pn   let u list distinct
predicate variables u            un   u p denote conjunction formulas
x ui  x  pi  x              n  x list distinct object variables whose
length arity pi   expression u   p stands  u p   p u  
   http   decreasoner sourceforge net

   

filee   palla

instance  p q unary predicate constants  u  v     p  q 


x u x  p x   x v x  q x   x p x  u x   x q x  v x    
circumscription defined terms circ operator minimized predicates 
first order formula f   expression circ f   p  stands second order formula
f u  u   p  f  u   
f  u  formula obtained f substituting ui pi   f sentence
 i e   formula free variables   intuitively  models circ f   p  models
f minimal p 
definition straightforwardly extended case f many sorted firstorder formula  lifschitz        section       language event calculus
situation calculus based on 
    review  first order stable model semantics
review follows definition ferraris et al          there  stable models
defined terms sm operator  whose definition similar circ operator
previous section  first order formula f finite list predicate constants
p    p            pn    formula sm f   p  defined
f u  u   p  f  u   
u defined circ f   p   f  u  defined recursively follows 
pi  t    ui  t  list terms 
f   f atomic formula f  including equality  contain
members p 
 f g    f g  
 f g    f g  
 f g     f g    f g  
 xf     xf  
 xf     xf  
predicates p called intensional  predicates intend
characterize f terms non intensional predicates   f sentence  models
second order sentence sm f   p  called p stable models f  
models f stable p  often simply write sm f   place sm f   p 
p list predicate constants occurring f   according lee  lifschitz 
   intensional predicates analogous output predicates datalog  non intensional predicates
analogous input predicates datalog  lifschitz        

   

fireformulating situation calculus event calculus

palla         answer sets defined special class stable models follows   f  
denote signature consisting object  function predicate constants occurring
f   f contains least one object constant  herbrand interpretation  f  
satisfies sm f   called answer set f   answer sets logic program defined
answer sets fol representation  i e   conjunction universal
closures implications corresponding rules   example  fol representation
program
p a 
q b 
r x  p x   q x 

p a  q b  x p x  q x  r x  

   

sm f  
p a  q b  x p x  q x  r x  
uvw   u  v  w     p  q  r   u a  v b 
x  u x   v x  q x   w x    p x  q x  r x     
equivalent first order sentence
x p x  x   a  x q x  x   b  x r x   p x  q x   

   

 ferraris et al         example     stable models f first order models     
answer set f herbrand model  p a   q b   r a   
according ferraris et al          definition answer set  applied
syntax logic programs  equivalent traditional definition answer set
based grounding fixpoints  gelfond   lifschitz        
note definition stable model general definition
answer set following ways  stable models restricted herbrand models 
underlying signature arbitrary  intensional predicates fixed
list predicate constants occurring formula  last fact essential view
following proposition  pr  f   denote list predicate constants occurring
f   choice p  denote conjunction choice formulas x p x  p x  
predicate constants p p  x list distinct object variables  false p 
denote conjunction xp x  predicate constants p p  sometimes identify
list corresponding set confusion 
proposition   formula
sm f   p  sm f choice pr  f   p  false p pr  f    

   

logically valid 
notice  implicit  intensional predicates right hand side    
 pr  f   p   choice formula makes predicates  pr  f     p  exempt
stability checking  hand  false formula makes predicates
 p   pr  f    stabilized  i e   empty extents   though occur f  
   

filee   palla

ferraris et al         incorporate strong negation stable model semantics
distinguishing intensional predicates two kinds  positive negative 
negative intensional predicate form p  p positive intensional predicate
symbol strong negation  syntactically logical connective 
appear part predicate constant  interpretation underlying
signature coherent satisfies formula
x p x  p x   

   

x list distinct object variables  negative predicate p  usually
consider coherent interpretations only  intuitively  p t  represents p t  false 
different p t  represents known p t  true  similarly 
p t  represents known p t  false  p t  represents
known p t  known true  note that  unlike first order logic  p t 
different p t   instance  formula p a  one answer set  p a   p a 
answer sets 
extension circumscription many sorted first order sentences  definition
stable model straightforwardly extended many sorted first order sentences 
    equivalence stable model semantics circumscription
canonical formulas
neither stable model semantics circumscription stronger other 
example 
circ x p x  p x    p 
   
equivalent xp x  
sm x p x  p x    p 

   

equivalent        stronger      hand 
circ x p x  q x    p  q 

   

equivalent x p x  q x   
sm x p x  q x    p  q 

   

equivalent x p x  q x        stronger     
section  show two semantics coincide class formulas called
canonical formulas  define below  first review notions positive  negative 
strictly positive occurrences 
definition   say occurrence predicate constant  subexpression  formula f positive number implications containing occurrence
antecedent even  negative otherwise   recall treat g shorthand
g    say occurrence strictly positive number implications f
containing occurrence antecedent   
   

fireformulating situation calculus event calculus

example       occurrences q positive  first one strictly
positive 
definition   say formula f canonical relative list p predicate constants

occurrence predicate constant p antecedents one
implication f  
every occurrence predicate constant p scope strictly positive
occurrence f strictly positive f  
example   formula
x p x  q x  

   

shown canonical relative  p  q  since satisfy first clause
definition  p occurs antecedents two implications p x  shorthand
p x     hand  formula canonical relative  q   formula
x p x  p x  

    

canonical relative  p  since satisfy second clause  the second occurrence p scope strictly positive occurrence   strictly positive
       formula
p a   x p x  x q x  
    
canonical relative  p  q  
p a  a  x p x  a  p b  x  

    

canonical relative  p  q  since satisfy second clause  the second
occurrence p scope strictly positive occurrence   strictly
positive formula       
following theorem states that  canonical formula  circumscription coincides
stable model semantics 
theorem   canonical formula f relative p 
circ f   p  sm f   p 

    

logically valid 
instance  formula       canonical relative  p  q   formulas circ       p  q 
sm       p  q  equivalent other  also  sentence f clearly canonical
relative   circ f     equivalent sm f      turn equivalent f  
hand  equivalence may necessarily hold non canonical formulas 
instance  observed that  formula      canonical relative  p   formulas         equivalent other  formula     canonical
   

filee   palla

relative  p  q   formulas         equivalent other  observe
formula      canonical relative  p  q   circ       p  q  equivalent
sm       p  q   herbrand interpretation  p a  a   p b  a   satisfies sm       p  q  
satisfy circ       p  q  
note non canonical formulas often equivalently rewritten canonical formulas  since equivalent transformation preserves models circumscription  theorem   applied non canonical formulas  first rewriting canonical
formulas  example  formula     equivalent
x p x  q x   

    

canonical relative  p  q   circ      p  q  equivalent sm       p  q  
another example  formula      equivalent
x p x  p x   

    

canonical relative  p   circ       p  equivalent sm       p  
clear treatment applied quantifier free formula  including
propositional formula  quantifier free formula equivalently rewritten
canonical formula first rewriting clausal normal form turning
clause form c d  c conjunction atoms disjunction
atoms  
sections     use theorem   reformulate event calculus situation
calculus first order stable model semantics 

   reformulating event calculus general theory stable
models
section  review syntax circumscriptive event calculus described chapter  
book mueller         based observation syntax conforms
condition canonicality  present reformulations event calculus general
theory stable models 
    review  circumscriptive event calculus
assume many sorted first order language  contains event sort  fluent sort 
timepoint sort  fluent term term whose sort fluent  event term
timepoint term defined similarly 
definition   condition defined recursively follows 
    terms  comparisons                                    
       conditions 
   appears unlikely knowledge encoded non canonical formula     
cannot easily turned equivalent canonical formula  c f  guide axiomatizing domains
first order logic  http   cs nyu edu faculty davise guide html   surprise
circumscriptive action theories mentioned paper satisfy canonicality assumption 

   

fireformulating situation calculus event calculus

f fluent term timepoint term  holdsat f  t  holdsat f  t 
conditions 
    conditions          conditions 
v variable condition  v condition 
use e ei denote event terms  f denote fluent terms  ti
denote timepoint terms  denote conditions 
event calculus  circumscribe initiates  terminates  releases minimize
unexpected effects events  circumscribe happens minimize unexpected events 
circumscribe ab  abnormality predicates  minimize abnormalities  formally  event
calculus description circumscriptive theory defined
circ    initiates  terminates  releases  circ    happens 
circ    ab             ab n    

    


conjunction universal closures axioms form
initiates e  f  t 
terminates e  f  t 
releases e  f  t 
   e  f    t     e  f    t 
 effect constraint 
  happens e    t    happens en   t  initiates e  f  t 
  happens e    t    happens en   t  terminates e  f  t  
    either initiates terminates     means
optional  
conjunction universal closures temporal ordering formulas  comparisons
timepoint terms  axioms form
happens e  t 
 f  t     f    t  n  fn   t  happens e  t 
 causal constraints 
happens e  t  happens e    t  happens en   t   disjunctive event axiom  
started stopped j    j n  either initiated
terminated  
conjunction universal closures cancellation axioms form
abi       t   
conjunction first order sentences  outside scope circ  including unique
name axioms  state constraints  event occurrence constraints  set domainindependent axioms event calculus  ec  for continuous event calculus  dec  for discrete event calculus   mueller        chapter    
   

filee   palla

includes following definitions predicates used causal constraints  
def

started  f  t   holdsat f  t  e happens e  t  initiates e  f  t   

 cc   

def

stopped  f  t   holdsat f  t  e happens e  t  terminates e  f  t   
def

initiated  f  t   started  f  t  e happens e  t  terminates e  f  t   
def

terminated  f  t   stopped  f  t  e happens e  t  initiates e  f  t   

 cc   
 cc   
 cc    

remark   following facts easy check 
canonical relative  initiates  terminates  releases  
canonical relative  happens  
canonical relative  ab             ab n   
facts used next section reformulate event calculus general
theory stable models 
    reformulating event calculus general theory stable models
following ferraris  lee  lifschitz  palla         formula f say
negative list p predicate constants members p strictly positive
occurrences f    example  formula     negative  p   negative  p  q  
formula form f  shorthand f   negative list predicates 
assume already equivalently rewritten negative  initiates 
terminates  releases  happens  ab             ab n    easily done prepending
strictly positive occurrences predicates  following theorem shows
equivalent reformulations circumscriptive event calculus general theory stable
models 
theorem   event calculus description       following theories equivalent
other  
 a  circ   i  t  r  circ   h  circ   ab             ab n    
 b  sm   i  t  r  sm   h  sm   ab             ab n    
 c  sm    i  t  r  h  ab             ab n    
 d  sm  choice pr        i  t  r  h  ab             ab n      
equivalence  a   b  immediate theorem    equivalence
 b   c  shown using splitting theorem ferraris et al         
assumption negative intensional predicates essential showing
   note distinguish formula negative  on p  occurrence negative
 section      
   brevity  abbreviate names circumscribed predicates 

   

fireformulating situation calculus event calculus

equivalence  for details  see proof appendix c      equivalence
 c   d  follows proposition   since
 i  t  r  h  ab             ab n     pr    
empty set  

   reformulating situation calculus general theory stable
models
section  review reformulate two versions situation calculuslins
causal action theories        reiters basic action theories        
    review  lins causal action theories
assume many sorted first order language contains situation sort  action
sort  fluent sort  truth value sort object sort  understand expression p  x  s  
p fluent name  shorthand holds p  x   s   consider functional
fluents simplicity 
according lin         formula  s  called simple state formula  s 
mention poss  caused situation term possibly variable s 
assume causal action theory consists finite number following
sets axioms  often identify conjunction universal closures
axioms d  following  f   fluent names  action name  v   vi truth
values  s  s  situation variables   s  simple state formula s  symbols a  a 
action variables  f variable sort fluent  v variable sort truth value  x 
xi   y  yi lists variables 
dcaused conjunction axioms form
poss a x   s    s  caused  f  y   v  do a x   s  
 direct effect axioms  
 s  caused  f   x     v    s  caused  fn  xn    vn   s  caused  f  x   v  s 
 indirect effect axioms  
dposs conjunction precondition axioms form
poss a x   s   s  

    

drest conjunction following axioms 
basic axioms 
caused  f  true  s  holds f  s  
caused  f  false  s  holds f  s  
true    false v v   true v   false  
   i    r  h occur domain independent axioms part  

   

    

filee   palla

unique name assumptions fluent names 
 x     fj  y    i    j 
 x     y  x   y 

    

similarly action names 
foundational axioms discrete situation calculus 

 

   do a  s  
 

 

 

 

do a  s    do a      a       



p p s    a  p s  p do a  s   p s   

    
    
    

frame axiom 
poss a  s   vcaused  f  v  do a  s  
 holds f  do a  s   holds f  s    
axioms domain knowledge   s  
causal action theory defined
circ dcaused   caused   dposs drest  

    

remark   easy check dcaused canonical relative caused  
fact used next section reformulate causal action theories general
theory stable models 
    reformulating causal action theories general theory stable
models
let dposs conjunction axioms  s  poss a x   s  axiom      dposs  
instead second order axiom       consider following first order formula dsit  
introduces new intensional predicate constant sit whose argument sort situation  
sit s    a  s sit s  sit do a  s    ssit s  

    


following  drest
theory obtained drest dropping      

theorem   given causal action theory       following theories equivalent
disregard auxiliary predicate sit 
 a  circ dcaused   caused   dposs drest  

 b  sm dcaused   caused   dposs drest
sm dsit   sit   

 c  sm dcaused   caused   sm dposs   poss  drest
sm dsit   sit   

 d  sm dcaused dposs drest
dsit   caused   poss  sit   

   simplicity omit two axioms regarding partial order among situations 
   suggested vladimir lifschitz  personal communication  

   

fireformulating situation calculus event calculus

    review  reiters basic action theories
causal action theories  understand p  x  s   p fluent name  shorthand
holds p  x   s   consider functional fluents 
basic action theory  bat  form
dss dap duna ds   

    


conjunction foundational axioms  section      
dss conjunction successor state axioms form
f  x  do a  s   f  x  a  s  
f  x  a  s  formula uniform
among x  a  s 

 

whose free variables

dap conjunction action precondition axioms form
poss a x   s   x  s  
 x  s  formula uniform whose free variables among x  s 
duna conjunction unique name axioms fluents actions 
ds  conjunction first order formulas uniform s   
    reformulating basic action theories general theory stable
models
note bat theory first order logic    view fact first order
logic sentence f equivalent sm f      trivial view bat first order theory
stable model semantics list intensional predicates empty 
rest section  consider alternative encoding bat asp 
need provide explicit successor state axioms dss   instead  successor state
axioms entailed effect axioms generic inertia axioms adopted asp
making intensional positive predicate holds negative predicate holds
 recall definitions positive negative predicates section       following
assume underlying signature contains predicates 
asp style bat form
deffect dprecond dinertia dexogenous  duna ds   

  duna ds  defined before 
   refer reader book reiter        definition uniform formula 
    simplicity disregard second order axiom      

   

    

filee   palla

deffect conjunction axioms form
 
r
 x  a  s  holds r x   do a  s  

    


r
 x  a  s  holds r x   do a  s   

    


 
r
 x  a  s 


r
 x  a  s 



variables among x  s 

formulas uniform whose free

dprecond conjunction axioms form
 x  s  poss a x   s  

    

 x  s  formula uniform whose free variables among x  s 
dinertia conjunction axioms
holds r x   s  holds r x   do a  s   holds r x   do a  s   
holds r x   s  holds r x   do a  s   holds r x   do a  s  
fluent names r 
dexogenous  conjunction
holds r x   s    holds r x   s   
fluent names r 
note axioms dinertia typically used answer set programming represent
common sense law inertia  lifschitz   turner         similarly  dexogenous  used
represent initial value fluent arbitrary   
show asp style bat related reiters bat  first  since use
strong negation  convenient define following notions  given signature
bat  holds signature obtained adding holds   say
interpretation holds complete holds satisfies
y holds y  holds y   
list distinct variables  given interpretation holds   expression i 
denotes projection  
let dss conjunction successor state axioms

holds r x   do a  s    
r  x  a  s   holds r x   s  r  x  a  s   
 

 
r  x  a  s  disjunction r  x  a  s  axioms      deffect   r  x  a  s 

disjunction r  x  a  s  axioms      deffect   dap denote conjunction axioms poss a x   s   x  s    x  s  disjunction  x  s 
axioms      dprecond  

    axioms dinertia dexogenous  closely related translation c  nonmonotonic
causal logic  giunchiglia  lee  lifschitz  mccain    turner        

   

fireformulating situation calculus event calculus

theorem   let theory      signature holds   coherent interpretation
holds complete holds  satisfies

x s  
r  x  a  s  r  x  a  s  

every fluent name r  satisfies
sm t   poss  holds  holds 
iff i  satisfies bat
dss dap duna ds   

   translating almost universal sentences logic programs
theorems    present reformulations situation calculus event calculus
general theory stable models  may contain nested quantifiers connectives 
hand  input languages asp solvers limited simple rule forms 
analogous clausal normal form classical logic  although first order formula
rewritten clausal normal form preserving satisfiability  transformations
necessarily preserve stable models  due fact notion equivalence
stronger stable model semantics  lifschitz  pearce    valverde        
definition    ferraris et al         formula f strongly equivalent formula g if 
formula h containing f subformula  and possibly containing object  function
predicate constants occur f   g   list p distinct predicate
constants  sm h  p  equivalent sm h     p   h   obtained h replacing
occurrence f g 
words  replacing subformula another strongly equivalent subformula
change stable models whole formula  strongly equivalent theories
classically equivalent  i e   equivalent classical logic   converse hold 
consequently  classically equivalent transformations necessarily preserve stable models  instance  consider p p  p intensional  former stable models
latter not 
known every propositional formula rewritten logic program  cabalar
  ferraris        cabalar  pearce    valverde        lee   palla         translations extended quantifier free formulas straightforward way  section      
however  method work presence arbitrary quantifiers 
target formalism  logic programs   variables implicitly universally quantified 
section  present translation turns certain class sentences called
almost universal sentences logic programs preserving stable models  turns
reformulations situation calculus event calculus sections  
  belong class almost universal sentences  use asp solvers
computing them 
   

filee   palla

    translating quantifier free formulas logic programs
cabalar et al         define following transformation turns propositional formula stable model semantics logic program 
left side rules 
 f g

 

 f g 

 l  

f g

 



 l  

f g h

 

 l  

 f g  h k

 

 f g  h k

 

 g f h 


f h k
gh k



f h k
gh k


h f g k

f g

 

 f g 

 r  

f  g

 



 r  

f g h

 

 r  

f  g h  k

 

f  g h  k

 

 g f h 


f gk
f h k


gf h k
h f g k

 l  

 l  

right side rules 

 r  
 r  

applying transformation formula lefthand side  assume
formula already written negation normal form  negation applied
literals only  using following transformation 
negation normal form conversion 
 

f
 f g 
 f g 
 f g 

 
 

 

 

 

 



 
f
f g
f g
f g

according cabalar et al          successive application rewriting rules
turn propositional formula disjunctive logic program  result simply
extended turn quantifier free formula logic program 
noted cabalar et al          translation may involve exponential blowup
size  theorem   paper shows indeed vocabulary preserving
polynomial time algorithm convert general propositional theories stable model
semantics disjunctive logic programs  alternatively  one use another translation
paper  linear size involves auxiliary atoms
complex 
   

fireformulating situation calculus event calculus

    quantifier elimination
introduce quantifier elimination method distinguishes two kinds occurrences quantifiers  singular non singular  non singular occurrence
quantifier easy eliminate  singular occurrence eliminated certain
syntactic condition 
definition   say occurrence qxg f singular
q   occurrence qxg positive f  
q   occurrence qxg negative f  
example  occurrence x q x  singular       occurrence x p x 
not 
non singular occurrences quantifiers eliminated view fact every
first order sentence rewritten prenex form  prenex form conversion rules given
section       pearce valverde        preserve strong equivalence  leads
following theorem   
theorem    lee   palla        proposition    every first order formula strongly
equivalent formula prenex form 
prenex form conversion turns non singular occurrence quantifier
outermost preserving strong equivalence  consequently  sentence contains
singular occurrence quantifier  results used turn sentence
universal sentence set asp rules  however  presence
singular occurrence quantifier  prenex form conversion turns occurrence
outermost   allowed logic programs  consider handle
occurrences 
obviously  herbrand universe finite  interested herbrand stable
models  i e   answer sets  only  quantified formulas rewritten multiple disjunctions
conjunctions  even need consider turning formula prenex form 
example  formula
r x p x  q x  

    

occurring theory whose signature contains             n  object constants  and
function constants   replace x p x  q x   multiple disjunctions
turn resulting program nested expressions usual disjunctive program
 lifschitz  tang    turner          n rules generated  instance  n     
    pearce valverde        show sentence qnc    monotonic basis quantified equilibrium
logic  turned prenex form  result follows 

   

filee   palla

resulting logic program
r 
r 
r 
r 
r 
r 
r 
r 

p    
p    
p    
p    
q    
q    
q    
q    

p    
p    
q    
q    
p    
p    
q    
q    

p   
q   
p   
q   
p   
q   
p   
q    

also  translation modular depends underlying domain  multiple
disjunctions conjunctions need updated domain changes  importantly  method applicable theory contains function constants positive
arity  herbrand universe infinite 
one may consider introducing skolem constants first order logic  presuming
that  sentence f skolem form f     sm f   p  satisfiable iff sm f     p 
satisfiable  however  idea work   
example   formula
f    x p x  q  x q p x   
sm f   q  equivalent first order sentence
 q x p x   x q p x   
unsatisfiable  the equivalence established using theorems      ferraris et al          formula f strongly equivalent prenex form

xy  p x  q   q p y    

    

however  introduce new object constants b replace existentially quantified
variables
f      p a  q   q p b   
formula sm f     q  equivalent
 q p a    q p b   
satisfiable 
present method eliminating singular occurrences quantifiers introducing auxiliary predicates  idea generalization practice logic programming
    pearce valverde        show skolemization works qnc    monotonic basis quantified equilibrium logic  example shows  imply skolemization works
quantified equilibrium logic 

   

fireformulating situation calculus event calculus

simulates negated existential quantification body rule introducing auxiliary predicates  instance  order eliminate       introduce new
predicate constant p    turn     
 r p  s  x p x  q x  p    

    

corresponds logic program
r  p 
p  p x   q x  

    

models sm       p  q  r  s  stable models      disregard
p    method involve grounding  translation depend
domain restricted herbrand models  method formally justified
following proposition 
recall formula h negative p members p strictly positive
occurrences h  given formula f   say occurrence subformula g
p negated f contained subformula h f negative p 
proposition   let f sentence  let p finite list distinct predicate constants 
let q new predicate constant occur f   consider non strictly
positive  p negated occurrence yg y  x  f   x list free variables
yg y  x   let f   formula obtained f replacing occurrence yg y  x 
q x  
sm f   p  x q x  yg y  x  
equivalent
sm f   xy g y  x  q x    p  q  
proposition   tells us sm f   p  sm f   xy g y  x  q x   p  q 
models disregard new predicate constant q  notice f   retain
occurrence y 
example   formula       x p x  q x   contained negative formula  relative
set intensional predicates   accordance proposition    sm       p  q  r  s 
models sm       p  q  r  s  p    disregard p   
singular  p negated occurrence subformula yg y  x  eliminated
using proposition   first rewriting yg y  x  yg y  x   note yg y  x 
strongly equivalent yg y  x   general classically equivalent transformation may necessarily preserve stable models  however  theorem double
negations  ferraris et al         reviewed appendix c  tells us transformation ensured preserve p stable models replaced occurrence p negated
given formula 
ready present quantifier elimination method  applies
class almost universal formulas 
   

filee   palla

definition   say formula f almost universal relative p every singular
occurrence qxg f p negated f  
example  formula      almost universal relative set predicates
singular occurrence x p x  q x        contained x p x  q x   
negative list predicates  formula f example   almost universal relative
 q  singular occurrence x p x  contained formula itself 
negative  q   singular occurrence x q p x   contained x q p x   
negative  q  
following procedure used eliminate  possibly nested  quantifiers
almost universal sentence 
definition    translation elim quantifiers  given formula f   first prepend
every maximal strictly positive occurrence formula form yh y  x    
repeat following process occurrences quantifiers remaining  select
maximal occurrence formula form qyg y  x  f   q   x
list free variables qyg y  x  
 a  occurrence qyg y  x  f non singular f   set f formula
obtained f replacing occurrence qyg y  x  g z  x   z
new variable 
 b  otherwise  q occurrence qyg y  x  f positive  set f

f    g y  x  pg  x   
pg new predicate constant f   formula obtained f replacing occurrence qyg y  x  pg  x  
 c  otherwise  q occurrence qyg y  x  f negative  set f
formula obtained f replacing occurrence qyg y  x 
yg y  x  
assume new predicate constants introduced translation belong
signature input formula f   clear process terminates  yields
formula quantifier free  since number times step  b  applied
number quantifiers input formula  new formulas added
size polynomial input formula  follows size resulting quantifier free
formula polynomial size input formula 
following theorem tells us almost universal sentence f turned
form xg  g quantifier free formula   second order  sentences f
g signature subset signature  say f  equivalent
g  denoted f g  class models f restricted identical class
models g restricted  
    maximality understood terms subformula relation  is  select strictly positive
occurrence subformula f form yh y  x  contained subformula
f form 

   

fireformulating situation calculus event calculus

theorem   let f sentence signature   let f   universal closure
formula obtained f applying translation elim quantifiers  let q list
new predicate constants introduced translation  f almost universal relative
p  sm f   p   equivalent sm f     p  q  
statement theorem becomes incorrect require f almost
universal relative p  instance  elim quantifiers applied x p x   results
q  p x  q   however  sm x p x   p   p  equivalent
sm x q  p x  q    p  q   former equivalent saying p singleton 
latter equivalent q xp x   q xp x    inconsistent 
    f lp  computing answer sets first order formulas
using translation elim quantifiers defined previous section  introduce translation f lp turns almost universal formula logic program  assume
underlying signature contains finitely many predicate constants 
definition    translation f lp 
   given formula f list intensional predicates p  apply translation elim quantifiers  definition    f  
   add choice formulas  q x  q x   non intensional predicates q 
   turn resulting quantifier free formula logic program applying translation section   paper cabalar et al          reviewed
section     
explained section      due third step  transformation may involve
exponential blowup size  one obtain polynomial translation replacing step  
alternative translation given section   paper cabalar et al 
following theorem asserts correctness translation 
theorem   let f sentence signature   let p list intensional predicates 
let f   fol representation program obtained f applying translation
f lp p intensional predicates  f almost universal relative p  sm f   p 
 equivalent
sm f   false p   pr  f       
example   consider one domain independent axioms discrete event calculus
 dec  axiom  
holdsat f  t  releasedat f  t   
e happens e  t  terminates e  f  t   holdsat f  t    
step   translation f lp introduces formula
happens e  t  terminates e  f  t  q f  t  
replaces     
holdsat f  t  releasedat f  t    q f  t  holdsat f  t    
   

    

filee   palla

step   turns formulas rules
q f  t  happens e  t   terminates e  f  t 
holdsat f  t    holdsat f  t   releasedat f  t     q f  t  
turning program obtained applying translation f lp input languages
lparse    gringo    requires minor rewriting  moving equality negated
atoms head body    adding domain predicates body variables
occurring rule order reduce many sorted signature non sorted one   
system f lp implementation translation f lp  turns first order formula
languages lparse gringo  system downloaded home
page
http   reasoning eas asu edu f lp  
first order formulas encoded f lp using extended rule form f g 
f g first order formulas contain   ascii representation
quantifiers connectives shown following table 
symbol
ascii





 


 


 


  


false

 
true

xyz
  x y z  

xyz
  x y z  

example  formula      encoded input language f lp
holdsat f t       holdsat f t    releasedat f t     
  e   happens e t    terminates e f t   

usual lparse gringo rules  which rule arrow     allowed
f lp  rules simply copied output  program returned f lp
passed asp grounders solvers accept lparse gringo languages 

   computing event calculus using asp solvers
using translation f lp  turn event calculus reformulation section    
answer set programs  following procedure describes process 
definition    translation ec asp 
   given event calculus description       rewrite
definitional axioms form
def

x p x  g 

    

x g p x    g obtained g prepending
occurrences intensional predicates initiates  terminates  releases  happens 
ab             ab n   prepend strictly positive occurrences intensional
predicates remaining axioms   let   resulting formula obtained
 
   
   
   
   

http   www tcs hut fi software smodels
http   potassco sourceforge net
instance   x y     q x y     p x y  turned    x  y   not q x y     p x y  
alternatively done declaring variables using  domain directive lparse gringo
languages 

   

fireformulating situation calculus event calculus

   apply translation f lp   intensional predicates
 initiates  terminates  releases  happens  ab             ab n   p 
p set predicate constants p      considered step   
following theorem states correctness translation 
theorem   let event calculus description      signature contains finitely
many predicate constants  let f fol representation program obtained
applying translation ec asp   equivalent sm f   
view theorem  system f lp used compute event calculus descriptions
simple rewriting stated translation ec asp    system used place
dec reasoner many existing applications event calculus  robotics 
security  video games  web service composition  listed
http   decreasoner sourceforge net csr decapps html  
computational mechanism dec reasoner similar method
based reduction event calculus reasoning propositional satisfiability uses
efficient sat solvers computation  however  method advantages 
first  significantly faster due efficient grounding mechanisms implemented
asp systems  evidenced experiments reported appendix b 
second  f lp allows us compute full version event calculus  assuming
domain given finite  hand  reduction implemented dec
reasoner based completion  weaker circumscription  makes
system unable handle recursive axioms disjunctive axioms  effect constraints
disjunctive event axioms  section       example  dec reasoner allow
following effect constraints describe indirect effects agents walking
objects holding 
holdsat holding a  o   t  initiates e  inroom a  r   t 
initiates e  inroom o  r   t 
holdsat holding a  o   t  terminates e  inroom a  r   t 
terminates e  inroom o  r   t  

    

third  enhance event calculus reasoning combining asp rules
event calculus description  words  event calculus viewed high
level action formalism top asp  illustrate using example work
dogandag  ferraris  lifschitz           rooms    doors shown
figure    initially robot robby middle room doors closed 
goal robot make rooms accessible other  figure    file robby 
shows encoding problem language f lp  atom door x  y  denotes
door rooms x y  open x  y  denotes event robby opening door
    kim  lee  palla        presented prototype f lp called ecasp tailored event
calculus computation 

   

filee   palla

figure    robbys apartment     grid
rooms x y  goto x  denotes event robby going room x  opened x  y 
denotes door x opened  inroom x  denotes robby
room x  accessible x  y  denotes accessible x  note rules
defining relation accessible part event calculus axioms  section      
example illustrates advantage allowing asp rules event calculus descriptions 
minimal number steps solve given problem     find
plan using combination f lp  gringo  grounder  claspd  solver disjunctive
programs  following way    
  f lp dec robby   gringo  c maxstep      claspd
file dec f lp encoding domain independent axioms discrete event
calculus  the file listed appendix a     following one plans found 
happens open         happens open         happens open        
happens goto       happens open         happens open        
happens goto       happens open         happens goto      
happens open         happens open         

   computing situation calculus using asp solvers
using translation f lp  turn situation calculus reformulations sections    
    answer set programs 
    representing causal action theories answer set programs
following theorem shows turn causal action theories answer set programs 
theorem   let finite causal action theory      signature contains finitely
many predicate constants  let f fol representation program obtained
applying translation f lp

dcaused dposs drest
dsit

    

intensional predicates  caused   poss  sit    equivalent sm f   
    one use clingo instead gringo claspd output f lp nondisjunctive program 
    file available http   reasoning eas asu edu f lp  along f lp encodings
domain independent axioms versions event calculus 

   

fireformulating situation calculus event calculus

  file robby
  objects
step    maxstep  
astep    maxstep       maxstep     
room       
  variables
 domain step t  
 domain room r  
 domain room r   
 domain room r   
  position
door r  r      r 
door r  r      r 
door r  r      r 
door r  r      r 

doors
      
      
      
      

r 
r 
r 
r 

      r        r        r    r    
       r        r        r    r    
       r         r         r    r    
  r    

door r  r      door r  r   
  fluents
fluent opened r r       door r  r   
fluent inroom r   
  f ranges fluents
 domain fluent f  
  events
event open r r       door r r   
event goto r   
  e e  range events
 domain event e  
 domain event e   
  effect axioms
initiates open r r   opened r r   t  
initiates open r r   opened r  r  t  
initiates goto r   inroom r   t 
   holdsat opened r  r   t    holdsat inroom r   t  
terminates e inroom r   t 
   holdsat inroom r   t    initiates e inroom r   t  
  action precondition axioms
holdsat inroom r   t     happens open r  r   t  

   

filee   palla

  event occurrence constraint
happens e  t     happens e t    e    e  
  state constraint
holdsat inroom r   t     holdsat inroom r   t    r     r  
  accessibility
accessible r r  t     holdsat opened r r   t  
accessible r r  t     accessible r r  t    accessible r  r  t  
  initial state
holdsat opened r  r      
holdsat inroom       
  goal state
accessible r r  maxstep  
  happens exempt minimization order find plan 
 happens e t        maxstep 
  fluents inertial
releasedat f    

figure    robby f lp

similar computation event calculus section    herbrand stable
models      computed using f lp answer set solvers  input f lp
simplified limit attention herbrand models  drop axioms         
ensured herbrand models  also  order ensure finite grounding  instead
dsit   include following set rules situation input f lp 
nesting   s   
nesting l   do a s      nesting l s    action a    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  

situation used generate finitely many situation terms whose depth maxdepth 
value given option invoking gringo  using splitting theorem
 section c     difficult check program containing rules
occurrence predicate nesting rules occurrence predicate situation head rules  every answer set contains
atoms situation do am   do am    do         do a    s       possible sequences actions
a                         maxdepth  though program satisfy syntactic conditions   restricted  gebser  schaub    thiele          restricted  syrjanen        
finite domain programs  calimeri  cozza  ianni    leone         answer set solvers
usually impose order ensure finite grounding  rules still finitely grounded
   

fireformulating situation calculus event calculus

  file  suitcase
value t  
value f  

lock l   

lock l   

 domain value v  
 domain lock x  
fluent up x   
fluent open  
 domain fluent f  
action flip x   
 domain action a  
depth    maxdepth  
 domain depth l  
  defining situation domain
nesting   s   
nesting l   do a s      nesting l s    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  
  basic axioms
h f s     situation s    caused f t s  
h f s     situation s    caused f f s  
  d caused
caused up x  f do flip x  s    situation s    final s    poss flip x  s    h up x  s  
caused up x  t do flip x  s    situation s    final s    poss flip x  s    h up x  s  
caused open t s     situation s    h up l   s    h up l   s  
  d poss
poss flip x  s     situation s  
  frame axioms
h f do a s    h f s    situation s    final s    poss a s 
    v  caused f v do a s   
h f do a s    not h f s    situation s    final s    poss a s 
    v  caused f v do a s   
  h non intensional 
 h f s      situation s  

figure    lins suitcase language f lp
   

filee   palla

gringo version   x  check syntactic conditions    difficult
see program leads finite grounding since provide explicit upper
limit nesting depth function do 
addition situation   use following program executable order represent
set executable situations  reiter        
executable s   
executable do a s      executable s    poss a s    final s 
  situation s    action a  

figure   shows encoding lins suitcase example        language f lp
 h used represent holds   describes suitcase two locks spring
loaded mechanism open suitcase locks up  example
illustrates ramification problem handled causal action theories  since fix
domain situations finite  require actions effective final
situations  done introducing atom final s  
consider simple temporal projection problem lin         initially first lock
second lock up  happen first lock flipped  intuitively 
expect locks suitcase open  automate reasoning
using combination f lp  gringo claspd  first  add executable
following rules theory figure    order check theory entails flipping
first lock executable  suitcase open action  encode
negation facts last rule 
  initial situation
   h up l   s   
h up l   s   
  query
   executable do flip l   s      h open do flip l   s    

check answer temporal projection problem running command 
  f lp suitcase   gringo  c maxdepth     claspd

claspd returns answer set expected 
now  consider simple planning problem opening suitcase locks
initially down  add executable following rules theory figure   
last rule encodes goal 
  initial situation
   h up l   s   
   h up l   s   
   h open s   
  goal
     s    executable s    h open s   

maxdepth    combined use f lp  gringo claspd results
answer sets  maxdepth    finds unique answer set contains
    similarly  system dlv complex allows us turn finite domain checking  option  nofdcheck  
system used conference paper  lee   palla        article based on 

   

fireformulating situation calculus event calculus

h open  do flip l    do flip l    s     h open  do flip l    do flip l    s     
encodes plan  words  single answer set encodes multiple plans
different branches situation tree  allows us combine information
different branches one model  instance hypothetical reasoning
elegantly handled situation calculus due branching time structure  belleghem 
denecker  schreye        note linear time structure event calculus
limited handle hypothetical reasoning allowed situation calculus 
    representing basic action theories answer set programs
since bat  not including second order axiom       viewed first order
theory stable model semantics list intensional predicates empty 
follows f lp used turn logic program  before  focus
asp style bat 
theorem    let asp style bat      signature contains finitely many
predicate constants  let f fol representation program obtained applying translation f lp intensional predicates  holds  holds  poss  
sm t   holds  holds  poss   equivalent sm f    f    poss   
figure   shows encoding broken object example discussed reiter        
consider simple projection problem determining object o  next
bomb b  broken bomb explodes  add executable following rules
theory figure   
  initial situation
h broken o  s     h fragile o  s     h nexto b o  s   
h holding p o  s     h exploded b  s   
  query
   executable do explode b  s      h broken o  do explode b  s    

command
  f lp broken   gringo  c maxdepth     claspd

returns answer set expected 

   related work
identifying syntactic class theories different semantics coincide important
understanding relationship them  known that  tight logic programs
tight first order formulas  stable model semantics coincides completion
semantics  fages        erdem   lifschitz        ferraris et al          fact helps us
understand relationship two semantics  led design answer
set solver cmodels      computes answer sets using completion  likewise class
canonical formulas introduced helps us understand relationship
stable model semantics circumscription  class canonical formulas largest
    http   www cs utexas edu users tag cmodels

   

filee   palla

  file  broken
  domains situations
person p  
object o  
bomb b  
 domain person r  
 domain object y  
 domain bomb b  
fluent holding r y   
fluent broken y   

fluent nexto b y   
fluent exploded b   

fluent fragile y   

action drop r y   

action explode b   

action repair r y   

 domain fluent f  
 domain action a  
depth    maxdepth  
 domain depth l  
  defining situation domain
nesting   s   
nesting l   do a s      nesting l s    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  
  effect axioms
h broken y  do drop r y  s      situation s    h fragile y  s    final s  
h broken y  do explode b  s      situation s    h nexto b y  s    final s  
h exploded b  do explode b  s      situation s    final s  
 h broken y  do repair r y  s      situation s    final s  
 h holding r y  do drop r y  s      situation s    final s  
  action precondition axioms
poss drop r y  s     h holding r y  s    situation s  
poss explode b  s     situation s    h exploded b  s  
poss repair r y  s     situation s    h broken y  s  
  inertial axioms
h f do a s      h f s     h f do a s     situation s    final s  
 h f do a s       h f s    h f do a s     situation s    final s  
  d exogeneous  
h f s      h f s   
  consider interpretations complete holds
   h f s     h f s    situation s  

figure    broken object example language f lp

   

fireformulating situation calculus event calculus

syntactic class first order formulas identified far stable models coincide
models circumscription  words  minimal model reasoning stable
model reasoning indistinguishable canonical formulas 
proposition   work lee lin        shows embedding propositional circumscription logic programs stable model semantics  theorem
canonical formulas generalization result first order case  janhunen
oikarinen        showed another embedding propositional circumscription logic
programs  implemented system circ dlp    translation appears quite
different one lee lin 
zhang  zhang  ying  zhou        show embedding first order circumscription
first order stable model semantics  theorem   paper reproduced follows   
theorem     zhang et al         thm     let f formula negation normal form
let p finite list predicate constants  let f formula obtained f
replacing every p t  p t   let f c formula obtained f replacing
every p t  p t  choice p   p p list terms  circ f   p 
equivalent sm f f c   p  
comparison theorem    theorem applied characterize circumscription arbitrary formulas terms stable models first rewriting formulas
negation normal form  theorem   applicable canonical formulas only 
require transformation  characterization bidirectional sense
viewed characterization stable models terms circumscription 
zhang et al         introduce translation turns arbitrary first order formulas
logic programs  work limited finite structures only  hand 
translation f lp  definition    works almost universal formulas only 
limited finite structures 
situation calculus event calculus widely studied action formalisms 
several papers compare relate  e g   belleghem  denecker   
schreye        provetti        belleghem et al         kowalski   sadri        
prolog provides natural implementation basic action theories since definitional
axioms represented prolog rules according clarks theorem  reiter       
chapter     lloyd topor transformation used turn formulas prolog rules
similar translation f lp  difference former preserves completion
semantics latter preserves stable model semantics 
lin wang        describe language used represent syntactically
restricted form lins causal situation calculus  called clausal causal theories 
allow quantifiers  show translate language answer set programs
strong negation  answer sets used obtain fully instantiated
successor state axioms action precondition axioms  quite different
approach  computes propositional models full situation calculus theories
directly 
kautz selman        introduce linear encodings similar propositionalized version situation calculus  mccarthy   hayes         lin        introduces
    http   www tcs hut fi software circ dlp
    bit simpler original statement redundancy dropped 

   

filee   palla

action description language describes procedure compile action domain
language complete set successor state axioms  strips like
description extracted  soundness procedure shown respect
translation action domain descriptions lins causal action theories  however 
procedure based completion cannot handle recursive axioms unlike
approach 
denecker ternovska        present inductive variant situation calculus
represented id logic  denecker   ternovska       classical logic extended inductive definitions  id logic first order stable model semantics appear closely
related  precise relationship yet shown 

   conclusion
first order stable model semantics defined similar circumscription  paper
takes advantage definition identify class formulas minimal model
reasoning stable model reasoning coincide  uses idea reformulate situation calculus event calculus first order stable model semantics  together
translation turns almost universal sentence logic program  show
reasoning situation calculus event calculus reduced computing
answer sets  implemented system f lp  front end asp solvers allows us
compute circumscriptive action theories  mathematical tool sets system presented paper may useful relating circumscriptive theories
logic programs  also  advances asp solvers may improve computation
circumscriptive theories 

acknowledgments
grateful yuliya lierler  vladimir lifschitz  erik mueller  heng zhang  yan zhang 
anonymous referees useful comments discussions  authors
partially supported national science foundation grant iis         

appendix a  file dec language f lp
file dec encodes domain independent axioms discrete event calculus  file
used together event calculus domain descriptions shown section   
  file dec
 domain
 domain
 domain
 domain
 domain
 domain
 domain

fluent f  
fluent f   
fluent f   
event e  
time t  
time t   
time t   

time    maxstep  
   

fireformulating situation calculus event calculus

  dec  
stoppedin t  f t      happens e t    t  t   t t    terminates e f t  
  dec  
startedin t  f t      happens e t    t  t   t t    initiates e f t  
  dec  
holdsat f  t  t      happens e t     initiates e f  t     t     
trajectory f  t  f  t     stoppedin t  f  t  t     t  t   maxstep 
  dec  
holdsat f  t  t      happens e t     terminates e f  t       t   
antitrajectory f  t  f  t     startedin t  f  t  t    
t  t   maxstep 
  dec  
holdsat f t       holdsat f t    releasedat f t     
  e   happens e t    terminates e f t     t maxstep 
  dec  
holdsat f t       holdsat f t    releasedat f t     
  e   happens e t    initiates e f t     t maxstep 
  dec  
releasedat f t     releasedat f t      e   happens e t   
 initiates e f t    terminates e f t      t maxstep 
  dec  
releasedat f t       releasedat f t   
  e    happens e t    releases e f t     t maxstep 
  dec  
holdsat f t       happens e t    initiates e f t    t maxstep 
  dec   
holdsat f t       happens e t    terminates e f t    t maxstep 
  dec   
releasedat f t       happens e t    releases e f t    t maxstep 
  dec   
releasedat f t       happens e t   
 initiates e f t    terminates e f t     t maxstep 
 holdsat f t   
 releasedat f t   

   

filee   palla

problem
 max  step 

dec
reasoner

dec
reasoner  minisat 

f lp
lparse   cmodels

f lp
gringo   cmodels

f lp
gringo   clasp d 

f lp
clingo

busride
    











   s
     s       s 
a       r      

    s

kitchen
sink     

    s
     s      s 
a      c      

    s
     s       s 
a      c      

    s
     s       s 
a       r      

    s

thielscher
circuit     

   s
    s      s 
a      c      

   s
    s      s 
a      c      

    s
     s       s 
a      r      

   s

walking
turkey     





    s
     s       s 
a     r    

    s

falling w 
antitraj     

     s
      s      s 
a     c     

     s
      s       s 
a     c     

    s
     s       s 
a      r     

    s

falling w 
events     

    s
     s      s 
a      c      

    s
     s      s 
a      c      

    s
     s       s 
a       r      

    s

hotair
baloon     

    s
     s      s 
a     c     

    s
     s      s 
a     c     

   s
    s      s 
a      r     

    s

telephone 
    

   s
    s      s 
a      c      

   s
    s      s 
a      c      

    s
     s       s 
a     r    
c  
    s
     s       s 
a      r      
c     
    s
     s       s 
a       r      
c  
    s
     s      s 
a      r      
c  
    s
     s       s 
a     r    
c  
    s
     s       s 
a      r     
c  
    s
     s       s 
a      r      
c     
   s
    s      s 
a     r     
c    
    s
     s       s 
a      r      
c  

    s
     s       s 
a     r    

commuter
    

    s
     s       s 
a     r     
c  
     s
      s        s 
a       r        
c  
    s
     s       s 
a        r       
c  
    s
     s       s 
a      r      
c  
    s
     s       s 
a     r    
c  
    s
     s       s 
a      r     
c  
    s
     s       s 
a      r       
c     
    s
     s       s 
a     r     
c    
    s
     s       s 
a       r      
c  

    s
     s       s 
a      r      

    s

a  number atoms  c  number clauses  r  number ground rules
figure    comparing dec reasoner f lp answer set solvers

appendix b  comparing dec reasoner asp based event
calculus reasoner
compared performance dec reasoner  v      running relsat  v     
minisat  v      following 
f lp  v       lparse  v         cmodels  v       running minisat  v    
beta  
f lp  v       gringo  v        cmodels  v       running minisat  v     beta  
f lp  v       gringo  v         clasp  v         claspd  v        used instead
disjunctive programs  
f lp  v       clingo  v        clasp v         
f lp turns input theory languages lparse gringo  lparse
gringo turn result ground asp program  cmodels turns ground program
set clauses invokes sat solver compute answer sets  clasp
computes answer sets using techniques similar used sat solvers  clingo
system combines gringo clasp monolithic way 
first five examples figure   part benchmark problems work
shanahan               next four mueller          we increased timepoints
   

fireformulating situation calculus event calculus

problem
 max  step 
zootest 
    

f lp
gringo   cmodels
     s
     s        s 
a        r        
c        
zootest 
   h
      s
    
      s         s 
a         r        
c        
zootest 
   h
      s
    
      s         s 
a         r        
c        
a  number atoms  c  number clauses  r  number
dec
reasoner  minisat 
   h

f lp
gringo   clasp
     s
     s        s 
a        r        
      s
      s         s 
a        r        
      s
      s         s 
a        r        
ground rules

figure    zoo world dec reasoner asp

see notable differences   examples found f lp homepage 
experiments done pentium machine      ghz cpu  gb ram running
   bit linux  reported run times seconds obtained using linux
time command  user time   sys time   except dec reasoner recorded
times reported system  fair comparisons order avoid including
time spent dec reasoner producing output neat format  sometimes
takes non negligible time  dec reasoner  times parentheses  sat encoding time   sat solving time   others  times spent
grounder solver  cmodels time includes time spent converting ground
program generated lparse gringo set clauses  calling sat solver 
time spent f lp translating event calculus description answer set
program  retaining variables  negligible problems  denotes system
cannot solve example due limited expressivity  instance  busride includes
disjunctive event axioms  results disjunctive program cannot handled
clingo  similarly  dec reasoner cannot handle busride  disjunctive event axioms  
commuter  compound events  walking turkey  effect constraints   evident
experiments  main reason efficiency asp based approach efficient grounding mechanisms implemented asp grounders  though dec reasoner
cmodels call sat solver minisat  number atoms processed dec
reasoner general much smaller  dec reasoner adopts optimized
encoding method  that based predicate completion  avoids large number
ground instances atoms initiates e  f  t   terminates e  f  t   releases e  f  t 
 mueller        section       hand  several examples  number clauses
generated cmodels    means answer sets found without calling
sat solver  examples unique answer set coincides
well founded model  efficiently computed cmodels preprocessing step
calling sat solvers     benchmark examples shanahan              
   belong case lparse used grounding 
   

filee   palla

experiments figure    solving times negligible problems  experimented computationally hard problems  solving takes
time grounding  figure   shows runs medium size action domain  zoo
world  akman  erdogan  lee  lifschitz    turner         tests shown table
planning problems max  step length minimal plan  cut off time
  hours dec reasoner terminate within time problems  fact  entire time spent sat encoding sat solver never
called  hand  asp grounder gringo took seconds ground
domain and  unlike figure    solvers took much time grounder 
see  cmodels minisat performed better clasp two problems 
check time taken minisat encoding generated dec reasoner 
ran zootest  completion  dec reasoner terminated          seconds       
hours  

appendix c  proofs
c   review useful theorems
review theorems ferraris et al         ferraris et al        
used prove main results  fact  provide version splitting theorem
slightly general one given ferraris et al          order
facilitate proof efforts 
lemma   formula
u p   f    u  f  
logically valid 
theorem     ferraris et al         thm     first order formula f
disjoint lists p  q distinct predicate constants 
sm f   p  sm f choice q   p q 
logically valid 
let f first order formula  rule f implication occurs strictly positively
f   predicate dependency graph f  relative p  directed graph
members p vertices 
edge p q if  rule g h f  
p strictly positive occurrence h 
q positive occurrence g belong subformula g
negative p 
theorem     ferraris et al         splitting thm   let f   g first order sentences 
let p  q finite disjoint lists distinct predicate constants 
   

fireformulating situation calculus event calculus

 a  strongly connected component predicate dependency graph f g relative
p  q either subset p subset q 
 b  f negative q 
 c  g negative p

sm f g  p q  sm f   p  sm g  q 
logically valid 
theorem slightly general one ferraris et al        
notion dependency graph yields less edges one given ferraris et al 
instead
q positive occurrence g belong subformula g
negative p 
ferraris et al s definition
q positive occurrence g belong subformula
form k 
instance  according ferraris et al   dependency graph
  p q  r  p

    

relative p two edges  from p r  p p   dependency graph
according definition edges 
hand  generalization essential view following theorem 
theorem     ferraris et al         thm  double negations  let h sentence  f
subformula h  h sentence obtained h inserting front f  
occurrence f p negated h  sm h  p  equivalent sm h   p  
instance  sm       p  equivalent sm   p q  r  p  p   dependency
graph   p q  r  p relative p according definition ferraris et al 
identical dependency graph      relative p according definition 
next  say formula f clark normal form  relative list p intensional
predicates  conjunction sentences form
x g p x   

    

one intensional predicate p  x list distinct object variables  g
free variables x  completion  relative p  formula f
clark normal form obtained replacing conjunctive term     
x p x  g  
following theorem relates sm completion  say f tight p
predicate dependency graph f relative p acyclic 
theorem     ferraris et al         formula f clark normal form tight
p  formula sm f   p  equivalent completion f relative p 
   

filee   palla

c   proof proposition  
using theorem    theorem    
sm f   p  sm f   p pr  f    sm    p pr  f   
sm f   p pr  f    false p pr  f   
sm f choice pr  f   p   false p pr  f   
sm f choice pr  f   p  false p pr  f     

c   proof theorem  
following  f formula  p list distinct predicate constants p            pn   u
list distinct predicate variables u            un length p 
lemma    ferraris et al         lemma    formula
u p  f  u  f  
logically valid 
lemma   every occurrence every predicate constant p strictly positive f  
 u p   f  u  f  u  
logically valid 
proof  induction  show case f g h  cases
straightforward  consider
f  u     g  u  h  u    g h  
since every occurrence predicate constants p f strictly positive  g contains
predicate constants p  g  u  equivalent g u  
g  also  i h   h  u  h u  logically valid  therefore sufficient prove
assumption u p 
 g h u    g h   g h u  
logically valid  left right clear  assume  u p   g h u   g  get
h u   equivalent h  u  i h  lemma    conclude h 

proof theorem   immediate following lemma  proved
induction 
lemma   f canonical relative p  formula
 u p  f  f  u  f  u  
logically valid 
   

fireformulating situation calculus event calculus

proof 
f atomic formula  trivial 
f   g h  follows i h 
f   g h  assume  u p   g h   since g h canonical relative p 
every occurrence every predicate constant p strictly positive g h 
that  lemma    g  u  equivalent g u   h  u  equivalent h u  
f   g h  assume  u p   g h   sufficient show
 g  u  h  u    g u  h u   

    

since g h canonical relative p  every occurrence every predicate constant
p g strictly positive g  that  lemma    g  u  equivalent
g u  
case    g  lemma    g  u   claim follows since g  u  equivalent
g u  
case    h  i h  h  u  equivalent h u   claim follows since g  u 
equivalent g u  
f   xg  follows i h 
f   xg  since every occurrence every predicate constant p g strictly
positive g  claim follows lemma   

c   proof theorem  
proof   a   b  
 b   c  

follows immediately theorem   

note first equivalent sm      since

every strongly connected component dependency graph relative
 i  t  r  h  either belongs  i  t  r   h  
negative  h  
negative  i  t  r  
follows theorem     b  equivalent
sm    i  t  r  h  sm   ab            abn   sm    
similarly  applying theorem    repeatedly  show formula
equivalent  c  
 c   d  

proposition   



   

filee   palla

c   proof theorem  
since dcaused canonical relative caused   theorem     a 

 a   b  
equivalent


sm dcaused   caused   dposs drest
     

    

consequently  sufficient prove claim that  assumption sit s  
formula      equivalent sm dsit   sit  
first note assumption       equivalently rewritten

p p s    a  s p s  p do a  s    p   sit  
    
hand  sit s   sm dsit   sit  equivalent
sit s    a  s sit s  sit do a  s   

p p   sit  p s    a  s p s  p do a  s    a  s sit s  sit do a  s      
which  assumption sit s   equivalent
p p s    a  s p s  p do a  s     p   sit 



furthermore      
 b   c   since  s  contain poss  equivalence follows
equivalence completion stable model semantics 
 c   d   since dcaused contains strictly positive occurrence poss
dposs contains occurrence caused   every strongly connected component
predicate dependency graph dcaused dposs relative  caused   poss  either belongs
 caused   belongs  poss   theorem     follows  b  equivalent

sm dcaused dposs   caused   poss  drest
sm dsit   sit  

similarly  applying theorem    two times  get formula equivalent
 c  

c   proof theorem  
theory
deffect dprecond ds  duna dinertia dexogenous   
corresponding bat
dss dap ds  duna  
without loss generality  assume already equivalently rewritten
exactly one positive effect axiom exactly one negative effect axiom fluent r 
exactly one action precondition axiom action a 
   

fireformulating situation calculus event calculus

consider
sm  deffect dprecond ds  duna dinertia dexogenous    poss  holds  holds  
since duna negative intensional predicates  formula equivalent
sm deffect dprecond ds  dinertia dexogenous    p oss  holds  holds  duna  
    
since p oss occur
deffect ds  dinertia dexogenous   
since dprecond negative  holds  holds   theorem          equivalent
sm deffect ds  dinertia dexogenous    holds  holds 
sm dprecond   p oss  duna  

    

equivalent
sm deffect ds  dinertia dexogenous    holds  holds 
dap duna  
therefore statement theorem proven showing following 

   x s  
r  x  a  s  r  x  a  s  

    

  

    

sm ds  dexogenous  deffect dinertia   holds  holds 

    

every fluent r 
satisfies

iff i  satisfies
ds  dss  
dexogenous    follows      equivalent
sm ds
dexogenous  deffect dinertia   holds  holds  
 

    

ds
formula obtained ds  prepending occurrences holds 
 
assumption      
ds
dexogenous  deffect dinertia
 
 holds  atomic tight w r t  i     relationship completion sm
stated corollary     lee   meng                 iff satisfies
ds    and  fluent r 
    see section   work lee meng        definition 

   

filee   palla

holds r x   do a  s    
r  x  a  s   holds r x  s  holds r x   do a  s   

    


holds r x   do a  s  
r  x  a  s   holds r x   s  holds r x   do a  s         
x  a   lists of  object names corresponding sorts 
remains show that  assumption       satisfies           iff i  satisfies

holds r x   do a  s    
r  x  a  s   holds r x   s  r  x  a  s   

    

following use following facts 
  holds r x   s  iff i      holds r x   s  
f ground formula contain      f iff i     f  
left right  assume              
case    i     holds r x   do a  s    clearly     holds r x   do a  s    that 
      two subcases consider 
subcase        
r  x  a  s   clearly  i  satisfies lhs rhs      
subcase       holds r x   s         follows    
r  x  a  s  
 x 
a 
s  
clearly 
i 
satisfies

lhs

rhs      
consequently  i     

r
case    i      holds r x   do a  s    follows           
r  x  a  s  
 x 
a 
s  

since

  holds r x  
do a  s   
equivalent saying i       
r
      two subcases consider 
subcase      
r  x  a  s   clearly  i  satisfies neither lhs rhs      
subcase       holds r x   s   equivalent saying i     
holds r x   s   clearly  i  satisfies neither lhs rhs      
right left  assume i          
case       holds r x   do a  s    follows      i  satisfies rhs      
two subcases consider 
subcase    i      
r  x  a  s   clearly  satisfies lhs rhs      
      follows    
r  x  a  s   consequently  satisfies neither
lhs rhs      
subcase    i     holds r x   s 
r  x  a  s   clearly  satisfies lhs
rhs       since    
 x 
a 
s  

satisfies neither lhs rhs      
r
case      holds r x   do a  s    follows      i       
r  x  a  s  
i       holds r x   s 
 x 
a 
s   


latter 
consider

two
subcases 
r
   

fireformulating situation calculus event calculus

subcase    i      holds r x   s   clearly  satisfies neither lhs rhs
      satisfies lhs rhs      
subcase    i     
r  x  a  s   clearly  satisfies neither lhs rhs      
satisfies lhs rhs      

c   proof proposition  
lemma   let f formula  let p list distinct predicate constants  let g
subformula f let g  formula classically equivalent g  let f  
formula obtained f substituting g  g  occurrence g subformula
f negative p occurrence g  subformula f   negative
p 
sm f   p  sm f     p 
logically valid 
proof  let f formula obtained f prepending g  let  f    
formula obtained f   prepending g    theorem double
negations  theorem      following formulas logically valid 
sm f   p  sm f   p  
sm f     p  sm  f       p  
lemma    follows
 u p  g g       f    u    f        u  
logically valid  u list predicate variables corresponding p  consequently 
sm f   p  sm  f       p 
logically valid 



proof proposition    formula
sm f   xy g y  x  q x    p  q  

    

clearly  f   negative q xy g y  x  q x   negative p  let h
subformula f negative p contains occurrence yg y  x   consider
two cases 
case    occurrence yg y  x  h strictly positive  thus dependency
graph f   xy g y  x  q x   relative  p  q  incoming edges q 
case    occurrence yg y  x  h strictly positive  since h negative p  yg y  x  negative p well  dependency graph
f   xy g y  x  q x   relative  p  q  outgoing edges q 
   

filee   palla

therefore  every strongly connected component dependency graph belongs either
p  q   consequently  theorem          equivalent
sm f     p  sm xy g y  x  q x    q 

    

since yg y  x  negative q  formula xy g y  x  q x   tight  q   theorem          equivalent
sm f     p  x yg y  x  q x   

    

lemma    follows      equivalent
sm f   p  x yg y  x  q x   
consequently  claim follows 



c   proof theorem  
clear algorithm terminates yields quantifier free formula k 
prove sm f   p  sm xk  p q   x list  free  variables k 
let f formula obtained initial formula f prepending double
negations front every maximal strictly positive occurrence formulas form
yg x  y   since f almost universal relative p  occurrence subformula
f negative p  thus theorem double negations  theorem     
sm f   p  equivalent sm f   p   note f contains strictly positive occurrence
formulas form yg x  y  
iteration  let us assume formula iteration
h  hn  
h  transformed f previous iterations  hi  i     
formula form g x  y  pg  x  introduced step  b   initially h  f
n      let r  p  let ri pg hi  i       induction prove

 i  every positive occurrence formulas form yg x  y  hi strictly positive  subformula hi negative ri  
 ii  every negative occurrence formulas form yg x  y  hi subformula
hi negative ri  
prove step  a  step  c  applied turn hk hk   
sm x  h    r    sm xn hn   rn  

    

sm x   h     r    sm x n hn    rn   

    

equivalent
hj    hj j different k  xi  i    list free variables
hi   x i  i    list free variables hi   
   

fireformulating situation calculus event calculus

indeed  step  a  part prenex form conversion  preserves strong equivalence
 theorem     clear      equivalent      
step  c  applied turn            since yh x  y  subformula
hk negative rk   equivalence           follows lemma   
step  b  applied turn hk hk  introduces new conjunctive term
 
hn     formula         r            rn   equivalent
 
sm x   h     r    sm x n hn    rn   sm x n   hn  
  rn    

    

proposition   due condition  i  
let
  
h    hm

    

final quantifier free formula  h    transformed f   induction 
follows sm f   p   equivalent
  
sm x    h      r    sm x  m hm
  rm   

    

x  i    m  list free variables hi    
since every non strictly positive occurrence new predicate ri  i      hj     
j m  positive  incoming edge ri dependency graph      relative
r    r            rm   consequently  every strongly connected component dependency
graph belongs one ri  i     moreover  clear hi    i    negative
every rj j    i   in case h      recall occurrence rj j    
strictly positive since f   h    obtained  contains strictly positive
occurrence formulas form yg x  y    thus splitting theorem  theorem     
formula      equivalent
  
sm x    h    x  m hm
  r  rm   

    


c   proof theorem  
use notations introduced proof theorem    theorem    sm f   p 
 equivalent      and  theorem          equivalent
  
sm x    h    x  m hm
choice  pred   p   pred r  rm  

    

 r  p   pred set predicate constants signature   follows
proposition    cabalar et al              equivalent
   
sm x    h     x  m hm
choice  pred   p   pred r  rm   

    

hi    obtained hi   applying translation  cabalar et al        
section    turns quantifier free formula set rules  easy see f  
formula
   
x    h     x  m hm
choice  pred   p 

   

filee   palla

pred r  rm p pr  f           written
sm f     p pr  f      
equivalent
sm f   false p   pr  f       
proposition   



c    proof theorem  
assume
circ   initiates  terminates  releases  circ   happens 
circ   ab             ab n    
equivalent
sm   initiates  terminates  releases  sm   happens 
sm   ab             ab n  

    

theorem   
let def set definitions        let   formula obtained
applying step    theorem     follows formula      def equivalent

sm x g  p x    p  
g  described step    consequently       equivalent
sm   initiates  terminates 
v releases  sm   happens 
sm   ab             ab n       def sm x g  p x    p      

    

   conjunction axioms   ones obtained
definitional axioms      
applying theorem    repeatedly  follows      equivalent
v
sm         def x g  p x   
initiates  terminates  releases  happens  ab             ab n   p   

    

according syntax event calculus reviewed section     
every positive occurrence formula form yg y       contained
subformula negative
 initiates  terminates  releases  happens  ab             ab n   p  
negative occurrences formula form yg y       
consequently  statement theorem follows theorem   

   



fireformulating situation calculus event calculus

c    proof theorem  
since      almost universal relative  caused   poss  sit   result follows theorems     

c    proof theorem   
dexogenous    follows sm t   holds  holds  poss  equivalent
sm t   holds  holds  poss   obtained prepending
occurrences holds ds    definition uniform formula  reiter        
follows almost universal relative  holds  holds  poss   result follows
theorem   


references
akman  v   erdogan  s   lee  j   lifschitz  v     turner  h          representing zoo
world traffic world language causal calculator  artificial
intelligence                  
belleghem  k  v   denecker  m     schreye  d  d          combining situation calculus
event calculus  proceedings international conference logic programming
 iclp   pp       
belleghem  k  v   denecker  m     schreye  d  d          relation situation
calculus event calculus  journal logic programming                
besnard  p     cordier  m  o          explanatory diagnoses characterization
circumscription  annals mathematics artificial intelligence                 
cabalar  p     ferraris  p          propositional theories strongly equivalent logic
programs  theory practice logic programming                
cabalar  p   pearce  d     valverde  a          reducing propositional theories equilibrium logic logic programs  proceedings portuguese conference artificial
intelligence  epia   pp      
calimeri  f   cozza  s   ianni  g     leone  n          computable functions asp  theory
implementation  proceedings international conference logic programming  iclp   pp         
denecker  m     ternovska  e          inductive situation calculus  artificial intelligence 
                  
denecker  m     ternovska  e          logic nonmonotone inductive definitions  acm
transactions computational logic        
doherty  p   gustafsson  j   karlsson  l     kvarnstrom  j          tal  temporal action
logics language specification tutorial  linkoping electronic articles computer
information science issn                     http   www ep liu se ea cis 
          
   

filee   palla

dogandag  s   ferraris  p     lifschitz  v          almost definite causal theories  
proceedings international conference logic programming nonmonotonic
reasoning  lpnmr   pp       
erdem  e     lifschitz  v          tight logic programs  theory practice logic
programming            
fages  f          consistency clarks completion existence stable models  journal
methods logic computer science          
ferraris  p   lee  j     lifschitz  v          new perspective stable models  proceedings international joint conference artificial intelligence  ijcai   pp         
ferraris  p   lee  j     lifschitz  v          stable models circumscription  artificial
intelligence              
ferraris  p   lee  j   lifschitz  v     palla  r          symmetric splitting general
theory stable models  proceedings international joint conference artificial
intelligence  ijcai   pp         
gebser  m   schaub  t     thiele  s          gringo   new grounder answer set
programming  proceedings international conference logic programming
nonmonotonic reasoning  lpnmr   pp         
gelfond  m     lifschitz  v          stable model semantics logic programming 
kowalski  r     bowen  k   eds    proceedings international logic programming
conference symposium  pp            mit press 
gelfond  m     lifschitz  v          action languages  electronic transactions artificial
intelligence             http   www ep liu se ea cis           
giunchiglia  e   lee  j   lifschitz  v   mccain  n     turner  h          nonmonotonic
causal theories  artificial intelligence                 
heyting  a          die formalen regeln der intuitionistischen logik  sitzungsberichte
der preussischen akademie von wissenschaften  physikalisch mathematische klasse 
     
janhunen  t     oikarinen  e          capturing parallel circumscription disjunctive
logic programs  proc   th european conference logics artificial intelligence
 jelia      pp         
kautz  h     selman  b          planning satisfiability  proceedings european
conference artificial intelligence  ecai   pp         
kim  t  w   lee  j     palla  r          circumscriptive event calculus answer set programming  proceedings international joint conference artificial intelligence
 ijcai   pp         
kowalski  r     sergot  m          logic based calculus events  new generation
computing          
kowalski  r  a     sadri  f          reconciling event calculus situation
calculus  journal logic programming                 
   

fireformulating situation calculus event calculus

lee  j   lifschitz  v     palla  r          reductive semantics counting choice
answer set programming  proceedings aaai conference artificial
intelligence  aaai   pp         
lee  j     lin  f          loop formulas circumscription  artificial intelligence          
       
lee  j     meng  y          first order stable model semantics first order loop formulas 
journal artificial inteligence research  jair              
lee  j     palla  r          yet another proof strong equivalence propositional
theories logic programs  working notes workshop correspondence
equivalence nonmonotonic theories 
lee  j     palla  r          situation calculus answer set programming  proceedings
aaai conference artificial intelligence  aaai   pp         
lifschitz  v          circumscription  gabbay  d   hogger  c     robinson  j   eds   
handbook logic ai logic programming  vol     pp          oxford university press 
lifschitz  v          answer set programming   proceedings aaai conference artificial intelligence  pp            mit press 
lifschitz  v          datalog programs stable models  de moor  o   gottlob 
g   furche  t     sellers  a   eds    datalog reloaded  first international workshop 
datalog       oxford  uk  march              revised selected papers  springer 
lifschitz  v   pearce  d     valverde  a          strongly equivalent logic programs  acm
transactions computational logic            
lifschitz  v   tang  l  r     turner  h          nested expressions logic programs  annals
mathematics artificial intelligence             
lifschitz  v     turner  h          representing transition systems logic programs 
proceedings international conference logic programming nonmonotonic
reasoning  lpnmr   pp        
lin  f          embracing causality specifying indirect effects actions  proceedings international joint conference artificial intelligence  ijcai   pp      
     
lin  f          compiling causal theories successor state axioms strips like systems  journal artificial intelligence research             
lin  f     shoham  y          logic knowledge justified assumptions  artificial
intelligence             
lin  f     wang  k          causal theories logic programs  sometimes  
proceedings international conference logic programming nonmonotonic
reasoning  lpnmr   pp         
lin  f     zhou  y          answer set logic programming circumscription via logic
gk  artificial intelligence              
   

filee   palla

marek  v     truszczynski  m          stable models alternative logic programming
paradigm  logic programming paradigm     year perspective  pp         
springer verlag 
mccarthy  j          circumscriptiona form non monotonic reasoning  artificial intelligence                  
mccarthy  j          applications circumscription formalizing common sense knowledge  artificial intelligence                
mccarthy  j     hayes  p          philosophical problems standpoint
artificial intelligence  meltzer  b     michie  d   eds    machine intelligence  vol    
pp          edinburgh university press  edinburgh 
miller  r     shanahan  m          event calculus classical logic   alternative axiomatisations  electronic transactions artificial intelligence     a         
mueller  e          commonsense reasoning  morgan kaufmann 
mueller  e  t          event calculus reasoning satisfiability  journal logic
computation                 
niemela  i          logic programs stable model semantics constraint programming
paradigm  annals mathematics artificial intelligence             
pearce  d     valverde  a          first order nonmonotonic extension constructive
logic  studia logica             
provetti  a          hypothetical reasoning actions  situation calculus event
calculus  computational intelligence             
reiter  r          logic default reasoning  artificial intelligence            
reiter  r          frame problem situation calculus  simple solution  sometimes  completeness result goal regression  lifschitz  v   ed    artificial
intelligence mathematical theory computation  papers honor john mccarthy  pp          academic press 
reiter  r          knowledge action  logical foundations specifying implementing dynamical systems  mit press 
shanahan  m          circumscriptive calculus events  artif  intell                  
shanahan  m          solving frame problem  mathematical investigation
common sense law inertia  mit press 
shanahan  m          event calculus explained  artificial intelligence today  lncs
      pp          springer 
shanahan  m     witkowski  m          event calculus planning satisfiability 
journal logic computation                 
syrjanen  t          cardinality constraint programs   proceedings european conference logics artificial intelligence  jelia   pp         
zhang  h   zhang  y   ying  m     zhou  y          translating first order theories logic
programs  proceedings international joint conference artificial intelligence
 ijcai   pp           

   


