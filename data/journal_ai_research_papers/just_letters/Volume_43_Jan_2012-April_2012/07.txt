journal of artificial intelligence research                 

submitted        published      

completeness guarantees for incomplete ontology
reasoners  theory and practice
bernardo cuenca grau
boris motik
giorgos stoilos
ian horrocks

bernardo cuenca grau cs ox ac uk
boris motik cs ox ac uk
giorgos stoilos cs ox ac uk
ian horrocks cs ox ac uk

department of computer science  university of oxford
wolfson building  parks road  ox   qd  oxford

abstract
to achieve scalability of query answering  the developers of semantic web applications
are often forced to use incomplete owl   reasoners  which fail to derive all answers for
at least one query  ontology  and data set  the lack of completeness guarantees  however 
may be unacceptable for applications in areas such as health care and defence  where
missing answers can adversely aect the applications functionality  furthermore  even
if an application can tolerate some level of incompleteness  it is often advantageous to
estimate how many and what kind of answers are being lost 
in this paper  we present a novel logic based framework that allows one to check whether
a reasoner is complete for a given query q and ontology t that is  whether the reasoner
is guaranteed to compute all answers to q w r t  t and an arbitrary data set a  since
ontologies and typical queries are often fixed at application design time  our approach allows
application developers to check whether a reasoner known to be incomplete in general is
actually complete for the kinds of input relevant for the application 
we also present a technique that  given a query q  an ontology t   and reasoners
r  and r  that satisfy certain assumptions  can be used to determine whether  for each
data set a  reasoner r  computes more answers to q w r t  t and a than reasoner r   
this allows application developers to select the reasoner that provides the highest degree of
completeness for q and t that is compatible with the applications scalability requirements 
our results thus provide a theoretical and practical foundation for the design of future
ontology based information systems that maximise scalability while minimising or even
eliminating incompleteness of query answers 

   introduction
ecient management and querying of large amounts of data is a core problem for a growing
range of applications in fields as diverse as biology  sidhu  dillon  chang    sidhu        
medicine  golbreich  zhang    bodenreider         geography  goodwin         astronomy
 derriere  richard    preite martinez         agriculture  soergel  lauser  liang  fisseha 
keizer    katz         and defence  lacy  aviles  fraser  gerber  mulvehill    gaskill 
       in order to facilitate interoperability  such applications often use standard data
models and query languages  in particular  rdf  hayes        provides a standard model
for semistructured data  sparql  prudhommeaux   seaborne        is a standard query
language for rdf  and ontology languages such as owl  horrocks  patel schneider   
van harmelen        and owl    cuenca grau  horrocks  motik  parsia  patel schneider 
c
    
ai access foundation  all rights reserved 

ficuenca grau  motik  stoilos   horrocks

  sattler      b  can be used to describe background knowledge about the application
domain  thus  answering sparql queries over rdf data sets structured using an owl
ontology is a key service in ontology based information systems 
an important question in the design of such systems is the selection of an appropriate
reasoner  systems such as pellet  sirin  parsia  cuenca grau  kalyanpur    katz        
hermit  motik  shearer    horrocks      b   and racer  haarslev   moller        are
based on  hyper tableau algorithms that are provably completethat is  they are guaranteed to compute all answers for each query  ontology  and data set  completeness  however 
comes at the cost of scalability  as answering queries over owl   ontologies is of high computational complexity  glimm  horrocks  lutz    sattler        ortiz  calvanese    eiter 
      calvanese  de giacomo  lembo  lenzerini    rosati        lutz  toman    wolter 
       thus  complete systems often fail to meet the scalability demands of applications
that manage data sets consisting of hundreds of millions or even billions of assertions 
scalability of query answering can be ensured by restricting the expressive power of the
ontology language to the level that makes provably complete reasoning tractable  this has
led to the development of three profiles of owl    motik  cuenca grau  horrocks  wu 
fokoue    lutz      a   owl   el  owl   rl  and owl   ql  query answering in all
three profiles can be implemented in polynomial time w r t  the size of data  and even in
logarithmic space in the case of owl   ql   such appealing theoretical properties have
spurred the development of specialised reasoners such as quonto  acciarri  calvanese 
de giacomo  lembo  lenzerini  palmieri    rosati        that target specific profiles and
typically reject ontologies that fall outside the target profile 
a dierent solution to the scalability problem is adopted in reasoners such as oracles semantic data store  wu  eadon  das  chong  kolovski  annamalai    srinivasan 
       sesame  broekstra  kampman    van harmelen         jena  mcbride  brian        
owlim  kiryakov  ognyanov    manov         minerva  ma  yang  qiu  xie  pan    liu 
       dle jena  meditskos   bassiliades         and virtuoso  erling   mikhailov        
these reasoners accept all owl   ontologies as inputthat is  they never reject inputs 
furthermore  to the best of our knowledge  all of these systems are intended to be sound 
which means that all results of a query are indeed correct answers  finally  these reasoners
typically use scalable reasoning techniques  such as various  deductive  database algorithms 
as a consequence  the reasoners are incomplete  for each reasoner  at least one query  ontology  and data set exist for which the reasoner does not return all answers to the query 
some of these reasoners were actually designed to be complete for a particular profile of
owl    typically this is owl   rl due to its close connection with datalog   and they
can often additionally handle certain kinds of axiom that fall outside the target profile 
since incomplete reasoners can handle large data sets  they often provide the best practical choice for developers of ontology based applications  for example  owlim was used
for reasoning in the backend of the bbcs      world cup website  and oracles reasoner is
being used by the university of texas health science center to improve large scale public
health surveillance  in order to verify that the selected reasoner meets the applications
requirements  developers typically resort to empirical testing  in which they check the reasoners answers w r t  the application ontology and queries for representative data sets 
although primarily intended for testing performance  benchmark suites such as the lehigh
   

ficompleteness guarantees for incomplete ontology reasoners

university benchmark  lubm   guo  pan    heflin        and the university ontology
benchmark  uobm   ma et al         have been used for such completeness testing 
empirical completeness testing  however  has several important limitations  first  tests
are not generic  as data sets used for testing typically have a fixed and or repetitive structure  which can skew test results  second  test data is not exhaustive  as completeness is
tested only w r t  a limited number of data sets  finally  query answers may not be verifiable  since complete reasoners fail to handle large data sets  they often cannot compute
the control answers needed to check the answers produced by an incomplete reasoner  as
a consequence  empirical completeness tests provide only limited assurance of a reasoners
ability to meet the requirements of a given application 
in this paper  we present a radically dierent approach to solving these problems  we
observed that  given a query q and ontology t   even if a reasoner is not complete for the
language of t   the reasoner may be able to correctly answer q w r t  t and an arbitrary data
set a  in such a case  we say that the reasoner is  q  t   complete  given that ontology based
applications often use a limited set of queries and a fixed ontology  or at least the queries and
the ontology evolve relatively slowly   a scalable reasoner that is generally incomplete  but
is  q  t   complete for all relevant combinations of q and t   may provide a solid foundation
for ontology based applications  allowing them to enjoy the best of both worlds  regardless
of the data set encountered  such applications will enjoy completeness guarantees normally
available only with computationally intensive complete reasoners  while at the same time
exhibiting scalability levels normally available only by sacrificing completeness  to develop
an approach for testing the  q  t   completeness of a given reasoner  we proceed as follows 
in section   we develop a logic based framework that allows us to establish formally
provable  q  t   completeness guarantees  the following two notions are central to our
framework  first  in order to abstract away from the implementation details of concrete
reasoners  we introduce the notion of an abstract reasoner an idealised reasoner that captures the intended behaviour and salient features  such as soundness and monotonicity  of
a class of concrete reasoners  second  we introduce the notion of a test suitea finite set
of data sets and queries  intuitively  given q and t   our goal is to construct a test suite
such that  if a reasoner correctly answers all queries on all data sets in the test suite  then
the reasoner is guaranteed to be  q  t   complete 
unfortunately  as we show in section      for certain q and t   it is impossible to
construct a finite test suite that will provide the aforementioned completeness guarantees 
therefore  we investigate assumptions on q  t   and the reasoner under which testing  q  t  completeness becomes practically feasible 
in section     we consider the case where q and t can be rewritten into a union of
conjunctive queries rthat is  when answering q w r t t and a data set a is equivalent
to evaluating r over a  for t expressed in owl   ql  a rewriting r can be computed
using the algorithm by calvanese et al          additionally  the algorithm by perez urbina 
motik  and horrocks        can sometimes compute r even if t is syntactically outside
this fragment  we show that such r can be converted into a test suite er that can be used
for testing the  q  t   completeness of any reasoner that satisfies some basic assumptions 
roughly speaking  the reasoners answers should not depend on the names of the individuals
occurring in a data set  and its answers must increase monotonically when new data is added 
the size of each test in er is polynomial in the size of the longest conjunctive query in r 
   

ficuenca grau  motik  stoilos   horrocks

so it should be feasible to compute correct answers to the tests using a complete reasoner 
the number of tests in er   however  can be exponential in the size of r  which may lead to
problems in practice  as a remedy  in section     we strengthen our assumptions and require
the reasoner not to drop answers when merging individualsthat is  if the reasoner returns
a given inputs q  t   and a  then for each  possibly noninjective  mapping  the reasoner
returns  a  given inputs q  t   and  a and we show that  q  t   completeness of such
reasoners can be checked using a test suite ir obtained from r by a linear transformation 
that q and t should be rewritable into a union of conjunctive queries eectively prevents t from stating recursive axioms  to overcome this restriction  in section     we consider first order reproducible reasonersthat is  reasoners whose behaviour on q  t   and a
can be seen as computing certain answers of q w r t  some  possibly unknown  first order
theory ft and a  since ft can be a datalog program  most reasoners based on deductive
databases are first order reproducible  in addition  we require q and t to be rewritable
into datalog  an extension of datalog that allows for existential quantifiers and disjunction in rule heads  in many cases  t can be transformed into a datalog  program
using equivalence preserving transformations  furthermore  the algorithm by perez urbina
et al         can in many cases produce a plain datalog rewriting  we then show how to
transform a datalog  rewriting of q and t into a test suite that can be used to test
 q  t   completeness of first order reproducible reasoners 
in section   we turn our attention to comparing incomplete reasoners  roughly speaking  given q and t   reasoner r  is more complete than reasoner r  if  for each data set a 
reasoner r  computes all the answers to q w r t  t and a that are computed by r    we
show that comparing incomplete reasoners is infeasible in general  therefore  we introduce
the notion of compact reasonersthat is  reasoners whose behaviour on q  t   and a can be
seen as first selecting some subset t  of t and then using a complete reasoner to evaluate
q w r t  t  and a  thus  the class of compact reasoners captures all reasoners that reduce
the input ontology t to a set of axioms that match certain parameters  such as fitting into
language fragments  for q and t that can be rewritten into a union of conjunctive queries
r  we show that the test suite ir can be used to compare compact reasoners 
we have implemented our approaches for computing test suites  and have tested completeness of several well known reasoners  see section     these show that test suites can
be eciently computed for realistic ontologies  furthermore  we were able to guarantee
 q  t   completeness of the evaluated reasoners for many queries and ontologies  finally 
when no  q  t   completeness guarantee could be provided  we were able to compute a
counter examplea small data set for which the reasoner at hand was incomplete 

   preliminaries
in this section we briefly introduce description logics  dls   baader  mcguinness  nardi   
patel schneider       a family of knowledge representation formalisms which underpin
the owl and owl   ontology languages  we describe description logics in the wider
framework of first order logic since many of our results hold for arbitrary first order theories 
we then introduce the datalog  and datalog languages  and we define the syntax and
semantics of unions of conjunctive queries  ucqs   finally  we introduce the notions of
ucq  datalog  and datalog  rewritings  which underpin many of our techniques 
   

ficompleteness guarantees for incomplete ontology reasoners

    description logics and first order logic
most of the results in this paper hold for arbitrary first order theories  rather than description logics  our work  however  is motivated by description logics and ontologies  so we use
the dl terminology throughout the paper  for example  we often talk about tboxes and
aboxes instead of first order theories and sets of facts 
all definitions in this paper are implicitly parameterised by a signature    p   i  
which consists of countably infinite disjoint sets of predicates p and individuals  commonly
called constants in first order logic  i   each predicate is associated with a nonnegative
arity  predicates of zero arity are commonly called propositional symbols  the notions of
variables  terms  atoms  first order formulae  and sentences are defined as usual  fitting 
       we do not consider function symbols in this article and we assume all formulae to
be function free  the atom that is false  true  in all interpretations is written      an
atom is a fact if it does not contain variables  we use the standard first order notions of
satisfiability  unsatisfiability  and entailment  written     of sets of first order sentences 
we assume that p contains the special equality and inequality predicates  and  
respectively  atoms of the form  t    t    and  t    t    are commonly written as t   t  and
t   t    respectively  we make a technical assumption that  and  are distinct predicates
rather than  as it is common in first order logic  that t   t  is an abbreviation for  t   t    
furthermore  we assume that each theory that uses  and  axiomatises their semantics as
follows  where     is instantiated for each predicate p of arity n and each i with    i  n 
x  y  x  y  x  y   

   

x  y  x  y  y  x 

   

x            xi           xn   yi   p  x            xi           xn    xi  yi  p  x            yi           xn   

   

x  x  x 

   

x  y  z  x  y  y  z  x  z 

   

note that  according to this assumption  each set of facts is satisfiable  for example  the
set of atoms  a  b  a  b  is satisfiable since both a  b and a  b are positive variable free
atoms that are semantically independent from each other  moreover  axiom     is required
to obtain the expected contradiction 
an individual renaming  often just renaming  is a partial function    i  i that
maps individuals to individuals  the domain and the range of  are written dom   and
rng    unless otherwise noted  we assume that dom   is finite  for  an object containing
individuals  such as a formula  a set of formulae  or a tuple of individuals   ind   is the
set of individuals occurring in   and    is obtained from  by simultaneously replacing
each individual a  ind    dom   with  a  
we use the notion of substitutions from first order logic  that is  a substitution  is a
mapping of variables to terms  for  a term  an atom  or a formula  the result of applying
a substitution  to  is written as    
a tbox t a is a finite set of first order sentences that contains axioms        whenever
 and or  are used  an abox a is a finite set of facts  note that this definition allows
for atoms of the form a  b and a  b in aboxes  furthermore  since aboxes can contain
only positive atoms  each abox  when considered without a tbox  is satisfiable 
   

ficuenca grau  motik  stoilos   horrocks

dl name
el
fl
alc
  h 
  r 
  s 
  i 
  q 
  o 

roles
r
r
r

concepts
  a  c   c    r c
  a  c   c    r c
    a  c  c   c    c   c    r c  r c
r self

tbox axioms
c   c 
c   c 
c   c 
r   r 
rs t
trans r 

r
 ns c   ns c
 a 

table    syntax of standard description logics  typical extensions of el  alc  and fl
are named by appending calligraphic letters  h  r  s  i  q  and or o  
a description logic dl is a  usually infinite  recursive set of tboxes satisfying the
following conditions 
 for each t  dl and each renaming   we have  t    dl  and
 for each t  dl and each t   t   we have t   dl 

if t  dl  we say that t is a dl tbox  finally  fol is the largest description logic that
contains all finite sets of first order sentences over the signature in question 
we next present an overview of the dls commonly considered in the literature  typically  the predicates in dl signatures are required to be unary or binary  the former are
commonly called atomic concepts and the latter are commonly called atomic roles  dls
typically use a specialised syntax  summarised in table    that provides a set of constructors
for constructing complex concepts and roles from simpler ones  as well as dierent kinds
of axioms  using the translation from table    concepts can be translated into first order
formulae with one free variable  roles can be translated into first order formulae with two
free variables  and axioms can be translated into first order sentences  note that the translation uses counting quantifiers n and n   which can be expressed by using ordinary
quantifiers and equality by well known transformations 
in the rest of this paper  we commonly write tboxes and aboxes in dl syntax  however 
to simplify the presentation  we identify t and a written in dl syntax with  t   and  a  
    datalog 
we next introduce a fragment of first order logic called datalog  as an extension of
datalog by cal  gottlob  lukasiewicz  marnette  and pieris         a datalog  rule
 or commonly just a rule  r is a formula of the form      where each bj is an atom dierent
from  whose free variables are contained in x  and
 m     and    x  y        or

 m    and  for each    i  m  formula i  x  yi   is a conjunction of atoms dierent
from  whose free variables are contained in x  yi  
   

ficompleteness guarantees for incomplete ontology reasoners

mapping dl roles into first order logic
 r  x  y    r x  y 
 r   x  y    r y  x 
mapping dl concepts into first order logic
   x  y    
   x  y    
 a  x  y    a x 
  a   x  y    x  a
 c  x  y     c  x  y 
 c  d  x  y     c  x  y    d  x  y 
 c  d  x  y     c  x  y    d  x  y 
 r c  x  y    y   r  x  y    c  y  x  
 r self  x  y    r x  x 
 r c  x  y    y   r  x  y    c  y  x  
  ns c  x  y    n y   s  x  y    c  y  x  
  ns c  x  y    n y   s  x  y    c  y  x  
mapping tbox axioms into first order logic
 c  d    x   c  x  y    d  x  y  
 r  s    x  y   r  x  y    s  x  y  
 trans r     x  y  z   r  x  y    r  y  z    r  x  z  
 r  s  t     x  y  z   r  x  y    s  y  z    t  x  z  
mapping abox axioms into first order logic
 c a      c  a  y 
 r a  b     r a  b 
 a  b    a  b
 a  b    a  b
table    translation of dl syntax into first order logic

x  b          bn 

m


i  

yi  i  x  yi   

   

a rule is safe if each variable in x also occurs in some bj   unless otherwise noted  all rules
are assumed to be safe  for brevity  the outer quantifier x is commonly left implicit  the
body of r 
is the set of atoms body r     b            bn    and the head of r is the formula
head r    m
yi  i  x  yi    a datalog  program is a finite set of safe datalog  rules 
i   
note that  since  and  are treated as ordinary predicates  they can occur in rules  provided
that their semantics is appropriately axiomatised  furthermore  note that the latter can be
achieved using datalog  rules 
let r be a datalog  rule  then  r is a datalog rule if head r  contains no existential
quantifier  also  r is a datalog rule if m      finally  r is a datalog rule if m     and the
head of r is a single atom without existential quantifiers  ceri  gottlob    tanca        
in several places in this paper  we check whether a set of first order sentences entails a
datalog  rule  which can be accomplished using the following simple result 
   

ficuenca grau  motik  stoilos   horrocks

proposition      let f be a set of first order sentences  and let r be a datalog  rule
of the form      then  for each substitution  mapping the free variables of r to distinct
individuals not occurring in f or r  we have f    r if and only if
f    b              bn      

m


i  

yi  i   x   yi  

proof  let x be the tuple of free variables in r and let  be an arbitrary substitution
mapping the variables in x to distinct individuals not occurring in f or r  the claim of
this proposition follows from the following equivalences 
f    x  b          bn 

m


yi  i  x  yi   

i  
m


f    x b          bn 
f   x  b          bn  

f    b             bn    
f    b              bn    

m


i

yi  i  x  yi     is unsatisfiable

i  skolem  of x 

m


i  

yi  i   x   yi    is unsatisfiable

yi  i   x   yi    is unsatisfiable

i  
m


f    b              bn      

yi  i  x  yi     is unsatisfiable

i  
m


i  

i  

i

i
i

yi  i   x   yi   

    queries
in order to achieve a high degree of generality  we define a query q as a finite set of firstorder sentences containing a distinct query predicate q  intuitively  the query predicate q
determines the answers of q  in order to simplify the notation  we typically assume that the
association between q and the query predicate is implicit  e g   we may require each query
to contain precisely one such predicate   and we assume that no query predicate occurs in
a tbox or an abox 
a tuple of constants a is a certain answer to a query q with query predicate q with
respect to a tbox t and an abox a if the arity of a agrees with the arity of q and
t  a  q    q a   the set of all certain answers of q w r t  t and a is denoted as
cert q  t   a   if the query predicate of q is propositional  i e   if the query is boolean  
then cert q  t   a  is either empty or it contains the tuple of zero length  in such cases  we
commonly write cert q  t   a    f and cert q  t   a    t  respectively 
we use  as the special boolean query that checks a first order theory for unsatisfiability 
thus  cert   t   a    t if and only if t  a is unsatisfiable 
a query q with a query predicate q is a union of conjunctive queries  ucq  if it is a
datalog program in which each rule contains q in the head but not in the body  a ucq q
is a conjunctive query  cq  if it contains exactly one rule 
   

ficompleteness guarantees for incomplete ontology reasoners

a union of conjunctive queries q is ground if  for each rule r  q  each variable occurring in the body of r also occurs in the head of r  roughly speaking  when computing
cert q  t   a  for a ground q  all variables in q can be matched only to the individuals in t
and a  but not to unnamed objects whose existence is guaranteed by existential quantifiers 
many state of the art reasoners used in practice support only ground ucqs  note that
q    a x   q x   r x  y   q x  y   is not a ground ucq  in fact  q is not even a valid
first order theory since predicate q does not have unique arity  to obtain a ucq  one can
pad the head of the first rulethat is  one can introduce a special fresh individual null
and rewrite the rules as q    a x   q x  null    r x  y   q x  y   
by the properties of first order logic entailment  cert satisfies the following properties
for each query q  all tboxes t and t    and all aboxes a and a  
   monotonicity  t  t  and a  a imply
 cert   t   a    t implies cert   t    a     t  and
 cert q  t   a   cert q  t    a   

   invariance under renamings  for each renaming  and each tuple of individuals a 
 cert   t   a    t implies cert    t     a     t  and

 a  cert q  t   a  implies  a   cert  q    t     a   
    rewritings
intuitively  a rewriting of a query q w r t  a tbox t is another query that captures all the
information from t that is relevant for answering q over an arbitrary abox a  calvanese
et al         artale  calvanese  kontchakov    zakharyaschev        perez urbina et al  
       in practice  ucqs  calvanese et al         and datalog  perez urbina et al        
are the most widely used target languages for query rewriting  for the sake of generality 
however  in this paper we use a notion of a datalog  rewriting 
definition      let q be a query and let t be a tbox  a datalog  rewriting  or simply
a rewriting  of q w r t  t is a triple r   rd   r   rq  where
 rd is a datalog  program not containing  or q such that t    rd  
 r is a datalog program such that head r     for each r  r   and
 rq is a ucq whose query predicate is q 
such that the following properties hold for each abox a 
 cert   t   a    cert   rd  r   a   and
 if cert   t   a    f  then cert q  t   a    cert rq   rd  r   a  
rewriting r is a datalog rewriting if rd is a datalog program  furthermore  rewriting r
is a ucq rewriting if rd     such an r is usually written as just r   r   rq  
   

ficuenca grau  motik  stoilos   horrocks

note that definition     requires t    rd to hold  which precludes rewritings consisting
of axioms that are unsound w r t  t   for example  let q    a x   q x   and t    
then  rd    b x   a x   does not satisfy the definition of a rewriting since formula
b x   a x  is not a logical consequence of t  
for a wide range of t and q  a datalog  rewriting of q w r t  t can be computed using
straightforward equivalence preserving transformations of t   this can be further optimised
by eliminating axioms from t that are irrelevant to answering q  furthermore  several
algorithms for computing ucq and datalog rewritings have been proposed in the literature 
for example  calvanese et al         showed how to compute a ucq rewriting in cases when
t is expressed in a logic from the dl lite family  and this approach can be extended to the
owl   ql profile of owl    motik et al       a   similarly  perez urbina et al        
proposed an algorithm for computing the simplest possible datalog rewriting when t is
expressed in the description logic elhio 
rewritings produced by known algorithms often contain predicates that do not occur
in t and q  such predicates are sometimes called fresh  for example  many rewriting
algorithms normalise tboxes by replacing complex concepts with fresh atomic concepts  a
rewriting r   rd   r   rq  obtained in such a way is unlikely to satisfy the requirement
that t    rd   however  predicates occurring in r but not in t can often be eliminated
via unfolding  for example  let q    a x   q x   and t    r s b  a   and assume
that a rewriting algorithm produces
rd    s x  y   b x   c x   r x  y   c y   a x   
to satisfy definition      predicate c can be unfolded and rd replaced with
rd    r x  y   s y  z   b z   a x   
for which t    rd holds  unfolding  however  may not always be possible  e g   this might
be the case when fresh predicates occur in recursive axioms   which may limit the applicability of some of the results presented in this paper 

   completeness guarantees for incomplete reasoners
in this section  we introduce the formal framework that will allow us to establish completeness guarantees for incomplete reasoners  our results are not restricted to any particular
description logic  but are applicable to all tboxes that satisfy the following criterion 
definition      a tbox t is admissible if a description logic dl exists such that t is
a dl tbox  and both checking tbox satisfiability and answering boolean ucqs w r t  an
arbitrary abox are decidable for dl 
    concrete and abstract reasoners
concrete reasoners are complex software systems that dier greatly in the functionality
and the supported interfaces  and that use a range of dierent implementation techniques 
to make our results general and independent from specific implementation techniques  we
introduce the notion of an abstract reasoner  an abstract reasoner can be thought of as an
   

ficompleteness guarantees for incomplete ontology reasoners

idealised reasoner that captures the intended behaviour and salient features of a class of
concrete reasoners  a concrete reasoner belonging to this class may use arbitrary algorithms 
as long as their observable behaviour mirrors that of the abstract reasoner 
definition      an abstract reasoner ans for a description logic dl is a computable function that takes as input an arbitrary dl tbox t   an arbitrary abox a  and either the
special unsatisfiability query  or an arbitrary ucq q  the return value of ans is defined
as follows 
 ans   t   a  is either t or f 
 if ans   t   a    t  then ans q  t   a  is of no interest and can be arbitrary  and
 if ans   t   a    f  then ans q  t   a  is a finite set of tuples of individuals  where the
arity of each tuple is equal to the arity the query predicate of q 
an abstract reasoner ans for dl is said to be applicable to a tbox t if t is a dl tbox 
intuitively  ans   t   a  asks the abstract reasoner to check whether t  a is unsatisfiable  and ans q  t   a  asks the abstract reasoner to evaluate q w r t  t  a  if t  a
is unsatisfiable  then each tuple of constants of the same arity as the query predicate q
is an answer to q on t  a  therefore  the result of ans q  t   a  is of interest only if
ans   t   a    fthat is  if ans identifies t  a as satisfiable 
example      consider the abstract reasoners rdf  rdfs  rl  and classify which  given as
input a ucq q  a tbox t   and an abox a  compute the answer to q w r t  t and a as
described next 
abstract reasoner rdf ignores t and evaluates q w r t  a  more precisely  rdf   t   a    f
and rdf q  t   a    cert q    a   thus  rdf captures the behaviour of rdf reasoners 
abstract reasoner rdfs evaluates q w r t  a and a datalog program prdfs that is constructed by translating each rdfs axiom  in t into an equivalent datalog rule  more
precisely  rdfs   t   a    f and rdfs q  t   a    cert q  prdfs   a   thus  rdfs captures the
behaviour of rdfs reasoners such as sesame 
abstract reasoner rl evaluates q w r t  a and a datalog program prl that is constructed
by translating each owl   rl axiom  in t into an equivalent datalog rule  more precisely 
rl   t   a    cert   prl   a  and rl q  t   a    cert q  prl   a   thus  rl captures the behaviour
of owl   rl reasoners such as jena and oracles semantic data store 
abstract reasoner classify first classifies t using a complete owl   dl reasoner  that is 
it computes a tbox t  containing each subclass axiom a  b such that t    a  b  and
a and b are atomic concepts occurring in t   the abstract reasoner then proceeds as rl 
but considers t  t  instead of t   more precisely  classify   t   a    rl   t  t    ain   and
classify q  t   a    rl q  t  t    a   in this way  classify captures the behaviour of owl  
rl reasoners such as minerva and dle jena that try to be more complete by materialising
certain consequences of t  


an ideal abstract reasoner is one such that  for an arbitrary ucq q  tbox t   and
abox a  we have ans   t   a    cert   t   a   and ans q  t   a    cert q  t   a  whenever
ans   t   a    f  we next introduce and discuss several properties of abstract reasoners
   

ficuenca grau  motik  stoilos   horrocks

that are likely to aect how close they come to this ideal and that may also be relevant to
the applicability of our results 
the following notion of soundness describes abstract reasoners that return only answers
that logically follow from q  t   and a 
definition      an abstract reasoner ans for dl is sound if the following conditions hold
for each ucq q  dl tbox t   and abox a 
 ans   t   a    t implies cert   t   a    t  and
 ans   t   a    f implies ans q  t   a   cert q  t   a  
the following notion of monotonicity describes abstract reasoners for which extending
the input tbox and abox never leads to dropping answers  we also consider a weaker
notion of  q  t   monotonicity  in which the input query q and tbox t are fixed 
definition      an abstract reasoner ans for dl is monotonic if the following conditions
hold for each ucq q  all dl tboxes t and t    and all aboxes a and a such that t  t 
and a  a  
 ans   t   a    t implies ans   t    a     t  and
 ans   t   a    f and ans   t    a     f imply ans q  t   a   ans q  t    a   
given a ucq q and a dl tbox t   ans is  q  t   monotonic if the following conditions
hold for all aboxes a and a such that a  a  
 ans   t   a    t implies ans   t   a     t  and
 ans   t   a    f and ans   t   a     f imply ans q  t   a   ans q  t   a   
as discussed in section      the logical consequences of a first order theory are invariant
under renaming and merging of individuals  to define analogous properties for abstract
reasoners  we first introduce the notions of t  stable and  q  t   stable renamingsthat is 
renamings that leave all individuals occurring in t  respectively  in q and t   unchanged 
definition      let q be a query  let t be a tbox  and let  be a renaming  then   is t stable if  a    a for each individual a  dom    ind t    furthermore   is  q  t   stable
if  a    a for each individual a  dom    ind q  t   
the following notion of weak faithfulness describes abstract reasoners whose answers
are invariant under replacement of individuals with fresh individuals  furthermore  weak
 q  t   faithfulness relaxes this property to the case when q and t are fixed 
definition      an abstract reasoner ans for dl is weakly faithful if the following conditions hold for each ucq q  dl tbox t   abox a  injective renaming   and tuple a 
 ans   t   a    t and ind t  a   dom   imply ans    t     a     t  and
 ans   t   a    f  ind q  t  a   dom    and a  ans q  t   a  imply
ans    t     a     f and  a   ans  q    t     a   
   

ficompleteness guarantees for incomplete ontology reasoners

given a ucq q and a dl tbox t   ans is weakly  q  t   faithful if the following conditions
hold for each abox a  injective renaming   and tuple a 
 ans   t   a    t  ind t  a   dom    and  is t  stable imply ans   t    a     t 
and
 ans   t   a    f  ind q  t  a   dom     is  q  t   stable  and a  ans q  t   a 
imply ans   t    a     f and  a   ans q  t    a   
the following notion of strong faithfulness describes abstract reasoners whose answers
are invariant under merging of individuals  furthermore  strong  q  t   faithfulness relaxes
this property to the case when q and t are fixed 
definition      an abstract reasoner ans for dl is strongly faithful if the following conditions hold for each ucq q  dl tbox t   abox a  renaming   and tuple a 
 ans   t   a    t implies ans    t     a     t  and
 ans   t   a    f  a  ans q  t   a   and ans    t     a     f imply
 a   ans  q    t     a   
given a ucq q and a dl tbox t   ans is strongly  q  t   faithful if the following conditions hold for each abox a  renaming   and tuple a 
 ans   t   a    t and  is t  stable imply ans   t    a     t  and
 ans   t   a    f   is  q  t   stable  a  ans q  t   a   and ans   t    a     f imply
 a   ans q  t    a   
the results that we present in the rest of this paper are applicable only to abstract
reasoners that satisfy various combinations of these properties  as a minimum  we require
 q  t   monotonicity and weak  q  t   faithfulness  the abstract reasoners described in example     all satisfy these properties  testing if this is the case for concrete reasoners may 
however  be infeasible in practice  indeed  we are not aware of a technique that would allow one to check whether a concrete reasoner satisfies the required properties  we believe 
however  that all concrete reasoners commonly used in practice are intended to be sound 
monotonic  and at least weakly faithful  and that strong faithfulness is a reasonable assumption in most cases  if a concrete reasoner fails to satisfy some of these properties on
certain inputs  this is likely to be due to implementation bugs  thus  any consequent failure
of completeness can be seen as a bug  and detecting such situations should be viewed as a
part of a more general problem of testing software systems 
we next present several examples of abstract reasoners that do not satisfy some of the
mentioned properties 
example      consider an abstract reasoner that behaves as rdf whenever the number
of assertions in the input abox is smaller than a certain threshold  and that returns the
empty set of answers for larger aboxes  intuitively  such an abstract reasoner characterises
a concrete rdf reasoner that processes inputs only up to a certain size  such a reasoner is
not  q  t   monotonic for an arbitrary q and t  

   

ficuenca grau  motik  stoilos   horrocks

example       consider an abstract reasoner that behaves like rdf  but that  for trust
reasons  removes from each input abox all assertions whose individuals are blacklisted
 e g   they come from an untrusted source   such an abstract reasoner is not weakly  q  t  faithful for an arbitrary q and t  

example      suggests that  for an abstract reasoner to be weakly faithful  it should not
make decisions that depend on specific names of individuals 
example       consider an abstract reasoner rl  that  given as input a ucq q  a tbox
t   and an abox a  proceeds as follows  first  rl  computes the abox a obtained by
evaluating the datalog program prl from example     over a  second  rl  computes the
query q  obtained from q by adding to the body of each rule r  q an inequality x  y
for all pairs of distinct variables x and y occurring in r  third  rl  evaluates q  over a
by considering a as a databasethat is  as a finite first order interpretation in which each
individual is mapped to itself  and thus dierent individuals are distinct   thus  rl  characterises concrete reasoners that evaluate queries by matching dierent variables to dierent
individuals  abstract reasoner rl  is sound  monotonic  and weakly faithful  but it is not
strongly faithful  for example  given query q    r x  y   q x    abox a    r a  b   
and renaming     a  c  b  c   we have rl   q    a     a   but rl   q     a       
example      suggests that  for an abstract reasoner to be strongly faithful  it should
allow distinct variables in queries and axioms to be mapped to the same individuals 
we next identify classes of abstract reasoners that we use throughout this paper  note
that soundness is not required  which contributes to the generality of our results 
definition       given a ucq q and a tbox t   cwq t  csq t   is the class of all  q  t  monotonic and weakly  strongly   q  t   faithful abstract reasoners applicable to t  
finally  note that all the abstract reasoners introduced in example     are sound  monotonic  and strongly  and therefore also weakly  faithful  consequently  all concrete reasoners
based on reasoning techniques outlined in example     can be considered sound  monotonic 
and strongly faithful  modulo implementation bugs 
    completeness of abstract reasoners
we next define the central notion of abstract reasoner completeness for a given query q
and tbox t   intuitively  a  q  t   complete abstract reasoner is indistinguishable from a
complete abstract reasoner when applied to q  t   and an arbitrary abox a 
definition       let dl be a description logic  and let ans be an abstract reasoner for dl 
then  ans is  q  t   complete for a ucq q and a dl tbox t if the following conditions
hold for each abox a 
 if cert   t   a    t  then ans   t   a    t 
 if cert   t   a    f and ans   t   a    f  then cert q  t   a   ans q  t   a  
finally  ans is complete if it is  q  t   complete for each ucq q and each dl tbox t  
   

ficompleteness guarantees for incomplete ontology reasoners

example       consider the el tbox t consisting of the following axioms  the translation
of the axioms into first order logic is shown after the  symbol 
takesco mathco  st



mathst  takesco mathco



calcco  mathco



st  prof  



x  y  takesco x  y   mathco y   st x  
x  calcco x   mathco x  

   
   

x  mathst x   y  takesco x  y   mathco y       
x  st x   prof x    

    

axiom     states that everyone taking a maths course is a student  axiom     states that
each calculus course is also a maths course  axiom     states that each maths student takes
some maths course  and axiom      states that no person can be both a student and a
professor  axiom     is an rdfs axiom  and all other axioms in t apart from     are owl
  rl axioms  consider also query      that retrieves students taking a maths course 
q    st x   takesco x  y   mathco y   q x  

    

none of the abstract reasoners rdf  rdfs  rl  and classify from example     are complete in
general for answering ucqs over el tboxes  furthermore  for q and t from the previous
paragraph  abstract reasoners rdf  rdfs  and rl are not  q  t   complete  as all of them return
the empty set of answers for abox a    mathst c    in contrast  in the following sections
we will show that abstract reasoner classify is  q  t   completethat is  that it returns all
certain answers to q  t   and an arbitrary abox a 

    test suites
checking  q  t   completeness of a concrete reasoner by applying the reasoner to all possible
aboxes and comparing the reasoners answers with that of a complete reasoner is clearly
infeasible in practice since there are infinitely many candidate input aboxes  to obtain
a practical approach  we need a finite number of tests  we formalise this idea using the
following definition 
definition       let t be a tbox  a t  test suite is a pair s   s   sq  where
 s is a finite set of aboxes such that cert   t   a    t for each a  s   and
 sq is a finite set of pairs a  y where a is an abox such that cert   t   a    f and
y is a ucq 
an abstract reasoner ans applicable to t passes a t  test suite s if ans satisfies the
following two conditions 
 for each a  s   we have ans   t   a    t  and
 for each a  y  sq   if ans   t   a    f  then cert y  t   a   ans y  t   a  
let q be a ucq  and let c be a class of abstract reasoners applicable to t   then  s is
exhaustive for c and q if each ans  c that passes s is  q  t   complete 
a t  test suite s is q simple if q is the only query occurring in sq   then  sq is commonly written as just a set of aboxes  and a  q  sq is commonly abbreviated as a  sq  
   

ficuenca grau  motik  stoilos   horrocks

intuitively  a t  test suite s   s   sq  determines the tests that an abstract reasoner
should be subjected to  for a reasoner to pass s  it must correctly identify each abox
a  s as unsatisfiable  and for each aboxquery pair a  y  sq the reasoner must
correctly answer y w r t  t and a 
given q and t   our goal is to identify a t  test suite s that is exhaustive for qthat
is  a test suite such that each abstract reasoner that passes s is guaranteed to be  q  t  complete  depending on the properties of abstract reasoners  however  dierent test suites
may or may not achieve this goal  therefore  the notion of exhaustiveness is relative to a
class of abstract reasoners c  if s is exhaustive for some class of abstract reasoners c  then
s can be used to test an arbitrary abstract reasoner in c  note that s depends on the
target class of abstract reasoners  but not on the actual abstract reasoner being tested  in
order words  the construction of s depends on the properties that one can assume to hold
for the target abstract reasoner  furthermore  if an abstract reasoner not contained in c
passes s  this will in general not imply a  q  t   completeness guarantee 
example       let q and t be as specified in example       and let a  a  be the
following aboxes 
a     takesco c  d   mathco d  
a     takesco c  d   calcco d  
a     mathst c  

a     takesco c  c   mathco c  
a     takesco c  c   calcco c  
a     st c   prof c  

in the following sections  we will show that the q simple t  test suite s   s   sq  defined
by s    a    and sq    a            a    is exhaustive for the class cwq t and q  consequently 
s can be used to test all abstract reasoners from example     
in particular  note that abstract reasoners rdf and rdfs fail all tests in s and sq   and
that abstract reasoner rl fails the test a   sq   furthermore  all failed tests provide a counterexample of  q  t   completeness  in contrast  abstract reasoner classify from example
     passes the tests in s  which implies that the abstract reasoner is indeed  q  t   complete 
finally  consider a variant of the abstract reasoner classify that  similarly to the abstract
reasoner described in example      returns the empty set of answers if the input abox
contains more than  say  ten assertions  such an abstract reasoner is not  q  t   monotonic
and hence does not belong to cwq t   this abstract reasoner clearly passes s  however  since
it does not belong to cwq t   passing s  correctly  does not imply that the abstract reasoner
is  q  t   complete 

we next state the following property  the proof of which is trivial 

proposition       let q be a ucq  let t be a tbox  and let c  and c  be classes of
abstract reasoners applicable to t such that c   c   
   if a t  test suite s is exhaustive for c  and q  then s is also exhaustive for c  and q 
   if no t  test suite exists that is exhaustive for c  and q  then no t  test suite exists
that is exhaustive for c  and q 
therefore  when proving existence of a t  test suite exhaustive for q  the most general
result is the one that applies to the largest possible class of abstract reasoners  furthermore 
   

ficompleteness guarantees for incomplete ontology reasoners

in the following section we will identify cases for which no t  test suite exhaustive for q
can be found  by proposition      it suces to provide nonexistence results for the smallest
possible class of abstract reasoners 
we finish this section by pointing out an important practically relevant property of
q simple t  test suites  which has been illustrated in example      
proposition       let s   s   sq  be a q simple t  test suite and let ans be an abstract
reasoner applicable to t   if ans does not pass s  then ans is not  q  t   complete 
proof  the abox in s or sq for which ans does not satisfy the conditions from definition
     is a counterexample for the  q  t   completeness of ans 
thus  a q simple t  test suite s exhaustive for c and q provides a sucient and necessary test for  q  t   completeness of the abstract reasoners in c  in contrast  if s is not
q simple  we show in section     that then s provides only a sucient  but not also a
necessary test for  q  t   completeness of the abstract reasoners in c 
    negative results
in sections      resp  section      we identify restrictions on a ucq q and a tbox t
that guarantee existence of t  test suites exhaustive for cwq t  resp  csq t   and q  before
presenting these positive results  we first outline the limits of  q  t   completeness testing
and thus justify the restrictions we use in the following sections 
      monotonicity and weak faithfulness
our approaches for testing  q  t   completeness of abstract reasoners are applicable only to
reasoners that are  q  t   monotonic and weakly  q  t   faithful  in this section  we provide
a formal justification for these requirements in the form of the following two theorems 
 theorem      shows that exhaustive test suites do not exist if we consider the class
of abstract reasoners satisfying all properties from section     apart from  q  t  monotonicity  this includes soundness  strong faithfulness  which implies weak faithfulness   and monotonicity w r t  the tbox only 
 theorem      shows that exhaustive test suites do not exist if we consider the class
of abstract reasoners satisfying all properties defined in section     with the exception
of  q  t   weak faithfulness  these properties include soundness and monotonicity 
the negative results of theorems      and      are very strong  they hold for smallest
classes of abstract reasoners we can define based on the notions introduced in section      by
proposition       the smaller the class of abstract reasoners  the more general the negative
result   and they hold regardless of the q and t considered  modulo a minor technicality 
unlike theorem       theorem      requires t to be satisfiable  
the proof of theorem      can intuitively be understood as follows  we first assume
that s is a t  test suite exhaustive for q and the class of abstract reasoners to which the
theorem applies  then  we specify an abstract reasoner ans that does the right thing  i e  
it returns the correct answer  when it is given as input the query q  the tbox t   and
   

ficuenca grau  motik  stoilos   horrocks

an arbitrary abox containing at most as many assertions as the largest test abox in s 
otherwise  ans returns a sound  but an incomplete answer  we finally show the following
three properties of ans 
 abstract reasoner ans belongs to the relevant class of abstract reasoners 
 abstract reasoner ans passes s 
 abstract reasoner ans is incomplete for at least one input abox 
these three properties then show that s is not exhaustive for q and the relevant class of
abstract reasoners  intuitively  this means that the class of abstract reasoners is too large 
allowing abstract reasoners to treat their input in an erratic way 
theorem       let q be an arbitrary ucq  and let t be an arbitrary admissible tbox 
then  no t  test suite exists that is exhaustive for q and the class of all sound and strongly
faithful abstract reasoners applicable to t satisfying the following conditions for each tbox
t  with t  t  and each abox a 
 ans   t   a    t implies ans   t    a    t 
 ans   t   a    f and ans   t    a    f imply ans q  t   a   ans q  t    a  
proof  consider an arbitrary t  test suite s   s   sq   let n be the maximum number of
assertions in an abox from s  furthermore  let ans be the abstract reasoner that takes as
input a ucq qin   an fol tbox tin   and an abox ain   the result of ans   tin   ain   is
determined as follows 
   try to find a renaming  such that dom     ind t   and  t    tin   if no such 
exists  then return f 
   if ain contains at most n assertions  then check the satisfiability of  t    ain using
a sound and complete reasoner  return t if  t    ain is unsatisfiable 
   return f 
furthermore  the result of ans qin   tin   ain   is determined as follows 
   try to find a renaming  such that dom     ind q  t     t    tin   and  q    qin  
if no such  exists  then return  
   if ain contains at most n assertions  then compute cert  q    t    ain   using a sound
and complete reasoner and return the result 
   return  
since t is admissible  checks in steps   and   can be performed in finite time  furthermore  step   can be realised by enumerating all mappings from ind t   to ind tin    and step
  can be realised analogously  consequently  ans can be implemented such that it terminates
on all inputs  to see that ans is sound and monotonic w r t  the tbox  consider arbitrary
input qin   tin   tin   and ain such that tin  tin  
   

ficompleteness guarantees for incomplete ontology reasoners

 assume that ans   tin   ain     t  then  on qin   tin   and ain the abstract reasoner
returns in step   because  t    ain is unsatisfiable  but then  since  t    tin   we
have that tin  ain is unsatisfiable as well  as required for soundness  furthermore 
since  t    tin  tin   on qin   tin   and ain the abstract reasoner returns in step  
as well  so ans   tin   ain     t  as required for monotonicity w r t  the tbox 
 assume that a  ans qin   tin   ain    then  on qin   tin   and ain the abstract reasoner
returns in step    and therefore we have a  cert  q    t    ain    but then  since
 q    qin and  t    tin   we have a  cert qin   tin   ain    as required for soundness  furthermore  since  t    tin  tin   on qin   tin   and ain the abstract reasoner
returns in step   as well  so a  ans qin   tin   ain    as required for monotonicity w r t 
the tbox 
to see that ans is strongly faithful  consider an arbitrary renaming   if renaming 
exists such that  q    qin and  t    tin   then clearly renaming   exists such that
   q     qin   and    t     tin    consequently  if ans   tin   ain   returns in step    then
ans    tin     ain    returns in step   as well  similarly  if ans qin   tin   ain   returns in step
   then ans  qin     tin     ain    returns in step   as well  clearly  ans is strongly faithful 
finally  it is straightforward to see that ans passes s 
now let a be an abox containing at least n     assertions such that cert q    a     
such a clearly exists  if t  a is unsatisfiable  then ans   t   a    f  furthermore  if t  a
is satisfiable  then ans q  t   a      consequently  ans is not  q  t   complete  thus  s is
not exhaustive for q and the class of abstract reasoners considered in this theorem 
we next prove theorem       the proof is similar to the proof of theorem       and
the main dierence is in the abstract reasoner ans we construct  in particular  given a test
suite s  we take ans to return the correct answer on the query q  the tbox t   and each
abox that contains only the individuals occurring in s  otherwise  the abstract reasoner
returns a sound  but an incomplete answer  again  the class of the abstract reasoners is
too large  allowing ans to treat inputs in an erratic way 
unlike theorem       the following theorem requires t to be satisfiable  to understand
why  consider an arbitrary unsatisfiable tbox t and ucq q  let s   s   sq  be the
t  test suite defined by s       i e   s contains a single empty abox  and sq     i e  
sq contains no aboxes   and consider an arbitrary monotonic abstract reasoner ans that
passes s   since ans passes s  we have ans   t       t  but then  since ans is monotonic 
for an arbitrary abox a we have ans   t   a    t as well  which in turn implies that ans is
 q  t   complete  failure to satisfy weak faithfulness is thus irrelevant if t is unsatisfiable 
theorem       let t be an arbitrary admissible and satisfiable tbox and let q be an
arbitrary ucq  then  no t  test suite exists that is exhaustive for q and the class of all
sound and monotonic abstract reasoners applicable to t  
proof  consider an arbitrary t  test suite s   s   sq   let i be the set of all individuals
occurring in s  q  and t   furthermore  let ans be the abstract reasoner that takes as
input a ucq qin   an fol tbox tin   and an abox ain   the result of ans   tin   ain   is
determined as follows 
   if t  tin   then return f 
   

ficuenca grau  motik  stoilos   horrocks

   let ain i be the set of assertions in ain that mention only the individuals in i 
   check the satisfiability of t  ain i using a sound and complete reasoner  return t if
t  ain i is unsatisfiable  and return f otherwise 
furthermore  given a ucq qin   the result of ans qin   tin   ain   is determined as follows 
   if t  tin or q  
 qin   then return  
   let ain i be the set of assertions in ain that mention only the individuals in i 
   compute cert q  t   ain i   using a sound and complete reasoner and return the result 
that ans can be implemented such that it terminates on all inputs can be shown as in
the proof of theorem       furthermore  the soundness of ans follows from the following
two observations 
 assume that ans   tin   ain     t  then  the abstract reasoner returns in step   since
t  ain i is unsatisfiable  but then  since t  tin and ain i  ain   we have that
tin  ain is unsatisfiable as well  as required 
 assume that a  ans qin   tin   ain    then  the abstract reasoner returns in step   
and therefore we have a  cert q  t   ain i    but then  since q   qin   t  tin   and
ain i  ain   we have a  cert qin   tin   ain    as required 
for monotonicity  consider an arbitrary tin and ain such that tin  tin and ain  ain  
clearly  we have t  tin and ain i  ain i   but then  by monotonicity of first order logic 
ans   tin   ain     t implies ans   tin   ain     t  and ans q  tin   ain    ans q  tin   ain    finally  it is straightforward to see that ans passes s 
now consider an arbitrary abox a such that ind a   i    and cert q    a      such
a clearly exists  if t  a is unsatisfiable  since the abox constructed in step   is empty
and t is satisfiable  we have ans   t   a    f  furthermore  if t  a is satisfiable  since the
abox constructed in step   is empty  ans q  t   a  cannot contain individuals not occurring
in i  consequently  ans is not  q  t   complete  thus  s is not exhaustive for q and the
class of abstract reasoners considered in this theorem 
      monotonicity and weak faithfulness do not suffice
next  we show that  q  t   monotonicity and  q  t   faithfulness in general do not guarantee
existence of a t  test suite exhaustive for q  in particular  theorem      shows that  if t
contains a single recursive axiom  no test suite exists that is exhaustive for the class of
all sound  monotonic  and strongly faithful abstract reasoners  and by proposition     
for csq t and cwq t as well  for each ucq q   although our result is applicable only to a
particular q and t   it is straightforward to adapt the proof to any tbox with a recursive
axiom that is relevant to the given query  example       however  shows that the concept
of relevance is rather dicult to formalise  even if t entails a recursive axiom  this axiom
is not necessarily relevant to answering the query  in order not to complicate matters any
further  we state the following result for fixed q and t   and we hope that our proof clearly
illustrates the limitations incurred by recursive axioms 
   

ficompleteness guarantees for incomplete ontology reasoners

theorem       for q    a x   q x   and t    r a  a   no t  test suite exists
that is exhaustive for q and the class of all sound  monotonic  and strongly faithful abstract
reasoners applicable to t  

proof  consider an arbitrary t  test suite s   s   sq   since s is a t  test suite  s
contains only aboxes a such that t  a is unsatisfiable  clearly  no such abox exists for t
as stated in the theorem  so s     let sq be an arbitrary  but finite  set of pairs a  y
with a an abox and y a ucq  and let n be the maximum number of assertions in an abox
in sq   furthermore  consider the following abox  where ai   aj for all    i   j  n     
an      r a    a             r an   an      a an     
we next construct an abstract reasoner pevaln with the following properties 
 p   for each a  y  sq   we have cert y  t   a   pevaln  y  t   a  
 p   a   pevaln  q  t   an      and
 p   pevaln is sound  monotonic  and strongly faithful 
note that a   cert q  t   an      so the above three properties imply that s is not exhaustive
for q and the class of abstract reasoners considered in this theorem 
abstract reasoner pevaln accepts as input an fol tbox tin and an abox ain   the
result of pevaln    tin   ain   is determined as follows 
   return f 

furthermore  given a ucq qin   the result of pevaln  qin   tin   ain   is determined as follows 
   if t  tin or q  
 qin   return  
   asat    ain
   repeat the following computation n times 
 asat    asat    a x      is a substitution s t    r x  y     a y     asat  
   return cert q    asat   

abstract reasoner pevaln clearly satisfies property  p   because deriving the assertion a a   
requires n   iterations of the loop in step    furthermore  pevaln also satisfies  p   because
every abox a occurring in sq contains at most n individuals and t can be seen as the
rule r x  y   a y   a x   which pevaln applies n times to the input abox ain  
we finally show  p    abstract reasoner pevaln is clearly sound  furthermore  for each
renaming  we have  t     t and  q    q  so pevaln is clearly strongly faithful 
to show that pevaln is monotonic  consider arbitrary tin   tin   ain   and ain such that
tin  tin and ain  ain   since pevaln    tin   ain     f for each input  the following are the
only relevant cases 
 pevaln returns  in step   on input qin   tin   and ain   in which case either t  tin or
q   qin   since tin  tin   clearly pevaln also returns  in step   on input qin   tin  
and ain   and monotonicity holds 
   

ficuenca grau  motik  stoilos   horrocks

 pevaln returns in step   on input qin   tin   and ain   then  pevaln can return in either
step   or step   on input qin   tin and ain   in the former case  monotonicity holds
trivially  and in the latter case  pevaln  qin   tin   ain    pevaln  qin   tin   ain   follows
directly from the fact that ain  ain  
the following example shows that the presence of recursive axioms in t does not preclude the existence of a t  test suite exhaustive for q 
example       consider q and t defined as follows 
q    a x   b x   q x  
t    r a  a  b  r a 
note that t contains the axiom mentioned in theorem       however  note also that
t    b  a  and so
r      b x   q x  

is a ucq rewriting of q w r t  t   in section     we show that the existence of a ucq rewriting of q w r t  t guarantees existence of a q simple t  test suite that is exhaustive for cwq t
 and hence also for csq t   and q  for example  s        b a     is one such t  test suite 
intuitively  t    b  a is the only consequence of t that is relevant for answering q  hence 
for t     b  a  and q    a x   q x    we have that cert q  t   a    cert q   t   a  for
an arbitrary abox a  hence  the recursive axiom in t is irrelevant for answering q  and
therefore its presence in t does not preclude the existence of a t  test suite that is exhaustive
for cwq t and q 

    testing  q  t   monotonic and weakly  q  t   faithful abstract reasoners

in this section  we identify a sucient condition that guarantees existence of a q simple
t  test suite s exhaustive for cwq t and q  by proposition       this result applies to csq t
as well  roughly speaking  such s can always be computed by instantiating the rules in a
ucq rewriting of q w r t  t in a suitable way  the requirement that q should be ucqrewritable w r t  t invalidates the negative result of theorem      since no ucq rewriting
of q    a x   q x   w r t  t    r a  a  exists 
this result allows one to compute q simple t  test suites exhaustive for q in numerous
practically relevant cases  in particular  a ucq rewriting is guaranteed to exist if t is
expressed in the dls underpinning the ql profile of owl    motik et al       a  calvanese
et al          furthermore  as illustrated in example       a ucq rewriting may exist even
if t is expressed in other fragments of owl   such as the owl   el  motik et al       a 
baader  brandt    lutz         in practice  such rewritings can be computed using systems
such as quonto  acciarri et al         and requiem  perez urbina et al         
we establish the desired result in two steps  first  in section       we present a general
characterisation of q simple t  test suites exhaustive for cwq t and q  then  in section
      we use this characterisation to establish the desired connection between rewritings
and q simple t  test suites exhaustive for q 
   

ficompleteness guarantees for incomplete ontology reasoners

      characterisation of simple and exhaustive test suites
we next prove that a q simple t  test suite s   s   sq  is exhaustive for cwq t and q if
and only if s contains an isomorphic copy of each data pattern  i e   a subset of an abox 
that can produce a certain answer to q and  w r t  t   but that preserves the identity of
the individuals occurring in t and q  to show that this is not just a sucient  but also
a necessary condition for the existence of an exhaustive t  test suite  we observe that  if s
does not contain one such copy of a data pattern  we can always find an abstract reasoner
in cwq t that passes s but that misses certain answers obtained via the missing data pattern
and that is therefore not  q  t   complete 
theorem       let q be a ucq  let t be an admissible tbox  and let s   s   sq  be
a q simple t  test suite  then  s is exhaustive for cwq t and q if and only if the following
properties are satisfied for each abox a 
   if t  a is unsatisfiable  then there exist an abox a  s and an injective t  stable
renaming  such that dom     ind t  a   and  a    a 
   if t  a is satisfiable  then for each tuple a  cert q  t   a  there exist an abox
a  sq   a tuple b  cert q  t   a    and an injective  q  t   stable renaming  such
that  b    a  dom     ind q  t  a    and  a    a 
proof     let s be an arbitrary q simple t  test suite that satisfies properties   and   
we next show that s is exhaustive for cwq t and q  consider an arbitrary abstract reasoner
ans  cwq t that passes sthat is  ans satisfies the following two properties 
 a  ans   t   a     t for each a  s   and
 b  ans   t   a     f implies cert q  t   a    ans q  t   a   for each a  sq  
we next show that ans is  q  t   completethat is  that ans satisfies the two conditions in
definition      for an arbitrary abox a  for an arbitrary such a  we have the following
two possibilities  depending on the satisfiability of t  a 
assume that t  a is unsatisfiable  since s satisfies property    there exist an abox
a  s and an injective t  stable renaming  s t  dom     ind t  a   and  a    a 
by condition  a  we have ans   t   a     t  since ans is weakly  q  t   faithful   is injective
and t  stable  and dom     ind t  a    we have ans   t    a      t  finally  since ans is
 q  t   monotonic and  a    a  we have ans   t   a    t  as required by definition      
assume that t  a is satisfiable and ans   t   a    f  furthermore  consider an arbitrary tuple a  cert q  t   a   since s satisfies property    there exist an abox a  sq  
a tuple b  cert q  t   a    and an injective  q  t   stable renaming  such that  b    a 
dom     ind q  t  a    and  a    a  since  a    a  ans   t   a    f  and ans is
 q  t   monotonic  we have ans   t    a      f  furthermore  ind t  a    dom     is
injective and  q  t   stable  and ans is weakly  q  t   faithful  so ans   t    a      f implies ans   t   a     f  but then  by condition  b  we have cert q  t   a    ans q  t   a   
so b  ans q  t   a    since ans is weakly  q  t   faithful   is injective and  q  t   stable 
and dom     ind q  t  a    we have  b   ans q  t    a     since  b    a  we have
   

ficuenca grau  motik  stoilos   horrocks

a  ans q  t    a     finally  since ans is  q  t   monotonic and  a    a  we then have
a  ans q  t   a   as required by definition      

   assume that s is exhaustive for cwq t and q  we next show that properties   and  
are satisfied for an arbitrary abox a  to this end  we consider a particular abstract reasoner
ans for which we prove that ans  cwq t and that ans passes s  this abstract reasoner will
help us identify the abox  the tuple  and the renaming required to prove properties   and   
let ans be the abstract reasoner that takes as input a ucq qin   an fol tbox tin  
and an abox ain   the result of ans   tin   ain   is determined as follows 
   if t  
 tin   then return f 

   for each abox a  s   do the following 
 a  check the satisfiability of t  a using a sound  complete  and terminating
reasoner 
 b  if t  a is unsatisfiable  and if an injective t  stable renaming  exists such that
dom     ind t  a   and  a    ain   then return t 
   return f 
furthermore  the result of ans qin   tin   ain   is determined as follows 
   if t  
 tin or q  
 qin   then return  
   out     
   for each tuple a of constants occurring in ain of arity equal to the arity of the query
predicate of q  and for each a  sq do the following 
 a  compute c    cert q  t   a   using a sound  complete and terminating reasoner 
 b  if a tuple b  c and an injective  q  t   stable renaming  exist such that
 b    a  dom     ind q  t  a    and  a    ain   then add a to out 
   return out 
we next show that ans belongs to cwq t   to this end  we prove that ans terminates on
all inputs  and that it is  q  t   monotonic and weakly  q  t   faithful 
termination  since t is admissible  checking satisfiability of t  a and the computation
of cert q  t   a   are decidable  so the relevant sound  complete and terminating reasoners
exist  furthermore  checking whether a t  stable  resp   q  t   stable  injective renaming 
exists can be done by enumerating all renamings from ind t  a    resp  ind q  t  a   
to ind t  ain    resp  ind q  t  ain     therefore  ans can be implemented such that it
terminates on each input 
 q  t   monotonicity  consider arbitrary input qin   tin   ain   and ain such that ain  ain  
 assume that ans   tin   ain     t  so on tin and ain the abstract reasoner terminates
in step   b  for some a  s and   but then  since  a    ain  ain   on tin
and ain the abstract reasoner also terminates in step   b   so ans   tin   ain     t  as
required 
   

ficompleteness guarantees for incomplete ontology reasoners

 assume that ans   tin   ain     f and ans   tin   ain     f  and consider an arbitrary
tuple a  ans qin   tin   ain    then a is added to out in step   b  for some a  sq
and   but then  since  a    ain  ain   on qin   tin   and ain the abstract reasoner
also adds a to out in step   b   so a  ans qin   tin   ain    as required 
weak  q  t   faithfulness  consider an arbitrary input qin   tin   and ain   and an arbitrary
injective renaming  
 assume that ans   tin   ain     t  dom    ind t  a   and  is t  stable  thus  on
tin and ain the abstract reasoner terminates in step   b  for some a  s and   let
 be the renaming such that   c      c   for each c  ind t  a    clearly  we have
dom      ind t  a    renaming  is t  stable and injective  and   a     ain   
thus  on tin and  ain   the abstract reasoner terminates in step   b   so we therefore
have ans   tin    ain      t  as required 
 assume that ans   tin   ain     f  dom    ind q  t  a   and  is  q  t   stable 
and consider an arbitrary truple a  ans qin   tin   ain    then a is added to out in step
  b  for some a  sq     and b  let  be the renaming defined s t    c      c  
for each individual c  ind q  t  a    clearly  we have dom      ind q  t  a   
renaming  is  q  t   stable and injective    a     ain    and   b     a   thus 
on qin   tin   and  ain   the abstract reasoner terminates in step   b  and we clearly
have  a   ans qin   tin    ain     as required 
this concludes the proof that ans  cwq t   furthermore  ans clearly passes s  but then 
since s is exhaustive for cwq t and q  abstract reasoner ans is  q  t   complete  we next
prove the main claim of this theorem  to this end  consider an arbitrary abox a  we have
the following possibilities  depending on the satisfiability of t  a 
 assume that t  a is unsatisfiable  then ans   t   a    t  so the abstract reasoner
returns in step   b  for some abox a  s and some t  stable renaming  such that
 a    a and dom     ind t  a    thus  property   holds as required 
 assume that t  a is satisfiable  and consider an arbitrary tuple a  cert q  t   a  
then ans   t   a    f and a  ans q  t   a   so a is added to out in step   b  for
some abox a  sq   tuple b  cert q  t   a    and an injective  q  t   stable renaming
 such that  b    a  dom     ind q  t  a    and  a    a  thus  property  
holds as required 
the following example illustrates theorem      
example       let q and t be as specified in example       and let s   s   sq  be
specified in example       as we show in section        s is exhaustive for cwq t and q 
consider now an abox a    st a   mathst b   takesco a  b      clearly  t  a is satisfiable and cert q  t   a     b   by theorem       this certain answer can be obtained by
evaluating q w r t  t and an abox in sq   indeed  note that abox a   sq is isomorphic
to the subset a    mathst b   of a via renaming     b  c   and that applying q to t
and a  produces c  which is isomorphic to b via  
   

ficuenca grau  motik  stoilos   horrocks

note also that  if we remove a  from s  we no longer have a t  test suite that is
exhaustive for q  for example  abstract reasoner rl from example      would pass such a
test suite  but it would not return the required certain answers when applied to a   and 
consequently  when applied to a either  

      computing test suites exhaustive for cwq t

based on theorem       in this section we show that a t  test suite exhaustive for cwq t and
q an be obtained by instantiating a ucq rewriting r of q w r t  t that is  by replacing all
variables in r with individuals in all possible ways  please note that such an instantiation
must be full  in the sense that all possible replacements must be considered  this is because
the class cwq t can contain abstract reasoners such as rl  from example      that are not
strongly faithful and that may incorrectly handle the case when distinct variables are bound
to the same individuals 
definition       let i be a set of individuals  let r be a datalog rule  and let  be a
substitution  then   is an instantiation substitution for r w r t  i if  x   i for each
variable x occurring in r  if the latter holds  then the instantiation of r w r t   is the abox
ar      b    b  body r   
let q be a ucq  let t be a tbox  let r   r   rq  be a ucq rewriting of q w r t 
t   let m be the maximum number of distinct variables occurring in a rule in r  and let i
be a set containing all individuals occurring in r  q  and t   as well as m fresh individuals 
r i
r i
the full instantiation of r w r t  i is the pair er i   er i
and er i
q
   eq  where e
are the smallest sets of aboxes such that
 ar  er i
 for each r  r and each instantiation substitution  for r w r t  i  and
 ar  er i
q for each r  rq and each instantiation substitution  for r w r t  i such
that cert   r   ar     f 
er i is clearly unique up to the renaming of the fresh individuals in i  so i is typically left
r
implicit  and one talks of the full instantiation er   er
   eq  of r 
example       let q and t be as specified in example       and let r   r   rq  be
such that r    st x   prof x     and rq consists of the following datalog rules 
takesco x  y   mathco y   q x 
takesco x  y   calcco y   q x 
mathst x   q x 

then  r is a ucq rewriting of q w r t  t   and one can see that the q simple t  test suite
s   s   sq  from example      is the full instantiation of r 


the following theorem shows that the full instantiation of a ucq rewriting of q w r t 
t is a q simple t  test suite exhaustive for cwq t and q  according to this theorem  the
t  test suite s in example      is exhaustive for cwq t and q 
   

ficompleteness guarantees for incomplete ontology reasoners

theorem       let q be a ucq  let t be an admissible tbox  let r   r   rq  be a
r
ucq rewriting of q w r t  t   and let er   er
   eq  be the full instantiation of r  then 
er is a q simple t  test suite that is exhaustive for cwq t and q 

proof  let i be the set of individuals that er is obtained from  we first show that er is
a q simple t  test suitethat is  that it satisfies the two properties in definition      
 consider an arbitrary abox a  er
   then  a rule r  r and an instantiation
substitution  for r exist such that a   ar   clearly cert    r   a    t  since r is a
ucq rewriting  t  a is unsatisfiable  as required 
 consider an arbitrary abox a  er
q   then  cert   r   a    f by definition      
since r is a ucq rewriting  t  a is satisfiable  as required 
we next show that er satisfies properties   and   of theorem      for an arbitrary
abox a 
 property    assume that t  a is unsatisfiable  since r is a ucq rewriting  by
definition     we have cert   r   a    t  but then  a rule r  r and a substitution 
exist such that ar  a and cert    r   ar     t  let  be an injective renaming such that
for each individual c occurring in r or t we have  c    c  and for each individual d
occurring in ar but not in r and t we have that  d  is a fresh individual in i  such 
exists since the number of variables in r is smaller or equal to the number of fresh individuals
in i  let  be an instantiation substitution for r such that  x      x   for each variable
r
x occurring in r  then ar  er
 holds since e is the full instantiation of r w r t  i  let 
be any injective renaming that coincides with the inverse of  on each individual occurring
in ar   r  or t   such  exists since  is injective and the range of  contains each individual
occurring in ar   r  and t   clearly  ar     ar holds  so  ar    a  furthermore   is
clearly t  stable  thus  property     is satisfied for ar  er
 and  
 property    assume that t  a is satisfiable  and consider an arbitrarily chosen tuple
a  cert q  t   a   since r is a ucq rewriting  by definition     we have cert   r   a    f
and a  cert rq   r   a   but then  clearly a  cert rq     a  as well  then  a rule r  rq
and a substitution  exist such that ar  a and a  cert  r     ar    let  be an injective
renaming such that for each individual c occurring in r  q  or t we have  c    c  and
for each individual d occurring in ar but not in r  q  and t we have that  d  is a fresh
individual in i  such  clearly exists since the number of variables in r is smaller or equal
to the number of fresh individuals in i  let  be an instantiation substitution for r such
r is
that  x      x   for each variable x occurring in r  then ar  er
q holds since e
the full instantiation of r w r t  i  let  be any injective renaming that coincides with
the inverse of  on each individual occurring in ar   r  q  or t   such  exists since 
is injective and the range of  contains each individual occurring in ar   r  q  and t  
furthermore  clearly a tuple b  cert  r     ar   exists such that  head r     q b   since
r is a ucq rewriting and t  ar is satisfiable  we have b  cert q  t   ar    furthermore 
since  is injective   b    a clearly holds  but then  property     is satisfied for ar  er
q 

  and b 
   

ficuenca grau  motik  stoilos   horrocks

      minimising exhaustive test suites
in practice  it is clearly beneficial to compute test suites that are as small as possible 
this goal can be achieved by applying known techniques for minimising ucq rewritings
 calvanese et al         perez urbina  horrocks    motik         by theorem       the
smallest such rewriting can be instantiated to obtain an exhaustive test suite 
state of the art query rewriting systems employ subsumption and condensation techniques in order to reduce the size of a rewriting  a datalog rule r subsumes a datalog rule
r if a substitution  exists such that  r   r   intuitively  r is then more general than r  
if a rewriting contains such rules r and r   then r can be safely removed from the rewriting 
furthermore  if a rule r contains distinct unifiable body atoms bi and bj   a condensation
of r is the rule  r  where  is the most general unifier of bi and bj   if a rewriting contains
such rule r and  r  subsumes r  the rule can safely be replaced with  r   the following
example illustrates how these techniques can be used to obtain small test suites 
example       let q and t be as specified in example       and let r be the rewriting
of q w r t  t from example       then r   r   rq  where rq consists of the following
rules is also a ucq rewriting of q w r t  t  
takesco x  y   takesco x  z   mathco y   q x 

    

takesco x  y   calcco y   q x 

    

mathst x   q x 

    

takesco x  x   calcco x   mathco x   q x 

    

st x   mathst x   q x 

    

by theorem       the full instantiation of r is also a t  test suite exhaustive for cwq t and
q  the rewriting r   however  contains redundancy and hence the resulting test suite is
unnecessarily large  in particular  by applying condensation to query       subsumption to
queries      and       and subsumption again to queries      and       we can obtain the
simpler rewriting r 

finally  note that the test suites obtained via full instantiation can contain isomorphic
aboxes  clearly  all isomorphic copies of an abox can safely be eliminated from a test
suite without losing exhaustiveness for cwq t and q 
    testing  q  t   monotonic and strongly  q  t   faithful abstract reasoners

due to full instantiation  test suites obtained by definition      can be exponentially larger
than the rewriting they are generated from  as a result  even rewritings of moderate size can
yield test suites containing thousands of aboxes  intuitively  full instantiation is required
to obtain a test suite exhaustive for the class cwq t because this class contains abstract
reasoners such as rl  from example       which do not correctly handle the case when
distinct variables in a query are matched to the same individual 
in this section  we show that test suites exhaustive for the class csq t can be obtained by
an injective instantiation of a rewritingthat is  by replacing each variable with a distinct
fresh individual  test suites obtained in such a way are linear in the size of the rewriting 
and are thus substantially smaller than test suites obtained by full instantiation 
   

ficompleteness guarantees for incomplete ontology reasoners

example       let q and t be as specified in example       and let s   s   sq  be the
q simple t  test suite from example       furthermore  consider the abstract reasoner rl 
from example      that is weakly  but not strongly  q  t   faithful  it is easy to check that
rl  returns complete answers on a  and a    but not on a  and a    therefore  by theorem
      for s to be exhaustive for cwq t and q  we must include in sq aboxes a  and a   
which are respectively obtained from aboxes a  and a  by merging individual d into c 
strongly  q  t   faithful abstract reasoners  however  correctly handle inputs obtained
by merging individuals  based on this observation  in this section we show that the q simple
t  test suite s   s   sq  where sq    a    a    a     obtained by injectively instantiating
the rewriting r from example       is exhaustive for csq t and q 



as in section      we first develop a characterisation of q simple t  test suites that are
exhaustive for csq t and q  this result is analogous to theorem      

theorem       let q be a ucq  let t be an admissible tbox  and let s   s   sq  be
a q simple t  test suite  then  s is exhaustive for csq t and q if and only if the following
properties are satisfied for each abox a 
   if t  a is unsatisfiable  then there exist an abox a  s and a t  stable renaming
 such that dom     ind t  a   and  a    a 
   if t  a is satisfiable  then for each tuple a  cert q  t   a  there exist an abox
a  sq   a tuple b  cert q  t   a    and a  q  t   stable renaming  such that  b    a 
dom     ind q  t  a    and  a    a 
proof     let s be an arbitrary q simple t  test suite that satisfies properties   and   
we next show that s is exhaustive for csq t and q  consider an arbitrary abstract reasoner
ans  csq t that passes sthat is  ans satisfies the following two properties 
 a  ans   t   a     t for each a  s   and
 b  ans   t   a     f implies cert q  t   a    ans q  t   a   for each a  sq  
we next show that ans is  q  t   completethat is  that ans satisfies the two conditions in
definition      for an arbitrary abox a  for an arbitrary such a  we have the following
two possibilities  depending on the satisfiability of t  a 
assume that t  a is unsatisfiable  since s satisfies property    there exist an abox
a  s and a t  stable renaming  such that dom     ind t  a   and  a    a  by
condition  a  we have ans   t   a     t  since ans is strongly  q  t   faithful and  is t stable  we have ans   t    a      t  finally  since ans is  q  t   monotonic and  a    a 
we have ans   t   a    t  as required by definition      
assume that t  a is satisfiable and ans   t   a    f  furthermore  consider an arbitrary tuple a  cert q  t   a   since s satisfies property    there exist an abox a  sq   a
tuple b  cert q  t   a    and a  q  t   stable renaming  such that  b    a   a    a  and
dom     ind q  t  a    since  a    a  ans   t   a    f  and ans is  q  t   monotonic 
we have ans   t    a      f  furthermore   is  q  t   stable and ans is strongly faithful  so ans   t    a      f implies ans   t   a     f  but then  by condition  b  we have
cert q  t   a    ans q  t   a    so b  ans q  t   a    now ans is strongly  q  t   faithful and
   

ficuenca grau  motik  stoilos   horrocks

 is  q  t   stable  so  b   ans q  t    a     since  b    a  we have a  ans q  t    a    
finally  since ans is  q  t   monotonic and  a    a  we have a  ans q  t   a   as required
by definition      
   assume that s is exhaustive for csq t and q  we next show that properties   and  
are satisfied for an arbitrary abox a  to this end  we consider a particular abstract reasoner
ans for which we prove that ans  csq t and that ans passes s  this abstract reasoner will
help us identify the abox  the tuple  and the renaming required to prove properties   and   
let ans be the abstract reasoner that takes as input a ucq qin   an fol tbox tin  
and an abox ain   the result of ans   tin   ain   is determined as follows 
   if t  
 tin   then return f 
   for each abox a  s   do the following 
 a  check the satisfiability of t  a using a sound  complete  and terminating
reasoner 
 b  if t  a is unsatisfiable  and if a t  stable renaming  exists such that
dom     ind t  a   and  a    ain   then return t 
   return f 
furthermore  the result of ans qin   tin   ain   is determined as follows 
   if t  
 tin or q  
 qin   then return  
   out     
   for each tuple a of constants occurring in ain of arity equal to the arity of the query
predicate of q  and for each a  sq do the following 
 a  compute c    cert q  t   a   using a sound  complete and terminating reasoner 
 b  if a tuple b  c and a  q  t   stable renaming  exist such that  b    a 
dom     ind q  t  a    and  a    ain   then add a to out 

   return out 
we next show that ans belongs to csq t   the proofs that ans terminates and that it
is  q  t   monotonic are analogous to the proofs in theorem       to show strong  q  t  faithfulness  consider an arbitrary qin   tin   and ain   and an arbitrary renaming  
 assume that ans   tin   ain     t and  is t  stable  thus  on tin and ain the abstract
reasoner terminates in step   b  for some a  s and   let  be the renaming such
that   c      c   for each c  ind t  a    clearly  we have dom      ind t  a   
renaming  is t  stable  and   a     ain    thus  on tin and  ain   the abstract
reasoner terminates in step   b   so we have ans   tin    ain      t  as required 
 assume that ans   tin   ain     f and  is  q  t   stable  and consider an arbitrary
tuple a  ans qin   tin   ain    then a is added to out in step   b  for some a  sq  
   

ficompleteness guarantees for incomplete ontology reasoners

  and b  let  be the renaming defined such that   c      c   for each individual c  ind q  t  a    clearly  we have dom      ind q  t  a    mapping  is
 q  t   stable    a     ain    and   b     a   thus  on qin   tin   and  ain   the
abstract reasoner terminates in step   b   so  a   ans qin   tin    ain     as required 
this concludes the proof that ans  csq t   furthermore  ans clearly passes s  but then 
since s is exhaustive for csq t and q  abstract reasoner ans is  q  t   complete  the main
claim of this theorem can now be shown as in theorem      
we next use theorem      to show that a q simple t  test suite that is exhaustive for
and q can be obtained as an injective instantiation of a ucq rewriting of q w r t  t  

csq t

definition       let q be a ucq  let t be a tbox  let r   r   rq  be a ucq rewriting
of q w r t  t   and let  be a substitution mapping each variable occurring in r into a distinct
r 
fresh individual  the injective instantiation of r w r t   is the pair ir    ir 
   iq 
where ir 
and ir 
are the smallest sets of aboxes such that
q

 ar  ir 
for each r  r   and

 ar  ir 
for each r  rq such that cert   r   ar     f 
q
ir  is clearly unique up to the renaming of the fresh individuals in   so  is typically left
r
implicit  and one talks of the injective instantiation ir   ir
   iq  of r 
theorem       let q be a ucq  let t be an admissible tbox  let r   r   rq  be a
r
ucq rewriting of q w r t  t   and let ir   ir
   iq  be the injective instantiation of r 
then  ir is a q simple t  test suite that is exhaustive for csq t and q 

proof  let  be the substitution that ir is obtained from  we first show that ir is a
q simple t  test suitethat is  that it satisfies the two properties in definition      
r
 consider an arbitrary a  ir
   then  a rule r  r exist such that a   a   clearly
cert    r   a    t  since r is a ucq rewriting  t  a is unsatisfiable  as required 

 consider an arbitrary a  ir
q   then  cert   r   a    f by definition       since r is
a ucq rewriting  t  a is satisfiable  as required 
we next show that ir satisfies properties   and   of theorem      for an arbitrary
abox a 
 property    assume that t  a is unsatisfiable  since r is a ucq rewriting  by
definition     we have cert   r   a    t  but then  a rule r  r and a substitution 
exist such that ar  a and cert    r   ar     t  let  be a renaming such that for each
individual c occurring in r or t we have  c    c  and for each variable x in r we have
  x      x   clearly   ar     ar   so  ar    a  furthermore  it is clear that  is
t  stable  thus  property     holds for ar  ir
 and  
 property    assume that t  a is satisfiable  and consider an arbitrarily chosen tuple
a  cert q  t   a   since r is a ucq rewriting  by definition     we have cert   r   a    f
and a  cert rq   r   a   but then  clearly a  cert rq     a  as well  then  a rule r  rq
   

ficuenca grau  motik  stoilos   horrocks

and a substitution  exist such that ar  a and a  cert  r     ar    let  be the renaming
such that for each individual c occurring in r  q  or t we have  c    c  and for each
variable x in r we have   x      x   clearly   ar     ar   so  ar    a  furthermore 
it is clear that  is  q  t   stable  finally  clearly a tuple b  cert  r     ar   exists such
that  head r     q b   since r is a ucq rewriting and t  ar is satisfiable  we have
b  cert q  t   ar    furthermore   b    a clearly holds  but then  property     is satisfied

for ar  ir
 
 
and b 
q
    dealing with recursive axioms
the negative result in theorem       which applies to both cwq t and csq t   depends on
the presence of a recursive axiom in the tbox  thus  the positive results in sections    
and     require the input ucq to be rewritable w r t  the input tbox  which eectively
prohibits recursion in tbox axioms  instead of disallowing recursive axioms  in this section
we overcome the limitation of theorem      by placing additional requirements on the
abstract reasoners by requiring them to be first order reproducible  intuitively  the latter
means that the reasoners behaviour can be seen as complete reasoning in some unknown
first order theory  such abstract reasoners are not allowed to partially evaluate recursive
axioms  which invalidates the approach used to prove theorem      
we show that a t  test suite exhaustive for q and the class of first order reproducible
abstract reasoners can be obtained by instantiating a datalog  rewriting of q w r t  t  
such rewritings exist for a wide range of tboxes and queries  which in turn allows our
results to be applicable to a range of practically interesting cases  in contrast to test
suites computed from a ucq rewriting  however  the test suites obtained from a datalog 
rewriting may not be q simple  in fact  we show in section       that  for certain q
and t   a t  test suite exhaustive for q and the class of first order reproducible abstract
reasoners exists  but no such test suite is q simple  this has an important practicallyrelevant consequence  if a t  test suite s is not q simple  a first order reproducible abstract
reasoner that passes s is guaranteed to be  q  t   complete  however  if an abstract reasoner
does not pass s  in general we cannot conclude that the reasoner is not  q  t   complete 
      first order reproducible abstract reasoners
state of the art concrete reasoners such as oracles reasoner  jena  owlim  minerva  virtuoso  and dle jena are all implemented as rdf triple stores extended with deductive
database features  given t and a as input  these reasoners first precompute all assertions
that follow from t  a in a preprocessing step  in practice  this step is commonly implemented by  a technique that can be seen as  evaluating a datalog program over a  after
preprocessing  these reasoners can then answer an arbitrary ucq q by simply evaluating
q in the precomputed set of assertions 
motivated by this observation  we next introduce the new class of first order reproducible
abstract reasonersthat is  abstract reasoners whose behaviour can be conceived as complete reasoning in some unknown first order theory  note that this theory is not required to
be a datalog program  for example  it can contain existential quantifiers  which can be used
to capture the behaviour of concrete reasoners such as jena and owlim  bishop  kiryakov 
   

ficompleteness guarantees for incomplete ontology reasoners

ognyano  peikov  tashev    velkov        that handle existential quantifiers in the input
by introducing fresh individuals 
definition       an abstract reasoner ans for a description logic dl is first order reproducible if  for each dl tbox t   a set of first order sentences ft exists such that  for each
abox a 
 ans   t   a    cert   ft   a   and

 if ans   t   a    f  then for each ucq q  we have ans q  t   a    cert q  ft   a  

if ft contains predicates and or individuals not occurring in t   these are assumed to be
internal to ans and not accessible in queries  tboxes  aboxes  test suites  and so on 
given a tbox t   cft is the class of all first order reproducible abstract reasoners applicable
to t  
example       abstract reasoners rdf  rdfs  rl and classify from example     are all firstorder reproducible  indeed  theory ft is empty in the case of rdf  and it is precisely prdfs
and prl in the cases of rdfs and rl  respectively  finally  for abstract reasoner classify  theory
ft is the union of prl and the program containing the axiom x  a x   b x   for each
atomic subsumption a  b entailed by the input tbox 


please note that a first order reproducible abstract reasoner ans does not need to actually construct ft   it only matters that some  possibly unknown  theory ft exists that
characterises the reasoners behaviour as specified in definition      
since qft a    qft a whenever a  a   each first order reproducible abstract
reasoner is  q  t   monotonic for arbitrary q and t   furthermore  it is straightforward
to see that each first order reproducible abstract reasoner is also strongly  q  t   faithful 
consequently  we have cft  csq t for each ucq q and each tbox t  
we next show that the negative result in theorem      does not directly apply to
the class cft   in particular  we show that the abstract reasoner pevaln used to prove
theorem      is not first order reproducible  intuitively  pevaln can be understood as
partial evaluation of a datalog programthat is  the rules in the program are applied to
the facts only a fixed number of times rather then until a fixpoint is reached 
proposition       for each positive integer n  the abstract reasoner pevaln defined in the
proof of theorem      is not first order reproducible 
proof  let t    r a  a   let q    a x   q x    and consider an arbitrary nonnegative integer n  furthermore  assume that pevaln  cft   then  a finite set of first order
sentences ft exists such that pevaln  q  t   a    cert q  ft   a  for each abox a 
let k be a positive integer  furthermore  let rk be the datalog rule and let ak be the
abox defined as follows  for a            ak arbitrary distinct but fixed individuals not occurring
in q  ft  
rk   r x    x            r xk    xk    a xk    a x   
ak    r a    a             r ak    ak    a ak   
the following condition holds by proposition     
ft    rk

if and only if ft  ak    a a   
   

    

ficuenca grau  motik  stoilos   horrocks

by the definition of pevaln   we have
a   pevaln  q  t   ak   for each    k  n  and
a   pevaln  q  t   ak   for each k   n 
since pevaln  q  t   a    cert q  ft   a   we have
a   cert q  ft   ak   for each    k  n  and
a   cert q  ft   ak   for each k   n 
since q contains only the atom a x  in the body  we have
ft  ak    a a    for each    k  n  and
ft  ak    a a    for each k   n 
by condition       we then have
ft    rk for each    k  n
ft    rk for each k   n 
this  however  contradicts the obvious observation that r     rk for each k    
note that the proof of proposition      relies on the fact that the theory ft only depends
on the input tbox  and not on the input query  as shown next  had we defined first order
reproducible abstract reasoners by allowing ft to depend also on the input query  then the
negative result from theorem      would have applied 
definition       an abstract reasoner ans for dl first order q reproducible if  for each
ucq q and each dl tbox t   a finite set of first order sentences fq t exists such that 
for each abox a 
 ans   t   a    cert   fq t   a   and
 if ans   t   a    f  then ans q  t   a    cert q  fq t   a  
theorem       for q    a x   q x   and t    r a  a   no t  test suite exists
that is exhaustive for q and the class of all sound  monotonic  strongly faithful  and qreproducible abstract reasoners applicable to t  
proof  to prove this claim  it suces to show that  for each nonnegative integer n  the
abstract reasoner pevaln defined in the proof of theorem      is first order q reproducible 
consider an arbitrary nonnegative integer n  an arbitrary dl tbox t    and an arbitrary
ucq q   we define fq  t  such that  if t  t  or q   q  then fq  t      otherwise 
fq  t  consists of the following n rules 
a x     q x   

r x    x     a x     q x   
   

r x    x     r x    x            r xn    xn    a xn    q x   
   

ficompleteness guarantees for incomplete ontology reasoners

clearly  pevaln    t    a     cert   fq  t    a     f for each ucq q   dl tbox t  and
abox a   as required  furthermore  for each q and t  such that either t  t  or q   q
and each abox a   we have pevaln  q   t    a     cert q   fq  t    a       finally  for
q   q  each t  such that t  t    and each abox a   we clearly have pevaln  q   t    a    
cert q   fq  t    a    as required 
      simple vs  non simple test suites
proposition      from section     shows that each q simple t  test suite that is exhaustive
for q and a class of abstract reasoners provides a sucient and necessary test for  q  t  completeness  we next show that an analogous result does not hold if t contains recursive
axioms  even if we consider only first order reproducible abstract reasoners  as in theorem       we prove the claim for a fixed q and t since the concept of relevant recursive
axioms might be dicult to formalise  however  our proof can easily be adapted to other
ucqs and tboxes  our result essentially states that no t  test suite exists that provides
a necessary and sucient condition for  q  t   completeness of each abstract reasoner in
cft   consequently  by proposition      each t  test suite exhaustive for cft and q is not
q simple  furthermore  in section       we show how to compute a t  test suite exhaustive
for cft and q  so the following claim does not hold vacuously 
theorem       let q    a x   b x   q x    let t    r a  a   and let c be the
class of all sound  monotonic  strongly faithful  and first order reproducible abstract reasoners applicable to t   then  no t  test suite s exists that satisfies the following two properties 
   s is exhaustive for c and q  and
   for each abstract reasoner ans  c  if ans is  q  t   complete then ans passes s 
proof  assume that a t  test suite s   s   sq  exists that satisfies properties   and   of
the theorem  let n be the maximal number of assertions occurring in an abox in s  we
next define two abstract reasoners ans  and ans    it is straightforward to check that both
are sound  monotonic  strongly faithful  and first order reproducible 
given an arbitrary fol tbox tin   abstract reasoner ans  uses the datalog program
ft in defined as follows 
 if t  tin   then ft in    
 if t  tin   then ft in contains the following n rules 
r   
r   
r   

b x     a x     a x   
b x     r x    x     a x     a x   
b x     r x    x     r x    x     a x     a x   
   
rn   b x     r x    x            r xn    xn    a xn    a x   
given an arbitrary fol tbox tin   abstract reasoner ans  uses the datalog program
defined as follows  where predicate z is private to ft in  and hence it does not aect
the soundness of the abstract reasoner  
ft in

   

ficuenca grau  motik  stoilos   horrocks

 if t  tin   then ft in    
 if t  tin   then ft in contains ft in as well as the following rules 
rz    r x    x            r xn   xn      a xn      z x   
rz   
r x    x     z x     z x   
rz   
z x   b x   a x 
now let a be an arbitrary abox containing at most n assertions  we next show
that  for each assertion  not containing predicate z  we have ft in  a     if and only
if ft in  a      the    direction is trivial since ft in  ft in   so we consider the   
direction  furthermore  since rz  is the only rule in ft in   ft in that does not contain
z in the head  the claim is nontrivial only if  is of the form a a    for some individual a  occurring in a  since the antecedent of rz  is satisfied for a    we have b a     a
and ft in  a    z a     but then  for the latter to be implied by rz  and rz    individuals
a    a            ak with    k exist such that r ai   ai      a for each    i   k  and a ak    a 
since a contains at most n assertions  w l o g  we can assume that k  n  but then  since
ft in contains rule rk   we have ft in  a    a a    as well  which proves our claim  as a consequence of this claim and the fact that all aboxes in s contain at most n assertions  we have
cert   ft in   a    cert   ft in   a  for each a  s   and cert y  ft in   a    cert y  ft in   a 
for each a  y  sq  
let a    b a     r a    a             r an   an      a an       then cert q  t   a     a    and
cert q  ft in   a      so ans  is not  q  t   complete  since s is exhaustive for c and q 
abstract reasoner ans  does not pass s  by the claim from the previous paragraph  abstract
reasoner ans  does not pass s either  we next show that ans  is  q  t   complete  which
contradicts the assumption that s satisfies property   and thus proves the claim of this
theorem 
consider an arbitrary abox a containing m assertions  clearly  a   cert q  t   a  if and
only if individuals a    a            ak with    k  m exist such that b a     a  r ai   ai      a
for each    i   k  and a ak    a  now assume that k  n  since rk  ft in   we have
ft in  a    a a    and thus a   cert q  ft in   a   in contrast  assume that k   n  since
rz   ft in   we have ft in  a    z akn     since rz   ft in   we have ft in  a    z ai  
for each    i  k  n     finally  since rz   ft in   we have ft in  a    a a     but then 
a   cert q  ft in   a   as required 
as a corollary to theorem       we next show that testing abstract reasoners in cft
cannot be done in general using q simple test suites 
corollary       for q    a x   b x   q x   and t    r a  a   no q simple t test suite exists that is exhaustive for q and the class of all sound  monotonic  strongly
faithful  and first order reproducible abstract reasoners applicable to t  
proof  if s is a q simple t  test suite that is exhaustive for q and the class mentioned in
the theorem  by proposition      each abstract reasoner ans from the class that does not
pass s is not  q  t   complete  which contradicts theorem      
   

ficompleteness guarantees for incomplete ontology reasoners

theorem      eectively says that  if an abstract reasoner ans  cft does not pass a t test suite s  we cannot conclude that ans is not  q  t   complete  please note that this holds
only if ans fails a test of the form a  y where q  
 y  if q   y  then a is a counterexample
to  q  t   completeness of ans  thus  s may show ans to be not  q  t   complete  but it is
not guaranteed to do so  this is illustrated by the following example 
example       let q    a x   b x   q x   and let t    r a  a  r c  c   furthermore  let s     sq  be the general test suite defined as follows 
sq    

   a c    
  a x   b x   q x     
   r c  d   a d       a c   q    
   r c  d   c d       c c   q   
 

let r   rd     q where rd    r x  y   a y   a x   r x  y   c y   c x    clearly 
r is a rewriting q w r t  t   in section       we show how to compute s from r using a
variant of injective instantiation in a way that guarantees exhaustiveness for cft and q 
now let ans   cft be the abstract reasoner defined by ft     r x  y   a y   a x   
the reasoner does not pass s since cert  c c   q    ft     r c  d   c d      f  note  however  that the reasoner is  q  t   complete  thus  if a test suite is not q simple  passing
it is a sucient  but not a necessary condition for  q  t   completeness  in fact  note that
t contains the tbox for theorem       so by the theorem we cannot reduce s so that it
correctly identifies all reasoners in cft that are not  q  t   complete 
in practice  however  one can try to mitigate this fundamental theoretical limitation by
eliminating the irrelevant axioms from the rewriting r and thus increasing the likelihood of
obtaining a t  test suite that a  q  t   complete abstract reasoner will pass  for example 
using the techniques by cuenca grau  horrocks  kazakov  and sattler      a  we can
extract the module of r relevant to the query  in the example from the previous paragraph 
this would remove the rule r x  y   c y   c x  from r  and injective instantiation will
produce the test suite s     sq  where sq is defined as follows 
sq    

   a c    
  a x   b x   q x     
   r c  d   a d       a c   q   
 

abstract reasoner ans  from the previous paragraph now passes s and is thus guaranteed
to be  q  t   complete 
now let ans  be the abstract reasoner defined by ft     b x   r x  y   a y   a x   
clearly  abstract reasoner ans  is not  q  t   complete  so ans  does not pass sq   from the
latter  however  we cannot immediately conclude that s is not  q  t   complete  the test
that fails does not involve the original query q  as a possible remedy  we can try to unfold
r to a certain level and then injectively instantiate the result in hope of obtaining a t  test
suite that will identify ans  as not being  q  t   complete  in particular  the first unfolding
of r produces the following query 
b x   r x  y   a y   q x 

instantiating this rewriting produces the following test suite  which does not prove that
ans  is not  q  t   complete 
sq    

   b c   r c  d   a d       a x   b x   q x      
   

ficuenca grau  motik  stoilos   horrocks

another round of unfolding  however  produces the following query 
b x   r x  y   r y  z   a z   q x 
instantiating this query produces the following test suite 
s
q   

   b c   r c  d   r d  e   a e       a x   b x   q x      

now ans  does not pass s
q   so we can conclude that ans  is not  q  t   complete 



to better understand example       consider a first order reproducible abstract reasoner
ans  an arbitrary ucq q  and a tbox t such that r   rd     rq  is a datalog rewriting
of q w r t  t   datalog program rd  rq is equivalent to the  possibly infinite  ucq ruq
obtained from rd  rq via exhaustive unfolding  we now have the following possibilities 
first  assume that ans is not  q  t   complete  since rd  rq is equivalent to ruq   each
certain answer a to q w r t  t and an arbitrary abox a is produced by some r  ruq  
but then  the injective instantiation ar of r will provide us with the counterexample for
the  q  t   completeness of ans  thus  we can prove that ans is not  q  t   complete by
generating the elements of ruq in a fair manner  i e   without indefinitely delaying the
generation of some element of ruq   and checking whether cert q  t   ar    ans q  t   ar   
we are guaranteed to eventually encounter some r  ruq that invalidates this condition and
thus proves that ans is not  q  t   complete 
second  assume that ans is  q  t   complete  using the above approach  we will determine that cert q  t   ar    ans q  t   ar   holds for each r  ruq   now if ruq is finite  i e   if
the unfolding of rd  rq terminates   then ruq is the ucq rewriting of q w r t  t   so by
the results from section     we can conclude that ans is indeed  q  t   complete  if  however  ruq is infinite  then we will never obtain a sucient assurance for the  q  t   complete
of ans  in the following section we show a possible remedy to this problem 
      testing first order reproducible abstract reasoners
in this section  we show how to compute a t  test suite s   s   sq  exhaustive for cft
and q from a datalog  rewriting r   rd   r   rq  of q w r t  t   since first order
reproducible abstract reasoners are strongly faithful  we need to consider only injective
instantiations of r  thus  the rules in r and rq should be instantiated as in section     
a rule r  rd   however  is instantiated into a pair a  y  sq with a the abox obtained
by instantiating the body of r and y the boolean ucq obtained by instantiating the head
of r  intuitively  such tests allow us to check whether the  unknown  first order theory ft
that captures the behaviour of the abstract reasoner entails r 
definition       let q be a ucq with query predicate q  let t be an admissible tbox 
let r   rd   r   rq  be a datalog  rewriting of q w r t  t   and let  be a substitution
mapping each variable occurring in r into a distinct fresh individual  the injective instanr 
r 
tiation of r w r t   is the pair ir    ir 
is the smallest set of aboxes
   iq  where i
and ir 
is the smallest set of pairs of an abox and a ucq such that
q
 ar  ir 
for each r  r  

   

ficompleteness guarantees for incomplete ontology reasoners

 ar   q  ir 
for each r  rq such that cert   rd  r   ar     f  and
q
 ar   y  ir 
for each r  rd of the form     such that cert   rd  r   ar     f 
q
where y is the ucq y    i   x   yi    q      i  m  with the propositional query
predicate q  
ir  is clearly unique up to the renaming of the fresh individuals in   so  is typically left
r
implicit  and one talks of the injective instantiation ir   ir
   iq  of r 
example       consider the query q    a x   q x   and the el tbox t consisting of
the following axioms  whose translation into first order logic is shown after the  symbol 
r a  b



bc



ad 



r c  a



c  r d



x  y  r x  y   a y   b x  
x  y  r x  y   c y   a x  
x  b x   c x  

x  c x   y  r x  y   d y   
x  a x   d x    

then  r   rd   r   rq  as defined next is a datalog rewriting of q w r t  t  
rd     r x  y   a y   b x   r x  y   c y   a x   b x   c x   
r     a x   d x     

rq     a x   q x   

r
the injective instantiation ir   ir
   iq  of r is shown below 

ir
       a c   d c     

ir
  a x   q x     
q        a c    
   r c  d   a d       b c   q    
   r c  d   c d       a c   q    
   b c    
  c c   q   
 



we now show that the injective instantiation of a datalog  rewriting of q w r t  t is
a t  test suite exhaustive for cft and q 
theorem       let q be a ucq  let t be a tbox  let r   rd   r   rq  be a datalog 
r
r
rewriting of q w r t  t   and let ir   ir
   iq  be the injective instantiation of r  then  i
is a t  test suite that is exhaustive for cft and q 
proof  let  be the substitution that ir is obtained from  we first show that ir is a t  test
suite 
r
 consider an arbitrary a  ir
   then  a rule r  r exist such that a   a   clearly
cert    r   a    t  so cert   rd  r   a    t as well  since r is a datalog  rewriting of q w r t  t   we have that t  a is unsatisfiable  as required 

   

ficuenca grau  motik  stoilos   horrocks

 consider an arbitrary a  ir
q   then  cert   rd  r   a    f by definition      
 
since r is a datalog
rewriting of q w r t  t   we have that t  a is satisfiable  as
required 
to show that ir is exhaustive for cft and q  consider an arbitrary abstract reasoner
ans  cft that passes ir that is  ans satisfies the following two properties 
 a  ans   t   a     t for each a  ir
   and
 b  ans   t   a     f implies cert y  t   a    ans y  t   a   for each y  a   ir
q 
since ans is first order reproducible  a set of first order sentences ft exists such that  for
each abox a  we have
 ans   t   a    cert   ft   a   and
 if ans   t   a    f  then ans q  t   a    cert q  ft   a  
by the assumption on ft in definition      and the fact that  maps variables to fresh
individuals  we have rng    ind ft      
let r d and r d be the smallest sets of rules satisfying the following conditions for each
rule r  rd  
 cert   ft   ar     t implies r  r d   where r is obtained from r by replacing the head
with   and
 cert   ft   ar     f implies r  r d  
furthermore  let r q and r q be the sets of rules obtained from rq in an analogous way 
since r d  r d is obtained from rd by replacing some head formulae with   we clearly
have r d  r d    rd   analogously  we have r q  r q    rq  

we next show that ft    r   the latter holds if and only if ft    r for each rule r  r  
consider an arbitrary rule r  r   note that head r      then  by definition      we have
r
r
ar  ir
   by  a  we have ans   t   a     t  by definition      we have cert   ft   a     t
and hence ft  ar      finally  since rng    ind ft       by proposition     we have
ft    r  as required 
we next show that ft    r d   the latter holds if and only if ft    r for each rule r  r d  
consider an arbitrary rule r  r d   note that head r      then  by the definition of r d
we have cert   ft   ar     t and hence ft  ar      finally  since rng    ind ft       by
proposition     we have ft    r  as required 
in a completely analogous way as in the previous paragraph  it is possible to show that
ft    r q  
we next show that ft    r d   the latter holds if and only if ft    r for each rule
r  r d   consider an arbitrary rule r  r d of the form      by the definition of r d we have
cert   ft   ar     f  so by definition      we have ans   t   ar     f  then  by definition
     we have ar   y  ir
x   yi    q     i  m   note
q where y is the ucq y    i   
that t    r by definition      so by proposition     we have that t  ar    m
x   yi   
i   i   
by the definition of y and the fact that q does not occur in t   we have y  t  ar    q  
   

ficompleteness guarantees for incomplete ontology reasoners

but then  cert y  t   ar     t  the latter observation  ans   t   ar     f  and  b  then imply
ans y  t   ar     t  so by definition      we have cert y  ft   ar     t  since q occurs only

in y  note that each predicate occurring
m in ft but not in t is private to ft   so q cannot
r
occur in ft    we have ft  a    i   i   x   yi    finally  since rng    ind ft       by
proposition     we have ft    r  as required 
we next show that q  ft    r q   the latter holds if and only if q  ft    r for each
rule r  r q   consider an arbitrary rule r  r q   note that head r  is an atom with predicate
q  and that by the definition of r q we have cert   ft   ar     f  so by definition      we
have ans   t   ar     f  furthermore  by definition       we have cert   rd  r   ar     f 
let a be the tuple of the arguments in  head r    then  by definition      we have
ar   q  ir
a  cert  r     ar    but then we have a  cert rq   rd  r   ar  
q   clearly  
by the monotonicity of first order logic  since r is a rewriting of q w r t  t   by definition     we have a  cert q  t   ar    the latter observation  ans   t   ar     f  and  b 
then imply a  ans q  t   ar    by definition      we have a  cert q  ft   ar    hence 
ft  ar    q a   finally  since we have rng    ind ft       by proposition     we have
ft    r  as required 
the following table summarises the entailment relationships between various first order
theories obtained thus far 
ft    r
q  ft    r q

ft    r d
r q  r q    rq

ft    r d
r d  r d    rd

ft    r q

clearly  this implies the following entailments 
ft    rd  r

q  ft    rd  r  rq

we now complete the proof of this theorem and show that ans is  q  t   complete  to
this end  consider an arbitrary abox a  we have the following possibilities  depending on
the satisfiability of t  a 
 assume that t  a is unsatisfiable  then cert   rd  r   a    t by definition
     by the above mentioned entailments  we have cert   ft   a    t  consequently 
ans   t   a    t by definition       as required 
 assume that t  a is satisfiable and ans   t   a    f  and consider an arbitrary tuple
a  cert q  t   a   then  cert   rd  r   a    f and a  cert rq   rd  r   a  by
definition      by the above mentioned entailments  we have a  cert q  ft   a  
hence  a  ans q  t   a  by definition       as required 
note that the size of the test suite obtained by theorem      is linear in the size of the
rewriting  which  we believe  makes our approach suitable for use in practice 
      testing ground queries
as shown in section        if an abstract reasoner ans  cft does not pass a t  test suite s
that is not q simple  we cannot always conclude that ans is not  q  t   complete  from a
practical point of view  it would be highly beneficial to identify situations where not passing
s would show that ans is indeed incomplete for q and t   furthermore  in applications where
   

ficuenca grau  motik  stoilos   horrocks

prototypical queries are not known at design time  we would like to design completeness
tests that are query independentthat is  which test an abstract reasoner for completeness
w r t  t regardless of the input data and query  in this section  we show that we can
achieve these two goals by focusing on ground queries  this restriction is not unreasonable
in practice  since any sparql query can be equivalently expressed as a ground ucq 
we first define a query independent notion of exhaustiveness of a test suite 
definition       let t be a tbox  let s be a t  test suite  and let c be a class of abstract
reasoners applicable to t   then  s is exhaustive for c and all ground ucqs if each ans  c
that passes s is  q  t   complete for each ground ucq q 
then  we define the notion of a ground rewriting of t a rewriting that captures all
query answers w r t  t   regardless of the input ground query and aboxand we show how
to instantiate such ground rewritings 

definition       a ground rewriting of a tbox t is a pair r   rd   r  such that  for
each ground ucq q  the triple rd   r   q is a datalog rewriting of t w r t  q  an

injective instantiation ir of such r is defined as ir   ir for r   rd   r    
note that definition      implies that each variable occurring in the head of a rule
in r also occurs in the rule body  tools such as requiem and kaon  can easily be
adapted to compute a ground rewriting of a tbox t in practice  we next show that
injective instantiation of a ground rewriting of t yields a t  test suite that provides us with
sucient and necessary check for completeness w r t  all ground ucqs 

theorem       let t be a tbox  and let r   rd   r  be a ground rewriting of t  
then  the following two claims hold 
   ir is exhaustive for cft and all ground ucqs 
   each abstract reasoner ans  cft that does not pass ir is not  q  t   complete for some
ground ucq q 

proof   property    consider an arbitrary abstract reasoner ans  cft that passes ir   let
ft be the first order theory that characterises the behaviour of ans  as in the proof of
theorem       the fact that ans passes ir implies ft    rd  r   furthermore  consider
an arbitrary ground ucq q and an arbitrary abox a  that ans is  q  t   complete can
be shown as in the proof of theorem       with the minor dierence that a  cert q  t   a 
implies a  cert q  rd  r   a  by definition      
 property    note that  since r is a ground rewriting of t   by definition      all ucqs
in ir are ground  thus  if some abstract reasoner ans  cft does not pass ir   this clearly
shows that ans is not  q  t   complete for some ground ucq q 

   comparing incomplete abstract reasoners
in this section  we investigate techniques that  given a query q and a tbox t   allow us to
determine whether an abstract reasoner ans  is more complete than an abstract reasoner
ans  that is  whether for all aboxes a  abstract reasoner ans  computes more answers to
q and t than abstract reasoner ans    this idea is formalised by the following definition 
   

ficompleteness guarantees for incomplete ontology reasoners

definition      let q be a ucq  let t be a tbox  and let ans  and ans  be abstract
reasoners applicable to t   then  ans  q t ans  if the following conditions hold for each
abox a 
   cert   t   a    t and ans     t   a    t imply ans     t   a    t  and
   cert   t   a    f  ans     t   a    f  and ans     t   a    f imply
ans   q  t   a   cert q  t   a   ans   q  t   a   cert q  t   a  
furthermore  ans   q t ans  if ans  q t ans  and an abox a exists such that at least one
of the following two conditions holds 
   cert   t   a    t  ans     t   a    f  and ans     t   a    t  or
   cert   t   a    f  ans     t   a    f  ans     t   a    f  and
ans   q  t   a   cert q  t   a   ans   q  t   a   cert q  t   a  
example      consider the abstract reasoners rdf  rdfs  rl  and classify introduced in example     and the query q and tbox t from example       we clearly have the following 
rdf q t rdfs q t rl q t classify
furthermore  for any two of these abstract reasoners  an abox exists that distinguishes the
abstracts reasoners w r t  q and t   for example  for abox a    takesco c  d   mathsco d   
we have rdfs q  t   a      and rl q  t   a      c   as a result  we also have the following 
rdf  q t rdfs  q t rl  q t classify



we would like to check whether ans  q t ans  and ans   q t ans  for any given pair
of abstract reasoners by subjecting the reasoners to a finite set of tests  towards this goal 
r
we next define the relations r
q t and  q t that compare abstract reasoners w r t  a given
finite set r of aboxes  ideally  given q and t   we would like to compute a finite r such
r
that r
q t and  q t coincide with q t and  q t on all abstract reasoners from a class c
of interest  these ideas are captured by the following definitions 
definition      let q be a ucq  let t be a tbox  let r be a finite set of aboxes  and let
ans  and ans  be abstract reasoners applicable to t  
then  ans  r
q t ans  if conditions   and   from definition     hold for each abox
r
a  r  furthermore  ans   r
q t ans  if ans  q t ans  and either condition   or condition
  from definition     holds for some abox a  r 
definition      let q be a ucq  let t be a tbox  and let c be a class of abstract reasoners
applicable to t   a finite set r of aboxes is  q  t   representative for c if the following
conditions hold for all ans    ans   c 
   ans  r
q t ans  if and only if ans  q t ans    and
   

ficuenca grau  motik  stoilos   horrocks

   ans   r
q t ans  if and only if ans   q t ans   
as we show next  to prove that r is  q  t   representative  it suces to show the only
if implication in condition   and the if implication in condition   from definition     
proposition      let q be a ucq  let t be a tbox  let c be a class of abstract reasoners
applicable to t   and let r be a finite set of aboxes such that
   ans  r
q t ans  implies ans  q t ans    and
   ans   q t ans  implies ans   r
q t ans   
then  r is  q  t   representative for c 
proof  note that ans  q t ans  trivially implies ans  r
q t ans    thus  condition   of this
proposition clearly implies condition   of definition      furthermore  if some abox a  r
satisfies condition   or   of definition      condition   or   of definition     holds as well 
consequently  conditions   and   of this proposition imply condition   of definition     
an obvious question is whether a q simple t  test suite that is exhaustive for a class
c and q is also  q  t   representative for c  the following example shows that this is not
necessarily the case 
example      let q and t be as specified in example       and let r    a            a    for
the aboxes as specified in example       as shown in section    the q simple t  test suite
s   s   sq  with s    a    and sq    a            a    is exhaustive for cwq t and q 
let trivial be the abstract reasoner that returns the empty set on each input  and consider also the rdf based abstract reasoner rdf from example      which ignores the tbox
and evaluates the query directly against the abox  clearly  trivial q t rdf  furthermore 
trivial  q t rdf since for a    st c   takesco c  d   mathco d   we have rdf q  t   a     c 
whereas trivial q  t   a      both abstract reasoners  however  return the empty set of
answers for all aboxes in r and thus rdf r
q t trivial  hence  by using r we cannot
dierentiate the two abstract reasoners 

    negative result
the following strong result shows that  for numerous tboxes t   no finite set of aboxes
exists that can dierentiate two arbitrary abstract reasoners from the class of all sound 
first order reproducible  monotonic  and strongly faithful reasoners  note that this result is
stronger than the negative result in theorem       as it applies to a smaller class of abstract
reasoners and all tboxes that imply at least one concept subsumption 
theorem      let t be an arbitrary tbox mentioning an atomic role r and atomic
concepts a and b such that t    a  b  and let q    b x   q x    then  no finite set
of aboxes exists that is  q  t   representative for the class of all sound  monotonic  strongly
faithful  and first order reproducible abstract reasoners applicable to t  
   

ficompleteness guarantees for incomplete ontology reasoners

proof  assume that a finite set of aboxes r exists that is  q  t   representative for the class
of all sound  monotonic  strongly faithful  and first order reproducible abstract reasoners
applicable to t   let n be the maximum number of assertions in an abox in r 
for an arbitrary integer k     let ansk be the first order reproducible abstract reasoner
that  given an fol tbox tin   uses the following datalog program ftkin  
ftkin

 




if tin     a  b
a x     r x    x            r xk    xk    b x    if tin    a  b

clearly  each ansk is sound  monotonic  and strongly faithful  furthermore  ansk    t   a    f
for each abox a  we next show that ansn    q  t   a   ansn    q  t   a  for each abox
a  r  consider an arbitrary a   ansn    q  t   a   then  individuals a    a            an   exist
such that r a    a    a for each      n      since a contains at most n assertions
but the rule in ftn   contains n     body atoms  we have ai   aj for some i   jthat is 
a contains an r cycle  but then  the rule in ftn   can be matched to a by mapping x  to
a    so a   ansn    q  t   a   therefore  we have ansn   r
q t ansn    
for a    a a     r a    a             r an   an       however  we have a   ansn    q  t   a  and
ansn    q  t   a      thus  ansn   q t ansn   does not hold  which contradicts our assumption that r is exhaustive for the class of abstract reasoners from this theorem 
    compact abstract reasoners
theorem     suggests that we need to make additional assumptions on the abstract reasoners that we wish to compare using a finite set of aboxes  in this section  we show that
representative sets of aboxes can be computed in practice if we further restrict ourselves
to abstract reasoners that we call  q  t   compact  intuitively  such an abstract reasoner
processes q  t   and a by computing all certain answers of q  a  and some subset t  of
t   where the subset depends only on t and q  in other words  the behaviour of compact
abstract reasoners can be simulated by the following process  select the subset of axioms
in the input tbox that can be processed  and then compute all certain answers w r t  the
selected fragment of the tbox  the class of  q  t   compact abstract reasoners thus captures the properties of concrete reasoners such as jena or oracles semantic data store that
discard axioms from the input tbox that fall outside a certain fragment  e g   existential
restrictions on the right hand of implications  and then encode the remaining axioms into
a suitable set of rules 
definition      let q be a ucq  and let t be a tbox  an abstract reasoner ans applicable
to t is  q  t   compact if a tbox t   t exists such that the following properties hold for
each abox a 
   cert   t    a    t implies ans   t   a    t 
   cert   t    a    f implies ans   t   a    f and ans q  t   a    cert q  t    a  
abstract reasoner ans is compact if it is  q  t   compact for each ucq q and each tbox
t to which ans is applicable  finally  ccq t is the class of all  q  t   compact and strongly
 q  t   faithful abstract reasoners applicable to t  
   

ficuenca grau  motik  stoilos   horrocks

example      all abstract reasoners defined in example     are  q  t   compact for the
query q and el tbox t from example       indeed  for abstract reasoner rdf the subset
t  of t is given by t      for abstract reasoner rdfs it is t           for abstract reasoner
rl it is t                      and for abstract reasoner classify it is t    t  

the abstract reasoners ansk defined in the proof of of theorem     are not  q  t  compact for the query and the tboxes to which theorem     applies 

proposition       let q    b x   q x   and let t    a  b  c  r    then  for
each k     abstract reasoner ansk from the proof of theorem     is not  q  t   compact 
proof  let q and t be as stated in the theorem and consider an arbitrary k     let a 
and a  be aboxes defined as follows 
a     a a    

a     a a     r a    a             r ak    ak   

clearly  we have the following 
ansk  q  t   a      

ansk  q  t   a       a   

one can straightforwardly check  however  that the following holds for each t  with t   t  
cert q  t    a      cert q  t    a   
thus  ansk is not  q  t   compact 
thus  the negative result from theorem     does not immediately apply to a class
containing only compact abstract reasoners 
    comparing compact abstract reasoners
in this section  we show that a set of aboxes that is  q  t   representative for ccq t can be
obtained by computing  for each subset t  of t   a q simple t   test suite that is exhaustive

for csq t   a minor complication arises due to the fact that t  can contain fewer individuals

than t   to deal with such cases correctly  the aboxes in st are not allowed to contain

individuals occurring in t but not in t    and the aboxes in stq are not allowed to contain
individuals occurring in t but not in q  t    this assumption is without loss of generality 

given a  q  t    test suite st   one can replace all individuals in t but not in q  t  with

fresh individuals  the result of such replacement is a  q  t    test suite exhaustive for csq t  
theorem       let q be a ucq  and let t be a tbox  furthermore  for each t   t   let




st   st   stq  be a q simple t   test suite that is exhaustive for csq t and q such that


no abox in st contains an individual from ind t     ind t    and no abox in stq contains
an individual from ind t     ind q  t     then  the set r of aboxes defined by



r 
st  stq
t  t

is  q  t   representative for ccq t  
   

ficompleteness guarantees for incomplete ontology reasoners

proof  assume that r satisfies the conditions of the theorem  and let ans  and ans  be
arbitrary abstract reasoners in ccq t   we next show that ans  and ans  satisfy the two
properties in proposition     
 property   of proposition     

ans  r
q t ans  implies ans  q t ans 

 property   of proposition     

ans   q t ans  implies ans   r
q t ans 

since ans  is  q  t   compact  a tbox t   t exists that satisfies the conditions of
definition      assume that ans  r
q t ans    we next show that conditions   and   of
definition     are satisfied for an arbitrary abox a 
 condition    assume that cert   t   a    t and ans     t   a    t  by the contrapositive of property   of definition      then cert   t    a    t  since r contains all the aboxes

of some q simple t   test suite that is exhaustive for csq t and q  by theorem      there
exist an abox a  r and a t   stable renaming  such that dom     ind t   a   and
 a    a  since a does not contain individuals from ind t     ind t     renaming  is also
t  stable  by the definition of a t   test suite  cert   t    a     t  furthermore  by property  

of definition     we have ans     t   a     t  since ans  r
q t ans  we have ans     t   a     t 

since ans  is strongly  q  t   faithful and  is t  stable  we have ans     t    a      t  finally  since  a    a and ans  is  q  t   monotonic  we have ans     t   a    t  as required 
 condition    assume that cert   t   a    f  ans     t   a    f  and ans     t   a    f 
and consider an arbitrary tuple a  ans q  t   a   cert q  t   a   by the contrapositive
of property   of definition      then cert   t    a    f  but then  by property   of definition      we have a  cert q  t    a   since r contains all the aboxes of some q
simple t   test suite that is exhaustive for csq t and q  by theorem      there exist
an abox a  r  a tuple b  cert q  t    a    and a  q  t    stable renaming  such that
dom     ind q  t   a     a    a  and  b    a  since a does not contain individuals from ind t     ind q  t     renaming  is also  q  t   stable  by the definition of a
 q  t    test suite  cert   t    a     f  furthermore  by property   of definition     we have
b  ans   q  t   a    since ans  r ans  we have b  ans   q  t   a    since ans  is strongly
q t
 q  t   faithful and  is  q  t   stable  we have that a  ans   q  t    a     finally  since
 a    a and ans  is  q  t   monotonic  we have a  ans   q  t   a   as required 
assume that ans   q t ans    by definition      then ans  q t ans  and an abox
a exists satisfying conditions   and   of definition      clearly  ans  r
q t ans    hence 
what remains to be shown is that r contains an abox that satisfies conditions   and  
of definition      since ans  is  q  t   compact  a tbox t   t exists that satisfies the
conditions of definition     
 condition    assume that cert   t   a    t  and assume also that ans     t   a    t
and ans     t   a    f  as in the proof of condition    we can identify an abox a  r and
a t  stable renaming  such that ans     t   a     t and  a    a  since ans  is  q  t  monotonic and ans     t   a    f  we have ans     t    a      f  furthermore  since ans 
is strongly  q  t   faithful and  is t  stable  we also have ans     t   a     f  but then 
condition   of definition     is satisfied for a  r 
 condition    assume that cert   t   a    f and ans     t   a    ans     t   a    f  and
consider an arbitrary tuple a   ans   q  t   a   cert q  t   a     ans   q  t   a   as in the
proof of condition    we can identify an abox a  r  a  q  t   stable renaming   and a
   

ficuenca grau  motik  stoilos   horrocks

tuple b  cert q  t    a   such that  a    a   b    a  and b  ans   q  t   a    since ans  is
 q  t   monotonic and a  ans   q  t   a   we have a  ans   q  t    a     furthermore  since
ans  is strongly  q  t   faithful and  is  q  t   stable  we also have b  ans   q  t   a    but
then  condition   of definition     is satisfied for a  r 
theorems      and      immediately suggest an approach for computing a set of aboxes
that is a  q  t   representative for ccq t   first  we compute a ucq rewriting of q w r t 
each subset of t   then  we instantiate each rule in each such rewriting using an injective
instantiation mapping  finally  we compute r as a union of all aboxes in all test suites 
such a nave procedure  however  is not practical since it requires computing an exponential
number of ucq rewritings  we next present a more practical approach to computing a
set of aboxes that is  q  t   representative for ccq t   intuitively  instead of computing
exponentially many rewritings  one can compute a single ucq rewriting of q w r t  t that
is subset closed that is  which contains a rewriting for each subset of t  
definition       a ucq rewriting r   r   rq  of q w r t  t is subset closed if for
each t   t a tuple r   r   rq  exists such that r  r   rq  rq and r is a
ucq rewriting of q w r t  t   
the following corollary is an immediate consequence of theorems             and      

corollary       let q be a ucq  let t be a tbox  let r be a subset closed ucq rewriting
r
of q w r t  t   and let ir   ir
   iq  be the injective instantiation of r  then  the set of
q t
r
aboxes r   ir
 
  iq is  q  t   representative for cc

practical query rewriting systems such as requiem are optimised to produce as small
a ucq rewriting as possible  so their output is typically not subset closed  therefore 
our technique requires the modification of ucq rewriting algorithms implemented in existing systems  as illustrated by the following example  the required modification typically
involves disabling  at least partially  subsumption based optimisations 
example       let q and t be as specified in example       and let s   s   sq  be
the t  test suite from example       a system such as requiem can compute such r
for the given q and t   note  however  that r is not subset closed  for example  a ucq
rewriting of q w r t  t     is q  and it is not a subset of rq   the rewriting can be made
subset closed by extending rq with the following rules 
st x   takesco x  y   mathco x  y   q x 
st x   takesco x  y   calcco x  y   q x 
mathst x   st x   q x 

systems such as requiem  however  typically discard such rules by applying subsumption
optimisations described in section       

as the following example shows  a subset closed ucq rewriting of q w r t  t can  in
the worst case  be exponentially larger than the minimal ucq rewritings of q w r t  t  
example       let q    c x   q x    and let t be the following tbox 
t    b  ai      i  n    a          an  c 
   

ficompleteness guarantees for incomplete ontology reasoners

furthermore  let r   r   rq  be such that r    and rq contains the following rules 
c x   q x 

b x   q x 

a   x          an  x   q x 
clearly  r is a ucq rewriting of q w r t  t   however  the number of rules in a subset closed
ucq rewriting of q w r t  t is exponential in n 


   evaluation
we implemented our techniques for computing exhaustive test suites and for comparing incomplete concrete reasoners in a prototype tool called sygenia   our tool uses requiem
for computing ucq and datalog rewritings  
we considered two evaluation scenarios  the first one uses the well known lehigh
university benchmark  lubm   guo et al          which consists of a relatively small
tbox about an academic domain     test queries  and a data generator  the second one
uses a small version of galen  rector   rogers       a complex ontology commonly
used in medical applications 
we evaluated the following concrete reasoners  sesame v    prl   dle jena v     
owlim v        minerva v      and jena v       in all of its three variants  micro  mini 
and max  
    computing exhaustive test suites
given a ucq q and a tbox t   our tool uses requiem to compute a datalog rewriting
r for q and t   if r is a ucq rewriting  then our tool computes a simple test suite by
either full or injective instantiation  see sections     and      respectively   otherwise  the
tool computes a non simple test suite by instantiating r as described in section       
      simple test suites
in the case of the lubm benchmark  each of the    test queries leads to a ucq rewriting w r t  the tbox   therefore  we computed a ucq rewriting for each query q in the
benchmark using requiem and instantiated it  both fully and injectively  thus obtaining
q simple t  test suites that are exhaustive for q and cwq t and csq t   respectively  the
times needed to compute the test suites and the size of each test suite are shown in table
   where s denotes the total number of aboxes in the corresponding test suites 
  
  
  
  
  
  
  
  

http   code google com p sygenia 
http   www cs ox ac uk projects requiem home html
http   www openrdf org 
http   lpis csd auth gr systems dle jena 
http   www ontotext com owlim 
http   www alphaworks ibm com tech semanticstk
http   jena sourceforge net 
since requiem does not currently support individuals in the queries  we replaced the individuals in
queries by distinguished variables 

   

ficuenca grau  motik  stoilos   horrocks

q t
cw

csq t

q 
time    
s
 
time    
s
 

q  q  q  q  q  q  q  q  q   q   q   q   q  
                       
 
                         
                                     
     
 
                                                     
 
 
  
        
  
     
 
 
 
 

table    computation of simple test suites for lubm  times are given in seconds 

q t
cw

csq t

time
s
time
s

q 
  
     
   
  

q 
  
      
 
   

q 
  
      
  
   

q 
   
  
   
  

table    computation of simple test suites for galen  times are given in seconds 
as shown in the table  simple test suites could be computed in times ranging from     
to   seconds  both for cwq t and csq t   the optimisations implemented in requiem ensure
that the ucq rewritings are relatively small  so the resulting test suites also consist of a
relatively small number of aboxes  notice  however  the significant dierence between the
numbers of aboxes in test suites obtained via injective instantiation  which range from  
to     with an average of      and those obtained via full instantiation  which range from
  to        with an average of       furthermore  each rule in a rewriting contains at most
  atoms  therefore each abox in a test suite also contains at most   assertions 
in the case of galen  we used the following sample queries  for which requiem can
compute a ucq rewriting 
q 
q 
q 
q 

 
 
 
 

haemoglobinconcentrationprocedure x   q x 
plateletcountprocedure x   q x 
lymphocytecountprocedure x   q x 
hollowstructure x   q x 

we instantiated each ucq rewriting both fully and injectively  the times needed to compute the test suites and the size of each test suite are shown in table   
as shown in the table  simple test suites for galen can be computed in times ranging
from     to    seconds with an average of    seconds  thus  computing test suites for
galen is more time consuming than for lubm  this is unsurprising since the tbox of
galen is significantly more complex than that of lubm  the number of aboxes in the
test suites ranged from    to     in the case of injective instantiations and from    to over
        in the case of full instantiations  again  note the significant dierence between the
sizes of the two kinds of test suites  in all cases  however  each individual abox was very
small  with the largest one containing only    assertions 
      non simple test suites
we also computed non simple test suites for cases where no ucq rewriting exists  as
already mentioned  all lubm queries are ucq rewritable  therefore  we manually added
the following query  for which requiem computes a recursive datalog rewriting 
   

ficompleteness guarantees for incomplete ontology reasoners

time  s 
s

cft

lubm
q  
   
  

q 
   
  

galen
q  q 
       
  
  

q 
   
  

table    general test suites computed from datalog rewritings for lubm and galen 
system
completeness guarantee completeness w r t  lubm data set
jenamax dle jena
q  q  
q  q  
owlim
q  q    q    q    q   q  
q  q  
jena mini micro
q  q    q    q    q   q  
q  q  
minerva
q  q    q    q  
q  q  
sesame
q    q    q     q  
q  q    q     q  

table    completeness guarantees for ucq rewritable queries in lubm
q    

organization x   q x 

due to the complex structure of the galen tbox  test queries that are not ucq rewritable
can be easily identified  we have evaluated the following four 
q 
q 
q 
q 

 
 
 
 

westergrenesrprocedure x   q x 
arthroscopicprocedure x   q x 
truecavity x   q x 
bacterialcellwall x   q x 

times needed to compute test suites and the size of each test suite are shown in table   
    completeness guarantees
as already discussed  existing concrete reasoners are captured by strongly  q  t   faithful
abstract reasoners  hence  in order to establish completeness guarantees for such concrete
reasoners  we restricted our tests to test suites computed using injective instantiations 
      results for simple test suites
our results for the original queries of the lubm benchmark are shown in table    for
each concrete reasoner  the first column of the table shows the queries for which we were
able to prove completeness using our techniques  i e   the queries that are complete for
an arbitrary data set   and the second column of the table shows the queries on which the
concrete reasoner computes all answers on the canonical lubm data set with one university 
our results clearly show that completeness w r t  the data set in the lubm benchmark is
no guarantee of completeness for arbitrary data sets  for example  owlim  minerva  and
jena mini micro are complete for all queries w r t  the lubm data set  and some of these
systems are even complete for the more expressive uobm benchmark   however  for certain
queries  these systems were found to be incomplete for a data set in our test suites 
jena max and dle jena are the only systems that are guaranteed to be complete for
all    lubm queries regardless of the data setthat is  these systems behave exactly like a
complete owl reasoner for all lubm queries and the lubm tbox  according to jenas
   

ficuenca grau  motik  stoilos   horrocks

documentation  jena max supports all types of axioms used in the lubm tbox  hence it
is expected to be complete for the lubm tbox and queries  interestingly  when tested
with some of the lubm data sets  jena max could not compute the answers to many of
the queries  so we used smaller lubm data sets instead  this demonstrates an additional
advantage of our approach  it does not require reasoning w r t  very large data sets  since the
aboxes in test suites typically contain only a small number of assertions  regarding dlejena  according to its technical description  meditskos   bassiliades         the system
uses a complete dl reasoner to materialise certain subsumptions in a preprocessing step
and then uses jena to saturate the abox  much like the abstract reasoner classify from
example      hence  dle jena is at least as complete as jena mini and  in addition  it is
able to draw the inferences that jena mini is missing  see below  
owlim is complete for all lubm queries that do not involve reasoning with existential
quantifiers in the consequent of implications  it is well known that the latter is not supported
by the system  jena mini and micro exhibited exactly the same behaviour as owlim 
despite the fact that jena mini can handle a larger fragment of owl than owlim  clearly 
the lubm tbox and queries are not suciently complex to reveal the dierences between
owlim  and jena mini micro 
minerva is guaranteed to be complete for only six queries  like dle jena  it uses a
dl reasoner to materialise entailed subsumptions between atomic concepts  but it uses a
custom method for saturating the abox  after investigating several aboxes from the test
suites we concluded that minerva cannot correctly handle  at least  inverse role axioms  for
example  it cannot find the entailment   r  r   r a  b       r b  a  
finally  sesame is complete for only four queries  this is unsurprising since sesame is
an rdfs reasoner and is thus complete only for a small fragment of owl   dl 
we next discuss the results of tests based on the galen ontology and test queries
q  q    we could not run jena max since galen heavily uses existential restrictions 
which  according to jenas documentation  might cause problems  minerva was the only
system that provided completeness guarantee for at least one query  q     this is because
minerva precomputes subsumption relationships between atomic concepts that depend on
existential restrictions on the right hand side of tbox axioms  which most other systems
do not handle  also  unlike lubm  the version of galen that we used does not contain
inverse roles  so minerva performed much better on this ontology  all other systems were
identified as being incomplete for all test queries 
      results for non simple test suites
results for test queries that are not ucq rewritable are summarised in table    symbol
 indicates that the concrete reasoner was found complete for the given query  furthermore  whenever a concrete reasoner failed a test suite  we tried to prove the reasoner to be
incomplete as discussed in the examples in section        in all cases we were successful 
so symbol  indicates that the concrete reasoner was identified as being incomplete for a
given query  finally  symbol  indicates that the concrete reasoner ran out of memory 
in the case of lubm  we were able to establish completeness guarantees w r t  query
q   for owlim  jena micro  dle jena  and jena max  note that all these systems
can handle recursive tbox statements  so completeness for q   is not surprising  rdfs 
   

ficompleteness guarantees for incomplete ontology reasoners

owlim
jena max
jena micro
dle jena
minerva
sesame

lubm
q  







q 






galen
q  q 











q 






table    completeness guarantees for datalog rewritable queries

csq t

q  q  q  q  q  q  q  q  q  q   q   q   q   q  
time                                                        
r
                                   
        

table    representative sets of aboxes for lubm  times are given in seconds 
however  cannot express recursive tbox statements involving roles  so sesamean rdfs
reasonerfails to compute certain answers to some tests 
in the case of galen  completeness is guaranteed on query q  for owlim  jena micro 
dle jena  and minerva  and additionally on query q  for minerva  as already mentioned 
answers to queries on galen depend on positive occurrences of existential restrictions in
axioms  which most systems cannot handle  we could not run jena max on galen 
    comparing incomplete concrete reasoners
we also implemented the techniques for comparing reasoners from section      to this end 
we modified requiem to compute subset closed rewritings  which are then injectively
instantiated to obtain a  q  t   representative sets of aboxes r 
      tests with lubm
as shown in table    representative sets of aboxes could be computed in just a few seconds
for most lubm queries  the only exception was q    for which requiem did not terminate
after disabling rule subsumption optimisations  the size of the representative sets ranged
between   and     aboxes  as expected  representative sets contain more aboxes than the
exhaustive test suites for the same query and tbox  see table    
all combinations of system and query for which the tests in section     identified the
system as incomplete are shown in table    the table shows the proportion of certain
answers that each system returned when applied to the lubm data set  the aboxes in r 
and the aboxes in the test suite s used in section     to check the systems completeness 
as shown in the table  owlim and jena micro exhibited the same behaviour and were
almost complete  in contrast  sesame was the least complete for all queries  furthermore 
please note the dierence between the values obtained for r and those for s  in particular 
sesame did not compute any certain answer for q  on s  whereas the system is able to
compute certain answers for q  on some aboxes  e g   on the lubm data set   this is
because the aboxes in s cannot distinguish sesame from a trivial reasoner that always
returns the empty set of answers  however  the set r can make such a distinction 
   

ficuenca grau  motik  stoilos   horrocks

lubm
s
r

q 
 
    
   

q 
 
    
    

lubm
s
r

q 
 
    
    

q 
 
    
    

minerva
q 
q  
q  
 
 
 
              
              
sesame
q 
q 
q 
q 
 
              
 
               
                     
q 
 
    
    

q  
 
   
    

owlim   jmicro
q 
q 
q  
 
 
 
    
    
    
    
    
    

q 
    
 
 

q  
    
     
     

q  
 
    
     

q  
 
   
    

table    reasoner comparison for lubm

csq t

time
r

q 
  
   

q 
  
   

q 
  
   

q 
 
   

table     representative sets of aboxes for galen
      tests with galen
as shown in table     representative sets of aboxes for galen could be computed in
times ranging from   to    seconds  and each set contains only a small number of aboxes 
for each system and query  table    shows the proportion of certain answers returned
by the system on r and the test suite s from section      minerva was the most complete
system  jena micro was better than dle jena  apart from query q     while dle jena
and owlim behaved in almost the same way  again apart from query q     as expected 
sesame was the least complete system 
the discrepancies between owlim  jena micro  dle jena and minerva are rather
surprising  owlim and jena theoretically support the same features of owl  furthermore 
dle jena is an extension of jena  meditskos   bassiliades        so dle jena should be
at least as complete as jena  as in the case of lubm  in order to explain these discrepancies 
we analysed the test suites for queries q  q    more precisely  we selected aboxes on which
owlim fails to return all certain answers but on which jena micro is complete  and then
we identified the minimal set of tbox axioms that entail all certain answers  our analysis
revealed that  for query q    owlim fails to find the entailment
t   device a   hollowtopology b   hastopology a  b      hollowstructure a  

which follows from the following galen axioms 

hollowtopology  topology  hasstate hollow
device  solidstructure

hollowstructure  solidstructure  hastopology  topology  hasstate hollow 

although existential restrictions appear in several axioms  we can observe that no reasoning
over existential variables is actually required  as the first and third axioms imply  by a simple
structural transformation  the following axiom 
solidstructure  hastopology hollowtopology  hollowstructure
   

ficompleteness guarantees for incomplete ontology reasoners

sesame
owlim
dle jena
jmicro
minerva

q 
s
r
         
         
         
         
         

q 
s
r
      
         
         
         
         

q 
s
r
      
         
         
         
         

q 
s
r
         
         
        
         
 
 

table     reasoner comparison on galen
this axiom entails the required answer  and both systems can deal with axioms of this form 
however  unlike jena micro  owlim appears to be incapable of dealing with such cases 
regarding dle jena  according to its technical description  meditskos   bassiliades 
       the system has replaced several inference rules of jena with queries to the dl reasoner  so it does not strictly extend jena  our investigation of the exhaustive test suite
for query q  revealed that dle jena returns many answers that are based on existential
restrictions on the right hand side of tbox axioms which jena misses  however  the investigation also revealed that dle jena misses several inferences that jenas tbox reasoner
can capture  which is probably due to the replacement of jenas inference rules  this also
explains why dle jena performs worse than minerva on galen 
these results clearly show that the behaviour of systems greatly depends on the given
application scenario  for example  dle jena was complete for all lubm queries  but
it did not perform equally well on galen  in contrast  minerva did not perform well on
lubm  but it was the most complete system for galen  our results thus allow application
developers to conduct a thorough comparison of reasoning systems for a given application 

   conclusion
in this paper we have proposed a theoretical framework and practical techniques for establishing formally provable and algorithmically verifiable completeness guarantees for incomplete ontology reasoners  our approach radically departs from ad hoc evaluation based on
well known benchmarks  and it provides a solid foundation for striking the balance between
scalability and completeness in practical applications 
our approach also opens up numerous and exciting possibilities for future research  for
example  our work opens the door to the design of ontology based information systems that
are optimised for a class of ontologies  queries  and data relevant to a particular application  such information systems could maximise scalability of reasoning while still ensuring
completeness of query answers  even for rich ontologies and sophisticated queries 

acknowledgments
this is an extended version of the paper how incomplete is your semantic web reasoner 
by giorgos stoilos  bernardo cuenca grau  and ian horrocks published at aaai     
and the paper completeness guarantees for incomplete reasoners by the same authors
published at iswc      
   

ficuenca grau  motik  stoilos   horrocks

this research has been supported by the eu project seals  fp  ict          and by
the epsrc projects exoda  ep h          and hermit  ep f           b  cuenca
grau is supported by a royal society university research fellowship 

references
acciarri  a   calvanese  d   de giacomo  g   lembo  d   lenzerini  m   palmieri  m    
rosati  r          quonto  querying ontologies  in proceedings of the   th national
conference on artificial intelligence  aaai       pp            aaai press   the
mit press 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          the dl lite family
and relations  j  artificial intelligence research  jair           
baader  f   mcguinness  d   nardi  d     patel schneider  p          the description logic
handbook  theory  implementation and applications  cambridge university press 
baader  f   brandt  s     lutz  c          pushing the el envelope  in proceedings of
the   th international joint conference on ai  ijcai      pp          morgankaufmann publishers 
bishop  b   kiryakov  a   ognyano  d   peikov  i   tashev  z     velkov  r         
owlim  a family of scalable semantic repositories  semantic web              
broekstra  j   kampman  a     van harmelen  f          sesame  a generic architecture for
storing and querying rdf and rdf schema  in proceedings of the  st international
semantic web conference  iswc        pp       
cal  a   gottlob  g   lukasiewicz  t   marnette  b     pieris  a          datalog     a
family of logical knowledge representation and query languages for new applications 
in proc  of the   th annual ieee symposium on logic in computer science  lics  
pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable
reasoning and ecient query answering in description logics  the dl lite family 
journal of automated reasoning                 
ceri  s   gottlob  g     tanca  l          what you always wanted to know about datalog
 and never dared to ask   ieee trans  knowledge data engineering                
cuenca grau  b   horrocks  i   kazakov  y     sattler  u       a   modular reuse of
ontologies  theory and practice  journal of artificial intelligence research         
    
cuenca grau  b   horrocks  i   motik  b   parsia  b   patel schneider  p     sattler  u 
     b   owl    the next step for owl  journal of web semantics  jws         
       
derriere  s   richard  a     preite martinez  a          an ontology of astronomical
object types for the virtual observatory  in proc  of the   th meeting of the iau 
virtual observatory in action  new science  new technology  and next generation
facilities  pp        prague  czech republic 
   

ficompleteness guarantees for incomplete ontology reasoners

erling  o     mikhailov  i          rdf support in the virtuoso dbms  in pellegrini  t  
auer  s   tochtermann  k     schaert  s   eds    networked knowledge   networked
media  pp       springer berlin   heidelberg 
fitting  m          first order logic and automated theorem proving   nd edition  texts
in computer science  springer 
glimm  b   horrocks  i   lutz  c     sattler  u          conjunctive query answering for
the description logic shiq  in proceedings of the international joint conference on
ai  ijcai   pp         
golbreich  c   zhang  s     bodenreider  o          the foundational model of anatomy
in owl  experience and perspectives  journal of web semantics                
goodwin  j          experiences of using owl at the ordnance survey  in proc  of the
owl  experiences and directions workshop  owled        galway  ireland 
guo  y   pan  z     heflin  j          lubm  a benchmark for owl knowledge base
systems  journal of web semantics                
haarslev  v     moller  r          racer system description  in gore  r   leitsch  a    
nipkow  t   eds    proc  of the  st int  joint conf  on automated reasoning  ijcar
       vol       of lnai  pp          siena  italy  springer 
hayes  p          rdf semantics  world wide web consortium  w c  recommendation 
horrocks  i   patel schneider  p  f     van harmelen  f          from shiq and rdf to
owl  the making of a web ontology language  journal web semantics             
kiryakov  a   ognyanov  d     manov  d          owlim a pragmatic semantic repository
for owl   in dean  m   guo  y   jun  w   kaschek  r   krishnaswamy  s   pan  z    
sheng  q  z   eds    wise workshops  pp         
lacy  l   aviles  g   fraser  k   gerber  w   mulvehill  a     gaskill  r          experiences
using owl in military applications  in proc  of the owl  experiences and directions
workshop  owled        galway  ireland 
lutz  c   toman  d     wolter  f          conjunctive query answering in the description
logic el using a relational database system  in proceedings of the   st international
joint conference on ai  ijcai   pp           
ma  l   yang  y   qiu  z   xie  g  t   pan  y     liu  s          towards a complete owl
ontology benchmark  in proceedings of the  rd european semantic web conference
 eswc        pp         
mcbride  brian         jena  implementing the rdf model and syntax specification  in
international workshop on the semantic web      
meditskos  g     bassiliades  n          combining a dl reasoner and a rule engine for
improving entailment based owl reasoning  in proceedings of the  th international
semantic web conference  iswc        pp         
motik  b   cuenca grau  b   horrocks  i   wu  z   fokoue  a     lutz  c       a   owl  
web ontology language profiles  w c recommendation 
   

ficuenca grau  motik  stoilos   horrocks

motik  b   shearer  r     horrocks  i       b   hypertableau reasoning for description
logics  j  artificial intelligence research  jair                      
ortiz  m   calvanese  d     eiter  t          data complexity of query answering in expressive description logics via tableaux  journal of automated reasoning               
perez urbina  h   horrocks  i     motik  b          ecient query answering for owl   
in proceedings of the  th international semantic web conference  iswc        vol 
     of lncs  pp          springer 
perez urbina  h   motik  b     horrocks  i          tractable query answering and rewriting
under description logic constraints  journal of applied logic                
prudhommeaux  e     seaborne  a          sparql query language for rdf  world
wide web consortium  w c   w c recommendation 
rector  a  l     rogers  j          ontological and practical issues in using a description
logic to represent medical concept systems  experience from galen  in barahona 
p   bry  f   franconi  e   henze  n     sattler  u   eds    reasoning web  second
international summer school       pp         
sidhu  a   dillon  t   chang  e     sidhu  b  s          protein ontology development
using owl  in proc  of the owl  experiences and directions workshop  owled
       galway  ireland 
sirin  e   parsia  b   cuenca grau  b   kalyanpur  a     katz  y          pellet  a practical
owl dl reasoner  journal of web semantics              
soergel  d   lauser  b   liang  a   fisseha  f   keizer  j     katz  s          reengineering
thesauri for new applications  the agrovoc example  j  of digital information 
      
wu  z   eadon  g   das  s   chong  e  i   kolovski  v   annamalai  m     srinivasan  j 
        implementing an inference engine for rdfs owl constructs and user defined
rules in oracle  in proceedings of the      ieee   th international conference on
data engineering  icde      pp            ieee computer society 

   

fi