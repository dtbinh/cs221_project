journal of artificial intelligence research                  

submitted        published      

reformulating the situation calculus and the event
calculus in the general theory of stable models and in
answer set programming

joohyung lee
ravi palla

joolee asu edu
ravi palla asu edu

school of computing  informatics 
and decision systems engineering
arizona state university
tempe  az        usa

abstract
circumscription and logic programs under the stable model semantics are two wellknown nonmonotonic formalisms  the former has served as a basis of classical logic based
action formalisms  such as the situation calculus  the event calculus and temporal action
logics  the latter has served as a basis of a family of action languages  such as language a
and several of its descendants  based on the discovery that circumscription and the stable
model semantics coincide on a class of canonical formulas  we reformulate the situation
calculus and the event calculus in the general theory of stable models  we also present a
translation that turns the reformulations further into answer set programs  so that efficient
answer set solvers can be applied to compute the situation calculus and the event calculus 

   introduction
circumscription  mccarthy              and logic programs under the stable model semantics  gelfond   lifschitz        are two well known nonmonotonic formalisms  as one of the
oldest nonmonotonic formalisms  circumscription has found many applications in commonsense reasoning and model based diagnoses  e g   mccarthy        shanahan        besnard
  cordier         the stable model semantics is the mathematical basis of answer set programming  asp   marek   truszczynski        niemela        lifschitz         which is
being widely applied thanks to the availability of several efficient implementations  known
as answer set solvers 
while the two nonmonotonic formalisms have been applied to overlapping classes of
problems  minimal model reasoning ensured by circumscription does not coincide with stable
model reasoning  moreover  these formalisms have different roots  while circumscription
is defined in terms of translation into classical  second order  logic  stable models proposed
by gelfond and lifschitz        are defined in terms of grounding and fixpoints in the
style of reiters default logic  reiter         these differences in part account for the fact
that the two formalisms have formed rather disparate traditions in knowledge representation
research  in particular  in the area of temporal reasoning  the former has served as a basis of
classical logic based action calculi  such as the situation calculus  mccarthy   hayes       
reiter         the event calculus  shanahan        and temporal action logics  doherty 
c
    
ai access foundation  all rights reserved 

filee   palla

gustafsson  karlsson    kvarnstrom         whereas the latter has served as a basis of a
family of action languages  such as language a  gelfond   lifschitz        and several of its
descendants which can be translated into logic programs under the stable model semantics 
however  a recent generalization of the stable model semantics shed new light on the
relationship between circumscription and stable models  the first order stable model semantics defined by ferraris  lee and lifschitz              characterizes the stable models
of a first order sentence as the models  in the sense of first order logic  of the sentence
that satisfy the stability condition  expressed by a second order formula that is similar
to the one used to define circumscription  since logic programs are viewed as a special
class of first order sentences under the stable model semantics  this definition extends the
stable model semantics by gelfond and lifschitz        to the full first order level without
limiting attention to herbrand models  essentially the same characterization was independently given by lin and zhou         via logic of knowledge and justified assumption  lin
  shoham         these definitions are also equivalent to the definition of quantified equilibrium logic given by pearce and valverde         which is defined in terms of the logic of
here and there  heyting        
the new definition of a stable model motivates us to investigate the relationship between
stable model reasoning and minimal model reasoning  in particular  we focus on their
relationship in the area of temporal reasoning  we show how the situation calculus and the
event calculus can be reformulated in the first order stable model semantics  and further in
asp  this is not only theoretically interesting  but also practically useful as it allows us to
leverage efficient answer set solvers for computing circumscriptive action theories 
for this  we develop two technical results  first  we show that circumscription and the
first order stable model semantics coincide on the class of canonical formulas  this is the
largest syntactic class identified so far on which the two semantics coincide  and is general
enough to cover several circumscriptive action formalisms  such as the situation calculus 
the event calculus  and temporal action logics  the result allows us to reformulate those
action formalisms in the first order stable model semantics  while minimal model reasoning
sometimes leads to unintuitive results  those circumscriptive action formalisms are carefully
designed to avoid such cases  and our result implies that minimal model reasoning in those
action formalisms can also be viewed as stable model reasoning 
second  we identify a class of almost universal formulas  which can be turned into the
syntax of a logic program while preserving stable models  it turns out that the reformulations of the situation calculus and the event calculus in the first order stable model
semantics fall into this class of formulas  we introduce system f lp that turns formulas in
this class to logic programs  and  in conjunction with the result on canonical formulas  use
the combination of f lp and answer set solvers to compute the situation calculus and the
event calculus 
our work makes explicit the relationship between classical logic and logic program traditions in temporal reasoning  interestingly  the development of the event calculus has
spanned over both traditions  the original version of the event calculus  kowalski   sergot        was formulated in logic programs  but not under the stable model semantics  that
was the time before the invention of the stable model semantics   more extensive developments have been later carried out on the classical logic foundation via circumscription  e g  
shanahan                    miller   shanahan        mueller         but the relation to
   

fireformulating the situation calculus and the event calculus

the logic program formulation remained implicit  based on the reduction of circumscription to completion  sat based event calculus systems were implemented  one by shanahan
and witkowski        and another by mueller         the latter system is called the dec
reasoner   which outperforms the former thanks to a more efficient and general compilation
method into propositional logic  while the system handles a large fragment of the event
calculus  it still cannot handle recursive and disjunctive axioms since completion cannot
be applied to such axioms  our asp based approach on the other hand can handle the
full version of the event calculus under the assumption that the domain is given and finite 
thanks to the efficiency of asp solvers  our experiments indicate that the asp based event
calculus reasoner is significantly faster than the dec reasoner  appendix b  
similar to the logic programming tradition of the event calculus  the situation calculus  mccarthy   hayes        reiter        can be implemented in prolog  based on the
fact that clarks completion semantics accounts for definitional axioms  but unlike the
event calculus  to the best of our knowledge  efficient propositional solvers have not been
applied to directly compute the models of situation calculus theories  in this paper  we
reformulate lins causal action theories        and reiters basic action theories        in
the first order stable model semantics and in asp  for basic action theories  we also provide
an asp based encoding method that obtains reiters successor state axioms from the effect
axioms and the generic inertia axioms adopted in asp  the idea of which is close to reiters
frame default        
the paper is organized as follows  the next section reviews the definitions of circumscription and the first order stable model semantics  and presents the definition of a
canonical formula  based on this  sections   and   reformulate the event calculus and the
situation calculus in the first order stable model semantics  section   shows a translation
that turns almost universal formulas into logic programs that can be accepted by asp
solvers  sections   and   use this result to turn the reformulations of the event calculus
and the situation calculus given in sections   and   into the input language of asp solvers 
complete proofs are given in appendix c 

   circumscription and first order stable model semantics
we assume the following set of primitive propositional connectives and quantifiers 
  falsity             
we understand f as an abbreviation of f    symbol   stands for     and f  g
stands for  f  g    g  f   
    review  circumscription
let p be a list of distinct predicate constants p            pn   and let u be a list of distinct
predicate variables u            un   by u  p we denote the conjunction of the formulas
x ui  x   pi  x   for all i            n  where x is a list of distinct object variables whose
length is the same as the arity of pi   expression u   p stands for  u  p    p  u   for
   http   decreasoner sourceforge net

   

filee   palla

instance  if p and q are unary predicate constants then  u  v     p  q  is


x u x   p x    x v x   q x     x p x   u x    x q x   v x    
circumscription is defined in terms of the circ operator with minimized predicates 
for any first order formula f   expression circ f   p  stands for the second order formula
f  u  u   p   f  u   
where f  u  is the formula obtained from f by substituting ui for pi   when f is a sentence
 i e   a formula with no free variables   intuitively  the models of circ f   p  are the models
of f that are minimal on p 
the definition is straightforwardly extended to the case when f is a many sorted firstorder formula  lifschitz        section       which is the language that the event calculus
and the situation calculus are based on 
    review  first order stable model semantics
this review follows the definition by ferraris et al          there  the stable models are
defined in terms of the sm operator  whose definition is similar to the circ operator in
the previous section  for any first order formula f and any finite list of predicate constants
p    p            pn    formula sm f   p  is defined as
f  u  u   p   f   u   
where u is defined the same as in circ f   p   and f   u  is defined recursively as follows 
 pi  t    ui  t  for any list t of terms 
 f    f for any atomic formula f  including  and equality  that does not contain
members of p 
  f  g    f   g  
  f  g    f   g  
  f  g     f   g     f  g  
  xf     xf   
  xf     xf   
the predicates in p are called intensional  these are the predicates that we intend to
characterize by f in terms of non intensional predicates   when f is a sentence  the models
of the second order sentence sm f   p  are called the p stable models of f   they are the
models of f that are stable on p  we will often simply write sm f   in place of sm f   p 
when p is the list of all predicate constants occurring in f   according to lee  lifschitz  and
   intensional predicates are analogous to output predicates in datalog  and non intensional predicates are
analogous to input predicates in datalog  lifschitz        

   

fireformulating the situation calculus and the event calculus

palla         answer sets are defined as a special class of stable models as follows  by  f  
we denote the signature consisting of the object  function and predicate constants occurring
in f   if f contains at least one object constant  an herbrand interpretation of  f   that
satisfies sm f   is called an answer set of f   the answer sets of a logic program  are defined
as the answer sets of the fol representation of   i e   the conjunction of the universal
closures of implications corresponding to the rules   for example  the fol representation
of the program
p a 
q b 
r x   p x   not q x 
is
p a   q b   x p x   q x   r x  

   

and sm f   is
p a   q b   x p x   q x   r x  
uvw   u  v  w     p  q  r    u a   v b 
x  u x    v x   q x    w x     p x   q x   r x     
which is equivalent to the first order sentence
x p x   x   a   x q x   x   b   x r x    p x   q x   

   

 ferraris et al         example     the stable models of f are any first order models of     
the only answer set of f is the herbrand model  p a   q b   r a   
according to ferraris et al          this definition of an answer set  when applied to the
syntax of logic programs  is equivalent to the traditional definition of an answer set that is
based on grounding and fixpoints  gelfond   lifschitz        
note that the definition of a stable model is more general than the definition of an
answer set in the following ways  stable models are not restricted to herbrand models  the
underlying signature can be arbitrary  and the intensional predicates are not fixed to the
list of predicate constants occurring in the formula  the last fact is not essential in view of
the following proposition  by pr  f   we denote the list of all predicate constants occurring
in f   by choice p  we denote the conjunction of choice formulas x p x   p x   for
all predicate constants p in p  where x is a list of distinct object variables  by false p  we
denote the conjunction of xp x  for all predicate constants p in p  we sometimes identify
a list with the corresponding set when there is no confusion 
proposition   formula
sm f   p   sm f  choice pr  f   p   false p pr  f    

   

is logically valid 
notice that the  implicit  intensional predicates on the right hand side of     are those
in  pr  f    p   the choice formula makes the predicates in  pr  f     p  to be exempt
from the stability checking  on the other hand  the false formula makes the predicates in
 p   pr  f    to be stabilized  i e   to have empty extents   though they do not occur in f  
   

filee   palla

ferraris et al         incorporate strong negation into the stable model semantics by
distinguishing between intensional predicates of two kinds  positive and negative  each
negative intensional predicate has the form p  where p is a positive intensional predicate
and  is a symbol for strong negation  syntactically  is not a logical connective  as
it can appear only as a part of a predicate constant  an interpretation of the underlying
signature is coherent if it satisfies the formula
x p x   p x   

   

where x is a list of distinct object variables  for each negative predicate p  we usually
consider coherent interpretations only  intuitively  p t  represents that p t  is false  this
is different from p t  which represents that it is not known that p t  is true  similarly 
 p t  represents that it is not known that p t  is false  and p t  represents that it is
not known that p t  is not known to be true  note that  unlike in first order logic  p t 
is different from p t   for instance  formula p a  has only one answer set  p a   but p a 
has no answer sets 
like the extension of circumscription to many sorted first order sentences  the definition
of a stable model is straightforwardly extended to many sorted first order sentences 
    equivalence of the stable model semantics and circumscription on
canonical formulas
neither the stable model semantics nor circumscription is stronger than the other  for
example 
circ x p x   p x    p 
   
is equivalent to xp x   and
sm x p x   p x    p 

   

is equivalent to    so that     is stronger than      on the other hand 
circ x p x   q x    p  q 

   

is equivalent to x p x   q x    and
sm x p x   q x    p  q 

   

is equivalent to x p x   q x    so that     is stronger than     
in this section  we show that the two semantics coincide on a class of formulas called
canonical formulas  which we define below  we first review the notions of positive  negative 
and strictly positive occurrences 
definition   we say that an occurrence of a predicate constant  or any other subexpression  in a formula f is positive if the number of implications containing that occurrence in
the antecedent is even  and negative otherwise   recall that we treat g as shorthand for
g     we say that the occurrence is strictly positive if the number of implications in f
containing that occurrence in the antecedent is   
   

fireformulating the situation calculus and the event calculus

for example  in      both occurrences of q are positive  but only the first one is strictly
positive 
definition   we say that a formula f is canonical relative to a list p of predicate constants
if
 no occurrence of a predicate constant from p is in the antecedents of more than one
implication in f   and
 every occurrence of a predicate constant from p that is in the scope of a strictly positive
occurrence of  or  in f is strictly positive in f  
example   the formula
x p x   q x  

   

that is shown above is not canonical relative to  p  q  since it does not satisfy the first clause
of the definition  p occurs in the antecedents of two implications as p x  is shorthand for
p x      on the other hand  the formula is canonical relative to  q   the formula
x p x   p x  

    

is not canonical relative to  p  since it does not satisfy the second clause  the second occurrence of p is in the scope of a strictly positive occurrence of   but is not strictly positive in
       the formula
p a    x p x   x q x  
    
is canonical relative to  p  q   while
p a  a   x p x  a   p b  x  

    

is not canonical relative to  p  q  since it does not satisfy the second clause  the second
occurrence of p is in the scope of a strictly positive occurrence of   but is not strictly
positive in formula       
the following theorem states that  for any canonical formula  circumscription coincides
with the stable model semantics 
theorem   for any canonical formula f relative to p 
circ f   p   sm f   p 

    

is logically valid 
for instance  for formula       which is canonical relative to  p  q   formulas circ       p  q 
and sm       p  q  are equivalent to each other  also  any sentence f is clearly canonical
relative to   so that circ f     is equivalent to sm f      which in turn is equivalent to f  
on the other hand  such equivalence may not necessarily hold for non canonical formulas 
for instance  we observed that  for formula      that is not canonical relative to  p   formulas     and     are not equivalent to each other  for formula     that is not canonical
   

filee   palla

relative to  p  q   formulas     and     are not equivalent to each other  we also observe
that formula      that is not canonical relative to  p  q   circ       p  q  is not equivalent
to sm       p  q   the herbrand interpretation  p a  a   p b  a   satisfies sm       p  q   but
does not satisfy circ       p  q  
note that non canonical formulas can often be equivalently rewritten as canonical formulas  since any equivalent transformation preserves the models of circumscription  theorem   can be applied to such non canonical formulas  by first rewriting them as canonical
formulas  for example  formula     is equivalent to
x p x   q x   

    

which is canonical relative to  p  q   so that circ      p  q  is equivalent to sm       p  q  
for another example  formula      is equivalent to
x p x   p x   

    

which is canonical relative to  p   so that circ       p  is equivalent to sm       p   it
is clear that this treatment can be applied to any quantifier free formula  including any
propositional formula  because a quantifier free formula can be equivalently rewritten as a
canonical formula by first rewriting it into a clausal normal form and then turning each
clause into the form c  d  where c is a conjunction of atoms and d is a disjunction of
atoms  
sections   and   use theorem   to reformulate the event calculus and the situation
calculus in the first order stable model semantics 

   reformulating the event calculus in the general theory of stable
models
in this section  we review the syntax of circumscriptive event calculus described in chapter  
of the book by mueller         based on the observation that the syntax conforms to the
condition of canonicality  we present a few reformulations of the event calculus in the general
theory of stable models 
    review  circumscriptive event calculus
we assume a many sorted first order language  which contains an event sort  a fluent sort 
and a timepoint sort  a fluent term is a term whose sort is a fluent  an event term and a
timepoint term are defined similarly 
definition   a condition is defined recursively as follows 
 if   and   are terms  then comparisons                                      
       are conditions 
   it appears unlikely that knowledge has to be encoded in a non canonical formula such as      that
cannot be easily turned into an equivalent canonical formula  c f  guide to axiomatizing domains
in first order logic  http   cs nyu edu faculty davise guide html   it is not a surprise that all
circumscriptive action theories mentioned in this paper satisfy the canonicality assumption 

   

fireformulating the situation calculus and the event calculus

 if f is a fluent term and t is a timepoint term  then holdsat f  t  and holdsat f  t 
are conditions 
 if   and   are conditions  then      and      are conditions 
 if v is a variable and  is a condition  then v is a condition 
we will use e and ei to denote event terms  f and fi to denote fluent terms  t and ti to
denote timepoint terms  and  and i to denote conditions 
in the event calculus  we circumscribe initiates  terminates  and releases to minimize
unexpected effects of events  circumscribe happens to minimize unexpected events  and
circumscribe ab i  abnormality predicates  to minimize abnormalities  formally  an event
calculus description is a circumscriptive theory defined as
circ    initiates  terminates  releases   circ    happens 
 circ    ab             ab n     

    

where
  is a conjunction of universal closures of axioms of the form
  initiates e  f  t 
  terminates e  f  t 
  releases e  f  t 
     e  f    t      e  f    t 
 effect constraint 
    happens e    t         happens en   t   initiates e  f  t 
    happens e    t         happens en   t   terminates e  f  t  
where each of   and   is either initiates or terminates     means that  is
optional  
  is a conjunction of universal closures of temporal ordering formulas  comparisons
between timepoint terms  and axioms of the form
  happens e  t 
 f  t      f    t       n  fn   t   happens e  t 
 causal constraints 
happens e  t   happens e    t       happens en   t   disjunctive event axiom  
where  is started or stopped and each j     j  n  is either initiated or
terminated  
  is a conjunction of universal closures of cancellation axioms of the form
  abi       t   
  is a conjunction of first order sentences  outside the scope of circ  including unique
name axioms  state constraints  event occurrence constraints  and the set of domainindependent axioms in the event calculus  such as ec  for the continuous event calculus  and dec  for the discrete event calculus   mueller        chapter     it also
   

filee   palla

includes the following definitions of the predicates used in the causal constraints in  
def

started  f  t    holdsat f  t   e happens e  t   initiates e  f  t   

 cc   

def

stopped  f  t    holdsat f  t   e happens e  t   terminates e  f  t   
def

initiated  f  t    started  f  t   e happens e  t   terminates e  f  t   
def

terminated  f  t    stopped  f  t   e happens e  t   initiates e  f  t   

 cc   
 cc   
 cc    

remark   the following facts are easy to check 
  is canonical relative to  initiates  terminates  releases  
  is canonical relative to  happens  
  is canonical relative to  ab             ab n   
these facts are used in the next section to reformulate the event calculus in the general
theory of stable models 
    reformulating the event calculus in the general theory of stable models
following ferraris  lee  lifschitz  and palla         about a formula f we say that it
is negative on a list p of predicate constants if members of p have no strictly positive
occurrences in f    for example  formula     is negative on  p   but is not negative on  p  q  
a formula of the form f  shorthand for f    is negative on any list of predicates 
we assume that  was already equivalently rewritten so that  is negative on  initiates 
terminates  releases  happens  ab             ab n    this can be easily done by prepending 
to strictly positive occurrences of those predicates  the following theorem shows a few
equivalent reformulations of circumscriptive event calculus in the general theory of stable
models 
theorem   for any event calculus description       the following theories are equivalent
to each other  
 a  circ   i  t  r   circ   h   circ   ab             ab n      
 b  sm   i  t  r   sm   h   sm   ab             ab n      
 c  sm         i  t  r  h  ab             ab n    
 d  sm         choice pr             i  t  r  h  ab             ab n      
the equivalence between  a  and  b  is immediate from theorem    the equivalence
between  b  and  c  can be shown using the splitting theorem by ferraris et al         
the assumption that  is negative on the intensional predicates is essential in showing that
   note that we distinguish between a formula being negative  on p  and an occurrence being negative
 section      
   for brevity  we abbreviate the names of circumscribed predicates 

   

fireformulating the situation calculus and the event calculus

equivalence  for more details  see the proof in appendix c      the equivalence between
 c  and  d  follows from proposition   since
 i  t  r  h  ab             ab n     pr         
is the empty set  

   reformulating the situation calculus in the general theory of stable
models
in this section  we review and reformulate two versions of the situation calculuslins
causal action theories        and reiters basic action theories        
    review  lins causal action theories
we assume a many sorted first order language which contains a situation sort  an action
sort  a fluent sort  a truth value sort and an object sort  we understand expression p  x  s  
where p is a fluent name  as shorthand for holds p  x   s   we do not consider functional
fluents here for simplicity 
according to lin         a formula  s  is called a simple state formula about s if  s 
does not mention poss  caused or any situation term other than possibly the variable s 
we assume that a causal action theory d consists of a finite number of the following
sets of axioms  we often identify d with the conjunction of the universal closures of all
axioms in d  in the following  f   fi are fluent names  a is an action name  v   vi are truth
values  s  s  are situation variables   s  is a simple state formula about s  symbols a  a 
are action variables  f is a variable of sort fluent  v is a variable of sort truth value  and x 
xi   y  yi are lists of variables 
 dcaused is a conjunction of axioms of the form
poss a x   s     s   caused  f  y   v  do a x   s  
 direct effect axioms   and
 s   caused  f   x     v    s       caused  fn  xn    vn   s   caused  f  x   v  s 
 indirect effect axioms  
 dposs is a conjunction of precondition axioms of the form
poss a x   s    s  

    

 drest is a conjunction of the following axioms 
 the basic axioms 
caused  f  true  s   holds f  s  
caused  f  false  s   holds f  s  
true    false  v v   true  v   false  
   i  t   r  h occur in the domain independent axioms as part of  

   

    

filee   palla

 the unique name assumptions for fluent names 
fi  x     fj  y    i    j 
fi  x    fi  y   x   y 

    

similarly for action names 
 the foundational axioms for the discrete situation calculus 

 

s    do a  s  
 

 

 

 

do a  s    do a   s     a   a  s   s   



p p s     a  s p s   p do a  s    s p s   

    
    
    

 the frame axiom 
poss a  s    vcaused  f  v  do a  s  
  holds f  do a  s    holds f  s    
 axioms for other domain knowledge   s  
a causal action theory is defined as
circ dcaused   caused    dposs  drest  

    

remark   it is easy to check that dcaused is canonical relative to caused  
this fact is used in the next section to reformulate causal action theories in the general
theory of stable models 
    reformulating causal action theories in the general theory of stable
models
let dposs  be the conjunction of axioms  s   poss a x   s  for each axiom      in dposs  
instead of the second order axiom       we consider the following first order formula dsit  
which introduces a new intensional predicate constant sit whose argument sort is situation  
sit s     a  s sit s   sit do a  s     ssit s  

    


in the following  drest
is the theory obtained from drest by dropping      

theorem   given a causal action theory       the following theories are equivalent to each
other when we disregard the auxiliary predicate sit 
 a  circ dcaused   caused    dposs  drest  

 b  sm dcaused   caused    dposs  drest
 sm dsit   sit   

 c  sm dcaused   caused    sm dposs    poss   drest
 sm dsit   sit   

 d  sm dcaused  dposs   drest
 dsit   caused   poss  sit   

   for simplicity we omit two other axioms regarding the partial order among situations 
   suggested by vladimir lifschitz  personal communication  

   

fireformulating the situation calculus and the event calculus

    review  reiters basic action theories
as in causal action theories  we understand p  x  s   where p is a fluent name  as shorthand
for holds p  x   s   and do not consider functional fluents 
a basic action theory  bat  is of the form
  dss  dap  duna  ds   

    

where
  is the conjunction of the foundational axioms  section      
 dss is a conjunction of successor state axioms of the form
f  x  do a  s    f  x  a  s  
where f  x  a  s  is a formula that is uniform in s
among x  a  s 

 

and whose free variables are

 dap is a conjunction of action precondition axioms of the form
poss a x   s   a  x  s  
where a  x  s  is a formula that is uniform in s and whose free variables are among x  s 
 duna is the conjunction of unique name axioms for fluents and actions 
 ds  is a conjunction of first order formulas that are uniform in s   
    reformulating basic action theories in the general theory of stable
models
note that a bat is a theory in first order logic    in view of the fact that any first order
logic sentence f is equivalent to sm f      it is trivial to view a bat as a first order theory
under the stable model semantics with the list of intensional predicates being empty 
in the rest of this section  we consider an alternative encoding of bat in asp  in which
we do not need to provide explicit successor state axioms dss   instead  the successor state
axioms are entailed by the effect axioms and the generic inertia axioms adopted in asp by
making intensional both the positive predicate holds and the negative predicate holds
 recall the definitions of positive and negative predicates in section       in the following
we assume that the underlying signature contains both these predicates 
an asp style bat is of the form
  deffect  dprecond  dinertia  dexogenous   duna  ds   
where
   duna and ds  are defined as before 
   we refer the reader to the book by reiter        for the definition of a uniform formula 
    for simplicity we disregard the second order axiom      

   

    

filee   palla

 deffect is a conjunction of axioms of the form
 
r
 x  a  s   holds r x   do a  s  

    


r
 x  a  s   holds r x   do a  s   

    

or
 
r
 x  a  s 


r
 x  a  s 

where
and
variables are among x  a and s 

are formulas that are uniform in s and whose free

 dprecond is a conjunction of axioms of the form
a  x  s   poss a x   s  

    

where a  x  s  is a formula that is uniform in s and whose free variables are among x  s 
 dinertia is the conjunction of the axioms
holds r x   s    holds r x   do a  s    holds r x   do a  s   
holds r x   s   holds r x   do a  s    holds r x   do a  s  
for all fluent names r 
 dexogenous  is the conjunction of
holds r x   s    holds r x   s   
for all fluent names r 
note that axioms in dinertia are typically used in answer set programming to represent
the common sense law of inertia  lifschitz   turner         similarly  dexogenous  is used
to represent that the initial value of a fluent is arbitrary   
we will show how this asp style bat is related to reiters bat  first  since we use
strong negation  it is convenient to define the following notions  given the signature  of
a bat   holds is the signature obtained from  by adding holds to   we say that an
interpretation i of  holds is complete on holds if it satisfies
y holds y  holds y   
where y is a list of distinct variables  given an interpretation i of  holds   expression i 
denotes the projection of i on  
let dss be the conjunction of successor state axioms

holds r x   do a  s     
r  x  a  s    holds r x   s   r  x  a  s   
 

where  
r  x  a  s  is the disjunction of r  x  a  s  for all axioms      in deffect   and r  x  a  s 

is the disjunction of r  x  a  s  for all axioms      in deffect   by dap we denote the conjunction of axioms poss a x   s   a  x  s   where a  x  s  is the disjunction of a  x  s 
for all axioms      in dprecond  

    the axioms dinertia and dexogenous  are also closely related to the translation of c  into nonmonotonic
causal logic  giunchiglia  lee  lifschitz  mccain    turner        

   

fireformulating the situation calculus and the event calculus

theorem   let t be a theory      of signature  holds   and i a coherent interpretation of
 holds that is complete on holds  if i satisfies

x a s  
r  x  a  s   r  x  a  s  

for every fluent name r  then i satisfies
sm t   poss  holds  holds 
iff i  satisfies the bat
  dss  dap  duna  ds   

   translating almost universal sentences into logic programs
theorems    present reformulations of the situation calculus and the event calculus in the
general theory of stable models  which may contain nested quantifiers and connectives  on
the other hand  the input languages of asp solvers are limited to simple rule forms  which
are analogous to clausal normal form in classical logic  although any first order formula can
be rewritten in clausal normal form while preserving satisfiability  such transformations do
not necessarily preserve stable models  this is due to the fact that the notion of equivalence
is stronger under the stable model semantics  lifschitz  pearce    valverde        
definition    ferraris et al         a formula f is strongly equivalent to formula g if 
for any formula h containing f as a subformula  and possibly containing object  function
and predicate constants that do not occur in f   g   and for any list p of distinct predicate
constants  sm h  p  is equivalent to sm h     p   where h   is obtained from h by replacing
an occurrence of f by g 
in other words  replacing a subformula with another strongly equivalent subformula
does not change the stable models of the whole formula  while strongly equivalent theories
are classically equivalent  i e   equivalent under classical logic   the converse does not hold 
consequently  classically equivalent transformations do not necessarily preserve stable models  for instance  consider p and p  when p is intensional  the former has stable models
and the latter does not 
it is known that every propositional formula can be rewritten as a logic program  cabalar
  ferraris        cabalar  pearce    valverde        lee   palla         and such translations can be extended to quantifier free formulas in a straightforward way  section      
however  the method does not work in the presence of arbitrary quantifiers  because in the
target formalism  logic programs   all variables are implicitly universally quantified 
in this section  we present a translation that turns a certain class of sentences called
almost universal sentences into logic programs while preserving stable models  it turns
out that the reformulations of the situation calculus and the event calculus in sections  
and   belong to the class of almost universal sentences  so that we can use asp solvers for
computing them 
   

filee   palla

    translating quantifier free formulas into logic programs
cabalar et al         define the following transformation that turns any propositional formula under the stable model semantics into a logic program 
 left side rules 
 f g

 

 f  g 

 l  

f g

 



 l  

f  g  h

 

 l  

 f  g   h  k

 

 f  g   h  k

 

 g  f  h 


f h k
gh k



 f  h  k
gh k


h  f  g  k

f g

 

 f  g 

 r  

f  g

 



 r  

f  g  h

 

 r  

f   g  h   k

 

f   g  h   k

 

 g  f  h 


f gk
f h k


gf h k
h  f  g  k

 l  

 l  

 right side rules 

 r  
 r  

before applying this transformation to each formula on the lefthand side  we assume
that the formula is already written in negation normal form  in which negation is applied
to literals only  by using the following transformation 
 negation normal form conversion 
 

f
 f  g 
 f  g 
 f  g 

 
 

 

 

 

 



 
f
f  g
f  g
f  g

according to cabalar et al          successive application of the rewriting rules above
turn any propositional formula into a disjunctive logic program  this result can be simply
extended to turn any quantifier free formula into a logic program 
as noted by cabalar et al          this translation may involve an exponential blowup in
size  and theorem   from their paper shows that indeed there is no vocabulary preserving
polynomial time algorithm to convert general propositional theories under the stable model
semantics into disjunctive logic programs  alternatively  one can use another translation
from the same paper  which is linear in size but involves auxiliary atoms and is more
complex 
   

fireformulating the situation calculus and the event calculus

    quantifier elimination
we introduce a quantifier elimination method that distinguishes between two kinds of occurrences of quantifiers  singular and non singular  any non singular occurrence of
a quantifier is easy to eliminate  while a singular occurrence is eliminated under a certain
syntactic condition 
definition   we say that an occurrence of qxg in f is singular if
 q is   and the occurrence of qxg is positive in f   or
 q is   and the occurrence of qxg is negative in f  
for example  the occurrence of x q x  is singular in       but the occurrence of x p x  is
not 
non singular occurrences of quantifiers can be eliminated in view of the fact that every
first order sentence can be rewritten in prenex form  the prenex form conversion rules given
in section       of pearce and valverde        preserve strong equivalence  which leads to
the following theorem   
theorem    lee   palla        proposition    every first order formula is strongly
equivalent to a formula in prenex form 
the prenex form conversion turns a non singular occurrence of a quantifier into an
outermost  while preserving strong equivalence  consequently  if a sentence contains no
singular occurrence of a quantifier  then the above results can be used to turn the sentence
into a universal sentence and then into a set of asp rules  however  in the presence of a
singular occurrence of a quantifier  the prenex form conversion turns the occurrence into
an outermost   which is not allowed in logic programs  below we consider how to handle
such occurrences 
obviously  if the herbrand universe is finite  and if we are interested in herbrand stable
models  i e   answer sets  only  quantified formulas can be rewritten as multiple disjunctions
and conjunctions  we do not even need to consider turning the formula into prenex form 
for example  for a formula
r  x p x   q x    s

    

occurring in a theory whose signature contains             n  as the only object constants  and
no other function constants   if we replace x p x   q x   with multiple disjunctions and
then turn the resulting program with nested expressions into a usual disjunctive program
 lifschitz  tang    turner          n rules are generated  for instance  if n      the
    pearce and valverde        show that a sentence in qnc    the monotonic basis of quantified equilibrium
logic  can be turned into prenex form  from which the result follows 

   

filee   palla

resulting logic program is
s  r  not
s  r  not
s  r  not
s  r  not
s  r  not
s  r  not
s  r  not
s  r  not

p     not
p     not
p     not
p     not
q     not
q     not
q     not
q     not

p     not
p     not
q     not
q     not
p     not
p     not
q     not
q     not

p   
q   
p   
q   
p   
q   
p   
q    

also  the translation is not modular as it depends on the underlying domain  the multiple
disjunctions or conjunctions need to be updated when the domain changes  more importantly  this method is not applicable if the theory contains function constants of positive
arity  as its herbrand universe is infinite 
one may also consider introducing skolem constants as in first order logic  presuming
that  for any sentence f and its skolem form f     sm f   p  is satisfiable iff sm f     p  is
satisfiable  however  this idea does not work   
example   for formula
f    x p x   q   x q  p x   
sm f   q  is equivalent to the first order sentence
 q  x p x    x q  p x   
which is unsatisfiable  the equivalence can be established using theorems   and    from ferraris et al          formula f is strongly equivalent to its prenex form

xy  p x   q    q  p y    

    

however  if we introduce new object constants a and b to replace the existentially quantified
variables as in
f      p a   q    q  p b   
formula sm f     q  is equivalent to
 q  p a     q  p b   
which is satisfiable 
here we present a method of eliminating singular occurrences of quantifiers by introducing auxiliary predicates  our idea is a generalization of the practice in logic programming
    pearce and valverde        show that skolemization works with qnc    the monotonic basis of quantified equilibrium logic  but as our example shows  this does not imply that skolemization works with
quantified equilibrium logic 

   

fireformulating the situation calculus and the event calculus

that simulates negated existential quantification in the body of a rule by introducing auxiliary predicates  for instance  in order to eliminate  in       we will introduce a new
predicate constant p    and turn      into
 r  p   s   x p x   q x   p    

    

which corresponds to the logic program
s  r  not p 
p   p x   q x  

    

the models of sm       p  q  r  s  are the same as the stable models of      if we disregard
p    this method does not involve grounding  so that the translation does not depend on
the domain and is not restricted to herbrand models  the method is formally justified by
the following proposition 
recall that a formula h is negative on p if members of p have no strictly positive
occurrences in h  given a formula f   we say that an occurrence of a subformula g is
p negated in f if it is contained in a subformula h of f that is negative on p 
proposition   let f be a sentence  let p be a finite list of distinct predicate constants 
and let q be a new predicate constant that does not occur in f   consider any non strictly
positive  p negated occurrence of yg y  x  in f   where x is the list of all free variables of
yg y  x   let f   be the formula obtained from f by replacing that occurrence of yg y  x 
with q x   then
sm f   p   x q x   yg y  x  
is equivalent to
sm f    xy g y  x   q x    p  q  
proposition   tells us that sm f   p  and sm f    xy g y  x   q x   p  q  have the
same models if we disregard the new predicate constant q  notice that f   does not retain
the occurrence of y 
example   in formula       x p x   q x   is contained in a negative formula  relative
to any set of intensional predicates   in accordance with proposition    sm       p  q  r  s 
has the same models as sm       p  q  r  s  p    if we disregard p   
any singular  p negated occurrence of a subformula yg y  x  can also be eliminated
using proposition   by first rewriting yg y  x  as yg y  x   note that yg y  x  is
not strongly equivalent to yg y  x   and in general such a classically equivalent transformation may not necessarily preserve stable models  however  the theorem on double
negations  ferraris et al         also reviewed in appendix c  tells us that such a transformation is ensured to preserve p stable models if the replaced occurrence is p negated in
the given formula 
now we are ready to present our quantifier elimination method  which applies to the
class of almost universal formulas 
   

filee   palla

definition   we say that a formula f is almost universal relative to p if every singular
occurrence of qxg in f is p negated in f  
for example  formula      is almost universal relative to any set of predicates because the
only singular occurrence of x p x   q x   in      is contained in x p x   q x    which
is negative on any list of predicates  formula f in example   is almost universal relative
to  q  because the singular occurrence of x p x  is contained in the formula itself  which is
negative on  q   and the singular occurrence of x q p x   is contained in x q p x   
which is also negative on  q  
the following procedure can be used to eliminate all  possibly nested  quantifiers in any
almost universal sentence 
definition    translation elim quantifiers  given a formula f   first prepend  to
every maximal strictly positive occurrence of a formula of the form yh y  x     and then
repeat the following process until there are no occurrences of quantifiers remaining  select
a maximal occurrence of a formula of the form qyg y  x  in f   where q is  or   and x
is the list of all free variables in qyg y  x  
 a  if the occurrence of qyg y  x  in f is non singular in f   then set f to be the formula
obtained from f by replacing the occurrence of qyg y  x  with g z  x   where z is a
new variable 
 b  otherwise  if q is  and the occurrence of qyg y  x  in f is positive  then set f to
be
f     g y  x   pg  x   
where pg is a new predicate constant and f   is the formula obtained from f by replacing the occurrence of qyg y  x  with pg  x  
 c  otherwise  if q is  and the occurrence of qyg y  x  in f is negative  then set f
to be the formula obtained from f by replacing the occurrence of qyg y  x  with
yg y  x  
we assume that the new predicate constants introduced by the translation do not belong
to the signature of the input formula f   it is clear that this process terminates  and yields
a formula that is quantifier free  since the number of times step  b  is applied is no more
than the number of quantifiers in the input formula  and the new formulas added have the
size polynomial to the input formula  it follows that the size of the resulting quantifier free
formula is polynomial in the size of the input formula 
the following theorem tells us that any almost universal sentence f can be turned into
the form xg  where g is a quantifier free formula  for any  second order  sentences f
and g of some signature and any subset  of that signature  we say that f is  equivalent
to g  denoted by f  g  if the class of models of f restricted to  is identical to the class
of models of g restricted to  
    the maximality is understood here in terms of subformula relation  that is  we select a strictly positive
occurrence of a subformula of f of the form yh y  x  that is not contained in any other subformula of
f of the same form 

   

fireformulating the situation calculus and the event calculus

theorem   let f be a sentence of a signature   let f   be the universal closure of the
formula obtained from f by applying translation elim quantifiers  and let q be the list
of new predicate constants introduced by the translation  if f is almost universal relative
to p  then sm f   p  is  equivalent to sm f     p  q  
the statement of the theorem becomes incorrect if we do not require f to be almost
universal relative to p  for instance  if elim quantifiers is applied to x p x   it results
in q   p x   q   however  sm x p x   p  is not  p  equivalent to
sm x q   p x   q    p  q   the former is equivalent to saying that p is a singleton 
the latter is equivalent to q  xp x    q  xp x    which is inconsistent 
    f lp  computing answer sets of first order formulas
using translation elim quantifiers defined in the previous section  we introduce translation f lp that turns an almost universal formula into a logic program  we assume that the
underlying signature contains finitely many predicate constants 
definition    translation f lp 
   given a formula f and a list of intensional predicates p  apply translation elim quantifiers  definition    to f  
   add choice formulas  q x   q x   for all non intensional predicates q 
   turn the resulting quantifier free formula into a logic program by applying the translation from section   of the paper by cabalar et al          which was also reviewed
in section     
as explained in section      due to the third step  this transformation may involve an
exponential blowup in size  one can obtain a polynomial translation by replacing step  
with an alternative translation given in section   of the paper by cabalar et al 
the following theorem asserts the correctness of the translation 
theorem   let f be a sentence of a signature   let p be a list of intensional predicates 
and let f   be the fol representation of the program obtained from f by applying translation
f lp with p as intensional predicates  if f is almost universal relative to p  then sm f   p 
is  equivalent to
sm f    false p   pr  f       
example   consider one of the domain independent axioms in the discrete event calculus
 dec  axiom  
holdsat f  t   releasedat f  t   
e happens e  t   terminates e  f  t    holdsat f  t    
step   of translation f lp introduces the formula
happens e  t   terminates e  f  t   q f  t  
and replaces      with
holdsat f  t   releasedat f  t     q f  t   holdsat f  t    
   

    

filee   palla

step   turns these formulas into rules
q f  t   happens e  t   terminates e  f  t 
holdsat f  t     holdsat f  t   not releasedat f  t     not q f  t  
turning the program obtained by applying translation f lp into the input languages of
lparse    and gringo    requires minor rewriting  such as moving equality and negated
atoms in the head to the body    and adding domain predicates in the body for all variables
occurring in the rule in order to reduce the many sorted signature into the non sorted one   
system f lp is an implementation of translation f lp  which turns a first order formula
into the languages of lparse and gringo  the system can be downloaded from its home
page
http   reasoning eas asu edu f lp  
first order formulas can be encoded in f lp using the extended rule form f  g  where
f and g are first order formulas that do not contain   the ascii representation of the
quantifiers and connectives are shown in the following table 
symbol
ascii


not


 


 


 


  


false

 
true

xyz
  x y z  

xyz
  x y z  

for example  formula      can be encoded in the input language of f lp as
holdsat f t       holdsat f t    not releasedat f t     
not   e   happens e t    terminates e f t   

the usual lparse and gringo rules  which have the rule arrow     are also allowed
in f lp  such rules are simply copied to the output  the program returned by f lp can
be passed to asp grounders and solvers that accept lparse and gringo languages 

   computing the event calculus using asp solvers
using translation f lp  we further turn the event calculus reformulation in section     into
answer set programs  the following procedure describes the process 
definition    translation ec asp 
   given an event calculus description       rewrite
all the definitional axioms of the form
def

x p x   g 

    

in  as x g  p x    where g is obtained from g by prepending  to
all occurrences of intensional predicates initiates  terminates  releases  happens 
ab             ab n   also prepend  to the strictly positive occurrences of the intensional
predicates in the remaining axioms of   let   be the resulting formula obtained
from  
   
   
   
   

http   www tcs hut fi software smodels
http   potassco sourceforge net
for instance   x y     q x y     p x y  is turned into    x  y   not q x y     p x y  
alternatively this can be done by declaring variables using the  domain directive in lparse and gringo
languages 

   

fireformulating the situation calculus and the event calculus

   apply translation f lp on         with the intensional predicates
 initiates  terminates  releases  happens  ab             ab n    p 
where p is the set of all predicate constants p in      as considered in step   
the following theorem states the correctness of the translation 
theorem   let t be an event calculus description      of signature  that contains finitely
many predicate constants  let f be the fol representation of the program obtained from t
by applying translation ec asp  then t is  equivalent to sm f   
in view of the theorem  system f lp can be used to compute event calculus descriptions
by a simple rewriting as stated in translation ec asp    the system can be used in place
of the dec reasoner in many existing applications of the event calculus  such as in robotics 
security  video games  and web service composition  as listed in
http   decreasoner sourceforge net csr decapps html  
the computational mechanism of the dec reasoner is similar to our method as it is
based on the reduction of event calculus reasoning to propositional satisfiability and uses
efficient sat solvers for computation  however  our method has some advantages 
first  it is significantly faster due to the efficient grounding mechanisms implemented
in asp systems  this is evidenced in some experiments reported in appendix b 
second  f lp allows us to compute the full version of the event calculus  assuming that
the domain is given and finite  on the other hand  the reduction implemented in the dec
reasoner is based on completion  which is weaker than circumscription  this makes the
system unable to handle recursive axioms and disjunctive axioms  such as effect constraints
and disjunctive event axioms  section       for example  the dec reasoner does not allow
the following effect constraints which describe the indirect effects of an agents walking on
the objects that he is holding 
holdsat holding a  o   t   initiates e  inroom a  r   t 
 initiates e  inroom o  r   t 
holdsat holding a  o   t   terminates e  inroom a  r   t 
 terminates e  inroom o  r   t  

    

third  we can enhance the event calculus reasoning by combining asp rules with the
event calculus description  in other words  the event calculus can be viewed as a high
level action formalism on top of asp  we illustrate this using the example from the work
of dogandag  ferraris  and lifschitz         there are   rooms and    doors as shown in
figure    initially the robot robby is in the middle room and all the doors are closed 
the goal of the robot is to make all rooms accessible from each other  figure    file robby 
shows an encoding of the problem in the language of f lp  atom door x  y  denotes that
there is a door between rooms x and y  open x  y  denotes the event robby opening the door
    kim  lee  and palla        presented a prototype of f lp called ecasp that is tailored to the event
calculus computation 

   

filee   palla

figure    robbys apartment in a      grid
between rooms x and y  goto x  denotes the event robby going to room x  opened x  y 
denotes that the door between x and y has been opened  inroom x  denotes that robby
is in room x  accessible x  y  denotes that y is accessible from x  note that the rules
defining the relation accessible are not part of event calculus axioms  section       this
example illustrates an advantage of allowing asp rules in event calculus descriptions 
the minimal number of steps to solve the given problem is     we can find such a
plan using the combination of f lp  gringo  grounder  and claspd  solver for disjunctive
programs  in the following way    
  f lp dec robby   gringo  c maxstep      claspd
file dec is an f lp encoding of the domain independent axioms in the discrete event
calculus  the file is listed in appendix a     the following is one of the plans found 
happens open         happens open         happens open        
happens goto       happens open         happens open        
happens goto       happens open         happens goto      
happens open         happens open         

   computing the situation calculus using asp solvers
using translation f lp  we further turn the situation calculus reformulations in sections    
and     into answer set programs 
    representing causal action theories by answer set programs
the following theorem shows how to turn causal action theories into answer set programs 
theorem   let d be a finite causal action theory      of signature  that contains finitely
many predicate constants  and let f be the fol representation of the program obtained by
applying translation f lp on

dcaused  dposs   drest
 dsit

    

with the intensional predicates  caused   poss  sit   then d is  equivalent to sm f   
    one can use clingo instead of gringo and claspd if the output of f lp is a nondisjunctive program 
    the file is also available at http   reasoning eas asu edu f lp  along with f lp encodings of the
domain independent axioms in other versions of the event calculus 

   

fireformulating the situation calculus and the event calculus

  file robby
  objects
step    maxstep  
astep    maxstep       maxstep     
room       
  variables
 domain step t  
 domain room r  
 domain room r   
 domain room r   
  position of the
door r  r      r 
door r  r      r 
door r  r      r 
door r  r      r 

doors
      
      
      
      

r 
r 
r 
r 

      r        r        r    r    
       r        r        r    r    
       r         r         r    r    
  r    

door r  r      door r  r   
  fluents
fluent opened r r       door r  r   
fluent inroom r   
  f ranges over the fluents
 domain fluent f  
  events
event open r r       door r r   
event goto r   
  e and e  range over the events
 domain event e  
 domain event e   
  effect axioms
initiates open r r   opened r r   t  
initiates open r r   opened r  r  t  
initiates goto r   inroom r   t 
   holdsat opened r  r   t    holdsat inroom r   t  
terminates e inroom r   t 
   holdsat inroom r   t    initiates e inroom r   t  
  action precondition axioms
holdsat inroom r   t     happens open r  r   t  

   

filee   palla

  event occurrence constraint
not happens e  t     happens e t    e    e  
  state constraint
not holdsat inroom r   t     holdsat inroom r   t    r     r  
  accessibility
accessible r r  t     holdsat opened r r   t  
accessible r r  t     accessible r r  t    accessible r  r  t  
  initial state
not holdsat opened r  r      
holdsat inroom       
  goal state
not not accessible r r  maxstep  
  happens is exempt from minimization in order to find a plan 
 happens e t      t   maxstep 
  all fluents are inertial
not releasedat f    

figure    robby in f lp

similar to the computation of the event calculus in section    the herbrand stable
models of      can be computed using f lp and answer set solvers  the input to f lp can
be simplified as we limit attention to herbrand models  we can drop axioms          as
they are ensured by herbrand models  also  in order to ensure finite grounding  instead of
dsit   we include the following set of rules situation in the input to f lp 
nesting   s   
nesting l   do a s      nesting l s    action a    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  

situation is used to generate finitely many situation terms whose depth is up to maxdepth 
the value that can be given as an option in invoking gringo  using the splitting theorem
 section c     it is not difficult to check that if a program  containing these rules has
no occurrence of predicate nesting in any other rules and has no occurrence of predicate situation in the head of any other rules  then every answer set of  contains
atoms situation do am   do am    do         do a    s       for all possible sequences of actions
a            am for m              maxdepth  though this program does not satisfy syntactic conditions  such as  restricted  gebser  schaub    thiele          restricted  syrjanen        
or finite domain programs  calimeri  cozza  ianni    leone         that answer set solvers
usually impose in order to ensure finite grounding  the rules can still be finitely grounded
   

fireformulating the situation calculus and the event calculus

  file  suitcase
value t  
value f  

lock l   

lock l   

 domain value v  
 domain lock x  
fluent up x   
fluent open  
 domain fluent f  
action flip x   
 domain action a  
depth    maxdepth  
 domain depth l  
  defining the situation domain
nesting   s   
nesting l   do a s      nesting l s    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  
  basic axioms
h f s     situation s    caused f t s  
not h f s     situation s    caused f f s  
  d caused
caused up x  f do flip x  s    situation s    not final s    poss flip x  s    h up x  s  
caused up x  t do flip x  s    situation s    not final s    poss flip x  s    not h up x  s  
caused open t s     situation s    h up l   s    h up l   s  
  d poss
poss flip x  s     situation s  
  frame axioms
h f do a s    h f s    situation s    not final s    poss a s 
  not   v  caused f v do a s   
not h f do a s    not h f s    situation s    not final s    poss a s 
  not   v  caused f v do a s   
  h is non intensional 
 h f s      situation s  

figure    lins suitcase in the language of f lp
   

filee   palla

by gringo version   x  which does not check such syntactic conditions    it is not difficult
to see why the program above leads to finite grounding since we provide an explicit upper
limit for the nesting depth of function do 
in addition to situation   we use the following program executable in order to represent
the set of executable situations  reiter        
executable s   
executable do a s      executable s    poss a s    not final s 
  situation s    action a  

figure   shows an encoding of lins suitcase example        in the language of f lp
 h is used to represent holds   which describes a suitcase that has two locks and a spring
loaded mechanism which will open the suitcase when both locks are up  this example
illustrates how the ramification problem is handled in causal action theories  since we fix
the domain of situations to be finite  we require that actions not be effective in the final
situations  this is done by introducing atom final s  
consider the simple temporal projection problem by lin         initially the first lock
is down and the second lock is up  what will happen if the first lock is flipped  intuitively 
we expect both locks to be up and the suitcase to be open  we can automate the reasoning
by using the combination of f lp  gringo and claspd  first  we add executable and the
following rules to the theory in figure    in order to check if the theory entails that flipping
the first lock is executable  and that the suitcase is open after the action  we encode the
negation of these facts in the last rule 
  initial situation
   h up l   s   
h up l   s   
  query
   executable do flip l   s      h open do flip l   s    

we check the answer to the temporal projection problem by running the command 
  f lp suitcase   gringo  c maxdepth     claspd

claspd returns no answer set as expected 
now  consider a simple planning problem for opening the suitcase when both locks are
initially down  we add executable and the following rules to the theory in figure    the
last rule encodes the goal 
  initial situation
   h up l   s   
   h up l   s   
   h open s   
  goal
   not   s    executable s    h open s   

when maxdepth is    the combined use of f lp  gringo and claspd results in no
answer sets  and when maxdepth is    it finds the unique answer set that contains both
    similarly  system dlv complex allows us to turn off the finite domain checking  option  nofdcheck  
that system was used in a conference paper  lee   palla        that this article is based on 

   

fireformulating the situation calculus and the event calculus

h open  do flip l    do flip l    s     and h open  do flip l    do flip l    s      each
of which encodes a plan  in other words  the single answer set encodes multiple plans
in different branches of the situation tree  which allows us to combine information about
the different branches in one model  this is an instance of hypothetical reasoning that is
elegantly handled in the situation calculus due to its branching time structure  belleghem 
denecker  and schreye        note that the linear time structure of the event calculus is
limited to handle such hypothetical reasoning allowed in the situation calculus 
    representing basic action theories by answer set programs
since a bat t  not including the second order axiom       can be viewed as a first order
theory under the stable model semantics with the list of intensional predicates being empty 
it follows that f lp can be used to turn t into a logic program  as before  we focus on
asp style bat 
theorem    let t be a asp style bat      of signature  that contains finitely many
predicate constants  and let f be the fol representation of the program obtained by applying translation f lp on t with intensional predicates  holds   holds  poss   then
sm t   holds  holds  poss  is  equivalent to sm f    f     poss   
figure   shows an encoding of the broken object example discussed by reiter        
consider the simple projection problem of determining if an object o  which is next to
bomb b  is broken after the bomb explodes  we add executable and the following rules to
the theory in figure   
  initial situation
not h broken o  s     h fragile o  s     h nexto b o  s   
not h holding p o  s     not h exploded b  s   
  query
   executable do explode b  s      h broken o  do explode b  s    

the command
  f lp broken   gringo  c maxdepth     claspd

returns no answer set as expected 

   related work
identifying a syntactic class of theories on which different semantics coincide is important
in understanding the relationship between them  it is known that  for tight logic programs
and tight first order formulas  the stable model semantics coincides with the completion
semantics  fages        erdem   lifschitz        ferraris et al          this fact helps us
understand the relationship between the two semantics  and led to the design of the answer
set solver cmodels      that computes answer sets using completion  likewise the class
of canonical formulas introduced here helps us understand the relationship between the
stable model semantics and circumscription  the class of canonical formulas is the largest
    http   www cs utexas edu users tag cmodels

   

filee   palla

  file  broken
  domains other than situations
person p  
object o  
bomb b  
 domain person r  
 domain object y  
 domain bomb b  
fluent holding r y   
fluent broken y   

fluent nexto b y   
fluent exploded b   

fluent fragile y   

action drop r y   

action explode b   

action repair r y   

 domain fluent f  
 domain action a  
depth    maxdepth  
 domain depth l  
  defining the situation domain
nesting   s   
nesting l   do a s      nesting l s    l   maxdepth 
situation s     nesting l s  
final s     nesting maxdepth s  
  effect axioms
h broken y  do drop r y  s      situation s    h fragile y  s    not final s  
h broken y  do explode b  s      situation s    h nexto b y  s    not final s  
h exploded b  do explode b  s      situation s    not final s  
 h broken y  do repair r y  s      situation s    not final s  
 h holding r y  do drop r y  s      situation s    not final s  
  action precondition axioms
poss drop r y  s     h holding r y  s    situation s  
poss explode b  s     situation s    not h exploded b  s  
poss repair r y  s     situation s    h broken y  s  
  inertial axioms
h f do a s      h f s    not  h f do a s     situation s    not final s  
 h f do a s       h f s    not h f do a s     situation s    not final s  
  d exogeneous  
h f s      h f s   
  consider only those interpretations that are complete on holds
   not h f s    not  h f s    situation s  

figure    broken object example in the language of f lp

   

fireformulating the situation calculus and the event calculus

syntactic class of first order formulas identified so far on which the stable models coincide
with the models of circumscription  in other words  minimal model reasoning and stable
model reasoning are indistinguishable on canonical formulas 
proposition   from the work of lee and lin        shows an embedding of propositional circumscription in logic programs under the stable model semantics  our theorem
on canonical formulas is a generalization of this result to the first order case  janhunen
and oikarinen        showed another embedding of propositional circumscription in logic
programs  and implemented the system circ dlp    but their translation appears quite
different from the one by lee and lin 
zhang  zhang  ying  and zhou        show an embedding of first order circumscription
in first order stable model semantics  theorem   from that paper is reproduced as follows   
theorem     zhang et al         thm     let f be a formula in negation normal form
and let p be a finite list of predicate constants  let f  be the formula obtained from f
by replacing every p t  by p t   and let f c be the formula obtained from f by replacing
every p t  by p t   choice p   where p is in p and t is a list of terms  then circ f   p 
is equivalent to sm f   f c   p  
in comparison with theorem    this theorem can be applied to characterize circumscription of arbitrary formulas in terms of stable models by first rewriting the formulas into
negation normal form  while theorem   is applicable to canonical formulas only  it does
not require any transformation  and the characterization is bidirectional in the sense that
it can be also viewed as a characterization of stable models in terms of circumscription 
zhang et al         also introduce a translation that turns arbitrary first order formulas
into logic programs  but this work is limited to finite structures only  on the other hand 
our translation f lp  definition    works for almost universal formulas only  but is not
limited to finite structures 
the situation calculus and the event calculus are widely studied action formalisms 
and there are several papers that compare and relate them  e g   belleghem  denecker   
schreye        provetti        belleghem et al         kowalski   sadri        
prolog provides a natural implementation for basic action theories since definitional
axioms can be represented by prolog rules according to the clarks theorem  reiter       
chapter     the lloyd topor transformation that is used to turn formulas into prolog rules
is similar to translation f lp  but the difference is that the former preserves the completion
semantics and the latter preserves the stable model semantics 
lin and wang        describe a language that can be used to represent a syntactically
restricted form of lins causal situation calculus  called clausal causal theories  which does
not allow quantifiers  they show how to translate that language into answer set programs
with strong negation  the answer sets of which are then used to obtain fully instantiated
successor state axioms and action precondition axioms  this is quite different from our
approach  which computes the propositional models of the full situation calculus theories
directly 
kautz and selman        introduce linear encodings that are similar to a propositionalized version of the situation calculus  mccarthy   hayes         lin        introduces
    http   www tcs hut fi software circ dlp
    this is a bit simpler than the original statement because some redundancy is dropped 

   

filee   palla

an action description language and describes a procedure to compile an action domain in
that language into a complete set of successor state axioms  from which a strips like
description can be extracted  the soundness of the procedure is shown with respect to a
translation from action domain descriptions into lins causal action theories  however  that
procedure is based on completion and as such cannot handle recursive axioms unlike our
approach 
denecker and ternovska        present an inductive variant of the situation calculus
represented in id logic  denecker   ternovska       classical logic extended with inductive definitions  id logic and the first order stable model semantics appear to be closely
related  but the precise relationship between them has yet to be shown 

   conclusion
the first order stable model semantics is defined similar to circumscription  this paper
takes advantage of that definition to identify a class of formulas on which minimal model
reasoning and stable model reasoning coincide  and uses this idea to reformulate the situation calculus and the event calculus in the first order stable model semantics  together
with the translation that turns an almost universal sentence into a logic program  we show
that reasoning in the situation calculus and the event calculus can be reduced to computing
answer sets  we implemented system f lp  a front end to asp solvers that allows us to
compute these circumscriptive action theories  the mathematical tool sets and the system presented in this paper may also be useful in relating other circumscriptive theories
to logic programs  also  the advances in asp solvers may improve the computation of
circumscriptive theories 

acknowledgments
we are grateful to yuliya lierler  vladimir lifschitz  erik mueller  heng zhang  yan zhang 
and the anonymous referees for their useful comments and discussions  the authors were
partially supported by the national science foundation under grant iis         

appendix a  file dec in the language of f lp
file dec encodes the domain independent axioms in the discrete event calculus  this file
is to be used together with event calculus domain descriptions as shown in section   
  file dec
 domain
 domain
 domain
 domain
 domain
 domain
 domain

fluent f  
fluent f   
fluent f   
event e  
time t  
time t   
time t   

time    maxstep  
   

fireformulating the situation calculus and the event calculus

  dec  
stoppedin t  f t      happens e t    t  t   t t    terminates e f t  
  dec  
startedin t  f t      happens e t    t  t   t t    initiates e f t  
  dec  
holdsat f  t  t      happens e t     initiates e f  t     t     
trajectory f  t  f  t     not stoppedin t  f  t  t     t  t   maxstep 
  dec  
holdsat f  t  t      happens e t     terminates e f  t       t   
antitrajectory f  t  f  t     not startedin t  f  t  t    
t  t   maxstep 
  dec  
holdsat f t       holdsat f t    not releasedat f t     
not   e   happens e t    terminates e f t     t maxstep 
  dec  
not holdsat f t       not holdsat f t    not releasedat f t     
not   e   happens e t    initiates e f t     t maxstep 
  dec  
releasedat f t     releasedat f t    not   e   happens e t   
 initiates e f t    terminates e f t      t maxstep 
  dec  
not releasedat f t       not releasedat f t   
not   e    happens e t    releases e f t     t maxstep 
  dec  
holdsat f t       happens e t    initiates e f t    t maxstep 
  dec   
not holdsat f t       happens e t    terminates e f t    t maxstep 
  dec   
releasedat f t       happens e t    releases e f t    t maxstep 
  dec   
not releasedat f t       happens e t   
 initiates e f t    terminates e f t     t maxstep 
 holdsat f t   
 releasedat f t   

   

filee   palla

problem
 max  step 

dec
reasoner

dec
reasoner  minisat 

f lp with
lparse   cmodels

f lp with
gringo   cmodels

f lp with
gringo   clasp d 

f lp with
clingo

busride
    











   s
     s       s 
a       r      

    s

kitchen
sink     

    s
     s      s 
a      c      

    s
     s       s 
a      c      

    s
     s       s 
a       r      

    s

thielscher
circuit     

   s
    s      s 
a      c      

   s
    s      s 
a      c      

    s
     s       s 
a      r      

   s

walking
turkey     





    s
     s       s 
a     r    

    s

falling w 
antitraj     

     s
      s      s 
a     c     

     s
      s       s 
a     c     

    s
     s       s 
a      r     

    s

falling w 
events     

    s
     s      s 
a      c      

    s
     s      s 
a      c      

    s
     s       s 
a       r      

    s

hotair
baloon     

    s
     s      s 
a     c     

    s
     s      s 
a     c     

   s
    s      s 
a      r     

    s

telephone 
    

   s
    s      s 
a      c      

   s
    s      s 
a      c      

    s
     s       s 
a     r    
c  
    s
     s       s 
a      r      
c     
    s
     s       s 
a       r      
c  
    s
     s      s 
a      r      
c  
    s
     s       s 
a     r    
c  
    s
     s       s 
a      r     
c  
    s
     s       s 
a      r      
c     
   s
    s      s 
a     r     
c    
    s
     s       s 
a      r      
c  

    s
     s       s 
a     r    

commuter
    

    s
     s       s 
a     r     
c  
     s
      s        s 
a       r        
c  
    s
     s       s 
a        r       
c  
    s
     s       s 
a      r      
c  
    s
     s       s 
a     r    
c  
    s
     s       s 
a      r     
c  
    s
     s       s 
a      r       
c     
    s
     s       s 
a     r     
c    
    s
     s       s 
a       r      
c  

    s
     s       s 
a      r      

    s

a  number of atoms  c  number of clauses  r  number of ground rules
figure    comparing the dec reasoner and f lp with answer set solvers

appendix b  comparing the dec reasoner with asp based event
calculus reasoner
we compared the performance of the dec reasoner  v      running relsat  v      and
minisat  v      with the following 
 f lp  v       with lparse  v         cmodels  v       running minisat  v    
beta  
 f lp  v       with gringo  v        cmodels  v       running minisat  v     beta  
 f lp  v       with gringo  v         clasp  v         claspd  v        used instead
for disjunctive programs   and
 f lp  v       with clingo  v        clasp v         
f lp turns an input theory into the languages of lparse and gringo  and lparse and
gringo turn the result into a ground asp program  cmodels turns this ground program
into a set of clauses and then invokes a sat solver to compute answer sets  while clasp
computes answer sets using the techniques similar to those used in sat solvers  clingo is
a system that combines gringo and clasp in a monolithic way 
the first five examples in figure   are part of the benchmark problems from the work
of shanahan               the next four are by mueller          we increased timepoints
   

fireformulating the situation calculus and the event calculus

problem
 max  step 
zootest 
    

f lp with
gringo   cmodels
     s
     s        s 
a        r        
c        
zootest 
   h
      s
    
      s         s 
a         r        
c        
zootest 
   h
      s
    
      s         s 
a         r        
c        
a  number of atoms  c  number of clauses  r  number
dec
reasoner  minisat 
   h

f lp with
gringo   clasp
     s
     s        s 
a        r        
      s
      s         s 
a        r        
      s
      s         s 
a        r        
of ground rules

figure    zoo world in dec reasoner and asp

to see more notable differences   more examples can be found from the f lp homepage  all
experiments were done on a pentium machine with      ghz cpu and  gb ram running
   bit linux  the reported run times are in seconds and were obtained using the linux
time command  user time   sys time   except for the dec reasoner for which we recorded
the times reported by the system  this was for fair comparisons in order to avoid including
the time spent by the dec reasoner in producing output in a neat format  which sometimes
takes non negligible time  for the dec reasoner  the times in parentheses are  sat encoding time   sat solving time   for the others  they are the times spent by each of the
grounder and the solver  cmodels time includes the time spent in converting the ground
program generated by lparse gringo into a set of clauses  and calling the sat solver 
the time spent by f lp in translating an event calculus description into an answer set
program  retaining variables  is negligible for these problems   denotes that the system
cannot solve the example due to the limited expressivity  for instance  busride includes
disjunctive event axioms  which results in a disjunctive program that cannot be handled
by clingo  similarly  the dec reasoner cannot handle busride  disjunctive event axioms  
commuter  compound events  and walking turkey  effect constraints   as is evident from
the experiments  the main reason for the efficiency of the asp based approach is the efficient grounding mechanisms implemented in the asp grounders  though the dec reasoner
and cmodels call the same sat solver minisat  the number of atoms processed by the dec
reasoner is in general much smaller  this is because the dec reasoner adopts an optimized
encoding method  that is based on predicate completion  which avoids a large number of
ground instances of atoms such as initiates e  f  t   terminates e  f  t   and releases e  f  t 
 mueller        section       on the other hand  in several examples  the number of clauses
generated by cmodels is    which means that the answer sets were found without calling
the sat solver  this is because for these examples the unique answer set coincides with
the well founded model  which is efficiently computed by cmodels in a preprocessing step
before calling sat solvers  out of the    benchmark examples by shanahan              
   of them belong to this case when lparse is used for grounding 
   

filee   palla

in the experiments in figure    the solving times are negligible for most of the problems  we also experimented with some computationally hard problems  where solving takes
more time than grounding  figure   shows runs of a medium size action domain  the zoo
world  akman  erdogan  lee  lifschitz    turner         all the tests shown in the table
are planning problems where max  step is the length of a minimal plan  the cut off time
was   hours and the dec reasoner did not terminate within that time for any of the problems  in fact  the entire time was spent on sat encoding and the sat solver was never
called  on the other hand  the asp grounder gringo took only a few seconds to ground
the domain and  unlike in figure    the solvers took much more time than the grounder  as
we can see  cmodels with minisat performed better than clasp on two of the problems 
to check the time taken by minisat on the encoding generated by the dec reasoner  we
ran zootest  to completion  the dec reasoner terminated after          seconds       
hours  

appendix c  proofs
c   review of some useful theorems
we review some theorems by ferraris et al         and ferraris et al         which will be
used to prove our main results  in fact  we will provide a version of the splitting theorem
which is slightly more general than the one given by ferraris et al          in order to
facilitate our proof efforts 
lemma   formula
u  p    f    u   f  
is logically valid 
theorem     ferraris et al         thm     for any first order formula f and any
disjoint lists p  q of distinct predicate constants 
sm f   p   sm f  choice q   p  q 
is logically valid 
let f be a first order formula  a rule of f is an implication that occurs strictly positively
in f   the predicate dependency graph of f  relative to p  is the directed graph that
 has all members of p as its vertices  and
 has an edge from p to q if  for some rule g  h of f  
 p has a strictly positive occurrence in h  and
 q has a positive occurrence in g that does not belong to any subformula of g
that is negative on p 
theorem     ferraris et al         splitting thm   let f   g be first order sentences 
and let p  q be finite disjoint lists of distinct predicate constants  if
   

fireformulating the situation calculus and the event calculus

 a  each strongly connected component of the predicate dependency graph of f  g relative
to p  q is either a subset of p or a subset of q 
 b  f is negative on q  and
 c  g is negative on p
then
sm f  g  p  q   sm f   p   sm g  q 
is logically valid 
the theorem is slightly more general than the one by ferraris et al         in that the
notion of a dependency graph above yields less edges than the one given by ferraris et al 
instead of
 q has a positive occurrence in g that does not belong to any subformula of g
that is negative on p 
ferraris et al s definition has
 q has a positive occurrence in g that does not belong to any subformula of the
form k 
for instance  according to ferraris et al   the dependency graph of
  p  q   r   p

    

relative to p has two edges  from p to r  and from p to p   while the dependency graph
according to our definition has no edges 
on the other hand  the generalization is not essential in view of the following theorem 
theorem     ferraris et al         thm  on double negations  let h be a sentence  f
a subformula of h  and h  the sentence obtained from h by inserting  in front of f  
if the occurrence of f is p negated in h  then sm h  p  is equivalent to sm h    p  
for instance  sm       p  is equivalent to sm   p  q   r   p  p   the dependency
graph of   p  q   r   p relative to p according to the definition by ferraris et al  is
identical to the dependency graph of      relative to p according to our definition 
next  we say that a formula f is in clark normal form  relative to the list p of intensional
predicates  if it is a conjunction of sentences of the form
x g  p x   

    

one for each intensional predicate p  where x is a list of distinct object variables  and g has
no free variables other than those in x  the completion  relative to p  of a formula f in
clark normal form is obtained by replacing each conjunctive term      with
x p x   g  
the following theorem relates sm to completion  we say that f is tight on p if the
predicate dependency graph of f relative to p is acyclic 
theorem     ferraris et al         for any formula f in clark normal form that is tight
on p  formula sm f   p  is equivalent to the completion of f relative to p 
   

filee   palla

c   proof of proposition  
using theorem    and theorem    
sm f   p   sm f   p  pr  f     sm    p pr  f   
 sm f   p  pr  f     false p pr  f   
 sm f  choice pr  f   p    false p pr  f   
 sm f  choice pr  f   p   false p pr  f     

c   proof of theorem  
in the following  f is a formula  p is a list of distinct predicate constants p            pn   and u
is a list of distinct predicate variables u            un of the same length as p 
lemma    ferraris et al         lemma    formula
u  p   f   u   f  
is logically valid 
lemma   if every occurrence of every predicate constant from p is strictly positive in f  
 u  p    f   u   f  u  
is logically valid 
proof  by induction  we will show only the case when f is g  h  the other cases are
straightforward  consider
f   u     g  u   h   u     g  h  
since every occurrence of predicate constants from p in f is strictly positive  g contains
no predicate constants from p  so that g  u  is equivalent to g u   which is the same as
g  also  by i h   h   u   h u  is logically valid  therefore it is sufficient to prove that
under the assumption u  p 
 g  h u     g  h    g  h u  
is logically valid  from left to right is clear  assume  u  p   g  h u   and g  we get
h u   which is equivalent to h   u  by i h  by lemma    we conclude h 

the proof of theorem   is immediate from the following lemma  which can be proved
by induction 
lemma   if f is canonical relative to p  then formula
 u  p   f   f   u   f  u  
is logically valid 
   

fireformulating the situation calculus and the event calculus

proof 
 f is an atomic formula  trivial 
 f   g  h  follows from i h 
 f   g  h  assume  u  p    g  h   since g  h is canonical relative to p 
every occurrence of every predicate constant from p is strictly positive in g or in h 
so that  by lemma    g  u  is equivalent to g u   and h   u  is equivalent to h u  
 f   g  h  assume  u  p    g  h   it is sufficient to show
 g  u   h   u     g u   h u   

    

since g  h is canonical relative to p  every occurrence of every predicate constant
from p in g is strictly positive in g  so that  by lemma    g  u  is equivalent to
g u  
 case    g  by lemma    g  u   the claim follows since g  u  is equivalent
to g u  
 case    h  by i h  h   u  is equivalent to h u   the claim follows since g  u 
is equivalent to g u  
 f   xg  follows from i h 
 f   xg  since every occurrence of every predicate constant from p in g is strictly
positive in g  the claim follows from lemma   

c   proof of theorem  
proof  between  a  and  b  
between  b  and  c  

follows immediately from theorem   

note first that  is equivalent to sm      since

 every strongly connected component in the dependency graph of    relative to
 i  t  r  h  either belongs to  i  t  r  or  h  
  is negative on  h   and
  is negative on  i  t  r  
it follows from theorem    that  b  is equivalent to
sm     i  t  r  h   sm   ab            abn    sm    
similarly  applying theorem    repeatedly  we can show that the above formula is
equivalent to  c  
between  c  and  d  

by proposition   



   

filee   palla

c   proof of theorem  
since dcaused is canonical relative to caused   by theorem     a 

between  a  and  b  
is equivalent to


sm dcaused   caused    dposs  drest
      

    

consequently  it is sufficient to prove the claim that  under the assumption s sit s  
formula      is equivalent to sm dsit   sit  
first note that under the assumption       can be equivalently rewritten as

p p s     a  s p s   p do a  s     p   sit  
    
on the other hand  under s sit s   sm dsit   sit  is equivalent to
sit s     a  s sit s   sit do a  s   

 p p   sit   p s     a  s p s   p do a  s     a  s sit s   sit do a  s      
which  under the assumption s sit s   is equivalent to
p p s     a  s p s   p do a  s      p   sit 



and furthermore to      
between  b  and  c   since  s  does not contain poss  the equivalence follows from the
equivalence between completion and the stable model semantics 
between  c  and  d   since dcaused contains no strictly positive occurrence of poss
and dposs  contains no occurrence of caused   every strongly connected component in the
predicate dependency graph of dcaused  dposs  relative to  caused   poss  either belongs
to  caused   or belongs to  poss   by theorem     it follows that  b  is equivalent to

sm dcaused  dposs    caused   poss   drest
 sm dsit   sit  

similarly  applying theorem    two more times  we get that the above formula is equivalent
to  c  

c   proof of theorem  
theory t is
  deffect  dprecond  ds   duna  dinertia  dexogenous   
and the corresponding bat is
  dss  dap  ds   duna  
without loss of generality  we assume that t is already equivalently rewritten so that there
are exactly one positive effect axiom and exactly one negative effect axiom for each fluent r 
and that there is exactly one action precondition axiom for each action a 
   

fireformulating the situation calculus and the event calculus

consider
sm   deffect  dprecond  ds   duna  dinertia  dexogenous    poss  holds  holds  
since  and duna are negative on the intensional predicates  the formula is equivalent to
sm deffect  dprecond  ds   dinertia  dexogenous    p oss  holds  holds     duna  
    
since p oss does not occur in
deffect  ds   dinertia  dexogenous   
and since dprecond is negative on  holds  holds   by theorem          is equivalent to
sm deffect  ds   dinertia  dexogenous    holds  holds 
 sm dprecond   p oss     duna  

    

which is equivalent to
sm deffect  ds   dinertia  dexogenous    holds  holds 
 dap    duna  
therefore the statement of the theorem can be proven by showing the following  if

i    x a s  
r  x  a  s   r  x  a  s  

    

i    

    

sm ds   dexogenous   deffect  dinertia   holds  holds 

    

for every fluent r  and
then i satisfies

iff i  satisfies
ds   dss  
from dexogenous    it follows that      is equivalent to
sm ds
 dexogenous   deffect  dinertia   holds  holds  
 

    

where ds
is the formula obtained from ds  by prepending  to all occurrences of holds 
 
under the assumption      
ds
 dexogenous   deffect  dinertia
 
is  holds  atomic tight w r t  i     so that by the relationship between completion and sm
that is stated in corollary    of  lee   meng         we have that i         iff i satisfies
ds    and  for each fluent r 
    see section   from the work of lee and meng        for the definition 

   

filee   palla

holds r x   do a  s     
r  x  a  s    holds r x  s    holds r x   do a  s   

    

and
holds r x   do a  s    
r  x  a  s    holds r x   s   holds r x   do a  s         
where x  a  s are any  lists of  object names of corresponding sorts 
it remains to show that  under the assumption       i satisfies            iff i  satisfies

holds r x   do a  s     
r  x  a  s    holds r x   s   r  x  a  s   

    

in the following we will use the following facts 
 i   holds r x   s  iff i      holds r x   s  
 if f is a ground formula that does not contain   then i    f iff i     f  
left to right  assume i               
 case    i     holds r x   do a  s    clearly  i    holds r x   do a  s    so that 
from       there are two subcases to consider 
 subcase    i     
r  x  a  s   clearly  i  satisfies both lhs and rhs of      
 subcase    i    holds r x   s   from       it follows that i     
r  x  a  s   and
 x 
a 
s  
clearly 
i 
satisfies
both
lhs
and
rhs of      
consequently  i      

r
 case    i      holds r x   do a  s    it follows from      that i      
r  x  a  s   which
 x 
a 
s  
also
since
i
  holds r x  
do a  s   
is equivalent to saying that i       
r
from       there are two subcases to consider 
 subcase    i    
r  x  a  s   clearly  i  satisfies neither lhs nor rhs of      
 subcase    i     holds r x   s   this is equivalent to saying that i     
holds r x   s   clearly  i  satisfies neither lhs nor rhs of      
right to left  assume i          
 case    i    holds r x   do a  s    it follows from      that i  satisfies rhs of      
so that there are two subcases to consider 
 subcase    i      
r  x  a  s   clearly  i satisfies both lhs and rhs of      
also from       it follows that i     
r  x  a  s   consequently  i satisfies neither
lhs nor rhs of      
 subcase    i     holds r x   s   
r  x  a  s   clearly  i satisfies both lhs and
rhs of       since i     
 x 
a 
s  
i
satisfies neither lhs nor rhs of      
r
 case    i   holds r x   do a  s    it follows from      that i       
r  x  a  s   and
i       holds r x   s   
 x 
a 
s   
from
the
latter 
consider
the
two
subcases 
r
   

fireformulating the situation calculus and the event calculus

 subcase    i      holds r x   s   clearly  i satisfies neither lhs nor rhs of
      and satisfies both lhs and rhs of      
 subcase    i      
r  x  a  s   clearly  i satisfies neither lhs nor rhs of      
and satisfies both lhs and rhs of      

c   proof of proposition  
lemma   let f be a formula  let p be a list of distinct predicate constants  let g be a
subformula of f and let g  be any formula that is classically equivalent to g  let f   be the
formula obtained from f by substituting g  for g  if the occurrence of g is in a subformula
of f that is negative on p and the occurrence of g  is in a subformula of f   that is negative
on p  then
sm f   p   sm f     p 
is logically valid 
proof  let f  be the formula obtained from f by prepending  to g  and let  f    
be the formula obtained from f   by prepending  to g    by the theorem on double
negations  theorem      the following formulas are logically valid 
sm f   p   sm f    p  
sm f     p   sm  f       p  
from lemma    it follows that
 u  p   g  g        f     u     f        u  
is logically valid  where u is a list of predicate variables corresponding to p  consequently 
sm f    p   sm  f       p 
is logically valid 



proof of proposition    in formula
sm f    xy g y  x   q x    p  q  

    

clearly  f   is negative on q and xy g y  x   q x   is negative on p  let h be any
subformula of f that is negative on p and contains the occurrence of yg y  x   consider
two cases 
 case    the occurrence of yg y  x  in h is not strictly positive  thus the dependency
graph of f    xy g y  x   q x   relative to  p  q  has no incoming edges into q 
 case    the occurrence of yg y  x  in h is strictly positive  since h is negative on p  yg y  x  is negative on p as well  so that the dependency graph of
f    xy g y  x   q x   relative to  p  q  has no outgoing edges from q 
   

filee   palla

therefore  every strongly connected component in the dependency graph belongs to either
p or  q   consequently  by theorem          is equivalent to
sm f     p   sm xy g y  x   q x    q 

    

since yg y  x  is negative on q  formula xy g y  x   q x   is tight on  q   by theorem          is equivalent to
sm f     p   x yg y  x   q x   

    

by lemma    it follows that      is equivalent to
sm f   p   x yg y  x   q x   
consequently  the claim follows 



c   proof of theorem  
it is clear that the algorithm terminates and yields a quantifier free formula k  we will
prove that sm f   p   sm xk  p  q   where x is the list of all  free  variables of k 
let f  be the formula obtained from the initial formula f by prepending double
negations in front of every maximal strictly positive occurrence of formulas of the form
yg x  y   since f is almost universal relative to p  such an occurrence is in a subformula
of f that is negative on p  thus by the theorem on double negations  theorem     
sm f   p  is equivalent to sm f    p   note that f  contains no strictly positive occurrence
of formulas of the form yg x  y  
for each iteration  let us assume that the formula before the iteration is
h       hn  
where h  is transformed from f  by the previous iterations  and each hi  i      is a
formula of the form g x  y   pg  x  that is introduced by step  b   initially h  is f 
and n      let r  be p  and let ri be each pg for hi  i       by induction we can prove
that
 i  every positive occurrence of formulas of the form yg x  y  in hi is not strictly positive  and is in a subformula of hi that is negative on ri  
 ii  every negative occurrence of formulas of the form yg x  y  in hi is in a subformula
of hi that is negative on ri  
we will prove that if step  a  or step  c  is applied to turn hk into hk    then
sm x  h    r         sm xn hn   rn  

    

sm x   h     r         sm x n hn    rn   

    

is equivalent to
where hj    hj for all j different from k  and xi  i     is the list of all free variables of
hi   and x i  i     is the list of all free variables of hi   
   

fireformulating the situation calculus and the event calculus

indeed  step  a  is a part of prenex form conversion  which preserves strong equivalence
 theorem     so it is clear that      is equivalent to      
when step  c  is applied to turn      into       since yh x  y  is in a subformula of
hk that is negative on rk   the equivalence between      and      follows from lemma   
when step  b  is applied to turn hk into hk  and introduces a new conjunctive term
 
hn     formula      is    r            rn   equivalent to
 
sm x   h     r         sm x n hn    rn    sm x n   hn  
  rn    

    

by proposition   due to condition  i  
let
  
h         hm

    

be the final quantifier free formula  where h    is transformed from f    by the induction 
it follows that sm f   p  is  equivalent to
  
sm x    h      r         sm x  m hm
  rm   

    

where each x  i     i  m  is the list of all free variables of hi    
since every non strictly positive occurrence of new predicate ri  i      in any hj      
j  m  is positive  there is no incoming edge into ri in the dependency graph of      relative
to r    r            rm   consequently  every strongly connected component of the dependency
graph belongs to one of ri  i      moreover  it is clear that each hi    i     is negative
on every rj for j    i   in the case of h      recall that the occurrence of rj for any j    
is not strictly positive since f    from which h    is obtained  contains no strictly positive
occurrence of formulas of the form yg x  y    thus by the splitting theorem  theorem     
formula      is equivalent to
  
sm x    h         x  m hm
  r       rm   

    


c   proof of theorem  
we use the notations introduced in the proof of theorem    by theorem    sm f   p  is
 equivalent to      and  by theorem          is equivalent to
  
sm x    h         x  m hm
 choice  pred   p    pred  r       rm  

    

 r  is p   where  pred is the set of all predicate constants in signature   it follows from
proposition   from  cabalar et al         that      is equivalent to
   
sm x    h          x  m hm
 choice  pred   p    pred  r       rm   

    

where hi    is obtained from hi   by applying the translation from  cabalar et al        
section    that turns a quantifier free formula into a set of rules  it is easy to see that f  
is the same as the formula
   
x    h          x  m hm
 choice  pred   p 

   

filee   palla

and  pred  r       rm is the same as p  pr  f      so that      can be written as
sm f     p  pr  f      
which is equivalent to
sm f    false p   pr  f       
by proposition   



c    proof of theorem  
assume that t is
circ   initiates  terminates  releases   circ   happens 
 circ   ab             ab n     
which is equivalent to
sm   initiates  terminates  releases   sm   happens 
 sm   ab             ab n    

    

by theorem   
let def be the set of all definitions      in   and let   be the formula obtained from 
by applying step    by theorem     it follows that each formula      in def is equivalent
to
sm x g   p x    p  
where g  is as described in step    consequently       is equivalent to
sm   initiates  terminates 
v releases   sm   happens 
 sm   ab             ab n        def sm x g   p x    p       

    

where    is the conjunction of all the axioms in   other than the ones obtained from
definitional axioms      
applying theorem    repeatedly  it follows that      is equivalent to
v
sm               def x g   p x   
initiates  terminates  releases  happens  ab             ab n   p   

    

according to the syntax of the event calculus reviewed in section     
 every positive occurrence of a formula of the form yg y  in      is contained in a
subformula that is negative on
 initiates  terminates  releases  happens  ab             ab n   p   and
 there are no negative occurrences of any formula of the form yg y  in      
consequently  the statement of the theorem follows from theorem   

   



fireformulating the situation calculus and the event calculus

c    proof of theorem  
since      is almost universal relative to  caused   poss  sit   the result follows from theorems   and   

c    proof of theorem   
from dexogenous    it follows that sm t   holds  holds  poss  is equivalent to
sm t    holds   holds  poss   where t  is obtained from t by prepending  to all
occurrences of holds in ds    from the definition of a uniform formula  reiter         it
follows that t  is almost universal relative to  holds  holds  poss   the result follows
from theorem   


references
akman  v   erdogan  s   lee  j   lifschitz  v     turner  h          representing the zoo
world and the traffic world in the language of the causal calculator  artificial
intelligence                  
belleghem  k  v   denecker  m     schreye  d  d          combining situation calculus
and event calculus  in proceedings of international conference on logic programming
 iclp   pp       
belleghem  k  v   denecker  m     schreye  d  d          on the relation between situation
calculus and event calculus  journal of logic programming                
besnard  p     cordier  m  o          explanatory diagnoses and their characterization by
circumscription  annals of mathematics and artificial intelligence                 
cabalar  p     ferraris  p          propositional theories are strongly equivalent to logic
programs  theory and practice of logic programming                
cabalar  p   pearce  d     valverde  a          reducing propositional theories in equilibrium logic to logic programs  in proceedings of portuguese conference on artificial
intelligence  epia   pp      
calimeri  f   cozza  s   ianni  g     leone  n          computable functions in asp  theory
and implementation  in proceedings of international conference on logic programming  iclp   pp         
denecker  m     ternovska  e          inductive situation calculus  artificial intelligence 
                  
denecker  m     ternovska  e          a logic of nonmonotone inductive definitions  acm
transactions on computational logic        
doherty  p   gustafsson  j   karlsson  l     kvarnstrom  j          tal  temporal action
logics language specification and tutorial  linkoping electronic articles in computer
and information science issn                     http   www ep liu se ea cis 
          
   

filee   palla

dogandag  s   ferraris  p     lifschitz  v          almost definite causal theories   in
proceedings of international conference on logic programming and nonmonotonic
reasoning  lpnmr   pp       
erdem  e     lifschitz  v          tight logic programs  theory and practice of logic
programming            
fages  f          consistency of clarks completion and existence of stable models  journal
of methods of logic in computer science          
ferraris  p   lee  j     lifschitz  v          a new perspective on stable models  in proceedings of international joint conference on artificial intelligence  ijcai   pp         
ferraris  p   lee  j     lifschitz  v          stable models and circumscription  artificial
intelligence              
ferraris  p   lee  j   lifschitz  v     palla  r          symmetric splitting in the general
theory of stable models  in proceedings of international joint conference on artificial
intelligence  ijcai   pp         
gebser  m   schaub  t     thiele  s          gringo   a new grounder for answer set
programming  in proceedings of international conference on logic programming and
nonmonotonic reasoning  lpnmr   pp         
gelfond  m     lifschitz  v          the stable model semantics for logic programming  in
kowalski  r     bowen  k   eds    proceedings of international logic programming
conference and symposium  pp            mit press 
gelfond  m     lifschitz  v          action languages  electronic transactions on artificial
intelligence             http   www ep liu se ea cis           
giunchiglia  e   lee  j   lifschitz  v   mccain  n     turner  h          nonmonotonic
causal theories  artificial intelligence                 
heyting  a          die formalen regeln der intuitionistischen logik  sitzungsberichte
der preussischen akademie von wissenschaften  physikalisch mathematische klasse 
     
janhunen  t     oikarinen  e          capturing parallel circumscription with disjunctive
logic programs  in proc  of  th european conference in logics in artificial intelligence
 jelia      pp         
kautz  h     selman  b          planning as satisfiability  in proceedings of european
conference on artificial intelligence  ecai   pp         
kim  t  w   lee  j     palla  r          circumscriptive event calculus as answer set programming  in proceedings of international joint conference on artificial intelligence
 ijcai   pp         
kowalski  r     sergot  m          a logic based calculus of events  new generation
computing          
kowalski  r  a     sadri  f          reconciling the event calculus with the situation
calculus  journal of logic programming                 
   

fireformulating the situation calculus and the event calculus

lee  j   lifschitz  v     palla  r          a reductive semantics for counting and choice
in answer set programming  in proceedings of the aaai conference on artificial
intelligence  aaai   pp         
lee  j     lin  f          loop formulas for circumscription  artificial intelligence          
       
lee  j     meng  y          first order stable model semantics and first order loop formulas 
journal of artificial inteligence research  jair              
lee  j     palla  r          yet another proof of the strong equivalence between propositional
theories and logic programs  in working notes of the workshop on correspondence
and equivalence for nonmonotonic theories 
lee  j     palla  r          situation calculus as answer set programming  in proceedings
of the aaai conference on artificial intelligence  aaai   pp         
lifschitz  v          circumscription  in gabbay  d   hogger  c     robinson  j   eds   
handbook of logic in ai and logic programming  vol     pp          oxford university press 
lifschitz  v          what is answer set programming   in proceedings of the aaai conference on artificial intelligence  pp            mit press 
lifschitz  v          datalog programs and their stable models  in de moor  o   gottlob 
g   furche  t     sellers  a   eds    datalog reloaded  first international workshop 
datalog       oxford  uk  march              revised selected papers  springer 
lifschitz  v   pearce  d     valverde  a          strongly equivalent logic programs  acm
transactions on computational logic            
lifschitz  v   tang  l  r     turner  h          nested expressions in logic programs  annals
of mathematics and artificial intelligence             
lifschitz  v     turner  h          representing transition systems by logic programs  in
proceedings of international conference on logic programming and nonmonotonic
reasoning  lpnmr   pp        
lin  f          embracing causality in specifying the indirect effects of actions  in proceedings of international joint conference on artificial intelligence  ijcai   pp      
     
lin  f          compiling causal theories to successor state axioms and strips like systems  journal of artificial intelligence research             
lin  f     shoham  y          a logic of knowledge and justified assumptions  artificial
intelligence             
lin  f     wang  k          from causal theories to logic programs  sometimes   in
proceedings of international conference on logic programming and nonmonotonic
reasoning  lpnmr   pp         
lin  f     zhou  y          from answer set logic programming to circumscription via logic
of gk  artificial intelligence              
   

filee   palla

marek  v     truszczynski  m          stable models and an alternative logic programming
paradigm  in the logic programming paradigm  a    year perspective  pp         
springer verlag 
mccarthy  j          circumscriptiona form of non monotonic reasoning  artificial intelligence                  
mccarthy  j          applications of circumscription to formalizing common sense knowledge  artificial intelligence                
mccarthy  j     hayes  p          some philosophical problems from the standpoint of
artificial intelligence  in meltzer  b     michie  d   eds    machine intelligence  vol    
pp          edinburgh university press  edinburgh 
miller  r     shanahan  m          the event calculus in classical logic   alternative axiomatisations  electronic transactions on artificial intelligence     a         
mueller  e          commonsense reasoning  morgan kaufmann 
mueller  e  t          event calculus reasoning through satisfiability  journal of logic and
computation                 
niemela  i          logic programs with stable model semantics as a constraint programming
paradigm  annals of mathematics and artificial intelligence             
pearce  d     valverde  a          a first order nonmonotonic extension of constructive
logic  studia logica             
provetti  a          hypothetical reasoning about actions  from situation calculus to event
calculus  computational intelligence             
reiter  r          a logic for default reasoning  artificial intelligence            
reiter  r          the frame problem in the situation calculus  a simple solution  sometimes  and a completeness result for goal regression  in lifschitz  v   ed    artificial
intelligence and mathematical theory of computation  papers in honor of john mccarthy  pp          academic press 
reiter  r          knowledge in action  logical foundations for specifying and implementing dynamical systems  mit press 
shanahan  m          a circumscriptive calculus of events  artif  intell                  
shanahan  m          solving the frame problem  a mathematical investigation of the
common sense law of inertia  mit press 
shanahan  m          the event calculus explained  in artificial intelligence today  lncs
      pp          springer 
shanahan  m     witkowski  m          event calculus planning through satisfiability 
journal of logic and computation                 
syrjanen  t          cardinality constraint programs   in proceedings of european conference on logics in artificial intelligence  jelia   pp         
zhang  h   zhang  y   ying  m     zhou  y          translating first order theories into logic
programs  in proceedings of international joint conference on artificial intelligence
 ijcai   pp           

   

fi