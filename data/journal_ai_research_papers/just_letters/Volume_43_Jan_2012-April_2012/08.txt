journal of artificial intelligence research                  

submitted        published      

local consistency and sat solvers
peter jeavons
justyna petke

peter jeavons cs ox ac uk
justyna petke cs ox ac uk

department of computer science  university of oxford
wolfson building  parks road  oxford  ox   qd  uk

abstract
local consistency techniques such as k consistency are a key component of specialised
solvers for constraint satisfaction problems  in this paper we show that the power of
using k consistency techniques on a constraint satisfaction problem is precisely captured by
using a particular inference rule  which we call negative hyper resolution  on the standard
direct encoding of the problem into boolean clauses  we also show that current clauselearning sat solvers will discover in expected polynomial time any inconsistency that can
be deduced from a given set of clauses using negative hyper resolvents of a fixed size  we
combine these two results to show that  without being explicitly designed to do so  current
clause learning sat solvers efficiently simulate k consistency techniques  for all fixed values
of k  we then give some experimental results to show that this feature allows clause learning
sat solvers to efficiently solve certain families of constraint problems which are challenging
for conventional constraint programming solvers 

   introduction
one of the oldest and most central ideas in constraint programming  going right back to
montanaris original paper in       is the idea of using local consistency techniques to prune
the search space  bessiere         the idea of arc consistency was introduced by mackworth
        and generalised to k consistency by freuder         modern constraint solvers
generally employ specialised propagators to prune the domains of variables to achieve some
form of generalised arc consistency  but typically do not attempt to enforce higher levels of
consistency  such as path consistency 
by contrast  the software tools developed to solve propositional satisfiability problems 
known as sat solvers  generally use logical inference techniques  such as unit propagation
and clause learning  to prune the search space 
one of the most surprising empirical findings of the last few years has been the remarkably good performance of general sat solvers in solving constraint satisfaction problems 
to apply such tools to a constraint satisfaction problem one first has to translate the instance into a set of clauses using some form of boolean encoding  tamura  taga  kitagawa 
  banbara        walsh         such encoding techniques tend to obscure the structure of the original problem  and may introduce a very large number of boolean variables
and clauses to encode quite easily stated constraints  nevertheless  in quite a few cases 
such approaches have out performed more traditional constraint solving tools  van dongen 
lecoutre    roussel              petke   jeavons        
c
    
ai access foundation  all rights reserved 

fijeavons   petke

in this paper we draw on a number of recent analytical approaches to try to account
for the good performance of general sat solvers on many forms of constraint problems 
building on the results of atserias  bulatov  and dalmau         atserias and dalmau
        and hwang and mitchell         we show that the power of using k consistency
techniques in a constraint problem is precisely captured by using a single inference rule in
a standard boolean encoding of that problem  we refer to this inference rule as negativehyper resolution  and show that any conclusions deduced by enforcing k consistency can be
deduced by a sequence of negative hyper resolution inferences involving boolean clauses in
the original instance and negative hyper resolvents with at most k literals  furthermore 
by using the approach of atserias  fichte  and thurley         and pipatsrisawat and
darwiche         we show that current clause learning sat solvers will mimic the effect of
such deductions in polynomial expected time  even with a random branching strategy  hence
we show that  although they are not explicitly designed to do so  running a clause learning
sat solver on a straightforward encoding of a constraint problem efficiently simulates the
effects of enforcing k consistency for all values of k 

   preliminaries
in this section we give some background and definitions that will be used throughout the
rest of the paper 
    constraint satisfaction problems and k consistency
definition   an instance of the constraint satisfaction problem  csp  is specified
by a triple  v  d  c   where
 v is a finite set of variables 
 d    dv   v  v   where each set dv is the set of possible values for the variable v 
called the domain of v 
 c is a finite set of constraints  each constraint in c is a pair  ri   si   where
 si is an ordered list of mi variables  called the constraint scope 
 ri is a relation over d of arity mi   called the constraint relation 
given any csp instance  v  d  c   a partial assignment is a mapping f from some
s
subset w of v to dv such that f  v   dv for all v  w   a partial assignment satisfies
the constraints of the instance if  for all  r   v    v            vm     c such that vj  w for
j                 m  we have  f  v     f  v            f  vm     r  a partial assignment that satisfies
the constraints of an instance is called a partial solution  to that instance  the set of
variables on which a partial assignment f is defined is called the domain of f   and denoted
dom f    a partial solution g extends a partial solution f if dom g   dom f   and
g v    f  v  for all v  dom f    a partial solution with domain v is called a solution 
one way to derive new information about a csp instance  which may help to determine
whether or not it has a solution  is to use some form of constraint propagation to enforce
   note that not all partial solutions extend to solutions 

   

filocal consistency and sat solvers

some level of local consistency  bessiere         for example  it is possible to use the notion
of k consistency  defined below  we note that there are several different but equivalent ways
to define and enforce k consistency described in the literature  bessiere        cooper       
freuder         our presentation follows that of atserias et al          which is inspired by
the notion of existential k pebble games introduced by kolaitis and vardi        
definition    atserias et al         for any csp instance p   the k consistency closure
of p is the set h of partial assignments which is obtained by the following algorithm 
   let h be the collection of all partial solutions f of p with  dom f     k     
   for every f  h with  dom f     k and every variable v of p   if there is no g  h
such that g extends f and v  dom g   then remove f and all its extensions from h 
   repeat step   until h is unchanged 
note that computing the k consistency closure according to this definition corresponds
precisely to enforcing strong  k    consistency according to the definitions given by bessiere
        cooper         and freuder        
throughout this paper  we shall assume that the domain of possible values for each
variable in a csp instance is finite  it is straightforward to show that for any fixed k 
and any fixed maximum domain size  the k consistency closure of an instance p can be
computed in polynomial time  atserias et al         cooper        
note that any solution to p must extend some element of the k consistency closure of
p   hence  if the k consistency closure of p is empty  for some k  then p has no solutions 
the converse is not true in general  but it holds for certain special cases  such as the class of
instances whose structure has tree width bounded by k  atserias et al          or the class
of instances whose constraint relations are     all relations  as defined in cooper  cohen 
and jeavons         or connected row convex relations  as defined in deville  barette 
and hentenryck         for these special kinds of instances it is possible to determine in
polynomial time whether or not a solution exists simply by computing the k consistency
closure  for an appropriate choice of k  moreover  if a solution exists  then it can be
constructed in polynomial time by selecting each variable in turn  assigning each possible
value  re computing the k consistency closure  and retaining an assignment that gives a
non empty result 
the following result gives a useful condition for determining whether the k consistency
closure of a csp instance is empty 
lemma    kolaitis   vardi        the k consistency closure of a csp instance p is
non empty if and only if there exists a non empty family h of partial solutions to p such
that 
   if f  h  then  dom f     k     
   if f  h and f extends g  then g  h 
   if f  h   dom f     k  and v 
  dom f   is a variable of p   then there is some
g  h such that g extends f and v  dom g  
a set of partial solutions h satisfying the conditions described in lemma   is sometimes
called a strategy for the instance p  barto   kozik        kolaitis   vardi        
   

fijeavons   petke

    encoding a csp instance as a propositional formula
one possible approach to solving a csp instance is to encode it as a propositional formula
over a suitable set of boolean variables  and then use a program to decide the satisfiability
of that formula  many such programs  known as sat solvers  are now available and can
often efficiently handle problems with thousands  or sometimes even millions  of boolean
variables  zhang   malik        
several different ways of encoding a csp instance as a propositional formula have been
proposed  prestwich        tamura et al         walsh        
here we consider one common family of encodings  known as sparse encodings  this term
was introduced in hoos         for any csp instance p    v  d  c   a sparse encoding
introduces a set of boolean variables of the form xvi for each v  v and each i  dv   the
boolean variable xvi is assigned true if and only if the original variable v is assigned the
value i  we will say that a partial assignment f falsifies a clause c if c consists entirely of
literals of the form xvf  v    for variables v  dom f    otherwise  we will say that a partial
assignment f satisfies a clause c 
example   let p be a csp instance such that v    u  v  w   du   dv           dw  
          and c contains a single ternary constraint with scope  u  v  w  specifying that
u  v   w  a sparse encoding of p will introduce seven boolean variables 
xu    xu    xv    xv    xw    xw    xw   
sparse encodings usually contain certain clauses known as at least one and at most one
clauses  to ensure that each variable v is assigned a value  say i  and that no other value 
w
j    i  is assigned to v  the at least one clauses are of the form idv xvi for each variable
v  the at most one clauses can be represented as a set of binary clauses xvi  xvj for all
i  j  dv with i    j 
example   in the case of the csp instance from example   the at least one clauses are 
xu   xu    xv   xv    xw   xw   xw 
the at most one clauses are 
xu   xu    xv   xv    xw   xw    xw   xw    xw   xw 
the various different sparse encodings differ in the way they encode the constraints of a
csp instance  two methods are most commonly used  the first one encodes the disallowed
variable assignments   the so called conflicts or no goods  the direct encoding  prestwich 
w
       for instance  generates a clause vs xvf  v  for each partial assignment f that does
not satisfy the constraint  r  s   c  using the direct encoding  the ternary constraint
from example   would be encoded by the following clauses 
xu   xv   xw   
xu   xv   xw   
xu   xv   xw   
xu   xv   xw   
   

filocal consistency and sat solvers

xu   xv   xw   
xu   xv   xw   
xu   xv   xw   
xu   xv   xw   
another way of translating constraints into clauses is to encode the allowed variable
assignments   the so called supports  this has been used as the basis for an encoding of
binary csp instances  known as the support encoding  gent         defined as follows 
for each pair of variables v  w in the scope of some constraint  and each value i  dv  
w
the support encoding will contain the clause xvi  ja xwj   where a  dw is the set of
values for the variable w which are compatible with the assignment v   i  according to the
constraint 
note that the support encoding is defined for binary csp instances only  however  some
non binary constraints can be decomposed into binary ones without introducing any new
variables  for instance  the ternary constraint from example   can be decomposed into two
binary constraints specifying that u  v and v   w  using the support encoding  these
binary constraints would then be represented by the following clauses 
xu   xv   xv    xu   xv    xv   xu    xv   xu   xu   
xv   xw   xw    xv   xw    xw    xw   xv    xw   xv   xv   
    inference rules
given any set of clauses we can often deduce further clauses by applying certain inference
rules  for example  if we have two clauses of the form c  x and c  x  for some  possibly
empty  clauses c    c    and some variable x  then we can deduce the clause c   c    this
form of inference is known as propositional resolution  the resultant clause is called the
resolvent  robinson        
in the next section  we shall establish a close connection between the k consistency
algorithm and a form of inference called negative hyper resolution  buning   lettmann 
       which we define as follows 
definition   if we have a collection of clauses of the form ci  xi   for i                 r 
and a clause c   x   x       xr   where each xi is a boolean variable  and c  and
each ci is a  possibly empty  disjunction of negative literals  then we can deduce the clause
c   c       cr  
we call this form of inference negative hyper resolution and the resultant clause
c   c       cr the negative hyper resolvent 
in the case where c  is empty  the negative hyper resolution rule is equivalent to the
nogood resolution rule described by hwang and mitchell        as well as the h  k rule
introduced by de kleer        and the nogood recording scheme described by schiex and
verfaillie        
note that the inference obtained by negative hyper resolution can also be obtained by a
sequence of standard resolution steps  however  the reason for introducing negative hyperresolution is that it allows us to deduce the clauses we need in a single step without needing
to introduce intermediate clauses  which may contain up to r    more literals than the
   

fijeavons   petke

negative hyper resolvent   by restricting the size of the clauses we use in this way we are
able to obtain better performance bounds for sat solvers in the results below 
example   assume we have a collection of clauses of the form ci xi   for i                 r 
and a clause c   x   x       xr   as specified in definition    where each ci   c    the
negative hyper resolvent of this set of clauses is c   
the clause c  can also be obtained by a sequence of standard resolution steps  as follows 
first resolve c   x   x       xr with c   xr to obtain c   x   x       xr    then
resolve this with the next clause  c   xr    and so on for the other clauses  until finally
we obtain c    however  in this case the intermediate clause c  x  x    xr  contains
r    more literals than the negative hyper resolvent 
example   note that the no good clauses in the direct encoding of a binary csp instance
can each be obtained by a single negative hyper resolution step from an appropriate support
clause in the support encoding together with an appropriate collection of at most one clauses 
let a  dw be the set of values for the variable w which are compatible with the assignment
w
v   i  then the support encoding will contain the clause c   xvi  ja xwj   if there are
any values k  dw which are incompatible with the assignment v   i  then we can form the
negative hyper resolvent of c with the at most one clauses xwk  xwj for each j  a  to
obtain the corresponding no good clause  xvi  xwk  
a negative hyper resolution derivation of a clause c from a set of initial clauses  is
a sequence of clauses c    c            cm   where cm   c and each ci follows by the negativehyper resolution rule from some collection of clauses  each of which is either contained in
 or else occurs earlier in the sequence  the width of this derivation is defined to be the
maximum size of any of the clauses ci   if cm is the empty clause  then we say that the
derivation is a negative hyper resolution refutation of  

   k consistency and negative hyper resolution
it has been pointed out by many authors that enforcing local consistency is a form of
inference on relations analogous to the use of the resolution rule on clauses  bacchus       
bessiere        hwang   mitchell        rish   dechter         the precise strength of the
standard resolution inference rule on the direct encoding of a csp instance was considered
in the work of walsh         where it was shown that unit resolution  where one of the
clauses being resolved consists of a single literal   corresponds to enforcing a weak form of
local consistency known as forward checking  hwang and mitchell        pointed out that
the standard resolution rule with no restriction on clause length is able to simulate all the
inferences made by a k consistency algorithm  atserias and dalmau        showed that
the standard resolution rule restricted to clauses with at most k literals  known as the kresolution rule  can be characterised in terms of the boolean existential  k     pebble game 
it follows that on csp instances with boolean domains this form of inference corresponds
to enforcing k consistency  an alternative proof that k resolution achieves k consistency for
instances with boolean domains is given in the book by hooker        thm        
here we extend these results a little  to show that for csp instances with arbitrary
finite domains  applying the negative hyper resolution rule on the direct encoding to obtain
   

filocal consistency and sat solvers

clauses with at most k literals corresponds precisely to enforcing k consistency  a similar
relationship was stated in the work of de kleer         but a complete proof was not given 
note that the bound  k  that we impose on the size of the negative hyper resolvents 
is independent of the domain size  in other words  using this inference rule we only need
to consider inferred clauses of size at most k  even though we make use of clauses in the
encoding whose size is equal to the domain size  which may be arbitrarily large 
theorem   the k consistency closure of a csp instance p is empty if and only if its direct
encoding as a set of clauses has a negative hyper resolution refutation of width at most k 
the proof is broken down into two lemmas inspired by lemmas   and   in the work
of atserias and dalmau        
lemma   let p be a csp instance  and let  be its direct encoding as a set of clauses 
if  has no negative hyper resolution refutation of width k or less  then the k consistency
closure of p is non empty 
proof  let v be the set of variables of p   where each v  v has domain dv   and let
x    xvi   v  v  i  dv   be the corresponding set of boolean variables in   let  be the
set of all clauses having a negative hyper resolution derivation from  of width at most k 
by the definition of negative hyper resolution  every non empty clause in  consists entirely
of negative literals 
now let h be the set of all partial assignments for p with domain size at most k    
that do not falsify any clause in    under the direct encoding 
consider any element f  h  by the definition of h  f does not falsify any clause of
  so by the definition of the direct encoding  every element of h is a partial solution to
p   furthermore  if f extends g  then g is also an element of h  because g makes fewer
assignments than f and hence cannot falsify any additional clauses to f  
if  has no negative hyper resolution refutation of width at most k  then  does not
contain the empty clause  so h contains  at least  the partial solution with empty domain 
and hence h is not empty 
now let f be any element of h with  dom f     k and let v be any variable of p
that is not in dom f    for any partial assignment g that extends f and has dom g   
dom f     v  we have that either g  h or else there exists a clause in    that is
falsified by g  since g is a partial assignment  any clause c in    that is falsified by g 
must consist entirely of negative literals  hence the literals of c must either be of the form
xwf  w  for some w  dom f    or else xvg v    moreover  any such clause must contain the
literal xvg v    or else it would already be falsified by f  
assume  for contradiction  that h does not contain any assignment g that extends f and
has dom g    dom f     v   in that case  we have that  for each i  dv      contains a
clause ci consisting of negative literals of the form xwf  w  for some w  dom f    together
with the literal xvi   now consider the clause  c  which is the negative hyper resolvent
w
of these clauses ci and the at least one clause idv xvi   the clause c consists entirely
of negative literals of the form xwf  w  for some w  dom f    so it has width at most
 dom f     k  and hence is an element of   however c is falsified by f   which contradicts
the choice of f   hence we have shown that for all f  h with  dom f     k  and for
   

fijeavons   petke

all variables v such that v   dom f    there is some g  h such that g extends f and
v  dom g  
we have shown that h satisfies all the conditions required by lemma    so we conclude
that the k consistency closure of p is non empty 
 

lemma   let p be a csp instance  and let  be its direct encoding as a set of clauses 
if the k consistency closure of p is non empty  then  has no negative hyper resolution
refutation of width k or less 
proof  let v be the set of variables of p   where each v  v has domain dv   and let
x    xvi   v  v  i  dv   be the corresponding set of boolean variables in  
by lemma    if the k consistency closure of p is non empty  then there exists a nonempty set h of partial solutions to p which satisfies the three properties described in
lemma   
now consider any negative hyper resolution derivation  from  of width at most k  we
show by induction on the length of this derivation that the elements of h do not falsify any
clause in the derivation  first we note that the elements of h are partial solutions  so they
satisfy all the constraints of p   and hence do not falsify any clause of   this establishes
the base case  assume  for induction  that all clauses in the derivation earlier than some
clause c are not falsified by any element of h 
note that  apart from the at least one clauses  all clauses in  and  consist entirely of
negative literals  hence we may assume  without loss of generality  that c is the negativehyper resolvent of a set of clauses     ci  xvi   i  dv   and the at least one clause
w
idv xvi   for some fixed variable v 
if f  h falsifies c  then the literals of c must all be of the form xwf  w    for some
w  dom f    since the width of the derivation is at most k  c contains at most k literals 
and hence we may assume that  dom f     k  but then  by the choice of h  there must
exist some extension g of f in h such that v  dom g   any such g will falsify some
clause in   which contradicts our inductive hypothesis  hence no f  h falsifies c  and 
in particular  c cannot be empty 
it follows that no negative hyper resolution derivation of width at most k can contain
the empty clause 
 
note that the proof of theorem   applies to any sparse encoding that contains the
at least one clauses for each variable  and where all other clauses are purely negative  we
will call such an encoding a negative sparse encoding  as well as the direct encoding  other
negative sparse encodings exist  for example  we may use negative clauses that involve only
a subset of the variables in the scope of some constraints  to forbid tuples where all possible
extensions to the complete scope are disallowed by the constraint   another example of
a negative sparse encoding is a well known variant of the direct encoding in which the
at most one clauses are omitted 
corollary   the k consistency closure of a csp instance p is empty if and only if any
negative sparse encoding of p has a negative hyper resolution refutation of width at most k 
   

filocal consistency and sat solvers

   negative hyper resolution and sat solvers
in this section we adapt the machinery from atserias et al          and pipatsrisawat and
darwiche        to show that for any fixed k  the existence of a negative hyper resolution
refutation of width k is likely to be discovered by a sat solver in polynomial time using
standard clause learning and restart techniques  even with a totally random branching
strategy 
note that previous results about the power of clause learning sat solvers have generally
assumed an optimal branching strategy  beame  kautz    sabharwal        pipatsrisawat
  darwiche          they have shown what solvers are potentially capable of doing  rather
than what they are likely to achieve in practice  an important exception is the paper
by atserias et al          which gives an analysis of likely behaviour  but relies on the
existence of a standard resolution proof of bounded width  here we show that the results
of atserias et al  can be extended to hyper resolution proofs  which can be shorter and
narrower than their associated standard resolution proofs 
we will make use of the following terminology from atserias et al          for a clause
c  a boolean variable x  and a truth value a          the restriction of c by the assignment
x   a  denoted c x a   is defined to be the constant    if the assignment satisfies the clause 
or else the clause obtained by deleting from c any literals involving the variable x  for
any sequence of assignments s of the form  x    a    x    a            xr   ar   we write c s to
denote the result of computing the restriction of c by each assignment in turn  if c s is
empty  then we say that the assignments in s falsify the clause c  for a set of clauses  
we write  s to denote the set  c s   c          
most current sat solvers operate in the following way  atserias et al         pipatsrisawat   darwiche         they maintain a database of clauses  and a current state
s  which is a partial assignment of truth values to the boolean variables in the clauses of
  a high level description of the algorithms used to update the clause database and the
state  derived from the description given in atserias et al   is shown in algorithm    a similar framework  using slightly different terminology  is given in pipatsrisawat   darwiche 
      
now consider a run of the algorithm shown in algorithm    started with the initial
database   and the empty state s    until it either halts or discovers a conflict  i e      s   
such a run is called a complete round started with   and we represent it by the sequence
of states s            sm   that the algorithm maintains  note that each state si extends the
state si  by a single assignment to a boolean variable  which may be either a decision
assignment or an implied assignment 
more generally  a round is an initial segment s    s            sr of a complete round started
with   up to a state sr such that either  sr contains the empty clause  or  sr does not
contain any unit clause  for any clause c  we say that a round s    s            sr satisfies c if
c sr      and we say that the round falsifies c if c sr is empty 
if s    s            sr is a round started with   and  sr contains the empty clause  then
the algorithm either reports unsatisfiability or learns a new clause  such a round is called
conclusive  if a round is not conclusive we call it inconclusive     note that if s    s            sr
is an inconclusive round started with   then  sr does not contain the empty clause 
   note that a complete round that assigns all variables and reports satisfiability is called inconclusive 

   

fijeavons   petke

and does not contain any unit clauses  hence  for any clause c    if sr falsifies all the
literals of c except one  then it must satisfy the remaining literal  and hence satisfy c  this
property of clauses is captured by the following definition 
definition    atserias et al         let  be a set of clauses  c a non empty clause  and
l a literal of c  we say that  absorbs c at l if every inconclusive round started with 
that falsifies c    l  satisfies c 
if  absorbs c at each literal l in c  then we simply say that  absorbs c 
note that a closely related notion is introduced by pipatsrisawat and darwiche        for
clauses that are not absorbed by a set of clauses   they are referred to as   empowering with
respect to    the exact relationship between   empowering and absorption is discussed
in atserias et al         
we will now explore the relationship between absorption and negative hyper resolution 
example   let  be the direct encoding of a csp instance p    v  d  c   where v  
 u  v  w   du   dv   dw          and c contains two binary constraints  one forbids the
assignment of the value   to u and v simultaneously  and the other forbids the simultaneous
assignment of the value   to u and   to w  let c also contain a ternary constraint that
forbids the assignment of the value   to all three variables simultaneously 
     xu   xu    xv   xv    xw   xw   
xu   xu    xv   xv    xw   xw   
xu   xv    xu   xw    xu   xv   xw    
the clause xv   xw  is not contained in   but can be obtained by negative hyperresolution from the clauses xu   xu    xu   xv    xu   xw   
this clause is absorbed by   since every inconclusive round that sets xv    true must
set xw    f alse by unit propagation  and every inconclusive round that sets xw    true
must set xv    f alse also by unit propagation 
example   indicates that clauses that can be obtained by negative hyper resolution from a
set of clauses  are sometimes absorbed by   the next result clarifies when this situation
holds 
lemma   any negative hyper resolvent of a set of disjoint clauses is absorbed by that set
of clauses 
proof  let c be the negative hyper resolvent of a set of clauses     ci  xi   i  
              r  and a clause c     c   x   x       xr   where each ci is a  possibly empty 
disjunction of negative literals  for    i  r  then c   c   c       cr by definition   
by definition    we must show that   c   absorbs c at each of its literals  assume all
but one of the literals of c are falsified  since the set of clauses   c   are assumed to be
disjoint  the remaining literal l must belong to exactly one of the clauses in this set  there
are two cases to consider 
   if l belongs to the clause c     then all clauses in  have all but one literals falsified  so
the remaining literal xi in each of these clauses is set to true  by unit propagation 
hence all literals in c   are falsified  except for l  so l is set to true  by unit propagation 
   

filocal consistency and sat solvers

   if l belongs to one of the clauses ci  xi   then all of the remaining clauses in  have
all but one literals falsified  so the corresponding literals xj are set to true  by unit
propagation  hence all literals in c   are falsified  except for xi   so xi is set to true  by
unit propagation  but now all literals in ci  xi are falsified  except for l  so l is set
to true by unit propagation 
 
the next example shows that the negative hyper resolvent of a set of clauses that is not
disjoint will not necessarily be absorbed by those clauses 
example   recall the set of clauses  given in example    which is the direct encoding of
a csp instance with three variables  u  v  w   each with domain        
the clause xu   xv  is not contained in   but can be obtained by negative hyperresolution from the clauses xw   xw    xu   xv   xw    xu   xw   
this clause is not absorbed by   since an inconclusive round that sets xv    true will
not necessarily ensure that xu    f alse by unit propagation 
the basic approach we shall use to establish our main results below is to show that any
clauses that can be obtained by bounded width negative hyper resolution from a given set
of clauses  but are not immediately absorbed  such as the one in example    are likely
to become absorbed quite quickly because of the additional clauses that are added by
the process of clause learning  hence a clause learning sat solver is likely to fairly rapidly
absorb all of the clauses that can be derived from its original database of clauses by negativehyper resolution  in particular  if the empty clause can be derived by negative hyperresolution  then the solver will fairly rapidly absorb some literal and its complement  and
hence report unsatisfiability  see the proof of theorem   for details  
the following key properties of absorption are established by atserias et al         
lemma    atserias et al         let  and   be sets of clauses  and let c and c   be
non empty clauses 
   if c belongs to   then  absorbs c 
   if c  c   and  absorbs c  then  absorbs c    
   if     and  absorbs c  then   absorbs c 
to allow further analysis  we need to make some assumptions about the learning scheme 
the restart policy and the branching strategy used by our sat solver 
the learning scheme is a rule that creates and adds a new clause to the database
whenever there is a conflict  such a clause is called a conflict clause  and each of its literals
is falsified by some assignment in the current state  if a literal is falsified by the i th decision
assignment  or some later implied assignment before the  i      th decision assignment  it is
said to be falsified at level i  if a conflict clause contains exactly one literal that is falsified
at the maximum possible level  it is called an asserting clause  pipatsrisawat   darwiche 
      zhang  madigan  moskewicz    malik        
assumption   the learning scheme chooses an asserting clause 
   

fijeavons   petke

algorithm   framework for a typical clause learning sat solver
input     set of clauses 
s   partial assignment of truth values to variables 
  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   

while  s     do
if    s then
conflict
if s contains no decision assignments then
print unsatisfiable and halt
else
apply the learning scheme to add a new clause to 
if restart policy says restart then
set s   
else
select most recent conflict causing unreversed decision assignment in s
reverse this decision  and remove all later assignments from s
end if
end if
else if  l    s for some literal l then
unit propagation
add to s the implied assignment x   a which satisfies l
else
decision
apply the branching strategy to choose a decision assignment x   a
add this decision assignment to s
end if
end while
print satisfiable and output s

most learning schemes in current use satisfy this assumption  pipatsrisawat   darwiche        zhang et al          including the learning schemes called  uip and decision  zhang et al         
we make no particular assumption about the restart policy  however  our main result
is phrased in terms of a bound on the expected number of restarts  if the algorithm restarts
after r conflicts  our bound on the expected number of restarts can simply be multiplied
by r to get a bound on the expected number of conflicts  this means that the results
will be strongest if the algorithm restarts immediately after each conflict  in that case 
r     and our bound will also bound the expected number of conflicts  existing satsolvers typically do not employ such an aggressive restart policy  but we note the remark
in the work of pipatsrisawat and darwiche        p      that there has been a clear trend
towards more and more frequent restarts for modern sat solvers 
the branching strategy determines which decision assignment is chosen after an inconclusive round that is not complete  in most current sat solvers the strategy is based on
some heuristic measure of variable activity  which is related to the occurrence of a variable in
conflict clauses  moskewicz  madigan  zhao  zhang    malik         however  to simplify
the probabilistic analysis  we will make the following assumption 

   

filocal consistency and sat solvers

assumption   the branching strategy chooses a variable uniformly at random amongst
the unassigned variables  and assigns it the value true 
as noted by atserias et al          the same analysis we give below can also be applied
to any other branching strategy that randomly chooses between making a heuristic based
decision or a randomly based decision  more precisely  if we allow  say  c     rounds of nonrandom decisions between random ones  then the number of required restarts and conflicts
would appear multiplied by a factor of c 
an algorithm that behaves according to the description in algorithm    and satisfies
the assumptions above  will be called a standard randomised sat solver 
theorem   if a set of non empty clauses  over n boolean variables has a negativehyper resolution refutation of width k and length m  then the expected number of restarts
requiredby a standard randomised sat solver to discover that  is unsatisfiable is less than
mnk   nk  
proof  let c    c            cm be a negative hyper resolution refutation of width k from  
where cm is the first occurrence of the empty clause  since each clause in  is non empty 
cm must be derived by negative hyper resolution from some collection of negative literals
x    x          xd and a purely positive clause x   x       xd   
now consider a standard randomised sat solver started with database   once all of
the unit clauses xi are absorbed by the current database  then  by definition    any further
inconclusive round of the algorithm must assign all variables xi false  and hence falsify the
clause x   x      xd   since this happens even when no decision assignments are made  the
sat solver will report unsatisfiability 
it only remains to bound the expected number of restarts required until each clause
ci is absorbed  for    i   m  let each ci be the negative hyper resolvent of clauses
  x   together with a clause c   c x x   x
ci    ci            cir   each of the form cij
j
i 
 
 
 
r
from   where c  is a  possibly empty  disjunction of negative literals  assume also that
each clause cij is absorbed by  for j                 r 
if  absorbs ci   then no further learning or restarts are needed  so assume now that 
does not absorb ci   by definition    this means that there exists some literal l and some
inconclusive round r started with  that falsifies ci    l  and does not satisfy ci   note
that r must leave the literal l unassigned  because one assignment would satisfy ci and
    and hence force all of the literals x used in the
the other would falsify c  and each cij
j
negative hyper resolution step to be satisfied  because each cij is absorbed by   so ci 
would be falsified  contradicting the fact that r is inconclusive 
hence  if the branching strategy chooses to falsify the literals ci    l  whenever it has
a choice  it will construct an inconclusive round r  where l is unassigned  since all the
decision assignments in r  are also assigned the same values in r  any implied assignments
in r  must also be assigned the same values  in r  but we have shown that r leaves l
unassigned   if the branching strategy then chooses to falsify the remaining literal l of ci  
then the algorithm would construct a conclusive round r   where ci  is falsified  and all
   see lemmas      and    in the work of atserias et al         for a more formal statement and proof of
this assertion 

   

fijeavons   petke

decision assignments falsify literals in ci   hence  by assumption    the algorithm would
then learn some asserting clause c   and add it to  to obtain a new set    
since c   is an asserting clause  it contains exactly one literal  l    that is falsified at the
highest level in r     hence  any inconclusive round r started with   that falsifies ci    l 
will falsify all but one literal of c     and hence force the remaining literal l  to be satisfied 
by unit propagation  if this new implied assignment for l  propagates to force l to be true 
then r satisfies ci   and hence   absorbs ci at l  if not  then the branching strategy can
once again choose to falsify the remaining literal l of ci   which will cause a new asserting
clause to be learned and added to   since each new asserting clause forces a new literal to
be satisfied after falsifying ci    l  this process can be repeated fewer than n times before
it is certain that   absorbs ci at l 
now consider any sequence of k random branching choices  if the first k    of these
each falsify a literal of ci    l   and the final choice falsifies l  then we have shown that the
associated round will reach a conflict  and add an asserting clause to   with a random
branching strategy  as described in assumption    the probability that this happens is at
least the probability that the first k    random choices consist of a fixed set of variables
 in some order   and the final choice is the variable associated with l  the number of
random choices that fall in a fixed set follows the hypergeometric distribution  so the overall
 
probability of this is n   nk   
     k nk   
 k  
to obtain an upper bound on the expected number of restarts  consider the worst case
where we require n asserting clauses to be added to absorb each clause ci at each of its k
literals l  since we require only an upper bound 
we will treat each round as an independent
n
trial with success probability p      k k    and consider the worst case where we have to
achieve  m    nk successes to ensure that ci for    i   m is absorbed  in this case the
total number of restarts will follow a negative binomial distribution  with expected value
 m    nk p  hence in all cases the expected number of restarts is less than mnk   nk    
a tighter bound on the number of restarts can be obtained if we focus on the decision
learning scheme  atserias et al         zhang et al          as the next result indicates 
theorem   if a set of non empty clauses  over n boolean variables has a negative hyperresolution refutation of width k and length m  then the expected number of restarts required
by a standard randomised sat solver
using the decision learning scheme to discover that

 is unsatisfiable is less than m nk  
proof  the proof is similar to the proof of theorem    except that the decision learning scheme has the additional feature that the literals in the chosen conflict clause falsify a
subset of the current decision assignments  hence in the situation we consider  where the
decision assignments all falsify literals of some clause ci   this learning scheme will learn a
subset of ci   and hence immediately absorb ci   by lemma          hence the maximum
number of learnt clausesrequired is
reduced from  m    nk to  m      and the probability

is increased from    k nk   to    nk   giving the tighter bound 
 
note that a similar argument shows that the standard deviation of the number of restarts
is less than the standard deviation of a negative binomial distribution with parameters m
   

filocal consistency and sat solvers




and    nk   which is less than m nk   hence  by chebyshevs inequality  one tailed version  
the probability that a standard randomised sat solver using the decision learning scheme

will discover that  is unsatisfiable after  m   m  nk restarts is greater than     

   k consistency and sat solvers
by combining theorem   and theorem   we obtain the following result linking k consistency
and sat solvers 
theorem   if the k consistency closure of a csp instance p is empty  then the expected
number of restarts required by a standard randomised sat solver using the decision learning scheme to discover that the direct encoding of p is unsatisfiable is o n k d k    where n
is the number of variables in p and d is the maximum domain size 
proof  the length m of a negative hyper resolution refutation of width k is bounded
pk
i n
by the number of possible no goods of length at most
k
for
p
 
which
is
i   d i   hence 



by theorem   and theorem   we obtain a bound of


i n
i   d i

pk

nd
k  

which is o n k d k     

hence a standard randomised sat solver with a suitable learning strategy will decide
the satisfiability of any csp instance with tree width k with o n k d k   expected restarts 
even when it is set to restart immediately after each conflict  in particular  the satisfiability
of any tree structured binary csp instance  i e   with tree width    will be decided by such
a solver with at most o n  d    expected conflicts  which is comparable with the growth rate
of an optimal arc consistency algorithm for binary constraints  note that this result cannot
be obtained directly from the work of atserias et al          because the direct encoding of
an instance with tree width k is a set of clauses whose tree width may be as high as dk 
moreover  a standard randomised sat solver will decide the satisfiability of any csp
instance  with any structure  within the same polynomial bounds  if the constraint relations
satisfy certain algebraic properties that ensure bounded width  barto   kozik        
examples of such constraint types include the     all relations  defined by cooper et al 
        and the connected row convex relations  defined by deville et al          which
can both be decided by   consistency 
it was shown by gent        that the support encoding of a binary csp instance can
be made arc consistent  that is    consistent  by applying unit propagation alone  hence  a
standard sat solver will mimic the effect of enforcing arc consistency on such an encoding
before making any decisions or restarts  by combining theorem   with the observation in
example   that the direct encoding can be obtained from the support encoding by negativehyper resolution  we obtain the following corollary concerning the support encoding for all
higher levels of consistency 
corollary   for any k     if the k consistency closure of a binary csp instance p
is empty  then the expected number of restarts required by a standard randomised satsolver using the decision learning scheme to discover that the support encoding of p is
unsatisfiable is o n k d k    where n is the number of variables in p and d is the maximum
domain size 
   

fijeavons   petke

the csp literature describes many variations on the notion of consistency  in this
paper we have considered k consistency only  we note that our results can be generalised
to some other types of consistency such as singleton arc consistency  bessiere         the
extension to singleton arc consistency follows from the recent discovery that if a family of
csp instances is solvable by enforcing singleton arc consistency  then the instances have
bounded width  chen  dalmau    gruien         in other words  all such instances can
be solved by enforcing k consistency  for some fixed k  hence  by theorem    they will be
solved in polynomial expected time by a standard randomised sat solver 

   experimental results
the polynomial upper bounds we obtain in this paper are not asymptotic  they apply for
all values of n  m and k  however  they are very conservative  and are likely to be met very
easily in practice 
to investigate how an existing sat solver actually performs  we measured the runtime
of the minisat solver  een   sorensson         version        on a family of csp instances
that can be decided by a fixed level of consistency  for comparison  we also ran our experiments on two state of the art constraint solvers  we used minion  gent  jefferson   
miguel         version       and the g   finite domain solver  nethercote et al         
version     
to match the simplified assumptions of our analysis more closely  we ran a further
set of experiments on a core version of minisat in order to get a solver that uses only
unit propagation and conflict directed learning with restarts  we also modified the solver to
follow the random branching strategy described above  our solver does not delete any learnt
clauses and uses an extreme restart policy that makes it restart whenever it encounters a
conflict  it uses the same learning scheme as minisat  we refer to this modified solver as
simple minisat 
as the characteristic feature of the instances tested is their relatively low tree width 
we also used the toulbar  solver  sanchez et al          this solver implements the btd
 backtracking with tree decomposition  technique which has been shown to be efficient
in practice  in contrast to earlier methods that had been proposed to attempt to exploit
tree decompositions of the input problem  jegou   terrioux         as the problem of
finding a tree decomposition of minimal width  i e   the tree width  is np hard  the btd
technique uses some approximations  described in jegou   terrioux         we note here
that toulbar  is designed for solving optimization problems  namely weighted csps  or
wcsps  in a wcsp instance  certain partial assignments have an associated cost  however 
the toulbar  solver can be used to solve standard csps by simply setting all costs to   
for all of the results  the times given are elapsed times on a lenovo      n    laptop
with an intel core   duo processor running at     ghz with  gb of ram  each generated
instance was run five times and the mean times and mean number of restarts are shown   
example   we consider a family of instances specified by two parameters  w and d  they
have   d  w   w variables arranged in groups of size w  each with domain          d   
   minisat and simple minisat were run with different seeds for each of the five runs of an instance 
instances marked with   were run once only  the runtime of simple minisat on those instances
exceeded   hours  moreover  toulbar  was run with parameter b     which enables btd 

   

filocal consistency and sat solvers

we impose a constraint of arity  w on each pair of successive groups  requiring that the
sum of the values assigned to the first of these two groups should be strictly smaller than
the sum of the values assigned to the second  this ensures that the instances generated are
unsatisfiable  an instance with w     and d     is shown diagrammatically and defined
using the specification language minizinc  nethercote et al         in figure    a  and  b 
respectively    a similar format is used for toulbar    and the same instance encoded in
this format is shown in figure    c   note that each hard constraint has cost    

 a  graphical representation 

chain
x     
x     
x     
x     
x     
x     
x     
x     
hard  x    x    x    x   
hard  x    x    x    x   
hard  x    x    x    x   

array       of var        x  
array       of var        x  
constraint
forall i in       
x  i    x  i    x  i        x  i       
solve satisfy 
 b  specification in minizinc 

 c  specification in cp format 

figure    an example of a csp instance with w      d     and tree width     

the structure of the instances described in example   has a simple tree decomposition as a
path of nodes  with each node corresponding to a constraint scope  hence the tree width of
these instances is  w    and they can be shown to be unsatisfiable by enforcing   w    consistency  atserias et al          however  these instances cannot be solved efficiently
using standard propagation algorithms which only prune individual domain values 
the structure of the direct encoding of these instances also has a tree decomposition
with each node corresponding to a constraint scope in the original csp instance  however 
because the direct encoding introduces d boolean variables to represent each variable in the
   in order to run an instance on a cp solver one must usually use a translator to convert the original
model  the minizinc distribution provides an mzn fzn translator while for minion one can use tailor
 available at http   www cs st andrews ac uk andrea tailor   
   a cp wcsp translator and a description of the cp and wcsp formats is available at
http   carlit toulouse inra fr cgi bin awki cgi softcsp 

   

fijeavons   petke

original instance  the tree width of the encoded sat instances is larger by approximately a
factor of d  it is in fact  wd     see figure    

 a  tree decomposition of the original instance 

 b  tree decomposition of its direct
encoding 

figure    tree decompositions of the csp instance from figure   
table   shows the runtimes of simple minisat and the original minisat solver on
this family of instances  along with times for the two state of the art cp solvers and the
wcsp solver toulbar   by far the best solver for this set of instances is toulbar  
which is explicitly designed to exploit low tree width by constructing a tree decomposition 
for the class of instances we are considering  the widths of the tree decompositions found
by toulbar  matched the tree widths of the instances tested  i e    w     
however  we also note that minisat is remarkably effective in solving these chains
of inequalities  compared to minion and g    even though the use of minisat requires
encoding each instance into a large number of clauses with a much larger tree width than
the original  although our simplified version of the minisat solver takes a little longer
than the current highly optimised version  it still performs very well on these instances in
comparison with the conventional cp solvers  moreover  the number of restarts  and hence
the number of conflicts  appears to grow only polynomially with the size of the instance
 see figure     in all cases the actual number of restarts is much lower than the polynomial
upper bound on the expected number of restarts given in theorem   
our best theoretical upper bounds on the expected run time were obtained for the
decision learning scheme  theorem     but the standard version of minisat uses the
 uip learning scheme with conflict clause minimization  to allow a direct comparison
with these theoretical upper bounds  we implemented the decision scheme in simpleminisat  as the  uip learning scheme has generally been found to be more efficient
in practice  zhang et al          we switched off conflict clause minimization in simpleminisat in order to compare the two standard learning schemes and ran a further set of
experiments  we counted the number of restarts for these two modified solvers on instances
of the form described in example     see table   
   

filocal consistency and sat solvers

group
size
 w 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

domain
size
 d 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 

csp
variables
 n 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

minion

g  

 sec 
     
     
     
     
     
      
     min
     min
     min
     
     
     min
     min
     min
     
     min
     min

 sec 
     
     
     
     
     
       
     min
     min
     min
     
     
     
     min
     min
     
      
     min

toulbar 

minisat

 sec 
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
      

 sec 
     
     
     
     
     
     
     
     
     
     
     
     
      
       
     
     
         

simpleminisat
 sec 
     
     
     
     
     
     
     
      
       
     
     
      
       
     min
     
       
     min

simpleminisat
restarts
  
   
   
     
     
      
      
      
       
   
     
      
       
       
     
       
          

table    average performance of solvers on instances from example   
group
size
 w 

domain
size
 d 

csp
variables
 n 

no  of clauses
in the direct
encoding

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
   
     
     
     
      
      
      
       
   
     
      
       
       
   
      

simpleminisat
 uip
 sec 
     
     
     
     
     
     
      
      
       
     
     
      
         
    hours
     
       

simpleminisat
 uip
restarts
  
   
     
     
      
      
      
       
       
   
     
      
       
          
     
       

simpleminisat
decision
 sec 
     
     
     
     
     
     
      
      
       
     
     
      
         
    hours
     
       

simpleminisat
decision
restarts
  
   
     
     
      
      
      
       
       
   
     
      
       
          
     
       

table    average performance of simple minisat with the  uip and the decision learning schemes on instances from example   

   

fijeavons   petke

figure    log log plot of the number of restarts conflicts used by simple minisat on the

instances from example    the solid lines show a growth function of d w  nd w
 
 
where n is the number of csp variables  this empirically derived polynomial
function appears to fit the experimental data well  and is much lower than the
upper bound on the expected number of restarts calculated in theorem   which
is o d w  n w    

   

filocal consistency and sat solvers

although the performance of simple minisat with the decision learning scheme
and the  uip scheme are significantly worse than the performance of the original simpleminisat solver  only about twice as many restarts were required for each instance  hence 
our theoretical upper bounds are still easily met for both of these standard learning schemes 

   conclusions
we have shown that the notion of k consistency can be precisely captured by a single
inference rule on the direct encoding of a csp instance  restricted to deriving only clauses
with at most k literals  we used this to show that a clause learning sat solver with a purely
random branching strategy will simulate the effect of enforcing k consistency in expected
polynomial time  for all fixed k  this is sufficient to ensure that such solvers are able to
solve certain problem families much more efficiently than conventional cp solvers relying
on gac propagation 
in principle clause learning sat solvers can also do much more  it is known that  with
an appropriate branching strategy and restart policy  they are able to p simulate general
resolution  beame et al         pipatsrisawat   darwiche         and general resolution
proofs can be exponentially shorter than the negative hyper resolution proofs we have considered here  hwang   mitchell         in practice  it seems that current clause learning
sat solvers with highly tuned learning schemes  branching strategies and restart policies
are often able to exploit structure in the boolean encoding of a csp instance even more
effectively than local consistency techniques  hence considerable work remains to be done
in understanding the relevant features of instances which they are able to exploit  in order
to predict their effectiveness in solving different kinds of csp instances 

acknowledgments
we would like to thank albert atserias and marc thurley for comments on the conference
version of this paper  as well as the anonymous referees  the provision of an epsrc
doctoral training award to justyna petke is also gratefully acknowledged 
a preliminary version of this paper appeared in proceedings of the   th international
conference on principles and practice of constraint programming   cp     

references
atserias  a   bulatov  a  a     dalmau  v          on the power of k consistency  in
international colloquium on automata  languages and programming   icalp   
pp         
atserias  a     dalmau  v          a combinatorial characterization of resolution width 
journal of computer and system sciences                 
atserias  a   fichte  j  k     thurley  m          clause learning algorithms with many
restarts and bounded width resolution  journal of artificial intelligence research
 jair              
bacchus  f          gac via unit propagation  in principles and practice of constraint
programming   cp    pp         
   

fijeavons   petke

barto  l     kozik  m          constraint satisfaction problems of bounded width  in
symposium on foundations of computer science   focs    pp         
beame  p   kautz  h  a     sabharwal  a          towards understanding and harnessing
the potential of clause learning  journal of artificial intelligence research  jair  
           
bessiere  c          constraint propagation  in rossi  f   van beek  p     walsh  t   eds   
handbook of constraint programming  chap     elsevier 
buning  h     lettmann  t          propositional logic  deduction and algorithms  cambridge tracts in theoretical computer science  cambridge university press 
chen  h   dalmau  v     gruien  b          arc consistency and friends  computing
research repository   corr  abs           
cooper  m  c          an optimal k consistency algorithm  artificial intelligence         
     
cooper  m  c   cohen  d  a     jeavons  p          characterising tractable constraints 
artificial intelligence                 
de kleer  j          a comparison of atms and csp techniques  in international joint
conference on artificial intelligence   ijcai    pp         
deville  y   barette  o     hentenryck  p  v          constraint satisfaction over connected
row convex constraints  in international joint conference on artificial intelligence ijcai        pp         
een  n     sorensson  n          an extensible sat solver  in theory and applications of
satisfiability testing   sat    pp         
freuder  e  c          synthesizing constraint expressions  communications of the acm 
                
gent  i  p          arc consistency in sat  in european conference on artificial intelligence
  ecai    pp         
gent  i  p   jefferson  c     miguel  i          minion  a fast scalable constraint solver  in
european conference on artificial intelligence   ecai    pp        
hooker  j  n          integrated methods for optimization  international series in operations research   management science   springer verlag new york  inc   secaucus 
nj  usa 
hoos  h  h          sat encodings  search space structure  and local search performance 
in international joint conference on artificial intelligence   ijcai    pp         
hwang  j     mitchell  d  g            way vs  d way branching for csp  in principles and
practice of constraint programming   cp    pp         
jegou  p     terrioux  c          hybrid backtracking bounded by tree decomposition of
constraint networks  artificial intelligence                
kolaitis  p  g     vardi  m  y          a game theoretic approach to constraint satisfaction  in conference on artificial intelligence   aaai     innovative applications of
artificial intelligence conference   iaai    pp         
   

filocal consistency and sat solvers

mackworth  a  k          consistency in networks of relations  artificial intelligence        
      
montanari  u          networks of constraints  fundamental properties and applications to
picture processing  information sciences           
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering an efficient sat solver  in design automation conference   dac    pp 
       
nethercote  n   stuckey  p  j   becket  r   brand  s   duck  g  j     tack  g         
minizinc  towards a standard cp modelling language  in principles and practice of
constraint programming   cp    pp         
petke  j     jeavons  p          tractable benchmarks for constraint programming  technical report rr        department of computer science  university of oxford 
pipatsrisawat  k     darwiche  a          on the power of clause learning sat solvers with
restarts  in principles and practice of constraint programming   cp    pp         
prestwich  s  d          cnf encodings  in biere  a   heule  m   van maaren  h     walsh 
t   eds    handbook of satisfiability  pp        ios press 
rish  i     dechter  r          resolution versus search  two strategies for sat  journal
of automated reasoning                   
robinson  j  a          a machine oriented logic based on the resolution principle  journal
of the acm               
sanchez  m   bouveret  s   de givry  s   heras  f   jegou  p   larrosa  j   ndiaye  s   rollon 
e   schiex  t   terrioux  c   verfaillie  g     zytnicki  m          max csp competition       toulbar  solver description  in proceedings of the third international
csp solver competition 
schiex  t     verfaillie  g          nogood recording for static and dynamic constraint
satisfaction problems  in international conference on tools with artificial intelligence
  ictai    pp       
tamura  n   taga  a   kitagawa  s     banbara  m          compiling finite linear csp
into sat  constraints                 
van dongen  m   lecoutre  c     roussel  o           rd international csp solver competition  instances and results available at http   www cril univ artois fr cpai    
van dongen  m   lecoutre  c     roussel  o           th international csp solver competition  instances and results available at http   www cril univ artois fr cpai    
walsh  t          sat v csp  in principles and practice of constraint programming cp    pp         
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning in boolean satisfiability solver  in international conference on computeraided design   iccad    pp         
zhang  l     malik  s          the quest for efficient boolean satisfiability solvers  in
computer aided verification   cav    pp       

   

fi