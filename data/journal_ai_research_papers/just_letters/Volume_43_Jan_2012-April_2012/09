journal artificial intelligence research                 

submitted        published      

computing all pairs shortest paths
leveraging low treewidth
leon planken
mathijs de weerdt

l r planken tudelft nl
m m deweerdt tudelft nl

faculty eemcs  delft university technology 
delft  netherlands

roman van der krogt

roman  c ucc ie

cork constraint computation centre 
university college cork  cork  ireland

abstract
present two new efficient algorithms computing all pairs shortest paths 
algorithms operate directed graphs real  possibly negative  weights  make use
directed path consistency along vertex ordering d  algorithms run n  wd
time  wd graph width induced vertex ordering  graphs constant
treewidth  yields n  time  optimal  chordal graphs  algorithms
run  nm  time  addition  present
variant exploits graph separators

arrive run time nwd    n  sd general graphs  sd wd size
largest minimal separator induced vertex ordering d  show empirically
constructed realistic benchmarks  many cases algorithms outperform
floydwarshalls well johnsons
algorithm 
represent current state


art run time n  nm   n  log n   respectively  algorithms
used spatial temporal reasoning  simple temporal problem 
underlines relevance planning scheduling community 

   introduction
finding shortest paths important fundamental problem communication
transportation networks  circuit design  bioinformatics  internet node traffic  social networking  graph analysis generale g  computing betweenness  girvan   newman       and sub problem many combinatorial problems 
represented network flow problem  particular  context planning
scheduling  finding shortest paths important solve set binary linear constraints
events  i e  simple temporal problem  stp  dechter  meiri    pearl        
stp turn appears sub problem np hard temporal constraint satisfaction
problem  tcsp  dechter et al         disjunctive temporal problem  dtp  stergiou
  koubarakis         powerful enough model e g  job shop scheduling problems  shortest path computations applications account significant
part total run time solver  thus  hardly surprising topics received substantial interest planning scheduling community  satish kumar       
bresina  jonsson  morris    rajan        rossi  venable    yorke smith        shah  
williams        conrad  shah    williams        
c
    
ai access foundation  rights reserved 

fiplanken  de weerdt    van der krogt

instances stp  called simple temporal networks  stns   natural representation directed graphs real edge weights  recently  specific interest
stns stemming hierarchical task networks  htns  castillo  fernandez olivares 
  gonzalez        bui   yorke smith         graphs sibling restricted
property  task  represented pair vertices  connected sibling tasks 
parent children  graphs number children task restricted
constant branching factor  therefore resulting stns tree like structure 
canonical way solving stp instance  dechter et al         computing
all pairs shortest paths  apsp  stn  thus achieving full path consistency 
graphs n vertices edges  done n  time floydwarshall
algorithm  floyd         based warshalls        formulation efficiently computing
transitive closure boolean matrices  however  state art computing apsp
sparse graphs algorithm based technique originally proposed johnson
        preprocessing allow n runs dijkstras        algorithm  using
fibonacci heap  fredman   tarjan         algorithm runs n  log n   nm time 
remainder paper  refer algorithm johnson 
paper present two new algorithms apsp real edge weights  in section     one algorithm  dubbed chleqapsp  based point to point shortest path
algorithm chleq         other  named snowball  similar planken  de weerdt 
van der krogts        algorithm enforcing partial  instead full  path consistency  p  c   new algorithms advance state art computing apsp 
graphs constant treewidth  sibling restricted stns based htns
con
 
stant branching factor  run time
algorithms bounded n  
optimal since output n    addition stns  examples graphs
constant treewidth outerplanar graphs  graphs bounded bandwidth  graphs
bounded cutwidth  series parallel graphs  bodlaender        
chleqapsp snowball applied chordal graphs  run time
 nm   strict improvement
state art  chaudhuri   zaroliagis 

      run time nmwd    wd defined below   chordal graphs important
subset general sparse graphs  interval graphs  trees  k trees split graphs special
cases chordal graphs  golumbic         moreover  graph made chordal using
so called triangulation algorithm  algorithm operates eliminating vertices one
one  connecting neighbours eliminated vertex thereby inducing cliques
graph 
induced width wd vertex ordering defined equal cardinality
largest set neighbours encountered  upper
bound run time
proposed algorithms general graphs  n  wd   depends induced
width  finding vertex ordering minimum induced width  however  np hard
problem  arnborg  corneil    proskurowski         minimum induced width
tree likeness property graph mentioned above  i e  treewidth  denoted w  
contrast  induced width direct measure input  graph   bound
n  wd quite proper  still  better bound johnson wd  log n   
   prefer write x  f  n   instead common x    f  n    formally  right hand
side represents set functions grow strictly slower f  n   traditional equality
fact works one direction  see graham  knuth    patashnik        section      

   

ficomputing apsp leveraging low treewidth


see this  note bound johnson never better n  log n   regardless
value m 
paper  present variant snowball exploits graph separators
attains upper bound run time nwd    n  sd   upper bound even
better one two new algorithms  since sd wd size largest
minimal separator induced vertex ordering d  theoretical bounds run
time usually give good indication performance algorithms  see especially
last variant always predict algorithm best settings 
section    therefore  experimentally establish computational efficiency
proposed algorithms wide range graphs  varying random scale free networks
parts road network new york city  stns generated htns job shop
scheduling problems 
below  first give detailed introduction required concepts 
induced width  chordal graphs triangulation  present new algorithms
analysis 

   preliminaries
section  briefly introduce algorithm enforces directed path consistency  dpc  find vertex ordering required algorithm 
present algorithms all pairs shortest paths  require enforcing dpc  or
stronger property  first step  treatment  assume weights edges
graph real possibly negative 
    directed path consistency
dechter et al         presented dpc  included algorithm    way check whether
stp instance consistent   equivalent checking graph
contain negative cycle  a closed path negative total weight   algorithm takes
input weighted directed graph g   hv  ei vertex ordering d  bijection
v natural numbers             n   paper  simply represent ith
vertex ordering natural number i   possibly negative  weight
arc j represented wij r  shorthand existence arc
vertices  either direction   i  j  e  finally  denote gk graph
induced vertices             k   likewise  set vertices v   v   gv   denotes graph
induced v     so  particular  gv   gn   g 
iteration k  algorithm adds edges  in line    pairs lower numbered
neighbours i  j k  thus triangulating graph  moreover  lines      updates
edge j weight paths k j j k i  shorter 
consequently    j  defining property dpc ensures wij higher
total weight path j consists vertices outside gj  except
j themselves   implies particular running dpc  w   w  
labelled shortest paths vertices     
   note algorithmssuch bellmanfordcan used purpose well  usually
perform better practice 

   

fiplanken  de weerdt    van der krogt

algorithm    dpc  dechter et al        
input  weighted directed graph g   hv  ei  vertex ordering   v             n 
output  dpc version g  inconsistent g contains negative cycle

  

k n  
forall   j   k  i  k     j  k  e
wij min  wij   wik   wkj  
wji min  wji   wjk   wki  
e e   i  j  
wij   wji    
return inconsistent
end
end
end

  

return g   hv  ei

 
 
 
 
 
 
 
 
 

run time dpc depends measure wd called induced width relative
ordering vertices  dechter et al         define induced width vertex
ordering procedurally exactly highest number neighbours j k j   k
encountered dpc algorithm  includes neighbours original graph  i e 
 j  k  e  well vertices became neighbours edges added
earlier iteration algorithm  however  definition based original
graph vertex ordering  making use following result 
proposition    suppose g   hv  ei undirected graph   v             n 
 where bijection  vertex ordering  suppose given n sets
edges ek    k n  defined follows 


ek     j  k  v   j   k path k j g j  k k       n 
then  ek  exactly set edges visited iteration k dpc 
proof  note definition  set ek  superset original edges
vertex k lower numbered neighbours  use fact prove equivalence
induction 
equivalence holds first iteration k   n  en  exactly set
original edges vertex n lower numbered neighbours  earlier
iterations dpc may added edges  j  k  j   k  now  assuming
equivalence holds sets e       k  show holds ek   
inductive case  prove inclusion relations separately 
   reach contradiction  assume exists edge  j  k    ek    j   k 
visited dpc iteration k  ek  includes original edges
k lower numbered neighbours  must new edge added earlier
iteration     k  must exist edges  j        k     e     induction hypothesis 
j k therefore connected induced subgraph g j k            n   
   

ficomputing apsp leveraging low treewidth

must connected larger subgraph g j  k k      n  thus definition
included ek    contradiction 
   assume  reaching contradiction  exists edge  j  k  ek 
part e iteration k dpc therefore visited algorithm  clearly 
 j  k  cannot one original edges  definition ek  must therefore
exist path least one intermediate vertex j k induced subgraph
g j  k k      n    let   lowest numbered vertex j k path 
    k   j  then  induction hypothesis  must exist edges
 j        k     e     visited dpc iteration    more 
reach contradiction  since dpc must added  j  k  e iteration     k 
formally define induced width follows  conclude proposition  
equivalent original procedural definition 
definition    given undirected graph g   hv  ei  vertex ordering d  n sets
edges ek  proposition    induced width wd g  relative d  following
measure 

wd   max fiek 
kv

follows run time dpc property graph per se  rather 
dependent graphand vertex ordering used  careful implementation 
dpcs time bound nwd  ordering known beforehand 
edges added dpc called fill edges make graph chordal  sometimes
called triangulated   indeed  dpc differs triangulation procedure
manipulation arc weights  chordal graph  every cycle length four
edge joining two vertices adjacent cycle  definition    number
edges chordal graph  denoted mc m   nwd    give formal
definitions concepts 


definition    given graph g   hv  ei set v     v             v k v vertices
form cycle g  chord
cycle edge non adjacent vertices
cycle  i e  edge v   v j e     j   k    graph g   hv  ei called chordal
cycles size larger   chord 
definition    given graph g   hv  ei  triangulation g  e    
set edges g    hv  e chordal  edges called fill edges 
minimal triangulation g exists proper subset    
triangulation g 
    finding vertex ordering
principle  dpc use vertex ordering make graph chordal directionally path consistent  however  since vertex ordering defines induced width 
directly influences run time number edges mc resulting graph  mentioned introduction  finding ordering minimum induced width wd   w  
even determining treewidth w   np hard problem general  still 
class constant treewidth graphs recognised  optimally triangulated   n 
   

fiplanken  de weerdt    van der krogt

time  bodlaender         g already chordal  find perfect ordering  resulting fill edges   m  time  using e g  maximal cardinality search  mcs  tarjan  
yannakakis         perfect ordering called simplicial ordering  every vertex k together lower numbered neighbours ordering induces clique
 simplex  subgraph gk   implies following  known  result  relating induced
width treewidth size largest clique g 
proposition    graph g chordal  size largest clique exactly w     
non chordal graph g triangulated along vertex ordering d  yielding chordal graph g   
size largest clique g  exactly wd      treewidth g  equals wd
upper bound treewidth original graph g  w wd  
general graphs  various heuristics exist often produce good results  mention
minimum degree heuristic  rose         iteration chooses vertex
lowest degree  since ordering produced heuristic fully known
dpc starts depends fill edges added  adjacency list based implementation
require another  log n  factor dpcs time bound  however  purposes
article  afford
comfort maintaining adjacency matrix  yields bounds

n    nwd  time n  space 

   all pairs shortest paths
even though  best knowledge  dpc based apsp algorithm yet
proposed  algorithms computing single source shortest paths  sssp  based dpc
obtained known results relatively straightforward manner  chleq       
proposed point to point shortest path algorithm trivial adaptation computes
sssp  planken  de weerdt  yorke smith        implicitly compute sssp part
ippc algorithm  algorithms run  mc   time thus
simply run
 
vertex yield apsp algorithm  nmc   n wd time complexity 
below  first show adapt chleqs algorithm compute apsp  then  present
new  efficient algorithm named snowball relates planken et al s        p  c 
    chleqs approach
chleqs        point to point shortest path algorithm simply called minpath computes shortest path two arbitrary vertices s  v directionally pathconsistent graph g  reproduced algorithm   seen run  mc  
time edge considered twice  shortest distance source
vertex maintained array d  algorithm iterates downward  
upward   t  updating distance array shorter path found 
since sink vertex used bound second loop  clear
actually contains shortest distances pairs  s  t    t  t  therefore 
easily adapt algorithm compute sssp within  mc   time bound setting
  n returning entire array instead d t   call result chleqapsp 
included algorithm    calls sssp algorithm  referred minpaths  n times
compute all pairs shortest paths  nmc   nwd  time 
   

ficomputing apsp leveraging low treewidth

algorithm    minpath  chleq       
input  weighted directed dpc graph g   hv  ei 
 arbitrary  source vertex destination vertex
output  distance t  inconsistent g contains negative cycle

  

v   d i 
d s   
k  
forall j   k  j  k  e
d j  min  d j   d k    wkj  
end
end
k  
forall j   k  j  k  e
d j  min  d j   d k    wkj  
end
end

  

return d t 

 
 
 
 
 
 
 
 
 
  
  

algorithm    chleqapsp
input  weighted directed graph g   hv  ei  vertex ordering   v             n 
output  distance matrix d  inconsistent g contains negative cycle
 
 

g dpc g  d 
return inconsistent dpc

 

  n
d i    minpaths g  i 
end

 

return

 
 

   

fiplanken  de weerdt    van der krogt

algorithm    snowball
input  weighted directed graph g   hv  ei  vertex ordering   v             n 
output  distance matrix d  inconsistent g contains negative cycle
 
 

g dpc g  d 
return inconsistent dpc

  

i  j v   d i  j 
v   d i  i   
k   n
forall j   k  j  k  e
forall             k   
d i  k  min  d i  k   d i  j    wjk  
d k  i  min  d k  i   wkj   d j  i  
end
end
end

  

return

 
 
 
 
 
 
 
  
  

    snowball algorithm
section  present algorithm computes apsp  or full path consistency  
dubbed snowball included algorithm    asymptotic worst case time
bounds chleqapsp requires strictly less computational work 
chleqapsp  algorithm first ensures input graph directionally pathconsistent  idea behind algorithm grow  execution
outermost loop  clique             k  computed  shortest  distances  one vertex
time  starting trivial clique consisting vertex    dpc performed
backward sweep along d  snowball iterates direction  adding vertex k
clique  two inner loops ensure compute distances k
vertices   k  works know dpc pair  i  k  
must exist shortest path k form j k  and vice versa  
 j  k  e j   k edge chordal graph  means algorithm
needs look vertices i  j   k  follows inductively d i  j 
d j  i  guaranteed correct earlier iteration 
name algorithm derives snowball effect  clique computed
distances grows quadratically course operation  small example
operation snowball given figure    originally  graph contained shortest path
         dashed edges added dpc  path     
shortest path  particular  w   holds correct value  snapshot taken
k      shaded vertices    already visited shortest distances d i  j 
computed i  j    then  iteration k      j         
algorithm sets correct weight d       taking sum w     d       
theorem
   algorithm     snowball  correctly computes all pairs shortest paths  nmc  
n  wd time 
   

ficomputing apsp leveraging low treewidth

 
 
 
 
 
 
 

figure    snapshot  k      graph operation snowball 

proof  proof induction  enforcing dpc  w   w   labelled
shortest distances vertices      k       j      algorithm
sets d       d       correct values 
now  assume d i  j  set correctly vertices i  j   k  let     v 
v  v   v    k shortest path k  let hmax  
arg maxh             vh    dpc      hmax      exists path
weight shortcut vhmax   vhmax    taken  argument repeated
conclude must exist shortest path   k lies completely gk and 
except last arc  gk    thus  induction hypothesis observation
algorithm considers arcs subgraph gk  k  d i  k  set correct
value  analogous argument holds d k  i  
regard algorithms time complexity  note two outermost loops
together result mc edges chordal graph visited exactly once 
inner loop always fewer n iterations  yielding run time  nmc   time 

 
observation mc nwd   state looser time bound n wd  
briefly discuss consequences two special cases  graphs constant
treewidth chordal graphs  chordal graphs  recognised  m  time 
substitute mc run time complexity  further  described above 
perfect ordering exists found  m  time  gives total run time
complexity  nm   likewise  stated given constant  
determined  n  time whether graph treewidth w   so  vertex ordering wd   w found within time bound  then  omitting
constant factor wd   algorithm runs n  time  follows algorithms pseudocode noting every vertex k constant number  at w  
neighbours j   k 
note similarity snowball p  c algorithm  planken et al  
       presented below  snowball  p  c operates enforcing dpc  followed
single

backward sweep along vertex ordering  p  c computes  nwd  time  shortest
   

fiplanken  de weerdt    van der krogt

algorithm    p   c  planken et al        
input  weighted directed graph g   hv  ei  vertex ordering   v             n 
output  ppc version g  inconsistent g contains negative cycle
 
 

g dpc g  d 
return inconsistent dpc

 

k   n
forall i  j   k  i  k     j  k  e
wik min  wik   wij   wjk  
wkj min  wkj   wki   wij  
end
end

 

return g

 
 
 
 
 

paths arcs present chordal graph  similarity property chordal
graphs fact prompt us present version snowball improved time complexity 
    improving run time complexity using separators

section  present improvement snowball nwd    n  sd run time 
sd size largest minimal separator chordal graph obtained
triangulation along d 
definition    given connected graph g   hv  ei  separator set v   v
gv  v   longer connected  separator v   minimal proper subset v  
separator 
bound better because  seen below  always holds sd wd   improvement hinges property chordal graphs called partial path consistency  ppc  
partially path consistent graph  arc labelled length shortest path
endpoints   p  c  presented algorithm    depends dpc computes ppc
nwd  time  current state art  then  use clique tree
ppc graph compute shortest path vertices  figure   shows example
chordal graph associated clique tree  clique tree following useful
properties  heggernes        section      
property    every chordal graph g   hv  ei associated clique tree   hc  si 
constructed linear time  mc   
property    clique tree node c c associated subset vc v induces
maximal clique g  conversely  every maximal clique g associated clique tree
node c c 
property    coherent  vertex v v   clique tree nodes whose associated
cliques contain v induce subtree  
   full path consistency  fpc  achieved arc exists pairs vertices u  v v  

   

ficomputing apsp leveraging low treewidth

 a  chordal graph

 b  clique tree

figure    chordal graph clique tree  shaded shape represents maximal
clique graph  containing vertices corners 
property    two clique tree nodes ci   cj c connected edge  ci   cj   s 
vci vcj minimal separator g  conversely  minimal separator v   g 
clique tree edge  ci   cj   v     vci vcj  
property
   vertices appear least one clique associated node   so 

v
 
v
 
cc c
since proposition   page     size largest clique chordal
graph exactly wd      follows properties     sd wd  

now  idea behind snowballseparators first compute ppc nwd  time using
p  c  traverse clique tree  ppc ensures shortest paths within clique
computed  then  traversing clique tree arbitrary root node
out  grow set vvisited vertices cliques whose nodes already traversed 
clique node c c visited traversal  shortest paths vertices
clique vc vertices vvisited must run separator vsep c cs
parent  sd size largest minimal separator g 
pair vertices
 
suffices consider sd alternative routesfor total n sd routes  yielding
stated overall time complexity nwd    n  sd   formally present algorithm based
idea algorithm   associated recursive procedure processcliquetreenode
 on following page  
note visit nodes parent visiting node itself  always
holds vcparent vvisited   note that  simplicity presentation  assume
graph connected  not  simply find connected components linear
time construct clique tree them 
improved algorithm edge original algorithm separators
small treewidth not  htn based sibling restricted stns  which described
part experimental validation section         instance  many separators

size    every task many   n  subtasks every task subtasks

induces clique 
wd   n  sd      implying snowballseparators still

 
optimal n time complexity instances  
proceed prove algorithm correct meets stated run time
bounds  introduce following definition 
   however  since general every task subtasks form clique  low value sd usually
attained practice 

   

fiplanken  de weerdt    van der krogt

algorithm    snowballseparators
input  weighted directed graph g   hv  ei  vertex ordering   v             n 
output  distance matrix d  inconsistent g contains negative cycle
 
 
 
 
 
 
 
 
 
  

g p  c g  d 
return inconsistent p  c
i  j v   d i  j 
v   d i  i   
 i  j  e   d i  j  wij
 i  j  e   d j  i  wji
build clique tree   hc  si g
select arbitrary root node croot c
 d  vvisited   processcliquetreenode croot   nil  d   
return

procedure processcliquetreenode c  cparent   d  vvisited  
input  current clique tree node c  cs parent cparent   distance matrix d  set
visited vertices vvisited
output  updated matrix set vvisited

  

cparent    nil
vnew vc   vcparent
vsep vc vcparent
vother vvisited   vc
forall  i  j  k  vnew vsep vother
d i  k  min  d i  k   d i  j    d j  k  
d k  i  min  d k  i   d k  j    d j  i  
end
end
vvisited vvisited vc
forall children c  c
 d  vvisited   processcliquetreenode c    c  d  vvisited  
end

  

return  d  vvisited  

 
 
 
 
 
 
 
 
 
  
  
  

   

   recursive call

ficomputing apsp leveraging low treewidth

definition    define distance matrix valid set u vertices   d  u  
valid pair  pairs vertices  i  j  u u   d i  j  holds shortest distance
g j 
split correctness proof algorithm three parts  lemmas    
culminate theorem    first step show processcliquetreenode called
valid pair  d  u   clique node c  procedure extends validity
u vc  
lemma    consider call procedure processcliquetreenode with  arguments  clique
node c  cs parent cparent   distance matrix d  set visited vertices vvisited  
valid vvisited upon calling  becomes valid vc vvisited running lines
   processcliquetreenode 
proof  first  note property    vc induces clique g  therefore  edges exist
pair  i  k  vertices vc   since graph ppc  wik labelled
shortest distance k  due lines     main algorithm 
contains shortest distances  valid vc  
now  remains shown pair vertices  i  k  vc vvisited
shortest distances d i  k  d k  i  set correctly  show case d i  k  
case analogous 
desired result follows trivially cparent   nil  since procedure called
vvisited     otherwise  let vnew   vc   vcparent   vsep   vc vcparent vother   vvisited   vc
set procedure lines     either k lies vsep   correctness d i  k s
value already proven  need consider pairs vertices  i  k  vnew vother  
pair  i  k   vsep separator k property   
shortest path k necessarily concatenation shortest paths j
j k  j vsep   since follows definitions vnew   vsep vother
 i  j  vnew vsep  j  k  vsep vother   d i  j  d j  k  correctly
set  by validity vc vvisited   respectively   loop lines    yields
desired result 
next step prove recursive calls  validity fact extended
entire subtree rooted c 
lemma    consider call procedure processcliquetreenode with  arguments 
clique node c  cs parent vcparent   distance matrix d  set visited vertices vvisited  
 
valid vvisited upon calling  returned  updated pair  d    vvisited
 
valid 
proof  first  note lemma    valid vvisited update line    
assume clique tree depth d  proof reverse induction
depth clique tree node  c clique tree node depth  i e  leaf   loop
lines      no op  immediately obtain desired result 
assume lemma holds nodes depth k let c clique tree
node depth k    first call  if any  made child node c  loop
lines       lemma applied  consequence  returned updated
   

fiplanken  de weerdt    van der krogt

pair valid  argument repeated loop ends procedure
returns valid pair 
results disposal  state prove main theorem
section 
theorem    algorithm
    snowballseparators  correctly computes all pairs shortest paths

nwd    n  sd time 
proof  note vvisited   call processcliquetreenode line   snowball
separators  therefore  pair  d  vvisited   trivially valid  lemma    call thus
returns valid updated pair  d  vvisited    since processcliquetreenode recursively tras
versed entire clique tree  vvisited contains union cc vc cliques clique
tree   hc  si  property   equals set vertices g  therefore 
contains correct shortest paths pairs vertices graph 

time complexity  note initialisations lines     carried
 
n time  whereas lines     require  mc   time  property   
clique tree built linear time  mc    since clique tree contains
n nodes 

processcliquetreenode called  n  times  line   requires wd  time  implement
lines       processcliquetreenode  represent characteristic function
vvisited array size n  using vvisited instead vcparent everywhere  simply
iterate  wd   members vc perform required computations 
now  complexity loop lines    remains shown  note
 vsep   sd definition   vother     n always  using observation
n vertices graph appears vnew exactly one invocation processcliquetree
node  after
becomes staunch member vvisited    obtain total time bound
 
n sd loop invocations 
recursive description perhaps easier grasp satisfies claimed
time bounds  found efficiency benefited practice iterative implementation 
turns good heuristic first visit child nodes connected already
visited subtree large separator  postponing processing children connected
small separator  set visited vertices still small  way  sum
terms  vsep vvisited   kept low  implementation  therefore used priority queue
clique nodes ordered separator sizes  future research must point whether
feasible determine optimal traversal clique tree within given time bounds 
presented new algorithms proven correctness formal complexity  move empirical evaluation performance 

   experiments
evaluate two algorithms together efficient implementations floydwarshall
johnson fibonacci heap  across six different benchmark sets  
   johnson used corrected fibonacci heap implementation fiedler         since widely
used pseudocode cormen  leiserson  rivest  stein        contains mistakes 
   available
http   dx doi org         uuid      c   c fb    f      cca    edccf

   

ficomputing apsp leveraging low treewidth

table    properties benchmark sets
type
chordal
figure  
figure  
scale free
figure  
figure  
new york
diamonds
job shop
htn

 cases

n



wd

sd

   
   

     
        

             
             

     
   

     
   

   
   
   
   
   
   

     
        
        
        
       
      

           
          
        
        
         
        

     
      
   
 
    
    

     
      
   
 
    
    

properties test cases summarised table    table lists number
test cases  range number vertices n  edges m  induced width wd produced
minimum degree heuristic  well size largest minimal separators sd
graphs  details different sets found below  one thing
stands immediately sd often equal marginally smaller wd  
however  median size minimum separator less    instances except
constructed chordal graphs 
algorithms implemented java went intensive profiling phase  
experiments run using java      openjdk       b    server mode  intel
xeon e     cpus running    bit linux  java processes allowed maximum
heap size   gb  used default stack size  report measured cpu times 
including time spent running triangulation heuristic chleqapsp
snowball  reported run times averaged    runs unique problem instance 
moreover  generated    unique instances parameter setting  obtained using
different random seeds  thus  reported statistic represents average     runs 
unless otherwise indicated  finally  graph instance ensured contain cycles
negative weight 
    triangulation
discussed section      finding optimal vertex ordering  with minimum induced
width  np hard  several efficient triangulation heuristics problem exist 
ran experiments six different heuristics  minimum fill minimum degree
heuristics  static variants  taking account original graph   ordering
produced running maximum cardinality search  mcs  original graph 
random ordering  these  except minimum fill  time complexities within bound
run time chleqapsp snowball  found minimum degree heuristic
gave average induced widths less      higher found minimum fill 
   implementations available binary form
http   dx doi org         uuid    a   e   c    ee  d    c  d  b    

   

fiplanken  de weerdt    van der krogt

table    summed induced width  triangulation  total run time snowball
experiments general  non chordal  graphs show minimum degree heuristic
best choice 
heuristic
min fill
min degree
mcs
static min fill
static min degree
random

p

wd
       
       
       
       
       
       

triangulation  s 
         
   
     
     
     
     

snowball  s 

     
     
     
     
     
     

total  s 
         
     
     
     
     
     

drastically lower run time  exorbitant time consumption minimum
fill heuristic partially explained fact used libtw package 
compute ordering  whose implementation probably improved  however 
known literature theoretical bound minimum fill heuristic
worse minimum degree  kjrulff         heuristics
slower minimum degree  yield induced width least     higher  resulting
longer total triangulation time longer total run time snowball  see summary
results benchmarks given table     again  confirms kjrulffs earlier
work  experimental results included therefore show results based
minimum degree heuristic 
    chordal graphs
evaluate performance new algorithms chordal graphs  construct chordal
graphs fixed size       vertices treewidth ranging    less
number vertices  thus yielding nearly complete graph high end 
results experiment depicted figure    this  figures  error
bars represent standard deviations measured run time instances
size  graphs induced width three quarters number vertices 
snowball significantly outperforms floydwarshall  which yields expected horizontal line  
overall run time new algorithms well johnson across
entire range  figure   shows run times chordal graphs constant treewidth
increasing number vertices  here  two new algorithms outperform johnson
nearly order magnitude  a factor     snowball around n          even
regarding floydwarshall  confirming expectations based theoretical upper bounds 
    general graphs

general  non chordal graphs  expect theoretical analysis nwd  time chleqapsp snowball algorithms faster johnson nm   n  log n
   available http   treewidth com  

   

ficomputing apsp leveraging low treewidth

      

time solve  ms  log scale 

f w
johnson
chleq
snowball

     

    

   
   

    
induced width  log scale 

figure    run times generated chordal graphs fixed number      vertices
varying treewidth 

 e   

f w
johnson
chleq
snowball

time solve  ms  log scale 

      

     

    

   
   

    
number vertices  log scale 

    

figure    run times generated chordal graphs fixed treewidth     

   

fiplanken  de weerdt    van der krogt

      
f w
johnson
chleq
snowball

time solve  ms  log scale 

     

    

   

  
   

   

   

   

   
induced width

   

   

   

   

figure    run times scale free benchmarks graphs       vertices varying
induced width 
time bound wd low  johnson faster sparse graphs  where low 
large induced width wd   main question induced width changeover
occurs  regarding floydwarshall n  bound  expect larger n
always outperformed algorithms 
      scale free graphs
scale free networks networks whose degree distribution follows power law  is 
large values k  fraction p  k  vertices network k connections
vertices tends p  k  ck   constant c parameter   words 
vertices many connections many vertices connections 
property found many real world graphs  social networks
internet  instances randomly generated albert barabasis       
preferential attachment method  iteration new vertex added graph 
attached number existing vertices  higher degree existing
vertex  likely connected newly added vertex  see
induced width johnson faster  compare run times generated graphs
      vertices  varying number attachments new vertex  
n    obtain graphs induced width ranging         graphs 
induced width already quite large small attachment values  example 
value     induced width already     
results experiment found figure    see
induced width      attachment value     snowball efficient  higher
induced widths  johnson becomes efficient  wd around      even floydwarshall
becomes faster snowball  consistent observation different angle
made figure    induced width          number edges
   

ficomputing apsp leveraging low treewidth

time solve  ms  log scale 

     

f w
johnson
chleq
snowball

    

   

   

   

   

   
   
number vertices

   

   

    

figure    run times scale free benchmarks graphs induced widths        
varying vertex count 
            number vertices varied           
see small graphs     vertices  johnson fastest  snowball overtakes
it  around     vertices chleqapsp faster johnson  this holds results
sparse graph       vertices  
around mark     vertices  results show decrease run time
snowball chleqapsp  artifact  preferential attachment  benchmark
generator  since cannot generate scale free graphs specific induced width 
modify attachment value instead  turns out  graphs size one
attachment value yields induced width within desired range  graph size
     width high end interval  whereas graph size     near
low end  explains reduced run time larger graph 
scale free networks  conclude snowball fastest four algorithms induced width large  at one third number vertices
benchmark set   however  observe structure scale free networks
particularly high induced width relatively sparse graphs  exactly
vertices connections  therefore  snowball efficient
relatively small attachment values 
      selections new york road network
interesting artificially constructed graphs graphs based real networks 
shortest path calculations relevant  first series based road
network new york city  obtained dimacs challenge website  
network large  with         vertices         edges  decided compute
   http   www dis uniroma  it  challenge  

   

fiplanken  de weerdt    van der krogt

figure    coordinates vertices new york city input graph  examples
extent subgraphs respectively                 vertices 

 e   
f w
johnson
chleq
snowball

time solve  ms  log scale 

 e   

      

     

    

   

  
   

    
number vertices  log scale 

figure    run times new york benchmarks subgraphs varying vertex count 

   

ficomputing apsp leveraging low treewidth

shortest paths  induced  subgraphs varying sizes  obtained running
simple breadth first search random starting location desired number
vertices visited  extent subnetworks thus obtained illustrated
three different sizes figure    results algorithms subgraphs
found figure    observe ranking algorithms chordal
graphs fixed treewidth diamonds  floydwarshall slowest n 
run time  johnson  chleqapsp  snowball significantly faster
predecessor  explained considering induced width graphs  even
largest graphs induced width around     considerably smaller
number vertices 
      stns diamonds
benchmark set based problem instances difference logic proposed strichman 
seshia  bryant        appearing smt lib  ranise   tinelli        
constraint graph instance takes form circular chain diamonds 
diamond consists two parallel paths equal length starting single vertex
ending another single vertex  latter vertex  two paths start again  converge
third vertex  pattern repeated diamond chain  final vertex
connected first one  sizes diamond total number
diamonds varied benchmarks 
problems class actually instances np complete disjunctive temporal
problem  dtp   constraints take form disjunction inequalities  dtp
instance  obtain stp instance  i e  graph  randomly selecting one inequality
disjunction  stp probably inconsistent  constraint graph
contains negative cycle  remedy modifying weights constraint edges 
idea behind procedure structure graph still conforms type
networks one might encounter solving corresponding dtp instance 
run time algorithms mostly depends structure  moreover  reduce
influence randomized extraction procedure  repeat    different seeds 
benchmark set  considered problem instances size
diamonds fixed   number varying  interesting property set
graphs generated sparse  ran experiments     graphs 
ranging size          vertices  induced width    induced width
clearly extremely small  translates chleqapsp snowball considerably
faster johnson floydwarshall  evidenced figure   
      stns job shop scheduling
generated     graphs job shop set instance real jobshop problem  instances type available smt lib  ranise   tinelli 
       larger range included benchmark collection  obtain
graphs job shop instances  used extraction procedure described
previous section  striking observation taken figure   
difference johnson two new algorithms quite pronounced 
though snowball consistently fastest three small margin  fact
   

fiplanken  de weerdt    van der krogt

      
f w
johnson
chleq
snowball

time solve  ms  log scale 

     

    

   

  

 
   

    
number vertices  log scale 

figure    run times diamonds benchmarks graphs varying vertex count 

     

f w
johnson
chleq
snowball

time solve  ms  log scale 

    

   

  

 
   
number vertices  log scale 

    

figure     run times job shop benchmarks graphs varying vertex count 

   

ficomputing apsp leveraging low treewidth

margin small likely due structure graphs  reflected
relatively high induced width  note run times floydwarshall
better graphs     vertices  larger graphs algorithms
significantly faster 
      stns htns
finally  consider benchmark set whose instances imitate so called sibling restricted
stns originating hierarchical task networks  set therefore particularly interesting planning point view  graphs  constraints may occur
parent tasks children  sibling tasks  bui   yorke smith        
consider extension includes landmark variables  castillo  fernandez olivares   
gonzalez        mimic synchronisation tasks different parts network  thereby cause deviation tree like htn structure  generate
htns using following parameters   i  number tasks initial htn tree  fixed
     note tasks start end point    ii  branching factor  determining
number children task  between        iii  depth htn tree
 between        iv  ratio landmark time points number tasks
htn  varying       step size        v  probability constraints
siblings  varying       step size      
settings result graphs         vertices  induced widths
varying        though induced width seems high light claim
constant  verified wd   branching factor    landmarks    
instances  filling maximal values       respectively  find upper
bound wd      well actual maximum encountered 
figure    shows results experiments function induced widths
graphs  see larger induced widths  johnson chleqapsp
come close  large induced widths found high landmark ratios     
results indicate majority stns stemming htns  snowball significantly
efficient johnson 
    snowballseparators
section     presented version snowball improved worst case run time
vanilla snowball taking advantage separators graph  section 
discuss results experiments comparing two variants  first  turn
attention benchmark problems regular graphs  results summarised
figure     one see  snowballseparators actually performs strictly worse sets
terms run time performance compared original snowball 
however  seen table    largest minimal separator often equal
marginally smaller induced width  even though may
separators large  many may substantially smaller  as noted above 
instances median separator size      prompts us run experiments
instances separator sizes artificially kept small  indeed  found
cases snowballseparators shows improvement vanilla snowball comparing
number update operations performedi e  lines     snowball lines    
   

fiplanken  de weerdt    van der krogt

f w
johnson
chleq
snowball

time solve  ms  log scale 

    

   

  
 

  

  

  
induced width

  

   

   

figure     run times htn benchmarks graphs         vertices
varying induced width  point average instances induced width within
range   k   k       k  results      instances per data point 

      
snowball
snowball sep

time solve  ms  log scale 

     

chordal

    
scale free

ny
diamonds

   
htn

  
job shop

 
   

    
number vertices  log scale 

figure     run times snowball algorithms benchmark problem sets listed
table   

   

ficomputing apsp leveraging low treewidth

      

number updates  x      log scale 

snowball
snowball sep
dpc
p c

     

    

   
  

   

   

   

   
   
induced width

   

   

   

figure     number distance matrix updates chordal instances     vertices 
largest minimal separator size   varying treewidth  point represents  
   instances 
processcliquetreenode  along lines     dpc lines     p  c  one
case presented figure     describes results collection chordal
graphs     vertices  largest minimal separator fixed size   
treewidth varied         figure includes results dpc p  c 
respective subroutines snowball snowballseparators  graphs 
snowballseparators performs strictly fewer update operations snowball instances 
although difference becomes smaller induced width increases  number
updates shows distinct improvement snowball  run times snowballseparators
algorithms show improvement  instead  seen figure    
run times snowball strictly better snowballseparators instances 
snowball even seen outperform p  c better theoretical bound 
reason adjacency matrix data structure used snowball fast 
adjacency list used p  c  though staying within theoretical bound  inflicts larger
constant factor run time 
experiments  conclude graphs sizes  additional
bookkeeping required snowballseparators outweighs potential improvement
number distance matrix updates 
    proper upper bound run time
general graphs  run time proposed algorithms depends induced width wd
ordering produced triangulation heuristic  induced width direct
measure input  graph   given upper bound run time quite proper 
arrive proper bound  section aim relate run time treewidth 
denoted w   property input  however  determining treewidth 
   

fiplanken  de weerdt    van der krogt

     

time solve  ms  log scale 

snowball
snowball sep
dpc
p c

    

   

  
  

   

   

   

   
induced width

   

   

   

   

figure     run times chordal instances     vertices  largest minimal separator
size   varying treewidth  point represents      instances 

np hard problem  intractable task benchmark problems used  therefore

compare measured induced width wd w   upper bound treewidth  lower
bound x w     unaware guarantee quality relative treewidth
either minimum degree triangulation heuristic lower bound used  however 
calculate ratio wd  x get upper bound ratio wd  w  
measure obtain upper bound run time expressed treewidth 
least benchmark problems paper 
results computations found figure     plot ratios
new york  htn  scale free job shop benchmarks function lower
bound x  using least squares approach  fitted functions wd  x    cxk  showing
straight line log log plot  plotted data points  functions found
fitting  get k       new york  k       htn  k        job shop 
small multiplicative constants         c         one see plotted data
points scale free instances  amenable fit therefore omit
figure 
decreasing trend job shop data indicates quality triangulation
 i e  upper bound represented induced width  gradually increases  lower
upper bound always less factor   apart  indeed  plot line representing
function wd   x     x  yielding horizontal line figure   find describes
comfortable upper bound data points benchmark set 
htn data prompts us plot function wd    x       x      exponent slightly
higher one found least squares fit  tweaked slightly
    lower bound computed libtw package  see http   treewidth com   used
mmd   least c heuristic 

   

firelative induced width  vs  lower bound 

computing apsp leveraging low treewidth

new york
htn
scale free
job shop
 x
 
  x   

 

 

 

 
  

   
lower bound treewidth

figure     upper bound induced width relative treewidth determined experimentally comparing lower bound treewidth 
multiplicative coefficient bring view  function plotted represents ample
upper bound htn benchmarks  as well job shop ones  
fit data points new york benchmark good trend
points clear  lower bound spans interval
     therefore  cannot give upper bound set benchmarks
acceptable level confidence 
however  scale free data points plotted  could fitted function
yielding straight line  mostly follow clear curving trend  hypothesis
behaviour quality upper lower bound deteriorates mostly middle
sizes benchmarks  smaller larger scale free graphs easier triangulate well   
give upper bound  could plot line outer hull data points  e g 
horizontal line represented wd  x     x would work  pessimistic assumption
would choose function highest slope  find upper bound
wd    x       x      found htn benchmarks  works here 
discussion 
may conclude
benchmarks ran except new
snowball
york  wd  x  x    turn w       run time algorithms

chleqapsp instances therefore bounded n  w      
conclude section  remark alternative triangulation heuristic
would use approximation algorithm bound induced width
theoretically determined  example  bouchitte  kratsch  muller  todinca       
give  log w   approximation treewidth w   using approximation
would

give upper bound run time snowball n  w log w   however  run
    mirrors earlier observations authors 

   

fiplanken  de weerdt    van der krogt


time obtaining approximate induced width n  log  nw   log w high
constant well  work isfor nowmainly theoretical value 

   related work
dense  directed
graphs real weights  state of the art apsp algorithms run

 
n   logn time  chan        han         represent serious improvement
n  bound floydwarshall profit fact graphs
occur practice  number edges significantly lower n   
profit exactly algorithms sparse graphs aim achieve  recently 
improvement published nm   n  log n algorithm based johnsons       
fredman tarjans
       work  algorithm sparse directed graphs running

nm   n  log log n time  pettie         theory  algorithm thus faster
johnson  in worst cases  large graphs   n log n     however  currently
implementation exists  as confirmed
personal communication pettie  june

       upper bound n  wd run time snowball smaller
established upper bound induced width small  i e  wd  log log n   
and  course  chordal graphs graphs constant treewidth 
familiar one earlier work compute shortest paths leveraging low
treewidth  chaudhuri zaroliagis        present
algorithm answering  point to

wd   
point  shortest path queries wd  n log n preprocessing time query time

direct extension results apsp would imply run time n  wd  general
graphs ando nmwd  chordal graphs  result computing apsp general graphs
n  wd  nm  chordal graphs thus strict improvement 
large part state of the art point to point shortest paths focused road
networks  with positive edge weights   studies strong focus heuristics  ranging goal directed search bi directional search using creating hierarchical
structure  see example  geisberger  sanders  schultes    delling        bauer  delling 
sanders  schieferdecker  schultes    wagner         one hierarchical heuristics
similarities idea using chordal graphs  heuristic called contraction 
idea distinguish important  core  vertices  may possible end points 
vertices never used start end point  latter vertices
removed  bypassed  one by one  connecting neighbours directly 
restrictions input graphs shortest paths computed
assumed  sometimes lead algorithms tighter bounds 
example 

unweighted chordal graphs  apsp lengths determined n  time  balachandhran
  rangan        han  sekharan    sridhar        pairs distance two known 
see  dragan        overview unification approaches  considering
planar graphs  recent work shows apsp found n  log  n  klein  mozes 
 
 
weimann         improvement johnson cases n log n  
context planning scheduling  number similar apsp problems need
computed sequentially  potentially allowing efficient approach using dynamic algorithms  even gazit        provide method addition single edge
require n  steps  deletion n   m average  thorup        deme    explain use notation x  f  n   footnote   page     

   

ficomputing apsp leveraging low treewidth

trescu italiano       
later give alternative approach amortized run time
n   log n   log  n m
 
  especially context planning scheduling  esn
sential shortest paths time points maintained  often  sufficient
shortest paths selection pairs maintained  above  already mentioned
p  c algorithm planken et al         single shot case  planken et al        
describe algorithm incrementally maintains property partial path consistency
chordal graphs time linear number edges 

   conclusions future work
paper give three algorithms computing all pairs shortest paths  run
time bounded  i  n  graphs constant treewidth  matching earlier results
required n   chaudhuri   zaroliagis        
 ii   nm  chordal graphs  improving earlier nmwd     iii  n  wd general
graphs  showing
 
 
improvement previously known tightest bound n wd   bounds  wd
induced width ordering used  experimentally determined bounded
treewidth power     benchmarks 
contributions obtained applying directed path consistency combined
known graph theoretic techniques  vertex elimination tree decomposition 
computing shortest paths  supports general idea techniques may help
solving graphically representable combinatorial problems  main contribution
article narrow  focusing improving state art single 
important problem computing apsp 
results extensive experiments make recommendations
algorithm best suited type problems  small instances 
floydwarshall used  probably mostly thanks simplicity  yielding
straightforward implementation low overhead  snowball exploit fact
perfect elimination ordering efficiently found chordal graphs  makes
efficient algorithm class graphs  experiments different
types general graphs  conclude snowball consistently outperforms johnson  and
floydwarshall   except induced width high  experiments show
snowball always outperforms chleqapsp snowballseparators  although
latter better bound run time  surprisingly actual performance worse
snowball instances benchmark sets  holds even instances
snowballseparators performs significantly fewer updates  thus  conclude
additional bookkeeping required snowballseparators pay off 
regarding experiments  must noted that  although utmost
obtain fair comparison  constant factor measurements depends significant
way exact implementation details  e g  whether lookup table heap used  
put forward earlier work experimentally comparing shortest path algorithms  mondou  crainic    nguyen        cherkassky  goldberg    radzik        
implementation higher constant factor snowball algorithms may caused
adhering object oriented paradigm  i e  inheriting dpc p  c superclasses 
choosing reuse code rather inlining method calls  nonetheless  confident
general trends identified hold independently details 
   

fiplanken  de weerdt    van der krogt

note strictly speaking  algorithms introduced paper compute all pairs
shortest distances  one wants actually trace shortest paths  algorithms
extended keep track midpoint whenever distance matrix updated 
one floydwarshall  then  pair vertices  actual shortest path
graph traced  n  time 
current implementation snowballseparators  used priority queue decide
heuristically clique tree node visit next  giving precedence nodes connected
large separator part clique tree already visited  noted before  defer
answering question whether optimal ordering found efficiently future work 
remark using minimum degree heuristic triangulation provides snowball
natural edge  delaying processing vertices number iterations
middle loop small k grows large 
cherkassky goldberg        compared several innovative algorithms singlesource shortest paths gave better efficiency standard bellmanford algorithm
practice  worst case bound  nm  run time  future
work  investigate clever improvements exploited snowball 
snowballseparators improved way influence theoretical complexity may yield better performance practice  iterating vother
seen reverse traversal part clique tree visited before  starting cs parent 
then  instead always using separator current clique node  containing k 
parent previously visited vertices vother   keep track smallest
separator encountered backwards traversal extra asymptotic cost  since
shown table   largest minimal separator often hardly smaller
induced width  might well pay search smaller separators  plan implement
improvement near future 
another possible improvement suggested following observation dpc 
variant dpc proposed edge directionality taken account 
iteration k  neighbours i  j   k considered directed path
k j  resulting addition arc j  set added arcs would often
much smaller twice number edges added standard dpc algorithm 
graph produced directed variant would chordal  correctness
snowball would impacted 
furthermore  would experimentally compare algorithms recent
algorithms pettie        algorithms graphs constant treewidth chaudhuri zaroliagis        future work  addition  interested efficient
triangulation heuristics  triangulation heuristics guaranteed quality  able
give guaranteed theoretical bound general graphs  another direction  especially
interesting context planning scheduling  use ideas presented
design faster algorithm dynamic all pairs shortest paths  maintaining shortest paths
edge deletions  or relaxations  additions  or tightenings  

acknowledgments
roman van der krogt supported science foundation ireland grant number
   rfp cms     
   

ficomputing apsp leveraging low treewidth

offer sincere gratitude reviewers comments  helped us
improve clarity article strengthen empirical results 
article based conference paper title  received
honourable mention best student paper international conference automated
planning scheduling  planken  de weerdt    van der krogt        

appendix a  johnsons heap
experiments paper  presented results johnson
using fibonacci
 
heap  theoretical bound nm   n log n time attained 
practice  using binary heap theoretical bound  nm log n  time turns
efficient occasions  show results section 
figure    shows run times johnson binary heap fibonacci
heap benchmark sets listed table    diamonds  htn  new
york benchmarks binary heap percent faster fibonacci heap 
slope lines doubly logarithmic scale same  conclude
average case run time similar asymptotic behavior  however  larger job shop
problems  binary heap factor   slower fibonacci heap  chordal
graph benchmark problems even factor     benchmark problems scale free graphs
fixed number vertices help explaining difference 
figure     run time variants johnson found scale free graphs
      vertices  number edges varying       almost        
here  see sparsest scale free graphs        edges  binary
heap slightly faster  edges considered  using fibonacci heap
significantly outperforms using binary heap  particular  run time fibonacci
heap implementation increases slowly number edges  run time
binary heap increases much significantly  explained fact
running dijkstras algorithm subroutine johnson  update  candidate 
shortest path done amortized constant time fibonacci heap 
binary heap worst case cost  log n  time per update  number updates
bounded run dijkstras algorithm  yielding bound  nm  updates
johnson  binary heap  nm log n  bound accounts significant part
run time  fibonacci heap operations  such extracting minimum
element heap  bigger relative contribution run time 
based results benchmark sets  conclude although johnson
binary heap help reducing actual run time sparse graphs  johnson fibonacci
heap overall better choice large 

   

fiplanken  de weerdt    van der krogt

 e   
binary
fibonacci

time solve  ms  log scale 

 e   

chordal

      

     

ny

    

diamonds
scale free

   

htn
job shop

  

  

   
number vertices  log scale 

    

figure     run times johnson binary heap fibonacci heap
benchmark problem sets listed table   

 e   
binary
fibonacci

time solve  ms  log scale 

 e   

      

     

    

   

  

    

    

    
     
number edges  log scale 

     

     

figure     run times johnson binary heap fibonacci heap scale free
graphs       vertices increasing number edges 

   

ficomputing apsp leveraging low treewidth

references
albert  r     barabasi  a  l          statistical mechanics complex networks  reviews
modern physics               
arnborg  s   corneil  d  g     proskurowski  a          complexity finding embeddings
k  tree  siam journal algebraic discrete methods                
balachandhran  v     rangan  c  p          all pairs shortest length strongly chordal
graphs  discrete applied mathematics                   
bauer  r   delling  d   sanders  p   schieferdecker  d   schultes  d     wagner  d         
combining hierarchical goal directed speed up techniques dijkstras algorithm  experimental algorithms  wea        vol       lncs  pp         
springer 
bodlaender  h  l          classes graphs bounded tree width  tech  rep  ruu cs       utrecht university 
bodlaender  h  l          linear time algorithm finding tree decompositions
small treewidth  siam journal computing                   
bouchitte  v   kratsch  d   muller  h     todinca  i          treewidth approximations 
discrete applied mathematics                    
bresina  j  l   jonsson  a  k   morris  p  h     rajan  k          activity planning
mars exploration rovers  proc    th int  conf  automated planning
scheduling  pp       
bui  h  h     yorke smith  n          efficient variable elimination semi structured
simple temporal networks continuous domains  knowledge engineering review                 
castillo  l   fernandez olivares  j     gonzalez  a          temporal constraint network
based temporal planner  proc    st workshop uk planning
scheduling special interest group  pp         delft  netherlands 
castillo  l   fernandez olivares  j     gonzalez  a          efficiently handling temporal
knowledge htn planner  proc    th int  conf  automated planning
scheduling  pp       

chan  t          all pairs shortest paths real weights n    log n time 
algorithms datastructures  lncs  pp          springer 
chaudhuri  s     zaroliagis  c  d          shortest paths digraphs small treewidth 
part i  sequential algorithms  algorithmica                 
cherkassky  b  v   goldberg  a  v     radzik  t          shortest paths algorithms  theory
experimental evaluation  mathematical programming                 
cherkassky  b  v     goldberg  a  v          negative cycle detection algorithms  mathematical programming             
chleq  n          efficient algorithms networks quantitative temporal constraints 
proc   st int  workshop constraint based reasoning  pp       
   

fiplanken  de weerdt    van der krogt

conrad  p  r   shah  j  a     williams  b  c          flexible execution plans
choice  proc    th int  conf  automated planning scheduling 
cormen  t  h   leiserson  c  e   rivest  r  l     stein  c          introduction algorithms   nd edition  mit press 
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence                
demetrescu  c     italiano  g  f          fully dynamic all pairs shortest paths
real edge weights  journal computer system sciences                 
dijkstra  e  w          note two problems connexion graphs   numerische
mathematik            
dragan  f  f          estimating pairs shortest paths restricted graph families 
unified approach  journal algorithms              
even  s     gazit  h          updating distances dynamic graphs  methods operations research             
fiedler  n          analysis java implementations fibonacci heap  http   tinyurl 
com fibo heap 
floyd  r  w          algorithm     shortest path  communications acm        
    
fredman  m     tarjan  r  e          fibonacci heaps uses improved network
optimization algorithms  journal acm                 
geisberger  r   sanders  p   schultes  d     delling  d          contraction hierarchies 
faster simpler hierarchical routing road networks  proc  int  workshop
experimental algorithms  pp          springer 
girvan  m     newman  m  e  j          community structure social biological
networks  proc  national academy sciences usa                    
golumbic  m          algorithmic graph theory perfect graphs  elsevier 
graham  r  l   knuth  d  e     patashnik  o          concrete mathematics  foundation
computer science   st edition   addison wesley 
han  k   sekharan  c  n     sridhar  r          unified all pairs shortest path algorithms
chordal hierarchy  discrete applied mathematics               

han  y          note n    log n  time algorithm all pairs shortest paths 
information processing letters                  
heggernes  p          minimal triangulations graphs  survey  discrete mathematics 
                 minimal separation minimal triangulation 
johnson  d  b          efficient algorithms shortest paths sparse networks  journal
acm              
kjrulff  u          triangulation graphs   algorithms giving small total state space 
tech  rep   aalborg university 
   

ficomputing apsp leveraging low treewidth

klein  p  n   mozes  s     weimann  o          shortestpaths directed planar graphs
negative lengths  linear space n log  n  time algorithm  acm transactions algorithms             
mondou  j  f   crainic  t  g     nguyen  s          shortest path algorithms  computational study c programming language  computers   operations research 
               
pettie  s          new approach all pairs shortest paths real weighted graphs 
theoretical computer science                
planken  l  r   de weerdt  m  m     van der krogt  r  p  j          p  c  new algorithm
simple temporal problem  proc    th int  conf  automated
planning scheduling  pp         
planken  l  r   de weerdt  m  m     van der krogt  r  p  j          computing allpairs shortest paths leveraging low treewidth  proc    st int  conf 
automated planning scheduling  pp         
planken  l  r   de weerdt  m  m     yorke smith  n          incrementally solving stns
enforcing partial path consistency  proc    th int  conf  automated
planning scheduling  pp         
ranise  s     tinelli  c          smt lib format  initial proposal  proc 
pragmatics decision procedures automated reasoning 
rose  d  j          graph theoretic study numerical solution sparse positive
definite systems linear equations  read  r   ed    graph theory computing 
pp          academic press 
rossi  f   venable  k  b     yorke smith  n          uncertainty soft temporal constraint problems  general framework controllability algorithms fuzzy
case  journal ai research             
satish kumar  t  k          tractability restricted disjunctive temporal problems  proc    th int  conf  automated planning scheduling  pp 
       
shah  j  a     williams  b  c          fast dynamic scheduling disjunctive temporal
constraint networks incremental compilation  proc    th int  conf 
automated planning scheduling  pp         
stergiou  k     koubarakis  m          backtracking algorithms disjunctions temporal
constraints  artificial intelligence                 
strichman  o   seshia  s  a     bryant  r  e          deciding separation formulas
sat  proc    th int  conf  computer aided verification  vol      
lncs  pp          springer 
tarjan  r  e     yannakakis  m          simple linear time algorithms test chordality
graphs  test acyclicity hypergraphs  selectively reduce acyclic hypergraphs  siam journal computing                 
   

fiplanken  de weerdt    van der krogt

thorup  m          fully dynamic all pairs shortest paths  faster allowing negative
cycles  algorithm theory  vol       lncs  pp          springer 
warshall  s          theorem boolean matrices  journal acm              

   


