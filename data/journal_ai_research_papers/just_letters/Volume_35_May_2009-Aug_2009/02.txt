journal of artificial intelligence research                  

submitted        published      

trust based mechanisms for robust and efficient task allocation in
the presence of execution uncertainty
sarvapali d  ramchurn

sdr   ecs   soton   ac   uk

intelligence  agents  multimedia
school of electronics and computer science
university of southampton  southampton  uk

claudio mezzetti

c   mezzetti   warwick   ac   uk

department of economics
university of warwick  coventry  uk

andrea giovannucci

agiovannucci   iua   upf  edu

specs laboratory
pompeu fabra university
barcelona  spain

juan a  rodriguez aguilar

jar   iiia   csic   es

artificial intelligence research institute
spanish council for scientific research
barcelona  spain

rajdeep k  dash
nicholas r  jennings

rkd   ecs   soton   ac   uk
nrj   ecs   soton   ac   uk

intelligence  agents  multimedia
school of electronics and computer science
university of southampton  southampton  uk

abstract
vickrey clarke groves  vcg  mechanisms are often used to allocate tasks to selfish and rational
agents  vcg mechanisms are incentive compatible  direct mechanisms that are efficient  i e   maximise social utility  and individually rational  i e   agents prefer to join rather than opt out   however  an important assumption of these mechanisms is that the agents will always successfully complete their allocated tasks  clearly  this assumption is unrealistic in many real world applications 
where agents can  and often do  fail in their endeavours  moreover  whether an agent is deemed to
have failed may be perceived differently by different agents  such subjective perceptions about an
agents probability of succeeding at a given task are often captured and reasoned about using the
notion of trust  given this background  in this paper we investigate the design of novel mechanisms
that take into account the trust between agents when allocating tasks 
specifically  we develop a new class of mechanisms  called trust based mechanisms  that can
take into account multiple subjective measures of the probability of an agent succeeding at a given
task and produce allocations that maximise social utility  whilst ensuring that no agent obtains
a negative utility  we then show that such mechanisms pose a challenging new combinatorial
optimisation problem  that is np complete   devise a novel representation for solving the problem 
and develop an effective integer programming solution  that can solve instances with about       
possible allocations in    seconds  
c
    
ai access foundation  all rights reserved 

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

   introduction
task allocation is an important and challenging problem within the field of multi agent systems 
the problem involves deciding how to assign a number of tasks to a set of agents according to some
allocation protocol  for example  a number of computational jobs may need to be allocated to agents
that run high performance computing data centres  byde         a number of network maintenance
tasks may need to be performed by communications companies for a number of business clients
 jennings  faratin  norman  obrien  odgers    alty         or a number of transportation tasks
may need to be allocated to a number of delivery companies  sandholm         in the general case 
the agents performing these jobs or asking for these jobs to be performed will be trying to maximise
their own gains  e g   companies owning data centres or servers will be trying to minimise the
number of servers utilised  communications companies will try to minimise the number of people
needed to complete the tasks demanded  and transportation companies will try to use the minimum
number of vehicles   given this  mechanism design  md  techniques can be employed to design
these task allocation protocols since these techniques can produce solutions that have provable and
desirable properties when faced with autonomous and utility maximising actors  dash  parkes   
jennings         in particular  the vickrey clarke groves  vcg  class of mechanisms has been
advocated in a number of problem domains  walsh   wellman        hershberger   suri       
dash et al         because they maximise social welfare  i e   they are efficient  and guarantee a nonnegative utility to the participating agents  i e   they are individually rational   in such mechanisms 
agents typically reveal their costs for performing the tasks or their valuation of the requested tasks to
a centre and the centre then computes the allocation of tasks to each agent and the payments they all
need to make and receive  however  an important underpinning assumption that such mechanisms
make is that an agent always successfully completes every task that is assigned to it by the centre 
the result of this assumption is that an allocation  i e   an assignment of tasks that are asked for
by requester agents and executed by task performer agents  is selected by the centre based only
on the costs or valuations provided by the agents  this ensures that the centre always chooses the
performers that are the cheapest and the requesters that are ready to pay the most  however  the
agents chosen by the centre may ultimately not be successful in completing their assignment  for
example  an agent providing access to a data centre with a cost of     but with a success rate of
      might be preferable to one providing the same service with a cheaper cost of   but with a
    chance of being successful  thus  in order to make efficient allocations in such circumstances 
we need to design mechanisms that consider both the task performers costs for the service and their
probability of success  pos   now  this probability may be perceived differently by different agents
because they typically have different standards or means of evaluating the performance of their
counterparts  for example  different customers might evaluate the performance of a data centre in
different ways such as timeliness  security  or quality of the output  given this  we turn to the notion
of trust to capture such subjective perceptions  ramchurn  huynh    jennings         to take into
account the agents trust in other agents  as well as their costs  when allocating tasks requires the
design of a new class of mechanisms that we have previously termed trust based  dash  ramchurn 
  jennings        
to date  however  existing work on trust based mechanisms  tbms  ignores a number of important aspects of the task allocation problem which makes them less robust to uncertainty  see section
  for more details   first  porter  ronen  shoham  and tennenholtz        only allow pos reports
to come from the task performer  rather than any other agent  this means the task requester can
 

fit rust based m echanisms for robust and e fficient task a llocation

be misled by the task performers opinion  even if it is truthfully revealed  since the task requester
may believe  at times  that the task performer failed while the task performer believes it has succeeded  second  in our previous work  dash et al          we presented a trust based mechanism
that could result in inefficient allocations as agents had strong incentives to over report their pos 
even more importantly  however  existing trust based mechanisms completely ignore the computational cost associated with including the pos and computing the optimal allocation and payments 
thus  while previous work highlights the economic benefits  they do not specify how the new problem can be effectively represented and efficiently solved  by ignoring these issues  previous work
has failed to prove that such mechanisms can actually be implemented  solved  and whether they
scale up to reasonable numbers of agents 
against this background  this paper provides economically efficient and individually rational
mechanisms for scenarios in which there exists uncertainty about agents successfully completing
their assigned tasks  this execution uncertainty can generally be modelled as follows  first  potential task performers are assessed by a task requester that uses both its individual experience of their
performance and information gathered from its environment  such as reports by other agents about
their performance  to construct its estimation of their pos  often these sources are called confidence and reputation respectively  ramchurn et al         dasgupta         and when combined
they give the notion of trust in an agent performing a particular task  this combined view of trust
is used here because it is a more robust measure of pos than any single estimate  especially one
originating from the task performer   this is evident from the fact that each agent is only likely to
have a partial view of the performance of a task performer because it is derived from a finite subset
of its interactions  for example  a task requester having ten tasks performed by an agent may benefit
from the experience acquired from another requesters fifty interactions with that same agent  however  incorporating trust in the decision mechanism of the requester introduces two major issues 
first  when agents use reports from other agents to build trust  it introduces the possibility of interdependent valuations  this means that the value that is generated by one agent in the system can be
affected by another agents report to the mechanism  jehiel   moldovanu        mezzetti        
this  in turn  makes it much harder than in standard vcg based techniques to incentivise agents to
reveal their private information truthfully  second  using trust to find the optimal allocation involves
a significant computational cost and we show that solving the optimisation problem of trust based
mechanisms is np complete 
to tackle the issue of interdependence  we build upon the work by mezzetti              to
construct a novel mechanism that incentivises agents to reveal their private information  moreover  to help combat the computational complexity generated by trust  we go on to develop a novel
representation for the optimisation problem posed by trust based mechanisms and provide an implementation based on integer programming  ip   given this  we show that the main bottleneck of
the mechanism lies in searching through a large set of possible allocations  but demonstrate that our
ip solution can comfortably solve small and medium instances within minutes  e g   for   tasks and
   agents  or hours  e g   for   tasks and    agents    in so doing  we provide the first benchmark
for algorithms that aim to solve such optimisation problems 
in more detail  this paper advances the state of the art in the following ways 

   though the time taken to find the optimal solution grows exponentially with the number of tasks  our mechanism sets
the baseline performance in solving the optimisation problem posed by trust based mechanisms 

 

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

   we design novel tbms that can allocate tasks when there is uncertainty about their completion  our tbms are non trivial extensions to the paper by porter et al         because they
are the first to consider the reputation of a task performer within the system  in addition to its
self report  this allows us to build greater robustness into the mechanism since it takes into
account the subjective perceptions of all agents  task requesters in particular  about the pos
of task performers 
   we prove that our tbms are incentive compatible  efficient and individually rational 
   we develop a novel representation for the optimisation problem posed by tbms and  given
this  cast the problem as a special matching problem  berge         we show that solving
the generalised version of tbms is np complete and provide the first integer programming
solution for it  this solution can solve instances of    agents and   tasks within one minute
and even larger instances within hours 
the rest of the paper is structured as follows  we start by providing an overview of the related
work in section    we then provide the contributions listed above in a step wise manner  first 
a simple task allocation model is detailed in section    where we introduce the tbm for a single
requester  single task scenario  section   then develops the generalised tbm for multiple requesters
and multiple tasks and we prove its economic properties  having dealt with the economic aspects 
we then turn to the computational problem of implementing tbms in section    specifically  we
develop a new representation for the optimisation problem posed by the generalised tbm  study
the computational costs associated with solving the problem  and provide an ip based solution to it 
section   then discusses a number of broader issues related to the development of future trust based
mechanisms 

   related work
in associating uncertainty to mechanism design  we build upon work in both areas  with regards to
capturing uncertainty in multi agent interactions  most work has focused on devising computational
models of trust and reputation  see papers by teacy  patel  jennings    luck        and ramchurn
et al         for reviews   these models mostly use statistical methods to estimate the reliability of
an opponent from other agents reports and direct interactions with the opponent  some of these
models also try to identify false or inaccurate reports by checking how closely each report matches
an agents direct experience with the opponent  teacy et al         jurca   faltings         now 
while these models can help in choosing the most successful agents  they are not shown to generate
efficient outcomes in any given mechanism  in contrast  in this paper we provide the means to use
such models in order to do just this 
in the case of md  there has been surprisingly little work on achieving efficient  incentive compatible and individually rational mechanisms that take into account uncertainty in general  the
approaches adopted can be separated into work on reputation mechanisms and mechanisms for
task or resource allocation  the former mainly aim at eliciting honest feedback from reputation
providers  examples of such mechanisms include papers by dellarocas         miller  resnick 
and zeckhauser         and jurca and faltings               in particular  miller et al         recently developed the peer prediction model  which incentivises agents to report truthfully about their
experience  their mechanism operates by rewarding reporters according to how well their reports
 

fit rust based m echanisms for robust and e fficient task a llocation

coincide with the experience of their peers  specifically  it assigns scores to the distance between
a given agents report and other selected reference reporters reports on a given task performer  in
a similar way  jurca and faltings        have also attempted to solve the same problem by placing
more importance on the repeated presence of agents in the system in order to induce truthful reporting  however  given that they focus on eliciting honest feedback  their mechanism is silent as to
what this feedback is actually used for  in particular  it cannot be employed in the task allocation
scenario we study in this paper because in our case the objective is to maximise the overall utility
of the society that  therefore  considers the value and pos of agents  for example  a car repair has
a lower value than building a bridge  hence  the feedback on the car repairer is less critical than the
feeback on the bridge builder in terms of its impact on the social welfare  interestingly  their mechanism is shown to have truth telling as a  non unique  nash equilibrium and it is budget balanced 
but not individually rational  see section   on how these social desiderata interplay  
in terms of md for task allocation  type uncertainty is taken into account by bayesian mechanisms such as dagva  daspremont   gerard varet        arrow         this considers the
case when the payoffs to the agents are determined via a probability distribution of types which is
common knowledge to all agents  however  this mechanism cannot deal with our problem in which
there is uncertainty about task completion  and each agent has information about the pos of all
other agents  but there is no common knowledge of the type distributions  porter et al         have
also considered this task allocation problem and their mechanism is the one that is most closely
related to ours  however  they limit themselves to the case where agents can only report on their
own pos  this is a serious drawback because it assumes the agents can measure their own pos
accurately and it does not consider the case where the agents may have different perceptions on the
pos  e g   a performer believes that it performs better or worse than what the requester perceives  
moreover  they only consider a single requester setting  while the mechanisms we develop here
deal with multiple tasks and multiple requesters  thus  our mechanisms can be considered to be
a two way generalisation of theirs  first  we allow multiple reports of uncertainty that need to be
fused appropriately to give a precise pos as perceived by the requester  second  we generalise their
mechanism to the case of multiple requesters where the agents can provide combinatorial valuations
on multiple tasks  in our earlier work on this problem  dash et al          we proposed a preliminary tbm where the agents could have followed the risky  but potentially profitable strategy  of
over reporting their costs or under reporting their valuations since payments are not made according to whether they succeed or fail in the allocated task  which we do in our new mechanism   in
contrast  in this work  the payment scheme ensures that such a strategy is not viable and thus this
mechanism is more robust  moreover  our previous work assumed trust functions that were monotonically increasing in pos reports and  similar to porter et al   did not develop the algorithms that
are needed to actually solve the optimisation problem posed by a tbm  in this paper  we present a
mechanism that applies to more general trust functions and also develop algorithms to solve tbms 
finally  our work is a case of interdependent  multidimensional allocation schemes  with interdependent payoffs  jehiel and moldovanu        have shown that is impossible to achieve efficiency
with a one stage mechanism  mezzetti         however  has shown that it is possible to achieve efficiency with an elegant two stage mechanism under very reasonable assumptions  our mechanism
achieves efficiency without needing two reporting stages because  in the setting we consider  payments can be contingent on whether or not tasks are successful and because agents do not derive a
direct payoff from the allocation of a task to another agent or the other agents assessments about
the completion probabilities  in our setting  there exists a specific function that captures the interde 

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

pendence that exists among the agents through their assessments of each others pos  this function
is  in our case  the agents trust model 

   single requester  single task allocation mechanisms
in this section  we first present the basic vcg mechanism for a simple task allocation model  a
single task being requested by a single agent  where the allocated task is guaranteed to be completed
 i e   all agents pos are equal to     we then briefly describe porter et al s        extension
which considers task performers that have a privately known objective probability that they finish
the assigned task  finally  we consider the case where the pos of a task performer is a function
of privately known variables held by each task performer in the system  this ensures that the
choice made by the task requester is better informed  drawing data from various sources  about
the pos of task performers  we show how porter et al s mechanism would fail to produce the
efficient allocation in such settings and then go on to provide a non trivial extension of their model
to cater for this  in so doing  we define a new trust based mechanism for the single requester 
single task scenario  as a prelude to the generalised mechanism that we will develop in the next
section   we then go on to prove the economic properties of this simple tbm  throughout this
section  a running example task allocation problem is employed to demonstrate the workings of the
mechanisms discussed 
    allocation with guaranteed task completion
in this task allocation scenario  a single agent derives a value when a certain task is performed  to
this end  that agent needs to allocate the task to one of the available task performers  which will
charge a certain amount to execute the task  we start by considering the following simple example 
example    moviepictures com  a computer graphics company  has an image rendering task that
it wishes to complete for a new movie  hence  moviepictures com publicly announces its intention
to all companies owning data centres that can execute the task  given the interest shown by many
of these companies  moviepictures com needs to decide on the mechanism to allocate the contract
and how much to pay the chosen contractor  given that moviepictures com does not know all the
contractors costs to execute the job  i e   it does not know how much it actually costs each company
to process the images and render them to the required quality  
the above example can be captured by the following model  there is a set of agents  data
centre agents in the example   i                  i          i   who each have a privately known cost
ci      r       of performing the rendering task    furthermore  let moviepictures com be
represented by a special agent    who has a value v       r       for the rendering task and a
cost of c        v      to perform the task  c         in case agent   cannot execute the task  
hence  moviepictures com can only get the task performed by another agent in the set i who has a
cost ci      v      
now  moviepictures com needs to decide on the procedure to award the contract  and hence 
acts as the centre that will invite offers from the other agents to perform the task  in devising such
a mechanism for task allocation  we focus on incentive compatible direct revelation mechanisms
 drms  by invoking the revelation principle which states that any mechanism can be transformed
into a drm  krishna         in this context  direct revelation means the strategy space  i e   all
possible actions  of the agents is restricted to reporting their type  i e   their private information  for
 

fit rust based m echanisms for robust and e fficient task a llocation

example their cost or valuation of a task  and incentive compatible means the equilibrium strategy
 i e   best strategy under a certain equilibrium concept  is truth telling 
thus  in a drm  the designer has control over two parts     the allocation rule that determines who wins the contract  and    the payment rule that determines the transfer of money between the centre  i e   moviepictures com  and the agents  i e   the data centres   let k denote
a particular allocation within the space of possible allocations k and  i  represent that agent
i gets allocated task  from agent    then  in this setting  the space of all possible allocations
are k                           i    where  denotes the case where the task is not allocated 
moreover  we abuse notation slightly to define the cost of an allocation k to agent i  as being
ci  k    ci     if k    i  and ci  k      otherwise  similarly  for the centre  the value of a
non empty allocation is simply the value it has for the task  i e   v   k    v      if k     and
v   k      if k     finally  let ri     r be the payment by the centre to agent i  in case ri    is
negative  agent i has to pay  ri     to the centre 
within the context of task allocation  direct mechanisms take the form of sealed bid auctions
where task performers report their costs to a centre  or auctioneer   agents may not wish to report
their true costs if reporting these falsely leads to a preferable outcome for them  we will therefore
distinguish between the actual costs and the reported ones by superscripting the latter with b 
the task allocation problem then consists of choosing the allocation and payment rules such that
certain desirable system objectives  some of which are detailed below  are satisfied  an allocation
rule is a mapping from reported costs to the set of allocations  with k b
ci   b
ci   being the allocation
chosen when agent i reports b
ci and all other agents report the vector b
ci   similarly  a payment rule
is a mapping from reported costs to payments for each agent  with ri  b
ci   b
ci   being the payment to
agent i when agent i reports b
ci and all other agents report the vector b
ci  
following the task execution and payments  an agent i derives a utility given by its utility function ui   k  r  r  as is common in this domain  we assume that an agent is rational  expected
utility maximiser  and has a quasi linear utility function  mascolell  whinston    green        
definition    a quasi linear utility function is one that can be expressed as 
ui  k  ri     ri  ci  k 

   

where k  k is a given allocation 
having modelled the problem as above  moviepictures com would like to use a protocol that
possesses the desirable properties of efficiency and individual rationality  it also needs to make sure
that the protocol is incentive compatible  agents must find it optimal to report their true costs  these
desiderata can be formally defined as follows 
definition    efficiency  the allocation mechanism is said to achieve efficiency if the outcome it
generates maximises the total utility of all the agents in the system  without considering transfers  
that is  for all vectors of reports b
c  it calculates k  such that 
 
 
x
b
ci  k 
   
k   b
c    arg max v   k  
kk

ii

definition    individual rationality  the allocation mechanism is said to achieve individual rationality if agents derive higher utility when participating in the mechanism than when opting out of it 
 

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

assuming that the utility that an agent obtains when opting out is zero  then an individually rational
allocation k is one in which  krishna        
ui  k  ri        i  i

   

definition    incentive compatibility  the allocation mechanism is said to achieve incentive compatibility if an agents true type is its optimal report no matter what other agents report  that
is 
ri  ci   b
ci    ci  k ci   b
ci     ri  b
ci   b
ci    ci  k b
ci   b
ci    ci   b
ci   b
ci  

note that incentive compatibility implies that for each vector of reports of the other agents b
ci
the payments to agent i must depend on is own report only through the chosen allocation  incentive
compatibility requires that telling the truth be a  weakly  dominant strategy  it is also important to
note that incentive compatibility in dominant strategies is the strongest possible form of incentive
compatibility  the vcg mechanism has this property 
moviepictures com then decides to employ a vickrey auction  also known as a second price
sealed bid auction  since this protocol possesses the desired properties of incentive compatibility 
efficiency  and individual rationality  krishna         in more detail  after having received the
sealed bids  reports b
c  from all the agents  the centre calculates the allocation k   b
c  according to
equation      while the transfer ri    to the winner i is given by 


x
v   k    
ri  b
c    v   k   b
c    max
b
cj  k   
   

k ki

ji i

where ki is the set of all allocations that do not involve i as a task performer 
    allocation with execution uncertainty

in the mechanism presented in the previous section  it is assumed that once the allocation k  is
decided  its value v   k    will be obtained by the centre  either v      if the task has been allocated
or   otherwise   thus  there is an implicit assumption that once allocated a task  an agent will
always perform it successfully  however  this is unrealistic  as illustrated by the following example 
example    many of the previous rendering tasks required by moviepictures com were allocated
to poorrender ltd because of its very competitive prices  unfortunately  poorrender ltd could
not complete the task in many cases because of lack of staff and other technical problems  which
it knew about before even bidding for the task   as a result  moviepictures com incurred severe
losses  hence  moviepictures com decides to alter the allocation mechanism in such a way that
the agents pos in completing the tasks can be factored into the selection of the cheapest agent 
moviepictures com assumes each contractor knows its own pos and cost privately and needs the
mechanism to elicit this information truthfully in order to choose the best allocation 
the above problem was studied by porter et al         and we briefly describe  in our own terms 
their mechanism in order to extend and generalise it later  see sections     and     we first introduce
the boolean indicator variable  that will denote whether the task has been completed        or
not         thus   is only observable after the task has been allocated  moreover  we extend
 

fit rust based m echanisms for robust and e fficient task a llocation

our notation here to capture the centres valuation of the task execution such that v       v   k   
if      and v         if       in this setting  we assume that  is commonly observed  i e  
if agent i believes that       then all agents i  i      believe the same   in our rendering
example   might denote whether the images are rendered up to the appropriate resolution which
will allow its usage or not  furthermore  the probability that      once the task is allocated to
agent i is dependent upon another privately known variable  pi              which is the pos of
agent i in executing task    note that this variable is privately known to the task performer i itself 
and so there is a single observation within the system  carried out by the task performer  about its
own pos  also note that the task performer incurs the cost ci     as soon as it attempts the task 
and irrespective of whether it is successful or not 
as can be seen  the value that the centre  moviepictures com  will derive  v      is not known
before the allocation is calculated  hence  the notions of efficiency and individual rationality introduced in section     need to be adjusted to this new setting  given the probability that the task will
be executed by a given agent  we have to consider the expected value of an allocation  v    k  p  
which is calculated as 
v    k  p    v   k   pi    

   

where i is the agent chosen to perform the task in allocation k and p   hp               pi    i is
the vector of pos values of all the agents  the list of assessments by each contractor of its own
probability that it will complete the rendering task as in our example   we now need to require
b the vector of reported pos values
agents to report their pos  in addition to the cost  we denote as p
hb
p               pbi    i 
the following modified desiderata need to be considered now 

definition    efficiency  a mechanism is said to achieve efficiency if it chooses the allocation that
maximises the sum of expected utilities  without considering the transfers  
 
 
x
b  
b    arg max v    k  p
b
ci  k 
   
k   b
c  p
kk

ii

b are reported by the agents and are key to computing the efficient
note here that both b
ci  k  and p
allocation 
definition    individual rationality  a mechanism achieves individual rationality if a participating
agent i derives an expected utility  ui   which is always non negative 
ui  c  p    ri  c  p   ci  k    

where ri  c  p  is the expected payment that agent i receives 
in order to achieve these desiderata  one could suppose that a nave extension of the standard
vickrey mechanism presented above would be sufficient  in such a mechanism  the centre would
ask the agents to report their extended types  b
ci   pbi       the allocation chosen would then be the one
maximising the expected utility of the agents and the payment rule would be conditioned according
to equation     with v    k    p  replacing v   k     however  such a mechanism would fail in these
settings  as illustrated in the next section 
 

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

      na ive a pplication of the v ickrey auction
example    consider the case where moviepictures com derives a value of v            when
the rendering task is completed and let there be three contractors whose costs ci     to render the
images are given by  c       c       c                          furthermore  assume each contractor
has a pos given by  p       p       p                        this information is represented in table
  
the efficient allocation in this case  shaded line in table    involves assigning the task to agent
  with an expected social utility of                      the payment to agent   using the
 reverse  vickrey auction with expected values is                             from equation
      however  such a mechanism is not incentive compatible  for example  if agent   reveals that
pb           then the centre will implement k        and will pay agent    r                 
thus  the agents in such a mechanism are always better off reporting pbi          no matter what
their actual pos is  hence  the centre will not be able to implement the efficient allocation 
agent
 
 
 

ci    
   
   
   

pi    
   
   
 

table    costs of performing task  and each agents own perceived probability of successfully completing
the task 

this type extension  i e   including the pos  is non trivial because the pos report of an agent
affects the social value expected by the centre  but not the agents cost under an allocation  as
a result  reporting a higher pos will only positively affect an agents probability of winning the
allocation and thus will positively affect its utility  to rectify this  we need a means by which this
gain in utility is balanced by a penalty so that only on truthfully reporting its type  will an agent
maximise its utility  this is achieved in porter et al s        mechanism  which we briefly detail in
the next section 
      p orter et al   s m echanism
this mechanism is based around payments being applied after the completion of tasks  specifically 
the mechanism finds the marginal contribution that an agent has made to the expected welfare of
other agents depending on whether it completes its assigned task or not  intuitively  this works since
the payment scheme punishes an agent that is assigned a task but does not complete it  i e         
as a result  the agent is not incentivised to reveal a higher pos value than its real pos since if it is
then allocated the task  it is more likely to reap a punishment rather than the reward which it obtains
when it successfully completes the task  i e         
in more detail  the allocation is determined by the centre according to equation      the payment rule for an agent i to which the task  is allocated is similar to that of the vcg in that the
marginal contribution of the agent to the system is extracted by comparing the efficient allocation
b        if it is not allowith the second best allocation  excluding the agent  the agent gets ri  b
c  p
cated the task   the difference is that it is the expected marginal contribution that is extracted  i e  
  

fit rust based m echanisms for robust and e fficient task a llocation

taking into account the agents real probability of success   this is achieved as follows 



p
  b
 
  p

b
b
v
 k
c
 
p
  

max
b
c
 k
  if     
v
 k
 


 
 
ji i j

k  ki

b     
ri  b
c  p



p


b  
b
cj  k   
  if     
 max v    k    p


   

ji i

k  ki

where ki is the set of allocations excluding agent i 
the mechanism would work with the example provided in table   since if  for example  agent
  reports pb           it will then be allocated the task and will be paid                with a
probability of     and     with a probability of      thus  on average  agent   will be paid   
but each time it will incur a cost of      thereby making an expected utility of     clearly  then 
a rational agent will not overstate its pos  in fact  the incentive compatibility of this mechanism
arises because an agent is expected utility  given it is allocated the task  is 


b    pi     v   k   b
b    ci  k   b
b    max
ui  b
c  p
c  p
c  p


k ki



b    max
      pi      ci  k   b
c  p


k ki



b   p   ci  k   b
b    max
c  p
c  p
  v    k   b


k ki



b  
v    k    p

b  
v    k    p



x

ji i

b  
v    k    p

x

ji i



b
cj  k    



b
cj  k    

x

ji i

   


b
cj  k   

note that the expected utility within this mechanism is the same as what would have been
derived by agents in the nave extension of the vcg if they were truthful in reporting p  however 
in porter et al s mechanism  agents do not have an incentive to lie  this is because  if pbi       pi    
 i e   the agent over reports its pos   then the agent might be allocated the task even though 
h
i
i    arg max v   k x  px      cx  k x  
xi

where

kx

 

 x   

which means it could be that 

b   p   ci  k   b
b     max
v    k   b
c  p
c  p


k ki



x
b  
b
cj  k   
v    k    p
ji i

this results in the agent deriving a negative utility as per equation      hence  an agent will not
report higher pos values  a more complete treatment of the proof of the incentive compatibility
of the mechanism is given in the paper by porter et al          furthermore  the mechanism is also
proven to be individually rational and efficient 
    allocation with multiple reports of execution uncertainty
in the previous section  we considered a mechanism in which each agent has only its privately known
estimation of its own uncertainty in task completion  this mechanism considers that the centre can
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

only receive a single estimate of each agents pos  we now turn our attention to the previously
unconsidered  but more general  case where several agents may have such an estimate  for example 
a number of agents may have interacted with a given data centre provisioning company on many
occasions in the past and therefore acquired a partial view on the pos of that company  using such
estimates  the centre can obtain a more accurate picture of a given agents likely performance if
it combines these different estimates together  this combination results in a better estimate for a
number of reasons  including 
   accuracy of estimation  the accuracy of an estimation is typically affected by noise  thus 
combining a number of observations should lead to a more refined estimate than obtaining a
single point estimate 
   personal preferences  each agent within the system may have different opinions as to what
constitutes success when attempting a task  as a result  the centre may be willing to assign
more weight to an agents estimate if it believes this agents perspective is more similar to its
own 
we illustrate the above points by considering the following example 
example    moviepictures com is still not satisfied with the solution chosen so far  this is because
poorrender ltd still reports that it has a high pos  even though moviepictures com has noticed
that they have failed their task on a number of occasions  this is because poorrender ltd believes
the images it rendered were of a high enough quality to be used in a feature film while moviepictures com believed they were not  moviepictures com therefore cannot rely on the agents own
perception of their pos to decide on the allocation  rather  moviepictures com wants to ask all
agents to submit their perception about each others pos  in so doing  moviepictures com aims to
capture the knowledge that agents might have about each other either from previous sub contracted
tasks or simple observations  to this end  moviepictures com needs to devise a mechanism that will
capture all the agents perceptions  including its own  into measures of pos for each agent and use
these fused measures in the selection process 
the above example can be modelled by introducing a new variable  the expected quality of
service  eqos   noted as ij      which is the perception of each agent i about the pos of agent j
on task    now  the vector of agent is eqos of all agents  including itself  within the system is
noted as  i   hi               ii    i  furthermore  we shall denote as  j the eqos that all agents
within the system  including itself  have about agent j  thus  in our image rendering example  ij    
might denote the probability as perceived by agent i that the rendering task is completed according
to a certain level of quality of the computer graphics  which is perceived differently by the different
agents   then  moviepictures com needs a function in order to combine the eqos of all the agents
so as to give it a resultant pos that the movie is rendered up to its own graphic requirements 
in more detail  given is previous personal interaction with j  i can compute  based on the frequency of good and bad interactions  a probability  termed its confidence  in j as the pos  second 
i can also take into account other agents  i  opinions about j  known as js reputation in the society  in order to compute the pos of j  ramchurn et al          the combination of both measures
is generally captured by the concept of trust  which is defined as the aggregate expectation  derived
from the history of direct interactions and information from other sources  that j will complete the
  

fit rust based m echanisms for robust and e fficient task a llocation

task assigned to it  the aggregate trust that agent j will successfully complete task  for agent   is
a function tr j          i          
there are multiple ways in which the trust function could be computed  but it is often captured
as follows 
tr j     

x

wl  lj

   

li

p
where wl         and wl      this function generates trust as a weighted sum of eqos values 
in some cases  the s are actually considered to be probability distributions and the trust function is
the expected value of the joint distribution constructed from the individually reported distributions
 teacy et al         jurca   faltings         much work exists in the literature that deals with
different ways of combining these distributions such that biases or incompatibilities between agents
perceptions are taken into account  essentially  however  they all assign weights to different reports
of the agents and choose the expected value of these reports as the trust in an agent  however  to
date  none of these models actually studies how to get self interested agents to generate such reports
truthfully along with maximising the social welfare 
now  a direct mechanism in this case elicits from each agent i  its cost and eqos vector 
 ci       i    after which the centre decides on the allocation and payments to the agents  in computing its expected utility in a mechanism  an agent must evaluate the trust  or probability of success 
by the agent who is allocated the task  this raises a conceptual difficulty  how should an agent
treat the other agents pos reports in assessing the probability of task completion  as opposed to
computing its best response to their type reports   the approach we will take in this paper is that
an agent assumes the reported pos of the other agents is truthful in computing the trust in another
agent  more precisely  an agent computes the value of the trust function by using his true eqos and
the reported eqos of the other agents  thus  the trust of agent i that agent j will be able to comb i    as we have already seen  in general a payment to an agent depends
plete the task is tr j   i   
b 
on the reported types of all agents and on whether the task succeeds or fails  to this end  let i b
c  
b    then  define
be the agent who is allocated the task when the vector of reported types is  b
c  
b   as
the expected payment to agent i when the true types are  c    and the reported types are  b
c  
follows 
h
i
b  
b 
b  
b 
i c
i c
b   c      ri  b
b        tr 
b i     ri  b
b            tr 
b i  
eri  b
c  
c  
  i   
c  
  i   
we should point out that the type of an agent  eqos plus cost  is multidimensional and  as is
common in a multidimensional world  there could be several type reports that generate the same
expected payment to an agent  we are now ready to define the modified notion of incentive compatibility we will use  

definition    incentive compatibility  in dominant strategies   the allocation mechanism is said
to achieve incentive compatibility in dominant strategies if an agents true type is its optimal report
no matter what the other agents report  that is  c    b
ci   b
 i   b
ci   b
 i  
b i   c     ci  k ci   b
bi  
b i   c     ci  k b
eri  ci   b
ci    i   
ci     eri  b
ci   b
ci   
ci   b
ci   

   that an agent uses the reported pos of the other agents in computing the value of the trust function seems a natural
assumption when an agent can rely on the other agents truthfully reporting their types  this is the case  for example 
when the history of interactions between the pos reporters is publicly known  e g   on ebay or amazon  

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

now  in the case where agents do not view the eqos reports of the other agents as being
truthful  the trust of agent i that agent j will be able to complete the task may depend on both
true and reported types of all agents  in such a case we could relax the incentive compatibility
requirement from dominant strategy to  ex post  nash equilibrium  mascolell et al          which
means that if all the other agents report truthfully  then it is optimal for an agent always to report its
true type  no matter what the true types of the other agents are  after replacing the new trust function
in the definition of the expected payment to agent i  the definition of incentive compatibility would
change to 
definition    incentive compatibility  in nash equilibrium   the allocation mechanism is said to
achieve incentive compatibility in  ex post  nash equilibrium if an agents true type is its optimal
report provided other agents report their type truthfully  that is  ci   b
ci    i   b
 i   ci    i  
b i    i   c     ci  k b
eri  ci   ci    i    i   c     ci  k ci   ci     eri  b
ci   ci   
ci   ci   

we next demonstrate why porter et al s mechanism would not work in this setting by extending
example   
      failure of p orter et 

al s

m echanism

example    two agents have costs for performing a task  requested by the centre and have formed
perceptions on the set of agents i given in table    suppose that tr i        i        i         and
v          
agent
 
 
i
tr    

ci   i  
 
 

i     
   
   
   

i     
 
   
   

table    costs and eqos reports of agents in a single task scenario  the trust of the requester is calculated
assuming truthful reports 

porter et al  do not specify a procedure that deals with eqos reports  however  a natural
   instead of pbi      and to ignore
extension of their technique would be to allocate according to tr i  b
all reports of agent i in the computation of its payment  we implement this in the above example 
agent   should be the winner since it generates an expected social utility of      while agent   would
generate a utility of      the expected utility to the agent allocated the task is then  according to
equation      
b i    ci  k   b
b     max
b     v   k   b
b     tr i   i   
c  
ui  b
c  
c  


k ki

h

i

 i    b
cj  k   
v   k     tr j  b

    
b i excludes all  reports by agent i  ki is the set of allocations excluding agent i  and
where 
j  is the agent that is allocated the task under allocation k    unfortunately  this extension breaks
incentive compatibility in the following way  given that the efficient allocation is computed using
b values of all agents  using tr   b
b in equation       the value of the best
the reported 
   instead of p
  

fit rust based m echanisms for robust and e fficient task a llocation

allocation obtained by removing one agent could be arbitrarily lower  in the example above  if agent
  reports         the efficient allocation becomes agent   with an expected social utility of     and
agent   gets an expected utility of     because the systems utility drops to     when its reports are
removed and the allocation recomputed  if agent   is truthful it will obtain   utility since agent  
would be the winner in this case  in effect  the removal of an agent from the system breaks the
mechanism because of the interdependence between the valuations introduced by the trust model 
we elaborate further on this issue and show how to solve it in the next section 
we thus need to develop a mechanism that is incentive compatible when agents are reporting
about their perceptions of other agents pos  in order to do so  however  we now need to additionally
consider the effect that reporting the eqos vector has on an agents expected utility  specifically 
we need to develop a trust based mechanism in which the eqos reports of an agent do not provide
it with a way of increasing its overall expected utility  as per the intuition behind the vcg   then 
with the true value of the eqos  the mechanism will result in the selection of the optimal allocation
of tasks 
      t he s ingle r equester s ingle task t rust based m echanism
intuitively  the following mechanism works by ascertaining that an agent derives a positive utility
when it successfully completes a task and its eqos report does not change the allocation in its
favour  thus  the mechanism we develop can be regarded as a generalisation of the paper by porter
et al         
in more detail  let i k  be the agent performing the task under allocation k  the centre first
determines the allocation according to 
 
x
i k 
b     arg max v   k   tr   b
k   b
c  
  
b
ci  k 
kk

 

    

ii

having computed the efficient allocation as above  we adopt a similar approach to porter et
al s to compute the payments after tasks have been executed  see section         however  the
novelty of our mechanism lies in the use of all agents eqos reports in the computation of the
efficient allocation  as we showed above   moreover  we have additional payments for the losers to
incentivise all agents to select the efficient allocation 
thus  we apply different payments to the cases where the agent winning the allocation succeeds
 i e         and when it fails  i e          so if agent i is allocated the task  i e   k      i    
the payment is 

b      
ri  b
c  


b     bi  b
b i     if     
c  
ci   
 v   k   b


b i  
bi  b
ci   

    

  if     

where bi       is a term independent from is report  a constant from is point of view  that
reduces the payment that needs to be made to the agent  we briefly discuss how the value of bi   
could be set to reduce the payout made by the centre later in this section  and we provide greater
detail in section     
in addition to paying the winner  we also reward the losers k  i   i in the following way 
depending on whether i succeeds or not 
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

b      
rk  b
c  


b     b
b     bk  b
b k     if     
c  
ci  k   b
c  
ck   
 v   k   b


b     bk  b
b k  
b
ci  k   b
c  
ck   

    

  if     

intuitively  the payment scheme aims to incentivise all agents to reveal their type so that the
most efficient allocation is chosen  let k i be the allocation assigning the task to agent i  suppose
b i   and all other agents report  b
b i    when
agent i with type  ci    i   reports its type as  b
ci   
ci   
agent i wins the task  it will derive the following expected utility 




b i   v  k i  tr i  i   
b i  ci k i  bi  b
b i  
ui k i    i   
ci   
    

b i reflects the true pos of agent i  when agent k    i is assigned the task 
note that tr i  i   
agent i obtains the following expected utility by participating in the mechanism 

 

 

b i   v  k k  tr k  i   
b i  b
b i  
ui k k    i   
ck k k  bi  b
ci   
    

the only difference between equations      and      is the identity of the winner  hence  by
falsely reporting  agent i can only influence the identity of the winner  agent is expected utility
in the mechanism is equal to the expected social utility in the system minus a constant independent
of is report  hence  if agent i is rational it should report its true type  so that the efficient agent
 outcome  is chosen  this shows that the single task trust based mechanism is incentive compatible
and efficient  
proposition    the mechanism described by equations             and      is incentive compatible 
proposition    the mechanism described by equations             and      is efficient 

proof  since agent ks report about  k affects the expected utility of all other agents  see equations
     and        we have interdependence between agents payoffs  or valuations  however  no agent
can influence its own transfer through its report  because the computation of agent is payment is
b i  and b
independent of its report 
ci   and is only dependent on the actual execution of the task and
therefore on the true  i value  it is this feature that permits the implementation of the efficient
allocation with a single stage mechanism 
to exemplify the payments in our mechanism  consider the following extension of example   
example    two agents have zero cost for performing a task  requested by the centre and have
eqos ij                      for i  j         suppose that tr i        i        i         and
v          
by setting bi       in the above example  we have that the payment to each agent when the
task is completed successfully is      while the payment when the task fails is      hence  the
centre profits from implementing the mechanism  agents have an incentive to report truthfully  so
that the agent most likely to succeed is allocated the task  furthermore  all agents are willing to
participate  because the probability of success is at least      it is     in the worst case scenario 
   we provide a more detailed proof for the generalised case in section     

  

fit rust based m echanisms for robust and e fficient task a llocation

and hence  agents expect to obtain at least zero from participating  the mechanism is individually rational  also note that the total expected payment from the centre to all agents is at most
                                but could be as low as                               as
we now show  bi can always be chosen so that individual rationality is satisfied 
proposition    for an appropriate choice of bi     the mechanism described by equations      
      and      is individually rational 
proof  by not participating in the mechanism  an agent can only obtain   utility  however  if an
agent decides to participate  and by virtue of the selection of the efficient allocation  which returns
no allocation if the social welfare generated is less than     it is guaranteed  as a winner  to obtain
the utility ui described in equation      or  as a loser  the utility uk in equation       since in both
cases ui  bi    when the efficient allocation is chosen  and bi can be set to    the mechanism is
individually rational 
obviously  since all agents utilities are tied to that of the winning agent  they also lose out if
the winning agent fails but  in expectation  all agents make a profit of at least   in case bi is set to
   as example   shows  if the centre is trying to minimise payments  and increase its own profits  
it could set bi to be greater than zero and still satisfy individual rationality  in section      we
show how to set bi to a value that maintains individual rationality while minimising payments in
the general model 
here we note that sometimes it may be preferable for the centre to give up individual rationality 
consider  for example  if we modify example   to allow for an additional eqos value ij          
for i  j         to induce type ij           to participate  the centre could set bi          
so that the payment following success is     and the payment after failure is      in the worst
case scenario for the centre  i e   when the centres profit is the lowest   the total expected payment
in this mechanism is                               in the best case scenario  the total
expected payment is zero   as we shall see in section      the centre could substantially reduce
its payments by making bi    depend on the report of the other agents  i e   other than i   still  it
may be preferable for the centre to set bi           giving up on the participation of agents with
eqos values ii       ij            in general  when there are low eqos types  the centre faces
a trade off between efficient task allocation and payments minimisation  we leave the study of this
trade off to future work  see section   for some initial thoughts  

   the generalised trust based mechanism
the mechanisms we presented in the previous section dealt with the basic task allocation problem
in which there is one requester  one task  and several performers  here  we aim to efficiently solve
the more general problem of trust based interactions in which more than one agent requests or
performs  or both  more than one task  to this end  we extend the single requester single task
setting to the more general one of multiple requesters and multiple tasks in our generalised trustbased mechanism  gtbm   this extension needs to consider a number of complex features on
top of those dealt with previously  first  we need to consider multiple requesters that can each
make requests for sets of tasks and task performers that can each perform sets of tasks as well 
thus  the centre now acts as a clearing house  determining the allocation and payments from the
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

multiple bids from the task requesters and multiple asks from the task performers  this significantly
complicates the problem of incentivising agents to reveal their types since we now have to make
sure that the agents reveal their costs  valuations  and eqos truthfully over more than one task 
second  the computation of the efficient allocation and payments will have to consider a much larger
space than previously  thus  we believe it is important to show how the problem can be modelled 
implemented  and solved to demonstrate how our mechanism scales with increasing numbers of
agents and tasks  the computability aspects are dealt with in section    
the following example illustrates this more general setting 
example    after using the trust based mechanism for a few months  moviepictures com made
significant profits and expanded into several independent business units  each performing rendering
tasks or having rendering tasks performed for certain clients  now  moviepictures com would like
to find ways in which its business units can efficiently allocate tasks amongst themselves  however 
some companies have uncertainties about each others performance of the rendering tasks  for
example  while some business units  such as highdeffilms com  believe poorrender ltd  now part
of moviepictures com  is inefficient  some others  such as goodfilms com  believe it is not so bad 
having recently had a large set of animations rendered very well for a very cheap price  to cater for
these differences in opinion while maximising the overall utility  moviepictures com needs to extend
the single task trust based mechanism and implement the generalised mechanism efficiently 
in order to deal with this more complex setting  we extend our task allocation model in the next
subsection  before describing the allocation rule and payment scheme in section     and proving
the economic properties of the mechanism in section     
    the extended task allocation setting
let t                 m   denote the set of tasks which can be requested or performed  compared
to the single task before   we use the notation   i to specify that the subset of tasks   t is
performed specifically for agent i   similarly  by adding the superscript to the task   i   k
denotes a subset of tasks that agent i performs  note that there is nothing in our model that restricts
an agent to be only a task performer or requester 
a selected allocation k in this multiple task  multiple requester model then generates a matching problem that involves finding agents that will perform the tasks that are requested by some other
ii     let the set of all possible allocations be
agents  e g   k                         i i           m
denoted as k  note that not all requested tasks need to be allocated  that is  the matching in k need
not be perfect 
in the multiple task case  agents may express valuations and costs for sets of tasks as well as
subsets of these sets of tasks  for example  agent i may have vi                    and vi           
   and vi           then  if agent i gets       and   executed it gets a value of      while if
only   and   get executed and   fails  agent i still obtains a value of     similarly  agent i may
have task execution costs ci                    and ci               and ci            to capture
such inter relationships between valuations  let kij be the set of tasks within the allocation k which
have to be performed by agent j for agent i  kij could be the empty set   note that each task is
specific to a task requester  this means that if agents   and   request task m   then a task performer
   in this paper  we will not consider agents requesting the performance of multiple units of tasks  although our model
is easily extensible to this case  the explanation is much more intricate 

  

fit rust based m echanisms for robust and e fficient task a llocation

 putting in one bid for m   matched to m for agent    only performs it for agent   and not for agent
   we will abuse notation slightly and define k    ki   k i  ii where ki    ki         kii   and
k i    k i        kii    an agent i has a value  assuming all the tasks in k will be completed  and cost
for an allocation k  vi  k          and ci  k          respectively  whereby  
vi  k    vi  ki  
ci  k    ci  k i  
kh k
that
moreover  within our model  each agent i has an eqos vector   i    ij  kh   j hi
represents its belief in how successful all agents within the system are at completing the tasks kh
for agent h  thus  at the most general level  agent is type is now given by i    v i   ci    i    for any
j
e j  k j and for any eqos
given set of tasks ki
thatfij mustperform for i  for any subset of tasks k
i
i
e j will be completed by
e j fifi k j    be the trust that exactly the set of tasks k
vector   we let trj k
i

i

i

i

j  the trust can be computed as we have shown in section     by simply replacing agent   with
agent i and replacing the single task by the set of tasks t   as in the single requester case  the trust
function represents the aggregate belief that agents have about a given task performer and hence all
task requesters form the same probability
 give all agents eqos reports  about a given

 fi of success
q j  e j fifi j 
fi
e
tri ki fi ki     
task performer  finally  we let tri ki fi ki     
ji

we are now ready to present the generalised trust based mechanism 

    the allocation rule and payment scheme
in our generalised mechanism  gtbm   the task requesters first provide the centre with a list of
tasks they require to be performed  along with their valuation vector associated with each set of
tasks  whereas the task performers provide their costs for performing sets of tasks   all agents
also submit their eqos vector to the centre  thus  each agent provides the centre with reports
bi    b
b    
b         
bi   is the report profile  given this  the centre applies the
b i    so that 

vi  b
ci   
rules of the mechanism in order to find the allocation k  and net payments ri to each agent i  in
more detail 
   the centre computes the allocation according to the following 
 
b  
k 

arg max

x

k  ki  k i  ii k ii




x

e i ki
k

e i    tri
vbi  k




fi

e i fifi ki   
b b
ci  k 
k

    

thus  the centre uses the reports of the agents in order to find the allocation that maximises
the expected utility of all agents within the system 
 
b  
   the agents carry out the tasks allocated to them in the allocation vector k  

   as a result of this setup  an agent i may not want some sets of tasks to be performed or it may be unable to perform
such tasks  in such cases  we then assign a default value of   and cost of  to those sets of tasks 
   as noted before  task performers can also be task requesters at the same time  and vice versa  

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

   the centre computes the payments to the agents  conditional on completion of the tasks allocated  let  ki   be an indicator function that takes the value one if ki is the set of all the
tasks  requested by agent i from all agents  that are completed  and takes the value of zero
otherwise  the payment to agent i is as follows 

ri





x 
b     
 

ji i

x

e j k   b 
k
j









ej  b
ej   k
cj
vbj k




 
b 
bi  
k 
  bi  

    

bi      is a constant from is point of view  i e   it is computed independently
where bi  
of agent is reports  but it may depend on the reports of the other agents   that can be used to
reduce the payout that the centre has to make 
as we discussed in section        the centre faces a trade off  by reducing the value of bi   
it induces participation by a larger set of types  i e   types with low eqos   but it increases the
centres payments to agents  making the mechanism less profitable for the centre  thus  the
scale of the payments one might expect from application of the gtbm depends on whether
the centre decides to satisfy the individual rationality constraint  thus making sure that every
type wants to participate  as we shall see in section      if the centre decides to satisfy the
individual rationality constraint  then the scale of payments to agent i increases with the lower
bound on trust values that could be derived using is eqos report 
it should also be noted that the computation of the payments requires solving several optimisation problems  i e   finding the optimal allocation with and without several reports   as
the number of agents increases  the difficulty of computing payments will increase and it is
important to show how such payments can be efficiently computed  we elaborate on our
solution to this in section    before doing so  however  we detail and prove the economic
properties of our mechanism in what follows 
    economic properties
here  we provide the proofs of the incentive compatibility  and efficiency of the mechanism  we
also prove that there are values of bi which make the mechanism individually rational 
proposition    the gtbm is incentive compatible 
proof  in order to prove incentive compatibility  we will analyse agent is best response   i e   its
bi    b
bi   we first calculate the expected
b i      when all other agents report 
best report of 
vi  b
ci   
utility that an agent i will derive given the above mechanism 
   again  we place the same caveat on the notion of incentive compatibility we use here as we do in in section      i e  
dominant strategy or  ex post  nash equilibrium depending on whether an agent computes the trust functions by
using the other agents pos reports as if they were true or not  

  

fit rust based m echanisms for robust and e fficient task a llocation

by 

b and the true types are  is given
the expected utility of an agent i when the reported types are 


b   
ui  

x



b b
e i k  
k
i   i
i









bi   
bi      
e i  ki 
e i    tri k
b
vi  k
i
i

bi   
bi
 ci k  





b 
  eri  



    

where eri is the expectation of ri taken with respect to the likelihood of task completion  the
e j   being equal to one  i e   all tasks k
e j being
probability attached by i to the indicator variable  k
completed   given
fi that the set
 of tasks requested by j is kj and all agents different from i report
fi
b
e
b i   hence  we can now use the formula for the payments to obtain 
 i   is trj kj fi kj    i   




 fi
 
bi   
bi      
e j fifi kj 
e j  trj k
b
vbj k
i
i



x 

 ke j k  b i  b i 
bi  
b
eri     
j
  bi  






ji i
bi   
bi
b
cj k  
    
if we replace the expression above into the formula for ui we can observe that an agent can only
b the key point to note is that the agent computes
affect its utility with its report by changing k     
b i   
the value of the trust function using the true value of  i   rather than its reported value 
now  equation      implies that for all allocations k 




bi   
bi     
bi     ui 
    
ui  i   


x

because the efficient allocation  computed by taking into account is true type  i and the reported
bi is better than or equal to any other allocation 
types of all other agents 
given the above condition and since equation      applies to all possible realisations of   the
mechanism is incentive compatible 
proposition    the gtbm is efficient 

proof  given the incentive compatibility of the mechanism  the centre will receive truthful reports
from all the agents  as a result  it will compute the allocation according to equation       thereby
leading to an efficient outcome 
proposition    there exist values of bi    such that the gtbm is individually rational 
proof  we again begin by making the standard assumption that the agent derives ui      when not
participating in the mechanism  then  it remains to be shown that the agent derives non negative
utility from the mechanism  since the efficient allocation is chosen  and is at worst a null allocation  
the expected utility of each agent is always greater than or equal to bi    according to equation
      since bi    can be set to    the mechanism is individually rational 
note that there are possibly many other values of bi   i    besides bi      that guarantee individual
rationality 
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

speaking more generally  it can easily be seen that the gtbm mechanism of the multiple task 
multiple requester scenario is a generalisation of the gtbm mechanism with a single requester and
a single task  it is also a generalisation of the mechanism of porter et al  where they simply assume
that each agent only has an eqos about its own probability of success  moreover  in the paper by
porter et al  for example  bi is specified as follows 


x

bi     max v   k     pbi     
bi  
b
c
 k
 
j

k ki

ji i

where pbi     is the reported probability of completion of the agent assigned the task in allocation
k  and ki is the set of allocations excluding agent i 
    extracting the minimum marginal contribution

up to now  we have considered that bi   i   could be set to arbitrary values to try and reduce
the payments made by the centre to all the agents  more interestingly  it should be possible  as
in the standard vcg mechanism  to only pay an agent its marginal contribution to the system 
however  in our case  due to the interdependence of valuations  it is not as simple as comparing the
social welfare with and without a given agent in the system as is commonly done in vcg based
mechanisms  porter et al        is an obvious example of this   this is because  in our case  when
an agent is removed from the domain used to compute the efficient allocation  the remaining eqos
reports can arbitrarily change the allocation value  this could  in turn  be exploited by other agents
to improve their utility  the example in section       showing the failure of a simple extension of
porter et al s mechanism illustrates this point 
assuming that the centre wants to induce participation by all agent types  here we propose a
novel approach to extracting the marginal contribution of an agent  by taking into account eqos
reports of other agents and possible reports that the agent could make  let ki be the set of possible
allocations when agent i is excluded from society  the value of bi    can be chosen such that it is
equivalent to the social utility of the mechanism when agent i is excluded and its eqos reports are
chosen so as to minimise social utility  that is 



 fi
 
x
x
bi    
e j fifi kj    i   
e j  trj k

b i  b
cj  k      
bi  
min
max
vbj k
 i  t
 
kki
 i      
ji i e
kj kj

it is to be noted that bi is computed using the lowest trust values that could be derived using is
eqos reports 
then  the generalised payment scheme is 



 
   


x  x
 b
b      
ej  b
ej   k

k
 
c
k
v
b
ri  
j
j


 
b
ji i k
e j k  
j


 fi

 
x
x
e j fifi kj    i   
e j  trj k

b i  b
cj  k 
vbj k

min
max
 i       i  t   kki ji i e
kj kj

    

  

fit rust based m echanisms for robust and e fficient task a llocation

the point to note here is that incentive compatibility  and hence efficiency of the mechanism 
still holds given that the payment scheme is still independent of is reports  in fact  ri rewards i with
the maximum difference that agent i could make by setting all elements in  i to different values in
       i  t     
this procedure reduces the payments made by the centre  while keeping individual rationality
since the value of the efficient allocation  given incentive compatibility as proven earlier  is always
higher than or equal to the value of bi   which means that 
ui  k         



x

ji



x

e j k     
k
j





e j  trj
vj k
x






fi

e j fifi kj        cj  k     
k



min
max
 i       i  t   kki ji i e

x

kj kj





e j  trj
vj k




fi

fi
e j fi kj    i    i  cj  k     
k

it is also to be noted that the above equation implies that there is no restriction placed on the
functional form of the trust function tr for the payment scheme to work and for the properties of
the mechanism to hold  this is an improvement on previous mechanisms  see section    which had
considered trust functions that are only monotonically increasing in  i for each i 
now  the choice of bi determines whether the centre runs the mechanism at a profit or not 
hence  to understand what the scale of payments may be in the gtbm discussed in this section 
consider the following example 
example    there are n agents  i            n   each requiring that a single task be performed
for them  all agents have value   for the task to be performed for them and have zero cost for
performing all tasks  the eqos of agent h about agent is probability of succeeding
at the task for
p
i
i
i
agent j is h  kj     x     for all h  i  j           n  suppose that trj     
hi h  kj    n 

in the above example  the eqos of each agent are in the interval  x      so that x can be viewed
as the lower bound on the expected probability of success at each task  from equation      we can
compute the value of bi  
 p
 
  k     x
x

j
hi i h
bi   i    
max
i
n
ji i

note that  depending on the value of  i   bi   i   could be any value between  n    x and
 n     n      x  n  bi increases with the lower bound x on agents eqos  the actual payment
to agent i will depend on the success or failure of each task  e g   the payment is bi if all tasks
fail   from equation       we can calculate the value of the expected payment to agent i as 
 
 
x    kj  
x
h
eri     
max
 bi   i  
i
n
hi
ji i
  
 
x    j   x
i

n
ji i

   this minimisation takes place over the domain of trust values which could be other than        in the general case 

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

where   j  is the agent allocated the task for agent j under the efficient allocation rule  let ev be
the total expected value from all tasks 
 p
 
  j 
x
ii i
ev     
n
ji

note that the total expected value of all tasks is greater than the sum of the expected payments
over all agents  that is 

    j 
 
 
 p
  j 
x
x
x
i
x 
ii i

 
n
n
ji

ii

ji i

thus  the centre always profits from the mechanism  a lower bound on the difference between total
p
  i 
   n    x  n  note also that the lower
expected value and total expected payments is   ii i
bound on the centres profit from the mechanism increases with the lower bound on eqos x 
as we pointed out in the discussion of example   in section        if the centre is trying to minimise payments  it could give up on individual rationality  by increasing bi   at the cost of inducing
some agent types not to participate in the mechanism  this may be appealing when the probability
of task failure is high  in such cases  the centre may prefer to avoid paying an amount almost as large
as the total value of the tasks  on the other hand  in a number of practical applications the centre
may want to use the mechanism that induces participation by all types  described in this section 
this is certainly the case  for example  if the lower bound on eqos  i e   the lower bound on the
probability that tasks are successful  is high  moreover  our mechanism with participation by all
types is appropriate when the centre mainly seeks to maximise social welfare  consider  for example  a government that is trying to boost the economy through major public infrastructure projects 
in order to do so  it may be willing to invest in the trust based mechanism to get the best infrastructures built at the cheapest cost  moreover  the government may be willing to make a low profit in
order to ensure the survivability of the construction companies by guaranteeing them some payoff
if they participate in the mechanism  another example where a company might want to involve all
task performers would be a company trying to acquire as much information as possible about all
task performers in order to maximise the returns on its future decisions  following from our running scenario  say movepictures com needs to contract a video editing company to add computer
graphics to a movie that may become a blockbuster if the graphics are well done  in case the task
is successful  moviepictures com is likely to get many contracts in the future  it is therefore critical
that all the available information is collected from agents in order to choose the most reliable video
editing company  in this case  moviepictures com may accept a smaller short run profit by running
our mechanism with full participation  in order to guarantee that the selected agent is the best one
and that future contracts will be obtained 
to summarise  in this section we have devised a mechanism that is incentive compatible  individually rational and efficient for task allocation under uncertainty when multiple distributed reports
are used in order to judge this uncertainty  it is to be noted that we did not need two stage mechanisms  as in the work of mezzetti         because in our settings we can condition payments on the
completion of the tasks  the indicator function     captures this dependence of payments on task
completion   so far  we have just considered the economic properties of the mechanisms  but as we
argued earlier  this is only part of the picture  in the next section  we report on its implementation 
  

fit rust based m echanisms for robust and e fficient task a llocation

   implementing the generalised trust based mechanism
as shown above  the addition of trust to the basic task allocation problem not only complicates the
payment scheme  but also requires a larger number of important optimisation steps than the normal
vcg  in more detail  trust based mechanisms require that agents specify an expected value for a set
of tasks depending on the performer of such tasks which  in turn  means that the space of solutions to
be explored is significantly larger than in common task allocation problems  moreover  the payment
scheme of trust based mechanisms requires finding the efficient allocation multiple times with and
without the agents reports  with this added level of complexity  it is important to show that the
mechanisms are actually implementable and that solutions can be found for usefully sized problems
in reasonable time  
against the above background  in this section we describe the first formulation and implementation of the gtbm  in particular  in the gtbm  we tackle the main optimisation problem posed
by equation       which is then repeated several times in the payment scheme   this is commonly
referred to as the winner determination problem in combinatorial auctions  in order to solve it 
we take insight from solutions to combinatorial exchanges which often map the problem to a well
studied matching problem  kalagnanam   parkes        engel  wellman    lochner         in
so doing  we develop a novel representation of the optimisation problem by using hypergraphs to
describe the relationships between valuations  trust  and bids by task performers and then cast the
problem as a special hypergraph matching problem  given this representation  we are then able
to solve the problem using integer programming techniques through a concise formulation of the
objective function and constraints 
    representing the search space
it is important to define the search space in such a way that relationships between valuations  bids 
trust  and tasks can be clearly and concisely captured  in particular  our representation aims to map
the gtbm optimisation problem to a matching problem that has been well studied in the literature 
to do this  the representation must allow us to define the whole space of feasible task allocations 
and  subsequently  define how to select them as valid solutions to the gtbm optimisation problem 
now  to allow bidders  task performers  and askers  task requesters  to express their bids and valuations in a consistent and implementable way  we choose the xor bidding language  such a bidding
language requires that an auctioneer can accept at most one bid out of each xor bid and that each
xor bid can belong to only one agent  we choose this particular bidding language because it has
been shown that any valuation can be expressed using it  nisan           an example of an xor
bid in our context would be  ci          xor ci          xor ci               which means that agent
i would only go for one of these three bids over tasks       and    ci could also be replaced by
vi for task requesters   in terms of our running example  such a bid would express poorrender
ltds cost for performing a sound editing task  i e        a movie production task  i e        or both in
combination  i e           
   it is already known that computing the efficient allocation and payments for vcg mechanisms is np hard  sandholm 
suri  gilpin    levine         therefore  finding efficient solutions to vcg mechanisms is already a significant
challenge in its own right 
    other bidding languages  such as those describing atomic or or bids  as in nisan        could equally well be used
in our model and would only require minor changes to the constraints that we need to apply 

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings


  
v
h


  

  
 



 

 

fi
ff

 

fi
 

 

fi
 

 

 

   
a

 
 

 

h


  
c
   

     
 
     
 


 
 

    


  

 


  

figure    graphical representation of the gtbm search space  nodes of the same colour represent valuation
or cost nodes that belong to the same agent  here nodes with v  belong to agent   and those with c  belong
to agent     edges of the same colour either originate from the same node or end up at the same node 

to build the overall representation of the problem  we first focus on representing expected valuations and costs as well as their relationships  these are depicted in figure    in more detail  we
specify three types of nodes      valuations  along the v column       bids  under the c column  
and     task per bidder nodes  under the a column   each node vi     in the v column stands for a
valuation submitted by agent i over a set of tasks   t   each node cj     in the c column stands
j 
for a bid issued by agent j over tasks   t   each element of a represents the allocation m
of
a single task m  t to task performer  bidder  j by a task requester yet to be determined  represented by a dot   in other words  the elements in a represent patterns for single task allocations 
we term such elements task per bidder nodes 
note that it is possible that different valuations come from the same requester  if so they are
labelled by the same subscript  moreover  since we have opted for an xor bidding language 
valuations belonging to the very same requester are mutually exclusive 
  

fit rust based m echanisms for robust and e fficient task a llocation

      d efining r elationships

between

valuations   tasks  

and

b ids

j 
in a to a node vi       m        in v
given the nodes defined by a  v  and c  by relating a node m
we define the assignment of task m by i to j through the specific valuation vi       m         similarly 
j 
in a to a node cj       m        in c we define the assignment of the task to the
by relating a node m
j 
j 
specific bid cj       m        by agent j  therefore  a triple  v  m
  c  where v  v  m
 a  c  c
fully characterises an allocation for task m   namely a single task allocation  hence  as can be seen
in figure    we define two types of relationships  between valuations and task per bidder nodes
 noted by edges e    e          and between bids and task per bidder nodes  noted by edges e    e           
using these relationships  a valuation can then be related to a set of task per bidder nodes if and
only if these fully cover the performance of the task s  in the valuation  for instance  we can relate
v           to nodes      agent   performs task     and      agent   performs task     because
they guarantee the performance of tasks   and     similar to valuation relationships  each node c
is only related to the set of task per bidder nodes in a into which each bid splits  thus  in figure   
bid c       is only related to       whereas bid c           is related to nodes     and      
thus  we can identify the task performers for each task in a given valuation  this is critical since
the gtbm  contrary to common task allocation mechanisms  such as vcg or mth price auctions  
requires that we identify exactly who performs a task in order to determine the pos of that task  by
virtue of the requesters trust in the performer  and hence the expected value of the task 
as can be seen  our representation allows us to capture all tasks and performers of such tasks
since each valuation node in v can be potentially related to multiple nodes in a  and  likewise  each
bid in the c column can be potentially related to multiple nodes in a  to capture these related relationships precisely  we define special edges that can connect several nodes  e g   the ones depicted as
e    e       e    e       in figure     such edges are termed hyperedges because they combine a number
of singleton edges  hence  figure   can be best described as a hypergraph  berge         in order
to precisely define the matching problem that the gtbm poses  we elaborate on the formalism of
hypergraphs since this will help in concisely expressing the problem later on  more specifically  the
formal notion of hypergraphs  as introduced in the paper by berge         is 

definition    hypergraph  let x    x    x            xn   be a finite set of n elements  and let e  
 ej  j  j  be a family of subsets of x where j                the family e is said to be a hypergraph
on x if 
   ej      j  j 
   jj ej   x 
the pair h    x  e  is called a hypergraph  the elements x    x            xn are called the vertices
and the sets e    e            ej are called the hyperedges 
we say that a hypergraph is weighted if we associate to each hyperedge e  e a real number 
w e   called the weight of e  this is used to give more or less importance to some edges 
from the formal definition of hypergraphs  we observe that figure   results from the overlapping of two separate hypergraphs   i  the valuation hypergraph that occurs from linking valuations
    figure   only depicts a sample of all possible relationships for ease of illustration 

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

to task per bidder nodes  and  ii  the bid hypergraph that occurs from linking each bid to the corresponding task per bidder nodes  in what follows  we formally define both hypergraphs from valuations and bids so that later on we can structurally characterise the notions of feasible and optimal
allocations 
      t he valuation h ypergraph
the valuation hypergraph highlights the main difference between the gtbm and the common combinatorial exchanges  e g   those based on traditional vcg or mth  price auctions   in particular  in
the gtbm valuations need to take into account the trust of the task requester in the task performer
while  in normal combinatorial exchanges  task requesters are indifferent to task performers  this
means the weight of each hyperedge in a valuation hypergraph is dependent on trust and a large
number of edges need to be generated  one per task performer  which is not the case in normal
combinatorial exchanges 
to define the valuation hypergraph  we need to define hyperedges that emanate from each node
in v to one or more nodes in a  to this end  let v    vi            t   i  i  and c    cj       
   t   j  i  be the sets of all valuations and all bids respectively  let  j       t  
   t   cj         and       be the set of tasks over which agent j submits bids  hence 
a    kj   k   j    j  i  cj      c  is the set containing all the tasks bid by each bidder   
furthermore  we need to define some auxiliary sets as follows  given a valuation over a set of
tasks    a set of nodes a  a fulfils it if and only if 
 

 kj       and        a 

kj  a

for instance  the set of nodes a                fulfils any valuation over           hence  the
subsets of a that fulfil a valuation over a set of tasks  are expressed using a which is defined as 
 
a    a  a  
 kj       and        a  
kj  a

for instance  considering the example in figure   
a                                                    
a                                      
given the above definitions  we can now define the set of all hyperedges connected to a valuation
vi      v as 
eiv       aa   vi       a 
for instance  from figure   
e v             e    e    e    and e v         e    e    
where e     v                         e     v                                 and so on 
    recall that since the mechanism has been proven to be incentive compatible we can use the agents true valuations
and costs instead of their reported counterparts 

  

fit rust based m echanisms for robust and e fficient task a llocation

the set of all hyperedges containing valuations of the very same agent i is defined as 
 
eiv  
eiv    
 t
then  the set of hyperedges connecting nodes in v to nodes in a is defined as 
 
ev  
eiv
ii

given this  we define the valuation hypergraph as a pair 
hv    v  a  e v  
thus  each hyperedge in hv consists of a single valuation vertex corresponding to an element in v
along with a complete task allocation for the valued tasks out of the task per bidder nodes in a 
the valuation hypergraph hv partly defines the space within which a solution needs to be found 
however  in order to define the quality of the solution found  it is important to define the weight
attached to each hyperedge of the hypergraph hv   the weight of a hyperedge is actually equal to
the expected value of the allocation of the tasks to a set of task performers  bidders   consider 
for instance  valuation v            all the possible matchings that fulfil it are represented by all the
pairs               for example  the hyperedge e  involving the pairing              denotes that
agent   performs task   for agent   and agent   performs task   for agent    the expected valuation
associated to this allocation depends on the pos of agents   and   when performing tasks   and  
respectively 
in this case  the expected valuation associated to e  is assessed as 
v                  v            p          p         
v        p              p          
v           

p         



    

p        

where p is a function that returns the pos of the agent that is assigned a given task  computed using
confidence  reputation  or trust   notice that the value     pi  kij    represents the probability of
agent i failing to perform task k for agent j  since no requests are submitted for   and   alone 
v       v          thus  the expected valuation associated to the particular allocation represented
by arc e  becomes v                  v            p          p          with a similar argument 
we obtain v                  v            p          p            v                 corresponding
to hyperedge e   
generalising  given a hyperedge e  e v with valuation vi      we can readily build an allocation
for the tasks in  from the elements in e and vi      if p is a function that returns the pos  be it
confidence  reputation  or trust  of a given task performer from each requesters point of view  then
we can compute the expected valuation of the allocation defined by hyperedge e as follows 


x 
y
y


v i      
pj  lji  
   pj  wji   
    
vi    
  
lj  e l  
lj  e w    
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

in other words  given a hyperedge e  e v   its weight is assessed using equation      which is
equivalent to the expected value computed in equation       i e   the sum of expected values over
all allocations from agent i   now  given that each edge of the valuation hypergraph is assigned a
weight  hv is termed a weighted hypergraph 
      t he b id h ypergraph
to define the bid hypergraph we need to determine the hyperedges that connect bids to task perbidder nodes  in more detail  given a bid cj      c  we relate it to the task per bidder nodes in a
by constructing hyperedge ejc        cj        kj   k      this hyperedge is assigned a weight
which is equal to the cost of cj      then the set of all hyperedges containing all the bids of agent i
can be defined as 
 
eic  
eci    
 t
given this  the set of all hyperedges connecting nodes in c to nodes in a can be defined as 
 
ec  
eic
ii

finally  we define the bid hypergraph as a pair 
hc    a  c  e c  
in other words  each hyperedge in hc consists of a single bid vertex corresponding to an element in
c along with the corresponding task per bidder nodes in a  notice that our definitions of valuation
and bid hypergraphs ensure that each hyperedge in h v contains a single valuation from v and each
hyperedge in h c contains a single bid from c 
      d efining the m atching p roblem for the gtbm
having defined the valuation and bid hypergraphs  we can now structurally characterise the notions
of feasible and optimal allocations  these are needed to determine the computational complexity of
the problem and define the objective function in particular   for this purpose  we must firstly recall
some notions of hypergraph theory  in a hypergraph  two hyperedges are said to be adjacent if their
intersection is not empty  otherwise they are said to be disjoint  for a hypergraph h    x  e   a
family e   e is defined to be a matching if the hyperedges of e  are pairwise disjoint  with respect
to a given matching e    a vertex xi is said to be matched or covered if there is a hyperedge in e 
incident to xi   if a vertex is not matched  it is said to be unmatched or exposed  a matching that
leaves no vertices exposed is said to be complete 
based on the definitions above  we can characterise feasible allocations in the gtbm as follows 
first  we must find a matching for the valuation hypergraph that is not necessarily complete  some
valuations may remain exposed   second  we must find another matching for the bid hypergraph
that is not necessarily complete either  the two matchings must be related in the following manner 
the task per bidder nodes in both matchings should be the same  in other words  given a task perbidder node  it must be related to some valuation node and to some bid node  or else be excluded
from both matchings  in this way  valuations and bids are linked to create single task allocations 
for instance  in figure    if e  belongs to the matching for the valuation hypergraph  then e  must
  

fit rust based m echanisms for robust and e fficient task a llocation

be part of the matching for the bid hypergraph to ensure that there is a bid for     and that either
e    e    or e  are part of the matching for the bid hypergraph to ensure that there is a bid for      
more formally 




definition     feasible allocation  we say that a pair  e v   e c   defines a feasible allocation iff 


 e v is a matching for hv  


 e c is a matching for hc  




   a    is matched by e v      is matched by e c   




given a feasible allocation  e v   e c   as defined above  it is straightforward to assess the expected utility of all agents within the system as follows 
x

ee v

w e  



x

w e  


e e c

since the weights of the hyperedges in the valuation hypergraph stand for expected valuations and
the weights of the hyperedges in the bid hypergraph stand for costs  solving equation      in the
gtbm amounts to finding the feasible allocation that maximises the expected utility of all agents
within the system  therefore  the following definition naturally follows 
definition     gtbm task allocation problem the problem of assessing the task allocation that
maximises the expected utility of all agents within the system amounts to solving 
arg max
 e


v


 e c  

x

ee

wv  e  

x

wc  e  

    


e e c

v



where  e v   e c   stands for a feasible allocation 
having defined the matching problem for the gtbm  we next describe our solution to this
problem using integer programming techniques that are commonly used to solve such problems
 cerquides  endriss  giovannucci    rodrguez aguilar          
    an integer programming solution
in this section we show how to map the problem posed by equation      into an integer program
 papadimitriou   steiglitz        so that it can be efficiently implemented and solved  given this
translation  the resulting program can be solved by powerful commercial solvers such as ilog
cplex   or lingo   
    other special purpose algorithms  e g   using dynamic programming or search trees  could also be designed to solve
this combinatorial problem  however  to understand the magnitude of the problem and to compare the difficulty of
solving this problem against other similar problems  we believe it is better to first attempt to find the solution using
standard techniques such as ip 
    http   www ilog com
    http   www lindo com

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

      o bjective f unction

and

s ide c onstraints

the translation of equation      into an ip is reasonably straightforward given our representation 
thus  solving the gtbm task allocation problem amounts to maximising the following objective
function 
x

xe  wv  e  

x

ye  wc  e  

    

e e c

ee v

where xe         is a binary decision variable representing whether the valuation in hyperedge
e is selected or not  and ye         is a binary decision variable representing whether the bid in
hyperedge e is selected or not  thus  xe is a decision variable that selects a given valuation with a
given task bidder matching  and ye selects a given bid 
however  some side constraints must be fulfilled in order to obtain a valid solution  first  the
semantics of the bidding language must be satisfied  second  if a hyperedge containing a set of taskper bidder nodes in a is selected  we must ensure that the bids covering such nodes are selected too 
moreover  as we employ the xor bidding language  the auctioneer  the centre in our case  can
only select at most one bid per bidder and at most one valuation per asker  thus  as for bidders  this
constraint translates into 
x
ye    i  i
    
e eic

for instance  in figure   this constraint ensures the auctioneer selects one hyperedge out of e    e   
and e    since they all belong to agent    they all come from nodes labelled with the same subscript
c       
for the valuations  the xor constraints involving them are collected in the following expression 
x
xe    i  i
    
eeiv

for instance  in figure   this constraint forces the auctioneer to select one hyperedge out of e    e   
e    e    and e  since they all belong to agent    they all come from nodes labelled with the same
subscript v       
if a valuation hyperedge e  e v is selected  the set of task per bidder nodes in a connected
to e must be performed by the corresponding bidder agent  for instance  in figure    if hyperedge
e  is selected  the task per bidder nodes     and     must be covered by some bid of agent   
in this case  bid c           is the one covering those tasks  thus  if we select hyperedge e  we are
forced to select bid c           by selecting hyperedge e    thus  in terms of hyperedges  we must
ensure that the number of valuation hyperarcs containing a given task per bidder node is less than
or equal to the number of bid hyperarcs containing it  graphically  this means that the number of
incident valuation hyperedges in a given node a  a must be less than the number of incident bid
hyperedges in a 
x

ee v  kj  e

xe 

x

ye

kj   a

    

e e c  kj  e

in case of no free disposal  i e   if we do not allow agents to execute tasks without them being asked
for  we simply have to replace  with    to summarise  solving the gtbm task allocation problem
  

fit rust based m echanisms for robust and e fficient task a llocation

amounts to maximising the objective function defined by expression      subject to the constraints
in expressions             and       next  we determine the complexity results for this problem 
      c omplexity r esults
having represented the gtbm task allocation problem and defined the corresponding ip formulation  we analyse its computational complexity in order to show the difficulty in solving the gtbm 
we also identify the main parameters that affect the computational costs of finding the optimal allocation  these parameters should then allow us to determine in which settings the gtbm can be
practically used 
proposition    the gtbm task allocation problem is n p complete and cannot be approximated
to a ratio n  in polynomial time unless p   zpp  where n is the total number of bids and
valuations 
proof  notice that our optimisation model  as formalised by equation       naturally translates to a
combinatorial exchange  kalagnanam  davenport    lee         this translation can be achieved
using our representation by taking the goods  in a combinatorial exchange  to be the dummy tasks
  t   the bids the elements in c  and the asks the weights of the hyperedges in hv   thus  while
bids remain the same in the exchange  the number of valuations may significantly increase  the
reason being that the introduction of trust in our theoretical model makes the initial valuations  asks  
the elements in v  allocation dependent  hence  every single valuation in v causes several asks to
be originated for the exchange when considering the bidder to which each task may be allocated
 see examples in section         as shown by sandholm et al          the decision problem for a
binary single unit combinatorial exchange winner determination problem is n p complete and the
optimisation problem cannot be approximated to a ratio n  in polynomial time unless p   zpp 
where n is the number of bids  therefore  the optimisation problem is n p hard  and so it is in
gtbm 
from the above proof  it can be understood that the search space in the gtbm task allocation
problem is significantly larger than in traditional combinatorial exchanges because of the dependency of valuations on the bidders performing tasks  in what follows  we provide a formula that
allows us to calculate exactly how big this search space is  this allows us to determine whether
the instance to be solved can actually be handled by the solver  which will have its own limits on
memory requirements and computation time  
in more detail  say that ak is the subset of a containing the task per bidder nodes referring
to the same tasks  more formally  ak    kj   a   j  i   from the example in figure   
a                        thus  the expression to assess the number of feasible allocations is 
 e v    

x x

y

 ak  

    

ii vi        k 

observe that the number of possible allocations can be computed as the cardinality of e v  i e   the
number of valuation hyperarcs  since it exactly determines the number of ways the valuations can
be satisfied by the provided bids  the total number of decision variables of the integer program is
thus  e v      e c    since the number of expected valuations is several times larger than the number of
bids  we expect the number of decision variables associated to bid hyperedges to be much less than
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

the number of valuation hyperedges  hence  assuming that  e c     e v    the number of decision
variables will be of the order of  e v   
in order to understand the implications of these parameters  consider the case in which all task
performers bid over all tasks and all requesters submit a single valuation over all tasks  specifically 
consider a scenario with    task performers     requesters  and   tasks  given that in this case
 ak       the number of allocations is  ev                         in reality  agents may not be
able to submit bids and asks over all tasks and this would result in a significantly lower number of
allocations  given the possible matchings   hence  to see whether such instances can be practically
solved  in appendix a  we report the running times of the solver  showing that instances with less
than        variables can be comfortably solved within    seconds  in the worst case   when taken
together  our empirical results and our formula to compute the size of the input  i e   equation    
allow us to affirm that  even if the computational cost associated to the gtbm has the potential to
be rather high  our solution can handle small and medium sized problems in reasonable time  see
table     however  as can be seen  the time to complete grows exponentially with the number of
set
 
 
 

tasks
 
 
  

task requesters
  
  
  

task performers
  
  
  

worst case running time
   s
   mins
  days

table    average running times for different numbers of tasks and agents  taken over     sample runs for set
      sample runs for sets   and    

tasks  during our experimental analysis  we also found that the impact of increasing the number of
task performers and task requesters was not as significant as increasing the number of tasks  this
can be explained by the fact that  given our setup  a larger number of tasks allows significantly more
matchings between bids and asks than a larger number of bids and asks  hence  many more task
requesters and performers can be accommodated for small numbers of tasks  it should also be noted
that we expect these worst case results to occur fairly rarely on average  much less than half of the
instances generated from the same parameters   as shown in figure   in appendix a 
having described the complete picture of the gtbm and its implementation  we next discuss
some important issues that may arise when trying to use a gtbm for task allocation 

   discussion
in this paper we have developed task allocation mechanisms that operate effectively when agents
cannot reliably complete tasks assigned to them  specifically  we have designed a novel generalised
trust based mechanism that is efficient and individually rational  this mechanism deals with the
case where task requesters form their opinions about task performers using reports from their environment and their own direct interactions with the performers  in addition to studying the economic
properties of the allocation mechanisms  we provided the optimisation model that generates the solutions that guarantee the efficiency of our mechanism  this optimisation model is the first solver
for trust based mechanisms  and other mechanisms in which the value of an allocation depends on
the performer of the allocation  and is based on integer programming  as a result  we have shown
that the input explodes combinatorially due to the huge number of possible allocations that must
be enumerated  nevertheless  while the computational cost associated to the gtbm is shown to be
  

fit rust based m echanisms for robust and e fficient task a llocation

rather high  given our implementation  we are still able to manage small to medium sized problems
in reasonable time 
speaking more generally  our work on trust based mechanisms has a number of broader implications  first  the gtbm shows how to explicitly blend work on trust models with work on
mechanism design  since the mechanism guarantees that certain properties hold for task allocation
problems  it can be used as a new  well founded testbed within which trust models can be evaluated  up to now  trust models have mainly been tested with randomly generated scenarios and
interactions that obey somewhat ad hoc market rules such as those used in the art testbed  fullam 
klos  muller  sabater  topol  barber  rosenschein    vercouter         second  our work is the
first single stage interdependent valuations mechanism that is efficient and individually rational  as
opposed to mezzettis two stage mechanism   this has been made achievable in the settings we
consider by capturing the interdependence between types through the trust function and making the
payments to the agents contingent on the actual execution of tasks  another novelty of our approach
is that we are able to extract the  maximum  marginal contribution of an agent despite the valuations being interdependent  as we have shown in section       third  our implementation of gtbm
highlights the importance of considering the computational aspects of any new mechanism  since
these determine whether the mechanism is implementable for realistic scenarios and can indeed
bring about its claimed benefits  our work is a strong statement in this direction since we provide
the complete picture of the problem  starting from its representation  through its implementation
and sample results  to its complexity analysis 
in practical terms  the gtbm is a step towards building robust multi agent systems for uncertain
environments  in such environments  it is important to aggregate the agents preferences  while
taking into account the uncertainty in order to ensure that the solutions chosen result in the best
possible outcome for the whole system  prior to the gtbm  it was not possible to come up with
an efficient solution that would maximise this expected utility  moreover  the fact that agents can
express their perception of the task performers pos is a new way of building more expressive
interactions between buyers and sellers of services  sandholm         we believe that the more
such perceptions are expressed  the better is the ensuing matching between buyers and sellers and
our results are proof of the gain in efficiency this better matching brings about  see sections       
       and      
by introducing gtbm as a new class of mechanisms  this work lays the foundations for several
areas of inquiry  to this end  we outline some of the main areas below 
 budget balance  an important economic property of mechanisms in some contexts is budget
balance    however  as mentioned in section        we have designed our tbms without
considering budget balance  in fact  the gtbm is not budget balanced similar to the vcg and
porter et al s mechanism  now  one possible way of overcoming this problem is to sacrifice
either efficiency or individual rationality  in fact  the dagva mechanism is a counterpart of
the vcg which does indeed sacrifice individual rationality for budget balance  see section
    moreover  parkes  kalagnanam  and eso        develop mechanisms where a number
of budget balancing schemes are proposed and near incentive compatibility is attained by
making the payments by the agents as close as possible to those of the vcg ones  their
    if a mechanism is budget balanced  it computes transfers in each allocation such that the overall transfer in the system
is zero  mascolellp
et al          thus  in a budget balanced mechanism  for each allocation k and associated transfer
vector r  we have ri  r ri     

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

most effective scheme  the threshold rule  results in a low loss of incentive compatibility
and it has a relatively high efficiency  around       such budget balance may be useful in
situations where the centre cannot run the risk of incurring a loss in generating the efficient
outcome for the set of agents in the system  for example  moviepictures com may not find
it worth injecting money into the system to find the efficient outcome if all its subunits are
all nearly equally competitive  both in price and pos   instead moviepictures com might
prefer a mechanism that generates a near efficient outcome by increasing bi as discussed in
section      by doing this  the set of agents that participate might be reduced because it is
not individually rational for all of them to participate in the mechanism  but  nevertheless 
moviepictures com may obtain a better outcome  in the future  we will study such trade offs
between the efficiency achieved in the system against the profit made by the centre 
 trust in task requesters  one other potential criticism of mechanisms such as ours is that
the task requesters  and the centre  must be trusted to reveal the observed execution of the task
 mezzetti         however  in our setting  task requesters have a strong incentive to reveal
their observations  in case these are not publicly visible  since they would prefer their chosen
task performer to be available the next time the mechanism is run  to this end  they must
ensure that the task performer does not go bankrupt  as noted in equations      and       the
task performer would have to pay a significant amount to the centre in case it is reported to
fail at its task  hence  the task requester is better off revealing a successful execution if the
task performer is indeed successful 
another issue with the trust function used is that weights given to each agents eqos report
may be uncertain  thus  in this case  agents may have to learn these weights over multiple
interactions  given this  it is important to develop learning and search techniques that will
be able to deal with the large number of possible weights that could be used in these trust
functions  these techniques will have to take into account the fact that agents may lose out
significantly while exploring the search space 
 iterative mechanisms  the gtbm is a one shot mechanism in which the allocation and
the payments are calculated given the type of the agents  v  c    using their trust models 
however  in some cases the participants may be engaged in repeated interactions that can be
exploited by their trust models in order to build accurate trust values of their counterparts 
in such situations  the introduction of multiple rounds can compromise the properties of the
mechanism by allowing for a greater range of strategies  e g   cornering the market by consistently offering low prices in initial rounds or accepting losses in initial rounds by providing
false and damaging information about competitors   however  the explosion in the strategy
space also implies that agents might not be able to compute their optimal strategy due to the
intractability of such a process  now  one way of solving this problem is to constrain the
strategies of the agents to be myopic  i e   best response to the current round  as shown by
parkes and ungar        using proxy bidding  another is to allow the agents to learn the trust
models without participating in the allocation problem  then  once the agents have an accurate representation of the trust functions and pos values  the mechanism can be implemented
as a one shot encounter  note that this problem arises in any one shot mechanism which is
implemented in an iterative context and is not solely in the realm of the gtbm 
  

fit rust based m echanisms for robust and e fficient task a llocation

 computational cost  as discussed in section    the algorithms we developed to compute
the efficient allocation have to be run multiple times to compute the individual payments to
the agents for tbms  hence  the time needed to compute the allocation and pay the agents
may be impractical if the agents have a very limited time to find a solution  put forward a large
number of bids  or ask for a large number of tasks to be performed  hence  it is important
that either less complex mechanisms such as those described by nisan and ronen       
or approximate  and computationally less expensive  algorithms be developed to solve such
problems  archer  papadimitriou  talwar    tardos         this will require more work in
developing local approximation algorithms and the approximate mechanisms that preserve
some of the properties we seek  in this vein  this paper provides a point of departure for these
future mechanisms since it provides the efficient mechanisms against which the approximate
ones can be compared 
acknowledgments
we thank the anonymous reviewers for their highly valuable comments  they have allowed us to
improve upon the previous version of this paper  which had a more restrictive mechanism  and
also helped rework the proofs  we are grateful to juuso valimaki for initial comments on the
mechanism  and ioannis vetsikas  enrico gerding  and archie chapman for checking the proofs and
discussing the ideas  juan a  rodriguez aguilar thanks iea  tin           c        agreement
technologies  consolider csd           ingenio       and the jose castillejo programme
 jc            of the spanish ministry of science and innovation  andrea giovannucci is funded
by a juan de la cierva contract  jci             and by the eu funded synthetic forager project
 ict        sf   claudio mezzetti thanks the fondazione cassa di risparmio di padova e rovigo
for support  the research in this paper was also undertaken as part of the aladdin  autonomous
learning agents for decentralised data and information systems  project and is jointly funded
by a bae systems and epsrc  engineering and physical research council  strategic partnership
 ep c          

appendix a  analysing the performance of the ip solution
in this section we analyse the computational performance of the integer programming solution we
detailed in section   in order to gauge the sizes of problems that can be solved in reasonable time  to
this end  it is important to recall that  as was shown in section    the number of input variables to the
optimization problem is nearly equal to the number of valuation hyperedges  ev    since  ec     ev   
given this  we can assume that the performance of the solver is directly related to the number of
possible allocations approximated as  ev   
therefore  our test set is composed of several instances of the gtbm task allocation problem
characterised by the number of possible allocations  in more detail  to produce such allocations  bids
and valuations are generated so that the number of bids submitted by a single bidder and the number
of valuations submitted by a single requester follow a geometric distribution with the p parameter
set to       milton   arnold         in order to randomly generate relatively large numbers of
bids asks per agent     a medium sized problem is set as follows  the number of negotiated tasks
is set to    the number of task performers is set to    and the number of task requesters is set to    
    setting p higher would result in fewer bids asks per agent 

  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

the average number of generated valuations for each instance is    and the average number of bids
is     finally  the number of runs of the experiments is      our experiments were performed on a
xeon dual processor machine with  ghz cpus    gb ram and the commercial software employed
to solve the integer program is ilog cplex     

  

clock time to find optimal solution  seconds 

  

  

  

  

  

 

 

 

   

   

   

   
 
   
no  of possible allocations

   

   

   

 
 

x   

figure    performance of the ip solution 

the results are shown in figure    specifically  the x axis represents the number of allocations
of a given problem instance and the y axis represents the time in seconds elapsed in solving the
corresponding problem instance  notice that the dependence of the difficulty of the problem on the
number of allocations is quite clear  moreover  as can be seen  it is possible to solve a problem with
less than        variables within    seconds  it is important to note that the performance of the
solver used is critical in this case and future advancements to mixed integer programming  mip 
solvers and cpu clock speeds can only improve our results 
given these results and since we provide a general formula  see equation       to compute
a priori the number of generated allocations  it is possible to estimate the feasibility of a general
problem before performing it  this means that the system designer can ask task requesters and
performers to constrain the number of tasks they ask for or the number of bids they issue to come
up with an input that can be solved by the program in a reasonable time  it will be more important 
however  to design special purpose algorithms that can deal with larger inputs and this is left as
future work 

references
archer  a   papadimitriou  c   talwar  k     tardos  e          an approximate truthful mechanism
for combinatorial auctions with single parameter agent  internet mathematics               
  

fit rust based m echanisms for robust and e fficient task a llocation

arrow  k  j          the property rights doctrine and demand revelation under incomplete information  in boskin  m   ed    economics and human welfare  academic press 
berge  c          graphs and hypergraphs  north holland publishing company 
byde  a          a comparison between mechanisms for sequential compute resource auctions  in
proceedings of the fifth international joint conference on autonomous agents and multiagent systems  aamas      pp            acm press 
cerquides  j   endriss  u   giovannucci  a     rodrguez aguilar  j  a          bidding languages
and winner determination for mixed multi unit combinatorial auctions  in proceedings of the
twentieth international joint conference on artificial intelligence  pp           
dasgupta  p          trust as a commodity  in gambetta  d   ed    trust  making and breaking
cooperative relations  pp        blackwell 
dash  r  k   parkes  d  c     jennings  n  r          computational mechanism design  a call to
arms  ieee intelligent systems              
dash  r  k   ramchurn  s  d     jennings  n  r          trust based mechanism design  in
proceedings of the third international joint conference on autonomous agents and multiagent systems  aamas      vol     pp         
daspremont  c     gerard varet  l  a          incentives and incomplete information  journal of
public economics              
dellarocas  c          goodwill hunting  an economically efficient online feedback mechanism
for environments with variable product quality  in proceedings of the  aamas     workshop
on agent mediated electronic commerce  pp         
engel  y   wellman  m  p     lochner  k          bid expressiveness and clearing algorithms in
multi attribute double auctions  in proceedings of the seventh acm conference on electronic
commerce  ec      pp         
fullam  k   klos  t   muller  g   sabater  j   topol  z   barber  k  s   rosenschein  j     vercouter 
l          the agent reputation and trust  art  testbed architecture  in proceedings of the
 aamas     workshop on trust in agent societies  pp       
hershberger  j     suri  s          vickrey pricing in network routing  fast payment computation 
in proceedings of the forty second ieee symposium on foundations of computer science 
pp         
jehiel  p     moldovanu  b          efficient design with interdependent valuations  econometrica 
              
jennings  n  r   faratin  p   norman  t  j   obrien  p   odgers  b     alty  j  l          implementing a business process management system using adept  a real world case study  international journal of applied artificial intelligence                
jurca  r     faltings  b          an incentive compatible reputation mechanism  in proceedings of
the ieee conference on e commerce  cec      pp         
jurca  r     faltings  b          minimum payments that reward honest reputation feedback  in
proceedings of the seventh acm conference on electronic commerce  ec      pp         
  

fir amchurn   m ezzetti   g iovannucci   rodriguez   dash   and j ennings

jurca  r     faltings  b          obtaining reliable feedback for sanctioning reputation mechanisms 
journal of artificial intelligence research  jair              
kalagnanam  j   davenport  a  j     lee  h  s          computational aspects of clearing continuous double auctions with assignment constraints and indivisible demand  tech  rep   ibm
research rc             
kalagnanam  j     parkes  d  c          auctions  bidding and exchange design  in simchi levi 
d   wu  s  d     shen  m   eds    handbook of quantitative supply chain analysis  modeling
in the e business era  international series in operations research and management science 
chap     kluwer 
krishna  v          auction theory  academic press 
mascolell  a   whinston  m     green  j          microeconomic theory  oxford university press 
mezzetti  c          mechanism design with interdependent valuations  efficiency  econometrica 
                
mezzetti  c          mechanism design with interdependent valuations  surplus extraction  economic theory                
miller  n   resnick  p     zeckhauser  r          eliciting honest feedback  the peer prediction
method  management science                  
milton  j     arnold  j  c          introduction to probability and statistics  principles and applications for engineering and the computing sciences  mcgraw hill inc 
nisan  n          bidding languages for combinatorial auctions  in cramton  p   shoham  y    
steinberg  r   eds    combinatorial auctions  pp          mit press 
nisan  n     ronen  a          computationally feasible vcg mechanisms  journal of artificial
intelligence research  jair            
papadimitriou  c  h     steiglitz  k          combinatorial optimization  algorithms and complexity  prentice hall  inc   upper saddle river  nj  usa 
parkes  d  c   kalagnanam  j  r     eso  m          achieving budget balance with vickreybased payment schemes in exchanges  in proceedings of seventeenth international joint
conference on artificial intelligence  ijcai      pp           
parkes  d  c     ungar  l  h          preventing strategic manipulation in iterative auctions  proxy
agents and price adjustment  in proceedings of the seventeenth national conference on artificial intelligence and twelfth conference on innovative applications of artificial intelligence  pp       
porter  r   ronen  a   shoham  y     tennenholtz  m          fault tolerant mechanism design 
artificial intelligence                    
ramchurn  s  d   huynh  d     jennings  n  r          trust in multi agent systems  the knowledge engineering review          
sandholm  t          expressive commerce and its application to sourcing  how we conducted   
billion of generalized combinatorial auctions  ai magazine              
  

fit rust based m echanisms for robust and e fficient task a llocation

sandholm  t   suri  s   gilpin  a     levine  d          winner determination in combinatorial
auction generalizations  in proceedings of the first international joint conference on autonomous agents and multi agent systems  aamas      pp       
sandholm  t  w          an implementation of the contract net protocol based on marginal cost
calculations  in proceedings of the twelfth international workshop on distributed artificial
intelligence  pp         
teacy  w  t  l   patel  j   jennings  n  r     luck  m          travos  trust and reputation in
the context of inaccurate information sources  autonomous agents and multi agent systems 
              
walsh  w     wellman  m          a market protocol for decentralized task allocation  in proceedings of the third international conference on multi agent systems  icmas     

  

fi