journal artificial intelligence research                  

submitted        published      

complexity circumscription description logic
piero a  bonatti

bonatti na infn it

section computer science  department physics
university naples federico ii  italy

carsten lutz

clu informatik uni bremen de

department mathematics computer science
university bremen  germany

frank wolter

wolter liverpool ac uk

department computer science
university liverpool  uk

abstract
fragments first order logic  description logics  dls  provide nonmonotonic
features defeasible inheritance default rules  since many applications would
benefit availability features  several families nonmonotonic dls
developed mostly based default logic autoepistemic logic 
paper  consider circumscription interesting alternative approach nonmonotonic
dls that  particular  supports defeasible inheritance natural way  study dls
extended circumscription different language restrictions different
constraints sets minimized  fixed  varying predicates  pinpoint exact
computational complexity reasoning dls ranging alc alcio alcqo 
minimized fixed predicates include concept names role names 
reasoning complete nexpnp   becomes complete npnexp number
minimized fixed predicates bounded constant  roles minimized
fixed  complexity ranges nexpnp undecidability 

   introduction
early knowledge representation  kr  formalisms semantic networks frames
included wealth features order provide much expressive power possible
 quillian        minsky         particular  formalisms usually admitted structured representation classes objects similar modern description logics  dls  
mechanisms defeasible inheritance  default rules  features nowadays studied area nonmonotonic logics  nmls   kr theory developed
further  all embracing approaches largely given favour specialized
ones due unfavourable computational properties problems semantics 
process caused dls nmls develop two independent subfields  consequently 
modern description logics shiq lack expressive power represent defeasible
inheritance nonmonotonic features  horrocks  sattler    tobies        
despite  or due to  development  continuous interest
 re integration nonmonotonic features description logics  recent years  advent several new applications dls increased interest even further  briefly
discuss two them  first  dls become popular tool formalization biomedc
    
ai access foundation  rights reserved 

fibonatti  lutz    wolter

ical ontologies galen  rector   horrocks        snomed  cote  rothwell 
palotay  beckett    brochu         argued example rector        stevens
et al          important ontologies represent exceptions form
humans  heart usually located left hand side body  humans
situs inversus  heart located right hand side body  modelling
situations requires defeasible inheritance  i e   properties transfer instances class
default  explicitly overridden special cases  mccarthy        horty       
brewka        baader   hollunder      b   second application use dls security policy languages  uszok  bradshaw  johnson  jeffers  tate  dalton    aitken       
kagal  finin    joshi        tonti  bradshaw  jeffers  montanari  suri    uszok        
formalizing access control policies  one must deal situation given request
neither explicitly allowed explicitly denied  then  default decision taken
open closed policies  authorizations respectively granted denied
default  bonatti   samarati         moreover  policies often formulated incrementally  i e   start general authorizations large classes subjects  objects  actions 
progressively refine introducing exceptions specific subclasses 
approach clearly incarnation defeasible inheritance 
applications illustrate integrating nonmonotonic features dls
worthwhile  actual engineering computationally well behaved nonmonotonic dl
provides sufficient expressive power turns non trivial task  particular 
combinations dls nonmonotonic logics typically involve subtle interactions
two component logics easily leads undecidability  appears
one optimal way circumnavigate difficulties  thus many different combinations
dls nonmonotonic logics proposed literature  individual
strengths limitations  we provide survey section     however  striking
gap  almost existing approaches based default logic autoepistemic logic 
circumscription received little attention connection dls  computational properties dls circumscription almost completely unknown 
surprising since circumscription known one weakest forms
nonmonotonic reasoningsee work janhunen        one recent surveys  paper bonatti eiter        expressiveness analysis terms
queries  therefore  natural idea use circumscription defining computationally
well behaved  yet expressive dl nonmonotonic features 
paper  study circumscription  mccarthy        alternative approach
defining nonmonotonic dls  particular  define family dls circumscription enable natural modelling defeasible inheritance  general approach
generalize standard dl knowledge bases circumscribed knowledge bases  ckbs  which 
additionally tbox representing terminological knowledge abox representing knowledge individuals  equipped circumscription pattern 
pattern lists predicates  i e   concept role names  minimized sense that 
admitted models ckb  extension listed predicates minimal
w r t  set inclusion  following mccarthy         minimized predicates used
abnormality predicates identify instances typical class  circumscription patterns require predicates fixed minimization  allow
vary freely  mccarthy         main feature dls family
   

fithe complexity circumscription dls

come built in mechanism defeasible inheritance  default  properties
class  humans first example above  transfer subclass  humans situs
inversus   exceptions specified based priority mechanism  well known
defeasible inheritance priority cannot modularly encoded pure default
autoepistemic logic  horty         workarounds explicit listing exceptions
lead serious maintainability problems  circumscription lends naturally priorities 
based circumscription patterns express preferences minimized predicates terms partial ordering  argued baader hollunder      b  
approach well suited ensure smooth interplay defeasible inheritance dl
subsumption  thus prefer traditional prioritized circumscription 
achieve decidability  nonmonotonic dls usually adopt suitable restrictions
expressive power dl component  non monotonic features  interaction  case default logic autoepistemic logic  typical restriction concerns
different treatment individuals explicitly denoted constant 
not  goes back reasoning first order default logic  reiter       
autoepistemic logic  moore         involve tricky technical issues related
denotation individuals  make reasoning decidable dls based default logic  default rules applied individuals denoted constants occur explicitly
knowledge base  baader   hollunder      a   unnamed individuals 
consequence  named unnamed individuals treated uniformly  approaches
based autoepistemic logic  donini  lenzerini  nardi  nutt    schaerf        donini 
nardi    rosati               alternative solution restrict domain fixed  denumerable set constants  approach overcomes different treatment named
unnamed individuals since individuals named  flipside ad hoc encodings
required domain finite unique name assumption enforced  i e  
different constants allowed denote individual  respect  dls
circumscription pose difficulty all  named individuals treated exactly
way unnamed ones without assumptions domain 
time  able base nonmonotonic dls rather expressive dl components
alcio alcqo without losing decidability  however  cannot without
restrictions either  allow fix minimize concept names circumscription
require role names vary 
main contribution paper detailed analysis computational properties
reasoning ckbs  show that  expressive dls alcio alcqo  instance
checking  satisfiability subsumption decidable concept circumscribed kbs
concept names  and role names  minimized fixed  precisely 
prove reasoning problems nexpnp  complete  lower bound applies
already concept circumscribed kbs alc empty preference relation without
fixed concept names     empty tbox     empty abox acyclic tbox  addition 
show constant bound imposed number minimized fixed concept
names  complexity drops npnexp  
situation completely different role names minimized fixed  first 
complexity reasoning ckbs formulated alc single fixed role name  empty
tbox  empty preference relation  minimized role names turns outside
analytic hierarchy  thus highly undecidable  result shown reduction
   

fibonatti  lutz    wolter

name

syntax
r

inverse role
nominal
negation
conjunction
disjunction
at least restriction
at most restriction

 a 
c
c ud
c td
   n r c 
   n r c 

semantics
 ri        d  e     e  d  ri  
 ai  
  c
c di
c di
 d     e c    d  e  ri   n 
 d     e c    d  e  ri   n 

figure    syntax semantics alcqio 

satisfiability monadic second order logic  mso  binary predicates arbitrary
 i e   necessarily tree shaped  structures  reduction apply ckbs
role names minimized  fixed  surprisingly  find case
reasoning empty tboxes becomes decidable  and nexpnp  complete  dls
alc alcqo  alci extensions undecidable 
logics  however  adding acyclic tboxes leads undecidability  reader find
table summarising complexity results section   
interesting note results somewhat unusual perspective
nmls  first  arity predicates impact decidability  fixing concept names
 unary predicates  impair decidability  whereas fixing single role name  binary
predicate  leads strong undecidability result  second  number predicates
minimized fixed  bounded vs  unbounded  affects computational complexity
reasoning  although  as note passing  similar effect observed propositional
logic circumscription  has  best knowledge  never explicitly
noted 
paper organized follows  next section introduce syntax  semantics 
reasoning problems circumscribed kbs  provide examples  section  
provides basic results polynomial simulation fixed concepts means
minimized concepts  polynomial reduction reasoning general tboxes reasoning acyclic tboxes  polynomial reduction simultaneous satisfiability
multiple ckbs standard satisfiability  then  section   proves decidability complexity results concept circumscribed knowledge bases  fixed minimized roles
considered sections      respectively  section   discusses related work  section  
concludes paper summarizing main results pointing interesting
directions research  improve readability  many proof details deferred
appendix  paper extended version article bonatti  lutz  wolter
       

   description logics circumscription
dls  concepts inductively defined help set constructors  starting
set nc concept names  set nr role names   possibly  set ni individual
   

fithe complexity circumscription dls

names  all countably infinite   use term predicates refer elements nc nr  
concepts expressive dl alcqio formed using constructors shown
figure   
there  inverse role constructor role constructor  whereas remaining six
constructors concept constructors  figure   throughout paper  use  s
denote cardinality set s  b denote individual names  r denote
roles  i e   role names inverses thereof   a  b denote concept names  c 
denote  possibly complex  concepts  usual  use   abbreviation arbitrary
 but fixed  propositional tautology     usual boolean abbreviations 
r c  existential restriction       r c   r c  universal restriction       r c  
paper  concerned alcqio itself  several
fragments   basic fragment allows negation  conjunction  disjunction 
universal existential restrictions  called alc  availability additional
constructors indicated concatenation corresponding letter  q stands number restrictions  stands inverse roles  nominals  explains name
alcqio  allows us refer fragments alcio  alcqo  alcqi 
semantics alcqio concepts defined terms interpretation  

       domain non empty set individuals interpretation function maps concept name nc subset ai   role name r nr
binary relation ri   individual name ni individual ai  
extension inverse roles arbitrary concepts inductively defined shown
third column figure    interpretation called model concept c c     
model c  say c satisfied i 
 general  tbox finite set concept implications  cis  c v c
 
concepts  usual  use c   abbreviation c v v c  abox
finite set concept assertions c a  role assertions r a  b   a  b individual
names  r role name  c concept  interpretation satisfies  i  ci c v
c di    ii  assertion c a  ai c    iii  assertion r a  b   ai   bi   ri  
then  model tbox satisfies implications   model abox
satisfies assertions a 
important class tboxes acyclic tboxes  call tbox acyclic set
 
concept definitions   c  concept name following two conditions
hold 
concept name occurs left hand side definition  
 
relation   defined setting b iff   c b occurs c 
well founded 
   reason consider alcqio paper finite model
property  i e   satisfiable concepts satisfiable finite models  proofs
complexity upper bounds assume finite model property and  therefore  work alcqio  investigating circumscription description logics without finite model property remains interesting
open problem 

   

fibonatti  lutz    wolter

    circumscription  varying predicates  partial priority ordering
circumscription logical approach suitable modelling normally typically
holds  thus admits modeling defeasible inheritance  mccarthy        lifschitz 
       idea define  standard first order language  domain knowledge
so called abnormality predicates identify instances class violate normal
typical properties class  capture intuition abnormality exceptional 
inference based set models resulting theory classical logic 
rather restricted models extension abnormality predicates
minimal respect set inclusion  intuitively  means reasoning based
models normal possible  since models classical models
given knowledge base  classical first order inferences valid circumscription  but
additional inferences may become possible  
since description logics fragments first order logic  circumscription readily
applied  using alc syntax  assert mammals normally inhabitate land 
whales live land 
mammal v habitat land abmammal
whale v mammal u habitat land
upper inclusion states mammal inhabitating land abnormal mammal 
thus satisfying abnormality predicate abmammal   applying circumscription
tbox  thus consider models extension abmammal minimal 
however  one way defining preferred models nonminimized predicate treated two different ways minimization  may
either fix extension let vary freely 
intuitively  fixed predicates retain classical semantics varying predicates may
affected minimization  concrete example  consider tbox
assume non minimized predicates fixed  derive following
subsumptions 
whale v abmammal
  
 
abmammal   mammal u habitat land 
here  whale v abmammal abmammal w mammal u habitat land classical consequences
tbox  minimization abmammal adds inclusion abmammal v mammal u
habitat land 
analyze fixed predicates  suppose explicitly introduce concrete
mammal whale adding abox assertion
mammal u whale flipper 
might expect derive habitat land flipper   actually
case  see this  observe classical model knowledge base falsifies
habitat land flipper   extension fixed predicates habitat land
affected minimization  habitat land flipper  must still false minimization 
argument applied negation habitat land flipper  
thus derivable  seen sentence uses fixed
   

fithe complexity circumscription dls

predicates  consequence circumscribed knowledge base if  if 
classical consequence knowledge base 
assume let role habitat concept name land vary freely  fix
mammal whale  view concept inclusion mammal original tbox 
setup may interpreted expressing unlikely mammal
live land  willing modify extension habitat land order avoid
abnormality  obtain additional consequence  namely 
 
whale   abmammal  
  
see indeed consequence note that  minimization   i  make
land non empty  ii  mammal whale  ensure
abmammal linking via habitat generated instance land   intuitively 
equality    seen reflecting unlikeliness abnormal  mammal
abnormal reason  reason captured knowledge
base whale 
let us return assertion mammal u whale flipper   applying classical
reasoning        derive whale w mammal u habitat land  i e   whales
mammals live land   thus derive expected conclusion habitat land flipper   summary  turning habitat land varying
predicates  obtained natural modelling habitat attribute
mammals forced default value 
driving example further  might consider whales abnormal degree
believe exist unless evidence do  should 
additionally  let whale vary freely  result       still derived 
additionally obtain consequence
 
 
whale   abmammal    
use abox add evidence whales exist  e g  assertion
whale mobydick   expected  result change
 
 
whale   abmammal    mobydick  
evidence existence another  anonymous whale could generated adding
abox assertion male mobydick  tbox statement
whale v mother  whale u male 
mother male varying freely  knowledge base classically entails exist
two whales  satisfying male male  respectively  former denoted mobydick 
latter denoted abox individual  which corresponds first order
constant   minimization  whale contains exactly two individuals 
general  appropriate combination fixed varying predicates depends
application  therefore  adhere standard circumscription give users freedom
choose predicates minimized  fixed  varying 
   indeed  reason let land vary  ensure made non empty
minimization 

   

fibonatti  lutz    wolter

another example  consider sentences  humans  heart usually located
left hand side body  humans situs inversus  heart located
right hand side body  axiomatized follows 
human v heart has position  left  abhuman
situs inversus v heart has position  right 
heart has position  left  u heart has position  right  v  
predicate abhuman represents abnormal humans minimized  humans
situs inversus restricted individuals explicitly declared
property  analogy previous example roles specifying heart
position class exceptional individuals situs inversus allowed vary
human fixed retain classical semantics  result absence
axioms  abhuman situs inversus empty minimized models 
additional axiom friend situs inversus john  turns abhuman situs inversus
singleton set containing anonymous individual  though models  may
john himself   example nonclassical consequence  consider 
human u situs inversus v heart has position  left   
is  humans default heart position exception
explicitly declared situs inversus 
extensively argued  mccarthy        horty        brewka        baader  
hollunder      b  interplay subsumption abnormality predicates addressed nonmonotonic dls  consider  example  following
tbox 
user
staff
staff
blacklistedstaff

v
v
v
v

hasaccessto  confidentialfile  abuser
user
hasaccessto  confidentialfile  abstaff
staff u hasaccessto  confidentialfile 

get models normal possible  first attempt could minimize
two abnormality predicates abuser abstaff parallel  assume hasaccessto
varying  user  staff  blacklistedstaff fixed  then  result parallel
minimization staff members may may access confidential files 
equal preference  first case  abnormal users  second case 
abnormal staff  however  one may argue first option preferred  since
staff v user  but way round   normality information staff
specific normality information users higher priority  effects well known propositional first order case indeed  circumscription
soon introduction extended priorities address issues specificity
 mccarthy        
formalism  users specify priorities minimized predicates  typically 
priorities reflect subsumption hierarchy  as computed w r t  class
models   since subsumption hierarchy general partial order  priorities
minimized predicates may form partial order  too  approach analogous partially
   

fithe complexity circumscription dls

ordering priorities default rules  proposed brewka         general
standard prioritized circumscription  assumes total ordering  mccarthy       
lifschitz         special case nested circumscription  lifschitz        
    circumscribed knowledge bases
define dls circumscription  start introducing circumscription patterns 
describe individual predicates treated minimization 
definition    circumscription pattern   cp   circumscription pattern tuple cp
form    m  f  v    strict partial order     f   v
mutually disjoint subsets nc nr   minimized  fixed  varying predicates 
respectively    denote reflexive closure   define preference relation  cp
interpretations setting  cp j iff following conditions hold 
     j and  ni   ai   aj  
   p f   pi   pj  
   p   pi   pj exists q   q p  q q j  
   exists p pi pj q q p  q   q j  
f nc  i e   minimized fixed predicates concepts  call
   m  f  v   concept circumscription pattern 
 
use term concept circumscription concept circumscription patterns admitted  based circumscription patterns  define circumscribed dl knowledge
bases models 
definition    circumscribed kb  circumscribed knowledge base  ckb  expression circcp  t   a   tbox  abox  cp      m  f  v   circumscription pattern m  f  v partition predicates used a  interpretation
model circcp  t   a  model exists model  
   cp i 
ckb circcp  t   a  called concept circumscribed kb cp concept circumscription pattern 
 
note partially ordered circumscription becomes standard parallel circumscription
empty relation used  
main reasoning tasks  non circumscribed  kbs satisfiability concepts
w r t  kbs  subsumption w r t  kbs  instance checking w r t  kbs  reasoning
tasks fundamental circumscribed kbs well  provide precise definitions
tasks  throughout following section  dl denotes set dls
introduced previous section  i e   alc  alci  alco  alcq  alcqi  alcio 
alcqo  alcqio 
definition    reasoning tasks 
   

fibonatti  lutz    wolter

concept c satisfiable w r t  ckb circcp  t   a  model circcp  t   a 
satisfies c      let l dl  satisfiability problem w r t  ckbs l defined
follows  given concept c l ckb circcp  t   a  l  decide whether c
satisfiable w r t  circcp  t   a  
concept c subsumed concept w r t  ckb circcp  t   a   symbols
circcp  t   a     c v d  c di models circcp  t   a   let l dl 
subsumption problem w r t  ckbs l defined follows  given concepts c
l ckb circcp  t   a  l  decide whether circcp  t   a     c v d 
individual name instance concept c w r t  ckb circcp  t   a  
symbols circcp  t   a     c a   ai c models circcp  t   a   let
l dl  instance problem w r t  ckbs l defined follows  given
concept c l  individual name a  ckb circcp  t   a  l  decide whether
circcp  t   a     c a  
 
reasoning problems polynomially reduced one another  first  c satisfiable
w r t  circcp  t   a  iff circcp  t   a      c v   circcp  t   a     c v iff c u
satisfiable w r t  circcp  t   a   second  c satisfiable w r t  circcp  t   a  iff
circcp  t   a      c a   individual name appearing a  conversely 
circcp  t   a     c a  iff auc satisfiable w r t  circcp   t   a a a    
concept name occurring a  cp  obtained cp adding
 and leaving is   paper  use satisfiability w r t  ckbs basic
reasoning problem 

   basic reductions
present three basic reductions reasoning problems circumscribed knowledge
bases interesting right and  additionally  useful establishing
main results paper later on  precisely  replay well known reduction
fixed predicates minimized predicates context dls  reduce reasoning w r t  ckbs
general tboxes reasoning w r t  ckbs acyclic tboxes  show that 
certain conditions  simultaneous satisfiability w r t  collection ckbs reducible
satisfiability w r t  single ckb 
    fixed minimized concepts
circumscription  folklore fixed predicates simulated terms minimized
predicates  see e g  de kleer         case dls  simulation possible
concept names  see this  let c  concept circcp  t   a  circumscribed
kb cp      m  f  v   f     a            ak     f nc   define new pattern
cp           f   f    v  
     a            ak   a             a k    a             a k concept names
occur c      f   v     a 
 
     a i   ai     k  
   

fithe complexity circumscription dls

difficult see c  satisfiable w r t  circcp  t   a  iff satisfiable w r t 
circcp   t     a   thus  get following result 
lemma   let l dl  satisfiability w r t   concept  circumscribed kbs l
polynomially reduced satisfiability w r t   concept  circumscribed kbs l
fixed concept names 
contrast concept names  fixed role names cannot reduced minimized role names
since boolean operators roles available standard dls alcqio 
proof given section    show that  cases  reasoning minimized
role names decidable  whereas corresponding reasoning task ckbs fixed role
names undecidable 
reduction clearly relies tboxes  however  paper sometimes
work circumscribed kbs tbox empty  following lemma  proved
appendix  shows ckbs alc without fixed role names empty tbox 
one simulate fixed concept names using minimized concept names without introducing
tbox  proof  may viewed much careful version proof
lemma    adapted yield analogous result logics dl 
lemma   alc  satisfiability w r t   concept  circumscribed kbs empty tbox
without fixed roles polynomially reduced satisfiability w r t   concept  circumscribed
kbs empty tbox without fixed predicates 
    acyclic general tboxes
many dls  satisfiability w r t   non circumscribed  kbs general tboxes harder
satisfiability w r t   non circumscribed  kbs acyclic tboxes  case alc 
alci  alcq  alcqo  latter problem pspace complete  baader  mcguiness 
nardi    patel schneider        baader  milicic  lutz  sattler    wolter      b  y  ding
  wu        former exptime complete  baader et al         
dls considered paper satisfiability exptime hard already acyclic
tboxes alcio extensions  areces  blackburn    marx         show that 
circumscribed kbs  difference computational complexity acyclic
general tboxes 
let c  concept circcp  t   a  ckb cp      m  f  v    may assume
 
without loss generality        c  concept c   to see this  observe
 
axioms c v equivalent     c d   define
 
 
 
 
acyclic tbox      a   c  b   u a  a    a  b     b   a  b  a    b     u
new concept role names occurring   a    f   v   c   
circumscription pattern cp           f  v           a    b     v    
v  a  b  u  
ad b   conjunctively c  thus interested models circcp   t     a 
 b    i      models  ai    and thus c     since  otherwise 
turn instance b   instance b   making instance b
   

fibonatti  lutz    wolter

linking via role u instance a  thus obtaining preferred model w r t 
 cp    basis proof following lemma  given appendix 
lemma   c  satisfiable w r t  circcp  t   a  iff c  ub   satisfiable w r t  circcp   t     a  
thus  obtained following result 
proposition   let l dl  satisfiability w r t   concept  circumscribed kbs l
polynomially reduced satisfiability w r t   concept  circumscribed kbs l acyclic
tboxes without changing abox 
shows satisfiability w r t  ckbs acyclic tboxes complexity
satisfiability w r t  ckbs general tboxes  many cases considered paper 
even true ckbs empty tboxes  c f  section    however  identify
cases ckbs non empty tboxes higher complexity  see theorems        
thus general reduction one underlying proposition   cannot exist case
empty tboxes 
    simultaneous satisfiability
applications  often necessary merge tboxes  aboxes  whole knowledge bases
taking union  show that  certain conditions  reasoning w r t  union
several circumscribed kbs reduced reasoning w r t  component ckbs 
concept c simultaneously satisfiable w r t  ckbs circcp   t    a             circcpk  tk   ak  
exists interpretation model ckbs satisfies c     
following lemma says simultaneous satisfiability polynomially reduced
satisfiability w r t  single ckb two ckbs share role name 
proof idea case k     follows  given circcp   t    a    circcp   t    a    
first take union two ckbs  replacing circcp   t    a    concept name
used circcp   t    a    fresh concept name a    introduce
additional concept name p  for problem  make sure p satisfied abox
individual whenever point model interpretation a 
disagrees  look model p satisfied abox  intuitively 
additional concept name p satisfies purpose decoupling a    important
e g  case a a  minimized circcp   t    a    circcp   t    a     details
given appendix 
lemma   l dl  simultaneous satisfiability w r t   concept  circumscribed kbs
circcp   t    a           circcpk  tk   ak    circcpi  ti   ai   circcpj  tj   aj   share
role names     j k  reduced polynomial time satisfiability w r t  single
 concept  circumscribed kbs 

   complexity reasoning concept circumscribed kbs
main contributions paper consist  i  showing that  many cases  reasoning
circumscribed knowledge bases decidable   ii  performing detailed analysis
   

fithe complexity circumscription dls

computational complexity decidable cases  section  show
satisfiability w r t  concept circumscribed kbs nexpnp  complete dl alc
extensions alcio alcqo  show npnexp  complete number
fixed minimized concept names bounded constant  first present proofs
upper bounds establish matching lower bounds 
    upper bounds
start general case bound number fixed
minimized predicates 
      general case
prepare upper bound proof showing concept satisfiable w r t 
concept circumscribed kb  satisfiable model bounded size  use  c 
denote length concept c  i e  
p number  occurrences of  symbols needed
write c  size  t   tbox cvdt  c     d   size  a  abox
sum sizes assertions a  size role assertion  
size concept assertions c a   c  
lemma   let c  concept  circcp  t   a  concept circumscribed kb  n     c     
 t      a   c  satisfiable w r t  circcp  t   a   following holds 
 i    c  formulated alcio  c  satisfied model
circcp  t   a   i   n  
 ii    c  formulated alcqo maximal parameter occurring number restriction   a  c    c  satisfied model
circcp  t   a   i   n  m      n 
proof  let cp    a  c  lemma    may assume   every
assertion c a  expressed implication  a  v c  every assertion r a  b 
expressed  a  v r  b   denote cl c    smallest set concepts contains
subconcepts c  subconcepts concepts appearing   closed single
negations  i e   cl c    start   cl c     
let common model c  circcp  t   a   let d  c i   define equivalence relation setting d  iff
 c cl c        c      c cl c        d  c   
use  d  denote equivalence class w r t  relation  pick
equivalence class  d  exactly one member denote resulting subset    
first prove point  i   thus  assume c  formulated alcio 
define new interpretation j follows 
j

    

aj

    d     ai  

rj

     d    d          d    d     d    d       d     d     ri  

aj

     ai  d  
   

fibonatti  lutz    wolter

following claim easily proved using induction structure c 
claim  c cl c        c iff d  c j element
d   d  j  
thus  j model satisfying c    show j model circcp  t   a   thus
remains show model j   j    cp j   assume contrary
j     define interpretation   follows 


 

ai

 

  
 
 d 
  
daj  

r

i 

 

  

 d   d 
 
ai

 d     d   

 rj  

   ai  

matter routine show following 
 

 

claim  concepts c cl c        c iff d  c j
element d   d  j  
 

 

follows   model   observe ai ai iff aj aj concept
name       therefore since cp concept circumscription pattern
   cp follows j    cp j   derived contradiction conclude j
model circcp  t   a   thus done since size j bounded   n  
point  ii   pick    concept    k r c  cl c     
   k r c i   k elements  d    d  c    d  d    ri    pick 
concept    k r c  cl c          k r c  i   k     elements
 d    d  c    d  d    ri    denote    collection elements picked  take
       element ds   ds define interpretation j
j

       

aj

    d        ai  

rj

     d    d                 d    d    ri  
  d    d                         ds    d    ri  

aj

   ai  d  

following claim easily proved 
claim  c cl c       following 
 i  d  d  j   d    c j iff d  c j  
 ii    c iff d  c j element d   d  j  
thus  j model satisfying c    show j model circcp  t   a  
thus remains show model j   j    cp j   assume
contrary j     define interpretation     end  take
   

fithe complexity circumscription dls

  j dp   dp   define   follows



 

i 

  
 

 

   aj  d   j   dp aj  

ri

 

   rj   d    d     i   j      dp    d    rj  

ai

 

   ai  

 

 

again  matter routine show 
 

claim  concepts c cl c        c j iff c j
 
 
c  i   j   iff dp c j element dp  d     
 

 

 

follows   model   observe ai ai iff aj aj concept
name       therefore since cp concept circumscription pattern
   cp follows j    cp j   derived contradiction conclude
j model circcp  t   a   thus done since size j clearly bounded
  n  m      n 

interesting note proof lemma   go role names
minimized fixed  problem cannot overcome  proved undecidability
results presented sections     
using bounded model property established  prove decidability
reasoning concept circumscribed kbs formulated alcio alcqo 
precisely  lemma   suggests non deterministic decision procedure satisfiability w r t 
concept circumscription patterns  simply guess interpretation bounded size
check whether model  turns procedure shows containment satisfiability complexity class nexpnp   contains problems solved
non deterministic exponentially time bounded turing machine access
np oracle  known nexp nexpnp expspace 
theorem    alcio alcqo  nexpnp decide whether concept
satisfiable w r t  concept circumscribed kb circcp  t   a  
proof  hard see exists np algorithm takes input
ckb circcp  t   a  finite interpretation i  checks whether model
circcp  t   a   algorithm first verifies polynomial time whether model
a  answering yes case  otherwise  algorithm guesses interpretation
j domain interprets individual names way 
checks whether  i  j model a   ii  j  cp i  answers yes
checks succeed  otherwise  clearly  checking whether j  cp done
time polynomial w r t  size j i 
np algorithm may used oracle nexp algorithm deciding
satisfiability concept c  w r t  ckb circcp  t   a   lemma    suffices guess
interpretation size   k k    c       t      a    use np algorithm
check whether model circcp  t   a   proves concept satisfiability
nexpnp  

   bound   k clearly dominates two bounds given parts  i   ii  lemma   

   

fibonatti  lutz    wolter

reductions given section    theorem    yields co nexpnp upper bounds
subsumption instance problem  show section     upper
bounds tight 
      bounded number minimized fixed predicates
since nexpnp rather large complexity class  natural question whether
impose restrictions concept circumscription reasoning becomes simpler 
following  identify case considering concept circumscribed kbs
number minimized fixed concept names bounded constant  case 
complexity satisfiability w r t  concept circumscribed kbs drops npnexp   readers
uninitiated oracle complexity classes  recall nexp npnexp nexpnp  
npnexp believed much less powerful nexpnp   see example work
eiter et al         
prove npnexp upper bound  first introduce counting formulas common
generalization tboxes aboxes 
definition     counting formula  counting formula boolean combination
concept implications  abox assertions c a   cardinality assertions  c   n  c
concept n non negative integer  use     denote boolean
operators counting formulas  interpretation satisfies cardinality assertion  c   n 
 c   n  satisfaction relation    models counting formulas
defined obvious way 
 
following  assume integers occurring cardinality assertions coded
binary  npnexp algorithm devised use algorithm satisfiability
 non circumscribed  counting formulas oracle  therefore  first determine
computational complexity latter  follows results tobies        that 
alc  satisfiability counting formulas nexp hard  matching upper bound
dls alcio alcqo obtained facts  i  polynomial
translation counting formulas formulated languages c   two variable
fragment first order logic extended counting quantifiers  gradel  otto    rosen 
      pacholski  szwast    tendera          ii  satisfiability c  nexp even
numbers counting quantifiers coded binary  pratt hartmann        
theorem     tobies  pratt  alc  alcio alcqo  satisfiability counting
formulas nexp complete even numbers number restrictions coded binary 
establish improved upper bound 
theorem    let c constant  alcio alcqo  npnexp decide satisfiability w r t  concept circumscribed kbs circcp  t   a   cp      m  f  v  
 m c  f c 

   

fithe complexity circumscription dls

proof  assume want decide satisfiability concept c  w r t  ckb
circcp  t   a   cp      m  f  v    m c  f c  lemma   
may assume f    we may increase constant c appropriately  
may assume without loss generality cardinality exactly c  thus  let
   a            ac    lemma    c  satisfiable w r t  circcp  t   a  iff exists
model c  circcp  t   a  size   k   k    c       t      a   consider 
  concept
cs   
au
a 

u



u

a a       ac   s

c constant  number  c concepts constant well  clearly  sets csi  
  form partition domain model i  introduce  concept
name b role name r a  fresh concept name b   fresh role name r   
respectively  concept c  denote c   result replacing c concept name
b role name r b   r    respectively  primed versions a   
defined analogously  denote n set individual names  c    
nexp oracle going use algorithm checks whether counting formula
satisfiable not  now  npnexp  algorithm follows  we use c  
abbreviation counting formula  c v d   d v c   
   guess
sequence  ns     numbers ns   k coded binary 
individual name n   exactly one set sa  
subset e n n  
   calling oracle  check whether counting formula   satisfiable   
conjunction
  c        
 cs   ns     
csa  a   n  
   a  v  b      a  b  e     a  v  b      a  b  n e  
   calling oracle  check whether counting formula   satisfiable   
conjunction
  a   
 cs   ns     note use unprimed versions  
csa  a   individual name n  we use unprimed versions  
   a  v  b      a  b  e     a  v  b      a  b  n e  
 
 a  v a 

 
bm ba

   

 b     b  

fibonatti  lutz    wolter

and  finally 
 

 

 a    a 




 
 b   b      

bm ba

   algorithm states c  satisfiable model circcp  t   a  if  if 
  satisfiable   satisfiable 
using fact c fixed  hard verify npnexp  algorithm 
remains show correctness completeness 
suppose exists model circcp  t   a  satisfying c   
model size bounded   k   let algorithm guess
numbers ns    csi    
sets sa ai csia  
set e     a  b    b  a    ai   bi   a  b n   
clearly    satisfied i  remains show   unsatisfiable  suppose
exists model j satisfying     definitions       may assume
  j  
ai   aj  
ai   aj individual names a 
moreover  unprimed role names occur   unprimed concept names
    may assume interpretation unprimed concept role
names j coincide  thus  j model circcp  t   a  satisfying c   
define model j   domain j setting
 

aj   aj   individual names a 
 

rj    r   j   role names r 
 

aj    a   j   concept names a 
then  conjunct item   definition     j   model  
items     definition     j    cp j   derived contradiction 
conversely  suppose algorithm says exists model circcp  t   a  satisfying c    take model     conjunct item       model
satisfying c    follows unsatisfiability   model
circcp  t   a  


   

fithe complexity circumscription dls

corollary  obtain co npnexp upper bounds subsumption instance problem  similar drop complexity occurs propositional logic  satisfiability w r t 
circumscribed theories complete npnp difficult see bounding
minimized fixed predicates allows us find pnp algorithm 
    lower bounds
prove lower complexity bounds reasoning concept circumscribed kbs
match upper bounds given section     
      general case
section      start general case number fixed minimized
predicates bounded  aim establish two nexpnp  lower bounds
match upper bound established theorem     first bound satisfiability w r t 
concept circumscribed kbs formulated alc empty tbox  nonempty abox  second bound satisfiability w r t  concept circumscribed kbs
formulated alc  assumes acyclic tbox empty abox  reductions work
already case empty preference relation  without fixed predicates  note
considering satisfiability concept c w r t  concept circumscribed kb circcp  t   a 
empty interesting  seen c satisfiable w r t 
circcp  t   a  iff c satisfiable  without reference kb   c concept
obtained c replacing minimized concept names  
proof first result reduction succinct version problem cocert col  nexpnp  complete  eiter  gottlob    mannila         satisfiability
w r t  concept circumscribed kbs empty tbox  let us first introduce regular  nonsuccinct  version co cert col 
instance size n  undirected graph g vertices                n    every
edge labelled disjunction two literals boolean variables  vi j   i  j   n  
yes instance size n  instance g size n that  truth value assignment
boolean variables  graph t g  obtained g including edges
whose label evaluates true   colorable 
shown stewart         co cert col complete npnp   obtain problem
complete nexpnp   eiter et al  use complexity upgrade technique  encoding
input succinct form using boolean circuits  complexity raised one exponential
nexpnp  eiter et al          precisely  succinct version co cert cols
co cert col obtained representing input graph g nodes              n   
 n     boolean circuits  n inputs  and one output  each  boolean circuits
   
   
 i 
named ce   cs   cs   cj                j   n  circuits   n inputs
bits binary representation two nodes graph  purpose
circuits follows 
circuit ce outputs   edge two input nodes    otherwise 
   

edge input nodes  circuit cs outputs   first literal
   
disjunction labelling edge positive    otherwise  circuit cs
   

fibonatti  lutz    wolter

second literal  edge input nodes  output
arbitrary 
 i 

edge input nodes  circuits cj compute labelling
vk   k  vk   k  edge input nodes generating numbers k            k   
 i 
circuit cj outputs j th bit ki   edge input nodes 
output arbitrary 
reduce co cert cols satisfiability w r t  concept circumscribed kbs formulated alc whose tbox preference relation empty  remains
apply lemma   eliminate fixed concept names  we note construction
proof lemma leaves preference relation untouched   let
   

   

 i 

g    n  ce   cs   cs    cj  i         j n  
 succinct representation the  input graph  n nodes  construct abox
ag    c  u root a      circumscription pattern cpg   concept cg g
yes instance co cert cols iff cg satisfiable w r t  circcpg    ag   
concept c  used ag conjunction whose presentation split two parts 
intuitively  purpose first group conjuncts fix truth assignment
variables  vi j   i  j   n   construct  an isomorphic image of  graph t g 
obtained g including edges whose label evaluates true t  then 
purpose second group make sure t g    colorable 
formulating c    use several binary counters counting modulo  n  the
number nodes input graph   main counters x use concept names
x            xn  y            yn  bits  respectively  additionally  introduce concept
 i 
 i 
names k            kn                  serve four additional counters k               k      
first group conjuncts c  found figure    following abbreviations
used 
ri  c denotes n fold nesting r   r c 
r  k  i    x  abbreviation

u

j n

 i 
 i 
 xj r kj   u  xj r kj  

similarly r  k  i      
abbreviations wc   c boolean circuit  explained later on 
intuition behind figure   follows  lines         build binary tree depth
 n whose edges labeled role name r    n leaves tree instances
concept name leaf  labeled possible values counters x
  since minimize leaf via circumscription pattern cpg   concept name
denotes precisely leaves tree  due use counters x   leaves
distinct 
leaves tree established satisfy number purposes  start with 
leaf counter values x     j corresponds variable vi j co certcols determines truth value variable via truth falsity concept
   

fithe complexity circumscription dls

ri   r xi u r xi  
j

r    xi r xi   u  xi r xi   
r
r

n j

n i

  r yi u r yi  

   yi r yi   u  yi r yi   

  n

   

  n  j    n

   

i n

   

  j   n

   

 n

r  leaf

   

r n   wce u wc    u wc     

   





r n   wc    u u wc     
j

j   n

r n   var  leaffix u var   k      x  u var   k      y   
 n

r   var  leaffix u var   k

   

   

j

 x  u var   k

   

   

 y   

   

 n

p r  var  leaf

    

 n

p r  var  leaf

    

r n   s   tr  var  tr  

    

 n

r   s   tr  var  tr  
 n

r   s   tr  var  tr  
 n

    
    

r   s   tr  var  tr  

    

 n

    

r   elim  e  tr  tr     
figure    first group conjuncts c   

name tr  thus  leaves jointly describe truth assignment instance g co certcols   second purpose leaves represent potential edges g 
additionally representing variable  leaf x     j corresponds
potential edge nodes j  explain properly  must first
discuss abbreviations wc used lines         figure   
concept wc   c boolean circuit  n inputs  result converting c
concept uses constructors   u  following condition satisfied 
instance wc   output c upon input b            b n  b  truth
value concept names x            xn    y            yn  described b            b n   
truth value concept name described b  introducing one
auxiliary concept name every inner gate c  translation done
size wc linear size c  following concept names used output 
wce uses concept name e output 
wc i  uses concept name si output         


 i 

wc i  uses concept name kj

output                 j   n 

j

   

fibonatti  lutz    wolter

r n   col  leaffix u col  leaffix 
 n

r   col   x   x  u col   y      
 n

r   col   y   x  u col   y      

    
    
    

 n

    

 n

p r  col  leaf

    

r n    y       r b g  

    

r    y        r u b  u  r u g  u  b u g   

    

r n    elim u col  r u col  r  clash 

    

r n    elim u col  g u col  g  clash 

    

r n    elim u col  b u col  b  clash 

    

p r  col  leaf

 n

figure    second group conjuncts c   
lines         ensure concepts propagated leaves  next aim
ensure leaf represents potential edge  i  j  connected via role var 
leaf represents variable first disjunct label  i  j   analogously
role var  variable second disjunct edge label  replaced
concept name leaffix leaf lines          lines would apparently
encode properties  however  careful mentioned replacement
would interact minimization leaf  fix problem  resort trick 
use concept name leaffix instead leaf  way  may may reach
instance leaf  not  force concept name p true root
tree lines            use cg rule models p true  finally 
fix leaffix via cpg eliminate interaction minimization leaf 
remaining lines           ensure leaf instance elim iff potential
edge represents present graph t g  induced truth assignment
described leaves 
second group conjuncts c  found figure    here   y      stands
concept  y  u u yn     already mentioned  purpose conjuncts
ensure graph t g  described leaves   coloring 
strategy ensuring follows  use  n leaves     store colors
nodes  i e   leaf x       stores color node i  lines     
      unique coloring  then  lines           ensure leaf  viewed
edge  connected via role col  leaf stores color first node
edge  analogously role col  second node edge  leaffix
p role before  lines           guarantee concept name clash
identifies problems coloring  leaf clash represents edge exists
g  dropped t g   endpoints color  idea
clash minimized r  g  b vary  additional concept
names fixed  corresponds universal quantification possible colorings 
   

fithe complexity circumscription dls

set cg   root u p u r n  clash  recall ag    c  u root a      following
lemma proved appendix 
lemma    g yes instance co  certcols iff cg satisfiable respect
circcpg    ag    cpg      m  f  v          root  leaf  clash  
f    leaffix  tr  x            xn    y            yn      
v set remaining predicates ag  
since size ag polynomial n  get following result applying lemma   
theorem    alc  satisfiability w r t  concept circumscribed kbs nexpnp  hard even
tbox preference relation empty fixed predicates 
rather straightforward establish announced second nexpnp lower bound
reduction satisfiability w r t  concept circumscribed kbs special case formulated
theorem     details given appendix 
corollary    alc  satisfiability w r t  concept circumscribed kbs nexpnp  hard
even tbox acyclic  abox preference relations empty 
fixed predicates 
corresponding lower bounds subsumption instance problems follow
reduction given section   
      bounded number minimized fixed predicates
establish matching lower bound theorem    showing that  alc  satisfiability w r t  concept circumscribed kbs npnexp  hard even constant number
predicates allowed minimized fixed  contrast previous section 
ignore case empty tboxes directly establish lower bound case
non empty tboxes empty aboxes  allows us demonstrate usefulness
lemma   separating different parts lower bound proof  main reduction
previous section  two parts reduction shown figure     truly
independent  forced us implement technical trick involves concept
names leaffix p   using lemma    contrast  achieve true separation
concerns  general  though  conjecture lower bound proved section
established case empty tboxes adapting mentioned technical trick 
leave problem interested reader 
recall  non deterministic  k tape turing machine described tuple
 q    q      qacc   qrej   
q finite set states  finite alphabet  q  q starting state 
q k q k  l  r k
transition relation  qacc   qrej q accepting rejecting states  purposes 
oracle turing machine   tape turing machine that  additionally  equipped

   

fibonatti  lutz    wolter

  tape turing machine m   the oracle  whose alphabet identical m 
query state q   
two answer states qyes qno  
second tape called oracle tape  enters q    oracle determines
next state m  content oracle tape contained language accepted
oracle  next state qyes   otherwise  qno   transition  head
moved symbols written  state q  cannot occur left most component
tuple ms transition relation 
let    q    q      qacc   qrej   m    q    qyes   qno   oracle turing machine
following holds 
solves npnexp  complete problem 
time consumption bounded polynomial p  where oracle calls contribute single clock tick  
    q     bounded  q n    q
time consumption m     q      q         qacc
rej
polynomial 

assume without loss generality m  never attempt move left
left most position tape  neither right right most position   npnexp hardness proof uses reduction word problem m  thus  let w input
length n  let   p n  m    q p n    construct three tboxes
tw   tw    tw     circumscription patterns cp  cp    cp     concept cw
accepts w iff cw simultaneously satisfiable w r t  circcp  tw      circcp   tw      
circcp    tw        then  lemma   yields reduction  non simultaneous  satisfiability w r t 
concept circumscribed ckbs  intuitively  purpose first tbox tw impose
basic structure domain  tw  describes computations m  tw   describes
computations m    use general tboxes rather acyclic ones since  lemma   
done without loss generality 
tbox tw shown figure    previous reduction  use concept
names x            xm    y            ym    implement two binary counters counting
 
modulo  m   use abbreviations previous reduction  additionally 
r  x    states value counter x            xm    incremented going
r successors  i e  


xj  xk r xk   u  xk r xk  
 

u
u

k    m  

k    m   

u


j    k 

j    k 



xj  xk r xk   u  xk r xk  

purpose lines           ensure that  possible value  i  j 
counters x   least one instance nexp satisfies  x   i   y   j  
 
 
minimize nexp  thus enforce nexp exactly  m  m elements 
 
 
elements interconnected via roles r  for right  u  for up  form  m  m grid  later on  use grid encode computations oracle machine m    observe
   

fithe complexity circumscription dls

  v aux nexp
m 

nexp v   x    

    
m 

   r nexp  u   y    

   u nexp 

    

nexp v r  y  y   u r  x   

    

nexp v u  x x  u u  y    

    

  v
result v

u aux  result u r  
u  r u r  

    



i m



i j m

    

j

  v aux np

    
figure    tbox tw  

that  since working simultaneous satisfiability  minimization nexp
interact anything going put tboxes tw  tw    
minimize concept name result  thus lines           guarantee
exactly instances result  identified concept names r            rm   
makes call oracle i th step  result call stored
 unique  instance result u ri   i e   instance satisfy concept name rej
m  rejected input falsify otherwise  finally  minimize np  thus
line      guarantees exactly one instance np  instance used
represent computation m  summing up  circumscription pattern tw
cp        nexp  result  np     v   
v containing remaining predicates used tw  
purpose tw  describe computations m  use following concept
names 
  i  j   m  k         introduce concept name sai j k   intuitively 
sai j k expresses symbol j th cell k th tape i th step
ms computation  start numbering tape cells steps   
q q   m  qiq concept name expressing state q
i th step computation 
q q  i  j   m  k         hji k concept name expressing
k th head cell j i th step computation 
q q    i  j   m  k          l  r   concept names aiq   ai j k
 
i k

serve markers  precisely  aq means that  time point i 
executed transition switches state q  similarly  ai j k
describes symbol

i k
written transition tape k  describes move tape k 
details tw  given figure    one copy concept inclusions figure
needed every i  j  j     every k         assume w   a  an 
   

fibonatti  lutz    wolter

  n  
  m   
np v q q  u h     u sa     
u sa  n   
u sb
u u sb
 
n 

    

     
  m   
np v h     u sb
u u sb

    

np v

u

i j     

a b qq  q   

 sai j   u sb

np v
np v
np v
np v
np v

ua
ua

qq


ai k
l
i k
ar


q

i j k


    
i  
aiq u ai j  
u ai j
u ai  

u         
b

   

    

 q a b q    a   b   m m    

sai   j k

i   k
hj 

   

    

    j    

    

i   k
hj  

    j    

i   j k
    j    j  
 sai j k u hji k
    sa

u
u



qi  
q

a b a  b

 sai j k u sbi j k   u

np v  hji k u hji k
   

    



 
np v

u qiq u hji   u hji  
   

u

q q   q q  q  

 qiq u qiq   

j    j  

    
    
    
    

np v resi   result u ri   u resi   result u ri  

    

np v  qiq  u resi  rej  qi  
qno

    

np v

 qiq 

u resi  rej 

qi  
qyes

np v  qiq  u hji k   hji   k
np v

u



   
   

   

i   j k

 qiq  u sai j k   sa

    
    
    

figure    tbox tw   
use b denote  shared  blank symbol m    lines           describe
behaviour turing machine usual way  transitions follow transition table 
computation starts initial configuration  etc  line      ensures instance
np reach  unique  instance result u ri via role resi     m  lines     
     deal transitions query state looking result oracle
call corresponding instance result  finally  lines           ensure head
position tape symbols change querying oracle  circumscription
pattern tw  simply cp            v    v set predicates used tw   
purpose tw   describe computations oracle turing machine m    note
describe single computation m   but polynomially many  since may visit state q  once  computations
represented nexp grid  different computations untangled use
different concept names computation  use counter x            xm    count
   

fithe complexity circumscription dls

configurations counter y            ym    count tape cells configuration 
moreover  use following concept names 
  m  concept name sai   sai satisfied instance
nexp x            xm    value j y            ym    value k  i th
computation m  has  j th step  symbol k th cell 
q q   m  concept name qiq   purpose concept name
two fold  first  represents current state m  i th computation 
second  indicates head position i th computation 
  q q   l  r    m  concept name aiq a m marker 
meaning marker aiq a m that  reach current configuration  m 
switched q  written a  moved head direction   additionally  marker
indicates head position previous configuration 
additional concept name nh  for nohead  helps us enforce m 
single head position 
details tw   shown figure    require one copy line every
  m  purpose lines           regenerate grid structure nexp using
roles r  und u    necessary since roles r u used tw   and  use
lemma    tboxes cannot share role names  lines           ensure every
instance nexp reaches  only  unique instance np via role tonp   only 
unique instance result u ri via role res i     m  lines           describe
computation m  straightforward way  precisely  lines           set
initial configuration reading contents ms oracle tape instance np 
lines           implement transitions  lines           enforce unique label
tape  unique state  unique head position  finally  line      ensures that 
i th computation m  rejecting  rej true instance result u ri  
note m  non deterministic machine may one computation 
storing rej result u ri   need know computations rejecting 
deal issue  rej minimized predicates varying  exists
accepting computation m  i th input  represent computation
nexp make rej false instance result u ri   hence  rej holds result u ri
iff exists accepting computation  note cannot fix concept names
x            xm      y            ym    minimizing rej since would get unbounded number
fixed concept names  means elements nexp change position
minimization  roles r  u    harmful since tw
lines           ensure structure  nexpi    r   i    u   i   always isomorphic
grid  rest tw   ensures elements nexp always encode computations
m    thus use circumscription pattern cp          rej     v      v   contains
predicates used tw   except rej 
proof following lemma left reader  formulation  union
qiqacc imposes least one state computation accepting 
   

fibonatti  lutz    wolter

 

 

nexp v   x    m    r   nexp  u   y    m    u   nexp 
 

 

 

 

    

nexp v r   y  y   u r   x    u u   x x  u u   y    

    

nexp v res i   result u ri   u res i   result u ri  

    

nexp v tonp np u tonp np

    

nexp v

uu



j m



 x      u  y   j  u tonp sai j   sai

    


nexp v   x      u  y m   sb

    

qiq 
 

    

nexp v   x      u  y      
nexp v

uu



 sai u qiq  

qq 



 q a q    a   m   

r   aiq   a   m



    

nexp v aiq a r  sai u u   qiq  

    

aiq a l sai
u   aiq a l

    

nexp v
nexp v

nexp v
nexp v

    

q u  s r  s  
u  s u   u u
q u  nh

nh q u u  nh

nexp v
nexp v

qiq

qq 


q

a b a  b
qq 




rej


b




    
 qiq u qiq   

q q   q   q  q  

 


q

qq 

nexp v qiq 

 







q

    
    

 

    

res i  rej

    

figure    tbox tw    
lemma    accepts w iff cw    np u

tq

i m


qacc

simultaneously satisfiable w r t 

circcp  tw      circcp   tw       circcp    tw       

remains apply lemmas         obtain following result 
theorem    alc  satisfiability w r t  concept circumscribed ckbs npnexp  hard
even tbox acyclic  abox preference relations empty 
fixed predicates  number minimized predicates bounded constant 
already mentioned  conjecture result proved empty tboxes
 but non empty aboxes   corresponding lower bounds subsumption instance
problems follow reduction given section   
   

fithe complexity circumscription dls

   circumscription fixed roles
preceeding sections  analyzed computational complexity reasoning
w r t  concept circumscribed kbs and  particular  established decidability  current
section  extend concept circumscribed kbs call role fixing ckbs  differ
former allowing role names fixed  but minimized   interestingly 
result seemingly harmless modification reasoning becomes highly undecidable 
start defining ckbs studied section 
definition    ckb circcp  t   a  cp      m  f  v   called role fixing contains role names 
 
pinpoint exact complexity reasoning role fixing ckbs  present reduction
logical consequence problem monadic second order logic binary relation symbols
 over unrestricted structures  trees  instance problem w r t  role fixing ckbs
formulated alc  follows latter problem harder problem definable
second order arithmetic thus outside analytical hierarchy  analogous results
satisfiability subsumption follow reductions given section    reduction
applies already case tbox preference relation empty 
finite set r binary relation symbols  denote mso r  set formulas
constructed countably infinite set p    p          variables sets  countable infinite
set x    x          individual variables  binary relation symbols r  using boolean
connectives  first order quantification  monadic second order quantification 
hard see reasoning role fixing ckbs corresponds reasoning tiny fragment mso r   specifically  consider standard translation alc concepts c
fo formulas  and thus mso r  formulas  c    x  one free individual variable x e g 
given borgida        take ckb circcp  t   a  cp      m  f  v      v    
   a   f    r   translate  t   a  mso r  sentence
 
 
 
 
x c    x  d   x  
c    xa  
r xa   xb   
cvdt

c a a

r a b a

xa individual variables 
alc concept c satisfiable w r t  circcp  t   a  if  if  mso r formula
xc    x  p  p a   p a    
satisfiable  p a  stands x  p  x  a   x  x  a   x p  x    p a   
denotes a  replaced p   translation easily extended case
arbitrary number concept names minimized arbitrary number concept
role names fixed varies 
prove logical consequence mso r  reducible instance problem w r t  role fixing ckbs  thus establish surprising result reasoning
skbs correspond tiny fragment mso r   hard
mso r   reduction indirect  instead directly reducing logical consequence
mso r   reduce semantic consequence problem modal logic exploit thomasons result logical consequence mso r  reduced latter problem  see
   

fibonatti  lutz    wolter

works thomason      b      a  survey articles wolter et al        
goldblatt        details 
first define semantic consequence problem modal logic  in framework
description logic  present thomasons result  starting notation 
let r finite set role names  r frame structure f    f   rf    f
non empty domain rf f f r r  interpretation    i    
based r frame f iff f   ri   rf r r  say concept c
valid f write f    c c   every interpretation based f  semantic
consequence modal logic defined follows  let c alc concepts
roles r  semantic consequence c  symbols c d  every
r frame f  f    c follows f    d  note since validity r frame f
involves quantification possible interpretations symbols contained r 
relation c invariant uniform renamings atomic concepts  this
used later on  
simplicity  consider mso r   monadic second order logic one binary
relation symbol r  straighforward extend result arbitrary finite sets r
relation symbols  given set role names r  alc concept called alc r  concept
uses role names r  following theorem follows
results thomason      b      a  
theorem    exist effective translation        mso r  sentences
alc  r   concepts alc  r   concept c  mso r  sentences  
following conditions equivalent 
logical consequence mso r  
c  u       
thus establish reduction mso r  instance problem w r t  role fixing
ckbs reducing instead semantic consequence problem  fact  reduction
implemented transparent way extend alc universal role  whereas
reduction alc requires number rather technical intermediate steps 
reason  defer alc case appendix give proof universal
role 
let u new role name  called universal role  every interpretation i  u
fixed interpretation ui     since interpretation u fixed anyway 
allow use circumscription patterns 
suppose c alc  r   concepts  establish reduction  construct role fixing ckb circcp     c   a    concept c  c if  if 
instance c  w r t  circcp     c   a     noted above  may assume c 
share concept names  otherwise  simply replace concept names fresh
ones   let concept name occur c d  let cp      m   r   v   
    consists set concept names c  v consists
concept names d  set     u c u 
b  a   

u

bm

lemma    following conditions equivalent 
   

fithe complexity circumscription dls

c d 
instance  u c  w r t  circcp    a  
proof  prove point   implies point    assume point   hold  let
model circcp    a  ai   u c  u d i   let based f  prove
point   hold  show f    c f     d  latter easy
witnessed interpretation i  show former  let j interpretation based
f  show c j     first note that  since model ai  u c i  
b     b   distinguish two cases 
b j     b   case  b interpretation
j   thus  since concept names c j based
frame  obtain c j   c    
b j      least one b   j  cp i  assume c j     
ai  u c j j model a  thus  derived contradiction
assumption model circcp    a  
prove point   implies point    assume point   hold  consider
frame f f    c  f     d  let interpretation based f
ai  d i   may assume b   b  since b occurs
d   ai   u c  u d i model a  remains show
exist    cp   model a  straightforward  f    c 
 
 
obtain exist   ai  u c i   moreover  clearly
 
 
 
exist   b   b b ai  u 
b i  


u

bm

thus proved logical consequence problem mso r  effectively reducible
instance problem w r t  role fixing ckbs formulated alc extended universal role  reduction  tbox preference relation empty  appendix 
show reduction modified prove result alc
without universal role 
theorem    logical consequence problem mso r  effectively reducible
instance problem w r t  role fixing ckbs formulated alc  even holds
tbox preference relation empty 

   circumscription minimized roles
unlike fixed concept names  fixed role names cannot simulated using minimized role
names  due fact boolean operators roles available standard
dls  thus  theorem    imply undecidability reasoning ckbs role
names allowed minimized  fixed  section  investigate ckbs
type  formal definition follows 
definition    ckb circcp  t   a  cp      m  f  v   called role minimizing f
contains role names 
 
   

fibonatti  lutz    wolter

show role minimizing ckbs behave rather differently concept circumscribed
kbs role fixing ckbs  first  turns reasoning role minimizing
ckbs empty tbox nexpnp  complete alcqo  undecidable alci 
thus  contrast circumscribed kbs considered far  observe difference
complexity alcqo alci  even alc alci  second
difference results obtained far nexpnp  lower bound  applies
ckbs formulated alc empty tbox  even holds role minimizing ckbs
single role minimized predicate fixed minimized  result
interest shows complexity drop npnexp number
minimized predicates constant  finally  show that  non empty tboxes  reasoning
role minimizing ckbs becomes undecidable already alc 
    role minimizing ckbs empty tbox alcqo
first prove nexpnp  completeness result discussed dls without inverse
roles  start upper bound  prove it  first establish bounded model
property using selective filtration style argument  see e g  blackburn et al         
difference bounded model property proof given concept circumscribed kbs
that  here  build quotient model given model identifying nodes using
equivalence relation  construct submodel given model selecting relevant nodes 
contrast forming quotient models  technique works empty tboxes since
tbox force us select infinitely many nodes  similarly  selection technique
work dls inverse role because  shall see below  inverse roles
used simulate tboxes 
recall role depth rd c  concept c defined nesting depth
constructors    k r d     k r d  c 
theorem    alcqo  satisfiability w r t  role minimizing ckbs empty tbox
nexpnp  
proof  let circcp    a  role minimizing ckb cp      m  f  v    let c 
concept satisfiable w r t  circcp    a   let m  maximal parameter occurring
number restrictions c    set
n    max  rd c      rd c    c a  a        m         a     c     n    
show exists model j circcp    a  satisfying c   j m 
let model circcp    a  exists d  c i     fix
minimal set d d  that 
every concept    k r c  occurs c     k r c i exist
least k distinct e d d   d  e  ri e c
every concept    k r c  occurs c       k r c i exist
least k     distinct e d d   d  e  ri e c  
clearly   d d   m         c       a     next  define set d 
setting
d      d     ai   ni occurs c    
   

fithe complexity circumscription dls

define sets di     n  inductively
 
di       
d d  
ddi

set n   



 in di  

define interpretation   domain follows 

 

ai   ai   individual names a 
 

r v    d  e  ri n   dn   e d d    d  e  ri  
 

v   ai   ai n  
 

f   ai   ai  
 

straightforward inductive argument shows   model d  c i  
 
note change interpretation f   moreover  pi pi
every p   together fact   model     cp i  even get
 
pi   pi every p   follows   model circcp    a  j  cp  
would imply j  cp i 
 
note ri n n   every role r  define interpretation j domain
j   n putting
 

aj   ai n   every concept name a 
 

rj   ri   every role name r 
aj   ai   every individual name c   
still j model satisfying c    moreover  interpretation j    cp j
satisfying easily extended interpretation     cp   satisfying a  hence 
interpretation exists j model circcp    a    n derive
 j m 
proof nexpnp  upper bound exactly proof theorem
    suffices replace bound   k size interpretations bound m 

give lower bound matching upper bound theorem    
theorem    alc  satisfiability w r t  role minimizing ckbs empty tbox nexpnp hard  holds even one minimized role name fixed prediates
proof  theorem     alc nexpnp  hard decide whether concept c 
satisfiable w r t  circcp    a   cp      m    v   contains concept names only 
clearly  still nexpnp  hard decide whether exists common model c 
circcp    a  size least  m   thus  sufficient provide polynomial reduction
problem satisfiability problem w r t  ckbs alc single minimized
role remaining predicates varying  suppose c  circcp    a  given  let
   a            ak   take
two fresh role names r    r   
   

fibonatti  lutz    wolter

boolean concepts c            ck built using fresh concept names b            bk
every ci   k  satisfiable every ci u cj      j  unsatisfiable  one take 
example  ci   b  u u bi  u bi u bi   u u bk   k 
let cp        r       v  b            bk   r     define a  c   result replacing 
c    every occurrence ai r   ci   k  finally  set   a   r   ci  a   
k   show following 
   c  satisfiable w r t  circcp    a  model size least  m if  if  c  
satisfiable w r t  circcp       
let model circcp    a  c  size least  m   define interpretation  
domain extending follows  take mutually distinct d            dk
interpret b            bk   r    r    way
 

cii    di    k 
 

r i     d  di     aii   k  
ai   d   
 

r i     d    d              d    dk    
readily checked   model c   circcp       
conversely  let model circcp       c     define interpretation  
 
extending aii    r   ci  i   k  readily checked   model c 
circcp    a  

    role minimizing ckbs nonempty tbox
bounded model property proof above  important selection nodes
stops n iterations set n   n maximum role depths
concepts abox concept c want satisfy  bound selection
nodes exist tbox non empty  show reasoning w r t 
role minimizing ckbs indeed undecidable case  proof reduction
 tiling problem  berger        

n n

definition    tiling problem quadruple triple p    t  h  v    finite
set tile types h  v horizontal vertical matching conditions 
solution p mapping  

n n

   i  j    i      j   h i  j   
   i  j    i  j       v i  j   
 
   

fithe complexity circumscription dls

let p    t  h  v   instance tiling problem  define tbox tp follows 
  v x   u y  
  v
  v



u

u



tt

tt

u

    
at 
 



    

t  t t  t



 t t   h


x at  u

u

tt





 t t   v

y at 



  v n  x y b u y x b 
n

v

    
    
    

w x d y d

    

v x d u y d

    

let cp      m    v   circumscription pattern v    b  d  consists
remaining concept role names 
lemma    circcp  tp         d a  iff p solution 
proof  assume p solution   define interpretation follows 

xi
yi
ait
ni
bi
di
ai

  
  
  
  
  
  
  
  

nn

   i  j    i      j     i  j   
   i  j    i  j         i  j   
  i  j     i  j    t 

  i  j        j     

      

straightforward verify model tp   additionally  clearly ai
  di  
thus remains show model j tp j  cp i  assume
j   since concept role names except b minimized  follows
   xi   xj   j j model      
   ait   aj
point   j model      
   n   n j because  matter b j is  point  
 x y b u y x b j    
thus j model       n   n j  
thus  j differ interpretation concept names b 
varying  contradiction j  cp i 
conversely  assume circcp  tp         d a   let model circcp  tp    
ai   di   induction   j  define mapping assigns  i  j 
element  i  j  i  j   

n n

   

fibonatti  lutz    wolter

     i  j    i      j   xi  
     i  j    i  j        
start  set          ai     th step  following 
select            d  put           d  exists
since model      
select            d  xi put           d  again 
exists since model      
let i  j       j      since model       d  d 
  i    j   d  xi   i  j     d      show   d   
set  i  j     d 
assume contrary    d             since ai
  di  

 i    j    n   define new interpretation j obtained
following modifications 
 i    j    removed n  
let d  b j   b j  
let dj    
clearly  j  cp i  obtain contradiction model circcp  tp     
thus remains show j model tp   suffices consider           
concept inclusions referring n   b  d  axioms           hold
dj     show       let e   show e c j c concept
right hand side       clearly  e c j since e c   e  x  y  x    reachable ai   e n e  x  y  x     reachable ai  
otherwise would ai di axioms            thus  e n j c j
e     i    j     finally   i    j    c j   definition b j  

n n

define mapping   setting  i  j      i  j         
mapping well defined        satisfies horizontal vertical matching conditions 
thus  p solution 

thus  shown following result 
theorem    alc  satisfiability w r t role minimizing ckbs undecidable 
    reasoning role minimizing ckbs empty tbox alci
prove undecidability reasoning role minimizing ckbs empty tbox alci 
proof uses spy point technique  areces  blackburn    marx         namely 
show aboxes simulate tbox reasoning employing inverse roles simulation
nominals circumscription  using idea proof rather similar proof
theorem    
   

fithe complexity circumscription dls

let p instance tiling problem consider ckb circcp  tp     defined
proof lemma     simulate tbox axioms c v c   abox assertions
  c c     u r    c c      a  enforcing role r  connect relevant points a 
achieved forcing relevant points domain satisfy r    a   since
nominals language use concept name instead  a  ensure
behaves nominal  present details 
sake readability  write concept assertions c a  form   c
set    r  c   c u r c  let a  b     n   fresh concept names r  fresh role
name occurring tp   ap consists assertions
     r     c c     

    

c v c   tp  
  a 

     r    

u s r

s x y




     r     n    a u b     r    a u b     u
     r     n   d  


   a 

    

s r

s x y


    a

u b    



  r   d

    

    

let cp      m     d  b  b       consists concept role names distinct
d  b  b    
lemma    circcp    ap       d a  iff p solution 
proof  assume p solution   take interpretation proof lemma   
expanded
ai            

n  i    

b  i    

r i     ai   d      

show model circcp    ap    clearly  model ap   thus remains
show model j ap j  cp i  assume exists j  cp
model ap   minimized       aj             follows axiom
     encoded                       xj                  j   one prove
induction       using axiom      encoded            i  j 
  j                i  j   r j   i  j    i      j   xj     i  j    i  j       j  
follows xj   xi j     observe n  j   because  matter
b   interpreted 

j

 a u b     r    a u b     u
s r    a u b    
   



s x y

one prove similarly proof lemma    j differ
interpretation b  b     d  contradiction 
conversely  suppose model circcp    ap   ai   di   first show
 ai   d  r i whenever    ai  x  y  reachable ai finite number
steps  assume case  exist d  d 
   

fibonatti  lutz    wolter

  ai  ai   d  r i  
 d  d    xi  d  d     
 a  d      r i  
      exists d   ai    d      d     d    r i   d   ai   observe
n  i      ai   di   define new interpretation j modifying follows 
removed n  i  
let ai b  j d     b  j  
let dj    
clearly j  cp i  obtain contradiction thus sufficient show j model
ap   clearly  assertion ap containing neither d  b     n   satisfied j  
remaining assertions except       follows dj   satisfied j  
finally        observe n  i  ai    e    ai   e  r i     di assertions
      thus  definition n  j   consider point removed n  i  

j

s r    a u b    
definition j  
 a u b     r    a u b     u



s x y

one use assertions      construct solution p way
proof lemma    

thus proved following result 
theorem    alci  satisfiability w r t  role minimizing ckbs empty tbox undecidable 

   related work
already pointed introduction circumscription one several
possible approaches nonmonotonic dls that  order achieve decidability 
approaches adopt suitable restriction expressive power dl
component  non monotonic features  interaction dl nonmonotonic features  section  survey existing approaches  discuss adopted
restrictions  relate dls circumscription whenever possible  however 
point full fledged formal comparison different approaches serious research endeavor outside scope paper  main approaches
nonmonotonic dls  excluding relying integration dls logic programming  summarized table    n a  stands analyzed specificity
column states whether formalism equipped priority mechanism based
specificity  i e   subsumption  concepts 
start two early approaches based circumscription  work brewka
        frame system given nonmonotonic semantics based circumscription 
focus showing appropriateness proposed semantics  decidability
complexity reasoning analyzed  cadoli et al          apply circumscription dl
   

fithe complexity circumscription dls

ref
 brewka       
 cadoli  donini   
schaerf       
 padgham   zhang 
     
 straccia       
 baader   hollunder      a 
 baader   hollunder      b 
 lambrix 
shahmehri    wahlloef 
     
 donini et al        

dl
frame lang 
  ale

nm features
circ
circ

complexity
n a 
p 

specificity

n

al concrete domains
alc

inheritance
networks
prioritized
default logic
default logic

n a 



decidable



decidable

n

prioritized
default logic
prioritized
default logic

decidable



n a 



mknf
restrictions
mknf
restrictions
maximized
typicality

depends dl

n

  exptime

n

co nexpnp

n

alcf
alc
alqo feature
agreement
decidable dl

 donini et al        

alc

 giordano  gliozzi 
olivetti    pozzato 
     

alc

table    approaches nonmonotonic dls

way here  authors consider non prioritized circumscription
apply fragment description logic ale  decidability reasoning shown
reduction propositional reasoning extended closed world assumption
 ecwa   p    best knowledge  first effective reasoning
method nonmonotonic description logic 
another early approach padgham zhang         nonmonotonic dl obtained adaptation inheritance networks approach  horty       
underlying dl essentially al extended concrete data values  main contribution definition formalism discussion applications  decidability
complexity analyzed 
recent approach similar spirit circumscription taken giordano
et al          authors extend alc modal operator representing typicality 
maximize extension achieve nonmonotonic inferences  decidability proved via
tableau algorithm establishes co nexpnp upper bound subsumption 
lower bound given 
turn approaches based default logic  reiter         nonmonotonic
dls baader hollunder      a      b   straccia         lambrix et al        
share common restriction  default rules applied individual
name  is  denoted individual constant occurs explicitly
knowledge base  restriction motivated observation that  defaults
applied implicit  anonymous  individuals  reasoning becomes undecidable  baader  
   

fibonatti  lutz    wolter

hollunder      a   since models dl knowledge bases usually include large number
anonymous individuals due existential quantification  restriction introduces
strong asymmetry treatment individuals 
another line nonmonotonic dls  donini et al                     based first order
autoepistemic logics whose interpretation domains restricted fixed denumerable
set constants  use unique domain resolves several issues related quantification
modal logics  such whether barcan formula hold  whether different
worlds kripke structure allowed different domains  
avoids asymmetry approaches based default logic because  definition 
individuals name  side coin domains finite varying
cardinality knowledge bases satisfy unique name assumption
dealt using rather technical encodings  such explicit axiomatization
finite domain represented concept name d  
first paper mentioned  donini et al          decidability results apply
monotonic knowledge bases  autoepistemic operator used nonmonotonic
fashion queries  restriction lifted subsequent publications 
make use logic minimal knowledge negation failure  mknf  
equipped two  auto epistemic operators k  donini et al               
former paper  donini et al          underlying monotonic fragment
description logic decidable instance checking problem  price payed
generality decidability results apply so called simple knowledge bases 
quantifying in  that is  quantification across modal operators  r k c  allowed 
nonetheless  kbs expressive enough model default rules  different restriction
explored donini et al          underlying dl restricted alc limited forms
quantifying in allowed  so called subjectively quantified alckn f knowledge bases 
decidability results obtained subclass simple subjectively quantified knowledge
bases  whose nonmonotonic part restricted inclusions form kc v
  v c inferred knowledge base  restriction incompatible
traditional embedding  priority free  circumscription autoepistemic logic 
based prerequisite free default rules would equivalent inclusions
form k  v c 
recent line research integrating dls logic programming rules introduces
nonmonotonic extensions dls based negation as failure  approaches
 eiter et al         use loosely coupled integration logic programs dls 
interpretations dl component restricted logic program variables
range named dl individuals  thus  approaches somewhat similar
classical extensions dls based defaults nonmonotonic inferences
limited named individuals  recent approach  motik   rosati        based
mknf shares mknf dls discussed pros cons adopting fixed
denumerable domain  complexity reasoning underlying dl c   np 
data complexity entailment bounded c c   finally  mention   valued variant
approach  knorr  alferes    hitzler        based well founded semantics 
   autoepistemic operator used restricted contexts suffice encode so called
procedural rules  monotonic 

   

fithe complexity circumscription dls

alc

concept circ 
minim  roles
fixed roles

 m n   f n
 unrestricted 
tbox 
tbox  

alcqo
alci alcio
nexp
np
nexpnp even     either tbox  abox 
nexpnp even  m     f  
undecidable
undecidable
highly undecidable  even tbox     

table    summary complexity results satisfiability w r t  ckbs
common limitation nonmonotonic extensions dls based mknf
provide support specificity priorities  particular  defeasible inheritance
mentioned expressiveness analysis autoepistemic approaches  donini et al  
            appear goal mknf based approach  pointed
introduction  well known that  propositional case  nonmonotonic logics
cannot modularly encode specificity based priorities needed inheritance
mechanisms  horty        

   conclusions perspectives
shown circumscription provides elegant approach defining nonmonotonic
dls  resulting formalisms appealing expressive power decidable
appropriate restrictions adopted  main restriction  leads rather
robust decidability results  concept names minimized fixed whereas
role names vary  empty tboxes  decidability retained roles allowed
minimized  fixed  decidability complexity results obtained
paper listed detail table    results section    bounds
tbox    apply general acyclic tboxes 
view paper promising step towards establishing circumscribed dls
major family nonmonotonic dls used practical applications  reach goal 
additional research topics addressed  mention two  first 
algorithms presented paper based massive non deterministic guessing
thus admit efficient implementation  ideally  one would algorithms
well behaved extensions tableau algorithms underly state of the art
dl reasoners  baader   sattler         crucial issue whether sophisticated optimization techniques implemented reasoners  tableaux caching  dependency directed
backtracking etc   cf  baader et al         chap     adapted circumscribed dls 
first steps made grimm hitzler         second  seems necessary
develop design methodology modelling defeasible inheritance  examples given
paper indicate main challenge find rules thumb determine
predicates fixed  varied  minimized  may appealing hide abnormality
predicates behind explicit syntax defeasible inclusions  trade generality
simplicity usability 
theoretical perspective  initial investigation leave open least
interesting questions  example  current techniques limited circumscribed dls
   

fibonatti  lutz    wolter

finite model property  would desirable overcome limitation
obtain decidability results even expressive dls shiq owl 
possible follow opposite approach consider circumscribed versions inexpressive
dls el dl lite family  baader  brandt    lutz      a  calvanese 
giacomo  lembo  lenzerini    rosati         currently popular large
number applications  first steps made bonatti  faella  sauro        
investigated circumscribed versions el dl lite 
finally  worth mentioning complexity results circumscription
used prove complexity bounds other  seemingly unrelated  reasoning problems
description logic  example  certain reasoning services conservative extensions
modularity description logic satisfiability problem w r t  concept circumscribed
knowledge bases mutually reducible polynomial time  konev  lutz 
walther    wolter         many problems known nexpnp complete  circumscription thus provides new class problems potentially
employed give nexpnp lower bound proofs 

acknowledgments
first author partially supported network excellence rewerse  ist             third author partially supported uk epsrc grant no  gr s         

appendix a  missing proofs section  
lemma    alc  satisfiability w r t   concept  circumscribed kbs empty tbox
without fixed roles polynomially reduced satisfiability w r t   concept  circumscribed kbs empty tbox without fixed predicates 
proof  proof lemma    used tbox axioms state fresh
concept names interpreted complement fixed concept names  general 
cannot done using abox assertions only  instead  construct abox assertions
force case objects relevant truth given abox 
care required using abox assertions polynomial size  first part
proof deals problem  second part straighforward modification
proof lemma   
first part proof consists introducing notation proving central
technical claim  w   r  rn nr   interpretation i  d  e   write

 d  e  wi iff d            dn   d    e   dn    di   di     ri  

  n 
let n set individual names paths mapping n powerset nr  
interpretation well behaved mapping paths every  
n w paths a   ai   d  wi   alc concept c  associate
set p c  pairs  w  d  w nr subconcept c follows 
c nc   p c        c   
c   d  p c        c   p d  
   

fithe complexity circumscription dls

c   d  u d  c   d  d    p c        c   p d    p d    
c   r d c   r d  p c        c     rw  e     w  e  p d   
set abox assertions individual name a  use p s  a  denote set

c a s p c   write paths s  a   w      w  d  p s  a    formulate
announced claim 
claim    suppose circcp    a      c   a     cp contain fixed role names
c   a  formulated alc  let    c   a     let n set individual
names s  let   restriction that  n
w paths s  a    ai   d  wi     model circcp    a 
c   a    well behaved mapping paths a    paths s  a   n  
prove claim  let model circcp    a  ai   c   i   note
 
n   paths s  a  thus ai   clearly    well behaved
paths  one prove induction c
 

   n    w  c  p s  a    ai   d  wi   c iff
 
ci  
show case c   r d  leave cases reader  let c  
e di  d  e  ri   since  w  c  p s  a    wr  d  p s  a  
 
since  ai   d  wi    ai   e   wr i   thus  e induction hypothesis
 
 
 
yields e di   definition   semantics  c   let c  
 
 
e di  d  e  ri   definition      d  e  ri   since  w  c  p s  a  
 wr  d  p s  a   since  ai   d  wi    ai   e   wr i   thus  induction
hypothesis yields e di  
thus     established  using    facts ai   c   i model
 
 
a  hard verify ai   c   i   model a  show
  model circcp    a   assume contrary model j  
j    cp     define interpretation j follows 
j    
aj   ai f  
 

aj   aj v  
 

rj   rj r nc  
bj   bi b ni  
using assumption cp contain fixed role names  hard verify
j  cp i  obtain contradiction fact model circcp    a  
thus remains show j model a  end  prove induction c
 

   n    w  c  p s  a   j  aj   d  wj   c j iff
 
cj  
since induction step proof     induction start  thus  let
c   nc   v   done definition j   let f   since  
   

fibonatti  lutz    wolter

 

 

 

 

restriction aj   ai   definition j yields aj j   aj   required 
finishes proof claim 
prove lemma    consider instance checking instead satisfiability  since
provided polynomial reductions satisfiability  non  instance checking vice
versa section    nevertheless obtain desired result  let circcp    a  ckb
cp      m  f  v   f    a            ak    take concept assertion c   a     let
   c   a     n set individual names s  define
     a            ak   a             a k    a i fresh concept names 
a     w  a i ai   a    w paths s  a   n   k  
cp             v   
circcp    a     c   a    iff circcp     a       c   a    follows immediately claim  
fact paths s  a    paths s     a       a  c   a    

lemma   c  satisfiable w r t  circcp  t   a  iff c  u b   satisfiable w r t  circcp   t     a  
proof  suppose model c  circcp  t   a   expand interpretation  
setting
 
 
 
 
 
ai   b  i     b   a i     ui    
clearly    model c  u b    t     a   show   model circcp   t     a  
assume contrary model j  t     a  j  cp      a j    
aj     b j     b   j     since u varying j  cp      thus easy
show j  cp i  contradicts fact model circcp  t   a  
conversely  suppose model c  u b   circcp   t     a   show
model c  circcp  t   a   first observe ai     suppose
case  define new interpretation j way except uj    
b j     b  j     j  cp   since b  i      j model  t     a   thus
derived contradiction  follows c   hence model  t   a 
c    remains show j  cp j model  t   a  
assume j exists  c j     define model j   expanding j follows 
 

 

aj   b  j    

 

 

b j   a j    

 

uj    

note a  b  a    b     u interpreted way  j    cp  i 
moreover  j   model  t     a   derived contradiction 

lemma   l dl  simultaneous satisfiability w r t   concept  circumscribed kbs
circcp   t    a           circcpk  tk   ak    circcpi  ti   ai   circcpj  tj   aj   share
role names     j k  reduced satisfiability w r t  single  concept 
circumscribed kbs polynomial time 
proof  suffices reduce simultaneous satisfiability without shared role names complement instance checking w r t  single ckbs  generalization straightforward 
give proof case k      thus  let l dl circcp   t    a     circcp   t    a   
   

fithe complexity circumscription dls

ckbs formulated l share role names  c  l concept  moreover  let
a            an  concept names shared two ckbs  r role names used
least one two ckbs together fresh role name r    cpi    i   mi     vi  
        obtain new tbox t   t  replacing concept name ai     n 
new concept name a i   let a   obtained a  cp           m     f     v    
cp  way  define tbox follows  p fresh concept name 
ai u a i v p   n
ai u a i v p   n
p
r p

v r p r r
v p r r

set 


   t  t  

   a  a    r   b    b      b    b  occur a  a  t  t   
       


   m  m  

f

   f  f  

v

   v  v    p  r   

cp       m  f  v  
let a  individual name a   clearly  may assume a        remains
show following 
claim  c  simultaneously satisfiable w r t  circcp   t    a    circcp   t    a    iff a 
instance  p u r   c    w r t  circcp  t   a  
if  assume a  instance  p u r   c    w r t  circcp  t   a  
model circscp  t   a  ai   p u r   c   i   call connected directed
graph gi    i   rr ri  r  i   connected  connected component  
 
 
restriction domain  maximal  connected component gi  
may assume without loss generality chosen model connected 
not  use role r  ensures connected component  
contains bi individual names b a  a  t  t    easy see  
 
 
model circcp  t   a  ai   p u r   c   i   thus may simply replace    
show c  simultaneously satisfiable respect circcp   t    a   
circcp   t    a     clearly  model c    construction circcp  t   a  
model t    a    show model circcp   t    a     assume
contrary case  exists model j t  a 
j  cp  i  define model j   follows 
 

j   j  
predicates used t  a  interpreted j  
predicates used t   a   interpreted i 
   

fibonatti  lutz    wolter

 
p

j 

  

 



  ai u a i    ai u a i   j      n



otherwise

 

 

r j   j j  
readily checked j   model a  j    cp i  thus 
derived contradiction fact model circcp  t   a   follows
model circcp  t    a    
remains show model circcp  t    a     since connected  model
  satisfies ai 
  p   aii    a i  i   n  therefore 
model t  a    analogously case circcp   t    a     show
model circcp   t    a    
if  assume c  simultaneously satisfiable w r t  ckbs circcp   t    a   
circcp   t    a     exists model c  model circcp   t    a   
circcp   t    a     modify new model   setting
 

 a i  i    aii   n 
 

p     
 

r i     
 

 

easy see   model a  ai  p u r   c   i   show
a  instance  p u r   c    w r t  circcp  t   a   thus remains prove
  model circcp  t   a   this  first show following 
 a    model circcp   t    a     case since model j t  a 
j  cp    satisfies j  cp  i  thus  existence model contradicts
fact model circcp   t    a    
 b    model circcp    t     a      assume contrary model j t  

    a i  j
a   j  cp       convert j interpretation j setting aj



  n  then  j model t  a  satisfies j  cp  i 
contradiction fact model circcp   t    a    
now  assume contrary shown model j  
j    cp     definition cp  j    cp   implies either j    cp   
j    cp     hold  since j   clearly satisfies t    a    t     a     obtain contradiction
 a   b  


appendix b  missing proofs section  
lemma    g yes instance co  certcols iff cg satisfiable w r t  circcpg    ag   
cpg      m  f  v          root  leaf  clash  
f    leaffix  tr  x            xn    y            yn      
v set remaining predicates ag  
   

fithe complexity circumscription dls

proof  if  suppose cg satisfiable w r t  circcpg    ag   let model
     show g yes instance co cert col  
circcpg    ag   cg

start  show
i 
 i  ai  cg
   ai  
assume contrary case  cg
 
  rooti   let j interpretation obtained setting
since cg
rootj    ai     definition ag   ai  rooti   thus j cpg i  moreover 
easily seen j model ag   thus established contradiction
fact model circcpg    ag    proves  i  
lines          fig      elements di w  the nodes tree   n
w       i

ai    d    
di w xji iff j     st bit w     n j min i  n    
di w yji iff n   j     st bit w    i  j n    n j n 
 di w   di   w      di w   di   w    ri      n 
d n w leaf   w        n  
i  j    n   use  i j denote element d n w w        n denotes
binary encoding followed j  show
 ii  leaf     i j   i  j    n   
assume contrary case  i e   leaf
    i j i  j    n   let id   jd     integers truth values x            xn 
encode id truth values y            yn  encode jd   starting i  construct
interpretation j setting
leaf j
rj

   leaf    d 
    ri    i d     e   id  jd      e  d  ri  

modify j j   setting
pj

 

    r n  var  leaf j
 r n  var  leaf j
 r n  col  leaf j
 r n  col  leaf j

going lines           straightforward check j   model ag  
moreover  clearly j    cpg i  thus obtain contradiction fact
model circcpg    ag    thus shown  ii  
following easy consequence  i   fact p conjunct cg  
lines                      
 iii    i j   d  ri implies leaf i  j    n     r  var   var   col   col   
   

fibonatti  lutz    wolter

suppose contrary aim prove g yes instance  then 
truth assignments t  subgraph t g    colorable  particular  holds
assignment defined setting  i  j    n  

t vij        iff  i j tri  

let c                n     r  g  b    coloring t g  construct interpretation
j starting applying following modifications 

cj
clashj

    i        n   c i    c  c  r  g  b 
   

clearly  j  cpg i  minimized predicate clash empty j   non empty since
non empty  obtain contradiction  thus suffices show j model
cg
ag  
since j agree predicates r  g  b  clash  inclusions
mention concepts satisfied j   lines           lines          
 n j
satisfied construction j since  due line      ii    aj
    d   r  
n
implies    i j i  j       thus remains consider lines            first
show
 iv  i  j    n    i  j  edge t g  iff  i j
  elimj  
let i  j    n let potential edge  i  j  labeled vk   k  vk   k   since
 i 
 i 
circuits cs cj deliver output input  assume potential 
non existing edges label    ii   iii  together lines         
var j   var i     k   k    var j   var i     k   k     thus  definition together
lines           yields  i  j  edge t g  iff  i j
  elimi   prove  iv  
remains note j interpret concept name elim way 
 n j
now  prove           satisfied j   let  aj
    d   r     line  
j
n
 ii      i j i  j       let  i j
  elim    iv  since c   coloring
t g   get c i     c j   thus  construction j    i  
  c j  j  
  c j
c  r  g  b    ii   iii  together lines            col j   col i     i    
col j   col i     j      therefore   i j
   col  c u col  c j c  r  g  b  
j
since holds  i j
  elim   preconditions implications lines     
     never satisfied  thus  implications satisfied 

if  suppose g yes instance let truth assignment
t g    colorable  let c                n     r  g  b  color assignment
minimizes  w r t  set inclusion  set   i  j     i  j  edge g c i    c j    define
interpretation follows  here following  distinguish
number binary encoding string  
   

fithe complexity circumscription dls


rooti

   di w    n   w       i  
   d    



   d n w   w        n  

leaffixi

   d n w   w        n  

leaf

xji

   di w   j     st bit w     n  j min i  n     

yji


   di w   n   j     st bit w    n    n  j n  

tr

   d n ij   t vij       

tri 

   d n ij   t vij   cs  i  j  

   

          

elim



   d n ij    i  j  edge t g  

c



   d n i    c i    c   c   r  g  b 



   d n ij    i  j  edge t g  c i    c j  

r



    di w   di   w      di w   di   w         n 

var 



    d n ij   d n kl     first variable label  i  j  vkl  

var 



    d n ij   d n kl     second variable label  i  j  vkl  



col 

    d n ij   d n i         n  

col i

    d n ij   d n j         n  

clash

pi

 

ai 

  d    

boolean circuit c  corresponding output concept name outc interpreted
outic     d n ij   i  j    n c i  j  true  

show cg satisfiable w r t  circcpg    ag    suffices show ai  cg
model circcpg    ag    former easy  recall cg   rootup ur n  clash 
definition i  ai   root u p  i   since c   coloring  ai   r n  clash i  
thus remains show model circcpg    ag    since easy verify
model ag   boils showing model j ag j  cpg i 
assume contrary j   lines        since j model
ag    leaf j   n   since  leaf     n j  cpg i  get leaf j   leaf  
similar simpler reasons  rootj   rooti   thus  j  cpg implies clashj   clashi  
lines         since j models ag leaf j   leaf  leaf  
 leaf j     n  

j
 n j
 i   d    ai    d   r n  i      d j    aj
    d   r       leaf   leaf

thus  lines           fact j model ag ensure

 ii  c r g b   leaf u elim u col  c u col  c j clashj  
define coloring c  setting
c   i    c iff d n i  c j
suppose
   

 c   r  g  b  

fibonatti  lutz    wolter

 iii   a  elimi leaf   elimj leaf  
 b  col i  leaf leaf     col j  leaf j leaf j   
 c  col i  leaf leaf     col j  leaf j leaf j   
 ii  guarantees  i  j  edge g c   i    c   j   d n ij clashj  
since clashj   clashi   get
   c   i    c   j   c i    c j  
   i  j c   i     c   j   c i    c j  
contradicts initial minimality assumption coloring c 
thus remains prove  iii   start  a   assume
 d  var i  leaf leaf     var j  leaf j leaf j  
 e  var i  leaf leaf     var j  leaf j leaf j   
then  lines           together  i  fact tri   trj implies  a   thus
remains prove  b   e   concentrate  b  cases analogous  take
 d  d    col i  leaf leaf      d n ij d    d n i  j   i  j  i    j      n  
line       i    j         i  lines           since j
agree interpretation x            xn    y            yn    e leaffixj
 d n ij   e  col j   value encoded x            xn  e j i  value
encoded y            yn  e j    since leaffixi   leaffixj   leaffixj  
leaf j   however  single element leaf j x            xn  encodes
y            yn  encodes   d n i    d    converse direction analogous 

corollary    alc  satisfiability w r t  concept circumscribed kbs nexpnp  hard
even tbox acyclic  abox preference relations empty 
fixed predicates 
proof  abox ag reduction given section       form  c   a    
circumscription pattern cpg empty preference relation  thus suffices
show polynomial reduction satisfiability w r t  concept circumscribed kbs
form satisfiability w r t  concept circumscribed kbs acyclic tbox  empty
abox preference relation  fixed predicates 
let circcp    a  concept circumscribed kb    c   a     cp    
  m  v  f       let c alc concept  define    a v u c    
concept name occur c u role name
occur c  define cp       m  v  u   f  a    c satisfiable w r t 
circcp    a  iff u c satisfiable w r t  circcp   t     
if  u c satisfiable w r t  circcp   t      model circcp   t    
d   a u c i   thus  e  c i   modify obtain new interpretation
j setting aj
    e    clearly  j model c  show model
circcp    a   assume contrary model j   j    cp j   modify
 
 
j   interpretation   setting ai   ai ui     readily checked
  model    cp  i  thus obtained contradiction fact
model circcp   t     
   

fithe complexity circumscription dls

if  c satisfiable w r t  circcp    a   model circcp    a 
d  c   let j defined i  except aj    d    uj     clearly 
j model u c  show j model circcp  t      assume
 
contrary model j   j    cp  j   since fixed cp    d  ai  
 
 
thus d   u c   j e  c j   modify j   new interpretation  
 
setting ai    e    readily checked   model    cp i  thus
obtained contradiction fact model circcp     a   get rid fixed
predicates  suffices apply lemma   


appendix c  missing proofs section  
show semantic consequence problem reduced instance checking
w r t  role fixing ckbs alc  already proved alc extended
universal role  fact  remaining problem approximate concepts u c using alc concepts state extension c contains points within certain 
sufficiently large neighbourhood 
construct approximation  first introduce local version notion
frame validity concepts  pointed r frame pair  f  d  f f
r frame  concept c valid pointed r frame  f  d   symbols  f  d     c  iff
c every interpretation based f  r finite set role names 
r c denotes c     

n

m  r c u

u r 

m 

rr

r c

     follows  use concepts form r c approximations
u c  remind reader correspondence results modal logic  let transa  
s a s s a conta   s a r a  well known  blackburn   van
benthem        easy prove every  r  s  frame f  following holds 
transa valid f if  if  sf transitive 
conta valid f if  if  rf sf  
say d  f  r  s  reachable f  d  d     rf sf   call f
root f every d  f  r  s  reachable f  f  r  s  frame root
d  following conditions equivalent 
   r  s   transa u conta   valid  f  d  
sf transitive rf sf  
observations used proof lemma    below  before  sometimes write
concept assertions c a  form   c  recall role depth rd c  concept c
defined nesting depth constructors r d r d  r r  c 
lemma    let c alc  r   concepts sharing concept names let
fresh concept name  let cp      m   r  s   v   circumscription pattern 
consists concept names c v consists concept names d  let
individual name  following conditions equivalent 
   

fibonatti  lutz    wolter

    r  s  frames f rf sf sf transitive  f    c  f    d 
   pointed  r  s  frames  f  d  
 f  d        r  s   transa u conta u c 



 f  d    

   instance    r  s   transa u conta u c  w r t  circcp    a  
   a       r  s   transa u conta u c    max    rd c    r  s  

u b   

bm

proof  point   implies point    suppose point   hold  let  f  d  pointed
 r  s  frame  f  d        r  s   transa u conta u c   f  d      d  may
assume root f   f  d        r  s   transa u conta   obtain rf sf
sf transitive  therefore   f  d        s  c obtain f    c  follows f
frame refuting point   
follows use  every   d i denote set e
 r  s  reachable     max     rd c   steps 
point   implies point    suppose point   hold  let model circcp    a 

ai     r  s   transa u conta u c  u d i  

    

let based f set    ai   show  f  d        r  s   transa u conta u c 
 f  d      d  latter easy witnessed interpretation i  show former 
let j interpretation based f  show     r  s   transa u conta u c  j  
     since model circcp    a   ai    max    rd c    r  s  
b i  

u

bm

follows immediately
b   d i  

    

b   distinguish two cases 
b j d i   b   since j based frame concept
names conta   transa   c   truth    r  s   transa u conta u c 
depends truth value concept names d i only      
obtain b d i   b j d i   b   hence            r  s   transa u
conta u c  j   required 
b j   d i   least one b  
 

let j   modification j b j   b j d i   b         j    cp
 
i      r  s   transa u conta u c  j   j   model
contradiction fact model circcp    a   thus      r  s   transa u
 
conta u c  j   since  again  truth    r  s   transa u conta u c  depends
truth value b d i only      r  s   transa u conta u c  j  
required 
   

fithe complexity circumscription dls

point   implies point    suppose point   hold  consider frame f sf
transitive  rf sf   f    c  f     d  follows f    transa u conta   let
interpretation based f  d i   may assume root f 
may assume b   d i b  since b occurs d  ai   d 
ai     r  s   transa u conta u c  u d  i model a  remains show
exist    cp
 

ai     r  s   transa u conta u c    max    rd c    r  s  

u b 

i 

bm

 

straightforward   f  d        r  s  c  obtain exist
 
 
      r  s  c i clearly exist b b b
 
   max    rd c    r  s  b i  

position prove reduction alc 
theorem    logical consequence problem mso r  effectively reducible
instance problem w r t  role fixing ckbs formulated alc  even holds
tbox preference relation empty 
proof  theorem     logical consequence problem mso r  effectively reducible
modal consequence problem alc  r   concepts  hence  suffices reduce
modal consequence problem alc  r   concepts  let alc  r   concepts c given 
may assume c concept names common  if have  replace
every concept name b new concept name b   denote resulting concept
d    noted above  c iff c d     let cp      m   s  r   v      
consists concept names c  v consists concept names d  let
   a       r  s   transa u conta u c    max    rd c    r  s  

u b  

bm

c       r  s   transa u conta u c  d  equivalence point   point  
lemma     circcp    a     c   a  if  if  frames f rf sf sf
transitive  f    c follows f    d  c contain s 
circcp    a     c   a 



c d 


references
areces  c   blackburn  p     marx  m          road map complexity hybrid logics 
proceedings eighth annual conference eacsl  csl     no      
lecture notes computer science  pp          springer verlag 
areces  c   blackburn  p     marx  m          computational complexity hybrid
temporal logics  logic journal igpl                
baader  f   brandt  s     lutz  c       a   pushing el envelope  kaelbling  l  p  
  saffiotti  a   eds    proceedings nineteenth international joint conference
artificial intelligence  ijcai     pp          professional book center 
   

fibonatti  lutz    wolter

baader  f   milicic  m   lutz  c   sattler  u     wolter  f       b   integrating description logics action formalisms reasoning web services  ltcsreport ltcs        chair automata theory  institute theoretical computer science  dresden university technology  germany  see http   lat inf tudresden de research reports html 
baader  f     hollunder  b       a   embedding defaults terminological knowledge
representation formalisms   journal automated reasoning                 
baader  f     hollunder  b       b   priorities defaults prerequisites  application treating specificity terminological default logic   journal automated
reasoning               
baader  f   mcguiness  d  l   nardi  d     patel schneider  p          description
logic handbook  theory  implementation applications  cambridge university
press 
baader  f     sattler  u          tableau algorithms description logics  dyckhoff 
r   ed    proceedings international conference automated reasoning
tableaux related methods  tableaux       vol       lecture notes artificial
intelligence  pp       springer verlag 
berger  r          undecidability dominoe problem  memoirs american
mathematical society     
blackburn  p     van benthem  j          modal logic  semantic perspective  handbook
modal logic  elsevier 
blackburn  p   de rijke  m     venema  y          modal logic  cambridge university
press 
bonatti  p   faella  m     sauro  l          defeasible inclusions low complexity dls 
preliminary notes  proceedings   st international joint conference artificial intelligence  ijcai     aaai press 
bonatti  p   lutz  c     wolter  f          expressive non monotonic description logics
based circumscription  proceedings tenth international conference
principles knowledge representation reasoning  kr     pp          aaai
press 
bonatti  p  a     eiter  t          querying disjunctive databases nonmonotonic
logics   theoretical computer science                    
bonatti  p  a     samarati  p          logics authorization security  logics
emerging applications databases  pp          springer verlag 
borgida  a          relative expressiveness description logics predicate logics 
artificial intelligence                     
brewka  g          logic inheritance frame systems  proceedings   th
international joint conference artificial intelligence  ijcai     pp          morgan kaufmann 
   

fithe complexity circumscription dls

brewka  g          adding priorities specificity default logic   proceedings
logics artificial intelligence  jelia     vol      lecture notes computer
science  pp          springer verlag 
cadoli  m   donini  f     schaerf  m          closed world reasoning hybrid systems 
proceedings  th international symposium methodologies intelligent
systems  ismis     pp          elsevier 
calvanese  d   giacomo  g  d   lembo  d   lenzerini  m     rosati  r          tractable
reasoning efficient query answering description logics  dl lite family  journal automated reasoning                 
cote  r   rothwell  d   palotay  j   beckett  r     brochu  l          systematized
nomenclature human veterinary medicine  tech  rep   snomed international 
northfield  il  college american pathologists 
de kleer  j     konolige  k          eliminating fixed predicates circumscription 
artificial intelligence                 
donini  f  m   lenzerini  m   nardi  d   nutt  w     schaerf  a          epistemic
operator description logics   artificial intelligence                    
donini  f  m   nardi  d     rosati  r          autoepistemic description logics  proceedings fifteenth international joint conference artificial intelligence  ijcai     pp          morgan kaufmann 
donini  f  m   nardi  d     rosati  r          description logics minimal knowledge
negation failure  acm transactions computational logic                
eiter  t   gottlob  g     mannila  h          disjunctive datalog  acm transactions
database systems                 
eiter  t   lukasiewicz  t   schindlauer  r     tompits  h          combining answer set
programming description logics semantic web  proceedings
ninth international conference principles knowledge representation
reasoning  kr        pp         
giordano  l   gliozzi  v   olivetti  n     pozzato  g  l          reasoning typicality
preferential description logics  proceedings logics artificial intelligence
 jelia     vol       lecture notes computer science  pp          springerverlag 
goldblatt  r          mathematical modal logic  view evolution  journal applied
logic            
gradel  e   otto  m     rosen  e          two variable logic counting decidable 
proceedings twelfth ieee symposium logic computer science  lics    
pp          ieee computer society press 
grimm  s     hitzler  p          defeasible inference circumscriptive owl ontologies 
proceedings workshop advancing reasoning web  scalability
commonsense  no      ceur ws  http   ceur ws org   
horrocks  i   sattler  u     tobies  s          practical reasoning expressive description logics  logic journal igpl                
   

fibonatti  lutz    wolter

horty  j  f          direct theories nonmonotonoc inheritance  handbook
logic artificial intelligence logic programming nonmonotonic reasoning
uncertain reasoning volume     pp          clarendon press 
janhunen  t          intertranslatability non monotonic logics  annals mathematics artificial intelligence                  
kagal  l   finin  t     joshi  a          policy language pervasive computing
environment  fourth ieee international workshop policies distributed
systems networks  policy      
knorr  m   alferes  j  j     hitzler  p          well founded semantics hybrid mknf
knowledge bases  proceedings      international workshop description
logics  dl       no      ceur ws  http   ceur ws org   
konev  b   lutz  c   walther  d     wolter  f          semantic modularity module extraction description logics  proceedings   th european conference
artificial intelligence  ecai   pp       
lambrix  p   shahmehri  n     wahlloef  n          default extension description
logics use intelligent search engine    proceedings thirty first
annual hawaii international conference system sciences  hicss    volume   
p        ieee computer society 
lifschitz  v          computing circumscription  proceedings ninth international joint conference artificial intelligence  ijcai     pp          morgan
kaufmann 
lifschitz  v          circumscription  handbook logic ai logic programming    pp          oxford university press 
lifschitz  v          nested abnormality theories  artificial intelligence                 
mccarthy  j          circumscription  form nonmonotonic reasoning  artificial intelligence           
mccarthy  j          applications circumscription formalizing common sense knowledge  artificial intelligence            
minsky  m          framework representating knowledge  winston  p  h   ed   
psychology computer vision  pp          mcgraw hill 
moore  r  c          semantical considerations nonmonotonic logics  artificial intelligence           
motik  b     rosati  r          faithful integration description logics logic
programming  proceedings twentieth international joint conference
artificial intelligence  ijcai       pp          morgan kaufmann 
pacholski  l   szwast  w     tendera  l          complexity results first order twovariable logic counting  siam journal computing                   
padgham  l     zhang  t          terminological logic defaults  definition
application  proceedings thirteenth international joint conference
artificial intelligence  ijcai     pp          morgan kaufmann 
   

fithe complexity circumscription dls

pratt hartmann  i          complexity two variable fragment counting quantifiers  journal logic  language  information                 
quillian  m  r          semantic memory  semantic information processing  pp         
mit press 
rector  a          defaults  context  knowledge  alternatives owl indexed knowledge bases  proceedings pacific symposium biocomputing  psb     pp 
        world scientific 
rector  a     horrocks  i          experience building large  re usable medical ontology
using description logic transitivity concept inclusions  proceedings
workshop ontological engineering  aaai spring symposium  aaai press 
reiter  r          logic default reasoning  artificial intelligence            
stevens  r   aranguren  m  e   wolstencroft  k   sattler  u   drummond  n   horridge 
m     rector  a          using owl model biological knowledge  international
journal man machine studies                 
stewart  i  a          complete problems involving boolean labelled structures projection transactions  journal logic computation                
straccia  u          default inheritance reasoning hybrid kl one style logics  
proceedings thirteenth international joint conference artificial intelligence
 ijcai     pp          morgan kaufmann 
thomason  s       a   logical consequence relation propositional tense logic 
zeitschrift fur mathematische logik und grundlagen der mathematik           
thomason  s       b   reduction second order logic modal logic  zeitschrift fur
mathematische logik und grundlagen der mathematik             
tobies  s          complexity reasoning cardinality restrictions nominals
expressive description logics  journal artificial intelligence research             
tonti  g   bradshaw  j  m   jeffers  r   montanari  r   suri  n     uszok  a          semantic web languages policy representation reasoning  comparison kaos 
rei  ponder  proceedings second international semantic web conference
 iswc     vol       lecture notes computer science  pp          springerverlag 
uszok  a   bradshaw  j  m   johnson  m   jeffers  r   tate  a   dalton  j     aitken  s 
        kaos policy management semantic web services  ieee intelligent systems 
             
wolter  f     zakharyaschev  m          modal decision problems  handbook modal
logic  elsevier 
y  ding  v  h     wu  j          new mapping alci alc  proceedings
     international workshop description logics  dl       no      ceurws  http   ceur ws org   

   


