journal artificial intelligence research                 

submitted        published      

message based web service composition  integrity constraints 
planning uncertainty  new connection
jorg hoffmann

joe   hoffmann   sap  com

sap research
karlsruhe  germany

piergiorgio bertoli

bertoli   fbk   eu

fondazione bruno kessler
trento  italy

malte helmert

helmert   informatik   uni   freiburg   de

albert ludwigs universitat freiburg
freiburg  germany

marco pistore

pistore   fbk   eu

fondazione bruno kessler
trento  italy

abstract
thanks recent advances  ai planning become underlying technique several applications  figuring prominently among automated web service composition  wsc 
capability level  services described terms preconditions effects ontological concepts  key issue addressing wsc planning ontologies formal
vocabularies  axiomatize possible relationships concepts  axioms correspond termed integrity constraints actions change literature 
applying web service essentially belief update operation  reasoning required belief
update known harder reasoning ontology itself  support belief update
severely limited current planning tools 
first contribution consists identifying interesting special case wsc
significant tractable  special case  term forward effects  characterized
fact every ramification web service application involves least one new constant
generated output web service  show that  setting  reasoning required
belief update simplifies standard reasoning ontology itself  relates to  extends 
current notions message based wsc  need belief update removed strong
 often implicit informal  assumption locality individual messages  clarify
computational properties forward effects case  point strong relation standard notions planning uncertainty  suggesting effective tools latter successfully
adapted address former 
furthermore  identify significant sub case  named strictly forward effects  actual
compilation planning uncertainty exists  enables us exploit off the shelf planning tools solve message based wsc general form involves powerful ontologies 
requires reasoning partial matches concepts  provide empirical evidence
approach may quite effective  using conformant ff underlying planner 

c
    
ai access foundation  rights reserved 

fih offmann   b ertoli   h elmert   p istore

   introduction
since mid nineties  ai planning tools become several orders magnitude scalable 
invention automatically generated heuristic functions search techniques
 see mcdermott        bonet   geffner        hoffmann   nebel        gerevini  saetti   
serina        helmert        chen  wah    hsu         paved way adoption
planning underlying technology several applications  one application area
web service composition  wsc   paper mean automated composition
semantic web services  sws   sws pieces software advertised formal description
do  composing sws means link together aggregate behavior
satisfies complex user requirement  ability automatically compose web services key
reducing human effort time to market constructing integrated enterprise applications 
result  widely recognized economic potential wsc 
wide spread sws frameworks owl s  wsmo    sws described two distinct
levels  one addresses overall functionality sws  details precisely
interact sws  former level  called service profile owl s service
capability wsmo  sws described akin planning operators  preconditions effects  therefore  planning prime candidate realizing wsc level  approach
follow paper 
setting  key aspect sws preconditions effects described relative
ontology defines formal  logical  vocabulary  indeed  ontologies much
formal vocabularies introducing set logical concepts  define axioms constrain behavior domain  instance  ontology may define subsumption relationship
two concepts b  stating members necessarily members b 
natural interpretation axiom  context wsc  every state encountered every possible configuration domain entities must satisfy axiom  sense 
ontology axioms correspond integrity constraints discussed actions change literature
 ginsberg   smith        eiter   gottlob        brewka   hertzberg        lin   reiter       
mccain   turner        herzig   rifi          hence wsc considered planning
presence integrity constraints  since constraints affect outcome action executions 
facing frame ramification problems  execution actions corresponds closely
complex notions belief update  lutz   sattler        herzig  lang  marquis    polacsek 
       unsurprisingly  providing support integrity constraints modern scalable planning tools mentioned poses serious challenges  best knowledge  yet
attempted all 
regarding existing wsc tools  planning tools employed solving wsc problems 
situation isnt much better  tools ignore ontology  i e   act constraints
domain behavior given  ponnekanti   fox        srivastava        narayanan   mcilraith 
      sheshagiri  desjardins    finin        pistore  traverso    bertoli      b  pistore  marconi  bertoli    traverso      a  agarwal  chafle  dasgupta  karnik  kumar  mittal    srivastava 
    a   approaches tackle full generality belief update using general reasoners 
   example  see work ankolekar et al         burstein et al         
   example  see work roman et al         fensel et al         
   integrity constraints sometimes called state constraints domain constraints 

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

suffer inevitable performance deficiencies  eiter  faber  leone  pfeifer    polleres       
giunchiglia  lee  lifschitz  mccain    turner        
planningbased
formalization

wsc formalism

variant

restriction
rich version

forward effects

wsc

planningbased
formalization

messagebased wsc

restriction

conformant planning


tackled

strictly forward effects

figure    overview planning wsc frameworks addressed paper  special cases
identified herein shown red   boldface 
work addresses middle ground two extremes  i e   trade off
expressivity scalability wsc  via identification special cases
tackled efficiently  figure   gives overview wsc planning frameworks involved 
brief  forward effects case requires every effect ramification web service
affects least one new constant generated web services output  situation 
frame problem trivializes  making planning problem similar common notions
conformant planning  smith   weld        bonet   geffner        cimatti  roveri    bertoli 
      hoffmann   brafman         discuss existing tools latter  particular
conformant ff  hoffmann   brafman         extended deal wsc forward
effects  strictly forward effects  action effects required affect outputs 
devise actual compilation conformant planning  thus obtain scalable tool interesting
wsc problems integrity constraints  particular able exploit  some of  heuristic
techniques mentioned  hoffmann   nebel        hoffmann   brafman        
follows  explain various parts figure   little detail  starting
point wsc formalism  addressing wsc terms planning presence integrity constraints  discussed above  formalism essentially enriched form conformant planning 
distinguishing aspects are 
initial state description conjunction literals  possibly mentioning
logical facts task  hence introducing uncertainty  
actions conditional effects semantics  meaning executed state 
effect applicable 
actions may output variables  i e   may create new constants 
set integrity constraints  universally quantified clause 
semantics action execution defined terms belief update operation 
section   provides details choices  motivates example
results literature  show  planning formalism hard  particularly 
  

fih offmann   b ertoli   h elmert   p istore

even testing whether given action sequence plan p   complete  contrast
common notions conformant planning  plan testing conp complete 
see  forward effects remove additional complexity  intuitively  forward effects
case covers situation web service outputs new constants  sets characteristic
properties relative inputs  relies ontology axioms describe ramifications
concerning new constants  case syntactically characterized follows 
    every effect literal contains least one output variable 
    within integrity constraint  every literal set variables arguments 
definition best understood example  consider following variant widespread virtual travel agency  vta   web services book travel accommodation must
linked  web services generate new constants corresponding tickets reservations 
example  integrity constraints stating subsumption  z   trainticket z 
ticket z   web service bookticket may input variable x  precondition train x   
output variable y  effect trainticket y  ticketfor  y  x   forward effects task 
every effect literal contains output variable y  integrity constraint single variable
z provides arguments literals constraint  say one instantiates input
bookticket constant c output new constant d  applying resulting
ground action state train c  holds true  constant gets created  characteristic
properties relative inputs trainticket d  ticketfor  d  c  set directly action 
integrity constraint takes care ramification  establishing ticket d  holds  note
status c apart relation affected way   
forward effects case closely related wide spread notion wsc problems 
refer message based wsc  approaches  composition semantics based
chaining input output messages web services  one sense  inferences
ontology axioms made many approaches  restricted way limited
assumption locality individual messages  interferences affect particular
message transfer  implications transfers ignored  locality assumption
usually made informal way  often stated explicitly all  one contribution work
shed light issue  via identification forward effects case lies
message based wsc full planning framework belief update semantics 
message based wsc forward effects case share focus output constants 
two important differences  first  forward effects case restricted messagebased wsc terms ontology axioms allowed  essentially  forward effects correspond
special case wsc locality assumption message based wsc actually justified 
within full planning framework  second  full framework comes benefit increased
flexibility combination services  locality enforced  e g  output one
service may reused several points plan  
computational point view  key property forward effects case
removes need belief update  nutshell  reason actions affect new propositions  i e   propositions involving least one output constant   recall point made
   latter would case effect bookticket included literal affecting x  example 
train x    integrity constraint capable mixing old new constants  example  x   
trainticket y  train x   

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

unchanged status c  vta example above   output constant  d  example 
exist prior application action  hence previous belief carries knowledge
need revised  consider characterization forward effects  given above 
condition     ensures immediate effect action affects new propositions  condition     ensures changes new propositions propagate new propositions  since
literals constraint share variables  output constant question copied
them  see  virtue properties complexity plan testing conp complete 
rather p   complete  forward effects case 
complexity reduction critical reduced complexity
common notions conformant planning initial state uncertainty  therefore feasible adapt conformant planning tools address wsc forward effects  scalable planning
tools conformant planning already developed  cimatti et al         bryce  kambhampati    smith        hoffmann   brafman        palacios   geffner         hence
promising line research  example  focus conformant ff tool  hoffmann
  brafman         short cff  outline main steps need taken adapting cff
handle wsc forward effects 
identify case actual compilation conformant planning initial
state uncertainty exists  that  one must fix set constants priori  manner
fairly standard  see  e g   settlers domain long   fox         simply include set
subset potential constants used instantiate outputs  subtle idea
put forward identify condition actions predict properties
assigned potential constants  case created  enables us design
compilation moves action effects initial state formula  uses actions
modify set constants already exist  way  reasoning initial state formula
compiled task reasoning output constants original task 
reasoning mechanisms included tools cff naturally used implement latter 
trick predicting output properties require actions compatible sense
either produce different outputs  effects  turns condition
naturally given restriction forward effects  call strictly forward effects 
web service effects concern new constants 
clearly  able reference inputs limitation  example  longer
say  vta example  output ticket input x  still  strictly forward
effects case describes interesting class wsc problems  class corresponds web services
modeled early versions owl s  example  logical connection
inputs outputs  further  class wsc problems allows powerful ontologies
universally quantified clauses makes possible combine services flexibly  using
compilation  class problems solved off the shelf tools planning
uncertainty 
validate compilation approach empirically running number tests using cff
underlying planner  use two test scenarios  scalable variety parameters  covering range different problem structures  examine cff reacts various
parameters  viewed isolation  results demonstrate large complex wsc instances
comfortably solved using modern planning heuristics 
comparison alternative wsc tools problematic due widely disparate nature
kinds problems tools solve  kinds input languages understand 
  

fih offmann   b ertoli   h elmert   p istore

purpose respective developers mind  nevertheless provide assessment
comparative benefits approach run tests dlvk tool eiter et al        
eiter  faber  leone  pfeifer  polleres         dlvk one planning tools
deals ontology axioms called static causal rules directly  without need restrict
forward effects without need compilation  since  context work 
main characteristic wsc presence ontology axioms  means dlvk one
existing native wsc tools  comparison  forward effects compilation approach
solves similar problem  sacrifices expressivity  question is  principle
gain anything sacrifice  absolutely  answer yes  dlvk much slower
compilation cff  solving small fraction test instances even always provided
correct plan length bound  emphasize wish over state results 
due above mentioned differences tools  conclusion draw
trade off expressivity scalability wsc important  forward effects case
seems constitute interesting point trade off 
paper organized follows  first  section   provides background necessary
understand context contribution work  section   introduces wsc planning
formalism  section   defines discusses forward effects  section   introduces compilation
planning uncertainty  section   presents empirical results  discuss closely
related work relevant points text  section   provides complete overview 
finally  section   concludes discusses future work  improve readability  proofs
moved appendix replaced text proof sketches 

   background
context work rather intricate  wsc new topic posing many different
challenges existing techniques  effect field populated disparate works differing considerably underlying purpose scope  words  common ground
fairly thin area  further  work actually involves three fields research wsc  planning 
reasoning actions change relevant understanding contribution 
reasons  explain background detail  first discuss wsc general 
wsc planning particular  state relevant facts belief update  finally
consider message based wsc 
    wsc  wsc planning
composition semantic web services received considerable attention last years 
general formulation problem  shared large variety works  focuses capability
level  web service conceived atomic operator transforms concepts 
specifically  service defined via iope description  service receives input set
typed objects  and  provided precondition p holds  produces output set
typed objects effect e guaranteed hold  typing objects exchanged
services given terms membership concepts  concepts classes defined
within ontologies  exploit description logics  dl   form logic  formally
define universe concepts admitted discourse  ontology express complex relationships among concepts  subsumption hierarchy  way objects belonging concept
structured parts referring concepts 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

general setting instantiated various ways depending kind conditions
admitted preconditions effects services  kind logics underlying ontology
definitions  independent this  problem semantic web service composition stated
one linking appropriately set existing services aggregate behavior
desired service  the goal   illustrate problem  consider following example 
inspired work thakkar  ambite  knoblock        e services bioinformatics
 and relies actual structure proteins  see example petsko   ringe        branden  
tooze        chasman        fersht        
example   say want compose web service provides information different classes
proteins  ontology states classes proteins exist  structural characteristics
may occur  available information service every structural characteristic 
presentation service combines range information  given particular protein class 
composed web service run relevant information services  present output 
concretely  classes proteins distinguished location  cell  membrane  intermembrane           modeled predicates protein x   cellprotein x   membraneprotein x  
intermembraneprotein x   along sub concept relations x   cellprotein x 
protein x   individual protein characterized following four kinds structures 
   primary structure states proteins sequence amino acids  e g    kw  x   a protein called glyoxalase   n   x   a protein called triosephosphate isomerase  
   secondary structure states proteins external shape terms dssp  dictionary secondary structure proteins  code  admitting limited set possible values 
example  g indicates   turn helix  b  sheet  on  total set values
g h i t e b s 
   tertiary structure categorizes proteins   d shape 
   subset proteins  quaternary structure categorizes proteins shape
combined complexes proteins  amounting      different shapes  see example
 dcomplex org        
various axioms constrain domain  apart mentioned subconcept
relations  first  obvious axioms specify protein value four
kinds structures  i e   protein sequence amino acids  external shape  etc   however 
complex axioms  particular kinds proteins come particular structure
values  modeled axioms as 
x   cellprotein x  g x   n   x 
x   cellprotein x  b x   kw  x  complexbarrel x 
dssp code z information service  named getinfodsspz   whose precondition
z x  whose effect infodssp y  output service  similarly  information services amino acids    d shapes  shapes complexes  presentation service 
named combineinfo  requires information four kinds structures created 
effect combinedpresentation y   where output combineinfo  
  

fih offmann   b ertoli   h elmert   p istore

input composed web service protein c  a logical constant  class 
goal x   combinedpresentation x   solution reason characteristics may
occur  apply respective information services  run combineinfo  variant
problem  additional requestinfo service used initiate information request  i e  
output requestinfo protein c class 
example shows ontology axioms play crucial role form wsc  formulating
complex dependencies different concepts  note applying web service may indirect consequences implied ontology axioms  example  output requestinfo
service implications kinds information services required 
another interesting aspect example   requires sws community calls partial matches  opposed plug in matches  paolucci  kawamura  payne    sycara        li
  horrocks        kumar  neogi  pragallapati    ram          consider situation one
wants connect web service w another web service w   is  w executed prior
w   output w used instantiate input w   w w said
partial match if  given ontology axioms  output w sometimes suffices provide
necessary input w   contrast  w w said plug in match if  given ontology
axioms  output w always suffices provide necessary input w  
plug in matches tackled many approaches wsc  whereas partial matches tackled
few  part reason probably plug in matches easier handle  many types
wsc algorithms  indeed existing wsc tools support plug in matches  see detailed
discussion wsc tools section     example   cannot solved plug in matches
information services provides necessary input combineinfo service
particular cases 
base work planning formalism allows specify web services  i e   actions 
outputs  allows specify ontology axioms  axioms interpreted integrity
constraints  resulting semantics corresponds closely common intuitions behind wsc 
well existing formal definitions related wsc  lutz   sattler        baader  lutz 
milicic  sattler    wolter        liu  lutz  milicic    wolter      b      a  de giacomo  lenzerini  poggi    rosati         since one main aims able exploit existing planning
techniques  consider particular form ontology axioms  correspondence representations used existing tools planning uncertainty  namely  axioms
universally quantified clauses  example subsumption relation x   trainticket x 
ticket x  mentioned above  usual b abbreviation b  planning task
specifies set clauses  interpreted conjunction clauses  note provides
significant modeling power  meaning universal quantification clauses
clauses hold planning objects logical constants known exist  sense 
interpretation formulas closed world customary planning tools  however  contrast
standard planning formalisms including pddl  assume fixed set constants 
rather  specification actions outputs enables dynamic creation new constants 
quantifiers ontology axioms range constants exist respective world 
similar fashion  planning goal may contain variables  existentially quantified 
constants used instantiate goal may pre existed  may generated
   terminology works slightly different use here  describe additional kinds
matches  details given section   

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

outputs web services applied path world  consider
illustration goal x   combinedpresentation x  example    goal variable x
instantiated output created combineinfo service 
another important aspect planning formalism allow incomplete initial state
descriptions  initial state corresponds input user provides composed web
service  certainly cannot assume contains complete information every aspect
world   in example    initial state tells us class proteins interested
in  leaves open consequences regarding possible structural characteristics  
consider case observability  i e   conformant planning  outcome
wsc sequence web services satisfies user goal possible situations  
customary conformant planning  actions conditional effects semantics  i e   fire
precondition holds true  otherwise nothing  note that  way  obtain notion
partial matches  solution employs different actions depending situation 
main difference planning formalism formalisms underlying current planning tools presence integrity constraints  effect semantics executing actions  semantics defined belief update operation 
    belief update
correspondence web service applications belief update first observed lutz
sattler         followed baader et al          liu et al       b      a  de giacomo
et al          original statement belief update problem  given belief  
i e   logical formula defining worlds considered possible  given formula  
update  intuitively  corresponds observation telling us world changed
way that  now  true  want obtain formula defining worlds
possible given update  certainly  need      ensuring corresponds
well known ramification problem  time  however  world change
unnecessarily  is  want close possible   among formulas
satisfy   corresponds frame problem 
say want apply action presence integrity constraints  describes
worlds possible prior application a  resulting set possible worlds 
integrity constraints correspond formula ic holds   require
hold   update formula given conjunction action effect ic   i e  
  effa ic   means update previous belief information that 
a  effa new formula required hold  ic still true  example  may
action effect a c  subsumption relation concepts b  formulated clause
x   a x  b x   update formula a c  x   a x  b x  ensures b c  true
 
belief update widely considered literature ai databases  see example
fagin  kuper  ullman    vardi        ginsberg   smith        winslett              katzuno
  mendelzon        herzig        herzig   rifi        liu et al       b  de giacomo et al  
       various approaches differ exactly defined  best consensus
one approach adequate every application context  approaches
   course  generally  observability partial web service effects uncertain  consider
generalizations here  extending notions accordingly straightforward  future work 

  

fih offmann   b ertoli   h elmert   p istore

agree hold updated state affairs       major differences lie
exactly taken mean close possible   various authors 
example brewka hertzberg         mccain turner         herzig         giunchiglia
lifschitz         argue notion causality needed  addition  or even instead of 
notion integrity constraints  model domain behavior natural way  counter
arguments  neither follow causal approach work  reason ontologies
context wsc  example ontologies formulated web ontology language owl
 mcguinness   van harmelen         incorporate notion causality  given
set axioms  made intention describe behavior domain itself  rather
behavior exhibits changed particular web services  idea work try
leverage  or reasonably close having   consideration causal
approaches wsc left future work 
belief update computationally hard problem  eiter gottlob        liberatore
       show that  non causal approaches defining   reasoning typically
harder reasoning class formulas used formulating   specifically  deciding
whether particular literal true  p  hard even complete conjunction
literals  corresponding single world state  propositional cnf formula 
problem conp hard even single world state propositional horn formula 
use results show that  planning formalism  checking plan testing whether
given action sequence plan  p  complete  deciding polynomially bounded plan
existence  p  complete 
given complexity  perhaps unsurprising support integrity constraints current planning tools severely limited  existing planning tools support integrity
constraints  namely eiter et al         giunchiglia et al          based generic
deduction  satisfiability testing answer set programming  hence lack planningspecific heuristic search techniques key scalability modern planning tools
developed since mid nineties  even investigated yet integrity constraints could handled latter tools  existing approach ventures direction implements so called derived predicates modern planning tools  thiebaux 
hoffmann    nebel        gerevini  saetti  serina    toninelli        chen et al         
approach postulates strict distinction basic predicates may affected actions 
derived predicates may affected integrity constraints taking form logic programming rules  predicate appears action effect  allowed appear
head rule  desirable restriction context wsc  web services
bound affect properties constrained ontology axioms 
existing work connecting wsc belief update  lutz   sattler        baader et al  
      liu et al       b      a  de giacomo et al         theoretical nature  actual implemented wsc tools make severe simplifying assumptions  often  assumption ignore
ontology axioms  ponnekanti   fox        srivastava        mcilraith   son        sheshagiri
et al         sirin  parsia  wu  hendler    nau        pistore et al       b      a   sometimes 
ontology constraints restricted subsumption hierarchies  makes update problem
easy  constantinescu   faltings        constantinescu  faltings    binder      b      a   sirin
parsia        sirin  parsia  hendler        discuss problem dealing ontology axioms wsc  make connection belief update  describe alternative
solution  finally  authors  example meyer weske         deal ontology ax  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

ioms composition  provide formal semantics specify exactly
action applications handled  seems fully formalized wsc approaches implicitly
assume message based framework  frameworks closely related forward effects
special case identified herein 
    message based wsc
message based approaches wsc  composition semantics based chaining input
output messages web services  word message standard term context 
authors use individual vocabulary  far aware  first appearance
word message wsc paper title work liu  ranganathan  riabov        
work describes message based wsc follows  solution directed acyclic graph  dag 
web services  input needed web service  dag graph node  w must provided
outputs predecessors w graph  is  plan determines fixed connections
actions  reasoning  then  takes place within connections  two connections
different output input messages  i e   two graph edges ending different node 
assumed mutually independent  consider following example illustration  say web
service w effect hasattributea c  d  output constant c input  i e   c
existed already prior application w   say axiom x    hasattributea x  y 
conceptb x  expressing attribute domain restriction  x value attribute a 
x must concept b  given this  ws effect implies conceptb c   now  suppose
belief prior applying w constrain c concept b  applying w leads new
knowledge c  hence need non trivial belief update taking account changed
status c  implications may have  message based wsc simply acts latter
case  checks whether w correctly supplies inputs web services w w
connected to  is  new fact hasattributea c  d  may taken part proof
effect w implies precondition connected web service w   considered
implications hasattributea c  d  may respect previous state affairs 
sense  message based wsc ignores need belief update 
intuitions underlying message based wsc fairly wide spread  many papers use
less direct way  many approaches explicitly define wsc solutions
dags local input output connections  zhan  arpinar    aleman meza        lecue
  leger        lecue   delteil        kona  bansal  gupta    hite        liu et al         ambite
  kapoor         various works  constantinescu   faltings        constantinescu et al  
    b      a  meyer   weske         message based assumptions implicit 
manifest mainly sense ontology axioms used infer properties
output messages  often checking whether inferences imply desired input
message definitely given 
previous work message based wsc address message based wsc relates
various notions  belief update  considered literature  one contribution work
shed light issue  via identification forward effects case lies
message based wsc full planning framework belief update semantics 
message based wsc forward effects case share focus outputs  indeed 
output constants generated actions viewed messages  output constant
represents information object created one web service  form

  

fih offmann   b ertoli   h elmert   p istore

input web service  forward effects case  due restriction axioms 
individual messages interact  much message based wsc  main difference
this  message based wsc ignores possible interactions  forward effects actually
arent interactions  according formal planning based execution semantics  sense 
forward effects correspond special case wsc assumptions message based wsc
justified 
reconsider example above  featuring web service w effect implying
conceptb c  c pre existing constant  explained above  message based wsc
simply ignore need updating knowledge c  contrast  forward effects case
disallows axiom x    hasattributea x  y  conceptb x  may lead new
conclusions old belief  note literals axiom refer different sets variables  
forward effects case differs significantly approaches message based wsc
terms flexibility allows combine actions plans  messagebased approach using dags  solution dag ensures inputs service w always
provided ws predecessors  is  plug in match set w ws
predecessors dag  w itself  note slightly general usual notion
plug in matches   w   may greater    hence single service w may
partial match w  notion used  amongst others  liu et al         
authors  example lecue leger        lecue delteil         restrictive
consider every individual input x w turn require exists w w
w plug in match x  i e   w guarantees always provide x   even generous
two definitions  partial matches restricted appear locally  dag links  every
action web service required always executable point applied 
words  services used fixed manner  considering dynamics actual execution 
example    would mean using information services regardless class
protein  hence completely ignoring relevant not 
forward effects case incorporates much general notion partial matches  happens straightforward way  exploiting existing notions planning  form conditional effects semantics  standard notion conformant solution defines partial matches
must work together global level  accomplish goal  best knowledge 
one line work wsc  constantinescu et al   constantinescu   faltings       
constantinescu et al       b      a   incorporates comparable notion partial matches 
work  web services characterized terms input output types  handle partial
matches  so called switches combine several web services way ascertains relevant
cases covered  switches designed relative subsumption hierarchy types 
note subsumption hierarchies special case much general integrity constraints
universally quantified clauses consider work 

   formalizing wsc
solid basis addressing wsc  define planning formalism featuring integrity constraints 
on the fly creation output constants  incomplete initial state descriptions  actions conditional effects semantics  application actions defined belief update operation  following possible models approach winslett         definition belief update somewhat
canonical widely used discussed  particular underlies recent work

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

relating formalizations wsc  lutz   sattler        baader et al         liu et al       b 
    a  de giacomo et al         de giacomo  lenzerini  poggi    rosati         show
 section       belief update operations equivalent anyway soon
forward effects case  recall forward effects case central object
investigation paper 
first give syntax formalism  denote wsc  give semantics  conclude analysis main computational properties 
    syntax
denote predicates g  h  i  variables x  y  z  constants c  d  e  literals possibly negated predicates whose arguments variables constants  arguments constants 
literal ground  refer positive ground literals propositions  given set p predicates
set c constants  denote p c set propositions formed p
c  given set x variables  denote lx set literals l use variables
x  note l may use arbitrary predicates constants   l literal  write
l x  indicate l variable arguments x  x    x            xk   c    c            ck   
l c            ck  x            xk   denote respective substitution  abbreviated l c  
way  use substitution notation construct involving variables  slightly abusing
notation  use vector constants denote set constants appearing it  further 
function assigns constants variables x  l a x  denote substitution
argument x x replaced a x   concerned first order logic  is 
whenever write formula mean first order formula  denote true   false   
clause  integrity constraint  disjunction literals universal quantification
outside  variables quantified exactly appear least one literals 
example  x    g x  y  h x  integrity constraint x  y  z   g x  y  h x  x  
g x  y h x  not  operator tuple  xo   preo   yo   effo    xo   yo sets variables  preo conjunction literals lxo   effo conjunction literals lxo yo   
intended meaning xo inputs yo outputs  i e   new constants created
operator  operator o  action given  prea   effa    preo   effo   ca  xo   ea  yo  
ca ea vectors constants  ea require constants pairwise different makes sense output new constant twice  given action a  refer
inputs outputs ca ea   respectively  use notations prea   effa
obvious meaning 
wsc task  planning task  tuple  p  ic   o  c        g    here  p set predicates 
ic set integrity constraints  set operators c  set constants  initial
constants supply    conjunction ground literals  describing possible initial states  g
conjunction literals existential quantification outside  describing goal states 
e g   x    g x  h y   predicates taken p  constants taken c   
constructs  e g   sets conjunctions  finite  sometimes identify ic
conjunction clauses contains  note existential quantification goal variables
   one could course introduce general notations logical constructs using set predicates constants 
however  herein two notations given suffice 
   stated  address disjunctive non deterministic effects  topic future work 

  

fih offmann   b ertoli   h elmert   p istore

provides option instantiate goal constants created planning obtaining objects
requested goal may possible use outputs 
various formulas occurring  p  ic   o  c        g   may make use constants c   
specifically  case clauses ic goal formula g   allowing use
constants effect complexity algorithmic results  conceivable
feature may useful  simple example  vta domain user may wish select
particular train  say train company provides table trains itineraries  table
represented     possibly help ic stating constraints hold particular trains 
user select train  say ice     pose goal   ticketfor  y  ice     
constraining produced ticket way would possible without use pre existing
constants  or would least require rather dirty hack  e g   encoding desired train terms
special predicate  
operator descriptions  is  preconditions effects  may use constants c   
value benign ic g one always replace constant c
precondition effect new input output variable x  instantiate x  during planning 
c  note  however  would give planner option  uselessly  instantiate x
constant  may hence affect planning performance  example  might
special operator booking ticket ice     e g   train particular ticketing regulations  
correspondence wsc task web service composition task fairly obvious 
set p predicates formal vocabulary used underlying ontology  set ic
integrity constraints set axioms specified ontology  i e   domain constraints
subsumption relations  set operators set web services  note formalization
corresponds closely notion iope descriptions  inputs  outputs  preconditions 
effects  ankolekar et al         burstein et al          action corresponds web service call 
web services parameters instantiated call arguments 
constructs c        g extracted user requirement composition 
assume requirements take form iope descriptions  then  c 
user requirement inputs    user requirement precondition  words  c   
describe input given composition user  similarly  g user requirement effect
condition user wants accomplished user requirement outputs
 existentially quantified  variables g  
    semantics
follows  assume given wsc task  p  ic   o  c        g    able model
creation constants  states  also called world states  formalism enriched set
constants exist them  state pair  cs     cs set constants 
cs  interpretation  i e   truth value assignment   p cs           quantifiers taken range
constants exist state  is  c interpretation formula 
writing    mean    c c except quantifiers
restricted range c  avoid clumsy notation  sometimes write    abbreviate
    
core definition specifies application action affects state  defined
form belief update  let us first define latter  assume state s  set constants
c cs   formula   define update s  c     set interpretations result

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

creating constants c   cs   updating according semantics proposed
winslett        
say i  i  c  interpretations  define partial order interpretations 
setting i   s i 
 p p cs   i   p      p    p p cs   i   p      p   

   

words  i  ordered i  iff differs proper subset values  given this 
formally define update s  c      let arbitrary c  interpretation  define
update s  c           i         s i     

   

hence  update s  c     defined set c  interpretations satisfy  
minimal respect partial order  s   put different terms  update s  c     contains
interpretations differ set inclusion minimal set values 
now  assume action a  say applicable s  short appl s  a      prea  
ca cs   ea cs     is  top usual precondition satisfaction require
inputs exist outputs yet exist  result executing is 

  c       c   cs ea   update s  c   ic effa    appl s  a 
   
res s  a    
 s 
otherwise
note executed even applicable  case  outcome singleton
set containing itself  i e   action affect state  important aspect
formalism  get back below  ic effa unsatisfiable  obviously get
res s  a      say case inconsistent  
overall semantics wsc tasks easily defined via standard notion beliefs 
model uncertainty true state world  belief b set world states
possible given point time  initial belief
b      s   cs   c       ic     

   

action inconsistent belief b inconsistent least one b  latter
case  res b  a  undefined  otherwise  defined
 
res s  a  
   
res b  a    
sb

extended action sequences obvious way  plan sequence ha           
res b    ha            i       g  

   

illustration  consider formalization example section   
example   reconsider example    sake conciseness  formalize part
example  simplified axioms  wsc task defined follows 
   unless ic mentions constants  based operator inconsistent  action based
inconsistent  operators can  principle  filtered pre process planning 

  

fih offmann   b ertoli   h elmert   p istore

p    protein  cellprotein  g  h  i   n     kw   infodssp  info d  combinedpresentation  
predicates unary 
ic consists clauses 
x   cellprotein x  protein x   subsumption 
x   protein x  g x  h x  i x   at least one dssp value 
x   protein x   n   x   kw  x   at least one   d shape 
x   cellprotein x  g x   n   x   dependency 
x   cellprotein x  h x   n   x   dependency 
consists operators 
getinfodsspg     x   g x    y   infodssp y  
getinfodssph     x   h x    y   infodssp y  
getinfodsspi     x   i x    y   infodssp y  
getinfo d n       x    n   x    y   info d y  
getinfo d kw      x    kw  x    y   info d y  
combineinfo    x    x     infodssp x    info d x      y   combinedpresentation y  
c     c       cellprotein c 
g   x   combinedpresentation x 
illustrate formalism  consider plan example task 
initial belief b  consists states cs    c     ic cellprotein c   say
apply following sequence actions 
   apply getinfodsspg  c  d  b    get belief b  b  except
that  b     g c   new states generated constant
infodssp d  
   apply getinfodssph  c  d  b    get belief b  new states
infodssp d  generated b     h c  
   apply getinfo d n    c  e  b    yielding b   
   apply getinfo d kw   c  e  b    yields b    get e info d e  b 
    n   c      kw  c  
   apply combineinfo d  e  f   b    brings us b  b  except
b  d  e cs new states generated f combinedpresentation f   
dependencies ic  the last two clauses   get b  satisfies either g c 
h c   subsumption clause clause regarding   d shapes  first third clauses 
get b  satisfies either  n   c   kw  c   hence  easy verify  b    
g hgetinfodsspg  c  d   getinfodssph  c  d   getinfo d n    c  e   getinfo d kw   c  e  
combineinfo d  e  f  i plan 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

note plan make use getinfodsspi  c  d   obtain plan  domain
one always apply information services  however  plan trivial take
account relevant not  reasoning ic enables us find better plans 
semantics executing non applicable actions vital workings example   
pointed above  definition res s  a   equation       executed even
applicable  realizes partial matches  web service called soon might match
one possible situations  planning terms  actions conditional effects semantics   
contrasting notion would enforce preconditions  i e   say res s  a  undefined
applicable s  would correspond plug in matches 
example    partial match semantics necessary order able apply actions
cover particular cases  example  consider action getinfodsspg  c  d   applied
initial belief example plan  precondition action g c   however 
states initial belief satisfy precondition  initial belief allows
interpretation satisfying ic    cf  equation       interpretations satisfy h c 
rather g c   due partial match semantics  getinfodsspg  c  d  affect
states match initial belief partial 
clarification order regarding understanding constants  first  every pddllike planning formalism  we aware of   make unique name assumption  i e   different
constants refer different objects  second  understanding web services output
create separate individual  i e   separate information object 
latter directly raises question allow actions share output constants 
answer allow planner treat two objects same  makes
sense two objects play role plan  consider example    actions
getinfodsspg  c  d  getinfodssph  c  d  share output constant  d  means
one name two separate information objects  two objects properties 
derived infodssp d   difference created different
cases  namely states satisfy g c  h c  respectively  single name
two objects useful take name parameter actions need
distinguish different cases  example  combineinfo d  e  f   action 
hinted  cases correspond different classes concrete execution traces 
importantly  particular execution trace  output constant created once  see
this  consider execution trace s    a    s    a            ak   sk     i e   alternating sequence states
actions s  b    si   res si   ai     k  say ai aj share
output constant  d  say ai applicable si   hence csi     then  quite
obviously  csl     l k      particular  aj applicable sj  
intersection output constants csj non empty  cf  definition appl s  a    so  due
definition action applicability  never happen constant created twice 
words  never reachable state single constant name refers
one individual information object  sense  use one name several objects occurs
planning time  actual execution trace actual case occur
known  illustration  consider getinfodsspg  c  d  getinfodssph  c  d   shared
    obvious generalization allow several conditional effects per action  style adl language  pednault         omit sake simplifying discussion  extension direction straightforward 

  

fih offmann   b ertoli   h elmert   p istore

output d  example    even concrete state s  b  execution starts satisfies
g c  h c   one actions fire namely one comes first 
remark initially experimented definition actions instantiate
inputs  applied state outputs are  virtue execution semantics 
instantiated constants outside cs   framework  one never choose share output
constants  i e   use name two different outputs  notion settled
strictly richer  planner always choose instantiate outputs constants outside cs  
question is  make sense share outputs  answering question domainindependent planner may turn quite non trivial  get back discuss
possible adaptation cff section      experiments reported herein  section     use
simple heuristic  outputs shared iff operator effects identical  giving indication
respective outputs may indeed play role plan  
conclude sub section final interesting observation regarding modeling
framework  negative effects essential part wsc formalism  compiled
away  simply replace negative effect g x            xk   notg x            xk    introducing
new predicate  state integrity constraints two equivalent  is  introduce two new clauses x            xk   g x            xk   notg x            xk   x            xk  
g x            xk   notg x            xk    simple compilation technique  formal
details little intricate  moved appendix a  action original task 
a  denotes corresponding action compiled task  vice versa  similarly  action
original task  s  denotes corresponding state compiled task  get 
proposition    compilation negative effects wsc  assume wsc task  p  ic   o  c   
 
    g    let  p      
ic     c        g   task negative effects compiled away 
assume action sequence ha            i  let b result executing ha             p  ic  
 
 
 
 
o  c        g    let b  result executing ha 
             p   ic     c        g   
then  state s  b iff s  b   
proved straightforward application relevant definitions  important aspect result new clauses introduced allowed forward effects
strictly forward effects special cases identified later  hence  hardness results transfer directly
tasks without negative effects dropping negative effects cannot make algorithms easier 
    computational properties
perform brief complexity analysis wsc formalism general form
introduced above  line many related works kind  eiter   gottlob        bylander 
      liberatore        eiter et al          consider propositional case  context 
means assume fixed upper bound arity predicates  number input output
parameters operator  number variables appearing goal  number
variables clause  refer wsc tasks restricted way wsc tasks fixed
arity 
consider problems checking plans testing whether given action sequence
plan deciding plan existence  latter  distinguish polynomially bounded
plan existence  unbounded plan existence  deem particularly relevant decision
problems context plan generation  certainly  plan checks integral part plan gen  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

eration  indeed  planning tool based state space search  tool either performs
checks explicitly  potentially many  plan candidates generated search  complexity
inherent effort underlies computation state transitions  polynomially bounded
plan existence relevant because  commonly used planning benchmark domains  plans
polynomial length  it wide spread intuition sws community composed
web services contain exceedingly large numbers web services   finally  unbounded plan
existence general decision problem involved  thus generic interest 
problems turn hard  prove this  reuse adapt various results
literature  start complexity plan checking  hardness follows
long established result  eiter   gottlob        regarding complexity belief update 
results  detailed proofs available appendix a 
theorem    plan checking wsc  assume wsc task fixed arity  sequence
ha            actions  p   complete decide whether ha            plan 
proof sketch  membership shown guess and check argument  guess proposition
values along ha            i  check whether values comply res  lead
inconsistent action  final state satisfy goal  ha            plan iff
case guess proposition values  checking goal satisfaction polynomial  checking
compliance res conp  checking consistency np 
hardness follows simple adaptation proof lemma     eiter gottlob
        proof uses reduction checking validity qbf formula x y  x    
lemma considers case propositional belief updated arbitrary  propositional 
formula   decision problem ask whether formula implied
updated belief  proof  complete conjunction literals  i e   corresponds single
world state  single propositional fact r true   semantics x y  x   
encoded complicated construction defining update   nutshell  cnf telling
us every assignment x  which yield world state updated belief   either
find assignment  x    holds  completing    falsify r 
difference setting lies restricted update formulas action effects
fact integrity constraints supposed hold every belief  adapt
proof by  first  taking integrity constraints clauses eiter gottlobs cnf formula
  modify constraints need true new fact holds i e   insert
every clause  initial belief false  otherwise corresponds exactly above 
action plan makes true  goal eiter gottlobs fact r 
 
remark membership theorem   remains valid allowing actions multiple
conditional effects  allowing parallel actions  even allowing combination 
hand  virtue proof argument outlined  hardness holds even initial state
literals   complete  describe single world state   plan consists single action
single positive effect literal  goal single propositional fact initially true 
next consider polynomially bounded plan existence  this  membership follows directly
theorem    prove hardness  construct planning task extends eiter gottlobs
construction actions allow choose valuation third  existentially quantified  set variables  hence reduces validity checking qbf formula x y z  x  y  z  

  

fih offmann   b ertoli   h elmert   p istore

theorem    polynomially bounded plan existence wsc  assume wsc task fixed arity  natural number b unary representation  p   complete decide whether exists
plan length b 
proof  membership  guess sequence b actions  theorem    check
p  oracle whether sequence plan 
hardness  validity qbf formula x y z  x  y  z   cnf  reduced
testing plan existence  say x    x            xn    planning task  n actions  operators
empty input output parameters  oxi oxi former sets xi true latter
sets xi false  further  action ot corresponds action used hardness
proof theorem    actions equipped preconditions effects ensuring
plan must first apply    n  either oxi oxi   thereafter must apply ot  of course
enforcing latter requires new goal fact achieved ot    hence  choosing
plan candidate task choosing value assignment ax variables x 
construction  oxi oxi actions executed  one ends belief
contains single world state  value assignment ax variables x corresponds
chosen actions  world state basically corresponds belief hardness proof
theorem    difference construction extended cater third
set variables  straightforward  then  belief results executing ot satisfies
goal iff eiter gottlobs fact r holds world states  virtue similar arguments
eiter gottlob  latter case iff y z  ax  x  y  z   i e   substitution
x y z  x  y  z  ax   valid  this  claim follows 
 
final result regards unbounded plan existence wsc  result relatively easy
obtain generic reduction described bylander        prove pspace hardness plan
existence strips  somewhat shockingly  turns plan existence wsc undecidable
even without integrity constraints  complete initial state description  source
undecidability is  course  ability generate new constants on the fly 
theorem    unbounded plan existence wsc  assume wsc task  decision problem
asking whether plan exists undecidable 
proof sketch  modification proof bylander        plan existence propositional strips planning pspace hard  original proof proceeds generic reduction 
constructing strips task turing machine polynomially bounded space  latter restriction necessary model machines tape  tape cells pre created positions within
bound  exploiting ability create constants on the fly  instead introduce simple
operators allow extend tape  ends 
 
able decide plan existence is  course  significant limitation principle  however  limitation probably marginal importance practice  planning tools
assume plan  try find rather trying prove
plan  sense  planning tools are  nature  semi decision procedures anyway 
matters decidability setting question whether one find plan

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

quickly enough  i e   exhausting time memory    relevant question
web service composition 

   forward effects
high complexity planning wsc motivates search interesting special cases 
define special case  called forward effects  every change action makes state involves
newly generated constant 
start section defining forward effects case making core observation
semantics  discuss modeling power special case  next  discuss forward effects general perspective belief update  analyze main computational
properties forward effects  conclude section assessment existing
planning tool could adapted handle forward effects 
    wsc f wd semantics
forward effects special case wsc defined follows 
definition   assume wsc task  p  ic   o  c        g    task forward effects iff 
   o  l x  effo   x yo     
   clauses ic     x            xk   l   x    ln  xn    x   
  xn  
set wsc tasks forward effects denoted wsc f wd  
first condition says variables every effect literal contain least one output variable  implies every ground effect literal action contains least one new constant 
second condition says that  within every integrity constraint  literals share arguments 
implies effects involving new constants affect literals involving new constants 
note that  since x            xk definition exactly variables occurring literals 
xi xi   x            xk   note may k      i e   literals
clause may ground  intentional  constants mentioned clause must
taken c    cf  discussion section      therefore  clauses interaction
statements new constants generated wsc f wd action 
discuss modeling power wsc f wd  section       first  observe
semantics wsc f wd much simpler general wsc  one longer needs
notion minimal change respect previous state  state precisely  assume

wsc task predicates p  say interpretation p c   c set constants 
say c c   denote  c restriction p c   i e   interpretation p c
coincides propositions  given state action a  define 

  c       c   cs ea    cs        ic effa   appl s  a 
   
res f wd  s  a    
 s 
otherwise
    indeed planning community generally rather unconcerned undecidability  cf  numeric track international planning competitions  helmerts        results decidability numerical planning problems 

  

fih offmann   b ertoli   h elmert   p istore

compare equation      defined member update s  c   ic effa   
returns interpretations satisfy ic effa differ minimally   equation      simply set identical   constants  on propositions constants 
existed beforehand  words  set new states get cross product old
state satisfying assignments ic effa  
lemma    semantics wsc f wd   assume wsc f wd task  reachable state s  action
a  res s  a    res f wd  s  a  
proof sketch  wsc f wd   differs minimally s  follows agrees totally
s  set propositions p cs interpreted s  see this  denote p cs  ea
set propositions arguments cs ea   least one argument ea   denote
ic  cs   ea   instantiation ic constants cs ea   clause
least one variable instantiated ea   key argument    ic effa equivalent
   ic  cs ea   effa   turn equivalent    ic  cs   ic  cs   ea   effa  
last formula  ic  cs   uses propositions p cs   whereas ic  cs   ea   effa
uses propositions p cs  ea   since reachable     ic  cs    therefore  satisfy
ic effa   need change values assigned s 
 
    modeling power
intuitively  wsc f wd covers situation web service outputs new constants  sets
characteristic properties relative inputs  relies ontology axioms describe
ramifications concerning new constants  detailed section    closely corresponds
various notions message based wsc explored literature  sense  modeling
power wsc f wd comparable message based wsc  one most widespread
approaches area 
simple concrete way assessing modeling power wsc f wd consider allowed
disallowed axioms  examples axioms allowed wsc f wd are  attribute domain
restrictions  taking form x    g x  y  h x   attribute range restrictions  taking form
x    g x  y  h y   relation transitivity  taking form x  y  z   g x  y  g y  z 
g x  z   note that  axioms  easy construct case action effect  even
though involves new constant  affects old belief  example  constants c e existed
beforehand  action outputs sets g c  d  g d  e   axiom x    g x  y 
g y  z  g x  z  infers g c  e  statement involve new constant d 
typical ontology axioms allowed wsc f wd are  subsumption relations  taking
form x   g x  h y   mutual exclusion  taking form x   g x  h y   relation reflexivity  taking form x   g x  x   relation symmetry  taking form x   
g x  y  g y  x   express concept g contained union concepts
h            hn   generally express complex dependencies concepts  taking form clausal constraints allowed combinations concept memberships 
one example complex dependencies important domain proteins illustrated
example    capturing dependencies important order able select correct web services  similar situations arise many domains involve complex interdependencies
and or complex regulations  example latter virtual travel agency discussed before  example  german rail system kinds regulations regarding
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

train may booked kind discount conditions  modeling
regulations would enable wsc algorithm select appropriate booking services  another interesting case hospital domain described de jonge  van der linden  willems        
there  problem hospital asset tracking handled means set tracking  logging
filter services  transform logs extract various kinds information  setting  would
make sense model complex dependencies web service composer may determine
hospital assets need tracked retrieved  namely  latter depends type operation
question  kind examinations operation requires  accordingly 
need model categorization operations  mapping sets required examinations 
examinations associated hospital assets  complications arise since
required examinations assets may depend particular circumstances  clearly  express
categorization dependencies terms clauses  course captures fraction
relevant hospital  considerably informed composer always
tracks assets 
main weakness wsc f wd allow us express changes regarding preexisting objects  best illustrated considering case negative effects   
planning community  commonly used model previous properties objects
invalidated action  illustration  reconsider example    say additional operator
dropcoffeein dmachine  effect info d y   one would normally expect that 
operator applied  fact info d y  deleted must re established 
wsc f wd   according restrictions special case imposes  variable info d y 
must output dropcoffeein dmachine  is  dropping coffee machine creates
new object  whose characteristic property happens info d y  rather info d y   clearly 
intended semantics operator 
model intended semantics  would need instantiate pre existing constant 
say that  belief b  example    constant e info d e  previously created
getinfo d n    c  e   wsc f wd allow us instantiate dropcoffeein dmachine
e  effect info d e   however  virtue definition action applicability 
action applicable states e yet exist corresponding execution
paths getinfo d n    c  e  executed  hence property info d e  get
deleted state  e used dropcoffeein dmachine still regarded newly
created object whose characteristic property info d y   difference new action
makes that  now  plan uses name  e  refer two different information objects
 output getinfo d n    c  e  vs  output dropcoffeein dmachine  play
role plan  cf  discussion section     
interesting workaround let operators output time steps  spirit reminiscent
situation calculus  mccarthy   hayes        reiter         every operator obtains extra
output variable t  included every effect literal  new time step stated stand
relation previous time steps  e g   next tprev  t  tprev input variable
instantiated previous time step  setting  state world changes
time  particular state object property different tprev 
example  action moves file f raedme readme could state
name f  raedme  tprev  name f  readme  t   problem construction
    or  wsc  positive effects triggering negative effects via ic   cf  proposition   

  

fih offmann   b ertoli   h elmert   p istore

time steps special interpretation  ordinary objects    causes
least two difficulties      want refer object property  know time step
first place is  know whether actual time step tprev  note
cannot maintain predicate actualtime x  would require us invalidate
property tprev      solution frame problem  operators must explicitly state
every relevant property previous time step  property changed new time
step   
conclude sub section  let us consider wsc f wd generalized without losing
lemma    importantly  instead requiring every effect literal involves new constant 
one postulate literals may actually affected integrity constraints 
particular  predicate appear clauses  certainly effect literal
predicate harmful even involve output constant  one obtains potentially stronger notion considering ground literals  rather predicates  note kind
generalization solves difficulty     time step construction  presuming time steps
constrained clauses   the frame problem  however  persists  
another possibility  deviating somewhat way wsc wsc f wd currently defined  define integrity constraints terms logic programming style rules  along lines
eiter et al                requirement wsc f wd relaxed postulate
effect literals without new constants appear rule heads 
remark latter observation suggests certain strategic similarity aforementioned derived predicates  thiebaux et al         previously used ai planning manage
complexity integrity constraints  there  integrity constraints take form stratified logic
programming style derivation rules  predicates appearing rule heads allowed
appear operator effects  overly restricted solution  wsc context  effects
web services indeed likely affect concepts relations appearing ontology
axioms  may wsc f wd   long output constants involved 
    belief update
lemma   specific possible models approach  winslett        underlies semantics
action applications  interesting consider semantics wsc f wd general
perspective belief update  recall update involves formula characterizing current
belief  formula describing update  seek formula characterizes updated belief 
wide variety definitions proposed updated belief defined 
however  common ground exists  katzuno mendelzon        suggest eight postulates 
named  u          u    every sensible belief update operation satisfy  herzig rifi
       discuss detail degree postulates satisfied wide range alternative
belief update operators  particular call postulate uncontroversial update operators
investigation satisfy them  take results following  examine
extent draw conclusions updated belief    setting forward effects
case  relying herzig rifis uncontroversial postulates 
    note similarity situation calculus ends  whereas time steps assigned specific role
formulas used situation calculus  ordinary objects handled actions  packages
blocks 
    despite difficulties  theorem   shows time step construction used simulate abacus
machine  hence prove undecidability plan existence wsc f wd  

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

assume planning task predicates p given  need following notations 
formulas  denotes formula results updating belief
update   semantics belief update operator  
given disjoint sets constants c e  p c e denotes set propositions formed
predicates p  arguments contained c e exists least one
argument contained e   recall p c denotes set propositions formed
predicates p arguments c  
given set constants c  ic  c  denotes instantiation ic c  is  ic  c 
conjunction clauses result replacing variables clause ic  
  x            xk   l   x    ln  xn    tuple  c            ck   constants c 
given disjoint sets constants c e  ic  c   e  conjunction clauses
result replacing variables clause ic     x            xk   l   x   
ln  xn    tuple  c            ck   constants c e  least one constant taken
e   
ground formula p    denote set propositions occurring  
denote current belief update   another convention  given set
constants c  writing c indicate p    p c   similarly  given disjoint sets constants
c e  writing c e indicate p    p c e   state  denote
conjunction literals satisfied s 
first consider case where  similar claim lemma    corresponds single
concrete world state s  want apply action a  wish characterize set states
res s  a   i e   wish construct formula   simplicity notation  denote c    cs
e    ea   applicable s  nothing do  otherwise  that 
 i  ic  c  c p   c   p c  
example  set c      since    ic   get desired equivalence  further 
that 
 iia  ic  c  ic  c   e  effa  
 iib  p  ic  c   e   p c e p  effa   p c e  
 iia  holds trivially  defined ic effa   equivalent ic  c e  effa
equivalent ic  c  ic  c   e  effa    iib   consequence forward effects
case  every effect literal contains least one output constant  hence effa contains propositions
p c e   ic  c   e   least one variable clause instantiated
constant e e  since  definition  literals clause share variables  e appears
every literal therefore ic  c   e  contains propositions p c e  
illustration  consider simple vta example  four predicates  train x  
ticket x   trainticket x   ticketfor  x  y   set integrity constraints ic consists
    clause ic contains variable  ic  c   e  empty  customary  empty conjunction
taken true  i e     

  

fih offmann   b ertoli   h elmert   p istore

single axiom x   trainticket x  ticket x   current state s  cs    c  
sets propositions   except train c   consider application action
  bookticket c  d   whose precondition train c   whose set e output constants  d  
whose effect effa trainticket d  ticketfor  d  c   setting  have  ic  c   
 trainticket c  ticket c    c    train c ticket c trainticket c ticketfor  c  c   
ic  c   e     trainticket d  ticket d   
derive following that 
 iii   ic  c  c    ic  c   e  effa   
is  characterize updated belief simply conjunction previous belief
action effect extended instantiation ontology axioms  corresponds
exactly lemma    illustrate  continue vta example  left hand side  iii 
refers four propositions based c  sets according s  right hand side
refers propositions based trainticket d  ticket d  well proposition
ticketfor  d  c  links c d 
one prerequisite derivation  iii   make assumption which  best
knowledge  discussed anywhere belief update literature 
 iv  let               formulas p      p          p      p          p     
p          p      p                                      
assumption postulates formulas talking disjoint sets variables updated
separately  since formulas disjoint variables essentially speak different aspects
world  seems reasonable assumption 
now  start formula   make replacements according  i   iia   leading
equivalent formula  ic  c  c    ic  c  ic  c   e  effa    map
formula onto  iv  taking   ic  c  c          ic  c    
ic  c   e  effa   hence  separate update two parts follows 
 a     c     ic  c  c   ic  c 
 b     c e       ic  c   e  effa  
according  iv   obtain desired formula    c    c e  
illustrating vta example  simply separate parts update talk
c talk combination constants   a  part
update trainticket c  ticket c  conjoined   updated trainticket c 
ticket c    b  part update   representing  empty  statement previous state
makes updated  trainticket d  ticket d   trainticket d  ticketfor  d  c  
remains examine    c    c e   need prove that 
 c     c ic  c  c  
 d     c e ic  c   e  effa  
essentially  means prove that   c  updating formula something already implies
incur changes   d  updating   formula yields belief equivalent formula 
see this  compare  a   c   b   d  
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

two statements may sound quite trivial  fact far trivial prove
wide variety of  partly rather complex  belief update operations literature  build
works katzuno mendelzon        herzig rifi         need two
postulates made katzuno mendelzon         namely 
 u                   
 u                       
herzig rifi        prove  u   uncontroversial  meaning satisfied belief
update operators investigated  cf  above   prove  u   equivalent conjunction two weaker statements  one uncontroversial  namely 
 u a                      
statement uncontroversial  however  proved satisfied non causal
update operators investigation  except so called winsletts standard semantics  winslett 
       latter semantics useful context anyway  restriction makes
states res s  a  differ propositions mentioned update
formula  case  include propositions appearing ic  c e   bound
quite lot  so  use winsletts standard semantics  res s  a  would likely
retain hardly information s 
consider formula    c specified  a      c    ic  c  c   ic  c  
prove  c   indeed quite simple   ic  c  c   ic  c  
instantiate    u   ic  c  c      u   ic  c   obtain
 ic  c  c   ic ic  c  c   hence    c ic  c  c desired 
said above  result uncontroversial  holds non causal update operators
 except winsletts standard semantics  investigated herzig rifi         terms vta
example   u   allowed us conclude update trainticket c  ticket c  make
change previous belief  already contains property 
next  consider formula   c e specified  b     c e     ic  c  e effa   
prove  d   postulate  u    get    c e ic  c   e  effa  
ic  c  e effa update formula     direction  exploit  u a   instantiate
   u a     get    ic  c   e  effa      ic  c   e  effa   
   ic  c   e  effa      c e   equivalent ic  c   e  effa
   c e   proves claim  note used postulates uncontroversial
according herzig rifi         reconsidering vta example  ic  c  e effa  
 trainticket d  ticket d   trainticket d  ticketfor  d  c   previous state say
anything propositions  thus represented    postulates allow us conclude
 for belief update operators investigated herzig   rifi        resulting belief
equivalent  trainticket d  ticket d   trainticket d  ticketfor  d  c  
far  restricted case   belief updated  corresponds single
world state s  consider general case characterizes belief b  want
characterize set states res b  a   first glance  seems much changes 
katzuno mendelzon        make following postulate 
 u                              

  

fih offmann   b ertoli   h elmert   p istore

means that  consists two alternate parts  updating taking union
updated parts  words  compute update state by state basis 
statement  i  still true  c disjunction states
b  rather single   rest argumentation stays exactly same  herzig
rifi        prove  u   uncontroversial leave that 
however  matters simple  source complications use partial
matches conditional effects semantics  update formula different individual states
b  hence cannot directly apply  u    obviously  states s  b applicable updated differently states s  b applicable latter updated all   
somewhat subtle distinction states b constants exist them  different
sets constants  integrity constraints update different  hence  obtain generic
update   split equivalence classes             n states within
cannot distinguished based prea based existing constants  then   u  
argumentation used show equivalent  iii    last step 
defining final disjunction individual   appears sensible 
follow immediately katzuno mendelzon        
illustration  consider variant vta example two preceding states  one
state train c  before  new state ticket c  instead   
bookticket c  d  applicable  hence update different   part
above  yielding result  trainticket d  ticket d   trainticket d  ticketfor  d  c  
update trivial  yields result  final outcome disjunction
two beliefs 
point situation much easier consider plug in matches  i e   forced preconditions  instead partial matches  there  applicable states  easy
see every state b constants  therefore  plug in matches   iii  follows immediately  u    vta example  update would computed since
bookticket c  d  would considered applicable preceding belief  satisfies
train c  disagrees aspect  e g   quite nonsensically  ticket c  holds 
updated belief equivalent  s    trainticket d  ticket d   trainticket d 
ticketfor  d  c  
    computational properties
paralleling analysis general wsc section      perform brief complexity
analysis wsc f wd special case  before  consider propositional case
assumes fixed upper bound arity predicates  number input output parameters
operator  number variables appearing goal  number variables
clause  before  consider decision problems checking plans  deciding
polynomially bounded plan existence  deciding unbounded plan existence  order 
contrast before  cannot reuse results literature much because  course 
particular circumstances wsc f wd investigated before  include proof sketches
here  refer appendix detailed proofs 
    one might speculate common update would prea   case  example 
possible models approach adopt wsc  updating    prea prea gives rise result
states change violate prea instead changing satisfy  

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

thanks simpler semantics per lemma    plan checking much easier wsc f wd
wsc 
theorem    plan checking wsc f wd   assume wsc f wd task fixed arity  sequence ha            actions  conp complete decide whether ha            plan 
proof sketch  hardness obvious  considering empty sequence  membership shown
guess and check argument  say c union c  output constants appearing
ha            i  guess interpretation propositions p c  further 
  n  guess set ct constants  needs time stamped because  action
generated outputs  properties respective propositions remain fixed forever  thanks
lemma    check polynomial time whether  a  ct correspond execution
ha            i  also  check polynomial time whether  b  cn satisfy g   ha           
plan iff guess answer  a  yes answer  b  no 
 
membership theorem   remains valid allowing parallel actions multiple conditional effects provided one imposes restrictions ensuring effects actions applied simultaneously  in one step  never self contradictory  otherwise  checking plans involves
consistency test plan step  np complete problem  note quite reasonable demand simultaneous actions effects contradict other  widely used
restrictions imposed ensure mutually exclusive effect conditions  and or non conflicting
sets effect literals 
next consider polynomially bounded plan existence  membership follows directly theorem    prove hardness  reduce validity checking qbf formula x y  x    
constructed planning task allows choose values x  thereafter apply actions evaluating arbitrary values   goal accomplished iff setting x exists works
 
theorem    polynomially bounded plan existence wsc f wd   assume wsc f wd task
fixed arity  natural number b unary representation  p   complete decide whether
exists plan length b 
proof sketch  membership  guess sequence b actions  theorem   
check np oracle whether sequence plan 
hardness proved reduction
wk validity checking qbf formula x y  x   
dnf normal form  i e     j   j   key idea use outputs creation
time steps  hence ensure operators adhere restrictions wsc f wd   setting
xi allowed time step i  is  xi operators oxi   oxi     take
input set time steps  t            ti    required successive  precondition
start t    next t    t    next ti    ti     output new time step ti attach
successor ti    set xi      respectively  time step i  is 
effect literal form xi  ti   xi  ti    respectively  rest planning task consists of 
operators ot allow extending sequence time steps step b  suitable value b  see
below   operators oj allow achieving goal  given j true end time
step sequence length b  integrity constraints  ic empty   values yi
specified  i e   variables take value initial belief 

  

fih offmann   b ertoli   h elmert   p istore

x y  x    valid obviously one construct plan task simply setting
xi accordingly  using ot stepping time b  applying oj   necessitates
complicated construction direction proof  namely  plan may cheat
setting xi      construction ensures costly  plan
forced maintain two parallel sequences time steps  starting faulty xi   choose
sufficiently large value b  together sufficiently small plan length bound b  cheating
possible 
 
final result regards unbounded plan existence  somewhat surprisingly  turns
still undecidable wsc f wd   similar above  key idea let actions output
new time step  thereby ensuring membership constructed task wsc f wd  
theorem    unbounded plan existence wsc f wd   assume wsc f wd task  decision
problem asking whether plan exists undecidable 
proof sketch  reduction halting problem abacus machines  undecidable 
abacus machine consists tuple integer variables v            vk  ranging positive
integers including     tuple instructions i              state given content
v            vk plus index pc active instruction  machine stops iff reaches state
pc   n  vi initially    pc initially    instructions either increment variable
jump another instruction  decrement variable jump different instructions
depending whether variable already   
difficult encode abacus machine wsc f wd task  two key ideas are     
design operator outputs next successor integer      design operators simulating
instructions  stepping successors predecessors integer values  latter kind
operators  membership wsc f wd ensured letting operators output new time step
new variable values associated  goal asks existence time step
active instruction  
 
argued end section     already  dont deem undecidability unbounded plan
existence critical issue practice  planning tools nature semi decision procedures 
anyway  particular  web service composition typically expected occur real time setting 
severe time outs apply 
    issues adapting cff
view  crucial observation wsc f wd test plans conp 
rather p  general wsc  standard notions planning uncertainty
complexity plan testing  research already resulted sizable number approaches
 comparatively  scalable tools  cimatti et al         bryce et al         hoffmann   brafman 
      palacios   geffner         show next section that  certain additional
restrictions wsc f wd   tools applied off the shelf  regarding general wsc f wd  
match complexity plan testing suggests underlying techniques successfully
adapted  following  consider detail cff tool  hoffmann   brafman        
promising options would extend mbp  cimatti et al         pond  bryce et al  
       look compilation techniques investigated palacios geffner        
cff characterized follows 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

    search performed forward space action sequences 
    sequence a  cnf formula  a  generated encodes semantics a 
sat reasoning  a  checks whether plan 
    reasoning results namely literals always true executing cached
speed future tests 
    search guided adaptation ffs  hoffmann   nebel        relaxed plan heuristic 
    relaxed planning makes use strengthened variant cnf formulas  a  used
reasoning action sequences  clauses projected onto  
literals  i e     literals removed respective clause  
techniques self explanatory  except possibly last one  projecting cnf
formulas ensures relaxed planning remains over approximation real planning 
projected formulas allow us draw conclusions  time  projected
formulas handled sufficiently runtime efficiently    method   projecting
clauses is  nutshell  ignore one condition literals conditional effect
relaxed planning graph 
fairly obvious basic answers given cff  i e   techniques          apply
wsc f wd   note that  indeed  main enabling factor check plans conp 
rather p  general wsc  enables us design desired cnf formulas  a 
straightforward fashion  plan checking p   hard  either need replace cnf
formulas qbf formulas  create worst case exponentially large cnf formulas 
are  least  technically quite challenging 
adaptation cff wsc f wd immediate promise  trivial  involves
technical challenges regarding on the fly creation constants well computation
heuristic function  latter brings significant new opportunities wsc context 
pertaining exploitation typical forms ontology axioms  let us consider issues
little detail 
first  todays planning tools  cff pre instantiates pddl purely propositional
representation  based core planning algorithms implemented  one allows on thefly creation constants  pre instantiation longer possible  hence adaptation
wsc f wd involves re implementing entire tool  challenge itself 
difficult obstacles overcome  sloppy formulation key question is  many
constants create  one can  course  create new tuple constants  the outputs of 
every new action application  however  seems likely approach would blow
representation size quickly  would hence infeasible  one instead share
output constants reasonable  one recognize reasonable points  issue
especially urgent inside heuristic function  namely  easy see that  worst case 
relaxed planning graph grows exponentially number layers  imagine example
web service w  takes input type generates output type b  whereas w  takes
input type b generates output type a  starting one constant type
one type b  get   constants type next graph layer  then  w  w 
    inside heuristic function  formulas come relaxed planning graphs quite big  handling
without approximations seems hopeless  discussed detail hoffmann brafman        

  

fih offmann   b ertoli   h elmert   p istore

applied two times  get   constants type next graph layer  forth 
dilemma probably cannot handled without making approximations relaxed
planning graph 
one positive note  seems possible exploit typical structures ontologies
practice  particular  practical ontologies make extensive use subsumption relations 
structuring domain interest concept hierarchy  additional ontology axioms often come
form constraints relations  reflexivity  symmetry  transitivity  typing number
relation arguments  may make sense exploit structures optimizing
formulas  a  associated sat reasoning  certainly  makes sense exploit structures
inside heuristic function  one include specialized analysis sub solver techniques
recognize structures solve separately order obtain precise relaxed plans 
one even try take account structures inside relaxed planning  hence
 potentially  obtain fast heuristic function 

   compilation initial state uncertainty
show that  certain additional restrictions  off the shelf scalable tools planning
uncertainty exploited solve wsc f wd   main limiting factors are     
tools allow generation new constants      tools allow specification
clausal formula initial state  states  approach deal     considers
set constants fixed priori  namely initially available constants plus additional potential
constants used instantiate outputs  subtle observation that  within special
case wsc f wd   dynamics states become predictable priori  one deal
    natural way 
follows  first introduce core observation case state space becomes
predictable  certain sense  observe predictability naturally given special
case forward effects  term strictly forward effects  discuss strengths limitations new special case  finally provide compilation strictly forward effects
planning initial state uncertainty 
    predictable state spaces
core observation based notion compatible actions  assume wsc f wd task  p  ic  
o  c        g    two actions a  compatible either ea ea     effa   effa   is 
either disjunct outputs hence affect disjunct sets literals since
wsc f wd effects agree completely  set actions compatible ea c   
a  every pair actions compatible 
lemma   states that  given used actions compatible  every state ever reached
satisfies action effects  modulo existing constants 
lemma    predictable state spaces wsc f wd   assume wsc f wd task  compatible set
actions a  state reached actions a       and  a 
ea cs    effa  
proof  proof induction  base case  b    claim holds definition since
cs ea   a  say reached action a  applicable

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

s  induction assumption nothing prove  otherwise  wsc f wd  
lemma   res s  a      c       c   cs ea    cs        ic effa   
v
induction assumption applied s  res s  a      c       c   cs ea     
  a e cs effa ic effa    now  ea cs ea ea   cs  

 
ea ea    hence effa   effa prerequisite  concludes argument 
virtue lemma  possible configurations constants
generated
v
actions characterized formula ic   aa effa   since parts
formula known prior planning  set possible configurations predictable 
even begin plan  already know constants behave generated 
list possible behaviors potential constants initial belief  let actions
affect constants actually exist  words  compile initial state
uncertainty  detail below  first  need identify setting lemma  
actually applied 
    strictly forward effects
given wsc f wd task  must settle finite set compatible actions planner
try compose plan from  one option simply require every action
unique output constants  appears undesirable since planning tasks often contain many actions 
set potential constants would huge  further  enable chaining several actions 
potential constants allowed instantiate input parameters every operator  hence
necessitating creation new action and  that  new potential constants  unclear
break recursion  sensible way 
herein  focus instead restriction wsc f wd suffices assign unique output
constants individual operators  rather individual actions 
definition   assume wsc task  p  ic   o  c        g    task strictly forward effects
iff 
   o  l x  effo    x      x yo  
   clauses ic     x            xk   l   x    ln  xn    x   
  xn  
set wsc tasks strictly forward effects denoted wsc sf wd  
second condition identical corresponding condition wsc f wd   first condition strictly stronger  wsc f wd requires least one effect literal variable taken
outputs  wsc sf wd requires variables taken outputs  therefore 
obviously  wsc sf wd wsc f wd   note wsc task formulated example   member
wsc sf wd  
key property wsc sf wd that  without input variables effect  actions based
operator effect  so  action set compatible  need
choose set unique output constants every operator  indeed  every set
operators whose effects pairwise identical  choose several sets output constants
group operators 
  

fih offmann   b ertoli   h elmert   p istore

    modeling power
limitations wsc f wd   discussed section      naturally inherited wsc sf wd   moreover  unlike wsc f wd   cannot state properties effect connect inputs
outputs  serious limitation  illustration  consider small vta example
using  operator bookticket effect ticketfor  y  x   relating produced ticket
train x given input  clearly  notion ticket rather weak cannot state
ticket actually valid for  another interesting case one extend example   considering two proteins rather one  is  set c     c  c       
cellprotein c  cellprotein c    wish encode need combined presentation
those  i e   g     combinedpresentation y  c  combinedpresentation y  c    wsc f wd  
solve including  every information providing operator  input variable x
effect literal  example  set getinfo d n        x    n   x    y   info d y  x   
possible wsc sf wd  
extent  difficulties overcome encoding relevant inputs predicate names  handle composition two proteins c c   would essentially mean
making copy entire model renaming part c   goal would g   y   
combinedpresentation y  combinedpresentation  y    operator preconditions would make
sure combinedpresentation y  generated before  combinedpresentation  y   generated using new operators  note rather dirty hack  depends knowing
number copies needed  prior planning  equivalent solution vta would introduce
separate ticketfor x predicate every entity x ticket may bought 
least  would result rather oversized unreadable model  yet troublesome case
time step construction outlined section      added new output variable
effect related via effect literal next prevt  t  previous time step prevt provided
input  wsc sf wd   longer relate prevt way stating time
step happens one  trying encode information predicate names 
would include one predicate per possible time step  necessitates assuming bound
number time steps  clear limitation respect natural encoding 
despite above  wsc sf wd far pathological irrelevant special case  example
applies domain proteins shown example    similarly  hospital domain
discussed section     naturally modeled wsc sf wd   generally  fact
wealth wsc formalisms encode connections inputs outputs 
example  category contains formalisms rely exclusively specifying types
input output parameters  information modeled types kind input
service requires  kind output produces example  input train output
ticket  examples formalisms various notions message based composition  zhan
et al         constantinescu et al       a  lecue   leger        lecue   delteil        kona
et al         liu et al          fact  early versions owl s regarded inputs outputs
independent semantic entities  using description logic formalization types 
thus  existence compilation wsc sf wd planning uncertainty quite
interesting  shows composition model similar early versions owl s  general
form partial matches powerful background ontologies  attacked off the shelf
planning techniques  opens new connection wsc planning 

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

    compilation
compile wsc sf wd task task conformant planning initial state uncertainty 
takes form  p  a      g    p finite set propositions used  finite set
actions  takes form  pre a   eff a   pair sets literals p   
cnf formula p  g conjunction literals p  notions given standard
belief state semantics  state truth value assignment p  initial belief set states
satisfying     result executing action state res s  a         pre a    
otherwise res s  a      sadd a   del a   use standard notation gives terms
set propositions makes true  uses add a  denote positive literals eff a  
del a  denote negative literals eff a   extension res beliefs definition
plan remain unchanged 
assume wsc sf wd task  p  ic   o  c        g    compiled task  p   a      g   makes
use new unary predicate ex expresses constants yet brought existence  compilation obtained follows  operator o  outputs
yo  

 y            yk    create set new constants eo    e            ek    then  c    c  oo eo
set constants fixed priori  initialize      operator o 
v include

preo   xxo ex x  
v
v set actions resulting using c instantiate precondition
  eeo ex e    give actions effect  eeo ex e   words  instantiate os outputs eo   enrich os precondition saying inputs exist
outputs yet exist  replace os effect statement simply bringing outputs
existence 
replacing effects way  original effects go  included
initial state formula  is  initialize   conjunction effo  eo  yo   operators
o  then  instantiate clauses invic c andv
conjoin     obtain final
  conjoining     cc  ex c   cc c  ex c   goal  here  goal
new proposition  serves model goal  namely  introduce set artificial
goal achievement actions  goal form g   x       v
    xk   x            xk    new actions
obtained instantiating operator   x            xk    ki   ex xi      goal  c 
is  goal achievement actions instantiate existentially quantified variables goal
possible constants  actions added set a  overall compiled task takes
form  p   a      goal   p simply set mentioned propositions 
summary  compile wsc sf wd task  p  ic   o  c        g   conformant planning
task  p   a      g   follows 
operator o  create uniquesset new constants eo    e            ek  
yo    y            yk    denote c    c  oo eo  

p contains instantiations  c  p plus two new predicates  ex goal  ex
arity   expresses constants yet brought existence  goal arity  
forms new goal  i e   g   goal 

actions instantiations o  xv
instantiated
vc  yo inex x  

 
stantiated eo   preconditions

enriched

 
eeo ex e   
xxo
v
effects replaced eeo ex e  

    before  give actions conditional effects semantics  rather usual distinction forced
preconditions  non forced effect conditions 

  

fih offmann   b ertoli   h elmert   p istore

further  contains goal achievement actions  achieving goal preconditions instantiating g c 
original action effects  i e   conjunction effo  eo  yo   operators
o 
v
  further  contains  
moved


instantiated

c 

 
 
ic
 
 
cc  ex c  
v
cc c  ex c   goal 

terminology section      means choose set actions actions
obtained operator instantiating inputs constants c 
outputs eo   suggested lemma    initial state formula   compiled
task describes possible configurations constants c  effect applying
action bring respective output constants existence  note that  although effects
compiled actions positive  planning still hard  conp complete  precise  due
uncertainty   if allow wsc operators delete constants  negative effects
deleting constants compiled task  
according strategy  create one set output constants per operator 
take account sets operators identical effects  simplify
presentation  results carry immediately complicated strategies create
one set output constants per operator  well strategies share sets output
constants operators identical effects  noted  however  operators
whose effects identical not  general  share outputs  particular  two
effects conflict  e g   infodssp d  infodssp d   initial state formula  
unsatisfiable  compiled planning task trivially solved empty plan  and 
course  encode solutions original problem 
example   re consider planning task defined example    specify compiled task  set
c    c  d  e  f   c initially available constant  d  e  f potential constants
operator outputs  compiled planning task  p   a      g   following 
p    protein  cellprotein  g  h  i   n     kw   combinedpresentation  infodssp 
info d  ex  goal   predicates except goal unary  have one argument  
consists instantiations of 
getinfodsspg  d y     x   g x  ex x  ex d   ex d  
getinfodssph  d y     x   h x  ex x  ex d   ex d  
getinfodsspi  d y     x   i x  ex x  ex d   ex d  
getinfo d n    e y     x    n   x  ex x  ex e   ex e  
getinfo d kw   e y     x    kw  x  ex x  ex e   ex e  

combineinfo f  y     x    x     infodssp x    info d x    ex x    ex x   
ex f    ex f   
goalop    x   combinedpresentation x  ex x   goal 
  conjunction of 
instantiations ic  consisting five axioms given example   
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

cellprotein c      
infodssp d  info d e  combinedpresentation f    original action effects 
ex c  ex d  ex e  ex f    constants existence 
goal  goal yet achieved 
g   goal
consider plan original task  see example     hgetinfodsspg  c  d  
getinfodssph  c  d   getinfo d n    c  e   getinfo d kw   c  e   combineinfo d  e  f  i 
illustrate  verify plan yields plan compiled task  task 
initial belief b  consists states c existing constant  d  e  f satisfy
respective effects     ic cellprotein c   apply action sequence 
   apply getinfodsspg  c  d  b    get belief b  b  except that 
b     g c   exists 
   apply getinfodssph  c  d  b    get belief b  b  except that 
b     h c   exists 
   apply getinfo d n    c  e  b    yielding b   
   apply getinfo d kw   c  e  b    brings us b  ex e  b 
    n   c      kw  c  
   apply combineinfo d  e  f   b    brings us b  b  except b 
e exist ex f   
   apply goalop f   b    yielding b   
reasoning ic used example   show b  satisfies original goal 
used show goalop f   applicable b  hence resulting belief b 
satisfies goal  obtain plan compiled task simply attaching goal achievement
action original plan 
prove soundness completeness compilation  need rule inconsistent
operators  i e   operators whose effects conflict background theory  meaning
ic xo   yo   effo unsatisfiable   example  case x   a x  b x 
contained ic   effo   a y  b y   presence operator  initial belief
compiled task empty  making task meaningless  note inconsistent operators
never part plan  hence filtered pre process  note that  wsc sf wd  
operator inconsistent iff actions based inconsistent 
non goal achievement actions correspond actions original task  obvious
way  connection  transform plans compiled task directly plans
original task  vice versa 
theorem    soundness compilation  consider wsc sf wd task  p  ic   o  c        g  
without inconsistent operators plan ha            compiled task  p   a      g   
sub sequence non goal achievement actions ha            plan task
 p  ic   o  c        g   
  

fih offmann   b ertoli   h elmert   p istore

proof sketch  arbitrary sequence non goal achievement actions  denote b belief
execution original task  b belief execution compiled task 
state ssin original task  denote  s  class compiled task states overvthe constants
c  oo eo  c
  s ex c          cs   s cs        ic   oo effo  eo   
one prove b   sb  s   claim follows directly that 
 

theorem    completeness compilation  consider wsc sf wd task  p  ic   o  c       
g   without inconsistent operators plan ha            every operator appears
one instantiation eo outputs  ha            extended goal achievement
actions form plan compiled task  p   a      g   obtained using outputs eo  

proof sketch  follows immediately b   sb  s  shown proof theorem    say
one executes ha            compiled task  ending belief b  there  plan
compiled task obtained simply attaching one goal achievement action every tuple
constants satisfying g world state b 
 

reader may noticed number instantiations goal achievement operator
exponential arity goal  worst case  instantiations must included
plan compiled task  particular  may happen plan constructed per
proof theorem    however  practical purposes appears reasonable assume fixed upper
bound number goal variables 
indicated  proofs theorems     remain valid allowing one eo
per operator  and or operators identical effects share output constants  note operators identical effects several web services provide alternative ways achieving something 
example   illustrates situation  cf  earlier discussion section       experiments
described next section  groups operators identical effects assigned
output constants 

   empirical results
show compilation approach merits  report number empirical experiments using cff underlying planner  start discussion general experimental
setup discuss results two different test scenarios 
    experiments setup
implemented compilation wsc sf wd planning uncertainty described
above  connected cff tool  noted that  although compiled planning
tasks delete effects  solved cffs relaxed plan based heuristic function 
function makes relaxation ignoring one conditions effect  see
earlier discussion cff section       ignoring one condition significantly affects
compiled tasks effects typically involve many conditions  particularly conditions
stating inputs exist outputs yet exist 
one problematic point evaluating planning based wsc choice test cases  field
still rather immature  due widely disparate nature existing wsc tools 

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

common set benchmarks    fact  web service composition new topic
posing many challenges existing techniques  different works differ widely terms
underlying purpose  specific aspect wsc address  detailed discussion
existing wsc tools given section    method choose evaluation design
two test scenarios reflect intuitively relevant kinds problem structures potential
applications planning based wsc  scalable number interesting parameters 
test reaction approach parameters 
test scenarios artificial benchmarks  cannot lead broad conclusions significance practice  allow us draw conclusions planning behavior differently
structured test problems  solution method scales quite well tested cases  efficiently finding solutions involve many web service calls  successfully employ
services really necessary  viewing results isolation  one conclude
representation techniques heuristic functions planning uncertainty may useful
attack large complex planning like wsc instances 
comparison alternative wsc tools is  again  problematic  due broad range problems tools solve  different kinds solutions find  different kinds input
syntax language read  obtain least notion empirical comparison tools 
following consider expressivity  how general input language tool  
scalability  how quickly tool compose    existing wsc tools constitutes
separate point trade off two  question whether compilation
approach  restricting wsc sf wd using cff solve compiled tasks  sensible point
trade off 
terms expressivity  approach located general planning methods  like
eiter et al               giunchiglia et al          inspired actions change literature 
restricted methods applied wsc far  question whether gain
scalability comparison expressive methods 
confirm experiments answer is  expected  yes  run dlvk tool
 eiter et al                handles powerful planning language based logic programming 
language particular features static causal rules similar integrity constraints
fully general wsc    sense  perspective dlvk native wsc tool
handles ontology axioms directly rather via restricting expressivity compiling
away  particular  encoded wsc test problems directly dlvks input language  without
compilation use cff 
dlvk relies answer set programming  instead relaxed plan heuristics  find plans  further  style many reasoning based planners  dlvk requires input length bound
plan  hence used find optimal plans running several times different bounds 
cases  ran dlvk once  bound corresponding optimal plan length 
even so  dlvk much slower cff  solving small fraction test instances 
wish over interpret results  conclude wsc sf wd constitutes interesting
point trade off expressivity scalability wsc 
    vta example could considered one benchmark  essentially every individual approach defines
particular version example 
    similarity lies static causal rules fully general integrity constraints can  side effect applying
action  yield ramifications affecting properties inherited previous state 

  

fih offmann   b ertoli   h elmert   p istore

running first tests compilation approach  noticed encoding
per section     unnecessarily generous set initial states  observe compiled
tasks always easier solve propositions true initial state  is  simply  literals operator preconditions  effects  goal positive  hence  proposition
p appear positively initial state clause  one set p   initially  thereby
reduce number initial states  without introducing new plans    setting proposition
  may cause unit propagations  setting propositions      iterate steps
fixpoint occurs  resulting initial state description stricter before  yields better performance cff dlvk  use optimized encoding experiments reported
below 
experimented another optimization  optimization makes assumption
constants requested goal generated step wise fashion  intermediate
constant generated certainty generating next constant  recallvthat encoding
per section      existence inputs operators  i e   condition xxo exists x  
part operator precondition thus interpreted conditional effects semantics  however  cff dlvk offer distinction effect conditions forced preconditions
must hold entire belief
action applicable  exploit distinction
v
postulate condition xxo exists x  forced  reduces state space  may cut
solutions  reduction quite beneficial cff dlvk  since optimization
affects set plans  switch part test cases  point possible speedup  tests optimization switched discussed text  indicated
keyword forced name test case 
use two versions cff  one cffs default configuration makes use ffs enforced hill climbing search algorithm well helpful actions pruning technique  hoffmann
  nebel         configuration  cff helpful actions pruning turned off  search
proceeds standard greedy best first fashion  open queue ordered increasing heuristic
values  henceforth denote former configuration cff def latter configuration
cff std 
results obtained    ghz pentium iv pc running linux  tests run
time out     seconds cpu  limiting memory usage   gb 
    subsumption hierarchies
first investigate well approach deal scaling subsumption hierarchies 
building chains successively created entities  outputs   purpose  design test scenario
called sh  demands composition web services realizing chain generation steps 
every generation step deal subsumption hierarchy 
scenario depicted figure    n top level concepts l            ln   depicted
tl figure    goal input l    goal output ln   beneath li  
tree shaped hierarchy sub concepts  precisely  tree perfectly balanced
branching factor b  depth d  inner nodes tree called intermediate level
 or simply intermediate  concepts  depicted il figure    leaf nodes tree
called basic level  or simply basic  concepts  depicted bl figure    every
non leaf concept c tree  children c            cb   axioms x   ci  x  c x 
    course  reducing set initial states invalidate old plans  either 

  

fitl

w eb ervice c omposition p lanning u ncertainty  n ew c onnection

il

il

bl

bl

bl

bl

bl

bl

sws

sws

sws

sws

sws

sws

tl

il

bl

il

bl

bl

bl

bl

bl

figure    schematic illustration sh scenario 
expressing subsumption  well axiom x   c x  c   x  cb  x  expressing
parent covered children 
available web services defined follows  top level concept li  
leaf bli j corresponding tree structure  web service available takes
bli j input outputs li     corresponding wsc operator takes form oi j  
  x   bli j  x    y   li    y    then  applying      n order  services oi j  
possible make sure constant concept li   created possible cases  hence 
sequencing steps plan  length  n    bd   note that  already stated
section      experiments groups operators identical effects assigned
output constants  sh scenario  means     n  oi j share
output constant  hence total number output constants generated  i e   number
potential constants initial state  equal number top level concepts  n 
although sh scenario abstract nature  representative variety relevant
situations  specifically  scenario model situations sets different services must
used address request none handle alone  role single service
handle particular possible case  example  set different services
set services oi j assembled li   given constant c member li   i e  
li  c  holds  particular possible case handled service oi j case c happens
member leaf bli j one cases must hold due coverage clauses tree 
  

fih offmann   b ertoli   h elmert   p istore

similar situations arise  e g   geographically located  regional  services composition
request location specific addresses locations higher  inter regional  level  similar
pattern found e government scenarios clear cut classification activities
leads establishing several parallel services serve different departmental areas 
orthogonal horizontal composition  scenario model vertical composition 
one function pursued concatenating existing functions  case
complex procedures diverse areas e government e commerce 
scenario instantiated study different aspects scalability approach 
empirical tests measure scalability horizontal vertical direction  further 
consider two extreme cases possible shapes individual concept trees chain 
giving us instances identical numbers leaves  set test scenario sh broad 
    b scales                  set test scenario sh deep  b    
scales                scenarios  n scales      
further  designed sh trap variant second chain n concepts linked 
completely irrelevant goal service  variant suitable testing extent
composition techniques affected irrelevant information  finally  recall encoding
method
comes two versions explained above  default method treats input existence
v
xxo exists x  conditional effects semantics  whereas non default method  forced 
compromises completeness efficiency treating input existence forced precondition 
all  following choices    different planners  cff def  cff std  dlvk  
  different encoding methods  sh without trap  sh broad sh deep  crossproduct choices yields    experiments  within    possible values
n   possible values b d  i e      test instances  cff  measured   performance
parameters  total runtime  number search states inserted open queue  number
actions plan  dlvk  measured total runtime number actions plan 
course  large amount data interesting  follows  summarize
important observations  figure   shows data selected purpose  part  a  figure
shows cff std sh broad   b  shows cff std sh deep   c  shows cff def sh forcedbroad   d  shows dlvk sh broad sh deep   e  shows dlvk sh forced broad
sh forced deep   f  shows dlvk cff std sh trap  vertical axes show log scaled
runtime  sec   horizontal axes show n  a    b   c    d    e   f   n fixed n    
horizontal axes show number leaves concept hierarchy 
consider first figure    a   b   plots point efficiently cff handle
kind wsc problem  even forced optimization  comparing two plots points
difference handling broad deep concept hierarchies  plots  cff std runtime
shown n  length chain built   a   show   curves   different
values b  the number leaves hierarchy depth      b  show   curves  
different values  the depth hierarchy branching factor     cases  scaling
behavior fairly good  small concept hierarchies  b           chains almost arbitrary
length built easily  hierarchies grow  runtime becomes exponentially worse  note 
however  one curve next size hierarchies doubles  growth
exponential  concept hierarchies    leaves  i e      alternative cases handled
step  still easily build chains   steps  solution involves    web services 
interesting aspect comparing two plots   a   b   underlying search spaces
actually identical  open queues same  difference performance stems
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

   

   

  

  

 

 

b  
b  
b  
b   
b   

   

    
 

 

 

 

  

  

  

d  
d  
d  
d  
d  

   

    

  

  

  

 

 

 

 a  cff std sh broad

 

  

  

  

  

  

  

 b  cff std sh deep
     
sh broad
sh deep
    

   

   

  
  

 
 

   
   

    
 

 

 

 

  

  

  

  

  

  

    
 

 

 c  cff def sh forced broad

 

 

 

 d  dlvk sh broad sh deep

     

     
sh forced broad
sh forced deep

dlvk sh trap broad
dlvk sh forced trap broad
cff std sh trap broad

    

    

   

   

  

  

 

 

   

   

    

    
 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

 

 e  dlvk sh forced broad sh forced deep

 

 

 

  

  

  

  

  

  

  

  

  

  

 f  dlvk cff std sh trap

figure    selected results sh scenario  see detailed explanation text 

  

  

  

fih offmann   b ertoli   h elmert   p istore

overhead cffs reasoning techniques  consume runtime case deep
concept hierarchies  hence slightly worse behavior  b  
run cff def test suites figure    a   b   obtain much worse behavior 
example  b     get n      reason seems ffs helpful actions
pruning enforced hill climbing greedy domain  simple way overcome
use standard heuristic search algorithm instead  done cff std shown figure    a 
 b   hand  forced optimization switched on  helpful actions pruning
enforced hill climbing work much better  obtain significant performance boost using
cff def  latter pointed figure    c   showing data cff def sh forced broad 
figure    a  cff std sh broad  plot shows   curves  one   values
b  legend omitted plot would overlap curves   see that  case 
easily build arbitrarily long chains even b       giving us solution involving     web
services n       even b       still get n     
figure    d   e  show one gets trying solve examples  encoding
directly dlvk instead using compilation solving cff  expected 
performance much worse  since hardly test instance solved n      fixed n
minimum value   plots  unlike  a    b   c    d   e  shows data
broad deep variants  showing number leaves horizontal axis  order obtain
fine grained view  broad variant increase number steps   rather
multiplicative factor   before  see that  without forced optimization figure    d 
performance poor  largest case solve n      b     solution involves
  web services  switch forced figure    e  performance dramatically improved
still different level obtain compilation cff 
figure    f   finally  exemplifies results get trap scenario  show data
broad version  default encoding cff std  default forced
encoding dlvk  dlvk quite affected irrelevant chain concepts  solving
single instance n      b     default encoding  getting n      b     
forced encoding  instead n      b      without trap  behavior expected since
dlvk make use heuristic techniques would able detect irrelevance
second chain concepts  question whether cffs techniques better that  figure  
 f  shows cff std largely unaffected n     one see comparing curve
points vertical axis figure    a   however  n     performance cff std
drastically degrades  instances solved n      b     n      b      reason
seems additional actions yield huge blow up open queue used global
heuristic search algorithm cff std  indeed  picture different using cff def
forced encoding instead  search spaces identical explored trap 
behavior get identical shown figure    c  
plans found sh scenario optimal  i e   plans returned contain web
services needed  single exception dlvk trap  solutions include
useless web services trap chain   
    note dlvks plans parallel  parallel length optimal  because provided correct plan
length bound  cf  section      however  parallel step may contain unnecessary actions  top necessary
ones  thats happens trap 

  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

    complex concept dependencies
two variants sh scenario feature tightly structured relationships involved
concepts  allow investigation scalability issues varying size structure 
consider advanced scenario  way top level concepts covered lowerlevel concepts subject complex concept dependencies  similar axioms constraining protein classes characteristics example    therefore investigate performance
impacted complex concept structures subsumption hierarchies 
tl

tl

il

il

il

il

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

tl

tl

il

bl

bl

il

il

bl

bl

bl

bl

bl

bl

il

bl

bl

bl

bl

figure    schematic illustration cd scenario vs  sh scenario 
new scenario called cd  concept dependencies  figure   illustrates scenario 
contrasts sh scenario  similarly sh  top level concepts 
one associated set basic sub concepts  b basic concepts
every top level concept  n top level concepts l            ln   goal achieve
ln starting l    before  done combining web services cover
possibilities  namely  every top level concept li every basic concept bli j associated
it  operator oi j      x   bli j  x    y   li    y     
difference lies connection basic concepts top level concepts 
sh  rigidly given terms tree structure subsumption coverage axioms
intermediate concepts  every basic concept i e   every operator oi j corresponding
concept included plan order cover possible cases  cd  use instead
complex set axioms connect basic concepts top level  top level concept
intermediate concepts ili             ili m   axioms stating ili j
    note that  i  operators assigned output constant compilation
technique 

  

fih offmann   b ertoli   h elmert   p istore

sub concept li   well axiom x   li  x  ili    x  ili m  x  stating
li covered ili             ili m   connection intermediate concepts
basic concepts  complex dependencies used  intermediate subconcept constrained
covered non empty set combinations basic subconcepts  precisely  create
random dnf  positive literals  using basic concepts predicates  take
dnf imply ili j   note that  implication  dnf negated hence becomes
cnf  directly encode formalism  every ili j  
setting  interesting control many combinations required cover
top level concept li   directly corresponds total number random combinations  random dnf disjuncts  generated  intermediate concepts ili j taken together 
control via call coverage factor  c  ranging          b   possible
combinations basic concepts  pick random subset size c   b     combination associated dnf randomly chosen intermediate concept  note cnf
formulas generated way may enormous  minimize size encoding  use
formula minimization software espresso  brayton  hachtel  mcmullen    sangiovanni vincentelli 
      mcgeer  sanghavi  brayton    sangiovanni vincentelli        
hypothetically c set   task unsolvable  experiments reported below 
whenever write c      means exactly one combination selected  associated
every intermediate concept 
escaping rigid schema relationships presented sh  cd scenario suitable test whether performance approach tied specific structure sh
problem  moreover  way cd designed allows us determine degree planners
react intelligently different concept structures  particular  scenario allows analysis of 
   ability approach  particular selected underlying planner cff  identify plans contain relevant actions  especially coverage factor c low 
basic subconcepts may never appear partition intermediate concepts  thus 
plan need include respective operators  still  due conditional effects partial matches semantics  plans include operators valid plans  evaluating
plan length performance varying c therefore interesting 
   ability approach deal complex axiomatizations  measured
terms impact coverage factor runtime performance  randomization
choice combinations basic factors  different settings c  may induce significant
differences cnf axiomatizations  result  subject underlying reasoning
engine different situations 
summary  cd scenario representative situations complex dependencies must
taken account order select correct services  examples domains discussed
sections          particular  cd scenario corresponds closely  a scalable version of 
protein domain example  different values dssp code correspond different basic
concepts  respective getinfodssp services operators taking intermediate
concept  infodssp y   similar amino acids    d shapes  shapes complexes 
top level concept combinedpresentation y  achieved constants every intermediate
concept created  so  difference cd lies that  rather single
top level concept generated intermediates  cd sequence top level concepts
need generated turn 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

sh scenario  total data experiments extensive  even since
  scenario parameters rather   before  since individual instances contain
random element  figure    report selected results pointing main observations  part
 a   b  figure show cff std runtime plan length n      b       c   d  show cffstd runtime search nodes c n           b       e  shows dlvk cff std runtime
b cd n      c          f  show latter data cff def cd forced 
figure    a   b  consider scalability solution lengths test varying size
scenario  representing different coverage factors different lines  report data cffstd  results similar cd forced cff def  i e   contrary sh  cd setting
options bring significant performance gain  see figure    a  cff scales
pretty well  though well sh  easily able solve tasks   top level concepts
  intermediate concepts   basic concepts  tasks minimum coverage factor 
c       solved particularly effortlessly  higher c values  one observe somewhat
easy hard easy pattern  where  example  curve c        lies significantly
curves c       c        examine easy hard easy pattern detail below 
figure    b   obvious expected observation plan length grows linearly
n  i e   number top level concepts  likewise obvious  much important 
observation plan length grows monotonically coverage factor c  reported above 
lower coverage factor opens opportunity employ less basic services  namely
relevant ones  figure    b  clearly shows cff std effective determining
services relevant not 
let us get back intriguing observation figure    a   easy hard easy pattern
growing c  figure    c   d  examine phenomenon detail  plots scale c
horizontal axis  fixed setting n  b  runtime shown  c    d  shows
number search states inserted open queue  value c  plots give
average standard deviation results    randomized instances  clearly see easyhard easy pattern  c  runtime  high variance particularly c         d  
see pattern number search states  variance much less
pronounced  shows easy hard easy pattern due differences actual search
performed cff  due effort spent search nodes  traced behavior cff
detail  found reason easy hard easy pattern lies runtime cff spends
sat reasoning state transitions  i e   reasoning uses determine facts
definitely true false belief  high non     values c  cnf encodings
concept dependency structures take rather complex form  cases cff takes lot
runtime  almost runtime spent within single call sat solver  is  seems
cffs sat solver exhibits kind heavy tailed behavior formulas  phenomenon
well known sat cp community  see example work gomes  selman  crato 
kautz         noted that  typical planning benchmarks  cnfs much
simpler structure  motivates use fairly naive sat solver cff  using neither clause
learning restarts  order save overhead formulas simple anyway  seems likely
addition advanced sat techniques solver could ameliorate observed problem 
finally  figure    e   f  compare performances compilation cff dlvk  with
compilation   plots fix n      i e   data shown   top level concepts 
instances dlvk solves n     ones forced optimization used n     
     b      further  plots c fixed c         reason
  

fih offmann   b ertoli   h elmert   p istore

    

  

c   
c    
c    
c    
c    
c     

   

c   
c    
c    
c    
c    
c     

  

  

  

  

  

 

  
   
 

    

 
 

 

 

 

 

 

 

 

 a  cff std runtime n

 

 

 

 

 b  cff std plan length n
   

   

   

  

   

 

   

   

  

    

 
 

  

  

  

  

   

 

 c  cff std runtime c
     

  

  

    

dlvk m  
dlvk m  
dlvk m  
cff std m  
cff std m  
cff std m  

    

  

  

   

 d  cff std plan length c
dlvk m  
dlvk m  
dlvk m  
cff def m  
cff def m  
cff def m  

   

   
  
  
 
 

   
   

    

    
 

 

 

 

  

  

 

 e  dlvk cff std runtime b

 

 

 

  

  

 f  dlvk cff def runtime b

figure    selected results cd scenario  see detailed explanation text 
find significant difference performance dlvk different values c  dlvk
unable exploit lower c lower runtime  neither show easy hard easy pattern 
speculate dlvks answer set programming solver tends perform exhaustive search anyway
accordingly affected different structures heuristic techniques employed
cff  however  cff  dlvk able exploit lower coverage factors c shorter plans 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

figure    e  shows default setting without forced optimization  see performance dlvk explodes quickly cff experience much trouble  cff fails
upper ends curves  figure    e   f   problem files  i e   cnfs
describing complex concept dependencies  become large parse      mb   notwithstanding  cffs runtime behavior clearly exponential  note  however  actual encodings 
i e   problem instances solved  grow exponentially c 
observe dlvk exhibits quite variance  particularly across different
settings m  curves cross figure    e   even pronounced figure    f  
observe  sh  forced optimization brings huge advantage
dlvk          figure    f   dlvk fails first unsolved problem instance
due running memory shortly parsing problem 
concluding section  observe empirical behavior cff sh cd scenarios promising  results over interpreted  though  test scenarios
capture problem structure typical variety potential applications wsc technology 
approach yet put test actual practice  same  however  said essentially
current planning based wsc technology  since field whole still rather immature 

   related work
relation work belief update literature covered detail already sections          relation planning  formalism basically follows commonly
used frameworks  notions operators  actions  conditional effects exactly used
pddl framework  mcdermott et al         bacchus        fox   long         except
extension outputs  regarding latter  recognized time planning
community  example golden              edelkamp         on the fly creation
constants relevant feature certain kinds planning problems  however  attempts actually
address feature planning tools scarce  fact attempt aware work
golden              golden  pand  nemani  votava         part reason
situation probably almost current state art tools employ pre processing procedures
compile pddl task fully grounded description  core algorithms implemented based propositional representation  lifting algorithms representation
involves variables on the fly instantiations requires major  implementation  effort  work
herein  circumvent effort using potential constants feeding resulting problem
cff  planners employs said pre processing  extending cff wsc f wd
involve dealing non propositional representations sub problem 
notion initial state uncertainty conformant plans closely follows related literature
planning uncertainty  smith   weld        cimatti et al         hoffmann   brafman 
       formalization terms beliefs adapted work bonet geffner        
related works planning allow domain axiomatization  i e   form
axioms constraining possible world states  eiter et al         giunchiglia et al         
best knowledge  work planning exists  apart work presented herein 
considers combination domain axioms outputs 
words order regarding notions partial plug in matches  terminology originates work service discovery sws community  see example paolucci
et al         li   horrocks        kumar et al          service discovery  one concerned

  

fih offmann   b ertoli   h elmert   p istore

matching service advertisements service requests  discovery result set services
whose advertisement matches request  descriptions services requests similar
functional level service descriptions  i e   planning operators use here  however 
terminology works slightly different ours  describe additional kinds
matches  notions given li horrocks        closest relation ours  service
descriptions defined terms constructed description logic concepts  say concept
describing advertisement  r concept describing request  li horrocks
say r have  exact match r  plug in match r  subsume match
r  intersection match r     compare setting  consider
situation effect action a  r precondition action r  exact matches
special case plug in matches distinguish herein  intersection matches
correspond call partial matches  concerning plug in subsume matches  matters
subtle  intuitive meaning plug in match advertisement fully suffices
fulfill request  planning terms  means effect implies precondition r 
however  service discovery traditionally taken mean every requested entity
provided  i e   r  latter notion precondition r implies effect
meaningful planning  hence use one two notions  correspondence li
horrockss subsume matches 
contrast work li horrocks         work  paolucci et al        
kumar et al         define matches individual input output parameters service descriptions 
rather service descriptions global level  precondition effect us  constructed
concept li   horrocks         level individual parameters  paolucci et al        
suggest notions li horrocks        except less formal notation 
define intersection matches  true kumar et al          latter
authors define notions contains part of matches  relating building blocks
constructed concepts  obviously  notions make sense framework 
arent constructed concepts  finally  kumar et al  define ways aggregating matches
individual parameters matches entire service descriptions  again  applicable
case since work global level first place 
brief survey existing works wsc follows  variety works compile composition less standard deterministic planning formalisms  ponnekanti   fox 
      srivastava        sheshagiri et al          works  agarwal  dasgupta  karnik 
kumar  kundu  mittal    srivastava      b  agarwal et al       a  additionally focus end to end
integration sws composition larger context  akkiraju  srivastava  anca andreea  goodwin  syeda mahmood        investigate techniques disambiguate concept names  mcilraith
fadel        achieve composition particular forms non atomic services  modeling
latter atomic actions take meaning kind macro actions  narayanan mcilraith
       obtain composition ability side effect verifying sws properties using petri nets 
kuter  sirin  nau  parsia  hendler         au  kuter  nau         au nau       
focus information gathering composition time  rather plan execution time  mcdermott
       treats actual interaction  communication  web service planning problem 
mediratta srivastava        design approach wsc based conditional planning  i e  
form planning uncertainty  suggests close relation work  focus
mediratta srivastavas work actually quite different ours  mediratta srivastava
consider output variables  neither consider domain axiomatizations 
  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

overlap formalism lies allow incomplete initial state descriptions  i e  
initial states assign value subset propositions  handle observation
actions allow observing value unspecified proposition  ameliorate need
complete modeling  consider definition user acceptable plans  subset
plan branches  specified user  guaranteed lead goal  latter may
interesting option look extending framework handle partial observability 
two approaches explore adapt formalisms so called hand tailored planning
sws composition  approaches based golog  mcilraith   son        htn planning  sirin et al          respectively  frameworks enable human user provide control
information  however  non deterministic action choice allowed  control information
given  planning fully automatic  hence  sense  frameworks strictly
powerful planning without control information  further  approaches capable
handling advanced plan constructs loops branches  golog  possible plans
possible composition solutions described kind logic high level instructions
given programmer  planner bind instructions concrete actions part
execution  htn  programmer supplies planning algorithm set so called
decomposition methods  specifying certain task accomplished terms combination sub tasks  recursively  decomposition methods sub tasks  thus
overall task decomposed step wise fashion  atomic actions reached  neither
mcilraith son        sirin et al         concerned handling ontology axioms 
paper  hence  combining insights directions synergetic potential 
interesting topic future work 
another approach capable handling advanced plan constructs  loops  branches  described
pistore et al       b   pistore  traverso  bertoli  marconi      c   pistore et al       a  
bertoli  pistore  traverso         work  process level composition implemented 
opposed profile capability level composition addressed paper  process level 
semantic descriptions detail precisely interact sws  rather characterizing
terms preconditions effects  pistore et al       b      c      a  bertoli
et al         exploit bdd  binary decision diagram  based search techniques obtain complex
solutions fully automatically  however  ontology axioms handled input output types
matched based type names 
approaches ontology axioms used requirements
matches relaxed  one described sirin  hendler  parsia         sirin  parsia 
hendler         sirin parsia         sirin et al          first two papers
series  sirin et al                sws composition support tool human programmers
proposed  stage composition process  tool provides user list
matching services  matches found examining subconcept relation  output
considered match input b b  corresponds plug in matches  later work
 sirin   parsia        sirin et al          htn approach  sirin et al         mentioned
adapted work standard planning semantics  description logics semantics
owl s  difficulties inherent updating belief observed  connection belief
update studied literature made  remains unclear solution adopted 
far aware  methods relaxed matches follow
termed message based approach wsc  approaches already discussed depth
section      next  give details ones closely related work 
  

fih offmann   b ertoli   h elmert   p istore

approach liu et al         discussed sufficient detail already section     
reconsider here 
meyer weske        handle ontology axioms wsc tool  provide
semantics action applications  reasoning used determine whether particular output
used establish particular input  approach classified message based 
terms  kind matches handled said plug in  best knowledge 
tool existing wsc tool employs relaxed plan based heuristic function 
cff  however  various design decisions  authors sacrifice scalability  explicitly
enumerate world states every belief  hence suffer exponentially large beliefs 
search forward parallel actions consequently suffer huge branching factor 
take heuristic relaxed planning graph length  rather relaxed plan length  thus
suffer fact that  time  hmax much less informative heuristic h   bonet
  geffner        hoffmann        
approach rather closely related ours  handle partial matches  described
constantinescu faltings        constantinescu et al       a      b   work
ontology assumed take form tree concepts  edges indicate subconcept
relation  tree compiled intervals  interval represents concept
contents arranged correspond tree  intervals used efficient implementation
indexing service lookup  discovery   well matching composition  latter
searches forward space switches  starting initial input  current input type
a  service input ai matches ai      services collected set
collected ai covers  that is  union intervals various ai contains
interval a   collected services form switch  next step search 
outputs becomes new input must treated  i e   switch node   composition
interleaved discovery  i e   every search state discovery called find services
match state  search proceeds depth first fashion  major differences work
following  first  formalization different  using intervals vs  using standard notions
planning based logics  second  approach interleaves discovery composition 
separate steps framework  web service discovery needed determine operators
wsc task   third  approach considers concept trees vs  clausal integrity constraints  last 
approach uses depth first search  whereas one main points making one
exploit heuristic techniques implemented standard planning tools scalable wsc 
finally  interesting approach related planning described ambite kapoor        
capture dependencies different input variables web service  input described terms relation variables  done outputs 
relations formulated terms logical formulas relative ontology  underlying formalism first order logic  modeling language quite expressive    reasoning performed
order establish links  messages  terms  inputs outputs  algorithmic
framework happens inspired partial order planning  penberthy   weld        
starting goal relation maintaining set open links  solution dag web
services links correspond different kinds data exchanges  selection  projection  join 
union   automatic insertion mediator services  e g   converting set standard formats 
supported 
    cost undecidable reasoning  according authors major issue practice 

   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

extent  preconditions effects clausal integrity constraints used model
relations sense ambite kapoor         say r k ary relation definition
  describing input web service  set corresponding operators precondition
r x            xk    transform set universally quantified clauses  long
latter done  long ontology axioms likewise transformed  obtain
model equivalent ambite kapoor  sense  main modeling advantage
approach ambite kapoor wsc f wd existential quantification  open question
whether quantification accommodated framework  insertion mediator services
supported wsc f wd   limited sense recognizing  via particular preconditions  particular kind mediator required  modeling actual data flow bound
awkward  summary  work ambite kapoor advanced data description transformation point view  hand  ambite kapoor neither consider
belief update  place work context fully fledged planning formalism 
less concerned exploiting heuristic technologies recent planners  combining
virtues approaches within either framework interesting direction
research 

   discussion
suggested natural planning formalism significant notion web service composition
profile   capability level  incorporating on the fly creation constants model outputs  incomplete initial states model incomplete user input  conditional effects semantics model partial
matches  and  importantly  clausal integrity constraints model ontology axioms 
identified interesting special case  forward effects  semantics action applications
simpler general case  demonstrated relates belief update
literature  shown results reduced computational complexity  forward effects
relate closely message based wsc  results serve put form wsc context  extend towards general notion partial matches  further  identified
compilation planning  initial state  uncertainty  opening interesting new connection
planning wsc areas 
empirical results encouraging  over interpreted  test scenarios serve capture structural properties likely appear applications wsc
technology  approach yet put test actual practice  same  however 
said essentially current planning based wsc technology  since field still rather immature  sense  thorough evaluation approach  planning based wsc
whole  challenge future 
apart evaluation  several directions research improving extending
technology introduced herein  line research find particularly interesting adapt
modern planning tools wsc  starting special cases  complications incurred
integrity constraints manageable  already outlined ideas adapting
cff  pointed new challenges arise  appears particularly promising tailor generic
heuristic functions  originating planning  exploit typical forms ontology axioms occur
practice  considering wealth heuristic functions available now  topic alone provides
material whole family subsequent work 

   

fih offmann   b ertoli   h elmert   p istore

acknowledgments
thank anonymous reviewers  well managing editor derek long  comments 
significant help improving paper 
jorg hoffmann performed part work employed university innsbruck  austria  work partly funded european unions  th framework programme super project  ist fp          http   www ip super org  
piergiorgio bertolis marco pistores work partly supported project software
methodology technology peer to peer systems  stamps  
malte helmerts work partly supported german research council  dfg  part
transregional collaborative research center automatic verification analysis complex
systems  sfb tr    avacs   see www avacs org information 

appendix a  proofs
first formally prove proposition    stating negative effects compiled away wsc 
so  first need introduce compilation formally  assume wsc task  p 
 
ic   o  c        g    construct second wsc task  p      
ic     c        g    initially
 
p     ic o  p  ic o  respectively  proceed follows  let g
p predicate arity k  exists o     xo   preo   yo   effo   effo
contains negative literal g x            xk    introduce new predicate notg p    
introduce two new clauses x            xk   g x            xk   notg x            xk   x            xk  
g x            xk   notg x            xk    every operator whose effect contains negation
g  replace  effo   g a            ak   notg a            ak      continue
negative effect literals remain o   
action  p  ic   o  c        g   denote a  corresponding action
 
 
 p      
ic     c        g    use notation vice versa  i e   action
 
 
 
 p   ic     c        g   denotes corresponding action  p  ic   o  c        g   
   cs     state using predicates p  denote s  state using predicates p    
following properties  cs    cs   p p cs is   p     p   notp
p p cs is   notp      iff  p       since is  obviously  exactly one
s    use correspondence vice versa 
 
proposition   assume wsc task  p  ic   o  c        g    let  p      
ic     c        g  
task negative effects compiled away  assume action sequence ha            i 
let b result executing ha             p  ic   o  c        g    b  result
 
 
 
 
executing ha 
             p   ic     c        g    then  state s  b iff
s  b   

proof  induction length action sequence question  sequence empty 
consider initial beliefs two tasks  claim follows directly
definition  inductive step  say claim holds b b    action  need
show that  state s  res b  a  iff s  res b    a    
direction right left  say s  res b    a     definition s 
 
 
 
res s 
      state s  b   induction hypothesis  s  b  therefore suffices show
    arguments ai may either variables constants 

   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

res s    a   need show        ic effa     differs s  set inclusion
minimal set values      obvious definitions  assume contrary    
exists s  s     ic effa s  identical except exists least one propo 
sition p s   p    s   p  s p     s   p   definition  get s 
     ic effa   
 
 
 
 
further  get s   p    s   p  s   p     s   p   altogether s   s  s   
 
contradiction s  res s    a     hence proves res s    a  desired 
direction left right proceeds fashion  say res b  a   definition
 
res s    a  state s  b  induction hypothesis  s 
  b   suffices
 
 
 
 
 
show s  res s 
       need show        ic effa     differs s 
set inclusion minimal set values      obvious definitions  assume contrary
 
 
 
 
    exists s 
  s     ic effa  s  identical except
 
 
 
exists least one proposition p s 
   p    s   p   p     s   p   definition  get
c

s     ic effa   further  p p   get s   p    s   p  s p     s   p  
p   notq   p cs  get property q  altogether  get s   s  s 
 
contradiction res s  a   hence proves s  res s 
 
      desired 
theorem   assume wsc task fixed arity  sequence ha            actions 
p   complete decide whether ha            plan 
proof  membership proved guess and check argument  first  observe that  arbitrary s   
a  decide within conp whether res s  a   guess state cs   cs ea  
check whether    ic effa   check whether  s   res s  a  iff guess
succeeds  further  action a  deciding whether inconsistent is  obviously  equivalent
satisfiability test  contained np  instruments hand  design
guess and check procedure decide whether ha            plan  guess proposition
values along ha            i  check whether values comply res  lead
inconsistent action  final state satisfy goal  detail  checking proceeds
follows  first  check whether initial proposition values satisfy ic     not  stop without
success  otherwise  iteratively consider action ai   pre state post state   check
np oracle whether inconsistent  yes  stop success  not  test np oracle
whether res s  a   not  stop without success  otherwise    n  go ai    
  n  test whether    g   stop success     g   stop without success    g  
ha            plan iff guess proposition values successful 
hardness follows following adaptation proof lemma     eiter gottlob
        validity qbf formula x y  x     cnf  reduced plan testing
single action a  use   ary predicates x    x            xm       y            yn   
new   ary predicates  z            zm   r  t   set operators contains single operator
empty in out parameters  empty precondition  effect t  initial constants empty   
conjunction xi   yi   zi   r  t  g r  theory is 
 


 

i  

 t xi zi     


 

 t xi zi     

i  

 

 t r c    

c

   

n
 

i  

 t yi r  

fih offmann   b ertoli   h elmert   p istore

viewed set clauses c  readably  theory equivalent to 
  


 

xi zi    r     

n
 

yi   r  

i  

i  

refer initial belief b  plan test contains single action based  equal to 
fact  o  refer resulting belief b   obviously  b contains single state everything
except true  also  consistent  interpretation sets r yi   satisfies ic effa  
theory conjuncts xi zi make sure w b makes exactly one xi   zi true 
particular  different assignments x incomparable respect set inclusion  hence 
every assignment ax truth values x  exists state b complies
ax   ax satisfiable together ic effa   assignment ax distant
least one variable  e g   ax  xi       ax  xi       ax closer ax
regarding interpretation zi   
prove that  plan  x y  x    valid  let ax truth value assignment x  above  state b complies ax   since plan 
   r  therefore  due theory conjunct r        obviously  values
assigned satisfy ax  
direction  say x y  x    valid  assume that  contrary thew
claim 
plan  b     r  then  due theory conjunct   ni   yi   r 
sets yi false  now  x y  x    valid  exists truth value
assignment ay complies setting xi zi s  obtain modifying
comply ay   setting r       ic effa   then  closer
  hence   b contradiction  concludes argument 
 
theorem    assume wsc task fixed arity  natural number b unary representation 
p   complete decide whether exists plan length b 
proof  membership  guess sequences actions containing b actions  note
size sequence polynomial size input representation   theorem   
check p  oracle whether sequence plan 
hardness follows extension proof lemma     eiter gottlob         validity qbf formula x y z  x  y  z   cnf  reduced testing plan existence 
use   ary predicates x    x            xn       y            ym    z    z            zk    new
  ary predicates  q            qm   r  t  f          fn   h  g   set operators composed of 
ot       f  fn h    g h 
  n  oxi       h    xi  
  n  oxi       h    xi  
initial constants empty  initial literal conjunction   composed yi   zi   qi  
r  t    h  g  is  yi   zi   qi well r h true  well
g false  value specified  only  xi   goal g r g  theory is 
 


 

i  

 t yi qi     


 

 t yi qi     

i  

 

 t r c    

c

   

n
 

i  

 t zi r  

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

viewed set clauses c  readably  theory equivalent to 
  


 

yi qi    r     

i  

n
 

zi   r  

i  

first  note obvious things construction 
ot must included plan 
ot applied  action applied anymore 
ot applied  either oxi oxi must applied  every   n 
theory switched off  i e   made irrelevant false  point ot
applied 
is  plan task must first apply oxi oxi   every   n  thereby choosing
value every xi   then  ot must applied plan must stop  applying ot   changes
made states except values xi set made true one
other  hence  belief b ot applied contains single state corresponds
extension   value assignment x  values flipped 
denote value assignment x ax   denote b    res b  ot    note
ot consistent  interpretation sets r zi    besides setting immediate effects
g h  satisfies ic effot   obviously  applications oxi oxi consistent
well 
theory conjuncts yi qi make sure w b makes exactly one yi   qi true 
particular  different assignments incomparable respect set inclusion  hence 
every assignment ay truth values   exists state b complies
ay   ay satisfiable together ic effot   assignment ay distant
least one variable  e g   ay  yi       ay  yi       ay closer ay regarding
interpretation qi   
prove that  exists plan  a yielding assignment ax   x y z  x  y  z 
valid  let ay arbitrary truth value assignment   state b
complies ax ay   ax ay satisfiable together ic effot   above 
assignment ay distant least one variable  and  course  one deviates
ax one distant respective variable  since  a plan     r 
therefore  due theory conjunct r        obviously  values assigned z
satisfy ax ay   proves claim ay chosen arbitrarily 
direction  say x y z  x  y  z  valid  let ax assignment x
y z  ax  x  y  z  valid  let  a corresponding plan  i e    a first applies    n 
either oxi oxi according ax   thereafter   a applies ot   assume
wn  a plan 



b     r  then  due theory conjunct   i   zi   r  sets
zi false  now  y z  ax  x  y  z  valid  exists truth value assignment
az z complies setting xi   yi   qi s  obtain modifying comply
az   setting r       ic effot   then  closer  
hence   b contradiction  concludes argument 
 

   

fih offmann   b ertoli   h elmert   p istore

theorem    assume wsc task  decision problem asking whether exists plan
undecidable 
proof  result holds even empty background theory  complete specification
initial state  predicates arity    operators arity    goal variables
 arity     positive literals preconditions goal  result follows minor
modification tom bylanders proof  bylander        plan existence propositional strips
planning pspace complete    original proof proceeds generic reduction  constructing
strips task turing machine  tm  polynomially bounded space  latter restriction
necessary model machines tape  tape cells pre created positions within bound 
makes difference pspace membership undecidability ability create
constants  introduce simple operators allow us extend tape  ends 
detail  say tm  a finite number of  states q tape alphabet symbols  where b
blank   transition function  q  initial state  f set accepting states 
input word  planning encoding contains following predicates  state q  indicates
current tm state q  in a  c  indicates current content tape cell c a  n eighbors c  c  
true iff c  immediate  right neighbor c  at c  indicates current position
tm head c  rightmost c   lef tmost c   true iff c currently right  left  neighbor 
set initial constants contains states q  alphabet symbols a  tape cells c corresponding
  initial literals  propositions constants assigned truth values
obvious  every transition  q  a  q     r  include operator 
  x  x    state q  in x  a  n eighbors x  x   at x  
  state q   state q  in x    in x  a  at x   at x   
obviously  encodes exactly transition  likewise transitions  q  a  q     l   
model final states  introduce   ary predicate g  include q f operator 
   state q     g 
finally include operators 
  x   rightmost x    x    n eighbors x  x   in b  x   rightmost x   rightmost x  

  x    lef tmost x     x   n eighbors x  x   in b  x  lef tmost x  lef tmost x   
definitions  easy verify exists plan iff tm reach accepting
state  
 
lemma    assume wsc f wd task  reachable state s  action a  res s  a   
res f wd  s  a  
    propositional strips framework  empty background theory  complete specification
initial state  goal variables  positive literals preconditions goal  output
parameters operators 

   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

proof  applicable s  claim holds trivially  consider case 
equation    res s  a  defined

  c       c   cs ea   min s  c   ic effa    appl s  a 
res s  a    
 s 
otherwise
min s  c   ic effa   set c  interpretations satisfy ic effa
minimal respect partial order defined i  i   iff propositions p cs  
i   p     p  i   p     p  
obvious res f wd  s  a  res s  a  satisfies ic effa identical
propositions cs   particular minimal according  
direction  let res s  a   assume  p      p  proposition p
cs   define equal except  p      p   obviously   s i   
suffices show    ic effa   then  get   min s  c   ic effa   contradiction 
hence agrees propositions p cs   hence res f wd  s  a  
before  denote p cs  ea set propositions arguments cs ea  
least one argument e  denote ic  cs   ea   instantiation ic
constants cs ea   clause least one variable instantiated ea   see
   ic effa   consider first equivalent    ic  cs ea   effa  
turn equivalent    ic  cs   ic  cs   ea   effa   last formula  task
wsc f wd   ic  cs   speaks propositions p cs   whereas ic  cs  ea  effa speaks
propositions p cs  ea   treat two parts separately     ic  cs  
   ic  cs   prerequisite since reachable     ic  cs   ea   effa
definition  concludes argument 
 
theorem    assume wsc f wd task fixed arity  sequence ha            actions 
conp complete decide whether ha            plan 
proof  hardness obvious  considering empty sequence  membership shown
following guess and check argument  say c union c  output constants appearing
ha            i  guess interpretation propositions p c  further 
  n  guess set ct constants  check polynomial time whether
ct correspond execution ha            i    n   say
applicable    prea   ca ct   ea ct     first  assert    ic   second 
  assert that  applicable     effa   third  assert ct    
ct  ea     applicable   using lemma    easy see ct correspond
execution iff three assertions hold  note needs time stamped
action generated outputs properties respective propositions remain fixed
forever  claim follows because  fixed arity  test polynomial time whether
cn satisfy g   guess ct successful corresponds execution
satisfy g   obviously  ha            plan iff guess ct  
 
theorem    assume wsc f wd task fixed arity  natural number b unary representation  p   complete decide whether exists plan length b 
proof  membership  guess sequence b actions  theorem    check
p  oracle whether sequence plan 
   

fih offmann   b ertoli   h elmert   p istore

prove hardness  assume qbf formula x y  x    dnf normal form 
 this formula class complete p     say x   x            xn     y            ym      
k   design wsc f wd task plan iff x y  x    true  key construction
use outputs creation time steps  allow setting xi time step i 
yi take arbitrary values  xi set  one operator per k allows achieve goal
given k true  main property need ensure construction xi set
once  i e   either      plan task iff one set x that 
  least one true case iff x y  x    true 
predicates task p    x               xn      y              ym     time     start    
next      goal      indicate predicate arity number points parentheses 
example  predicate next     arity    theory ic empty  initial constants
c     t     initial literals     time t     goal y goal y   operators
follows 
  n  have  oxi       t            ti     start t    next t    t   
next ti    ti      ti    time ti  next ti    ti  xi  ti     operator allows generating
time step i  setting xi   step 
  n  have  oxi       t            ti     start t    next t    t   
next ti    ti      ti    time ti   next ti    ti   xi  ti     operator allows generating time step i  setting xi   step 
define value b below  n j   n   b  have  otj     t            tj    
start t    next t    t    next tj    tj      tj    time tj   next tj    tj    
operators allow increasing time step n n   b 
  k  say   xlxj  xlxjxn ylyj  ylyjyn xlj  xj   xj  
ylj  yj   yj    have  oi     t            tn b    start t    next t    t   
next tn b    tn b   xlxj   txj    xlxjxn  txjxn   ylyj     ylyjyn      c  
goal c    operator allows achieve goal time step n   b  provided
respective true  note xj precondition literals refer time step tj   i e  
value set xj earlier time step  yj precondition literals arguments
refer initial values yj   arbitrary 
assume choose value b  polynomial input size   x y  x    true 
then  obviously  find plan size n   b   k  apply oxi   oxi   operator xi  
depending whether xi must set      apply b operators otj   apply operators
oi   respective input parameter instantiations obvious 
opposite direction proving truth x y  x    based plan problematic 
plan might cheat setting xi      reason construction
complicated able avoid precisely case  based specifying strict enough plan length
bound b  key property that  order cheat xi   plan generate two sequences
time steps ti           tn b   therefore  lower bound length cheating plan n    b 
already seen  upper bound length non cheating plan n   b   k 
determine plan length bound b  simply choose b cheating plan
use many steps  n  b   n b  k case iff b   k  set b    k     obtain
b    n    k      bound b  plan proceed setting xi value  n actions  
   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

increasing time step n   b   n   k      k     actions   applying sufficient subset
oi  at k actions   plan cheats  needs apply least n  b   n  k    actions
able apply oi actions exploiting different value settings xi   concludes
argument 
 
theorem    assume wsc f wd task  decision problem asking whether exists plan
undecidable 
proof  reduce halting problem abacus machines  undecidable  abacus machine consists tuple integer variables v            vk  ranging positive integers
including     tuple instructions i              state given content v            vk plus
index pc active instruction  machine stops iff reaches state pc   n  vi
initially    pc initially    two kinds instructions  ii   inc j  goto ii increments value vj jumps pc     ii   dec j  branch ii   ii  asks whether vj     
so  jumps pc   i    otherwise  decrements value vj jumps pc   i   
map arbitrary abacus program wsc f wd instance follows 
predicates  number v   zero v   succ v   v   value   v  t           valuek  v  t   instruction   t  
        instructionn  t 
background theory  none  i e   trivial theory 
operators 
operator h v    number v     v     number v    succ v   v  i
instructions form ii   inc j  goto ii   operator
h v            vk   t  
 instructioni  t   value   v    t           valuek  vk   t   succ v   vj    
 t   
 instructioni  t    value   v               valuej   vj       valuej  v     
valuej    vj                valuek  vk     i 
instructions form ii   dec j  branch ii   ii    operators
h v            vk   t  
 instructioni  t   value   v    t           valuek  vk   t   succ vj   v    
 t   
 instructioni   t    value   v               valuej   vj       valuej  v     
valuej    vj                valuek  vk     i 

h v            vk   t  
 instructioni  t   value   v    t           valuek  vk   t   zero vj    
 t   
 instructioni   t    value   v               valuej   vj       valuej  vj     
valuej    vj                valuek  vk     i 
   

fih offmann   b ertoli   h elmert   p istore

initial constants  v    t 
initial literals  number v   zero v   value   v    t    valuek  v    t   instruction   t   
goal condition  t instructionn  t 
describe intuitive meaning constants predicates  two kinds constants  numbers  represent natural numbers  including     time points  represent
computation steps abacus machine  variables refer time points denoted
above  variables represent numbers 
three predicates refer numbers exclusively  number v  true iff v encodes natural number
 and time point   zero v  true iff v encodes number    succ v   v  true iff v
encodes number one larger number encoded v  reduction
enforce every number uniquely represented  e g   may several representations
number     unique representation necessary  guaranteed number  
uniquely represented  though 
remaining predicates encode configurations abacus machine  valuei  v  t  true iff 
time point t  i th abacus variable holds number represented v  instructionj  t 
true iff current instruction time point ij  
obviously  accepting run abacus machine extract plan task 
vice versa  proves claim 
 
prove theorems      first establish core lemma theorems follow
relatively easily  need notations  denote beliefs  states   p  ic   o  c        g  
b  s   denote beliefs  states   p   a      g   b  s   assume sequence ha           
ai non goal achievement actions  denote b    res b    ha            ai i  b    res b   
ha            ai i   note overload res function denote state transitions
compiled task formalism  further  state s  c s      c   s ex c        denote
constants exist s  denote c relation states true iff
c s    c s   s c s     c s    c equivalence relation  equivalent states agree
constants exist howvthey interpreted  note every state reachable
compiled
v
task satisfies    ic   oo effo  eo    note ic   oo effo  eo   actually
satisfiable prerequisite  unless ic   unsatisfiable  outputs instantiated
unique constants operators consistent  state s  define  s    
 
 
 s   defined c 
effo  eo   
eo   c s    cs   s cs        ic  
oo

oo

is   s  equivalence class states reachable compiled task agree
constants exist interpreted 
lemma   assume wsc sf wd task without inconsistent operators  let ha            ai consist
non goal achievement
actions  let b    res b    ha            ai i  b    res b    ha            ai i  

b   sb  s  

proof  proof induction i  base case       i e   b   b  b   b   
b   
 s   cs   c       ic    
   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

hand  b   
 s   c s    c       ic  

 

effo  eo   

oo

obviously  latter comprised one equivalence class possibility assign propositions c  way compliant ic     exactly claim 
thes
inductive case  say add another action
ha            ai i  induction assumption 
b   sb  s   need prove res b  a    res b a   s    obviously  suffices prove

that  every b  res  s   a    res s a   s    first  say applicable s 

neither applicable  s   res  s   a     s    res s a   s    second  say
applicable s  lemma   res s  a   
  cs ea        cs        ic effa  
hand  res  s   a   
 s   ex   s   c s     c s  ea    c s    s     ic  

 

effo  eo   

oo

re write latter
 s   c s     cs ea    cs        ic  

 

effo  eo   

oo

obviously  desired  latter set comprised one equivalence class possibility
assign propositions cs ea way compliant ic effa   concludes
argument 
 
theorem    assume wsc sf wd task  p  ic   o  c        g   without inconsistent operators 
plan ha            compiled task  p   a      g    sub sequence non goal
achievement actions ha            plan  p  ic   o  c        g   
proof  ic   unsatisfiable  nothing prove  start belief original
task empty  non trivial case  first note that  plan compiled task  goal
achievement actions moved back plan  hence  without loss generality 
assume ha            ai consist entirely non goal achievement actions  hai             ai consist
entirely goal achievement actions 
denote b    res b    ha            ai i  b    res b    ha           
ai i   lemma    b   sb  s   since ha       
    plan compiled task  every
b tuple constants satisfying g   b   sb  s   follows every b satisfies
g  
 
theorem    assume wsc sf wd task  p  ic   o  c        g   without inconsistent operators 
plan ha            every operator appears one instantiation eo
outputs  ha            extended goal achievement actions form plan
compiled task  p   a      g   obtained using outputs eo  
proof 
denote b    res b    ha            i  b    res b    ha            i  
lemma   
b   sb  s   since ha            plan  every b satisfies g   b   sb  s   follows
every b tuple constants satisfying g   attaching respective goal achievement
actions yields plan compiled task 
 
   

fih offmann   b ertoli   h elmert   p istore

references
 dcomplex org         web server browse protein complexes known  d structures 
http   supfam mrc lmb cam ac uk elevy  dcomplex data hierarchy   root html 
agarwal  v   chafle  g   dasgupta  k   karnik  n   kumar  a   mittal  s     srivastava  b       a  
synthy  system end end composition web services  journal web semantics 
     
agarwal  v   dasgupta  k   karnik  n   kumar  a   kundu  a   mittal  s     srivastava  b       b  
service creation environment based end end composition web services    th
international conference world wide web  www     pp         
akkiraju  r   srivastava  b   anca andreea  i   goodwin  r     syeda mahmood  t          semaplan  combining planning semantic matching achieve web service composition 
 th international conference web services  icws    
ambite  j     kapoor  d          automatically composing data workflows relational descriptions shim services   th international semantic web conference  iswc    
ankolekar  a   burstein  m   hobbs  j   lassila  o   martin  d   mcdermott  d   mcilraith  s  
narayanan  s   paolucci  m   payne  t     sycara  k          daml s  web service description semantic web   st international semantic web conference  iswc    
au  t  c   kuter  u     nau  d          web service composition volatile information   th
international semantic web conference  iswc    
au  t  c     nau  d          incompleteness planning volatile external information 
  th european conference artificial intelligence  ecai    
baader  f   lutz  c   milicic  m   sattler  u     wolter  f          integrating description logics
action formalisms  first results    th national conference artificial intelligence
 aaai    
bacchus  f          subset pddl aips     planning competition  aips    planning competition committee 
bertoli  p   pistore  m     traverso  p          automated web service composition on the fly
belief space search    th international conference automated planning scheduling
 icaps    
bonet  b     geffner  h          planning incomplete information heuristic search belief
space   th international conference artificial intelligence planning systems  aips    
pp       
bonet  b     geffner  h          planning heuristic search  artificial intelligence          
    
branden  c     tooze  j          introduction protein structure  second edition  garland publishing company  new york  isbn            
brayton  r   hachtel  g   mcmullen  c     sangiovanni vincentelli  a          logic minimization
algorithms vlsi synthesis  kluwer academic publishers 
brewka  g     hertzberg  j          things worlds  formalizing actions
plans  j  logic computation               
   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

bryce  d   kambhampati  s     smith  d  e          planning graph heuristics belief space
search  journal artificial intelligence research           
burstein  m   hobbs  j   lassila  o   mcdermott  d   mcilraith  s   narayanan  s   paolucci  m  
parsia  b   payne  t   sirin  e   srinivasan  n   sycara  k     martin  d          owl s 
semantic markup web services  owl s      http   www daml org services owl s      
version     
bylander  t          computational complexity propositional strips planning  artificial
intelligence                 
chasman  d   ed            protein structure determination  analysis applications drug
discovery  marcel dekker ltd                
chen  y   wah  b     hsu  c          temporal planning using subgoal partitioning resolution
sgplan  journal artificial intelligence research             
cimatti  a   roveri  m     bertoli  p          conformant planning via symbolic model checking
heuristic search  artificial intelligence                  
constantinescu  i     faltings  b          efficient matchmaking directory services   nd
international conference web intelligence  wi    
constantinescu  i   faltings  b     binder  w       a   large scale  type compatible service composition   nd international conference web services  icws    
constantinescu  i   faltings  b     binder  w       b   typed based service composition    th
international conference world wide web  www    
de giacomo  g   lenzerini  m   poggi  a     rosati  r          update description
logic ontologies instance level    st national conference artificial intelligence
 aaai    
de giacomo  g   lenzerini  m   poggi  a     rosati  r          approximation instance
level update erasure description logics    nd national conference american
association artificial intelligence  aaai    
de jonge  m   van der linden  w     willems  r          eservices hospital equipment   th
international conference service oriented computing  icsoc     pp         
edelkamp  s          promela planning    th international spin workshop model checking
software  spin    
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a          logic programming approach
knowledge state planning  ii  dlvk system  artificial intelligence                   
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a          logic programming approach
knowledge state planning  semantics complexity  transactions computational logic 
             
eiter  t     gottlob  g          complexity propositional knowledge base revision  updates  counterfactuals  artificial intelligence                  
fagin  r   kuper  g   ullman  j     vardi  m          updating logical databases  advances
computing research         

   

fih offmann   b ertoli   h elmert   p istore

fensel  d   lausen  h   polleres  a   de bruijn  j   stollberg  m   roman  d     domingue  j         
enabling semantic web services web service modeling ontology  springer verlag 
fersht  a          structure mechanism protein science  guide enzyme catalysis
protein folding  mps  isbn                  
fox  m     long  d          pddl     extension pddl expressing temporal planning
domains  journal artificial intelligence research            
gerevini  a   saetti  a     serina  i          planning stochastic local search temporal
action graphs  journal artificial intelligence research             
gerevini  a   saetti  a   serina  i     toninelli  p          fast planning domains derived
predicates  approach based rule action graphs local search    th national conference american association artificial intelligence  aaai    
ginsberg  m     smith  d          reasoning action i  possible worlds approach  artificial
intelligence                
giunchiglia  e   lee  j   lifschitz  v   mccain  n     turner  h          nonmonotonic causal
theories  artificial intelligence                  
giunchiglia  e     lifschitz  v          action language based causal explanation  preliminary report    th national conference artificial intelligence  aaai    
golden  k          dpadl  action language data processing domains  proc   rd
international nasa planning scheduling workshop 
golden  k          domain description language data processing  proc  workshop
future pddl icaps   
golden  k   pand  w   nemani  r     votava  p          automating processing earth observation data  proceedings  th international symposium artificial intelligence 
robotics automation space 
gomes  c   selman  b   crato  n     kautz  h          heavy tailed phenomena satisfiability
constraint satisfaction problems  journal automated reasoning                 
helmert  m          decidability undecidability results planning numerical state variables   th international conference artificial intelligence planning systems  aips    
helmert  m          fast downward planning system  journal artificial intelligence research             
herzig  a          pma revisited   th international conference principles knowledge
representation reasoning  kr    
herzig  a   lang  j   marquis  p     polacsek  t          updates  actions  planning    th
international joint conference artificial intelligence  ijcai     pp         
herzig  a     rifi  o          propositional belief base update minimal change  artificial
intelligence                 
hoffmann  j          ignoring delete lists works  local search topology planning benchmarks  journal artificial intelligence research             
hoffmann  j     brafman  r          conformant planning via heuristic forward search  new
approach  artificial intelligence                  
   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

hoffmann  j     nebel  b          planning system  fast plan generation heuristic
search  journal artificial intelligence research             
katzuno  h     mendelzon  a          difference updating knowledge base
revising it   nd international conference principles knowledge representation
reasoning  kr    
kona  s   bansal  a   gupta  g     hite  d          automatic composition semantic web services   th international conference web services  icws    
kumar  a   neogi  a   pragallapati  s     ram  j          raising programming abstraction
objects services   th international conference web services  icws    
kuter  u   sirin  e   nau  d   parsia  b     hendler  j          information gathering planning
web service composition  journal web semantics                 
lecue  f     delteil  a          making difference semantic web service composition 
  nd national conference american association artificial intelligence  aaai    
lecue  f     leger  a          formal model semantic web service composition   th
international semantic web conference  iswc    
li  l     horrocks  i          software framework matchmaking based semantic web
technology    th international conference world wide web  www    
liberatore  p          complexity belief update  artificial intelligence                   
lin  f     reiter  r          state constraints revisited  journal logic computation       
       
liu  h   lutz  c   milicic  m     wolter  f       a   reasoning actions using description
logics general tboxes    th european conference logics artificial intelligence
 jelia       
liu  h   lutz  c   milicic  m     wolter  f       b   updating description logic aboxes    th international conference principles knowledge representation reasoning  kr    
liu  z   ranganathan  a     riabov  a          planning approach message oriented semantic
web service composition    nd national conference american association
artificial intelligence  aaai    
long  d     fox  m           rd international planning competition  results analysis 
journal artificial intelligence research          
lutz  c     sattler  u          proposal describing services dls  international
workshop description logics       dl    
mccain  n     turner  h          causal theory ramifications qualifications    th
international joint conference artificial intelligence  ijcai      pp           
mccarthy  j     hayes  p          philosophical problems standpoint artificial
intelligence  machine intelligence            
mcdermott  d          estimated regression planning interactions web services   th
international conference artificial intelligence planning systems  aips    
mcdermott  d   et al          pddl planning domain definition language  aips   
planning competition committee 
   

fih offmann   b ertoli   h elmert   p istore

mcdermott  d  v          using regression match graphs control search planning  artificial
intelligence                   
mcgeer  p   sanghavi  j   brayton  r  k     sangiovanni vincentelli  a          espressosignature  new exact minimizer logic functions  proceedings   th acm ieee
design automation conference  dac     
mcguinness  d  l     van harmelen  f          owl web ontology language overview  w c
recommendation   online http   www w  org tr owl features  
mcilraith  s     fadel  r          planning complex actions   th international workshop
non monotonic reasoning  nmr     pp         
mcilraith  s     son  t  c          adapting golog composition semantic web services 
 th international conference principles knowledge representation reasoning
 kr    
mediratta  a     srivastava  b          applying planning composition web services
user driven contingent planner  tech  rep  ri        ibm research 
meyer  h     weske  m          automated service composition using heuristic search   th
international conference business process management  bpm    
narayanan  s     mcilraith  s          simulation  verification automated composition web
services    th international conference world wide web  www    
palacios  h     geffner  h          conformant classical planning  efficient translations
may complete too    th international conference automated planning
scheduling  icaps    
paolucci  m   kawamura  t   payne  t     sycara  k          semantic matching web services
capabilities   st international semantic web conference  iswc    
pednault  e  p          adl  exploring middle ground strips situation
calculus   st international conference principles knowledge representation
reasoning  kr    
penberthy  j     weld  d          ucpop  sound  complete  partial order planner adl 
 rd international conference principles knowledge representation reasoning
 kr     pp         
petsko  g  a     ringe  d          protein structure function  new science press  isbn
                          
pistore  m   marconi  a   bertoli  p     traverso  p       a   automated composition web services planning knowledge level    th international joint conference artificial
intelligence  ijcai    
pistore  m   traverso  p     bertoli  p       b   automated composition web services planning
asynchronous domains    th international conference automated planning
scheduling  icaps    
pistore  m   traverso  p   bertoli  p     marconi  a       c   automated synthesis composite
bpel ws web services   rd international conference web services  icws    

   

fiw eb ervice c omposition p lanning u ncertainty  n ew c onnection

ponnekanti  s     fox  a          sword  developer toolkit web services composition 
  th international conference world wide web  www    
reiter  r          frame problem situation calculus  simple solution  sometimes 
completeness result goal regression  artificial intelligence mathematical theory
computation  papers honour john mccarthy  pp         
roman  d   keller  u   lausen  h   de bruijn  j   lara  r   stollberg  m   polleres  a   feier  c  
bussler  c     fensel  d          web service modeling ontology  applied ontology       
      
sheshagiri  m   desjardins  m     finin  t          planner composing services described
daml s  third symposium adaptive agents multi agent systems  aamas    
sirin  e   parsia  b   wu  d   hendler  j     nau  d          htn planning web service composition using shop   journal web semantics       
sirin  e   hendler  j     parsia  b          semi automatic composition web services using
semantic descriptions  workshop web services iceis   
sirin  e     parsia  b          planning semantic web services  workshop semantic web
services iswc   
sirin  e   parsia  b     hendler  j          composition driven filtering selection semantic
web services  aaai fall symposium semantic web services 
sirin  e   parsia  b     hendler  j          template based composition semantic web services 
aaai fall symposium agents search 
smith  d  e     weld  d          conformant graphplan    th national conference
american association artificial intelligence  aaai     
srivastava  b          automatic web services composition using planning  knowledge based
computer systems  kbcs     pp         
thakkar  s   ambite  j  l     knoblock  c          composing  optimizing  executing plans
bioinformatics web services  vldb journal  special issue data management  analysis
mining life sciences                
thiebaux  s   hoffmann  j     nebel  b          defense pddl axioms  artificial intelligence 
              
winslett  m          reasoning actions using possible models approach   th national
conference american association artificial intelligence  aaai    
winslett  m          updating logical databases  cambridge university press 
zhan  r   arpinar  b     aleman meza  b          automatic composition semantic web services   st international conference web services  icws    

   


