journal artificial intelligence research                  

submitted        published      

compiling uncertainty away conformant planning
problems bounded width
hector palacios

hlp ldc usb ve

universitat pompeu fabra
roc boronat     
      barcelona  spain

hector geffner

hector geffner upf edu

icrea   universitat pompeu fabra
roc boronat     
      barcelona  spain

abstract
conformant planning problem finding sequence actions achieving goal
presence uncertainty initial state action effects  problem
approached path finding problem belief space good belief representations
heuristics critical scaling up  work  different formulation introduced
conformant problems deterministic actions automatically converted
classical ones solved off the shelf classical planner  translation maps
literals l sets assumptions initial situation  new literals kl t
represent l must true initially true  lay general translation scheme
sound establish conditions translation complete 
show complexity complete translation exponential parameter
problem called conformant width  benchmarks bounded  planner
based translation exhibits good performance comparison existing planners 
basis t    best performing planner conformant track     
international planning competition 

   introduction
conformant planning form planning goal achieved initial
situation fully known actions may non deterministic effects  goldman  
boddy        smith   weld         conformant planning computationally harder
classical planning  even polynomial restrictions plan length  plan verification
remains hard  haslum   jonsson        baral  kreinovich    trejo        turner       
rintanen         practical problems purely conformant  ability find
conformant plans needed contingent planning conformant situations special
case relaxations conformant planning yield useful heuristics  hoffmann  
brafman        
problem conformant planning formulated path finding problem
belief space sequence actions map given initial belief state target
belief sought  bonet   geffner         belief state represents set states
deemed possible  actions  whether deterministic not  map one belief state
c
    
ai access foundation  rights reserved 

fipalacios   geffner

another  formulation  underlies current conformant planners  hoffmann  
brafman        bryce  kambhampati    smith        cimatti  roveri    bertoli       
must address two problems  problem representing beliefs compact way 
problem obtaining effective heuristics beliefs  first problem approached
logical representations make use sat obdd technology 
intractable worst case  scale better plain state representations  second
problem  hand  complex  heuristics searching belief
space successful far heuristics developed classical planning  bonet
  geffner        hoffmann   nebel        
work  introduce different approach conformant planning problems
automatically compiled classical problems solved classical planner 
translation maps sets literals initial situation literals l new literals
kl t express true initial situation  l must true  lay first
general translation scheme sound establish conditions
translation complete  also  show complexity complete translation
exponential parameter problem call conformant width 
benchmark domains bounded  implying complete translation
cases polynomial  planner based translation exhibits good performance
comparison existing conformant planners basis t    best performing
planner conformant track      international planning competition 
translation based approach provides solution two problems faced conformant planners search belief space  belief representation heuristic
beliefs  translation based approach  beliefs represented literals kl t
stand conditionals  representation polynomial complete conformant problems bounded width  addition  since belief states represented
plain states  heuristic beliefs classical heuristic  computational point
view  though  explicit search belief space  conformant problems p
converted classical problems k p   knowledge level  petrick   bacchus        
whose solutions  computed classical planner  encode conformant solutions p  
formulation limited conformant problems deterministic
uncertainty lies initial situation  address nonetheless issues must
handled order generalize translation based approach non deterministic domains
report empirical results non deterministic domains well 
paper organized follows  define first syntax semantics conformant
planning problems p  section     consider simple sound incomplete translation
k   section     consider general translation scheme kt m
two parameters  set tags encoding assumptions initial situation 
set merges encoding valid disjunctions tags  section     analyze several
instances scheme follow particular choices sets tags merges 
complete exponential translation ks  tags associated possible
initial states problem  section     polynomial translation ki fixed integer
  complete problems conformant width bounded  section    
provide alternative explanation compact complete translation
showing problems bounded width  exponential number possible initial
states s  includes always polynomial number critical initial states s   plans
   

ficompiling uncertainty away conformant planning problems

conform s   conform s   section     finally present conformant
planner t   section     empirical evaluation planner  section     extension
non deterministic actions  section      discussion related work  section     
followed brief summary  section     formal proofs  appendix  
work revision extension formulation presented palacios
geffner         turn based ideas first sketched palacios geffner
       

   conformant problem p
define next syntax semantics conformant planning problems considered 
    syntax
conformant planning problems p represented tuples form p   hf  i  o  gi
f stands fluent symbols problem  set clauses f defining
initial situation  stands set  ground  operators actions a  g set
literals f defining goal  every action precondition p re a  given set
fluent literals  set conditional effects c l c set fluent literals
l fluent literal 
actions assumed deterministic hence uncertainty lies initial
situation  thus  language conformant problem p excluding uncertainty
initial situation  strips extended conditional effects negation  moreover 
uncertainty initial situation  fluents appear unit clauses
i  p equivalent classical planning problem 
refer conditional effects c l action rules associated
a  sometimes write   c l  convenient  join several effects
associated action condition   c l l  write c l
true l c empty  finally  literal l  l denotes complement l 
    semantics
state truth assignment fluents f p   hf  i  o  gi possible initial
state p state satisfies clauses i 
state s  write i s  refer set atoms  positive literals  true
s  write p s refer classical planning problem p s   hf  i s   o  gi
conformant problem p except initial state fixed s 
action sequence    a    a              classical plan p s action sequence
executable state results goal state sg   i e                n 
preconditions action ai true si   si   state results action
ai state si   goal literals true sn    
finally  action sequence conformant plan p iff classical plan p s
every possible initial state p  
conformant planning computationally harder classical planning  plan verification remains hard even polynomial restrictions plan length  haslum   jonsson 
      baral et al         turner        rintanen         common approach
   

fipalacios   geffner

conformant planning based belief state formulation  bonet   geffner        
belief state b non empty set states deemed possible given situation 
every action executable b  maps b new belief state ba   conformant
planning task becomes path finding problem graph nodes belief states
b  source node b  belief state corresponding initial situation  target
belief states bg goals true 
assume throughout logically consistent  set possible initial
states empty  p consistent  bodies c c   conflicting
effects   c l   c   l associated action mutually exclusive
mutex  details this  see part b appendix 

   basic translation k 
simple translation conformant problem p classical problem k p  
obtained replacing literals l literals kl kl aimed capturing whether
l known true known false respectively 
definition    translation k     conformant planning problem p   hf  i  o  gi 
translation k   p     hf         o    g  classical planning problem
f      kl  kl   l f  
     kl   l unit clause i 
g     kl   l g 
o    precondition l replaced kl  conditional
effect   c l replaced   kc kl   kc kl 
expressions kc kc c   l    l        abbreviations formulas
kl    kl        kl    kl        respectively 
intuition behind translation simple  first  literal kl true initial
state   l known true i  otherwise false  removes uncertainty
k   p    making classical planning problem  addition  soundness 
rule   c l p mapped two rules  support rule   kc kl  ensures
l known true condition known true  cancellation
rule   kc kl guarantees kl deleted  prevented persist 
action applied c known false  use support cancellation rules
encoding original rules knowledge level subtlety translation 
translation k   p   sound every classical plan solves k   p   conformant
plan p   incomplete  conformant plans p classical plans k p   
meaning kl literals follows similar pattern  plan achieves kl k   p   
plan achieves l certainty p   yet plan may achieve l certainty
p without making literal kl true k   p    
proposition    soundness k   p     classical plan k   p   
conformant plan p  
   formal proofs found appendix 

   

ficompiling uncertainty away conformant planning problems

illustration  consider conformant problem p   hf  i  o  gi f    p  q  r  
   q   g    p  r   actions    a  b  effects
  q r     p p   b   q p  
problem  action sequence    a  b  conformant plan p action
sequence      a  not  indeed  classical plan p s possible initial state
s    classical plan possible initial state s  p true  recall
possible initial state p satisfies neither p r assumed
initially false problem  
definition    translation k   p     hf         o    g  classical planning problem
fluents f      kp  kp  kq  kq  kr  kr   initial situation      kq   goals g   
 kp  kr   actions o     a  b  effects
  kq kr     kp kp   b   kq kp 
encode supports  effects
  kq kr     kp kp   b   kq kp 
encode cancellations 
proposition   implies  example       a   conformant plan
p   cannot classical plan k p   either  easy verify  support
  kq kr achieves goal kr kq true     cancellation   kp kp
associated action  preserves kp false goal p 
translation k  complete  meaning fails capture conformant plans p classical plans  completeness assessed terms weaker
semantics  so called   approximation semantics  baral   son         belief states b
represented   valued states fluents true  false  unknown  incomplete belief representation  checking whether action applicable belief state b 
computing next belief state ba   verifying polynomial length plans polynomial
time operations  particular  literal l true next belief state ba iff a  action
effect c l literals c true b  b  l true b
effects c   l action a  complement literal l  c   true b  action
sequence conformant plan p according   approximation semantics
belief sequence generated according   approximation semantics makes
action sequence applicable terminates belief state goals true 
possible prove that 
proposition    k   p     approximation   action sequence classical plan
k   p   iff conformant plan p according   approximation semantics 
correspondence surprising though   approximation semantics
k   p   translation throw away disjunctive information restrict plans
make use uncertain knowledge  indeed  states s    s          generated
action sequence    a    a           classical problem k   p   encode precisely
   

fipalacios   geffner

literals known true according   approximation  namely  l true
time according   approximation iff literal kl true state si  
proposition   mean basic translation k    approximation
semantics equivalent rather rely equivalent belief representations 
translation k  delivers way get valid conformant plans using classical
planner  translation based approach thus addresses representational
heuristic issues arise conformant planning 
illustration proposition    given conformant problem p    p  r 
actions b effects   p q    r v  b   q v  plan    a  b  valid
achieving goal g    q  v  according k   p     approximation 
plan    b  valid according either  time  initial situation
changed    p q   neither approach sanctions plan    a  g    q   even
valid conformant plan  this  ability reason disjunctions needed 
extension basic translation k  allows limited form disjunctive reasoning presented palacios geffner         extension based introduction
new literals l xi used encoding conditionals xi l  below  basic translation
k  extended different manner ensures tractability completeness
large class problems 

   general translation scheme kt m
basic translation k  extended general translation scheme kt m
two parameters  set tags set merges m  show
suitable choices two parameters  translation kt m   unlike translation k   
sound complete 
tag set  conjunction  literals l p whose truth value initial
situation known  tags used introduce new class literals kl t
classical problem kt m  p   represent conditional true initially  l
true  assertion could written k t  l  temporal modal logic  use
notation kl t rather l t used palacios geffner        
distinction kl t kl t  roughly kl t means conditional
k t  l  true  kl t means conditional k t  l  true 
likewise  merge non empty
w collection tags stands disjunctive normal form  dnf  formula tm t  merge valid one tags
must true i  i e  
 
  
 
tm

merge literal l p translate merge action single effect
 
kl t kl
tm

captures simple form reasoning cases 
valid merge used reasoning literal l p   computationally
convenient  although logically necessary  specify certain merges
used literals l others  thus  formally  collection pairs
   

ficompiling uncertainty away conformant planning problems

 m  l   merge l literal p   pair means merge
l  group merges literal l set ml   thus  understood
collection sets ml l p   simplicity  however  except
may cause confusion  keep referring plain set merges 
assume collection tags always includes tag stands
empty collection literals  call empty tag denote   empty
tag  denote kl t simply kl 
translation kt m  p   basic translation k   p   conditioned tags
extended actions capture merges  
definition    translation kt m    let p   hf  i  o  gi conformant problem 
kt m  p   classical planning problem kt m  p     hf         o    g 
f      kl t  kl t   l f  
     kl t   i     l 
g     kl   l g 
o     a v
  kc t kl t    kc t kl t     c l p  
 am l     tm kl t  kl xl   l p  ml  
kl precondition action kt m  p   l precondition p   kc t
kc t stand kl   t  kl   t 
v         kl   t  kl   t        respectively 
c   l    l           xl stands l  kl  l  ranging literals l  mutex
l p  
translation kt m  p   reduces basic translation
k   p   empty
v
contains empty tag  extra effects xl   l  kl  merge actions am l
needed ensure translation kt m  p   consistent p consistent 
otherwise ignored  indeed  l l  mutex consistent p   invariant
kl t kl   t holds kt m  p   non empty tags t  hence successful merge
l always followed successful merge l    rest paper
thus assume p kt m  p   consistent  ignore extra merge effects 
come back appendix b proving consistency kt m  p  
consistency p  
suitable choices   translation kt m  p   sound complete 
establishing results  however  let us make notions precise 
definition    soundness   translation kt m  p   sound classical plan
solves classical planning problem kt m  p    plan   results dropping
merge actions conformant plan p  
definition    completeness   translation kt m  p   complete conformant
plan   solves conformant problem p   classical plan solves
classical problem kt m  p     equal merge actions removed 
general translation scheme kt m sound provided merges valid
tags consistent  literals tag true possible initial state  
   

fipalacios   geffner

theorem    soundness kt m  p     translation kt m  p   sound provided
merges valid tags consistent 
unless stated otherwise  assume merges valid tags consistent 
call translations  valid translations 
convention keeping notation simple  singleton tags    p   curly
brackets often dropped  thus  literals kl t    p  written kl p 
merges    t    t    singleton tags t     p  t     q   written    p  q  
example  illustration  consider problem moving object origin
destination using two actions  pick l   picks object location hand
empty object location  drop l   drops object location
object held  making problem interesting  let us assume
action pick l  drops object held l hand empty 
conditional effects action preconditions  assuming single
object  effects written as 
pick l    hold  at l  hold at l 
pick l    hold hold at l 
drop l    hold hold at l   
consider instance p domain  hand initially empty
object  initially either l  l    must moved l    i e   p   hf  i  o  gi
   hold   at l    at l      at l    at l      at l    

g    at l      
action sequence
     pick l     drop l     pick l     drop l    
conformant plan problem  attempt pick object location
l  followed drop target location l    ensuring object ends l 
originally l    followed attempt pick object l 
drop l   
hand  action sequence   results   removing first
drop action
     pick l     pick l     drop l    
conformant plan  since object originally l    would end l 
action pick l     notation introduced above    classical plan classical
problem p s two possible initial states s    classical plan problem
p s state object initially l   
   

ficompiling uncertainty away conformant planning problems

consider classical problem kt m  p     hf         o    g  obtained p
   at l     at l      contains merge    at l     at l     literals
hold at l     definition  fluents f   kt m  p   form kl t
kl t l  at l   hold   l  l    l       initial situation  
     khold  khold at l   kat l     kat l    at l   kat l  at l   kat l    at l  
l  l   l    l    l     l  goal g 
g     kat l      
effects associated actions pick l  drop l  o  support rules
pick l    khold  kat l  khold kat l 
pick l    khold khold kat l 
drop l    khold khold kat l 
one three locations l   li   condition rule empty tag 
along support rules 
pick l    khold at l     kat l  at l    khold at l    kat l  at l   
pick l    khold at l    khold at l    kat l  at l   
drop l    khold at l    khold at l    kat l  at l   
condition rule tags at l      l   l    l     corresponding
cancellation rules are 
pick l    khold  kat l  khold kat l 
pick l    khold khold kat l 
drop l    khold khold kat l 

pick l    khold at l     kat l  at l    khold at l    kat l  at l   
pick l    khold at l    khold at l    kat l  at l   
drop l    khold at l    khold at l    kat l  at l     
addition  actions o  include merge actions am hold am at l    follow
merge    at l     at l     literals hold at l    
am hold   khold at l     khold at l    khold
am at l      kat l    at l     kat l    at l    kat l     
   empty tag assumed every thus mentioned explicitly 

   

fipalacios   geffner

shown plan
      pick l     drop l     pick l     drop l     am at l     
solves classical problem kt m  p   hence  theorem    plan   obtained
   dropping merge action  valid conformant plan p  shown above  
see literals kt m  p   evolve actions    executed 
  
  
  
  
  
  

kat l    at l     kat l    at l   
khold at l     kat l    at l   
kat l    at l     kat l    at l   
kat l    at l     khold at l   
kat l    at l     kat l    at l   
kat l   

true
true
true
true
true
true

 






pick l   
drop l   
pick l   
drop l   
merge am at l     

verify manner action sequence   
      pick l     pick l     am hold   drop l    
classical plan kt m  p    reason atom khold at l    holds
first pick action second  due cancellation rule 
pick l      khold at l    khold at l    kat l    at l   
expresses assumption at l    initial situation  hold at l   
known true action pick l     assumption  hold
known true action 

   complete translation  ks 
complete instance translation scheme kt m obtained simple manner
setting tags possible initial states problem p merge
precondition goal literal l includes tags  call resulting
exhaustive translation ks   
definition    translation ks     conformant problem p   translation ks   p  
instance translation kt m  p  
set union empty tag set s  possible initial states p
 understood maximal sets literals consistent i  
set contain single merge   s  precondition goal literal l
p 
translation ks  valid hence sound  complete due correspondence
tags possible initial states 
theorem    completeness ks     conformant plan p  
classical plan   ks   p   result dropping merge actions    

   

ficompiling uncertainty away conformant planning problems

 s 
problem
adder   
blocks   
blocks   
bomb     
bomb     
bomb      
bomb     
coins   
coins   
coins   
coins   
comm   
comm   
comm   
corners square   
corners square   
corners square   
corners square    
corners square    
square center   
square center   
log        
log        
ring  
ring  
safe   
safe   
safe    
sortnet   
sortnet   
sortnet   
sortnet   
uts k   
uts k   

  
  
   
 k
 k
 k
 m
 k
 k
 k
 m
   
 k
 k
 
 
 
 
 
   
   
 k
  k
   k
   k
  
  
   
   
   
 k
 k
  
  

ks 
time
len
   h
   
  
    
  
   
  
    
  
    
  
     gb
    
  
    
  
    
  
     gb
    
  
    
  
     gb
   
   
   
   
   
   
          
     gb
    
   
     gb
     
  
   h
    
  
     gb
   
  
   
  
 
   
   
  
   
  
    
  
     gb
   
  
   
  

pond
time len
   
  
   
  
         
 
  
 
  
 
  
    
  
 
  
 
  
 
  
   h
 
  
 
  
 
  
    
  
   h
   h
   h
   h
    
  
   h
   h
   h
 
  
  
  
 
  
  
  
     gb
   
  
   h
   h
   h
  
  
    
  

cff
time
len
   h
   h
   h
 
  
 
  
 
  
 
  
 
  
 
  
   
  
 
  
 
  
 
  
 
  
    
   
   
   
   h
   h
   h
   h
   h
   
  
   
   
   
  
    
  
    
  
     
  
          
snh
snh
snh
snh
   
  
    
  

table    ks  translation fed planner compared pond conformant
 cff  along times reported plan lengths   s  stands number
initial states  snh means goal syntax handled  by cff   times reported
seconds rounded closest decimal 

   

fipalacios   geffner

problems p whose actions preconditions  argument simple 
conformant plan p must classical plan p s possible initial
state s  achieves  goal  literal gi p s s  must achieve
literal kgi  s ks   p   well  followed merge action gi  
must achieve literal kgi   presence action preconditions  argument must
applied inductively plan length  idea remains  see proof
appendix details   correspondence established evolution
fluents l problem p s evolution fluents kl s problem
ks   p   
significance exhaustive ks  translation theoretical 
plenty conformant problems quite hard current planners even involve
handful possible initial states  example square center n task  cimatti
et al          agent reach center empty square grid certainty 
knowing initial location  four actions move agent one unit
direction  except border grid  effects  standard
version problem  initial position fully unknown resulting n  possible initial
states  yet problem remains difficult  actually beyond reach planners 
small values n  even uncertainty reduced pair possible initial states 
reason agent must locate heading goal  domain
corners square n table   variation square center n possible initial
states four corners grid 
table   shows results conformant planner based ks   p   translation
uses  hoffmann   nebel        solving resulting classical problem  compares
two planners entered conformant track      int  planning
competition  bonet   givan         pond  bryce et al         conformant
 hoffmann   brafman         the two planners competition translationbased  t    based formulation developed paper  k p    based earlier
restricted formulation due palacios   geffner         clearly  approach
based ks   p   translation scale problems many possible initial
states  yet number states small  quite well 

   complete translations may compact
order complete translations polynomial  certain assumptions
formulas initial situation need made  otherwise  checking whether
goal true intractable itself  therefore polynomial complete translation
would impossible  unless p   np   thus assume prime implicate  pi 
form  marquis         meaning includes inclusion minimal clauses
entails tautologies  known checking whether clause follows logically
formula pi form reduces checking whether clause subsumed clause
tautology  hence polynomial operation  initial situations
benchmarks p form easily cast pi form normally specified
means set non overlapping oneof  x            xn   expressions translate
clauses x  xn binary clauses xi xj    j resolvent
tautology 
   

ficompiling uncertainty away conformant planning problems

    conformant relevance
translation ks   p   complete introduces number literals kl t exponential worst case  one possible initial state s    raises question 
possible complete translations exhaustive sense  answer
yes section provide simple condition ensures translation
kt m  p   complete  makes use notion relevance  
definition     relevance   conformant relevance relation l l  p   read l
relevant l    defined inductively
   l l
   l l    c l  p l c action p
   l l  l l   l   l 
   l l  l l   l   l   
first clause stands reflexivity  third transitivity  second captures conditions relevant effect  fourth  conditions l preempts
conditional effects may delete l    replace  
  l l  l l 
equivalent   context     resulting definition one son
tu         notion relevance used generate limited set possible partial
initial states   approximation complete  see section    discussion
relation tags partial initial states  
notice according definition  precondition p action taken
relevant effect q  reason want relation l l  capture
conditions uncertainty l relevant uncertainty l   
say relation conformant relevance  preconditions must known
true order action applied  introduce propagate uncertainty
effects action 
let ci stand set clauses representing uncertainty initial situation  namely  non unit clauses along tautologies l l complementary
literals l l appearing unit clauses i  notion  conformant  relevance
extended clauses follows 
definition     relevant clauses   clause c ci relevant literal l p
literals l  c relevant l  set clauses ci relevant l denoted ci  l  
representation uncertainty initial situation relevant
literal l  possible analyze completeness translation kt m terms
relation merges literals l  one hand  sets clauses ci  l 
relevant l other 
   follow earlier account  palacios   geffner         many definitions theorems
differ number details  for example  notion relevance depends rules p
clauses initial situation   changes aimed making resulting formulation simpler
cleaner 

   

fipalacios   geffner

    covering translations
may appear translation kt m would complete
w merges precondition goal literals l  understood dnf formulas tm t  contain much
information  thus equivalent cnf formula ci  l  captures fragment
initial situation relevant l  intuition partially correct  misses
one important point  namely every dnf formula equivalent ci  l  do 
dnf representation captured merges must vivid enough  example  ci  l 
single clause x x  completeness requires tag x  tag x  merge
   x  x  l containing two tags  even clause x x tautology
thus equivalent dnf formula true 
defining types tags merges required completeness then 
let us first define closure set literals s  relative conformant problem
p   hf  i  o  gi  set literals follow i 
   l   i     l   
let us say consistent contain pair complementary literals 
type merges required precondition goal literals l
imply ci  l  satisfy well  notion satisfaction associates
consistent set literals partial truth assignment implicit closure
s  extended account conditions dnf formula  e g  
merge l  satisfies cnf formula  e g   ci  l   
definition     satisfaction  
   consistent set literals satisfies clause l  l 

lm contains one literals li                m 
   consistent set literals satisfies collection clauses c satisfies clause
c 
   collection consistent sets literals satisfies collection clauses c set
satisfies c 
type merges required completeness simply valid merges
satisfy set clauses ci  l   call covering merges 
definition     covering merges   valid merge translation kt m  p   covers
literal l satisfies ci  l  
example  ci  l  given clauses result oneof  x            xn   expression  i e  x  x  xn xi xj j    i  j n     j 
merge    x            xn   covers literal l  xi includes xi xj
j    i  thus xi satisfies ci  l  
w
merge    t            tn    denote dnf formula ti ti  
tag ti replaced closure ti   simple prove covers literal l 
entails ci  l   merge covers l thus dnf formula strong enough
imply cnf formula ci  l   through closure   weak enough entailed i 
vivid enough satisfy ci  l  
   

ficompiling uncertainty away conformant planning problems

illustration  ci  l  given tautologies p p q q 
  ci  l   merge m     p  p  implies ci  l  satisfy ci  l   likewise 
merge m      p  q    p  q   satisfies ci  l  entailed i  finally  merge
m      p  q    p  q    p  q    p  q   satisfies ci  l  entailed i  thus
valid merge covers l 
valid translation kt m  p   contains merge covers l precondition
goal literal l p   say translation covers p covering
translation 
definition     covering translation   covering translation valid translation
kt m  p   includes one merge covers l  precondition goal literal l
p  
central result paper covering translations complete 
theorem     completeness   covering translations kt m  p   complete  i e  
conformant plan p   classical plan   kt m  p    
merge actions removed 
words  complete translations kt m  p   result tags merges
capture information initial situation relevant precondition
goal literal suitable manner 
theorem    used two ways  proving completeness translation 
checking covering condition holds  constructing complete translations 
enforcing covering condition  addition  interest paper conformant planning optimality guarantees  theorem useful optimal conformant
planning well  whether cost plans defined length  action costs equal
   sum non uniform action costs  cases  theorem ensures
problem optimal conformant planning gets mapped problem optimal classical
planning provided cost merge actions kt m  p   made sufficiently small 
illustration theorem     consider conformant problem p initial situation    x  xm    goal g   l  actions ai                m  effect xi l 
number possible initial states problem exponential m  disjunction
among xi exclusive  so  translation ks   p   complete exponential
size  hand  consider translation kt m  p      x            xm  
contains single valid merge    x            xm   l  simple verify
merge covers goal l  satisfies ci  l    i   hence translation kt m  p  
covering  theorem     complete  polynomial m 
notice testing whether valid translation kt m  p   covering translation
done polynomial time  particular  computing set literals every tag
tractable operation provided pi form  indeed  i     l  iff    l 
iff l  tautology subsumed clause i 
    translation kmodels
straightforward show exponential translation ks  considered section   
 non empty  tags stand possible initial states  covering hence complete
   

fipalacios   geffner

according theorem     possible  however  take advantage theorem   
devising complete translation usually compact  call kmodels 
definition     translation kmodels p   obtained general scheme kt m  p  
defining
contain one merge precondition goal literal l given models
ci  l  consistent i  
contain tags merges along empty tag 
translation kmodels equivalent ks  precondition goal
literals l  ci  l    i  i e   clauses relevant l  yet  cases 
first translation exponential number variables appearing one ci  l 
set  the one largest number variables   second exponential
number unknown variables i  example  n precondition goal
literals li                n p one  ci  li   unique oneof  xi            xim  
expression  merge literal li ks   p   contain mn models n one of
expressions i  merge li kmodels p   contain models
single oneof  xi            xim   expression ci  li    translation kmodels thus
exponentially compact exhaustive ks  translation remaining sound
complete 
theorem     translation kmodels p   sound complete 
worst case  however  kmodels exponential translation  thus consider
next polynomial translations conditions complete 
    conformant width
address conditions compact  covering translation constructed polynomial time  this  define structural parameter call
conformant width problem p   analogy notion width used graphical
models  dechter         provide upper bound time space complexity
required generating covering translation  precisely  complexity construction exponential conformant width problem p cannot exceed
number fluents p much lower 
principle  would define width w p   maximum tag size required
translation kt m  p   covering translation  definition  however  would
give us complexity bounds want  checking validity merge
tags bounded size intractable operation  whether initial situation
prime implicate form not   need define width different way  first  let
cover set clauses defined follows 
   models ci  l  understood conjuntions literals 
   problem checking whether entails dnf formula whose terms may   literals
conp hard even equivalent true  indeed    cnf formula  contradictory iff
negation  which   dnf  valid  turn true iff implied i  actually 
general prime implicate form  problem remains conp hard even terms dnf formula
contain   literals  thank pierre marquis pointing results us 

   

ficompiling uncertainty away conformant planning problems

definition     cover   cover c c  set clauses c  relative conformant
problem p initial situation i  collection minimal sets literals consistent
contains literal clause c 
two important properties cover c c  set clauses c c c  stands
dnf formula logically equivalent cnf formula c given i  c c 
computed polynomial time size c bounded constant  moreover  c c 
implies c satisfies c well  thus particular  c collection clauses
ci  l  relevant literal l  cover c ci  l   ci  l  valid merge
covers l  completeness covering translations  follows complete
translation kt m  p   constructed polynomial time size  ci  l   sets
clauses ci  l  precondition goal literals l p bounded  unfortunately 
condition rarely seems hold  yet weaker sufficient condition does  namely 
often possible find subset c clauses either ci  l  tautologies
c c  satisfies ci  l  thus covers literal l  thus define width
literal l size smallest set  cardinality wise   this  denote
ci  l  set clauses ci  l  extended tautologies form p p fluents p
either p p appears ci  l   if appear ci  l  p p ci  l 
definition  
definition     width literal   conformant width literal l p   written w l  
size smallest  cardinality wise  set clauses c ci  l  c c  satisfies
ci  l  
consequence definition width literal must lie interval
  w l  n  n number fluents p whose status initial situation
known  indeed  ci  l  empty  w l       set clauses ci  l  
cover c c  set c tautologies ci  l  must satisfy ci  l   thus w l   c  n 
similarly  ci  l  contains single clause x  xm clauses x  xm
xi xj correspond oneof  x            xm   expression  simple prove
w l      singleton c    x  xm   generating cover c c      x              xn   
satisfies ci  l   finally  ci  l  contains two tautologies pp qq  w l     
smallest c ci  l  whose cover satisfies ci  l  ci  l  itself 
width problem width precondition goal literal maximum
width 
definition     width problem   conformant width problem p   written
w p    w p     maxl w l   l ranges precondition goal literals p  
show problems bounded width  complete translations
constructed polynomial time  moreover  almost existing conformant benchmarks bounded width  precisely  width equal    case 
resulting translations use tags never greater size w p   
problems width    tags single literals 
 tree width graphical models  computing width problem p
exponential w p    recognition problems small width carried
quite efficiently 
   

fipalacios   geffner

proposition     determining width   width w p   p determined time
exponential w p   
particular  test w p       considering one one sets c
includes single clause ci  l   verifying whether c c  satisfies ci  l  not 
w p        verification must carried setting c set
clauses ci  l  increasing values i  fixed value i  polynomial
number clause sets c verification one done polynomial
time  moreover  arguments regarding w l   w p   never exceed
number unknown fluents problem 
proposition     bounds width   width p   w p   n  n
number fluents whose value initial situation known 
    polynomial translation ki
translation ki   parameter non negative integer  instance
general kt m scheme designed sound  polynomial fixed i  complete
problems width w p   i  thus  example  translation k  sound  polynomial 
complete problems width   
definition     translation ki    translation ki  p   obtained general
scheme kt m  p  
set contain one merge   c c  precondition goal literal l p
set c clauses ci  l  covers l  set
exists  one merge   c c  l created set c clauses ci  l  
merges created l ci  l  empty 
collection tags appearing merges empty tag 
translation ki  p   applies problems p width  remaining cases exponential polynomial number fluents  actions  clauses p   addition 
translation ki  p   sound  problems width bounded i  complete 
theorem     properties ki    fixed i  translation ki  p   sound  polynomial 
w p   i  covering complete 
soundness result merges valid construction  covers c c 
c ci  l  entailed c hence i  complexity polynomial fixed
i  polynomial number clause sets c size ci  l   constructing
cover c c  one them  polynomial operation  finally  completeness follows
definition width  w p   i  set clauses c ci  l 
size  c  greater whose cover satisfies ci  l   thus ki  p   must contain
merge   c c  l covers l 
notice      translation ki  p   reduces basic k   p   translation
introduced section   tags  other empty tag  merges  before 
assessed completeness translation terms   approximation semantics 
theorem    provides alternative interpretation  translation k   p   complete
   

ficompiling uncertainty away conformant planning problems

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

domain parameter
safe n combinations
uts n locs
ring n rooms
bomb in the toilet n bombs
comm n signals
square center n n grid
cube center n n n cube
grid n shapes n keys
logistics n pack locs
coins n coins locs
block tower n blocks
sortnet n bits
adder n pairs bits
look and grab objs n n locs
  dispose objs n n locs

  unknown fluents
n
n
 n
n
n
 n
 n
nm
nm
nm
n  n       n    
n
 n
nnm
nnm

width
 
 
 
 
 
 
 
 
 
 
n  n       n    
n
 n



table    width parameterized domains
problems p zero width  problems set clauses ci  l 
relevant precondition goal literal l empty  makes precise intuition
mentioned k   p   translation complete problems uncertain
information relevant  cases  none clauses initial situation
make sets relevant clauses ci  l  preconditions goal literals l 
illustration theorem     consider conformant problem p initial
situation    x  xm    goal g    l   actions ai                m 
effect xi l  problem  singleton set clauses c   ci  l   
c c      x              xm    covers ci  l   then  since precondition goal
literal  k   p   includes single merge   c c  l singleton tags ti    xi   
write simply    x            xm    translation k   p   polynomial m 
since w p        theorem    complete  notice example 
translations ks   p   kmodels p   identical exponential  the number
models ci  l   
    width conformant benchmarks
practical value notion width becomes apparent width existing
benchmarks considered  table   summarizes width many existing benchmark
domains conformant planning  domains depend certain parameters n
capture size instances  e g   size grid  number objects  etc    domain
bounded width width grow size instances 
width equal instances width regardless parameter values 
seen table  width existing benchmarks   
cases  means sets ci  l  clauses relevant precondition
   names parameterized domains table coincide names instances
currently used  e g  comm n ipc  refers communication instance necessarily
instance n signals 

   

fipalacios   geffner

goal literal l contain single clause  often tautology p p disjunction x        xm  
single oneof  x            xm   expression  that translates disjunction x  xm
clauses xi xk    shown above  w l   therefore  w p    equal   theses
cases 
extreme domains blocks  sortnet  adder 
maximal widths  i e   widths equivalent number fluents whose status initial situation known  fluents interact
action conditions  not preconditions   numbers blocks table    thus follow
number fluents involved  namely  fluents on x  y   clear x   ontable x  
holding x  
finally  domains   dispose look and grab  palacios   geffner             
objects unknown locations grid n n must collected robot
whose gripper hold one object time  width equal m  meaning
width domains grows number objects size grid 
case  clauses possible locations objects
relevant condition hand empty pick actions 
let us point completeness translation ki  p   problems p
width w p   bounded i  establishes correspondence conformant plans
p classical plans kt m  p    solving p   however  correspondence
needed  suffices ki  p   solvable  plan ki  p   encode
conformant plan p   even ki  p   capture conformant plans p  
perspective  makes sense refer smallest value parameter
classical problem ki  p   solvable  effective width p   denoted  p    turns
 p   cannot larger w p    may much smaller  interesting
example comes sortnet n domain  bonet   geffner         sortnet n
considered challenging domain conformant planning planners able
scale even small values n  the number entries sorted sorting network  
domain width n  compact encoding used ipc   input vector
represented set bits  exploiting fact sorting vectors numbers reduces
sorting vector bits   s  s   domain cannot solved k  translation
reports correctly unsolvable brief unsuccessful search  hand 
possible reformulate domain  replacing unary high i  low i  predicates
binary predicates less i  j  compare two vector entries  call reformulation
sort   n  encoding sort n linear n  encoding sort   n quadratic n 
cases  problem width maximum  given number fluents whose
status initial situation unknown  yet  compact sort n encoding
solvable k  translation  k  suffices solve problem expanded sort  n encoding actually solved k    thus effective width sort   n
   interestingly  provided k  translation sort   n  instances solved
   entries  hand  conformant planners conformant ff pond
solve sort   n instances n greater   
   

ficompiling uncertainty away conformant planning problems

   tags initial states
deeper understanding results obtained relating tags possible
initial states  looking closely relation context covering translations 
able answer question polynomial number contexts  tags 
play role exponential number possible initial states problems bounded
width 
this  let us first recall notation introduced section      state s 
wrote i s  refer set atoms encoding  i e  p i s  iff p true s  p s
refer classical planning problem p s   hf  i s   o  gi conformant
problem p   hf  i  o  gi initial state fixed s 
let us extend notation say action sequence conforms set
states given conformant problem p iff plan classical problem p s
s  clearly  conformant plan p nothing else action sequence
conforms set s  possible initial states p   yet notion conforms allows
us abstract away initial situation make precise notion basis 
definition     basis p    set states   basis conformant problem p  
hf  i  o  gi   subset set s  possible initial states p every plan
conforms   conforms set possible initial states s   
words    basis p   necessary consider states s 
computing conformant plans p   suffices consider states     aim
show width p bounded  p polynomial basis   even s 
exponential size  moreover  states basis close correspondence
tags appearing covering translation 
illustration  consider problem p actions ai                n  effects
ai   xi l  let g    l  goal    x  xn   initial situation 
set s  possible initial states truth valuations xi atoms least
one atoms true   n   states  hand  one show
set s   n valuations exactly one atoms true provides basis
p   i e   plans conform n possible initial states  exactly plans
conform complete set  n   possible initial states s   
reduction number possible initial states must considered computing conformant plans results two monotonicity properties formulate using
notation rel s  l  refer set literals l  true state
relevant literal l 
rel s  l     l    l  l  relevant l   
proposition     monotonicity     let s  two states let action sequence
applicable classical problems p s p s    achieves literal l p s 
rel s    l  rel s  l   achieves literal l p s 
proposition     monotonicity       two collections states
every state every precondition goal literal l p   state s   
rel s    l  rel s  l   plan p conforms     plan
p conforms s 
   

fipalacios   geffner

properties  follows
proposition       basis p every possible initial state p every
precondition goal literal l p     contains state s  rel s    l  rel s  l  
proposition allows us verify claim made example set s    
contains number states linear n  basis p exponential
number possible initial states  indeed  problem precondition single
goal literal l  every state makes one atom xi true  these
literals relevant l   state s  s   makes one atoms true 
hence relation rel s    l  rel s  l  holds 
question address build basis complies condition
proposition    given covering translation kt m  p    this  let    t            tn  
merge covers precondition goal literal l  let s ti   l  denote set
possible initial states p rel s  l  ti   i e   s ti   l  contains possible initial
states p make literals l  relevant l false  except
closure ti ti   show first prime implicate form  s ti   l  non empty
set  
proposition     initial situation prime implicate form    t            tn  
valid merge covers literal l p   set s ti   l  possible initial states
p rel s  l  ti non empty 
let s ti   l  stand arbitrary state s ti   l   obtain following result 
theorem     let kt m  p   covering translation problem p initial
situation pi form  let   stand collection states s ti   l  l
precondition goal literal p ti tag merge covers l    basis
p  
important result three reasons  first  tells us build basis p
given tags ti covering translation kt m  p    second  tells us size
resulting basis linear number precondition goal literals l tags ti  
third  makes role tags ti covering translation kt m  p   explicit  providing
intuition works  tag ti merge covers literal l represents one
possible initial state  namely  state s ti   l  makes false literals l 
relevant l except ti   plan conforms critical states 
conform possible initial states monotonicity  proposition      follows
particular that 
theorem     p conformant planning problem bounded width  p admits
basis polynomial size 
namely  conformant problems p width bounded non negative integer admit
polynomial translations complete  plans conform possibly
exponential number initial states p correspond plans conform
   recall assuming throughout initial situation logically consistent
tags consistent i 

   

ficompiling uncertainty away conformant planning problems

subset critical initial states polynomial number  namely 
polynomial basis   thus  one complete polynomial translation problems
ki translation  another one  ks  translation tags associated
critical initial states rather initial states 
illustration  problem p actions ai effects ai   xi l 
goal g    l   initial situation    x  xn    k   p   translation tags xi  
             n  merge    x            xn   goal literal l  covering translation 
theorem    states basis   p results collection states si
make tag xi true  literals relevant l xi false  i e  
xk atoms k    i   precisely basis p includes
states make single atom xi true              n  plans conform
basis exactly plans conform whole collection possible initial
states p   basis size polynomial though  number
possible initial states p exponential m 

   planner t 
current version conformant planner t  based two instances general
translation scheme kt m  p   whose outputs fed classical planner v      one
instance polynomial necessarily complete  complete necessarily
polynomial  incomplete translation  t  uses k  complete problems
width greater    argued above  result solvable instances problems
larger widths  complete translation  kmodels translation used instead
simple optimization  k  translation produces single merge covers l 
merge used l instead potentially complex one determined
kmodels  mere optimization resulting translation remains complete 
merges kmodels  result models set clauses ci  l 
consistent i  computed using sat solver relsat v      bayardo jr    schrag 
       current default mode t    one used experiments below 
two translations k  kmodels used sequence  called first upon
output k  fails  called upon output kmodels  experiments
below  indicate cases kmodels invoked 
translations used t  accommodate certain simplifications two additional
actions capture types deductions  simplifications fact
translations considered uniform sense literals l p
rules c l conditioned tags   practical point
view  however  needed  simplifications address source inefficiency 
particular 
literals kl t created closure contains literal relevant l 
case  invariance kl t kl holds  thus  every occurrence
literal kl t kt m  p   replaced kl 
   conformant planner t  along benchmarks considered paper available
http   www ldc usb ve hlp software 

   

fipalacios   geffner

support rules   kc t kl t non empty tags created l
relevant literal l  merge contains t  case  literal
kl t cannot contribute establish precondition goal  similarly  cancellation
rules   kc t kl t non empty tags created l
relevant literal l  merge contains t 
support cancellation rules   kc t kl t   kc t kl t
grouped   kc t kl t kl t every fluent l  relevant l  either
l  l  entailed t  case  incomplete information
l given initial situation  thus invariant kl t kl t holds 
kc t equivalent kc t 
two types sound deductive rules included translations 
rule   kc kl added   c  l l rule p action a 
rule p form   c   l 
rules kl            kli    kli             kln kli              n added
new unique action precondition  l  ln static clause p  a
clause p static true initial situation provably true action  
rules versions action compilation static disjunctions rules  palacios  
geffner               appear help certain domains without hurting others 
version t  reported assume initial situation p
prime implicate form rather renders pi form running version tisons
algorithm         computation none benchmarks solved took   
seconds 
translators t  written ocaml code parsing pddl files
written c   

   experimental results
considered instances three sources  conformant ff distribution  conformant track      international planning competition  ipc    relevant publications  palacios   geffner              cimatti et al          instances run
cluster linux boxes      ghz  gb  experiment cutoff  h    gb
memory  times t  include steps  particular  computation prime implicates  translation  search  done ff   include results conformant
track recent      international planning competition  ipc   
goals sets literals sets clauses transformed t  standard
way  goal clause c   l  lm modeled new goal atom gc   new
action executed added rules li gc                m  
   alternative way represent cnf goals converting dnf first
action end map non mutex terms dummy goal lg   alternative encoding pays
cases  adder    instance get solved default cnf goal
encoding  see below  

   

ficompiling uncertainty away conformant planning problems

problem
bomb        
square center   
sortnet   
blocks   
dispose     
look and grab      
sgripper   

p
 acts  atoms  effects
     
   
     
 
   
   
  
  
   
  
  
   
    
    
    
   
   
    
   
   
    

time
 
    
   
 
     
   
    

k   p  
pddl
 acts  atoms  effects size
     
    
     
   
 
     
     
   
  
     
      
   
  
     
     
   
           
    
   
   
    
      
   
   
    
     
 

table    translation data selected instances   acts   atoms   effects stand
number actions  fluents  conditional effects  time translation
time seconds rounded closest decimal  pddl size size
pddl file megabytes 

table   shows data concerning translation group selected instances 
seen  number conditional effects grows considerably cases  sometimes
translation may take several seconds 
tables                show plan times lengths obtained number
benchmarks t    pond      bryce et al          conformant  hoffmann   brafman 
       mbp  cimatti et al         kacmbp  bertoli   cimatti         last
two planners accept problems standard syntax  based pddl  
limited number experiments performed them  general picture t 
scales well domains  exceptions square center cube center
table    kacmbp scales better  sortnet table    kacmbp mbp
scale better  adder table    pond planner able solve one
instance 
problems table   encodings conformant ff repository  bomb x y
refers bomb in the toilet problem x packages  toilets  clogging  logistics ij k variation classical version uncertainty initial location packages 
ring n closing locking windows ring n rooms without knowing
current room  safe n opening safe n possible combinations 
problems width    t  clearly best last two domains  first two
domains  conformant ff well too 
table   reports experiments four grid domains  cube center n refers problem
reaching center cube size n  completely unknown location  squarecenter n similar involves square n  possible locations  corners cube n
corners square n variations problems set possible initial locations
restricted cube square corners respectively  mbp kacmbp appear
effective domains  although kacmbp doesnt scale well corner versions 
t  solves problems  corner versions  quality plans poor 
problems width   
table   reports experiments problems      international planning competition  bonet   givan         domains coins  comm uts width   
others max width given number unknown fluents initial situation 
   

fipalacios   geffner

problem
bomb     
bomb     
bomb      
bomb      
bomb      
bomb      
bomb       
bomb       
bomb        
logistics      
logistics        
logistics        
logistics        
ring  
ring  
ring  
ring  
ring  
ring   
safe   
safe   
safe   
safe   
safe    

t 
time
   
   
   
   
   
   
   
    
   
   
 
   
   
   
   
   
   
   
    
   
   
   
    
   

len
  
  
  
  
   
   
   
   
   
  
  
   
   
  
  
  
  
  
   
  
  
  
  
   

pond
time len
       
   h
   h
   h





  
  
   h
   h
   h
 
  
 
  
  
  
   
  
   h

 
  
 
  
 
  
  
  
     gb

cff
time
len
 
  
 
  
 
  
 
  
    
   
    
   
    
   
   
   
 
   
 
  
   
  
   
   
   
   
   
  
   
  
    
  
   
  
   h

 
  
   
  
    
  
     
  
          

mbp
time len
   h
   h
   h
   h





   h
   h
   h
   h
 
  
   
  
   
  
   
  
  
  
   h
   
  
   h
   h
   h
   h

kacmbp
time len
 
  
   
  
   
  
 
  
   
   
   
   
        
   h
   h
     gb
     gb
     gb
     gb
 
  
   
  
   
  
   
   
 
   
     gb
 
  
   
  
   
  
   
  
   
   

table    experiments well known benchmarks  times reported seconds rounded
closest decimal  means time memory smaller instances 

   

ficompiling uncertainty away conformant planning problems

problem
square center  
square center   
square center   
square center   
square center   
square center   
square center    
square center    
cube center  
cube center  
cube center  
cube center   
cube center   
cube center   
cube center   
cube center   
cube center   
cube center   
cube center    
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square    
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   

t 
time
len
   
  
   
  
   
  
   
  
    
   
    
   
     gb
     gb
   
  
   
  
   
  
   
  
   
  
   
  
    
   
    
   
         
     gb
     gb
   
  
   
   
   
   
   
   
   
   
   
   
   
   
         
         
         
          
   
   
   
   
   
   
   
   
   
   
   
   
    
   
   
    
     gb

pond
time len
 
  
  
  
       
   h
   h



 
  
 
  
 
  
  
  
       
   h
   h




  
  
       
   h
   h







       
        
   h
   h






cff
time
len
    
  
   h
   h





   
  
   h
   h








   
  
    
   
    
   
   
   
mpl






         
         
         
          
mpl





mbp
time
len
 
  
 
  
 
  
 
  
   
   
   
   
   
   
   
   
 
  
 
  
   
  
   
  
   
  
   
   
  
   
     gb
     gb


 
  
 
  
   
  
   
  
   
  
   
   
   
   
         
   
   
         
     gb
   
  
    
  
         
         
   h
   h




kacmbp
time
len
 
  
 
  
 
  
 
  
   
   
   
   
   
   
   
   
 
  
 
  
 
  
 
  
 
  
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
   
   
   
    
   
          
   h
   h



         
         
          
    
   
          
   h
   h



table    experiments grid problems  times reported seconds rounded
closest decimal  mpl cff means plan exceeds maximal plan length
     actions   means time memory smaller instances 

   

fipalacios   geffner

problem
adder   
adder   
blocks   
blocks   
blocks   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
comm   
comm   
comm   
comm   
comm   
comm   
comm   
comm   
sortnet   
sortnet   
sortnet   
sortnet   
sortnet   
sortnet   
uts k   
uts k   
uts k   
uts k   
uts k   
uts k   
uts k   
uts l   
uts l   
uts l   
uts l   

t 
time len
   h
   h
   
 
   
  
    
  
   
  
   
  
   
  
   
   
   
  
   
  
   
   
   
   
   h
   
  
   
  
   
  
   
  
   
   
   
   
   
   
   
   
   
  
   
  
   
  
    
  
     gb
     gb
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  

pond
time len
    
 
   h
   
 
   
  
         
 
  
   h
   h






 
  
 
  
 
  
 
  
 
  
   h
     gb

  
  
   
  
   h
   h


 
  
 
  
  
  
  
  
  
  
   h
    
  
   
  
   
  
   h
   h

cff
time len
snh
snh
 
 
   h
   h
   
  
   
  
 
  
        
   
  
   
   
        
        
   h
 
  
 
  
 
  
 
  
   
  
   
   
   
   
        
snh
snh
snh
snh
snh
snh
   
  
   
  
   
  
   
  
   
  
   
  
    
  
   
  
   
  
   
  
   
  

mbp
time
len
nr
nr
nr
nr
nr
   h
   h







   
  
   
  
   
  
   
  
   
   
   
   
    
   
   h
 
  
 
  
 
  
 
  
   
  
   
  
   
  
         
         
   h
   h


    
  
    
   
    
   
   h

kacmbp
time
len
nr
nr
nr
nr
nr
   
   
          
   h
   h





    
  
         
   h
   h




 
  
 
  
 
  
 
  
   
  
   
  
   
  
     
  
   h
   h



   h
   h



table    experiments problems ipc   times reported seconds rounded
closest decimal  snh cff means goal syntax handled 
nr mbp kacmbp planners run due lack
translations pddl  means time memory smaller instances 

   

ficompiling uncertainty away conformant planning problems

problem
dispose    
dispose    
dispose    
dispose    
dispose    
dispose    
dispose     
dispose     
dispose     
dispose     
dispose     
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      

t 
time
len
   
  
   
   
   
   
   
   
    
   
         
  
    
         
     gb
   
    
     gb
   
  
   
 
    
 
  
  
     
 
     
 
     gb
     
 
     gb
    
   
    
  
     
  
   h
   h
   h
   h
   h
   h

pond
time len
 
  
  
  
       
     gb
     gb






       
   h
   h
     gb
   h
   h
     gb












cff
time
len
   
  
   
  
   
  
         
          
   h

     gb



   h
mcl
mcl
   h
mcl
mcl
   h
   h
   h










mbp
time len
   h
   h









   h
    
 
    
 
   h
    
 
    
 
   h
    
 
    
 
   h
   h
   h
   h
   h
   h
   h
   h
   h

kacmbp
time len
    
  
   h
   h








   
  
   
 
   
 
    
  
    
 
    
 
    
  
    
 
    
 
   h
   h
   h
   h
   h
        
   h
   h
    
  

table    problems palacios geffner               times reported seconds
rounded closest decimal  means time memory smaller instances 
mcl mean many edges many clauses respectively 

t  dominates domains except adder pond planner able
solve instance  sortnet  mbp kacmbp well  possibly due
use cardinality heuristic obdd representations  t  fails adder
gets lost search  looking problem closely  found could solve
 translation the  first instance less minute provided cnf goal
problem encoded dnf explained footnote    page      domains adder 
blocks  sortnet table  along domain look and grab next table 
domains considered run k  translation reports solution
brief search  triggering use complete kmodels translation 
cases kmodels used  k  translation unreachable goal fluent
need try it 
   

fipalacios   geffner

problem
push to    
push to    
push to    
push to    
push to    
push to    
push to     
push to     
push to     
  dispose    
  dispose    
  dispose    

t 
time
len
   
  
   
  
   
  
    
   
     
   
          
   h
   h
     gb
    
    
     gb
     gb

pond
time len
 
  
   
  

   h
   h
   h



     gb
     gb


cff
time len
   
  
   
  
   
  
     gb
     gb
     gb



   h
   h


table    problems palacios geffner               mbp kacmbp
tried problems use different syntax  times reported
seconds rounded closest decimal  means time memory
smaller instances 

problems reported table   table   variations family grid problems
 palacios   geffner               dispose retrieving objects whose initial location
unknown placing trash given  known location  push to variation
objects picked two designated positions grid
objects pushed to  pushing object cell contiguous cell moves
object cell    dispose variation dispose robot hand
empty condition pick actions work  result  plan   dispose
scan grid  performing pick ups every cell  followed excursions trash can 
on  plans get long  a plan reported      actions   look and grab
action picks objects sufficiently close any  pickup must dump objects collected trash continuing  problem
p n m table  n grid size number objects  look n grab 
third parameter radius action    means hand picks
objects   surrounding cells    hand picks objects   
surrounding cells  on  domains tables     width   except   dispose
look n grab  because  hand empty fluent relevant
goal  clauses location objects relevant hand empty 
domains t  appears better planners  kmodels translation
triggered instances look and grab n m r      the width
instances  mentioned section      m  independent grid size  
report additional data table    comparing search results
use planner classical translations t    search carried
conformant ff original conformant problems  conformant ff conformant
planner built top searches explicitly belief space  table illustrates
two problems faced belief space planners mentioned introduction handle
   

ficompiling uncertainty away conformant planning problems

problem
bomb      
bomb        
safe    
logistics        
square center  
square center   
cube center  
cube center  
blocks   
blocks   
coins   
comm   
uts k   
dispose    
dispose    
dispose    
look and grab      

nodes
    
   
   
   
    
     
    
     
  
    
    
   
  
    
    
    
    

cff
time
    
   
      
    
    
       
   
       
   
       
    
    
    
     
      
       
       

nodes sec
     
   
   
    
    
 
     
    
    
   
  
   
   
   
   
   
   

nodes
    
   
   
   
  
  
  
   
  
  
   
    
  
     
     
      
  

t 
time nodes sec
    
       
    
    
 
     
    
      
    
   
    
    
    
    
   
    
 
     
   
    
    
     
    
      
    
     
    
       
     
      
     
      
   
   

table    cff conformant problems vs  translations  nodes stand number
nodes evaluated  time expressed seconds  nodes sec stands average
number nodes per second  numbers shown bold either cff
evaluate significantly less nodes  an order of magnitude reduction more   times
preceded   time outs 

   

fipalacios   geffner

results translation based approach  belief representation
update problem appears overhead maintaining evaluating beliefs 
shows number nodes evaluated per second  cff evaluates
hundred nodes per second  evaluates several thousands  time  heuristic
used cff conformant setting  appears less informed heuristic used
classical translations  domains square center n  cube center n 
blocks  look and grab  needs orders of magnitude less nodes cff find
plan  oppositive true dispose n m evaluates many nodes
cff  nonetheless  even then  due overhead involved carrying beliefs 
manages solve problems cff cannot solve  example  instance dispose    
solved t  evaluating half million nodes  times cff
evaluating less three thousand nodes 
tables       provide details results conformant track     
international planning competition  ipc    bryce   buffet         held almost time
original version paper submitted  planner binaries submitted
organizers months before  version t  ipc  different
version t  used ipc   winning entry  different
version reported paper  relation  former  t  ipc  cleaner
complete reimplementation  relation latter  t  ipc  handled problems width
greater   different way  explained previous section  current version
t    uses k  basic translation regardless width problem  switching
kmodels search k  fails  version t  ipc   basic translation
combination k  k    precisely  merges literals l width w l      
generated according k    merges literals l width w l      
generated all  result basic translation t  ipc  lighter
basic translation current version t  could fail problems width
higher   latter solve  retrospectively  good choice 
didnt much impact results  however bug program
prevented two width   domains  forest dispose  recognized such 
thus resulted use kmodels translation  complete widths 
scale well 
two conformant planners entered ipc  cpa h  cpa c  
belief space planners represent beliefs dnf formulas  use simple
belief state heuristics guiding search  tran  nguyen  pontelli    son              
belief progression planners done quite effectively  progressing term
turn  according   approximation semantics  potential blow comes
number terms dnf formula encoding initial belief state  rather choosing
terms initial belief state possible initial states  planners limit
terms dnf formula collection partial initial states assign
truth value literals deemed irrelevant  resulting belief representation
complete may still result exponential number terms  son   tu         order
reduce number terms initial dnf formula  independent one of
expressions combined  example  two independent one of clauses oneof  x    x   
oneof  y    y    would give rise   possible initial states dnf terms  combined
single one of expression oneof  x  y    x  y     results   possible initial
   

ficompiling uncertainty away conformant planning problems

domain
blocks
adder
uts cycle
forest
raos keys
dispose

  instances
 
 
  
 
  
  

cpa h 
 
 
 
 
 
  

cpa c 
 
 
 
 
 
  

t  ipc 
 
 
 
 
 
  

table     data conformant track recent ipc  competition  number
problems solved conformant planners  time    mins 
bold  entry planner performed best domain  data
bryce buffet       

states terms  one of expressions independent shown
interact problem  technique appears related notion critical
initial states considered section    shown plans conform
critical initial states must conform possible initial states  heuristics used
cpa h  cpa c  combinations cardinality heuristic  measures
number states belief state  total sum heuristic  adds heuristic distances
goal possible state  number satisfied goals  counts
number top goals achieved  heuristics simple  yet work well
benchmarks 
tables       show data obtained ipc  organizers planner logs 
first table appears ipc  report  bryce   buffet         new domains
forest raos keys explained  shows number problems solved
planner  displaying bold planner best domain  planner cpa h  
declared winner  declared best three domains  blocks  raos keys 
dispose   t  best two domains  uts cycle forest   cpa c 
best one  adder  
table    shows additional details instances  particular  total time
taken solve instance length plans three planners 
terms domain coverage  planners similarly domains  except
forest  t  solved instances cpa h  solved      vs       
dispose  cpa h  solved instances t  solved        vs         
terms time plan quality  cpa h  cpa c  appear slightly faster
t  blocks  produce much longer plans  dispose  t  scales better
cpa h  cpa c  size grids  worse number objects 
indeed  t  manages solve largest grid single object  dispose        
cpa h  cpa c  solve instances   objects largest grids 
cases  plan lengths produced t  shorter  e g   plan dispose      
contains     actions t        cpa h       cpa c  
dispose actually domain cardinality heuristic well generation plans  even plans tend rather long  discussed above  domain 
agent scan grid collecting set objects unknown locations  time
   

fipalacios   geffner

action picking object cell may contain object made  except
first time   cardinality belief state reduced  indeed  initially object
may positions p    p            pn   pick p    object positions
p            pn gripper  pick p    object positions p            pn
gripper  on  pick action decreasing cardinality belief state 
becoming singleton belief object must gripper certainty 
problem version t  used ipc  dispose domain 
explores many states search  explained above  used
expensive kmodels translation instead lighter k  translation complete
domain width    bug fixed  t  solves    rather      
dispose instances  still failing larger grids many objects  producing
much shorter plans  example  dispose      solved plan     actions 
cpa h  cpa c  solve plans           actions respectively 
bug surfaced forest domain  prevented solution one instance
only  forest  dispose  uts cycle conformant widths equal   
domains larger widths  see table   widths blocks adder  
second domain ipc  got lost search adder  indeed  t 
solve instance  instance shown solved t  competition
report  appears mistake  similarly  fourth instance blocks  reported
solved cpa h   may mistake too  indeed  plan instance found
logs  t  reports goal unreachable kmodels translation
complete  according t    instance four raos key unsolvable too 
hand  t  failed larger uts cycle raos key instances translation 
first  resulting pddls large cant loaded ff 
second  number init clauses turns quite large  above       giving rise
still larger set prime implicates  above       caused translator run
memory  second instance raos keys  however  rather small t  didnt solve
due different bug  bug fixed  t  solves     seconds  producing plan
   actions  compares well solutions produced cpa h  cpa c 
        seconds        steps  respectively 

    non deterministic actions
translation schemes considered limited problems deterministic actions
only  nonetheless  illustrate below  schemes applied non deterministic
actions well provided suitable transformations included  cover transformations briefly matter illustration only 
consider conformant problem p non deterministic action effects   c oneof  s   
s            sm    si set  conjunction  literals  transformed problem
p     effects mapped deterministic rules form   c  hi si  
expression oneof  h            hm   added initial situation p     p     hidden hi
variables used encoding uncertainty possible outcomes si action a 
easy show non deterministic conformant problem p deterministic conformant problem p   equivalent provided plans p p  
considered non deterministic action p executed once  namely 
   

ficompiling uncertainty away conformant planning problems

problem

instance

blocks

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
   
   
   
   
   
   
   
   
   
   
    
    

adder
uts cycle

forest

raos keys
dispose

cpa h 
time
len
 
 
   
  
   
   
         
   
 
   
 
    
 

cpa c 
time
len
 
 
   
  
   
   
   
   
    

 
 
 

   

  

    

  

   
   
   
   
   
 
   
    
    
    
    
    
    

  
  
  
   
   
   
   
   
    
    
   
    
    

 
   
   
   
   
   
   
    
    
     
    
     

  
  
  
   
   
   
   
   
    
    
   
    

t  ipc 
time len
   
 
   
  
    
  

   
   
   
   
   
   
    
    
    
     

 
 
  
  
  
  
   
   
   
   

 

  

   
   
     

  
   
   

   
     

   
   

   

   

  

   

table     running time plan length ipc  logs  time seconds  blanks stand
time memory out        dispose n m instances shown 
ipc   size n grid ranged       number objects   
    t  scales best n worst m 

   

fipalacios   geffner

correspondence exists conformant plans p use actions
conformant plans p   use actions too 
hand  conformant plan p   actions done many times
necessarily represent conformant plan p   indeed  non deterministically moves
agent right square grid n n  starting bottom left corner  n actions
row would leave agent either top left corner bottom right corner p    
anywhere manhattan distance n origin p  divergence p
p     however  arise non deterministic actions executed once 
building idea  non deterministic conformant planner obtained
deterministic conformant planner following way  non deterministic problem
p   let p  problem p   above  additional constraint actions
p  arising non deterministic actions p executed once 
easily achieved adding precondition enabled a  true initially
sets false  let p  represent deterministic conformant problem
non deterministic action p mapped   deterministic actions  executable
once  hidden fluents h            hm oneof  h            hm  
expression initial situation  similarly  let pi deterministic problem results
encoding non deterministic action p deterministic copies 
encoding  simple iterative conformant planner non deterministic problems p defined terms conformant planner deterministic problems
invoking latter upon p    p    p    on  solution reported  reported
solution uses copy non deterministic action once  thus encodes
solution original problem 
implemented strategy top t  additional refinement
takes advantage nature kt m translation  assumptions initial
situation maintained explicitly tags  basically  non deterministic actions pi
allowed executed provided literals kl hi depend
particular outcome actions  si   erased  implemented means
additional reset a  action pi whose unconditional effect enabled a   i e  
action done again  whose conditional effects kl kl hi
kl kl hi              m  namely  literals kl hi truth l depends
particular non deterministic outcome  si   erased  except l true
assumptions  i e  kl true  non deterministic actions executed
plan provided occurrence a  except first one  preceded
reset a  action 
table    compares resulting non deterministic planner mbp kacmbp
number non deterministic problems considered mbp kacmbp papers 
added additional domain  slippery gripper  sgripper   similar
classical gripper number balls moved room b  except
robot cannot move b directly  non deterministic move action
move a  c  d  moves robot either c d  typical plan moving
two balls b pick a  move c d  move c b 
b  finally dropping balls b 
deterministic conformant planner  t    used non deterministic setting
added following modification  merges introduced precondition goal
   

ficompiling uncertainty away conformant planning problems

problem
sgripper   
sgripper   
sgripper   
btuc    
btuc    
btuc    
btuc    
btuc    
bmtuc      
bmtuc      
bmtuc      
bmtuc      
bmtuc      
bmtuc       
bmtuc       
bmtuc        
nondet ring  
nondet ring   
nondet ring   
nondet ring   
nondet ring   
nondet ring  key  
nondet ring  key   
nondet ring  key   
nondet ring  key   
nondet ring  key   
nondet ring  key   

t 
time len
   
  
    
  
  
   
   
   
   
   
  
   
        
  
   
   
  
   
  
   
  
   
   
   
   
   
   
        
        
    
  
   h
   h


   h
     gb





mbp
time
len
   h
   h

   h
   h



    
  
   h
   h





 
  
   
  
         
   h

   
  
    
   
         
     gb



kacmbp
time
len
   
  
   
   
    
   
 
   
   
   
    
   
    
   
    
   
   
  
   
  
   
  
   
   
          
    
   
   h
   h
   
  
   
   
   
   
   
   
          
   
  
 
   
    
   
          
           
   h

table     non deterministic problems  problems except sgripper mbp
kacmbp  problems modified render simple translation
pddl  particular  complex preconditions moved conditions  times
reported seconds rounded closest decimal  means time memory
smaller instances 

literals literals  reason setting pays remove uncertainty
literals reset mechanism used  indeed  provided simple change
reset mechanism  none problems move beyond p   a single copy
non deterministic action  even domains non deterministic actions
required many times plans  e g     balls room a  
seen table  t  better mbp collection nondeterministic domains  although well kacmbp  particular  nondetring non det ring  key domains  case  results obtained t 
domains quite meaningful  cases t  failed solved problem  reason
classical planner  ff  got lost search plans  something may
improve advances classical planning technology 

   

fipalacios   geffner

    related work
recent conformant planners cff  pond  mbp cast conformant planning
heuristic search problem belief space  bonet   geffner         compact belief
representations informed heuristic functions  however  critical making approach work  effective belief representation  planners use sat obdds
techniques intractable worst case often exhibit good behavior average 
heuristics  hand  use fixed cardinality heuristics count number
states possible given belief state  a tractable operation obdd representations  heuristics obtained relaxed planning graph suitably extended take
uncertain information account  heuristics appear work well domains
others  perspective  translation based approach provides handle
two problems  belief states p become plain states translation kt m  p   
solved using classical heuristics  established conditions
belief representation compact complete 
sound incomplete approach planning incomplete information advanced
petrick bacchus        represent belief states formulas  order make
belief updates efficient though  several approximations introduced  particular 
existing disjunctions carried one belief next  new disjunctions
added  imposes limitation type problems handled 
two limitations approach domains must crafted hand 
control information derived domains search plans blind 
approach understood providing solution two problems too 
one hand  move knowledge level done automatically  other 
problem lifted knowledge level solved classical planners able search
control information derived automatically new representation 
third thread work related approach arises so called   approximation
semantics  baral   son           approximation semantics  belief states b represented sets states single   valued state fluents true  false 
unknown  proposition   above  correspondence established plans
p conformant according   approximation semantics classical plans
translation k   p    turns instance general translation
ki  p   complete problems width      semantics translation
k  thus related   approximation semantics  yet k  translation delivers something more  computational method obtaining conformant plans comply
  approximation semantics using classical planner 
  approximation basic k  translation weak dealing
existing benchmarks  translations ki extend k  problems higher width
replacing set fluents kl fluents kl t tags encode assumptions
initial situation  extensions   approximation semantics context
conformant planning taken different form  switching single   valued state
representing beliefs sets   valued states    valued state progressed efficiently
independently others  son  tu  gelfond    morales         initial set
  valued states obtained forcing states assign boolean truth value  true false 
number fluents  crucial approach work number fluents 
   

ficompiling uncertainty away conformant planning problems

belief representation update exponential it  conditions ensure
completeness extension   approximation semantics expressed terms
relevance analysis similar one underlying analysis width  son   tu 
       fluents must set true false initial   valued state
appearing clause ci  l  precondition goal literal l  particular 
initial situation n tautologies pi pi   relevant precondition goal literal
l  number initial   valued states required completeness exponential n 
make fluent pi true false  difference approach seen
tautologies pi pi relevant unique precondition goal literal li  
case  number   valued partial states required completeness remains
exponential n  resulting problem width   thus solved
k  translation involves tags single literal  words  tags used
translation scheme encode local contexts required different literals
problem  initial   valued states  son   tu        encode possible combinations
form global contexts  global contexts correspond consistent combinations
local contexts  may thus exponential number even problem
bounded width  planners cpa h  cpa c   discussed context
conformant track recent      int  planning competition  ipc    build
approach  reduce number partial initial states required using technique
replace many one of expressions single one  tran et al                simplification
related notion critical initial states discussed section   
another difference   valued approach  son et al         son   tu        
translation approach addresses representation beliefs
computation conformant plans  conformant problem p translated problem
kt m  p    solved classical planner  approaches defined
top   approximation semantics  knowledge level approach planning
incomplete information petrick bacchus         need way guide search
plans simplified belief space  search petrick bacchus        blind
 iterative deepening   search son et al          son tu        guided
combination simple heuristics cardinality subgoal counting 

    summary
practical problems purely conformant  ability find conformant plans
needed contingent settings conformant situations special case  paper 
introduced new approach conformant planning conformant problems p
converted classical planning problems kt m  p   solved classical
planner  studied conditions general translation sound
complete  translation depends two parameters  set tags  referring local
contexts initial situation  set merges stand valid disjunctions
tags  seen different translations  ks  kmodels  obtained
suitable choices tags merges  introduced measure complexity
conformant planning called conformant width  translation scheme ki polynomial fixed complete problems width bounded i  shown
conformant benchmarks width    developed conformant planner t 
   

fipalacios   geffner

based translations  shown planner exhibits good performance
comparison existing conformant planners  recently  explored use
ideas general setting contingent planning  albore  palacios    geffner 
      

acknowledgments
thank alex albore help syntax mbp kacmbp  pierre marquis
kindly answering question complexity deductive task  thank
anonymous reviewers useful comments  h  geffner partially supported grant
tin           c      

appendix a  proofs
p stands conformant planning problem p   hf  i  o  gi kt m  p    
hf         o    g  translation  propositions theorems body paper
appear appendix numbers  new lemmas propositions
numbers preceded letters b  for appendix b   conformant problem
p classical problems p s kt m  p   arise p assumed
consistent  consistency issues important  addressed detail
second part appendix shown p consistent  kt m  p   consistent
 appendix b   consistent classical problem p     standard progression lemma
applies  namely  literal l achieved applicable action sequence        a 
action sequence action iff a  achieves c rule   c l p    
b  achieves l negation l  literal l  body c   rule p  
form   c   l  see theorem b   below  
lemma a    let action sequence applicable p k   p   
achieves kl k   p    achieves l p  
proof  induction length   empty achieves kl k   p   
kl must     hence l must i  achieves l p  
likewise         achieves kl k   p   a  rule   kc kl
k   p    achieves kc k   p    b  achieves kl k   p  
rule   kc   kl k   p    achieves kl  k   p   l  c    
a  true  p must contain rule   c l  inductive hypothesis 
must achieve c p   therefore         must achieve l p   b  true 
inductive hypothesis  must achieve l p along l  literal l  body
c   rule   c   l  thus        must achieve l p too 
lemma a    action sequence applicable k   p    applicable p  
proof  empty  trivial  likewise         applicable k   p   
applicable k   p    thus inductive hypothesis  applicable p   since 
  applicable k   p    must achieve literals kl k   p   precondition
l a  lemma a    must achieve literals l preconditions
p   thus  sequence        applicable p  
   

ficompiling uncertainty away conformant planning problems

proposition   classical plan k   p    conformant plan p  
proof  direct lemma a   consider problem p   similar p new
dummy action ag whose preconditions goals g p   plan k   p   
  ag applicable k   p      lemma a      ag applicable p     implies
applicable p achieves g  thus  plan p  
proposition   action sequence classical plan k   p   iff conformant
plan p according   approximation semantics 
proof  let us say action sequence   a              applicable p   achieves
literal l p belief sequence b            bn   generated according   approximation
semantics preconditions actions ai true bi   goals
true bn   respectively  definition   approximation semantics  and
consistency p    applicable action sequence thus   achieves literal l p iff
empty l i        a    c l effect p     achieves
literal l  c  b      achieves l effects   c   l p       achieves l 
l  c     these  however  conditions achieves literal kl
k   p   sequence   achieving literal l p replaced sequence achieving
literal kl k   p    thus  action sequence applicable k   p  
  applicable p achieves literal kl k   p   iff   achieves literal l p  
applicable k   p   iff   applicable p   last part following first
using induction plan length 
definition a    action p   define action sequence
followed merges kt m  p   arbitrary order  similarly    a            ai
action sequence p   define action sequence   a            kt m  p   
lemma a    let action sequence applicable p applicable
valid translation kt m  p    achieves kl t kt m  p    achieves l
p s possible initial states satisfy t 
proof  empty   achieves kl t  definition kt m  p   since
   l  l must s  thus must achieve l p s 

likewise         empty tag    
    achieves kl t

kt m  p   iff a  achieves kc t kt m  p   rule   kc t kl t kt m  p   
b  achieves kl t  rule   kc    t kl t  achieves kl   t
kt m  p   l  c    merge actions delete positive literals kl t  
a  inductive hypothesis  achieves c p s possible initial state
satisfies t  hence        achieves l p s rule   c l must
p   b  inductive hypothesis  achieves l l  p s  l  body
rule   c   l p   thus        achieves l p s 
v
empty tag     third case must considered  merge action t  kl t 
    achieving kl k
kl may cause action sequence   
t m  p   



case  sequence   a  hence     must achieve kl t   nonempty  t  kt m  p    hence inductive hypothesis two cases
above  sequence   must achieve l p s possible initial state satisfies
   

fipalacios   geffner

t    yet  since merge valid  possible initial states must satisfy one
t    thus must achieve l p s possible initial states s  initial
states satisfy    
lemma a    applicable valid translation kt m  p    applicable p  
    applicable k
proof  empty  direct         a    
t m  p   

applicable kt m  p    achieving kl precondition l a  hence
inductive hypothesis  applicable p   lemma a    must achieve
l precondition l a  thus        applicable p  

theorem   translation kt m  p   sound provided merges valid
tags consistent 
proof  consider problem p   similar p new dummy action ag
whose preconditions goals g p   plan kt m  p   iff
    ag applicable kt m  p      lemma a   implies   ag applicable
p     means plan p  
lemma a    let action sequence applicable p applicable
ks   p    achieves l p s possible initial state s  achieves kl s
ks   p   
proof  empty achieves l p s  l s  since    l  kl s must
  thus achieves kl s ks   p   
likewise         achieves l p s a  rule   c l
achieves c p s  b  achieves l rule   c   l  achieves l 
ks   p   l  c    
a   inductive hypothesis  achieves kc s ks   p   and  rule   kc s
    achieves kl s  merges
kl s    must achieve kl s  thus    
delete positive literals kl t  
b   inductive hypothesis  achieves kl s kl   s ks   p   l 
body rule   c   l p   therefore   achieves kl s 
     
  
lemma a    applicable p   applicable ks   p   
proof  empty  trivial         applicable p   must
applicable p must achieve precondition l p s every possible initial
state s  s    inductive hypothesis  must applicable ks   p   
lemma a    v
must achieve literals kl s s    then  last
merge action effect ss  kl s kl must achieve kl   
therefore    applicable ks   p   
theorem   conformant plan p   classical plan   ks   p  
result dropping merge actions    
   

ficompiling uncertainty away conformant planning problems

proof  direct lemma a   consider problem p   similar p new
action ag whose preconditions goals g p   plan p   sequence   ag
applicable p     lemma a      ag applicable ks   p      thus
plan ks   p   
definition a    rel s  l  stands set literals l  relevant l p  
rel s  l     l    l  l  relevant l   
definition a    stands deductive closure i 
    l   i     l   
theorem a     let    t            tn   covering merge literal l valid translation kt m  p   problem p whose initial situation prime implicate form 
tag ti must possible initial state p rel s  l  ti  
proof  assume otherwise state satisfying makes true literal ls relevant
l ls   ti   take c disjunction literals ls
states satisfy i  obtain entails c  since prime implicate form 
means c contains tautology c  subsumed clause c   i  but  either case 
contradiction  literals c  c   relevant l  hence ti   ti
part covering merge m  must contain literal either c  c     hence c 
lemma a     let action sequence applicable p applicable covering translation kt m  p    then  achieves l p s possible
initial state tag rel s  l    achieves kl t
kt m  p   
proof  empty achieves l p s  l thus  rel s  l   since
rel s  l    l   thus kl t initial situation   kt m  p   
achieves kl t kt m  p    likewise         achieves l p s  a 
rule   c l p achieves c p s  b  achieves l p s
rule   c   l  achieves l  p s l  c     a  inductive
hypothesis  achieves kc t  support rule   kc t kl t kt m  p   
      merges cannot
  must achieve kl t kt m  p    must   
delete positive literal kl t  b  inductive hypothesis  achieves kl t 
cancellation rule   kc    t kl t arising rule   c   l p   must
     
achieve kl   t literal l  c     means   a  therefore    
must achieve kl t 
lemma a     let kt m  p   covering translation p   applicable p  
applicable kt m  p   
proof  empty  direct  else         applicable p   must
applicable p must achieve literal l p re a   therefore  inductive
hypothesis must applicable kt m  p    then  let    t            tn   covering
merge l p re a  kt m  p    theorem a     ti must
   

fipalacios   geffner

possible initial state rel s  l  ti   lemma a     achieving l
p s implies achieving kl ti kt m  p    since true ti achieves
l p re a  p s possible initial states s  follows achieves kl ti
ti kt m  p    therefore achieves kl kt mv p   ends
sequence merges include action merge am l effect ti kl ti kl 
    applicable k
result    
t m  p   
theorem    covering translations kt m  p   complete  i e   conformant plan
p   classical plan   kt m  p     merge actions
removed 
proof  theorem follows trivially lemma a    problem p  
p additional  dummy action ag goals g p preconditions
ag   action sequence plan p iff action sequence   ag applicable p    
due lemma a    implies action sequence   ag applicable kt m  p    
turn true iff action sequence plan kt m  p    sequence  
turn  sequence merge actions removed 
theorem    translation kmodels p   sound complete 
proof  direct merges generated kmodels precondition goal
literals l  clearly merges valid  tags consistent i 
cover l  the models ci  l  satisfy ci  l    thus result follows theorems  
   
proposition    width w p   p determined time exponential
w p   
proof  number clauses ci  l   mi sets clauses c
ci  l   c    i  clause one set must n literals  n
number fluents p   hence  one literal clause c collected  end
ni sets literals size greater i  inconsistent
consistent minimal  no consistent set collection
properly included   tests polynomial given prime implicate form 
thus constructing cover c c  set clauses c  c    exponential i 
checking whether one cover satisfies ci  l  polynomial operation provided
prime implicate form  indeed  c c     t            tn    computing closures
ti ti c c   pi  testing whether ti intersects clause
ci  l  polynomial operations  the former reducing checking literal l 
whether    ti l     thus computing width l   generate sets c clauses
ci  l   c    i  starting      increasing one one one set 
c c  satisfies ci  l   computation exponential w l   computation
preconditions goal literals p exponential w p   
proposition    width p   w p   n  n number
fluents whose value initial situation known 
   

ficompiling uncertainty away conformant planning problems

proof  inequality   w p   direct w l  defined size  c  minimal set
clauses c ci  l  c c  satisfies ci  l   w p     w l  precondition
goal literal l  inequality w p   n follows noticing set c clauses
given tautologies l  l  ci  l   c c  must satisfy clause c ci  l  
c c  must assign truth value literal c  inconsistent c 
inconsistent thus pruned c c   finally  max number tautologies
ci  l  number fluents l  neither l  l  unit clauses i 
theorem    fixed i  translation ki  p   sound  polynomial  w p   i 
covering complete 
proof  soundness  need prove merges ki  p   valid
tags ki  p   consistent  soundness follows theorem    merges
literal l ki  p   given covers c c  collections c less clauses
ci  l  clearly since
model must satisfy ci  l   must satisfy
w
c c     tm   c c   time  definition
cover c c   tags must consistent i 
proving ki polynomial fixed i  follow ideas similar ones used
proof proposition    above  shown width p
determined time exponential w p   polynomial number clauses
fluents p   fixed i  number sets clauses c ci  l  size  c 
polynomial  complexity computing covers c c  sets  hence 
merges l ki  p   polynomial too  thus  whole translation ki  p   fixed
polynomial number clauses  fluents  rules p  
finally  proving completeness  w p   i  w l  precondition
goal literal l p   therefore  literal l  set c clauses ci  l 
c c  satisfies ci  l   translation ki  p   generate unique merge
l covers l  since ki  p   valid translation  means ki  p   covering
translation  complete  virtue theorem    
lemma a     l  relevant l rel s  l  rel s    l   rel s  l    rel s    l    
proof  l   rel s  l     l   relevant l    since l  relevant l
relevance relation transitive  l   relevant l  thus  l   rel s  l  therefore 
since rel s  l  rel s    l   l   rel s    l   l   s  since relevant
l    l   rel s    l    
proposition    let s  two states let action sequence applicable
classical problems p s p s    achieves literal l p s  rel s    l 
rel s  l   achieves literal l p s 
proof  induction length   empty  achieves literal l p s    l
must s    since l relevant itself  l rel s    l   rel s    l  rel s  l  
l must s  thus achieves l p s 
   

fipalacios   geffner

likewise         achieves l p s  a  rule   c l
achieves c p s    b  achieves l p s  rule   c   l  achieves
l  p s  l  c    
a  must achieve literal li c p s    since li relevant l rel s    l 
rel s  l   lemma a     rel s    li   rel s  li    then  inductive hypothesis  plan
must achieve li p s li c  thus        must achieve l p s
b  since l  relevant l  as l  relevant l   rel s    l 
rel s  l   lemma a     rel s    l    rel s  l     thus inductive hypothesis 
must achieve l  p s l         must achieve l p s 
lemma a       two collection states every state
every precondition goal literal l p   state s    rel s    l 
rel s  l   applicable p s     applicable p s 
proof  induction length   empty  obvious         applicable
p s     applicable p s   and  inductive hypothesis  applicable p s 
need prove achieves preconditions action p s 
l p rec a  s  hypothesis  state s   
rel s    l  rel s  l   proposition     since achieves l p s    must
achieve l p s  since argument applies s  achieves l p s  thus
       must applicable p s 
proposition      two collections states every state
every precondition goal literal l p   state s    rel s    l 
rel s  l   plan p conforms     plan p conforms
s 
proof  lemma a     consider problem p   similar p new action
ag whose preconditions goals g p   plan p conforms    
action sequence   ag applicable p    s     lemma    ag
applicable p    s  thus must plan p s
proposition      basis p every possible initial state p every
precondition goal literal l p     contains state s  rel s    l  rel s  l  
proof  direct proposition     considering set possible initial states
p  
proposition    initial situation prime implicate form    t            tn  
merge covers literal l p   set s ti   l  possible initial states p
rel s  l  ti non empty 
proof  direct theorem a    
theorem    let kt m  p   covering translation let   stand collection
states s ti   l  l precondition goal literal p ti tag merge
covers l    basis p  
   

ficompiling uncertainty away conformant planning problems

proof  show every possible initial state precondition goal literal
l    theorem contains state s  rel s    l  rel s  l   result
follows proposition     indeed  state must satisfy tag ti covering
merge    t            tn   l  merges valid  theorem a     must
possible initial state s  rel s    l  ti   therefore  rel s    l  rel s  l 
must satisfy ti possibly literals l  relevant l 
theorem    p conformant planning problem bounded width  p admits
basis polynomial size 
proof  w p   fixed i  ki  p   covering translation polynomial number
merges tags  case  basis   p defined theorem    contains
polynomial number states  regardless number possible initial states 

appendix b  consistency
assuming throughout paper conformant planning problems p
translations kt m  p   consistent  section make notion precise 
explain needed  prove kt m  p   consistent p is  proof 
take account heads kl merge actions am l kt m  p    extended
literals kl  literals l  mutex l p  see definition    
start beginning assuming states truth assignments sets
literals fluents language  state complete every literal l  l l
s  consistent literal l l s  complete consistent
states represent truth assignments fluents f consistency p
translation kt m  p   ensures applicable action sequences map complete
consistent states complete consistent states s    guaranteed  complete
consistent states referred simply states done
paper 
given complete state action applicable s  next state sa
sa    s   del a  s   add a  s 

add a  s     l     c l p c s 

del a  s     l   l add a  s    
follows sa complete state complete state  action
deletes literal l l added s  hand  may consistent
sa inconsistent  example  rules   c l   c   l
c c   s  order exclude possibility  ensuring reachable
states complete consistent  thus represent genuine truth assignments
fluents f   consistency condition p needed 
definition b    consistency   classical conformant problem p   hf  i  o  gi consistent initial situation logically consistent every pair complementary
literals l l mutex p  
   

fipalacios   geffner

consistent classical problem p   reachable states complete consistent 
standard progression lemma used preceding proofs holds 
theorem b    progression   action sequence        applicable complete
consistent state achieves literal l consistent classical problem p iff a  achieves
body c rule   c l p   b  achieves l every rule   c   l 
achieves l  literal l  c    
see conformant problem p consistent sense 
valid translation kt m  p    tested benchmarks considered paper
consistency found consistent except two domains
introduced elsewhere    dispose look and grab  cases  since consistency
classical problem kt m  p   cannot inferred consistency p  
checked explicitly using definition b    similarly  plans obtained
kt m  p   checked consistency indicated section    soundness
plans ensured provided never trigger conflicting effects kl t kl t   
proof  proof theorem b   rest particular definition mutexes 
mutex atoms true reachable state  consistent problem p  
applicable action sequence maps complete consistent state s  represents
truth assignment  then  action sequence        achieves l iff c  l add a  s   
d  l s  l   del a  s     condition theorem  however  equivalent c 
condition b theorem  equivalent d  indeed  l   del a  s    iff rule
  c   l literal l  c   l    s    which  given s  complete
consistent  true iff l  s   this precisely consistency needed  else l  s 
would imply l    s    
notion mutex used definition consistency expresses guarantee
pair literals true reachable state  sufficient polynomial conditions
mutual exclusivity type invariants defined various papers 
follow definition bonet geffner        
definition b    mutex set   mutex set collection r unordered literals pairs
 l  l    classical conformant problem p that 
   pair  l  l    r  l l  possible initial state s 
     c l   c   l  two rules action  l  l    pair
r  p re a  c c   mutex r 
     c l rule p literal l pair  l  l    r  either a  l    l 
b  p re a  c mutex l  r  c  p re a  c implies c   r rule
  c   l  p  
    consistency two domains    dispose look and grab  established however
definition mutexes slightly stronger one used  actually suffices change
expression p re a  c clause  c  definition mutex sets p re a  c  l    

   

ficompiling uncertainty away conformant planning problems

definition  pair said mutex r belongs r  set literals
said mutex r contains pair r  set literals said imply set
literals   r mutex r complement l literal l     s 
easy verify r  r  mutex sets  union r  r  mutex set 
thus maximal mutex set p denote r   pairs r
called mutexes 
simplicity without loss generality  assume preconditions p re a 
empty  indeed  simple show mutexes problem p remain
preconditions pushed conditions  assume condition c rule
c l p mutex  rules simply pruned  addition  assume
literal l mutex pair complementary literals l  l    l cannot
true reachable state  thus  pruned well 
definition mutexes sound  meaning pair mutex set true
reachable state 
theorem b     l  l    pair mutex set r classical conformant problem
p   reachable state p    l  l    s 
proof  proceed inductively  clearly  l l  cannot part possible initial state 
ruled definition mutex sets  thus  let us assume inductive hypothesis
l l  part state reachable less steps  let us prove
true states s    sa reachable one step  clearly
l l  belong s    either a  l l  belong add a  s   b  l belongs
add a  s  l  belongs del a  s   show possible 
a  p must comprise rules   c l   c   l  c c   s  yet
definition mutex sets  c c   must mutex  inductive hypothesis
c c     s  b  must rule   c l c s  l 
inductive hypothesis  follows l  mutex c r  thus 
mutex set definition  either l    l c implies c   rule   c   l   
first case  however  due rule   c l c s  l  del a  s  
second case  completeness reachable states  must c   s  hence
l  del a  s   contradicting b cases 
provided initial situation conformant planning problem p prime
implicate form  computing largest mutex set r testing consistency p
polynomial time operations  former  one starts set literal pairs
iteratively drops set pairs comply definition
reaching fixed point  bonet   geffner        
move prove conformant problem p consistent  valid
translation kt m  p    consistency classical problems p s possible initial
states direct  set mutexes p subset set mutexes p s
initial situation constrained 
proposition b    mutex set rt    valid translation kt m  p   consistent conformant problem p   define rt set  unordered  literals pairs  kl t  kl   t   
 kl t  kl   t   l  l    mutex p   t  two tags jointly satisfiable
 i      t t      rt mutex set kt m  p   
   

fipalacios   geffner

follows kt m  p   consistent p consistent  l    l
mutex l p    kl t  kl t  must mutex rt  
theorem b    consistency kt m  p     valid translation kt m  p   consistent p
consistent 
consistency translation k   p   follows special case  k   p   kt m  p  
empty set merges set tags containing empty tag 
left prove proposition b   
proof proposition b    must show set rt comprised pairs  kl t  kl   t   
 kl t  kl   t  l  mutex l p   tags t  jointly satisfiable
i  set complies clauses         definition b    go one clause
time 
   pair rt true initially kt m  p     hf         o    g  jointly satisfiable
i  t  t    indeed  kl t kl   t    must possible initial
state satisfying t  l l  true contradiction l l 
mutex p   similarly  kl t   kl   t not  must case
   l     l    must possible initial state p
t  l  l  hold  contradiction l l  mutex p too 
   action rules kl t kl   t  rules must support
rules form   kc t kl t   kc    t  kl   t  arising rules
  c l   c   l  p     since l l  mutex p   c c  
must contain literals l  c l  c    l    l    mutex p  
hence  kl   t  kl   t    belongs rt   kc t kc    t  mutex rt
well 
similarly  action rules kl t kl   t literal l 
mutex l p   rules must support cancellation rules form
  kc t kl t   kc    t kl   t  arising rules   c l
  c   l  p   since l l  mutex p   c c   must contain literals
l  c l  c   mutex p   hence rt must contain pair
 kl   t  kl   t   kc t kc    t must mutex rt  
   left show set rt given pairs  kl t  kl   t     kl t 
kl   t  complies clause   definition mutex sets well  consider
first class pairs  kl t  kl   t    rule   kc t kl t kl t arising
rule   c l p   since l mutex l  p   one conditions  a 
 b   c must hold rule   c l l     a  l    l  kc t
must imply body kc t  cancellation rule   kc t  kl t   
literal l  c  rt must contain pair  kl   t  kl   t    kl   t
implies kl   t    kc t implies kc t   case  c    b  c l 
    action cannot merge literal l   mutex l l    case  l   implies
l l  mutex  similarly  cannot merge l case  l mutex
l  l    reason  cannot merge l  either  thus  action
cannot merge must action p  

   

ficompiling uncertainty away conformant planning problems

mutex p   thus c contains literal l  mutex l  p   means
pair  kl   t  kl   t    rt hence kc t mutex kl   t  rt
 case  b   last   c  c implies c   p rule   c   l    kc t must
imply body kc    t  cancellation rule   kc    t  kl   t    indeed 
literal l  c c     kl   t implies kl   t   
l  literal c   c  literal l  c must mutex
l  p   hence pair  kl   t  kl   t    must rt kl   t implies
kl   t   case  c 
   
consider
v pair  kl t  kl  t   along merge action am l
rule ti kl ti kl kl t   kl  thus empty tag   case  since
merge valid t  consistent  must ti ti
t  jointly consistent i  follows  kl ti   kl   t    pair rt
thus body merge mutex kl   t  rt  case  b  

need consider pair  kl t  kl   t    along rules kl   t   
literals kl t kl   t  structure  thus argument
applies  replacing t  l l   
switch second class pairs  kl t  k l   t  rules  
kc t kl t kl t  since l l  mutex p   conditions  a   b 
 c must hold  a  l    l  case  condition  c holds kt m  p  
kc t implies body kc t rule   kc t kl   l    l   b  c
mutex l    thus literal l  c l  l  mutex
p   therefore kc t kl   t mutex rt  case  b   finally  c  c
implies c   rule   c   l  p   kc t must imply kc    t rt
rule   kc    t kl   t  case  c  
empty tag t  rule kl t may merge  due extra
effects kl  merge action l  merge kl merge kl   
case  c holds 
last  class pairs  rules kl   t cancellation rules
form   kc     t kl   t rule   c    l  p   since l  mutex
l p   conditions  a   b   c must hold rule   c    l  l  p  
a  l   l    cancellation rule   kc     t kl  case  c  
b  c    mutex l  thus literal l  c     l    l  mutex
p   therefore kl t implies kl   t rt   hence kl   t kc     t
imply kl t rt  case  b   finally  c  c    implies c   rule   c   l p  
kc     t must imply kc    t rule   kc    t kl t rt  
indeed  la implies lb p   lb implies la p   klb  t implies kla  t
rt   kla  t implies klb  t 

references
albore  a   palacios  h     geffner  h          translation based approach contingent
planning  proc    st int  joint conference ai  ijcai      pp           
   

fipalacios   geffner

baral  c   kreinovich  v     trejo  r          computational complexity planning
approximate planning presence incompleteness  artificial intelligence                   
baral  c     son  t  c          approximate reasoning actions presence sensing
incomplete information  proc  ilps       pp         
bayardo jr   r     schrag  r          using csp look back techniques solve real world
sat instances  proc  aaai  pp         
bertoli  p     cimatti  a          improving heuristics planning search belief space 
ghallab  m   hertzberg  j     traverso  p   eds    proc  aips       pp         
aaai press 
bonet  b     geffner  h          planning heuristic search  new results  proceedings
ecp     pp          springer 
bonet  b     geffner  h          planning incomplete information heuristic search
belief space  proc  aips       pp        aaai press 
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
bonet  b     givan  b          results conformant track  th int  planning
competition  http   www ldc usb ve bonet ipc  docs results conformant pdf 
bryce  d     buffet  o          international planning competition uncertainty part  benchmarks results  http   ippc      loria fr wiki images      results pdf 
bryce  d   kambhampati  s     smith  d  e          planning graph heuristics belief
space search  journal artificial intelligence research           
cimatti  a   roveri  m     bertoli  p          conformant planning via symbolic model
checking heuristic search  artificial intelligence              
dechter  r          constraint processing  morgan kaufmann 
goldman  r  p     boddy  m  s          expressive planning explicit knowledge 
proc  aips       pp         
haslum  p     jonsson  p          results complexity planning incomplete information  proc  ecp     lect  notes ai vol       pp         
springer 
hoffmann  j     brafman  r          contingent planning via heuristic forward search
implicit belief states  proc    th int  conf  automated planning scheduling
 icaps        pp        aaai 
hoffmann  j     brafman  r          conformant planning via heuristic forward search 
new approach  artificial intelligence                    
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research             
marquis  p          consequence finding algorithms  gabbay  d     smets  p   eds   
handbook defeasible reasoning uncertainty management systems  vol     pp 
       kluwer 
   

ficompiling uncertainty away conformant planning problems

palacios  h     geffner  h          compiling uncertainty away  solving conformant planning problems using classical planner  sometimes   proc  aaai     pp         
palacios  h     geffner  h          conformant classical planning  efficient translations may complete too  proc  icaps     pp         
petrick  r     bacchus  f          knowledge based approach planning incomplete
information sensing  proc  aips     pp         
rintanen  j          complexity planning partial observability  proc  icaps      pp         
smith  d     weld  d          conformant graphplan  proceedings aaai     pp     
     aaai press 
son  t  c   tu  p  h   gelfond  m     morales  a          conformant planning domains
constraints  new approach  proc  aaai     pp           
son  t  c     tu  p  h          completeness approximation based reasoning
planning action theories incomplete information   proc    th int  conf 
principles kr reasoning  kr      pp         
tison  p          generalized consensus theory applications minimization
boolean circuits  ieee transactions computers  ec                
tran  d   nguyen  h   pontelli  e     son  t  c          cpa c   h   two approximationbased conformant planners  http   ippc      loria fr wiki images      team cpa pdf 
tran  d   nguyen  h   pontelli  e     son  t  c          improving performance conformant planners  static analysis declarative planning domain specifications  practical aspects declarative languages    th international symposium  padl      proceedings  vol       lecture notes computer science  pp          springer 
turner  h          polynomial length planning spans polynomial hierarchy  jelia
    proc  european conference logics ai  pp          springer verlag 

   


