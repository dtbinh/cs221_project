journal of artificial intelligence research                  

submitted        published      

compiling uncertainty away in conformant planning
problems with bounded width
hector palacios

hlp ldc usb ve

universitat pompeu fabra
roc boronat     
      barcelona  spain

hector geffner

hector geffner upf edu

icrea   universitat pompeu fabra
roc boronat     
      barcelona  spain

abstract
conformant planning is the problem of finding a sequence of actions for achieving a goal
in the presence of uncertainty in the initial state or action effects  the problem has been
approached as a path finding problem in belief space where good belief representations and
heuristics are critical for scaling up  in this work  a different formulation is introduced for
conformant problems with deterministic actions where they are automatically converted
into classical ones and solved by an off the shelf classical planner  the translation maps
literals l and sets of assumptions t about the initial situation  into new literals kl t that
represent that l must be true if t is initially true  we lay out a general translation scheme
that is sound and establish the conditions under which the translation is also complete  we
show that the complexity of the complete translation is exponential in a parameter of the
problem called the conformant width  which for most benchmarks is bounded  the planner
based on this translation exhibits good performance in comparison with existing planners 
and is the basis for t    the best performing planner in the conformant track of the     
international planning competition 

   introduction
conformant planning is a form of planning where a goal is to be achieved when the initial
situation is not fully known and actions may have non deterministic effects  goldman  
boddy        smith   weld         conformant planning is computationally harder than
classical planning  as even under polynomial restrictions on plan length  plan verification
remains hard  haslum   jonsson        baral  kreinovich    trejo        turner       
rintanen         while few practical problems are purely conformant  the ability to find
conformant plans is needed in contingent planning where conformant situations are a special
case and where relaxations into conformant planning yield useful heuristics  hoffmann  
brafman        
the problem of conformant planning can be formulated as a path finding problem in
belief space where a sequence of actions that map a given initial belief state into a target
belief is sought  bonet   geffner         a belief state represents the set of states that
are deemed possible  and actions  whether deterministic or not  map one belief state into
c
    
ai access foundation  all rights reserved 

fipalacios   geffner

another  this formulation  that underlies most current conformant planners  hoffmann  
brafman        bryce  kambhampati    smith        cimatti  roveri    bertoli       
must address two problems  the problem of representing beliefs in a compact way  and the
problem of obtaining effective heuristics over beliefs  the first problem has been approached
through logical representations that make use of sat or obdd technology  that while
intractable in the worst case  scale up better than plain state representations  the second
problem  on the other hand  has been more complex  with heuristics for searching in belief
space not being as successful so far as the heuristics developed for classical planning  bonet
  geffner        hoffmann   nebel        
in this work  we introduce a different approach to conformant planning where problems
are automatically compiled into classical problems and solved by a classical planner  the
translation maps sets of literals t about the initial situation and literals l into new literals
kl t that express that if t is true in the initial situation  l must be true  we lay out first a
general translation scheme that is sound and then establish the conditions under which the
translation is also complete  also  we show that the complexity of the complete translation
is exponential in a parameter of the problem that we call the conformant width  which
for most benchmark domains is bounded  implying that the complete translation in those
cases is polynomial  the planner based on this translation exhibits good performance in
comparison with existing conformant planners and is the basis for t    the best performing
planner in the conformant track of the      international planning competition 
the translation based approach provides a solution to the two problems faced by conformant planners that search in belief space  the belief representation and the heuristic over
beliefs  in the translation based approach  the beliefs are represented by the literals kl t
that stand for conditionals  a representation that is polynomial and complete for conformant problems with bounded width  in addition  and since belief states are represented as
plain states  the heuristic over beliefs is a classical heuristic  from a computational point
of view  though  there is no explicit search in belief space  conformant problems p are
converted into classical problems k p   at the knowledge level  petrick   bacchus        
whose solutions  computed by a classical planner  encode the conformant solutions for p  
our formulation is limited to conformant problems that are deterministic and where
all uncertainty lies in the initial situation  we address nonetheless the issues that must be
handled in order to generalize the translation based approach to non deterministic domains
and report empirical results over non deterministic domains as well 
the paper is organized as follows  we define first the syntax and semantics of conformant
planning problems p  section     and consider a simple sound but incomplete translation
k   section     we then consider a more general translation scheme kt m where t and
m are two parameters  a set of tags t encoding assumptions about the initial situation 
and a set of merges m encoding valid disjunctions of tags  section     and analyze several
instances of this scheme that follow from particular choices of the sets of tags and merges 
a complete but exponential translation ks  where tags are associated with the possible
initial states of the problem  section     and a polynomial translation ki for a fixed integer
i    that is complete for problems with conformant width bounded by i  section    
we provide then an alternative explanation for this compact but complete translation by
showing that in problems with bounded width  the exponential number of possible initial
states s  includes always a polynomial number of critical initial states s   such that plans
   

ficompiling uncertainty away in conformant planning problems

that conform with s   conform also with s   section     we finally present the conformant
planner t   section     an empirical evaluation of the planner  section     an extension to
non deterministic actions  section      and a discussion of related work  section      this
is followed by a brief summary  section     and the formal proofs  appendix  
this work is a revision and extension of the formulation presented by palacios and
geffner         which in turn is based on ideas first sketched also by palacios and geffner
       

   the conformant problem p
we define next the syntax and semantics of the conformant planning problems considered 
    syntax
conformant planning problems p are represented as tuples of the form p   hf  i  o  gi
where f stands for the fluent symbols in the problem  i is a set of clauses over f defining
the initial situation  o stands for a set of  ground  operators or actions a  and g is a set of
literals over f defining the goal  every action a has a precondition p re a  given by a set
of fluent literals  and a set of conditional effects c  l where c is a set of fluent literals
and l is a fluent literal 
all actions are assumed to be deterministic and hence all uncertainty lies in the initial
situation  thus  the language for the conformant problem p excluding the uncertainty in
the initial situation  is strips extended with conditional effects and negation  moreover  if
there is no uncertainty in the initial situation  as when all fluents appear in unit clauses in
i  p is equivalent to a classical planning problem 
we refer to the conditional effects c  l of an action a as the rules associated with
a  and sometimes write them as a   c  l  when convenient  we also join several effects
associated with the same action and condition as in a   c  l  l  and write c  l as
true  l when c is empty  finally  for a literal l  l denotes the complement of l 
    semantics
a state s is a truth assignment over the fluents f in p   hf  i  o  gi and a possible initial
state s of p is a state that satisfies the clauses in i 
for a state s  we write i s  to refer to the set of atoms  positive literals  that are true
in s  and write p s to refer to the classical planning problem p s   hf  i s   o  gi which
is like the conformant problem p except for the initial state that is fixed to s 
an action sequence     a    a            an   is a classical plan for p s if the action sequence
 is executable in the state s and results in a goal state sg   i e   if for i              n  the
preconditions of the action ai are true in si   si   is the state that results from doing action
ai in the state si   and all goal literals are true in sn    
finally  an action sequence  is a conformant plan for p iff  is a classical plan for p s
for every possible initial state s of p  
conformant planning is computationally harder than classical planning  as plan verification remains hard even under polynomial restrictions on plan length  haslum   jonsson 
      baral et al         turner        rintanen         the most common approach to
   

fipalacios   geffner

conformant planning is based on the belief state formulation  bonet   geffner         a
belief state b is the non empty set of states that are deemed possible in a given situation 
and every action a executable in b  maps b into a new belief state ba   the conformant
planning task becomes a path finding problem in a graph where the nodes are belief states
b  the source node b  is the belief state corresponding to the initial situation  and the target
belief states bg are those where the goals are true 
we assume throughout that i is logically consistent  so that the set of possible initial
states is not empty  and that p itself is consistent  so that the bodies c and c   of conflicting
effects a   c  l and a   c    l associated with the same action a are mutually exclusive
or mutex  for further details on this  see part b of the appendix 

   a basic translation k 
a simple translation of the conformant problem p into a classical problem k p   can be
obtained by replacing the literals l by literals kl and kl aimed at capturing whether
l is known to be true and known to be false respectively 
definition    translation k     for a conformant planning problem p   hf  i  o  gi  the
translation k   p     hf     i     o    g  i is a classical planning problem with
 f      kl  kl   l  f  
 i      kl   l is a unit clause in i 
 g     kl   l  g 
 o    o but with each precondition l for a  o replaced by kl  and each conditional
effect a   c  l replaced by a   kc  kl and a   kc  kl 
where the expressions kc and kc for c   l    l        are abbreviations of the formulas
kl    kl        and kl    kl        respectively 
the intuition behind the translation is simple  first  the literal kl is true in the initial
state i   if l is known to be true in i  otherwise it is false  this removes all uncertainty
from k   p    making it into a classical planning problem  in addition  for soundness  each
rule a   c  l in p is mapped into two rules  a support rule a   kc  kl  that ensures
that l is known to be true when the condition is known to be true  and a cancellation
rule a   kc  kl that guarantees that kl is deleted  prevented to persist  when
action a is applied and c is not known to be false  the use of support and cancellation rules
for encoding the original rules at the knowledge level is the only subtlety in the translation 
the translation k   p   is sound as every classical plan that solves k   p   is a conformant
plan for p   but is incomplete  as not all conformant plans for p are classical plans for k p   
the meaning of the kl literals follows a similar pattern  if a plan achieves kl in k   p   
then the same plan achieves l with certainty in p   yet a plan may achieve l with certainty
in p without making the literal kl true in k   p    
proposition    soundness of k   p     if  is a classical plan for k   p    then  is a
conformant plan for p  
   formal proofs can be found in the appendix 

   

ficompiling uncertainty away in conformant planning problems

as an illustration  consider the conformant problem p   hf  i  o  gi with f    p  q  r  
i    q   g    p  r   and actions o    a  b  with effects
a   q  r   a   p  p   b   q  p  
for this problem  the action sequence     a  b  is a conformant plan for p while the action
sequence       a  is not  indeed   is a classical plan for p s for any possible initial state
s  while    is not a classical plan for the possible initial state s  where p is true  recall that
s is a possible initial state of p if s satisfies i so that neither p nor r are assumed to be
initially false in this problem  
from definition    the translation k   p     hf     i     o    g  i is a classical planning problem
with fluents f      kp  kp  kq  kq  kr  kr   initial situation i      kq   goals g   
 kp  kr   and actions o     a  b  with effects
a   kq  kr   a   kp  kp   b   kq  kp 
that encode supports  and effects
a   kq  kr   a   kp  kp   b   kq  kp 
that encode cancellations 
proposition   implies  for example  that       a   which is not a conformant plan for
p   cannot be a classical plan for k p   either  this is easy to verify  as while the support
a   kq  kr achieves the goal kr as kq is true in i     the cancellation a   kp  kp
associated with the same action  preserves kp false for the other goal p 
while the translation k  is not complete  meaning that it fails to capture all conformant plans for p as classical plans  its completeness can be assessed in terms of a weaker
semantics  in the so called   approximation semantics  baral   son         belief states b
are represented by   valued states where fluents can be true  false  or unknown  in this incomplete belief representation  checking whether an action a is applicable in a belief state b 
computing the next belief state ba   and verifying polynomial length plans are all polynomial
time operations  in particular  a literal l is true it the next belief state ba iff a  action a
has some effect c  l such that all literals in c are true in b  or b  l is true in b and for all
effects c    l of action a  the complement of some literal l   c   is true in b  an action
sequence  is then a conformant plan for p according to the   approximation semantics if
the belief sequence generated by  according to the   approximation semantics makes the
action sequence applicable and terminates in a belief state where the goals are true  it is
possible to prove then that 
proposition    k   p   and   approximation   an action sequence  is a classical plan for
k   p   iff  is a conformant plan for p according to the   approximation semantics 
this correspondence is not surprising though as both the   approximation semantics
and the k   p   translation throw away the disjunctive information and restrict the plans to
those that make no use of the uncertain knowledge  indeed  the states s    s          generated
by the action sequence     a    a           over the classical problem k   p   encode precisely
   

fipalacios   geffner

the literals that are known to be true according to the   approximation  namely  l is true
at time i according to the   approximation iff the literal kl is true in the state si  
proposition   does not mean that the basic translation k  and the   approximation
semantics are equivalent but rather that they both rely on equivalent belief representations 
the translation k  delivers also a way to get valid conformant plans using a classical
planner  the translation based approach thus addresses both the representational and the
heuristic issues that arise in conformant planning 
as an illustration of proposition    given a conformant problem p with i    p  r  and
actions a and b with effects a   p  q  a   r  v  and b   q  v  the plan     a  b  is valid
for achieving the goal g    q  v  according to both k   p   and the   approximation  while
the plan     b  is not valid according to either  at the same time  if the initial situation
is changed to i    p  q   neither approach sanctions the plan     a  for g    q   even if
it is a valid conformant plan  for this  some ability to reason with disjunctions is needed 
an extension of the basic translation k  that allows a limited form of disjunctive reasoning is presented by palacios and geffner         the extension is based on the introduction
of new literals l xi used for encoding the conditionals xi  l  below  the basic translation
k  is extended in a different manner that ensures both tractability and completeness over
a large class of problems 

   general translation scheme kt m
the basic translation k  is extended now into a general translation scheme kt m where t
and m are two parameters  a set of tags t and a set of merges m  we will show that for
suitable choices of these two parameters  the translation kt m   unlike the translation k   
can be both sound and complete 
a tag t  t is a set  conjunction  of literals l from p whose truth value in the initial
situation is not known  the tags t are used to introduce a new class of literals kl t in
the classical problem kt m  p   that represent the conditional if t is true initially  then l is
true  an assertion that could be written as k t   l  in a temporal modal logic  we use
the notation kl t rather than l t as used by palacios and geffner         because there
is a distinction between kl t and kl t  roughly kl t means that the conditional
k t   l  is not true  while kl t means that the conditional k t   l  is true 
likewise  a merge m is a non empty
w collection of tags t in t that stands for the disjunctive normal form  dnf  formula tm t  a merge m is valid when one of the tags t  m
must be true in i  i e   when
 
i   
t  
tm

a merge m for a literal l in p will translate into a merge action with a single effect
 
kl t  kl
tm

that captures a simple form of reasoning by cases 
while a valid merge can be used for reasoning about any literal l in p   computationally
it is convenient  although not logically necessary  to specify that certain merges are to be
used with some literals l and not with others  thus  formally  m is a collection of pairs
   

ficompiling uncertainty away in conformant planning problems

 m  l   where m is a merge and l is a literal in p   such a pair means that m is a merge for
l  we group all the merges m for a literal l in the set ml   and thus  m can be understood
as the collection of such sets ml for all l in p   for simplicity  however  except when it
may cause a confusion  we will keep referring to m as a plain set of merges 
we assume that the collection of tags t always includes a tag t that stands for the
empty collection of literals  that we call the empty tag and denote it as   if t is the empty
tag  we denote kl t simply as kl 
the translation kt m  p   is the basic translation k   p   conditioned with the tags t in
t and extended with the actions that capture the merges in m  
definition    translation kt m    let p   hf  i  o  gi be a conformant problem  then
kt m  p   is the classical planning problem kt m  p     hf     i     o    g  i with
 f      kl t  kl t   l  f and t  t  
 i      kl t   i  t    l 
 g     kl   l  g 
 o     a v
  kc t  kl t  a   kc t  kl t   a   c  l in p   
 am l     tm kl t   kl  xl   l  p  m  ml  
where kl is a precondition of action a in kt m  p   if l is a precondition of a in p   kc t
and kc t stand for kl   t  kl   t 
v         and kl   t  kl   t        respectively  when
c   l    l           and xl stands for l  kl  with l  ranging over the literals l  mutex
with l in p  
the translation kt m  p   reduces to the basic translation
k   p   when m is empty and
v
t contains only the empty tag  the extra effects xl   l  kl  in the merge actions am l
are needed only to ensure that the translation kt m  p   is consistent when p is consistent 
and otherwise can be ignored  indeed  if l and l  are mutex in a consistent p   the invariant
kl t  kl   t holds in kt m  p   for non empty tags t  and hence a successful merge for
l can always be followed by a successful merge for l    in the rest of the paper we will
thus assume that both p and kt m  p   are consistent  and ignore such extra merge effects 
but we will come back to them in appendix b for proving the consistency of kt m  p   from
the consistency of p  
for suitable choices of t and m   the translation kt m  p   will be sound and complete 
before establishing these results  however  let us make these notions precise 
definition    soundness   a translation kt m  p   is sound if for any classical plan  that
solves the classical planning problem kt m  p    the plan    that results from  by dropping
the merge actions is a conformant plan for p  
definition    completeness   a translation kt m  p   is complete if for any conformant
plan    that solves the conformant problem p   there is a classical plan  that solves the
classical problem kt m  p   such that    is equal to  with the merge actions removed 
the general translation scheme kt m is sound provided that all merges are valid and
all tags are consistent  literals in a tag are all true in some possible initial state  
   

fipalacios   geffner

theorem    soundness kt m  p     the translation kt m  p   is sound provided that all
merges in m are valid and all tags in t are consistent 
unless stated otherwise  we will assume that all merges are valid and all tags consistent 
and will call such translations  valid translations 
as a convention for keeping the notation simple  in singleton tags like t    p   the curly
brackets are often dropped  thus  literals kl t for t    p  are written as kl p  while
merges m    t    t    for singleton tags t     p  and t     q   are written as m    p  q  
example  as an illustration  consider the problem of moving an object from an origin to a
destination using two actions  pick l   that picks up an object from a location if the hand is
empty and the object is in that location  and drop l   that drops the object at a location if
the object is being held  for making the problem more interesting  let us also assume that
the action pick l  drops the object being held at l if the hand is not empty  these are all
conditional effects and there are no action preconditions  assuming that there is a single
object  these effects can be written as 
pick l    hold  at l   hold  at l 
pick l    hold  hold  at l 
drop l    hold  hold  at l   
consider now an instance p of this domain  where the hand is initially empty and the
object  initially at either l  or l    must be moved to l    i e   p   hf  i  o  gi with
i    hold   at l     at l      at l     at l      at l    
and
g    at l      
the action sequence
     pick l     drop l     pick l     drop l    
is a conformant plan for this problem  where an attempt to pick up the object at location
l  is followed by a drop at the target location l    ensuring that the object ends up at l  if
it was originally at l    this is then followed by an attempt to pick up the object at l  and
a drop at l   
on the other hand  the action sequence   that results from   by removing the first
drop action
     pick l     pick l     drop l    
is not a conformant plan  since if the object was originally at l    it would end up at l  after
the action pick l     in the notation introduced above    is a classical plan for the classical
problem p s for the two possible initial states s  while   is a classical plan for the problem
p s but only for the state s where the object is initially at l   
   

ficompiling uncertainty away in conformant planning problems

consider now the classical problem kt m  p     hf     i     o    g  i that is obtained from p
when t    at l     at l      and m contains the merge m    at l     at l     for the literals
hold and at l     from its definition  the fluents f   in kt m  p   are of the form kl t and
kl t for l   at l   hold   l   l    l     and t  t   while the initial situation i   is
i      khold  khold at l   kat l     kat l    at l   kat l  at l   kat l    at l  
for l  l    l    l    and l     l  and the goal g  is
g     kat l      
the effects associated to the actions pick l  and drop l  in o  are the support rules
pick l    khold  kat l   khold  kat l 
pick l    khold  khold  kat l 
drop l    khold  khold  kat l 
for each one of the three locations l   li   that condition each rule in o with the empty tag 
along with the support rules 
pick l    khold at l     kat l  at l     khold at l     kat l  at l   
pick l    khold at l     khold at l     kat l  at l   
drop l    khold at l     khold at l     kat l  at l   
that condition each rule in o with the tags at l     t   for l    l    l     the corresponding
cancellation rules are 
pick l    khold  kat l   khold  kat l 
pick l    khold  khold  kat l 
drop l    khold  khold  kat l 
and
pick l    khold at l     kat l  at l     khold at l     kat l  at l   
pick l    khold at l     khold at l     kat l  at l   
drop l    khold at l     khold at l     kat l  at l     
in addition  the actions in o  include the merge actions am hold and am at l    that follow
from the merge m    at l     at l     in m for the literals hold and at l    
am hold   khold at l     khold at l     khold
am at l      kat l    at l     kat l    at l     kat l     
   the empty tag is assumed in every t and thus it is not mentioned explicitly 

   

fipalacios   geffner

it can be shown then that the plan
      pick l     drop l     pick l     drop l     am at l     
solves the classical problem kt m  p   and hence  from theorem    that the plan   obtained
from    by dropping the merge action  is a valid conformant plan for p  shown above   we
can see how some of the literals in kt m  p   evolve as the actions in    are executed 
  
  
  
  
  
  

kat l    at l     kat l    at l   
khold at l     kat l    at l   
kat l    at l     kat l    at l   
kat l    at l     khold at l   
kat l    at l     kat l    at l   
kat l   

true
true
true
true
true
true

in i  
after
after
after
after
after

pick l   
drop l   
pick l   
drop l   
merge am at l     

we can also verify in the same manner that the action sequence   
      pick l     pick l     am hold   drop l    
is not a classical plan for kt m  p    the reason being that the atom khold at l    holds after
the first pick up action but not after the second  this is due to the cancellation rule 
pick l      khold at l     khold at l     kat l    at l   
that expresses that under the assumption at l    in the initial situation  hold and at l   
are not known to be true after the action pick l     if under the same assumption  hold
was not known to be true before the action 

   a complete translation  ks 
a complete instance of the translation scheme kt m can be obtained in a simple manner
by setting the tags to the possible initial states of the problem p and by having a merge
for each precondition and goal literal l that includes all these tags  we call the resulting
exhaustive translation ks   
definition    translation ks     for a conformant problem p   the translation ks   p   is
an instance of the translation kt m  p   where
 t is set to the union of the empty tag and the set s  of all possible initial states of p
 understood as the maximal sets of literals that are consistent with i   and
 m is set to contain a single merge m   s  for each precondition and goal literal l in
p 
the translation ks  is valid and hence sound  and it is complete due the correspondence
between tags and possible initial states 
theorem    completeness of ks     if  is a conformant plan for p   then there is a
classical plan    for ks   p   such that  is the result of dropping the merge actions from     

   

ficompiling uncertainty away in conformant planning problems

 s 
problem
adder   
blocks   
blocks   
bomb     
bomb     
bomb      
bomb     
coins   
coins   
coins   
coins   
comm   
comm   
comm   
corners square   
corners square   
corners square   
corners square    
corners square    
square center   
square center   
log        
log        
ring  
ring  
safe   
safe   
safe    
sortnet   
sortnet   
sortnet   
sortnet   
uts k   
uts k   

  
  
   
 k
 k
 k
 m
 k
 k
 k
 m
   
 k
 k
 
 
 
 
 
   
   
 k
  k
   k
   k
  
  
   
   
   
 k
 k
  
  

ks 
time
len
   h
   
  
    
  
   
  
    
  
    
  
     gb
    
  
    
  
    
  
     gb
    
  
    
  
     gb
   
   
   
   
   
   
          
     gb
    
   
     gb
     
  
   h
    
  
     gb
   
  
   
  
 
   
   
  
   
  
    
  
     gb
   
  
   
  

pond
time len
   
  
   
  
         
 
  
 
  
 
  
    
  
 
  
 
  
 
  
   h
 
  
 
  
 
  
    
  
   h
   h
   h
   h
    
  
   h
   h
   h
 
  
  
  
 
  
  
  
     gb
   
  
   h
   h
   h
  
  
    
  

cff
time
len
   h
   h
   h
 
  
 
  
 
  
 
  
 
  
 
  
   
  
 
  
 
  
 
  
 
  
    
   
   
   
   h
   h
   h
   h
   h
   
  
   
   
   
  
    
  
    
  
     
  
          
snh
snh
snh
snh
   
  
    
  

table    ks  translation fed into ff planner compared with pond and conformant ff
 cff  along both times and reported plan lengths   s  stands for number of
initial states  snh means goal syntax not handled  by cff   times reported in
seconds and rounded to the closest decimal 

   

fipalacios   geffner

for problems p whose actions have no preconditions  the argument is simple  if  is
a conformant plan for p then  must be a classical plan for p s for each possible initial
state s  but then if  achieves the  goal  literal gi in p s for each s   must achieve the
literal kgi  s in ks   p   for each s as well  so that  followed by the merge action for gi  
must achieve the literal kgi   in the presence of action preconditions  this argument must
be applied inductively on the plan length  but the idea remains the same  see the proof
in the appendix for details   a correspondence can be established between the evolution of
the fluents l in each problem p s and the evolution of the fluents kl s in the problem
ks   p   
the significance of the exhaustive ks  translation is not only theoretical  there are
plenty of conformant problems that are quite hard for current planners even if they involve
a handful of possible initial states  an example of this is the square center n task  cimatti
et al          where an agent has to reach the center of an empty square grid with certainty 
not knowing its initial location  there are four actions that move the agent one unit in each
direction  except when in the border of the grid  where they have no effects  in the standard
version of the problem  the initial position is fully unknown resulting in n  possible initial
states  yet the problem remains difficult  and actually beyond the reach of most planners 
for small values of n  even when the uncertainty is reduced to a pair of possible initial states 
the reason is that the agent must locate itself before heading for the goal  the domain
corners square n in table   is a variation of square center n where the possible initial
states are the four corners of the grid 
table   shows results for a conformant planner based on the ks   p   translation that
uses ff  hoffmann   nebel        for solving the resulting classical problem  and compares
it with two of the planners that entered the conformant track of the      int  planning
competition  bonet   givan         pond  bryce et al         and conformant ff
 hoffmann   brafman         the other two planners in the competition were translationbased  t    based on the formulation developed in this paper  and k p    based on an earlier
and more restricted formulation due to palacios   geffner         clearly  the approach
based on the ks   p   translation does not scale up to problems with many possible initial
states  yet when the number of such states is small  it does quite well 

   complete translations that may be compact too
in order to have complete translations that are polynomial  certain assumptions about the
formulas in the initial situation i need to be made  otherwise  just checking whether a
goal is true in i is intractable by itself  and therefore a polynomial but complete translation
would be impossible  unless p   np   we will thus assume that i is in prime implicate  pi 
form  marquis         meaning that i includes only the inclusion minimal clauses that it
entails but no tautologies  it is known that checking whether a clause follows logically from
a formula i in pi form reduces to checking whether the clause is subsumed by a clause in
i or is a tautology  and hence is a polynomial operation  the initial situations i in most
benchmarks is in p i form or can easily be cast into pi form as they are normally specified
by means of a set of non overlapping oneof  x            xn   expressions that translate into
clauses x       xn and binary clauses xi  xj for i    j where any resolvent is a
tautology 
   

ficompiling uncertainty away in conformant planning problems

    conformant relevance
the translation ks   p   is complete but introduces a number of literals kl t that is exponential in the worst case  one for each possible initial state s    this raises the question  is
it possible to have complete translations that are not exhaustive in this sense  the answer
is yes and in this section we provide a simple condition that ensures that a translation
kt m  p   is complete  it makes use of the notion of relevance  
definition     relevance   the conformant relevance relation l  l  in p   read l is
relevant to l    is defined inductively as
   l  l
   l  l  if a   c  l  is in p with l  c for some action a in p
   l  l  if l  l   and l    l 
   l  l  if l  l   and l    l   
the first clause stands for reflexivity  the third for transitivity  the second captures conditions that are relevant to the effect  and the fourth  the conditions under which l preempts
conditional effects that may delete l    if we replace   by
  l  l  if l  l 
which is equivalent to   in the context of     the resulting definition is the one by son and
tu         where the notion of relevance is used to generate a limited set of possible partial
initial states over which the   approximation is complete  see section    for a discussion on
the relation between tags and partial initial states  
notice that according to the definition  a precondition p of an action a is not taken to
be relevant to an effect q  the reason is that we want the relation l  l  to capture the
conditions under which uncertainty about l is relevant to the uncertainty about l    this is
why we say this is a relation of conformant relevance  preconditions must be known to be
true in order for an action to be applied  so they do not introduce nor propagate uncertainty
into the effects of an action 
if we let ci stand for the set of clauses representing uncertainty about the initial situation  namely  the non unit clauses in i along with the tautologies l  l for complementary
literals l and l not appearing as unit clauses in i  the notion of  conformant  relevance
can be extended to clauses as follows 
definition     relevant clauses   a clause c  ci is relevant to a literal l in p if all
literals l   c are relevant to l  the set of clauses in ci relevant to l is denoted as ci  l  
having a representation of the uncertainty in the initial situation that is relevant to a
literal l  it is possible to analyze the completeness of a translation kt m in terms of the
relation between the merges m for the literals l  on one hand  and the sets of clauses ci  l 
that are relevant to l on the other 
   while we follow an earlier account  palacios   geffner         many of the definitions and theorems
differ in a number of details  for example  the notion of relevance depends on the rules in p but not on
the clauses in the initial situation   the changes are aimed at making the resulting formulation simpler
and cleaner 

   

fipalacios   geffner

    covering translations
it may appear that a translation kt m would be complete when
w the merges m for precondition and goal literals l  understood as the dnf formulas tm t  contain as much
information  and thus are equivalent to the cnf formula ci  l  that captures the fragment
of the initial situation i that is relevant to l  this intuition is partially correct  but misses
one important point  namely that not every dnf formula equivalent to ci  l  will do  the
dnf representation captured by the merges must be vivid enough  for example  if ci  l 
is the single clause x  x  completeness requires a tag for x  a tag for x  and a merge
m    x  x  for l containing the two tags  even if the clause x  x is a tautology and is
thus equivalent to the dnf formula true 
for defining the types of tags and merges that are required for completeness then 
let us first define the closure s  of a set of literals s  relative to a conformant problem
p   hf  i  o  gi  as the set of literals that follow from s and i 
s     l   i  s    l   
let us also say that s is consistent if s  does not contain a pair of complementary literals 
the type of merges m required for precondition and goal literals l are then those that
do not only imply ci  l  but that satisfy it as well  the notion of satisfaction associates a
consistent set of literals s with the partial truth assignment that is implicit in the closure
s  of s  and is extended to account for the conditions under which a dnf formula  e g   a
merge for l  satisfies a cnf formula  e g   ci  l   
definition     satisfaction  
   a consistent set of literals s satisfies a clause l  l  

    lm if s contains one of the literals li   i              m 
   a consistent set of literals s satisfies a collection of clauses c if s satisfies each clause
in c 
   a collection s of consistent sets of literals satisfies a collection of clauses c if each set
s in s satisfies c 
the type of merges required for completeness are then simply the valid merges m that
satisfy the set of clauses ci  l   we call them covering merges 
definition     covering merges   a valid merge m in a translation kt m  p   covers a
literal l if m satisfies ci  l  
for example  if ci  l  is given by the clauses that result from a oneof  x            xn   expression  i e  x   x       xn and xi  xj for all i and j     i  j  n  i    j  then the
merge m    x            xn   covers the literal l  as each xi not only includes xi but also xj
for all j    i  and thus xi satisfies ci  l  
w
if for a merge m    t            tn    we denote by m the dnf formula ti m ti   where each
tag ti is replaced by its closure ti   then it is simple to prove that if m covers the literal l 
m entails ci  l   a merge m that covers l is thus a dnf formula that is strong enough
to imply the cnf formula ci  l   through the closure   weak enough to be entailed by i 
and vivid enough to satisfy ci  l  
   

ficompiling uncertainty away in conformant planning problems

as a further illustration  if ci  l  is given by the tautologies p  p and q  q  and
i   ci  l   the merge m     p  p  implies ci  l  but does not satisfy ci  l   likewise  the
merge m      p  q    p  q   satisfies ci  l  but is not entailed by i  finally  the merge
m      p  q    p  q    p  q    p  q   satisfies ci  l  and is entailed by i  and thus is a
valid merge that covers l 
if a valid translation kt m  p   contains a merge m that covers l for each precondition
and goal literal l in p   we say that the translation covers p or just that it is a covering
translation 
definition     covering translation   a covering translation is a valid translation
kt m  p   that includes one merge that covers l  for each precondition and goal literal l
in p  
a central result of the paper is that covering translations are complete 
theorem     completeness   covering translations kt m  p   are complete  i e   if  is a
conformant plan for p   then there is a classical plan    for kt m  p   such that  is    with
the merge actions removed 
in other words  complete translations kt m  p   result when the tags and merges in t
and m capture the information in the initial situation that is relevant to each precondition
and goal literal in a suitable manner 
theorem    can be used in two ways  for proving the completeness of a translation  by
checking that the covering condition holds  and for constructing complete translations  by
enforcing the covering condition  in addition  while our interest in this paper is on conformant planning with no optimality guarantees  the theorem is useful for optimal conformant
planning as well  whether the cost of plans is defined as their length  action costs equal to
   or as the sum of non uniform action costs  in both cases  the theorem ensures that the
problem of optimal conformant planning gets mapped into a problem of optimal classical
planning provided that the cost of the merge actions in kt m  p   is made sufficiently small 
as an illustration of theorem     consider the conformant problem p with initial situation i    x       xm    goal g   l  and actions ai   i              m  each with effect xi  l 
the number of possible initial states for this problem is exponential in m  as the disjunction
among the xi s is not exclusive  so  the translation ks   p   is complete but exponential in
size  on the other hand  consider the translation kt m  p   where t    x            xm   and
m contains the single valid merge m    x            xm   for l  it is simple to verify that this
merge covers the goal l  satisfies ci  l    i   and hence that the translation kt m  p   is
covering  and by theorem     complete  while being polynomial in m 
notice that testing whether a valid translation kt m  p   is a covering translation can
be done in polynomial time  as in particular  computing the set of literals t from every tag
t in t is a tractable operation provided that i is in pi form  indeed  i  t    l  iff i    t  l 
iff t  l  is a tautology or is subsumed by a clause in i 
    translation kmodels
it is straightforward to show that the exponential translation ks  considered in section   
where  non empty  tags stand for the possible initial states  is covering and hence complete
   

fipalacios   geffner

according to theorem     it is possible  however  to take further advantage of theorem   
for devising a complete translation that is usually more compact  we call it kmodels 
definition     the translation kmodels p   is obtained from the general scheme kt m  p  
by defining
 m to contain one merge m for each precondition and goal literal l given by the models
of ci  l  that are consistent with i   and
 t to contain the tags in all such merges along with the empty tag 
the translation kmodels is equivalent to ks  when for all the precondition and goal
literals l  ci  l    i  i e   when all the clauses in i are relevant to l  yet  in other cases 
the first translation is exponential in the number of variables appearing in one such ci  l 
set  the one with the largest number of such variables   while the second is exponential in
the number of unknown variables in i  for example  if there are n precondition and goal
literals li   i              n in p such that for each one  ci  li   is a unique oneof  xi            xim  
expression  the merge for the literal li in ks   p   will contain the mn models of the n one of
expressions in i  while the merge for li in kmodels p   will just contain the m models of
the single oneof  xi            xim   expression in ci  li    the translation kmodels can thus be
exponentially more compact than the exhaustive ks  translation while remaining sound
and complete 
theorem     the translation kmodels p   is sound and complete 
in the worst case  however  kmodels is also an exponential translation  we thus consider
next polynomial translations and the conditions under which they are complete 
    conformant width
we address now the conditions under which a compact  covering translation can be constructed in polynomial time  for this  we define a structural parameter that we call the
conformant width of a problem p   that in analogy to the notion of width used in graphical
models  dechter         will provide an upper bound on the time and space complexity
required for generating a covering translation  more precisely  the complexity of this construction will be exponential in the conformant width of the problem p that cannot exceed
the number of fluents in p but can be much lower 
in principle  we would like to define the width w p   as the maximum tag size required
in a translation kt m  p   to be a covering translation  such a definition  however  would
not give us the complexity bounds that we want  as just checking the validity of a merge
with tags of bounded size is an intractable operation  whether the initial situation i is in
prime implicate form or not   so we need to define width in a different way  first  let the
cover of a set of clauses be defined as follows 
   the models of ci  l  are to be understood as conjuntions of literals 
   the problem of checking whether i entails a dnf formula whose terms may have more than   literals
is conp hard even if i is equivalent to true  indeed  if  is a   cnf formula   is contradictory iff its
negation   which is in   dnf  is valid  which in turn is true iff  is implied by i  actually  for a
general i in prime implicate form  the problem remains conp hard even if the terms of the dnf formula
contain at most   literals  we thank pierre marquis for pointing these results to us 

   

ficompiling uncertainty away in conformant planning problems

definition     cover   the cover c c  of a set of clauses c  relative to a conformant
problem p with initial situation i  is the collection of all minimal sets of literals s consistent
with i such that s contains a literal of each clause in c 
two important properties of the cover c c  of a set of clauses c are that c c  stands for
a dnf formula that is logically equivalent to the cnf formula c given i  and that c c  can
be computed in polynomial time if the size of c is bounded by a constant  moreover  c c 
not only implies c but satisfies c as well  thus in particular  if c is the collection of clauses
ci  l  that are relevant to the literal l  the cover c ci  l   of ci  l  is a valid merge that
covers l  from this and the completeness of covering translations  it follows that a complete
translation kt m  p   can be constructed in polynomial time if the size  ci  l   of the sets of
clauses ci  l  for all precondition and goal literals l in p is bounded  unfortunately  this
condition rarely seems to hold  yet there is a weaker sufficient condition that does  namely 
it is often possible to find a subset c of clauses that are either in ci  l  or are tautologies
such that c c  satisfies ci  l  and thus covers the literal l  we thus define the width of
the literal l as the size of the smallest such set  cardinality wise   for this  we denote by
ci  l  the set of clauses ci  l  extended with tautologies of the form p  p for fluents p
such that either p or p appears in ci  l   if both appear in ci  l  then p  p is in ci  l 
from its definition  
definition     width of literal   the conformant width of a literal l in p   written w l  
is the size of the smallest  cardinality wise  set of clauses c in ci  l  such that c c  satisfies
ci  l  
a consequence of this definition is that the width of a literal must lie in the interval
   w l   n  where n is the number of fluents in p whose status in the initial situation
is not known  indeed  if ci  l  is empty  w l       while for any set of clauses ci  l   the
cover c c  of the set c of tautologies in ci  l  must satisfy ci  l   and thus w l    c   n 
similarly  if ci  l  contains a single clause x       xm or the clauses x       xm and
xi  xj that correspond to the oneof  x            xm   expression  it is simple to prove that
w l      with the singleton c    x    xm   generating the cover c c      x              xn   
that satisfies ci  l   finally  if ci  l  contains the two tautologies pp and qq  w l     
as the smallest c in ci  l  whose cover satisfies ci  l  is ci  l  itself 
the width of a problem is the width of the precondition or goal literal with maximum
width 
definition     width of problem   the conformant width of a problem p   written as
w p    is w p     maxl w l   where l ranges over the precondition and goal literals in p  
we show below that for problems with bounded width  complete translations can be
constructed in polynomial time  and moreover  that almost all existing conformant benchmarks have bounded width  and more precisely  width equal to    in such a case  the
resulting translations will use tags that are never greater in size than w p    so that for
problems with width    tags will be single literals 
like for the  tree width of graphical models  computing the width of a problem p is
exponential in w p    so the recognition of problems with small width can be carried out
quite efficiently 
   

fipalacios   geffner

proposition     determining width   the width w p   of p can be determined in time
that is exponential in w p   
in particular  we can test if w p       by considering one by one each of the sets c
that includes a single clause from ci  l   verifying whether c c  satisfies ci  l  or not  if
w p        then the same verification must be carried out by setting c to each set of i
clauses in ci  l  for increasing values of i  for a fixed value of i  there is a polynomial
number of such clause sets c and the verification of each one can be done in polynomial
time  moreover  from the arguments above regarding w l   w p   can never exceed the
number of unknown fluents in the problem 
proposition     bounds on width   the width of p is such that    w p    n  where n
is the number of fluents whose value in the initial situation is not known 
    polynomial translation ki
the translation ki   where the parameter i is a non negative integer  is an instance of
the general kt m scheme designed to be sound  polynomial for a fixed i  and complete for
problems with width w p    i  thus  for example  the translation k  is sound  polynomial 
and complete for problems with width   
definition     translation ki    the translation ki  p   is obtained from the general
scheme kt m  p   where
 m is set to contain one merge m   c c  for each precondition and goal literal l in p
if there is a set c of at most i clauses in ci  l  such that m covers l  if no such set
exists  one merge m   c c  for l is created for each set c of i clauses in ci  l   and
no merges are created for l if ci  l  is empty 
 t is the collection of tags appearing in those merges and the empty tag 
the translation ki  p   applies to problems p of any width  remaining in all cases exponential in i but polynomial in the number of fluents  actions  and clauses in p   in addition 
the translation ki  p   is sound  and for problems with width bounded by i  complete 
theorem     properties ki    for a fixed i  the translation ki  p   is sound  polynomial 
and if w p    i  covering and complete 
soundness is the result of the merges being all valid by construction  as the covers c c 
for any c in ci  l  are entailed by c and hence by i  the complexity is polynomial for a fixed
i  because there is a polynomial number of clause sets c of size i in ci  l   and constructing
the cover c c  for each one of them  is a polynomial operation  finally  completeness follows
from the definition of width  if w p    i  then there is a set of clauses c in ci  l  with
size  c  no greater than i whose cover satisfies ci  l   and thus m in ki  p   must contain a
merge m   c c  for l that covers l 
notice that for i      the translation ki  p   reduces to the basic k   p   translation
introduced in section   that has no tags  other than the empty tag  and no merges  before 
we assessed the completeness of this translation in terms of the   approximation semantics 
theorem    provides an alternative interpretation  the translation k   p   is complete for
   

ficompiling uncertainty away in conformant planning problems

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

domain parameter
safe n combinations
uts n locs
ring n rooms
bomb in the toilet n bombs
comm n signals
square center n  n grid
cube center n  n  n cube
grid n shapes of n keys
logistics n pack m locs
coins n coins m locs
block tower n blocks
sortnet n bits
adder n pairs of bits
look and grab m objs from n  n locs
  dispose m objs from n  n locs

  unknown fluents
n
n
 n
n
n
 n
 n
nm
nm
nm
n   n        n    
n
 n
nnm
nnm

width
 
 
 
 
 
 
 
 
 
 
n   n        n    
n
 n
m
m

table    width of parameterized domains
problems p with zero width  these are the problems for which the set of clauses ci  l 
relevant to a precondition or goal literal l is empty  this makes precise the intuition
mentioned above that the k   p   translation is complete for problems where the uncertain
information in i is not relevant  in such cases  none of the clauses in the initial situation i
make it into the sets of relevant clauses ci  l  for preconditions and goal literals l 
as an illustration of theorem     consider again the conformant problem p with initial
situation i    x       xm    goal g    l   and actions ai   i              m  each with
effect xi  l  for this problem  the singleton set of clauses c   ci  l    i is such that
c c      x              xm    covers ci  l   then  since there is no other precondition or goal
literal  k   p   includes the single merge m   c c  for l with the singleton tags ti    xi   
that we write simply as m    x            xm    the translation k   p   is polynomial in m 
and since w p        by theorem    it is complete  notice that for this same example  the
translations ks   p   and kmodels p   are identical and exponential in m  the number of
models of i and ci  l   
    width of conformant benchmarks
the practical value of the notion of width becomes apparent when the width of existing
benchmarks is considered  table   summarizes the width of many of the existing benchmark
domains for conformant planning  the domains all depend on certain parameters n or m
that capture the size of the instances  e g   size of a grid  number of objects  etc    a domain
has a bounded width when its width does not grow with the size of its instances  and has
width equal to i when all of its instances have width i regardless of the parameter values 
as it can be seen from the table  the width of most existing benchmarks is    in all
these cases  this means that the sets ci  l  of clauses that are relevant to a precondition or
   the names of the parameterized domains in the table do not coincide with the names of the instances
as currently used  e g  comm n in ipc  refers to a communication instance but not necessarily to an
instance with n signals 

   

fipalacios   geffner

goal literal l contain a single clause  often a tautology p  p or a disjunction x          xm  
or a single oneof  x            xm   expression  that translates into the disjunction x       xm
and clauses xi  xk    as shown above  w l   and therefore  w p    is equal to   in theses
cases 
on the other extreme are domains such as blocks  sortnet  and adder  all of which
have maximal widths  i e   widths that are equivalent to the number of fluents whose status in the initial situation is not known  this is because all fluents interact through the
action conditions  not the preconditions   the numbers for blocks in table    thus follow
from the number of fluents involved  namely  the fluents on x  y   clear x   ontable x   and
holding x  
finally  the domains   dispose and look and grab  palacios   geffner             
where m objects with unknown locations in a grid of n by n must be collected by a robot
whose gripper can hold one object at a time  have width equal to m  meaning that the
width of these domains grows with the number of objects but not with the size of the grid 
this is because in this case  the clauses about the possible locations of the m objects are
all relevant to the condition hand empty of the pick up actions 
let us point out that the completeness of the translation ki  p   for problems p with
width w p   bounded by i  establishes a correspondence between the conformant plans
for p and the classical plans for kt m  p    for solving p   however  this correspondence
is not needed  it suffices for ki  p   to be solvable  a plan for ki  p   will then encode a
conformant plan for p   even if ki  p   does not capture all conformant plans for p   from
this perspective  it makes sense to refer to the smallest value of the i parameter for which
the classical problem ki  p   is solvable  as the effective width of p   denoted we  p    it turns
out that while we  p   cannot be larger than w p    it may be much smaller  an interesting
example of this comes from the sortnet n domain  bonet   geffner         sortnet n is
considered a challenging domain in conformant planning with very few planners able to
scale up to even small values of n  the number of entries to be sorted in a sorting network  
the domain has width n  and in the compact encoding used in ipc   the input vector is
represented by a set of bits  exploiting the fact that sorting vectors of numbers reduces to
sorting vector of bits   s and  s   the domain cannot be solved by the k  translation that
ff reports correctly as unsolvable after a brief unsuccessful search  on the other hand 
it is possible to reformulate the domain  replacing the unary high i  and low i  predicates
by binary predicates less i  j  that compare two vector entries  we call this reformulation
sort   n  while the encoding sort n is linear in n  the encoding sort   n is quadratic in n 
and in both cases  the problem width is maximum  given by the number of fluents whose
status in the initial situation is unknown  yet  while the more compact sort n encoding is
not solvable by the k  translation  k  suffices to solve the problem over the expanded sort  n encoding that actually can also be solved by k    thus the effective width of sort   n
is    interestingly  provided the k  translation of sort   n  instances can be solved with up
to    entries  on the other hand  conformant planners such as conformant ff and pond
can solve sort   n instances for n no greater than   
   

ficompiling uncertainty away in conformant planning problems

   tags and initial states
a deeper understanding of the results above can be obtained by relating tags with possible
initial states  by looking more closely at this relation in the context of covering translations 
we will be able to answer the question of how a polynomial number of contexts  tags  can
play the role of an exponential number of possible initial states in problems with bounded
width 
for this  let us first recall a notation introduced in section      where for a state s  we
wrote i s  to refer to the set of atoms encoding s  i e  p  i s  iff p is true in s  and p s
to refer to the classical planning problem p s   hf  i s   o  gi that is like the conformant
problem p   hf  i  o  gi but with the initial state fixed to s 
let us now extend this notation and say that an action sequence  conforms with a set
of states s given the conformant problem p iff  is a plan for the classical problem p s for
each s  s  clearly  a conformant plan for p is nothing else but an action sequence that
conforms with the set s  of possible initial states of p   yet the notion of conforms allows
us to abstract away the initial situation i and make precise the notion of a basis 
definition     basis for p    a set of states s   is a basis for a conformant problem p  
hf  i  o  gi if s   is a subset of the set s  of possible initial states of p and every plan that
conforms with s   conforms with the set of possible initial states s   
in words  if s   is a basis for p   it is not necessary to consider all the states in s  for
computing the conformant plans for p   it suffices to consider just the states in s     we aim
to show that if the width of p is bounded  then p has a polynomial basis s   even if s  has
exponential size  moreover  the states s in such a basis are in close correspondence with
the tags appearing in a covering translation 
as an illustration  consider a problem p with actions ai   i              n  and effects
ai   xi  l  let g    l  be the goal and i    x       xn   the initial situation  the
set s  of all possible initial states are the truth valuations over the xi atoms where at least
one of these atoms is true  there are  n    such states  on the other hand  one can show
that the set s   of n valuations in which exactly one of these atoms is true provides a basis
for p   i e   the plans that conform with these n possible initial states  are exactly the plans
that conform with the complete set of  n    possible initial states in s   
the reduction in the number of possible initial states that must be considered for computing conformant plans results from two monotonicity properties that we formulate using
the notation rel s  l  to refer to the set of literals l  that are true in the state s and are
relevant to the literal l 
rel s  l     l    l   s and l  is relevant to l   
proposition     monotonicity     let s and s  be two states and let  be an action sequence
applicable in the classical problems p s and p s    then if  achieves a literal l in p s 
and rel s    l   rel s  l    achieves the literal l in p s 
proposition     monotonicity     if s and s   are two collections of states such that for
every state s in s and every precondition and goal literal l in p   there is a state s  in s  
such that rel s    l   rel s  l   then if  is a plan for p that conforms with s      is a plan
for p that conforms with s 
   

fipalacios   geffner

from these properties  it follows that
proposition     s   is a basis for p if for every possible initial state s of p and every
precondition and goal literal l in p   s   contains a state s  such that rel s    l   rel s  l  
this proposition allows us to verify the claim made in the example above that the set s    
that contains a number of states that is linear in n  is a basis for p that has an exponential
number of possible initial states  indeed  such a problem has no precondition and a single
goal literal l  and for every state s that makes more than one atom xi true  these are the
literals relevant to l   there is a state s  in s   that makes only one of those atoms true  and
hence for which the relation rel s    l   rel s  l  holds 
the question that we address now is how to build a basis that complies with the condition
in proposition    given a covering translation kt m  p    for this  let m    t            tn   be
a merge in m that covers a precondition or goal literal l  and let s ti   l  denote the set of
possible initial states s of p such that rel s  l   ti   i e   s ti   l  contains the possible initial
states of p that make all the literals l  that are relevant to l false  except for those in the
closure ti of ti   we show first that if i is in prime implicate form  s ti   l  is a non empty
set  
proposition     if the initial situation i is in prime implicate form and m    t            tn  
is a valid merge that covers a literal l in p   then the set s ti   l  of possible initial states s
of p such that rel s  l   ti is non empty 
let then s ti   l  stand for an arbitrary state in s ti   l   we obtain the following result 
theorem     let kt m  p   be a covering translation for a problem p with an initial
situation in pi form  and let s   stand for the collection of states s ti   l  where l is a
precondition or goal literal of p and ti is a tag in a merge that covers l  then s   is a basis
for p  
this is an important result for three reasons  first  it tells us how to build a basis for p
given the tags ti in a covering translation kt m  p    second  it tells us that the size of the
resulting basis is linear in the number of precondition and goal literals l and tags ti   and
third  it makes the role of the tags ti in the covering translation kt m  p   explicit  providing
an intuition for why it works  each tag ti in a merge that covers a literal l represents one
possible initial state  namely  a state s ti   l  that makes false all the literals l  that are
relevant to l except those in ti   if a plan conforms with those critical states  then it will
conform with all the possible initial states by monotonicity  proposition      it follows then
in particular that 
theorem     if p is a conformant planning problem with bounded width  then p admits
a basis of polynomial size 
namely  conformant problems p with width bounded by a non negative integer i admit
polynomial translations that are complete  because the plans that conform with the possibly
exponential number of initial states of p correspond with the plans that conform with
   recall that we are assuming throughout that the initial situation i is logically consistent and that the
tags t are consistent with i 

   

ficompiling uncertainty away in conformant planning problems

a subset of critical initial states that are polynomial in number  namely  those in the
polynomial basis   thus  one complete polynomial translation for such problems is the
ki translation  another one  is the ks  translation but with the tags associated with those
critical initial states only rather than with all the initial states 
as an illustration  for the problem p above with actions ai and effects ai   xi  l 
goal g    l   and initial situation i    x       xn    the k   p   translation with tags xi  
i              n  and the merge m    x            xn   for the goal literal l  is a covering translation 
theorem    then states that a basis s   for p results from the collection of states si that
make each tag xi true  and all the literals that are relevant to l that are not in xi false  i e  
all xk atoms for k    i   this is precisely the basis for p that we had above that includes
the states that make a single atom xi true for i              n  the plans that conform with this
basis are then exactly the plans that conform with the whole collection of possible initial
states of p   this basis has a size that is polynomial in m though  while the number of
possible initial states of p is exponential in m 

   the planner t 
the current version of the conformant planner t  is based on two instances of the general
translation scheme kt m  p   whose outputs are fed into the classical planner ff v      one
instance is polynomial but not necessarily complete  the other is complete but not necessarily
polynomial  for the incomplete translation  t  uses k  that is complete for problems with
width no greater than    and as argued above  can result in solvable instances for problems
of larger widths  for the complete translation  the kmodels translation is used instead
with a simple optimization  if the k  translation produces a single merge m that covers l 
then this merge m is used for l instead of the potentially more complex one determined by
kmodels  this is a mere optimization as the resulting translation remains complete  the
other merges in kmodels  that result from the models of the set of clauses ci  l  that are
consistent with i  are computed using the sat solver relsat v      bayardo jr    schrag 
       in the current default mode in t    which is the one used in the experiments below 
the two translations k  and kmodels are used in sequence  ff is called first upon the
output of k  and if this fails  it is called upon the output of kmodels  in the experiments
below  we indicate the cases when kmodels was invoked 
the translations used in t  accommodate certain simplifications and two additional
actions that capture other types of deductions  the simplifications have to do with the fact
that the translations considered are all uniform in the sense that all literals l in p and
all rules c  l are conditioned by each of the tags t in t   from a practical point of
view  however  this is not needed  the simplifications address this source of inefficiency  in
particular 
 literals kl t are not created when the closure t contains no literal relevant to l 
in such a case  the invariance kl t  kl holds  and thus  every occurrence of the
literal kl t in kt m  p   is replaced by kl 
   the conformant planner t  along with all the benchmarks considered in the paper are available at
http   www ldc usb ve hlp software 

   

fipalacios   geffner

 support rules a   kc t  kl t for non empty tags t are not created when l is not
relevant to a literal l  with a merge that contains t  as in such a case  the literal
kl t cannot contribute to establish a precondition or goal  similarly  cancellation
rules a   kc t  kl t for non empty tags t are not created when l is not
relevant to a literal l  with a merge that contains t 
 support and cancellation rules a   kc t  kl t and a   kc t  kl t are
grouped as a   kc t  kl t  kl t when for every fluent l  relevant to l  either
l  or l  is entailed by i and t  in such a case  there is no incomplete information
about l given t in the initial situation  and thus the invariant kl t or kl t holds 
and kc t is equivalent to kc t 
two other types of sound deductive rules are included in the translations 
 a rule a   kc  kl is added if a   c  l  l is a rule in p for an action a  and no
rule in p has the form a   c    l 
 rules kl            kli    kli             kln  kli for i              n are added to a
new unique action with no precondition  when l       ln is a static clause in p  a
clause in p is static if true in the initial situation and provably true after any action  
these rules are versions of the action compilation and static disjunctions rules  palacios  
geffner               and they appear to help in certain domains without hurting in others 
the version of t  reported below does not assume that the initial situation i of p is
in prime implicate form but it rather renders it in pi form by running a version of tisons
algorithm         a computation that in none of the benchmarks solved took more than   
seconds 
the translators in t  are written in ocaml while the code for parsing the pddl files
is written in c   

   experimental results
we considered instances from three sources  the conformant ff distribution  the conformant track of the      international planning competition  ipc    and relevant publications  palacios   geffner              cimatti et al          the instances were run on a
cluster of linux boxes at      ghz with  gb  each experiment had a cutoff of  h or    gb
of memory  times for t  include all the steps  in particular  computation of prime implicates  translation  and search  done by ff   we also include results from the conformant
track of the recent      international planning competition  ipc   
goals that are not sets of literals but sets of clauses are transformed in t  in a standard
way  each goal clause c   l       lm is modeled by a new goal atom gc   and a new
action that can be executed once is added with rules li  gc   i              m  
   an alternative way to represent such cnf goals is by converting them into dnf first and having an
action end map each of its non mutex terms into a dummy goal lg   this alternative encoding pays
off in some cases  such as in the adder    instance that does not get solved in the default cnf goal
encoding  see below  

   

ficompiling uncertainty away in conformant planning problems

problem
bomb        
square center   
sortnet   
blocks   
dispose     
look and grab      
sgripper   

p
 acts  atoms  effects
     
   
     
 
   
   
  
  
   
  
  
   
    
    
    
   
   
    
   
   
    

time
 
    
   
 
     
   
    

k   p  
pddl
 acts  atoms  effects size
     
    
     
   
 
     
     
   
  
     
      
   
  
     
     
   
           
    
   
   
    
      
   
   
    
     
 

table    translation data for selected instances   acts   atoms  and  effects stand for
the number of actions  fluents  and conditional effects  time is the translation
time in seconds rounded to the closest decimal  and pddl size is the size of the
pddl file in megabytes 

table   shows data concerning the translation of a group of selected instances  as it can
be seen  the number of conditional effects grows considerably in all cases  and sometimes
the translation may take several seconds 
tables             and    show the plan times and lengths obtained on a number of
benchmarks by t    pond      bryce et al          conformant ff  hoffmann   brafman 
       mbp  cimatti et al         and kacmbp  bertoli   cimatti         these last
two planners do not accept problems in the standard syntax  based on pddl   so only a
limited number of experiments were performed on them  the general picture is that t 
scales up well in most domains  the exceptions being square center and cube center in
table    where kacmbp scales up better  sortnet in table    where kacmbp and mbp
scale up better  and adder in table    where pond is the only planner able to solve one
instance 
the problems in table   are encodings from the conformant ff repository  bomb x y
refers to the bomb in the toilet problem with x packages  y toilets  and clogging  logistics ij k is a variation of the classical version with uncertainty about initial location of packages 
ring n is about closing and locking windows in a ring of n rooms without knowing the
current room  and safe n is about opening a safe with n possible combinations  all these
problems have width    t  does clearly best on the last two domains  while in the first two
domains  conformant ff does well too 
table   reports experiments on four grid domains  cube center n refers to the problem
of reaching the center of a cube of size n  from a completely unknown location  squarecenter n is similar but involves square with n  possible locations  corners cube n and
corners square n are variations of these problems where the set of possible initial locations
is restricted to the cube and square corners respectively  mbp and kacmbp appear to be
effective in these domains  although kacmbp doesnt scale up well in the corner versions 
t  solves most of the problems  but in the corner versions  the quality of the plans is poor 
these problems have also width   
table   reports experiments over problems from the      international planning competition  bonet   givan         the domains coins  comm and uts have all width   
the others have max width given by the number of unknown fluents in the initial situation 
   

fipalacios   geffner

problem
bomb     
bomb     
bomb      
bomb      
bomb      
bomb      
bomb       
bomb       
bomb        
logistics      
logistics        
logistics        
logistics        
ring  
ring  
ring  
ring  
ring  
ring   
safe   
safe   
safe   
safe   
safe    

t 
time
   
   
   
   
   
   
   
    
   
   
 
   
   
   
   
   
   
   
    
   
   
   
    
   

len
  
  
  
  
   
   
   
   
   
  
  
   
   
  
  
  
  
  
   
  
  
  
  
   

pond
time len
       
   h
   h
   h





  
  
   h
   h
   h
 
  
 
  
  
  
   
  
   h

 
  
 
  
 
  
  
  
     gb

cff
time
len
 
  
 
  
 
  
 
  
    
   
    
   
    
   
   
   
 
   
 
  
   
  
   
   
   
   
   
  
   
  
    
  
   
  
   h

 
  
   
  
    
  
     
  
          

mbp
time len
   h
   h
   h
   h





   h
   h
   h
   h
 
  
   
  
   
  
   
  
  
  
   h
   
  
   h
   h
   h
   h

kacmbp
time len
 
  
   
  
   
  
 
  
   
   
   
   
        
   h
   h
     gb
     gb
     gb
     gb
 
  
   
  
   
  
   
   
 
   
     gb
 
  
   
  
   
  
   
  
   
   

table    experiments over well known benchmarks  times reported in seconds and rounded
to the closest decimal   means time or memory out for smaller instances 

   

ficompiling uncertainty away in conformant planning problems

problem
square center  
square center   
square center   
square center   
square center   
square center   
square center    
square center    
cube center  
cube center  
cube center  
cube center   
cube center   
cube center   
cube center   
cube center   
cube center   
cube center   
cube center    
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square   
corners square    
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   
corners cube   

t 
time
len
   
  
   
  
   
  
   
  
    
   
    
   
     gb
     gb
   
  
   
  
   
  
   
  
   
  
   
  
    
   
    
   
         
     gb
     gb
   
  
   
   
   
   
   
   
   
   
   
   
   
   
         
         
         
          
   
   
   
   
   
   
   
   
   
   
   
   
    
   
   
    
     gb

pond
time len
 
  
  
  
       
   h
   h



 
  
 
  
 
  
  
  
       
   h
   h




  
  
       
   h
   h







       
        
   h
   h






cff
time
len
    
  
   h
   h





   
  
   h
   h








   
  
    
   
    
   
   
   
mpl






         
         
         
          
mpl





mbp
time
len
 
  
 
  
 
  
 
  
   
   
   
   
   
   
   
   
 
  
 
  
   
  
   
  
   
  
   
   
  
   
     gb
     gb


 
  
 
  
   
  
   
  
   
  
   
   
   
   
         
   
   
         
     gb
   
  
    
  
         
         
   h
   h




kacmbp
time
len
 
  
 
  
 
  
 
  
   
   
   
   
   
   
   
   
 
  
 
  
 
  
 
  
 
  
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
   
   
   
    
   
          
   h
   h



         
         
          
    
   
          
   h
   h



table    experiments over grid problems  times reported in seconds and rounded to the
closest decimal  mpl for cff means that plan exceeds maximal plan length
     actions    means time or memory out for smaller instances 

   

fipalacios   geffner

problem
adder   
adder   
blocks   
blocks   
blocks   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
coins   
comm   
comm   
comm   
comm   
comm   
comm   
comm   
comm   
sortnet   
sortnet   
sortnet   
sortnet   
sortnet   
sortnet   
uts k   
uts k   
uts k   
uts k   
uts k   
uts k   
uts k   
uts l   
uts l   
uts l   
uts l   

t 
time len
   h
   h
   
 
   
  
    
  
   
  
   
  
   
  
   
   
   
  
   
  
   
   
   
   
   h
   
  
   
  
   
  
   
  
   
   
   
   
   
   
   
   
   
  
   
  
   
  
    
  
     gb
     gb
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
  

pond
time len
    
 
   h
   
 
   
  
         
 
  
   h
   h






 
  
 
  
 
  
 
  
 
  
   h
     gb

  
  
   
  
   h
   h


 
  
 
  
  
  
  
  
  
  
   h
    
  
   
  
   
  
   h
   h

cff
time len
snh
snh
 
 
   h
   h
   
  
   
  
 
  
        
   
  
   
   
        
        
   h
 
  
 
  
 
  
 
  
   
  
   
   
   
   
        
snh
snh
snh
snh
snh
snh
   
  
   
  
   
  
   
  
   
  
   
  
    
  
   
  
   
  
   
  
   
  

mbp
time
len
nr
nr
nr
nr
nr
   h
   h







   
  
   
  
   
  
   
  
   
   
   
   
    
   
   h
 
  
 
  
 
  
 
  
   
  
   
  
   
  
         
         
   h
   h


    
  
    
   
    
   
   h

kacmbp
time
len
nr
nr
nr
nr
nr
   
   
          
   h
   h





    
  
         
   h
   h




 
  
 
  
 
  
 
  
   
  
   
  
   
  
     
  
   h
   h



   h
   h



table    experiments over problems from ipc   times reported in seconds and rounded
to the closest decimal  snh for cff means that goal syntax not handled  while
nr for mbp and kacmbp that these planners were not run due to lack of
translations from pddl   means time or memory out for smaller instances 

   

ficompiling uncertainty away in conformant planning problems

problem
dispose    
dispose    
dispose    
dispose    
dispose    
dispose    
dispose     
dispose     
dispose     
dispose     
dispose     
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      
look and grab      

t 
time
len
   
  
   
   
   
   
   
   
    
   
         
  
    
         
     gb
   
    
     gb
   
  
   
 
    
 
  
  
     
 
     
 
     gb
     
 
     gb
    
   
    
  
     
  
   h
   h
   h
   h
   h
   h

pond
time len
 
  
  
  
       
     gb
     gb






       
   h
   h
     gb
   h
   h
     gb












cff
time
len
   
  
   
  
   
  
         
          
   h
me
     gb



   h
mcl
mcl
   h
mcl
mcl
   h
   h
   h










mbp
time len
   h
   h









   h
    
 
    
 
   h
    
 
    
 
   h
    
 
    
 
   h
   h
   h
   h
   h
   h
   h
   h
   h

kacmbp
time len
    
  
   h
   h








   
  
   
 
   
 
    
  
    
 
    
 
    
  
    
 
    
 
   h
   h
   h
   h
   h
        
   h
   h
    
  

table    problems from palacios and geffner               times reported in seconds and
rounded to the closest decimal   means time or memory out for smaller instances 
me and mcl mean too many edges and too many clauses respectively 

t  dominates in all these domains except in adder where pond is the only planner able
to solve an instance  and sortnet  where mbp and kacmbp do very well  possibly due to
use of the cardinality heuristic and obdd representations  t  fails on adder because ff
gets lost in the search  looking at this problem more closely  we found that ff could solve
the  translation of the  first instance in less than a minute provided that the cnf goal for
this problem is encoded in dnf as explained in footnote    page      the domains adder 
blocks  and sortnet in the table  along with the domain look and grab in the next table 
are the only domains considered where ff run on the k  translation reports no solution
after a brief search  triggering then the use of the complete kmodels translation  in all the
other cases where kmodels was used  the k  translation had an unreachable goal fluent and
there was no need to try ff on it 
   

fipalacios   geffner

problem
push to    
push to    
push to    
push to    
push to    
push to    
push to     
push to     
push to     
  dispose    
  dispose    
  dispose    

t 
time
len
   
  
   
  
   
  
    
   
     
   
          
   h
   h
     gb
    
    
     gb
     gb

pond
time len
 
  
   
  

   h
   h
   h



     gb
     gb


cff
time len
   
  
   
  
   
  
     gb
     gb
     gb



   h
   h


table    other problems from palacios and geffner               mbp and kacmbp
were not tried on these problems as they use a different syntax  times reported
in seconds and rounded to the closest decimal   means time or memory out for
smaller instances 

the problems reported in table   and table   are variations of a family of grid problems
 palacios   geffner               dispose is about retrieving objects whose initial location is
unknown and placing them in a trash can at a given  known location  push to is a variation
where objects can be picked up only at two designated positions in the grid to which all
objects have to be pushed to  pushing an object from a cell into a contiguous cell moves
the object if it is in the cell    dispose is a variation of dispose where the robot hand being
empty is a condition for the pick up actions to work  as a result  a plan for   dispose has to
scan the grid  performing pick ups in every cell  followed by excursions to the trash can  and
so on  the plans can get very long  a plan is reported with      actions   look and grab
has an action that picks up the objects that are sufficiently close if any  and after each pickup must dump the objects it collected into the trash before continuing  for the problem
p n m in the table  n is the grid size and m is the number of objects  for look n grab 
the third parameter is the radius of the action    means that the hand picks up all the
objects in the   surrounding cells    that that the hand picks up all the objects in the   
surrounding cells  and so on  the domains in tables   and   have width   except   dispose
and look n grab  this is because  the hand being empty is a fluent that is relevant to
the goal  and clauses about the location of objects are all relevant to hand empty  in all
these domains t  appears to do better than the other planners  the kmodels translation
was triggered only in the instances look and grab n m r for m      the width of these
instances  as mentioned in section      is m  independent of grid size  
we also report some additional data in table    comparing the search that results from
the use of the ff planner over the classical translations in t    to the search carried out
by conformant ff over the original conformant problems  conformant ff is a conformant
planner built on top of ff that searches explicitly in belief space  the table illustrates the
two problems faced by belief space planners mentioned in the introduction and the handle
   

ficompiling uncertainty away in conformant planning problems

problem
bomb      
bomb        
safe    
logistics        
square center  
square center   
cube center  
cube center  
blocks   
blocks   
coins   
comm   
uts k   
dispose    
dispose    
dispose    
look and grab      

nodes
    
   
   
   
    
     
    
     
  
    
    
   
  
    
    
    
    

cff
time
    
   
      
    
    
       
   
       
   
       
    
    
    
     
      
       
       

nodes sec
     
   
   
    
    
 
     
    
    
   
  
   
   
   
   
   
   

nodes
    
   
   
   
  
  
  
   
  
  
   
    
  
     
     
      
  

ff in t 
time nodes sec
    
       
    
    
 
     
    
      
    
   
    
    
    
    
   
    
 
     
   
    
    
     
    
      
    
     
    
       
     
      
     
      
   
   

table    cff over conformant problems vs  ff over translations  nodes stand for number
of nodes evaluated  time is expressed in seconds  and nodes sec stands for average
number of nodes per second  numbers shown in bold when either cff or ff
evaluate significantly less nodes  an order of magnitude reduction or more   times
preceded by   are time outs 

   

fipalacios   geffner

over them that results from the translation based approach  the belief representation and
update problem appears in the overhead of maintaining and evaluating the beliefs  and
shows in the number of nodes that are evaluated per second  while cff evaluates a few
hundred nodes per second  ff evaluates several thousands  at the same time  the heuristic
used in cff in the conformant setting  appears to be less informed that the heuristic used
by ff over the classical translations  in domains like square center n  cube center n 
blocks  and look and grab  ff needs orders of magnitude less nodes than cff to find a
plan  while the oppositive is true in dispose n m where ff evaluates many more nodes
than cff  nonetheless  even then  due to the overhead involved in carrying the beliefs  ff
manages to solve problems that cff cannot solve  for example  the instance dispose    
is solved by t  after evaluating more than half a million nodes  but times out in cff after
evaluating less than three thousand nodes 
tables    and    provide details on the results of the conformant track of the     
international planning competition  ipc    bryce   buffet         held almost at the time
where the original version of this paper was submitted  with planner binaries submitted to
the organizers a few months before  the version of t  in ipc  was different from the
version of t  used in ipc   where it was the winning entry  and different also from the
version reported in this paper  in relation  to the former  t  ipc  was a cleaner but
complete reimplementation  in relation to the latter  t  ipc  handled problems with width
greater than   in a different way  as explained in the previous section  the current version
of t    uses k  as the basic translation regardless of the width of the problem  switching to
kmodels when the search over k  fails  in the version of t  at ipc   the basic translation
was a combination of k  and k    more precisely  merges for literals l with width w l      
were generated according to k    but merges for literals l with width w l       were not
generated at all  the result was that the basic translation in t  in ipc  was lighter than
the basic translation of the current version of t  but could fail on problems with width
higher than   that the latter can solve  retrospectively  this was not a good choice  but it
didnt have much of an impact on the results  there was however a bug in the program
that prevented two width   domains  forest and dispose  to be recognized as such  and
thus resulted in the use of the kmodels translation  that is complete for all widths  but does
not scale up that well 
the other two conformant planners entered into ipc  where cpa h  and cpa c  
these are belief space planners that represent beliefs as dnf formulas  and use simple
belief state heuristics for guiding the search  tran  nguyen  pontelli    son              
the belief progression in these planners is done quite effectively  by progressing each term
in turn  according to the   approximation semantics  the potential blow up comes from the
number of terms in the dnf formula encoding the initial belief state  rather than choosing
the terms of the initial belief state as the possible initial states  these planners limit the
terms in the dnf formula to a collection of partial initial states that do not assign any
truth value to the literals that are deemed irrelevant  the resulting belief representation is
complete but may still result in an exponential number of terms  son   tu         in order
to reduce further the number of terms in this initial dnf formula  independent one of
expressions are combined  for example  two independent one of clauses oneof  x    x    and
oneof  y    y    which would give rise to   possible initial states and dnf terms  are combined
into the single one of expression oneof  x   y    x   y     that results into   possible initial
   

ficompiling uncertainty away in conformant planning problems

domain
blocks
adder
uts cycle
forest
raos keys
dispose

  instances
 
 
  
 
  
  

cpa h 
 
 
 
 
 
  

cpa c 
 
 
 
 
 
  

t  ipc 
 
 
 
 
 
  

table     data from the conformant track of the recent ipc  competition  number of
problems solved by each of the conformant planners  with time out of    mins 
in bold  entry for planner that performed best in each domain  the data is from
bryce and buffet       

states and terms  these one of expressions are independent when they can be shown not
to interact in the problem  the technique appears to be related to the notion of critical
initial states considered in section    where it was shown that plans that conform with all
critical initial states must conform also with all possible initial states  the heuristics used
by cpa h  and cpa c  are combinations of the cardinality heuristic  that measures the
number of states in a belief state  the total sum heuristic  that adds the heuristic distances
to the goal from each possible state  and the number of satisfied goals  that counts the
number of top goals achieved  these heuristics are all very simple  yet they work well on
some benchmarks 
tables    and    show data obtained from the ipc  organizers from the planner logs 
the first table appears in the ipc  report  bryce   buffet         where the new domains
forest and raos keys are explained  and shows the number of problems solved by each
planner  displaying in bold the planner that did best in each domain  the planner cpa h  
was declared the winner  as it was declared best in three domains  blocks  raos keys 
dispose   with t  doing best in two domains  uts cycle and forest   and cpa c  doing
best in one  adder  
table    shows additional details on some of the instances  in particular  the total time
taken to solve the instance and the length of the plans for each of the three planners 
in terms of domain coverage  the planners do similarly on most domains  except in
forest  where t  solved most of the instances and cpa h  solved few      vs        and
dispose  where cpa h  solved most of the instances and t  solved few        vs         
in terms of time and plan quality  cpa h  and cpa c  appear to be slightly faster
than t  on blocks  but produce much longer plans  in dispose  t  scales up better than
cpa h  and cpa c  over the size of the grids  and worse on the number of objects 
indeed  only t  manages to solve the largest grid but for a single object  dispose        
and only cpa h  and cpa c  solve instances with more than   objects in the largest grids 
as in most cases  plan lengths produced by t  are shorter  e g   the plan for dispose      
contains     actions for t        for cpa h   and     for cpa c  
dispose is actually a domain where the cardinality heuristic does very well in the generation of plans  even if the plans tend to be rather long  as discussed above  in this domain 
an agent has to scan a grid collecting a set of objects at unknown locations  and each time
   

fipalacios   geffner

the action of picking up an object from a cell that may contain the object is made  except
for the first time   the cardinality of the belief state is reduced  indeed  if initially an object
may be at positions p    p            pn   after a pick up at p    the object can be in positions
p            pn or in the gripper  after a pick up at p    the object can be in positions p            pn or
in the gripper  and so on  each pick up action decreasing the cardinality of the belief state 
until becoming a singleton belief where the object must be in the gripper with certainty 
the problem with the version of t  used in ipc  in the dispose domain  was not only
that ff explores too many states in the search  but as explained above  that it used the
expensive kmodels translation instead of the lighter k  translation that is complete for
this domain that has width    with this bug fixed  t  solves    rather than    of the   
dispose instances  still failing on some of the larger grids with many objects  but producing
much shorter plans  for example  dispose      is solved with a plan with     actions  while
cpa h  and cpa c  solve it with plans with      and      actions respectively  the
same bug surfaced in the forest domain  but it just prevented the solution of one instance
only  forest  dispose  and uts cycle have all conformant widths equal to    while the
other domains have all larger widths  see table   for the widths of blocks and adder  
the second domain in ipc  where ff got lost in the search was adder  where indeed  t 
did not solve any instance  the instance that is shown to be solved by t  in the competition
report  appears to be a mistake  similarly  the fourth instance of blocks  that is reported as
solved by cpa h   may be a mistake too  indeed  no plan for such an instance can be found
in the logs  and t  reports that the goal is unreachable in the kmodels translation that
is complete  according to t    instance four of raos key is unsolvable too  on the other
hand  t  failed on the larger uts cycle and raos key instances during the translation 
in the the first  the resulting pddls are too large and cant be loaded into ff  in the
second  the number of init clauses turns out to be quite large  above       giving rise to
a still larger set of prime implicates  above       that caused the translator to run out of
memory  the second instance of raos keys  however  is rather small and t  didnt solve it
due to a different bug  with this bug fixed  t  solves it in     seconds  producing a plan
with    actions  which compares well with the solutions produced by cpa h  and cpa c 
in     and     seconds  with    and    steps  respectively 

    non deterministic actions
the translation schemes considered are all limited to problems with deterministic actions
only  nonetheless  as we illustrate below  these schemes can be applied to non deterministic
actions as well provided suitable transformations are included  we cover these transformations briefly as a matter of illustration only 
consider a conformant problem p with non deterministic action effects a   c  oneof  s   
s            sm    where each si is a set  conjunction  of literals  and the transformed problem
p     where these effects are mapped into deterministic rules of the form a   c  hi  si   with
the expression oneof  h            hm   added to the initial situation of p     in p     the hidden hi
variables are used for encoding the uncertainty on the possible outcomes si of the action a 
it is easy to show that the non deterministic conformant problem p and the deterministic conformant problem p   are equivalent provided that only plans for p and p   are
considered where the non deterministic action a from p are executed at most once  namely 
   

ficompiling uncertainty away in conformant planning problems

problem

instance

blocks

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
   
   
   
   
   
   
   
   
   
   
    
    

adder
uts cycle

forest

raos keys
dispose

cpa h 
time
len
 
 
   
  
   
   
         
   
 
   
 
    
 

cpa c 
time
len
 
 
   
  
   
   
   
   
    

 
 
 

   

  

    

  

   
   
   
   
   
 
   
    
    
    
    
    
    

  
  
  
   
   
   
   
   
    
    
   
    
    

 
   
   
   
   
   
   
    
    
     
    
     

  
  
  
   
   
   
   
   
    
    
   
    

t  ipc 
time len
   
 
   
  
    
  

   
   
   
   
   
   
    
    
    
     

 
 
  
  
  
  
   
   
   
   

 

  

   
   
     

  
   
   

   
     

   
   

   

   

  

   

table     running time and plan length from ipc  logs  time in seconds  blanks stand
for time or memory out  only    of the    dispose n m instances shown  at
ipc   size n of grid ranged from   to     while number m of objects  from   to
    t  scales up best on n and worst on m 

   

fipalacios   geffner

a correspondence exists between the conformant plans for p that use such actions at most
once with the conformant plans for p   that use the same actions at most once too  on the
other hand  a conformant plan for p   where these actions are done many times will not
necessarily represent a conformant plan for p   indeed  if a non deterministically moves an
agent up or right in a square grid n  n  starting in the bottom left corner  n actions a in
a row would leave the agent at either the top left corner or the bottom right corner in p    
and anywhere at manhattan distance n from the origin in p  the divergence between p
and p     however  does not arise if non deterministic actions are executed at most once 
building on this idea  a non deterministic conformant planner can be obtained from a
deterministic conformant planner in the following way  for the non deterministic problem
p   let p  be the problem p   above  with the additional constraint that the actions a in
p  arising from the non deterministic actions in p can be executed at most once  this
is easily achieved by adding a precondition enabled a  to a that is true initially and that
a sets to false  let then p  represent the deterministic conformant problem where each
non deterministic action a in p is mapped into   deterministic actions  each executable
only once  and each having its own hidden fluents h            hm with the oneof  h            hm  
expression in the initial situation  similarly  let pi be the deterministic problem that results
from encoding each non deterministic action in p with i deterministic copies 
from this encoding  a simple iterative conformant planner for non deterministic problems p can be defined in terms of a conformant planner for deterministic problems by
invoking the latter upon p    p    p    and so on  until a solution is reported  the reported
solution uses each copy of a non deterministic action at most once  and thus encodes a
solution to the original problem 
we have implemented this strategy on top of t  with an additional refinement that
takes advantage of the nature of the kt m translation  where assumptions about the initial
situation are maintained explicitly in tags  basically  non deterministic actions a in pi are
allowed to be executed more than once provided that all the literals kl hi that depend
on a particular outcome of these actions  si   are erased  this is implemented by means
of an additional reset a  action in pi whose unconditional effect is enabled a   i e   the
action a can then be done again  and whose conditional effects are kl  kl hi and
kl  kl hi for i              m  namely  literals kl hi where the truth of l depends
on a particular non deterministic outcome  si   are erased  except when l is true with no
assumptions  i e  when kl is true  then non deterministic actions a can be executed more
than once in a plan provided that each occurrence of a  except for the first one  is preceded
by a reset a  action 
table    compares the resulting non deterministic planner with mbp and kacmbp
on a number of non deterministic problems considered in the mbp and kacmbp papers 
we have just added an additional domain  slippery gripper  sgripper   that is similar to
classical gripper where a number of balls have to be moved from room a to b  except
that the robot cannot move from a to b directly  but has a non deterministic move action
move a  c  d  that moves the robot from a to either c or d  a typical plan for moving
two balls from a to b is to pick them at a  move to c or d  move from c to b  and from
d to b  finally dropping the balls at b 
for the deterministic conformant planner  t    used in the non deterministic setting we
added the following modification  merges are not introduced only for precondition and goal
   

ficompiling uncertainty away in conformant planning problems

problem
sgripper   
sgripper   
sgripper   
btuc    
btuc    
btuc    
btuc    
btuc    
bmtuc      
bmtuc      
bmtuc      
bmtuc      
bmtuc      
bmtuc       
bmtuc       
bmtuc        
nondet ring  
nondet ring   
nondet ring   
nondet ring   
nondet ring   
nondet ring  key  
nondet ring  key   
nondet ring  key   
nondet ring  key   
nondet ring  key   
nondet ring  key   

t 
time len
   
  
    
  
  
   
   
   
   
   
  
   
        
  
   
   
  
   
  
   
  
   
   
   
   
   
   
        
        
    
  
   h
   h


   h
     gb





mbp
time
len
   h
   h

   h
   h



    
  
   h
   h





 
  
   
  
         
   h

   
  
    
   
         
     gb



kacmbp
time
len
   
  
   
   
    
   
 
   
   
   
    
   
    
   
    
   
   
  
   
  
   
  
   
   
          
    
   
   h
   h
   
  
   
   
   
   
   
   
          
   
  
 
   
    
   
          
           
   h

table     non deterministic problems  all problems except sgripper are from mbp and
kacmbp  these problems were modified to render a simple translation into
pddl  in particular  complex preconditions were moved in as conditions  times
reported in seconds and rounded to the closest decimal   means time or memory
out for smaller instances 

literals but for all literals  the reason is that in this setting it pays to remove the uncertainty
of all literals when the reset mechanism is used  indeed  provided with this simple change
and the reset mechanism  in none of the problems we had to move beyond p   a single copy
of each non deterministic action  even if in all the domains non deterministic actions are
required many times in the plans  e g   if there are more than   balls in room a  
as it can be seen from the table  t  does better than mbp on these collection of nondeterministic domains  although not as well as kacmbp  in particular  in the nondetring and non det ring  key domains  in any case  the results obtained with t  on these
domains are quite meaningful  in all cases where t  failed to solved a problem  the reason
was that the classical planner  ff  got lost in the search for plans  something that may
improve with further advances in classical planning technology 

   

fipalacios   geffner

    related work
most recent conformant planners such as cff  pond  and mbp cast conformant planning
as an heuristic search problem in belief space  bonet   geffner         compact belief
representations and informed heuristic functions  however  are critical for making these approach work  as an effective belief representation  these planners use sat and obdds
techniques that while intractable in the worst case often exhibit good behavior on average 
as heuristics  on the other hand  they use fixed cardinality heuristics that count the number
of states that are possible for a given belief state  a tractable operation on obdd representations  or heuristics obtained from a relaxed planning graph suitably extended to take
uncertain information into account  these heuristics appear to work well in some domains
but not in others  from this perspective  the translation based approach provides a handle
on the two problems  belief states in p become plain states in the translation kt m  p   
that is then solved using classical heuristics  we have also established the conditions under
which this belief representation is compact and complete 
a sound but incomplete approach to planning with incomplete information is advanced
by petrick and bacchus        that represent belief states as formulas  in order to make
belief updates efficient though  several approximations are introduced  and in particular 
while existing disjunctions can be carried from one belief to the next  no new disjunctions
are added  this imposes a limitation on the type of problems that can be handled  the
two other limitations of this approach are that domains must be crafted by hand  and that
no control information is derived from the domains so that the search for plans is blind 
our approach can be understood as providing a solution to these two problems too  on
the one hand  the move to the knowledge level is done automatically  on the other  the
problem lifted to the knowledge level is solved by classical planners able to search with
control information derived automatically from the new representation 
a third thread of work related to our approach arises from the so called   approximation
semantics  baral   son         in the   approximation semantics  belief states b are represented not by sets of states but by a single   valued state where fluents can be true  false  or
unknown  in proposition   above  a correspondence was established between the plans for
p that are conformant according to the   approximation semantics and the classical plans
for the translation k   p    which in turns is an instance of the more general translation
ki  p   that is complete for problems with width i      the semantics of the translation
k  is thus related to the   approximation semantics  yet the k  translation delivers something more  a computational method for obtaining conformant plans that comply with the
  approximation semantics using a classical planner 
the   approximation and the basic k  translation are too weak for dealing with the
existing benchmarks  the translations ki extend k  for problems of higher width by
replacing the set of fluents kl by fluents kl t where the tags t encode assumptions about
the initial situation  the extensions of the   approximation semantics in the context of
conformant planning have taken a different form  switching from a single   valued state
for representing beliefs to sets of   valued states  each   valued state progressed efficiently
and independently of the others  son  tu  gelfond    morales         the initial set of
  valued states is obtained by forcing states to assign a boolean truth value  true or false 
to a number of fluents  crucial for this approach to work is the number of such fluents 
   

ficompiling uncertainty away in conformant planning problems

belief representation and update are exponential in it  the conditions that ensure the
completeness of this extension of the   approximation semantics can be expressed in terms
of a relevance analysis similar to the one underlying our analysis of width  son   tu 
       the fluents that must be set to true or false in each initial   valued state are those
appearing in a clause in ci  l  for a precondition or goal literal l  in particular  if in the
initial situation there are n tautologies pi pi   each relevant to a precondition or goal literal
l  then the number of initial   valued states required for completeness is exponential in n  as
each has to make each fluent pi true or false  the difference with our approach can be seen
when each of the tautologies pi  pi is relevant to a unique precondition or goal literal li  
in such a case  the number of   valued or partial states required for completeness remains
exponential in n  while the resulting problem has width   and thus can be solved with the
k  translation that involves tags with a single literal  in other words  while the tags used
in our translation scheme encode the local contexts required by the different literals in the
problem  the initial   valued states  son   tu        encode their possible combinations in
the form of global contexts  these global contexts correspond to the consistent combinations
of such local contexts  which may thus be exponential in number even if the problem has
bounded width  the planners cpa h  and cpa c   discussed above in the context of
the conformant track of the recent      int  planning competition  ipc    build on this
approach  but reduce the number of partial initial states required using a technique that can
replace many one of expressions by a single one  tran et al                a simplification
related to the notion of critical initial states discussed in section   
another difference with the   valued approach  son et al         son   tu         is
that the translation approach not only addresses the representation of beliefs but also the
computation of conformant plans  once a conformant problem p is translated into a problem
kt m  p    it can be solved by a classical planner  the approaches that have been defined on
top of the   approximation semantics  like the knowledge level approach to planning with
incomplete information by petrick and bacchus         need a way to guide the search for
plans in the simplified belief space  while the search by petrick and bacchus        is blind
 iterative deepening   the search by son et al          son and tu        is guided by a
combination of simple heuristics such as cardinality or subgoal counting 

    summary
while few practical problems are purely conformant  the ability to find conformant plans is
needed in contingent settings where conformant situations are an special case  in this paper 
we have introduced a new approach to conformant planning where conformant problems p
are converted into classical planning problems kt m  p   that are then solved by a classical
planner  we have also studied the conditions under which this general translation is sound
and complete  the translation depends on two parameters  a set of tags  referring to local
contexts in the initial situation  and a set of merges that stand for valid disjunctions of
tags  we have seen how different translations  such as ks  and kmodels  can be obtained
from suitable choices of tags and merges  and have introduced a measure of complexity in
conformant planning called conformant width  and a translation scheme ki that is polynomial for a fixed i and complete for problems with width bounded by i  we have also shown
that most conformant benchmarks have width    have developed a conformant planner t 
   

fipalacios   geffner

based on these translations  and have shown that this planner exhibits a good performance
in comparison with existing conformant planners  recently  we have explored the use of
these ideas in the more general setting of contingent planning  albore  palacios    geffner 
      

acknowledgments
we thank alex albore for help with the syntax of mbp and kacmbp  and pierre marquis
for kindly answering a question about the complexity of a deductive task  we also thank
the anonymous reviewers for useful comments  h  geffner is partially supported by grant
tin           c      

appendix a  proofs
p below stands for a conformant planning problem p   hf  i  o  gi and kt m  p    
hf     i     o    g  i for its translation  propositions and theorems in the body of the paper
appear in the appendix with the same numbers  while new lemmas and propositions have
numbers preceded by the letters a and b  for appendix a and b   the conformant problem
p and the classical problems p s and kt m  p   that arise from p are all assumed to be
consistent  consistency issues are important  and they are addressed in more detail in the
second part of this appendix where it is shown that if p is consistent  kt m  p   is consistent
too  appendix b   for a consistent classical problem p     the standard progression lemma
applies  namely  a literal l is achieved by an applicable action sequence        a  where
 is an action sequence and a is an action iff a   achieves c for a rule a   c  l in p    
or b   achieves l and the negation l  of a literal l  in the body c   of each rule in p   of
the form a   c    l  see theorem b   below  
lemma a    let  be an action sequence applicable in both p and k   p    then if 
achieves kl in k   p     achieves l in p  
proof  by induction on the length of   if  is empty and  achieves kl in k   p    then
kl must be in i     and hence l must be in i  so that  achieves l in p  
likewise  if        a achieves kl in k   p   then a  there is rule a   kc  kl in
k   p    such that  achieves kc in k   p    or b   achieves kl in k   p   and for each
rule a   kc    kl in k   p     achieves kl  in k   p   for some l  in c    
if a  is true  then p must contain a rule a   c  l  and by inductive hypothesis  
must achieve c in p   and therefore         a must achieve l in p   if b  is true  by
inductive hypothesis   must achieve l in p along with l  for some literal l  in the body
c   of each rule a   c    l  and thus        a must achieve l in p too 
lemma a    if an action sequence  is applicable in k   p    then  is applicable in p  
proof  if  is empty  this is trivial  likewise  if        a is applicable in k   p     is
applicable in k   p    and thus by inductive hypothesis   is applicable in p   also since 
  a is applicable in k   p     must achieve the literals kl in k   p   for each precondition
l of a  but then from lemma a     must achieve the literals l for the same preconditions
in p   and thus  the sequence        a is applicable in p  
   

ficompiling uncertainty away in conformant planning problems

proposition   if  is a classical plan for k   p    then  is a conformant plan for p  
proof  direct from lemma a   once we consider a problem p   similar to p but with a new
dummy action ag whose preconditions are the goals g of p   then if  is a plan for k   p   
  ag is applicable in k   p      and by lemma a      ag is applicable in p     which implies
that  is applicable in p and achieves g  and thus  that  is a plan for p  
proposition   an action sequence  is a classical plan for k   p   iff  is a conformant
plan for p according to the   approximation semantics 
proof  let us say that an action sequence    a            an is   applicable in p and   achieves
a literal l in p if the belief sequence b            bn   generated according to the   approximation
semantics is such that the preconditions of the actions ai in  are true in bi   and the goals
are true in bn   respectively  from the definition of the   approximation semantics  and
the consistency of p    an applicable action sequence  thus   achieves a literal l in p iff 
is empty and l  i  or         a and a  a   c  l is an effect of p and      achieves each
literal l  in c  or b       achieves l and for all effects a   c    l in p        achieves l 
for some l   c     these  however  are the conditions under which  achieves the literal kl
in k   p   once a sequence   achieving a literal l in p  is replaced by a sequence achieving
the literal kl in k   p    thus  an action sequence  that is applicable in k   p   and
  applicable in p achieves a literal kl in k   p   iff    achieves the literal l in p   while 
is applicable to k   p   iff it is   applicable to p   with the last part following from the first
using induction on the plan length 
definition a    for an action a in p   define a to be the action sequence where a is
followed by all merges in kt m  p   in arbitrary order  similarly  if    a            ai is an
action sequence in p   define   to be the action sequence     a            an in kt m  p   
lemma a    let  be an action sequence such that  is applicable in p and   is applicable
in a valid translation kt m  p    if   achieves kl t in kt m  p    then  achieves l in
p s for all possible initial states s that satisfy t 
proof  for an empty   if   achieves kl t  from the definition of kt m  p   and since
i    t  l  l must be in any such s  and thus  must achieve l in p s 

likewise  if        a and t is not the empty tag    
      a achieves kl t in

kt m  p   iff a   achieves kc t in kt m  p   for a rule a   kc t  kl t in kt m  p   
or b    achieves kl t  and for any rule a   kc    t  kl t    achieves kl   t in
kt m  p   for some l  in c    merge actions do not delete positive literals kl t  
if a  by inductive hypothesis   achieves c in p s for each possible initial state s that
satisfies t  and hence        a achieves l in p s from the rule a   c  l that must be in
p   if b  by inductive hypothesis   achieves l and l  in p s  for some l  in the body of
each rule a   c    l in p   and thus        a achieves l in p s 
v
for the empty tag t     a third case must be considered  a merge action t  m kl t  
       a achieving kl in k
kl in a may be the cause for the action sequence   
t m  p   



in such a case  the sequence    a  and hence    a   must achieve kl t  for each  nonempty  t   m in kt m  p    and hence from the inductive hypothesis and the two cases
above  the sequence   a must achieve l in p s for each possible initial state s that satisfies
   

fipalacios   geffner

any such t    yet  since the merge m is valid  all possible initial states s must satisfy one
such t    and thus  must achieve l in p s for all possible initial states s  that are the initial
states that satisfy t    
lemma a    if   is applicable in a valid translation kt m  p    then  is applicable in p  
       a is applicable in k
proof  if  is empty  this is direct  for        a  if   
t m  p   

then  is applicable in kt m  p    achieving kl for each precondition l of a  and hence
from the inductive hypothesis   is applicable in p   and from lemma a     must achieve
l for each precondition l of a  and thus        a is applicable in p  

theorem   the translation kt m  p   is sound provided that all merges in m are valid
and all tags in t are consistent 
proof  consider the problem p   that is similar to p but with a new dummy action ag
whose preconditions are the goals g of p   we have then that   is a plan for kt m  p   iff
    ag is applicable in kt m  p      which from lemma a   implies that   ag is applicable
in p     which means that  is a plan for p  
lemma a    let  be an action sequence such that  is applicable in p and   is applicable
in ks   p    if  achieves l in p s for some possible initial state s    achieves kl s in
ks   p   
proof  if  is empty and  achieves l in p s  then l  s  and since i    s  l  kl s must
be in i   and thus   achieves kl s in ks   p   
likewise  if        a achieves l in p s then a  there is rule a   c  l such that
 achieves c in p s  or b   achieves l and for any rule a   c    l   achieves l  in
ks   p   for some l   c    
if a   by inductive hypothesis    achieves kc s in ks   p   and  from rule a   kc s 
       a achieves kl s  merges in a do
kl s      a must achieve kl s  and thus    
not delete positive literals kl t  
if b   by inductive hypothesis    achieves kl s and kl   s in ks   p   for some l 
in the body of each rule a   c    l in p   and therefore     a achieves kl s  and so does
       a  
  
lemma a    if  is applicable in p     is applicable in ks   p   
proof  if  is empty  this is trivial  if        a is applicable in p   then  must be
applicable in p and must achieve each precondition l of a in p s for every possible initial
state s  s  s    from the inductive hypothesis    must then be applicable in ks   p   
and from lemma a    it v
must achieve the literals kl s for all s  s    and then  the last
merge action with effect ss  kl s  kl in   must achieve kl  and so does     and
therefore      a is applicable in ks   p   
theorem   if  is a conformant plan for p   then there is a classical plan    for ks   p  
such that  is the result of dropping the merge actions from     
   

ficompiling uncertainty away in conformant planning problems

proof  direct from lemma a   if we consider a problem p   similar to p but with a new
action ag whose preconditions are the goals g of p   if  is a plan for p   the sequence   ag
is applicable in p     and from lemma a        ag is applicable in ks   p      and thus   is a
plan for ks   p   
definition a    rel s  l  stands for the set of literals l  in s that are relevant to l in p  
rel s  l     l    l   s and l  is relevant to l   
definition a    t stands for the deductive closure of t under i 
t     l   i  t    l   
theorem a     let m    t            tn   be a covering merge for a literal l in a valid translation kt m  p   for a problem p whose initial situation is in prime implicate form  then
for each tag ti in m there must be a possible initial state s of p such that rel s  l   ti  
proof  assume otherwise that each state s satisfying i makes true a literal ls relevant to
l such that ls   ti   if we then take c to be the disjunction of such literals ls over all the
states s that satisfy i  we obtain that i entails c  which since i is in prime implicate form 
means that c contains a tautology c  or is subsumed by a clause c   in i  but  in either case 
this is a contradiction  as all the literals in c  or c   are relevant to l  and hence ti   where ti
is part of the covering merge m  must contain a literal in either c  or c     and hence in c 
lemma a     let  be an action sequence such that  is applicable in p and   is applicable in a covering translation kt m  p    then  if  achieves l in p s for some possible
initial state s and there is a tag t in t such that rel s  l   t     achieves kl t in
kt m  p   
proof  if  is empty and  achieves l in p s  then l is in s and thus  in rel s  l   since
rel s  l   t   then l  t   and thus kl t is in the initial situation i   of kt m  p    and
  achieves kl t in kt m  p    likewise  if        a achieves l in p s  then a  there
is a rule a   c  l in p such that  achieves c in p s  or b   achieves l in p s and
for each rule a   c    l   achieves l  in p s for some l  in c     if a  by inductive
hypothesis    achieves kc t  and from the support rule a   kc t  kl t in kt m  p   
       a   as the merges in a cannot
    a must achieve kl t in kt m  p    and so must   
delete a positive literal kl t  if b  by inductive hypothesis    achieves kl t  and for each
cancellation rule a   kc    t  kl t arising from the rule a   c    l in p     must
       a  
achieve kl   t for some literal l   c     this means that     a  and therefore    
must achieve kl t 
lemma a     let kt m  p   be a covering translation of p   then if  is applicable in p  
  is applicable in kt m  p   
proof  if  is empty  this is direct  else  if        a is applicable in p   then  must be
applicable in p where it must achieve each literal l in p re a   and therefore  by inductive
hypothesis   must be applicable in kt m  p    then  let m    t            tn   be a covering
merge for l  p re a  in kt m  p    from theorem a     for each ti  m there must be a
   

fipalacios   geffner

possible initial state s such that rel s  l   ti   and then from lemma a      achieving l in
p s implies   achieving kl ti in kt m  p    since this is true for all ti  m and  achieves
l  p re a  in p s for all possible initial states s  then it follows that   achieves kl ti
for all ti  m in kt m  p    and therefore that   achieves kl in kt mv p   as   ends with
a sequence of merges that include the action merge am l with effect ti m kl ti  kl 
       a is applicable in k
as a result    
t m  p   
theorem    covering translations kt m  p   are complete  i e   if  is a conformant plan
for p   then there is a classical plan    for kt m  p   such that  is    with the merge actions
removed 
proof  the theorem follows trivially from lemma a    by having a problem p   that is like
p but with an additional  dummy action ag such that the goals g of p are the preconditions
of ag   the action sequence  is a plan for p iff the action sequence   ag is applicable in p    
which due to lemma a    implies that the action sequence     ag is applicable in kt m  p    
which in turn is true iff the action sequence   is a plan for kt m  p    the sequence   in
turn  is the sequence   with all the merge actions removed 
theorem    the translation kmodels p   is sound and complete 
proof  direct from the merges m generated by kmodels for each precondition and goal
literals l  clearly these merges are all valid  their tags are consistent with i  and they
cover l  the models of ci  l  all satisfy ci  l    thus the result follows from theorems  
and    
proposition    the width w p   of p can be determined in time that is exponential in
w p   
proof  if m is the number of clauses in ci  l   then there are at most mi sets of clauses c in
ci  l  such that  c    i  each clause in one such set must have at most n literals  where n is
the number of fluents in p   and hence  if one literal from each clause in c is collected  we end
up with at most ni sets of literals of size no greater than i  some of which are inconsistent
with i and some of which are consistent and minimal  no other consistent set in the collection
is properly included   both tests being polynomial given that i is in prime implicate form 
thus constructing the cover c c  for a set of clauses c with  c    i is exponential in i 
while checking whether one such cover satisfies ci  l  is a polynomial operation provided
that i is in prime implicate form  indeed  if c c     t            tn    computing the closures
ti for each ti  c c   when i is in pi  and testing whether each ti intersects each clause
in ci  l  are polynomial operations  the former reducing to checking for each literal l 
whether i    ti  l     thus for computing width l   we generate all sets c of clauses
in ci  l  with  c    i  starting with i      increasing i one by one until for one such set 
c c  satisfies ci  l   this computation is exponential in w l   and the computation over
all preconditions and goal literals in p is exponential in w p   
proposition    the width of p is such that    w p    n  where n is the number of
fluents whose value in the initial situation is not known 
   

ficompiling uncertainty away in conformant planning problems

proof  the inequality    w p   is direct as w l  is defined as the size  c  of the minimal set
of clauses c in ci  l  such that c c  satisfies ci  l   and w p     w l  for some precondition
and goal literal l  the inequality w p    n follows by noticing that for the set c of clauses
given by the tautologies l   l  in ci  l   c c  must satisfy each clause c in ci  l   as each
t  c c  must assign a truth value to each literal in c  and if inconsistent with c  it will be
inconsistent with i and thus pruned from c c   finally  the max number of such tautologies
in ci  l  is the number of fluents l  such that neither l  nor l  are unit clauses in i 
theorem    for a fixed i  the translation ki  p   is sound  polynomial  and if w p    i 
covering and complete 
proof  for soundness  we just need to prove that all merges m in ki  p   are valid and that
all tags t in ki  p   are consistent  the soundness follows from theorem    the merges
m for a literal l in ki  p   are given by the covers c c  of collections c of i or less clauses
in ci  l  and clearly since
each model m of i must satisfy ci  l   it must satisfy some
w
t  c c  so that i    tm t for m   c c   at the same time  from the definition of the
cover c c   each of these tags t must be consistent with i 
for proving that ki is polynomial for a fixed i  we follow ideas similar to the ones used
in the proof of proposition    above  where we have shown that the width of p can be
determined in time that is exponential in w p   and polynomial in the number of clauses
and fluents in p   for a fixed i  the number of sets of clauses c in ci  l  with size  c   i is
polynomial  and the complexity of computing the covers c c  for such sets  and hence  the
merges m for l in ki  p   is polynomial too  thus  the whole translation ki  p   for a fixed
i is polynomial in the number of clauses  fluents  and rules in p  
finally  for proving completeness  if w p    i  then w l   i for each precondition and
goal literal l in p   therefore  for each such literal l  there is a set c of clauses in ci  l 
such that c c  satisfies ci  l   the translation ki  p   will then generate a unique merge
for l that covers l  since ki  p   is a valid translation  this means that ki  p   is a covering
translation  that is then complete  by virtue of theorem    
lemma a     if l  is relevant to l and rel s  l   rel s    l   then rel s  l     rel s    l    
proof  if l   is in rel s  l     then l   is relevant to l    and since l  is relevant to l and the
relevance relation is transitive  l   is relevant to l  thus  l   is in rel s  l  and therefore 
since rel s  l   rel s    l   l   is in rel s    l   but then l   is in s  and since it is relevant
to l    l   is in rel s    l    
proposition    let s and s  be two states and let  be an action sequence applicable in
the classical problems p s and p s    then if  achieves a literal l in p s  and rel s    l  
rel s  l    achieves the literal l in p s 
proof  by induction on the length of   if  is empty  and  achieves a literal l in p s    l
must be in s    and since l is relevant to itself  l  rel s    l   then as rel s    l   rel s  l  
l must be in s  and thus  achieves l in p s 
   

fipalacios   geffner

likewise  if        a achieves l in p s  then a  there is rule a   c  l such that 
achieves c in p s    or b   achieves l in p s  and for any rule a   c    l   achieves
l  in p s  for some l   c    
if a   must achieve each literal li  c in p s    since li is relevant to l and rel s    l  
rel s  l   by lemma a     rel s    li    rel s  li    then  by inductive hypothesis  the plan
 must achieve li in p s for each li  c  and thus        a must achieve l in p s
if b  since each such l  is relevant to l  as l  is relevant to l   and rel s    l  
rel s  l   by lemma a     rel s    l     rel s  l     and thus by inductive hypothesis  
must achieve l  in p s and also l  so that        a must achieve l in p s 
lemma a     if s and s   are two collection of states such that for every state s in s and
every precondition and goal literal l in p   there is a state s  in s   such that rel s    l  
rel s  l   then if  is applicable in p s      is applicable in p s 
proof  by induction on the length of   if  is empty  it is obvious  if        a is applicable
in p s     then  is applicable in p s   and  by inductive hypothesis   is applicable in p s 
we need to prove that  achieves the preconditions of action a in p s 
for any l  p rec a  and any s  s  from the hypothesis  there is a state s   s   such
that rel s    l   rel s  l   from proposition     and since  achieves l in p s     must
achieve l in p s  since the argument applies to any s  s   achieves l in p s  and thus
       a must be applicable in p s 
proposition    if s and s   are two collections of states such that for every state s in s
and every precondition and goal literal l in p   there is a state s  in s   such that rel s    l  
rel s  l   then if  is a plan for p that conforms with s      is a plan for p that conforms
with s 
proof  from lemma a     we consider a problem p   similar to p but with a new action
ag whose preconditions are the goals g of p   if  is a plan for p that conforms with s    
then the action sequence   ag is applicable in p    s     and then from the lemma    ag is
applicable in p    s  and thus  must be a plan for p s
proposition    s   is a basis for p if for every possible initial state s of p and every
precondition and goal literal l in p   s   contains a state s  such that rel s    l   rel s  l  
proof  direct from proposition     by considering s to be the set of possible initial states
of p  
proposition    if the initial situation i is in prime implicate form and m    t            tn  
is a merge that covers a literal l in p   then the set s ti   l  of possible initial states s of p
such that rel s  l   ti is non empty 
proof  direct from theorem a    
theorem    let kt m  p   be a covering translation and let s   stand for the collection of
states s ti   l  where l is a precondition or goal literal of p and ti is a tag in a merge m
that covers l  then s   is a basis for p  
   

ficompiling uncertainty away in conformant planning problems

proof  we show that for every possible initial state s and any precondition and goal literal
l  s   in the theorem contains a state s  such that rel s    l   rel s  l   the result then
follows from proposition     indeed  any such state s must satisfy a tag ti in a covering
merge m    t            tn   for l  as these merges are valid  but from theorem a     there must
be a possible initial state s  such that rel s    l   ti   and therefore  rel s    l   rel s  l  as
s must satisfy ti and possibly other literals l  that are relevant to l 
theorem    if p is a conformant planning problem with bounded width  then p admits
a basis of polynomial size 
proof  if w p    i for a fixed i  ki  p   is a covering translation with a polynomial number
of merges and tags  and in such case  the basis s   for p defined by theorem    contains a
polynomial number of states  regardless of the number of possible initial states 

appendix b  consistency
we have been assuming throughout the paper that the conformant planning problems p
and their translations kt m  p   are consistent  in this section we make this notion precise 
explain why it is needed  and prove that kt m  p   is consistent if p is  for the proof  we
take into account that the heads kl of the merge actions am l in kt m  p    are extended
with the literals kl  for the literals l  that are mutex with l in p  see definition    
we start at the beginning assuming that states are not truth assignments but sets of
literals over the fluents of the language  a state is complete if for every literal l  l or l is
in s  and consistent if for no literal both l and l are in s  complete and consistent
states represent truth assignments over the fluents f and the consistency of p and of
the translation kt m  p   ensures that all applicable action sequences  map complete and
consistent states s into complete and consistent states s    once this is guaranteed  complete
and consistent states can be referred to simply as states which is what we have done in the
paper 
given a complete state s and an action a applicable in s  the next state sa is
sa    s   del a  s    add a  s 
where
add a  s     l   a   c  l in p and c  s 
and
del a  s     l   l  add a  s    
it follows from this that sa is a complete state if s is a complete state  as the action a
only deletes a literal l in s if l is added by a in s  on the other hand  s may be consistent
and sa inconsistent  as for example  when there are rules a   c  l and a   c    l such
that both c and c   are in s  in order to exclude this possibility  ensuring that all reachable
states are complete and consistent  and thus represent genuine truth assignments over the
fluents in f   a consistency condition on p is needed 
definition b    consistency   a classical or conformant problem p   hf  i  o  gi is consistent if the initial situation i is logically consistent and every pair of complementary
literals l and l is mutex in p  
   

fipalacios   geffner

in a consistent classical problem p   all the reachable states are complete and consistent 
and the standard progression lemma used in the preceding proofs holds 
theorem b    progression   an action sequence        a applicable in the complete and
consistent state s achieves a literal l in a consistent classical problem p iff a   achieves
the body c of a rule a   c  l in p   or b   achieves l and for every rule a   c    l 
 achieves l  for a literal l  in c    
we will see below that if a conformant problem p is consistent in this sense  so will be
any valid translation kt m  p    we have tested all the benchmarks considered in this paper
for consistency and found all of them to be consistent except for two domains that we have
introduced elsewhere    dispose and look and grab  in these cases  since the consistency
of the classical problem kt m  p   cannot be inferred from the consistency of p   it can
be checked explicitly using definition b    or similarly  the plans that are obtained from
kt m  p   can be checked for consistency as indicated in section    the soundness of these
plans is ensured provided that they never trigger conflicting effects kl t and kl t   
proof  the proof of theorem b   does not rest on a particular definition of mutexes  just
that mutex atoms are not both true in a reachable state  in a consistent problem p   an
applicable action sequence  maps s into a complete and consistent state s  that represents
a truth assignment  then  the action sequence        a achieves l iff c  l  add a  s   
or d  l  s  and l   del a  s     condition a in the theorem  however  is equivalent to c 
and condition b in the theorem  is equivalent to d  indeed  l   del a  s    iff for each rule
a   c    l there is a literal l   c   such that l    s    which  given that s  is complete and
consistent  is true iff l   s   this is precisely where consistency is needed  else l   s 
would not imply l    s    
the notion of mutex used in the definition of consistency expresses a guarantee that
a pair of literals is not true in a reachable state  sufficient and polynomial conditions for
mutual exclusivity and other type of invariants have been defined in various papers  here
we follow the definition by bonet and geffner        
definition b    mutex set   a mutex set is a collection r of unordered literals pairs
 l  l    over a classical or conformant problem p such that 
   for no pair  l  l    in r  both l and l  are in a possible initial state s 
   if a   c  l and a   c    l  are two rules for the same action where  l  l    is a pair
in r  then p re a   c  c   is mutex in r  and
   if a   c  l is a rule in p for a literal l in a pair  l  l    in r  then either a  l    l 
b  p re a   c is mutex with l  in r  or c  p re a   c implies c   in r for a rule
a   c    l  in p  
    the consistency of the two domains    dispose and look and grab  can be established however if a
definition of mutexes slightly stronger than the one below is used  it actually suffices to change the
expression p re a   c in clause  c  of the definition of mutex sets below by p re a   c   l    

   

ficompiling uncertainty away in conformant planning problems

in this definition  a pair is said to be mutex in r if it belongs to r  a set of literals s is
said to be mutex in r if s contains a pair in r  and a set of literals s is said to imply a set
of literals s   in r when s is mutex in r with the complement l of each literal l in s     s 
it easy to verify that if r  and r  are mutex sets  their union r   r  is a mutex set 
and thus that there is a maximal mutex set for p that we denote as r   the pairs in r
are just called mutexes 
for simplicity and without loss of generality  we will assume that preconditions p re a 
are empty  indeed  it is simple to show that the mutexes of a problem p remain the same
if preconditions are pushed in as conditions  we also assume that no condition c in a rule
c  l in p is mutex  as these rules can be simply pruned  in addition  we assume that no
literal l is mutex with a pair of complementary literals l  and l    as then l cannot be
true in a reachable state  and thus  can be pruned as well 
the definition of mutexes is sound  meaning that no pair in a mutex set can be true in
a reachable state 
theorem b    if  l  l    is a pair in a mutex set r of a classical or conformant problem
p   then for no reachable state s in p    l  l     s 
proof  we proceed inductively  clearly  l and l  cannot be part of a possible initial state  as
this is ruled out by the definition of mutex sets  thus  let us assume as inductive hypothesis
that l and l  are not part of any state s reachable in less than i steps  and let us prove
that the same is true for the states s    sa that are reachable from s in one step  clearly if
l and l  belong to s    then either a  both l and l  belong to add a  s   or b  l belongs
to add a  s  and l  belongs to s but not to del a  s   we show that this is not possible 
for a  p must comprise rules a   c  l and a   c    l  such that c  c    s  yet from
the definition of mutex sets  c  c   must be mutex  and from the inductive hypothesis then
c  c     s  for b  there must be a rule a   c  l with c  s  but then from l   s
and the inductive hypothesis  it follows that l  is not mutex with c in r  and thus  from
the mutex set definition  that either l    l or c implies c   for a rule a   c    l    in
the first case  however  due to the rule a   c  l and c  s  l   del a  s   while in the
second case  from the completeness of all reachable states  we must have c    s  and hence
l   del a  s   contradicting b in both cases 
provided that the initial situation i of a conformant planning problem p is in prime
implicate form  computing the largest mutex set r and testing the consistency of p are
polynomial time operations  for the former  one starts with the set of literal pairs and
then iteratively drops from this set the pairs that do not comply with the definition until
reaching a fixed point  bonet   geffner        
we move on now to prove that if a conformant problem p is consistent  so is a valid
translation kt m  p    the consistency of the classical problems p s for possible initial
states s is direct  as the set of mutexes in p is a subset of the set of mutexes in p s where
the initial situation is more constrained 
proposition b    mutex set rt    for a valid translation kt m  p   of a consistent conformant problem p   define rt to be the set of  unordered  literals pairs  kl t  kl   t    and
 kl t  kl   t  where  l  l    is a mutex in p   and t and t  are two tags jointly satisfiable
with i  i      t  t      then rt is a mutex set in kt m  p   
   

fipalacios   geffner

it follows from this that kt m  p   is consistent if p is consistent  as then l    l is
mutex with l in p   and so  kl t  kl t  must be a mutex in rt  
theorem b    consistency kt m  p     a valid translation kt m  p   is consistent if p is
consistent 
the consistency of the translation k   p   follows as a special case  as k   p   is kt m  p  
with an empty set of merges m and a set of tags t containing only the empty tag  we are
left to prove proposition b   
proof of proposition b    we must show that the set rt comprised of the pairs  kl t  kl   t   
and  kl t  kl   t  for l  mutex with l in p   and tags t and t  jointly satisfiable with
i  is a set that complies with clauses       and   of definition b    we go one clause at a
time 
   no pair in rt can be true initially in kt m  p     hf     i     o    g  i for jointly satisfiable
i  t  and t    indeed  if both kl t and kl   t  are in i   there must be a possible initial
state satisfying t and t  where l and l  are true in contradiction with l and l  being
mutex in p   similarly  if kl t is in i   but kl   t not  it must be the case that
i    t  l and i     t  l    so that there must be some possible initial state of p
where t  l  and l  hold  a contradiction with l and l  being mutex in p too 
   if there is an action a with rules for kl t and kl   t  then the rules must be support
rules of the form a   kc t  kl t and a   kc    t   kl   t  arising from rules
a   c  l and a   c    l  in p     then since l and l  are mutex in p   c and c  
must contain literals l   c and l   c   such that  l    l    is a mutex in p   and
hence  kl   t  kl   t    belongs to rt   so that kc t and kc    t  are mutex in rt as
well 
similarly  if there is an action with rules for kl t and kl   t for a literal l 
mutex with l in p   the rules must be support and cancellation rules of the form
a   kc t  kl t a   kc    t  kl   t  arising from rules a   c  l and
a   c    l  in p   since l and l  are mutex in p   c and c   must contain literals
l   c and l   c   that are mutex in p   and hence rt must contain the pair
 kl   t  kl   t   so that kc t and kc    t must be mutex in rt  
   we are left to show that the set rt given by the pairs  kl t  kl   t    and  kl t 
kl   t  complies with clause   in the definition of mutex sets as well  consider the
first class of pairs  kl t  kl   t    and a rule a   kc t  kl t for kl t arising from
a rule a   c  l in p   since l is mutex with l  in p   then one of the conditions  a 
 b  or  c must hold for the rule a   c  l and l    if  a  then l    l  and kc t
must imply the body kc t  of the cancellation rule a   kc t   kl t    as
for each literal l  in c  rt must contain the pair  kl   t  kl   t    so that kl   t
implies kl   t    and kc t implies kc t   case  c   if  b  then c and l  are
    the action a cannot be a merge for a literal l   mutex with both l and l    as in such case  l   implies
that l and l  that are mutex  similarly  a cannot be a merge for l as in such a case  l will be mutex
with both l  and l    for the same reason  a cannot be a merge for l  either  thus  the action a above
cannot be a merge and must be an action from p  

   

ficompiling uncertainty away in conformant planning problems

mutex in p   and thus c contains a literal l  mutex with l  in p   this means that
the pair  kl   t  kl   t    is in rt and hence that kc t is mutex with kl   t  in rt
 case  b   last  if  c  c implies c   in p for a rule a   c    l    but then kc t must
imply the body kc    t  of the cancellation rule a   kc    t   kl   t    indeed 
for each literal l  in both c and c     we had above that kl   t implies kl   t   
while if l  is a literal in c   but not in c  then some literal l   c must be mutex with
l  in p   and hence the pair  kl   t  kl   t    must be in rt and kl   t implies
then kl   t   case  c 
   
consider
v now the same pair  kl t  kl  t   along with a merge action am l with a
rule ti m kl ti  kl for kl t   kl  thus t is the empty tag   in this case  since
the merge m is valid and t  is consistent  there must be some ti  m such that ti and
t  are jointly consistent with i  it follows then that  kl ti   kl   t    is a pair in rt
and thus that the body of the merge is mutex with kl   t  in rt  case  b  

there is no need to consider the pair  kl t  kl   t    along with the rules for kl   t   
as the literals kl t and kl   t  have the same structure  and thus the same argument
above applies  replacing t with t  and l with l   
we switch now to the second class of pairs  kl t  k l   t  and the rules a  
kc t  kl t for kl t  since l and l  are mutex in p   then conditions  a   b  or
 c must hold  if a  then l    l  and in such a case  condition  c holds in kt m  p  
as kc t implies the body kc t of the rule a   kc t  kl   l    l   if b  c
is mutex with l    and thus there is a literal l  in c such that l  and l  are mutex
in p   and therefore kc t and kl   t are mutex in rt  case  b   finally  if c  c
implies c   for a rule a   c    l  in p   then kc t must imply kc    t in rt for a
rule a   kc    t  kl   t  case  c  
for the empty tag t  the rule for kl t may also be a merge  but then due to the extra
effects kl  in the merge action for l  the merge for kl is also a merge for kl   
and then case  c holds 
last  for the same class of pairs  the only rules for kl   t are cancellation rules of
the form a   kc     t  kl   t for a rule a   c     l  in p   since l  is mutex with
l in p   then conditions  a   b  or  c must hold for the rule a   c     l  and l  in p   if
a  then l   l    and the cancellation rule is then a   kc     t  kl  case  c   if
b  c    is mutex with l  and thus there is a literal l  in c    such that  l    l  is a mutex
in p   and therefore kl t implies kl   t in rt   and hence kl   t and kc     t
imply kl t in rt  case  b   finally  if c  c    implies c   for a rule a   c    l in p  
and then kc     t must imply kc    t for a rule a   kc    t  kl t in rt  
indeed  if la implies lb in p   lb implies la in p   and klb  t implies kla  t
in rt   and kla  t implies klb  t 

references
albore  a   palacios  h     geffner  h          a translation based approach to contingent
planning  in proc    st int  joint conference on ai  ijcai      pp           
   

fipalacios   geffner

baral  c   kreinovich  v     trejo  r          computational complexity of planning and
approximate planning in the presence of incompleteness  artificial intelligence                   
baral  c     son  t  c          approximate reasoning about actions in presence of sensing
and incomplete information  in proc  ilps       pp         
bayardo jr   r     schrag  r          using csp look back techniques to solve real world
sat instances  in proc  aaai  pp         
bertoli  p     cimatti  a          improving heuristics for planning as search in belief space 
in ghallab  m   hertzberg  j     traverso  p   eds    proc  aips       pp         
aaai press 
bonet  b     geffner  h          planning as heuristic search  new results  in proceedings
of ecp     pp          springer 
bonet  b     geffner  h          planning with incomplete information as heuristic search
in belief space  in proc  of aips       pp        aaai press 
bonet  b     geffner  h          planning as heuristic search  artificial intelligence        
        
bonet  b     givan  b          results of the conformant track of the  th int  planning
competition  at http   www ldc usb ve bonet ipc  docs results conformant pdf 
bryce  d     buffet  o          international planning competition uncertainty part  benchmarks and results  at http   ippc      loria fr wiki images      results pdf 
bryce  d   kambhampati  s     smith  d  e          planning graph heuristics for belief
space search  journal of artificial intelligence research           
cimatti  a   roveri  m     bertoli  p          conformant planning via symbolic model
checking and heuristic search  artificial intelligence              
dechter  r          constraint processing  morgan kaufmann 
goldman  r  p     boddy  m  s          expressive planning and explicit knowledge  in
proc  aips       pp         
haslum  p     jonsson  p          some results on the complexity of planning with incomplete information  in proc  ecp     lect  notes in ai vol       pp         
springer 
hoffmann  j     brafman  r          contingent planning via heuristic forward search with
implicit belief states  in proc    th int  conf  on automated planning and scheduling
 icaps        pp        aaai 
hoffmann  j     brafman  r          conformant planning via heuristic forward search  a
new approach  artificial intelligence                    
hoffmann  j     nebel  b          the ff planning system  fast plan generation through
heuristic search  journal of artificial intelligence research             
marquis  p          consequence finding algorithms  in gabbay  d     smets  p   eds   
handbook on defeasible reasoning and uncertainty management systems  vol     pp 
       kluwer 
   

ficompiling uncertainty away in conformant planning problems

palacios  h     geffner  h          compiling uncertainty away  solving conformant planning problems using a classical planner  sometimes   in proc  aaai     pp         
palacios  h     geffner  h          from conformant into classical planning  efficient translations that may be complete too  in proc  icaps     pp         
petrick  r     bacchus  f          a knowledge based approach to planning with incomplete
information and sensing  in proc  aips     pp         
rintanen  j          complexity of planning with partial observability  in proc  icaps      pp         
smith  d     weld  d          conformant graphplan  in proceedings aaai     pp     
     aaai press 
son  t  c   tu  p  h   gelfond  m     morales  a          conformant planning for domains
with constraints  a new approach  in proc  aaai     pp           
son  t  c     tu  p  h          on the completeness of approximation based reasoning and
planning in action theories with incomplete information   in proc    th int  conf  on
principles of kr and reasoning  kr      pp         
tison  p          generalized consensus theory and applications to the minimization of
boolean circuits  ieee transactions on computers  ec                
tran  d   nguyen  h   pontelli  e     son  t  c          cpa c   h   two approximationbased conformant planners  at http   ippc      loria fr wiki images      team cpa pdf 
tran  d   nguyen  h   pontelli  e     son  t  c          improving performance of conformant planners  static analysis of declarative planning domain specifications  in practical aspects of declarative languages    th international symposium  padl      proceedings  vol       of lecture notes in computer science  pp          springer 
turner  h          polynomial length planning spans the polynomial hierarchy  in jelia
    proc  of the european conference on logics in ai  pp          springer verlag 

   

fi