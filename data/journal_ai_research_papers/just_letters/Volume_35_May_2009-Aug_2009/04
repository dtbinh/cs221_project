journal artificial intelligence research                 

submitted        published      

modularity aspects disjunctive stable models
tomi janhunen
emilia oikarinen

tomi janhunen tkk fi
emilia oikarinen tkk fi

helsinki university technology
department information computer science
p o  box       fi       tkk  finland

hans tompits
stefan woltran

tompits kr tuwien ac at
woltran dbai tuwien ac at

technische universitt wien
institut fr informationssysteme
favoritenstrae      a      vienna  austria

abstract
practically programming languages allow programmer split program
several modules brings along several advantages software development 
paper  interested area answer set programming fully declarative
nonmonotonic languages applied  context  obtaining modular structure
programs means straightforward since output entire program cannot
general composed output components  better understand effects
disjunctive information modularity restrict scope analysis case
disjunctive logic programs  dlps  subject stable model semantics  define notion
dlp function  well defined input output interface provided  establish
novel module theorem indicates compositionality stable model semantics
dlp functions  module theorem extends well known splitting set theorem
enables decomposition dlp functions given strongly connected components
based positive dependencies induced rules  setting  possible split
shared disjunctive rules among components using generalized shifting technique 
concept modular equivalence introduced mutual comparison dlp functions
using generalization translation based verification method 

   introduction
practically programming languages used software development allow programmer
split program several modules interact well dened input output
interfaces  given this  entire program viewed composition component modules typically linked together respective run time environment 
expected benets modular program development manifold  first  imposes
good programming style followed programmer  complex software system
much easier develop set interacting components rather monolithic program  second  modular architecture allows additional exibility regards delegating
programming tasks amongst team programmers  setting  goal programmer implement desired input output behavior s  terms concrete module s 
together implement software system developed  third  modular program
c
    
ai access foundation  rights reserved 

fijanhunen  oikarinen  tompits   woltran

design exploited order boost execution programs  program optimization facilitated structural information encompassed module interfaces 
answer set programming  asp   marek   truszczyski        niemel        gelfond
  leone        paradigm declarative problem solving solutions problems
described terms rules subject nonmonotonic semantics based stable models
 gelfond   lifschitz         typical problem representations  tight correspondence
solutions stable models sought for  default negation fully exploited
order obtain concise encodings relations involved problem descriptions 
furthermore  recursive denitions enable  e g   representation closures relations
natural way  due ecient implementations emerging applications 
paradigm received increasing attention past two decades   meantime 
number extensionssuch disjunctions  weight constraints  aggregateshave
proposed basic syntax normal logic programs  paper  concentrate
class disjunctive logic programs  dlps  appropriate solving search problems
residing second level polynomial time hierarchy  semantical account
dlps based respective generalization stable model semantics  gelfond  
lifschitz        
paper  goal investigate modularity context dlps stablemodel semantics  since stable models dened complete programs 
lend modular programming prima facie  perhaps reason  concept
module yet raised much attention realm answer set programming 
except dedicated papers  gaifman   shapiro        eiter  gottlob    veith      b 
baral  dzifcak    takahashi         modules mostly appeared by product studies
formal properties stratication  splitting  or  lately  work equivalence
relations programs  lifschitz   turner        eiter  gottlob    mannila      a 
eiter  ianni  lukasiewicz  schindlauer    tompits         recent approach oikarinen
janhunen      a   modular architecture put forth gaifman shapiro       
accommodated classes normal smodels programs  main result
module theorem links stable models associated individual modules
composition  result signicant indicates stable models
compositional much sense classical models propositional logic 
major restriction implied module theorem denition set
positively interdependent atoms must given within module 
besides general benets modular program development discussed above 
looking potential computational advantages modularizing reasoning tasks asp 
context  search stable models probably central reasoning task 
results module theorem discussed provide basis modularizing
search task  extra care  however  required computation stable models
modules separation necessarily ecient  sophisticated methods 
identifying cones influence boolean circuits  junttila   niemel         devised
identify modules relevant search stable modelsthe rest used
expand qualied stable model one entire program  strategy alleviates
treatment extremely large program instances amenable query evaluation 
     th anniversary stable model semantics celebrated iclp   held udine 
italy  december      

   

fimodularity aspects disjunctive stable models

unfortunately  contemporary disjunctive answer set solvers  claspd  drescher
et al          cmodels  giunchiglia  lierler    maratea         dlv  leone et al         
gnt  janhunen  niemel  seipel  simons    you         exhibit little support modular
reasoning although related techniques strongly connected components exploited internally  reasoning tasks boosted modular approach 
instance  optimization answer set programs gives rise problem verifying
whether dierent versions programs answer sets  demonstrated
oikarinen janhunen         verication tasks may benet modularization 
and  particular  approximation techniques based modular equivalence introduced 
following idea  rst modular o line optimizer answer set programs  called modopt  recently implemented  janhunen      b  
interesting applications modules sight  gebser et al       a 
propose incremental technique answer set solving  idea gradually extend
program instance terms additional modules  e g   solving ai planning problems 
moreover  theoretical results splitting set theorem  lifschitz   turner       
module theorem directly exploited correctness proofs  instance  proved
oikarinen janhunen      b  models prioritized circumscription
captured disjunctive stable models using particular translation  similar proof
strategy adopted theorem     paper 
anticipate compositional semantics prove useful one tries boost
search stable models via parallelization  e g   computing stable models modules
parallel  however  order avoid excessive communication costs  extra caution needed
stable models computed separation linked together potentially rejected 
one possibility identify mutually independent modules basis distribution 
besides aspect  modularization may lead novel methods  non parallelized 
computation stable models  traditional ones 
structure preview results paper  concentrate formal underpinnings modular programming context disjunctive logic programs
stable model semantics  proceed follows  rst goal generalize theory
developed normal programs smodels programs  oikarinen   janhunen      a 
case disjunctive programs  end  rst introduce notion dlpfunction section    term goes back gelfond gabaldon        introduced
lp functions  partial  denitions new relations terms old  known ones  enable functional view disjunctive programs  endowed well dened
input output interface  idea partition signature program encapsulated
way input atoms  output atoms  hidden  or local   atoms  distinctions
provide basis systematic composition larger disjunctive logic programs
program modules  however  arbitrary combinations program modules meaningful and  rst all  adopt syntactic restrictions introduced gaifman shapiro
       context negation disjunction free logic programs  interplay default negation disjunctions brings along new factors lead relaxation
restrictions sense program modules allowed share rules  then 
basic syntactic issues dlp functions laid out  concentrate semantics
section    respect  follow strict model theoretic approach and  particular 
   

fijanhunen  oikarinen  tompits   woltran

address role input atoms comes viewing dlp functions mathematical
functions  proceed step step assign three dierent classes models
dlp function  viz  classical models  minimal models  stable models  last provides
appropriate generalization disjunctive stable models  gelfond   lifschitz       
presence input atoms 
second objective establish adequacy concept dlp function
view compositional semantics  witnessed main result paper 
viz  module theorem shows stable models dlp function   
alternatively obtained unions compatible stable models modules constituting
  proof theorem based notions completion  clark        loop
formulas  lin   zhao        lee   lifschitz        rst lifted case dlpfunctions section   preparatory step  proof module theorem follows
main topic section    result non trivial underlying semantics based
stable models inherently nonmonotonic  feature already recognized gaifman
shapiro        much simpler setting denite programsneither involving default
negation disjunctions  observed them  too  syntactic restrictions program
composition necessary order guarantee compositionality properties semantics
based herbrand models   current paper  strive analogous results
case programs permitting default negation disjunctions  turns
strongly connected components positive dependency graphs provide key criterion
comes conning program composition  compositionality properties disjunctive
programs stable model semantics arisen context so called
splitting set theorem  lifschitz   turner        eiter et al       a         fact 
module theorem established herein proper generalization predecessor  oikarinen  
janhunen      a   illustrate potential modular architecture evaluation
quantied boolean formulas  qbfs   serve canonical representatives classes
polynomial time hierarchy  ph   due basic complexity results established eiter
gottlob         natural perspective concentrate second level
ph case disjunctive programs 
third aim paper look particular applications module theorem disjunctive logic programming  section    take opposite view
modular construction dlp functions consider possibilities decomposition
even absence structural information  turns strongly connected
components exploited respect but  addition  occurrences hidden
atoms must taken account splitting dlp function components 
demonstrated section    results open new prospects regards unwinding disjunctions
using principle shifting  gelfond  przymusinska  lifschitz    truszczyski        dix 
gottlob    marek        eiter  fink  tompits    woltran         proper generalization
principle partially covers programs involving head cycles formulated
proved correct  moreover  due modular nature dlp functions  makes perfect
sense compare modules  notion modular equivalence introduced
purpose section    interestingly  modular equivalence supports substitutions equivalent
programs lends translation based verification put forth oikarinen
   main concern gaifman shapiro        modularity respect logical consequences
definite program hence intersection herbrand models 

   

fimodularity aspects disjunctive stable models

janhunen              related cases ordinary equivalence smodels programs  section   contrasts approach related work  finally  section    provides
brief summary results concludes paper 

   class dlp functions
topic section syntax dlp functions well syntactic restrictions
imposed composition dlp functions  disjunctive rule expression form
a  b            bm   c            ck  

   

n  m  k    a              b            bm   c            ck propositional atoms  since
order atoms considered insignicant  write b  c shorthand rules
form         a               b    b            bm    c    c            ck   respective
sets atoms  basic intuition behind rule b  c atom
positive body b inferred none atoms negative body c 
atom head inferred  b c empty  disjunctive
fact  written   empty  constraint  written b  c 
disjunctive logic program  dlp  conventionally formed nite set disjunctive
rules  additionally  want distinguished input output interface dlp 
end  extend denition originally proposed gaifman shapiro        case
disjunctive programs   natural interface imposes certain restrictions
rules allowed module  given set r disjunctive rules  write at r 
signature r  i e   set  ground  atoms eectively appearing rules r 
definition     dlp function    quadruple hr  i  o  hi  i  o  h
pairwise distinct sets input atoms  output atoms  hidden atoms  respectively  r
dlp rule b  c r 
   b c h 
         o h      
dlp function   hr  i  o  hi occasionally identied r and  slight abuse
notation  write b  c denote b  c r  rst condition
denition      rules dlp function must obey interface specication  
i e   at r  h  regards sets atoms i  o  h involved module
interface  atoms considered visible hence accessible
dlp functions conjoined   either produce input utilize output
  hand  hidden atoms h used formalize auxiliary concepts
may make sense context dlp functions may save space
substantially demonstrated  e g   janhunen oikarinen        example      
second condition denition     concerned set atoms h defined
rules r  principle non empty disjunctive head must involve least one
atom h  ensure dlp function must interfere
   similar approaches within area asp previously introduced gelfond gabaldon
        janhunen         oikarinen janhunen      a  

   

fijanhunen  oikarinen  tompits   woltran

denitions input atoms terms rules b  c satisfying i 
otherwise  rules may conditioned input atoms   given set atoms 
distinguish set rules dene atoms r  i e   set defining rules
def r  s     a b  c r        

   

next objective specify conditions composition dlp functions
may take place  roughly speaking  idea larger dlp functions formed
modular fashion using smaller dlp functions components  observed already
gaifman shapiro         syntactic restrictions program composition necessary
order guarantee compositionality properties semantics based herbrand models  even simple case denite programs  thus  program union operator
composition without restrictions satisfactory respect compositionality 
start adapting construction gaifman shapiro        case
disjunctive programs 
definition     two dlp functions     hr    i    o    h      hr    i    o    h  respect input output interfaces
    i  o  h    h     
    i  o  h    h     
   o  o     
   def r   o      def r  r   o    
   def r   o      def r  r   o    
rst three conditions due gaifman shapiro       
imply sets o    h    o    h  mutually pairwise distinct  violations
respect rst two conditions circumvented renaming strategy 
instance  atom h  appears i  o  h    hence violating second condition 
possible replace occurrences   new atom   i  o  h 
appearing     removes conict respect forth  
hand  last two conditions denition     concern distribution
rules involved definitions     sets atoms o  o    i e   sets rules
def r   o    def r   o     r  r    respectively  regards disjunctive rules 
principle sets dening rules must remain intact union r  r 
formed means module supposed copies rules form
denition output atoms  spite this  two modules     subject
conditions denition     may eectively share disjunctive rules b  c
non empty head o     o       demonstrated next 
   particular  input atoms head rule act much atoms negative body c 
   opposite view program composition considered section    possibilities decomposing disjunctive program smaller dlp functions studied  counterpart renaming 
revealing operator introduced definition     used circumventing first two conditions
definition     

   

fimodularity aspects disjunctive stable models

example     consider following two dlp functions  
 b 
b c 
a 
 a  c 



 a 
b c 
e a  e
 b  c 

formally      hr     a  c    b    d i     hr     b  c    a    e i
r  r     a b c   show     respect input output interfaces
other  first  hidden atoms e occur exactly one two programs
thus first two conditions definition     satisfied  second  disjoint output
atoms  viz  atom b   atom     finally  def r    b     def r  r    b    
def r    a     def r  r    a      a b c   shows final two conditions
definition     satisfied  far syntax concerned  makes sense compose
larger dlp function obtained kind union       see     below 
contrast disjunctive programs  shared rules arise context normal
logic programs since one head atom allowed rule  stated
smodels programs  simons  niemel    soininen        although programs
may contain  among rule types  choice rules form
 a              b  c

   

heads cardinality greater one  observed oikarinen janhunen      a  
heads choice rules possessing multiple atoms freely split without aecting
semantics  splitting rules n dierent rules  ai   b  c
  n  concern creation n copies rule body b  c could
reserve quadratic space worst case  new atom introduced circumvent
this  nature proper disjunctive rules      subject study paper 
somewhat dierent  unlike choice rules  disjunctive rules may interact rule heads 
example      denition depends b vice versa  however  given choice rule
 a  b  c instance  choices regarding b independent other  c
true  atoms truth value  quite dierent interpretation
ab c makes either b true given c true  grasp interaction
b natural b input denition and  conversely  input
b  demonstrated section    shared rules rewritten input atoms
removed rule head drawback rewriting technique  compactness
representation partly lost  therefore  appreciate extra exibility provided
shared rules interpret reect true nature disjunctive rules 
general  dlp functions composed according following principle 

   henceforth make use tabular format represent dlp functions  output signature
given top  input signature bottom  rules listed between  thus 
declaration hidden signature remains implicit 

   

fijanhunen  oikarinen  tompits   woltran

o 
l

i 
h 

h 
i 

 

o 

i  o 

o 

h 

i 

i  i 

i 

h 

o 

o  i 

figure    treatment signatures composition operator  
definition      composition  let     hr    i    o    h      hr    i    o    h 
two dlp functions respect input output interfaces other  then  composition     defined determined
      hr  r     i    o     i    o     o  o    h  h  i 

   

treatment atom types denitions         summarized figure   
two symmetric gures left hand side illustrate signatures dlp functions
    hr    i    o    h      hr    i    o    h  subject composition  input signatures
output signatures emphasized light gray dark gray shadings  respectively 
superposition two gures yields diagram given right represents
resulting nine categories atoms  three may involve shared atoms
originate       interface conditions introduced intuitive
readers acquainted principles object oriented programming 
   although     must share hidden atoms  may share input atoms  i e  
i  i     allowed  output atoms treated dierently o  o    assumed 
   input atom   becomes output atom     appears output
atom     i e     provides input   setting  input atoms  
treated symmetric fashion 
   hidden atoms     retain status      
example     recall example     showed dlp functions     respect
input output interfaces other  thus  composition     defined 
    hr  r    i  o  hi set input atoms   a  c     a     b  c     b    
 c   set output atoms  a   b     a  b   set h hidden atoms
 d   e     d  e   i e   using tabular format represent modules 
 b 
b c 
a 
 a  c 



 a 
b c 
e a  e
 b  c 

 

 a  b 
b c 
a  d 
e a  e
 c 

definitions b     share rule b c  thanks flexibility
definition      able split     components whenever appropriate 
   

fimodularity aspects disjunctive stable models

following previous approaches  gelfond   gabaldon        oikarinen   janhunen 
    a   dene signature at   dlp function   hr  i  o  hi h  
notational convenience  distinguish visible hidden parts at   setting
atv      ath      h   at     atv     respectively  moreover  ati   
ato    used refer sets input output atoms   respectively 
notations provide us way access module interface left implicit  e g  
neglect internal structure modules  lastly  set at   atoms  denote projections ati     ato     atv     ath    si     sv   sh  
respectively 
formal terms  dlp function   hr  i  o  hi designed provide mapping
subsets set subsets h analogy lp functions formalized
gelfond gabaldon         however  exact denition mapping deferred
section   semantics dlp functions anchored  sequel 
 syntactic  class dlp functions denoted d  assumed  sake simplicity 
spans xed  at denumerable  signature at d   at   at d 
holds dlp function d  given dlp functions           pairwise
respect input output interfaces other  holds
     closure  
            empty dlp function   h       identity  
           commutativity  
                     associativity  
theory modules put forth oikarinen janhunen      a  based
restrictive operator program composition  viz  join   idea behind operator
forbid positive dependencies programs explicated next 
technically speaking  dene positive dependency graph dg     dlp function
  hr  i  o  hi using positive dependenciesfollowing denition ben eliyahu
dechter         however  exclude input atoms graph denitions
external anyway  thus  let dg       ho h    b   holds
pair atoms a  b h rule b  c r
b b  reexive transitive closure   gives rise dependency relation
ato    ath     strongly connected component  scc  graph dg    
maximal set ato    ath    b every pair a  b atoms  given
    dened  say     mutually dependent dg        
scc ato         ato          oikarinen   janhunen 
    a   i e   component shared dlp functions     way   
  mutually dependent  call mutually independent 
definition      joins  given two dlp functions       composition    
defined     mutually independent  join           
defined coincides      
   consequently  length symbols  denoted kk  gives upper bound  at   
important one considers computational cost translating programs  janhunen        
   practice  set could set identifiers  names propositions similar objects  

   

fijanhunen  oikarinen  tompits   woltran

case     dened  thus     mutually independent  exactly
one following conditions holds scc dg         
ato      ath      

   

ato      ath      

   

example     recall programs     example     obtain
positive dependency graph dg           h a  b  d  e    ha  di  ha  ei i  hence  sccs
graph simply singletons  a    b    d    e   together observation
ato      ato      disjoint  derive     mutually dependent 
thus  join           defined since composition     defined
basis analysis performed example     
example     example two dlp functions composition defined
yet ineligible join  consider following situation 
 b 
b c 
b a  c
 a  c 



 a 
b c 
b  c
 b  c 

 

 a  b 
b c 
b  c 
b a  c
 c 

here  result composition involves scc    a  b  respective positive dependency graph  non empty intersection output signatures programs
subject composition  hence  respective join modules question defined 

   model theory stable model semantics
syntax dlp functions dened  turn semantics  proceed
three steps introduce  correspondingly  three kinds models  viz  classical models 
minimal models  and  nally  stable models dlp function  last provide
intended semantics dlp function whereas rst two serve auxiliary concepts 
usual  interpretation dlp function dened arbitrary subset
at    given particular interpretation at    atom at   true  
denoted    a    otherwise false   denoted     a  negative
literal a  dene        a  set l literals satisfied   denotedwby
   l     l  everywliteral l l  dene disjunctive interpretation l
set l literals     l    l literal l l 
begin with  cover dlp functions pure classical semantics  treats
disjunctive rules classical implications  emphasized classical models
dlp function specic interpretations dened hence subsets at   
definition     interpretation at    classical  model dlp function
  hr  i  o  hi  denoted      iff    r  i e   every rule b  c r 
w
   b c implies    a 
   

fimodularity aspects disjunctive stable models

set classical models denoted cm   
classical models provide appropriate level abstraction address role input
atoms dlp functions  given dlp function interpretation at   
projection mi viewed actual input may  or may not  produce
respective output mo   depending semantics assigned   treatment input
atoms sequel based partial evaluation  idea pre interpret input
atoms appearing respect mi  
definition     dlp function   hr  i  o  hi actual input mi  
instantiation respect mi   denoted  mi   quadruple hr     o  hi
r contains reduced rule
 a   i   b   i    c   i 

   

rule b  c r mi    ai bi ci  
example     consider following dlp function  
 a  b 
b c 
c  b 
b c 
 c 
actual input  c  ati     reduct   c  dlp function
h a b  b a      a  b   i 
hand  actual input ati     obtain reduct
    h a b      a  b   i 
rules form     free input atoms indicates reduct  mi
dlp function without input  atoms ato    ath    aected  mi  
proposition     let dlp function at   interpretation defines
actual input mi ati      interpretations n at   ni   mi  
n    nh     mi  
proof  consider n at   ni   mi  
    suppose n      assume nh satisfy     rule
b  c   follows mi    ai bi ci   therefore ni    ai bi ci  
thus  n     b  c  contradiction  follows nh     mi  
    let nh   w mi hold  assuming n     b  c rule implies
n    b c n     a  follows ni    ai bi ci corresponding
rule     included  mi ni   mi   rule satised nh since
   

fijanhunen  oikarinen  tompits   woltran

w
n     b  c implies nh     b   i   c   i  nh      a   i  
contradiction  hence  n     

thus  input reduction  given denition      fully compatible classical
semantics characterize semantic operator cm terms equation
 
 mi n   n cm  mi    
   
cm    
mi ati   

recall models dlp function subsets at    hence 
n cm  mi   subset at  mi   thus mi n   mi ati   
since atom ati    occurs  mi denition 
handling input atoms slightly complicated case minimal models
primitives parallel circumscription  lifschitz        mccarthy        provide us
straightforward way address them  rough idea keep interpretation input
atoms fixed minimizing  i e   falsifying  others far possible 
definition     let   hr  i  o  hi dlp function  model at  
i minimal iff model n ni   mi n  
sequel  set i minimal models   hr  i  o  hi denoted mm  
treat input atoms stipulating i minimality models  using idea  proposition    
lifts minimal models given fact ati   mi      
proposition     let dlp function at   interpretation defines
actual input mi ati      interpretations n at   ni   mi  
n mm   nh mm  mi   
proof  consider n at   ni   mi  
    let n mm    follows proposition     nh     mi   assume
nh
  mm  mi    recall ati   mi       thus  interpretation
nh     mi   follows proposition     n   
interpretation n   mi s  ni   ni n n jointly contradict n mm   
    suppose nh mm  mi    so  nh     mi   n    follows
proposition      let us assume n   mm    i e   model n   
ni   ni n n   thus   no nh    no nh    since ni   ni   mi
follows nh     mi proposition      then  however  nh     mi
contradiction nh mm  mi   

set mm   ati    minimal models sucient determine semantics
positive dlp function   i e   whose rules form b  recall
rules   ati       holds whenever      order cover arbitrary dlp functions 
interpret negative body literals way proposed gelfond lifschitz        
definition     given dlp function   hr  i  o  hi interpretation at   
reduct respect positive dlp function   hrm   i  o  hi
rm    a b   b  c r    c  
   

   

fimodularity aspects disjunctive stable models

definition     interpretation at   stable model dlp function
input signature ati    iff mm m    i e   ati    minimal model  
hidden atoms play special role denition      contrast this  aect
possibilities program decomposition  presented section    status
nally explicated notion modular equivalence introduced section   
denition     covers case ordinary disjunctive logic program  simply
dlp function   hr    o  i  model at     stable
minimal model rm   denition stable models gives rise semantic operator
at d 
sm     
dlp functions 
sm      m at     mm m    

    

proposition     provides us way dismiss ati    minimality denition stable
models desirable  given stable model   projection n   mo mh minimal
model   mi  n hence stable model  mi   words 
  mi  m     mi  mo mh    mi  
thus  derive following result 
corollary     dlp function  
sm      m at     mo mh sm  mi    
example      recall dlp function example      hidden atoms 
given follows 
 a  b 
b c 
c  b 
b c 
 c 
four stable models total  m     a   m     b   m     a  c   m     b  c  
 c  minimal models respective reducts  
m 
m 
m 
m 

  h a b   c    c    a  b   i 
  h a b   b c    c    a  b   i 
  h a c    c    a  b   i 
  h b c    c    a  b   i 

now  easy verify mj  c  minimal model reduct mj  
illustrating corollary      recall reducts
  c    h a b  b a      a  b  
    h a b      a  b   i 
then  sm   c       a    b   sm        a    b   
   

fijanhunen  oikarinen  tompits   woltran

immediate observation loose general antichain property stable
models input signatures introduced  instance  m  m  m  m 
example       however  since interpretation input atoms xed semantics 
perceive antichains locally  i e   set  n sm     ni   mi   stable models forms
antichain  input mi ati     example       sets stable models associated
actual inputs  c   m    m     m    m     respectively 

   characterizations using classical logic
well known set stable models ordinary disjunctive logic program  i e  
dlp function form hr    o  i  characterized via classical propositional logic 
using concepts completion  clark        loop formulas  lin   zhao        lee  
lifschitz         section  generalize concepts arbitrary dlp functions 
end  main concern role input atoms incorporate
concepts  furthermore  extend tightness property programs  erdem   lifschitz 
      dlp functions introducing notion i tightness section     
    program completion loop formulas
given dlp function   loop non empty subset strongly connected
component positive dependency graph dg      recall dg    
atoms ato    ath    nodes  particular  singleton  a  ato   
ath    thus loop 
example     consider dlp functions     defined follows 

   

 b  c 
c b 
ba
 a 

   

 a  b 
c b 
ba
 c 

here    singleton loops  b   c   particular   a  b  loop
contains input atom a  hand    loops  a    b    a  b  
follows 
use wfor set propositional
w formulas  or atoms   denote
v
conjunction ss shorthand ss s  moreover  appearing within
formula  set implicitly understood conjunction elements  dlp function
atom ato    ath     dene set supporting formulas
suppf a       b c  a    a     b  c a 
loop l ato    ath      set externally supporting formulas
esuppf l       b c  a   l    b  c   l      b l     
clarks completion procedure  conjunctive  loop formulas generalized dlpfunctions following way 
definition     dlp function   completion set formulas
   

fimodularity aspects disjunctive stable models

w
comp      b c
w   b  c  
 a suppf a      ato    ath    

set loop formulas
w
lf      l esuppf l      l ato    ath    loop    

observe case ati        i e   ato    ath      at    completion
comp   reduces denition provided lee lifschitz        holds
set lf   loop formulas  generally speaking  propositional theories comp  
lf   characterize set sm   stable models following sense 

theorem     dlp function interpretation at   
sm      comp      lf   
proof  rst relate sets suppf a    esuppf l     introduced
dlp function   respective sets complementary rules
suppcr a       a    a  b  c   b  c a 
esuppcr l       a   l b  c   b  c   l      b l     
first  straightforward that  interpretation at       comp  
jointly     ato    ath          suppcr a     quite
similarly  holds    lf   i  loop l  ato    ath      
    esuppcr l     hand  viewing suppcr a    esuppcr l   
dlp functions signatures   apply proposition     order
evaluate input atoms  thus  obtain following relationships dlp function
  interpretation at    atom ato    ath     loop l ato    ath   
 
      mo mh     mi  
      suppcr a    mo mh    suppcr a   mi   
      esuppcr l    mo mh    esuppcr l   mi   
finally  recall interpretation at    ato      ato   mi  
ath      ath   mi    inspecting denition comp   lf   again 
conclude interpretation at      comp   lf   mo mh   
comp  mi   lf  mi    turn  know mo mh    comp  mi   lf  mi  
mo mh stable model program  mi results lee lifschitz        
recall  mi ordinary disjunctive program without input atoms  finally 
sm      m at     mo mh sm  mi    corollary      equality shows
claim 

example     let us demonstrate functioning program completion loop formulas dlp functions example      i e       hr   a    b  c      
hr   c    a  b   i  r    a c b  b a   completions
   although may seem case singleton loop l    a  somewhat redundant  so 
since tautological rules b make difference 

   

fijanhunen  oikarinen  tompits   woltran

comp        b c  b   b a  c b a 
comp        b c  b   b a  b c  
furthermore  sets loop formulas
w
w
lf        b esuppf  b        c esuppf  c       
   b a 
w c b a 
w
lf        b esuppf  b  
     esuppf  a       
w
b esuppf  a  b       
   b a  b c  b   
last formula  w
occurrence view esuppf  a  b          
yields empty disjunction esuppf  a  b         usual 
computing classical models comp     lf       comp     yields two
models  m     a  b  m      one check indeed stable models
  recalling ati         a   thus  m  relates actual input m  ati         a 
whereas m  based m  ati          hand  classical models
comp     lf     m     c  m      relate two possible
inputs ati         c   finally  note  a  b  model comp    
ruled lf     
    tight dlp functions
extend well known concept tightness  erdem   lifschitz        dlpfunctions  interest since exploit fact positive dependency
graph dg     reduced modulo input atoms  words  since dependency graph
dg     atoms ato    ath    nodes  tightness dlp functions
dened respect input signature 
beginning section    loops dened arbitrary non empty subsets
strongly connected components dg      thus  dg     acyclic
singleton loops  however  converse necessarily true  since  program
singleton loops  dg     may edges ha  ai  i e   cycles length one 
definition     dlp function ati    tight  or tight  short   positive dependency graph dg     acyclic 
example     recall dlp functions     hr   a    b  c       hr   c    a  b  
based r    a c b  b a  example      here     a  tight since potential
non singleton loop  a  b  contains input atom a  hand     c  tight 
worth mentioning ordinary variant     viz  dlp function hr     a  b  c   i 
 tightin particular  since r tight usual sense 
note last observation  viz  dlp function hr  i  o  hi may i tight
although r tight program  relies use disjunctions program  fact 
dlp functions hr  i  o  hi  r set normal rules form b  c 
dlp function   hr  i  o  hi i tight r tight  verify this  note
second item denition     implies head atom normal rule b  c
must appear i  thus loop may involve atoms i 
   

fimodularity aspects disjunctive stable models

show notion tightness introduced denition     enables us
characterize stable models dlp function classical models completion 
since ordinary program represented dlp function  thus properly
generalize well known completion semantics  clark         following lemma
already sucient result view denition     theorem     
lemma     tight dlp function   lf   comp   
w
proof  recall ato    ath     suppf a    contained
comp    moreover wsince tight  singleton loops  thus lf   contains
formulas esuppf  a      ato    ath     remains
show that  atom a  suppf a    equivalent esuppf  a     whenever
positive dependency graph dg     acyclic  repeat denition suppf a   
give denition esuppf l     simplied case l    a  
suppf a       b c  a    a     b  c a  
esuppf  a        b c  a    a     b  c   a  b  a      
easy see acyclic dependency graph dg      implies b a   
every rule b  c   thus  conclude suppf a      esuppf  a    
holds ato    ath     hence  claim follows 

example     recalling dlp function     hr   a    b  c   example    
r    a c b  b a   obtain
comp        b
w c  b   b a  cw b a 
lf        b esuppf  b        c esuppf  c       
   b a  c b a  
now    tight observe lf     comp     expected 
observations presented far lead us following result 
theorem     tight dlp function interpretation at   
sm      comp   
particular  result compatible existing characterization stable models
case ati        i e   ato    ath      at    then  notion ati   tightness coincides ordinary tightness  denition completion comp  
reduces one provided lee lifschitz        

   compositional semantics
follows  objective establish main result paper  i e   show
stable model semantics  given denition      fully compositional larger
dlp functions formed joins         n dlp functions  precisely 
interconnection sm   sm              sm n   explicated section      analogy
   

fijanhunen  oikarinen  tompits   woltran

section    follow quite rigorous approach consider relationship classical
models rst  minimal models  eventually cover case stable models
comprises module theorem  then  section      use quantied boolean formulas
second level polynomial hierarchy modular representation terms
dlp functions illustrate module theorem  finally  devote section    
comparison splitting set theorem proven lifschitz turner        
    module theorem
begin with  formalize criteria combining interpretations well models 
definition     given two dlp functions       interpretations m  at    
m  at     mutually compatible  with respect        compatible 
m  atv        m  atv      

    

according       two compatible interpretations m  m        respectively  agree truth values joint visible atoms atv      atv      
quick inspection figure   reveals three cases may arise join      
dened joint output atoms     thereafter disallowed  may exist
   joint input atoms ati      ati      ati      
   atoms ato      ati      output atoms   input atoms    
   symmetry  atoms ati      ato      
recall according denition      atoms last two categories end ato   
      formed  atoms atv      atv      provide basis combine
compatible interpretations      
definition     let     two dlp functions       defined 
given sets interpretations a   at     a   at       natural join a 
a  respect atv      atv       denoted a 
a    set interpretations
a 
a     m  m    m  a    m  a    m  m  compatible  

    

rst modularity result formulated dlp functions classical semantics
dened section    combination classical models understood      
proposition     positive dlp functions         defined 
cm         cm    
cm     

    

proof  consider interpretation at       projections m    at    
m    at     respect     hr    i    o    h      hr    i    o    h  i 
follows m  m  compatible   m  m 
   

fimodularity aspects disjunctive stable models

cm      




   r  r 
m     r  m     r 
m  cm     m  cm    
cm    
cm     



generalizing proposition     stable models dlp functions much elaborate 
cover case positive dlp functions minimal models rst  proof
theorem     exploits program completion  loop formulas  well characterization
stable minimal models section   follows 
lemma     dlp functions         defined  following
conditions hold 
comp         comp     comp     
lf         lf     lf     

    
    

proof  begin proof analyzing formulas introduced clarks completion
loop formulas related joins dlp functions  end  establish
sets formulas associated     directly obtained unions sets
formulas associatedwwith     hr    i    o    h      hr    i    o    h  i  first 
implication b c belongs comp       belongs comp     
comp      case shared rule  second  let us consider atom h 
  o  o  h   h  h  disjoint     dened 
reason  either o  h  o  h    i e   atom dened either       thus 
either def r   a    def r  r   a  def r   a    def r  r   a  denition     
implies either suppf a       w  suppf a      suppf a          suppf a      
follows implication
     
w suppf a        member comp 
w
either  i  suppf a      belongs comp      ii  suppf a     
belongs comp      thus  may conclude      completions involved 
third  recall loop l at           contained scc
      follows           denition     either
   l o  h  loop   def r   l    def r  r   l  
   l o  h  loop   def r   l    def r  r   l  
cases above  either esuppf l          esuppf l w
    esuppf l   
      esuppf l       thus  respective loop formula l
esuppf l       
belongs lf       contained lf     lf     

theorem     positive dlp functions         defined 
mm         mm    
mm     

    

proof  consider at       respective projections m    at    
m    at     compatible and  moreover    m  m    obtain
following chain equivalences 
   

fijanhunen  oikarinen  tompits   woltran

mm      
   comp          lf      
m     comp     m     lf    

m     comp     m     lf    
m  mm     m  mm    
mm    
mm     

 theorem     
           
 theorem     
 denition     


example     let us demonstrate result theorem     practical setting using dlpfunctions     visualized composition   hr     a  b  c  d  e   i 

   

 a  b  c 
b  
b 
b a 
c 
c e a  b
 d  e 

   

 d  e 
c 
e d 
e 
c e a  b
 a  b  c 

join     defined sccs composition s     a  b  c 
s     d  e   ati      minimal models    a  b  c    a  b  d    a  b  e  
 a  b  d  e   likewise  calculating mm      get
mm           a    b    c  d  e    a  b  d  e    a  c  d  e    b  c  d  e    a  b  c  d  e   
hence  minimal model    a  b  d  e  compatibility condition
underlying      correctly excludes n    a  b  c  d  e    mm    note support
c true   e true  accordingly  c e a  b active 
prepared present central result 
theorem      module theorem  dlp functions        
defined 
sm         sm    
sm     
    
proof  again  take interpretation at       respective compatible
projections m    at     m    at     consideration  proof     
based      number preliminary facts established 
m 
 
   composition
dened 
   

since     dened  know     dened  indicates  
 

  respect input output interfaces other  construction
 
m 
m 
m 
  aect property implies     dened 
m 
 
dened 
   join
   
m 
 
preceding item  positive dependency graph dg   m
      dened 
m 
m 
let us assume     mutually dependent  i e   scc
m 
 
graph ato  m
       ato           since
dependency graph potentially fewer dependencies respective graph

   

fimodularity aspects disjunctive stable models

dg               follows contained scc latter 
m 

 
since ato  m
      ato      ato        ato       obtain ato        
ato           thus      mutually dependent  contradiction 
m 
 
   reduct       m coincides
     

rule b belongs       m rule b  c    
    c     equivalently  rule b  c  
c m      rule b  c   c m      i e  
 
 
b
b
 
   
therefore get following chain equivalences 
sm      






mm       m  
m 
 
mm m
     
 
 
mm m
mm m
   
   
m 
 
m  mm m
    m  mm    
m  sm     m  sm    
sm    
sm     

 denition     
 item   above 
 theorem     
 denition     
 denition     
 denition     



moral theorem     denition     stable semantics supports modularization long positively interdependent atoms enforced module 
example     let     dlp functions defined      
join  which clearly defined  
 b 
b  
bc
 a  c 



 c 
c  
bc
 a  b 

 

 b  c 
b  
c  
bc
 a 

straightforward verify sm         b    a  b    a  c    b  c   sm      
  c    a  b    a  c    b  c    since atv      atv         a  b  c   obtain
sm    
sm       sm     sm         a  b    a  c    b  c   
simple cross check confirms sm   indeed given set 
example     consider dlp functions     example      then  sm      
    a  b    b  c   sm           a  b    a  c    shown example      join  
  undefined  thus  theorem     applicable  concerning composition
      note sm             a  c    b  c    
      a  b     sm    
sm     
theorem     easily extended dlp functions consisting two
modules  view this  say nite sequence m            mn stable models
modules             n   respectively  compatible  mi mj pairwise compatible 
 
i  j n  property guarantees mi recovered union
  ni   mi taking respective projection at i     mi  
   

fijanhunen  oikarinen  tompits   woltran

corollary      let             n sequence dlp functions join  
n defined  then 
sm   n     sm    

sm n   

    

example      following example simply extends example     
 b 
b  
bc
 a  c 



 c 
c  
bc
 a  b 

 a 
b  
ac
 b  c 



 

 a  b  c 
b  
c  
bc


sm         b    a  b    a  c    b  c    sm         c    a  b    a  c    b  c   
sm         a    a  b    a  c    b  c    thus  learn corollary     
sm           sm    
sm    
sm         a  b    a  c    b  c   
    modular representation quantified boolean formulas
next objective illustrate theory developed far terms extensive
unsat depicted
example  end  consider pair dlp functions sat
n n
figure    purpose evaluation quantified boolean formulas  qbfs 
form
n
 
xy
 ai bi ci di   
    
i  

aj   bj   cj   dj set boolean variables  parameter n gives
number disjuncts matrix boolean formula insdisjunctive normal
form  dnf     without loss generality  may assume x   ni    ai bi     

n
i    ci di    x   hold sets x boolean variables      
important point general evaluation qbfs form      constitutes p   complete decision problem perfectly matches complexity checking
existence stable models disjunctive program  given completeness property 
follows principle decision problem p  turned qbf form
      albeit direct representations obtained particular problem domains 
respect  let us address three specic domains prior detailing generic approach 
   strategic companies domain identied leone et al         one rst
practical domains involving decision problems second level polynomialtime hierarchy solved using asp techniques  simplied encoding provided
koch  leone  pfeifer        based two kinds disjunctive rules 
strat x    strat x    strat x    strat x    prod y  x    x    x    x    

    

strat x  ctrl x  x    x    x    x     strat x     strat x     strat x     strat x    

    

    also  recall shorthands  

v

ss

 

v

   

ss

introduced right example     

fimodularity aspects disjunctive stable models

function sat
n  

function unsat
 
n

x
  n x ai   x  act i  
  n x bi   x act i  
  n  ai bi   act i 
 act             act n  

ci  u  di   act i  
u 
u u
 act             act n  

  n 
 

unsat
figure    dlp functions sat
n n wfor evaluation quantied boolean formula
xy matrix   ni    ai bi ci di   

predicates strat x   prod y  x    x    x    x     ctrl x  x    x    x    x     respectively 
denote company x strategic  product produced companies x            x   
company x controlled companies x            x    obviously  instances
predicate strat arising rules forms           create positive dependencies program   resulting sccs used split program
modules             n           n dened  theorem      status
specic company x decided using module denes strat x 
rather entire encoding  
   model based diagnosis digital circuitry provides another interesting application
area  quite recently  oikarinen janhunen      b  presented ecient encoding
prioritized circumscription disjunctive program  and thus  special case 
parallel circumscription well enabling concise representation minimal diagnoses sense reiter         resulting disjunctive rules involve head cycles
 see section   details  typically pre empt polynomial time translation
computationally easier normal logic program  observation suggests completeness second level polynomial time hierarchy although aware
exact hardness result  correctness proof encoding exploits two modules
module theorem 
   finally  let us mention gebser  schaub  thiele  usadel  veber      b  identify
minimal inconsistent cores large biological networks disjunctive programs 
decision problem question dp  complete indicates appropriateness
disjunctive logic programs representation domain  since dp complete decision problem described independent combination npcomplete decision problem p  conp complete decision problem p    foresee
representation form join sat unsat   sat stable model p 
succinct certicate  unsat unique stable model p  succinct
   

fijanhunen  oikarinen  tompits   woltran

 x    x   
x  act    
x    act    
x    act     x  act    
x  act    
x    act    
x  act    
x    act    
x  x    act   
 act     act     act     act    


u y    y    act    
u y  y    act    
u y  y    act    
u y  y  act    
y  u  y  u  u u
 act     act     act     act    

unsat  
figure    particular instances sat
   

certicates  required dlps worked via reductions propositional
 un satisability  particular  test unsatisability realized analogy
unsat
analyzed below 
n
general case  use boolean variables propositional atoms interchangeably
order describe validity problem      captured dlp functions
unsat based explanatory approach janhunen
figure    design sat
n n
et al               equivalently viewed formula xy matrix
conjunctive normal form  cnf   clause    ai bi ci di active
whenever ai bi false truth clause becomes dependent ci di  
put dually  ai bi true truth ai bi ci di depends ci di  
validity formula xy captured follows  given input interpretation
mi  act             act n    upper dlp function sat
n figure   tries explain
activation statuses clauses checking respective theory  ai bi  
act i  mi    ai bi   act i    mi   satisable  lower dlp function  unsat
  plays
n
role conp oracle  captures test theory  ci di   act i  mi  
unsatisable  correctness representation provided dlp functions
addressed soon  enough understand syntax intuitive meaning
moment  concrete qbf instance evaluated follows 
unsat figure   case qbf
example      consider dlp functions sat
n n

x  x  y  y    x  y  y    x  y  y    x  y  y    x  x  y  y          
thus  parameter instance n      input signature  act             act    
unsat   illustrated figure    output signature former dlpfor sat
   
function  x    x    atoms  i e   y    y    u  remain hidden latter 
joint input signature used specify active part matrix       dlpfunction sat
provides explanation  i e   assignment variables x  x 
 
output  whereas unsat
responsible respective unsatisfiability check  regards
 
validity qbf given       input interpretation  act     act     act     act    
yields positive answer  respective explanation  i e   output interpretation found
sat
     x     easy check x  true x  false remainder
matrix true whatever values assigned y  y    hence  qbf      valid 
    purposes section  interpret disjunctions b sets b    b   b b 
positive negative literals  respectively  disjunctions elements 

   

fimodularity aspects disjunctive stable models

unsat figure    identical
regards general dlp functions sat
n n
sat
input signatures  n output atoms  hidden atoms unsat
fully
n
sat
unsat
respected  hence  composition n n
dened  moreover  atoms appearing
rules involve positive dependencies belong disjoint sets x  u  
unsat   cannot scc x   
therefore clear dg   sat
n n
unsat dened regardless qbf     
 y  u        implies sat
n n
question  let us exploit fact context specic dlp functions example      

example      four stable models dlp function sat
   
 act     act     act     act     x      act     act     x    x      act       x    
listed decreasing level activation  hand  dlp function unsat

 
unique stable model  act     act     act     act     y    y    u   i e   interpretation  y    y    u 
  act     act     act     act     set rules
unique stable model unsat
 
given
  u y    y    u y  y    u y  y    u y  y    y  u  y  u  u u   
 mi stable models input interpretation mi   moreover 
unsat
 
unsat   combining compatible pairs
may apply module theorem calculate sm sat
   
models  one pair 
 act     act     act     act     x    sm sat
   
 act     act     act     act     y    y    u  sm unsat
  
 
thus   act     act     act     act     x    y    y    u  unique stable model join sat
 
sat unsat   non empty  conclude      indeed valid 
unsat
 
since
sm 
 
 
 
natural ask stated stable models general dlpfunctions unsat
sat
n
n associated qbf xy given       stable
sat
model n   respective projection mx   x determines   i e   holds
  n matrix act i  mx    ai bi   moreover  model
mx minimal sense strictly smaller interpretation n mx
property  additional feature brought along minimality stable models 
consequence  dlp function sat
n capture possible truth assignments
variables x relevant truth assignments lost  hand  stable
indicates respective theory
model unsat
n
 ci di     n  act i   
w
inconsistent  alternatively  formula  in act i m ci di valid 
concerning correctness representation given figure    due existing
proof janhunen et al          present main stepsfully exploiting benets
modular approach 
unsat   non empty 
theorem      qbf xy form      valid iff sm sat
n n

proof sketch  consider qbf xy form       following equivalent 
   

fijanhunen  oikarinen  tompits   woltran

   formula xy valid 
   minimal interpretation n x that  set      n  
n     ai bi   indices determined n n     ai bi   i  ai bi  
  i   theory  ci di   i  unsatisable 
unsat compatible stable models   n  act i   
   dlp functions sat
 
n n
i  m     act i    i   u   respectively 
unsat stable model
   dlp function sat
n n

  m  m    n  act i    i   u  
second item  minimality n means n n    n  
n     ai bi     i  assumed without loss generality 

theorem      module theorem suggest approximation strategy verifying
unsat   empty  know
validity qbfs form       either sm sat
n   sm n
unsat      
directly formula valid  otherwise  check whether sm sat
n n
    splitting sets
sake comparison  formulate splitting set theorem  lifschitz   turner 
      dlp function   hr    o  i  essentially forms ordinary disjunctive
program  splitting sets sets atoms closed following sense 
definition      given dlp function   hr    o  i  set u atoms splitting set if  every rule b  c r 
u    implies b c u  
denitions           sets always splitting sets   however 
one mostly interested non trivial splitting sets u   sets
need exist  nevertheless  splitting set u divides respective set rules r two
parts  bottom  bu  r   r respect u contains rules b  c r
b c u   whereas top  tu  r   r r   bu  r   splitting r
bu  r  tu  r  becomes proper one  i e   bu  r     tu  r      
   u non trivial
   every atom least one dening rule b  c r a 
according lifschitz turner         solution r respect u pair
hx  x u    u   x sm bu  r    sm tu  r  x   here  tu  r  x
denotes partial evaluation tu  r  sense denition     using x u
input interpretation  using similar idea  let us introduce dlp functions corresponding
bu  r  tu  r   given splitting set u   join   b  
b   hbu  r     u    htu  r   u    u 
dened  then  following result implied theorem     
   

fimodularity aspects disjunctive stable models

corollary       splitting set theorem lifschitz   turner        every
dlp function   hr    o  corresponding set r disjunctive rules  every splitting
set u   every interpretation at     o  following conditions
equivalent 
   stable model  
   u sm b   sm t   
   hm u     u solution r respect u  
fact  theorem     strictly stronger splitting set theorem  previously
demonstrated oikarinen janhunen      a   splitting sets applicable dlpfunctions   h a b  b a      a  b   trivial way  i e   u   
u     a  b  splitting sets   contrast  theorem     applies preceding
dlp function versatile ways  i e       dened     h a b    b    a  
    h b a    a    b   i  consequence     dened  possible
determine sets stable models sm         a    b     sm     separation 
appropriate  conclude sm     sm    
sm         a    b   holds
well  yet another generality aspect splitting concerns role input atomsthey
assumed nonexistent above  theorem      however  enables us treat well 

   decomposing dlp functions
objectives section contrary construction dlp function join
modules  idea exploit strongly connected components dg      dlpfunction   order decompose smaller components  e g   priori
information internal structure   simplicity  rst consider dlpfunctions hidden atoms  i e   ath        eects hidden atoms
decomposition dlp functions addressed thereafter  dened conjunction
denition      sccs dg     induced positive dependency relation
reexive transitive  i e   preorder denition  sequel  set
sccs dg     denoted scc      positive dependency relation lifts
elements scc     follows  s  s  atoms a  s  a  s 
a  a    end  matter pair atoms inspected 
lemma     dlp function components s    s  scc      s  s 
a  a  every a  s  a  s   
proof      s  s    b  s  b  s  b  b    consider
a  s  a  s    follows a  b  b  a  denition sccs  thus 
a  a  transitive 
    holds trivially sccs non empty 

proposition     relation scc     reflexive  transitive  antisymmetric 
   

fijanhunen  oikarinen  tompits   woltran

proof  relation scc     reexive transitive denition  antisymmetry  consider s    s  scc     s  s  s  s    follows
lemma     that  every a  s  a  s    a  a  a  a    thus  s    s 
maximality components scc     

 
consequently  may conclude hscc     partially ordered set  since
nite denition  hscc      maxima minima elements need
unique  particular  scc     minimum element s  scc    
s  s  s  implies s    s    s  scc      thus  may
apply principle well founded induction using minima hscc      basis 
given structure hscc      i  dlp function   hr  i  o  decomposed following way  set rules associated scc     def r  s 
     i e   set defining rules r  general  head arbitrary rule
b  c r may coincide sense     several sccs  implies
rule included def r  s  several scc      however  distribution
rules perfect harmony last two conditions denition      must
bear mind integrity constraints b  c included def r  s 
scc      access integrity constraints set r rules  dene
ic r     a b  c r       

    

ready present decomposition based scc     
definition     given dlp function   hr  i  o  i  decomposition induced
scc     includes dlp function
    hic r   at ic r    i   at r     

    

and  scc      dlp function
  hdef r  s   at def r  s     s  s  i 

    

purpose extra module   keep track integrity constraints well
input atoms mentioned rules r  modules involved
decomposition induced sccs  refers modules using
at def r  s     input signature provides dening rules  if any  every
atom s  recall output atom dening rules falsied default 
proposition     dlp function   hr  i  o  decomposition based
scc      join
f
    
    sscc      
defined equal  

proof  let us consider   scc      composition  
dened modules involve hidden atoms  ato         
def r         def r  r     def r   s    def r  s    def r  r   s  sets rules
r    ic r  r    def r  s   join   dened respective composition
integrity constraints   create dependencies dg       
   

fimodularity aspects disjunctive stable models

let us perform similar analysis s  s  based two dierent components
s    s  scc      clear s  s  dened since modules involve
hidden atoms  s  s      def r   s      def r  s      def r  r   s   
def r   s      def r  s      def r  r   s     r    def r  s    r    def r  s    
since pairwise joins dened  overall join      dened  denition    
denition scc      outcome equal

   ic r  sscc     def r  s    r 

   sscc       o 


    at ic r     o    i   at r     o  sscc      at def r  s     o    i 
corollary     dlp function ath      decomposition based
scc     
sm     sm    
  sscc     sm s    




example     consider following dlp function  
 a  b  c  d 
b c  
a  c  b  c 
a  d  b  d 
b 
c d 
b a 
c 

so  ati        ato       a  b  c  d   ath        two sccs dg     
viz  s     a  b  s     c  d   resulting decomposition consists
    h  a  c  a  d  b  c  b  d    a  b  c  d     i 
s    h a b c   b  b a    c  d    a  b   i 
s    h a b c   c d  c    a  b    c  d   i 
respective sets stable models
sm    
sm s   
sm s   
sm  

 
 
 
 

  a  b    c  d    a    b    c    d     
  a  b    c    d    c  d   
  c  d    a    b    a  b   
  a  b    c  d   

next  address case dlp functions involving hidden atoms  i e  
ath       holds  then  components dg     subsets ato    ath   
revise      accordingly  dlp function   hr  i  o  hi scc     
  hdef r  s   at def r  s     s  o  hi 

    

unfortunately  decomposition based modules form      likely negrained  certain components s    s  scc     s     s    respective
   

fijanhunen  oikarinen  tompits   woltran

modules s  s  conforming      might respect hidden atoms other 
similar setting may arise   individual module based scc    
integrity constraints refer hidden atoms   problem would disappear
hidden atoms revealed hardly appropriatethere good reasons
hide certain atoms knowledge representation perspective 
way approach problem distinguish components s  scc    
s  scc     respective modules s  s  would respect hidden
atoms other  i e   hidden atom dened one would referred othereither
positively negatively  similar conicts could arise due integrity constraints packed
module   distinguished denition      rst sight  amalgamate  
module whose hidden atoms occur integrity constraints     but 
order avoid fusions kind far possible  worth redistributing integrity
constraints referring hidden atoms  clearly possible integrity constraints referring hidden atoms involved single component only  formalize ideas presented
far  distinguish precise relation among components scc     follows 
definition     given dlp function   components s    s  scc     respect
hidden atoms other  denoted s   h s    s     s 
   hidden atom h ath  s    h ati  s    
   hidden atom h ath  s    h ati  s    
   hidden atoms h  ath  s    h  ath  s    occurrence integrity constraint b  c  
clear  h irreexive symmetric components scc    
dlp function   moreover  transitive closure  h   denoted   
h   gives rise
 
repartitioning scc     maximal block s            sn components
si   
h sj holds every    j induces module determined      union
  s        sn   key observation modules associated dierent blocks
components respect hidden atoms makes theorem     applicable
level abstraction  summarize treatment dlp functions involving hidden
atoms rules  revise denition     accordingly 
definition     given dlp function   hr  i  o  hi  decomposition induced
scc       
h includes dlp function
    hic   r   at ic   r    i   at r     

    

ic   r      b  c r    b c  h     and  maximal block s            sn
components scc     si   
h sj every    j  dlp function
  hdef r  s  ics  r   at def r  s  ics  r     s  o  hi

    

  s        sn ics  r      b  c r    b c   s h       
regards example      denitions         yield identical decompositions
dlp function question  eects hiding demonstrated following example 
   

fimodularity aspects disjunctive stable models

example     consider dlp function   hr    o  hi 
r     a  c  b   b c   c d  c  b 
h    a  b  c  d   exact partitioning atoms h varies case
case analyzed below  sccs scc     s     a   s     b   s     c  d  
   take atoms visible   i e   h     decomposition yields three modules  s    h a b     b    a   i  s    h a b   b c     a  c  d    b   i 
s    h b c   c d  c  b    b    c  d   i  addition module
    h  a  c    a  c     encompassing integrity constraints 
   hide h    a    obtain s   h s  disjunctive rule b   therefore  components s  s  must placed block maximal
giving rise module   h  a  c  b   b c     c  d    b    a i
  s  s     a  b   modules     s  listed above 
   finally  set h    a  c    obtain s   h s  b c s   h s 
a  c addition s   h s  stated above  since       decomposition
effectively collapses single module     s  s  s   
note non trivial modules mentioned
sm s   
sm s   
sm s   
sm    
sm s  

 
 
 
 
 

  a    b   
  b    a  b    b  c    a  c    b  d    a  d    b  c  d    a  c  d   
  b    c  d   
    c    a  c   
  b    a  c    b  c    b  d    a  c  d    b  c  d   

but  regardless decomposition obtained  holds respective joins
sm    
 
 
 

sm s   
sm s   
sm s   
sm    
sm s  
sm s   
sm  
sm s  
sm  
  a  c  d    b   

calculations involving
important notice allowed combinations
stable models determined terms joint visible atoms modules involved 
instance  atv  s    atv  s       a  b   b  c  d     b  sm s   

sm s      a   c  d    b   b       a  c  d    b   denition      thus  interestingly 
role remaining two modules s    merely approve upon two
models  recalling discussion introduction  suggests strategy gives
precedence
   evaluation modules stable models 
   combination stable models modules visible atoms common 
   

fijanhunen  oikarinen  tompits   woltran

   shifting disjunctions
section  continue pursuit applications module theorem established
section    generalize principle shifting disjunctive rules  gelfond et al        
dix et al         applying results paper  roughly speaking  idea behind
shifting translate disjunctive rule b  c several normal  non disjunctive 
rules shifting head atoms h negative literals h body  instance 
simple disjunctive rule b c captured normal rules
b  c 

b a  c 



c a  b 

shown eiter et al          local shifting transformation preserves ordinary
equivalence  i e   stable models    application technique is  however  pre empted
presence head cycles  ben eliyahu   dechter         cycle provided
scc intersects head disjunctive rule b  c
 s a       instance  local shifting longer applicable rule b c
presence b b create strongly connected component    a  b  
consequence  respective dlp functions
    h a b c   b  b a      a  b  c   i 

    

    h a b  c  b a  c  c a  b  b  b a      a  b  c  

    

dierent stable models  sm         a  b    c   sm         c    discrepancy stable models settled applying decomposition technique
section    fact  leads proper generalization local shifting transformation
formalized dlp functions strongly connected components 
definition     let   hr  i  o  hi dlp function scc     respective set
sccs  general shifting dlp function gsh     hic r  r   i  o  hi 
r set rules
  a s  b  c   a   s    b  c r  scc          

    

hence  idea project head rule respect component s 
atoms dierence   shifted negative body  viewed
contribution disjunctive rule b  c particular component s 
example             scc           a  b    c   
gsh       h a b c  c a  b  b  b a      a  b  c   i 
importantly  sm gsh          a  b    c     sm      contrast set
sm         c   stable models        
    addition ordinary equivalence  uniform equivalence  eiter   fink        preserved local
shifting strong equivalence  lifschitz  pearce    valverde        

   

fimodularity aspects disjunctive stable models

prove correctness general shifting principle denition     
aim exploit decomposition denition     together modular
reconstruction proposition     compositionality stable semantics
corollary      extend coverage corollary      introduce explicit operators
revealing hiding atoms dlp functions follows 
definition     let   hr  i  o  hi dlp function  then 
   reveal   a    hr  i  a  h   ai  set h hidden atoms 
   hide   a    hr  i    a  h ai  set output atoms 
since denition stable models make dierence output atoms
hidden atoms  following properties easy verify  role hidden atoms
becomes important section   dlp functions compared other 
proposition     let dlp function 
   ath     sm     sm reveal   a   
   ato     sm     sm hide   a   
lemma     let dlp function ath        component scc     
respective module decomposition according definition      then 
sm s     sm gsh s    

    

proof  recall   hdef r  s   i  s  i  input signature   at def r  s    
s  notice component scc   s   hence gsh s   set rules
r     a s  b  c   a   s    b  c def r  s   
consider interpretation s  input output signatures
  respectively  thus  mi   mo   s  then  following equivalences
hold 






b  def r  s  mi  mo
b  c def r  s  mi mo    c
b   c def r  s    ao   b   bo   c   co  
mi    ai bi ci   mo    co
b   c   ai r   ao   b   bo   c   co  
mi    ai bi ci   mo    co
b  c r  mi mo    c
b  r  mi  mo  

thus  conclude  def r  s  mi  mo coincides  r  mi  mo   and  consequently  mo
mm  def r  s  mi  mo   mo mm  r  mi  mo    therefore  sm s  mi    
sm gsh s   mi    since and  particular  mi arbitrarily chosen beginning 
obtain equality stable models stated      directly corollary     

   

fijanhunen  oikarinen  tompits   woltran

theorem     dlp function   hr  i  o  hi  sm     sm gsh    
proof  since may hidden atoms  corollary     applicable decomposition based scc      thus  start   reveal   h    hr  i  h 
rather itself  since sccs independent hiding  scc        scc    
gsh      reveal gsh   
h   since ath       construction  know
f

proposition         sscc           applying gsh   equation yields
f
gsh          sscc     gsh s    

    

regards respective sets stable models  obtain
sm   

 



 
sm   


 

sm gsh     

 

sm    
 

 

sscc     

sm s   

 corollary     

sscc     

sm gsh s    

 lemma     
 corollary          

follows proposition     sm hide    h     sm      sm gsh      
sm hide gsh     h    since hide    h    hide gsh     h    gsh   
established sm     sm gsh    desired 

according denition      decompositions dlp functions create multiple copies
disjunctive rules whose heads intersect several sccs  introduction copies
circumvented applying general shifting technique denition     
example     dlp function example      obtain r     ab c  d 
b  b a  r     c a  b  c d  c  sets rules associated     hr     c  d    a  b       hr     a  b    c  d   i       
hr  r       a  b  c  d   defined 

observations enable us view disjunctive rules shared modules
associated sccs syntactic sugar  however  clever implementation save space
using shared rules  worst case  unwinding rule a  b  c coincides
respective sccs s            sn a  s            sn may create n copies
body b c  quadratic blow up partly alleviated introducing new
atom b name body  thus result shifting a  s            sn becomes
a  b  a             
  
 
ai b  a            ai    ai              
  
 
b  a            an 
together dening rule b b  c b  implementation general
shifting principle called dencode    requested so  calculates beforehand whether
pays introduce new atom body disjunctive rule not 
    available http   www tcs hut fi software asptools  experimenting 

   

fimodularity aspects disjunctive stable models

   equivalence dlp functions
concept visible equivalence originally introduced order neglect hidden atoms
logic programs  theories interest  compared basis models  janhunen         oikarinen janhunen      a  extended idea level
logic program modulesgiving rise notion modular equivalence logic programs 
section  generalize concept modular equivalence dlp functions
introduce translation based method checking modular equivalence dlp functions
following analogous approaches oikarinen janhunen              
    modular equivalence
module interfaces must taken properly account dlp functions compared 
reason  consider two dlp functions     compatible
ati        ati      ato        ato      
definition     dlp functions     modularly equivalent  denoted      

       compatible
   bijection f   sm     sm     interpretations
sm      atv        f  m   atv      
proof congruent lifts case normal programs  oikarinen
  janhunen      a  disjunctive case using theorem     
proposition     let         dlp functions       
  defined       
proof  let     hr    i    o    h      hr    i    o    h  dlp functions
        hr  i  o  hi dlp function acting arbitrary context  
      dened  consider sm      theorem    
implies m    at     sm     n   at   sm    since      
i    i    o    o    bijection f   sm     sm    
m   i  o      f  m     i  o   

    

holds m    dene m    f  m     since m  n compatible denition     
holds  models m  n compatible i    i  o    o    thus  m  n
sm     theorem     eectively described mapped model
sm     function g   sm     sm     dened
g m     f  m at       m at    
clearly  g maps set visible atoms itself  is 
 i  o  o    g m    i  o  o  
justications g bijection follows 
   

fijanhunen  oikarinen  tompits   woltran

g injection     n implies g m      g n   m  n sm      since
f  m at         f  n at      at      n at   
g surjection  n sm        f    n at       n at   
sm     g m     n   since f surjection 
inverse function g     sm     sm     g dened setting
  f    n at       n at     thus       

note gsh   follows directly theorem      applying proposition    
context theorem     indicates shifting localized particular component
  larger dlp function   since   gsh      

g    n  

    verifying modular equivalence
oikarinen janhunen        proposed translation based method verication
weak equivalence disjunctive logic programs  two logic programs weakly equivalent exactly set stable models  thus  weak equivalence
seen special case modular equivalence dlp functions    
ati      ath        ati      ath          motivates us adjust translationbased technique verication modular equivalence  observed previous work
 janhunen   oikarinen        oikarinen   janhunen      a   verication visible modular equivalence involves counting problem general  reduction computational time complexity achieved programs enough visible atoms 
referred eva property short   janhunen   oikarinen         dlpfunction   hr  i  o  hi  dene hidden part restricted dlp function
h   hdef r  h   o  h  enables evaluation hidden atoms h given
arbitrary truth values atoms o  recalling denition      use
instantiation h respect interpretation mv ati  h    i e   h  mv   dene
eva property dlp function  
definition     dlp function   hr  i  o  hi enough visible atoms iff h  mv
unique stable model mv atv      ati  h   
idea behind translation based method oikarinen janhunen       
ordinary disjunctive programs r  r  weakly equivalent translations
tr r    r    tr r    r    stable models  following  propose modied
version translation function adjusted verication modular equivalence  order
able verify modular equivalence  need take semantics atoms
input signature account well role hidden atoms modular equivalence
programs consideration  case dlp functions  transform pair  
  compatible dlp functions dlp function eqt         stable
model stable model sm     stable model
n sm     atv        n atv       form translation composition
dlp functions order fully exploit compositionality stable model semantics
justifying correctness method 
follows  use new atoms     appearing at     at    
atom a  use shorthand    a   a  set atoms 
   

fimodularity aspects disjunctive stable models

analogously dened shorthands   moreover  diff  unsat  unsat   ok new
atoms appearing at     at      translation eqt         
summarized denition     below  consists following three parts 
 i  dlp function   naturally captures stable model sm     
 ii  dlp function hidden       hrh   o  h   provides representation
hidden part     hr  i  o  hi evaluated respect visible part  
input signature hidden     consists visible atoms atv        atv       
o  set rh contains rule ah bv bh    av cv ch   b  c r
ah      i e   b  c def r  h   hidden parts rules renamed
systematically using atoms ath        capture unique stable model
n     h  mv expressed ath      rather ath       note existence
uniqueness n guaranteed eva property 
 iii  finally  dlp function
tr       hrtr   h   h  unsat  unsat   diff  ok   h
provides minimality check  set rtr contains
   rule unsat bv bh    av ah cv ch   rule b  c r 
   rules a    unsat a    unsat o  rules
    unsat     unsat h 
   rule unsat bi bo bh    ai ao ah cv ch    unsat rule
b  c r 
   rule diff a    unsat o  rule diff     unsat
h 
   following rules 
ok unsat 

ok diff  unsat  unsat  

ok 

intuition behind translation tr     follows  rules rst
item check whether interpretation l at     corresponding actual input
k    l  i o    a   l h  atv      ath      tr     satises
rules     rules   satised  rules items    activated
literals unsat bodies  rules second item used
generate subset l l l ati        l ati       achieved
introducing new atom ato      ath       rules third
item check whether representation l ati      ato      ath        i e  
k    l i   a   l  o h    satises rules l
    rules
fourth item check whether l proper subset l  finally  rules fth
item summarize reasons l cannot stable model     i e   either
rules   satised l  l minimal model l
    net eect
construction  tr     k stable model l stable model    
   

fijanhunen  oikarinen  tompits   woltran

definition     let       hr  i  o  hi compatible dlp functions enough
visible atoms  then  translation eqt         given   hidden     tr     
translation tr     minimality check essentially contains rules
tr r    r      r    tr r    r    translation dened oikarinen janhunen
       sets r  r  disjunctive rules  two aspects  however 
first  occurrences hidden atoms h additionally represented using counterparts h   second  need renamed versions atoms h
interpretation atoms input signature kept xed  finally  note
dlp functions     correspond ordinary disjunctive logic programs  i e  
    hr      o      hr      o  i  translation eqt         coincides
tr r    r    
theorem     let     compatible dlp functions enough visible atoms 
then      iff sm eqt            sm eqt             
proof sketch  let       hr  i  o  hi compatible dlp functions enough
visible atoms  theorem      given compatible interpretations m  at      m 
at hidden       m  at tr         m  m  m  stable model translation eqt         m  sm      m  sm hidden       m  sm tr       given
interpretation m  at      unique stable model m  sm hidden     
compatible m    since   eva property  hence  hidden     constrain
stable models composition eqt          whenever m  compatible m 
m    holds m   i oh      m  m    i oh   m  sm tr     
interpretation m   i o  a h   m    stable model   established
oikarinen janhunen        theorem    

verifying modular equivalence dlp functions forms      
possible streamline translations involved verication task 
theorem     let     compatible dlp functions enough visible atoms 
dlp function     defined  then     
iff sm eqt             sm eqt              
context arbitrary dlp function  i e   necessary
eva property  long     dened  prove theorem      notice
due structure translation  eqt         dened whenever  
dened  theorems         applied 

   related work
eiter et al       a  consider use disjunctive datalog programs query programs
relational databases  approach  query programs formalized triples h  r  si
set disjunctive rules r signatures input output
relations  respectively  whereas auxiliary  hidden  predicates left implicit  hence 
propositional case  notable dierence respect denition     input
atoms allowed occur heads disjunctive rules  regards semantics 
   

fimodularity aspects disjunctive stable models

program reduced respect complete input database specied terms
r  yielding instantiation  d   and  among others  stable model semantics applied
 d  analogy denition      however  contrast modular architecture  eiter
et al       a  take positive negative dependencies account recursion
modules tolerated  resulting hierarchy complete components admits
straightforward generalization splitting sequences  lifschitz   turner        
essential dierence partial order rather total order modules assumed 
respect  worth pointing partial orders dlp functions permitted
 
modularity gained attention context conventional  monotonic  logic
programming  see work bugliesi  lamma  mello        survey  two mainstream approaches identied  rst called programming in the large algebraic operators introduced construction logic programs modules 
approach paper falls categorythe join example operators 
other  quite dierent programming in the small approach  extend underlying logical language terms abstraction mechanisms  approach eiter et al 
     b   instance  logic program modules viewed generalized quantifiers
allowed nest hierarchical fashion  give idea approach  consider
module formalizes transitive closure relation denoted predicate rel     
tclo x  y  rel x  y  

tclo x  y  tclo x  z   rel z  y  

here  tclo     acts output predicate module tclo rel  whereas rel    
input predicate  module invoked create transitive closure binary
relation substituted rel     above  consider  instance  rule
loop x  tclo edge  x  y   tclo edge  y  x 
captures nodes involved loops directed graph whose edges supposed
represented predicate edge      approach  call tclo edge  would result
one module part respective ground program input output signatures
   edge x  y      x  n     tclo x  y      x  n 
case n vertices  however  architecture eiter et al       b   module
tclo rel  invoked several times form transitive closures dierent relations 
eectively propositional approach  invocation tclo rel  would map new module 
although modules could obtained straightforward renaming predicates 
aspect illustrates power programming in the small approach  here  tclo rel  acts
new parameterized connective programmer concisely refer new
relation  viz  transitive closure rel case  but  spite succinctness
point  relations may unwound actual implementation  aspect
made explicit modular action description  mad  language proposed lifschitz
ren         modular action description turned single module description
recursive fashion  outcome determines meaning modular description via
embedding asp  lifschitz   turner        
faber  greco  leone        apply magic set method evaluation datalog
programs negation  notion module based concept independent
   

fijanhunen  oikarinen  tompits   woltran

set  non disjunctive logic program   hr    o  i  set satises 
s  following two conditions 
   rule h b  c r h   a  b c s 
   b c dangerous rule h b  c r   h  b c s 
skip exact denition dangerous rules which  roughly speaking  may interfere
existence stable models  clear independent sets splitting sets sense
denition       vice versa general  hence  module theorem provided
faber et al         viewed special case splitting set theorem and  therefore 
observations presented section     apply independent sets well 

    conclusion discussion
paper  introduced formal framework modular programming context
disjunctive logic programs stable model semantics  framework based
notion dlp function puts eect appropriate input output interfacing
disjunctive logic programs  analogous module concepts already studied
cases normal logic programs smodels programs  oikarinen   janhunen      a 
even propositional theories  janhunen      a   special characteristics disjunctive
rules properly taken account syntactic semantic denitions dlpfunctions presented herein  respect  would draw readers attention
denition      item     denition      items      well denition     
undoubtedly  main result paper module theorem  i e   theorem     
proved dlp functions generalthus covering class disjunctive programs  module theorem important provides compositional semantics
disjunctive programs generalizes existing approaches based splitting sets  lifschitz   turner        magic sets  faber et al          although
approach based number design decisions  e g   regards denition module
composition  nevertheless brings limits modular programming context
nonmonotonic declarative language  module theorem exploited number ways asp based disjunctive logic programs  demonstrated section   
provides basis decomposing disjunctive programs components hence
localization reasoning tasks  moreover  established section    technique
shifting disjunctive rules generalized disjunctive programs involving head cycles 
actually  generalized form enables us remove shared disjunctive rules altogether
might desirable due higher space requirements  finally  theory modular
equivalence fully applicable dlp functions demonstrated section   
addition results discussed above  anticipate applications module theorem future  strongly believe research direction yields
results theoretical interest leads development practicably useful software
engineering methods asp  fact  rst tools decomposing linking programs
already implemented context smodels system    results section   enable development analogous tools used disjunctive solvers
    see modlist lpcat asp tools collection http   www tcs hut fi software asptools  

   

fimodularity aspects disjunctive stable models

claspd  cmodels  dlv  gnt  implementation general shifting
principle  called dencode  asp tool collection  results section   pave way
extending translation based verication tool  dlpeq  janhunen   oikarinen        
verication modular equivalence  extension already available
respective tool  lpeq  smodels programs  oikarinen   janhunen          
acknowledgments work partially supported academy finland projects          advanced constraint programming techniques large structured problems           methods constructing solving large constraint
models   austrian science foundation  fwf  projects p       formal methods comparing optimizing nonmonotonic logic programs  p     
 methods methodologies developing answer set programs   authors would
thank anonymous referees constructive comments well martin gebser torsten schaub suggestion exploit program completion loop formulas
proof module theorem  preliminary version paper appeared
proceedings  th international conference logic programming nonmonotonic
reasoning  lpnmr     vol       lncs  pp          tempe  az  usa  springer 

references
baral  c   dzifcak  j     takahashi  h          macros  macro calls use ensembles
modular answer set programming  etalle  s     truszczyski  m   eds    proceedings
  nd international conference logic programming  iclp      vol      
lncs  pp          seattle  wa  usa  springer 
ben eliyahu  r     dechter  r          propositional semantics disjunctive logic programs  annals mathematics artificial intelligence                
bugliesi  m   lamma  e     mello  p          modularity logic programming  journal
logic programming                
clark  k  l          negation failure  gallaire  h     minker  j   eds    logic
data bases  pp          plenum press  new york 
dix  j   gottlob  g     marek  v  w          reducing disjunctive non disjunctive
semantics shift operations  fundamenta informaticae                  
drescher  c   gebser  m   grote  t   kaufmann  b   knig  a   ostrowski  m     schaub 
t          conict driven disjunctive answer set solving  brewka  g     lang  j 
 eds    proceedings   th international conference principles knowledge
representation reasoning  pp          sydney  australia  aaai press 
eiter  t     fink  m          uniform equivalence logic programs stable model
semantics  palamidessi  c   ed    proceedings   th international conference
logic programming  iclp     vol       lncs  pp          mumbay  india 
springer 
    verification tools mentioned available http   www tcs hut fi software lpeq  

   

fijanhunen  oikarinen  tompits   woltran

eiter  t   fink  m   tompits  h     woltran  t          simplifying logic programs
uniform strong equivalence  lifschitz  v     niemel  i   eds    proceedings
 th international conference logic programming nonmonotonic reasoning
 lpnmr      vol       lnai  pp        fort lauderdale  fl  usa  springer 
eiter  t     gottlob  g          computational cost disjunctive logic programming 
propositional case  annals mathematics artificial intelligence               
    
eiter  t   gottlob  g     mannila  h       a   disjunctive datalog  acm transactions
database systems                 
eiter  t   gottlob  g     veith  h       b   modular logic programming generalized
quantiers  dix  j   furbach  u     nerode  a   eds    proceedings  th
international conference logic programming nonmonotonic reasoning  lpnmr      vol       lncs  pp          dagstuhl  germany  springer 
eiter  t   ianni  g   lukasiewicz  t   schindlauer  r     tompits  h          combining
answer set programming description logics semantic web  artificial
intelligence                       
erdem  e     lifschitz  v          tight logic programs  theory practice logic
programming                  
faber  w   greco  g     leone  n          magic sets application data integration  journal computer system sciences             
gaifman  h     shapiro  e          fully abstract compositional semantics logic programs  proceedings   th annual acm symposium principles programming languages  pp          austin  tx  usa  acm press 
gebser  m   kaminski  r   kaufmann  b   ostrowski  m   schaub  t     thiele  s       a  
engineering incremental asp solver  de la banda  m     pontelli  e   eds   
proceedings   th international conference logic programming  iclp    
vol       lncs  pp          udine  italy  springer 
gebser  m   schaub  t   thiele  s   usadel  b     veber  p       b   detecting inconsistencies large biological networks answer set programming  de la banda 
m     pontelli  e   eds    proceedings   th international conference logic
programming  iclp     vol       lncs  pp          udine  italy  springer 
gelfond  m     gabaldon  a          building knowledge base  example  annals
mathematics artificial intelligence                   
gelfond  m     leone  n          logic programming knowledge representation
a prolog perspective  artificial intelligence                 
gelfond  m     lifschitz  v          stable model semantics logic programming 
kowalski  r  a     bowen  k  a   eds    proceedings  th international conference logic programming  iclp     pp            seattle  wa  usa  mit
press 
   

fimodularity aspects disjunctive stable models

gelfond  m     lifschitz  v          classical negation logic programs disjunctive
databases  new generation computing            
gelfond  m   przymusinska  h   lifschitz  v     truszczyski  m          disjunctive defaults  allen  j  f   fikes  r     sandewall  e   eds    proceedings  nd international conference principles knowledge representation reasoning  pp 
        cambridge  ma  usa  morgan kaufmann 
giunchiglia  e   lierler  y     maratea  m          answer set programming based
propositional satisability  journal automated reasoning                 
janhunen  t           in translatability results normal logic programs propositional theories  journal applied non classical logics                
janhunen  t       a   modular equivalence general  ghallab  m   spyropoulos  c  
fakotakis  n     avouris  n   eds    proceedings   th european conference
artificial intelligence  ecai     pp        patras  greece  ios press 
janhunen  t       b   removing redundancy answer set programs  de la banda 
m     pontelli  e   eds    proceedings   th international conference logic
programming  iclp     vol       lncs  pp          udine  italy  springer 
janhunen  t   niemel  i   seipel  d   simons  p     you  j  h          unfolding partiality
disjunctions stable model semantics  acm transactions computational
logic             
janhunen  t     oikarinen  e          lpeq dlpeq translators automated equivalence testing logic programs  lifschitz  v     niemel  i   eds    proceedings
 th international conference logic programming nonmonotonic reasoning
 lpnmr      vol       lnai  pp          fort lauderdale  fl  usa  springer 
janhunen  t     oikarinen  t          automated verication weak equivalence within
smodels system  theory practice logic programming                
junttila  t     niemel  i          towards ecient tableau method boolean circuit
satisability checking  lloyd  j  w   et al   eds    proceedings first international conference computational logic  cl        vol       lncs  pp         
london  uk  springer 
koch  c   leone  n     pfeifer  g          enhancing disjunctive logic programming systems
sat checkers  artificial intelligence                    
lee  j     lifschitz  v          loop formulas disjunctive logic programs  palamidessi 
c   ed    proceedings   th international conference logic programming
 iclp      vol       lncs  pp          mumbay  india  springer 
leone  n   pfeifer  g   faber  w   eiter  t   gottlob  g     scarcello  f          dlv
system knowledge representation reasoning  acm transactions computational logic                
   

fijanhunen  oikarinen  tompits   woltran

lifschitz  v          computing circumscription  joshi  a  k   ed    proceedings
 th international joint conference artificial intelligence  ijcai      pp         
los angeles  ca  usa  morgan kaufmann 
lifschitz  v   pearce  d     valverde  a          strongly equivalent logic programs  acm
transactions computational logic                
lifschitz  v     ren  w          modular action description language  proceedings
  st national conference artificial intelligence  aaai     pp         
boston  ma  usa  aaai press 
lifschitz  v     turner  h          splitting logic program  hentenryck  p  v   ed   
proceedings   th international conference logic programming  iclp     
pp        santa margherita ligure  italy  mit press 
lifschitz  v     turner  h          representing transition systems logic programs 
gelfond  m   leone  n     pfeifer  g   eds    proceedings  th international
conference logic programming nonmonotonic reasoning   lpnmr      vol 
     lnai  pp         el paso  tx  usa  springer 
lin  f     zhao  y          assat  computing answer sets logic program sat
solvers  artificial intelligence                    
marek  v  w     truszczyski  m          stable models alternative logic programming paradigm  apt  k  r   marek  v  w   truszczyski  m     warren 
d  s   eds    logic programming paradigm     year perspective  pp         
springer 
mccarthy  j          applications circumscription formalizing commonsense knowledge  artificial intelligence            
niemel  i          logic programs stable model semantics constraint programming
paradigm  annals mathematics artificial intelligence                  
oikarinen  e     janhunen  t          verifying equivalence logic programs
disjunctive case  lifschitz  v     niemel  i   eds    proceedings  th international conference logic programming nonmonotonic reasoning  lpnmr     
vol       lnai  pp          fort lauderdale  fl  usa  springer 
oikarinen  e     janhunen  t       a   achieving compositionality stable model
semantics smodels programs  theory practice logic programming         
       
oikarinen  e     janhunen  t       b   implementing prioritized circumscription computing disjunctive stable models  dochev  d   pistore  m     traverso  p   eds   
artificial intelligence  methodology  systems  applications    th international
conference  aimsa     vol       lncs  pp          varna  bulgaria  springer 
oikarinen  e     janhunen  t          translation based approach verication
modular equivalence  journal logic computation              
   

fimodularity aspects disjunctive stable models

reiter  r          theory diagnosis rst principles  artificial intelligence         
     
simons  p   niemel  i     soininen  t          extending implementing stable
model semantics  artificial intelligence                   

   


