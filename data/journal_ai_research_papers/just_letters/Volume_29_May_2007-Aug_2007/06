journal artificial intelligence research                 

submitted          published        

language search
jinbo huang

jinbo huang nicta com au

logic computation program
national ict australia

adnan darwiche

darwiche cs ucla edu

computer science department
university california  los angeles

abstract
paper concerned class algorithms perform exhaustive search
propositional knowledge bases  show algorithms defines generates
propositional language  specifically  show trace search interpreted
combinational circuit  search algorithm defines propositional language
consisting circuits generated across possible executions algorithm 
particular  show several versions exhaustive dpll search correspond
well known languages fbdd  obdd  precisely defined subset d dnnf 
thus mapping search algorithms propositional languages  provide uniform
practical framework successful search techniques harnessed compilation
knowledge various languages interest  new methodology whereby power
limitations search algorithms understood looking tractability
succinctness corresponding propositional languages 

   introduction
systematic search algorithms lie core wide range automated reasoning systems 
many based procedure branches node search tree
generated splitting possible values chosen variable  one prototypical example
dpll algorithm  davis  logemann    loveland        propositional satisfiability
 sat   given propositional formula  problem sat determine whether
formula satisfying assignmentan assignment boolean values      
variables formula evaluates    example   x       x       x      
satisfying assignment following formula   x  x    x  x  x    x  x  x    
determine satisfiability given formula   dpll chooses variable x
formula  recursively determines whether satisfiable case x set    case x
set    declares satisfiable precisely least one two cases results
positive answer  effect  algorithm performs systematic search space
variable assignments terminates either finding satisfying assignment 
realizing assignment exists 
despite simplicity  dpll long remained basis sat solvers
employ systematic search  berre   simon         finds natural counterparts
general constraint satisfaction problems  variables restricted
boolean domain  several decades sustained research greatly enhanced efficiency
scalability dpll based search algorithms  today routinely used solve

c
    
ai access foundation  rights reserved 

fihuang   darwiche

practical problems several million variables  zhang   malik         algorithms
successful  indeed  become recent trend areas formal
verification modify produce solutions propositional formula  mcmillan 
      chauhan  clarke    kroening        grumberg  schuster    yadgar        
alternative traditional practice  mcmillan        converting formula
ordered binary decision diagram  obdd   bryant         modifications thus involved
form dpll search terminate finding first solution 
extended exhaust whole search space  formula shown earlier 
example output exhaustive search could following set three solutions
  x       x       x         x       x       x         x       x         note solution
defined assignment boolean values  possibly all  variables
satisfies formula regardless values variables  last solution
set  example  represents two satisfying assignments variable x  free
assume either value 
producing solutions propositional formula is  course  one possible
computational tasks exhaustive search useful  tasks include
counting number satisfying assignments formula  known model counting
 birnbaum   lozinskii        bayardo   pehoushek        bacchus  dalmao    pitassi 
    b  sang  bacchus  beame  kautz    pitassi        sang  beame    kautz        
processing certain types queries belief constraint networks  dechter   mateescu 
    b      a  
paper uncover fundamental connection class exhaustive
search algorithms  group propositional languages extensively studied field knowledge compilation  darwiche   marquis         specifically  show
exhaustive search algorithm based variable splitting  run propositional
knowledge bases  defines generates propositional language precise sense 
trace single search  recorded graph  interpreted combinational
circuit logically equivalent propositional knowledge base search
run  search algorithm defines propositional language consisting
circuits generated legal executions algorithm  show  particular 
exhaustive dpll corresponds language fbdd  free binary decision diagrams 
 blum  chandra    wegman         exhaustive dpll fixed variable ordering corresponds language obdd  ordered binary decision diagrams   bryant        
exhaustive dpll decomposition corresponds well defined subset language
d dnnf  deterministic decomposable negation normal form   darwiche        
establishment correspondence supplies bridge field knowledge compilation  areas automated reasoning  including propositional satisfiability  search algorithms extensively studied  particular  leads
following two sets theoretical practical benefits 
first  show class search algorithms described immediately
turned knowledge compilers respective propositional languages define 
simply recording trace search  realization provides uniform practical framework successful techniques developed context search
directly used compilation knowledge various languages interest  particular 
discuss recent advances dpll search  including sophisticated conflict analysis 
   

fithe language search

dependency directed backtracking  clause learning  new variable ordering heuristics 
data structures faster constraint propagation  harnessed building efficient
practical knowledge compilers 
second  show how  looking known properties propositional languages 
able answer fundamental level  concrete terms  two important questions
regarding power limitations class search algorithms 
algorithms do  not  specifically  discuss tractability
propositional language defined search algorithm illustrates power algorithm 
succinctness constraints language illustrate limitations 
complement discussions relating results previous work knowledge compilation recent body work centering notion and or search
 dechter   mateescu      b      a  marinescu   dechter         particular  discuss
similarities well differences and or search d dnnf compilation 
finally  present experimental results implementations exhaustive search algorithms define distinct propositional languages  use programs compile set
propositional formulas respective languages  demonstrate practicality knowledge compilation framework  empirically illustrate variation
language succinctness response variation search strategy 
remainder paper organized follows  section   reviews number
propositional languages concerned work theoretical roles relations
knowledge compilation  section   discusses dpll search algorithm propositional
satisfiability exhaustive extension  introduces notion interpreting
trace search combinational circuit  section   detailed exposition mapping
variants exhaustive dpll fbdd  obdd  subset d dnnf  well techniques involved transforming algorithms practical knowledge compilers
respective languages  section   formalizes two fundamental principles relating intrinsic power limitations class exhaustive search algorithms  using recently proposed
model counting algorithms concrete examples  relate results previous work
section    present experimental results section    conclude section    proofs
theorems given appendix 

   propositional languages properties
study propositional languages  i e   representations propositional theories 
central subject knowledge compilation  concerned task converting given knowledge base one language another certain reasoning
tasks become tractable compiled knowledge base  selman   kautz        del val 
            marquis        selman   kautz        cadoli   donini        darwiche  
marquis        darwiche              coste marquis  berre  letombe    marquis        
propositional theories compiled language obdd  example 
equivalence tested time polynomial sizes obdds  meinel  
theobald         constant time obdds use variable order  bryant        
recent applications compilation using language d dnnf found
fields diagnosis  barrett              huang   darwiche      a  elliott   williams       
siddiqi   huang         planning  barrett        palacios  bonet  darwiche    geffner 
   

fihuang   darwiche

 a  nnf

 b  decision node



















x







x



 c  alternatively
x



b

b



c





c





figure    nnf circuit decision node 
      huang        bonet   geffner         probabilistic reasoning  chavira   darwiche 
      chavira  darwiche    jaeger         query rewrites databases  arvelo  bonet 
  vidal        
section review set propositional languages discuss established
body results concerning tractability succinctness  darwiche   marquis       
several languages resurface section   exhaustive search
algorithms mapped  properties prove vital formalization section  
two fundamental principles relating power limitations exhaustive search
algorithms 
    propositional languages
following conventions darwiche marquis         consider graph representations propositional theories  allow sharing subformulas compactness  specifically  consider directed acyclic graphs  dags  internal node labeled
conjunction  and    disjunction  or     leaf labeled propositional
literal constant  true f alse        clear dag effectively
combinational circuit and gates  or gates  inverters  inverters appear
next inputs  variables   property characteristic negation normal form
 nnf   barwise         hence refer dags nnf circuits set
dags nnf language  figure  a depicts propositional theory represented
nnf circuit  next define interesting subsets nnf language 
popular language cnf  conjunctive normal form  defined
subset nnf satisfies  i  flatness  height dag two   ii 
simple disjunction  disjunction leaf nodes  i e   clause   similarly 
dnf  disjunctive normal form  subset nnf satisfies flatness simpleconjunction  conjunction leaf nodes  i e   term  
consider next set nested representations  starting dnnf  decomposable
negation normal form  language  set nnf circuits satisfying decomposability  conjuncts conjunction share variables  next language  d dnnf 
satisfies decomposability determinism  disjuncts disjunction pairwise
logically inconsistent  nnf circuit shown figure  a  example  d dnnf 
   

fithe language search

x 





x 


x 

x 

x 

x 

 a  dnnf

x 

x 
x 

x 

x 

 

 

 b  fbdd

x 

 

 

 c  obdd

figure    circuit dnnf  fbdd  obdd 
shown figure  a  contrast  dnnf d dnnf neither two
disjunction nodes satisfies determinism 
fbdd language subset d dnnf root every circuit
decision node  defined recursively either constant       disjunction
form figure  b x propositional variable decision nodes 
note equivalent compact drawing decision node figure  c widely
used formal verification literature  fbdds equivalently known bdds
 binary decision diagrams  satisfy test once property  variable appears
root to sink path  gergov   meinel          see figure  b fbdd
example using compact drawing 
obdd language subset fbdd circuits satisfy ordering
property  variables appear order root to sink paths  bryant         see
figure  c obdd example  using compact drawing   particular
variable order    write obdd  denote corresponding obdd subset
circuits use order   
    succinctness tractability propositional languages
given choice languages knowledge base may represented  one needs
strike balance size representation support provides
reasoning task hand  two properties representation often run counter
other  cnf  example  often convenient compactly encoding knowledge
base since many applications behavior system naturally described
conjunction behaviors components  however  typical reasoning tasks
efficiently carried cnf representations  efficient algorithm determine 
example  whether arbitrary clause entailed cnf formula  story changes
propositional theory represented language known pi  prime implicates 
subset cnf   definition pi supports linear time clausal entailment test 
downside is  unfortunately  pi representations exponentially larger
cnf equivalents worst case  karnaugh        forbus   de kleer        
therefore interested formally analyzing succinctness tractability
languages  given required reasoning task  choose succinct language
   fbdds known read once branching programs  wegener        

   

fihuang   darwiche

supports set necessary operations polynomial time  following classical
definition succinctness 
definition     succinctness  let l  l  two subsets nnf  l  least succinct
l    denoted l  l    iff exists polynomial p every circuit l   
exists logically equivalent circuit l     p      here       
sizes   respectively 
intuitively  language l  least succinct language l  given circuit l   
exists logically equivalent circuit l  whose size blow up  one
define l  strictly succinct l    denoted l    l    l  l  l    l   
languages described section     satisfy following succinctness relations  nnf
  dnnf   d dnnf   fbdd   obdd  nnf   cnf  dnnf   dnf  darwiche  
marquis         note  however  l  l  imply l    l  general 
words  imposing conditions representation necessarily reduce succinctness 
one example smoothness  requires disjuncts disjunction mention
set variablesit known condition  imposed d dnnf  reduce
succinctness  darwiche   marquis        
turn tractability languages  refers set polynomial time
operations support  according darwiche marquis         one traditionally
distinguishes two types operations circuits given language  queries
transformations  difference two queries return information
circuits  normally change them  transformations modify circuits generate
new ones  in language  
known results darwiche marquis        regarding tractability languages summarized table    queries  table    transformations  
abbreviations first row table   stand following eight queries  respectively 
consistency  is formula satisfiable   validity  does formula evaluate  
variable assignments   clausal entailment  does formula imply given clause  
implicant  is formula implied given term   equivalence  are two formulas logically equivalent   sentential entailment  does one formula imply other  
model counting  how many satisfying assignments formula have   model enumeration  what satisfying assignments formula   abbreviations
first row table   stand following eight transformations  respectively  conditioning  setting set variables constants   forgetting  existentially quantifying set
variables   single variable forgetting  existentially quantifying single variable   conjunction  conjoining set circuits   bounded conjunction  conjoining bounded
number circuits   disjunction  disjoining set circuits   bounded disjunction
 disjoining bounded number circuits   negation  negating circuit  
interestingly  table   offers one explanation popularity obdds formal verification efficient equivalence testing  among things  often critical  although
succinct  d dnnf fbdd known admit polynomial time equivalence
test  a polynomial time probabilistic equivalence test possible  see blum et al        
darwiche   huang         note although difference d dnnf
fbdd extent table  question mark equivalence test  eq  could
eventually resolved differently two languages 
   

fithe language search

table    polynomial time queries supported language   means supported unless
p np   means dont know  
language
nnf
dnnf
d dnnf
bdd
fbdd
obdd
obdd 
dnf
cnf

co




va




ce




im




































eq


 

 



se








ct






























table    polynomial time transformations supported language   means supported  means supported unless p np    means dont know  
language
nnf
dnnf
d dnnf
bdd
fbdd
obdd
obdd 
dnf
cnf

cd










fo



sfo











c


bc































c



bc






















c


 







worth pointing tractability respect queries generally improves language becomes restrictive  has conditions imposed  
tractability respect transformations may not  dnnf  example  supports
subset queries supported obdd according table    therefore
less tractable obdd point view  however  comes certain
transformations  operation forgetting  existential quantification   dnnf becomes tractable obdd according table    key reason shift
advantage transformations operate circuits given propositional language 
require result languagethis requirement become burden
restrictive language conditions need satisfied result
transformation generated 

   

fihuang   darwiche

    connection established
summarized discussed section rich body known results concerning
properties various propositional languages  results previously presented
guide task selecting suitable target compilation language applications
knowledge compilation  particular  suggest given reasoning task involving
knowledge compilation  one identify set operations required task 
select succinct target compilation language supporting operations  darwiche
  marquis        
following sections paper  wish establish fundamental connection
propositional languages distinct degrees succinctness tractability 
exhaustive search algorithms running distinct sets constraints  specifically 
show trace exhaustive search interpreted circuit representing
compilation propositional knowledge base search run  search
algorithm defines propositional language consisting possible traces 
connection serve bridge field knowledge compilation
areas automated reasoning search algorithms extensively
studied  affording two related sets benefits follows 
first direction  show connection provides set practical algorithms
compilation knowledge various languages  specifically  exhaustive search
algorithm directly turned knowledge compiler recording trace
execution graph  variations search algorithm nicely correspond
compilers different propositional languages  framework knowledge compilation
provides significant advantage many  past well future  advances search
automatically carry knowledge compilation  particular  discuss
knowledge compilers capitalize several important recent advances dpll search
propositional satisfiability  including sophisticated conflict analysis  dependency directed
backtracking  clause learning  new variable ordering heuristics  data structures faster
constraint propagation 
second direction  formulate two principles whereby intrinsic power
limitations given exhaustive search algorithm understood identifying
propositional language defined search algorithm  specifically  tractability
language illustrates power  usefulness  search algorithm succinctness
constraints language illustrates limitations  using group recently
proposed model counters concrete examples  show search algorithms used
model counters powerful enough support model counting query 
queries known tractable language d dnnf 
probabilistic equivalence test  darwiche   huang         hand  two fundamental limitations identified algorithms  well exhaustive
search algorithms based variable splitting  first traces restricted
subset d dnnf  potentially limiting efficiency search  second
inability produce traces without determinism  making overly constrained
compilation knowledge general languages d dnnf  dnnf 

   

fithe language search

proceed uncover connection search algorithms propositional
languages  starting systematic search algorithm propositional satisfiability 
exhaustive extension  notion trace search 

   systematic search satisfiability exhaustive extension
section introduce notion trace systematic exhaustive search 
show trace interpreted circuit  logically equivalent  and hence
compilation of  propositional knowledge base search run 
context systematically searching satisfying assignments propositional
formula  major approach problem propositional satisfiability  sat 
come known dpll  davis et al         
    dpll search exhaustive extension
algorithm   summary dpll sat  takes propositional formula cnf 
return       precisely formula satisfiable  unsatisfiable   works recursively case analysis assignment selected variable  line     formula
satisfiable either case results satisfiable subformula  line     two
subformulas denote  x    x     result replacing occurrences
x      respectively  keeping rules boolean logic  assume
literal becomes evaluates   result variable instantiation 
removed every clause contains it  literal becomes evaluates   
clauses contain removed   to facilitate subsequent discussion variants
dpll  omitted use unit resolution pseudocode  programs
used section    however  employ unit resolution   effect  algorithm   performs
search space variable assignments finds one satisfies given cnf
formula realizes satisfying assignments exist 
consider extending algorithm   go space satisfying assignmentsby always exploring branches line  rather terminate finding first one  figure  a depicts search tree exhaustive version dpll  particular variable ordering  following cnf formula 
 x  x     x  x  x     x  x  x     note drawing branches
search use dotted  solid  line denote setting variable      we refer
corresponding child search node low  high  child 
algorithm   dpll cnf     returns satisfiability
   empty clause
  
return  
   variables
  
return  
   select variable x
   return dpll  x     dpll  x    

   

fihuang   darwiche



x 


x 
x 



x 

unsat


sat

x 
unsat

  x 

unsat




x 


x 


x 
sat


x 

x   





  x  x      x  x   
 b  equivalent nnf circuit

sat

 a  termination tree

figure    trace exhaustive dpll search 
tree depicted figure  a known termination tree search 
captures set paths search space explored
termination search  particular  leaf tree labeled sat gives
partial variable assignment satisfies propositional formula regardless values
unassigned variables  whole tree characterizes precisely set satisfying
assignments  algorithm set find succeeded finding 
    trace search issue redundancy
alluded earlier  would view termination tree trace
search  make two important observations  first  trace
search depicted figure  a directly translated circuit nnf depicted
figure  b  involved rename sat unsat     invoke identity
figure  b figure  c described section      second  nnf circuit
logically equivalent to  hence compilation of  cnf formula
search run   note notion trace different used earlier work
establish power dpll proof system unsatisfiable cnf formulas 
example  earlier work shown unsatisfiable cnf formula  trace
dpll converted tree like resolution refutation  urquhart         
two observations imply exhaustive dpll powerful knowledge
compiler  long one takes  small  trouble recording trace  viewpoint
knowledge compilation  however  search trace recorded present form may
immediately useful  typically size proportional amount work
done produce it  answering even linear time query  which may require single
traversal compiled representation  compilation  example  would
one running whole search again 
problem remedied first realizing quite bit redundancy
search trace drawn  figure  a  example  two subgraphs whose
roots labeled x  isomorphic could merged one 
redundancy  course  present corresponding portions nnf circuit
shown figure  b 
   

fithe language search

distinguish two levels dealing issue redundancy trace 
first level  remove redundancy trace reducing tree
dag  repeated applications following two rules   i  isomorphic nodes  i e  
nodes label  low child  high child  merged   ii 
node identical children deleted pointers redirected either one
children  bryant         apply reduction rules tree figure  a  again
renaming sat unsat       get dag shown figure  c  in particular
example second rule apply   note instead performing reduction
end search two reduction rules suggest  better integrating
rules trace recording process redundant portions trace
recorded first place  brings us technique known unique nodes  brace 
rudell    bryant        somenzi         discuss detail next section 
removing redundancy level ensures smallest possible compilation obtained given particular execution search algorithm  however  improve
time complexity search itself  figure  a  example  reason
two isomorphic subgraphs  rooted nodes labeled x    first place
search run equivalent subproblems different paths  general case
nontrivial subproblems  solving one source great inefficiency  therefore refer second level dealing issue redundancy 
would able recognize equivalence subproblems avoid carrying
computation again  done using technique
formula caching  majercik   littman         discuss following section 

   language search
established section   notion interpreting trace exhaustive search
circuit  section continue study search algorithms showing
defines propositional language consisting possible traces  look
three algorithms particular   i  original exhaustive dpll   ii  exhaustive dpll
fixed variable ordering   iii  exhaustive dpll decomposition  algorithm
discuss propositional language defines  corresponding knowledge compiler
provides  well issues regarding efficiency knowledge compiler 
    mapping exhaustive dpll fbdd
seen section   application reduction rules  trace exhaustive
dpll example  depicted figure  a  stored compactly figure  c 
none circuit language fbdd  which happens
obdd case  
formally show traces exhaustive dpll across possible executions
algorithm form propositional language precisely language  reduced 
fbdd defined section    from assume circuits fbdd
obdd always given reduced form application two reduction rules  
order first need formalism explicitly recording trace search
graph  purpose introduce algorithm    exactly exhaustive
extension original dpll  algorithm    except newly introduced function 
   

fihuang   darwiche

get node  given algorithm     provides means recording trace search
form dag  specifically  get node return decision node  in form
figure  b  labeled first argument  second argument low child 
third argument high child  lines     modified
return terminal decision nodes  instead boolean constants   note that 
briefly mentioned section    algorithm trace recorded directly
reduced from  instead producing redundant nodes removed later 
two reduction rules built means unique nodes table  well known
bdd community  brace et al         somenzi         specifically  nodes created
get node stored hash table get node create new node  i  node
created already exists table  that existing node returned    ii  second
third arguments  either argument returned   formally state
result follows 
theorem    dags returned algorithm   form language  reduced  fbdd 
theorem   immediately provides us cnf to fbdd compiler  means
soon search finishes  answer polynomial time query
propositional theory  long query known tractable fbdd  according
table    queries include consistency  validity  clausal entailment  implicant  model
counting  model enumeration  according blum et al          one
test equivalence two propositional formulas probabilistically polynomial time
running algorithm   both  hand  propositional theory given algorithm   known polynomial size representation fbdd  conclude
algorithm able finish polynomial time matter variable
ordering uses 
make algorithm   practical fbdd compiler  need deal issue
redundant computation briefly mentioned section    reason that  despite
use unique nodes controls space complexity  algorithm   still time
complexity proportional size tree version search trace  portions
dag end explored multiple times  see figure   example 
two different instantiations first three variables lead subformula 
would compiled twice  unnecessarily  algorithm    alleviate problem 
one resorts technique formula caching  majercik   littman        
algorithm   describes exhaustive dpll search  caching 
result recursive call dpllf    stored cache  line     returned 
indexed key  computed line    identifying   subsequent call  
algorithm   dpllf  cnf     exhaustive dpll
   empty clause
  
return   sink
   variables
  
return   sink
   select variable x
   return get node x  dpllf   x      dpllf   x     
   

fithe language search

x 

x 

x 

 
x 

x 

x 

x 

x 

x 

x 

x 

 

x 
x 

x 

x 

 

 

x 
x 
x 
x 

x 

x 
 

 

x 
x  x 

x 

x 

x 
x  x 

figure    reaching subformula via different paths search 
immediately return existing compilation cache  line      found
equivalent  by key comparison line      note introduction caching
change identity proposition language defined algorithm 
words  theorem   applies algorithm   well  
practice  one normally focuses efficiently recognizing formulas syntactically
identical  i e   set clauses   various methods proposed
purpose recent years  starting majercik littman        used caching
probabilistic planning problems  followed darwiche        proposed concrete
formula caching method context knowledge compilation  bacchus  dalmao 
pitassi      a  sang et al         context model counting 
darwiche        huang darwiche      b  proposed refinements
method darwiche        
    mapping exhaustive dpll fixed variable ordering obdd
note algorithm    dpll free choose variable branch  line    
corresponds use dynamic variable ordering heuristic typical sat solver 
keeping spirit free binary decision diagrams  fbdd  
surprisingly  one switches dynamic static variable ordering  dags
produced algorithm restricted subset fbdd  algorithm   implements
change  taking particular variable order second argument  making sure
order enforced choosing next branching point  see line     across
possible inputs variable orderings  algorithm indeed produce exactly set
circuits language  reduced  obdd 
algorithm   get node int  i  bdd  low  bdd  high 
   low high
  
return low
   node  i  low  high  exists unique table
  
return unique table  i  low  high  
   result   create bdd node i  low  high 
   unique table  i  low  high     result
   return result
   

fihuang   darwiche

theorem    dags returned algorithm   form language  reduced  obdd 
therefore provided cnf to obdd compiler algorithm    means
soon search finishes  answer polynomial time query
propositional theory  long query known tractable obdd 
notably  test equivalence two propositional formulas deterministically
polynomial time running algorithm   both  could algorithm  
algorithm    hand  propositional theory given algorithm  
known polynomial size representation obdd  hidden weighted bit
function  bryant         conclude algorithm able finish
polynomial time matter variable ordering uses 
make algorithm   practical obdd compiler  need deal issue
redundant computation  naturally  general formula caching method  ones
described earlier  applicable algorithm    constrained search
algorithm  however  special method available shorter cache keys used
reduce cost manipulation  reader referred huang darwiche
     b  details method  allows one bound number distinct cache
keys  therefore providing space time complexity bound  particular 
specific caching scheme force  space time complexity algorithm  
shown exponential cutwidth given cnf formula  variant caching
scheme allows one show parallel complexity terms pathwidth  cutwidth
pathwidth comparable  
emphasize algorithm   represents distinct way obdd construction 
contrast standard method widely adopted formal verification one recursively
builds obdds components system  or propositional formula  compiled
combines using apply operator  bryant         well known problem
latter method intermediate obdds arise process grow large
make manipulation impossible  even final result would tractable
size  considering final obdd really one after  algorithm   affords
solution problem building exactly it  less  although may
work linear obdd size  inconsistent subproblems
contribute obdd size  caching complete   empirical
algorithm   dpllf  cnf     exhaustive dpll caching
   empty clause
  
return   sink
   variables
  
return   sink
   key   compute key  
   exists cache entry  key  result 
  
return result
   select variable x
   result   get node x  dpllf   x      dpllf   x     
    cache insert key  result 
    return result
   

fithe language search

abc
ade
bc
de






bc



b c
e






de

b



b





c




b

e
 






c

 

 a  mixture decision conjunction nodes






b
e

 b  equivalent nnf circuit

figure    trace exhaustive dpll decomposition 
comparison compilation algorithm traditional obdd construction method
found huang darwiche      b  
    mapping exhaustive dpll decomposition subset d dnnf
observed  particular case model counting  efficiency exhaustive dpll improved introducing decomposition  known component
analysis  bayardo   pehoushek        bacchus et al       b  sang et al               
idea propositional formula breaks conjunction disjoint subformulas  i e   share variables   subformula processed separately
results combined 
algorithm   implements decomposition exhaustive dpll relaxing constraint
algorithm    immediately line   algorithm    need insist
case analysis performed variable x formula  instead  examine
current formula  attempt decompose  line    subsets share
algorithm   dpllo  cnf    order     exhaustive dpll fixed variable ordering
   empty clause
  
return   sink
   variables
  
return   sink
   key   compute key  
   exists cache entry  key  result 
  
return result
   x   first variable order appears
   result   get node x  dpllo   x        dpllo   x       
    cache insert key  result 
    return result
   

fihuang   darwiche

variable  we assume process nondeterministic  is  detect
decomposition points   search run subformulas separately
recursively  lines      separate subtraces result connected
means and node indicate results recursive call combined
 line      case decomposition performed  line   fails   branch selected
variable regular dpll  lines        
figure  a shows result example execution algorithm  instantiation first variable breaks cnf formula two disjoint clauses 
processed separately results combined and node  figure  b shows
trace drawn equivalently explicit nnf circuit  for ease viewing constants
removed decision nodes bottom compacted corresponding literals
represent  
witnessed  use decomposition exhaustive dpll resulted
new type node trace  returned get and node line    algorithm   
old get node function  line     still returns decision nodes  in relaxed sense 
children necessarily decision nodes  form figure  c  unique nodes
technique extended straightforward way isomorphic and nodes 
well duplicate children and node  created 
ready discuss proposition language defined algorithm   
purpose first define following subset d dnnf language  determinism
fulfilled means decision nodes  again  relaxed sense  
definition    language decision dnnf set d dnnf circuits
disjunction nodes form figure  b   x    x    x variable  
   note that  unlike fbdd  either conjunction disjunction node 

algorithm   dplld  cnf     exhaustive dpll decomposition
   empty clause
  
return   sink
   variables
  
return   sink
   components   exhaustive partitions disjoint variable sets
    components     
  
conjuncts     
  
c components
  
conjuncts   conjuncts  dplld  c   
   
return get and node conjuncts 
    key   compute key  
    exists cache entry  key  result 
   
return result
    select variable x
    result   get node x  dplld   x      dplld   x     
    cache insert key  result 
    return result
   

fithe language search

formally state result  again  assume circuits always given
reduced form application appropriate reduction rules described earlier 
although allowed redundancy figures ease viewing  
theorem    dags returned algorithm   form language  reduced  decision dnnf 
hence provided cnf to decision dnnf compiler algorithm   
serve d dnnf compiler practice since decision dnnf d dnnf  means
search finishes  answer polynomial time query input
propositional formula  long query known tractable language ddnnf  see table     hand  algorithm   able finish polynomial
time propositional theory polynomial size representation ddnnf  and decision dnnf   matter variable ordering decomposition method
uses 
again  one needs implement form formula caching make algorithm  
practical compiler  several caching methods proposed d dnnf compilation 
latest effective appeared darwiche         however  refer
reader darwiche        caching scheme specific decomposition method
based known dtrees  which discuss next   scheme effective
one darwiche        former may miss equivalences would
caught latter  yet allows one show space time complexity algorithm    caching scheme force  exponential treewidth
cnf formula  as compared pathwidth cutwidth obdd compilation discussed
section       considering model counting linear time query supported
d dnnf language  results darwiche        imply dpll decomposition  such algorithm    used count models time space complexity
exponential treewidth cnf formula  see bacchus et al       a 
alternative derivation complexity result  interestingly  similar structure based
measure complexity appears known fbdd compilation 
finally  would briefly discuss distinction two possible methods
decomposition  algorithm   suggests dynamic notion decomposition  disjoint
components recognized variable split  dynamic decomposition
initially proposed utilized bayardo pehoushek        model counting
adopted recent model counters  sang et al                darwiche             
proposed another method performing decomposition less dynamically preprocessing cnf formula generate dtree  decomposition tree   binary tree
whose leaves correspond clauses cnf formula  node dtree defines
set variables  called cutset  whose instantiation guaranteed decompose
cnf formula node disjoint components  rationale cost
dynamically computing partition  line   algorithm    many times search
replaced lesser cost computing static recursive partition
all  method decomposition allows one provide structure based computational
guarantees discussed above  moreover  instantiation variables cutset
performed dynamically  utilizing dynamic variable ordering heuristics typically done
sat solvers  use dtrees  combined dynamic variable ordering  leads
almost static behavior highly structured problems  cutsets small  yet  one
   

fihuang   darwiche

sees dynamic behavior less structured problems  random   sat 
cutsets relatively large dynamic variable ordering tends dominate  interestingly  static behavior dtrees  low overhead  orders magnitude efficient
purely dynamic behavior structured benchmarks  including iscas   circuits 
hand  dynamic behavior dtrees lead competitive results
unstructured benchmarks  including random   sat  one may obtain results effect
running model counter sang et al          cachet version      d dnnf
compiler darwiche         c d version      relevant benchmarks  noted
two programs differ aspects  decomposition method appears
one major differences 
    harnessing search techniques knowledge compilation
research recent years greatly improved efficiency scalability systematic
search methods  particularly problem propositional satisfiability  techniques contributing improvement include sophisticated conflict analysis  dependencydirected backtracking  clause learning  new variable ordering heuristics  data structures
faster constraint propagation  among things  marques silva   sakallah       
marques silva        aloul  markov    sakallah        moskewicz  madigan  zhao  zhang 
  malik        zhang  madigan  moskewicz    malik        goldberg   novikov       
zhang   malik        heule   van maaren         hand  described
section uniform framework systematic search algorithms converted
knowledge compilers exhausting search space recording trace search 
framework affords opportunity many successful search techniques
carry knowledge compilation  refer reader bayardo pehoushek        
darwiche               huang darwiche      b   sang et al               detailed discussions issues arise implementation techniques
search extended exhaustion  trace search needs stored 
decomposition introduced 
finally  note efficiency search addressed techniques  including caching particular  important practical issue  orthogonal
language generated search  main focus present paper  simple
example  one may two versions algorithm   drastically different running
times input one much better caching method 
end day  bound produce exactly obdd due canonicity
obdds  another example  learned clause provided conflict analysis reduce
number search nodes  affect final dag  circuit  generated 
nodes avoided correspond contradictions  the constant    would
appear dag anyway due reduction rules 

   power limitations exhaustive search algorithms
sections     established notion interpreting trace exhaustive
search circuit  mapping search algorithm propositional language
consisting possible traces  notion provides new perspective intrinsic
power limitations search algorithms  illustrated section  
   

fithe language search











b

c




c



b b
 a  general determinism




b

 b  nondeterminism

figure    dpll unable produce general determinism nondeterminism 
discussing usefulness search algorithms knowledge compilers inherent
inefficiency certain classes inputs  section formalize
concepts illustrate using examples real implementations exhaustive
search algorithms 
consider arbitrary exhaustive search algorithm based variable splitting  call
dpllx   suppose traces form propositional language lx   intrinsic power
limitations dpllx identified following two principles  respectively 
   dpllx runs polynomial time class formulas  dpllx  with trace
recorded  answer polynomial time query formulas known
tractable language lx  
   dpllx run polynomial time formulas polynomial size
representations exist lx  
take example model counters recently proposed bayardo pehoushek
       sang et al                employ techniques decomposition
 the latter also  formula caching  simple analysis model counters shows
traces language decision dnnf   consider query testing
whether minimization theory implies particular clause   min       
min   defined theory whose models exactly minimum cardinality models
  query heart diagnostic nonmonotonic reasoning known
tractable d dnnf  applying first principle above  noting decisiondnnf d dnnf  conclude query answered polynomial time
class formulas model counters bayardo pehoushek        sang
et al               polynomial time complexity  similarly  probabilistic equivalence
test performed polynomial time formulas models counters
polynomial time complexity 
example second principle above  first note neither
model counters finish polynomial time formulas polynomial size
representations exist decision dnnf  furthermore  recall decision dnnf defined
definition   strict subset d dnnf  every disjunction decision dnnf circuit
   see ddp algorithm bayardo pehoushek        table   sang et al         
example  variable splitting  lines     table   sang et al         corresponds generation
decision node  tocomponents function  line   line    corresponds generation
and node satisfies decomposability 

   

fihuang   darwiche

form  x    x    d dnnf allows disjunctions form
logically inconsistent  yet contradict particular
variable  figure  a gives one example   recall model counting query remains
tractable one generalizes decision dnnf d dnnf  decision dnnf turns
succinct d dnnf  therefore  one may find another generation model
counters  well d dnnf compilers exponentially efficient
current ones 
finally  note dpll traces inherently bound nnf circuits
deterministic decomposable  decomposability alone  however  sufficient
tractability important tasks clausal entailment testing  existential quantification variables  cardinality based minimization  darwiche   marquis         dpll
cannot generate traces dnnf d dnnf  figure  b example   since
variable splitting  the heart dpll  amounts enforcing determinism  property determinism provides power needed model counting   sat  
essential applications probabilistic reasoning  one need
power  one go beyond dpll based procedures  otherwise one would solving
harder computational problem necessary 

   relation previous work
employed notion trace search paper provide theoretical
practical channel advances systematic search knowledge compilation  channel indeed active time  implicitly mostly one
direction  systematic search algorithms employed compile knowledge bases  see 
example  darwiche              huang   darwiche      b  darwiche         fact 
techniques variable ordering  decomposition  caching extensively
used bodies work  used  some recently  pure search
algorithms 
key contribution paper formally explicating notion search
trace  proposing basis systematic framework compiling knowledge
bases subsets nnf  contrasted earlier systematic studies
nnf  darwiche   marquis         concerned describing various
properties compiled nnf representations without delving algorithmic nature
generating them  another key contribution paper activating second
direction search compilation channel  looking language membership search
traces formally characterize power limitations various search algorithms 
recent line work  centering notion and or search 
concerned understanding power limitations various search techniques 
decomposition caching  measuring size explored search spaces  dechter
  mateescu      b      a  marinescu   dechter         premise work
traditional search algorithms  based branching  thought exploring
orsearch space  recent search algorithms  employing decomposition  thought
exploring and orsearch space  here  space and or search characterized graph  or tree caching used  alternating layers and nodes
or nodes  former representing decomposition latter branching  algorithms
   

fithe language search

exploring and orsearch space therefore exhibit behavior similar algorithm    used compiling cnf d dnnf  darwiche                      except
algorithm   records and orsearch space explicitly circuit  hence  and or
search algorithm   share limitations discussed dpll  cannot take
advantage general notion determinism  rid determinism altogether 
note proposed algorithms and or search proceed instantiating variables performing decomposition according pseudo tree  freuder   quinn 
       earlier work d dnnf compilation uses decomposition tree two
tasks  corresponding choices lines      algorithm     pseudo trees decomposition trees similar provide scheme instantiation
certain set variables lead decomposition problem  framework
proposed paper  however  make commitment either decomposition
variable ordering scheme  relevant discussion  one note
though commitment particular decomposition variable ordering scheme
significant practical implications  specifically  search algorithm whose trace
d dnnf may performing variable ordering decomposition way
prohibit possibility generating certain  space efficient  d dnnf circuits 
finally  one identify major difference and or search d dnnf
compilation  terms handling queries  execution and or search
algorithm answers single query  executing d dnnf compilation algorithm
results compact structure used repeatedly answer queries  for
knowledge base  known tractable  discussed earlier  traversing
compiled structure potentially much efficient repeating search
produced it  point view  separation search actual reasoning
task provides benefit amortizing search effort potentially large number
queries  provides  discussed  systematic methodology
independent advances search harnessed improve performance automated
reasoning systems 

   experimental results
way experimentation  ran implementations algorithm   using mince variable ordering heuristic  aloul et al          algorithm   using vsids variable ordering
heuristic  moskewicz et al          algorithm   using static decomposition hypergraph partitioning  darwiche   hopkins         compile set cnf formulas
obdd  fbdd  d dnnf  respectively  implementation details first third
programs found huang   darwiche      b darwiche         goal
experiments show practicality search based compilation framework
illustrate improvement language succinctness response relaxation
constraints search process  benchmarks used include random   cnf
graph coloring problems hoos stutzle         set iscas   circuits 
results experiments shown table    running times
given seconds based    ghz cpu  size compilation reflects number
edges nnf dag  dash indicates compilation succeed given
available memory   gb      second time limit  seen
   

fihuang   darwiche

table    compiling cnf obdd  fbdd  d dnnf 
cnf
name
uf     
uf     
uf     
uf      
uf      
uf      
uf      
uf      
uf      
flat    
flat    
flat    
flat     
flat     
flat     
flat     
flat     
flat     
s   
s   
s     
s   
s    
s    
s    
s    
s    

number
models
    
    
 
   
   
    
      
       
         
     
      
     
      
      
        
             
           
           
       
       
                    
              
          
          
                            
     
     

obdd
size
time
     
    
     
    
   
    
    
    
    
    
     
    
    
      




     
    
     
    
     
    
     
    
     
    
     
    






             
             
     
    
             
             
              


             
             

fbdd
size
time
    
    
     
    
   
    
    
    
    
    
    
    
    
     
     
     
            
     
    
    
    
     
    
     
    
     
    
     
    


           
           
           
           


            
             
             


           
           

d dnnf
size
time
   
    
    
    
  
    
   
    
   
    
    
    
   
    
   
    
           
    
    
    
    
    
    
    
    
    
    
    
    
            
          
    
    
     
    
     
    
     
    
     
    
           
           
           
     
    
     
    

instances  compilation smallest d dnnf  fbdd  obdd 
similar relation observed among running times  also  number instances
successfully compiled largest d dnnf  fbdd  obdd  tracks
well theoretical succinctness relations three languages   however  note
fbdd d dnnf canonical representations therefore compilations smaller
reported perfectly possible  smaller obdd compilations are  course 
possible different variable orderings  
close section noting implementations knowledge compilers
bear witness advantage search based compilation framework described
section    first compiler based existing sat solver  moskewicz et al  
       two implementation dpll  three benefiting
techniques found success sat  including conflict analysis  clause learning 
data structures efficient detection unit clauses 

   

fithe language search

   conclusion
work concerned class exhaustive search algorithms run propositional knowledge bases  proposed novel methodology whereby trace search
identified combinational circuit search algorithm mapped propositional language consisting possible traces  mapping leads uniform
practical framework compilation propositional knowledge bases various languages
interest  time provides new perspective intrinsic power limitations exhaustive search algorithms  interesting examples  unveiled hidden
power several recent model counters  discussed one potential limitations 
pointed inability class algorithms produce traces without property
determinism  limits power knowledge compilation point view 
discussed generality results relation recent work and or
search  finally  presented experimental results demonstrate practicality
search based knowledge compilation framework illustrate variation language
succinctness response variation search strategy 

acknowledgments
parts work presented dpll trace  sat knowledge
compilation  proceedings   th international joint conference artificial intelligence  ijcai         pages         thank rina dechter anonymous reviewers
feedback earlier drafts paper  work partially supported
nsf grant iis          muri grant n                 jpl nasa contract       da        national ict australia funded australian governments backing
australias ability initiative  part australian research council 

appendix
proof theorem  
first point recursion guaranteed terminate recursive call
 line    accompanied disappearance one variable eventually either line  
line   execute  assuming compact drawing decision nodes figure  c 
show every dag returned algorithm   fbdd  every fbdd
generated execution algorithm   
part i  three return statements algorithm    lines          single
nodes returned lines     trivial fbdds  dag returned get node
line    call g  decision node induction level recursion  hence remains
show g satisfies test once property  equivalent decomposability case
discussed section       true line    variable x replaced
constants two recursive calls  hence cannot appear two graphs
supplied second third arguments get node  finally  fbdds returned
algorithm guaranteed reduced use unique nodes technique
get node function  brace et al         

   

fihuang   darwiche

part ii  let g denote arbitrary  reduced  fbdd  root node  define
following function  g  returns cnf formula  as set clauses  every g 


 the empty clause  




   
 g 

 x c   c  g low    x c   c  g high   



g   sink 
g   sink 
otherwise  node g
labeled variable x 

last line definition above  assume literal x  and x  always appended
front clause c  execute algorithm    g   line   always choose
first variable clause  the first variable every clause must same  
dag returned isomorphic g 
proof theorem  
show every dag returned algorithm   obdd  every obdd
generated execution algorithm   
part i  first  dag returned algorithm   fbdd algorithm  
restricted version algorithm    second  dag obdd nonterminal
node n dag must constructed line    therefore virtue line   satisfies
following property  variable x labels n appears variables
two subgraphs n variable order   finally  obdds returned algorithm
guaranteed reduced use unique nodes technique get node
function  brace et al         
part ii  given arbitrary  reduced  obdd g  let variable order g 
using  g  defined previous proof  execute algorithm     g      dag
returned isomorphic g 
proof theorem  
show every dag returned algorithm   decision dnnf circuit 
every decision dnnf circuit generated execution algorithm   
part i  nodes returned get and node line    conjunction nodes satisfy
decomposability components identified line   share variables  nodes
returned get node line    disjunction nodes form figure  c
definition get node  therefore whole dag decision dnnf  finally  decisiondnnf circuits returned algorithm guaranteed reduced use
unique nodes technique get node get and node functions 
part ii  let g denote arbitrary  reduced  decision dnnf circuit  assuming
compact drawing decision nodes figure  c  expand previous definition
 g  follows 


 the empty clause  




   


 

 g 

 gi   







 x c   c  g low    x c   c  g high   



   

g   sink 
g  
  sink 
g
gi  


otherwise  node g
labeled variable x 

fithe language search

previous definition  g   assume last line definition above 
literal x  and x  always appended front clause c  now  let literal
clause associated  possibly empty  list colors follows  lists
initially empty literals x x introduced last line definition 
third line definition  assign distinct color sets unioned 
set  append assigned color head list colors first literal
every clause  execute algorithm    g  resolve nondeterministic choices
line    decomposition  line     variable selection  follows  first literal
clause nonempty list colors   the first literal every clause must
nonempty list colors  let line   partition set clauses according first color
first literal remove color first literal every clause  otherwise 
 the first literal every clause must mention variable  let line   return single
partition line    choose first variable clause  dag returned
isomorphic g 

references
aloul  f   markov  i     sakallah  k          faster sat smaller bdds via common
function structure  international conference computer aided design  iccad  
pp         
arvelo  y   bonet  b     vidal  m  e          compilation query rewriting problems
tractable fragments propositional logic  proceedings   st national
conference artificial intelligence  aaai  
bacchus  f   dalmao  s     pitassi  t       a   algorithms complexity results
 sat bayesian inference    th annual ieee symposium foundations
computer science  focs   pp         
bacchus  f   dalmao  s     pitassi  t       b   dpll caching  new algorithm
 sat bayesian inference  electronic colloquium computational complexity
 eccc            
barrett  a          hybrid systems universal plans via domain compilation  proceedings   th international conference automated planning scheduling
 icaps   pp       
barrett  a          model compilation real time planning diagnosis feedback 
proceedings   th international joint conference artificial intelligence
 ijcai   pp           
barwise  j   ed            handbook mathematical logic  north holland 
bayardo  r     pehoushek  j          counting models using connected components 
proceedings   th national conference artificial intelligence  aaai   pp 
       
berre  d  l     simon  l         
http   www satcompetition org  



annual

sat

competitions 

birnbaum  e     lozinskii  e          good old davis putnam procedure helps counting
models  journal artificial intelligence research             
   

fihuang   darwiche

blum  m   chandra  a  k     wegman  m  n          equivalence free boolean graphs
decided probabilistically polynomial time  information processing letters 
             
bonet  b     geffner  h          heuristics planning penalties rewards using compiled knowledge  proceedings tenth international conference
principles knowledge representation reasoning  kr   pp         
brace  k  s   rudell  r  l     bryant  r  e          efficient implementation bdd
package  proceedings   th design automation conference  dac   pp       
bryant  r  e          graph based algorithms boolean function manipulation  ieee
transactions computers  c            
bryant  r  e          complexity vlsi implementations graph representations
boolean functions application integer multiplication  ieee transactions
computers             
cadoli  m     donini  f  m          survey knowledge compilation  ai communications             
chauhan  p   clarke  e  m     kroening  d          using sat based image computation
reachability analysis  tech  rep  cmu cs         school computer science 
carnegie mellon university 
chavira  m     darwiche  a          compiling bayesian networks local structure 
proceedings   th international joint conference artificial intelligence
 ijcai   pp           
chavira  m   darwiche  a     jaeger  m          compiling relational bayesian networks
exact inference  international journal approximate reasoning                
coste marquis  s   berre  d  l   letombe  f     marquis  p          propositional fragments
knowledge compilation quantified boolean formulae   proceedings
  th national conference artificial intelligence  aaai   pp         
darwiche  a          tractability counting theory models application
belief revision truth maintenance  journal applied non classical logics 
               
darwiche  a          compiler deterministic decomposable negation normal form 
proceedings   th national conference artificial intelligence  aaai   pp 
       
darwiche  a          new advances compiling cnf decomposable negation normal form  proceedings   th european conference artificial intelligence
 ecai   pp         
darwiche  a          c d compiler user manual  tech  rep  d      computer science
department  ucla  http   reasoning cs ucla edu c d  
darwiche  a     hopkins  m          using recursive decomposition construct elimination
orders  jointrees dtrees  trends artificial intelligence  lecture notes ai 
      pp          springer verlag 

   

fithe language search

darwiche  a     huang  j          testing equivalence probabilistically  tech  rep  d     
computer science department  ucla 
darwiche  a     marquis  p          knowledge compilation map  journal artificial
intelligence research             
davis  m   logemann  g     loveland  d          machine program theorem proving 
journal acm               
dechter  r     mateescu  r       a   impact and or search spaces constraint
satisfaction counting  proceedings   th international conference
principles practice constraint programming  cp   pp         
dechter  r     mateescu  r       b   mixtures deterministic probabilistic networks
and or search spaces  proceedings   th conference uncertainty
artificial intelligence  uai   pp         
del val  a          tractable databases  make propositional unit resolution complete compilation  proceedings fourth international conference
principles knowledge representation reasoning  kr   pp         
del val  a          analysis approximate knowledge compilation  proceedings
  th international joint conference artificial intelligence  ijcai   pp         
elliott  p     williams  b          dnnf based belief state estimation  proceedings
  st national conference artificial intelligence  aaai  
forbus  k  d     de kleer  j          building problem solvers  mit press 
freuder  e  c     quinn  m  j          taking advantage stable sets variables
constraint satisfaction problems  proceedings ninth international joint conference artificial intelligence  ijcai   pp           
gergov  j     meinel  c          efficient analysis manipulation obdds
extended fbdds  ieee transactions computers                    
goldberg  e     novikov  y          berkmin  fast robust sat solver  design
automation test europe  date   pp         
grumberg  o   schuster  a     yadgar  a          memory efficient all solutions sat solver
application reachability analysis  proceedings  th international
conference formal methods computer aided design  fmcad   pp         
heule  m     van maaren  h          aligning cnf  equivalence reasoning  proceedings seventh international conference theory applications satisfiability testing  sat  
hoos  h  h     stutzle  t          satlib  online resource research sat 
i p gent  h v maaren  t walsh  editors  sat       pp          ios press  satlib
available online www satlib org 
huang  j          combining knowledge compilation search conformant probabilistic
planning  proceedings   th international conference automated planning
scheduling  icaps   pp         

   

fihuang   darwiche

huang  j     darwiche  a       a   compiling system models faster scalable
diagnosis  proceedings   th national conference artificial intelligence
 aaai   pp         
huang  j     darwiche  a       b   using dpll efficient obdd construction 
seventh international conference theory applications satisfiability testing 
sat       revised selected papers  vol       lecture notes computer science 
pp         
karnaugh  m          map method synthesis combinational logic circuits  transactions aiee                 
majercik  s  m     littman  m  l          using caching solve larger probabilistic
planning problems  proceedings   th national conference artificial intelligence  aaai   pp         
marinescu  r     dechter  r          and or branch and bound graphical models 
proceedings   th international joint conference artificial intelligence
 ijcai   pp         
marques silva  j     sakallah  k          graspa new search algorithm satisfiability 
proceedings international conference computer aided design  iccad  
pp         
marques silva  j          impact branching heuristics propositional satisfiability
algorithms  proceedings  th portuguese conference artificial intelligence 
pp       
marquis  p          knowledge compilation using theory prime implicates  proceedings
  th international joint conference artificial intelligence  ijcai   pp     
    
mcmillan  k          symbolic model checking  kluwer academic 
mcmillan  k  l          applying sat methods unbounded symbolic model checking 
proceedings   th international conference computer aided verification
 cav   pp         
meinel  c     theobald  t          algorithms data structures vlsi design  obdd
foundations applications  springer 
moskewicz  m   madigan  c   zhao  y   zhang  l     malik  s          chaff  engineering
efficient sat solver  proceedings   th design automation conference
 dac   pp         
palacios  h   bonet  b   darwiche  a     geffner  h          pruning conformant plans
counting models compiled d dnnf representations  proceedings   th
international conference automated planning scheduling  icaps   pp     
    
sang  t   bacchus  f   beame  p   kautz  h     pitassi  t          combining component
caching clause learning effective model counting  proceedings seventh
international conference theory applications satisfiability testing  sat  
pp       
   

fithe language search

sang  t   beame  p     kautz  h          heuristics fast exact model counting 
proceedings eighth international conference theory applications
satisfiability testing  sat   lecture notes computer science  pp         
selman  b     kautz  h          knowledge compilation using horn approximation 
proceedings ninth national conference artificial intelligence  aaai   pp 
       
selman  b     kautz  h          knowledge compilation theory approximation  journal
acm                 
siddiqi  s     huang  j          hierarchical diagnosis multiple faults  proceedings
  th international joint conference artificial intelligence  ijcai   pp     
    
somenzi  f         
cudd  cu decision diagram package  release       
http   vlsi colorado edu fabio cudd cuddintro html 
urquhart  a          complexity propositional proofs  bulletin symbolic logic 
              
wegener  i          branching programs binary decision diagrams  theory applications  siam monographs discrete mathematics applications 
zhang  l   madigan  c   moskewicz  m     malik  s          efficient conflict driven learning
boolean satisfiability solver  proceedings international conference
computer aided design  iccad   pp         
zhang  l     malik  s          quest efficient boolean satisfiability solvers 
proceedings   th international conference automated deduction  cade  
lecture notes computer science  pp         

   


