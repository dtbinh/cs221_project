journal of artificial intelligence research                 

submitted          published        

the language of search
jinbo huang

jinbo huang nicta com au

logic and computation program
national ict australia

adnan darwiche

darwiche cs ucla edu

computer science department
university of california  los angeles

abstract
this paper is concerned with a class of algorithms that perform exhaustive search on
propositional knowledge bases  we show that each of these algorithms defines and generates
a propositional language  specifically  we show that the trace of a search can be interpreted
as a combinational circuit  and a search algorithm then defines a propositional language
consisting of circuits that are generated across all possible executions of the algorithm  in
particular  we show that several versions of exhaustive dpll search correspond to such
well known languages as fbdd  obdd  and a precisely defined subset of d dnnf  by
thus mapping search algorithms to propositional languages  we provide a uniform and
practical framework in which successful search techniques can be harnessed for compilation
of knowledge into various languages of interest  and a new methodology whereby the power
and limitations of search algorithms can be understood by looking up the tractability and
succinctness of the corresponding propositional languages 

   introduction
systematic search algorithms lie at the core of a wide range of automated reasoning systems 
and many of them are based on a procedure where branches of a node in the search tree are
generated by splitting on the possible values of a chosen variable  one prototypical example
is the dpll algorithm  davis  logemann    loveland        for propositional satisfiability
 sat   given a propositional formula  the problem of sat is to determine whether the
formula has a satisfying assignmentan assignment of boolean values    and    to the
variables under which the formula evaluates to    for example   x       x       x       is a
satisfying assignment for the following formula   x  x    x  x  x    x  x  x    
to determine the satisfiability of a given formula   dpll chooses a variable x from the
formula  recursively determines whether  is satisfiable in case x is set to    and in case x
is set to    and declares  satisfiable precisely when at least one of the two cases results
in a positive answer  in effect  this algorithm performs a systematic search in the space
of variable assignments and terminates either on finding a satisfying assignment  or on
realizing that no such assignment exists 
despite its simplicity  dpll has long remained the basis of most sat solvers that
employ systematic search  berre   simon         and finds natural counterparts in the
more general constraint satisfaction problems  where variables are not restricted to the
boolean domain  several decades of sustained research has greatly enhanced the efficiency
and scalability of dpll based search algorithms  and today they are routinely used to solve

c
    
ai access foundation  all rights reserved 

fihuang   darwiche

practical problems with several million variables  zhang   malik         these algorithms
have been so successful  indeed  that it has become a recent trend in such areas as formal
verification to modify them to produce all solutions of a propositional formula  mcmillan 
      chauhan  clarke    kroening        grumberg  schuster    yadgar         as an
alternative to the traditional practice  mcmillan        of converting the formula into an
ordered binary decision diagram  obdd   bryant         the modifications thus involved
are in such a form that the dpll search will not terminate on finding the first solution 
but is extended to exhaust the whole search space  for the same formula shown earlier  an
example output of such an exhaustive search could be the following set of three solutions
  x       x       x         x       x       x         x       x         note that a solution
here is defined as an assignment of boolean values to some  possibly all  of the variables
that satisfies the formula regardless of the values of the other variables  the last solution
in the above set  for example  represents two satisfying assignments as variable x  is free to
assume either value 
producing all solutions of a propositional formula is  of course  only one of the possible
computational tasks for which an exhaustive search is useful  other such tasks include
counting the number of satisfying assignments of a formula  also known as model counting
 birnbaum   lozinskii        bayardo   pehoushek        bacchus  dalmao    pitassi 
    b  sang  bacchus  beame  kautz    pitassi        sang  beame    kautz         and
processing certain types of queries on belief and constraint networks  dechter   mateescu 
    b      a  
in this paper we uncover a fundamental connection between this class of exhaustive
search algorithms  and a group of propositional languages that have been extensively studied in the field of knowledge compilation  darwiche   marquis         specifically  we show
that an exhaustive search algorithm based on variable splitting  when run on propositional
knowledge bases  defines and generates a propositional language in a very precise sense  the
trace of a single search  when recorded as a graph  can be interpreted as a combinational
circuit that is logically equivalent to the propositional knowledge base on which the search
has run  the search algorithm itself then defines a propositional language consisting of all
circuits that can be generated by legal executions of the algorithm  we show  in particular 
that exhaustive dpll corresponds to the language of fbdd  free binary decision diagrams 
 blum  chandra    wegman         exhaustive dpll with fixed variable ordering corresponds to the language of obdd  ordered binary decision diagrams   bryant         and
exhaustive dpll with decomposition corresponds to a well defined subset of the language
of d dnnf  deterministic decomposable negation normal form   darwiche        
the establishment of this correspondence supplies a bridge between the field of knowledge compilation  and other areas of automated reasoning  including propositional satisfiability  where search algorithms have been extensively studied  in particular  it leads to the
following two sets of theoretical and practical benefits 
first  we show that the class of search algorithms we have described can be immediately
turned into knowledge compilers for the respective propositional languages they define  by
simply recording the trace of the search  this realization provides a uniform and practical framework in which successful techniques developed in the context of search can be
directly used for compilation of knowledge into various languages of interest  in particular 
we discuss how recent advances in dpll search  including sophisticated conflict analysis 
   

fithe language of search

dependency directed backtracking  clause learning  new variable ordering heuristics  and
data structures for faster constraint propagation  can be harnessed for building efficient
practical knowledge compilers 
second  we show how  by looking up known properties of propositional languages  we are
now able to answer at a fundamental level  and in concrete terms  two important questions
regarding the power and limitations of the same class of search algorithms  what can these
algorithms do  and what can they not  specifically  we discuss how the tractability of the
propositional language defined by a search algorithm illustrates the power of the algorithm 
and how the succinctness and the constraints of the language illustrate its limitations 
we complement these discussions by relating our results to previous work on knowledge compilation and a recent body of work centering on the notion of and or search
 dechter   mateescu      b      a  marinescu   dechter         in particular  we discuss
similarities as well as differences between and or search and d dnnf compilation 
finally  we present experimental results on implementations of exhaustive search algorithms that define distinct propositional languages  we use these programs to compile a set
of propositional formulas into the respective languages  both to demonstrate the practicality of this knowledge compilation framework  and to empirically illustrate the variation of
language succinctness in response to the variation of the search strategy 
the remainder of the paper is organized as follows  section   reviews a number of
propositional languages concerned in this work and their theoretical roles and relations in
knowledge compilation  section   discusses the dpll search algorithm for propositional
satisfiability and its exhaustive extension  and introduces the notion of interpreting the
trace of a search as a combinational circuit  section   is a detailed exposition on mapping
variants of exhaustive dpll to fbdd  obdd  and a subset of d dnnf  as well as techniques involved in transforming these algorithms into practical knowledge compilers for the
respective languages  section   formalizes two fundamental principles relating to the intrinsic power and limitations of a class of exhaustive search algorithms  using recently proposed
model counting algorithms as concrete examples  we relate our results to previous work in
section    present experimental results in section    and conclude in section    proofs of
all theorems are given in the appendix 

   propositional languages and their properties
the study of propositional languages  i e   representations for propositional theories  has
been a central subject in knowledge compilation  which is concerned with the task of converting a given knowledge base from one language into another so that certain reasoning
tasks become tractable on the compiled knowledge base  selman   kautz        del val 
            marquis        selman   kautz        cadoli   donini        darwiche  
marquis        darwiche              coste marquis  berre  letombe    marquis        
after propositional theories are compiled into the language of obdd  for example  their
equivalence can be tested in time that is polynomial in the sizes of the obdds  meinel  
theobald         or constant time if the obdds use the same variable order  bryant        
more recent applications of compilation using the language of d dnnf can be found in the
fields of diagnosis  barrett              huang   darwiche      a  elliott   williams       
siddiqi   huang         planning  barrett        palacios  bonet  darwiche    geffner 
   

fihuang   darwiche

 a  nnf

 b  decision node
or

or
and

and

and

and

or

or

or

and and and and

x

or

and and and and



x



 c  alternatively
x

a

b

b

a

c

d

d

c





figure    an nnf circuit and a decision node 
      huang        bonet   geffner         probabilistic reasoning  chavira   darwiche 
      chavira  darwiche    jaeger         and query rewrites in databases  arvelo  bonet 
  vidal        
in this section we review a set of propositional languages and discuss an established
body of results concerning their tractability and succinctness  darwiche   marquis       
several of these languages will resurface in section   as those to which exhaustive search
algorithms are mapped  and their properties will prove vital to our formalization in section  
of two fundamental principles relating to the power and limitations of exhaustive search
algorithms 
    propositional languages
following the conventions of darwiche and marquis         we consider graph representations of propositional theories  which allow sharing of subformulas for compactness  specifically  we consider directed acyclic graphs  dags  where each internal node is labeled with
a conjunction  and    or disjunction  or     and each leaf is labeled with a propositional
literal or constant  true f alse  or       it should be clear that such a dag is effectively a
combinational circuit with and gates  or gates  and inverters  where inverters only appear
next to inputs  variables   a property that is characteristic of the negation normal form
 nnf   barwise         we will hence refer to these dags as nnf circuits and the set of
all such dags as the nnf language  figure  a depicts a propositional theory represented
as an nnf circuit  we will next define some interesting subsets of the nnf language 
the popular language of cnf  conjunctive normal form  can now be defined as the
subset of nnf that satisfies  i  flatness  the height of the dag is at most two  and  ii 
simple disjunction  any disjunction is over leaf nodes only  i e   is a clause   similarly 
dnf  disjunctive normal form  is the subset of nnf that satisfies flatness and simpleconjunction  any conjunction is over leaf nodes only  i e   is a term  
we consider next a set of nested representations  starting with the dnnf  decomposable
negation normal form  language  which is the set of all nnf circuits satisfying decomposability  conjuncts of any conjunction share no variables  our next language  d dnnf 
satisfies both decomposability and determinism  disjuncts of any disjunction are pairwise
logically inconsistent  the nnf circuit shown in figure  a  for example  is in d dnnf 
   

fithe language of search

x 

or
and
or

x 
and

x 

x 

x 

x 

 a  dnnf

x 

x 
x 

x 

x 

 

 

 b  fbdd

x 

 

 

 c  obdd

figure    a circuit in dnnf  fbdd  and obdd 
that shown in figure  a  by contrast  is in dnnf but not in d dnnf as neither of the two
disjunction nodes satisfies determinism 
the fbdd language is the subset of d dnnf where the root of every circuit is a
decision node  which is defined recursively as either a constant    or    or a disjunction in
the form of figure  b where x is a propositional variable and  and  are decision nodes 
note that an equivalent but more compact drawing of a decision node as figure  c is widely
used in the formal verification literature  where fbdds are equivalently known as bdds
 binary decision diagrams  that satisfy the test once property  each variable appears at
most once on any root to sink path  gergov   meinel          see figure  b for an fbdd
example using this more compact drawing 
the obdd language is the subset of fbdd where all circuits satisfy the ordering
property  variables appear in the same order on all root to sink paths  bryant         see
figure  c for an obdd example  using the more compact drawing   for a particular
variable order    we also write obdd  to denote the corresponding obdd subset where
all circuits use order   
    succinctness and tractability of propositional languages
given a choice of languages in which a knowledge base may be represented  one needs to
strike a balance between the size of the representation and the support it provides for the
reasoning task at hand  as these two properties of a representation often run counter to
each other  cnf  for example  is often convenient for compactly encoding a knowledge
base since in many applications the behavior of a system can be naturally described as the
conjunction of behaviors of its components  however  few typical reasoning tasks can be
efficiently carried out on cnf representations  there is no efficient algorithm to determine 
for example  whether an arbitrary clause is entailed by a cnf formula  the story changes
when the propositional theory is represented in a language known as pi  prime implicates 
a subset of cnf   by definition pi supports a linear time clausal entailment test  the
downside is  unfortunately  that pi representations can be exponentially larger than their
cnf equivalents in the worst case  karnaugh        forbus   de kleer        
we are therefore interested in formally analyzing the succinctness and tractability of
languages  so that given a required reasoning task  we can choose the most succinct language
   fbdds are also known as read once branching programs  wegener        

   

fihuang   darwiche

that supports the set of necessary operations in polynomial time  the following is a classical
definition of succinctness 
definition     succinctness  let l  and l  be two subsets of nnf  l  is at least as succinct
as l    denoted l   l    iff there exists a polynomial p such that for every circuit   l   
there exists a logically equivalent circuit   l  where     p      here     and    are
the sizes of  and   respectively 
intuitively  language l  is at least as succinct as language l  if given any circuit in l   
there exists a logically equivalent circuit in l  whose size does not blow up  one can also
define l  to be strictly more succinct than l    denoted l    l    if l   l  but l    l   
the languages we described in section     satisfy the following succinctness relations  nnf
  dnnf   d dnnf   fbdd   obdd  nnf   cnf  and dnnf   dnf  darwiche  
marquis         note  however  that l   l  does not imply l    l  in general  in other
words  imposing conditions on a representation does not necessarily reduce its succinctness 
one example is smoothness  which requires disjuncts of any disjunction to mention the same
set of variablesit is known that this condition  when imposed on d dnnf  does not reduce
its succinctness  darwiche   marquis        
we now turn to the tractability of languages  which refers to the set of polynomial time
operations they support  according to darwiche and marquis         one traditionally
distinguishes between two types of operations on circuits in a given language  queries and
transformations  the difference between the two is that queries return information about
circuits  but normally do not change them  while transformations modify circuits to generate
new ones  in the same language  
some of the known results from darwiche and marquis        regarding the tractability of languages are summarized in table    queries  and table    transformations   the
abbreviations in the first row of table   stand for the following eight queries  respectively 
consistency  is the formula satisfiable   validity  does the formula evaluate to   under
all variable assignments   clausal entailment  does the formula imply a given clause  
implicant  is the formula implied by a given term   equivalence  are the two formulas logically equivalent   sentential entailment  does the one formula imply the other  
model counting  how many satisfying assignments does the formula have   model enumeration  what are the satisfying assignments of the formula   the abbreviations in the
first row of table   stand for the following eight transformations  respectively  conditioning  setting a set of variables to constants   forgetting  existentially quantifying a set of
variables   single variable forgetting  existentially quantifying a single variable   conjunction  conjoining a set of circuits   bounded conjunction  conjoining a bounded
number of circuits   disjunction  disjoining a set of circuits   bounded disjunction
 disjoining a bounded number of circuits   negation  negating a circuit  
interestingly  table   offers one explanation for the popularity of obdds in formal verification where efficient equivalence testing  among other things  is often critical  although
more succinct  d dnnf and fbdd are not known to admit a polynomial time equivalence
test  a polynomial time probabilistic equivalence test is possible  see blum et al        
darwiche   huang         note also that although there is no difference between d dnnf
and fbdd to the extent of this table  the question mark on the equivalence test  eq  could
eventually be resolved differently for the two languages 
   

fithe language of search

table    polynomial time queries supported by a language   means not supported unless
p np and   means we dont know  
language
nnf
dnnf
d dnnf
bdd
fbdd
obdd
obdd 
dnf
cnf

co




va




ce




im




































eq


 

 



se








ct




me

























table    polynomial time transformations supported by a language   means not supported   means not supported unless p np  and   means  we dont know  
language
nnf
dnnf
d dnnf
bdd
fbdd
obdd
obdd 
dnf
cnf

cd










fo



sfo











c


bc































c



bc






















c


 







it is also worth pointing out that while tractability with respect to the queries generally improves when the language becomes more restrictive  has more conditions imposed  
tractability with respect to the transformations may not  dnnf  for example  supports a
subset of the queries that are supported by obdd according to table    and is therefore
less tractable than obdd from this point of view  however  when it comes to certain
transformations  such as the operation of forgetting  existential quantification   dnnf becomes more tractable than obdd according to table    the key reason for this shift of
advantage is that transformations operate on circuits in a given propositional language  and
require the result to be in the same languagethis requirement can become a burden for
the more restrictive language where more conditions need to be satisfied when the result of
the transformation is generated 

   

fihuang   darwiche

    a connection to be established
we have summarized and discussed in this section a rich body of known results concerning
properties of various propositional languages  these results have previously been presented
as a guide for the task of selecting a suitable target compilation language in applications
of knowledge compilation  in particular  they suggest that given a reasoning task involving
knowledge compilation  one identify the set of operations required for the task  and then
select the most succinct target compilation language supporting these operations  darwiche
  marquis        
in the following sections of the paper  we wish to establish a fundamental connection
between propositional languages with distinct degrees of succinctness and tractability  and
exhaustive search algorithms running under distinct sets of constraints  specifically  we
show that the trace of an exhaustive search can be interpreted as a circuit representing a
compilation of the propositional knowledge base on which the search has run  and the search
algorithm itself then defines a propositional language consisting of all its possible traces 
this connection will then serve as a bridge between the field of knowledge compilation
and other areas of automated reasoning in which search algorithms have been extensively
studied  affording two related sets of benefits as follows 
in the first direction  we show how this connection provides a set of practical algorithms
for compilation of knowledge into various languages  specifically  an exhaustive search
algorithm can be directly turned into a knowledge compiler by recording the trace of its
execution as a graph  and variations on the search algorithm then nicely correspond to
compilers for different propositional languages  such a framework for knowledge compilation
provides a significant advantage in that many  past as well as future  advances in search
will automatically carry over to knowledge compilation  in particular  we discuss how
knowledge compilers can capitalize on several important recent advances in the dpll search
for propositional satisfiability  including sophisticated conflict analysis  dependency directed
backtracking  clause learning  new variable ordering heuristics  and data structures for faster
constraint propagation 
in the second direction  we formulate two principles whereby the intrinsic power and
limitations of a given exhaustive search algorithm can be understood by identifying the
propositional language defined by the search algorithm  specifically  the tractability of the
language illustrates the power  usefulness  of the search algorithm and the succinctness
and the constraints of the language illustrates its limitations  using a group of recently
proposed model counters as concrete examples  we show that the search algorithms used
by these model counters are powerful enough to support not just a model counting query 
but all other queries that are known to be tractable for the language of d dnnf  such as
a probabilistic equivalence test  darwiche   huang         on the other hand  two fundamental limitations can be identified for these same algorithms  as well as other exhaustive
search algorithms based on variable splitting  the first in their traces being restricted to
a subset of d dnnf  potentially limiting the efficiency of the search  and the second in
their inability to produce traces without determinism  making them overly constrained for
compilation of knowledge into more general languages than d dnnf  such as dnnf 

   

fithe language of search

we now proceed to uncover the connection between search algorithms and propositional
languages  starting with a systematic search algorithm for propositional satisfiability  its
exhaustive extension  and the notion of the trace of a search 

   systematic search for satisfiability and its exhaustive extension
in this section we introduce the notion of the trace of a systematic exhaustive search  and
show how the trace can be interpreted as a circuit  which is logically equivalent to  and hence
is a compilation of  the propositional knowledge base on which the search has run  we will
do so in the context of systematically searching for satisfying assignments of a propositional
formula  a major approach to the problem of propositional satisfiability  sat  that has
come to be known as dpll  davis et al         
    dpll search and its exhaustive extension
algorithm   is a summary of dpll for sat  which takes a propositional formula in cnf 
and return       precisely when the formula is satisfiable  unsatisfiable   it works by recursively doing a case analysis on the assignment to a selected variable  line     the formula
is satisfiable if and only if either case results in a satisfiable subformula  line     the two
subformulas are denote as  x   and  x     which result from replacing all occurrences of
x in  with   and    respectively  in keeping with the rules of boolean logic  we assume
that if a literal becomes or evaluates to   as a result of this variable instantiation  it is
removed from every clause that contains it  and that if a literal becomes or evaluates to   
all clauses that contain it are removed   to facilitate our subsequent discussion of variants
of dpll  we have omitted the use of unit resolution from the pseudocode  the programs
used in section    however  do employ unit resolution   in effect  algorithm   performs a
search in the space of variable assignments until it finds one that satisfies the given cnf
formula or realizes that no satisfying assignments exist 
now consider extending algorithm   so that it will go through the space of all satisfying assignmentsby always exploring both branches of line  rather than terminate on finding the first one  figure  a depicts the search tree of this exhaustive version of dpll  under some particular variable ordering  on the following cnf formula 
 x   x      x   x   x      x   x   x     note that in drawing the branches of the
search we use a dotted  solid  line to denote setting the variable to      we will also refer
to the corresponding child of the search node as the low  high  child 
algorithm   dpll cnf     returns satisfiability of 
   if there is an empty clause in  then
  
return  
   if there are no variables in  then
  
return  
   select a variable x of 
   return dpll  x     or dpll  x    

   

fihuang   darwiche

or

x 

and
x 
x 

or

x 

unsat

and
sat

x 
unsat

  x 

unsat

or

and
x 

and
x 
or

x 
sat

and
x 
and
x   

or

and and
and and
  x  x      x  x   
 b  equivalent nnf circuit

sat

 a  termination tree

figure    the trace of an exhaustive dpll search 
the tree depicted in figure  a is also known as the termination tree of the search 
as it captures the set of paths through the search space that have been explored at the
termination of the search  in particular  each leaf of the tree labeled with sat gives a
partial variable assignment that satisfies the propositional formula regardless of the values
of any unassigned variables  and the whole tree characterizes precisely the set of all satisfying
assignments  which the algorithm has set out to find and succeeded in finding 
    the trace of the search and the issue of redundancy
as we have alluded to earlier  we would like to view such a termination tree as the trace of
the search  about which we now make two important observations  first  the trace of the
search as depicted in figure  a can be directly translated into a circuit in nnf as depicted
in figure  b  all that is involved is to rename sat unsat to     and invoke the identity
between figure  b and figure  c as we described in section      second  this nnf circuit
is logically equivalent to  and hence is a compilation of  the cnf formula on which the
search has run   note that this notion of trace is different from that used in earlier work
to establish the power of dpll as a proof system for unsatisfiable cnf formulas  for
example  in earlier work it was shown that on an unsatisfiable cnf formula  the trace of
dpll can be converted into a tree like resolution refutation  urquhart         
these two observations imply that exhaustive dpll is as powerful as a knowledge
compiler  as long as one takes the  small  trouble of recording its trace  from the viewpoint
of knowledge compilation  however  a search trace recorded in its present form may not be
immediately useful  because it will typically have a size proportional to the amount of work
done to produce it  answering even a linear time query  which may require only a single
traversal of the compiled representation  on such a compilation  for example  would be as
if one were running the whole search over again 
this problem can be remedied by first realizing that there is quite a bit of redundancy
in the search trace we have drawn  in figure  a  for example  the two subgraphs whose
roots are labeled with x  are isomorphic to each other and could be merged into one  the
same redundancy  of course  is present in the corresponding portions of the nnf circuit
shown in figure  b 
   

fithe language of search

we can distinguish two levels of dealing with the issue of redundancy in the trace  in
the first level  we can remove all redundancy from the trace by reducing it from a tree to
a dag  with repeated applications of the following two rules   i  isomorphic nodes  i e  
nodes that have the same label  same low child  and same high child  are merged   ii  any
node with identical children is deleted and pointers to it are redirected to either one of its
children  bryant         if we apply these reduction rules to the tree of figure  a  again
renaming sat unsat to       we will get the dag shown in figure  c  in this particular
example the second rule does not apply   note that instead of performing the reduction at
the end of the search as these two reduction rules suggest  we can do better by integrating
the rules into the trace recording process so that redundant portions of the trace will not
be recorded in the first place  this brings us to a technique known as unique nodes  brace 
rudell    bryant        somenzi         which we discuss in more detail in the next section 
removing redundancy in this level ensures that the smallest possible compilation is obtained given a particular execution of the search algorithm  however  it does not improve
the time complexity of the search itself  in figure  a  for example  the reason why there
are two isomorphic subgraphs  rooted at nodes labeled with x    in the first place is that the
search has run into equivalent subproblems from different paths  in the general case these
can be nontrivial subproblems  and solving each one of them can be a source of great inefficiency  we therefore refer to the second level of dealing with the issue of redundancy  where
we would like to be able to recognize the equivalence of subproblems and avoid carrying
out the same computation over and over again  this can be done using the technique of
formula caching  majercik   littman         which we also discuss in the following section 

   the language of search
we have established in section   the notion of interpreting the trace of an exhaustive search
as a circuit  in this section we continue our study of these search algorithms by showing how
each defines a propositional language consisting of all its possible traces  we will look at
three algorithms in particular   i  the original exhaustive dpll   ii  exhaustive dpll with
fixed variable ordering  and  iii  exhaustive dpll with decomposition  for each algorithm
we will discuss the propositional language it defines  the corresponding knowledge compiler
it provides  as well as issues regarding the efficiency of the knowledge compiler 
    mapping exhaustive dpll to fbdd
we have seen in section   that with the application of reduction rules  the trace of exhaustive
dpll in our example  depicted in figure  a  can be stored more compactly as figure  c 
which is none other than a circuit in the language of fbdd  which happens to be also an
obdd in this case  
we will now formally show that traces of exhaustive dpll across all possible executions
of the algorithm form a propositional language that is precisely the language of  reduced 
fbdd as defined in section    from now on we will assume that circuits in fbdd and
obdd are always given in their reduced form by application of the two reduction rules   in
order to do so we will first need a formalism for explicitly recording the trace of the search
as a graph  for this purpose we introduce algorithm    which is exactly the exhaustive
extension of the original dpll  algorithm    except that the newly introduced function 
   

fihuang   darwiche

get node  given in algorithm     provides a means of recording the trace of the search
in the form of a dag  specifically  get node will return a decision node  in the form of
figure  b  labeled with the first argument  having the second argument as the low child 
and having the third argument as the high child  lines     have also been modified to
return the terminal decision nodes  instead of the boolean constants   note that  as we
briefly mentioned in section    this algorithm will have its trace recorded directly in the
reduced from  instead of producing redundant nodes to be removed later  this is because
the two reduction rules are built in by means of a unique nodes table  well known in
the bdd community  brace et al         somenzi         specifically  all nodes created by
get node are stored in a hash table and get node will not create a new node if  i  the node
to be created already exists in the table  that existing node is returned   or  ii  the second
and third arguments are the same  either argument is returned   we can now formally state
our result as follows 
theorem    dags returned by algorithm   form the language of  reduced  fbdd 
theorem   immediately provides us with a cnf to fbdd compiler  which means that
as soon as the search finishes  we can answer in polynomial time any query about the
propositional theory  as long as that query is known to be tractable for fbdd  according
to table    such queries include consistency  validity  clausal entailment  implicant  model
counting  and model enumeration  according to blum et al          one can then also
test the equivalence of two propositional formulas probabilistically in polynomial time after
running algorithm   on both  on the other hand  if a propositional theory given to algorithm   is known to have no polynomial size representation in fbdd  we can also conclude
that the algorithm will not be able to finish in polynomial time no matter what variable
ordering it uses 
to make algorithm   a practical fbdd compiler  we need to deal with the issue of
redundant computation as briefly mentioned in section    the reason is that  despite
the use of unique nodes which controls the space complexity  algorithm   still has a time
complexity proportional to the size of the tree version of the search trace  portions of
the dag can end up being explored multiple times  see figure   for an example  where
two different instantiations of the first three variables lead to the same subformula  which
would then be compiled twice  unnecessarily  by algorithm    to alleviate this problem 
one resorts to the technique of formula caching  majercik   littman        
algorithm   describes the same exhaustive dpll search  but now with caching  the
result of a recursive call dpllf    will be stored in a cache  line     before being returned 
indexed by a key  computed on line    identifying   any subsequent call on some   will
algorithm   dpllf  cnf     exhaustive dpll
   if there is an empty clause in  then
  
return   sink
   if there are no variables in  then
  
return   sink
   select variable x of 
   return get node x  dpllf   x      dpllf   x     
   

fithe language of search

x 

x 

x 

 
x 

x 

x 

x 

x 

x 

x 

x 

 

x 
x 

x 

x 

 

 

x 
x 
x 
x 

x 

x 
 

 

x 
x  x 

x 

x 

x 
x  x 

figure    reaching the same subformula via different paths of the search 
immediately return the existing compilation for  from the cache  line    if   is found to
be equivalent to   by a key comparison on line      note that the introduction of caching
does not change the identity of the proposition language defined by the algorithm  in other
words  theorem   applies to algorithm   as well  
in practice  one normally focuses on efficiently recognizing formulas that are syntactically
identical  i e   have the same set of clauses   various methods have been proposed for this
purpose in recent years  starting with majercik and littman        who used caching for
probabilistic planning problems  followed by darwiche        who proposed a concrete
formula caching method in the context of knowledge compilation  then bacchus  dalmao 
and pitassi      a  and sang et al         in the context of model counting  and then
darwiche        and huang and darwiche      b  who proposed further refinements on
the method of darwiche        
    mapping exhaustive dpll with fixed variable ordering to obdd
note that in algorithm    dpll is free to choose any variable on which to branch  line    
this corresponds to the use of a dynamic variable ordering heuristic in a typical sat solver 
and is in keeping with the spirit of free binary decision diagrams  fbdd  
not surprisingly  when one switches from dynamic to static variable ordering  the dags
produced by the algorithm will be restricted to a subset of fbdd  algorithm   implements
this change  by taking a particular variable order  as a second argument  and making sure
that this order is enforced when choosing the next branching point  see line     across all
possible inputs and variable orderings  this algorithm will indeed produce exactly the set of
all circuits in the language of  reduced  obdd 
algorithm   get node int  i  bdd  low  bdd  high 
   if low is the same as high then
  
return low
   if node  i  low  high  exists in unique table then
  
return unique table  i  low  high  
   result   create bdd node i  low  high 
   unique table  i  low  high     result
   return result
   

fihuang   darwiche

theorem    dags returned by algorithm   form the language of  reduced  obdd 
we are therefore provided with a cnf to obdd compiler in algorithm    which means
that as soon as the search finishes  we can answer in polynomial time any query about
the propositional theory  as long as that query is known to be tractable for obdd  most
notably  we can now test the equivalence of two propositional formulas deterministically in
polynomial time after running algorithm   on both  which we could not with algorithm  
or algorithm    on the other hand  if a propositional theory given to algorithm   is
known to have no polynomial size representation in obdd  such as the hidden weighted bit
function  bryant         we can also conclude that the algorithm will not be able to finish
in polynomial time no matter what variable ordering it uses 
to make algorithm   a practical obdd compiler  we need again to deal with the issue
of redundant computation  naturally  any general formula caching method  such as the ones
we described earlier  will be applicable to algorithm    for this more constrained search
algorithm  however  a special method is available where shorter cache keys can be used
to reduce the cost of their manipulation  the reader is referred to huang and darwiche
     b  for details of this method  which allows one to bound the number of distinct cache
keys  therefore providing both a space and a time complexity bound  in particular  with
this specific caching scheme in force  the space and time complexity of algorithm   was
shown to be exponential only in the cutwidth of the given cnf formula  a variant caching
scheme allows one to show a parallel complexity in terms of the pathwidth  cutwidth and
pathwidth are not comparable  
we emphasize here that algorithm   represents a distinct way of obdd construction  in
contrast to the standard method widely adopted in formal verification where one recursively
builds obdds for components of the system  or propositional formula  to be compiled and
combines them using the apply operator  bryant         a well known problem with this
latter method is that the intermediate obdds that arise in the process can grow so large as
to make further manipulation impossible  even when the final result would have a tractable
size  considering that the final obdd is really all that one is after  algorithm   affords
a solution to this problem by building exactly it  no more and no less  although it may
do more work than is linear in the obdd size  both because inconsistent subproblems do
not contribute to the obdd size  and because the caching is not complete   an empirical
algorithm   dpllf  cnf     exhaustive dpll with caching
   if there is an empty clause in  then
  
return   sink
   if there are no variables in  then
  
return   sink
   key   compute key  
   if there exists a cache entry  key  result  then
  
return result
   select variable x of 
   result   get node x  dpllf   x      dpllf   x     
    cache insert key  result 
    return result
   

fithe language of search

abc
ade
bc
de

and

a

and
bc

or

a  b  c
a  d  e

and a
and

or

de

b

d

b

and

d

c

or

and
b d

e
 

or

and
a and

c

 

 a  mixture of decision and conjunction nodes

or
and

and

b d
e

 b  equivalent nnf circuit

figure    trace of exhaustive dpll with decomposition 
comparison of this compilation algorithm and the traditional obdd construction method
can be found in huang and darwiche      b  
    mapping exhaustive dpll with decomposition to a subset of d dnnf
it has been observed  in the particular case of model counting  that the efficiency of exhaustive dpll can be improved by introducing decomposition  also known as component
analysis  bayardo   pehoushek        bacchus et al       b  sang et al                the
idea is that when a propositional formula breaks down to a conjunction of disjoint subformulas  i e   those that do not share variables   each subformula can be processed separately
and the results combined 
algorithm   implements decomposition in exhaustive dpll by relaxing a constraint on
algorithm    immediately before line   of algorithm    we need not insist any more that
a case analysis be performed on some variable x of the formula  instead  we will examine
the current formula  and attempt to decompose it  line    into subsets that do not share a
algorithm   dpllo  cnf    order     exhaustive dpll with fixed variable ordering
   if there is an empty clause in  then
  
return   sink
   if there are no variables in  then
  
return   sink
   key   compute key  
   if there exists a cache entry  key  result  then
  
return result
   x   first variable of order  that appears in 
   result   get node x  dpllo   x        dpllo   x       
    cache insert key  result 
    return result
   

fihuang   darwiche

variable  we assume that this process is nondeterministic  that is  we do not have to detect
all decomposition points   the search will then run on each of these subformulas separately
and recursively  lines      and the separate subtraces that result are connected by
means of an and node to indicate that the results of the recursive call are being combined
 line      in case no decomposition is performed  line   fails   we will branch on a selected
variable as in regular dpll  lines        
figure  a shows the result of an example execution of this algorithm  where the instantiation of the first variable breaks the cnf formula into two disjoint clauses  which are
processed separately and the results combined as an and node  figure  b shows the same
trace drawn equivalently as an explicit nnf circuit  for ease of viewing constants have been
removed and decision nodes at the bottom compacted into the corresponding literals they
represent  
as we have just witnessed  the use of decomposition in exhaustive dpll has resulted
in a new type of node in the trace  returned by get and node on line    of algorithm   
the old get node function  line     still returns decision nodes  in a relaxed sense  as their
children now are not necessarily decision nodes  in the form of figure  c  the unique nodes
technique can also be extended in a straightforward way so that isomorphic and nodes  as
well as duplicate children of an and node  will not be created 
we are now ready to discuss the proposition language defined by algorithm    for which
purpose we first define the following subset of the d dnnf language  where determinism is
fulfilled by means of decision nodes  again  in the relaxed sense  
definition    the language of decision dnnf is the set of d dnnf circuits in which all
disjunction nodes have the form of figure  b  or  x      x     where x is a variable  
   note that  unlike in an fbdd  here  and  can be either a conjunction or a disjunction node 

algorithm   dplld  cnf     exhaustive dpll with decomposition
   if there is an empty clause in  then
  
return   sink
   if there are no variables in  then
  
return   sink
   components   exhaustive partitions of  with disjoint variable sets
   if  components      then
  
conjuncts     
  
for all c  components do
  
conjuncts   conjuncts   dplld  c   
   
return get and node conjuncts 
    key   compute key  
    if there exists a cache entry  key  result  then
   
return result
    select variable x of 
    result   get node x  dplld   x      dplld   x     
    cache insert key  result 
    return result
   

fithe language of search

we can now formally state our result  again  we assume that circuits are always given
in their reduced form by application of appropriate reduction rules as described earlier 
although we have allowed redundancy in some of our figures for ease of viewing  
theorem    dags returned by algorithm   form the language of  reduced  decision dnnf 
we are hence provided with a cnf to decision dnnf compiler in algorithm    which
can serve as a d dnnf compiler in practice since decision dnnf  d dnnf  this means
that once the search finishes  we can answer in polynomial time any query about the input
propositional formula  as long as that query is known to be tractable for the language of ddnnf  see table     on the other hand  algorithm   will not be able to finish in polynomial
time on any propositional theory that does not have a polynomial size representation in ddnnf  and decision dnnf   no matter what variable ordering and decomposition method
it uses 
again  one needs to implement some form of formula caching to make algorithm   a
practical compiler  several caching methods have been proposed for d dnnf compilation 
the latest and most effective of which appeared in darwiche         however  we refer the
reader to darwiche        for a caching scheme that is specific to a decomposition method
based on what is known as dtrees  which we discuss next   this scheme is not as effective
as the one in darwiche        in that the former may miss some equivalences that would be
caught by the latter  yet it allows one to show that the space and time complexity of algorithm    with this caching scheme in force  will be exponential only in the treewidth of the
cnf formula  as compared to pathwidth and cutwidth in obdd compilation as discussed
in section       considering that model counting is a linear time query supported by the
d dnnf language  the results of darwiche        also imply that dpll with decomposition  such as algorithm    can be used to count models with a time and space complexity
that is exponential only in the treewidth of the cnf formula  see bacchus et al       a  for
an alternative derivation of this complexity result  interestingly  no similar structure based
measure of complexity appears to be known for fbdd compilation 
finally  we would like to briefly discuss a distinction between two possible methods of
decomposition  algorithm   suggests a dynamic notion of decomposition  where disjoint
components will be recognized after each variable split  this dynamic decomposition was
initially proposed and utilized by bayardo and pehoushek        for model counting and
adopted by more recent model counters  sang et al                darwiche             
proposed another method for performing the decomposition less dynamically by preprocessing the cnf formula to generate a dtree  decomposition tree   which is a binary tree
whose leaves correspond to clauses of the cnf formula  each node in the dtree defines
a set of variables  called the cutset  whose instantiation is guaranteed to decompose the
cnf formula below that node into disjoint components  the rationale is that the cost of
dynamically computing a partition  line   of algorithm    many times during the search
is now replaced with the lesser cost of computing a static and recursive partition once and
for all  this method of decomposition allows one to provide structure based computational
guarantees as discussed above  moreover  the instantiation of variables in each cutset can be
performed dynamically  by utilizing dynamic variable ordering heuristics as typically done
in sat solvers  the use of dtrees  combined with dynamic variable ordering  leads to an
almost static behavior on highly structured problems  for which cutsets are small  yet  one
   

fihuang   darwiche

sees a more dynamic behavior on less structured problems  such as random   sat  where
the cutsets are relatively large and dynamic variable ordering tends to dominate  interestingly  the static behavior of dtrees  low overhead  can be orders of magnitude more efficient
than purely dynamic behavior on structured benchmarks  including the iscas   circuits 
on the other hand  the dynamic behavior of dtrees can lead to very competitive results on
unstructured benchmarks  including random   sat  one may obtain results to this effect
by running the model counter of sang et al          cachet version      against the d dnnf
compiler of darwiche         c d version      on relevant benchmarks  it should be noted
that the two programs differ in other aspects  but the decomposition method appears to be
one of the major differences 
    harnessing search techniques for knowledge compilation
research in recent years has greatly improved the efficiency and scalability of systematic
search methods  particularly those for the problem of propositional satisfiability  techniques contributing to this improvement include sophisticated conflict analysis  dependencydirected backtracking  clause learning  new variable ordering heuristics  and data structures
for faster constraint propagation  among other things  marques silva   sakallah       
marques silva        aloul  markov    sakallah        moskewicz  madigan  zhao  zhang 
  malik        zhang  madigan  moskewicz    malik        goldberg   novikov       
zhang   malik        heule   van maaren         on the other hand  we have described in
this section a uniform framework where systematic search algorithms can be converted into
knowledge compilers by exhausting the search space and recording the trace of the search 
such a framework affords an opportunity for many of the successful search techniques to
carry over to knowledge compilation  we refer the reader to bayardo and pehoushek        
darwiche               huang and darwiche      b   and sang et al               for detailed discussions of issues that arise from the implementation of these techniques when
search is extended to exhaustion  when the trace of the search needs to be stored  and when
decomposition is introduced 
finally  we note that the efficiency of the search as addressed by these and other techniques  including caching in particular  is an important practical issue  but is orthogonal
to the language generated by the search  the main focus of the present paper  as a simple
example  one may have two versions of algorithm   that have drastically different running
times on the same input because one of them has a much better caching method  but at the
end of the day  they are bound to produce exactly the same obdd due to the canonicity
of obdds  as another example  a learned clause provided by conflict analysis can reduce
the number of search nodes  but of itself will not affect the final dag  circuit  generated 
because the nodes avoided all correspond to contradictions  the constant    and would not
appear in the dag anyway due to the reduction rules 

   power and limitations of exhaustive search algorithms
in sections   and   we have established the notion of interpreting the trace of an exhaustive
search as a circuit  and then mapping the search algorithm itself to a propositional language
consisting of all its possible traces  this notion provides a new perspective on the intrinsic
power and limitations of these search algorithms  which we have illustrated in section   by
   

fithe language of search

or
and

or

and
and

a

b

c
or
and
and

c

or

a b a b
 a  general determinism

a

and
b

 b  nondeterminism

figure    dpll is unable to produce general determinism or nondeterminism 
discussing the usefulness of the search algorithms as knowledge compilers and the inherent
inefficiency of the same on certain classes of inputs  in this section we formalize these
concepts and further illustrate them using examples from real implementations of exhaustive
search algorithms 
consider an arbitrary exhaustive search algorithm based on variable splitting  call it
dpllx   and suppose that its traces form a propositional language lx   the intrinsic power
and limitations of dpllx can then be identified by the following two principles  respectively 
   if dpllx runs in polynomial time on a class of formulas  then dpllx  with its trace
recorded  can answer in polynomial time any query on these formulas that is known
to be tractable for language lx  
   dpllx will not run in polynomial time on formulas for which no polynomial size
representations exist in lx  
take for example the model counters recently proposed by bayardo and pehoushek
       and sang et al                which employ the techniques of decomposition and
 the latter also  formula caching  a simple analysis of these model counters shows that
their traces are in the language of decision dnnf   now consider the query of testing
whether the minimization of a theory  implies a particular clause   min        where
min   is defined as a theory whose models are exactly the minimum cardinality models of
  this query is at the heart of diagnostic and nonmonotonic reasoning and is known to be
tractable if  is in d dnnf  applying the first principle above  and noting that decisiondnnf  d dnnf  we conclude that this query can be answered in polynomial time for any
class of formulas on which the model counters of bayardo and pehoushek        and sang
et al               have a polynomial time complexity  similarly  a probabilistic equivalence
test can be performed in polynomial time for formulas on which these models counters have
a polynomial time complexity 
as an example of the second principle above  first note that neither of these same
model counters will finish in polynomial time on formulas for which no polynomial size
representations exist in decision dnnf  furthermore  recall that decision dnnf as defined
in definition   is a strict subset of d dnnf  every disjunction in a decision dnnf circuit
   see the ddp algorithm of bayardo and pehoushek        and table   of sang et al          for
example  the variable splitting  lines     in table   of sang et al         corresponds to the generation
of a decision node  and the tocomponents function  line   and line    corresponds to the generation
of an and node that satisfies decomposability 

   

fihuang   darwiche

has the form  x      x     while d dnnf allows disjunctions of the form    where
   is logically inconsistent  yet  and  do not contradict each other on any particular
variable  figure  a gives one example   recall also that the model counting query remains
tractable when one generalizes from decision dnnf to d dnnf  if decision dnnf turns
out to be not as succinct as d dnnf  therefore  one may find another generation of model
counters  as well as d dnnf compilers that can be exponentially more efficient than the
current ones 
finally  we note that dpll traces are inherently bound to be nnf circuits that are
both deterministic and decomposable  decomposability alone  however  is sufficient for the
tractability of such important tasks as clausal entailment testing  existential quantification of variables  and cardinality based minimization  darwiche   marquis         dpll
cannot generate traces in dnnf that are not in d dnnf  figure  b for example   since
variable splitting  the heart of dpll  amounts to enforcing determinism  it is the property of determinism that provides the power needed to do model counting   sat   which
is essential for applications such as probabilistic reasoning  but if one does not need this
power  then one should go beyond dpll based procedures  otherwise one would be solving
a harder computational problem than is necessary 

   relation to previous work
we have employed the notion of the trace of a search in this paper to provide a theoretical
and practical channel between advances in systematic search and those in knowledge compilation  this channel has indeed been active for some time  but implicitly and mostly in one
direction  systematic search algorithms being employed to compile knowledge bases  see 
for example  darwiche              huang   darwiche      b  darwiche         in fact 
the techniques of variable ordering  decomposition  and caching have all been extensively
used in these bodies of work  just as they are being used  some more recently  in pure search
algorithms 
a key contribution of this paper is then in formally explicating this notion of search
trace  and proposing it as the basis for a systematic framework for compiling knowledge
bases into subsets of nnf  this is to be contrasted with earlier systematic studies on
nnf  darwiche   marquis         as those were concerned with describing the various
properties of compiled nnf representations without delving into the algorithmic nature
of generating them  another key contribution of this paper is in activating the second
direction of the search compilation channel  looking at the language membership of search
traces to formally characterize the power and limitations of various search algorithms 
there has been a recent line of work  centering on the notion of and or search  which
is also concerned with understanding the power and limitations of various search techniques 
such as decomposition and caching  by measuring the size of explored search spaces  dechter
  mateescu      b      a  marinescu   dechter         the premise of this work is that
while traditional search algorithms  based on branching  can be thought of as exploring an
orsearch space  more recent search algorithms  employing decomposition  can be thought
of as exploring an and orsearch space  here  the space of an and or search is characterized by a graph  or tree if no caching is used  with alternating layers of and nodes and
or nodes  the former representing decomposition and the latter branching  the algorithms
   

fithe language of search

for exploring an and orsearch space therefore exhibit a behavior similar to that of algorithm    used in compiling cnf to d dnnf  darwiche                      except that
algorithm   records the and orsearch space explicitly as a circuit  hence  and or
search and algorithm   share the same limitations we discussed of dpll  they cannot take
advantage of the general notion of determinism  or rid themselves of determinism altogether 
we note here that the proposed algorithms for and or search proceed by instantiating variables and performing decomposition according to a pseudo tree  freuder   quinn 
       while earlier work on d dnnf compilation uses a decomposition tree for those two
tasks  corresponding to the choices on lines   and    of algorithm     pseudo trees and decomposition trees are similar in that they both provide a scheme in which the instantiation
of a certain set of variables will lead to decomposition of the problem  in the framework
proposed in this paper  however  we make no commitment to either the decomposition or
the variable ordering scheme  as they are not relevant to our discussion  one should note
though that a commitment to any particular decomposition or variable ordering scheme
can have significant practical implications  specifically  a search algorithm whose trace is
in d dnnf may be performing variable ordering and decomposition in such a way as to
prohibit the possibility of generating certain  space efficient  d dnnf circuits 
finally  one can identify a major difference between and or search and d dnnf
compilation  in terms of their handling of queries  each execution of an and or search
algorithm answers only a single query  while executing a d dnnf compilation algorithm
results in a compact structure that can be used repeatedly to answer all queries  for the
same knowledge base  that are known to be tractable  as discussed earlier  traversing a
compiled structure can be potentially much more efficient than repeating the search that
produced it  from this point of view  the separation of search from the actual reasoning
task provides the benefit of amortizing the search effort over a potentially large number
of queries  it also provides  as we have discussed  a systematic methodology by which
independent advances in search can be harnessed to improve the performance of automated
reasoning systems 

   experimental results
by way of experimentation  we ran implementations of algorithm   using the mince variable ordering heuristic  aloul et al          algorithm   using the vsids variable ordering
heuristic  moskewicz et al          and algorithm   using static decomposition by hypergraph partitioning  darwiche   hopkins         to compile a set of cnf formulas into
obdd  fbdd  and d dnnf  respectively  implementation details of the first and third
programs can be found in huang   darwiche      b and darwiche         the goal of
these experiments is to show the practicality of the search based compilation framework
and to illustrate the improvement of language succinctness in response to the relaxation of
constraints on the search process  the benchmarks we used include random   cnf and
graph coloring problems from hoos and stutzle         and a set of iscas   circuits 
the results of these experiments are shown in table    where the running times are
given in seconds based on a    ghz cpu  the size of the compilation reflects the number
of edges in the nnf dag  a dash indicates that the compilation did not succeed given
the available memory   gb  and a     second time limit  it can be seen that for most of
   

fihuang   darwiche

table    compiling cnf into obdd  fbdd  and d dnnf 
cnf
name
uf     
uf     
uf     
uf      
uf      
uf      
uf      
uf      
uf      
flat    
flat    
flat    
flat     
flat     
flat     
flat     
flat     
flat     
s   
s   
s     
s   
s    
s    
s    
s    
s    

number of
models
    
    
 
   
   
    
      
       
         
     
      
     
      
      
        
             
           
           
       
       
                    
              
          
          
                            
     
     

obdd
size
time
     
    
     
    
   
    
    
    
    
    
     
    
    
      




     
    
     
    
     
    
     
    
     
    
     
    






             
             
     
    
             
             
              


             
             

fbdd
size
time
    
    
     
    
   
    
    
    
    
    
    
    
    
     
     
     
            
     
    
    
    
     
    
     
    
     
    
     
    


           
           
           
           


            
             
             


           
           

d dnnf
size
time
   
    
    
    
  
    
   
    
   
    
    
    
   
    
   
    
           
    
    
    
    
    
    
    
    
    
    
    
    
            
          
    
    
     
    
     
    
     
    
     
    
           
           
           
     
    
     
    

these instances  the compilation was the smallest in d dnnf  then fbdd  then obdd  a
similar relation can be observed among the running times  also  the number of instances
successfully compiled was the largest for d dnnf  then fbdd  then obdd  this tracks
well with the theoretical succinctness relations of the three languages   however  note that
fbdd and d dnnf are not canonical representations and therefore compilations smaller
than reported here are perfectly possible  smaller obdd compilations are  of course  also
possible under different variable orderings  
we close this section by noting that the implementations of these knowledge compilers
bear witness to the advantage of the search based compilation framework we have described
in section    the first compiler is based on an existing sat solver  moskewicz et al  
       and the other two on our own implementation of dpll  all three benefiting from
techniques that have found success in sat  including conflict analysis  clause learning  and
data structures for efficient detection of unit clauses 

   

fithe language of search

   conclusion
this work is concerned with a class of exhaustive search algorithms that are run on propositional knowledge bases  we proposed a novel methodology whereby the trace of a search is
identified with a combinational circuit and the search algorithm itself is mapped to a propositional language consisting of all its possible traces  this mapping leads a uniform and
practical framework for compilation of propositional knowledge bases into various languages
of interest  and at the same time provides a new perspective on the intrinsic power and limitations of exhaustive search algorithms  as interesting examples  we unveiled the hidden
power of several recent model counters  discussed one of their potential limitations  and
pointed out the inability of this class of algorithms to produce traces without the property
of determinism  which limits their power from a knowledge compilation point of view  we
discussed the generality of some of of our results in relation to recent work on and or
search  finally  we presented experimental results to demonstrate the practicality of the
search based knowledge compilation framework and to illustrate the variation of language
succinctness in response to the variation of the search strategy 

acknowledgments
parts of this work have been presented in dpll with a trace  from sat to knowledge
compilation  in proceedings of the   th international joint conference on artificial intelligence  ijcai         pages         we thank rina dechter and the anonymous reviewers
for their feedback on earlier drafts of this paper  this work was partially supported by
nsf grant iis          muri grant n                 and jpl nasa contract       da        national ict australia is funded by the australian governments backing
australias ability initiative  in part through the australian research council 

appendix a
proof of theorem  
we first point out that the recursion is guaranteed to terminate as each recursive call
 line    is accompanied by the disappearance of one variable and eventually either line  
or line   will execute  assuming the compact drawing of decision nodes as in figure  c 
we now show that every dag returned by algorithm   is an fbdd  and that every fbdd
can be generated by some execution of algorithm   
part i  there are three return statements in algorithm    lines       and    the single
nodes returned on lines   and   are trivial fbdds  the dag returned by get node on
line    call it g  is a decision node by induction on the level of recursion  hence it remains
to show that g satisfies the test once property  equivalent to decomposability in this case as
we discussed in section       which is true because on line    variable x has been replaced
with constants before the two recursive calls  and hence cannot appear in the two graphs
that are supplied as the second and third arguments to get node  finally  fbdds returned
by the algorithm are guaranteed to be reduced by the use of the unique nodes technique in
the get node function  brace et al         

   

fihuang   darwiche

part ii  let g denote an arbitrary  reduced  fbdd  and also its root node  define the
following function  g  that returns a cnf formula  as a set of clauses  for every g 


 the empty clause  




   
 g  

  x  c   c   g low     x  c   c   g high   



if g is the   sink 
if g is the   sink 
otherwise  where node g
is labeled with variable x 

on the last line of the definition above  assume that the literal x  and x  is always appended
to the front of the clause c  now execute algorithm   on  g   and on line   always choose
the first variable of any clause  the first variable of every clause must be the same   the
dag returned will be isomorphic to g 
proof of theorem  
we show that every dag returned by algorithm   is an obdd  and that every obdd can
be generated by some execution of algorithm   
part i  first  any dag returned by algorithm   is an fbdd as algorithm   is a
restricted version of algorithm    second  the dag is an obdd because any nonterminal
node n in the dag must be constructed on line    and therefore by virtue of line   satisfies
the following property  the variable x that labels n appears before all other variables in the
two subgraphs below n in the variable order   finally  obdds returned by the algorithm
are guaranteed to be reduced by the use of the unique nodes technique in the get node
function  brace et al         
part ii  given an arbitrary  reduced  obdd g  let  be the variable order of g  now
using  g  as defined in the previous proof  execute algorithm   on   g      the dag
returned will be isomorphic to g 
proof of theorem  
we show that every dag returned by algorithm   is a decision dnnf circuit  and that
every decision dnnf circuit can be generated by some execution of algorithm   
part i  nodes returned by get and node on line    are conjunction nodes that satisfy
decomposability because the components identified on line   do not share variables  nodes
returned by get node on line    are disjunction nodes that have the form of figure  c by
the definition of get node  therefore the whole dag is in decision dnnf  finally  decisiondnnf circuits returned by the algorithm are guaranteed to be reduced by the use of the
unique nodes technique in the get node and get and node functions 
part ii  let g denote an arbitrary  reduced  decision dnnf circuit  again assuming the
compact drawing of decision nodes as in figure  c  we now expand the previous definition
of  g  as follows 


 the empty clause  




   


  

 g  

 gi   


i




 x  c   c   g low     x  c   c   g high   



   

if g is the   sink 
if g is  
the   sink 
if g is
gi  
i

otherwise  where node g
is labeled with variable x 

fithe language of search

as in the previous definition of  g   assume that on the last line of the definition above 
the literal x  and x  is always appended to the front of the clause c  now  let each literal
of each clause be associated with a  possibly empty  list of colors as follows  the lists
are initially empty for the literals x and x introduced on the last line of the definition  on
the third line of the definition  assign a distinct color to each of the sets being unioned  and
in each set  append the assigned color to the head of the list of colors for the first literal of
every clause  now execute algorithm   on  g  and resolve the nondeterministic choices
on line    decomposition  and line     variable selection  as follows  if the first literal of
any clause has a nonempty list of colors  then  the first literal of every clause must have a
nonempty list of colors  let line   partition the set of clauses according to the first color
of their first literal and remove that color from the first literal of every clause  otherwise 
 the first literal of every clause must mention the same variable  let line   return a single
partition and on line    choose the first variable of any clause  the dag returned will be
isomorphic to g 

references
aloul  f   markov  i     sakallah  k          faster sat and smaller bdds via common
function structure  in international conference on computer aided design  iccad  
pp         
arvelo  y   bonet  b     vidal  m  e          compilation of query rewriting problems
into tractable fragments of propositional logic  in proceedings of the   st national
conference on artificial intelligence  aaai  
bacchus  f   dalmao  s     pitassi  t       a   algorithms and complexity results for
 sat and bayesian inference  in   th annual ieee symposium on foundations of
computer science  focs   pp         
bacchus  f   dalmao  s     pitassi  t       b   dpll with caching  a new algorithm for
 sat and bayesian inference  electronic colloquium on computational complexity
 eccc            
barrett  a          from hybrid systems to universal plans via domain compilation  in proceedings of the   th international conference on automated planning and scheduling
 icaps   pp       
barrett  a          model compilation for real time planning and diagnosis with feedback 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai   pp           
barwise  j   ed            handbook of mathematical logic  north holland 
bayardo  r     pehoushek  j          counting models using connected components  in
proceedings of the   th national conference on artificial intelligence  aaai   pp 
       
berre  d  l     simon  l         
http   www satcompetition org  

the

annual

sat

competitions 

birnbaum  e     lozinskii  e          the good old davis putnam procedure helps counting
models  journal of artificial intelligence research             
   

fihuang   darwiche

blum  m   chandra  a  k     wegman  m  n          equivalence of free boolean graphs
can be decided probabilistically in polynomial time  information processing letters 
             
bonet  b     geffner  h          heuristics for planning with penalties and rewards using compiled knowledge  in proceedings of the tenth international conference on
principles of knowledge representation and reasoning  kr   pp         
brace  k  s   rudell  r  l     bryant  r  e          efficient implementation of a bdd
package  in proceedings of the   th design automation conference  dac   pp       
bryant  r  e          graph based algorithms for boolean function manipulation  ieee
transactions on computers  c            
bryant  r  e          on the complexity of vlsi implementations and graph representations
of boolean functions with application to integer multiplication  ieee transactions on
computers             
cadoli  m     donini  f  m          a survey on knowledge compilation  ai communications             
chauhan  p   clarke  e  m     kroening  d          using sat based image computation
for reachability analysis  tech  rep  cmu cs         school of computer science 
carnegie mellon university 
chavira  m     darwiche  a          compiling bayesian networks with local structure 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai   pp           
chavira  m   darwiche  a     jaeger  m          compiling relational bayesian networks
for exact inference  international journal of approximate reasoning                
coste marquis  s   berre  d  l   letombe  f     marquis  p          propositional fragments
for knowledge compilation and quantified boolean formulae   in proceedings of the
  th national conference on artificial intelligence  aaai   pp         
darwiche  a          on the tractability of counting theory models and its application
to belief revision and truth maintenance  journal of applied non classical logics 
               
darwiche  a          a compiler for deterministic decomposable negation normal form 
in proceedings of the   th national conference on artificial intelligence  aaai   pp 
       
darwiche  a          new advances in compiling cnf into decomposable negation normal form  in proceedings of the   th european conference on artificial intelligence
 ecai   pp         
darwiche  a          the c d compiler user manual  tech  rep  d      computer science
department  ucla  http   reasoning cs ucla edu c d  
darwiche  a     hopkins  m          using recursive decomposition to construct elimination
orders  jointrees and dtrees  in trends in artificial intelligence  lecture notes in ai 
      pp          springer verlag 

   

fithe language of search

darwiche  a     huang  j          testing equivalence probabilistically  tech  rep  d     
computer science department  ucla 
darwiche  a     marquis  p          a knowledge compilation map  journal of artificial
intelligence research             
davis  m   logemann  g     loveland  d          a machine program for theorem proving 
journal of the acm               
dechter  r     mateescu  r       a   the impact of and or search spaces on constraint
satisfaction and counting  in proceedings of the   th international conference on
principles and practice of constraint programming  cp   pp         
dechter  r     mateescu  r       b   mixtures of deterministic probabilistic networks and
their and or search spaces  in proceedings of the   th conference on uncertainty
in artificial intelligence  uai   pp         
del val  a          tractable databases  how to make propositional unit resolution complete through compilation  in proceedings of the fourth international conference on
principles of knowledge representation and reasoning  kr   pp         
del val  a          an analysis of approximate knowledge compilation  in proceedings of the
  th international joint conference on artificial intelligence  ijcai   pp         
elliott  p     williams  b          dnnf based belief state estimation  in proceedings of
the   st national conference on artificial intelligence  aaai  
forbus  k  d     de kleer  j          building problem solvers  mit press 
freuder  e  c     quinn  m  j          taking advantage of stable sets of variables in
constraint satisfaction problems  in proceedings of the ninth international joint conference on artificial intelligence  ijcai   pp           
gergov  j     meinel  c          efficient analysis and manipulation of obdds can be
extended to fbdds  ieee transactions on computers                    
goldberg  e     novikov  y          berkmin  a fast and robust sat solver  in design
automation and test in europe  date   pp         
grumberg  o   schuster  a     yadgar  a          memory efficient all solutions sat solver
and its application for reachability analysis  in proceedings of the  th international
conference on formal methods in computer aided design  fmcad   pp         
heule  m     van maaren  h          aligning cnf  and equivalence reasoning  in proceedings of the seventh international conference on theory and applications of satisfiability testing  sat  
hoos  h  h     stutzle  t          satlib  an online resource for research on sat  in
i p gent  h v maaren  t walsh  editors  sat       pp          ios press  satlib
is available online at www satlib org 
huang  j          combining knowledge compilation and search for conformant probabilistic
planning  in proceedings of the   th international conference on automated planning
and scheduling  icaps   pp         

   

fihuang   darwiche

huang  j     darwiche  a       a   on compiling system models for faster and more scalable
diagnosis  in proceedings of the   th national conference on artificial intelligence
 aaai   pp         
huang  j     darwiche  a       b   using dpll for efficient obdd construction  in
seventh international conference on theory and applications of satisfiability testing 
sat       revised selected papers  vol       of lecture notes in computer science 
pp         
karnaugh  m          the map method for synthesis of combinational logic circuits  transactions of the aiee                 
majercik  s  m     littman  m  l          using caching to solve larger probabilistic
planning problems  in proceedings of the   th national conference on artificial intelligence  aaai   pp         
marinescu  r     dechter  r          and or branch and bound for graphical models 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai   pp         
marques silva  j     sakallah  k          graspa new search algorithm for satisfiability 
in proceedings of the international conference on computer aided design  iccad  
pp         
marques silva  j          the impact of branching heuristics in propositional satisfiability
algorithms  in proceedings of the  th portuguese conference on artificial intelligence 
pp       
marquis  p          knowledge compilation using theory prime implicates  in proceedings
of the   th international joint conference on artificial intelligence  ijcai   pp     
    
mcmillan  k          symbolic model checking  kluwer academic 
mcmillan  k  l          applying sat methods in unbounded symbolic model checking 
in proceedings of the   th international conference on computer aided verification
 cav   pp         
meinel  c     theobald  t          algorithms and data structures in vlsi design  obdd
foundations and applications  springer 
moskewicz  m   madigan  c   zhao  y   zhang  l     malik  s          chaff  engineering
an efficient sat solver  in proceedings of the   th design automation conference
 dac   pp         
palacios  h   bonet  b   darwiche  a     geffner  h          pruning conformant plans
by counting models on compiled d dnnf representations  in proceedings of the   th
international conference on automated planning and scheduling  icaps   pp     
    
sang  t   bacchus  f   beame  p   kautz  h     pitassi  t          combining component
caching and clause learning for effective model counting  in proceedings of the seventh
international conference on theory and applications of satisfiability testing  sat  
pp       
   

fithe language of search

sang  t   beame  p     kautz  h          heuristics for fast exact model counting  in
proceedings of the eighth international conference on theory and applications of
satisfiability testing  sat   lecture notes in computer science  pp         
selman  b     kautz  h          knowledge compilation using horn approximation  in
proceedings of the ninth national conference on artificial intelligence  aaai   pp 
       
selman  b     kautz  h          knowledge compilation and theory approximation  journal
of the acm                 
siddiqi  s     huang  j          hierarchical diagnosis of multiple faults  in proceedings of
the   th international joint conference on artificial intelligence  ijcai   pp     
    
somenzi  f         
cudd  cu decision diagram package  release       
http   vlsi colorado edu fabio cudd cuddintro html 
urquhart  a          the complexity of propositional proofs  bulletin of symbolic logic 
              
wegener  i          branching programs and binary decision diagrams  theory and applications  siam monographs on discrete mathematics and applications 
zhang  l   madigan  c   moskewicz  m     malik  s          efficient conflict driven learning
in a boolean satisfiability solver  in proceedings of the international conference on
computer aided design  iccad   pp         
zhang  l     malik  s          the quest for efficient boolean satisfiability solvers  in
proceedings of the   th international conference on automated deduction  cade  
lecture notes in computer science  pp         

   

fi