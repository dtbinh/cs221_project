journal of artificial intelligence research                

submitted        published      

asynchronous forward bounding for distributed cops
amir gershman
amnon meisels
roie zivan

amirger   cs   bgu   ac   il
am   cs   bgu   ac   il
zivanr   cs   bgu   ac   il

department of computer science 
ben gurion university of the negev 
beer sheva          israel

abstract
a new search algorithm for solving distributed constraint optimization problems  discops 
is presented  agents assign variables sequentially and compute bounds on partial assignments
asynchronously  the asynchronous bounds computation is based on the propagation of partial
assignments  the asynchronous forward bounding algorithm  afb  is a distributed optimization
search algorithm that keeps one consistent partial assignment at all times  the algorithm is described in detail and its correctness proven  experimental evaluation shows that afb outperforms
synchronous branch and bound by many orders of magnitude  and produces a phase transition as
the tightness of the problem increases  this is an analogous effect to the phase transition that has
been observed when local consistency maintenance is applied to maxcsps  the afb algorithm is
further enhanced by the addition of a backjumping mechanism  resulting in the afb bj algorithm 
distributed backjumping is based on accumulated information on bounds of all values and on processing concurrently a queue of candidate goals for the next move back  the afb bj algorithm is
compared experimentally to other discop algorithms  adopt  dpop  optapo  and is shown to
be a very efficient algorithm for discops 

   introduction
the distributed constraint optimization problem  discop  is a general framework for distributed
problem solving that has a wide range of applications in multi agent systems and has generated
significant interest from researchers  modi  shen  tambe    yokoo        zhang  xing  wang   
wittenburg        petcu   faltings      a  mailler   lesser        ali  koenig    tambe       
silaghi   yokoo         discops are composed of agents  each holding one or more variables 
each variable has a domain of possible value assignments  constraints among variables  possibly
held by different agents  assign costs to combinations of value assignments  agents assign values to
their variables and communicate with each other  attempting to generate a solution that is globally
optimal with respect to the costs of the constraints  modi et al         petcu   faltings        
there is a wide scope of motivation for research on discop  since distributed cops are an
elegant model for many every day combinatorial problems that are distributed by nature  take for
example a large hospital that is composed of many wards  each ward constructs a weekly timetable
assigning its nurses to shifts  the construction of a weekly timetable involves solving a constraint
optimization problem for each ward  some of the nurses in every ward are qualified to work in
the emergency room  hospital regulations require a certain number of qualified nurses  e g  for
emergency room  in each shift  this imposes constraints among the timetables of different wards
and generates a complex distributed cop  solotorevsky  gudes    meisels        
c
    
ai access foundation  all rights reserved 

fig ershman   m eisels     z ivan

another example is the sensor networks tracking problem  zhang  xing  wang    wittenburg 
      zhang et al          in which the task is to assign sensors to tracking targets  such that the
maximal number of the targets will be tracked by the sensor collection  this too can be solved using
the discop model 
discop modeling can also solve problems like log based reconciliation  chong   hamadi 
       in which copies of a data base exist in several physical locations  users perform actions on
these data base copies  each user on its own local copy  the actions cause the data base to change 
so only initially all copies are identical  but later actions change some of them and they are no longer
identical  logs of all user actions are kept  the problem is how to merge these logs  into a single log
that keeps as many of the actions as possible  it is not always possible to keep all local logs intact 
since actions are constrained with other actions  for example you can not reconcile the deletion of
an item from the database and a later print or update of it  
discops represent real life problems that cannot or should not be solved centrally for several
reasons  among them are lack of autonomy  single point of failure and privacy of agents  in the
hospital wards example  wards want to maintain a degree of autonomy over their local problems
involving the constraints of every single nurse  in the sensor example  the sensors have a very small
memory and computing power and therefore cannot solve the problem in a centralized fashion  in
the database example  centralization is possible  but issues such as network bottleneck  computing
power and single point of failure encourage looking for a distributed solution 
the present paper proposes a new distributed search algorithm for discops  asynchronous
forward bounding  afb   in the afb algorithm agents assign their variables and generate a partial
solution sequentially  the innovation of the proposed algorithm lies in propagating partial solutions asynchronously  propagation of partial solutions enables asynchronous updating of bounds on
their cost  and early detection of a need to backtrack  hence the algorithms name afb  this form
of propagating bounds asynchronously turns out to generate a very efficient form of concurrent
computation by all the participating agents  more efficient than algorithms that use asynchronous
assignment processes  especially on hard instances of discops 
the overall framework of the afb algorithm is based on a branch and bound scheme  agents
extend a partial solution as long as the lower bound on its cost does not exceed the global bound 
which is the cost of the best solution found so far  in the proposed afb algorithm  the state of the
search process is represented by a data structure called current partial assignment  cpa   the cpa
starts empty at some initializing agent that records its assignments on it and sends it to the next agent 
the cost of a cpa is the sum on the costs of constraints it includes  besides the current assignment
cost  the agents maintain on a cpa a lower bound which is updated according to information they
receive from yet unassigned agents  each agent which receives the cpa  adds assignments of its
local variables to the partial assignment on the received cpa  if an assignment with a lower bound
smaller than the current global upper bound can be found  otherwise  it backtracks by sending the
cpa to a former agent to revise its assignment 
an agent that succeeds to extend the assignment on the cpa sends forward copies of the updated
cpa  requesting all unassigned agents to compute lower bound estimations on the cost of the partial
assignment  the assigning agent will receive these estimations asynchronously over time and use
them to update the lower bound of the cpa 
gathering updated lower bounds from future assigning agents  may enable an agent to discover
that the lower bound of the cpa it sent forward is higher than the current upper bound  i e  inconsistent   this discovery triggers the creation of a new cpa which is a copy of the cpa it sent
forward  the agent resumes the search by trying to replace its inconsistent assignment  the time
  

fia synchronous f orward b ounding for d istributed cop s

stamp mechanism proposed by nguyen  sam hroud  and faltings        and used by meisels and
zivan        is used by agents to determine the most updated cpa and to discard obsolete cpas 
the concurrency of the afb algorithm is achieved by the fact that forward bounding is performed concurrently and asynchronously by all agents  this form of asynchronicity is similar to
that employed by the asynchronous forward checking  afc  algorithm for distributed constraint
satisfaction problems  discsps   meisels   zivan        meseguer   jimenez         when afb
is enhanced with backjumping  zivan   meisels         the resulting algorithm performs concurrently distributed forward bounding and backjumping and prunes the search space of discops very
efficiently  this is demonstrated by the extensive experimental evaluation in section   where af b
demonstrates a phase transition on randomly generated discops  larrosa   schiex         the
extensive evaluation includes comparisons of the performance of af b to that of the best discop
search algorithms  these include asynchronous branch and bound like adopt  modi et al         
as well as algorithms that are based on other principles   dpop  petcu   faltings      a  that uses
two passes on a pseudo tree and opt ap o that divides the discop into sub problems  mailler  
lesser        
the plan of the paper is as follows  distributed constraint optimization are presented in section    in section    the af b algorithm in full details is presented  in section   a version of the
af b algorithm which is enhanced with conflict directed backjumping  cbj  is presented  a correctness proof of the af b algorithm is presented in section    in section   an extensive empirical
evaluation of the af b algorithm is presented  af b is compared with the state of the art discop
algorithms  adop t which like af b does not include centralization of the problems data and
dp op and opt ap o  petcu   faltings      a  mailler   lesser         which are based on very
different principles  our conclusions are presented in section   

   distributed constraint optimization
formally  a discop is a tuple   a  x   d  r    a is a finite set of agents a    a         an   x is a
finite set of variables x   x       xm   each variable is held by a single agent  an agent may hold more
than one variable   d is a set of domains d    d       dm   each domain di contains the finite set of
values which can be assigned to variable xi   r is a set of relations  constraints   each constraint
c  r defines a none negative cost for every possible value combination of a set of variables  and
is of the form c   di   di          dik  r        a binary constraint refers to exactly two
variables and is of the form cij   di  dj  r        a binary discop is a discop in which
all constraints are binary  an assignment  or a label  is a pair including a variable  and a value from
that variables domain  a partial assignment  pa  is a set of assignments  in which each variable
appears at most once  vars pa  is the set of all variables that appear in pa  vars p a     xi  
a  di   xi   a   p a   a constraint c  r of the form c   di   di          dik  r      
is applicable to pa if xi    xi            xik  vars p a   the cost of a partial assignment pa is the
sum of all applicable constraints to pa over the assignments in pa  a full assignment is a partial
assignment that includes all the variables  vars p a    x    the goal is to find a full assignment of
minimal cost 
in this paper  we will assume each agent owns a single variable  and use the term agent
and variable interchangeably  and assume agent ai holds variable xi  modi et al         petcu  
faltings      a  mailler   lesser         we will assume that constraints are at most binary and the
delay in delivering a message is finite  yokoo      a  modi et al          furthermore  we assume
a static final order on the agents  known to all agents participating in the search process  yokoo 
  

fig ershman   m eisels     z ivan

figure    an example discop  each variable has two values r and b  all constraints are of the
same form as shown in the table to the left 

    a   these assumptions are commonly used by discsp and discop algorithms  yokoo      a 
modi et al         
example   an example of a discop is presented in figure    there are   variables  each variable
is held by a different agent  the domains of all variables contain exactly the two values r and b 
lines between variables represent  binary  constraints  the cost of these constraints is shown in the
table to the left  a partial assignment of   x    r   has a cost of zero  since there is no constraint
applicable to it  a partial assignment of   x    r    x    r   also has a cost of zero  since there is
no constraint applicable to it  a partial assignment of   x    r    x    r   has a cost of two  due to
the constraint c      a partial assignment of   x    r    x    r    x    b   has a cost of four  due to
the constraints c      c      c      one solution is   x    r    x    b    x    r    x    r   which has a
cost of five  this is a solution since there is no other full assignment of lower cost 

   asynchronous forward bounding
in the afb algorithm a single most up to date current partial assignment is passed among the agents 
agents assign their variables only when they hold the up to date cpa 
the cpa is a unique message that is passed between agents  and carries the partial assignment
that agents attempt to extend into a complete and optimal solution by assigning their variables on
it  the cpa also carries the accumulated cost of constraints between all assignments it contains  as
well as a unique time stamp 
due to the asynchronous nature of the algorithm  multiple cpas may be present at any instant 
however only a single cpa includes the most update to date partial assignment  this cpa has the
highest timestamp 
only one agent performs an assignment on a single cpa at any time  copies of the cpa are
sent forward and are concurrently processed by multiple agents  each unassigned agent computes a
lower bound on the cost of assigning a value to its variable  and sends this bound back to the agent
  

fia synchronous f orward b ounding for d istributed cop s

which performed the assignment  the assigning agent uses these bounds to prune sub spaces of the
search space which do not contain a full assignment with a cost lower than the best full assignment
found so far  a total order among agents is assumed  a  is assumed to be the first agent in the order 
and an is assumed to be the last  
in more detail  every agent that adds its assignment to the cpa sends forward copies of the cpa 
in messages we term fb cpa  to all agents whose assignments are not yet on the cpa  an agent
receiving an fb cpa message computes a lower bound on the cost increment caused by adding
an assignment to its variable  this estimated cost is sent back to the agent who sent the fb cpa
message via fb estimate messages  the computation of this bound is detailed in section     
notice that it is possible that the assigning agent already sent its cpa forward by the time the
estimations are received  should the estimations indicate that the cpa exceeds the bound  the agent
will generate a new cpa  with a different local assignment  and a higher timestamp associated
with it  and continue the search with this new cpa  the timestamping mechanism insures that
the obsolete cpa will  eventually  be discarded regardless of its current location  the timestamp
mechanism is described in section     
    afb   computing the lower bound estimation on cost increment
the computation of the lower bound on the cost increment caused by adding an assignment to the
agents local variable is done as follows 
denote by cost  i  v    j  u   the cost of assigning ai   v and aj   u  for each agent ai and
each value in its domain v  di   we denote the minimal cost of the assignment  i v  incurred by
an agent aj by hj  v    minudj  cost  i  v    j  u     we define h v   the total cost of assigning
the value v  to be the sum of hj  v  over all j   i  intuitively  h v  is a lower bound on the cost
of constraints involving the assignment ai   v and all agents aj such that j   i  note that this
bound can be computed once per agent  since it is independent of the assignments of higher priority
agents 
an agent ai   which receives an f b cp a message  can compute for every v  di both the
cost increment of assigning v as its value  i e  the sum of the cost that v has with the assignments
included in the cp a  and h v   the sum of these  is denoted by f  v   the lowest calculated f  v 
among all values v  di is chosen to be the lower bound estimation on the cost increment by agent
ai  
figure   presents a constraint network  large ovals represent variables while small circles represent values  in the presented constraint network  a  already assigned the value v  and a    a    a 
are unassigned  let us assume that the cost of every constraint is one  the cost of v  will increase
by one due to its constraint with the current assignment thus f  v         since v  is constrained with
both v  and v    assigning this value will trigger a cost increment when a  performs an assignment 
therefore h v        is an admissible lower bound of the cost of the constraints between this value
and lower priority agents  since v  does not conflict with assignments on the cpa  f  v        as
well  f  v        because this assignment conflicts with the assignment on the cpa and in addition
conflicts with all the values of the two remaining agents 
since h v  takes into account only constraints of ai with lower priority agents  aj s t  j   i  
unassigned lower priority agents do not need to estimate their cost of constraints with ai   therefore 
these estimations can be accumulated and summed up by the agent which initiated the forward
bounding process to compute a lower bound on the cost of a complete assignment extended from
the cpa 
  

fig ershman   m eisels     z ivan

figure    a simple discop  demonstration
more formally we can define 
definition   cpa is the current partial assignment  containing the assignments made by agents
a            ai   
let us define the notions of past  local and future costs in definitions      and   
definition   pc  past cost  is the added cost of assignments made by higher priority agents on the
cpa  the costs incurred by agents a            ai   
definition   lc v   local cost  is the cost incurred to the cpa if ai would assign the value v and
add it to the cpa  therefore 
x
lc v   
cost  i  v    j  w  
 aj  w cp a

definition   fc v   future cost  is the sum of all lower bounds on cost increments caused by
agents ai             an for the cpa with the additional assignment of ai   v 
x
f c v   
minwdj  f  w    s t ai   v added to cp a
j i

the above definitions allow us to compute a lower bound on the cost of any full assignment
extended from the cpa  and use this bound in order to prune parts of the search space  an agent
 ai   which receives the cpa  can question  what be its lower bound if it would be extended with
an assignment of ai   v  pc and lc v  are both known to the agent  and fc v  can be computed
over time  by requesting future agents  lower priority agents  to compute their lower bounds and
send them back to ai   the sum pc   lc v    fc v  composes this lower bound  and can be used
to prune search spaces  this can happen when the agent knows that a full assignment was already
  

fia synchronous f orward b ounding for d istributed cop s

found with cost lower than this sum  and therefore exploring this search space would not lead to
any better cost solutions 
thus  asynchronous forward bounding enables agents an early detection of partial assignments
that cannot be extended into complete assignments with cost smaller than the known upper bound 
and initiate backtracks as early as possible 
    afb   algorithm description
the afb algorithm is run on each of the agents in the discop  each agent first calls the procedure
init and then responds to messages until it receives a t erm in at e message  the algorithm
is presented in figure      the computation of bounds  and the time stamping mechanism are not
shown  as they are explained in the text 
in the initialization  each agent updates b to be the cost of the best full assignment found so far
and since no such assignment was found  it is set to infinity  line     only the first agent  a    creates
an empty cpa and then begins the search process by calling assign cpa  lines       in order to find
a value assignment for its variable 
an agent receiving a cpa  when received cpa msg   first makes sure it is relevant  the time
stamp mechanism is used to determine the relevance of the cpa and will be explained in section     
if the cpas time stamp reveals that it is not the most up to date cpa  the message is discarded 
in such a case  the agent processing the message has already received a message implying that an
assignment of some agent which has a higher priority than itself  has been changed  when the
message is not discarded  the agent saves the received pa in its local cpa variable  line     then 
the agent checks that the received pa  without an assignment to its own variable  does not exceed
the allowed cost b  lines        if it does not exceed the bound  it tries to assign a value to its
variable  or replace its existing assignment in case it has one already  by calling assign cpa  line
     if the bound is exceeded  a backtrack is initiated  line     and the cpa is sent to a higher
priority agent  since the cost is already too high  even without an assignment to its variable  
procedure assign cpa attempts to find a value assignment  for the current agent  within the
bounds of the current cpa  first  estimates related to prior assignments are cleared  line      next 
the agent attempts to assign every value in its domain it did not already try  if the cpa arrived
without an assignment to its variable  it tries every value in its domain  otherwise  the search for
such a value is continued from the value following the last assigned value  the assigned value must
be such that the sum of the cost of the cpa and the lower bound of the cost increment caused by
the assignment will not exceed the upper bound b  lines         if no such value is found  then
the assignment of some higher priority agent must be altered  and so backtrack is called  line     
otherwise  the agent assigns the selected value on the cpa 
when the agent is the last agent  an    a complete assignment has been reached  with an accumulated cost lower than b  and it is broadcasted to all agents  line      this broadcast will inform
the agents of the new bound for the cost of a full assignment  and cause them to update their upper
bound b 
the agent holding the cpa  an   continues the search  by updating its bound b  and calling
assign cpa  line      the current value will not be picked by this call  since the cpas cost with
this assignment is now equal to b  and the procedure requires the cost to be lower than b  so the
agent will continue the search  testing other values  and backtracking in case they do not lead to
further improvement 
  

fig ershman   m eisels     z ivan

procedure init 
   b  
   if  ai   a   
  
generate cp a  
  
assign cp a  
when received  fb cpa  aj   p a 
   f  estimation based on the received p a 
   send  f b est im at e  f   p a  ai   to aj
when received  cpa msg  p a 
   cp a  p a
   t empcp a  p a
   if t empcp a contains an assignment to ai   remove it
    if  t empcp a cost  b 
   
backtrack  
    else
    assign cp a  
when received  fb estimate  estimate  p a   aj  
    save estimate
    if   cpa cost   all saved estimates   b  
    assign cp a  
when received  new solution  p a 
    b cp a  p a
    b  p a cost
procedure assign cpa 
    clear estimations
    if cp a contains an assignment ai   w  remove it
    iterate  from last assigned value  over di until found
v  di s t  cp a cost   f  v    b
    if no such value exists
   
backtrack  
    else
   
assign ai   v
    if cp a is a full assignment
   
broadcast  new solution  cpa  
   
b  cp a cost
   
assign cp a  
    else
   
send cpa msg  cpa  to ai  
   
forall j   i
   
send fb cpa  ai   cpa  to aj
procedure backtrack 
    clear estimates
    if  ai   a   
   
broadcast terminate 
    else
   
send cpa msg  cpa  to ai 

figure    the procedures of the afb algorithm

  

fia synchronous f orward b ounding for d istributed cop s

when the agent holding the cpa is not the last agent  line      the cpa is sent forward to the
next unassigned agent  for additional value assignment  line      concurrently  forward bounding
requests  i e  fb cpa messages  are sent to all lower priority agents  lines        
an agent receiving a forward bounding request  when received fb cpa  from agent aj   again
uses the time stamp mechanism to ignore irrelevant messages  only if the message is relevant  then
the agent computes its estimate  lower bound  of the cost incurred by the lowest cost assignment to
its variable  line     the exact computation of this estimation was described in section      it is the
minimal f  v  over all v  di    this estimation is then attached to the message and sent back to the
sender  as a fb estimate message 
an agent receiving a bound estimation  when received fb estimate  from a lower priority
agent aj  in response to a forward bounding message  ignores it if it is an estimate to an already
abandoned partial assignment  identified by using the time stamp mechanism   otherwise  it saves
this estimate  line     and checks if this new estimate causes the current partial assignment to exceed
the bound b  line      in such a case  the agent calls assign cp a  line     in order to change its
value assignment  or backtrack in case a valid assignment cannot be found  
the call to backtrack is made whenever the current agent cannot find a valid value  i e  below
the bound b   in such a case  the agent clears its saved estimates  and sends the cpa backwards to
agent ai   line      if the agent is the first agent  nowhere to backtrack to   the terminate broadcast
ends the search process in all agents  line      the algorithm then reports that the optimal solution
has a cost of b  and the full assignment with such a cost is b cp a 
    the time stamp mechanism
as mentioned previously  afb uses a time stamp mechanism  nguyen et al         meisels  
zivan        to determine the relevance of the cpa  the requirements from this mechanism are
that given two messages with two different partial assignments  it must determine which one of
them is obsolete  an obsolete partial assignment is one that was abandoned by the search process
because one of the assigned agents has changed its assignment  this requirement is accomplished by
the time stamping mechanism in the following way  each agent keeps a local running assignment
counter  whenever it performs an assignment it increments its local counter  whenever it sends
a message containing its assignment  the agent copies its current counter onto the message  each
message holds a vector containing the counters of the agents it passed through  the i th element
of the vector corresponds to ai s counter  this vector is in fact the time stamp  a lexicographical
comparison of two such vectors will reveal which time stamp is more up to date 
each agent saves a copy of what it knows to be the most up to date time stamp  when receiving
a new message with a newer time stamp  the agent updates its local saved latest time stamp 
suppose agent ai receives a message with a time stamp that is lexicographically smaller than the
locally saved latest  by comparing the first i    elements of the vector  this means that the
message was based on a combination of assignments which was already abandoned and this message
is discarded  only when the messages time stamp in the first i    elemental is equal or greater
than the locally saved best time stamp is the message processed further 
the vectors counters might appear to require a lot of space  as the number of assignments can
grow exponentially in the number of agents  however  if the agent  ai   resets its local counter to
zero each time the assignments of higher priority agents are altered  the counters will remain small
 log of the size of the value domain   and the mechanism will remain correct 
  

fig ershman   m eisels     z ivan

    afb   example run
suppose we run afb on the discop in figure    x  will create an empty cpa  assign its first value
r and pass the cpa to x    the cpa will travel from x    to x  and finally to x    with each agent
assigning its first value  r  on it along the way until finally at x  we will have a full assignment
with total accumulated cost of    this cost will be broadcasted to all agents  line    in figure      as
the new upper bound  instead of infinity   next  x  will call the assign cp a procedure  line     
this call will result in a new assignment for x    with the value b  since the resulting full assignment
will have a cost of only    this will cause another broadcast update of the upper bound and another
call to assign cp a  in this next call  x  will have an empty domain and be forced to backtrack the
cpa to x    this cpa contains the assignments x    x    x    r  with a total accumulated cost
of   which is below the upper bound  therefore x  will call its assign cp a  line      examining
its remaining values  x  explores the assignment of b which will result in a cpa with a cost of  
 line      which is below the current upper bound b  the cpa is sent to x   line      x  calls the
assign cp a procedure  line      the value r will result in a cpa with a cost of    which is better
than the upper bound b of    and therefore is broadcasted  line      the next value  b  explored
by x  results in a cpa with cost    which is also broadcasted  the cpa is sent backwards to x   
x  has no more values to try  so it also backtracks the cpa  to x    x  assigns its next value  b 
and sends the cpa to x    in addition x  also sends copies of the cpa in fb cpa messages to x 
and x   line      if x  now receives this fb cpa  it computes an estimation of    because if x  is
r then it would increase this cpas cost by   and if it were b it would increase it by     and sends
this information back to x   line     suppose x  also receives his f b cp a  it then replies with
an estimation of    while the cpa explores the sub search in which x    b  passing between x 
and x     these estimations arrive at x    x  saves these estimations and adds them up  this leads to
the discovery that a backtrack is needed  since the cpas cost is    because x    r  x    b  with
the additional estimations of   results in a sum equal to the upper bound b  line      therefore 
x  abandons its assignment and attempts to assign its next value  calling assign cp a   line     
since x  has no values  this call results in a backtrack  line      the cpa sent from this backtrack
has a higher timestamp value than the cpa previously sent forward by x    and the former cpa
would eventually be discarded 
    discussion   concurrency  robustness  privacy and asynchronicity
at any point in time during the run of afb  there is a single most up to date cpa in the system 
each agent adds an assignment when it holds it  so assignments are performed sequentially  one
might think that this would necessarily result in poor performance  as the search process does not try
to take advantage of the existing multiple computational resources available to it  the concurrency
of afb comes from the use of the forward bounding mechanism  while the cpa is held by one
agent  many copies of it are sent forward  and a collection of agents compute concurrently lower
bounds for that cpa  when the cpa advances to the next agent  again this process repeats  and so
the unassigned agents are constantly kept working  either when they receive the cpa  or when they
need to compute bounds for some other partial assignment 
this degree of asynchronicity is similar to that employed by the asynchronous forward checking
afc algorithm for discsps  meseguer   jimenez        meisels   zivan         afc performs
a similar process in which the agents receive forward checking messages by agents which performed assignments  the unassigned agents perform forward checking  checking they have at least
one value which is consistent with all previous assignments   in afb these agents compute a lower
  

fia synchronous f orward b ounding for d istributed cop s

bound on their local cost increment due to all assignments made by previous agents  due to this
similarity we named our algorithm asynchronous forward bounding 
afbs approach is quite different from that used by asynchronous assignments algorithms such
as adopt or abt  modi et al         bessiere  maestre  brito    meseguer         in these
algorithms the search process attempts to perform assignments concurrently by the collection of
agents  since many agents are assigning their variables simultaneously  there is a probability that
must be handled by the algorithm  that the current agents view of assignments made by other agents
is incorrect  this is due to the fact that agents concurrently alter their assignments  the algorithm
must be able to deal with this uncertainty 
a search process which performs assignments asynchronously may be expected to save time
since agents need not wait for all assignments of past agents to reach them  as is done by a sequentially assigning algorithm  however  asynchronously assigning algorithms must also deal with
inconsistencies caused by message delay  for example  if several higher priority agents change
their assignments and only some of the messages are received  the others are delayed  computation
performed will be based on this inconsistent agent view  this type of scenario  which has computation based on an inconsistent partial assignment  is completely avoided by sequentially assigning
algorithms 
one variation of the afb algorithm has agents which sent out fb cpa messages  send these
messages only to the subset of the target agents which have a direct constraint with the sending
agent  this may be useful if the communication between agents is limited  agents may only communicate with agents with whom they have a direct conflict  and would keep the algorithm correct 
this change may have two effects  first  less agents will return bounds to the sending agents  these
bounds can be significant  greater than zero  since they take into account constraints with assignments of previous agents  which they may be conflicted with  and also constraints between the
receiving agent and agents of lower priority  constraint between unassigned agents   receiving less
lower bounds would not invalidate the correctness of the algorithm but it may cause the search process to needlessly explore sub spaces which could have been discovered to be dead ends  second 
the detection of obsolete cpas may be delayed since less agents receive a higher timestamp  which
the fb cpa may contain   the mechanism would remain correct since eventually another fb cpa
or the cpa itself would reach an agent which did not receive the fb cpa  however this may take
more time than a single cycle of messages  in other words  more time than the travel time of a
single message between two agents   the afb algorithm was intentionally presented as an algorithm which sends out fb messages to all unassigned agents  since no constraint on communication
between agents is assumed  in case such constraints exist  or one attempts to reduce the number of
messages sent by the algorithm  this variation should be explored 
privacy is considered one of the main motivations for solving problems distributively  the common model for distributed search algorithms on discsps and discops enables assignments and
nogoods to be passed among agents  yokoo  ishida  durfee    kuwabara        yokoo      b 
bessiere et al         modi et al         zivan   meisels        meisels   zivan         af b follows the model proposed by yokoo  sending assignments forward and bounds on partial assignments
 n ogoods  backwards  an additional privacy drawback of af b is the fact that agents can learn
about the assignments of non neighboring agents via cpas which they receive from their neighbors 
this problem can be easily solved in af b by a simple use of encryption  if every pair neighboring
agents will share an encryption key  then an agent would be able to learn only the assignments of
its neighbors when it receives a cpa  such use of limited encryption in discop algorithms was
recently proposed for dp op by  greenstadt  grosz    smith        
  

fig ershman   m eisels     z ivan

if  due to privacy  the constraints are partially known so that between two constrained agents 
only a part of the constraint is known to each of the constrained agents  then the bound computation
mechanism must be adjusted in afb  these type of constraints were discussed for discsp algorithms  brito  meisels  meseguer    zivan         to the best of our knowledge  no discop solver
so far has handled such constraints  this remains an interesting possible extension to afb as part
of future work 
robustness is another important aspect of a distributed search algorithm  we assumed that all
messages are delivered in the order in which they are sent and no messages are lost  however if
message passing is susceptible to losses or corruption of the data  afb may not terminate  if  say  the
cpa message is lost   it is also possible that the local data held by some agents will be corrupt  due
to some mechanical failure for example   a solution would be to build a self stabilizing algorithm 
self stabilization in distributed systems  dijkstra        is the ability of a system to respond to
transient failures by eventually reaching and maintaining a legal state  a self stabilizing version
was shown for a simple dfs algorithm for discsps  collin  dechter    katz         based on
that self stabilizing dfs algorithm  a self stabilizing version of dpop was developed  petcu  
faltings      b   however these are the only self stabilizing discsp discop solvers to the best
of the authors knowledge  clearly  a more thorough study of robustness and self stabilization is
required for discop algorithms 
to conclude  the afb algorithm includes concurrent computation by multiple agents  without
having to deal with the uncertainty that comes with asynchronous assignments  each agent that
receives a message containing a partial assignment knows with certainty that the given partial assignment is the one it was supposed to receive  and not a result of a network delay inconsistency 
therefore  afb has both concurrent computation and the certainty of working with consistent partial assignments  this results in a much better performance on hard instances of random discops 
as will be demonstrated in the empirical evaluation in section   

   afb with cbj
in both centralized and distributed csps backjumping can be accomplished by maintaining data
structures that allow an agent to deduce who is the latest agent  in the order in which assignments
were made  whose changed assignment could possibly lead to a solution  once such an agent is
found  the assignments of all following agents are unmade and the search process backjumps to
that agent  prosser        
a similar process can be designed for branch and bound based solvers for cops and discops 
consider a sequence of assignments by the agents a    a    a    a    a  where a  determined that
none of its possible value assignments can lead to a full assignment with a cost lower than the cost
of the best full assignment found so far  clearly  a  must backtrack 
in chronological backtracking  the search process would simply return to the previous agent 
namely a    and have it change its assignment  however  a  can sometimes determine that no value
change of a  would suffice to reach a full assignment with a lower cost  intuitively  a  can safely
backjump to a    if it can compute a lower bound on the cost of a full assignment extended from the
assignments of a    a  and a    and show that this bound is greater or equal to the cost of the best
full assignment found so far  this is the intuitive basis of how backjumping can be added to afb 
more formally  let us consider a scenario in which ai decides to backtrack  and the cost of the
best full assignment found so far is b  e g  the upper bound of the current state of the search   the
current partial assignment includes the assignments of agents a         ai   
  

fia synchronous f orward b ounding for d istributed cop s

definition   cpa    k  is the set of assignments made by agents a            ak in the current partial
assignment  we define cp a            
definition   fa k  is the set of all full assignments  which include all the assignments appearing
in cpa    k   in other words  this set contains all full assignments which can be extended from the
assignments appearing in cpa    k   naturally  fa    is the set of all possible full assignments 
on a backtrack  instead of simply backtracking to the previous agent  ai performs the following
actions  it computes a lower bound on the cost of any full assignment in fa i     if this bound is
smaller than b  it backtracks to ai  just like it would do in chronological backtracking  however 
if this bound is greater or equal to b  then backtracking to ai  would do little good  no value
change of ai  alone could result in a full assignment of cost lower than b  as a result  ai knows
it can safely backjump to ai    it may be possible for ai to backjump even further  depending on
the lower bound on the cost of any full assignment in
fa i     if this bound is smaller than b  it backjumps to ai    otherwise  it knows it can safely
backjump to ai    similar checks can be made about the necessity to backjump further 
the backjumping procedure relies on the computation of lower bounds for sets of full assignments  fa k    next  we will show how can ai compute such lower bounds  let us define the
notions of past  local and future costs in definitions      and   
definition   pc  past costs  is a vector of size n    in which the k th element     k  n  is
equal to the cost of cpa    k  
definition   lc v   local costs  is a vector of size n     computed by ai and held by it  in which
the k th element     k  n  is
x
lc v  k   
cost ai   v  aj   vj  
 aj  vj  cp a s t jk

since the cpa held by ai only includes assignments of a            ai    then
j  i  lc v  i       lc v  j 
intuitively  lc v  i  is the accumulated cost of the value v of ai   with respect to all assignments in
cpa    i  
definition   fcj  v   future costs  is a vector of size n    in which the k th element     k  n 
contains a lower bound on the cost of assigning a value to aj with respect to the partial assignment cpa    k   assume this structure is held by agent ai   if k  i then cpa    k  contains the
assignment ai   v  but for k   i the value v of ai is irrelevant as it does not appear in cpa    k  
the above vectors provide additive lower bounds on full assignments that start with the current
cpa up to k  fa k   pc k  ispthe exact cost of the first k assignments  lc v  k  is the exact cost of
the assignment ai   v  and j i f cj  v  k  is a lower bound on the assignments of ai          an  
therefore  the sum
x
falb v  k    lc v  k    p c k   
f cj  v  k 
j i

  

fig ershman   m eisels     z ivan

figure    an example discop
is a full assignment lower bound on the cost of any full assignment extended from cpa    k  in
which ai   v 
fa k  contains all full assignments extended from cpa    k   and is not limited to assignments
in which ai   v  if we go over all falb v  k   for all possible values v  di we produce a lower
bound on any assignment in fa k  
definition    falb k    minvdi  f alb v  k   
falb k  is a lower bound on the cost of any full assignment extended from cpa    k  
in a distributed branch and bound algorithm  this bound is computed by ai   pc   the cost
of previous agents is sent along with their value assignment messages to ai   lc v    the cost of
assigning v to ai can be computed by ai   ai requests all agents ordered after it  aj  j   i   to
compute fcj and send the results back to ai   this is part of the already existing afb mechanism
for forward bounding 
in the afb algorithm  gershman  meisels    zivan        ai already requests unassigned
agents to compute lower bounds on the cpa and send back the results  the additional bounds
needed for backjumping can be easily added to the existing afb framework 
    a backjumping example
to demonstrate the backjumping possibility  consider the discop in figure    again  large ovals
represent variables while small circles represent values   let us assume that the search begins with
a  assigning a as its value and sending the cp a forward to a    a    a    a    and a  all assign
the value a and we get a full assignment with cost     the search continues  and after fully
exploring the sub space in which a    a  a    a  the best assignment found is a    a  a   
a  a    b  a    a  a    b with a total cost of b    assume that a  is now holding the cp a
after receiving it from some future agent  a  or a     a  has exhausted its value domain and must
backtrack  it computes 
f alb a       p c      lc a        f c   a       f c   a     
  

fia synchronous f orward b ounding for d istributed cop s

                     
f alb b       p c      lc b        f c   b       f c   b     
                     
f alb      min f alb a      f lab b         
f alb     b  therefore a  knows that any full assignment extended from  a    a  would cost
at least    a full assignment with that cost was already discovered  so there is no need to explore
the rest of this sub space  and it can safely backjump the search process back to a    to change its
value to b  backtracking to a  leaves the search process within the  a    a  sub space  which
a  knows cannot lead to a full assignment with a lower cost 
    the afb bj algorithm
the afb bj algorithm is run on each of the agents in the discop  each agent first calls the procedure init and then responds to messages until it receives a terminate message  the algorithm is
presented in figures   and    as in pure afb  a timestamping mechanism is used on all messages 
the same timestamping mechanism used by afb is used in afb bj to determine which messages are relevant and which are obsolete  for simplicity we choose to omit the pseudo code detailing the calculation of lc  pc  fc and falb  as they were described in section     
the algorithm starts by each agent calling init and then awaiting messages until termination 
at first  each agent updates b to be the cost of the best full assignment found so far and since no
such assignment was found  it is set to infinity  line     only the first agent  a    creates an empty
cpa and then begins the search process by calling assign cpa  lines       in order to find a value
assignment for its variable 
an agent receiving a cpa  when received cpa msg   checks the time stamp associated with
it  an out of date cp a is discarded  when the message is not discarded  the agent saves the
received pa in its local cpa variable  line     in case the cpa was received from a higher priority
agent  the estimations of future agents in f cj are no longer relevant and are discarded  and the
domain values must be reordered by their updated cost  lines        then  the agent attempts to
assign its next value by calling assign cpa  line     or to backtrack if needed  line     
procedure assign cpa attempts to find a value assignment  for the current agent  the assigned
value must be such that the sum of the cost of the cpa and the lower bound of the cost increment
caused by the assignment will not exceed the upper bound b  lines      if no such value is found 
then the assignment of some higher priority agent must be altered  so backtrack is called  line     
when a full assignment is found which is better than the best full assignment known so far  it is
broadcast to all agents  line      after succeeding to assign a value  the cpa is sent forward to the
next unassigned agent  line      concurrently  forward bounding requests  i e  fb cpa messages 
are sent to all lower priority agents  lines        
an agent receiving a bound estimation  when received fb estimate  from a lower priority
agent aj  in response to a forward bounding message  ignores it if it is an estimate to an already
abandoned partial assignment  identified using the time stamp mechanism   otherwise  it saves this
estimate  line     and checks if this new estimate causes the current partial assignment to exceed
the bound b  line      in such a case  the agent calls assign cp a  line     in order to change its
value assignment  or backtrack in case a valid assignment cannot be found  
  

fig ershman   m eisels     z ivan

procedure init 
   b  
   if  ai   a   
  
generate cp a  
  
assign cp a  
when received  fb cpa  aj   p a 
   v  estimation vector for each pa    k      k  n 
   send  f b est im at e  v   p a  ai   to aj
when received  cpa msg  p a  aj  
   cp a  p a
   t empcp a  p a
   if  j   i    
    j re initialize f cj  v 
    reorder domain values v  di by lc v  i   from low to high 
    if  t empcp a contains an assignment to ai   remove it
    if  t empcp a cost  b 
    backtrack  
    else
    assign cp a  
when received  fb estimate  v   p a   aj  
    f cj  v   v
    if   falb v  i   b  
    assign cp a  
when received  new solution  p a 
    b cp a  p a
    b  p a cost
figure    initialization and message handling procedures of the afb bj algorithm

the call to backtrack is made whenever the current agent cannot find a valid value  i e  below
the bound b   in such a case  the agent calls backtrackto   to compute to which agent the cpa
should be sent  and backtracks the search process  by sending the cpa  back to that agent  if the
agent is the first agent  nowhere to backtrack to   the terminate broadcast ends the search process
in all agents  line      the algorithm then reports that the optimal solution has a cost of b  and the
full assignment corresponding to this cost is b cp a 
the function backtrackto computes to which agent the cpa should be sent  this is the kernel
of the backjumping  bj  mechanism  it goes over all candidates  from j    down to    looking
for the first agent it finds that has a chance of reaching a full assignment with a lower cost than
b  falb v  j    is a lower bound on the cost of a full assignment extended from cpa    j     and
pc j  pc j    is the cost added to that cpa by aj s assignment  since aj picked the lowest cost
value in its domain  its domain was ordered in line      the addition of these two components
  

fia synchronous f orward b ounding for d istributed cop s

procedure assign cpa 
    if cp a contains an assignment ai   w  remove it
    iterate  from last assigned value  over di until the first value satisfying
v  di s t  cp a cost   f  v    b
    if no such value exists
   
backtrack  
    else
   
assign ai   v
   
if cp a is a full assignment
   
broadcast  new solution  cpa  
   
b  cp a cost
   
assign cp a  
   
else
   
send cpa msg  cpa  ai   to ai  
   
forall j   i
   
send fb cpa  ai   cpa  to aj
procedure backtrack 
    if  ai   a   
   
broadcast terminate 
    else
   
j  backtrackto  
   
remove assignments of aj         ai from cp a
   
send cpa msg  cpa  ai   to aj
function backtrackto 
    for j   i    downto  
   
foreach v  di
   
if   falb v  j       pc j    pc j       b  
   
return j
    broadcast terminate 
figure    the assigning and backtracking procedures of the afb bj algorithm 
produces a more accurate lower bound on the cost of a full assignment extended from cpa    j    
this can be safely added to the falb since the it adds a lower bound on the cost increment by an
agent for which the falb did not include a lower bound 
example   in the example presented in section      when a  computed the falb b     it added
the past costs of the partial assignments  cost incurred by a     the local cost of a    and a lower
bound on the cost increment by future agents  a  and a     to this sum we can safely add the cost
added by a  if we know that a  picked its lowest cost assignment 
this addition helps tighten the falb and reduce search  if this combined bound is not smaller
than b  then surely any combination of assignments made by aj and any following agent could
only raise the cost  which is already too high  in case even backjumping back to a  will not prove
helpful  the search process is terminated  line     
  

fig ershman   m eisels     z ivan

   correctness of afb
in order to prove correctness for af b two claims must be established  first  that the algorithm
terminates and second that when the algorithm terminates its global upper bound b is the cost of
the optimal solution  to prove termination one can show that the af b algorithm never goes into
an endless loop  to prove the last statement it is enough to show that the same partial assignment
cannot be generated more than once 
lemma   the af b algorithm never generates two identical cpas 
assume by negation that ai is the highest priority agent  first in the order of assignments 
that generates a cpa for the second time  now lets consider all possible events that immediately
preceded this creation 
case     ai received a cpa message from a lower priority agent  let us denote that agent as aj  
where j   i  when ai received this message  he executed lines       see figure       the procedure
backtrack in line    was not executed since we know ai generated a cpa  and that procedure would
not do so  therefore line    was executed  and the procedure assign cpa was invoked  ai executed
lines        line    was not executed since invoking the backtrack procedure could not lead to
the creation of the cpa  therefore  in line    a value as described in line    was found to exist 
line    searches for a value in ai s remaining value domain  not exploring any value previously
attempted for the current set of assignments of higher priority agents  since we assumed ai to
be the highest priority agent that generates a cpa for the second time  this combination of higher
priority assignments did not repeat itself  therefore  since ai received the current set of higher
priority assignments ai does not re pick any local value  and the set of high priority assignments
did not repeat itself  therefore ai cannot pick a value that would generate the same cpa for the
second time 
case     ai received a cpa message from a higher priority agent  let us denote that agent as
aj   where j   i  since we assumed ai to be the highest priority agent that generates a cpa for
the second time  this combination of higher priority assignments did not repeat itself  therefore any
value ai would assign next would generate a unique cpa  one which he could not have generated
before 
case     ai received a cpa message from itself  this cannot be since ai never sends such a
message to itself 
case     ai received an fb estimate message from aj   j   i since fb estimate are
only sent in response to fb cpa messages  which are only sent  line     to agents of lower priority
than ai   since this message caused the creation of a cpa  the condition in line    must have been
evaluated to be true  and the procedure assign cpa in line    invoked  similar to case    lines      
were executed and line    was not  similar to case    a value was found in line     this value does
not repeat any value previously picked under the current set of higher priority agent assignments 
this is the only time the agent received such current set of higher priority agent assignments due to
the assumption that ai is the first to generate a cpa twice 
case     the procedure init was invoked  this cannot be since no cpas were previously generated  any cpa generated now must be unique 
no other events could have immediately preceded the creation of the second identical cpa 
therefore it is impossible for this event to occur  this completes the proof of the lemma 
termination follows immediately from lemma   

  

fia synchronous f orward b ounding for d istributed cop s

next  one needs to prove that upon termination the complete assignment  corresponding to the
optimal solution  is in b cp a  see figure       there is only one point of termination for the
af b algorithm  in procedure backtrack  so  one needs to prove that during search no partial
assignment that can lead to a solution of lower cost than b is discarded  let us consider all possible
cases where an agent discards a cpa  changes a value or skips over a value and let us show that
this cannot be  skipping over or changing a value is only done inside the procedure assign cpa
in lines        if v is a value that is skipped over  then by the condition itself in line    it holds
that cp a cost   f  v   b  since b  b cp a  cp a cost   f  v   b  b cp a and this
means that v could not possibly lead to a solution of cost lower than b cp a at termination  let
us consider all possible cases in which a value is changed  this only occurs inside the procedure
assign cpa  let us then consider all possible cases in which this procedure is invoked that result in
a value change 
case     invoking assign cpa from the init procedure  line     no solution could be lost since
this is the very first assignment performed  no part of the search space is skipped over by this
assignment 
case     invoking assign cpa from inside the assign cpa procedure  line      this happens
when a new best  so far  solution was found  obviously changing the assignment now would not lose
this solution since it is saved and broadcasted as the new current solution  it will only be discarded
if a better solution is later found 
case     invoking assign cpa following a received fb estimate message  line      the
current partial assignment can be safely discarded  knowing that no solution will be lost since the
condition in line    indicated that the current partial assignment has a lower bound that exceeds the
best solution found so far 
case     invoking assign cpa following a received cpa msg message  line     from aj where
j   i  this means the cpa returned from a backtrack after fully exploring the current sub space 
and therefore changing the current assignment would not lead to any potential solution lost 
case     invoking assign cpa following a received cpa msg message  line     from aj where
j   i  this means that the cpa was received from a higher priority agent  ai did not yet pick an
assignment  so any assignment it will make will not lose out on any potential solutions 
therefore  any value skipped over and any change to the cpa will not lead to the loss of a
potential solution  the only remaining event that may lead to a solution being skipped over is a
cpa being discarded  this is done by the time stamping mechanism and only occurs when the
agent knows of the existence of a more up to date cpa  that cpa was created because some agent
changed its assignment by calling assign cpa  we showed that in such a case no better solution can
be lost  therefore it is safe to discard the cpa 
in conclusion  in any event a value is skipped over or changed or a cpa is discarded  no possible better solution is lost  therefore at termination  the afb algorithm reports the best solution
possible  this completes the correctness proof of the af b algorithm  
in order to prove the correctness of the afb bj algorithm we first prove the correctness of the proposed backjumping method and then show that its combination with afb does not violate afbs
correctness which has been proven 
in order to prove the correctness of the backjumping method one need only show that none
of the agents assignments that the algorithm backjumps over  can lead to a solution with a lower
cost than the current upper bound  the condition for performing backjumping over an agent aj
 line     is that the lower bound on the cost of a full assignment extended from the assignments of
  

fig ershman   m eisels     z ivan

figure    total non concurrent computational steps by afb  adopt and sbb on low density
 p        max discsp

a        aj  and of the assignment cost of aj exceeds the global upper bound b  since aj picked
the lowest cost value in its remaining domain  as the domain is ordered   extending the assignments
of a        aj  must lead to a cost greater or equal to b  therefore  backjumping back to aj 
cannot discard any potentially lower cost solutions  this completes the correctness proof of the
afb bj backjumping  function backtrackto  method 
assuming the correctness of afb  in order to prove the correctness of the composite algorithm
afb bj it is enough to prove the consistency of the lower bounds computed by the agents in afbbj  the lower bounds computed by afb bj include fc  lc and pc as described in section    pc
is contained in the cpa  and is updated by any agent that receives it and adds an assignment  not
shown in the code   lc v  is computed by the current agent ai whenever it assigns v as its value
assignment  fcj is computed by aj in line    in figure     and is sent back to ai in line    ai
receives and saves this in line     the lower bounds contained inside these vectors are correct
because pc was exactly calculated when holding the cpa  lc was exactly calculated by the current
agent ai   and the bounds in fcj are the same bounds computed in afb which were proven to be
correct lower bounds for the assignment of aj   the fcj bounds are accurate and based on the
current partial assignment since the timestamp mechanism prevents processing of bounds which are
based on an obsolete cpa  whenever the cpa is altered by some higher priority agent  the previous
bounds are cleared  line    of figure     this completes the correctness proof of af b  bj  

   experimental evaluation
all experiments were performed on a simulator in which agents are simulated by threads which
communicate only through message passing  the distributed optimization problems used in all of
the presented experiments are random max discsps  the network of constraints  in each of the
experiments  is generated randomly by selecting the probability p  of a constraint among any pair
of variables and the probability p    for the occurrence of a violation  a non zero cost  among two
assignments of values to a constrained pair of variables  such uniform random constraints networks
of n variables  d values in each domain  a constraints density of p  and tightness p  are commonly
used in experimental evaluations of csp algorithms  cf   prosser          max csps are commonly
used in experimental evaluations of constraint optimization problems  cops   larrosa   schiex 
  

fia synchronous f orward b ounding for d istributed cop s

figure    total number of messages sent by afb  adopt and sbb on low density  p        maxdiscsp

 a 

 b 

figure     a  number of none concurrent steps performed by adopt  afb  afb minc and afbbj for high density max discsp  p           b  a closer look at p       

       other experimental evaluations of discops include graph coloring problems  modi et al  
      zhang et al          which are a subclass of max discsp 
in order to evaluate the performance of distributed algorithms  two independent measures of
performance are used   run time  in the form of non concurrent steps of computation  zivan  
meisels      b   and communication load  in the form of the total number of messages sent  lynch 
      yokoo      a  
in the first set of experiments  the performance of af b is compared to that of two algorithms 
the synchronous b b algorithm  sbb   hirayama   yokoo        and the asynchronous distributed optimization algorithm  adop t    modi et al          figure   presents the average runtime in number of non concurrent computation steps  on randomly generated max discsps with
n      agents  domain size d       and a constraint tightness of p         figure   compares the
  

fig ershman   m eisels     z ivan

 a 

 b 

figure      a  number of messages sent by adopt  afb  afb minc and afb bj for high density
max discsp  p           b  a closer look at p       

same algorithms on the same problems by the total number of messages sent  from these figures
it is clear that adopt outperforms the basic algorithm sbb  in accordance with the past experimental evaluation of these two algorithms  modi et al          it is also clear that afb outperforms
adopt by a large margin for tight  high p    problems  this is true for both measures 
the second set of experiments includes the adopt algorithm and three versions of the afb algorithm  afb  afb minc   a variation of afb which includes dynamic ordering of values based on
minimal cost  of the current cpa   and afb bj which is the composite backjumping and forwardbounding algorithm  afb bj uses the same value ordering heuristic as afb minc  this was selected in order to show that the improved performance of afb bj does indeed arise from the backjumping feature and not from the value ordering heuristic 
figure   presents the average run time in number of non concurrent computation steps  of all
the algorithms  adopt  afb  afb minc and afb bj  on max discsps with n      agents 
domain size d       and a constraint density of p         asynchronous optimization  adopt  is
much slower than the standard version of afb  also clear from this figure  is that the value ordering
heuristic greatly improves afbs performance  the added backjumping improves the performance
much further  the rhs of the figure provides a zoom in on the section of the graph between
p        and p          for such tight problems  adopt did not terminate in a reasonable
amount of time and had to be terminated manually  and thus is missing from the graph  
for tightness values that are higher than p        afb and its variants demonstrate a phase
transition  this phase transition behavior of the afb algorithms is very similar to that of lookahead algorithms on centralized max csps  larrosa   meseguer        larrosa   schiex        
our explanation for this phase transition is that problem difficulty increase exponentially with
tightness but only up to some point  when the problem becomes over constrained such that many
combinations produce the highest cost possible all these combinations are in fact equal in quality 
and can be easily pruned by an intelligent search 
  

fia synchronous f orward b ounding for d istributed cop s

figure     number of non concurrent constraint checks  ncccs  performed by several discop
solvers for high density max discsp  p         in both linear scale  top  and logarithmic scale  bottom 

figure    presents the total number of messages sent by each of the algorithms  the results
of this measurement closely match the results of run time  as measured by non concurrent steps 
  

fig ershman   m eisels     z ivan

figure     number of non concurrent constraint checks  ncccs  performed by several discop
solvers for low density maxdiscsp  p         in logarithmic scale

we can see that adopt has an exponentially rapid growth of messages  the explanation for this
growth is simple  following each message an agent receives in adopt  several value messages
are sent to lower priority agents  and a single cost message is sent to a higher priority agent  modi
et al          on the average  at least two messages are sent for every message received  therefore
the total number of messages in the system increases exponentially over time 
the third batch of experiments  includes a comparison with two additional discop solvers dpop  petcu   faltings      a  and optapo  mailler   lesser         dpop performs only a
linear number of computational steps  but each step performs an exponential number of computations  the number of messages in dpop is linear   n  in the number of agents  similar to adopt 
dpop also uses a pseudo tree ordering of the agents and so we use the same ordering for both
algorithms  optapo performs a partial centralization of the problem  and has agents that solve a
part of the problem they are in charge of  therefore  for both algorithms  evaluation measures that
use the number of  non concurrent  computational steps are inappropriate  since the steps can be
exponentially time consuming  for this reason  the performance of all algorithms must be evaluated by a different metric  the canonical choice is the number of non concurrent constraint checks
 n cccs   this implementation independent measure includes the computations performed within
every single step  zivan   meisels      b      a         the number of messages sent is also not
a good measure in this case  since dpop sends out exponentially large messages  but only a linear
number of them  while the other algorithms send out an exponential amount of messages but of
only linear size  thus we only present the results using the n cccs metric  we repeat the experimental setup of the previous experiment on randomly generated problems  and report the total
number of non concurrent constraint checks  ncccs  in figure     the results are presented in
both logarithmic and linear scales 
in this experiment optapo  sbb and adopt did not terminate in a reasonable time on some
of the harder problem instances and are therefore partially absent in the graphs  the computation
  

fia synchronous f orward b ounding for d istributed cop s

in dpop is composed of each agent sending out a message containing its subtrees optimal cost
for every possible combination of higher priority constrained agents  for a given constraint density
the size of the message each agent sends would not be effected by changing the constraint tightness  therefore  the computation performed by each agent is unaffected by changing the constraint
tightness  p     dpops run time is expected to remain roughly the same for all tightness values in
our experiment  for problems with a low constraint tightness dpops performance is poor when
compared to the rest of the algorithms  however  as problem tightness increases the gap between
dpops run time and the rest of the algorithms narrows  until at p        dpop and optapo and
sbb have roughly the same run time  at p         dpop outperforms adopt  optapo and sbb
 which did not terminate   afb and its variants outperform dpop for the whole range of constraint
tightness by orders of magnitude  optapo appears to perform only slightly better than sbb and
afb clearly outperforms it by orders of magnitude  afb and its variations produce the same phase
transition as reported in previous experiments  and af b  bj comes out as the best performing
algorithm for solving random discops 
the results for a similar experiment in low density  p         max discsps are presented in
figure     notice the logarithmic scale   as in high density problems  dpop performance is unaffected by the problem tightness  producing roughly similar results for all tightness values  at
low tightness values  optapo and afb are vastly superior to dpop while optapo slightly outperforms afb  as tightness increases  optapo increases exponentially in run time to become the
worst performing algorithm  afb outperforms dpop at all tightness values except at p        

   conclusions
the asynchronous forward bounding algorithm  af b  uses asynchronous and concurrent constraint propagation on top of the distributed branch and bound scheme  in its forward bounding
protocol af b maintains local consistency  and prevents exploration of dead ends of the searchspace  the run time and network load of afb were evaluated by an asynchronous simulator on
randomly generated m ax  discsp s  the results of this evaluation revealed a phase transition
in af bs performance  as the tightness of the problems increased beyond some point  no other
discop solver was reported to display such a behavior  a similar phase transition was previously
reported for centralized cop solvers  as part of the work of larrosa et  al   larrosa   meseguer 
      larrosa   schiex         the phase transition observed there is reported to occur only by
cop solvers  that enforce a strong enough form of local consistency  larrosa   meseguer       
larrosa   schiex         we therefore attribute this behavior of afb to its concurrent enforcement
of local consistency 
af b can be extended  one extension is to include a value ordering heuristic  a good ordering heuristic is the minimum cost heuristic  where values with lower cost due to assignments of
higher priority agents are selected first  we named this version of the algorithm afb minc  in the
experiments  the use of this heuristic substantially improved the performance of af b 
a further extension of af b enhanced it with a backjumping mechanism  by adding a small
amount of information to the bounding messages  agents which detect that the lower bound of the
current partial assignment is too large  i e  the state is inconsistent and backtracking is required 
are now able to check whether backtracking to the previous agent will indeed help to reduce the
lower bound so that the resulting partial assignment is consistent  otherwise  the search process
backtracks even further  the resulting algorithm  afb bj  performs significantly better than the
other versions of afb  by comparing afb minc and afb bj  it was shown that the backjumping
  

fig ershman   m eisels     z ivan

does indeed affect performance  and the improvement over standard af b is not only a result of the
addition of the ordering heuristic 
the af b algorithm was compared to two algorithms that are based on the branch   bound
mechanism in its distributed form   adopt and sbb  yokoo      b  modi et al          the
experimental evaluation clearly demonstrates a substantial difference in performance between the
algorithms  asynchronous distributed optimization  adop t   outperforms sbb  but af b outperforms adop t by a large margin in both measures of performance  to the best of our knowledge this is the only evaluation of adop t on increasingly tighter problems  other experimental
evaluations measured adop t s scalability  by increasing the number of variables  and not by increasing the difficulty  tightness  of problems of a fixed size  the exponential growth of the number
of messages in adop t is also apparent in figures   and    a   outperforming af b are the two
extended versions of af b  afb minc and afb bj  with afb bj having the best performance 
the proposed value ordering heuristic improves performance  and when adding the backjumping
mechanism on top of that  performance is even further enhanced 
although af b and adop t perform concurrent computation the nature of concurrency used
by them is very different  concurrency in adop t is achieved by performing asynchronous assignments  in such an algorithm each agent picks its value assignment and is free to change it at
any time  multiple agents may change their assignments concurrently  asynchronous assignments
introduce some degree of uncertainty with regard to the consistency of the current partial assignment as known to an agent  in fact  there are scenarios in which an agent may base its computation
on an inconsistent partial assignment  which is a combination of assignments performed by higher
priority agents that are not aware of each others most up to date assignment 
two algorithms that were used for comparisons with af b   adop t and dp op   use the
pseudo tree ordering of agents  which allows independent subproblems to be solved concurrently 
a good pseudo tree ordering can be problematic to find  it is np hard to find the optimal ordering  
and sometimes even the best ordering is not good enough  due to the structure of the specific problem  overall  these orderings become less useful when dealing with problems with high constraint
density 
in order to further evaluate the performance of afb  it was compared and tested against two
additional discop algorithms  both dpop and optapo do not use branch and bound to find an
optimal solution  the dpop algorithm delivers all possible partial assignments up the pseudo tree
and performs an exponential number of constraints checks in two passes over the pseudo tree  petcu
  faltings      a   optapo partitions the discop into sub problems  each solved by a mediator
of that sub problem  mailler   lesser         the performance of these algorithms is expected to
be different than algorithms that use branch   bound search  in fact  the performance of dpop
on randomly generated discops is independent of the tightness of the problems  the results of
extensive empirical evaluations of all algorithms on random discops are described in section  
and are conclusive  the afb algorithm is the best performing discop algorithm on randomly
generated discops in both measures of performance  it performs less non concurrent constraints
checks and it sends a smaller number of messages 
in essence  the idea behind af b can be summed up as follows   run a sequential assignment
optimization process and concurrently run in parallel many additional processes that check the consistency of the partial assignment  the main search process is slow  at any point in time only one
agent holds the current partial assignment in order to extend it  concurrency is achieved via the
forward bounding  which is performed concurrently 
  

fia synchronous f orward b ounding for d istributed cop s

the results of the experimental evaluation show that adding concurrent maintenance of bounds
to a sequential assignment process results in an efficient optimization algorithm  af b   this algorithm outperforms all other concurrent algorithms on the hard instances of random discops 

references
ali  s  m   koenig  s     tambe  m          preprocessing techniques for accelerating the dcop
algorithm adopt   in aamas  pp           
bessiere  c   maestre  a   brito  i     meseguer  p          asynchronous backtracking without
adding links  a new member in the abt family  artificial intelligence               
brito  i   meisels  a   meseguer  p     zivan  r          distributed constraint satisfaction with
partially known constraints  constraints  in press 
chong  y     hamadi  y          distributed log based reconciliation  in proc  ecai     pp 
       
collin  z   dechter  r     katz  s          self stabilizing distributed constraint satisfaction 
chicago journal of theoretical computer science    
dijkstra  e  w          self stabilizing systems in spite of distributed control  commun  acm 
               
gershman  a   meisels  a     zivan  r          asynchronous forward bounding with backjumping  in distributed constraints reasonning workshop  ijcai      hyderabad  india 
greenstadt  r   grosz  b     smith  m  d          ssdpop  improving the privacy of dcop
with secret sharing  in aamas     proceedings of the  th international joint conference on
autonomous agents and multiagent systems  pp     new york  ny  usa  acm 
hirayama  k     yokoo  m          distributed partial constraint satisfaction problem   in cp 
pp         
larrosa  j     meseguer  p          phase transition in max csp  in proc  ecai    budapest 
larrosa  j     schiex  t          solving weighted csp by maintaining arc consistency   artificial
intelligence           
lynch  n  a          distributed algorithms  morgan kaufmann series 
mailler  r     lesser  v          solving distributed constraint optimization problems using
cooperative mediation  in proceedings of the third international joint conference on autonomous agents and multiagent systems  aamas     pp          acm 
meisels  a     zivan  r          asynchronous forward checking for distributed csps  constraints             
meisels  a     zivan  r          asynchronous forward checking for distributed csps  constraints        
meseguer  p     jimenez  m  a          distributed forward checking  in proc  cp      workshop
on distributed constraint satisfaction singapore 
modi  p  j   shen  w   tambe  m     yokoo  m          adopt  asynchronous distributed constraints optimization with quality guarantees  artificial intelligence                  
  

fig ershman   m eisels     z ivan

nguyen  t   sam hroud  d     faltings  b          dynamic distributed backjumping  in proc 
 th workshop on distributed constraints reasoning dcr    toronto 
petcu 

a     faltings  b         
a value ordering heuristic for distributed resource allocation 
in proc  csclp    lausanne  switzerland
http   liawww epfl ch publications archive petcu     pdf 

petcu  a     faltings  b       a   a scalable method for multiagent constraint optimization   in
proc  ijcai     pp         
petcu  a     faltings  b       b   s dpop  superstabilizing  fault containing multiagent combinatorial optimization  in proceedings of the national conference on artificial intelligence 
aaai     pp         
prosser  p          hybrid algorithms for the constraint satisfaction problem  computational
intelligence            
prosser  p          an empirical study of phase transitions in binary constraint satisfaction problems  artificial intelligence            
silaghi  m  c     yokoo  m          nogood based asynchronous distributed optimization
 adopt ng    in proc  aamas    pp           
solotorevsky  g   gudes  e     meisels  a          modeling and solving distributed constraint
satisfaction problems  dcsps   in constraint processing     pp       new hamphshire 
yokoo  m       a   algorithms for distributed constraint satisfaction  a review  autonomous
agents   multi agent sys             
yokoo  m       b   distributed constraint satisfaction problems  springer verlag 
yokoo  m   ishida  t   durfee  e     kuwabara  k          distributed constraint satisfaction for
formalizing distributed problem solving  in ieee intern  conf  distrb  comp  sys   pp     
     
zhang  w   xing  z   wang  g     wittenburg  l          an analysis and application of distributed
constraint satisfaction and optimization algorithms in sensor networks  in proc   nd intern 
joint conf  on autonomous agents   multi agent systems  aamas      pp         melbourne  australia 
zhang  w   xing  z   wang  g     wittenburg  l          distributed stochastic search and distributed breakout  properties  comparishon and applications to constraints optimization problems in sensor networks  artificial intelligence                
zivan  r     meisels  a          dynamic ordering for asynchronous backtracking on discsps 
constraints             
zivan  r     meisels  a          conflict directed backjumping for maxcsps  in ijcai     
hyderabad  india 
zivan  r     meisels  a       a   concurrent search for distributed csps   artif  intell            
       
zivan  r     meisels  a       b   message delay and discsp search algorithms  annals of mathematics and artificial intelligence                

  

fi