journal of artificial intelligence research                  

submitted        published      

planning over chain causal graphs for variables with
domains of size   is np hard
omer gimenez

omer gimenez upc edu

dept  de llenguatges i sistemes informatics
universitat politecnica de catalunya
jordi girona     
      barcelona  spain

anders jonsson

anders jonsson upf edu

dept  of information and communication technologies
universitat pompeu fabra
roc boronat     
      barcelona  spain

abstract
recently  considerable focus has been given to the problem of determining the boundary
between tractable and intractable planning problems  in this paper  we study the complexity of planning in the class cn of planning problems  characterized by unary operators and
directed path causal graphs  although this is one of the simplest forms of causal graphs a
planning problem can have  we show that planning is intractable for cn  unless p   np  
even if the domains of state variables have bounded size  in particular  we show that plan
existence for ckn is np hard for k    by reduction from cnf sat  here  k denotes the
upper bound on the size of the state variable domains  our result reduces the complexity
gap for the class ckn to cases k     and k     only  since c n is known to be tractable 

   introduction
there is an ongoing effort in the planning community to determine the complexity of different classes of planning problems  known tractable classes are usually characterized by
a simple causal graph structure accompanied by additional restrictions on variables and
operators  however  the boundary between tractable and intractable planning problems is
still not clearly established  the present paper contributes a novel complexity result for
a class of planning problems with simple causal graph structure from the literature  in an
effort to reduce this complexity gap 
the problem of determining tractable classes of planning problems is not purely of theoretical interest  for instance  complex planning problems can be projected onto tractable
fragments of planning problems to generate heuristics to be used during search  katz  
domshlak      b   also  the causal graph heuristic  helmert        exploits the hierarchical structure of a planning problem by transforming it into a more tractable form  first  it
translates propositional variables into multi valued variables  a process that simplifies the
causal graph of the problem  then  it keeps relaxing the problem until the causal graph
becomes acyclic 
the present paper aims to study the complexity of planning problems in the class cn  
defined by domshlak and dinitz         the class cn contains planning problems with
c
    
ai access foundation  all rights reserved 

figimenez   jonsson

ckn
k  
k        
k 

plan generation
p
exp
exp

macro plan generation
p
 
intractable

plan existence
p
 
np hard

table    overview of the complexity results for the class ckn  

multi valued variables and chain causal graphs  i e   the causal graph is just a directed path
 implying that operators are unary   the notation n indicates that the number of state
variables is unbounded  in particular  we study the complexity of plan existence for cn  
i e   determining whether or not there exists a plan that solves a planning problem in cn  
even though planning problems in cn exhibit an extremely basic form of causal structure  i e   linear dependence between state variables  solving planning problems in cn is not
necessarily tractable  even if we impose additional restrictions  let ckn be the subclass of
cn for which state variables have domains of size at most k  it is known that class c n is
polynomial time solvable  brafman   domshlak        and that plan existence for class
cn is np hard  gimenez   jonsson      a   our aim is to study the complexity of plan
existence for those classes in between  namely ckn for k    
domshlak and dinitz        showed that there are solvable instances of c n that require
exponentially long plans  this means that there is no polynomial time plan generation
algorithm for ckn with k     as was the case for c n   however  this does not rule out the
existence of a polynomial time algorithm that determines plan existence for class ckn   or
even an algorithm that generates plans in some succinct form  like those of jonsson       
and gimenez and jonsson      a   this is not incompatible with cn being np hard 
in this paper  we prove that plan existence for the class ckn is np hard for k    
in other words  even if the causal graph is a directed path and the domains of the state
variables are restricted to contain no more than   values  deciding whether or not a plan
exists for solving the corresponding planning problem is np hard  our result implies that it
is not sufficient for a planning problem to exhibit linear variable dependence and restricted
variable domain sizes  additional restrictions are necessary to make planning tractable 
table   shows an overview of the complexity results for the class ckn to date  by
macro plan generation we mean any algorithm for generating a compact representation
of the solution  such as in the work of jonsson        and gimenez and jonsson      a  
the intractable result for this column means that the complexity is yet unknown but
cannot be in p unless p   np  else plan existence would be in p   the row for k     is due
to brafman and domshlak         the column for plan generation is due to domshlak and
dinitz         and the contributions of the present paper are marked in boldface  note that
the novel result subsumes that of gimenez and jonsson      a   who showed np hardness
for k   o n  
this paper is organized as follows  in section   we relate our results to previous work 
and in section   we introduce the notation used throughout  in section   we give formal
proof of a reduction from cnf sat to planning problems in c  
n   the main result  a
 
reduction from cnf sat to planning problems in cn   is then proved in section    although
  
the result for c n subsumes that for c  
n   we believe that the intuitive idea behind the cn
   

fichain causal graphs with domains of size  

reduction is easier to understand  and may be of interest for anyone trying to prove hardness
results under similar circumstances  in section   we discuss the complexity of the remaining
classes c n and c n  
we also prove the correctness of a third reduction  this time from cnf sat to c n   in
 
appendix a  the reductions for c  
n and cn previously appeared in a conference paper
 gimenez   jonsson      b   and the present paper provides formal proof of their correctness 

   related work
the complexity of planning has been studied extensively over the last twenty years  bylander        chapman        erol  nau    subrahmanian         many tractable classes of
planning problems exploit the notion of a causal graph in one way or another  knoblock
       is usually credited with introducing the causal graph in his work on hierarchical
planning  williams and nayak        required planning problems to have acyclic causal
graphs in an effort to ensure tractability  jonsson and backstrom        defined the class
 s of planning problems  also with acyclic causal graphs  and showed that plan existence
is tractable for this class 
domshlak and dinitz        introduced the class cn of planning problems studied in
this paper  as well as several related classes  all of which have a particular causal graph
structure  brafman and domshlak        designed a polynomial time algorithm for solving planning problems with binary state variables and polytree causal graphs of bounded
indegree  proving that planning is tractable for the class c n   brafman and domshlak
       presented complexity results related to the tree width of the causal graph  katz
and domshlak      a  used causal graph structure to prove several complexity results for
optimal planning 
jonsson        and gimenez and jonsson      a  designed polynomial time algorithms
that solve planning problems with restricted causal graphs by generating a hierarchy of
macros  recently  chen and gimenez        showed that the complexity of planning is
intractable unless the size of the largest connected component of the causal graph is bounded
by a constant  consequently  causal graph structure alone is not enough to guarantee
tractability  implying that additional restrictions are needed 

   notation
throughout the paper  we use  i  n  to denote the set  i          n  
let v be a set of state variables  and let d v  be the finite domain of state variable
v  v   we define a state s as a function on v that maps each state variable v  v to
a value s v   d v  in its domain  a partial state p is a function on a subset vp  v of
state variables that maps each state variable v  vp to p v   d v   we frequently use the
notation  v    x            vk   xk   to denote a partial state p defined by vp    v            vk   and
p vi     xi for each vi  vp  
a planning problem is a tuple p   hv  init  goal  ai  where v is the set of variables  init
is an initial state  goal is a partial goal state  and a is a set of operators  an operator
a   hpre a   post a i  a consists of a partial state pre a  called the pre condition and a
   

figimenez   jonsson

v 

v 

v 

v 

v 

figure    example causal graph of a planning problem in the class ck   
partial state post a  called the post condition  operator a is applicable in any state s such
that s v    pre a  v  for each v  vpre a    and applying operator a in state s results in a
new state s such that s  v    post a  v  if v  vpost a  and s  v    s v  otherwise 
a partial plan  for planning problem p is a sequence of operators a            ak  ak  
k     such that a  is applicable in the initial state init and  for each i      k   ai is
applicable following the application of a            ai  starting in init  note that a partial plan
does not necessarily solve p   a plan  for solving p is a partial plan such that the goal
state goal is satisfied following the application of a            ak   p is solvable if and only if
there exists such a plan  
the causal graph of a planning problem p is a directed graph  v  e  with the state
variables as nodes  there is an edge  u  v   e if and only if u    v and there exists an
operator a  a such that u  vpre a   vpost a  and v  vpost a    figure   shows an example
causal graph in the form of a directed path  the structure of the causal graph implies that
each operator a  a is unary  i e   the post condition of a is specified on a single variable
v  and the pre condition of a is specified on  at most  v and its predecessor v  in the causal
graph 
in this paper we study the class ckn of planning problems  defined as follows 
definition      a planning problem p belongs to the class ckn if and only if the causal
graph of p is a directed path and  for each v  v    d v    k 
for planning problems in ckn   the domain transition graph  or dtg  of a state variable
v is a labelled  directed graph  d v   e    with the values in the domain of v as nodes 
there is an edge  x  y   e  with label l  d v    if and only if there exists an operator
hv    l  v   x  v   yi in a  where v  is the predecessor of v in the causal graph  an edge
without label indicates that the pre condition of the corresponding operator is defined on v
alone  an edge with more than one label indicates the existence of multiple operators with
the same pre  and post condition on v but different pre conditions on v   

   c  
n is np hard
in this section we prove that c  
n is np hard by reduction from cnf sat  in other words 
to every cnf formula f we associate a planning instance p    f   of c  
n such that p    f  
is solvable if and only if f is satisfiable  we first describe the planning problem p    f   
then explain the intuitive idea behind the reduction  and finally provide formal proof of its
correctness 
let f   c       ck be a cnf formula on k clauses and n variables x            xn   we
define the planning problem p    f      v  init  goal  a  as follows  the variable set v is
 si   i       n        vs     vij   i      k   j      n     ve     ei   i       n      
with domains d si     d ei     d ve            for i       n      d vs            x   and
d vij      gx   g    g    ax   a    a    b    b    cx   c    c    for i      k   j      n   the initial state is
defined by init si     init ei     init ve        i       n      init vs     x  and init vij     ax
   

fichain causal graphs with domains of size  

s 

s n 

vs

v n

v  

vk 

vkn

ve

e 

e n 

figure    causal graph of the planning problem p    f   
 
 
 

 

 
 

 

 
 

 

x
 
 

   

 
 

figure    dtgs of the variables s    s            s n    vs  
for i      k   j      n   and the goal state is a partial state defined by goal vin     gx for
each i      k   goal ve        and goal ei      i mod    for each i       n     
before providing a formal definition of the operators in a  we give an intuitive overview
of the planning problem p    f    to do this  we present the causal graph of p    f   as well
as the dtgs of each state variable  a reader who is only interested in the formal proof
of the correctness of the reduction may skip to section      where we introduce the formal
definitions of operators in order to prove several theoretical properties of p    f   
    intuition
the planning problem p    f   associated to each cnf formula f consists of three parts  each
with a clearly defined role  the three parts are illustrated in figure    showing the causal
graph of p    f    the first part of p    f   corresponds to state variables s            s n    vs  
the second part corresponds to state variables v             v n           vk            vkn   and the third
part corresponds to state variables ve   e            e n    the role of the first part is to generate
a message corresponding to an assignment to the variables of the cnf formula f   the
role of the second part is to verify whether this assignment satisfies each clause ci   and to
remember this fact  using a value of state variable vin    finally  the role of the third part
is to make sure that the message is propagated all the way to the end of the chain 
the dtgs of state variables s            s n    vs appear in figure    these state variables
are used to generate an assignment  to the variables x            xn of the cnf formula f   to
do this  the operators of p    f   are defined in such a way that the value of vs can change
from x to either   or    while from   or   it can only change back to x  thus  by applying
the operators of p    f   it is possible to generate a sequence x  m    x          x  mn   x of values
of vs   where mj         for each j      n  
we define a message m as the sequence m            mn of n symbols  either   or    corresponding to a sequence of values of vs   in what follows  we refer to these symbols as the
bits of the message  the value x is used as a separator to distinguish between consecutive
bits of the message  given a message m  the assignment  is defined as  xj     mj for
each j      n   thus  the assignment to x  is determined by the first choice of whether to
change the value of vs from x to   or    and so on  the only purpose of the remaining state
variables si of the first part is to restrict the message m to contain no more than n bits 
   

figimenez   jonsson

 a 

 b 
a 

g 

a 

g 

c 

b 

c 

b 
a  b  g 

 

 

x
 

gx
 

ax

 

x
cx

x

gx
a  b  g 

 

x

ax cx gx

a  b  g 

x

ax cx gx

ax
ax cx gx

a  b  g 

ax cx gx

a  b  g 

ax cx gx

cx

x
a  b  g 

g 

a 

c 

b 

g 

a 

b 

ax cx gx
c 

 c 
a 

g 
a  b 
c  g 

cx gx g
 
gx

c  g 

cx gx g 

ax

a  b 
g 

c 

b 
ax cx

c 

c 

cx

c 

cx

ax cx
a 

cx

cx

c 
b 

cx
c 

figure    dtgs of  a  v      b  vi  for i      and  c  vij for j      dashed edges are
explained in the text 

the dtgs of state variables vij   i      k  and j      n   appear in figure    the
dashed edges in the dtgs indicate that the corresponding operators depend on the cnf
formula f   for example  if the assignment  x        satisfies the clause c    the edge from
v     ax with label   in figure   a  points to g    else it points to b    likewise  if  x       
satisfies c    the edge from v     ax with label   points to g    else it points to b   
recall that the role of the second part is to check whether the assignment  generated
by the first part satisfies the cnf formula f   for each clause ci and each variable xj of
f   the main function of state variable vij is to check whether the assignment  xj     mj
satisfies ci   to do this  state variable vij acts as a finite state automaton that propagates
each bit of the message m while keeping track of when the j th bit of the message arrives 
since the domain size of state variables is restricted  there is no way for vij to count the
number of bits it has received  instead  the fact that the j th bit has arrived is indicated
to it by vi j     moreover  the last state variable vin for each clause ci has to remember
whether or not ci has been satisfied by the assignment to some variable xj  
in summary  each state variable vij in the second part performs the following functions
through its values and operators 
   propagate the message m generated by vs  
   check whether the assignment to xj  the j th bit of m  satisfies the clause ci  
   

fichain causal graphs with domains of size  

 

 
a  a  
b  b    
g  g 

ax
cx
gx
 

 
 

 

 

 
 

figure    the domain transition graph of the variables ve   e            e n   
   remember whether ci was satisfied by the assignment to some xl   l  j 
   if j   n and ci has been satisfied  propagate this fact 
   if j   n  let vi j    know when the  j      th bit of the message has arrived 
note that the third function is only strictly necessary for j   n  however  including it for
all state variables makes the reduction more compact because of symmetry 
next  we briefly describe how vij implements each of these functions  each value in
the domain of vij has subscript       or x  to propagate the message  vij always moves
to a value whose subscript matches that of its predecessor  in the case of v     its subscript
should match the value of vs    unless ci is satisfied by the assignment to xl   l   j  the
value of vij remains in the subdomain  a    a    ax   prior to the arrival of the j th bit 
the clause ci is encoded into the dashed edges of the dtgs of variables vij   these
operators are such that when the j th bit mj arrives  vij moves from ax to gmj if the
assignment  xj     mj satisfies ci   and to bmj otherwise  the fact that the value of vij
is in the subdomain  g    g    gx   indicates that ci was satisfied by the assignment to some
xl   l  j  this fact is propagated all the way to vin since each subsequent state variable
for ci is forced to move to a value in the subdomain  g    g    gx   whenever the value of its
predecessor is in  g    g    gx    whether or not a clause ci has been satisfied is checked by
defining a goal state vin   gx  
finally  if j   n and vij moves to bmj   then vi j    moves to amj   from there  vij has
no choice but to move to cx   causing vi j    to return to ax   when the next bit arrives  vij
moves to either c  or c    correctly indicating to vi j    that the  j      th bit has arrived 
consequently  vi j    moves to either g   g    or b   b     depending on whether or not the
assignment to xj   satisfies ci   hence  the values of type b are used to delay the transition
of vi j    from a value of type a to either b or g  this is the mechanism that allows a
variable vij to react to the j th bit  for each clause ci   the operators for vi  are defined
such that vi  always reacts to the first bit 
the dtgs of state variables ve   e            e n  appear in figure    the function of these
state variables is to make sure that all n bits of the message m are propagated to the end
of the causal graph  a state variable  strictly speaking  a planner solving the planning
problem  is never forced to select an operator  so it can choose not to propagate a bit of the
message and instead wait for the next bit to arrive before acting  in turn  this may cause
another state variable to incorrectly conclude that a clause has  not  been satisfied  the
variables of the third part prevent this from happening  since the goal state is defined in
such a way that it cannot be reached unless all bits of the message arrive at the end of the
causal graph 
   

figimenez   jonsson

variable
s 
si  
i       n    
vs

operator
hs       s     i
hsi       si      si    i
hsi       si      si    i
hs n       vs   x  vs   mi
hs n       vs   m  vs   xi

qualifier

m        
m        

table    operators for the variables s    s            s n    vs  

    formal proof
in this section  we prove that c  
n is np hard by showing that the planning problem p    f  
is solvable if and only if the formula f has a satisfying assignment  to start with  we provide
formal definitions of the operators of p    f    the operators for s            s n    vs appear in
table    and the corresponding dtgs appear in figure    the operators for variables vij  
i      k  and j      n   appear in table    and the dtgs appear in figure    finally  the
operators for ve   e            e n  appear in table    and the dtgs appear in figure   
to reduce the space requirement we use shorthand in the definitions of operators  in
other words  hv    m  v   c  v   mi  m   a  b   denotes the existence of two operators
hv    a  v   c  v   ai and hv    b  v   c  v   bi  similarly  hv    a  b   v   c  v   di denotes
the existence of two operators hv    a  v   c  v   di and hv    b  v   c  v   di  for state
variables vij we also introduce reference numbers that allow us to easily refer to operators 
furthermore  some operators are conditional on properties of the cnf formula f   such
an operator only exists if the indicated property is satisfied  for example  the operator
hv     c    v     ax   v     g  i only exists if the clause c  is satisfied by x    and the operator
hv     c    v     ax   v     b  i only exists if c  is not satisfied by x    we use the set notation
xj  ci to denote that the literal xj appears in the clause ci  
the proof is organized as follows  we begin with a series of technical definitions and
lemmas          related to the operators and their implications  definition     then introduces the notion of admissible plans  and lemma     states that any plan for solving p    f  
has to be admissible  next  lemma      establishes that any admissible plan corresponds
to an assignment to the variables of the cnf formula f   and that all operator choices of the
plan are forced given this assignment  finally  lemma      determines the exact sequence
of values taken on by each state variable during the execution of an admissible plan  making
it possible to check whether the goal state is reached at the end of the execution  theorem
     then concludes that the only admissible plans solving p    f   are those corresponding
to satisfying assignments of f  
definition      given a partial plan  for p    f   and a variable v  v    v  is the number
of times the value of v is changed by operators in  
lemma      for each partial plan  for p    f    it holds that
  si    i for i       n      and
  vs     n 
   

fichain causal graphs with domains of size  

variable
v  

vi   
i      k 

vij  
i      k  
j      n 

ref 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    

operator
hvs      v     ax   v     g  i
hvs      v     ax   v     b  i
hvs      v     ax   v     g  i
hvs      v     ax   v     b  i
hvs   m  v     cx   v     cm i
hvs   m  v     gx   v     gm i
hvs   x  v     bm   v     cx i
hvs   x  v     cm   v     cx i
hvs   x  v     gm   v     gx i
hv i  n   a    b    g     vi    ax   vi    g  i
hv i  n   a    b    g     vi    ax   vi    b  i
hv i  n   a    b    g     vi    ax   vi    g  i
hv i  n   a    b    g     vi    ax   vi    b  i
hv i  n   am   bm   gm    vi    cx   vi    cm i
hv i  n   am   bm   gm    vi    gx   vi    gm i
hv i  n   ax   cx   gx    vi    bm   vi    cx i
hv i  n   ax   cx   gx    vi    cm   vi    cx i
hv i  n   ax   cx   gx    vi    gm   vi    gx i
hvi j     c    vij   ax   vij   g  i
hvi j     c    vij   ax   vij   b  i
hvi j     c    vij   ax   vij   g  i
hvi j     c    vij   ax   vij   b  i
hvi j     am   bm    vij   ax   vij   am i
hvi j     gm   vij   ax   vij   gm i
hvi j     cm   vij   cx   vij   cm i
hvi j     cm   gm    vij   gx   vij   gm i
hvi j     ax   cx    vij   am   vij   ax i
hvi j     cx   vij   bm   vij   cx i
hvi j     cx   vij   cm   vij   cx i
hvi j     cx   gx    vij   gm   vij   gx i

qualifier
x   c 
x  
  c 
x   c 
x  
  c 
m        
m        
m        
m        
m        
x   ci
x  
  ci
x   ci
x  
  ci
m        
m        
m        
m        
m        
xj  ci
xj 
  ci
xj  ci
xj 
  ci
m        
m        
m        
m        
m        
m        
m        
m        

table    operators for the variables v             vkn  

variable
ve

hvkn

e 
ei   i       n    

operator
  a    a    b    b    g    g     ve
hvkn   ax   cx   gx    ve
hve      e 
hve      e 
hei       ei
hei       ei

     ve    i
     ve    i
     e     i
     e     i
     ei    i
     ei    i

table    operators for the variables ve   e            e n   

   

figimenez   jonsson

proof  by induction on i  for i      variable s  can only change once  so  s        for
i       n      it follows from inspection of the operators that we cannot change the value
of si twice without changing the value of si  once in between  the operator for setting si
to   has si      as a pre condition  and the operator for resetting si to   has si     
as a pre condition   since we can change the value of si once in the initial state without
first changing the value of si    it follows that  si     si          i           i by
induction  the same argument holds for variable vs and its predecessor s n    so  vs   
 s n           n            n 
lemma      for each partial plan  for p    f   and each vij   i      k  and j      n   it
holds that  vij     v     where v  is the predecessor of vij in the causal graph 
proof  just as before  it follows by inspection of the operators that we cannot change the
value of vij twice without changing the value of v  in between  to see this  note that the
subscript of each value in d vij   is either x     or    an operator for vij either changes
its value from one with subscript x to one with subscript        if v  also has a value with
subscript        or from one with subscript       to one with subscript x  if v  also has a value
with subscript x  the same argument holds for v     although the values of its predecessor
vs are x     and   without subscripts  
note that the value of vij cannot change in the initial state without first changing the
value of v    since v  has to have a value with subscript   or   for the value of vij to change
from its initial value ax   consequently  the value of vij cannot change more times than the
value of v    so  vij     v    as claimed 
lemma      for each vij   i      k  and j      n   and each partial state  v    x  vij   y  
where v  is the predecessor of vij in the causal graph  there is at most one applicable operator
for changing the value of vij  
proof  by inspecting the operators it is easy to see that each pair of operators for vij have
different pre conditions  the only exception to this rule are operators that do not exist
simultaneously due to properties of the cnf formula f  e g  operators     and      
lemma      for each partial plan  for p    f    it holds that
  ve     vkn   
  e      ve    and
  ei     ei    for i       n     
proof  let v be a variable among ve   e            e n    and let v  be its predecessor in the causal
graph  as before  we cannot change the value of v twice without changing the value of v 
once in between  if v   e            e n     the operator setting v to   requires v       and the
operator resetting v to   requires v       for v   ve   the operator setting v to   requires
v  to have a value with subscript   or    while the operator resetting v to   requires v  to
have a value with subscript x  note that  in either case  we cannot change the value of v in
the initial state without first changing the value of v    thus   v    v    for each of these
variables  as claimed 
   

fichain causal graphs with domains of size  

we now turn to the problem of finding a plan  that solves p    f   
lemma      let  be a plan that solves p    f    then
  ei     n  i for i       n      and
  ve     n 
proof  by descending induction on i  for i    n     goal e n         so the value of
e n  has to change at least once from its initial value init e n         implying  e n    
     n    n      for i       n      assume that  ei       n   i      holds by
induction  from lemma     it follows that  ei     ei       n   i       however 
since goal ei      goal ei     and since  solves p    f    it follows that  ei       ei     
hence  ei      ei      from which it follows that  ei     n  i  as claimed  the same
argument applies to e  and its predecessor ve   since goal ve              goal e     yielding
 ve     n 
definition      an admissible plan  for planning problem p    f   is a partial plan such
that  si     i   vs      v                vkn      ve      n  and  ei      n  i  for each
i       n     
lemma      any plan  that solves p    f   is admissible 
proof  by lemmas     and     we have that  vs     v           vkn     ve    but 
by lemmas     and      all these values are equal to  n  since  n   vs   and  ve     n 
from the proof of lemma     we have that  si     si         i       n      and
 vs     s n         which together with lemma     and  vs      n implies  si     i 
i       n      from the proof of lemma     we have that  ve      e      ei      ei     
i       n      and  e n        which together with lemma     and  ve      n implies
 ei      n  i  i       n     
please note that the converse of lemma     is not true  that is  not all admissible plans
do solve the planning problem p    f   
as a consequence of lemma      to find a plan that solves p    f   we only need to
consider admissible plans  in particular  an admissible plan changes the value of variable vs
exactly  n times  generating a sequence of  n     values  note that the value of vs always
changes from x to either   or    and then back to x 
definition      let  be an admissible plan  and let x  m    x          x  mn   x be the sequence
of  n     values that variable vs takes on during the execution of   where mj         for
each j      n   we use m to denote the message m            mn induced by   and we use
 to denote the formula assignment   xj     mj for each j      n  
as it turns out  the operators that are part of an admissible plan  are completely
determined by the message m induced by  
lemma       let  be an admissible plan for p    f   and let m be its induced message 
the operators in  for changing the value of variable vij   i      k  and j      n   as well
as the sequence of values that variable vij takes on during the execution of   are completely
determined by m  
   

figimenez   jonsson

proof  for each v   v             vkn    let v  be its causal graph predecessor  from the proof of
lemma     we know that we cannot change the value of v twice without changing the value
of v  in between  and that in the initial state  we have to change the value of v  before we can
change the value of v  from the definition of admissible we know that  v       v     n 
the only way an admissible plan can change the value of v  n times without changing the
value of v  more than  n times is to first change the value of v    then v  then v    and so on 
now  from lemma     we know that  given a partial state  v    x  v   y   there is at
most one applicable operator for changing the value of v  thus  each time the admissible
plan changes the value of v for some value of v    there is at most one operator for doing so 
the plan has no choice but to select this operator since it is not allowed to change the value
of v  again before changing the value of v  consequently  if the sequence of values taken
on by v  is completely determined  the operators for v  as well as the sequence of values
it takes on  are completely determined also  the proof follows by a double induction on i
and j  since the sequence of values taken on by vs  the predecessor of v     is completely
determined by the message m  
it follows from lemma      that the only relevant degree of freedom of an admissible
plan  is selecting the elements of the message m   by repeatedly deciding whether to move
to vs     or vs     from vs   x  once m has been selected  all other operator choices are
forced  else the plan is not admissible  in particular  for each message m there is a unique
state s such that executing any admissible plan starting from init results in s  it remains
to determine whether this unique state matches the goal state 
remark  note that lemma      does not mention the operator order of an admissible plan 
indeed  we can change the order of the operators of an admissible plan without making the
plan inadmissible  as an example  let v    v    and v  be three consecutive variables in the
causal graph  and let ha     a     a     a     a     a   i be a subsequence of operators for changing their
values  such that aji is the j th operator for changing the value of vi   then the subsequence
i
ha     a     a     a     a     a   i achieves the same result  as long as the partial order haji   aji     aj  
i
is respected for each i and j  we can change the operator order as we please 
we proceed to determine the sequence of values that variable vij   i      k  and j 
    n   takes on during the execution of an admissible plan  with induced message m  
first  we define the satisficing index of clauses  and the sequence of values of a plan 
definition       let  be an admissible plan with induced message m   m  for each
clause ci   let the satisficing index ti      n    be the smallest number such that   xti    
mti satisfies ci   if no such number exists  ti   n     
definition       let  be an admissible plan  for each clause ci and each t       n      
let the sequence of values qti    be the vector of n values representing  for each variable
vij   j      n   the t th value taken on by vij during the execution of  
the following lemma is key to understanding the idea behind the reduction for c  
n   since
it specifies the sequences of values that an admissible plan induces during its execution 
lemma       let  be an assignment to variables x            xn of formula f  
   

fichain causal graphs with domains of size  

   existence  there exists an admissible plan  of planning problem p    f   with induced assignment     
   claim  let qti be the sequences of values described in part    of this lemma  all
admissible plans  with     have the same sequences of values qti      qti   for
all i      k  and t       n      
   sequence of values  the sequence of values qti   for i      k  and t       n      
is as follows 
a  if j   ti   then
nj

j 

z     
c x    cx
qi j   
 j
qi   cmj    cmj
 j  
 
c x    cx
qi

ax
bmj
cx

z     
ax    ax
amj    amj
ax    ax

ax
gmj
gx

z     
ax    ax
gmj    gmj
gx    gx

b  if j   ti   then
nj

j 

qi j 
q j
i
q j  
i

z     
c x    cx
 
  cmj    cmj
 
c x    cx

c  if j   ti   then
jti

nj

z     
gx    gx
gmj    gmj
gx    gx

z     
gx    gx
gmj    gmj
gx    gx

ti  

qi j 
q j
i
q j  
i

z     
 
c x    cx
  cmj    cmj
 
c x    cx

gx
gmj
gx

proof  before proving the lemma  we must check that the definition of qti given in part  
is consistent  this is necessary due to the overlapping of the statements  namely  for every
odd t other than   and  n      the sequence qti is defined twice  once as qi j  for j     t  

and another time as qi j    for j      t   however  these sequences of values are well defined
   
because the definitions of qi j  and q j
match for any combination of j and j    j    
i
as shown in the following table 


j

qi j      qi j 

case  a 

z      z     
cx    cx ax    ax

case  b 

z      z     
cx    cx ax    ax

case  c 

z      z     
cx    cx gx    gx

case  c 

z      z     
cx    cx gx    gx

j

j

    j   ti  

case  a 

j

    j   ti  

case  a 

ti  

j   ti      n 

case  b 

ti  

ti       j  n 

case  c 

   

nj 

nj 

nti   
nti   

figimenez   jonsson

now  we prove parts   and   of the lemma  assume  is an admissible plan with induced
assignment      the proof proceeds by a double induction on i and j  in particular 
 j  
we prove the validity of the three statements of type qi j    q j
  assuming that all
i   qi


t

statements of type qi  for any i   i and any t  and that all statements of type qi j     q j
i

and qi j     for any j    j  already hold  we first prove the validity of qi j    for j     
qi j    q i   ax    ax in cases  a  and  b  corresponds to the initial state of vi            vin
 note that case  c  cannot hold for j       when j     we know that  since the statements

are consistent  qi j    qi j    for j    j     hence the correctness of qi j  follows by
induction on j 
 j  
next  we prove the statements relative to q j
  consider the variable v  that
i and qi
precedes vi  in the causal graph  and values number  j      j  and  j     it takes on
during the execution of   if i      then v    vs and the values are x  mj   x  if i     
then v    v i  n and  by induction on i  the values are ax   amj   ax if j   ti  and j   n 
ax   bmj   cx if j   n   ti    ax   gmj   gx if j   ti    or gx   gmj   gx if j   ti   
the proof is divided into   parts  depending on the values of j and ti  
i      j   ti   consider the following table  where we write m instead of mj   m  to
simplify the notation 
v
vi 
 j   
 x  ax   gx  
ax
 m  am   bm   gm   
 j
 j      x  ax   cx   gx  


vi 
ax








vin
ax



the three rows of the table correspond to values number  j      j  and  j     of
variables v    vi            vin   the first column corresponds to the possible values that the
predecessor v  of vi  can take on  the first row is given by qi j    while the second
 j  
and third rows  to be filled  correspond to q j
 
i and qi
let a j be the operator causing the  j th value of vi    according to the previous
table  the pre condition of a j must be compatible with
hv    m    am    bm    gm     vi    ax i
that is  the values of variables v  and vi  when a j is applied  since ti        x     
m  does not satisfy clause ci   so the operator a j must be one of those labelled    
and     in table     only one of these operators is applicable  depending on the value
of m  and whether v  is vs or v i  n    in either case  the application of a j causes
the value of vi  to become bm    so we can fill in a blank in the previous table 
v
vi 
vi 
 j   
 x  ax   gx  
ax
ax
 j
 m  am   bm   gm   bm        
 j      x  ax   cx   gx  








vin
ax



in the same way  we can check that a j     the operator causing the   j      th value
of vi    must be one of those labelled     in table    the new value of vi  is cx   as for
   

fichain causal graphs with domains of size  

the remaining variables  it is easy to check that variables vi            vin become am    due
to operators of type       and then become ax   due to operators of type       the
table is now complete 
v
vi 
vi     vin
 j   
 x  ax   gx  
ax
ax    ax
 j
 m  am   bm   gm   bm        am    am     
 j      x  ax   cx   gx  
cx    
ax    ax     
this shows that case  a  of lemma      holds when j     and ti     
ii      j   ti   the proof is similar to that of case  i   since ti        x      m 
satisfies clause ci   as a result  the admissible operators for causing the  j th value
of vi  are now those labelled     and      in either case  the value of vi  becomes gm   
consequently  the admissible operators for vi            vin are different from before  this
is the resulting table 
v
vi 
vi     vin
 j   
 x  ax   gx  
ax
ax    ax
 j
 m  am   bm   gm   gm        gm    gm     
 j      x  ax   cx   gx  
gx    
gx    gx     
iii      j   ti   in this case  as in the remaining ones  we just show the resulting table 
we always write m   mj   in what follows  we omit the column for v  since its possible
values are always the same 
vi 
vi     vi j  
vij
vi j       vin
 j    cx
c x    cx
ax
ax    ax
cm    
cm    cm      bm         
am    am     
 j
 j     cx    
cx    cx      cx     
ax    ax     
iv      j   ti  
vi 
vi     vi j  
vij
vi j       vin
 j    cx
c x    cx
ax
ax    ax
cm    
cm    cm      gm         
gm    gm     
 j
 j     cx    
cx    cx      gx     
gx    gx     
v      ti   j 
vi 
vi     vin
 j    gx
gx    gx
 j
gm     gm    gm     
 j     gx     gx    gx     
vi      ti   j 
vi 
vi     vi ti   
viti    vin
 j    cx
c x    cx
gx    gx
 j
cm    
cm    cm      gm    gm     
cx    cx      gx    gx     
 j     cx    
   

figimenez   jonsson

it just remains to check that case  a  of lemma      follows from parts  i  and  iii  
case  b  from parts  ii  and  iv   and case  c  from parts  v  and  vi   this proves part
  and   of the lemma 
finally  note that the existence of an admissible plan  directly follows from the previous
discussion  since we have always specified which operators should be used in every situation 
and not just assumed their existence  this proves part   of the lemma 
theorem       there exists a plan that solves the planning problem p    f   if and only if
there exists an assignment  that satisfies the cnf formula f  
proof    given an assignment  that satisfies f   construct an admissible plan  whose
induced formula assignment  equals   by choosing the sequence of values of vs accordingly  it follows that ti  n for each clause ci   since there exists a variable xj such that
  xj     mj satisfies ci   then  q n  
has the form indicated in case  b  or  c  of lemma
i
      in either case  the   n      th value of variable vin is gx   as required by the goal state 
the plan  thus solves p    f   
  let  be a plan that solves the planning problem p    f    by lemma     the plan 
is admissible  we show by contradiction that     satisfies f   assume not  then there
exists a clause ci not satisfied by   implying ti   n      since n   ti   the   n      th
value of variable vin is cx according to case  a  of lemma       this contradicts  solving
p    f    since the goal value of vin is not cx but gx  
proposition       plan existence for c  
n is np hard 
proof  the largest variable domains of the planning problem p    f   are those of variables
v             vkn   which contain    values  the proof follows immediately from the well known
np hardness of cnf sat  theorem       and the fact that we can produce the planning
problem p    f   in polynomial time given the cnf formula f  
    example
we illustrate the reduction using a small example cnf formula f    x   x    on one
clause and two variables x  and x    the variable set of the corresponding planning problem
p    f   is v    s    s    s    vs   v     v     ve   e    e    e     an admissible plan  can induce any of
four different messages                         and         only the message        corresponds
to an assignment that does not satisfy f   a plan  that solves p    f   with induced
message        appears in table    note that  following execution of the plan  the goal state
goal    v     gx   ve      e       e       e       is satisfied as desired  the last value change
of each variable appearing in the goal state is marked using boldface 

   c n is np hard
in this section  we describe a reduction from cnf sat to c n   to each cnf formula f we
associate a planning problem p   f    for each clause ci and variable xj of f   p   f   contains
    with domain d v        a   a   a   b    and v     with domain d v      
two state variables vij
x     x
ij
ij
ij
    so d v        a   b   b    the
 ax   a    a    b    b     the values a  and a  are omitted for vin
x    
in
   

fichain causal graphs with domains of size  

  
 
hs       s       s     i
hs       s       s     i
hs       vs   x  vs    i
hvs      v     cx   v     c  i
hv     c    v     ax   v     g  i
hv     g    ve      ve    i
hve      e       e     i
hs       s     i
hs       s       s     i
hs       s       s     i
hs       vs      vs   xi
hvs   x  v     c    v     cx i
hv     cx   v     g    v     gx i
hv     gx   ve      ve    i

hs       vs   x  vs    i
hvs      v     ax   v     b  i
hv     b    v     ax   v     a  i
hv     a    ve      ve    i
hve      e       e     i
he       e       e     i
he       e       e     i
hs       s       s     i
hs       vs      vs   xi
hvs   x  v     b    v     cx i
hv     cx   v     a    v     ax i
hv     ax   ve      ve    i
hve      e       e     i
he       e       e     i
  
 

table    a plan that solves the planning problem p    f   for the example formula f  
 a 

 b 

 c 

 d 

a 

a 

a 

a 
a 

x

 

b 

x

ax

bx

ax

x

x

b 

ax

ax b 

ax

ax b 

bx
ax

ax
a 

 

ax a 

ax

a 

ax bx

ax

ax
a 

a 

b 
a 

ax
a 

bx

ax

 e 
b 
ax bx

a 

ax a 
a 

ax bx
b 

ax bx

a 
b 

     b  v     i       c  v     j       d  v     j   n   e  v    
figure    dtgs of  a  v  
i 
ij
ij
in

state variables s            s n    vs   ve   e            e n    as well as their domains and corresponding
   
operators  are the same as before  except the predecessor of ve is now vkn
      init v       a   i      k  and
the initial state on the new state variables is init vij
x
ij
 
j      n   and the goal state is goal vi      ax   i      k   table   lists the operators for
  and v     i      k  and j      n   and figure   shows the corresponding dtgs 
variables vij
ij
table   also lists the new operators for variable ve   which have different pre conditions now
   
that the predecessor of ve is vkn
    intuition
the reduction for c n is based on the following idea  instead of using an explicit value to
remember that a clause has been satisfied  the goal is to remain in the initial value ax  
this way we were able to reduce the size of the variable domains needed for the reduction 
somewhat surprisingly  the new reduction uses fewer total operators than that for c  
n  
   

figimenez   jonsson

variable
 
v  

  
vi 
i      k 
  
vij
i      k  
j      n 
  
vij
i      k  
j      n    

   
vin
i      k 

ve

ref 
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    

operator
    a   v    a i
hvs   m  v  
x   
m
    a   v    a i
hvs   x  v  
m   
x
    a   v    b i
hvs   x  v  
m   
x
    a   v    a i
 
  bm   vi 
hv i  n
x i 
m
 
    a   v    a i
hv i  n
  ax   vi 
x
m i 
 
    a   v    b i
hv i  n
  ax   vi 
m i 
x
    a   v    a i
 
  am   vij
hvi j  
m
x ij
 
    a   v    a i
hvi j  
  ax   vij
m ij
x
    b   v    a i
 
  bm   vij
hvi j  
m
x ij
 
 
 
hvi j     ax   vij   am   vij   bx i
    a   v    a   v    a i
hvij
m
x ij
m ij
    a   v    a   v    a i
hvij
x
x ij
m ij
 
 
 
hvij   am   vij   ax   vij   bm i
    a   v    b   v    a i
hvij
x
x ij
  ij
    b   v    b   v    a i
hvij
x ij
  ij
x
    a   v    b   v    a i
hvij
x ij
  ij
x
    b   v    b   v    a i
hvij
x ij
  ij
x
    a   v    a   v    b i
hvin
m
x in
m in
    a   v    b   v    a i
hvin
x in
  in
x
    b   v    b   v    a i
hvin
x
  in
x in
    a   v    b   v    a i
hvin
x
x in
  in
    b   v    b   v    a i
hvin
x
  in
x in
    b   v      v    i
hvkn
m e
e
    a   v      v    i
hvkn
x e
e

qualifier
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
xnj    ci
xnj   
  ci
xnj    ci
xnj   
  ci
m        
x   ci
x  
  ci
x   ci
x  
  ci
m        

    v     and v   i      k  and j      n  
table    operators for variables vij
e
ij

   

fichain causal graphs with domains of size  

our reduction for c n also uses another new idea  in the reduction for c  
n   information
was propagated forward  i e   variable vij changed its value according to the value of its
predecessor vi j     the reduction for c n   however  is constructed such that some information is propagated forward  in particular  the bits of the message  but other information
is propagated backwards  the index of the bit we are currently checking   the planning
problem is arranged such that a variable v may have several applicable operators  but only
one of them satisfies the pre condition of an applicable action for its successor v    the result
is that the value of v at time t     depends on the value of v  at time t 
we explain the planning problem p   f   in a bit more detail  due to the backward
propagation mechanism  the bits of the message are checked in reverse order  in other
words  vin now checks the first bit  vi n   checks the second bit  and vi  checks the n th
  is to check whether the  n  j      th bit satisfies the clause c  
bit  the purpose of vij
i
  is to inform v  
whereas the purpose of vij
that
the
 n

j
 
   th
bit
has
arrived 
i j  
  also keeps track of whether c has been satisfied after the first  n  j     
implicitly  vij
i
bits 
assume without loss of generality that the message is         let us see what happens
if the corresponding assignment does not satisfy the clause ci   upon arrival of the first bit 
  has to move to b   this requires v     a as a pre condition  which in
state variable vin
 
 
in
l   j      n     and l          to be in a   next  v   has
turn requires state variables vij
 
in
    b   in turn  this requires state
to move back to ax   which requires the pre condition vin
x
l   j      n     and l          to be in a   when v   moves again it is from b
variables vij
x
x
in
 
to a    requiring vi n     b  as a pre condition 
  is in b following the  nj    we see that  as long as the clause remains unsatisfied  vij
x
  is in b following the last bit  assume now that the
th bit  in particular  this means vi 
x
  moves from b to a   this requires v   to
 n  j      th bit satisfies clause ci   when vij
 
x
ij
 
move to ax instead of bx   from there  there is no way for vi j  
to be in bx following the
  will be in a following the last bit  satisfying the goal
 n  j      th bit  in particular  vi 
x
state 
    formal proof
the proof for c n is organized much in the same way as that for c  
n   note that variables
s            s n    vs   ve   e            e n  are the same as before  so lemmas     and     still apply
to p   f    it is easy to check that lemmas          and     also hold for p   f    however 
lemma     no longer holds  since several operators share the same preconditions  namely
operators     and          and          and       and      and       in spite of this  the
operators and sequences of values of an admissible plan  are completely determined by its
induced message m   just as for p    f    as shown in lemma       
lemma      let  be an admissible plan for p   f   and let m be its induced message  the
l   i      k   j      n   and l         
operators in  for changing the value of variable vij
l takes on during the execution of   are
as well as the sequence of values that variable vij
completely determined by m  
    and assume without loss of generality that its value is a  
proof  first consider variable v  
 
    namely      changing its value to
given  vs   x   there are two applicable operators for v  

   

figimenez   jonsson

ax   and      changing its value to bx   at first sight  an admissible plan  can choose either 
  in between each pair of
however  for  to be admissible  it has to change the value of v  
    note that when v     a   v   can have either of two values  namely
value changes for v  
 
  
  
  is a   the only admissible operator for v   is       which has
a  or b    if the value of v  
 
  
    a   thus  if  changes the value of v   to b it is no longer admissible 
pre condition v  
x
x
  
  is b   the correct choice depends on the
so it has to choose operator      if the value of v  
 
  is      with
cnf formula f   if xn satisfies clause c    the only admissible operator for v  
    a   so  should choose operator      otherwise  the only admissible
pre condition v  
x
 
    b   so  should choose operator      in
operator for v   is      with pre condition is v  
x
   
 
either case  the operator choice for v   is forced given the value of v  
    i      k   v     i      k  and j      k  
the same reasoning applies to variables vi 
ij
    i      k  and j      n      and the corresponding operators that share the same
and vij
pre conditions  the only degree of freedom of an admissible plan is selecting its induced
message m by choosing the operators for vs accordingly  the remaining operator choices
and  consequently  sequences of values are completely determined by the induced message
m  
we now prove a lemma similar to lemma       establishing the sequence of values taken
on by state variables in p   f   during the execution of an admissible plan 
definition      let  be an admissible plan for p   f    for each clause ci and each
t       n       let the sequence of values qti    be the vector of  n elements representing 
l   j      n  and l          the t th value taken on by variable v l during
for each variable vij
ij
l    we define the diagonal value
the execution of   let us denote this value by qt    vij
 
qji     for i      k  and j      n   as the value q j      vi nj   
  
lemma      let  be an assignment to variables x            xn of formula f  
   existence  there exists an admissible plan  of planning problem p   f   with induced
assignment     
   claim  let qji be as described in part    of this lemma  all admissible plans  with
    have the same diagonal values qji      qji for each i      k  and j      n  
   diagonal values  the diagonal values qji   for i      k  and j      n   are as
follows 
a  if j   ti   then qji   bx  
b  if j  ti   then qji   ax  
proof  note that  according to lemma      not only the diagonal values qji     but also the
full sequences of values qti     are completely determined for an admissible plan   we
have to prove  then  that admissible plans exist for any assignment   as claimed in part   
and that the diagonal values match the expression given in part    we prove these two facts
by doing a careful  general analysis of the planning problem p   f    and then explaining
how this analysis implies the lemma  incidentally  the sequences of values qti    can also
   

fichain causal graphs with domains of size  

be obtained from our analysis  we do not study them because they are not important for
our purposes 
l be some variable of p  f    clearly  the
let  be an admissible plan  and let v   vij
 
t
subscript of the t th value q    v  that v takes on depends on the parity of t  since all
operators affecting v change its subscript from x to m          and from there back to x 
namely  the subscript of qt    v  is x if t    p     and m if t    p  where m is the p th
bit of the message m  
  
now  for some j      n     and i      k   consider the t th values that variables vij
    v 
vij
i j    take on  for t    p      p   p      the previous observation on the subscripts
implies that we  trivially  know something about these values 
    qt    v     qt    v  
qt    vij
ij
i j     
t    p     ax   bx  
ax
 ax   bx  
t    p
am
 am   bm  
am
t    p      ax   bx  
ax
 ax   bx  
 
  affects the other values on the diagonal 
we study how the value q p     vi j   
 p 
 
 p  
 
 p
 
   vi j   
    ax   then we can check there
   vij    if q
namely q    vij   and q
is only one possible outcome 
 
  
  
rule i
 
qt    vi j   
qt    vij
qt    vij
t    p     ax   bx  
ax
ax
t    p
am
am
    
am
   
t    p    
ax
   
ax
    
 ax   bx  

that is  a value of type ax is propagated along the diagonal to another value ax   we
call this propagation rule i 
 
    bx   in this
now we study which are the possible outcomes when q p     vi j   
 p
 
 p  
 
case  the other values q    vij   and q
   vij   on the diagonal depend on whether
the p th bit m of the message m is such that clause ci is satisfied by xnj     m  c f 
operators          and          in table     if ci is satisfied by xnj     m  it follows
that these values must be bm and ax   this is propagation rule ii 
  
  
 
rule ii
qt    vij
qt    vij
qt    vi j   
 
t    p     ax   bx  
ax
bx
am
bm
    
am
   
t    p
t    p    
ax
   
ax
        
 ax   bx  

on the contrary  if clause ci is not satisfied  then these values must be bm and bx   we
call this propagation rule iii 
 
  
  
rule iii qt    vij
qt    vi j   
 
qt    vij
t    p     ax   bx  
ax
bx
t    p
am
bm
    
am
   
t    p    
bx
    
ax
        
 ax   bx  

   

figimenez   jonsson

finally  let us consider the cases j     and j   n  which have not been treated in the
  do not have values of type a   also note that
previous analysis  note that variables vin
m
  cannot take on value b at time t    n      for then it cannot change further 
variables vi 
x
since the pre conditions of operators         if i      or         if i      k   are not
    b   thus  the only possible outcome for these two variables when
compatible with vi 
x
p   n is the following 
 
   
   
 
qt    v i    
qt    vin
qt    vin
t    p     ax   bx  
ax
ax
t    p
am
bm
    
am
   
ax
                
ax
   
t    p      ax   bx          
 
  can be either ax or bx   using operators
note that  when p   n  the value q p      v i    
    where
    and      the reader can check that a similar analysis applies to variable v  
operators        take the role of operators        
let us summarize the previous analysis in the following table 

t  
t  
t  
t  
  
 

 
 
 
vi 
vi 
vi 

ax ax ax   
am
ax
am
  
 

t    n    am
t    n    ax
t    n
am
t    n     





  v 
 
 
vin
vi n  
vi n  
in
ax
ax ax ax
bm
ax
bm
  
 



bm
ax
bm
 ax

the first row in the previous table contains the initial state of the planning problem  all
variables are set to ax   the leftmost column and the rightmost column contain the values
  and v     then  the values b of the right column are propagated
taken on by variables vi 
m
in
along the diagonals using the three propagation rules already discussed  a value of type a
yields more values of type a according to rule i  a value of type b yields a value of type
a if the clause is satisfied by rule ii  and of type b if it is not satisfied  by rule iii  the
same applies when propagating the values of the first row  since they are all of type a  all
values of the top left triangle are of type a  according to rule i  note also that the longest
diagonal coincides with the diagonal values qji of definition     
after this discussion we proceed to prove the lemma  let  be an assignment of formula
f   the existence of a plan  with     is implied from the analysis already done on the
l    since we have shown which operators can be used in each case to produce
values qt  vij
the actual changes of value 
    
finally  consider the diagonal values qji    for j              n  that is  the values q     vin
 
 
 n  
 
q    vi n             q
   vi     let j   ti as in case  a   that is  the first j bits of the
message m   when assigned to variables x            xj   do not satisfy clause ci   consequently 
i
 j      v  
     q i   q     v  
the diagonal values q i   q     vin
 
i n  j    must
i n             qj   q
   

fichain causal graphs with domains of size  

all be bx   according to rule iii  on the contrary  if we assume j  ti as in case  b   then
it follows that qpi   bx for p   ti due to rule iii  that qpi   ax for p   ti due to rule ii 
and that qpi   ax for j  p   ti due to rule i 
theorem      there exists a valid plan for solving the planning problem p   f   if and only
if there exists an assignment  that satisfies the cnf formula f  
proof    by lemma      the existence of an assignment  that satisfies f implies that all
admissible plans  with     satisfy qji      qji   since ti  n for all i      k   it follows
that qni   ax   as required by the goal state of p   f    the plan  thus solves p   f   
  let  be a plan solving the planning problem p   f    since lemma     holds
for p   f    the plan  is admissible  we show by contradiction that     satisfies f  
assume not  then there exists a clause ci not satisfied by   thus  lemma     implies that
  following the execution of  is b  
qji      bx for all j      n   in particular  the value of vi 
x
   a  
this contradicts  solving p   f    since bx is different from the goal state goal vi 
x
proposition      plan existence for c n is np hard 
proof  the largest variable domains of the planning problem p   f   are those of variables
    i      k  and j      n      which contain   values  the proof follows immediately
vij
from the np hardness of cnf sat  theorem      and the fact that we can produce the
planning problem p   f   in polynomial time given the cnf formula f  

   discussion
in this paper  we have shown that the problem of determining whether a solution plan exists
for planning problems in the class ckn is np hard whenever k     in contrast  brafman
and domshlak        developed a polynomial time algorithm for generating plans that solve
planning problems in the class c n   what can be said about the intermediate cases  namely
ckn for k          in what follows  we sketch some arguments for and against tractability
of these cases  although the discussion is mostly based on intuition gained from studying
these classes  it might prove helpful for someone trying to determine their complexity 
on one hand  it seems likely to us that plan existence for c n is also np hard  our
reduction for c n only uses one type of state variable whose domain is larger than    namely
    finding a reduction for c  seems possible  although it will likely be difficult since the
vij
n
available options become increasingly restricted as the state variable domains get smaller 
in particular  we tried but failed to find a reduction for c n  
domshlak and dinitz        showed that there exist planning problems in c n with
exponential length minimal solutions  although this often indicates that a planning class
is difficult  it does not imply that plan existence is intractable  this is exemplified by
jonsson and backstrom        who define a class of planning problems with exponential
length minimal solutions but where plan existence could be checked in polynomial time 
the present authors  gimenez   jonsson      a  showed that even plan generation for
this particular class could be done in polynomial time  if the resulting plans are given in a
compact format such as macros 
a second argument in favor of the hardness of c n is that there may be multiple ways
to transition between two values of a variable  for example  consider a planning problem
   

figimenez   jonsson

such that there are two actions for changing the value of a variable v from   to    namely
a   hv       v      v    i and a   hv       v      v    i  since variables can have   values 
it is possible that neither v      nor v      hold in the current state  a planner would
thus have to choose whether to satisfy v      or v       in contrast  for c n the same two
actions could be replaced by a single action hv      v    i since one of a and a is always
applicable  as a consequence  even if the minimal plan length is bounded for a planning
problem in c n   there may be exponentially many plans of that length  in fact  this is the
main idea behind our reductions  
another observation regards the number of possible domain transition graphs for each
state variable  for each k     it is possible to show that a state variable in ckn may have
 
 k  k   distinct domain transition graphs  in other words  the number of graphs grows
exponentially in k  in particular  while state variables in c n can only have         distinct
graphs  the same number for c n is       although a large number of possibilities does not
guarantee hardness  it is clear that the expressive power of c n is much higher than that of
c n  
the evidence provided above suggests that c n is significantly harder than c n   however 
we are not sure that c n is hard enough to be intractable  state variables with just three
values do not lend themselves well to the type of reduction we have presented  since just
propagating the message requires three values  if there is such a reduction for c n   the idea
underlying it may not be the message passing mechanism we have exploited  on the other
hand  maybe there is some way to determine plan existence of c n in polynomial time  such
an algorithm would take into consideration the multiple  but finite  combinations of domain
transition graphs of three values  as well as any inherent structure of the graphs  we know
that the expressive power of domain transition graphs of   values is just too large to handle
in polynomial time  maybe this is not the case when using just   values 

acknowledgments
this work was partially funded by apidis and mec grant tin           c      

appendix a  c n is np hard
in this appendix  we describe how to modify the reduction for c  
n so that the resulting
planning problem  which we call p   f    only needs variable domains of size    this reduction previously appeared in a conference paper  gimenez   jonsson      b   but without
proof  the main idea of the reduction is the same  but the construction used to check
if the assignment  satisfies a clause ci is more involved  previously  we used n variables  vij  j       n  whose role was  essentially  to check whether the j th bit   xj   of the
propagated message satisfies ci   in the modified reduction  each variable vij is replaced
    v     and v     that collectively play the same role  the variables
by three variables vij
ij
ij
s            s n    vs   ve   e            e n    as well as their domains and corresponding operators  are
   
the same as before  except the predecessor of ve is now vkn
      d v        a   a   a   b   b   b   g   and
the domains of these new variables are d vij
x     x     x
ij
 
d vij      gx   g    g    ax   a    a    bx   for each i      k   j      n   the initial state on these
      init v       init v       a   i      k  and j      n   and the goal
variables is init vij
x
ij
ij
   

fichain causal graphs with domains of size  

variable
 
v  

  
vi 
i      k 

  
vij
i      k  
j      n 

ref 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    

operator
    a   v    g i
hvs      v  
x
x   
    a   v    b i
hvs      v  
x   
 
    a   v    g i
hvs      v  
x
x   
    a   v    b i
hvs      v  
x   
 
    g   v    b i
hvs   m  v  
x   
m
    b   v    b i
hvs   m  v  
x   
m
    b   v    b i
hvs   x  v  
m   
x
 
    a   v    g i
hv i  n
  a    b     vi 
x
x i 
    a   v    b i
 
  a    b     vi 
hv i  n
x i 
 
 
 
 
hv i  n   a    b     vi    ax   vi    gx i
 
    a   v    b i
hv i  n
  a    b     vi 
x i 
 
 
    g   v    b i
hv i  n
  am   bm    vi 
x i 
m
 
    b   v    b i
hv i  n
  am   bm    vi 
x i 
m
 
 
 
hv i  n   ax   bx    vi    bm   vi    bx i
 
    a   v    g i
hvi j  
  b    vij
x ij
x
 
 
 
hvi j     b    vij   ax   vij   b  i
 
    a   v    g i
hvi j  
  b    vij
x ij
x
    a   v    b i
 
  b    vij
hvi j  
x ij
 
 
    a   v    g i
hvi j  
  gx   vij
x ij
x
 
 
 
hvi j     am   vij   ax   vij   am i
 
    g   v    b i
hvi j  
  bm   vij
m
x ij
 
    b   v    b i
hvi j     bm   vij
x ij
m
 
    a   v    a i
hvi j  
  ax   bx    vij
x
m ij
    b   v    b i
 
  bx   vij
hvi j  
m ij
x

qualifier
x   c 
x  
  c 
x   c 
x  
  c 
m        
m        
m        
x   ci
x  
  ci
x   ci
x  
  ci
m        
m        
m        
xj  ci
xj 
  ci
xj  ci
xj 
  ci
m        
m        
m        
m        
m        

    i      k  and j      n  
table    operators for variables vij

      g   i      k   table   shows the operators for variables v     i      k 
state is goal vin
x
ij
  and v     i      k  and
and j      n   and table   shows the operators for variables vij
ij
j      n   figures   and   shows the corresponding domain transition graphs  table   also
shows the new operators for variable ve   which have different pre conditions now that the
   
predecessor of ve is vkn

a   intuition
the intuition behind the reduction for c n is largely the same as that for c  
n   the planning
problem p   f   corresponding to a cnf formula f consists of three parts  the first and
third being identical to those of p    f    thus  the difference lies in the second part  recall
that in the reduction for c  
n   for each clause ci and each variable xj of f   the planning
problem p    f   contains a state variable vij that performs the following functions 
   propagate the message m generated by vs  
   

figimenez   jonsson

variable
  
vij
i      k  
j      n 

ref 
    
    
    
    
    
    
    
    
    
    
    
    
    
    

  
vij
i      k  
j      n 

ve

operator
    a   b    v     a   v     a i
hvij
m m
x ij
m
ij
    g   v    a   v    g i
hvij
x
x ij
x ij
    b   v    g   v    g i
hvij
m ij
x ij
m
    b   v    b   v    a i
hvij
m
x ij
m ij
    a   v    a   v    a i
hvij
x ij
m ij
x
    b   v    a   v    b i
hvij
x
m ij
x ij
    b   v    g   v    g i
hvij
x ij
m ij
x
    a   v    a   v    a i
hvij
m ij
x ij
m
    g   v    a   v    g i
hvij
x
x ij
x ij
    g   v    g   v    b i
hvij
m ij
x ij
m
    a   g    v     b   v     b i
hvij
m
x ij
m m
ij
    a   v    a   v    a i
hvij
x ij
m ij
x
 
 
 
hvij   bx   vij   am   vij   bx i
    b   g    v     b   v     b i
hvij
x
x x
m ij
ij
 
hvkn   a    a    b    b     ve      ve    i
    a   b    v      v    i
hvkn
x x
e
e

qualifier
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        
m        

    v     and v   i      k  and j      n  
table    operators for variables vij
e
ij

 a 

 b 

 c 

b 

b 

a 

 
ax

 

 
bx

gx
 

x

ax
 

 

a 
a  b  b 

a  b 

x

gx

a   b 

a   b 

ax
bx

b 

bx

ax

gx

a 
b 

ax
bx

b 
ax bx

b 

b 
ax bx

a 

b 

b 

b 

bx
bx

gx
b 

bx

b 

a 
a 

b 

     b  v   for i      k    c  v   for i      k   j      n  
figure    dtgs of  a  v  
ij
i 

   check whether the assignment to xj  the j th bit of m  satisfies the clause ci  
   remember whether ci was satisfied by the assignment to some xl   l  j 
   if j   n and ci has been satisfied  propagate this fact 
   if j   n  let vi j    know when the  j      th bit of the message has arrived 
the first and fourth function is to propagate information and thus has to be performed
by all state variables if information is not to be lost  however  the other functions can be
performed by different state variables  the idea behind the reduction for c n is to split vij
    that performs the second function  v     that performs the third 
into three variables  vij
ij
 
and vij   that performs the fifth 
   

fichain causal graphs with domains of size  

 a 

 b 
a 

g 
b 

a 
bx

bx
a  b 
gx

gx

g 

b 

ax

bx

ax
a  b 

b 

bx

ax

a 

a 

ax

b 

bx

g 
a  g 

ax

bx

gx

bx gx
bx

gx
bx gx

ax

b 

a 
a 

bx

a  g 

g 
b 

  and  b  v   for i      k   j      n  
figure    dtgs of  a  vij
ij

just as before  the message m is propagated using the subscripts of values in the domains
  moves
of state variables  when the j th bit mj of the message arrives  state variable vij
  moves
from ax to gx if the assignment  xj     mj satisfies ci   and to bmj otherwise  if vij
to gx   it is forced to move to bmj next  forgetting that ci was satisfied  however  while the
  is g   all subsequent state variables for c can also move to g   propagating the
value of vij
x
i
x
  is able to remember that
fact that ci has been satisfied  consequently  state variable vin
ci has been satisfied by remaining within the subdomain  g    g    gx   
  moves to b   causing v   and v   to move to a  
if  xj     mj does not satisfy ci   vij
mj
mj
ij
ij
 
 
 
 
from there  vij   vij   and vij all move to bx   when the next bit arrives  vij moves to b   b    
  to move to a  a   and v   to b  b    this indicates to v  
causing vij
 
 
 
 
ij
i j    that the  j      th
bit has arrived  causing it to act accordingly  just as before  the operators are defined such
  always reacts to the first bit for each clause c  
that vi 
i
a   formal proof
since variables s            s n    vs   ve   e            e n  are the same as before  lemmas     and
    both apply to p   f    however  lemma     is violated since it is sometimes possible
to change the value of a variable twice without changing the value of its predecessor  e g 
using operators     and       consequently  lemma      which states that all plans that
solve p    f   are admissible  no longer holds for p   f   
l   for variables in the middle of
to prove equivalent lemmas for p   f    we redefine  vij
the causal graph 
l   i      k   j      n   and
definition a    given a partial plan  and variable vij
l   be the number of subscript changes of v l during the execution of  
l             let  vij
ij
l   i      k   j      n   and
lemma a    for each partial plan  for p   f   and each vij
l     v     where v  is the predecessor of v l in the causal
l             it holds that  vij
ij
graph 
l   each operator that
proof  follows immediately from inspection of the operators for vij
l
changes the subscript of vij to z         x  has a pre condition on v  with subscript z  or
  and its predecessor v    there are operators for changing the value
value z in the case of v  
s
  to g that have a pre condition on v  with a subscript  or value  different from x  but
of vij
x
  since their pre condition on v   is a  
these operators do not change the subscript of vij
x
ij

   

figimenez   jonsson

    
lemma a    for each partial plan  for p   f     ve     vkn
    denotes
proof  note that  ve   still denotes the number of value changes of ve   while  vkn
    each time we change the value of v we need to
the number of subscript changes of vkn
e
 
change the subscript of vkn in between  in addition  the first value change of ve requires a
  different from that in the initial state  thus   v     v     
subscript for vkn
e
kn

definition a    an admissible plan  for planning problem p   f   is a partial plan such
               v        v      n  and  e      n  i  for each
that  si     i   vs      v  
e
i
kn
i       n     
lemma a    any plan  that solves the planning problem p   f   is admissible 
          v       v    we
proof  by lemmas a   and a   we have that  vs     v  
e
kn
can now use lemmas     and     and apply the same reasoning as in the proof of lemma
    
l exactly  n
in other words  an admissible plan has to change the subscript of each vij
l an extra time by moving through g   however 
times  although it can change the value of vij
x
l    we cannot prove an equivalent of lemma      for
even with the new definition of  vij
l   l          can choose not to follow its predecessor to g without
p   f    since a variable vij
x
making the plan inadmissible  consequently  the sequences of values qti    of an admissible
plan  are no longer completely determined by the induced message m   nevertheless  we
can still prove a lemma similar to lemma      

definition a    let  be an admissible plan  for each clause ci and each t       n      
let the sequence of values qti    be the vector of  n elements representing  for each variable
l   j      n  and l             the first value following the  t     th subscript change of
vij
l during the execution of  
vij
lemma a    let  be an assignment of variables x            xn of formula f  
   existence  there exists an admissible plan  of planning problem p   f   with induced
assignment     
   claim  let qti be the sequences of values described in part    of this lemma  if 
satisfies f   then there exists an admissible plan  with     such that qti      qti  
for all t       n    and i      k   if  does not satisfy clause ci   then all admissible
plans  with     have qti      qti   for all t       k      
   sequence of values  the sequence of values qti   for i      k  and t       n      
is as follows 
a  if j   ti   then
j 

qi j 
q j
i
q j  
i

nj
  
 
z
z
  
 
bx bx bx    bx bx bx
ax ax ax
ax ax ax    ax ax ax
 
  bm am bm    bm am bm bm am am am am am    am am am
 
bx bx bx    bx bx bx
bx bx bx
ax ax ax    ax ax ax

   

fichain causal graphs with domains of size  

b  if j   ti   then
j 

qi j 
q j
i
 j  
qi

nj
z
  
 
z
  
 
 
bx bx bx    bx bx bx
ax ax ax
ax ax ax    ax ax ax
  bm am bm    bm am bm bm gm bm bm gm bm    bm gm bm
 
bx bx bx    bx bx bx
bx gx bx
bx gx bx    bx gx bx

c  if j   ti   then
jti

ti  

qi j 
q j
i
 j  
qi

nj

z
z
  
 
  
 
  
 
z
bx gx bx    bx gx bx bx gx bx bx gx bx    bx gx bx
  bx bx bx    bx bx bx
  bm am bm    bm am bm bm gm bm    bm gm bm bm gm bm bm gm bm    bm gm bm
  bx bx bx    bx bx bx
bx gx bx    bx gx bx bx gx bx bx gx bx    bx gx bx

proof  note the similarity of this lemma with lemma       as before  we must show that
there are operators  this time in tables   and    whose post conditions equal the values
 j  
given by qi j    q j
  again  we must check for consistency in the statements
i and qi
 j    
 j 

with j   j     this implies  as in lemma       that the statements
and qi
of qi
for qi j  are valid  due to the initial state being ax    ax and by induction on j  it just
 j  
remains to show that the statements for q j
are also valid 
i and qi
the proof is divided into the same six parts as that of lemma       note that  in
contrast to that lemma  here we aim to show that  when  satisfies f   there exists an
admissible plan with given qti   not that all admissible plans have this form  this is because
sometimes during the execution of the plan more than one operator could have been chosen 
and the resulting plan would still be admissible  in the tables that follow  which are alike
to those in the proof of lemma       we only indicate the operator choice that leads to the
desired qti   and we use boldface to remark that these operators are not forced  we add
an extra row to the tables to indicate that sometimes we need to apply two operators for
each variable before changing its subscript  these disparities with respect to lemma     
only occur in parts ii and iv of the proof  which require ti  n  that is   satisfying clause
ci   for some fixed i  thus  when  does not satisfy clause ci   all admissible plans  have
the same sequences of values qti for each t       n      
i      j   ti  
  v  v 
  v   v    k      n 
vi 
vik
i  i 
ik ik
 j    ax ax ax
ax ax ax
 j
bm am am                am am am             
ax ax ax             
 j     bx bx bx            

ii      j   ti  
  v  v 
  v   v    k      n 
vi 
vik
i  i 
ik ik
 j    ax ax ax
ax ax ax
gx gx gx               
gx gx gx             
 j
bm gm bm            
bm gm bm             
bx gx bx            
bx gx bx             
 j    

   

figimenez   jonsson

iii      j   ti  
  v   v    k      j     v   v   v  
  v   v    k   j      n 
vik
vik
ij ij ij
ik ik
ik ik
 j   
b x bx bx
ax ax ax
ax ax ax
 j
bm am bm                 bm am am                 am am am             
bx bx bx                
bx bx bx             
ax ax ax             
 j    

iv      j   ti  
  v   v    k      j     v   v   v  
  v   v    k   j      n 
vik
vik
ij ij ij
ik ik
ik ik
 j   
b x bx bx
ax ax ax
ax ax ax
bm am bm                 gx gx gx                
gx gx gx             
 j
bm am bm
bm gm bm             
bm gm bm             
 j    
bx bx bx                
bx gx bx             
bx gx bx             

v      ti   j 
  v   v    k      n 
  v  v 
vik
vi 
i  i 
ik ik
 j   
bx gx bx
bx gx bx
 j
bm gm bm             bm gm bm             
 j    
bx gx bx            
bx gx bx             

vi      ti   j 
  v   v    k      t     v   v   v    k   t   n 
vik
i
i
ik ik
ik ik ik
 j   
bx bx bx
bx gx bx
 j
bm am bm                
bm gm bm             
 j    
bx bx bx                
bx gx bx             

theorem a    there exists a plan that solves the planning problem p   f   if and only if
there exists an assignment  that satisfies the cnf formula f  
proof    given an assignment  that satisfies f   construct an admissible plan whose
induced formula assignment  equals   by choosing the sequence of values of vs accordingly  it follows that for each clause ci   ti  n  since there exists a variable xj such that
  xj     mj satisfies ci   since n  ti   there exists an admissible plan  for which qi n  
has the form indicated in case  b  or  c  of lemma a    in either case  the   n      th
  is g   as required by the goal state  the plan  thus solves p  f   
value of variable vin
x
 
  let  be a plan that solves the planning problem p   f    by lemma a   the plan
 is admissible  we show by contradiction that     satisfies f   assume not  then
there exists a clause ci not satisfied by   thus  lemma a   applies to the sequence of
  following the execution
values q n  
of   in particular  this means that the value of vin
i
of  is bx according to case  a  of the lemma  this contradicts  solving p   f    since bx
    g  
is different from the goal state goal vin
x
proposition a    plan existence for c n is np hard 
   

fichain causal graphs with domains of size  

proof  the largest variable domains of the planning problem p   f   are those of variables
            v     which contain   values  the proof follows immediately from the np hardness
v  
kn
of cnf sat  theorem a    and the fact that we can produce the planning problem p   f  
in polynomial time given a cnf formula f  

references
brafman  r     domshlak  c          structure and complexity in planning with unary
operators  journal of artificial intelligence research             
brafman  r     domshlak  c          factored planning  how  when  and when not  in
proceedings of the   st national conference on artificial intelligence  pp         
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence             
chapman  d          planning for conjunctive goals  artificial intelligence                
chen  h     gimenez  o          causal graphs and structurally restricted planning  in
proceedings of the   th international conference on automated planning and scheduling  pp       
domshlak  c     dinitz  y          multi agent off line coordination  structure and complexity  in proceedings of the  th european conference on planning  pp         
erol  k   nau  d     subrahmanian  v          complexity  decidability and undecidability
results for domain independent planning  artificial intelligence                
gimenez  o     jonsson  a       a   the complexity of planning problems with simple
causal graphs  journal of artificial intelligence research             
gimenez  o     jonsson  a       b   in search of the tractability boundary of planning
problems  in proceedings of the   th international conference on automated planning
and scheduling  pp        
helmert  m          the fast downward planning system  journal of artificial intelligence
research             
jonsson  a          the role of macros in tractable planning over causal graphs  in
proceedings of the   th international joint conference on artificial intelligence  pp 
         
jonsson  p     backstrom  c          tractable plan existence does not imply tractable
plan generation  annals of mathematics and artificial intelligence                 
katz  m     domshlak  c       a   new islands of tractability of cost optimal planning 
journal of artificial intelligence research             
katz  m     domshlak  c       b   structural patterns heuristics via fork decompositions  in proceedings of the   th international conference on automated planning
and scheduling  pp         
knoblock  c          automatically generating abstractions for planning  artificial intelligence                
   

figimenez   jonsson

williams  b     nayak  p          a reactive planner for a model based executive  in
proceedings of the   th international joint conference on artificial intelligence  pp 
         

   

fi