journal artificial intelligence research                  

submitted        published      

planning chain causal graphs variables
domains size   np hard
omer gimenez

omer gimenez upc edu

dept  de llenguatges sistemes informatics
universitat politecnica de catalunya
jordi girona     
      barcelona  spain

anders jonsson

anders jonsson upf edu

dept  information communication technologies
universitat pompeu fabra
roc boronat     
      barcelona  spain

abstract
recently  considerable focus given problem determining boundary
tractable intractable planning problems  paper  study complexity planning class cn planning problems  characterized unary operators
directed path causal graphs  although one simplest forms causal graphs
planning problem have  show planning intractable cn  unless p   np  
even domains state variables bounded size  particular  show plan
existence ckn np hard k   reduction cnf sat  here  k denotes
upper bound size state variable domains  result reduces complexity
gap class ckn cases k     k     only  since c n known tractable 

   introduction
ongoing effort planning community determine complexity different classes planning problems  known tractable classes usually characterized
simple causal graph structure accompanied additional restrictions variables
operators  however  boundary tractable intractable planning problems
still clearly established  present paper contributes novel complexity result
class planning problems simple causal graph structure literature 
effort reduce complexity gap 
problem determining tractable classes planning problems purely theoretical interest  instance  complex planning problems projected onto tractable
fragments planning problems generate heuristics used search  katz  
domshlak      b   also  causal graph heuristic  helmert        exploits hierarchical structure planning problem transforming tractable form  first 
translates propositional variables multi valued variables  process simplifies
causal graph problem  then  keeps relaxing problem causal graph
becomes acyclic 
present paper aims study complexity planning problems class cn  
defined domshlak dinitz         class cn contains planning problems
c
    
ai access foundation  rights reserved 

figimenez   jonsson

ckn
k  
k       
k 

plan generation
p
exp
exp

macro plan generation
p
 
intractable

plan existence
p
 
np hard

table    overview complexity results class ckn  

multi valued variables chain causal graphs  i e   causal graph directed path
 implying operators unary   notation n indicates number state
variables unbounded  particular  study complexity plan existence cn  
i e   determining whether exists plan solves planning problem cn  
even though planning problems cn exhibit extremely basic form causal structure  i e   linear dependence state variables  solving planning problems cn
necessarily tractable  even impose additional restrictions  let ckn subclass
cn state variables domains size k  known class c n
polynomial time solvable  brafman   domshlak        plan existence class
cn np hard  gimenez   jonsson      a   aim study complexity plan
existence classes between  namely ckn k   
domshlak dinitz        showed solvable instances c n require
exponentially long plans  means polynomial time plan generation
algorithm ckn k    case c n   however  rule
existence polynomial time algorithm determines plan existence class ckn  
even algorithm generates plans succinct form  jonsson       
gimenez jonsson      a   incompatible cn np hard 
paper  prove plan existence class ckn np hard k   
words  even causal graph directed path domains state
variables restricted contain   values  deciding whether plan
exists solving corresponding planning problem np hard  result implies
sufficient planning problem exhibit linear variable dependence restricted
variable domain sizes  additional restrictions necessary make planning tractable 
table   shows overview complexity results class ckn date 
macro plan generation mean algorithm generating compact representation
solution  work jonsson        gimenez jonsson      a  
intractable result column means complexity yet unknown
cannot p unless p   np  else plan existence would p   row k     due
brafman domshlak         column plan generation due domshlak
dinitz         contributions present paper marked boldface  note
novel result subsumes gimenez jonsson      a   showed np hardness
k   o n  
paper organized follows  section   relate results previous work 
section   introduce notation used throughout  section   give formal
proof reduction cnf sat planning problems c  
n   main result 
 
reduction cnf sat planning problems cn   proved section    although
  
result c n subsumes c  
n   believe intuitive idea behind cn
   

fichain causal graphs domains size  

reduction easier understand  may interest anyone trying prove hardness
results similar circumstances  section   discuss complexity remaining
classes c n c n  
prove correctness third reduction  time cnf sat c n  
 
appendix a  reductions c  
n cn previously appeared conference paper
 gimenez   jonsson      b   present paper provides formal proof correctness 

   related work
complexity planning studied extensively last twenty years  bylander        chapman        erol  nau    subrahmanian         many tractable classes
planning problems exploit notion causal graph one way another  knoblock
       usually credited introducing causal graph work hierarchical
planning  williams nayak        required planning problems acyclic causal
graphs effort ensure tractability  jonsson backstrom        defined class
 s planning problems  acyclic causal graphs  showed plan existence
tractable class 
domshlak dinitz        introduced class cn planning problems studied
paper  well several related classes  particular causal graph
structure  brafman domshlak        designed polynomial time algorithm solving planning problems binary state variables polytree causal graphs bounded
indegree  proving planning tractable class c n   brafman domshlak
       presented complexity results related tree width causal graph  katz
domshlak      a  used causal graph structure prove several complexity results
optimal planning 
jonsson        gimenez jonsson      a  designed polynomial time algorithms
solve planning problems restricted causal graphs generating hierarchy
macros  recently  chen gimenez        showed complexity planning
intractable unless size largest connected component causal graph bounded
constant  consequently  causal graph structure alone enough guarantee
tractability  implying additional restrictions needed 

   notation
throughout paper  use  i  n  denote set  i          n  
let v set state variables  let d v  finite domain state variable
v v   define state function v maps state variable v v
value s v  d v  domain  partial state p function subset vp v
state variables maps state variable v vp p v  d v   frequently use
notation  v    x            vk   xk   denote partial state p defined vp    v            vk  
p vi     xi vi vp  
planning problem tuple p   hv  init  goal  ai  v set variables  init
initial state  goal partial goal state  set operators  operator
  hpre a   post a i consists partial state pre a  called pre condition
   

figimenez   jonsson

v 

v 

v 

v 

v 

figure    example causal graph planning problem class ck   
partial state post a  called post condition  operator applicable state
s v    pre a  v  v vpre a    applying operator state results
new state  v    post a  v  v vpost a   v    s v  otherwise 
partial plan planning problem p sequence operators a            ak ak  
k    a  applicable initial state init and      k   ai
applicable following application a            ai  starting init  note partial plan
necessarily solve p   plan solving p partial plan goal
state goal satisfied following application a            ak   p solvable
exists plan  
causal graph planning problem p directed graph  v  e  state
variables nodes  edge  u  v  e u    v exists
operator u vpre a  vpost a  v vpost a    figure   shows example
causal graph form directed path  structure causal graph implies
operator unary  i e   post condition specified single variable
v  pre condition specified  at most  v predecessor v causal
graph 
paper study class ckn planning problems  defined follows 
definition      planning problem p belongs class ckn causal
graph p directed path and  v v    d v   k 
planning problems ckn   domain transition graph  dtg  state variable
v labelled  directed graph  d v   e   values domain v nodes 
edge  x  y  e label l d v   exists operator
hv   l  v   x  v   yi a  v predecessor v causal graph  edge
without label indicates pre condition corresponding operator defined v
alone  edge one label indicates existence multiple operators
pre  post condition v different pre conditions v  

   c  
n np hard
section prove c  
n np hard reduction cnf sat  words 
every cnf formula f associate planning instance p    f   c  
n p    f  
solvable f satisfiable  first describe planning problem p    f   
explain intuitive idea behind reduction  finally provide formal proof
correctness 
let f   c  ck cnf formula k clauses n variables x            xn  
define planning problem p    f      v  init  goal  a  follows  variable set v
 si        n      vs    vij       k   j     n    ve    ei        n     
domains d si     d ei     d ve                 n     d vs            x  
d vij      gx   g    g    ax   a    a    b    b    cx   c    c        k   j     n   initial state
defined init si     init ei     init ve             n     init vs     x  init vij     ax
   

fichain causal graphs domains size  

s 

s n 

vs

v n

v  

vk 

vkn



e 

e n 

figure    causal graph planning problem p    f   
 
 
 

 

 
 

 

 
 

 

x
 
 

   

 
 

figure    dtgs variables s    s            s n    vs  
    k   j     n   goal state partial state defined goal vin     gx
    k   goal ve        goal ei      i mod         n    
providing formal definition operators a  give intuitive overview
planning problem p    f    this  present causal graph p    f   well
dtgs state variable  reader interested formal proof
correctness reduction may skip section      introduce formal
definitions operators order prove several theoretical properties p    f   
    intuition
planning problem p    f   associated cnf formula f consists three parts 
clearly defined role  three parts illustrated figure    showing causal
graph p    f    first part p    f   corresponds state variables s            s n    vs  
second part corresponds state variables v             v n           vk            vkn   third
part corresponds state variables   e            e n    role first part generate
message corresponding assignment variables cnf formula f  
role second part verify whether assignment satisfies clause ci  
remember fact  using value state variable vin    finally  role third part
make sure message propagated way end chain 
dtgs state variables s            s n    vs appear figure    state variables
used generate assignment variables x            xn cnf formula f  
this  operators p    f   defined way value vs change
x either          change back x  thus  applying
operators p    f   possible generate sequence x  m    x          x  mn   x values
vs   mj        j     n  
define message sequence m            mn n symbols  either      corresponding sequence values vs   follows  refer symbols
bits message  value x used separator distinguish consecutive
bits message  given message m  assignment defined  xj     mj
j     n   thus  assignment x  determined first choice whether
change value vs x      on  purpose remaining state
variables si first part restrict message contain n bits 
   

figimenez   jonsson

 a 

 b 
a 

g 

a 

g 

c 

b 

c 

b 
a  b  g 

 

 

x
 

gx
 

ax

 

x
cx

x

gx
a  b  g 

 

x

ax cx gx

a  b  g 

x

ax cx gx

ax
ax cx gx

a  b  g 

ax cx gx

a  b  g 

ax cx gx

cx

x
a  b  g 

g 

a 

c 

b 

g 

a 

b 

ax cx gx
c 

 c 
a 

g 
a  b 
c  g 

cx gx g
 
gx

c  g 

cx gx g 

ax

a  b 
g 

c 

b 
ax cx

c 

c 

cx

c 

cx

ax cx
a 

cx

cx

c 
b 

cx
c 

figure    dtgs  a  v      b  vi        c  vij j      dashed edges
explained text 

dtgs state variables vij       k  j     n   appear figure   
dashed edges dtgs indicate corresponding operators depend cnf
formula f   example  assignment  x        satisfies clause c    edge
v     ax label   figure   a  points g    else points b    likewise   x       
satisfies c    edge v     ax label   points g    else points b   
recall role second part check whether assignment generated
first part satisfies cnf formula f   clause ci variable xj
f   main function state variable vij check whether assignment  xj     mj
satisfies ci   this  state variable vij acts finite state automaton propagates
bit message keeping track j th bit message arrives 
since domain size state variables restricted  way vij count
number bits received  instead  fact j th bit arrived indicated
vi j     moreover  last state variable vin clause ci remember
whether ci satisfied assignment variable xj  
summary  state variable vij second part performs following functions
values operators 
   propagate message generated vs  
   check whether assignment xj  the j th bit m  satisfies clause ci  
   

fichain causal graphs domains size  

 

 
a  a  
b  b    
g  g 

ax
cx
gx
 

 
 

 

 

 
 

figure    domain transition graph variables   e            e n   
   remember whether ci satisfied assignment xl   l j 
   j   n ci satisfied  propagate fact 
   j   n  let vi j    know  j      th bit message arrived 
note third function strictly necessary j   n  however  including
state variables makes reduction compact symmetry 
next  briefly describe vij implements functions  value
domain vij subscript       x  propagate message  vij always moves
value whose subscript matches predecessor  in case v     subscript
match value vs    unless ci satisfied assignment xl   l   j 
value vij remains subdomain  a    a    ax   prior arrival j th bit 
clause ci encoded dashed edges dtgs variables vij  
operators j th bit mj arrives  vij moves ax gmj
assignment  xj     mj satisfies ci   bmj otherwise  fact value vij
subdomain  g    g    gx   indicates ci satisfied assignment
xl   l j  fact propagated way vin since subsequent state variable
ci forced move value subdomain  g    g    gx   whenever value
predecessor  g    g    gx    whether clause ci satisfied checked
defining goal state vin   gx  
finally  j   n vij moves bmj   vi j    moves amj   there  vij
choice move cx   causing vi j    return ax   next bit arrives  vij
moves either c  c    correctly indicating vi j     j      th bit arrived 
consequently  vi j    moves either g   g    b   b     depending whether
assignment xj   satisfies ci   hence  values type b used delay transition
vi j    value type either b g  mechanism allows
variable vij react j th bit  clause ci   operators vi  defined
vi  always reacts first bit 
dtgs state variables   e            e n  appear figure    function
state variables make sure n bits message propagated end
causal graph  state variable  strictly speaking  planner solving planning
problem  never forced select operator  choose propagate bit
message instead wait next bit arrive acting  turn  may cause
another state variable incorrectly conclude clause  not  satisfied 
variables third part prevent happening  since goal state defined
way cannot reached unless bits message arrive end
causal graph 
   

figimenez   jonsson

variable
s 
si  
     n   
vs

operator
hs       s     i
hsi       si      si    i
hsi       si      si    i
hs n       vs   x  vs   mi
hs n       vs   m  vs   xi

qualifier

      
      

table    operators variables s    s            s n    vs  

    formal proof
section  prove c  
n np hard showing planning problem p    f  
solvable formula f satisfying assignment  start with  provide
formal definitions operators p    f    operators s            s n    vs appear
table    corresponding dtgs appear figure    operators variables vij  
    k  j     n   appear table    dtgs appear figure    finally 
operators   e            e n  appear table    dtgs appear figure   
reduce space requirement use shorthand definitions operators 
words  hv   m  v   c  v   mi   a  b   denotes existence two operators
hv   a  v   c  v   ai hv   b  v   c  v   bi  similarly  hv  a  b   v   c  v   di denotes
existence two operators hv   a  v   c  v   di hv   b  v   c  v   di  state
variables vij introduce reference numbers allow us easily refer operators 
furthermore  operators conditional properties cnf formula f  
operator exists indicated property satisfied  example  operator
hv     c    v     ax   v     g  exists clause c  satisfied x    operator
hv     c    v     ax   v     b  exists c  satisfied x    use set notation
xj ci denote literal xj appears clause ci  
proof organized follows  begin series technical definitions
lemmas          related operators implications  definition     introduces notion admissible plans  lemma     states plan solving p    f  
admissible  next  lemma      establishes admissible plan corresponds
assignment variables cnf formula f   operator choices
plan forced given assignment  finally  lemma      determines exact sequence
values taken state variable execution admissible plan  making
possible check whether goal state reached end execution  theorem
     concludes admissible plans solving p    f   corresponding
satisfying assignments f  
definition      given partial plan p    f   variable v v    v  number
times value v changed operators  
lemma      partial plan p    f    holds
 si        n    
 vs    n 
   

fichain causal graphs domains size  

variable
v  

vi   
    k 

vij  
    k  
j     n 

ref 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    

operator
hvs      v     ax   v     g 
hvs      v     ax   v     b 
hvs      v     ax   v     g 
hvs      v     ax   v     b 
hvs   m  v     cx   v     cm
hvs   m  v     gx   v     gm
hvs   x  v     bm   v     cx
hvs   x  v     cm   v     cx
hvs   x  v     gm   v     gx
hv i  n  a    b    g     vi    ax   vi    g 
hv i  n  a    b    g     vi    ax   vi    b 
hv i  n  a    b    g     vi    ax   vi    g 
hv i  n  a    b    g     vi    ax   vi    b 
hv i  n  am   bm   gm    vi    cx   vi    cm
hv i  n  am   bm   gm    vi    gx   vi    gm
hv i  n  ax   cx   gx    vi    bm   vi    cx
hv i  n  ax   cx   gx    vi    cm   vi    cx
hv i  n  ax   cx   gx    vi    gm   vi    gx
hvi j     c    vij   ax   vij   g 
hvi j     c    vij   ax   vij   b 
hvi j     c    vij   ax   vij   g 
hvi j     c    vij   ax   vij   b 
hvi j    am   bm    vij   ax   vij  
hvi j     gm   vij   ax   vij   gm
hvi j     cm   vij   cx   vij   cm
hvi j    cm   gm    vij   gx   vij   gm
hvi j    ax   cx    vij     vij   ax
hvi j     cx   vij   bm   vij   cx
hvi j     cx   vij   cm   vij   cx
hvi j    cx   gx    vij   gm   vij   gx

qualifier
x  c 
x 
  c 
x  c 
x 
  c 
      
      
      
      
      
x  ci
x 
  ci
x  ci
x 
  ci
      
      
      
      
      
xj ci
xj
  ci
xj ci
xj
  ci
      
      
      
      
      
      
      
      

table    operators variables v             vkn  

variable


hvkn

e 
ei        n   

operator
 a    a    b    b    g    g    
hvkn  ax   cx   gx   
hve      e 
hve      e 
hei       ei
hei       ei

        i
        i
     e     i
     e     i
     ei    i
     ei    i

table    operators variables   e            e n   

   

figimenez   jonsson

proof  induction i       variable s  change once   s      
     n     follows inspection operators cannot change value
si twice without changing value si   the operator setting si
  si      pre condition  operator resetting si   si     
pre condition   since change value si initial state without
first changing value si    follows  si    si         i         
induction  argument holds variable vs predecessor s n     vs  
 s n          n           n 
lemma      partial plan p    f   vij       k  j     n  
holds  vij    v    v predecessor vij causal graph 
proof  before  follows inspection operators cannot change
value vij twice without changing value v between  see this  note
subscript value d vij   either x        operator vij either changes
value one subscript x one subscript        v value
subscript        one subscript       one subscript x  v value
subscript x  the argument holds v     although values predecessor
vs x       without subscripts  
note value vij cannot change initial state without first changing
value v   since v value subscript     value vij change
initial value ax   consequently  value vij cannot change times
value v    vij    v   claimed 
lemma      vij       k  j     n   partial state  v   x  vij   y  
v predecessor vij causal graph  one applicable operator
changing value vij  
proof  inspecting operators easy see pair operators vij
different pre conditions  exception rule operators exist
simultaneously due properties cnf formula f  e g  operators          
lemma      partial plan p    f    holds
 ve    vkn   
 e     ve   
 ei    ei         n    
proof  let v variable among   e            e n    let v predecessor causal
graph  before  cannot change value v twice without changing value v
between  v  e            e n     operator setting v   requires v     
operator resetting v   requires v      v     operator setting v   requires
v value subscript      operator resetting v   requires v
value subscript x  note that  either case  cannot change value v
initial state without first changing value v   thus   v   v  
variables  claimed 
   

fichain causal graphs domains size  

turn problem finding plan solves p    f   
lemma      let plan solves p    f   
 ei    n      n    
 ve    n 
proof  descending induction i     n    goal e n         value
e n  change least initial value init e n         implying  e n   
     n   n          n     assume  ei      n  i      holds
induction  lemma     follows  ei    ei      n  i       however 
since goal ei      goal ei     since solves p    f    follows  ei       ei     
hence  ei      ei      follows  ei    n i  claimed 
argument applies e  predecessor   since goal ve              goal e     yielding
 ve    n 
definition      admissible plan planning problem p    f   partial plan
 si     i   vs      v                vkn      ve      n   ei      n i 
     n    
lemma      plan solves p    f   admissible 
proof  lemmas          vs    v      vkn    ve    but 
lemmas          values equal  n  since  n  vs    ve    n 
proof lemma      si    si              n    
 vs    s n         together lemma      vs      n implies  si     i 
     n     proof lemma      ve      e      ei      ei     
     n      e n       together lemma      ve      n implies
 ei      n i       n    
please note converse lemma     true  is  admissible plans
solve planning problem p    f   
consequence lemma      find plan solves p    f   need
consider admissible plans  particular  admissible plan changes value variable vs
exactly  n times  generating sequence  n     values  note value vs always
changes x either      back x 
definition      let admissible plan  let x  m    x          x  mn   x sequence
 n     values variable vs takes execution   mj       
j     n   use denote message m            mn induced   use
denote formula assignment  xj     mj j     n  
turns out  operators part admissible plan completely
determined message induced  
lemma       let admissible plan p    f   let induced message 
operators changing value variable vij       k  j     n   well
sequence values variable vij takes execution   completely
determined  
   

figimenez   jonsson

proof  v  v             vkn    let v causal graph predecessor  proof
lemma     know cannot change value v twice without changing value
v between  initial state  change value v
change value v  definition admissible know  v      v     n 
way admissible plan change value v  n times without changing
value v  n times first change value v   v  v   on 
now  lemma     know that  given partial state  v   x  v   y  
one applicable operator changing value v  thus  time admissible
plan changes value v value v   one operator so 
plan choice select operator since allowed change value
v changing value v  consequently  sequence values taken
v completely determined  operators v  well sequence values
takes on  completely determined also  proof follows double induction
j  since sequence values taken vs  the predecessor v     completely
determined message  
follows lemma      relevant degree freedom admissible
plan selecting elements message   repeatedly deciding whether move
vs     vs     vs   x  selected  operator choices
forced  else plan admissible  particular  message unique
state executing admissible plan starting init results s  remains
determine whether unique state matches goal state 
remark  note lemma      mention operator order admissible plan 
indeed  change order operators admissible plan without making
plan inadmissible  example  let v    v    v  three consecutive variables
causal graph  let ha     a     a     a     a     a   subsequence operators changing
values  aji j th operator changing value vi   subsequence

ha     a     a     a     a     a   achieves result  long partial order haji   aji     aj  

respected j  change operator order please 
proceed determine sequence values variable vij       k  j
    n   takes execution admissible plan induced message  
first  define satisficing index clauses  sequence values plan 
definition       let admissible plan induced message   m 
clause ci   let satisficing index ti     n    smallest number  xti    
mti satisfies ci   number exists  ti   n     
definition       let admissible plan  clause ci      n      
let sequence values qti    vector n values representing  variable
vij   j     n   t th value taken vij execution  
following lemma key understanding idea behind reduction c  
n   since
specifies sequences values admissible plan induces execution 
lemma       let assignment variables x            xn formula f  
   

fichain causal graphs domains size  

   existence  exists admissible plan planning problem p    f   induced assignment    
   claim  let qti sequences values described part    lemma 
admissible plans   sequences values qti      qti  
    k       n      
   sequence values  sequence values qti       k       n      
follows 
a  j   ti  
nj

j 

z     
c x cx
qi j   
 j
qi   cmj cmj
 j  
 
c x cx
qi

ax
bmj
cx

z     
ax ax
amj amj
ax ax

ax
gmj
gx

z     
ax ax
gmj gmj
gx gx

b  j   ti  
nj

j 

qi j 
q j

q j  


z     
c x cx
 
  cmj cmj
 
c x cx

c  j   ti  
jti

nj

z     
gx gx
gmj gmj
gx gx

z     
gx gx
gmj gmj
gx gx

ti  

qi j 
q j

q j  


z     
 
c x cx
  cmj cmj
 
c x cx

gx
gmj
gx

proof  proving lemma  must check definition qti given part  
consistent  necessary due overlapping statements  namely  every
odd    n      sequence qti defined twice  qi j  j    t  

another time qi j    j    t   however  sequences values well defined
  
definitions qi j  q j
match combination j j   j   

shown following table 


j

qi j      qi j 

case  a 

z      z     
cx cx ax ax

case  b 

z      z     
cx cx ax ax

case  c 

z      z     
cx cx gx gx

case  c 

z      z     
cx cx gx gx

j

j

    j   ti  

case  a 

j

    j   ti  

case  a 

ti  

j   ti     n 

case  b 

ti  

ti       j n 

case  c 

   

nj

nj

nti   
nti   

figimenez   jonsson

now  prove parts     lemma  assume admissible plan induced
assignment     proof proceeds double induction j  particular 
 j  
prove validity three statements type qi j    q j
  assuming
  qi




statements type qi  for   t  statements type qi j     q j


qi j     for j   j  already hold  first prove validity qi j    j     
qi j    q i   ax ax cases  a   b  corresponds initial state vi            vin
 note case  c  cannot hold j       j     know that  since statements

consistent  qi j    qi j    j   j    hence correctness qi j  follows
induction j 
 j  
next  prove statements relative q j
  consider variable v
qi
precedes vi  causal graph  values number  j     j   j     takes
execution        v   vs values x  mj   x      
v   v i  n and  induction i  values ax   amj   ax j   ti  j   n 
ax   bmj   cx j   n   ti    ax   gmj   gx j   ti    gx   gmj   gx j   ti   
proof divided   parts  depending values j ti  
i      j   ti   consider following table  write instead mj   m 
simplify notation 
v
vi 
 j  
 x  ax   gx  
ax
 m    bm   gm  
 j
 j      x  ax   cx   gx  


vi 
ax








vin
ax



three rows table correspond values number  j     j   j    
variables v   vi            vin   first column corresponds possible values
predecessor v vi  take on  first row given qi j    second
 j  
third rows  filled  correspond q j
 
qi
let a j operator causing  j th value vi    according previous
table  pre condition a j must compatible
hv  m    am    bm    gm     vi    ax
is  values variables v vi  a j applied  since ti       x     
m  satisfy clause ci   operator a j must one labelled    
    table     only one operators applicable  depending value
m  whether v vs v i  n    either case  application a j causes
value vi  become bm    fill blank previous table 
v
vi 
vi 
 j  
 x  ax   gx  
ax
ax
 j
 m    bm   gm   bm       
 j      x  ax   cx   gx  








vin
ax



way  check a j     operator causing   j      th value
vi    must one labelled     table    new value vi  cx  
   

fichain causal graphs domains size  

remaining variables  easy check variables vi            vin become am    due
operators type       become ax   due operators type      
table complete 
v
vi 
vi  vin
 j  
 x  ax   gx  
ax
ax ax
 j
 m    bm   gm   bm            
 j      x  ax   cx   gx  
cx    
ax ax     
shows case  a  lemma      holds j     ti     
ii      j   ti   proof similar case  i   since ti       x      m 
satisfies clause ci   result  admissible operators causing  j th value
vi  labelled          either case  value vi  becomes gm   
consequently  admissible operators vi            vin different before 
resulting table 
v
vi 
vi  vin
 j  
 x  ax   gx  
ax
ax ax
 j
 m    bm   gm   gm        gm gm     
 j      x  ax   cx   gx  
gx    
gx gx     
iii      j   ti   case  remaining ones  show resulting table 
always write   mj   follows  omit column v since possible
values always same 
vi 
vi  vi j  
vij
vi j    vin
 j   cx
c x cx
ax
ax ax
cm    
cm cm      bm         
    
 j
 j     cx    
cx cx      cx     
ax ax     
iv      j   ti  
vi 
vi  vi j  
vij
vi j    vin
 j   cx
c x cx
ax
ax ax
cm    
cm cm      gm         
gm gm     
 j
 j     cx    
cx cx      gx     
gx gx     
v      ti   j 
vi 
vi  vin
 j   gx
gx gx
 j
gm     gm gm     
 j     gx     gx gx     
vi      ti   j 
vi 
vi  vi ti   
viti vin
 j   cx
c x cx
gx gx
 j
cm    
cm cm      gm gm     
cx cx      gx gx     
 j     cx    
   

figimenez   jonsson

remains check case  a  lemma      follows parts  i   iii  
case  b  parts  ii   iv   case  c  parts  v   vi   proves part
    lemma 
finally  note existence admissible plan directly follows previous
discussion  since always specified operators used every situation 
assumed existence  proves part   lemma 
theorem       exists plan solves planning problem p    f  
exists assignment satisfies cnf formula f  
proof    given assignment satisfies f   construct admissible plan whose
induced formula assignment equals   choosing sequence values vs accordingly  follows ti n clause ci   since exists variable xj
 xj     mj satisfies ci   then  q n  
form indicated case  b   c  lemma

      either case    n      th value variable vin gx   required goal state 
plan thus solves p    f   
  let plan solves planning problem p    f    lemma     plan
admissible  show contradiction   satisfies f   assume not 
exists clause ci satisfied   implying ti   n      since n   ti     n      th
value variable vin cx according case  a  lemma       contradicts solving
p    f    since goal value vin cx gx  
proposition       plan existence c  
n np hard 
proof  largest variable domains planning problem p    f   variables
v             vkn   contain    values  proof follows immediately well known
np hardness cnf sat  theorem       fact produce planning
problem p    f   polynomial time given cnf formula f  
    example
illustrate reduction using small example cnf formula f    x  x    one
clause two variables x  x    variable set corresponding planning problem
p    f   v    s    s    s    vs   v     v       e    e    e     admissible plan induce
four different messages                                 message        corresponds
assignment satisfy f   plan solves p    f   induced
message        appears table    note that  following execution plan  goal state
goal    v     gx        e       e       e       satisfied desired  last value change
variable appearing goal state marked using boldface 

   c n np hard
section  describe reduction cnf sat c n   cnf formula f
associate planning problem p   f    clause ci variable xj f   p   f   contains
    domain d v        a       b    v     domain d v      
two state variables vij
x     x
ij
ij
ij
    d v        a   b   b   
 ax   a    a    b    b     values a  a  omitted vin
x    

   

fichain causal graphs domains size  

  
 
hs       s       s     i
hs       s       s     i
hs       vs   x  vs    i
hvs      v     cx   v     c 
hv     c    v     ax   v     g 
hv     g            i
hve      e       e     i
hs       s     i
hs       s       s     i
hs       s       s     i
hs       vs      vs   xi
hvs   x  v     c    v     cx
hv     cx   v     g    v     gx
hv     gx           i

hs       vs   x  vs    i
hvs      v     ax   v     b 
hv     b    v     ax   v     a 
hv     a            i
hve      e       e     i
he       e       e     i
he       e       e     i
hs       s       s     i
hs       vs      vs   xi
hvs   x  v     b    v     cx
hv     cx   v     a    v     ax
hv     ax           i
hve      e       e     i
he       e       e     i
  
 

table    plan solves planning problem p    f   example formula f  
 a 

 b 

 c 

 d 

a 

a 

a 

a 
a 

x

 

b 

x

ax

bx

ax

x

x

b 

ax

ax b 

ax

ax b 

bx
ax

ax
a 

 

ax a 

ax

a 

ax bx

ax

ax
a 

a 

b 
a 

ax
a 

bx

ax

 e 
b 
ax bx

a 

ax a 
a 

ax bx
b 

ax bx

a 
b 

     b  v           c  v     j       d  v     j   n   e  v    
figure    dtgs  a  v  
i 
ij
ij


state variables s            s n    vs     e            e n    well domains corresponding
   
operators  before  except predecessor vkn
      init v             k 
initial state new state variables init vij
x
ij
 
j     n   goal state goal vi      ax       k   table   lists operators
  v         k  j     n   figure   shows corresponding dtgs 
variables vij
ij
table   lists new operators variable   different pre conditions
   
predecessor vkn
    intuition
reduction c n based following idea  instead using explicit value
remember clause satisfied  goal remain initial value ax  
way able reduce size variable domains needed reduction 
somewhat surprisingly  new reduction uses fewer total operators c  
n  
   

figimenez   jonsson

variable
 
v  

  
vi 
    k 
  
vij
    k  
j     n 
  
vij
    k  
j     n   

   
vin
    k 



ref 
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    

operator
      v   
hvs   m  v  
x   

      v   
hvs   x  v  
  
x
      v    b
hvs   x  v  
  
x
      v   
 
  bm   vi 
hv i  n
x i 

 
      v   
hv i  n
  ax   vi 
x
i 
 
      v    b
hv i  n
  ax   vi 
i 
x
      v   
 
    vij
hvi j  

x ij
 
      v   
hvi j  
  ax   vij
ij
x
    b   v   
 
  bm   vij
hvi j  

x ij
 
 
 
hvi j     ax   vij     vij   bx
      v      v   
hvij

x ij
ij
      v      v   
hvij
x
x ij
ij
 
 
 
hvij     vij   ax   vij   bm
      v    b   v   
hvij
x
x ij
  ij
    b   v    b   v   
hvij
x ij
  ij
x
      v    b   v   
hvij
x ij
  ij
x
    b   v    b   v   
hvij
x ij
  ij
x
      v      v    b
hvin

x

      v    b   v   
hvin
x
 
x
    b   v    b   v   
hvin
x
 
x
      v    b   v   
hvin
x
x
 
    b   v    b   v   
hvin
x
 
x
    b   v      v    i
hvkn
e
e
      v      v    i
hvkn
x e
e

qualifier
      
      
      
      
      
      
      
      
      
      
      
      
      
xnj   ci
xnj  
  ci
xnj   ci
xnj  
  ci
      
x  ci
x 
  ci
x  ci
x 
  ci
      

    v     v       k  j     n  
table    operators variables vij
e
ij

   

fichain causal graphs domains size  

reduction c n uses another new idea  reduction c  
n   information
propagated forward  i e   variable vij changed value according value
predecessor vi j     reduction c n   however  constructed information propagated forward  in particular  bits message  information
propagated backwards  the index bit currently checking   planning
problem arranged variable v may several applicable operators 
one satisfies pre condition applicable action successor v   result
value v time     depends value v time t 
explain planning problem p   f   bit detail  due backward
propagation mechanism  bits message checked reverse order 
words  vin checks first bit  vi n   checks second bit  vi  checks n th
  check whether  n j      th bit satisfies clause c  
bit  purpose vij

  inform v  
whereas purpose vij


 n

j
 
   th
bit

arrived 
i j  
  keeps track whether c satisfied first  n j     
implicitly  vij

bits 
assume without loss generality message      let us see happens
corresponding assignment satisfy clause ci   upon arrival first bit 
  move b   requires v     pre condition 
state variable vin
 
 

l   j     n    l           next  v  
turn requires state variables vij
 

    b   turn  requires state
move back ax   requires pre condition vin
x
l   j     n    l           v   moves b
variables vij
x
x

 
a    requiring vi n     b  pre condition 
  b following  nj    we see that  long clause remains unsatisfied  vij
x
  b following last bit  assume
th bit  particular  means vi 
x
  moves b   requires v  
 n j      th bit satisfies clause ci   vij
 
x
ij
 
move ax instead bx   there  way vi j  
bx following
  following last bit  satisfying goal
 n j      th bit  particular  vi 
x
state 
    formal proof
proof c n organized much way c  
n   note variables
s            s n    vs     e            e n  before  lemmas         still apply
p   f    easy check lemmas              hold p   f    however 
lemma     longer holds  since several operators share preconditions  namely
operators                                        spite this 
operators sequences values admissible plan completely determined
induced message   p    f    as shown lemma       
lemma      let admissible plan p   f   let induced message 
l       k   j     n   l        
operators changing value variable vij
l takes execution  
well sequence values variable vij
completely determined  
    assume without loss generality value  
proof  first consider variable v  
 
    namely      changing value
given  vs   x   two applicable operators v  

   

figimenez   jonsson

ax        changing value bx   first sight  admissible plan choose either 
  pair
however  admissible  change value v  
    note v       v   either two values  namely
value changes v  
 
  
  
    admissible operator v        
a  b    value v  
 
  
      thus  changes value v   b longer admissible 
pre condition v  
x
x
  
  b   correct choice depends
choose operator      value v  
 
      
cnf formula f   xn satisfies clause c    admissible operator v  
      choose operator      otherwise  admissible
pre condition v  
x
 
    b   choose operator     
operator v        pre condition v  
x
   
 
either case  operator choice v   forced given value v  
        k   v         k  j     k  
reasoning applies variables vi 
ij
        k  j     n     corresponding operators share
vij
pre conditions  degree freedom admissible plan selecting induced
message choosing operators vs accordingly  remaining operator choices
and  consequently  sequences values completely determined induced message
 
prove lemma similar lemma       establishing sequence values taken
state variables p   f   execution admissible plan 
definition      let admissible plan p   f    clause ci
     n       let sequence values qti    vector  n elements representing 
l   j     n  l         t th value taken variable v l
variable vij
ij
l    define diagonal value
execution   let us denote value qt    vij
 
qji         k  j     n   value q j      vi nj   
  
lemma      let assignment variables x            xn formula f  
   existence  exists admissible plan planning problem p   f   induced
assignment    
   claim  let qji described part    lemma  admissible plans
  diagonal values qji      qji     k  j     n  
   diagonal values  diagonal values qji       k  j     n  
follows 
a  j   ti   qji   bx  
b  j ti   qji   ax  
proof  note that  according lemma      diagonal values qji    
full sequences values qti     completely determined admissible plan  
prove  then  admissible plans exist assignment   claimed part   
diagonal values match expression given part    prove two facts
careful  general analysis planning problem p   f    explaining
analysis implies lemma  incidentally  sequences values qti   
   

fichain causal graphs domains size  

obtained analysis  study important
purposes 
l variable p  f    clearly 
let admissible plan  let v   vij
 

subscript t th value q    v  v takes depends parity t  since
operators affecting v change subscript x          back x 
namely  subscript qt    v  x    p       p  p th
bit message  
  
now  j     n        k   consider t th values variables vij
    v 
vij
i j    take on     p     p   p      previous observation subscripts
implies  trivially  know something values 
    qt    v     qt    v  
qt    vij
ij
i j     
   p    ax   bx  
ax
 ax   bx  
   p

 am   bm  

   p      ax   bx  
ax
 ax   bx  
 
  affects values diagonal 
study value q p     vi j   
 p 
 
 p  
 
 p
 
   vi j   
    ax   check
   vij    q
namely q    vij   q
one possible outcome 
 
  
  
rule
 
qt    vi j   
qt    vij
qt    vij
   p    ax   bx  
ax
ax
   p


    

   
   p    
ax
   
ax
    
 ax   bx  

is  value type ax propagated along diagonal another value ax  
call propagation rule i 
 
    bx  
study possible outcomes q p     vi j   
 p
 
 p  
 
case  values q    vij   q
   vij   diagonal depend whether
p th bit message clause ci satisfied xnj      c f 
operators                   table     ci satisfied xnj     m  follows
values must bm ax   propagation rule ii 
  
  
 
rule ii
qt    vij
qt    vij
qt    vi j   
 
   p    ax   bx  
ax
bx

bm
    

   
   p
   p    
ax
   
ax
        
 ax   bx  

contrary  clause ci satisfied  values must bm bx  
call propagation rule iii 
 
  
  
rule iii qt    vij
qt    vi j   
 
qt    vij
   p    ax   bx  
ax
bx
   p

bm
    

   
   p    
bx
    
ax
        
 ax   bx  

   

figimenez   jonsson

finally  let us consider cases j     j   n  treated
  values type   note
previous analysis  note variables vin

  cannot take value b time    n      cannot change further 
variables vi 
x
since pre conditions operators                          k  
    b   thus  possible outcome two variables
compatible vi 
x
p   n following 
 
   
   
 
qt    v i    
qt    vin
qt    vin
   p    ax   bx  
ax
ax
   p

bm
    

   
ax
                
ax
   
   p      ax   bx          
 
  either ax bx   using operators
note that  p   n  value q p      v i    
   
         reader check similar analysis applies variable v  
operators        take role operators        
let us summarize previous analysis following table 

t  
t  
t  
t  
  
 

 
 
 
vi 
vi 
vi 

ax ax ax

ax

  
 

   n  
   n   ax
   n

   n    





  v 
 
 
vin
vi n  
vi n  

ax
ax ax ax
bm
ax
bm
  
 



bm
ax
bm
ax

first row previous table contains initial state planning problem 
variables set ax   leftmost column rightmost column contain values
  v     then  values b right column propagated
taken variables vi 


along diagonals using three propagation rules already discussed  value type
yields values type according rule i  value type b yields value type
clause satisfied rule ii  type b satisfied  rule iii 
applies propagating values first row  since type a 
values top left triangle type a  according rule i  note longest
diagonal coincides diagonal values qji definition     
discussion proceed prove lemma  let assignment formula
f   existence plan   implied analysis already done
l    since shown operators used case produce
values qt  vij
actual changes value 
    
finally  consider diagonal values qji    j              n  is  values q     vin
 
 
 n  
 
q    vi n             q
   vi     let j   ti case  a   is  first j bits
message   assigned variables x            xj   satisfy clause ci   consequently 

 j      v  
     q   q     v  
diagonal values q i   q     vin
 
i n  j    must
i n             qj   q
   

fichain causal graphs domains size  

bx   according rule iii  contrary  assume j ti case  b  
follows qpi   bx p   ti due rule iii  qpi   ax p   ti due rule ii 
qpi   ax j p   ti due rule i 
theorem      exists valid plan solving planning problem p   f  
exists assignment satisfies cnf formula f  
proof    lemma      existence assignment satisfies f implies
admissible plans   satisfy qji      qji   since ti n     k   follows
qni   ax   required goal state p   f    plan thus solves p   f   
  let plan solving planning problem p   f    since lemma     holds
p   f    plan admissible  show contradiction   satisfies f  
assume not  exists clause ci satisfied   thus  lemma     implies
  following execution b  
qji      bx j     n   particular  value vi 
x
   a  
contradicts solving p   f    since bx different goal state goal vi 
x
proposition      plan existence c n np hard 
proof  largest variable domains planning problem p   f   variables
        k  j     n     contain   values  proof follows immediately
vij
np hardness cnf sat  theorem      fact produce
planning problem p   f   polynomial time given cnf formula f  

   discussion
paper  shown problem determining whether solution plan exists
planning problems class ckn np hard whenever k    contrast  brafman
domshlak        developed polynomial time algorithm generating plans solve
planning problems class c n   said intermediate cases  namely
ckn k         follows  sketch arguments tractability
cases  although discussion mostly based intuition gained studying
classes  might prove helpful someone trying determine complexity 
one hand  seems likely us plan existence c n np hard 
reduction c n uses one type state variable whose domain larger    namely
    finding reduction c  seems possible  although likely difficult since
vij
n
available options become increasingly restricted state variable domains get smaller 
particular  tried failed find reduction c n  
domshlak dinitz        showed exist planning problems c n
exponential length minimal solutions  although often indicates planning class
difficult  imply plan existence intractable  exemplified
jonsson backstrom        define class planning problems exponential
length minimal solutions plan existence could checked polynomial time 
present authors  gimenez   jonsson      a  showed even plan generation
particular class could done polynomial time  resulting plans given
compact format macros 
second argument favor hardness c n may multiple ways
transition two values variable  example  consider planning problem
   

figimenez   jonsson

two actions changing value variable v      namely
  hv      v      v    i   hv      v      v    i  since variables   values 
possible neither v     v     hold current state  planner would
thus choose whether satisfy v     v      contrast  c n two
actions could replaced single action hv      v    i since one always
applicable  consequence  even minimal plan length bounded planning
problem c n   may exponentially many plans length  in fact 
main idea behind reductions  
another observation regards number possible domain transition graphs
state variable  k    possible show state variable ckn may
 
 k  k   distinct domain transition graphs  words  number graphs grows
exponentially k  particular  state variables c n         distinct
graphs  number c n       although large number possibilities
guarantee hardness  clear expressive power c n much higher
c n  
evidence provided suggests c n significantly harder c n   however 
sure c n hard enough intractable  state variables three
values lend well type reduction presented  since
propagating message requires three values  reduction c n   idea
underlying may message passing mechanism exploited 
hand  maybe way determine plan existence c n polynomial time 
algorithm would take consideration multiple  but finite  combinations domain
transition graphs three values  well inherent structure graphs  know
expressive power domain transition graphs   values large handle
polynomial time  maybe case using   values 

acknowledgments
work partially funded apidis mec grant tin           c      

appendix a  c n np hard
appendix  describe modify reduction c  
n resulting
planning problem  call p   f    needs variable domains size    reduction previously appeared conference paper  gimenez   jonsson      b   without
proof  main idea reduction same  construction used check
assignment satisfies clause ci involved  previously  used n variables  vij  j       n  whose role was  essentially  check whether j th bit  xj  
propagated message satisfies ci   modified reduction  variable vij replaced
    v     v     collectively play role  variables
three variables vij
ij
ij
s            s n    vs     e            e n    well domains corresponding operators 
   
before  except predecessor vkn
      d v        a       b   b   b   g  
domains new variables d vij
x     x     x
ij
 
d vij      gx   g    g    ax   a    a    bx       k   j     n   initial state
      init v       init v             k  j     n   goal
variables init vij
x
ij
ij
   

fichain causal graphs domains size  

variable
 
v  

  
vi 
    k 

  
vij
    k  
j     n 

ref 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    

operator
      v    g
hvs      v  
x
x   
      v    b
hvs      v  
x   
 
      v    g
hvs      v  
x
x   
      v    b
hvs      v  
x   
 
    g   v    b
hvs   m  v  
x   

    b   v    b
hvs   m  v  
x   

    b   v    b
hvs   x  v  
  
x
 
      v    g
hv i  n
 a    b     vi 
x
x i 
      v    b
 
 a    b     vi 
hv i  n
x i 
 
 
 
 
hv i  n  a    b     vi    ax   vi    gx
 
      v    b
hv i  n
 a    b     vi 
x i 
 
 
    g   v    b
hv i  n
 am   bm    vi 
x i 

 
    b   v    b
hv i  n
 am   bm    vi 
x i 

 
 
 
hv i  n  ax   bx    vi    bm   vi    bx
 
      v    g
hvi j  
  b    vij
x ij
x
 
 
 
hvi j     b    vij   ax   vij   b 
 
      v    g
hvi j  
  b    vij
x ij
x
      v    b
 
  b    vij
hvi j  
x ij
 
 
      v    g
hvi j  
  gx   vij
x ij
x
 
 
 
hvi j       vij   ax   vij  
 
    g   v    b
hvi j  
  bm   vij

x ij
 
    b   v    b
hvi j     bm   vij
x ij

 
      v   
hvi j  
 ax   bx    vij
x
ij
    b   v    b
 
  bx   vij
hvi j  
ij
x

qualifier
x  c 
x 
  c 
x  c 
x 
  c 
      
      
      
x  ci
x 
  ci
x  ci
x 
  ci
      
      
      
xj ci
xj
  ci
xj ci
xj
  ci
      
      
      
      
      

        k  j     n  
table    operators variables vij

      g       k   table   shows operators variables v         k 
state goal vin
x
ij
  v         k 
j     n   table   shows operators variables vij
ij
j     n   figures     shows corresponding domain transition graphs  table  
shows new operators variable   different pre conditions
   
predecessor vkn

a   intuition
intuition behind reduction c n largely c  
n   planning
problem p   f   corresponding cnf formula f consists three parts  first
third identical p    f    thus  difference lies second part  recall
reduction c  
n   clause ci variable xj f   planning
problem p    f   contains state variable vij performs following functions 
   propagate message generated vs  
   

figimenez   jonsson

variable
  
vij
    k  
j     n 

ref 
    
    
    
    
    
    
    
    
    
    
    
    
    
    

  
vij
    k  
j     n 



operator
   a   b    v       v    
hvij

x ij

ij
    g   v      v    g
hvij
x
x ij
x ij
    b   v    g   v    g
hvij
ij
x ij

    b   v    b   v   
hvij

x ij
ij
      v      v   
hvij
x ij
ij
x
    b   v      v    b
hvij
x
ij
x ij
    b   v    g   v    g
hvij
x ij
ij
x
      v      v   
hvij
ij
x ij

    g   v      v    g
hvij
x
x ij
x ij
    g   v    g   v    b
hvij
ij
x ij

   a   g    v     b   v     b
hvij

x ij

ij
      v      v   
hvij
x ij
ij
x
 
 
 
hvij   bx   vij     vij   bx
   b   g    v     b   v     b
hvij
x
x x
ij
ij
 
hvkn  a    a    b    b             i
   a   b    v      v    i
hvkn
x x
e
e

qualifier
      
      
      
      
      
      
      
      
      
      
      
      

    v     v       k  j     n  
table    operators variables vij
e
ij

 a 

 b 

 c 

b 

b 

a 

 
ax

 

 
bx

gx
 

x

ax
 

 

a 
a  b  b 

a  b 

x

gx

a   b 

a   b 

ax
bx

b 

bx

ax

gx

a 
b 

ax
bx

b 
ax bx

b 

b 
ax bx

a 

b 

b 

b 

bx
bx

gx
b 

bx

b 

a 
a 

b 

     b  v       k    c  v       k   j     n  
figure    dtgs  a  v  
ij
i 

   check whether assignment xj  the j th bit m  satisfies clause ci  
   remember whether ci satisfied assignment xl   l j 
   j   n ci satisfied  propagate fact 
   j   n  let vi j    know  j      th bit message arrived 
first fourth function propagate information thus performed
state variables information lost  however  functions
performed different state variables  idea behind reduction c n split vij
    performs second function  v     performs third 
three variables  vij
ij
 
vij   performs fifth 
   

fichain causal graphs domains size  

 a 

 b 
a 

g 
b 

a 
bx

bx
a  b 
gx

gx

g 

b 

ax

bx

ax
a  b 

b 

bx

ax

a 

a 

ax

b 

bx

g 
a  g 

ax

bx

gx

bx gx
bx

gx
bx gx

ax

b 

a 
a 

bx

a  g 

g 
b 

   b  v       k   j     n  
figure    dtgs  a  vij
ij

before  message propagated using subscripts values domains
  moves
state variables  j th bit mj message arrives  state variable vij
  moves
ax gx assignment  xj     mj satisfies ci   bmj otherwise  vij
gx   forced move bmj next  forgetting ci satisfied  however 
  g   subsequent state variables c move g   propagating
value vij
x

x
  able remember
fact ci satisfied  consequently  state variable vin
ci satisfied remaining within subdomain  g    g    gx   
  moves b   causing v   v   move  
 xj     mj satisfy ci   vij
mj
mj
ij
ij
 
 
 
 
there  vij   vij   vij move bx   next bit arrives  vij moves b   b    
  move  a   v   b  b    indicates v  
causing vij
 
 
 
 
ij
i j     j      th
bit arrived  causing act accordingly  before  operators defined
  always reacts first bit clause c  
vi 

a   formal proof
since variables s            s n    vs     e            e n  before  lemmas    
    apply p   f    however  lemma     violated since sometimes possible
change value variable twice without changing value predecessor  e g 
using operators           consequently  lemma      states plans
solve p    f   admissible  longer holds p   f   
l   variables middle
prove equivalent lemmas p   f    redefine  vij
causal graph 
l       k   j     n  
definition a    given partial plan variable vij
l   number subscript changes v l execution  
l            let  vij
ij
l       k   j     n  
lemma a    partial plan p   f   vij
l    v    v predecessor v l causal
l            holds  vij
ij
graph 
l   operator
proof  follows immediately inspection operators vij
l
changes subscript vij z        x  pre condition v subscript z  or
  predecessor v    operators changing value
value z case v  

  g pre condition v subscript  or value  different x 
vij
x
  since pre condition v    
operators change subscript vij
x
ij

   

figimenez   jonsson

    
lemma a    partial plan p   f     ve    vkn
    denotes
proof  note  ve   still denotes number value changes    vkn
    time change value v need
number subscript changes vkn
e
 
change subscript vkn between  addition  first value change requires
  different initial state  thus   v    v     
subscript vkn
e
kn

definition a    admissible plan planning problem p   f   partial plan
               v        v      n   e      n i 
 si     i   vs      v  
e

kn
     n    
lemma a    plan solves planning problem p   f   admissible 
     v      v   
proof  lemmas a   a    vs    v  
e
kn
use lemmas         apply reasoning proof lemma
    
l exactly  n
words  admissible plan change subscript vij
l extra time moving g   however 
times  although change value vij
x
l    cannot prove equivalent lemma     
even new definition  vij
l   l         choose follow predecessor g without
p   f    since variable vij
x
making plan inadmissible  consequently  sequences values qti    admissible
plan longer completely determined induced message   nevertheless 
still prove lemma similar lemma      

definition a    let admissible plan  clause ci      n      
let sequence values qti    vector  n elements representing  variable
l   j     n  l            first value following  t    th subscript change
vij
l execution  
vij
lemma a    let assignment variables x            xn formula f  
   existence  exists admissible plan planning problem p   f   induced
assignment    
   claim  let qti sequences values described part    lemma 
satisfies f   exists admissible plan   qti      qti  
     n        k   satisfy clause ci   admissible
plans   qti      qti        k      
   sequence values  sequence values qti       k       n      
follows 
a  j   ti  
j 

qi j 
q j

q j  


nj
  
 
z
z
  
 
bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax
 
  bm bm bm bm bm
 
bx bx bx bx bx bx
bx bx bx
ax ax ax ax ax ax

   

fichain causal graphs domains size  

b  j   ti  
j 

qi j 
q j

 j  
qi

nj
z
  
 
z
  
 
 
bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax
  bm bm bm bm bm gm bm bm gm bm bm gm bm
 
bx bx bx bx bx bx
bx gx bx
bx gx bx bx gx bx

c  j   ti  
jti

ti  

qi j 
q j

 j  
qi

nj

z
z
  
 
  
 
  
 
z
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx
  bx bx bx bx bx bx
  bm bm bm bm bm gm bm bm gm bm bm gm bm bm gm bm bm gm bm
  bx bx bx bx bx bx
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx

proof  note similarity lemma lemma       before  must show
operators  time tables      whose post conditions equal values
 j  
given qi j    q j
  again  must check consistency statements
qi
 j   
 j 

j   j    implies  lemma       statements
qi
qi
qi j  valid  due initial state ax ax induction j 
 j  
remains show statements q j
valid 
qi
proof divided six parts lemma       note that 
contrast lemma  aim show that  satisfies f   exists
admissible plan given qti   admissible plans form 
sometimes execution plan one operator could chosen 
resulting plan would still admissible  tables follow  alike
proof lemma       indicate operator choice leads
desired qti   use boldface remark operators forced  add
extra row tables indicate sometimes need apply two operators
variable changing subscript  disparities respect lemma     
occur parts ii iv proof  require ti n  is  satisfying clause
ci   fixed i  thus  satisfy clause ci   admissible plans
sequences values qti      n      
i      j   ti  
  v  v 
  v   v    k     n 
vi 
vik
i  i 
ik ik
 j   ax ax ax
ax ax ax
 j
bm                            
ax ax ax             
 j     bx bx bx            

ii      j   ti  
  v  v 
  v   v    k     n 
vi 
vik
i  i 
ik ik
 j   ax ax ax
ax ax ax
gx gx gx               
gx gx gx             
 j
bm gm bm            
bm gm bm             
bx gx bx            
bx gx bx             
 j    

   

figimenez   jonsson

iii      j   ti  
  v   v    k     j    v   v   v  
  v   v    k  j      n 
vik
vik
ij ij ij
ik ik
ik ik
 j  
b x bx bx
ax ax ax
ax ax ax
 j
bm bm                 bm                             
bx bx bx                
bx bx bx             
ax ax ax             
 j    

iv      j   ti  
  v   v    k     j    v   v   v  
  v   v    k  j      n 
vik
vik
ij ij ij
ik ik
ik ik
 j  
b x bx bx
ax ax ax
ax ax ax
bm bm                 gx gx gx                
gx gx gx             
 j
bm bm
bm gm bm             
bm gm bm             
 j    
bx bx bx                
bx gx bx             
bx gx bx             

v      ti   j 
  v   v    k     n 
  v  v 
vik
vi 
i  i 
ik ik
 j  
bx gx bx
bx gx bx
 j
bm gm bm             bm gm bm             
 j    
bx gx bx            
bx gx bx             

vi      ti   j 
  v   v    k     t    v   v   v    k  t   n 
vik


ik ik
ik ik ik
 j  
bx bx bx
bx gx bx
 j
bm bm                
bm gm bm             
 j    
bx bx bx                
bx gx bx             

theorem a    exists plan solves planning problem p   f  
exists assignment satisfies cnf formula f  
proof    given assignment satisfies f   construct admissible plan whose
induced formula assignment equals   choosing sequence values vs accordingly  follows clause ci   ti n  since exists variable xj
 xj     mj satisfies ci   since n ti   exists admissible plan qi n  
form indicated case  b   c  lemma a    either case    n      th
  g   required goal state  plan thus solves p  f   
value variable vin
x
 
  let plan solves planning problem p   f    lemma a   plan
admissible  show contradiction   satisfies f   assume not 
exists clause ci satisfied   thus  lemma a   applies sequence
  following execution
values q n  
  particular  means value vin

bx according case  a  lemma  contradicts solving p   f    since bx
    g  
different goal state goal vin
x
proposition a    plan existence c n np hard 
   

fichain causal graphs domains size  

proof  largest variable domains planning problem p   f   variables
            v     contain   values  proof follows immediately np hardness
v  
kn
cnf sat  theorem a    fact produce planning problem p   f  
polynomial time given cnf formula f  

references
brafman  r     domshlak  c          structure complexity planning unary
operators  journal artificial intelligence research             
brafman  r     domshlak  c          factored planning  how  when  not 
proceedings   st national conference artificial intelligence  pp         
bylander  t          computational complexity propositional strips planning 
artificial intelligence             
chapman  d          planning conjunctive goals  artificial intelligence                
chen  h     gimenez  o          causal graphs structurally restricted planning 
proceedings   th international conference automated planning scheduling  pp       
domshlak  c     dinitz  y          multi agent off line coordination  structure complexity  proceedings  th european conference planning  pp         
erol  k   nau  d     subrahmanian  v          complexity  decidability undecidability
results domain independent planning  artificial intelligence                
gimenez  o     jonsson  a       a   complexity planning problems simple
causal graphs  journal artificial intelligence research             
gimenez  o     jonsson  a       b   search tractability boundary planning
problems  proceedings   th international conference automated planning
scheduling  pp        
helmert  m          fast downward planning system  journal artificial intelligence
research             
jonsson  a          role macros tractable planning causal graphs 
proceedings   th international joint conference artificial intelligence  pp 
         
jonsson  p     backstrom  c          tractable plan existence imply tractable
plan generation  annals mathematics artificial intelligence                 
katz  m     domshlak  c       a   new islands tractability cost optimal planning 
journal artificial intelligence research             
katz  m     domshlak  c       b   structural patterns heuristics via fork decompositions  proceedings   th international conference automated planning
scheduling  pp         
knoblock  c          automatically generating abstractions planning  artificial intelligence                
   

figimenez   jonsson

williams  b     nayak  p          reactive planner model based executive 
proceedings   th international joint conference artificial intelligence  pp 
         

   


