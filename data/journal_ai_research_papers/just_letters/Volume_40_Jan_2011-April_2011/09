journal artificial intelligence research                  

submitted        published      

clause learning algorithms many restarts
bounded width resolution
albert atserias

atserias lsi upc edu

universitat politecnica de catalunya
barcelona  spain

johannes klaus fichte

fichte kr tuwien ac at

vienna university technology
vienna  austria

marc thurley

marc thurley googlemail com

university california berkeley
berkeley  usa

abstract
offer new understanding aspects practical sat solvers based
dpll unit clause propagation  clause learning  restarts  analyzing
concrete algorithm claim faithful practical solvers do  particular 
making new decision restart  solver repeatedly applies unit resolution
rule saturation  leaves component mercy non determinism except
internal randomness  prove perhaps surprising fact that  although
solver explicitly designed it  high probability ends behaving width k
resolution o n k     conflicts restarts  n number
variables  words  width k resolution thought o n k     restarts
unit resolution rule learning 

   introduction
discovery method introduce practically feasible clause learning non chronological backtracking dpll based solvers layed foundation sometimes called
modern sat solving  silva   sakallah        bayardo   schrag         methods
set ground new effective implementations  moskewicz  madigan  zhao  zhang   
malik        spawned tremendous gains efficiency sat solvers many
practical applications  great somewhat unexpected success seemed contradict
widely assumed intractability sat  time uncovered need
formal understanding capabilities limitations underlying methods 
several different approaches suggested literature developing rigorous understanding  among find proof complexity approach  captures
power sat solvers terms propositional proof systems  beame  kautz    sabharwal              hertel  bacchus  pitassi    gelder        pipatsrisawat   darwiche 
       rewriting approach  provides useful handle reason
properties underlying algorithms correctness  nieuwenhuis  oliveras   
tinelli         approaches  sat solvers viewed algorithms search
proofs underlying proof system propositional logic  view mind 
illuminating understand proof system underlying modern solvers always
c
    
ai access foundation  rights reserved 

fiatserias  fichte    thurley

subsystem resolution  beame et al          particular  means performance never beat resolution lower bounds  time provides many
explicit examples sat solvers require exponential time  complementing
result idealized sat solver relies non determinism apply techniques
best possible way able perform good general resolution  weak forms
statement first established beame et al               hertel et al        
current form pipatsrisawat   darwiche         beame et al         put it 
negative proof complexity results uncover examples inherent intractability even
perfect choice strategies  positive proof complexity results give hope finding
good choice strategy 
work add new perspective kind rigorous result  try avoid
non deterministic choices components abstract solver still get positive proof
complexity results  main finding concrete family sat solvers
rely non determinism besides mild randomness least powerful bounded width
resolution  precise proof complexity result unit propagation rule
standard learning scheme considered state of the art solvers  totally random decision strategy needs o k   ln kn n k     conflicts deterministic restarts
detect unsatisfiability cnf formula n variables width k resolution
refutation  probability least      remarkably  analysis provide exact expression upper bound holds values n k particular bound
get asymptotic  another remarkable feature analysis insensitive
whether algorithm implements non chronological backtracking heuristic based decisions provided restarts often enough  provided performs totally random decisions
often enough  details given section   
result nice theoretical consequences  shall sketch briefly 
first  although explicitly designed purpose  sat solvers able solve instances   sat polynomial time since every unsatisfiable   cnf formula resolution
refutation width two  strongly  result interpreted showing widthk resolution simulated o k   ln kn n k     rounds unit clause propagation 
knowledge  tight connection width k resolution repeated application
width one methods unknown before  another consequence sat solvers
able solve formulas bounded branch width  and hence bounded treewidth  polynomial time  elaborate later paper  finally  partial automatizability
results ben sasson wigderson         follows sat solvers able solve
formulas polynomial size tree like resolution proofs quasipolynomial time 
formulas polynomial size general resolution proofs subexponential time 
concerning techniques  perhaps surprising proof main result
proceed showing width k refutation learned algorithm 
know produced proof much larger width  thing show
every width k clause refutation absorbed algorithm  means
behaves learned  even though might not  particular  literal
complement absorbed  algorithm correctly declares formula
unsatisfiable  sort analysis main technical contribution paper 
   

ficlause learning algorithms

    related work
first attempt compare power sat solvers power resolution
proof system made beame et al                main positive result
work clause learning specific learning scheme without restarts
provide exponentially shorter proofs proper refinements resolution tree 
regular  positive resolution  furthermore  show modification standard
solver allow multiple assignments variable would able simulate general
resolution efficiently  assuming ideal decision strategy  following work showed
requirement multiple assignments variable technical issue
avoided given cnf formula pre processed appropriately  hertel et al         
work avoid two maneuvers introducing concept clause absorption
help us analyze standard algorithms directly 
interestingly  clauses logical consequences input formulas  concept
clause absorption turns dual concept   empowerment introduced
independently pipatsrisawat darwiche           used   empowerment show
sat solvers without conceptual modification operation able simulate
general resolution efficiently  assuming ideal decision strategy  comparison 
goal settles weaker simulation result  bounded width resolution instead general
resolution  rely non determinism ideal decision  show
totally random decision strategy good enough purpose  provided restart often
enough  complete point  worth noting non automatizability results
alekhnovich razborov        indicate cannot expect efficient simulation
general resolution completely avoid non determinism time 
fact concepts discovered independently adds confidence belief
play role subsequent studies power sat solvers  indeed 
techniques recently extended show sat solvers totally random decision
strategy able efficiently simulate local consistency techniques general constraint
satisfaction problems  jeavons   petke        
    organization
section   introduce basic notation define algorithm analyze 
discuss dependence results choice learning scheme  restart policy
decision strategy used algorithm  section   starts elementary
facts runs algorithm  continues key definitions absorption
beneficial rounds  analysis running time algorithm  section  
contains discussion consequences  including implications formulas bounded
treewidth 

   clause learning algorithms
section define algorithm discuss choice components 
start preliminary definitions 
   note that  originally  weaker version   empowerment introduced pipatsrisawat darwiche
       

   

fiatserias  fichte    thurley

    preliminaries
let v    v            vn   fixed set propositional variables  literal propositional
variable x negation x  use notation x  x x  x  note xa
defined way assignment x   satisfies it          use
  a  literal     xa use   x a   clause set literals 
formula conjunctive normal form  cnf formula  set clauses  width
clause number literals it  following  formulas set
variables v every clause contains literals variables v  
two clauses    x                r   b    x                  s   define resolvent
b x res a  b  x                   r                   s    variable resolve on  x 
implicit simply write res a  b   clause may contain literal negation  note
resolvent res a  b  x  b x still well defined case  resolution
refutation cnf formula f sequence clauses c            cm cm  
clause ci sequence either belongs f resolvent previous clauses
sequence  length refutation number clauses sequence 
clause c  variable x  truth value         restriction c x  
constant   literal xa belongs c  c    x a   otherwise  write c x a
restriction c x   a 
partial assignment sequence assignments  x    a            xr   ar  
variables distinct  let partial assignment  say satisfies literal xa
contains x   a  say falsifies contains x     a  c clause  let
c  result applying restrictions x    a            xr   ar c  clearly order
matter  say satisfies c satisfies least one literals  i e  
c       say falsifies c falsifies literals  i e   c      set
clauses  let d  denote result applying restriction clause d 
removing resulting  s  call d  residual set clauses 
    definition algorithm
state sequence assignments  x    a            xr   ar   variables

distinct assignments marked decisions  use notation xi   ai
denote assignment xi   ai decision assignment  case xi called
decision variable  rest assignments called implied assignments  use
denote states  empty state one without assignments  define decision level
assignment xi   ai number decision assignments  x    a            xi   ai   
convenient  identify state underlying partial assignment
decision marks ignored 
      operation
algorithm maintains current state current set clauses d  four
modes operation default  conflict  unit  decision  algorithm starts
default mode empty state current state given cnf formula
current set clauses 
   

ficlause learning algorithms

default  sets variables satisfies clauses d  stop output
sat together current state s  otherwise  d s contains empty clause 
move conflict mode  otherwise  d s contains unit clause  move unit
mode  finally  control reaches point  move decision mode 
conflict  apply learning scheme add new clause c d  c empty
clause  stop output unsat  otherwise  apply restart policy decide whether
continue restart default mode current initialized
empty state  case continue further  repeatedly remove assignments
tail long c s     go unit mode 
unit  unit clause  xa   d s   add x   go back default
mode 


decision  apply decision strategy determine decision x   added
go back default mode 

guarantee correctness termination  learning scheme always add clause c
logical consequence d  c s   holds time added 
contains one variable maximum decision level  hard see
properties prevent clause learned twice  since number clauses
variables finite  implies termination  clauses characteristics
always exist include asserting clauses  zhang  madigan  moskewicz    malik 
      discussed section       
well known dpll procedure precursor algorithm where  conflict
mode  learning scheme never adds new clause  restart policy dictate
restart all  assignments removed tail latest decision


assignment  say x   a  replaced x     a  say dpll procedure
backtracks latest decision  contrast  modern sat solvers implement learning
schemes backtrack literal  determined learned clause  necessarily latest decision  called non chronological backtracking  besides learning
schemes non chronological backtracking  modern sat solvers implement restart
policies appropriate decision strategies  discuss choice components
algorithm section     
      runs algorithm
consider run algorithm started default mode empty state initial
set clauses d  either clause falsified variables set  run called
complete round started represent sequence states s            sm
algorithm goes through  s  empty state sm state
either variables set  falsified clause found  generally  round
initial segment s            sr complete round state either d sr contains
empty clause d sr contain unit clause  d sr contains empty clause
say round conclusive  round conclusive call inconclusive 
   

fiatserias  fichte    thurley

term inconclusive means reflect fact clause learned round 
particular   complete  round ends satisfying assignment inconclusive   
round s            sr   note             r   state si extends si  exactly

one assignment form xi   ai xi   ai depending whether unit decision
executed iteration  mode assigns variables  lead
confusion  identify round last state interpreted partial assignment 
particular  say round satisfies clause c c sr      falsifies
c sr    
    restart policy  learning scheme  decision strategy
following discuss choice learning scheme  restart policy
decision strategy used algorithm  discussion particularly focus
dependence results choice 
      restart policy
restart policy determines whether restart search clause learned 
important characteristic need restart policy dictate
restarts often enough  particular  analysis work equally well aggressive restart policies  one dictates restart every conflict 
less aggressive strategy allows bounded number conflicts restarts 
fact analysis insensitive follow monotonicity property
performance algorithm prove lemma    precisely 
follow monotonicity lemma decide use policy allows c    
conflicts restart  upper bound number required restarts
decrease  or stay same   upper bound number conflicts would
appear multiplied factor c  even though truth might even decrease
well  simplicity exposition  rest paper assume restart
policy dictates restart every conflict 
      decision strategy
decision strategy determines variable assigned next  value  again 
important characteristic need decision strategy
allow round totally random decisions often enough  here  totally random decision
defined follows  current state algorithm s  choose variable x
uniformly random among variables v appear s  value
       uniformly random independently choice x  thus  analysis
actually applies decision strategy allows bounded number rounds
heuristic based decisions totally random ones  precisely  allow say c    
rounds non random decisions random ones  number required restarts
conflicts would appear multiplied factor c  follow
   let us note definitions round  conclusive round inconclusive round differ slightly
given conference version paper  atserias  fichte    thurley         current
definitions make concepts robust 

   

ficlause learning algorithms

monotonicity lemma referred above  said  simplicity exposition assume
following every decision totally random 
      learning scheme
learning scheme determines clause added set clauses
conflict occurs  let s            sr conclusive round started set clauses

ends falsifying clause d  let xi   ai xi   ai i th assignment
round  annotate si clause ai reverse induction             r  
   let ar   clause falsified sr  


   r xi   ai decision  let ai   ai    
   r xi   ai implied  let bi clause bi  si 
unit clause  xai    let ai   res ai     bi   xi   clauses resolvable
xi   let ai   ai   otherwise 
quite clear construction ai resolution proof clauses
d  fact  resolution proof linear even trivial sense beame et al 
        call clause ai conflict clause  denotes maximum decision level
assignments sr   conflict clause called asserting clause contains exactly
one variable decision level d  asserting clauses  originally defined zhang et al         
capture properties conflict clauses learned virtually modern sat solver 
brevity  describe two concrete learning schemes detail  schemes see
work zhang et al         
decision learning scheme adds clause a  current set clauses
conflict  hard check a  asserting clause  furthermore  every literal
a  negation decision literal sr   important later on 
 uip learning scheme  stands  st unique implication point  one adds
clause ai r maximal subject condition ai asserting
clause 
following assume  tacitly  algorithm employs asserting
learning scheme  is  one whose learned clauses always asserting  except
empty clause 
      clause bookkeeping
mentioned analysis relies crucially assumption learned
clauses never removed current set clauses  however  practical sat solvers
periodically delete learned clauses save memory avoid overhead
introduce  thus interesting question whether results made work
without assumption  respect  strong proof complexity results nordstrom
       showing every small width resolution refutation made work
small clause space seems indicate assumption similar indeed needed 
another remark worth making point concerns width learned clauses 
since goal show algorithm simulate small width resolution  seems
natural ask whether restrict learning scheme learn clauses small width
   

fiatserias  fichte    thurley

only  mentioned introduction  analysis seem allow it  moreover 
recent results ben sasson johannsen        show that  general  learning short
clauses provably weaker scheme learning arbitrarily long clauses  thus 
examples ben sasson johannsen        small width resolution
refutations therefore show keeping long clauses actually required
case  conceivable might 

   analysis algorithm
section analyze running time algorithm  this 
however  introduce key technical concepts absorption beneficial
rounds  study important properties 
    runs algorithm
let r r  rounds  let c clause  say r  subsumes r if  decision
marks  every assignment r appears r    say r r  agree c
restrictions r r  variables c equal  every variable c either unassigned
both  assigned value both  say r branches c decision
variables r variables c  note properties agree c branches c
depend set variables c  define clauses simplify notation
later on 
prove two rather technical lemmas  goal show inconclusive rounds
robust respect order assignments made  example  first
lemma shows inconclusive round subsumes round agrees
decisions  fact need slightly stronger claim involves rounds two
different sets clauses 
lemma    let d  sets clauses d    let c clause  let r 
inconclusive round started d    then  every round r started branches
c agrees r  c  holds r  subsumes r 
proof  let r    s            sr    induction i  prove every             r   every
assignment si made r        nothing prove since s      let

    assume every assignment si  made r    let x   x  
last assignment si   since r r  agree c r branches c  every decision

assignment made r made r    takes care case x   a  suppose
last assignment x   si implied  means exists clause
a si     xa    since d  every assignment made si 
made r    necessarily x   appears r  r  inconclusive cannot leave
unit clauses unset 
next lemma shows universal quantifier conclusion previous
lemma void  addition  round chosen inconclusive 
lemma    let d  sets clauses d    let c clause  let r 
inconclusive round started d    then  exists inconclusive round r started
branches c agrees r  c  r  subsumes r 
   

ficlause learning algorithms

proof  let r     t            tt    define             t  set indices i th

assignment r  assigns variable c  i  let xi   ai xi   ai i th
assignment r   
construct round r    s            ss   started inductively  associated
sj set ij indices xi left unassigned sj   recall s 
empty state definition  hence i    i  define following process 
   sj falsifies clause sets variables v set   j stop 
   otherwise  unit clause  xa   d sj let sj   sj plus x   a 
   otherwise  ij non empty  let minimum element ij   let sj  

obtained adding decision xi   ai sj  
none cases applies set   j stop process 
construction r valid round started d  let us see r  subsumes r  let
set literals made true decisions r  construction  r r  agree
hence r  subsumes r lemma    furthermore  r inconclusive  d 
r  inconclusive  d r  contain empty clause  r  subsumes
r  d r contain empty clause  further  every variable c belongs
v r inconclusive  process stops     together fact r 
subsumes r  shows r r  agree c  note finally r branches c
construction 
    absorption
one key feature definition round inconclusive  residual set
clauses contain unit clauses and  particular  closed unit propagation 
means inconclusive round r started d  clause r
falsifies literals one  r must satisfy remaining literal  hence
well  besides d  clauses may property  important enough
deserve definition 
definition    absorption   let set clauses  let non empty clause let
xa literal a  say absorbs xa every inconclusive round started
falsifies    xa   assigns x a  say absorbs absorbs every
literal a 
naturally  absorbs xa say absorbed xa  
intuitively  one way think absorbed clauses learned implicitly  rest
section devoted make intuition precise  now  let us note
inconclusive rounds started d  every clause absorbed  agrees
given intuition since absence inconclusive rounds means unit clause propagation
applied produces empty clause  section show notion
clause absorption tightly connected concept   empowerment independently
introduced pipatsrisawat darwiche        
   

fiatserias  fichte    thurley

      properties absorption
continue  let us discuss key properties absorption  argued already
every clause absorbed d  give example showing may absorb
clauses  let set consisting three clauses
b

bc

b e 

example  clause c belong absorbed since every inconclusive round sets     must set c     unit propagation  every inconclusive
round sets c     must set     unit propagation  may absorb
clauses saw  note every non empty clause absorbed logical
consequence d  write    c  every satisfying assignment satisfies c 
lemma    let set clauses let c non empty clause  absorbs c 
   c 
proof  let full assignment satisfies clauses d  want show
satisfies c well  let r    s            sr   complete round algorithm started
sets decision variables set s  induction             r  
show si follow r stopped conflict therefore
sr   s  particular r inconclusive  falsifies literals c one  must
satisfy remaining one c absorbed  since r sets variables c sr   s 
means satisfies c 
remains show si every i      nothing show since

s      fix     assume si  s  let x   x   last assignment

si   case x   taken care assumption decision variables r set
s  suppose last assignment x   implied  means exists
clause a si     xa    since satisfies si  s  necessarily x
set s 
next  let us see converse lemma hold  namely  see
every implied clause absorbed  previous example  instance  note
bde consequence  resolve first third clause a  absorbed


 consider inconclusive round      e      
one interesting property illustrated example c resolvent
two absorbed clauses b  c absorbed literal      appears
b  example above  absorb b e b  b appears
clauses b b e d  whose resolvent precisely b e 
prove general fact next section objects study non absorbed
resolvents absorbed clauses 
next show three key monotonicity properties clause absorption  first
one motivated definition 
lemma    let e sets clauses let b non empty clauses 
following hold 
   belongs d  absorbs a 
   

ficlause learning algorithms

   b absorbs a  absorbs b 
   e absorbs a  e absorbs a 
proof  prove    assume contradiction literal   inconclusive
round s            sr started falsifies a     satisfy a  round
inconclusive  cannot a sr     means a sr        contradiction
definition round 
proof    let   literal b define b     b        consider two
different cases   
  b   and  absorbed d  inconclusive
round falsifies b     thus b absorbed case    a  let a          let
s            sr inconclusive round started falsifies b     falsifies a 
satisfies absorption  thus satisfies b  b absorbed case well 
remains prove    let   literal a           let r 
inconclusive round started e falsifies a    lemma    inconclusive
round r started falsifies a  subsumed r    absorbed
d  see r  and hence r    satisfies a 
      absorption empowerment
next goal show absorption empowerment dual notions  assignments   write every assignment   let us reproduce
definition   empowerment work pipatsrisawat darwiche         slightly
adapted better suit notation terminology 
definition      empowerment pipatsrisawat   darwiche         let set
clauses  let c non empty clause let xa literal c  let assignment
sets     b every literal b c    xa    say c   empowering via xa
respect d  following three conditions met 
   c logical consequence d  i e     c 
   repeated applications unit clause propagation d  yield empty clause 
   repeated applications unit clause propagation d  assign x a 
say xa empowering literal c  say c   empowering
  empowering via literal c 
preliminary version definition given pipatsrisawat darwiche       
second three conditions required 
definition absorption  see non empty clause absorbed
set clauses d  inconclusive round r started literal xa
r falsifies    xa   satisfy  xa    logical consequence
d  witnesses precisely fact   empowering via xa   show
converse true 
lemma    let set clauses  let c non empty clause    c 
let xa literal c  then  c   empowering via xa respect
absorb c xa  
   

fiatserias  fichte    thurley

proof  let c     c  xa    assume first absorb c xa   let r    s            sr  
inconclusive round started witnessing fact  i e  sr falsifies c  
assign x   a  particular sr   furthermore  every unit clause  y b   d 
  b sr   r inconclusive round  straightforward induction 
see every obtained repeated applications unit clause propagation
d  satisfies sr   directly implies conditions       definition
  empowerment  condition    met assumption 
converse  assume c   empowering via xa respect d 
show inconclusive round started falsifies c   assign
x   a  let r    s            sr   round started every decision assignment
chosen falsify literal c     that  among rounds property  assigns
many literals c   possible  clearly maximal round exists since one
make decision meets property 
shall show r round seek              r   let
maximal assignment si   let obtained repeated applications
unit clause propagation d i   let subset assignments
si   particular si   shall prove  induction i  si hence
si    
base case     trivial since s      assume     si  i   
i th assignment si decision assignment  construction falsifies literal
c   hence belongs   belongs   required 
i th assignment si implied distinguish two cases  whether belongs
not  implied assignment     required 
implied assignment     i  hence   i    then  since
si  i  induction hypothesis i  i    unit clause responsible
definition si appears process forming i  hence process forming
  therefore assignment  
completes induction shows  particular  sr   r   point   
definition   empowerment  r inconclusive  furthermore  point    definition
  empowerment  sr assign x   a  remains show sr falsifies c     first
note that  maximality r fact r inconclusive  every literal c  
assigned r  moreover  since decision assignments r chosen falsify
literals c     suffices show implied assignments r satisfy literal
c     thus  suppose contradiction   b implied assigned r
b literal c     let             r   y b   unit clause d si   since
si sr r assigned   b   unit clause  y b   d si appears
empty clause closure unit clause propagation d    contradicts point   
definition   empowerment completes proof 

let us note point condition    definition   empowerment
dropped  hypothesis    c dropped lemma    would
make   empowerment absorption literally dual other 
   

ficlause learning algorithms

    beneficial rounds
shall study key situation explains algorithm possibly simulate
resolution proofs  consider resolvent c   res a  b  two absorbed clauses b
itself  however  absorbed  goal study a  b c look
case  start showing c absorbed literal   c   
appears b  property held key discovering concept clauseabsorption relevance simulation resolution proofs  similar connection
clause learning observed pipatsrisawat darwiche         pointed
condition literal c appears b known merge
resolution  andrews        
lemma    let set clauses  let b two resolvable clauses absorbed
d  let c   res a  b     literal c absorb c     
appears b 
proof  let c   res a  b  y   let a       y  b     b    y   let
    xa literal c assume absorb c    exists
inconclusive round r falsifies c    xa   set x a  since   belongs c
c   a  b     belongs b  both  belongs both 
done  otherwise  assume without loss generality belongs
b  case r falsifies b    y   since b absorbed  set   r  r
falsifies    xa    since absorbed  x set r  contradicts choice
r x set a 
continue showing situation interest  always exist beneficial
round algorithm predicts eventual absorption 
definition    beneficial round   let set clauses  let non empty clause 
let xa literal a  let r inconclusive round started d  say r
beneficial xa falsifies    xa    branches    xa    leaves x unassigned 

yields conclusive round extended decision x     conclusive round obtained

extending r x   called beneficial xa   say r beneficial
beneficial literal a 
words  round started beneficial xa witness
absorb xa   minimal property  yet yields conflict
x set wrong value  thus  informally  beneficial round witness
almost absorbs xa  
lemma     let set clauses  let b two resolvable clauses
absorbed d  let c   res a  b   c non empty absorbed d 
round started beneficial c 
proof  identify literal xa c able build beneficial round c
xa  
let c   res a  b  y   let a       y  b     b    y   c
non empty absorbed d  literal xa c inconclusive round r 
   

fiatserias  fichte    thurley

started falsifies c     c    xa   set x a  x assigned
r  since otherwise would falsify c  c   a  b   absorbs
b  would satisfied r    shows x unassigned r   
let r inconclusive round started obtained applying lemma  
c   given inconclusive round r    claim r beneficial c xa  
round r falsifies c     agrees r  c     r branches c   and  r  subsumes
r  leaves x unassigned  finally  note r r  agree    y  b    y  

hence extending round r decision x   yields conclusive round  otherwise
would satisfied since b absorbed d 
    main technical lemma
start analyzing number complete rounds takes resolvent
two absorbed clauses absorbed function width  however  trivial
first determine number complete rounds takes sufficient prerequisite
absorption occurs  beneficial round 
lemma     let set clauses  let b two resolvable clauses
absorbed non empty resolvent c   res a  b   let n total
number variables d  k width c  every    let r            rt  denote
consecutive complete rounds algorithm started d  let d            dt 
denote intermediate sets clauses  then  probability none ri beneficial
k
c none di absorbs c et   n    
proof  let r            rt  denote consecutive complete rounds algorithm started
d  let d            dt  intermediate sets clauses  particular d   
ri round started di   every                let ri event ri
beneficial let di event di absorb c  want compute
upper bound joint probability events  note
 t 
  t   
  t   
 
j 
j 

 


 
 

pr
ri  
pr rj dj
ri
pr rj dj
ri
   
i  

j  

i  

j  

i  

hence  shall give appropriate upper bounds factors right hand side
inequality  this  let us first bound pr rj   dj   rj    dj            r    d 
below  conditions dj   rj    dj            r    d    lemma    implies
inconclusive round r started dj beneficial c xa c 
probability rj beneficial c bounded probability rj
beneficial c xa   therefore bound latter below 
first let us compute lower bound probability first k   decisions

decision strategy chosen falsify c    xa   k th choice x   a  probability
choices made least






k 
k 
 
 
 k    
 


k 
k
k
 n
  n   
  n k     
  n k     
  n
 n
note round started dj follows choices may even able
decisions corresponding assignments may implied  however 
   

ficlause learning algorithms



decision x   made  round following choices perform decisions
agree r c    xa   therefore stay subsumed r every new decision 

lemma    particular  right decision x   inconclusive  falsify
c    xa    leave x unset  lemma   performed assignments

r order  therefore addition x   make conclusive  follows
probability round beneficial c xa bigger 
consequently  probability rj conditional dj   rj    dj            r    d  bounded
   n k   therefore  equation    
pr

 t 
 
i  

 
ri



 
k
  k
et   n  
 n

second inequality used fact     x ex every real number x 
    bounds
tools given above  able prove main result paper 
simulation width k resolution algorithm  shall first give proof
algorithm employing decision learning scheme  proof easier
instructive  get slightly better bounds special case  afterwards 
see result asserting learning schemes general 
      decision scheme
fact makes decision easier analyze that  learning scheme 
occurrence beneficial round immediately yields absorption next step  indeed 
r beneficial c  branches c  means clause learned
complete round subset c  particular means next set clauses
absorb subset c  hence c well lemma    obtain following result
direct consequence lemma    
lemma     let set clauses  let b two resolvable clauses
absorbed non empty resolvent c   res a  b   let n total
number variables k width c  then     using decision
learning scheme  probability c absorbed current set clauses
k
restarts et   n    
proof  let r            rt  denote consecutive complete rounds algorithm started
d  let d            dt intermediate sets clauses  particular d   
ri round started di   every                let ri event
ri beneficial c let di event di absorb c  one
ri beneficial c  di   absorbs c  see this  note r branches
c  clause ci learned ri satisfies ci c  hence di   absorbs ci c
lemma    further  dt absorbs c  one di absorbs lemma
   hence 
probability c absorbed dt bounded pr  t 
i   ri di   
k 
t   n
lemma    implies bounded e
 
   

fiatserias  fichte    thurley

theorem     let f set clauses n variables resolution refutation
width k length m  probability least      algorithm started f   using
decision learning scheme  learns empty clause  m ln  m nk conflicts
restarts 
proof  resolution refutation must terminate application resolution rule
form res x  x   show     x     x  probability
    absorbed current set clauses  m ln  m nk restarts     
thus   x   x  absorbed probability least      case 
straightforward every complete round algorithm conclusive  particular 
round make decision conclusive  case empty
clause learned 
let c    c            cr       resolution proof     included width k
resolution refutation f   particular r m  every ci non empty width
k  let d    d            ds sequence clause sets produced algorithm
  rt   d  ln  r nk e  every             r   let ei event every
clause initial segment c            ci absorbed dit   let e negation  note
pr  e        vacuously hence pr  e               bound probability
ei hold conditional ei  cases  let pi   pr  e   ei    probability 
ci clause f   pi     lemma    ci derived two previous clauses 
k
pi et   n   lemma         r  choice t 
law total probability gives






pr e   pr e   ei  pr  ei      pr e   e i  pr e i 




pr e   ei    pr e i   



p
adding             r   together pr e        gives pr e r ri   pi
r
 
 r       since probability cr absorbed drt bounded pr  e r   
proof follows 
      asserting learning schemes general
shall study algorithm applying arbitrary asserting learning scheme 
analysis bit complex decision scheme since general clause
learned complete round r cannot assumed subset decisions r 
therefore show resolvent eventually absorbed little detour 
note proof overcome similar difficulties as  inspired by    proof
proposition   work pipatsrisawat darwiche        
need preparation  let c clause set clauses  let wc d
denote set literals   c exists inconclusive round started
beneficial c    let u  c d denote number variables left unassigned
inconclusive round started beneficial c    round
exists  define u  c d      note number well defined  follows easily
   thank anonymous reviewer pointing original proof proposition   work
pipatsrisawat darwiche        contained error corrected version paper
webpage  proof affected error 

   

ficlause learning algorithms

lemma   every inconclusive round started beneficial c   leaves
number variables unassigned  further  define
uc d  

x

u  c d  

 wc d

note c absorbed d  wc d     moreover  hypothesis
lemma     converse true  analogously  c absorbed d  uc d    
and  hypothesis lemma     converse true 
lemma     let d  sets clauses d    let b two resolvable
clauses absorbed d  let c   res a  b   then  wc d  wc d u  c d 
u  c d   wc d  
proof  wc d      nothing shown  otherwise  xa wc d    start
showing xa belongs wc d   let r  inconclusive round started d 
beneficial c    application lemma   r  c   xa   yields inconclusive round
r started following properties  r  subsumes r  agree c    xa   
r branches c    xa    show r beneficial c xa   remains

prove extending r x   yields conclusive round  let r round defined
extension  let c   res a  b  y   r falsifies b    y     y  
absorption  r cannot inconclusive  otherwise  would satisfied r  
proves wc d  wc d  
now  show u  c d  u  c d every   wc d     belong wc d 
nothing shown since u  c d      case  otherwise  let r  r inconclusive
rounds beneficial c   r  started d  r started d 
lemma    r  subsumes r  finishes proof 
lemma     let set clauses  let b two resolvable clauses
absorbed d  let c   res a  b   let r conclusive round started let
d  obtained adding asserting clause learned r  c empty
r beneficial c   c  u  c d    u  c d uc d    uc d  
proof  lemma    already know uc d  uc d u  c d  u  c d   therefore 
suffices demonstrate that  presence r  second inequality strict 
hypothesis  r beneficial c    let c   asserting clause learned r 
let r unique inconclusive round contained r beneficial c   
round contain last decision made r  lemma    number
assignments made two rounds started beneficial c  
same  hence  number variables left unassigned r equals u  c d   u  c d  
since least one variable unset 
u  c d      already u  c d    u  c d   therefore  assume u  c d    
particular  exists inconclusive round r  started d  beneficial c
   lemma   round r  subsumes r   definition asserting clauses  c    r
unit clause  since c   belongs d    absorbed d  hence r  satisfies c    
proves r  sets least one variable r therefore u  c d    u  c d  
   

fiatserias  fichte    thurley

two technical lemmas hand ready state prove analogue
lemma    arbitrary asserting learning schemes 
lemma     let set clauses  let b two resolvable clauses
absorbed non empty resolvent c   res a  b   let n total
number variables let k width c  then     using arbitrary
asserting learning scheme  probability c absorbed current set clauses
k
kn restarts kn et   n    
proof  let b   uc d     bt  let d            ds sequence sets clauses
produced algorithm  starting d    d  every             b   let xi   uc dit
let ei event xi b i 
bound probability c absorbed dbt above  since
event implies xb       suffices bound pr  e b    note pr  e        vacuously
hence pr  e               bound probability ei hold  law
total probability gives






pr e   pr e   ei  pr  ei      pr e   e i  pr e i 




pr e   ei    pr e i   
let pi   pr  e   ei    note pr  e   xi    b            hence pi
pr  e   xi    b        consider sequence d i  t             dit sets clauses
corresponding complete rounds algorithm  conditional xi    b     
event e implies xi   xi       hence none sets clauses absorbs
c  furthermore  lemma     none corresponding rounds beneficial c  thus 
k
lemma     pi et   n     adding             r   together



pb
k
pr e        gives pr e b i   pi b et   n     lemma follows necessarily
b kn 
able prove main theorem 
theorem     let f set clauses n variables resolution refutation width
k length m  probability least      algorithm started f   using arbitrary asserting learning scheme  learns empty clause  km ln  knm nk  
conflicts restarts 
proof  proof analogous proof theorem    lemma    playing role
lemma     choosing   d  ln  m kn nk e now 

   consequences

total number clauses width k n variables bounded  k nk  
 nk every n k  therefore  f n variables resolution refutation width
k  may assume length  nk following estimate

k

k
k
x
x
n  
n

   
n        n
 nk  
 

n 
i  

i  

obtain following consequence theorem    
   

ficlause learning algorithms

corollary     let f set clauses n variables resolution refutation
width k  probability least      algorithm started f   using arbitrary
asserting learning scheme  learns empty clause   k k      ln   kn n k  
conflicts restarts 
application corollary    that  even though explicitly defined
purpose  algorithm used decide satisfiability cnf formulas treewidth
k time o k   log kn n k      follows known fact every unsatisfiable formula treewidth k resolution refutation width k    
 alekhnovich   razborov        dalmau  kolaitis    vardi        atserias   dalmau 
      
interested producing satisfying assignment exists  proceed
self reducibility  assign variables one time  running algorithm log   n      times
assignment detect current partial assignment cannot extended
further  case choose complementary value variable  use
fact f treewidth k  f  x a treewidth k 
analysis  note since run algorithm correct probability least
     new assignment correct probability least
    log   n        

 
 
 n

means iterations correct probability least   
running time algorithm o k    log kn    n k     

  n
 n  



 
  



acknowledgments
thank martin grohe suggesting problem comparing power sat solvers
bounded width resolution  thank knot pipatsrisawat adnan darwiche
pointing connection   empowering absorption  thanks
peter jeavons comments conference version paper  anonymous
referees detailed comments 
first author supported part cycit tin           c       second
author supported part european research council  erc   grant        
third author supported part fellowship within postdoc programme
german academic exchange service  daad   preliminary version paper appeared
proceedings   th international conference theory applications
satisfiability testing  sat    atserias et al         

references
alekhnovich  m     razborov  a  a          satisfiability  branch width tseitin tautologies  proceedings   rd symposium foundations computer science
 focs        pp          ieee computer society 
alekhnovich  m     razborov  a  a          resolution automatizable unless w p 
tractable  siam j  comput                    
   

fiatserias  fichte    thurley

andrews  p  b          resolution merging  j  acm                 
atserias  a     dalmau  v          combinatorial characterization resolution width 
j  comput  syst  sci                  
atserias  a   fichte  j  k     thurley  m          clause learning algorithms many
restarts bounded width resolution  kullmann  o   ed    proceedings   th
international conference theory applications satisfiability testing  sat  
vol       lecture notes computer science  pp          springer 
bayardo  r  j     schrag  r  c          using csp look back techniques solve real world
sat instances  proceedings fourtheenth national conference artificial
intelligence  aaai     pp         
beame  p   kautz  h  a     sabharwal  a          understanding power clause
learning  gottlob  g     walsh  t   eds    proceedings eighteenth international joint conference artificial intelligence  ijcai      pp            morgan
kaufmann 
beame  p   kautz  h  a     sabharwal  a          towards understanding harnessing
potential clause learning  j  artif  intell  res   jair              
ben sasson  e     johannsen  j          lower bounds width restricted clause learning
small width formulas  strichman  o     szeider  s   eds    proceedings   th
international conference theory applications satisfiability testing  sat  
vol       lecture notes computer science  pp        springer 
ben sasson  e     wigderson  a          short proofs narrow   resolution made simple 
proceedings thirty first annual acm symposium theory computing
 stoc        pp         
dalmau  v   kolaitis  p  g     vardi  m  y          constraint satisfaction  bounded
treewidth  finite variable logics  cp     proceedings  th international
conference principles practice constraint programming  pp          london  uk  springer verlag 
fox  d     gomes  c  p   eds            proceedings twenty third aaai conference
artificial intelligence  aaai       chicago  illinois  usa  july              aaai
press 
hertel  p   bacchus  f   pitassi  t     gelder  a  v          clause learning effectively
p simulate general propositional resolution   fox    gomes  fox   gomes        
pp         
jeavons  p     petke  j          local consistency sat solvers  proceedings
  th international conference principles practice constraint programming
  cp       vol       lecture notes computer science  pp          springer 
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering efficient sat solver  proceedings   th design automation conference
 dac    
nieuwenhuis  r   oliveras  a     tinelli  c          solving sat sat modulo theories  abstract davisputnamlogemannloveland procedure dpll t  
journal acm                 
   

ficlause learning algorithms

nordstrom  j          narrow proofs may spacious  separating space width
resolution  siam j  comput                 
pipatsrisawat  k     darwiche  a          new clause learning scheme efficient unsatisfiability proofs   fox    gomes  fox   gomes         pp           
pipatsrisawat  k     darwiche  a          power clause learning sat solvers
restarts  gent  i  p   ed    proceedings   th international conference
principles practice constraint programming   cp       vol       lecture
notes computer science  pp          springer 
silva  j  p  m     sakallah  k  a          grasp   new search algorithm satisfiability 
proceedings ieee acm international conference computer aided design 
pp         
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning boolean satisfiability solver  international conference computeraided design  iccad     pp         

   


