journal of artificial intelligence research                  

submitted        published      

clause learning algorithms with many restarts
and bounded width resolution
albert atserias

atserias lsi upc edu

universitat politecnica de catalunya
barcelona  spain

johannes klaus fichte

fichte kr tuwien ac at

vienna university of technology
vienna  austria

marc thurley

marc thurley googlemail com

university of california at berkeley
berkeley  usa

abstract
we offer a new understanding of some aspects of practical sat solvers that are based on
dpll with unit clause propagation  clause learning  and restarts  we do so by analyzing
a concrete algorithm which we claim is faithful to what practical solvers do  in particular 
before making any new decision or restart  the solver repeatedly applies the unit resolution
rule until saturation  and leaves no component to the mercy of non determinism except
for some internal randomness  we prove the perhaps surprising fact that  although the
solver is not explicitly designed for it  with high probability it ends up behaving as width k
resolution after no more than o n k     conflicts and restarts  where n is the number of
variables  in other words  width k resolution can be thought of as o n k     restarts of the
unit resolution rule with learning 

   introduction
the discovery of a method to introduce practically feasible clause learning and non chronological backtracking to dpll based solvers layed the foundation of what is sometimes called
modern sat solving  silva   sakallah        bayardo   schrag         these methods
set the ground for new effective implementations  moskewicz  madigan  zhao  zhang   
malik        that spawned tremendous gains in the efficiency of sat solvers with many
practical applications  such great and somewhat unexpected success seemed to contradict
the widely assumed intractability of sat  and at the same time uncovered the need for a
formal understanding of the capabilities and limitations underlying these methods 
several different approaches have been suggested in the literature for developing a rigorous understanding  among these we find the proof complexity approach  which captures
the power of sat solvers in terms of propositional proof systems  beame  kautz    sabharwal              hertel  bacchus  pitassi    gelder        pipatsrisawat   darwiche 
       and the rewriting approach  which provides a useful handle to reason about the
properties of the underlying algorithms and their correctness  nieuwenhuis  oliveras   
tinelli         in both approaches  sat solvers are viewed as algorithms that search for
proofs in some underlying proof system for propositional logic  with this view in mind  it
was illuminating to understand that the proof system underlying modern solvers is always
c
    
ai access foundation  all rights reserved 

fiatserias  fichte    thurley

a subsystem of resolution  beame et al          in particular  this means that their performance can never beat resolution lower bounds  and at the same time it provides many
explicit examples where sat solvers require exponential time  complementing this is the
result that an idealized sat solver that relies on non determinism to apply the techniques
in the best possible way will be able to perform as good as general resolution  weak forms
of this statement were first established in beame et al               hertel et al         and
in the current form in pipatsrisawat   darwiche         as beame et al         put it  the
negative proof complexity results uncover examples of inherent intractability even under
perfect choice strategies  while the positive proof complexity results give hope of finding a
good choice strategy 
in this work we add a new perspective to this kind of rigorous result  we try to avoid
non deterministic choices on all components of our abstract solver and still get positive proof
complexity results  our main finding is that a concrete family of sat solvers that do not
rely on non determinism besides mild randomness is at least as powerful as bounded width
resolution  the precise proof complexity result is that under the unit propagation rule and
a standard learning scheme considered by state of the art solvers  the totally random decision strategy needs no more than o k   ln kn n k     conflicts and deterministic restarts to
detect the unsatisfiability of any cnf formula on n variables having a width k resolution
refutation  with probability at least      remarkably  the analysis will provide an exact expression for this upper bound that holds for all values of n and k and in particular the bound
we get is not asymptotic  another remarkable feature is that our analysis is insensitive to
whether the algorithm implements non chronological backtracking or heuristic based decisions provided it restarts often enough  and provided it performs totally random decisions
often enough  further details about this are given in section   
by itself this result has some nice theoretical consequences  which we shall sketch briefly 
first  although not explicitly designed for that purpose  sat solvers are able to solve instances of   sat in polynomial time since every unsatisfiable   cnf formula has a resolution
refutation of width two  more strongly  our result can be interpreted as showing that widthk resolution can be simulated by o k   ln kn n k     rounds of unit clause propagation  to
our knowledge  such a tight connection between width k resolution and repeated application
of width one methods was unknown before  another consequence is that sat solvers are
able to solve formulas of bounded branch width  and hence bounded treewidth  in polynomial time  we elaborate on this later in the paper  finally  from the partial automatizability
results of ben sasson and wigderson         it follows that sat solvers are able to solve
formulas having polynomial size tree like resolution proofs in quasipolynomial time  and
formulas having polynomial size general resolution proofs in subexponential time 
concerning our techniques  it is perhaps surprising that the proof of our main result
does not proceed by showing that the width k refutation is learned by the algorithm  for
all we know the produced proof has much larger width  the only thing we show is that
every width k clause in the refutation is absorbed by the algorithm  which means that it
behaves as if it had been learned  even though it might not  in particular  if a literal and
its complement are both absorbed  the algorithm correctly declares that the formula is
unsatisfiable  this sort of analysis is the main technical contribution of this paper 
   

ficlause learning algorithms

    related work
the first attempt to compare the power of sat solvers with the power of resolution as
a proof system was made by beame et al                the main positive result from
their work is that clause learning with a specific learning scheme and without restarts can
provide exponentially shorter proofs than proper refinements of resolution such as tree  or
regular  or positive resolution  furthermore  they show that the modification of a standard
solver to allow multiple assignments on the same variable would be able to simulate general
resolution efficiently  assuming an ideal decision strategy  following work showed that the
requirement for multiple assignments on the same variable is a technical issue that can be
avoided if the given cnf formula is pre processed appropriately  hertel et al          in
our work we avoid these two maneuvers by introducing the concept of clause absorption to
help us analyze the standard algorithms directly 
interestingly  for clauses that are logical consequences of the input formulas  our concept
of clause absorption turns out to be dual to the concept of   empowerment introduced
independently by pipatsrisawat and darwiche           they used   empowerment to show
that sat solvers without any conceptual modification in their operation are able to simulate
general resolution efficiently  again assuming an ideal decision strategy  for comparison 
our goal settles for a weaker simulation result  bounded width resolution instead of general
resolution  but does not rely on the non determinism of ideal decision  we show that the
totally random decision strategy is good enough for this purpose  provided we restart often
enough  to complete this point  it is worth noting that the non automatizability results of
alekhnovich and razborov        indicate that we cannot expect an efficient simulation of
general resolution and completely avoid non determinism at the same time 
the fact that both concepts were discovered independently adds confidence to our belief
that they will play a role in subsequent studies of the power of sat solvers  indeed  our
techniques were recently extended to show that sat solvers with a totally random decision
strategy are able to efficiently simulate local consistency techniques for general constraint
satisfaction problems  jeavons   petke        
    organization
in section   we introduce basic notation and we define the algorithm we analyze  we also
discuss the dependence of our results on our choice of the learning scheme  the restart policy
and the decision strategy used by the algorithm  section   starts with some elementary
facts about the runs of the algorithm  continues with the key definitions of absorption and
beneficial rounds  and then with the analysis of the running time of the algorithm  section  
contains a discussion of the consequences  including the implications for formulas of bounded
treewidth 

   clause learning algorithms
in this section we will define the algorithm and discuss our choice of its components  we
start with some preliminary definitions 
   note that  originally  a weaker version of   empowerment was introduced by pipatsrisawat and darwiche
       

   

fiatserias  fichte    thurley

    preliminaries
let v    v            vn   be a fixed set of propositional variables  a literal is a propositional
variable x or its negation x  we use the notation x  for x and x  for x  note that xa is
defined in such a way that the assignment x   a satisfies it  for a          we also use
a for    a  and for a literal     xa we use   for x a   a clause is a set of literals  and
a formula in conjunctive normal form  cnf formula  is a set of clauses  the width of a
clause is the number of literals in it  in the following  all formulas are over the same set of
variables v and every clause contains only literals on variables from v  
for two clauses a    x                r   and b    x                  s   we define the resolvent of a
and b on x by res a  b  x                   r                   s    if the variable we resolve on  x  is
implicit we simply write res a  b   a clause may contain a literal and its negation  note
that the resolvent res a  b  x  of a and b on x is still well defined in this case  a resolution
refutation of a cnf formula f is a sequence of clauses c            cm such that cm    and
each clause ci in the sequence either belongs to f or is a resolvent of previous clauses in
the sequence  the length of a refutation is the number m of clauses in the sequence  for
a clause c  a variable x  and a truth value a          the restriction of c on x   a is the
constant   if the literal xa belongs to c  and c    x a   otherwise  we write c x a for the
restriction of c on x   a 
a partial assignment is a sequence of assignments  x    a            xr   ar   with all
variables distinct  let  be a partial assignment  we say that  satisfies a literal xa if it
contains x   a  we say that  falsifies it if it contains x      a  if c is a clause  we let
c  be the result of applying the restrictions x    a            xr   ar to c  clearly the order
does not matter  we say that  satisfies c if it satisfies at least one of its literals  i e   if
c       we say that  falsifies c if it falsifies all its literals  i e   if c      if d is a set
of clauses  we let d  denote the result of applying the restriction  to each clause in d 
and removing the resulting  s  we call d  the residual set of clauses 
    definition of the algorithm
a state is a sequence of assignments  x    a            xr   ar   in which all variables are
d
distinct and some assignments are marked as decisions  we use the notation xi   ai
to denote that the assignment xi   ai is a decision assignment  in this case xi is called a
decision variable  the rest of assignments are called implied assignments  we use s and t to
denote states  the empty state is the one without any assignments  define the decision level
of an assignment xi   ai as the number of decision assignments in  x    a            xi   ai   
when convenient  we identify a state with the underlying partial assignment where all
decision marks are ignored 
      operation
the algorithm maintains a current state s and a current set of clauses d  there are four
modes of operation default  conflict  unit  and decision  the algorithm starts in
default mode with the empty state as the current state and the given cnf formula as
the current set of clauses 
   

ficlause learning algorithms

 default  if s sets all variables in d and satisfies all clauses in d  stop and output
sat together with the current state s  otherwise  if d s contains the empty clause 
move to conflict mode  otherwise  if d s contains a unit clause  move to unit
mode  finally  if control reaches this point  move to decision mode 
 conflict  apply the learning scheme to add a new clause c to d  if c is the empty
clause  stop and output unsat  otherwise  apply the restart policy to decide whether
to continue further or to restart in default mode with the current d and s initialized
to the empty state  in case we continue further  repeatedly remove assignments from
the tail of s as long as c s     and then go to unit mode 
 unit  for any unit clause  xa   in d s   add x   a to s and go back to default
mode 
d

 decision  apply the decision strategy to determine a decision x   a to be added to
s and go back to default mode 

to guarantee correctness and termination  the learning scheme will always add a clause c
that is a logical consequence of d  for which c s    holds at the time it is added  and that
contains at most one variable of maximum decision level  it is not hard to see that these
properties prevent such a clause from being learned twice  and since the number of clauses
on the variables of d is finite  this implies termination  clauses with these characteristics
always exist as they include the asserting clauses  zhang  madigan  moskewicz    malik 
      that will be discussed in section       
the well known dpll procedure is a precursor of this algorithm where  in conflict
mode  the learning scheme never adds any new clause  the restart policy does not dictate
any restart at all  and assignments are removed from the tail of s up to the latest decision
d
d
assignment  say x   a  which is replaced by x      a  we say that the dpll procedure
backtracks on the latest decision  in contrast  modern sat solvers implement learning
schemes and backtrack on a literal  as determined by the learned clause  which is not necessarily the latest decision  this is called non chronological backtracking  besides learning
schemes and non chronological backtracking  modern sat solvers also implement restart
policies and appropriate decision strategies  we discuss our choice of these components of
the algorithm in section     
      runs of the algorithm
consider a run of the algorithm started in default mode with the empty state and initial
set of clauses d  until either a clause is falsified or all variables are set  such a run is called
a complete round started with d and we represent it by the sequence of states s            sm
that the algorithm goes through  where s  is the empty state and sm is the state where
either all variables are set  or the falsified clause is found  more generally  a round is an
initial segment s            sr of a complete round up to a state where either d sr contains the
empty clause or d sr does not contain any unit clause  if d sr contains the empty clause
we say that the round is conclusive  if a round is not conclusive we call it inconclusive  the
   

fiatserias  fichte    thurley

term inconclusive means to reflect the fact that no clause can be learned from such a round 
in particular  a  complete  round that ends in a satisfying assignment is inconclusive   
for a round s            sr   note that for i              r   the state si extends si  by exactly
d
one assignment of the form xi   ai or xi   ai depending on whether unit or decision
is executed at that iteration  no other mode assigns variables  when this does not lead to
confusion  we identify a round with its last state interpreted as a partial assignment  in
particular  we say that the round satisfies a clause c if c sr      and that it falsifies it if
c sr    
    restart policy  learning scheme  and decision strategy
in the following we will discuss our choice of the learning scheme  the restart policy and
the decision strategy used by the algorithm  our discussion will particularly focus on the
dependence of our results on this choice 
      restart policy
the restart policy determines whether to restart the search after a clause is learned  the
only important characteristic that we need from the restart policy is that it should dictate
restarts often enough  in particular  our analysis will work equally well for the most aggressive of the restart policies  the one that dictates a restart after every conflict  as for
a less aggressive strategy that allows any bounded number of conflicts between restarts 
the fact that our analysis is insensitive to this will follow from a monotonicity property of
the performance of the algorithm that we will prove in lemma    more precisely  it will
follow from the monotonicity lemma that if we decide to use a policy that allows c    
conflicts before a restart  then the upper bound on the number of required restarts can
only decrease  or stay the same   only the upper bound on the number of conflicts would
appear multiplied by a factor of c  even though the truth might be that even those decrease
as well  for simplicity of exposition  for the rest of the paper we assume that the restart
policy dictates a restart after every conflict 
      decision strategy
the decision strategy determines which variable is assigned next  and to what value  again 
the only important characteristic that we need from the decision strategy is that it should
allow a round of totally random decisions often enough  here  a totally random decision
is defined as follows  if the current state of the algorithm is s  we choose a variable x
uniformly at random among the variables from v that do not appear in s  and a value a in
       also uniformly at random and independently of the choice of x  thus  our analysis
actually applies to any decision strategy that allows any bounded number of rounds with
heuristic based decisions between totally random ones  more precisely  if we allow say c    
rounds of non random decisions between random ones  then the number of required restarts
and conflicts would appear multiplied by a factor of c  again this will follow from the
   let us note that the definitions of round  conclusive round and inconclusive round differ slightly from
those given in the conference version of this paper  atserias  fichte    thurley         the current
definitions make the concepts more robust 

   

ficlause learning algorithms

monotonicity lemma referred to above  that said  for simplicity of exposition we assume in
the following that every decision is totally random 
      learning scheme
the learning scheme determines which clause will be added to the set of clauses when a
conflict occurs  let s            sr be a conclusive round started with the set of clauses d that
d
ends up falsifying some clause of d  let xi   ai or xi   ai be the i th assignment of the
round  we annotate each si by a clause ai by reverse induction on i              r  
   let ar   be any clause in d that is falsified by sr  
d

   for i  r for which xi   ai is a decision  let ai   ai    
   for i  r for which xi   ai is implied  let bi be any clause in d such that bi  si  is
the unit clause  xai i    and let ai   res ai     bi   xi   if these clauses are resolvable on
xi   and let ai   ai   otherwise 
it is quite clear from the construction that each ai has a resolution proof from the clauses
in d  in fact  the resolution proof is linear and even trivial in the sense of beame et al 
        we call each clause ai a conflict clause  if d denotes the maximum decision level
of the assignments in sr   a conflict clause is called an asserting clause if it contains exactly
one variable of decision level d  asserting clauses  originally defined by zhang et al         
capture the properties of conflict clauses learned by virtually any modern sat solver  for
brevity  we describe only two concrete learning schemes in detail  for other schemes see the
work of zhang et al         
the decision learning scheme adds clause a  to the current set of clauses after each
conflict  it is not hard to check that a  is an asserting clause  furthermore  every literal
in a  is the negation of some decision literal in sr   this will be important later on  the
 uip learning scheme  which stands for  st unique implication point  is the one that adds
a clause ai such that i  r is maximal subject to the condition that ai is an asserting
clause 
in the following we will assume  tacitly  that the algorithm employs some asserting
learning scheme  that is  one whose learned clauses are always asserting  except for the
empty clause 
      clause bookkeeping
it should be mentioned that our analysis relies crucially on the assumption that the learned
clauses are never removed from the current set of clauses  however  practical sat solvers
periodically delete some of the learned clauses to save memory and to avoid the overhead
they introduce  thus an interesting question is whether our results can be made to work
without the assumption  in this respect  the strong proof complexity results of nordstrom
       showing that not every small width resolution refutation can be made to work in
small clause space seems to indicate that an assumption similar to ours is indeed needed 
another remark worth making at this point concerns the width of the learned clauses 
since our goal is to show that the algorithm can simulate small width resolution  it seems
natural to ask whether we can restrict the learning scheme to learn clauses of small width
   

fiatserias  fichte    thurley

only  as mentioned in the introduction  our analysis does not seem to allow it  moreover 
recent results by ben sasson and johannsen        show that  in general  learning short
clauses only is a provably weaker scheme than learning arbitrarily long clauses  thus 
while the examples of ben sasson and johannsen        do not have small width resolution
refutations and therefore do not show that keeping long clauses is actually required in this
case  it is conceivable that it might 

   analysis of the algorithm
in this section we will analyze the running time of the algorithm  before we can do this 
however  we will have to introduce our key technical concepts of absorption and beneficial
rounds  and study some of their most important properties 
    runs of the algorithm
let r and r  be rounds  and let c be a clause  we say that r  subsumes r if  up to decision
marks  every assignment in r appears also in r    we say that r and r  agree on c if the
restrictions of r and r  to variables in c are equal  every variable in c is either unassigned
in both  or assigned to the same value in both  we say that r branches in c if all decision
variables of r are variables in c  note that the properties agree on c and branches in c
depend only on the set of variables of c  we define them for clauses to simplify notation
later on 
we prove two rather technical lemmas  the goal is to show that inconclusive rounds
are robust with respect to the order in which assignments are made  for example  the first
lemma shows that any inconclusive round subsumes any other round that agrees with it on
its decisions  in fact we will need a slightly stronger claim that involves rounds from two
different sets of clauses 
lemma    let d and d  be sets of clauses with d  d    let c be a clause  and let r  be an
inconclusive round started with d    then  for every round r started with d that branches
in c and agrees with r  on c  it holds that r  subsumes r 
proof  let r    s            sr    by induction on i  we prove that for every i              r   every
assignment in si is also made in r    for i     there is nothing to prove since s      let
d
i     and assume that every assignment in si  is also made in r    let x   a or x   a be
the last assignment in si   since r and r  agree on c and r branches in c  every decision
d
assignment made in r is also made in r    this takes care of the case x   a  suppose then
that the last assignment x   a in si is implied  this means that there exists a clause a
in d such that a si     xa    since d  d  and every assignment made in si  is also
made in r    necessarily x   a appears in r  because r  is inconclusive and cannot leave
unit clauses unset 
the next lemma shows that the universal quantifier in the conclusion of the previous
lemma is not void  in addition  the round can be chosen inconclusive 
lemma    let d and d  be sets of clauses with d  d    let c be a clause  and let r  be
an inconclusive round started with d    then  there exists an inconclusive round r started
with d that branches in c and agrees with r  on c  and such that r  subsumes r 
   

ficlause learning algorithms

proof  let r     t            tt    define i              t  as the set of indices i such that the i th
d
assignment of r  assigns some variable in c  for i  i  let xi   ai or xi   ai be the i th
assignment in r   
we will construct a round r    s            ss   started with d inductively  associated with
each sj is the set ij  i of indices i such that xi is left unassigned in sj   recall that s  is
the empty state by definition  hence i    i  we define the following process 
   if sj falsifies some clause in d or it sets all variables in v then set s   j and stop 
   otherwise  if there is a unit clause  xa   in d sj then let sj   be sj plus x   a 
   otherwise  if ij is non empty  let i be the minimum element of ij   and let sj   be
d
obtained by adding the decision xi   ai to sj  
if none of the above cases applies set s   j and stop the process 
by construction r is a valid round started with d  let us see that r  subsumes r  let
a be the set of literals made true by decisions in r  by construction  r and r  agree on
a and hence r  subsumes r by lemma    furthermore  r is inconclusive  by d  d 
and r  being inconclusive  d r  does not contain the empty clause  and as r  subsumes
r  also d r does not contain the empty clause  further  as every variable in c belongs
to v and r is inconclusive  the process stops with is     together with the fact that r 
subsumes r  this shows that r and r  agree on c  note finally that r branches in c by
construction 
    absorption
one key feature of the definition of a round is that if it is inconclusive  then the residual set of
clauses does not contain unit clauses and  in particular  it is closed under unit propagation 
this means that for an inconclusive round r started with d  if a is a clause in d and r
falsifies all its literals but one  then r must satisfy the remaining literal  and hence a as
well  besides those in d  other clauses may have this property  which is important enough
to deserve a definition 
definition    absorption   let d be a set of clauses  let a be a non empty clause and let
xa be a literal in a  we say that d absorbs a at xa if every inconclusive round started with
d that falsifies a    xa   assigns x to a  we say that d absorbs a if d absorbs a at every
literal in a 
naturally  when d absorbs a at xa we also say that a is absorbed by d at xa  
intuitively  one way to think of absorbed clauses is as being learned implicitly  the rest
of this section is devoted to make this intuition precise  for now  let us note that if there are
no inconclusive rounds started with d  then every clause is absorbed  this agrees with the
given intuition since the absence of inconclusive rounds means that unit clause propagation
applied on d produces the empty clause  in this section we also show that the notion
of clause absorption is tightly connected to the concept of   empowerment independently
introduced by pipatsrisawat and darwiche        
   

fiatserias  fichte    thurley

      properties of absorption
before we continue  let us discuss some key properties of absorption  we argued already
that every clause in d is absorbed by d  we give an example showing that d may absorb
other clauses  let d be the set consisting of the three clauses
a  b

bc

a  b  d  e 

in this example  the clause a  c does not belong to d but is absorbed by d since every inconclusive round that sets a     must set c     by unit propagation  and every inconclusive
round that sets c     must set a     also by unit propagation  while d may absorb other
clauses as we just saw  we note that every non empty clause absorbed by d is a logical
consequence of d  we write d    c  if every satisfying assignment of d satisfies c 
lemma    let d be a set of clauses and let c be a non empty clause  if d absorbs c 
then d    c 
proof  let s be a full assignment that satisfies all clauses in d  we want to show that s
satisfies c as well  let r    s            sr   be a complete round of the algorithm started with
d that sets all its decision variables as they are set in s  by induction on i              r   we
will show that si  s and it will follow that r is not stopped by a conflict and therefore
sr   s  in particular r is inconclusive  and if it falsifies all literals of c but one  it must
satisfy the remaining one because c is absorbed  since r sets all variables in c and sr   s 
this means that s satisfies c 
it remains to show that si  s for every i  for i     there is nothing to show since
d
s      fix i     and assume that si   s  let x   a or x   a be the last assignment in
d
si   the case x   a is taken care by the assumption that all decision variables of r are set as
in s  suppose then that the last assignment x   a is implied  this means that there exists
a clause a in d such that a si     xa    since s satisfies d and si   s  necessarily x
is set to a in s 
next  let us see that the converse of the above lemma does not hold  namely  we see
that not every implied clause is absorbed  in the previous example  for instance  note that
bde is a consequence of d  resolve the first and the third clause on a  but is not absorbed
d
d
by d  consider the inconclusive round d      e      
one interesting property that is illustrated by this example is that if c is the resolvent
of two absorbed clauses a and b  and c is not absorbed at some literal    then   appears
in both a and b  in the example above  d does not absorb b  d  e at b  and b appears in
the clauses a  b and a  b  d  e from d  whose resolvent is precisely b  d  e  we will
prove this general fact in the next section where the objects of study will be non absorbed
resolvents of absorbed clauses 
next we show three key monotonicity properties of clause absorption  where the first is
the one that motivated its definition 
lemma    let d and e be sets of clauses and let a and b be non empty clauses  the
following hold 
   if a belongs to d  then d absorbs a 
   

ficlause learning algorithms

   if a  b and d absorbs a  then d absorbs b 
   if d  e and d absorbs a  then e absorbs a 
proof  to prove    assume for contradiction that there is a literal   in a and an inconclusive
round s            sr started with d which falsifies a     but does not satisfy a  as the round is
inconclusive  we cannot have a sr     which means then that a sr        in contradiction
to the definition of round 
for the proof of    let   be a literal of b and define b     b        we consider two
different cases  if   
  a then a  b   and  as a is absorbed by d  there is no inconclusive
round which falsifies b     thus b is absorbed in this case  if    a  let a    a       and let
s            sr be an inconclusive round started with d which falsifies b     then it falsifies a 
and satisfies a by absorption  thus it satisfies b  and b is absorbed in this case as well 
it remains to prove    let   be some literal in a and a    a        let r  be an
inconclusive round started with e which falsifies a    by lemma    there is an inconclusive
round r started with d which falsifies a  and which is subsumed by r    as a is absorbed
by d  we see that r  and hence r    satisfies a 
      absorption and empowerment
our next goal is to show that absorption and empowerment are dual notions  for assignments    we write    if every assignment in  is also in   let us reproduce the
definition of   empowerment in the work of pipatsrisawat and darwiche         slightly
adapted to better suit our notation and terminology 
definition      empowerment in pipatsrisawat   darwiche         let d be a set of
clauses  let c be a non empty clause and let xa be a literal in c  let  be the assignment
that sets y      b for every literal y b in c    xa    we say that c is   empowering via xa
with respect to d  if the following three conditions are met 
   c is a logical consequence of d  i e  d    c 
   repeated applications of unit clause propagation on d  do not yield the empty clause 
   repeated applications of unit clause propagation on d  do not assign x to a 
we also say that xa is an empowering literal of c  we say that c is   empowering if it is
  empowering via some literal in c 
a preliminary version of this definition was given by pipatsrisawat and darwiche       
where the second of the three conditions was not required 
by the definition of absorption  we see that if some non empty clause a is not absorbed
by a set of clauses d  then there is an inconclusive round r started with d and a literal xa in
a such that r falsifies a    xa   but does not satisfy  xa    when a is a logical consequence
of d  this witnesses precisely the fact that a is   empowering via xa   we show that the
converse is also true 
lemma    let d be a set of clauses  let c be a non empty clause such that d    c  and
let xa be a literal in c  then  c is   empowering via xa with respect to d if and only if d
does not absorb c at xa  
   

fiatserias  fichte    thurley

proof  let c     c  xa    assume first that d does not absorb c at xa   let r    s            sr  
be an inconclusive round started with d witnessing this fact  i e  sr falsifies c   and does
not assign x   a  in particular   sr   furthermore  for every unit clause  y b   in d 
we have y   b in sr   as r is an inconclusive round  by a straightforward induction  we
see that every  obtained from  by repeated applications of unit clause propagation from
d  also satisfies   sr   this directly implies conditions    and    in the definition of
  empowerment  condition    is met by assumption 
for the converse  assume that c is   empowering via xa with respect to d  we have to
show that there is an inconclusive round started with d that falsifies c   but does not assign
x   a  let r    s            sr   be a round started with d in which every decision assignment
is chosen to falsify a literal in c     and that  among all rounds with this property  assigns as
many literals from c   as possible  clearly such a maximal round exists since the one that
does not make any decision meets the property 
we shall show that r is the round we seek  for each i              r   let i   be the
maximal assignment such that i  si   let i be obtained from i by repeated applications
of unit clause propagation from d i   and let i be the subset of assignments in i that are
also in si   in particular i  si   we shall prove  by induction on i  that si  i and hence
si   i  
the base case i     is trivial since s      assume now that i     and si   i    if
the i th assignment of si is a decision assignment  then by construction it falsifies a literal
in c   and hence belongs to   but then it also belongs to i   i and i as required  if
the i th assignment of si is implied we distinguish two cases  whether it also belongs to
 or not  if the implied assignment is also in   then it is in i   i and i as required  if
the implied assignment is not in   then i   i  and hence i   i    but then  since
si   i  by induction hypothesis and i   i    the unit clause responsible for the
definition of si appears in the process of forming i  and hence in the process of forming
i   therefore the assignment will also be in i  
this completes the induction and shows  in particular  that sr   r   by point    in the
definition of   empowerment  r is inconclusive  furthermore  by point    in the definition
of   empowerment  sr does not assign x   a  it remains to show that sr falsifies c     first
note that  by the maximality of r and the fact that r is inconclusive  every literal in c  
is assigned by r  moreover  since the decision assignments of r are chosen to falsify the
literals in c     it suffices to show that the implied assignments of r do not satisfy any literal
in c     thus  suppose for contradiction that y   b is an implied assigned in r and that
y b is a literal in c     let i              r  be such that  y b   is a unit clause in d si   since
si  sr  r and y is assigned to    b in   the unit clause  y b   in d si appears as the
empty clause in the closure under unit clause propagation of d    this contradicts point   
in the definition of   empowerment and completes the proof 

let us note at this point that if condition    in the definition of   empowerment is
dropped  then the hypothesis that d    c can also be dropped from lemma    this would
make   empowerment and absorption literally dual of each other 
   

ficlause learning algorithms

    beneficial rounds
we shall now study the key situation that explains how the algorithm can possibly simulate
resolution proofs  consider the resolvent c   res a  b  of two absorbed clauses a and b
which itself  however  is not absorbed  our goal is to study what a  b and c look like
in such a case  we start by showing that if c is not absorbed at a literal    c  then  
appears in both a and b  this property held the key for discovering the concept of clauseabsorption and its relevance to the simulation of resolution proofs  a similar connection to
clause learning was observed by pipatsrisawat and darwiche         where it is also pointed
out that the condition that some literal from c appears in both a and b is known as merge
resolution  andrews        
lemma    let d be a set of clauses  let a and b be two resolvable clauses that are absorbed
by d  and let c   res a  b   if   is a literal in c and d does not absorb c at    then  
appears in both a and b 
proof  let y be such that c   res a  b  y   and let a    a    y  and b     b    y   let
    xa be a literal in c and assume d does not absorb c at    then there exists an
inconclusive round r that falsifies c    xa   but does not set x to a  since   belongs to c
and c   a   b   we have that   belongs to a or to b  or to both  if it belongs to both 
we are done  otherwise  assume without loss of generality that it belongs to a but not to
b  in this case r falsifies b    y   and since b is absorbed  y is set to   in r  but then r
falsifies a    xa    and since a is absorbed  x is set to a in r  this contradicts the choice of
r where x was not set to a 
we continue by showing that in the situation of interest  there always exist a beneficial
round of the algorithm which predicts eventual absorption 
definition    beneficial round   let d be a set of clauses  let a be a non empty clause 
let xa be a literal of a  and let r be an inconclusive round started with d  we say that r is
beneficial for a at xa if it falsifies a    xa    branches in a    xa    leaves x unassigned  and
d
yields a conclusive round if extended by the decision x   a   the conclusive round obtained
d
by extending r by x   a is also called beneficial for a at xa   we say that r is beneficial
for a if it is beneficial for a at some literal in a 
in other words  a round started with d that is beneficial for a at xa is a witness that
d does not absorb a at xa   which is minimal with this property  and yet yields a conflict
when x is set to the wrong value  thus  informally  a beneficial round is a witness that d
almost absorbs a at xa  
lemma     let d be a set of clauses  let a and b be two resolvable clauses that are
absorbed by d  and let c   res a  b   if c is non empty and not absorbed by d  then
there is a round started with d that is beneficial for c 
proof  we identify a literal xa in c for which we are able to build a beneficial round for c
at xa  
let y be such that c   res a  b  y   and let a    a    y  and b     b    y   as c is
non empty and not absorbed by d  there is a literal xa in c and an inconclusive round r 
   

fiatserias  fichte    thurley

started with d which falsifies c     c    xa   but does not set x to a  also x is not assigned
a in r  since otherwise it would falsify c  and as c   a   b   and d absorbs both a and
b  both y and y would be satisfied by r    this shows that x is unassigned in r   
let r be the inconclusive round started with d which is obtained by applying lemma  
to c   and the given inconclusive round r    we claim that r is beneficial for c at xa   the
round r falsifies c     as it agrees with r  on c     also r branches in c   and  as r  subsumes
r  leaves x unassigned  finally  note that r and r  also agree on a    y  and b    y  
d
hence extending the round r by a decision x   a yields a conclusive round  otherwise both
y and y would be satisfied since both a and b are absorbed by d 
    main technical lemma
we will now start analyzing the number of complete rounds it takes until the resolvent of
two absorbed clauses is absorbed as a function of its width  however  as this is not trivial we
first have to determine the number of complete rounds it takes until a sufficient prerequisite
of absorption occurs  a beneficial round 
lemma     let d be a set of clauses  and let a and b be two resolvable clauses that
are absorbed by d and that have a non empty resolvent c   res a  b   let n be the total
number of variables in d  and k be the width of c  for every t     let r            rt  denote
the t consecutive complete rounds of the algorithm started with d  and let d            dt 
denote the intermediate sets of clauses  then  the probability that none of the ri is beneficial
k
for c and none of the di absorbs c is at most et   n    
proof  let r            rt  denote the t consecutive complete rounds of the algorithm started
with d  and let d            dt  be the intermediate sets of clauses  in particular d    d and
ri is a round started with di   for every i              t     let ri be the event that ri is
not beneficial and let di be the event that di does not absorb c  we want to compute an
upper bound for the joint probability of these events  note that
 t 
  t   
  t   
 
j 
fi j 
fi
 
y
y
 
fi  
fi
pr
ri  d i  
pr rj  dj fi
ri  d i 
pr rj fi dj 
ri  d i
   
i  

j  

i  

j  

i  

hence  we shall give appropriate upper bounds for the factors on the right hand side of
this inequality  to do this  let us first bound pr rj   dj   rj    dj            r    d  from
below  under the conditions dj   rj    dj            r    d    lemma    implies that there is
an inconclusive round r started with dj which is beneficial for c at some xa  c  the
probability that rj is beneficial for c is bounded from below by the probability that rj is
beneficial for c at xa   we will therefore bound the latter from below 
first let us compute a lower bound on the probability that the first k    decisions of the
d
decision strategy are chosen to falsify c    xa   and the k th choice is x   a  the probability
that these choices are made is at least




 

k 
k 
 
 
 k     
 


 k 
k
k
 n
  n    
  n  k     
  n  k     
  n
 n
note that a round started with dj that follows these choices may not even be able to do
some of the decisions as the corresponding assignments may be implied  however  before
   

ficlause learning algorithms

d

the decision x   a is made  a round following these choices will only perform decisions that
agree with r in c    xa   and therefore stay subsumed by r after every new decision  by
d
lemma    in particular  right before the decision x   a it will be inconclusive  it will falsify
c    xa    and it will leave x unset  also by lemma   it has performed the same assignments
d
as r up to order  and therefore the addition of x   a will make it conclusive  it follows
that the probability that the round will be beneficial for c at xa can only be bigger 
consequently  the probability of rj conditional on dj   rj    dj            r    d  is bounded
from above by     n k   therefore  by equation     we have
pr

 t 
 
i  

 
ri  d i



  t
k
   k
 et   n  
 n

where in the second inequality we used the fact that     x  ex for every real number x 
    bounds
with the tools given above  we are now able to prove the main result of the paper  the
simulation of width k resolution by the algorithm  we shall first give the proof for the
algorithm employing the decision learning scheme  not only is the proof easier and more
instructive  but also we get slightly better bounds for this special case  afterwards  we will
see the result for asserting learning schemes in general 
      the decision scheme
the fact that makes decision easier to analyze is that  for this learning scheme  the
occurrence of a beneficial round immediately yields absorption at the next step  indeed  if
r is beneficial for c  then it branches in c  which means that the clause learned in this
complete round is a subset of c  in particular this means that the next set of clauses will
absorb a subset of c  and hence c as well by lemma    we obtain the following result as
a direct consequence to lemma    
lemma     let d be a set of clauses  and let a and b be two resolvable clauses that
are absorbed by d and that have a non empty resolvent c   res a  b   let n be the total
number of variables in d and k be the width of c  then  for all t     using the decision
learning scheme  the probability that c is not absorbed by the current set of clauses after t
k
restarts is at most et   n    
proof  let r            rt  denote the t consecutive complete rounds of the algorithm started
with d  and let d            dt be the intermediate sets of clauses  in particular d    d
and ri is a round started with di   for every i              t     let ri be the event that
ri is not beneficial for c and let di be the event that di does not absorb c  if one of
the ri is beneficial for c  then di   absorbs c  to see this  note that as r branches in
c  the clause ci learned from ri satisfies ci  c  hence di   absorbs both ci and c by
lemma    further  dt also absorbs c  if one of the di absorbs it again by lemma
t    hence 
the probability that c is not absorbed by dt is bounded from above by pr  t 
i   ri  di   
k 
t   n
lemma    implies that this is bounded by e
 
   

fiatserias  fichte    thurley

theorem     let f be a set of clauses on n variables having a resolution refutation of
width k and length m  with probability at least      the algorithm started with f   using
the decision learning scheme  learns the empty clause after at most  m ln  m nk conflicts
and restarts 
proof  the resolution refutation must terminate with an application of the resolution rule
of the form res x  x   we will show that for both     x and     x  the probability that
    is not absorbed by the current set of clauses after  m ln  m nk restarts is at most     
thus  both  x  and  x  will be absorbed with probability at least      if this is the case  it
is straightforward that every complete round of the algorithm is conclusive  in particular 
the round that does not make any decision is conclusive  and in such a case the empty
clause is learned 
let c    c            cr       be the resolution proof of     that is included in the width k
resolution refutation of f   in particular r  m  and every ci is non empty and has width
at most k  let d    d            ds be the sequence of clause sets produced by the algorithm
where s   rt and t   d  ln  r nk e  for every i              r   let ei be the event that every
clause in the initial segment c            ci is absorbed by dit   and let e i be its negation  note
that pr  e        vacuously and hence pr  e          for i      we bound the probability that
ei does not hold conditional on ei  by cases  let pi   pr  e i   ei    be this probability  if
ci is a clause in f   we have pi     by lemma    if ci is derived from two previous clauses 
k
we have pi  et   n   by lemma     which is at most     r  by the choice of t 
the law of total probability gives
 



 

pr e i   pr e i   ei  pr  ei      pr e i   e i  pr e i 




 pr e i   ei    pr e i   
 


p
adding up over all i              r   together with pr e        gives pr e r  ri   pi 
r
 
 r       since the probability that cr is not absorbed by drt is bounded by pr  e r    the
proof follows 
      asserting learning schemes in general
we shall now study the algorithm applying an arbitrary asserting learning scheme  the
analysis is a bit more complex than that of the decision scheme since in general a clause
learned from a complete round r cannot be assumed to be a subset of the decisions in r 
therefore we can only show that the resolvent is eventually absorbed by a little detour  we
note that this proof has to overcome similar difficulties as  and is inspired by    the proof of
proposition   in the work of pipatsrisawat and darwiche        
we need some preparation  let c be a clause and d be a set of clauses  let wc d
denote the set of literals   in c such that there exists an inconclusive round started with
d that is beneficial for c at    let u  c d denote the number of variables left unassigned
by an inconclusive round started with d which is beneficial for c at    if no such round
exists  we define u  c d      note that this number is well defined  as it follows easily from
   we thank an anonymous reviewer for pointing out that the original proof of proposition   in the work
of pipatsrisawat and darwiche        contained an error that was corrected in the version of the paper
on their webpage  our proof is not affected by this error 

   

ficlause learning algorithms

lemma   that every inconclusive round started with d which is beneficial for c at   leaves
the same number of variables unassigned  further  define
uc d  

x

u  c d  

 wc d

note that if c is absorbed by d  then wc d     moreover  under the hypothesis of
lemma     the converse is also true  analogously  if c is absorbed by d  then uc d    
and  under the hypothesis of lemma     the converse is also true 
lemma     let d and d  be sets of clauses with d  d    let a and b be two resolvable
clauses that are absorbed by d  and let c   res a  b   then  wc d   wc d and u  c d  
u  c d for all    wc d  
proof  if wc d      nothing is to be shown  otherwise  for xa in wc d    we start by
showing that xa belongs to wc d   let r  be an inconclusive round started with d  which is
beneficial for c at    application of lemma   to r  and c   xa   yields an inconclusive round
r started with d with the following properties  r  subsumes r  both agree on c    xa   
and r branches in c    xa    to show that r is beneficial for c at xa   it only remains to
d
prove that extending r by x   a yields a conclusive round  let r be a round defined by
this extension  let y be such that c   res a  b  y   then r falsifies b    y  and a    y  
by absorption  r cannot be inconclusive  as otherwise  y and y would be satisfied by r  
this proves wc d   wc d  
now  we show that u  c d   u  c d for every   in wc d   if   does not belong to wc d 
nothing is to be shown since u  c d      in that case  otherwise  let r  and r be inconclusive
rounds beneficial for c at   such that r  is started with d  and r is started with d  by
lemma    r  subsumes r  which finishes the proof 
lemma     let d be a set of clauses  let a and b be two resolvable clauses that are
absorbed by d  and let c   res a  b   let r be a conclusive round started with d and let
d  be obtained from d by adding the asserting clause learned from r  if c is not empty
and r is beneficial for c at some    c  then u  c d    u  c d and uc d    uc d  
proof  by lemma    we already know that uc d   uc d and u  c d   u  c d   therefore 
it suffices to demonstrate that  in the presence of r  the second inequality is strict 
by hypothesis  r is beneficial for c at    let c   be the asserting clause learned by r 
let r be the unique inconclusive round contained in r which is beneficial for c at    this
is the round which does not contain the last decision made by r  by lemma    the number
of assignments made by any two rounds started with d and beneficial for c at   are the
same  hence  the number of variables left unassigned by r equals u  c d   and u  c d   
since at least one variable is unset 
if u  c d      then already u  c d    u  c d   therefore  assume that u  c d      in
particular  there exists an inconclusive round r  started with d  which is beneficial for c at
   by lemma   the round r  subsumes r   by the definition of asserting clauses  c    r is a
unit clause  and since c   belongs to d    it is absorbed by d  and hence r  satisfies c     this
proves that r  sets at least one more variable than r and therefore u  c d    u  c d  
   

fiatserias  fichte    thurley

with these two technical lemmas in hand we are ready to state and prove the analogue
of lemma    for arbitrary asserting learning schemes 
lemma     let d be a set of clauses  and let a and b be two resolvable clauses that
are absorbed by d and that have a non empty resolvent c   res a  b   let n be the total
number of variables in d and let k be the width of c  then  for all t     using an arbitrary
asserting learning scheme  the probability that c is not absorbed by the current set of clauses
k
after kn  t restarts is at most kn  et   n    
proof  let b   uc d   and s   bt  and let d            ds be the sequence of sets of clauses
produced by the algorithm  starting with d    d  for every i              b   let xi   uc dit
and let ei be the event that xi  b  i 
we will bound the probability that c is not absorbed by dbt from above  since this
event implies that xb       it suffices to bound pr  e b    note that pr  e        vacuously
and hence pr  e          for i      we bound the probability that ei does not hold  the law
of total probability gives
 



 

pr e i   pr e i   ei  pr  ei      pr e i   e i  pr e i 




 pr e i   ei    pr e i   
let pi   pr  e i   ei    and note that pr  e i   xi    b  i            hence we have pi 
pr  e i   xi    b  i        consider the sequence d i  t             dit of sets of clauses and
the corresponding complete rounds of the algorithm  conditional on xi    b  i      the
event e i implies that xi   xi       and hence none of the above sets of clauses absorbs
c  furthermore  by lemma     none of the corresponding rounds is beneficial for c  thus 
k
by lemma     we have pi  et   n     adding up over all i              r   together with
 


pb
k
pr e        gives pr e b  i   pi  b  et   n     the lemma follows as necessarily
b  kn 
we are now able to prove the main theorem 
theorem     let f be a set of clauses on n variables having a resolution refutation of width
k and length m  with probability at least      the algorithm started with f   using an arbitrary asserting learning scheme  learns the empty clause after at most  km ln  knm nk  
conflicts and restarts 
proof  the proof is analogous to the proof of theorem    with lemma    playing the role
of lemma     and choosing t   d  ln  m  kn nk e now 

   consequences

the total number of clauses of width k on n variables is bounded by  k nk   which is at most
 nk for every n and k  therefore  if f has n variables and a resolution refutation of width
k  we may assume that its length is at most  nk by the following estimate
 
 k

k
k
x
x
n  
i n
i
   
n        n 
  nk  
 
i
n 
i  

i  

we obtain the following consequence to theorem    
   

ficlause learning algorithms

corollary     let f be a set of clauses on n variables having a resolution refutation of
width k  with probability at least      the algorithm started with f   using an arbitrary
asserting learning scheme  learns the empty clause after at most   k k      ln   kn n k  
conflicts and restarts 
an application of corollary    is that  even though it is not explicitly defined for the
purpose  the algorithm can be used to decide the satisfiability of cnf formulas of treewidth
at most k in time o k   log kn n k      this follows from the known fact that every unsatisfiable formula of treewidth at most k has a resolution refutation of width at most k    
 alekhnovich   razborov        dalmau  kolaitis    vardi        atserias   dalmau 
      
if we are interested in producing a satisfying assignment when it exists  we proceed by
self reducibility  we assign variables one at a time  running the algorithm log   n      times
after each assignment to detect if the current partial assignment cannot be extended any
further  in which case we choose the complementary value for the variable  for this we use
the fact that if f has treewidth at most k  then f  x a also has treewidth at most k  for
the analysis  note that since each run of the algorithm is correct with probability at least
     each new assignment is correct with probability at least
     log   n         

 
 
 n

this means that all iterations are correct with probability at least    
running time of this algorithm is o k    log kn    n k     

  n
 n  



 
  

the

acknowledgments
we thank martin grohe for suggesting the problem of comparing the power of sat solvers
with bounded width resolution  we also thank knot pipatsrisawat and adnan darwiche
for pointing out the connection between   empowering and absorption  thanks also to
peter jeavons for comments on the conference version of this paper  and to the anonymous
referees for very detailed comments 
the first author was supported in part by cycit tin           c       the second
author was supported in part by the european research council  erc   grant         the
third author was supported in part by a fellowship within the postdoc programme of the
german academic exchange service  daad   a preliminary version of this paper appeared
in the proceedings of the   th international conference on theory and applications of
satisfiability testing  sat    atserias et al         

references
alekhnovich  m     razborov  a  a          satisfiability  branch width and tseitin tautologies  in proceedings of the   rd symposium on foundations of computer science
 focs        pp          ieee computer society 
alekhnovich  m     razborov  a  a          resolution is not automatizable unless w p 
is tractable  siam j  comput                    
   

fiatserias  fichte    thurley

andrews  p  b          resolution with merging  j  acm                 
atserias  a     dalmau  v          a combinatorial characterization of resolution width 
j  comput  syst  sci                  
atserias  a   fichte  j  k     thurley  m          clause learning algorithms with many
restarts and bounded width resolution  in kullmann  o   ed    proceedings of the   th
international conference on theory and applications of satisfiability testing  sat  
vol       of lecture notes in computer science  pp          springer 
bayardo  r  j     schrag  r  c          using csp look back techniques to solve real world
sat instances  in proceedings of the fourtheenth national conference on artificial
intelligence  aaai     pp         
beame  p   kautz  h  a     sabharwal  a          understanding the power of clause
learning  in gottlob  g     walsh  t   eds    proceedings of the eighteenth international joint conference on artificial intelligence  ijcai      pp            morgan
kaufmann 
beame  p   kautz  h  a     sabharwal  a          towards understanding and harnessing
the potential of clause learning  j  artif  intell  res   jair              
ben sasson  e     johannsen  j          lower bounds for width restricted clause learning
on small width formulas  in strichman  o     szeider  s   eds    proceedings of   th
international conference on theory and applications of satisfiability testing  sat  
vol       of lecture notes in computer science  pp        springer 
ben sasson  e     wigderson  a          short proofs are narrow   resolution made simple 
in proceedings of the thirty first annual acm symposium on theory of computing
 stoc        pp         
dalmau  v   kolaitis  p  g     vardi  m  y          constraint satisfaction  bounded
treewidth  and finite variable logics  in cp     proceedings of the  th international
conference on principles and practice of constraint programming  pp          london  uk  springer verlag 
fox  d     gomes  c  p   eds            proceedings of the twenty third aaai conference
on artificial intelligence  aaai       chicago  illinois  usa  july              aaai
press 
hertel  p   bacchus  f   pitassi  t     gelder  a  v          clause learning can effectively
p simulate general propositional resolution   in fox    gomes  fox   gomes        
pp         
jeavons  p     petke  j          local consistency and sat solvers  in proceedings of the
  th international conference on principles and practice of constraint programming
  cp       vol       of lecture notes in computer science  pp          springer 
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering an efficient sat solver  in proceedings of the   th design automation conference
 dac    
nieuwenhuis  r   oliveras  a     tinelli  c          solving sat and sat modulo theories  from an abstract davisputnamlogemannloveland procedure to dpll t  
journal of the acm                 
   

ficlause learning algorithms

nordstrom  j          narrow proofs may be spacious  separating space and width in
resolution  siam j  comput                 
pipatsrisawat  k     darwiche  a          a new clause learning scheme for efficient unsatisfiability proofs   in fox    gomes  fox   gomes         pp           
pipatsrisawat  k     darwiche  a          on the power of clause learning sat solvers
with restarts  in gent  i  p   ed    proceedings of the   th international conference
on principles and practice of constraint programming   cp       vol       of lecture
notes in computer science  pp          springer 
silva  j  p  m     sakallah  k  a          grasp   a new search algorithm for satisfiability 
in proceedings of ieee acm international conference on computer aided design 
pp         
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning in a boolean satisfiability solver  in international conference on computeraided design  iccad     pp         

   

fi