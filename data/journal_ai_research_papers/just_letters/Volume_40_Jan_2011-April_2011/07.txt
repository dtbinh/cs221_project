journal of artificial intelligence research                 

submitted       published     

on line planning and scheduling 
an application to controlling modular printers
wheeler ruml

ruml at cs unh edu

department of computer science
university of new hampshire
   academic way
durham  nh       usa

minh binh do
rong zhou
markus p  j  fromherz

minhdo at parc com
rzhou at parc com
fromherz at parc com

palo alto research center
     coyote hill road
palo alto  ca       usa

abstract
we present a case study of artificial intelligence techniques applied to the control of
production printing equipment  like many other real world applications  this complex domain requires high speed autonomous decision making and robust continual operation  to
our knowledge  this work represents the first successful industrial application of embedded
domain independent temporal planning  our system handles execution failures and multiobjective preferences  at its heart is an on line algorithm that combines techniques from
state space planning and partial order scheduling  we suggest that this general architecture may prove useful in other applications as more intelligent systems operate in continual 
on line settings  our system has been used to drive several commercial prototypes and
has enabled a new product architecture for our industrial partner  when compared with
state of the art off line planners  our system is hundreds of times faster and often finds
better plans  our experience demonstrates that domain independent ai planning based on
heuristic search can flexibly handle time  resources  replanning  and multiple objectives in
a high speed practical application without requiring hand coded control knowledge 

   introduction
it is a sustaining goal of artificial intelligence to develop techniques enabling autonomous
agents to robustly achieve multiple interacting goals in a dynamic environment  this goal
is not just intellectually attractive  it also happens to align perfectly with the needs of
many commercial manufacturing plants  in this paper  we focus on one particular manufacturing setting  high speed digital production printing systems  these large machines use
xerography to print the requested images on individual sheets of paper  unlike traditional
continuous feed offset presses  digital printers can treat each sheet differently  feeding different types and sizes of media  printing different kinds of images  and performing different
preparatory and finishing operations  often  a single integrated machine can transform
blank sheets into a complete document  such as a bound book or a folded bill in a sealed
envelope  it is sometimes even possible to process different kinds of jobs simultaneously on
c
    
ai access foundation  all rights reserved 

firuml  do  zhou    fromherz

the same equipment  a printer controller must plan quickly and reliably  otherwise expensive human intervention will be required  designing a high performance yet cost effective
controller for such machines is made more difficult by the current trend towards increased
modularity  in which each customers system is unique and includes only those components
that are most appropriate for their needs  we have been working closely with the xerox
corporation to explore architectures in which printing systems can be composed of literally hundreds of modules  possibly including multiple specialized printing modules  working
together at high speed 
in this paper  we demonstrate how techniques from artificial intelligence can be used to
control such machines  requests for print jobs become goals for the system to achieve  the
various actuators and mechanisms in the machine become actions and resources to be used
in achieving these goals  and sensors provide feedback on action execution and the state
of the system  to provide high productivity  and thus high return on investment for the
equipment owner   the planning and control techniques must be fast and produce optimal
or near optimal plans  to reduce the need for operator oversight and to allow the use of
very complex mechanisms  the system must be as autonomous and autonomic as possible 
because operators can make mistakes and even highly engineered system modules can fail 
the system must cope with execution failure and unexpected events  and because the
system must work with legacy modules in order to be commercially viable  its architecture
must tolerate components that are out of its direct control 
to meet these requirements  we present a novel architecture for on line planning  execution  and replanning that synthesizes techniques from state space planning  ghallab  nau 
  traverso        and partial order scheduling  smith   cheng         we develop new
heuristic evaluation functions for temporal planning that incorporate some of the effects of
resource constraints  although domain independent ai planning is often regarded as too
expensive for use in a soft real time setting  our system achieves good performance without
any hand coded control rules  despite the additional requirements of reasoning about temporal actions and resources  by avoiding domain dependent search control knowledge  it
becomes possible to use the same planner to run very different printing systems at full productivity  the success of our system has enabled a new modular product architecture that
can span multiple markets  much as previous work brought constraint based scheduling
into daily use in print shops and offices world wide  fromherz  saraswat    bobrow       
fromherz  bobrow    de kleer         our work can bring domain independent temporal
planning into continual widespread use by everyday people  our approach is practical and
efficient  and it showcases the flexibility inherent in viewing planning as heuristic search 
after discussing the application context in more detail  we will present an overview of
our system  followed by detailed discussion of its major aspects  nominal planning  exception handling  and multiple objectives  as we go  we will present empirical measurements
demonstrating that large printing systems can be controlled by our system while meeting
our real time requirements  in particular  section       describes a comparison with stateof the art generic off line planners that demonstrates that our planner finds plans hundreds
of times faster that are often of higher quality  and an on line appendix provides videos
of our planner controlling our hardware prototype  our integrated approach to on line
planning and scheduling allows us to achieve high throughput even for complex systems 
   

fion line planning and scheduling for modular printers

figure    a prototype modular printer built at parc  the system is composed of approximately     individually controlled modules  including four print engines 

we conclude the paper with a summary of general lessons we derived from building this
application 

   application context
in analogy to other parallel systems such as raid storage  our approach to modular printing
systems is called rack mounted printing  rmp   an rmp system can be seen as a network
of transports linking multiple printing engines  these transports are known as the media
path  figure   shows a four engine prototype printer built at the palo alto research center
 parc  from over     independently controlled modules  figure   provides a schematic
side view  showing the many possible paper paths linking the paper feeders to the possible
output trays   video   in the on line appendix  nominal simulation  presents an animation
of figure     multiple feeders allow blank sheets to enter the printer at a high rate and
multiple finishers allow several print jobs to run simultaneously  having redundant paths
through the machine enables graceful degradation of performance when modules fail  by
building the system out of relatively small modules  we enable easy reconfiguration of the
   

firuml  do  zhou    fromherz

figure    a schematic side view of the modular printer indicating the feeders  paper path 
and output trays 

components to add new modules and functionality  achieving these benefits  however  poses
a considerable control challenge 
the modular printing domain is reminiscent of mass customization  in which massproduced products are closely tailored and personalized to individual customers needs 
it is also similar to package routing or logistics problems  from a control perspective  it
involves planning and scheduling a series of sheet requests that arrive asynchronously over
time from the front end print job submission and rendering engine  the system runs at
high speed  with several sheet requests arriving per second  possibly for many hours  each
sheet request completely describes the attributes of a desired final product  there may be
several different sequences of actions that can be used to print a given sheet  for example 
in figure    a blank sheet may be fed from either of the two feeders  then routed to any
one of the four print engines  or through any combination of two of the four engines in the
case of duplex printing  and then to either finisher  unless the sheet is part of an on going
print job  
this on line planning problem is complicated by the fact that many sheets are in flight
simultaneously and the plan for the new sheet must not interfere with those sheets  most
actions require the use of physical printer components  so planning for later sheets must take
into account the resource commitments in plans already released for production  because
modern printers are highly configurable  can execute an large variety of jobs potentially
simultaneously  and have a large variety of constraints on feasible plans  hard coded or
locally reactive plans do not suffice  fromherz et al          in fact  printer engineers at
xerox delight in uncovering situations in which products from competing manufacturers 
who do not use model based planning  attempt to execute infeasible plans 
   

fiprinter
model

translator

on line planning and scheduling for modular printers

domain
description

planner

failures

translator

problem
description
sheet
description

constraints

stn

plans
time info
itineraries

goals

plan manager

rejections 
failures 
updates

machine
controller

figure    the system architecture  with the planning system indicated by the dashed box 

the planning system must decide how to print all requested sheets as quickly as possible
and thus it must determine a plan and schedule for each sheet such that the end time t of
the plan that finishes last is minimized  in other words  the planner attempts to minimize
the makespan of the combined global plan for all sheets  in essence optimizing the systems
overall throughput  typically there are many feasible plans for any given sheet request 
the problem is to quickly find one that minimizes t   the optimal plan for a sheet depends
not only on the sheet request  but also on the resource commitments present in previouslyplanned sheets  any legal series of actions can always be easily scheduled by pushing it
far into the future  when the entire printer has become completely idle  but of course this
is not desirable  this is an on line task because the set of sheets grows as time passes
and plan execution  i e   printing  interleaves with plan creation  in fact  because it is the
real world wall clock end time that we want to minimize and because the production of a
sheet cannot start until it is planned  the speed of the planner itself affects the value of a
plan  however  the system often runs at full capacity  and thus the planner usually need
only plan at the rate at which sheets are completed  which again may be several per second 
while challenging  the domain is also forgiving  feasible schedules can be found quickly 
sub optimal plans are acceptable  and plan execution is relatively reliable 
a printer controller works in an on line real time and continual planning environment
with three on going processes     on line arrival of new goals     planning for known goals 
and    execution of previously synthesized plans  figure   shows the inputs and outputs
of the planning system  with the domain model and sheet requests entering from the left
and communication with the low level control system on the right  the plan manager is
responsible for tracking the status of each goal and invoking the planner when necessary 
while planning and execution occur sequentially for any given sheet  these processes will
usually be interleaved between different sheets  figure   sketches the different steps in the
sheet plan life cycle managed by the plan manager  specifically  upon receiving  sheets are
put in the unplanned first in first out queue  sheets   and     the sheet planner then picks
one sheet at the time from the unplanned queue and tries to find a route plan for that
sheet  sheet     any plan when found is put in the queue of plans that havent yet been
sent to the printer controller  sheets   and     another plan manager process regularly
checks the planned queue to decide if the earliest starting time of any plan in that queue is
   

firuml  do  zhou    fromherz

sheet  
sheet  
sheet  

sheet  

sheet  

start time

sheet  

sheet  

sheet
ddescriptions
i ti

not yet
planned

being
planned

planned 
unsent

sent to
printer

figure    stages in the life of a sheet in the planning system 
close enough to the current wall clock time and send those plans to the printer controller
for execution  sheets   and     note that in the figure  time advances downward so plans
starting earlier are higher in the figure  sheets       and   finish in order  sheets   and  
belongs to a different job and can be scheduled to run concurrently 
in our application  there is an additional negotiation step after a plan is issued by the
planning system and before the plan is committed  first  each plan step is proposed by the
machine controller to the modules involved  if the individual hardware modules from all
steps accept their proposed actions  then the plan is committed  as we discuss below  this
commitment means that modules become responsible for notifying the controller if they fail
to complete an action or realize that they will not be able to perform a planned action in
the future  after a plan is confirmed  the planner cannot modify it  there is thus some
benefit in releasing plans to the machine controller only when their start times approach  if
not all modules confirm  then the machine controller notifies the planning system that the
proposed plan has been rejected  and the system must produce a new plan  this negotiation
process is one reason that we must find a complete plan before starting execution 
each module has a limited number of discrete actions it can perform  each transforming
a sheet in a known deterministic way  for many of these actions  the planner is allowed
to control its duration within a range spanning three orders of magnitude  milliseconds
to seconds   for example  the planner may choose to transport a sheet faster or slower
through a module in order to avoid collisions  actions may not split a sheet into two pieces
or join multiple sheets from different paths in the printer together  this means that a single
printed sheet must be created from a single blank sheet of the same size  thereby conflating
sheets with material and allowing plans to be a linear sequence of actions  in our domain 
adjacent actions must meet in time  sheets cannot be left lingering inside a printer after an
action has completed but must immediately begin being transported to its next location 
sheets are grouped into print jobs  a job is an ordered set of sheets  all of which must
eventually arrive at the same destination in the same order in which they were submitted 
multiple jobs may be in production simultaneously  although because sheets from different
   

fion line planning and scheduling for modular printers

jobs are not allowed to interleave at a single destination  the number of concurrent jobs is
limited by the number of destinations  i e   finisher trays  
currently  xerox uses a constraint based scheduler to control its high end and midrange printers  fromherz et al          the scheduler enumerates all possible plans when
the machine starts up and stores them in a database  when printing requests arrive on line 
the scheduler picks the first feasible plan from the database and uses temporal constraint
processing to schedule its actions  this decoupling of planning and scheduling is insufficient
for complex machines for two reasons  first  the number of possible plans is too large to
generate ahead of time  and indeed becomes infinite if loops are present  as in the printer
shown in figure    second  the precompiled plans can be poor choices given the existing
sheets in the system  for example  sheets should be fed from different feeders depending
on when the previous sheets were fed  how large they are  and how long they will dwell
in the print engines  which can be a function of sheet thickness and material   for high
performance  we must integrate planning and scheduling in an on line fashion 
occasionally a module will break down  failing to perform its committed action  modules
can also take themselves off line intentionally  for example to perform internal re calibration
or diagnosis  modules may be added or subtracted from the system and this information is
passed from the machine controller to the planning system at the right side of figure    the
vision of rmp is that the system should provide the highest possible level of productivity
that is safe  including running for long periods with degraded capabilities   meeting this
mandate in the context of highly modular systems means that precomputing a limited set
of canonical plans and limiting on line computation to scheduling only is not desirable  for
a large system of     modules  there are infeasibly many possible degraded configurations
to consider  depending on the capabilities of the machines  the number of possible sheet
requests may also make plan precomputation infeasible  furthermore  even the best precomputed plan for a given sheet may be suboptimal given the current resource commitments
in the printing machine 
to summarize  our domain is finite state  fully observable  and specifies classical goals
of achievement  however  planning is on line with additional goals arriving asynchronously 
actions have real valued durations and use resources  plans for new goals must respect
resource allocations of previous plans  execution failures and domain model changes can
occur on line  but are rare 

   system overview
a complete printing system encompasses many components  including print job submission 
print job management and planning  sheet management and planning  image rendering and
distribution  low level module control  media handling hardware  and exception handling 
this paper focuses on planning issues at the sheet level  including exception handling 
before discussing any one issue in great detail  this section provides an overview of those
topics that involve sheet planning most directly  including hardware control and exception
handling 
   for example  for the safety of the operator  the system should not continue to use a module whose access
cover has been opened  even if it were hypothetically possible to repair one portion of the module while
another is in use 

   

firuml  do  zhou    fromherz

time step
 

 

 

 

 

 

feed    
print

 

loop
finish

 

 

 

 

 
 

 
 

 

 

 

 

 

 

 
 

 

 

figure    two different schedules for printing a duplex sheet     after a simplex sheet     
launching the sheets out of order improves throughput 

figure   shows the basic architecture of the planning system and how it communicates
with the machine controller  the overall objective is to minimize the makespan of the
combined global plan for all sheets  in essence optimizing the systems throughput  we
approximate this by planning one sheet at a time  with the objective of having that sheet
finish as quickly as possible while respecting any ordering constraints it may have with other
sheets  sheets are optimally planned on an individual basis  in order of arrival  without
reconsidering the plans selected for previous sheets  in the figure  the plan manager calls
the planner for each sheet and records the resulting plan  to mitigate the restrictiveness of
this greedy scheme  we represent action times using temporal constraints instead of absolute
times  these constraints are stored in a simple temporal network  dechter  meiri    pearl 
       marked stn in the figure  by maintaining temporal flexibility as long as possible 
we can shift plans for older sheets later in time to make room for starting a new sheet earlier
if that improves overall machine throughput  while this may sound like a rare case  it can
be quite common  figure   illustrates how  for a simplex  single sided  cover sheet followed
by a duplex  double sided  sheet  it can be faster overall to launch the second sheet first 
although this basic architecture is specifically adapted to our on line setting  the planner uses no domain dependent search control knowledge  furthermore  this mix of goaldecomposable planning with cross goal resource constraints is quite common  and we believe
our framework can be useful in any ai system that needs to interleave real time decision
making  planning  and execution  such as robot operations 
    planning
we have implemented our own temporal planner using an architecture that is adapted to
this on line domain  as we will see below  the large number of potential plans for a given
sheet and the close interaction between plans and their schedules means that it is much
better to process scheduling constraints during the planning process and allow them to focus
planning on actions that can be executed soon  the planner uses state space regression 
with temporal information stored in the stn  the stn records a feasible interval for each
time point in each plan  time points are restricted to occur at specific single times only
when the posted constraints demand it  because the planner maintains the partial orders
between different actions in plans for different sheets through the stn while conducting
   

fion line planning and scheduling for modular printers

on lineplanner
   plan the next sheet
   if an unsent plan starts soon  then
  
foreach plan  from the oldest through the imminent one
  
clamp its time points to the earliest possible times
  
release the plan to the machine controller
plansheet
   search queue   final state 
   loop 
  
dequeue the most promising node
  
if it is the initial state  then return
    foreach applicable action
   
apply the action
   
add temporal constraints
   
foreach potential resource conflict
   
generate all orderings of the conflicting actions
  
enqueue any feasible child nodes
figure    outline of the hybrid planner
the backward state space search  it can be seen as a hybrid between state space search
and partial order planning  a sketch of the planner is given in figure    the outer loop
corresponds to the plan manager in figure   
after planning a new sheet  the outer loop checks the queue of planned sheets to see
if any of them begin soon  step     it is imperative to recheck this queue on a periodic
basis  so soon is defined to be before some constant amount after the current time and
we assume that the time to plan the next sheet will be smaller than this constant  the
value of this constant depends on the domain specifics such as communication delay or
module preparation time and is currently selected manually  if this assumption is violated 
we can interrupt planning the next sheet and start over later  as plans are released and
executed  resource contention will only decrease  so the time to plan the new sheet should
decrease as well  it is important that new temporal constraints are added by the outer loop
only between the planning of individual sheets  as propagation can affect feasible sheet end
times and thus could invalidate previously computed search node evaluations if planning
were underway 
while maintaining partial orderings between actions seems necessary to mitigate our
one sheet at a time greedy strategy  the planning for individual sheets need not necessarily
take the form of state space regression  we have considered a forward search strategy  such
as employed by many modern planners such as ff  hoffmann   nebel        or lama
 richter  helmert    westphal         initial investigation and preliminary empirical comparisons showed that while a progression planner is easier to implement and easier to extend
to handle additional domain complexities  the performance of the regression planner  using
the same heuristic  is significantly better in many problems in this domain  this seems
   

firuml  do  zhou    fromherz

to be due mainly to the temporal constraint enforcing that a given sheet should end after
the end time of all the previous sheets in the same batch  this constraint interacts well
with searching backward from the goal  immediately constraining the end time of the plan 
together with the constraint that actions must abut in time  many possible orderings for
resolving resource contention are immediately ruled out  for example  the current sheet
cannot be transported to its destination before the previous sheet in the same batch  in
addition  some orderings may immediately push the end time of the plan even later  further
informing the node evaluation function 
a planner that searches in the forward direction benefits slightly from avoiding logical
states that are unreachable from the initial state  however  without a similar temporal
constraint for the first action in the plan  few resource allocation orderings can be pruned
and the branching due to resource contention increases in direct proportion to the number
of plans for previous sheets maintained in the plan manager  furthermore  the end time
of the plan rarely changes until far into the planning processes  making the heuristic less
useful  in short  for the first sheet  the performance of forward or backward planners are
similar  while as the number of plans managed by the plan manager increases  the backward
planner seems to perform better 
due to details of the machine controller software  the planner must release plans to
the machine controller in the same order in which the sheet requests were submitted  this
means that sheets submitted before any imminent sheet must be released along with it  step
    only at this stage are the allowable intervals of the sheets time points forcibly reduced
to specific absolute times  step     sensibly enough  we ask that each point occur exactly
at the earliest possible time  because the temporal network uses a complete algorithm to
maintain the allowable window for each time point  a variation on cervoni  cesta    oddi 
       we are guaranteed that the propagation caused by this temporal clamping process
will not introduce any inconsistencies  the clamping happens before plans are issued  thus
we do not face the on line dispatchability problem of muscettola  morris  and tsamardinos
       
in our current on line setting  even though we plan for multiple sheets belonging to
different jobs  we build plans for a single sheet at the time  even if there are many submitted
sheets waiting to be planned  this strategy is reasonable given that sheets arrived in sequence
and  until the arrival of the last sheet  we do not know how many sheets are in each job and
when the planner will receive the individual sheet specifications  waiting until all sheets
are known is impractical as many production jobs  such as billing and payroll  involve jobs
with many thousands of sheets that can run for multiple days 
    control
as shown in figure    our system consists of two feeders on the left  two finishing trays
on the right  and four print engines with one in each of the four quadrants of the printer 
there are three high speed sheet highways that connect the feeders with the finisher trays 
sheets traveling on the top and bottom highways can be routed to and from the print engines
through the on ramps and off ramps  for increased modularity  the highways and the
on  and off ramps are made up of only two types of modules  straight through modules
and three way modules  each module has its own processor  a texas instruments f    
   

fion line planning and scheduling for modular printers

figure    the control system architecture 

dsp  all modules run the same distributed algorithms for state estimation and control
and communicate with each other via five controller area network  can  buses  plus a
dedicated data logging bus for debugging purposes  modules from the same quadrant
of the printer reside on the same can bus  except for the four print engines  which are
on a separate bus  sheets are moved by roller actuators  called nips  that are driven by
independently controlled stepper motors  for sensory feedback  each nip is equipped with
an edge detection sensor on both sides of the nip  in each three way module  there are three
solenoids that drive flipper actuators to direct the sheet along different paths 
figure   shows the control system architecture  which implements a hierarchical approach to distributed plan execution in which a sheet controller manages those module
controllers that are currently  or will soon be  in contact with the sheet  thus the sheet
controller group membership is dynamic over the life cycle of a sheet  starting from the
feeder all the way to the finisher tray  as soon as a new sheet is sent to the machine controller  a corresponding sheet controller is created that resides on a centralized processor 
even though all the module controllers it manages reside locally on the modules themselves 
note that a module controller may be processing commands from multiple sheet controllers 
as is the case of the module controller in the middle of figure    while still in contact with
the first sheet  it will soon be in contact with the second sheet 
because a sheet can span multiple modules in our printer  different nips acting on the
same sheet must be tightly synchronized in order to avoid damaging or jamming the sheet 
however  achieving exact synchronization over a network with uncertain communication
delays and stringent bandwidth can be challenging  moreover  one must consider the limited
computation power of a module in the design of such a synchronization scheme  for example 
our controller sample time is set at   milliseconds  thus  anything that takes longer than  
milliseconds to compute within a sampling period will not work  to eliminate the effects of
uncertain network delays  the control system uses a delay equalizer  which buffers all sensory
feedback messages until an apply time  to make sure that any sensor information is used at
the same time by all members of a group of module controllers for the same sheet  to save
bandwidth needed for synchronization  each controller uses internal models  or estimators 
to keep track of the states of the other controllers on the network in order to limit the need
   

firuml  do  zhou    fromherz

for communications  crawford  hindi  zhou    larner        hindi  crawford    fromherz 
      
the limited network bandwidth has fundamental impact on our choice of the control algorithm  initially  a linear quadratic gaussian  lqg   franklin  powell    workman       
controller was used  which has the nice property that its solution constitutes a linear dynamic feedback control law that is easily computed  however  the bandwidth requirements
of an lqg controller  which necessitates that more than a dozen way points per sheet be
sent over the network  has prompted the adoption of a different kind of controller based
on proximate time optimal servo  ptos   hindi  crawford  zhou    eldershaw       
franklin et al          which consumes much less bandwidth  for comparison  a ptos
controller reduces the number of intermediate way points from more than a dozen to two
per sheet  since ptos is based on time optimal control that uses either the maximum acceleration or deceleration to reach the target control state  this also maximizes the temporal
flexibility of the planning actions that our planner can use  thus improving on the overall
throughput of the printer 
    previous work
there has been much interest in the last    years in the integration of planning and scheduling techniques  hsts  muscettola        and ixtet  ghallab   laruelle        are examples of systems that not only select and order the actions necessary to reach a goal  but also
specify precise execution times for the actions  the visopt shopfloor system of bartak
       uses a constraint logic programming approach to incorporate aspects of planning
into scheduling  and the europa system of frank and jonsson        uses an novel representation based on attributes and intervals  all of these system use domain representations
quite different from the mainstream pddl language  fox   long        used in planning
research and all of them were designed for off line use  rather than controlling a system
during continual execution 
there is currently great interest in extending planning and scheduling techniques to handle more of the complexities found in real industrial applications  for example  pddl has
been extended to handle continuous quantities and durative actions  there are additional
dimensions to planning complexity besides expressivity  however  our work complements
the trend in current planning research to extend expressiveness by focusing on the middle ground between planning and scheduling  the domain semantics for printing are more
complex than in job shop scheduling but simpler in many ways than pddl     choice of
actions to perform is important in our domain  but managing resource conflicts is equally
important  as in classical scheduling  resource constraints are essential because the printer
modules often cannot perform multiple actions at once  but action selection and sequencing are also required because a given sheet can usually be achieved using several different
sequences of actions 
our domain formalization lies between partial order scheduling and temporal pddl 
because the optimal actions needed to fulfill any given print job request may vary depending on the other sheets in the machine  the sequence of actions is not predetermined
and classical scheduling formulations such as job shop scheduling or resource constrained
project scheduling are not expressive enough  this domain clearly subsumes job shop and
   

fion line planning and scheduling for modular printers

flow shop scheduling  precedence constraints can be encoded by unique preconditions and
effects  open shop scheduling  in which one can choose the order of a predetermined set
of actions for each job  does not capture the notion of alternative sequences of actions and
is thus also too limited  the positive planning theories of palacios and geffner        allow actions to have real valued durations and to allocate resources  but they cannot delete
atoms  this means that they cannot capture even simple transformations like movement
that are fundamental in our domain  in fact  optimal plans in our domain may even involve executing the same action multiple times  something that is always unnecessary in a
purely positive domain  however  the numeric effects and full durative action generality of
pddl    are not necessary 
because of the on line nature of the task and the unambiguous objective function  there
is an additional trade off in this domain between planning time and execution time that is
absent from much prior work in planning and scheduling  in our setting the set of sheets is
only revealed incrementally over time  unlike in classical temporal planning where the entire
problem instance is available at once  and in contrast to much work on continual planning
 desjardins  durfee  ortiz    wolverton         the tight constraints of our domain require
that we produce a complete plan for each sheet before its execution can begin  our domain
emphasizes on line decision making  which has received only limited attention to date  our
objective is to complete the known print jobs as soon as possible  so taking too long to
synthesize a slightly shorter plan is worse than quickly finding a near optimal solution 
this is especially true when rerouting in flight sheets during exception handling 
although we present our system as a temporal planner  it fits easily into the tradition
of constraint based scheduling  smith   cheng        policella  cesta  oddi    smith 
       the main difference is that actions time points and resource allocations are added
incrementally rather than all being present at the start of the search process  the central
process of identifying temporal conflicts  posting constraints to resolve them  and computing
bounds to guide the search remains the same  in our approach  we attempt to maintain
a conflict free schedule rather than allowing contention to accumulate and then carefully
choosing which conflicts to resolve first  our approach is perhaps similar in spirit to that
taken by the ixtet system  ghallab   laruelle        
our basic approach of coordinating separate state space searches via temporal constraints may well be suitable for other on line planning domains  by planning for individual
print jobs and managing multiple plans at the same time  our strategy is similar in spirit to
planners that partition goals into subgoals and later merge plans for individual goals  wah
  chen        koehler   hoffmann         in our framework  even though each print job
is planned locally  the plan manager along with the global temporal database ensures that
there are no temporal or resource inconsistencies at any step of the search  it would be
interesting to see if the same strategy could be used to solve partitionable strips planning
problems effectively 

   nominal sheet planning
the sheet planner builds a plan for each sheet of a job using a combination of regression
state space planning and partial order scheduling  it plans by adding one module action
at a time  starting from a finisher until the sequence of actions reaches a feeder  adding
   

firuml  do  zhou    fromherz

an action to a sheets itinerary  i e   plan  causes resource allocations to be made on any
resources required for the execution of that action  given the media path redundancies in
rmp  the planner usually faces multiple choices about which action to add at each planning
step  to organize this search  the planner uses best first a  search with a planning graph
heuristic  adjusted with resource conflicts  that estimates how promising each plan suffix
is  unlike traditional regression planners  to maintain maximum flexibility  all action times
such as the start and end of each action and each resource allocation are represented as
flexible time points instead of absolute times  temporal constraints are used to represent the
durations of actions and to resolve resource contention by imposing orderings among actions 
the planner attempts to minimize the makespan of the combined global plan for all sheets 
in essence optimizing the systems throughput  the planner uses no domain dependent
search control knowledge  allowing us to use the same planner to run very different printing
systems at full productivity 
    domain language
we used a two tiered approach to represent the rmp domain  at the highest level  we
use a specialized language that makes it easier for xerox engineers to model their printers 
this language specifies printer configurations as components that are connected to each
other  basic components can have different capabilities and components can be grouped in
a hierarchical structure  the model files in this format are then automatically translated
into a variation of pddl     which is then fed into our planner  the automatic translation
process instantiates the primitive modules and then converts each modules capabilities
into durative actions  the movement of a sheet and the marking actions can be directly
translated from the printer model into traditional logical preconditions and effects that test
and modify attributes of the sheet  following the spirit of compositionality of earlier work
 fromherz et al          the model of the system can be automatically synthesized from
models of the individual components 
as in pddl  we distinguish between two types of input to the planner  before planning
begins  a domain description containing predicate and action templates is provided  then
the problem descriptions arrive on line  containing initial and goal states  which are sets
of literals describing the starting and desired configurations  our action representation
is similar to the durative actions in pddl     with the notable difference that we use
explicit representation of resources  actions can specify the exclusive use of different types
of resources for time intervals specified relative to the actions start or end time  executing
one action may involve allocating multiple resources of various types such as  unit capacity 
multi capacity  cyclic  and state resources  our actions also specify real valued duration
bounds  that is  one can specify upper and lower bounds and then let the planner choose
the desired duration of the action  this is critical to modeling controllable speed paper
paths  which can be very useful in practice  while pddl allows the specification of duration
ranges  we are not aware of any ipc benchmark that does so or any general purpose planner
that supports it 
to summarize  the core part of a domain file is a set of actions  each of which corresponds
to a capability of some component in a printer and is a   tuple a   hpre  eff  dur  alloci 
where 
   

fion line planning and scheduling for modular printers

printsimplexandinvert  sheet   side   color   image 
preconditions  location  sheet  printer  input 
blank  sheet 
sideup  sheet  side 
opposite  side   other side 
canprint markingengine   color 
effects  location  sheet  printer  output 
location  sheet  printer  input 
hasimage  sheet  side  image 
blank  sheet 
sideup  sheet   side 
sideup  sheet  other side 
duration        seconds       seconds 
set up time      second
allocations  markingengine at  start       for     seconds
figure    a simple action specification 
 pre and eff are sets of literals representing the actions preconditions and effects 
 dur is a pair hlower  upperi of scalars representing the upper and lower bounds on
action duration 
 alloc is a set of triplets hres  offset  duri indicating that action a starting at time sa
uses resource res during an interval  sa   offset  sa   offset   dur   the constraints on
different types of resources are 
 unit capacity  this type of resource is non sharable and thus all allocations for
a given resource of this type should not overlap  this provides a good model of
physical space and is the most common type of resource used in our planner 
 cyclic  cyclic resource is one special type of unit capacity resources for which
there are repeated durations during which the resources are unavailable for the
actions selected by the planner  for example  the unavailable durations may
represent routine automatic maintenance of some modules 
 multi capacity  there is an upper bound on the maximum number of allocations
for a given resource of this type that can overlap  moreover  allocations follow
a first in first out order  thus  if there are two allocations a     sa    ea    and
a     sa    ea    then sa   sa  implies ea   ea   
 state resource  the resource can be labeled using one of a set of states  allocations for a resource of this type can overlap if and only if they require the
resource to be in the same state 
a simple example is given in figure    set up time refers to the required time between
when an action is committed and its execution beginscertain actions can require extensive
preparation on the part of the module before the sheet arrives and the action is really
   

firuml  do  zhou    fromherz

background 
initial 

goal 

print job id 

sheet   
location sheet     some feeder 
blank sheet    
sideup sheet    side   
location sheet     upper finisher 
hasimage sheet     side    image   
hasimage sheet     side    image   
color sheet     side    color 
color sheet     side    black   white 
 

figure    a sample sheet specification 
performed  for resource usage  the printsimplexandinvert action in figure   specifies
exclusive use of the markingengine from     seconds after the start of the action until    
seconds later  printer modules with multiple independent resources or with actions that
have short allocation durations relative to the overall action duration can work on multiple
sheets simultaneously  in pddl  arbitrary predicates can be made to hold at the start 
end  or over the duration of an action  this expressivity is not needed in our domain and
thus we can assume a simple semantics similar to that using in the tgp planner of smith
and weld        in which      delete effects happen at start      add effects happen at
end      preconditions that are deleted are at start  and     preconditions that are not
deleted are over all  in addition to sheet dependent literals  sometimes it is convenient
to specify actions using preconditions that refer to literals that are independent of the
particular goals being sought  this background knowledge about the domain is supplied
separately in the machine specification  although it could also be compiled into the action
specifications  in our example  the possible colors that engines can put on a sheet of paper
 e g   black white  color  custom color  or default sides of papers  e g   front  back  are
specified in this way  they are represented similarly to the constant concept in pddl 
in addition to the static domain description  the on line sheet requests are modeled by
initial and goal state pairs describing the starting and desired sheet configurations  each
new initial goal pair defines a new object  the sheet  and the associated literals for the
planner to track  specifically  a problem description for a particular sheet is a   tuple of
hjob  initial  goal  backgroundi  where job is the id of the print job that that sheet belongs
to and initial  goal  and background are sets of literals 
a simple example sheet specification is given in figure    in this example  some feeder
is a virtual location where all sheet sources are placed and upper finisher is one particular
finisher where all sheets that belong to print job   need to be routed to  in terms of figure   
the feeder location literal is added to the goal by the plan manager  which maintains a
table of active jobs and the finisher assigned to each  finisher assignment is handled by
extracting the finisher selected by the planner in its plan for the first sheet of the job 
because finishing requires actions in the plan and actions are never reconsidered  only
rescheduled   the planner can never reconsider a jobs finisher assignment  even if it hasnt
begun production yet 
   

fion line planning and scheduling for modular printers

given a domain description  top left of figure    and a low level delay constant tdelay
capturing the latency of the machine controller software  the planner then accepts a stream
of sheets arriving asynchronously over time  note that sheets may belong to different print
jobs being printed in parallel  within their print job  sheets need to be routed to the same
finisher  among multiple finishers  and finish in order  this stream corresponds to the
standard notion of a pddl problem instance  for each sheet  the planner must eventually
return a plan  a sequence of actions labeled with start times  in absolute wall clock time 
that will transform the initial state into the goal state  any allocations made on the same
unit capacity resource by multiple actions must not overlap in time  state and multi capacity
resources have different constraints as described earlier   happily  plans for individual sheets
are independent except for these interactions through resources  additional constraints on
the planner include 
 plans for sheets with the same print job id must finish at the same destination 
 plans for sheets with the same print job id must finish in the same order in which the
jobs were submitted 
 the first action in each plan must not begin sooner than tdelay seconds after it is issued
by the planner  with tdelay represents the delays in communication and negotiation
with the printer module controller  
 subsequent actions must begin at times that obey the duration constraints specified
for the previous action  thus it is assumed that the previous action ends just as the
next action starts  
    temporal reasoning
printer control is a rich temporal domain with real time constraints   i  between wall clock
time and the plans for individual sheets      between plans for different sheets  and     between the planner and the machine controller  thus  fast temporal constraint propagation 
consistency checking  and querying are extremely important in our planner  we maintain
the temporal constraints using a simple temporal network  stn   dechter et al         
represented by the box named stn in figure    essentially  the network contains a set of
temporal time points ti and constraints between them of the form lb  ti  tj  ub   the
time points managed by the stn include action start and end times and resource allocation
start and end times  temporal constraints maintained in the stn are 
 constraints on wall clock action start time 
 action start and end times should be within the action duration range 
 constraints between action start time and resource allocation by that action  and
 conflicts for various types of resources 
because we use an a  search strategy that maintains multiple open search nodes  there
is a separate stn for each node  temporal constraints are added to the appropriate stn
when a search node is expanded  whenever a new constraint is added  propagation tightens
   

firuml  do  zhou    fromherz

planning time  in seconds 

idpc
ac  

 

 

 
  

  

  

  

   

sheet number

figure     simple arc consistency is faster than incremental directed path consistency for
maintaining our stns 

the upper and lower bounds on the domain of each affected time point  while this can lead
to more memory usage and extra overhead  it allows us not having to deal with temporal
constraint retraction  which is needed if a single stn is used for multiple search nodes 
retracting temporal constraints from an stn is a complicated and time consuming process 
because the planner must run indefinitely  we perform garbage collection on time points in
the stn between sheet planning episodes  harvesting those that lie in the past 
all time points are flexible until the plans they belong to are sent to the machine
controller  after planning a new sheet  the plan manager checks the queue of planned
sheets to see if there are any that could begin soon  if there are  those plans are released
to the machine controller to execute  new temporal constraints are added that freeze the
start and end times of actions belonging to plans sent to the controller  those time points
are frozen at the earliest possible wall clock time as indicated by the stn based on its
constraint set  those constraints can cause significant propagation and in turn     freeze
the start and end times of resource allocations related to actions in the frozen plans  and
    tighten the starting times of actions in the remaining plans 
the original representation of an stn as a complete matrix of time relations updated
by all pairs shortest paths  dechter et al         is much too inefficient for our purposes 
we have implemented two versions of the stn  one uses an incremental directed path
consistency  idpc  algorithm  chleq         which may change the values on edges in
the constraint graph as well as introduce new edges but requires only linear time to find
the minimum and maximum interval between any two time points in the database  the
other uses arc consistency  cervoni et al         and maintains for each point its minimum
   

fion line planning and scheduling for modular printers

and maximum times from t    the reference time point  in this latter method  one cannot
easily obtain the exact relations between arbitrary time points  only their relations with t   
however  as long as inconsistency can be efficiently detected when constraints are added 
we do not need to query the relations of arbitrary pairs of points  and the efficiency gains
are welcome  new arcs are never added to the network during propagation and existing
ones are not modified  which means that copying the network for a new search node does
not entail copying all the arcs  as the figure    attests  this results in dramatic time
savings and this technique is used in our current implementation  we further improved our
implementation by     using change flags to facilitate faster cycle detection for temporal
consistency checking and     converting all times and durations to integer values  with user
defined precision  to eliminate rounding effects and increase speed 
    planning a sheet
when planning individual sheets  the regressed state representation contains the state of
the sheet  which may be only partially specified  a  search is used to find the optimal plan
for the current sheet  in the context of all previous sheets  after the optimal plan for a
sheet is found  the resource allocations and stn used for the plan are passed back to the
plan manager and become the basis for planning the next sheet 
one unusual feature of our planning approach is that we seamlessly integrate planning
and scheduling  starting times of actions are not fixed but merely constrained by temporal
ordering constraints in the stn  we insist that any potential overlaps in allocations for
the same resource be resolved immediately  resulting in potentially multiple children for a
single action choice  this allows temporal propagation to update the action time bounds
and guide plan search  while the plan for a single sheet is a totally ordered sequence of
actions  there are partial orders between actions that belong to plans of different sheets to
represent the resource conflict resolutions 
      state representation
because the plan must be feasible in the context of previous plans  the state contains
information both about the current sheet and previous plans  more specifically  the state
is a   tuple hliterals  tdb  rsrcsi in which 
literals describes the regressed logical state of the current sheet  we distinguish between
literals whose status is true  false  or unknown  le  baral  zhang    tran        
the distinction between false and unknown literals is important in our domain because there may be fine grained restrictions on the acceptable values for unspecified
attributes of the sheet  for example  if a sheet s is the first of a given print job  then
the finisher representing the final location of the sheet is unknown because it can be
any finisher that is not allocated to another print job when the plan for that sheet s
is executed  as we discuss below  we allow regression to match unknown literals with
both true and false effects of actions  in this sense unknown can function like dont
care  in our implementation  we represent explicitly those literals that are currently
true and those whose value is unknown  with false literals being represented implicitly 
   

firuml  do  zhou    fromherz

tdb is the temporal database represented as a simple temporal network  stn  containing
all known time points and the current constraints between them  this includes constraints between different plans  between actions in the same plan  as well as against
the wall clock time  examples of time points include the start end times of actions
or resource allocations  as soon as a plan for a given sheet is sent to the machine
 sheets   and   in figure     time points associated with that plan in the tdb are no
longer allowed to float but are clamped at their lower bounds  all other time points
are flexible 
rsrcs is the set of current resource allocations  representing the commitments made to
plans of previous sheets and the partial plan of the current sheet  each resource
allocation is of the form hres  tp   tp i with res is a particular resource and tp    tp  are
two time points in the tdb representing the duration res is allocated to some action 
note that there are multiple resources in the domain and each resource can have
multiple  overlapping or non overlapping depending on the resource type  resource
allocations  in our implementation  we maintain an ordered list of the allocations on
each resource  most recent to oldest 
in essence  the state contains information reflecting the strategy of our planner  hybrid between state space sequential temporal regression search and partial order scheduling  the
literals and the action start and end time points represent the temporal planning regressed
state and the rsrcs and the temporal orderings between competing resource allocations represent partial order scheduling constraints between actions in the plans of different sheets 
      branching on applicable actions
each regressed logical state in our planner is a   tuple l   hlt   lf   lu i where lt   lf   and
lu are the disjoint sets of literals that are true  false  and unknown  respectively  if pre   a 
and pre  a  are the sets of positive and negative preconditions and add a  and del a 
are the sets of positive and negative effects of action a  then the regression rules used to
determine action applicability and update the state literals are 
applicability action a is applicable to the literal set l if     none of its effects are inconsistent with l and     any preconditions not modified by the effects of a are
t
t
consistent with l  more formally       add a  lf       del a  lt      and    
t
t
 pre   a  lf  del a     pre  a  lt  add a   

in many planning settings  an additional criterion for applicability can be added witht
out destroying completeness  at least one effect of a must match l   add a  lt   
t
    del a  lf        this is not necessarily valid in our setting because adding
a no op action a may give more time for an existing resource allocation to run out 
enabling other actions to be used which might lead to a shorter plan 

update the regression of l   hlt   lf   lu i over an applicable action a is derived by undoing the effects of a and unioning the result with as preconditions  for a given literal
l modified by an effect of a  its status will be unknown in the regressed state unless it
is also specified by a corresponding precondition of a  e g   l is a precondition of a  
   

fion line planning and scheduling for modular printers

more formally      lt    lt   add a   pre   a       lf    lf   del a  
s
s
s
and    lu    lu  add a  del a       pre   a  pre  a  
s

s

pre  a  

given that  lf   is usually much larger than  lt   and  lu   in our domain  we explicitly store
lt and lu in our current implementation and use the closed world assumption to imply
that all other literals belong to lf   the modeling translator we provide to xerox engineers
for modeling printers encourages all effects to be mentioned in preconditions  reducing the
growth of the number of unknown literals  for example  if x  add a  then x  p re  a  
although it is not usually the case in our domain  we should note that if the goal
state were always fully specified  with no unknown literals  and every actions effects had
corresponding preconditions  all regressed states would be fully specified  one could then
simplify the logical state representation to l   hlt   lf i and simplify the regression rules to
applicability action a is applicable iff all of its effects match in l  add a   lt and
del a   lf  
update regressing hlt   lf i through a gives h lt  add a  

s

del a    lf  del a  

s

add a i

a plan is considered complete if its literals unify with the desired initial state  step  
in figure     after the optimal plan for a sheet is found  the temporal database used for
the plan is passed back to the outer loop in figure   and becomes the basis for planning
the next sheet  because feasible windows are maintained around the time points in a plan
until the plan is released to the machine controller  subsequent plans are allowed to make
earlier allocations on the same resources and push actions in earlier plans later  if such an
ordering leads to an earlier end time for the newer goal  it will be selected  this provides a
way for a complex job j  that is submitted after a simple job j  to start its execution in the
printer earlier than j    out of order starts are allowed as long as all sheets in each print
job finish in the correct order  this can often provide important productivity gains 
      branching on resource allocation orderings
while the first step in creating regressed states is to branch over the actions applicable
in l  applying each candidate action a can in fact result in multiple child nodes due to
resource contention  some scheduling algorithms use complex reasoning over disjunctive
constraints to avoid premature branching on ordering decisions that might well be resolved
by propagation  baptiste   pape         we take a different approach  insisting that any
potential overlaps in allocations for the same resource be resolved immediately  temporal
constraints are posted to order any potentially overlapping allocations and these changes
propagate to the action times  because many action durations are relatively rigid in typical
printers  this aggressive commitment can propagate to cause changes in the potential end
times of a plan  immediately helping to guide the search process  because multiple orderings
may be possible  there may be many resulting child search nodes 
for example  in figure    assume that a is the current candidate action when searching
for a plan for sheet   and that a uses resource r for a duration  s  e   we also assume
that there are n actions in the plans for sheets    that also use r  implying n existing
non overlapping resource allocations  s    e        sn   en   and corresponding time points in the
temporal database  when trying to allocate r for a  one obvious and consistent choice is
   

firuml  do  zhou    fromherz

end time of
new plan

earliest
start time
next actio
on

planning
start time

estimated length
of plan to come
 pg   res  conflict 

predicted
planning
time

end time of
prev  plan
in same job

end time of
all plans

length of
plan so far

t 

t 

t 

t 

stn  plan starting time constraint

t 

t 

t 

stn  sheet ordering constraint

branching on actions  resource conflicts  
stn  resource contention constraints

figure     important time points for constructing and evaluating a plan 
putting it after all other previous allocations by adding the temporal constraint en  s 
however  there can also be gaps between the existing allocations  si   ei    allowing us to post
constraints such as ei  s  e  si     each such possible allocation for r generates a
distinct child node in the search space  because action a can use several different resources
r  the number of branches is potentially quite large  however  immediately resolving any
potential overlaps in allocations for the same resource avoids the introduction of disjunctions
in the temporal network  maintaining the tractability of temporal constraint propagation 
in summary  at every branch in the planners search space  we modify the logical state by
branching over relevant actions and potentially introduce different temporal constraints in
order to resolve resource contention  because each branch results in a different irrevocable
choice that is reflected in the final plan  the state at each node in the planners search tree
is unique  therefore  we do not need to consider the problem of duplicating search effort
due to reaching the same state by two different search paths 
      heuristic estimation
for each potential plan suffix  a lower bound is computed on the remaining makespan  in
order to guide the planners a  search  figure    illustrates how this heuristic estimate
is used  in the figure  planning start time  t    refers to the wall clock time at which the
planning process started and earliest start time   current wall clock time   predicted planning time  t    is the estimated time at which we will find a plan for the current sheet and
thus is the earliest time that any action can be scheduled to begin  note that in practice 
the machine controller communication and negotiation time is also added to the predicted
planning time  the hypothetical start time of the plan when found  t    is constrained to
happen after this earliest possible wall clock plan execution time  t   t     a plan is constrained to end after those for previous sheets in the same print job  t   t     but is not
necessarily constrained to start after or before plans for previous sheets  the start time of
the next action added to the regressed partial plan  t    is constrained to occur at least d
   

fion line planning and scheduling for modular printers

after the hypothetical plan starting time  t    d  t    where d is the heuristic value on
the makespan of the remaining plan to complete the current regressed partial plan 
our overall objective is to minimize the earliest possible end time of all plans  including
the sheet that we are planning for  this is indicated by the lower bound on the floating
time point t  in figure     this time point is constrained to be after the end time points of
all the sheets that have been planned and the one currently being planned  for the current
sheet  this is represented by the constraints t   t  as shown in figure     because t  is
constrained to end after the completion time of all the other planned sheets in the same
print job  the constraint essentially pushes t  to be after all the sheets in the current print
job end  to support this objective function  the primary criterion evaluating the promise
of a partial plan  step   in figure    is the estimate of the earliest possible happening time
for t    indicated by the stn embedded in this search node  after all constraints shown in
figure    are added in the current branch 
the key duration that affects t  is the heuristic estimate of the lower bound on the
additional makespan required to complete the current regressed plan  this heuristic value
is indicated in figure    by estimated remaining makespan between t  and t    by adding the
constraint t   t    the insertion may thus change the earliest time of all the subsequent time
points t    t    t  and t    it may also introduce an inconsistency in the temporal database  in
which case we can safely abandon the plan  given that the current plan should end after
the end time of all previous sheets in the same print job  t   t     our objective function is
to minimize t  without causing any inconsistency in the temporal database  we break ties
in favor of 
 smaller t   e g   end time of the current print job 
 smaller predicted makespan  t   t   
 larger currently realized makespan  t   t     this is analogous to breaking ties on
f  n  in a  search with larger g n   and thus encourages further extension of plans
nearer to a goal 
the performance of our search based planner heavily depends on the quality of the
heuristic estimating the makespan to go  we estimate d by building the temporal planning
graph with adjustment for both logical mutex and resource contentions  for the rest of this
section  we will discuss the details of how d is computed  overall  we want an effective
planning heuristic that is 
 admissible  because maintaining high plan quality  high productivity of the printer 
is an important criterion for our customer 
 informed and easy to compute  because in most cases  we are only allowed a fraction
of a second to find a feasible plan  any delay in finding a plan will delay plan start
execution time and thus reduce the overall productivity 
to derive an admissible estimate of the duration required to achieve a given set of goals
g from the initial state  we perform dynamic programming over the explicit representation
of the bi level temporal planning graph  which was described in the tgp system  smith
  weld         in tgp  the planning graph is represented by a fact level and an action
   

firuml  do  zhou    fromherz

level  starting with the initial state at time t      the graph is grown forward in time with
actions being activated when all of their preconditions are satisfied and non mutex  there
are three types of mutual exclusion relations  fact fact  fact action  action action  that are
propagated during the graph building process  the graph expansion phase alternates with
the plan extraction phase starting from the time point at which all the goals appear nonmutex in the graph 
in our graph expansion algorithm  for each action a and fact f   we store the first times
ta and tf at which a can optimistically occur or f can optimistically be achieved  they
correspond to the first times at which a and f appear in the temporal planning graph  for
mutex propagation  we also store the first time point at which each pair of facts hf    f  i can
be achieved together and each pair of actions ha    a  i can execute together  in the planning
graph  those are the first time points that hf    f  i and ha    a  i become non mutex  in our
implementation  a fact action mutex between fact f and action a is converted into action
mutex hnoopf   ai  as we will discuss later 
   to begin  f  a  f    f    a    a    ta   tf   thf   f  i   tha   a  i    
   let i be the initial state  f  f    f   i   tf      thf   f  i     
   dynamically update the values of ta   tf   thf   f  i   tha   a  i starting from the initial state
i and time t     as follows 
ta   max  setup time a  

max

f p rec a 

tf  

max

f   f  p rec a 

thf   f  i  

tf   min  ta   dur a  

   

f eff a 

thf   f  i   min  tha   a  i  

max

 dur a     dur a     

f  eff a    f  eff a   

tha   a  i   max  ta    ta   

max

f  p rec a    f  p rec a   

   

thf   f  i  

   

   

the updates are done in the increasing order of time  as usual for planning graph
building algorithms 
   stop when g  g   tg    and g    g   g   thg   g i    or we reach a fixed point 
in the equations         as shown above  the actions include the noop actions as in
the normal planning graph  those actions start from the time point at which a fact is first
achieved  the mutex relation between a noop and an action is equivalent to a fact action
mutex as described by smith and weld         while the overall plan for all sheets is
highly parallel  the plan for a single sheet is sequential  therefore  we currently use the
serial version of the temporal planning graph  which is also faster to build and consumes
less memory  in this version  two non noop actions are always mutex with each other 
therefore  we do not need to store and reason about action mutexes and thus the value of
tha   a  i in eq     is only applicable to mutexes between a noop and a real action  in our
   

fion line planning and scheduling for modular printers

implementation  we build the graph starting from t     by putting in events of     activating
an action  updating ta        activating a fact  updating tf    and     removing a fact mutex
 updating thf   f  i    ordered by the time they occur  each event will trigger new events to
happen at a later time  for example  adding a new fact f or removing a fact mutex hf    f  i
can activate actions supported by f or by both f  and f    and activating action a will add
events of activating facts in effect a  and or removing fact mutexes between effect a  and
noop  facts  that are not mutex with p recond a   we also only explicitly store the factfact mutex timing values thf   f  i but none of the action mutexes tha   a  i   instead reasoning
about them on the fly 
the time at which all the goals are achieved pair wise non mutex is the heuristic value
estimating the remaining makespan to achieve the goal state  see figure      while most
regression planners  haslum   geffner        nguyen  kambhampati    nigenda       
compute their heuristic once  until a fixed point is reached  before the planning process
begins  in our case  the planning graph expansion process may be revisited if goals representing a regressed state do not appear non mutex in the graph and a fixed point was not
reached in the previous round of expansion  because only pair wise mutexes are taken into
account while building the graph  the estimated value is an underestimate of the makespan
of any plan that can achieve the goal  therefore  the returned value by the planning graph
will lead to a underestimate  admissible heuristic  for both our objective function  overall
end time t    and tie breakers  current sheet end time t  and current estimated makespan
t   t    as described above  therefore  using this estimate  the planner will return plan p
with an optimal end time  minimum t    and p also has a minimum makespan among all
plans with the same end time 
incorporating resource mutexes the planning graph discussed until now assumes
that the printer is empty  thus  we create the planning graph similar to the procedure
used in an off line planner in which we assume the interference relations only occur between
actions related to a given sheet that we are planning for  if the machine is empty  the
heuristic is generally correct for simple sheets such as simplex printing and nearly correct
for complicated sheets such as duplex printing 
however  most of the time  the printer is not empty and there are plans for sheets that
are either     executing  or     found by the planner but havent been sent to the machine
controller yet  those plans involve resource allocations  either at fixed time points  for     
or at still flexible ones  for       to find a more effective heuristic in those scenarios where
the machine is busy  we take into account resource mutexes  thus incorporating scheduling
resource contention constraints into the temporal planning graph  figure    shows the
pseudo code of the algorithm  the key observation is that  to find the earliest time ta at
which an action a can possibly execute  a necessary condition is not only that all of as
preconditions appear non mutex in the planning graph but also that there is no resource
conflict between any resource r used by a and all current allocations of r  given to previous
plans and by external processes  
as shown in the example action description in figure    each resource allocation of
action a is represented as a triple hr  o  di  if a starts at sa   this means that resource
r is used from sa   o for a duration d  which is normally different from the duration
da of a  for example  the lone resource usage for action printsimplexandinvert in fig   

firuml  do  zhou    fromherz

   resource types  r    r        rn
   all resource allocations   r    r        rn  
with ri     si    ei      si    ei         sim   eim    the ordered list of allocations for ri
function checkearliest r  t  d 
  
r  resource
  
t  earliest time intend to use r
  
d  duration intend to use r
  
r     s    e      s    e         sm   em     current allocations for r 
  
tmin   earliest time of a non conflict allocation for r  initialize to  tmin  t
  
for each allocation l    sk   ek    r check
  
if we can reserve r for a duration of d before l starts  latest sk     tmin   d
   
then go to line   
   
else move forward to the next possible opening at the end of allocation a
   
tmin  earliest ek  
    end for 
    return tmin  
end function 
building the temporal planning graph
    when consider adding action a to the planning graph
    initialize ta to the earliest time at which p rec a  achieved non mutex  eq   
    resource allocations of a  ra    hr    o    d  i  hr    o    d  i       hrn   on   dn i 
    for each allocation l   hrk   ok   dk i check the earliest non conflict time for l
   
ta  checkearliest ri   ta   oi   di    oi
    end for 
    add action a to the temporal planning graph at ta until all
goals appear non pairwise mutex 
figure     building the temporal planning graph with adjustments for resource conflicts 
ure   is  m arkingengine             lines       in figure    show that when building the
graph  for each action a that has all of its preconditions satisfied at ta   the algorithm goes
through all resources used by a  for each resource allocation hr  o  di  it calls the function
checkearliest r  ta  o  d  to update ta   the earliest executable time that a can start without
overlapping with any of the previous resource allocations of r  the pseudo code of function
checkearliest r  t  d  is self explanatory in that we try to find the earliest time point after
t at which we can slot the allocation for r with duration d in without overlapping with the
previous allocations of r 
figure    shows one example to demonstrate this algorithm  in this example  we try
to find the starting time for action a  which needs two unit capacity resource allocations
hr    o    d  i and hr    o    d  i as shown on the top left corner  assume that when building the
graph  all of as preconditions can first be achieved non mutex at time t    referring to
figure     the fixed allocations for r  are allocations           and    and for r  are     and
   

fion line planning and scheduling for modular printers

sa

a 
r 

da

o 

d 

r 

o 
   

r 

ea

d 
   

   

   

r 

t 

d 

o 

o 

t 

   

   

   

d 

t 

   

t 

t 

figure     example of action starting time adjustment using resource contentions
     the flexible allocations  shown with their upper lower bound constraints are     for r 
and     and     for r    starting from t    the first time point at which we can allocate r  for
a duration d  without overlapping with previous allocations  both fixed and flexible  is t   
thus  we adjust the new earliest possible starting time for a to t    t   o   t    given the
new earliest possible starting time ta   t    we find that the earliest time point from t  at
which we can allocate resource for r  is t    given that t    t   o   t    we will then take
t  as the final earliest starting time for a and activate action a at t  in the graph  instead
of the original value t      
with resource mutexes  the starting times of actions are adjusted to higher than the time
points at which their preconditions can be achieved  and thus the time point tg at which
all the goals appear non mutex in the graph is not an underestimation on the makespan of
the remaining plan  value t   t  in figure      thus  tg can be higher than the summation
of the durations of actions in the optimal  serial  plan  however  tg still underestimates
the first time that we can achieve the goals and thus is still an admissible heuristic for our
main objective function of minimizing the end time of current printing sheets  minimizing
t  in figure      however  if we do not use the resource mutexes  then both the heuristic
estimate for end time  t    and the tie breaker on plan makespan  t   t    are admissible
while with resource mutexes  only the estimate of t  is admissible and the tie breaker t   t 
   note that we only go through all resource allocations of a given action one time  lines       in figure     
therefore  even when action a in figure    is added at t    there is still a potential conflict for resource
r  consumed by a  with the existing allocation     of r     however  by not repeating the procedure
 lines       in figure     multiple times until a fixed point is reached  and potentially returning better
heuristic estimate   we seek the balance between heuristic quality and heuristic computation time 

   

firuml  do  zhou    fromherz

time  sec 

 
no mutex
logical mutex
log   res mutex
productivity level

   

 

   

 
 

 

                                           

figure     performance for the prototype built by our industrial partner 

can be inadmissible  thus  the a  algorithm is still guaranteed to find an optimal solution 
minimizing the plan end time  but the final solution will not be guaranteed to have a shortest
duration among all plans that finish earliest 
    evaluation of nominal planning
in collaboration with xerox  we have deployed the planner to control three physical prototype multi engine printers  these deployments have been successful and the planner has
also been used in simulation to control hundreds of hypothetical printer configurations 
the planner is written in objective caml  a dialect of ml  and communicates with the job
submitter and the machine controller using ascii text over sockets  the planner can also
communicate with a plan visualizer to graphically display the plans  the first two videos
in the on line appendix show the planner controlling the prototype depicted in figures  
and   at full productivity  both using the visualizer  video    nominal simulation  and the
hardware  video    nominal hardware   a full description of the videos can be found in
the textual appendix of the paper  the shortest single plan for the machine has    actions 
given that there are many sheets in the printer at any given time and the planner can
plan ahead  the plan manager consistently manages dozens of plans and hundreds of actions  during planning  the planner needs to do temporal reasoning regarding the conflict
between actions in the current plans and hundreds of actions in previous plans  even so 
the planner consistently on average produces plans within the      seconds required to keep
the printer running at full productivity      pages minute   for one of the most complex
current xerox commercial products  the planner can regularly find the optimal plan within
     seconds and can plan ahead hundreds of sheets  the ability to use domain independent
planning techniques allows us to use the same planner for very different configurations  without needing any hand tuned control rules  for the rest of this section  we will elaborate on
these results 
   

fion line planning and scheduling for modular printers

time  sec 

  
nomutex
logical mutex
log   res mutex
productivity level

 
 

 

  

  

  

  

  

  

  

  

   

    

jobs
figure     performance for the current prototype built by us and shown in figure    note
that time is plotted logarithmically 

figure    and    show the performance of our planner in two of the most complex
parallel printer prototypes built by xerox and by us  their productivity levels are higher
than any other printer of the same class currently on the market  in each figure  we show
the cpu time consumed per sheet for the basic test of using the planner for a print job
of    sheets      without mutexes      with serial temporal planning graph with mutexes 
    combination of logical and resource mutexes  and     the baseline requirement for the
planners performance to match with the printers full productivity  the other prototypes
investigated using our planner are either simpler or more complicated but used for theoretical investigations only  for the rest of this section  we will refer to the first printer
 results shown in figure     as configuration   and the other  results shown in figure    
as configuration   
the configuration   printer in figure    is the simpler one  with    main components
 including four print engines      action schemata  and a nominal productivity of     sheets
per minute  leading to a timing requirement on the planner of around                sec
for planning each sheet  the shortest possible plan for a simplest simplex sheet contains  
actions  there are normally more than    sheets in flight at a time and thus the planner
needs to handle the interaction of around     actions  however  the planner is typically
intended to plan many sheets ahead so the number of interactions is often much higher 
this printer is built and run by our industrial partner  in the figure  we show that without
mutex  the planner starts taking more than the base time of       second around sheet   
and consistently takes higher than the limit around sheet     however  with logical and
resource mutexes  the planner consistently returns plans within a much shorter time than
required  on average  our planner with logical mutex takes an average of        second
to find a plan and the combination of logical and resource mutex helps reduce the average
planning time to        second     x improvement   without mutexes  the planner takes
an average of        seconds and can not keep up with the full productivity of the printer 
   

firuml  do  zhou    fromherz

the configuration   printer tested in figure    is the more complicated one  there
are     action schemata and the shortest possible plan contains    actions  the printer
generally handles more than    sheets at a time so the planner needs to regularly reason
about the interactions between more than         actions  the productivity level of this
printer is     pages per minute  which leads to the base running time for the planner of
              second for planning a single sheet  because of the wider gap in performance
between different versions of the planners  we show timing results for this printer in log scale 
without using mutexes  the planner quickly overruns the time limit after a few sheets and
grows to more than    seconds around sheet     when we stopped the experiment  with
mutexes  logical  resource  the planner generally takes less than     second to find a plan 
however  occasionally the planner takes longer  but because it usually plans ahead around
   sheets before releasing plans to the lower level controller  occasional jumps in planning
time dont prevent the planner from achieving the full productivity of the printer in practice 
the planner averages        second with only logical mutexes and        second      x
improvement  if used in conjunction with resource mutexes 
the results in figure    and    indicate that the average planning time for individual
sheets increases with the number of previous sheets  this is due to the fact that the planner
generally plans faster than the speed at which the printer can print  thus  as the number
of print requests received increases  the number of plans in the unsent queue  i e   planned
for  but not sent to the machine yet  increases  this increases the resource contention and
branching factor when searching for a new plan  which leads to the increment in planning
time  eventually  the number of lookahead sheets reaches a point where the planning time
equals the planners productivity and a dynamic equilibrium is reached  the planning time
does not strictly increase linearly in accordance with the number of sheets planned  but
rather shows an oscillating pattern  this is due to the complex interaction between the
on line processes of planning  freezing time points in the found plan  and plan execution 
this can lead to easier planning problems when there are more sheets  depending on how
those sheets interact with the sheet that is currently being planned 
while it was noted by smith and weld        and other work based on building the
planning graph that mutex propagation is costly  this was not our experience  in fact 
when the printer is rather empty  the total planning time  which subsumes the graph with
mutex building time is less than      second  we believe that this is due to a simpler mutex
propagation rule in our planner and the fact that the sequential plan of each sheet makes all
actions mutex at each step  our resource mutex reasoning time is not as optimized as the
logical mutex implementation and can be improved  but it does not seem to be a significant
impediment in our intended application 
while the results we have presented indicate that our optimal per sheet strategy seems
efficient enough  further work is needed to assess the drop in quality that would be experienced by a more greedy strategy  such as always placing the current sheets resource
allocations after those of any previous sheet  similarly  during a lull in sheet submissions 
it might be beneficial to plan multiple sheets together  backtracking through the possible
plans of the first in order to find an overall faster plan for the pair together  sheets that have
been planned but whose plans have not been released to the printer represent opportunities
for reconsideration in light of the newer sheets submitted more recently 
   

fion line planning and scheduling for modular printers

 
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

lpg
span
time
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     
    
     
    
     
    
     
           
    
     
           
    
     

sgplan
span
time
   
    
          
 

hybrid
span
time
           
           
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

table    comparison of lpg  sgplan  and our hybrid planner  showing the makespan of
the plans found  span  and planning times  time  in seconds for problems with
various numbers of sheets     

      scaling against generic planners
although our planner has certain features  such as controllable action durations  that are
beyond the capabilities of existing planners  it is still interesting to compare against offline systems to validate our new approach  if existing generic systems could solve basic
printing control problems well  it might be possible to extend them  rather than developing
the more specialized planner architecture described above  therefore  we built a tool to
automatically convert our custom domain language into the pddl    temporal planning
language  allowing us to test current state of the art planners 
while our domain must be simplified to fit the limitations of pddl  we observe that
even these simplified problems are not easy to solve by state of the art academic planners
such as sgplan  chen  hsu    wah        and lpg  gerevini  saetti    serina        
winners of the      and      international planning competitions  since both planners
cannot solve any problem for the configuration   machine from figure    we tested them on
the much simpler configuration   machine  while we only tested a monochrome job with
up to    simplex sheets  this already stretched the limits of lpg and sgplan  our planner
can plan ahead hundreds of sheets for this machine  as can be seen in table    sgplan
took more than   minutes to find a two sheet plan that only took our planner less than
      second to find  compared to sgplan  lpg is much faster  although the quality of the
plan lpg finds is much worse  on average  lpg returns plans with     longer makespan
and is about     times slower than our planner  for the objective function of minimizing
wall clock finishing time  which combines planning time and plan makespan   our planner
is more than     x better than both planners for this small printer configuration 
   

firuml  do  zhou    fromherz

in addition to being faster  our hybrid planner is also more predictable  lpgs planning
time has much higher variance and it sometimes takes longer to plan for a smaller job than
a bigger one  for example  it took lpg    times longer to plan for the    sheet job in
table   than it did for the    sheet job  this makes it unsuitable for real time on line
planning  which depends on accurate estimation of planning times for efficient temporal
event management 
      the      international planning competition
a version of our printing domain was used in the  th international planning competition
 ipc    held in      and the results were presented at the icaps    conference  this
allowed us to evaluate our planner against many state of the art systems  the deterministic
part of the competition had three tracks 
   sequential with objective function of minimizing total cost of actions in the plan
   temporal with objective function of minimizing the plan makespan 
   net benefit with objective function of minimizing the trade off between total goal
utility and action cost 
for all three tracks  the emphasis was on finding good solution quality  thus  planner
running time is not part of the overall scoring metric  specifically  each planner was given
   minutes to run on a particular planning instance  the cost of the plan returned within
the time limit is used to calculate the score for that particular planner in that particular
instance  the score for a given instance is cost of best known solution   cost of generated
plan  where the cost of generating no plan is infinite  there are a total of    instances in
each domain and thus the maximum score any competitor can achieve is     if all solutions
returned have the best quality among all competitors  or equal to the best known solution
generated by a specialized solver  
real world planners are often demonstrated on complex domains such as spacecraft or
mobile robot control which can be difficult to simulate and thus make awkward benchmarks 
most popular temporal planning benchmark domains are off line in the sense that the
planners speed does not affect solution quality  there remains a need for a simple yet
realistic benchmark domain that combines elements of planning and scheduling  especially
in an on line setting  as a step toward bridging this gap  the organizers of ipc  elected to
use the parc printer domain in two tracks  sequential and temporal  the temporal track
was the most natural fit due to the default objective function of maximizing the printers
productivity  which equals to minimizing the makespan of the plan finishing all print job
requests  for the sequential track  minimizing the total printing cost was used  each action
has a certain cost value and using a more expensive color print engine to print a black white
page costs more than using a monochrome print engine  however  the cost trade off may
not be clear cut if the feeder  where the blank sheets originally reside  is closer to the color
print engine than to the monochrome engine 
even though the internal representation of our planner  which was used as a starting
point for the competition domain description  is not too far from the pddl representation 
there were some difficulties in creating the competition domain file and the problem set 
   

fion line planning and scheduling for modular printers

c 
     

dae 
     

dae 
    

dtgplan
     

f fah
     

h
f fsa
     

lama
     

plana
    

sgp  
     

upwards
     

baseline
     

table    scores from the ipc  sequential satisficing track
because of the on line continual nature of the domain and the fact that constraints such as
multiple resource allocations by each action and the sequential finishing order of sheets in
the same job caused a blowup in the problem size when using pure pddl  the organizers
had to     remove or approximate certain constraints in the original domain  and    model
less complex machines  overall  three different printers were modeled  the first one is the
simpler four engine  two color and two mono  configuration   machine that we described
in section      the second one is a stripped down version by using only half  one color and
one mono  of the first printer  the third one is another variation with only one mono and
one color printer  the first two printers have a rather symmetric design and a third one is
asymmetric  all three are significantly simpler than the fixture built at parc  we helped
the ipc organizers model the actions as accurately as possible  and thus even though the
printer configurations are hypothetical  they reflect the characteristics of real hardware 
for the problem files  to reduce complexity  only print requests of a single job with
multiple sheets were used  the sheets are randomly set to be either simplex  one sided print 
or duplex  two sided print  and each image is also randomly selected to be either mono or
color  the number of sheets varies from   to     given this print job request and a particular
printer configuration  the competing planner needed to find a plan with lowest total printing
cost in the sequential track  matching effectively between image requirement and print
engine capabilities  and smallest makespan in the temporal track  synchronizing effectively
between different print engines   in the actual competition  only problems ranging from
     sheets were used for each of the three modeled printers and only simplex sheets were
used for the biggest printer    engine version  to make the problems not too difficult for a
majority of participants 
for all problems used in the two tracks  more details below   we used the planner
described in this paper to provide the best known solutions to score competing planners 
for the temporal planning track  we ran our planner with the default objective function of
maximizing the machines productivity  for the sequential track  we ran our planner with
the objective function of minimizing printing cost  as described later in section      given
that the plan representation is different between our planner and the standard format used
in the ipc  a post processing step was needed to convert from one format to another  note
that in the plans returned by our planner  there are temporal buffers between related time
points  such as inter sheet gaps  the post processing step does not remove those small
temporal buffers  which are not needed for pddl plans to be valid  therefore  competing
temporal planners could theoretically return shorter makespans than our planner  however 
the results as described below show that our planner is still superior to all competing
planners in terms of plan quality  the organizers did not officially reveal the plan running
time but unofficial results showed that our planner was also much faster than all competing
planners in solving most problems 
tables       and   show the ipc results in the three sub tracks in which the parc printer
domain was used  sequential satisficing  sequential optimal  and temporal satisficing  our
   

firuml  do  zhou    fromherz

cfdp
 

co plan
 

cpt 
  

gamer
 

hsp 
  

hspf
  

mips xxl
 

plana
 

upwards
 

baseline
  

table    scores from the ipc  sequential optimal track
cpt 
     

dae 
     

dae 
    

sgplan  
     

tfd
    

tlp gp
    

baseline
     

table    scores from the ipc  temporal satisficing track

planners score would be    for all tracks given that it was used to provide the best known
solutions for all tracks  the baseline planner for the sequential optimizing track was based
on blind search for optimal cost  in the sequential satisficing track was the ff planner  and
in temporal satisficing was the metric ff planner followed by a greedy scheduler  while the
sequential satisficing planners performed well  mostly due to the fact that most problems
in the sequential tracks are easy to solve  the competitors did not perform well in the other
tracks  the reason that sequential optimal planners did not perform well because they could
not solve many problems among those    selected  for the temporal satisficing tracks  most
planners could solve a large number of instances  but the quality of the plans returned by
those plans was not high  thus leading to the low overall scores  in short  the results of the
     international planning competition reinforced our early study indicating that generic
off line planners are not competitive with our on line hybrid system in this application 
together  they provide evidence that the demands of our setting warrant a more specialized
approach 

   exception handling
while maintaining high productivity  and thus high return on investment  is the most
common and important objective  it is by no means the only thing that equipment owners
care about  to reduce the need for operator oversight and expertise and to allow the use of
very complex mechanisms  the system must be as autonomic as possible  because operators
can make mistakes and even highly engineered system modules can fail  the system must
cope with execution failure  this is a crucial part of the rmp value proposition  for
example  imagine a printer or copier that never seems to jam  but just runs a little slower
as the month goes on  once a month  someone opens the covers  removes some jammed
sheets  and the system is back at full productivity  the rmp systems that our planner is
used to control are designed to fulfill this vision of partial productivity when a subset of the
modules are down  to make this transition transparent to the user  and thus increase the
perceived reliability of the system   we have been concentrating on developing exception
handling techniques that minimize user interventions without stopping or slowing down the
machine  current products perform exception handling using rules hard coded into each
machine module  this technique works well for simple straight line systems  but would be
limited to a small predefined subset of failures in more complex topologies  in our modular
rmp systems  there are an astronomical number of different printer configurations and
failure possibilities  so we require a more general exception handling approach 
   

fion line planning and scheduling for modular printers

in addition  because the system must work with legacy modules in order to be commercially viable  its architecture must tolerate components that are out of its direct control
and will give rise to unexpected events  we handle several different exception types such
as plan rejection  by the machine controller   model updates  i e   modules capabilities go
on or off line   and sheet jams 
since most plans in our system tightly interact through various scheduling and temporal
constraints  whether or not they belong to the same print job  an exception affecting any
single plan can affect the executability of other plans and the final job integrity  plans in
different stages of their life cycle need to be analyzed and treated differently  see figure     
simple exceptions such as plan rejection and model updates can be handled by discarding
recently made plans and rolling back the state of the planner to before those sheets were
planned  our implementation uses non destructive data structures to make this efficient 
execution failures such as sheet jams require more elaborate handling  while unsent plans
can be canceled  we need new plans for the sheets that are already in flight at the time an
exception occurs  while this replanning can reuse much of the nominal planning system  it
requires some special modifications that we discuss in detail below  in this section  we first
provide an overview of the various types of exceptions that we handle and how the plan
manager reacts to them  we then concentrate on the hardest part of the exception handling
framework  finding a new set of consistent plans for in flight sheets 
    related work
there are several previously proposed frameworks for handling exceptions and uncertainty
in plan execution  markov decision processes  boutilier  dean    hanks        and contingency planning  pryor   collins        build plans and policies robust to uncertain environment  planners built on those techniques are normally slow  especially in a real time
dynamic environment with complex temporal constraints like ours  they are not suitable
for our domain where exceptions do not happen frequently  but need to be responded to very
quickly  fox  gerevini  long  and serina        discuss the trade off between replanning
and plan repair strategies for handling execution failure  their algorithms work off line 
instead of in an on line real time environment such as ours  and they target a different
objective function  in their case  plan stability   casper system at jpl  chien  knight 
stechert  sherwood    rabideau        uses iterative repairs to continuously modify and
update plans to adjust to the dynamic environment  unlike our system  casper uses
domain control rules and thus is less flexible and the replanning decision is also not needed
as quickly as in our domain  in our case  sub second  
    basic exception handling
our planner can handle several types of exceptions  figure    extends the system architecture diagram from figure   and shows in solid lines the possible steps of the replanning
process  in general  when an exception occurs  the machine controller sends the planner
a message in real time detailing the exception  the planner then cancels plans that have
been created but have not been sent to the printer controller to execute  the corresponding
goals are rolled back into the unplanned queue  the planner at the same time also tries
to find the new plans for sheets that are moving in the printer to avoid further exceptions 
   

firuml  do  zhou    fromherz

printer model  off line
p
 
 

planner
stn
plans
fl ibl
flexible
start time

sheet
descriptions
 on line 

recreate goals

new plans
l
unplanned

planning

planned unsent

plan manager

sent

fixed time plans

exceptions
p

figure     system architecture  showing the steps involved in nominal planning  dashed
lines  and replanning  solid lines  

the new plans when found are sent to the machine controller to replace the ones that are
executing 
next  we discuss in detail each of the different exception types 
plan rejection  when a plan is sent to the machine controller to execute  the controller
may reject the plan if one of the relevant modules cannot commit to executing its requested
action at the time defined by the planner  while such rejections are rare  they can be caused
by module constraints that are outside the scope of the planners model  for example  a
printer engine may need time to bring the toner to the proper temperaturea state variable
and constraint not currently modeled in our system  when a plan is rejected  the planner
will cancel all plans in the unsent queue  in addition to the recently sent and rejected plan 
all goals corresponding to those plans will be rolled back to the unplanned queue  even
plans that are not directly affected by the error message also need to be canceled and rolled
back because those plans were made after the commitments had been made for the rejected
plan 
module update  machine modules can go off  line due to a hardware failure  such as a
sheet jam  a benign event  such as running out of paper in a feed tray  or an unmodeled
process  such as print engine self adjustment  similarly  they can come on line when they
are repaired  adjusted  or otherwise made ready  when this happens  the module controller
will send a message to the planner indicating which of the modules capabilities is now
on off  if a given capability is turned off  then the planner will remove the corresponding
action from consideration in future planning episodes  if a given capability is turned on 
then the planner will add it to the action set for future planning episodes 
break in future  when a module changes the status of some of its capabilities from on
to off  currently executing or unsent plans using that module may become invalid  in this
case  the module controller will send messages to the planner indicating which plans are
   

fion line planning and scheduling for modular printers

affected  the planner will cancel the affected unsent plans and subsequent plans and move
the goals back to the unplanned queue  for plans that are executing and thus correspond to
sheets that have already been fed into the machine  the planner needs to find new plans for
the affected sheets so that they can get to the correct finisher tray without going through
the affected modules  the next section describes in detail how to reroute those in flight
sheets 
broken  this type of exception happens when one or more sheets are jammed in the system 
the broken messages sent to the planner include the ids of all sheets that are jammed and
thus cannot be reused or rerouted because of the failure  when some sheets jam  they
normally also disable some modules and thus a broken message is normally accompanied
by several module update messages  which are described above  the handling of the broken
exception is similar to the handling of the break in future exception in many respects  it
involves canceling of unsent plans and finding new plans for the in flight sheets  however 
the main differences are      in flight sheets that were jammed cannot be rerouted  and    
more critically  the jammed sheets break print job integrity  we discuss this in detail next 
    in flight sheet replanning
in this section  we discuss the problem of finding a new set of plans for in flight sheets when
a sheet is jammed or a module to be used by some plans is broken  the constraints that
make replanning more challenging than nominal planning are 
 sheets cannot stop or slow down while the planner searches for new plans for all inflight sheets  thus  if the planner takes too much time to find new plans  the jams
and or module failures will cascade 
 all newly found plans do not have flexible starting times as in the nominal planning
case  but should all start from the location where the sheets are projected to be when
the plans are found  the new locations depend on the actual replanning time of the
planner 
 any in flight sheets occurring later in the same print job as a jammed sheet should
be rerouted to a purge tray  the sheets from jobs without jammed sheets still need
to finish in the correct finisher tray and in order 
replanning involves four main steps      create new goals for the in flight sheets     
predict  an upper bound on  the replanning time      project the sheets according to the
original trajectory and the predicted planning time to find their future locations  which will
form the new initial state of the replanning problem      find plans for all sheets that are
salvageable  those for which it is possible to avoid broken modules and jammed sheets in
time   satisfying the constraints listed above 
      example
here we provide a concrete example illustrating our replanning procedure  figures        
show a scenario in which there are three in flight sheets  s    and s    belong to the same
print job and were planned to go to finisher    in the middle   sheet s    belongs to a
   

firuml  do  zhou    fromherz

   
   

finisher  
finisher  
p
purge
tray

   

figure     replanning example  before jam   sheet     and     are planned to enter finisher
   and sheet     to finisher   

   
   

finisher  
finisher  
purge tray

   

figure     replanning example  after jam   sheet     is jammed  which requires the planner to reroute sheet     to the purge tray and reroute sheet     to circumvent
the jammed sheet before going to finisher   

different print job and is scheduled to go to finisher    the third finisher is the purge tray 
the original routes are indicated by the dashed lines in figure     assume that s    is
jammed  according to the original routes  we have      s    will arrive in the finisher tray
out of order  because s    did not arrive before it       s    will crash into the module where
s    jammed  therefore  we need to find new plans for those two sheets so that s    will
instead go to the purge tray and s    goes around s      finding those plans takes time and
given that we cannot stop or slow down s    and s    while finding the new plans for them 
those two sheets will continue their original trajectories to the new locations  which are
   

fion line planning and scheduling for modular printers

sheet  
plan  
plan  

   
plan  

sheet  

plan  

   
plan  

plan  

plan  

figure     chaining many searches together gives a search tree with potentially infinite
branching factor 
circled in figure     from there  the machine controller will apply the new plans  indicated
in the figure by solid lines  in order to guarantee print job integrity while avoiding further
cascading failures  after the replanning is done  the planner will generate fresh plans to
re create s    and s     
the example above shows one replanning strategy where the new goal for out of order
sheet s    is set to go to the purge tray  this is the default strategy in our replanner that tries
to clear out the machine and finish the replanning process as quickly as possible to return
to normal operation  however  there are scenarios where the printing media is expensive
or the content is confidential and purging sheets is not desirable  in those scenarios  we
have also experimented with a different strategy that does not purge s    but keeps it in
the machine  for example  by looping it in a holding pattern  while waiting for s    to be
reprinted  then s    is routed to the original finisher  the only modification necessary to
implement this strategy in our system is to change the way replanning goals and end time
constraints are generated  we have tested this strategy successfully for a small number of
sheets  although more sheets could be saved if one were allowed to slow down the transports 
      chained bfs
for normal operation  the planner uses a  to find the plan for a given sheet that can end
soonest  given the  temporally flexible  plans for the previous sheets  a plan always exists
if scheduled sufficiently far in the future  for rerouting  the problem is different  we must
find jointly feasible plans for as many in flight sheets as possible  we cannot greedily plan
one sheet at a time  committing irrevocably to the plans for all previous sheets  because the
plan selected for one sheet might render subsequent sheets infeasible  this cannot happen
during nominal planning  as later sheets are always feasible when scheduled sufficiently far
in the future  when replanning  however  we are forced to confront a true multi body
planning problem 
we considered two strategies to solve this problem  the first was to simply plan in the
joint action space of all sheets  this would result in a large branching factor and it was not
clear to us how to design an effective heuristic evaluation function  we chose a different
approach  in which we can retain the view of planning for each sheet individually using
heuristic search  however  we overlay an additional search on top of this  as depicted in
figure     in the high level search  a branching node represents the situation in which we
have selected certain specific plans for all previous sheets and it is time to select a plan for an
   

firuml  do  zhou    fromherz

chainedbfs  problems 
   if problems is empty  return success
   p  remove first problem from problems
   initialize openlist for p
   repeat until openlist is empty or node limit is reached 
  
n  best node on openlist
  
if n is a goal  call chainedbfs with remaining problems
  
expand n  adding any children to openlist
figure     sketch of chained best first search with a depth first strategy 
additional sheet  the children of that node represent commitments to the different possible
plans for that additional sheet  by considering different paths in the high level search
tree  we can consider different combinations of plans for the different sheets  we call this
approach chained best first search  in our current implementation  sheets are replanned in
their original order  as an approximation of increasing distance from exit  which correlates
with increasing flexibility  an alternative approach is to replan in the order of urgency
defined as the time left to reroute a sheet before it becomes unsalvageable 
because the children of a node represent the possible plans returned by a best first
search  the children are not available all at once  instead  an individual sheet level planning
search will encounter goal nodes one at a time  we cannot terminate the search when we
find the first goal node for single sheet planning because we have no guarantee that the
sheet plan reaching that first goal will make the subsequent sheets feasible  finding a plan
for a single sheet merely results in a new branch in the high level space  and to retain
completeness we must retain the ability to continue our search and uncover additional
possible plans  in fact  in printers such as ours that contain loops in the paper path  there
may be an infinite number of possible plans for a given sheet  fundamentally  the highlevel search must explore a tree where nodes are expanded incrementally and the branching
factor is potentially infinite 
we identified three possible strategies for searching a tree with infinite branching factor 
the first is a best first approach  in which one formulates a traditional heuristic evaluation
function for the high level nodes  these nodes represent commitments to complete plans for
a subset of the in flight sheets  so the heuristic function needs to estimate the probability
that those plans will allow feasible plans for the remaining sheets to be found  the infinite
branching factor could be handled using partial expansion a   yoshizumi  miura    ishida 
       although this would require a non trivial lower bound on the heuristic value of the
plans that have not yet been found  it was not clear to us how this might be done  the
second possible strategy we considered was limited discrepancy search  korf         unlike
depth first search  limited discrepancy search doesnt necessarily visit all the children of
a node  which are potentially infinite for us  the disadvantage to this method is that 
because we revisit each node many times with different discrepancy bounds  we will suffer
considerable node regeneration overhead 
the third strategy  and the one we used in our implementation  is perhaps the simplest 
depth first search  figure    shows a pseudo code sketch  because we have a fixed number of
sheets to replan  the high level search tree has bounded depth  to cope with the potentially
   

fion line planning and scheduling for modular printers

infinite branching factor  we impose a limit on the number of nodes each low level sheet
planning search may expand  this avoids the danger of searching forever at one high level
node without finding another goal  and is reminiscent of iterative broadening  ginsberg
  harvey         to guide the sheet level planning  we use a heuristic that minimizes
plan duration  this attempts to minimize resource use in the machine and maximize the
probability that other sheets will have feasible plans 
    evaluation
until now  the exception handling strategies in current production printers have been to 
    stop the production and ask the operator to remove all sheets or     use machine specific
customized local rules to purge sheets in the system  our work is the first to demonstrate
automatic exception handling that does not rely on machine specific control rules 
the planner can handle the two easiest types of exception  plan reject and module
update without any difficulties  for the break in future and broken exceptions  we can
currently reroute on the fly up to five sheets for the machine shown in figure    this
number may seem low  but recall that replanning is harder than nominal planning by a
factor exponential in the number of in flight sheets  for the simpler prototype systems at
xerox with fewer  but larger  modules  four print engines  and an aggregate throughput of
    pages per minute  our planner has been able to successfully reroute all reroutable sheets
when different jams happen  we have demonstrated our replanning technology in real time
by allowing people come up and either turn on off modules  or jam sheets intentionally 
sometimes right before sheets hit the broken module  upon receiving the error messages
from the machine controller  the planner is fast enough to reroute the sheets around the
failed modules or jammed sheets to the correct locations  in addition to experimenting
with the physical hardware built at parc and by xerox  we have also tested replanning in
simulation  by connecting the planner to a visualizer instead of the machine controller  the
on line appendix contains two videos of the planner performing in flight rerouting on the
parc prototype  both in simulation  video    replanning simulation  and in hardware
 video    replanning hardware  
in addition to testing our replanning framework on different hypothetical printer configurations and different fault modes  we have also investigated different exception handling
strategies  for example  when the printing media is expensive and the replanning objective
function is switched from the default objective function of finish replanning as quickly as
possible  which can lead to many purged sheets  to saving as many sheets at possible  which
can lead to longer replanning time  then the planner has been able to successfully route
up to   out of order sheets in long routes  that may contain loops  in the system waiting
for the jammed sheet to be printed before being routed to the correct finisher tray  while
achievement of replanning for up to five sheets in a large rmp machine may not seem very
impressive  we want to point out that      our planner can reroute all reroutable sheets in
simpler machines  which is still much more complex than the biggest multi engine printer
xerox currently has on the market       the large machine is very complex for automated
planningthe last two ipc winners sgplan and lpg cannot even find plan for a single
sheet in nominal planning using the pddl    version of our printer domain 
   

firuml  do  zhou    fromherz

   handling multiple objectives
our second major extension to nominal planning is aimed at better meeting shop owners
needs in the nominal case  up to this point  the planners objective has been to run
multi engine reconfigurable printers at full productivity  optimizing for machine throughput 
productivity  while very important  is only one of the many optimization criteria that
naturally exist in real world planning and scheduling applications like the printer control
domain  in this section  we will describe several additional objective functions that were
pointed out as important by our industrial partner  and discuss how we extended our
planning framework to handle them 
in a modular system with multiple print engines  one might want to optimize the cost of
printing by choosing to print black only pages only on monochrome engines and avoid using
more expensive color engines  also  one might want to optimize image quality by choosing to
print pages from the same document only on print engines whose current marking gamuts
are similar  the printer controller needs to give operators the ability to trade off these
conflicting objectives while maintaining robust operation  we meet these challenges using
    an optimization objective that combines separate estimates of productivity and printing
cost  and     multiple heuristic look ups to efficiently handle image quality consistency
constraints  in contrast to an explicit multi objective optimization  in which a planner
would return an selection of non dominated solutions on the pareto frontier  presumably
for a human to choose from  our planner needs to select a single solution for execution  so
we need to combine the multiple criteria into single objective  because our planner is built
atop generic state space heuristic search  we need only design a new comparison function
to order search nodes  in addition to linear combinations of objectives  it is relatively easy
for us to handle tiered criteria using tie breaking strategies 
there are several academic domain independent planners such as grt  refanidis  
vlahavas        and lpg  gerevini  saetti    serina        that can optimize for multiple objectives or trade off between planning time and plan quality  standard planning
languages  especially pddl   gerevini   long         allow specifying complex objective
functions in the weighted sum format  as in our framework   while our planner is also based
on domain independent planning technology and uses an extension of pddl  it works in
a dynamic on line continual environment and interacts with a physical machine  not in an
off line abstracted environment like previous planners 
    optimizing for printing cost
for systems with heterogeneous print engines  the cost of printing a given page depends on
which of the engines is used  for example  it is generally costlier to print a black and white
page on a color engine than a monochrome one  thus  to minimize the overall printing cost 
one should use the engines with the lowest printing cost that still satisfy the image type
and quality requirements of a given print job  by doing so  only a subset of all the available
engines will be used for printing a job and thus the overall productivity may be reduced 
to strike a balance between machine productivity and printing cost  we have implemented an objective that can trade off productivity for cost and vice versa  we show that
by combining different performance criteria into a single objective  the same optimization
framework that works so well for single objective planning can be efficiently applied to
   

fion line planning and scheduling for modular printers

the multi objective case  below are the main steps required to extend the planner from
supporting a single objective to multiple objectives 
step    extend the planners representation of machine capabilities to model action cost 
specifically  we added a cost field representing the cost of executing each capability  in
addition  there is an overall objective field with user supplied weights for each of the two
objectives  obj   min w   t   w   c  where t is the end time and c is the accumulated total
cost of printing all sheets 
step    create one heuristic estimation function for each of the objectives  to find the
best route for a given sheet  we estimate how good a potential route is according to each
of the objective functions  finishing time is estimated using a temporal planning graph
adjusted with resource conflicts  as described in section        to estimate the total plan
execution cost  we use dynamic programming starting from the initial state  i e   sheet in
the feeder  to compute the total cost to reach different reachable states  the computation is similar to cost propagation on the planning graph as in the sapa planner  do  
kambhampati        
step    extend the search algorithm to considering multiple objectives simultaneously 
the estimations on total time and cost are combined using the user supplied weights  as
described in step    to compare nodes in the best first a  search algorithm  given that both
heuristics for time and cost are admissible  like the single objective planner  our planner is
guaranteed to find an optimal solution for any given sheet  if the weights are not given  the
planner chooses to prioritize the objectives  for example  the planner can first find the plan
that has the lowest cost  and then break ties favoring plans with higher productivity  then
favoring one with lower wear and tear  and so on  this mechanism has been implemented
and fully integrated into our planner  the default option when no weights are specified is
to optimize for productivity and break ties on total cost 
    planning for image quality consistency
maintaining image consistency across a set of heterogeneous print engines is especially
important for a multi engine printing system  the planner achieves this by enforcing additional image consistency constraints while searching for an optimal plan  in color science 
the  in consistency of two colors is measured by a function  often denoted e  that calculates the distance between the two in some device independent color space  while there
exist a variety of such functions  the most popular of which is called e      see green 
       for our planning purpose it suffices to assume that given any two engines  a e
function returns a non negative real valued scalar  called e distance  that measures the
discrepancy in perceived color as a result of printing the same image on these two engines 
because facing pages  i e   pages that face each other in a bound book or magazine  are
most sensitive to image consistency issues  we thus consider the following constraints in our
planner 
   facing page constraints that require the facing pages of a job be printed by the same
print engine
   e constraints that allow only engines within some maximum e distance to print
facing pages
   

firuml  do  zhou    fromherz

given that in reality no two engines can have a e distance of zero  the facing page
constraints can be viewed as a special case of the e constraints with the maximum e
distance set to zero  thus  we only need to focus on the latter  which is more general 
to enforce e constraints  the planner keeps track of the set of print capabilities that
can be used to print the front side of a sheet  which is constrained by the print action
applied to the back side of its previous sheet  since the first sheet of a job does not have a
previous sheet  the set of print capabilities eligible for printing its front side is unconstrained
 i e   equal to the entire set of print capabilities   for subsequent sheets of the same job 
however  only a subset of print capabilities is allowed  such a subset is computed based
on the e constraints by including only capabilities of those engines whose e distance
to the print engine that printed the back side of the previous sheet is less than or equal
to some maximum distance  in most cases  this has to be determined on line  because the
e distance between a pair of engines can drift over time  thus  our planner maintains an
on line version of a pairwise e distance matrix for all the engines in a printer 
while adding extra image consistency constraints can reduce the brute force search
space  if the constraints make the set of reachable states smaller   in practice we found
this often makes the search problem harder  because the heuristic computed for the unconstrained problem  while still admissible  is no longer informative  to improve the accuracy
of the heuristic  the planner computes the temporal planning graph heuristic for all legal
combinations of print capabilities that can be used to print one side of a sheet  and then
stores them in multiple lookup tables  one for each combination  when a heuristic estimate
for a search node is needed  the planner calculates an index into the lookup table based
on the state description  e g   sheet location  monochrome or color printing   in much the
same way as lookups are done in pattern databases  culberson   schaeffer         in our
implementation  a hash table of hash tables is used to store multiple lookup tables  but for
any given sheet only the relevant hash table s  is loaded before the sheet is being planned 
because the set of eligible print actions is known and fixed at that time 
since there are only a limited number of ways of printing a single face of a sheet  this
approach to improving heuristic accuracy has little overhead yet can significantly reduce
the time it takes to find an itinerary  interestingly  the same approach can also be used
to improve the accuracy of the heuristic for handling exceptions in which jammed sheets
block the paper paths to some engines  because then only unblocked engines are eligible for
printing sheets  creating planning problems that are similar to enforcing the e constraints 
for example  one can set the e distance to any blocked engine as infinity  which effectively
forces sheets to go through only unblocked engines  and the computational savings comes
from the use of a more accurate heuristic that is built specifically for a particular set of
unblocked engines  instead of a nominal case heuristic that assumes no engine is blocked 
      planning with a constrained action set
from an algorithmic perspective  our approach to planning for image quality consistency
corresponds to solving a constrained planning problem with a reduced set of actions  compared to its unconstrained version   given a planning problem with k actions  one can create o  k   different versions of the constrained problem  thus  pre computing the temporal
planning graph heuristic for all possible subsets of actions can quickly become infeasible as
   

fion line planning and scheduling for modular printers

k increases  here we describe a general solution that strikes a balance between heuristic
accuracy and the space overhead for storing multiple lookup tables  one for each subset of
the actions  the idea is to limit m  the maximum number of actions that are removed from
the unconstrained problem  and compute heuristic lookup tables only for those constrained
problems  for example  it is usually feasible to enumerate those constrained problems in
which only one or two actions are removed from the action set  to compute the heuristic
value of a state in a constrained problem that is not included in this pre computed set  the
algorithm consults all the lookup tables whose removed actions form a subset of the actions removed in the constrained problem  and returns the maximum value as the heuristic
estimate of the state  since the value returned by any of the lookup tables is admissible 
more formally  let h s p   be an admissible heuristic estimate for state s in the constrained problem with the set of actions p  a removed from the original action set a  and
let m be the maximum number of actions removed in any constrained problems for which
the heuristic is pre computed  the heuristic estimate h s p   can be calculated as follows 
h s p    

 

h s p  
maxqp

  q  m

if  p    m
h s q  otherwise

the new heuristic resembles the hm family of admissible heuristics  haslum   geffner 
       where m limits the maximum cardinality of the set of atoms considered in the
construction of the heuristic  the difference is that our heuristic considers the set of removed
actions  whereas the hm heuristic considers the set of satisfied atoms  our heuristic can also
be seen as a kind of multiple pattern database  holte  felner  newton  meshulam    furcy 
      in which one can take the maximum over a set of heuristic estimates without losing
admissibility  although ours is based on action space abstraction and  multiple  pattern
databases are based on state space abstraction 
    evaluation
to test the ability of our planner to trade off between machine productivity and printing
cost  we have tested on the model of a four engine prototype printer built at xerox  this is a
better test bed for this trade off investigation because that printer has a mixed set of printer
engines  two color and two black and white engines  instead of four identical black engines
such as in the parc prototype system  moreover  the engines are aligned asymmetrically
and thus the paths leading to different engines are slightly different  we have modeled the
costs for all different components in consultation with xerox engineers  we are especially
interested in modeling the cost to print black pages on different engines  printing them
on more expensive color engines costs more than on cheaper monochrome engines  by
varying the weights between the two objective functions  we have been able to show that 
    increasing the weight given to productivity results in more printer utilization of all four
engines      increasing the weight on saving printing cost leads to reductions in the number
of unnecessary costly printing  thus fewer black sheets are printed on color engines  we can
observe the trade off between modules with similar functionality as well  such as between
different feeders  finishers  or paper paths  for example  increasing the weight for saving
costs lowers the number of sheets fed from a more expensive but faster feeder  we have
also tested our search on other hypothetical printers with mixed components and similar
   

firuml  do  zhou    fromherz

results were observed  we also observed that moving from single to multiple objectives did
not slow down our planner and thus did not affect the overall productivity 
we also tested the performance of our planner on image consistency planning  the
model of the printer used has four monochrome engines  two of which are faster but lowquality engines  and the remaining two are slower but high quality engines  all four engines
are connected through asymmetric paper paths  we ran the simulation with a    sheet
job that requires using the two high quality engines for double sided printing  this can be
done with certain e constraints  which can prevent the planner from choosing the two
low quality engines  since we are particularly interested in the effect of the heuristic on the
search performance  we tested the planner with and without using multiple lookup tables 
which made a significant difference in the number of node expansions in a  search and
planning times  on average  when the multiple lookup table heuristic is used  the planner
expands only      nodes per sheet  whereas using the heuristic computed for the unconstrained problem  which grossly underestimates the remaining makespan for constrained
problems  needs      node expansions to find a plan  in terms of running time  the one
that uses multiple lookup tables is     faster than using the naive heuristic 
one future direction is to investigate a different objective entirely  wear and tear  under
this objective  one would like the different machines in the plant to be used the same amount
over the long term  however  because machines are often cycled down when idle for a long
period and cycling them up introduces wear  one would like recently used machines to be
selected again soon in the short term  although our implementation currently only supports
throughput and cost  it should be easily extensible to support additional objectives 

   deployment
in the process of building and deploying the planner  we utilized many off the shelf techniques from academic research in planning  extending  and integrating them to form a fast
on line planner scheduler  in this section  we list the most important lessons we learned
and describe the ancillary tools that were necessary to develop and deploy the planner  we
hope that they can be useful for both application developers and academic researchers in
planning 
    lessons learned
modeling is important  we mean this in two respects  first  it was important to our
end users that printers were modeled with a specialized representation in which machine
modules and the connections between them are the main themes of the language  as
we discussed in section      this representation is then compiled into the planner input
language  taking the capabilities of different modules along with their inter connections and
producing action schemata  in this process  the set of machine capabilities are compiled
into a higher number of action schemata that ground some of the parameters  through
discussion with our users and industrial partners  we feel that the machine centric language
involving modules  machine instances  and inter connections is easier for them to understand
and accept  while the compiled down representation makes it much easier for us to adopt
strips planning techniques 
   

fion line planning and scheduling for modular printers

second  we also found that  because we understood the search algorithm  regression with
three value state representation  and the heuristics  planning graph with mutexes  used by
the planner  we could manipulate the modeling of the actions  goals  and initial states to
produce quite different computational results  consider a simple example of the action a    
move l    l    that moves an object from location l  to l    the most common form of strips
representation of this action is p re a         at l     and effect a        at l     at l     
recall that we use the three value representation in which a literal can have values true 
false  or unknown  regressing the  partial  state s     at l     using a   will get us to state
s     at l     u nknown at l     which is regressable through both actions move l    l    and
move l    l     while the normal regression rules may not consider move l    l    because it
will not lead to an optimal length plan  regressing s  through move l    l    will not cause
inconsistency  in fact  in a domain like ours  we do branch over all regressable actions
because there are scenarios in which we need to buy time to free up resource allocations 
note that in this example  sophisticated techniques to discover invariants such as tim  fox
  long        or discoplan  gerevini   schuert        can discover that the object
can only be at a single location at any time and thus that s  is not regressable through
action move l    l     however  we can eliminate that branch simply by adding a precondition
at l    to the action description of a   and make sure that in the goal state  any location
other than the goal is false  generating an extra child node and propagating all constraints
in our domain is expensive because  in addition to a logical part  our state representation
includes temporal and resource databases  so cutting down on the number of generated
nodes is important  and this can be partially accomplished by careful modeling 
similarly  adding or removing predicates from the domain description can have a great
effects on the heuristic estimation derived by the planning graph through mutex propagation  we experienced a scenario in which adding two extra predicates representing subgoal
completion and modeling the domain slightly differently achieved a speedup of nearly   x
for some printer configurations 
these manipulations are reminiscent of the work of rintanen         who showed how
domain advice expressed in linear temporal logic  such as dont move a package that is at
its destination  could be compiled into the planning operators of a domain using conditional
effects  leading to great gains in planning efficiency  however  we want to emphasize that in
a highly configurable systems like ours  it can be dangerous to encode explicit action choices
or pruning into the domain  it can be hard to guarantee that completeness or optimality will
be maintained under all possible job mixes or failure combinations   for example  looping
a sheet may free up a resource that will allow the job to complete earlier   our approach
is to encode the domain physics  that is  things that are universally true in the domain
and help keep the search within reachable states  but not any control rules in the sense of
heuristic action selections  such as when condition  choose action  our point is that the
same physics can be represented differently  even if limited to strips  and finding the right
match with the chosen search strategy can dramatically affect the planners performance  as
application developers  not having to work with a fixed benchmark domain representation
allows us to exploit another dimension in modeling to improve our planners performance 
the most suitable planning algorithm depends on the application specifications 
even after formulating our domain using an extension of strips  we went through several
   

firuml  do  zhou    fromherz

implementations of different planning algorithms before settling on the current one  our first
version was a lifted partial order planner  which we still think is the more elegant algorithm 
we then implemented a grounded forward state space planner  because that approach has
dominated the planning competitions  however  as discussed in section      we realized
that a combination of the constraint that sheets in a same print job should be finished in
order and our objective function of minimizing the finishing time is not suitable for forward
state space search  we finally settled on a backward state space framework  which is much
faster in our domain  the lesson we drew from this is that just because some approach works
best in a wide range of benchmark domains in the competition does not mean that it is the
best choice for a given application  and if it doesnt work  it does not mean that other less
popular approaches cannot do significantly better  therefore  understanding your domain 
the important constraints involved  your objective function  and how different planning
algorithms work can help in selecting the most suitable strategy  looking up competition
results is not a replacement for understanding the variety of applicable planning algorithms 
having a fast and robust temporal reasoner is very important  in our planner 
even though the source code for the simple temporal network  stn  totals less than    
lines of code  it is critical in handling all temporal relations between actions and resource allocations within a single plan and between different plans  in a real world application where
there are various temporal constraints and delays to take into account  such as communication  setup time  machine controller coordination  and time synchronization delays between
the planner and the other components in the overall control architecture  ensuring temporal
consistency is one of the most important tasks necessary for keeping the planner running
without interruption for a long period of time  having an explicit temporal reasoner also
helped us to uniformly represent and manage start and end times of actions and different
types of resource allocations  it also allowed us to smoothly extend from handling fixed
duration actions to action with variable durations  and extend from regular resource allocations to resource allocations caused by external events such as cyclic resources allocation by
uncontrollable processes  in our domain  variable action durations are context independent
and are different from actions such as refuel in the logistics domain used in the competition 
we havent noticed many planners in the competition having an explicit general purpose
temporal reasoner  except ixtet ghallab   laruelle         however  we would like to
emphasize that in a real world setting in which the planner needs to coordinate with other
software and expects to face various time constraints and delays  this is critical 
there are many uses for a planner  besides its main job of controlling different
printers  the planner has also been used extensively for system analysis purposes  thus 
the planner is tested against     different printer designs to help decide the better ones 
    printers with various broken modules to test the reliability of each printer  those
analyses can help the product group to decide which printer to built for a given purpose 
for example  our customer ran an extensive test consisting of        different planner runs
for variations of a single printer configuration  among those runs  they used the planner to
test different combinations of possible broken points  different print job mixes  and changed
speeds of different modules  another use has been to test the performance of the upstream
job submission and sequencing methods  the most direct and accurate way to evaluate a job
sequencer is to run a long print job mix  thousands of sheets or more  through the planner
   

fion line planning and scheduling for modular printers

and measure the total makespan  recently  we completed a print job mix of        sheets
without any break  which is more intensive than the regular real life printer operation 
through these experiences  we learned that there are many potential applications of a
planner beyond direct machine control 
exception handling  given that the planner interacts with other parts that are either
higher or lower in the control hierarchy  exceptions can come in many forms  we believe
that similar exceptions would occur in most applications where the planner interacts with
physical world  while robust exception handling  such as replanning  is important  we
found that there is much less research on this topic compared to other branches of domainindependent planning 
we hope that these observations can help researchers to develop planning techniques
that are closer to those needed in real world applications and that they are also useful for
those considering deploying ai planning in their applications 
    ancillary tools
in the course of building our system  we developed a number of ancillary tools around our
core planning and scheduling software  among these tools  the most notable piece is the
visualizer  which simulates the movement of each sheet inside the printer in real time  like
the planner  the visualizer adopts the same model based principle to make it as machineindependent as possible  because an itinerary is given as a discrete sequence of actions  each
having a single time stamp that prescribes the start time of the action  linear interpolation
is used to compute the position of a sheet when the current simulation time is somewhere
in between the start times of two consecutive actions  the visualizer works in one of the
following two modes  the on line mode that accepts live itineraries sent by the planner over
sockets  and the off line mode that reads in previously recorded itineraries from a file stored
on disk 
to separate the visualization engine from the specific designs of a printer  we developed
a simple module definition language for describing the dimensions of each module type 
the locations of input and output ports within a modules local coordinate system  the
travel distance between a pair of input and output ports  and optionally a customized
drawing function that can be used to render the type of modules on the screen  besides the
definition of module types  the visualizer needs to know the location as well as the orientation
of each module in a machine wide coordinate system  while it is possible to specify all
these information manually  we developed another ancillary tool called the visualizer preprocessor that can be used to automate this laborious yet error prone task  with this tool 
the user only needs to specify the location and orientation for one module  called a seed
module  from which the locations and orientations of all the other  directly or indirectly
connected  modules are deduced based on the connectivity graph of the modules  for
machines with more than one feasible configuration  our tool can find all possible solutions
and store them in multiple files that can be used later by the visualizer  besides the nominal
case  the visualizer can also simulate various exceptions such as paper jams and break infuture scenarios  our long term vision is for the visualizer to become a design  debug  and
verification tool for the manufacturer  as well as a gui console for the end user who operates
the printer 
   

firuml  do  zhou    fromherz

to make it easier to run tests on our modular printers  we also developed a wrapper
program that glues together the planner and the controller  or the visualizer   it takes
as input a set of pre defined test scenarios specified with succinct syntax  e g     sc means
print    single sided color sheets   to support the simulation of pre fabricated exceptions 
it sends special messages to the visualizer that contains information about when or where
a sheet jam should occur  it also supports simultaneous printing jobs for printers with
multiple finishers  and uses a round robin algorithm to draw sheets from jobs at the same
rate to maintain fairness  to facilitate remote testing and debugging  the wrapper program
uses sockets to communicate with the machine controller  or the visualizer  

   conclusion
we described a real world domain that requires a novel on line integration of planning and
scheduling and we formalized it using a temporal extension of strips that falls between
partial order scheduling and temporal pddl  we presented a hybrid planner that uses
state space regression on a per sheet basis  while using a temporal constraint network to
maintain flexibility through partial orderings representing resource conflicts between plans
for different sheets  our system has successfully controlled three hardware prototypes and
outperforms state of the art planners in this domain  no domain dependent search control
heuristics are necessary to control a printer composed of     modules in real time  we
described extensions to handle two critical issues      real time execution failures  and
    objective functions beyond productivity  we have successfully demonstrated our fast
replanning and multiple objective handling on three physical prototype printers and many
other potential printer configurations in simulation 
our work provides an example of how ai planning and scheduling can find real world
application not just in exotic domains such as spacecraft or mobile robot control  but also
for common down to earth problems such as manufacturing process control  the modular
printer domain is representative of a wider class of ai applications that require continual
on line decision making  through a novel combination of fast continual temporal planning
techniques  we have shown how artificial intelligence can successfully enable robust  highperformance  autonomous operation without hand coded control knowledge 

acknowledgments
much of this work was done while the first author was with the palo alto research center 
preliminary results from this project were published by ruml  do  and fromherz        
do and ruml         and do  ruml  and zhou        and summarized by do  ruml  and
zhou         the authors would like to thank the members of the embedded reasoning
area at parc  especially lara crawford  haitham hindi  johan de kleer  and lukas kuhn 
as well as danny bobrow  david biegelsen  craig eldershaw  and dave duff for their help
and contributions to the project  our industrial collaborators not only provided domain
expertise but were invaluable in helping us to simplify and frame the application in a useful
way  wed like to especially thank bob lofthus and ron root for their enthusiasm and
perseverance and steve hoover for supporting the project 
   

fion line planning and scheduling for modular printers

appendix a  video
the on line appendix on the jair website contains four movies of the system in action 
   nominal simulation mp   shows one simplex job of     sheets being run in a simulation of the parc prototype printer shown in figure    the planner keeps all four
print engines busy  achieving full productivity of the system 
   nominal hardware wmv  shows two simplex jobs being run simultaneously using all
four engines of the parc hardware prototype  the two feeders are on the left and
two simple finishing trays are on the right  red lights on the machine modules show
the position of sheets   background time synchronization is indicated by the periodic
blinking   in the lower left corner  a schematic visualization shows how sheets are
moving through the machine  with one job colored blue and the other red 
   replanning simulation mp   show a simple exceptions handling scenario in simulation  blue sheets and red sheets belong to different jobs  the second sheet of the blue
job jams  the third sheet  already in flight  is rerouted to the middle purge tray and
fresh plans are initiated to recreate both sheets  the red job continues uninterrupted 
   replanning hardware wmv  demonstrates two exception handling scenarios  the
first shows simple on line replanning  after a sheet has launched  a button is pushed
on a module that the sheet is headed toward  to mark the module as broken  this
initiates replanning  and the sheet is routed around the failed module  a second
modules button is pushed  marking it failed and thereby blocking the finishing tray
that the sheet was headed toward  the sheet is rerouting again and emerges at the
remaining finishing tray 
in the second scenario  the module that is broken already contains the first sheet of
a two sheet job  the replanner is fast enough to reroute the second sheet around the
jammed first sheet to a purge tray  the original two sheets are then planned again
from scratch and arrive at the lower finishing tray 

references
baptiste  p     pape  c  l          a theoretical and experimental comparison of constraint
propagation techniques for disjunctive scheduling  in proceedings of ijcai     pp 
       
bartak  r          visopt shopfloor  on the edge of planning and scheduling  in proceedings
of the conference on principles and practice of constraint programming  cp      pp 
       
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions and computational leverage  journal of artificial intelligence research 
        
cervoni  r   cesta  a     oddi  a          managing dynamic temporal constraint networks 
in proceedings of aips     pp       
   

firuml  do  zhou    fromherz

chen  y   hsu  c  w     wah  b          temporal planning using subgoal partitioning
and resolution in sgplan  journal of artificial intelligence research             
chien  s  a   knight  r   stechert  a   sherwood  r     rabideau  g          using iterative repair to improve the responsiveness of planning and scheduling for autonomous
spacecraft  in proc  of ijcai 
chleq  n          efficient algorithms for networks of quantitative temporal constraints  in
proceedings of constraints     pp       
crawford  l   hindi  h   zhou  r     larner  d          synchronized control in a large scale
networked distributed printing system  in proceedings of      ieee international
conference on robotics and automation  icra     
culberson  j     schaeffer  j          pattern databases  computational intelligence         
       
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence           
desjardins  m  e   durfee  e  h   ortiz  jr   c  l     wolverton  m  j          a survey of
research in distributed  continual planning  ai magazine               
do  m   ruml  w     zhou  r          on line planning and scheduling  an application to
controlling modular printers  in proceedings of aaai    
do  m  b     kambhampati  s          sapa  a multi objective metric temporal planer 
journal of artificial intelligence research             
do  m  b     ruml  w          lessons learned in applying domain independent planning
to high speed manufacturing  in proceedings of icaps     pp         
do  m  b   ruml  w     zhou  r          planning for modular printers  beyond productivity  in proceedings of the eighteenth international conference on automated
planning and scheduling  icaps  
fox  m   gerevini  a   long  d     serina  i          plan stability  replanning versus plan
repair  in proc  of icaps     pp         
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificial intelligence research            
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research            
frank  j     jonsson  a          constraint based attribute and interval planning  constraints            
franklin  g   powell  j     workman  m          digital control of dynamic systems 
prentice hall 
fromherz  m  p  j   bobrow  d  g     de kleer  j          model based computing for
design and control of reconfigurable systems  ai magazine                 
fromherz  m  p  j   saraswat  v  a     bobrow  d  g          model based computing 
developing flexible machine control software  artificial intelligence               
    
   

fion line planning and scheduling for modular printers

gerevini  a     long  d          preferences and soft constraints in pddl   in workshop
on preferences and soft constraints in planning  icaps   
gerevini  a   saetti  a     serina  i          planning through stochastic local search and
temporal action graphs in lpg  journal of artificial intelligence research             
gerevini  a   saetti  a     serina  i          an approach to efficient planning with numerical
fluents and multi criteria plan quality  artificial intelligence              
gerevini  a     schuert  l          inferring state constraints for domain independent
planning  in proceedings of the fifteenth national conference on artificial intelligence
 aaai  
ghallab  m     laruelle  h          representation and control in ixtet  a temporal
planner  in proceedings of aips     pp       
ghallab  m   nau  d     traverso  p          automated planning theory and practice 
morgan kaufmann  san francisco 
ginsberg  m  l     harvey  w  d          iterative broadening  artificial intelligence     
       
green  p          colorimetry and colour difference  in green  p     macdonald  l   eds   
color engineering  pp        wiley 
haslum  p     geffner  h          admissible heuristics for optimal planning  in proceedings
of aips  pp         
haslum  p     geffner  h          heuristic planning with time and resources  in proceedings
of ecp    
hindi  h   crawford  l     fromherz  m          synchronization of state based control
processes with delayed and asynchronous measurements  in proc  of decision and
control       and      european control conference  cdc ecc     pp           
hindi  h   crawford  l   zhou  r     eldershaw  c          efficient waypoint tracking
hybrid controllers for double integrators using classical time optimal control  in proc 
of   th ieee conference on decision and control        cdc       
hoffmann  j     nebel  b          the ff planning system  fast plan generation through
heuristic search  journal of artificial intelligence research             
holte  r   felner  a   newton  j   meshulam  r     furcy  d          maximizing over
multiple pattern databases speeds up heuristic search  artificial intelligence         
                
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
korf  r  e          improved limited discrepancy search  in proceedings of aaai     pp 
        mit press 
le  t  c   baral  c   zhang  x     tran  s          regression with respect to sensing
actions and partial states  in proceedings of aaai    
   

firuml  do  zhou    fromherz

muscettola  n          hsts  integrating planning and scheduling  in zweben  m     fox 
m  s   eds    intelligent scheduling  chap     pp          morgan kaufmann 
muscettola  n   morris  p     tsamardinos  i          reformulating temporal plans for
efficient execution  in proceedings of the conference on principles of knowledge representation and reasoning  kr     
nguyen  x   kambhampati  s     nigenda  r  s          planning graph as the basis to
derive heuristics for plan synthesis by state space and csp search  artificial intelligence 
                 
palacios  h     geffner  h          planning as branch and bound  a constraint programming implementation  in proceedings of clei    
policella  n   cesta  a   oddi  a     smith  s  f          from precedence constraint posting
to partial order schedules  ai communications                 
pryor  l     collins  g          planning for contingencies  a decision based approach 
journal of artificial intelligence research            
refanidis  i     vlahavas  i          multiobjective heuristic state space planning  artificial
intelligence           
richter  s   helmert  m     westphal  m          landmarks revisited  in proceedings of
aaai     pp         
rintanen  j          incorporation of temporal logic control into plan operators  in proceedings of the fourteenth european conference on artificial intelligence  ecai       
pp         
ruml  w   do  m  b     fromherz  m  p  j          on line planning and scheduling for
high speed manufacturing  in proceedings of icaps     pp       
smith  d  e     weld  d  s          temporal planning with mutual exclusion reasoning 
in proceedings of ijcai     pp         
smith  s  f     cheng  c  c          slack based heuristics for constraint satisfaction
scheduling  in proceedings of aaai     pp         
wah  b  w     chen  y          partitioning of temporal planning problems in mixed
space using the theory of extended saddle points  in ieee international conference
on tools with artificial intelligence 
yoshizumi  t   miura  t     ishida  t          a  with partial expansion for large branching
factor problems  in proceedings of aaai       pp         

   

fi