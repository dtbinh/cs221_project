journal of artificial intelligence research               

submitted       published     

flecs  planning with a flexible commitment strategy
manuela veloso
peter stone

department of computer science  carnegie mellon university
pittsburgh  pa            usa

veloso cs cmu edu
pstone cs cmu edu

abstract
there has been evidence that least commitment planners can eciently handle planning
problems that involve dicult goal interactions  this evidence has led to the common belief
that delayed commitment is the  best  possible planning strategy  however  we recently
found evidence that eager commitment planners can handle a variety of planning problems
more eciently  in particular those with dicult operator choices  resigned to the futility
of trying to find a universally successful planning strategy  we devised a planner that can
be used to study which domains and problems are best for which planning strategies 
in this article we introduce this new planning algorithm  flecs  which uses a flexible
commitment strategy with respect to plan step orderings  it is able to use any strategy
from delayed commitment to eager commitment  the combination of delayed and eager
operator ordering commitments allows flecs to take advantage of the benefits of explicitly
using a simulated execution state and reasoning about planning constraints  flecs can vary
its commitment strategy across different problems and domains  and also during the course
of a single planning problem  flecs represents a novel contribution to planning in that it
explicitly provides the choice of which commitment strategy to use while planning  flecs
provides a framework to investigate the mapping from planning domains and problems to
ecient planning strategies 

   introduction
general purpose planning has a long history of research in artificial intelligence  several
different planning algorithms have been developed ranging from the pioneering gps  ernst
  newell        to a variety of recent algorithms in the snlp  mcallester   rosenblitt 
      family  at the most basic level  the purpose of planning is to find a sequence of
actions that change an initial state into a state that satisfies a goal statement  planners use
the actions provided in their domain representations to try to achieve the goal  however
different planners use different means to this end 
faced with a variety of different planning algorithms  some planning researchers  including these authors  have been increasingly curious to compare different planning methodologies  although general purpose planning is known to be undecidable  chapman         it
has been a common belief that least commitment planning is the  best   i e   the most efficient planning strategy for most planning problems  this belief is based on evidence that
least commitment planners can eciently handle planning problems that involve dicult
plan step interactions  barrett   weld        kambhampati        minton  bresina   
drummond         delayed commitments  in particular to step orderings  allow the plan

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fiveloso   stone

steps to remain unordered until the interactions are visible   in similar situations  eagercommitment planners may encounter severe eciency problems with early commitments to
incorrect orderings 
recently we engaged in an investigation of other sorts of planning problems which would
be handled eciently by other planning strategies  since all planning is driven by heuristics 
we identified different sets of heuristics that correspond to different planning methods  we
designed sets of planning domains and problems to test different planning strategies  while
studying the impact of these different strategies in different kinds of planning problems 
we came across evidence that eager commitment planners can eciently handle a variety
of planning problems  in particular those with dicult operator choices  stone  veloso 
  blythe         the up to date state allows them to make informed planning choices 
particularly in terms of the operator alternatives available  in similar situations  delayedcommitment planners may need to backtrack over incorrect operator choices  veloso  
blythe         we came to believe that no planner was consistently better than all others
across different domains and problems 
resigned to the futility of trying to find a universally successful planning strategy  we
felt the need to study which domains and problems were best suited to which planning
methods   in order to do so  we devised and implemented a planner that can use any
operator ordering commitment strategy along the continuum between  on the one extreme
delayed commitment  and on the other  eager commitment  this planner is completely
exible along one dimension of planning heuristics  operator ordering commitments  our
main contribution in this paper is to completely describe this planning algorithm and to
put it forth as a tool for studying the mapping between heuristics and domains or problems 
rather than risking the possibility that the planner itself might get overlooked if it were
relegated to an  architecture  section of a future paper  we present flecs and its underlying
philosophy as a contribution in its own right 
the continuum of heuristics that can be explored by our planning algorithm lies between
the operator ordering commitment strategies of delayed commitment and eager commitment
backward chaining planners  which we now situate within a broad range of planning and
problem solving methods  one possible planning strategy is to search all the possible states
that can be reached from the initial state to find one that satisfies the goal  this method 
called progression or forward chaining  can be very impractical  there are often too many
accessible states in the world to eciently search the complete state space  as an alternative  several planners constrain their search by using regression  or backward chaining 
rather than considering all possible actions that could be executed in the initial state and
searching recursively forward through the state space  they search backwards from the goal 
their search is driven by the set of actions that can directly achieve the goal 
there are two main ways of performing backward chaining  several planners do regression by searching the space of possible plans  planners  such as noah  tweak  snlp 
   least commitment planners really delay commitments to plan step orderings and to variable bindings 
throughout this article we use the term delayed commitment to contrast with eager commitment in the
context of step orderings 
   similar concerns regarding different constraint satisfaction algorithms have led recently to the design
of the multi tac architecture  minton         this system investigates a given problem to find a
combination of heuristics from a collection of available ones to solve the problem in an ecient way 

  

fiflecs  planning with a flexible commitment strategy

and their descendants  chapman        mcallester   rosenblitt        mcdermott       
sacerdoti        tate        wilkins        are plan space planners that use a delayedcommitment strategy  in particular  they delay the decision of ordering operators as long
as possible  consequently  the planner reasons from the initial state and from a set of
constraints that are regressed from the goal  on the other hand  planners such as gps 
strips  and the prodigy family  carbonell  knoblock    minton        fikes   nilsson 
      rosenbloom  newell    laird        use an eager commitment strategy   they use
backward chaining to select plan steps relevant to the goals  these eager commitment planners make explicit use of an internal representation of the state of the world  their internal
state  and order operators when possible so that they can reason from an updated version
of this state  they trade the risk of eager commitment for the benefits of using an explicit
updated planning state 
in this article we introduce a planning algorithm  flecs  that uses a flexible commitment strategy with respect to operator orderings  flecs is designed to provide us and
other planning researchers with a framework to investigate the mapping from domains and
problems to ecient planning strategies  this algorithm represents a novel contribution
to planning in that it introduces explicitly the choice of the commitment strategy  this
ability to change its commitment strategy makes it useful for studying the tradeoffs between
delayed and eager commitments  flecs is a descendant of prodigy    and its current
implementation is directly on top of prodigy     it extends prodigy    by reasoning
explicitly about ordering alternatives and by having the ability to change its commitment
strategy across different problems and domains  and also during the course of a single
planning problem  
this article gradually introduces flecs  section   gives a top level view of the algorithm
and describes the different ways in which flecs makes use of a uniquely specified state of
the world  section   introduces the concepts used by the flecs algorithm  we provide
an annotated example to illustrate the details of the planning concepts defined  section  
presents flecs s planning algorithm in full detail and explains the algorithm step by step 
we discuss different heuristics to guide flecs s choices  in particular the exible choice of
commitment strategy  we analyze the advantages and disadvantages of delayed and eager
plan step ordering commitments  section   shows specific examples of planning domains and
problems that we devised  which support the need for the use of flecs s exible commitment
strategy  we performed an empirical analysis on planning performance in these domains 
the corresponding empirical results demonstrate the tradeoffs discussed and show evidence
that exible commitment is necessary  finally section   draws conclusions from this work 
   planners in the prodigy family include prodigy     minton  knoblock  kuokka  gil  joseph    carbonell         nolimit  veloso         and prodigy     carbonell  blythe  etzioni  gil  joseph  kahn 
knoblock  minton  perez  reilly  veloso    wang         nolimit and prodigy     as opposed to
prodigy     do not require the linearity assumption of goal independence and their search spaces are
complete  fink   veloso         they also have some control over their commitment choices as opposed
to the other earlier total order planners 
   we found that we needed a new name for our algorithm as flecs represents a significant change in
philosophy and implementation from prodigy    

  

fiveloso   stone

   a top level view of flecs
prodigy    and flecs differ most significantly from other state of the art planning systems

in that they search for a solution to a planning problem by combining backward chaining  or
regression  and simulation of plan execution  fink   veloso         while back chaining 
they can commit to a total ordering of plan steps so as to make use of a uniquely specified
world state  these planners maintain an internal representation of the state and update it by
simulating the execution of operators found relevant to the goal by backward chaining  note
that simulating execution while planning differs from interleaving planning and execution 
since the option of  un simulating   or rolling back  must remain open  interleaved planning
and execution is generally done by separate modules for planning  monitoring  executing 
and replanning  ambros ingerson   steel         flecs can either delay or eagerly carry
out the plan simulation  in this way  our planning algorithm has the exibility of both being
able to delay operator ordering commitments and being able to use the effects of previously
selected operators to help determine which goals to plan for next and which operators to
use to achieve these goals  in short  it can emulate both delayed commitment planners and
eager commitment planners 
table   shows the top level view of the flecs algorithm 
   initialize 
   terminate if the goal statement has been satisfied 
   compute the pending goals and applicable operators 
 pending goals are the yet to be achieved preconditions of operators that have been
selected to be in the plan 
 applicable operators are those that have all their preconditions satisfied in the
current state 
   choose to subgoal or apply   backtrack point 
 to subgoal  go to step   
 to apply  go to step   
   select a pending goal  no backtrack point  and an operator that can achieve it  backtrack point   go to step   
   change the state as specified by an applicable operator  backtrack point   go to step   
table    a top level view of flecs  the step numbers here are made to correspond with
the step numbers in the detailed version of the algorithm presented in table  
 section     which refines these steps and adds an additional necessary step   
all the terms used in this table are fully described along with the detailed version of the
algorithm in section    in this section we focus on two main characteristics of this algorithm 
namely its use of an internal state and its exibility with respect to commitment strategies 
  

fiflecs  planning with a flexible commitment strategy

    the use of a simulated planning state
flecs uses its internal state for at least four purposes  first  it terminates when every goal

from the given problem is satisfied in the current version of the state  the current state  
at this point  a complete plan  the sequence of operators that transformed the initial state
into the current state  has been created and the planning process can stop  second  in every
cycle  the algorithm uses the internal state to determine which goals need to be planned for
and which have already been achieved by following a means ends analysis strategy  unlike
some other planners which analyze all of the possible effects of the operators that may have
changed the initial state  flecs simply checks if a particular goal is true in the current
state   third  the planner uses the state to determine which operators may now be applied 
i e   those whose preconditions are all true in the state  fourth  flecs can use its state to
choose an operator and bindings that are most likely to achieve a particular goal with a
minimum of planning effort  blythe   veloso         in summary  and with reference to
the algorithm in table    flecs uses the state to determine 






if the goal statement has been satisfied  step    
which goals still need to be achieved  step    
which operators are applicable  step    
which operators to try first while planning  step    

in planners that do not keep an internal state  all four of these steps require considerable
planning effort when they are even attempted at all  in contrast  flecs can perform
these steps in sub quadratic time  furthermore  other planners do not have any particular
methods for choosing among possible operators to achieve a goal  this particular use of
state has been shown to provide significant eciency gains in prodigy     veloso   blythe 
      
since flecs does use the state  it makes a big difference whether or not it chooses to
change its state  apply an operator  at a given time  the advantage of applying an operator
is that more informed planning results during each of the above four steps  however  the
choice to apply an operator involves a commitment to order this operator before all other operators that have not yet been applied  this commitment is only temporary since if no plan
can be found with the operator in this position  the operator can be  un applied  by simply
changing the internal state back to its previous status  one may argue that the requirement that operators be applied in an explicit order opens up the possibility of exponential
backtracking  however this argument is vacuous  as planning is undecidable  chapman 
       due to the use of state  flecs can reduce the likelihood of requiring backtracking at
the operator choice point  in so doing  it may increase the likelihood of backtracking at the
operator ordering choice point  however  it has the exibility of being able to come down
on either side of this tradeoff 
   note that since the goal and the state are fully instantiated  this matching can be accomplished in
constant time for each goal by using a hash table of literals 

  

fiveloso   stone

    the choice of commitment strategies

in order to control the tradeoff between eager and delayed state changes  flecs has a
toggle which determines whether the algorithm prefers subgoaling or applying an operator
in step    which option flecs considers first may affect its path through the search space
and consequently its planning eciency  this ability to accommodate different types of
search is the most novel part of our algorithm  its significance lies in the difference between
subgoaling and applying 
the difference between subgoaling and applying is illustrated in figure    subgoaling
can be best understood as regressing one goal  or backward chaining  using means ends
analysis  it includes the choices of a goal to plan for and an operator to achieve this goal 
as seen in section      both of these choices are affected by flecs s internal state  thus 
subgoaling without ever updating the internal state  applying an operator  can lead to
uninformed planning decisions  on the other hand  by subgoaling extensively  flecs can
select a large set of operators that will appear in the plan before deciding in which order
to apply them  then flecs takes into account the conicts  or  threats   among operators
and orders them appropriately when applying them 
x
i

s

c

z

g

s

x

y

x
i

s

z

c
t

i

g

y

c

y

z

g

subgoaling

applying

operator t achieves a precondition of
operator y that is not true in state c 

all preconditions of operator x are true in state c 
applying x changes the state to c 

figure    this diagram from  fink   veloso        illustrates the difference between subgoaling and applying  a search node consisting of a  head plan  and a  tailplan   the head plan contains operators that have already been applied and
have changed the initial state  i  to the current state  c   the tail plan consists
of operators that have been selected to achieve goals in the goal statement  g 
and operators that have been selected to achieve preconditions of these operators 
etc  the figure shows how the planner could either subgoal or apply at a given
search node 
applying an operator is flecs s way of changing the current internal state so that
future subgoaling decisions can be more informed  however  applying an operator is a commitment  temporary since backtracking is possible  that this operator should be executed
  

fiflecs  planning with a flexible commitment strategy

before any other  this is the essential tradeoff between eagerly subgoaling and eagerly
applying  eagerly subgoaling delays ordering commitments  delayed commitment   while
eagerly applying facilitates more informed subgoaling  eager commitment  
flecs has a switch  toggle  that can change its behavior from eager subgoaling to
eager applying and vice versa at any time  this feature is the most significant improvement in flecs over prodigy    and its predecessors  since we saw evidence that neither delayed commitment nor eager commitment search strategies were consistently effective  stone et al          we felt the need to provide flecs with the toggle  thus  flecs
can combine the advantages of delayed commitments and eager commitments  

   an illustrative example

in this section we present an example that illustrates in detail most of the planning situations
that can arise in a general planning problem  although planning may be well understood in
general  past descriptions of planning algorithms have not directly addressed most of these
situations in full detail  the flecs algorithm is designed to handle all of these situations 
in order to describe flecs completely  we need to define several variables that are
maintained as the algorithm proceeds  since it is much easier to understand the algorithm
once one is familiar with the concepts that these variables denote  we present an annotated
example in figures   through   before formally presenting flecs  we further recommend
following how each of the variables and functions c   g   p   o  a  a  and c change throughout
the annotated example  according to their definitions 
 c represents the current internal state of the planner  its uses are summarized in
section     
 g is the set of goals and subgoals that the planner is aiming to achieve  these are the
goals that are on the fringe of the subgoal tree  goals in g may be goals that have not
yet been planned for  or goals that have been achieved  perhaps trivially  but not yet
used by the operator that needs them as one of its preconditions  i e   this operator
has not been applied yet  
 p is the set of pending goals  goals in g that may need to be planned for in the current
state 
 o stands for the set of instantiated operators that have been selected to achieve goals
and subgoals 
 a is the set of applicable operators  operators in o whose preconditions are all satisfied
in the current state and which are needed in the current state to achieve some goal 
 for a goal g  a g  is the set of its ancestor goal sets   the sequences of goals that
caused g to become a member of g   trivially  a goal is an ancestor of each of the
preconditions of the operator selected to achieve this goal  a g  is a set of sets because
g can have different sets of ancestors  this concept will become clearer through the
example 
   in section   we discuss different heuristics to guide this choice and we discuss our view of toggle as a
perfect focus for learning 

  

fiveloso   stone

 for an operator o  c o  is the set of goals which o was selected to achieve   its causes 
applying o establishes each member of c o   as illustrated below  the functions a
and c are needed to determine which goals are pending and which operators are
applicable  they are analogous to causal links used to determine threats in other
planners  chapman        mcallester   rosenblitt        

the sequence of planning decisions in this example  figure   through figure    is designed to illustrate the uses of all of flecs s variables and functions  we recommend
becoming familiar with them by spending some time carefully tracing their values and returning to the above definitions throughout this example  note that the figures show only
the tail plan while we mention applied operators and state changes in the text  goals are
in circles  solid circles if they are not true and dashed circles if they are true in the current
state  operators are in boxes with arrows pointing to the goals which they  produce  
i e   the goals which the operators have been selected to achieve  their causes   in turn 
the preconditions of these operators are goals with arrows pointing to the operators which
 consume  them  operators that are applicable in the current state appear in bold boxes 
changes to the functions c and a are underlined in the captions 
we present now the example  figure   shows the initial planning situation  in which we
consider a planning problem with three literals in the goal statement  g    g   and g    i e  
g   fg   g   g g  there is one literal in the initial state  g   i e   c   fg g  as none of
the goals is true in the initial state  p   g   there are no operators selected  i e   o     
and therefore also no operators applicable  i e   a      at this point  since they are all
top level goals  none of the goals has any ancestors  a g     a g     a g        as there
are no applicable operators  the next step must be to subgoal on one of the pending goals 

c   fg g
g   fg   g   g g
o  
p   fg   g   g g
a  

g

g

g

 

 

 

figure    an example  the initial specification of a planning situation 
figure   shows the planning situation after flecs subgoals on g  and g    suppose that
operator o    with preconditions g  and g    is selected to achieve g   while o  is chosen
to achieve g  as indicated below  note that the operators  preconditions replace their
causes in the set of fringe goals g   since g  is true in the current state  it is not included
in the set of pending goals p   here g  is the cause of o   so c o     fg g  similarly 
  

fiflecs  planning with a flexible commitment strategy

c o     fg g  the new goals all have nonempty ancestor sets  a g     a g     ffg gg 
and a g     ffg gg  there are still no applicable operators  o  cannot be applied because
g     c and o  cannot be applied because g     c   therefore  flecs subgoals again 

c   fg g
g   fg   g   g   g g
o   fo   o g
p   fg   g   g g
a  
g

g

g

 

 

 

o

o

 

 

g

g

g

 

 

 

figure    resulting planning situation after subgoaling on g  and g   
figure   shows the planning situation after flecs subgoals on g    suppose that the
operator selected to achieve g  has preconditions g  and g    we now have c o     fg  g 
and a g     ffg gg  the causes of operators o  and o  do not change  so c o     fg g
and c o     fg g as in the previous step  similarly  a g    and a g   remain unchanged 
however  g  now has two sets of ancestor goals  a g     ffg g  fg gg  to understand
the need to keep both ancestor sets  consider the possibility that g  could be achieved
unexpectedly as a side effect of some unrelated operator instead of being achieved by o 
as planned for  in this case  g  would remain a pending goal since it would be needed to
achieve g   again  since there are no applicable operators  flecs must subgoal on one of
the pending goals  i e   g   g   or g  

c   fg g
g   fg   g   g   g g
o   fo   o   o g
p   fg   g   g g
a  
g

 

g

g

g

 

 

 

o

o

o

 

 

 

figure    resulting planning situation after subgoaling on g   
  

g

g

g

 

 

 

fiveloso   stone

figure   shows the planning situation after flecs subgoals on g    suppose that o 
  an operator with precondition g    is selected to achieve g    since g  is true in the
current state  o  is our first applicable operator  note that it is necessarily ordered before
o  and o  since its cause is a precondition of these operators  as usual  the cause of the
new operator is stored  c o     fg  g  in addition  the ancestors of g  must be augmented
to include two new ancestor sets  a g     ffg g  fg   g g  fg   g gg  although there is
now an applicable operator  let us assume that flecs chooses to delay its commitment to
order o  as the first step in the plan and subgoals again on a pending goal 

c   fg g
g   fg   g   g g
o   fo   o   o   o g
p   fg   g g
a   fo g
g

 

g

o

 

g

g

 

 

 

o

o

o

g

 

g

 

g

 

 

 

 

figure    resulting planning situation after subgoaling on g   
figure   shows the planning situation after flecs subgoals on g    suppose that operator o  can also achieve g  and that it is selected to do so  we now need to update both
the causes of this operator and the ancestors of its precondition  c o     fg   g g and
a g     ffg g  fg   g g  fg   g g  fg   g gg  now rather than subgoaling on the last remaining pending goal  g    let us apply o    note that this decision corresponds to an early
commitment in terms of ordering the operators o    o   and any operators later selected to
achieve g  which are unordered by the current planning constraints  flecs changes here
from its delayed commitment strategy to an eager commitment strategy 
c   fg g
g   fg   g g
g
 
g
o
o   fo   o   o   o g
 
 
p   fg g
a   fo g
g

 

o

 

g

g

 

 

o

o

 

 

g

g

figure    resulting planning situation after subgoaling on g   
  

 

 

fiflecs  planning with a flexible commitment strategy

figure   shows the planning situation after flecs applied o    since operator o  was
applied in order to achieve goals g  and g   they are both true in the current state and
back on the fringe of the goal tree  i e   they are in c and g   notice that they stay in g
until eventually they have been  consumed  by o  and o   however  since they are true
in the current state  they are not pending goals  since g  is once again the precondition
of only one selected operator  a g     ffg gg as before  o  and o  are now applicable
as their preconditions are all true in the current state thanks to o   let us assume that
flecs maintains the eager commitment strategy and continues applying applicable operators  flecs orders o  before o   since o  deletes a precondition of o   effects are not
shown  
c   fg   g   g g
g   fg   g   g   g g
g
o   fo   o   o g
o
 
g
 
 
p   fg g
a   fo   o g
g

 

g

g

 

 

o

o

 

 

g

g

 

 

figure    resulting planning situation after applying o  from figure   
figure   shows the planning situation after flecs applied o   suppose that  although
it was not selected to do so  operator o  achieves g  as a side effect  perhaps o  has a
conditional effect that was not visible to the planner  or perhaps o  simply looked more
promising than o  as an operator to achieve g  at the time when it was selected  in any

c   fg   g   g   g   g g
g   fg   g   g   g   g g
o   fo   o g
p  
a   fo g
g

 

g

g

g

 

o

 

g

 

 

g

o

 

g

 

 

 

figure    resulting planning situation after applying o  from figure   
  

fiveloso   stone

case  g  is now in c and the planning done for it is no longer needed  g  is no longer a
pending goal  since its sole ancestor is already in c   this fortuitous achievement of a goal
is the reason that we need to use the functions c and a to adjust the sets of pending goals
p and applicable operators a  it would be wasted effort for flecs to plan to achieve g  
note that were g  a precondition of o  as well as o   it would be a pending goal since it
would still be relevant to achieving g    at this point  only the ancestors of g  must be
reset  a g     ffg gg  since there are no more pending goals  flecs must now apply the
last remaining applicable operator  o  
figure   shows the final planning situation after flecs applied o    at this point all of
the top level goals are true in the current state  despite the fact that some of the planning
tree remains  flecs recognizes that there is no more work to be done and terminates  the
final plan is o   o   o    which is the sequence of operators applied in the head plan  not
shown  corresponding to the steps in figures       and    an a posteriori algorithm  veloso 
perez    carbonell        can convert the sequence into a partially ordered plan capturing
the dependencies  o    fo   o g 

c   fg   g   g   g   g   g g
g   fg   g   g   g g
o   fo g
p  
a  
g

g

 

o

 

g

g

 

g

 

 

 

figure    final planning situation after applying o  from figure   

   flecs  the detailed description
aside from the variables and functions introduced in the preceding section  we need to
define only four more things before presenting the complete algorithm  first  initial state
and goal statement are the corresponding ground literals from the problem definition  second  for a given operator o  pre o   add o   and del o  are its instantiated preconditions 
add list  and delete list respectively  flecs takes these values straight from the domain representation  which may include disjunctions  negations  existentially and universally quantified preconditions and effects  and conditional effects  carbonell et al          when o
has conditional effects  add o  and del o  are determined dynamically  using the state at
the time o is applied  third  the  relevant instantiated operators that could achieve g 
 step    are all the instantiated operators o  operators with fully specified bindings  which
  

fiflecs  planning with a flexible commitment strategy

have g   add o  if g is a positive goal or g   del o  if g is a negative goal  fourth  toggle
is a variable that determines the avor of search  as described later 

    the planning algorithm
we present the flecs planning algorithm in full detail in table     while examining the algorithm  notice that the fringe goals g   the selected operators o  the ancestor function a g  
the cause function c o   and the current state c are maintained incrementally  on the other
hand  the pending goals p   the applicable operators a  and toggle are recomputed on every
pass through the algorithm 
step   initializes most of these variables  at the beginning of the planning process  the
only goals in g are those in the goal statement  the current state c is the same as the initial
state  and since no operators have yet been selected  o is empty  both the ancestor function
a and the cause function c are initialized to the constant function that maps everything to   
in practice  the domain of a is the set of goals and the domain of c is the set of operators
that appear in the problem  however  since most of these goals and all of these operators
have not been determined when the algorithm is first called  we must initialize the functions
with unrestricted domains 
step   is the termination condition  it is called after each time a new operator is
applied  the algorithm terminates successfully if every goal g in the goal statement is true 
or satisfied  in the current state c   i e   g   c  
in step    the sets of pending goals and applicable operators are computed based on the
current state  pending goals are the goals that the planner may need to plan for  initially 
the pending goals are the fringe goals that are not currently true or that were true in the
initial state   the applicable operators are the selected operators whose preconditions are
true in the state 
then  step   computes the pending goals p and applicable operators a that are active
in the current state  a pending goal is active as long as it is on the fringe of the subgoal tree
and it still needs to be planned for  a goal is no longer active if every one of its ancestor sets
has at least one goal that has already been achieved  then all purposes for which the goal
was selected no longer exist  as was the case for g  in figure     an applicable operator is
active in the current state as long as it would achieve a goal that is still useful to the plan 
an applicable operator is no longer active if each of its causes is either true in the current
state or no longer active 
step   is the most novel part of our algorithm  it allows for a exible search strategy
within a single planning algorithm  since at this step  flecs has not yet terminated  there
must be either some active pending goals or active applicable operators  i e   p or a must
be non empty  however  if there is only one or the other  then there is no choice to be
made  if  on the other hand  both p and a are non empty  then we can either proceed to
step   or to step    for the sake of completeness  we must keep both options open  but
which option flecs considers first may affect the amount of search required  by changing
   the detail of this algorithm allows the reader to carefully study and re implement flecs 
   since the planner cannot backtrack beyond the initial state  we must keep goals from the initial state as
pending goals for the sake of completeness 

  

fiveloso   stone

   initialize 
c   current state
a  g   goal statement 
g   fringe goals
b  c   initial state 
p   pending goals
c  o     
o
  instantiated operators
d   g a g      
a
  applicable operators
e   o c o      
a  ancestor goal sets
c  causes
   terminate if goal statement  c  
   compute applicable operators a and pending goals p  
a  p   fg   g j g    c   g   initial stateg 
b  a   fa   o j pre a   cg 
   adjust p and a to contain only active members 
a  p   p   fp   p j  s   a p    g   s s t  g   cg 
b  a   a   fa   a j  g   c a    g   c       s   a g   g   s s t  g   c   g 
   subgoal or apply 
a  set or reset toggle to sub or app  i e  set default to delayed or eager commitment 
b  if a      go to step   
c  if p      go to step   
d  choose to apply or to subgoal  backtrack point  
 if toggle   sub   p   c   subgoal first  go to step   
 if toggle   app  apply first  go to step   
   choose a goal p from p  not a backtrack point  
 choose a goal not true in the current state using means ends analysis 
a  get the set r of relevant instantiated operators that could achieve p  
b  if r     then
i  p   p   fp g 
ii  if p     then fail  i e   backtrack  
iii  go to step   
c  choose an operator o from r  backtrack point  
 choose the operator with minimum conspiracy number  i e  the operator which
appears to be achievable with the least amount of planning 
d  o   o   fog 
e  g    g   fp g    pre o  
f  c o    c o    fp g 
g   g   pre o  a g    a g    ffp g   s j s   a p  g 
h  go to step   
   choose an operator a from a  backtrack point for interactions  
 use a heuristic to find operators with fewer interactions   similar to the one used by
the saba heuristic 
a  apply a  c    c   add a     del a 
b  o   o   fag 
c   g   pre a  a g    a g    fs   a g  j s   c a      g 
d  g    g   c a     fg   pre a  j a g     g 
e  c a      
f  go to step   
 

table    the full description of flecs 
  

 

fiflecs  planning with a flexible commitment strategy

the value of toggle  which can be done on any pass through the loop  flecs can change the
type of search as it works on a problem 
each pass through the body of the algorithm visits either step   or step    when
subgoaling  step     an active pending goal p is chosen from p   note that unlike the
corresponding choice in step    this choice of subgoals is not a backtrack point  however  if
there are no operators that could achieve this goal  then another goal is chosen  step  b  
means ends analysis is used as a heuristic to prefer subgoaling on goals that are not currently
true  next  an operator o is chosen that could achieve the chosen goal  step  c   it can
either be a new operator or an existing one as in figure    o   which had already been
selected to achieve g   is also selected to achieve g    the choice of operator is a backtrack
point  unless some other heuristic is provided  the minimum conspiracy number heuristic
is used to determine which operator should be tried first  blythe   veloso         in short 
this heuristic selects the instantiated operator that appears to be achievable with the least
amount of planning 
before returning to the top of the loop  all of the affected variables are updated  first 
o is added to o using set union so that the same operator never appears twice  step  d  
second  o s preconditions are added to g   while p is removed  step  e   once p has an
operator selected to achieve it  it is no longer on the fringe of the subgoal tree  third  the
cause of o is augmented to include p  step  f   fourth  the ancestor sets of o s preconditions
are augmented to include all sets of goals comprised of p and its ancestors  step  g   as
explained in figure    all ancestor sets must be included  finally  since the state is not
changed at all  the termination condition cannot be met  the algorithm returns to step   
when applying an operator  step     an applicable operator a is chosen from a 
a heuristic that analyzes the applicable operators can be used to choose the best possible operator  one such heuristic analyzes interactions between operators by identifying
negative threats  similarly to the saba heuristic in  stone et al          in short  this
heuristic prefers operators that do not delete any preconditions of  and whose effects are
not deleted by  other operators  this choice of an applicable operator is a backtrack point
where all orderings of interacting applicable operators are considered  different orderings
of completely independent operators need not be considered  completely independent operators are those with interactions neither between themselves nor among their ancestor
sets  since the application of one such operator can make no difference to the application
of another  we only need to consider one ordering of these operators 
once a is chosen  it is promptly applied  step  a   this application involves changing the
current state as prescribed by a  note that if a has conditional effects  they are expanded at
this point  next  the relevant variables are updated  first  updating involves removing a
from the set of selected operators  step  b   second  the ancestors of a s preconditions
are only those ancestor sets which did not include a  step  c   a does not need further
planning  figure   shows an example in which a precondition  g   does still have an
ancestor remaining  third  since a has been applied  its preconditions that are not goals
for any other reason are no longer on the fringe  but its causes are  step  d   if they are
unachieved they must be re achieved  fourth  in case a is ever selected again as an operator
to achieve some goal  c a  is reset to    step  e   finally  since the current state has been
altered  the algorithm returns to step   where the termination condition is checked 
  

fiveloso   stone

    discussion  backtracking  heuristics  and properties
one should pay close attention to the placement of backtrack points in the algorithm  in
particular  there are only three  the subgoal apply choice in step    the choice of operator
to achieve a goal in step    and the choice of applicable operator in step    however  the
choice of goal on which to subgoal in step    which is a backtrack point in the prodigy
algorithm  is not a backtrack point here  flecs does not need this backtrack point because
the choice to apply or not to apply an operator at a given time is left open in step   and
all significantly different orders of applying applicable operators are considered in step   
as explained in the previous subsection  different orderings of completely independent operators are not considered  nevertheless  all orderings that could lead to a solution are
considered  therefore  backtracking on the choice of subgoal would only cause redundant
search  this elimination of a backtrack point is a significant improvement in flecs over
previous implementations  namely nolimit and prodigy     note that no new backtrack
points are added to offset the eliminated backtrack point 
flecs s only explicit failure point is in step   and occurs when the algorithm has chosen
to subgoal  but none of the pending goals have any relevant operators  all other failures
are implicit  that is  at a backtrack point  if all choices have been unsuccessfully tried
then the algorithm backtracks  as presented  the algorithm only terminates unsuccessfully
if the entire search space has been exhausted  other causes for failure  such as goal loops 
state loops  depth bounds  and time limits  are incorporated in the same manner as in
prodigy     carbonell et al         
at each choice point  there is some heuristic to determine which branch to try  first   in
step    the goal is chosen using means ends analysis  and the operator with the minimum
conspiracy number is chosen to achieve that goal  in step    the choice mechanism from
the saba heuristic is used to determine which applicable operator to try first  in step   
toggle  which can be changed at any time  determines whether the default commitment
strategy should be eager subgoaling or eager applying  note that if all of the pending goals
are true in the current state  or if there are no pending goals   the planner may apply an
applicable operator regardless of the value of toggle  similarly  if there are no applicable
operators  the planner must subgoal even if toggle indicates to prefer applying  toggle is a
new variable to guide heuristic search at an existing choice point with a branching factor of
two  it does not represent the addition of a new backtrack point  as discussed throughout 
it provides flecs with the ability to change its commitment strategy  as suggested by its
name  toggle can be one of two values  sub and app indicating eager subgoaling and eager
applying respectively 
here we describe a domain independent heuristic that could be used to guide changes to
the value of toggle  such a heuristic should allow eager commitments when there is reason to
believe that there will not be a need to backtrack over the resulting operator linearization 
in this case  setting toggle to app will increase the planning eciency by converting a
partially ordered set of operators into a sequence that leads to a single possible state  which
can then be used to guide subsequent planning  this process is equivalent to starting a new
and smaller planning problem as all the previous choices will be embedded in the state 
the situation described above is similar to that which arises in the alpine system which
constructs ecient abstraction hierarchies  knoblock         alpine can guarantee that
  

fiflecs  planning with a flexible commitment strategy

planning hierarchically using its generated abstraction hierarchies will not lead to backtracking across refinement spaces  figure    illustrates how flecs can use this abstraction
planning information to control the value of toggle  if toggle changes to app when a particular abstract planning step is completely refined and the abstraction hierarchies preserve
alpine s ordered monotonicity property  then there should be no need to backtrack over the
resulting operator ordering  then toggle can change back to sub  and flecs can continue
planning with updated state information 
abstraction level
   begin with
toggle sub 
s 

   continue planning 
toggle sub 

build a partial
order plan for the
first step in the
abstract plan

s 

   continue
until done   

s 
   set toggle app 
commit to an ordering and
compute the new state 

s 

s 
   after another
step in the abstract
plan  commit again 
toggle app 

figure     using abstraction information to guide changes to toggle 
the abstraction driven heuristic is one method for exploiting this choice point  similarly 
the minimum conspiracy number heuristic and the saba heuristic are not the only ways
to guide the choices of instantiated operator and applicable operator respectively  the
heuristics used can always be changed  and we do not claim that the ones we provide as
defaults are the best possible  no heuristic will work all the time 
the planning algorithm we present is both sound and complete if it searches the entire
search space  using a technique such as iterative deepening  korf         flecs is sound
because it only terminates when it has reached the goal statement as a result of applying
operators  that is  the application of the operator sequence returned as the final plan has
been entirely simulated by the time the planner terminates  thus the preconditions of each
operator will all be true at the time the operator is executed  and after all operators have
been executed  the goal statement will be satisfied  consequently  flecs is sound 
since no step in the algorithm prunes any of the search space  flecs with an iteratively
increasing depth bound is also complete  if there is a solution to a planning problem  flecs
will find one  to insure this property  we need only show that flecs can consider all possible
operators that may achieve a goal as well as all orderings of interacting applicable operators 
flecs does so by maintaining backtracking points at the choice of operator  step  c  and
at both points at which the operator ordering could be affected  the choice of applicable
operator itself  step    and the choice of whether to subgoal or apply  step  d   selecting
  

fiveloso   stone

 apply  commits to ordering all operators that are not currently applicable after at least
one of the currently applicable operators  note that completeness is achieved even without
maintaining the choice of goals to subgoal on as a backtrack point  step     since regardless
of the order in which the operators are chosen  they are applied according to their possible
interactions  i e   similarly to resolving negative threats   thus flecs s search space is
significantly reduced from that of prodigy     while still preserving completeness   see
appendix a for formal proofs of flecs s soundness and completeness  

   empirical analysis of heuristics to control the commitment strategy

as we have seen  flecs introduces the notion of a exible choice point between delayed and
eager operator ordering commitments  to appreciate the need for this exibility  consider
the two extreme heuristics  always eagerly subgoaling  delaying commitment  and always
eagerly applying  eager commitment   the former heuristic chooses to subgoal as long as
there is at least one active pending goal  subgoal always before applying or saba   the
latter chooses to apply as long as there are any active applicable operators  subgoal after
every try to apply or savta   in this section we show empirical results that demonstrate
that both of these extremes can lead to highly sub optimal search in particular domains 
indeed  we believe that no single domain independent search heuristic can perform well
in all domains  stone et al          it is for this reason that we have equipped flecs
with the ability to use either extreme domain independent heuristic or any more moderate
heuristic  in between  the two  during every iteration through our algorithm  there is an
opportunity to change from eagerly subgoaling to eagerly applying or vice versa  one could
define different heuristics to guide this choice  or one could leave the choice up to the user
interactively 
this exibility in search method provides our algorithm with the ability to search sensibly in a wide variety of domains  any algorithm that is not so exible is susceptible to
coming across domains which it cannot handle eciently  barrett   weld        veloso  
blythe        kambhampati         flecs s exibility makes it possible to study which
heuristics work best in which situations  in addition  this exible choice is a perfect learning
opportunity  since no single search method will solve all planning problems  we will use
learning techniques to help us determine from experience which search strategies to try 
to illustrate the need for different search strategies  we provide one real world situation
in which eagerly subgoaling leads directly to the optimal solution  one in which eagerly
applying does so  and one in which an intermediate policy is best  these examples are not
intended to be an exhaustive demonstration of flecs s capabilities  rather  our examples
are intended to illustrate the need to consider problems other than traditional goal ordering
problems and to motivate the potential impact of flecs 

    eagerly subgoaling can be better

first  consider the class of tasks in which the following is true  all operators are initially
executable  but they must be performed in a specific order because each operator deletes
the preconditions of the operators that were supposed to be executed earlier  for instance 
suppose that there is a single paint brush and several objects which need to be painted
different colors  the paint brush can be washed fairly well  but it never comes completely
  

fiflecs  planning with a flexible commitment strategy

clean  for this reason  if we ever use a lighter paint after a darker paint  some of the darker
paint will show up on the painted object and our whole project will be ruined  perhaps the
shade of red is darker than the shade of green  then to paint a chair with a red seat and
green legs  we had better paint the legs first 
consider a range of colors ordered from light to dark  white  yellow  green          and
black  initially  we could paint an object any color  however  if we start by painting
something black  then no other paint can be used  in order to represent this situation to a
planner  we created a domain with the operators shown in table   
operator 
preconds 
adds 
deletes 

paint white  obj 

 usable white 
 white  obj  

paint yellow  obj 

 usable yellow 
 yellow  obj  
 usable white 






  
 

paint black  obj 

 usable black 
 black  obj  
 usable white 
 usable yellow 
  
 
 usable brown 

table    example domain for which delayed step ordering commitment results in ecient
planning 
assume that all the colors are usable in the initial state  since painting an object a certain
color deletes the precondition of painting an object a lighter color  and since this precondition cannot be re achieved  no operator adds the predicate  usable    the colors must be
used in a specific order 
this painting domain is a real world interpretation of the artificial domain dm s   introduced in  barrett   weld         the operators in dm s   look like 
operator  a
preconds  fi g
adds  fg g
deletes  fi jj   ig
since each operator deletes the preconditions of all operators numerically before it  these
operators can only be applied in increasing numerical order  thus  a  corresponds to the
operator paint white  a  corresponds to paint yellow  etc  we used this domain for our
experiments  all of which were run on a sparc station  we generated random problems
having one to fifteen goals  ten problems with each number of goals  we used these same
    problems to test both of the extreme heuristics  to get our data points  we averaged
the results for the ten problems with the same number of goals  all of the raw data is
contained in the online appendix  we graph the average time that flecs took to solve the
problems versus the number of goals 
as shown in  stone et al           eagerly applying leads to exponential behavior  as
a function of the number of goals  in this domain  while eagerly subgoaling  when using
i

i

i

j

   we began the study of our new planning algorithm   now named flecs  on prodigy     we consider
the version of prodigy used in  stone et al         to be a preliminary implementation of flecs 

  

fiveloso   stone

an operator choice heuristic from the same study  leads to approximately linear behavior
and no backtracking  the problem with eagerly applying is that  for example  if goal g 
is solved before g   then flecs will immediately apply a  and have to backtrack when
it unsuccessfully tries to apply a    eagerly subgoaling allows flecs to build up the set
of operators that it will need to apply and then order them appropriately by selecting an
application order that avoids conicts or threats  figure    shows a graphic comparison of
the two different behaviors 
eager subgoaling
eager applying

time  msec

    
    
    
    
   
 
 

 

 

 
 
     
number of goals

  

  

figure     flecs s performance with different heuristics in domains dm s    eager subgoaling and applying correspond to delayed commitments and eager commitments
respectively 

    eagerly applying can be better

next  consider the class of tasks in which the following is true  several operators could
be used to achieve any goal  but each operator can only be used once  to use a similar
example  suppose we are trying to paint different parts of a single object different colors 
however  now suppose that we are using multiple brushes that never come clean  once we
use a brush for one color  we can never safely use it again  for instance  if we painted the
green parts using brush   we would need to use brush   or any brush besides brush   to
paint the red parts  table   represents the operators in this new domain 
operator 

paint with brush 

 parts   color 
preconds   unused brush  
adds   painted  parts   color  
deletes   unused brush  

      paint with brush 

 parts   color 
    unused brush  
    painted  parts   color  
    unused brush  

table    example domain for which eager step ordering commitment and use of the state
results in ecient planning 
note that each operator can be used for any color  but since it deletes its own precondition 
it can only be used once  we capture the essential features of this domain in an artificial
domain called d   use once  the operators in d  use once look like 
  

fiflecs  planning with a flexible commitment strategy

a
fi g
f  g  g
fi g

operator 
preconds 
adds 
deletes 

i

i

i

any operator can achieve any goal  but since each operator deletes its own precondition  it
can only be used once  each operator corresponds to painting with a different brush 
in this domain  it is better to eagerly apply than it is to eagerly subgoal  eagerly
subgoaling causes flecs to select the same operator to achieve all of its goals  with a
deterministic method for selecting operators  such as minimum conspiracy number with
order of appearance in the domain specification as a tie breaker   it selects operator a  to
achieve two different goals  however  since it could only apply a  once  it would need to
backtrack to select a different operator for one of the goals  as shown in figure     eagerly
applying outperforms eagerly subgoaling in this case  we generated these results in the
same way as the results in the previous subsection 
eager subgoaling
eager applying

time  msec

    
    
    
    
    
 
 

 

 

 
 
     
number of goals

  

  

figure     flecs s performance with different heuristics in domains d  use once 

    an intermediate heuristic

were it always possible to find good solutions either by always eagerly subgoaling  as in the
first example  or by always eagerly applying  as in the second  there would be no need to
include the variable toggle in flecs  we could simply have an eager subgoal mode and an
eager apply mode  however  there are cases when neither of the above alternatives suces 
instead  we need to eagerly subgoal during some portions of the search and eagerly apply
during others  one heuristic for changing the commitment strategy is the abstraction driven
method described in section      here we present a domain which can use a form of this
heuristic 
this time consider the class of tasks in which the following is true  top level goals take at
least three operators to achieve  one of which is irreversible  can only be executed a limited
number of times  and restricts the bindings of the other operators  one representative of
this class is the one way rocket domain introduced in  veloso   carbonell         for the
sake of consistency  however  we will present a representative of this class of domains in
the painting context  suppose that we are painting walls with rollers  to paint a wall we
  

fiveloso   stone

need to first  ready  the wall  which for the purpose of this example means to decide that
the wall needs to be painted and to designate a color and roller to paint the wall  next we
must fill the selected roller with the appropriately colored paint  then we can paint the
wall  unfortunately  our limited supply of rollers can never become clean after they have
been filled with paint  but they must be clean when they are selected to paint a wall  for
this reason  we must ready all the walls that we want to paint with the same roller before
we can fill the roller with paint  for the reader familiar with the one way rocket domain 
the  fill roller  operator here is analogous to the  move rocket  operator in that domain 
it can only be executed once due to a limited supply of fuel  and it must be executed after
it has been fully loaded  table   shows a possible set of operators in this painting domain 
operator 

designate roller

fill roller

paint wall

 wall   roller   color   roller   color   wall   roller   color 
preconds   clean  roller  
 clean  roller  
 ready
 needs painting  wall  
 chosen
 wall   roller   color  
 roller   color    filled with paint
 roller   color  
adds   ready
 filled with paint
 painted  wall   color  
 wall   roller   color    roller   color  
 chosen  roller   color  
deletes 
 clean  roller  
 ready
 wall   roller   color  
 needs painting  wall  

table    example domain for which the exibility of commitments results in ecient planning 
when given this domain representation  flecs has a dicult time with some apparently simple problems if it uses the same search strategy throughout its entire search  for
example  consider the problem with five walls and two rollers  equivalent to a problem in
the one way rocket domain with five objects and two destinations  
initial state
 needs painting walla 
 needs painting wallb 
 needs painting wallc 
 needs painting walld 
 needs painting walle 
 clean roller  
 clean roller  

goal statement
 painted walla red 
 painted wallb red 
 painted wallc red 
 painted walld green 
 painted walle green 

  

an optimal solution
 designate roller walla roller  red 
 designate roller wallb roller  red 
 designate roller wallc roller  red 
 fill roller roller  red 
 paint wall walla roller  red 
 paint wall wallb roller  red 
 paint wall wallc roller  red 
 designate roller walld roller  green 
 designate roller walle roller  green 
 fill roller roller  green 
 paint wall walld roller  green 
 paint wall walle roller  green 

fiflecs  planning with a flexible commitment strategy

flecs does not directly find this solution when always eagerly subgoaling or when always
eagerly applying  to search eciently  it must subgoal until it has considered all the walls
that need to be painted the same color  then it must apply all applicable operators before
continuing  there is no explicit information in the domain telling it to use one roller for red
and one roller for green    for this reason  when flecs eagerly subgoals  it initially selects
the same roller to paint all the walls  it extensively backtracks before finding the correct
bindings  flecs also does not realize that it should  ready  all the walls that are going
to be painted the same color before filling the roller  thus  when flecs eagerly applies
operators  it tries filling a roller as soon as it has one wall  readied   note that planning
with variables would not solve this problem since the planner would still need to make
binding selections before subgoaling beyond  paint wall   hence facing the same problems 
when flecs tries to solve the above problem using either strategy described  it does
not succeed in a reasonable amount of time  since flecs is complete  it would certainly
succeed eventually  but eventually can be a long time away when dealing with an np hard
problem  neither of these commitment strategies leads to a solution to the above problem
in under     seconds of search time  but all is not lost  by changing the value of toggle
at the appropriate times  flecs can easily find a solution to the above problem  in fact  it
can do so in just   seconds when toggle is manually changed at the appropriate times 
time sec  solution
eager applying
   
no
eager subgoaling
   
no
variable strategy
 
yes
if flecs eagerly subgoals until it has decided to paint walla  wallb  and wallc with
roller   then it can begin eagerly applying  once the three walls are painted red  flecs
can begin subgoaling again without any danger of preparing the other walls with the wrong
roller  only roller  is still clean  this is an example in which the change in state allows the
minimum conspiracy number heuristic to select the correct instantiated operator 
the general heuristic here is that toggle should be set to sub until all walls that need
to be painted the same color have been considered  then toggle should be set to app until
all the applicable operators have been applied  then toggle should be set back to sub as
the process continues  in this way  flecs will need to do very little backtracking and it
can quickly reach a solution  this heuristic corresponds to using an abstraction hierarchy
to deal separately with the interactions between the different colors and the different walls 

   conclusion

we have presented a planner that is intended for studying the correspondence between planning problems and the search heuristics that are most suited to those problems  flecs has
the ability to eagerly subgoal  thus delaying operator ordering commitments  eagerly apply 
thus maximizing the advantages of maintaining an internal state  or to exibly interleave
these two strategies  thus it can operate at any point in the continuum of operator ordering
heuristics   one important dimension of planning 
    this problem is very common in planning as there is often no syntactically correct way to restrict bindings
in a domain representation while maintaining the intended exibility and generality in the domain 

  

fiveloso   stone

in this paper  we explained the advantages and disadvantages of delayed and eager
commitments  we presented the flecs algorithm in full detail  carefully motivating the
concepts and illustrating them with clear examples  we discussed different heuristics to
guide flecs in its choice points and discussed its properties  we showed examples of
specific planning tasks and corresponding empirical results which support our position that
a general purpose planner must be able to use a exible commitment strategy  although
all planning problems are solvable by complete planners  flecs may solve some of the
problems more eciently than other planners that do not have the ability to change their
commitment strategy and may fall into a worst case of their unique commitment strategy 
flecs provides a framework to study the characteristics of different planning strategies
and their mapping to planning domains and problems  flecs represents our view that
there is no domain independent planning strategy that is uniformly ecient across different domains and problems  flecs addresses the particular operator ordering choice as a
exible planning decision  it allows the combination of delayed and eager operator ordering
commitments to take advantage of the benefits of explicitly using a simulated execution
state and reasoning about planning constraints 
we are currently continuing our work on understanding the tradeoffs among different
planning strategies along different dimensions  we plan to study the effects of eager versus
delayed commitments at the point of operator instantiations  we are also investigating the
effects of combining real execution into flecs  finally  we plan to use machine learning
techniques on flecs s choice points to gain a possibly automated understanding of the
mapping between ecient planning methods and planning domains and problems 

appendix a  proofs
we prove that flecs is sound and that with iterative deepening it is complete  consider
the flecs algorithm as presented in table    a planning problem is determined by the
initial state  the goal statement  and the set of operators available in the domain  a plan
is a  totally ordered  sequence of instantiated operators  the returned plan generated by
flecs for a planning problem is the sequence of applied operators upon termination  a
solution to a planning problem is a plan whose operators can be applied to the problem s
initial state so as to reach a state that satisfies the goal statement  a justified solution is
a solution such that no subsequence of operators in the solution is also a solution  flecs
terminates successfully when the termination condition is met  step    

theorem   

flecs is sound 
we show that the flecs algorithm is sound  that is  if the algorithm terminates suc 

cessfully  then the returned plan is indeed a solution to the given planning problem 
assume that flecs terminates successfully and that s   o    o      on is the returned
plan  flecs applies an operator only when the preconditions of the operator are satisfied
in the current state c  step     hence  by construction  after operators o    o        ok for
any k   n have been applied  the preconditions of operator ok   are satisfied in c   at the
point of termination  the current state c satisfies the goal statement  step     but c was
reached from the initial state by applying the operators of s   therefore s is a solution 
qed 
  

fiflecs  planning with a flexible commitment strategy

theorem   

flecs with iterative deepening is complete 

recall that completeness  informally  means that if there is a solution to a particular
problem  then the algorithm will find it  we show that flecs s search space is complete and
that flecs s search algorithm is complete as long as it explores all branches of the search
space  for example using iterative deepening  korf           iterative deepening involves
searching with a bound on the number of search steps that may be performed before a
particular search path is suspended from further expansion  if no solution is found for a
particular depth bound  the search is repeated with a larger depth bound 
for a planning problem  assume that s   o   o      on is a justified solution  we will
show that if flecs searches with iterative deepening  it will find a solution 
the flecs algorithm has four choice points  three of these choice points are backtrack
points  the choice between subgoaling and applying  step  d   the choice of which operator
to use to achieve a goal  step  c   and the choice of which applicable operator to apply
 step     one choice point is not a backtrack point  the choice of goal on which to subgoal
 step    
to prove completeness  we must show that at each backtrack point  there is some possible
choice that will lead flecs towards finding the plan s   no matter what choices flecs makes
at the non backtrack choice point  then if flecs explores all branches of the search space
by searching with iterative deepening  it must eventually find s unless it finds some other
solution  of length  n  first 
the proof involves constructing oracles that tell flecs which choices to make at the
backtrack points so as to find s   then no matter what choices it makes at the other choice
point  it finds solution plan s  
consider the point in the search at which operators o   o   o          ok for some k  and
no others  have already been applied  then let there be oracles at the backtrack points
which operate as follows 
at the choice of subgoaling or applying  step  d   the first oracle makes flecs choose to
apply if and only if ok   is applicable  i e   is in a   otherwise it makes flecs subgoal  if
flecs chooses to apply  ok     a   then it reaches another choice point  namely the choice
of operator to apply  step     another oracle makes flecs select precisely the step ok    
if flecs chooses to subgoal  ok      a   then let flecs choose any goal p from the
set of pending goals p  step     since step   is not a backtrack point  we cannot have an
oracle determine the choice at this point  instead we have to show that  independently from
the choice made at this point  flecs will still find the solution s   it can find this solution
as a consequence of the construction of the next oracle that controls the final choice point
 below   that oracle guarantees that any p selected must either be a member of the goal
statement or a precondition of some operator of s  
the final choice point is the selection of an operator to achieve p  step  c   the third
oracle makes flecs choose an operator of s to achieve p   since s is a solution to the
planning problem and since p is either a member of the goal statement or a precondition
of some operator of s   there must be some operator of s that achieves p   if there is more
than one such operator  any one can be chosen  since only operators from s are selected 
    as opposed to breadth first search  iterative deepening does not harm eciency  it combines the eciency
of searching depth first with the completeness of searching breadth first 

  

fiveloso   stone

the condition that all pending goals are from the goal statement or are preconditions of
operators of s is maintained 
these three oracles will lead flecs to the justified solution s   since s is justified  every
operator of s is necessary to achieve either some goal in the goal statement or some precondition of another operator  consequently  since the third oracle only chooses operators
of s   every such operator will eventually be chosen and then applied as prescribed by the
first two oracles  once every operator of s has been applied  the termination condition will
be met  since s is a solution  and flecs will terminate successfully  qed 

acknowledgements
we would like to recognize in particular the contributions of jim blythe and eugene fink to
our research  jim blythe is highly responsible for the current implementation of prodigy   
upon which flecs is based  eugene fink helped with the formalization of our algorithms
and proofs  we thank eugene fink  karen haigh  gary pelton  alicia perez  xuemei wang 
and the anonymous reviewers for their comments on this article 
this research is sponsored by the wright laboratory  aeronautical systems center  air
force materiel command  usaf  and the advanced research projects agency  arpa 
under grant number f                 the views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the
ocial policies or endorsements  either expressed or implied  of wright laboratory or the
u  s  government 

references

ambros ingerson  j     steel  s          integrating planning  execution  and monitoring 
in proceedings of the seventh national conference on artificial intelligence  pp       
st  paul  mn 
barrett  a     weld  d  s          partial order planning  evaluating possible eciency
gains  artificial intelligence             
blythe  j     veloso  m  m          an analysis of search techniques for a totally ordered
nonlinear planner  in proceedings of the first international conference on ai planning systems  pp        college park  md 
carbonell  j  g   blythe  j   etzioni  o   gil  y   joseph  r   kahn  d   knoblock  c  
minton  s   perez  a   reilly  s   veloso  m     wang  x          prodigy     the
manual and tutorial  tech  rep  cmu cs         department of computer science 
carnegie mellon university 
carbonell  j  g   knoblock  c  a     minton  s          prodigy  an integrated architecture for planning and learning  in vanlehn  k   ed    architectures for intelligence 
erlbaum  hillsdale  nj  also technical report cmu cs        
chapman  d          planning for conjunctive goals  artificial intelligence              
  

fiflecs  planning with a flexible commitment strategy

ernst  g  w     newell  a          gps  a case study in generality and problem solving 
acm monograph series  academic press  new york  ny 
fikes  r  e     nilsson  n  j          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence             
fink  e     veloso  m          prodigy planning algorithm  technical report cmu cs        school of computer science  carnegie mellon university 
kambhampati  s          desing tradeoffs in partial order  plan space  planning  in proceedings of the second international conference on ai planning systems  aips    
pp        chicago  il 
knoblock  c  a          automatically generating abstractions for planning  artificial
intelligence     
korf  r  e          depth first iterative deepening  an optimal admissible tree search 
artificial intelligence                 
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings of
the ninth national conference on artificial intelligence  pp          
mcdermott  d  v          planning and acting  cognitive science              
minton  s          integrating heuristics for constraint satisfaction problems  a case study 
in proceedings of the eleventh national conference on artificial intelligence  pp      
    
minton  s   bresina  j     drummond  m          commitment strategies in planning  a
comparative analysis  in proceedings of the twelfth international joint conference
on artificial intelligence  pp          
minton  s   knoblock  c  a   kuokka  d  r   gil  y   joseph  r  l     carbonell  j  g 
        prodigy      the manual and tutorial  technical report cmu cs        
school of computer science  carnegie mellon university 
rosenbloom  p  s   newell  a     laird  j  e          towards the knowledge level in
soar  the role of the architecture in the use of knowledge  in vanlehn  k   ed   
architectures for intelligence  erlbaum  hillsdale  nj 
sacerdoti  e  d          a structure for plans and behavior  american elsevier  new york 
stone  p   veloso  m     blythe  j          the need for different domain independent
heuristics  in proceedings of the second international conference on ai planning
systems  pp          
tate  a          generating project networks  in proceedings of the fifth international
joint conference on artificial intelligence  pp          
  

fiveloso   stone

veloso  m     blythe  j          linkability  examining causal link commitments in partialorder planning  in proceedings of the second international conference on ai planning
systems  pp          
veloso  m  m          nonlinear problem solving using intelligent casual commitment 
technical report cmu cs         school of computer science  carnegie mellon university 
veloso  m  m     carbonell  j  g          derivational analogy in prodigy  automating
case acquisition  storage  and utilization  machine learning              
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning with parallel
resource allocation  in proceedings of the darpa workshop on innovative approaches
to planning  scheduling  and control  pp          san diego  ca  morgan kaufmann 
wilkins  d  e          domain independent planning  representation and plan generation 
artificial intelligence              

  

fi