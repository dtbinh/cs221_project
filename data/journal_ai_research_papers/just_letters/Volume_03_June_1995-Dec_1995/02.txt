journal of artificial intelligence research                

submitted       published     

building and refining abstract planning cases
by change of representation language
ralph bergmann
wolfgang wilke

bergmann informatik uni kl de
wilke informatik uni kl de

centre for learning systems and applications  lsa 
university of kaiserslautern  p o  box       d       kaiserslautern  germany

abstract

abstraction is one of the most promising approaches to improve the performance of problem
solvers  in several domains abstraction by dropping sentences of a domain description   as
used in most hierarchical planners   has proven useful  in this paper we present examples
which illustrate significant drawbacks of abstraction by dropping sentences  to overcome
these drawbacks  we propose a more general view of abstraction involving the change of
representation language  we have developed a new abstraction methodology and a related
sound and complete learning algorithm that allows the complete change of representation
language of planning cases from concrete to abstract  however  to achieve a powerful
change of the representation language  the abstract language itself as well as rules which
describe admissible ways of abstracting states must be provided in the domain model 
this new abstraction approach is the core of paris  plan abstraction and refinement
in an integrated system   a system in which abstract planning cases are automatically
learned from given concrete cases  an empirical study in the domain of process planning
in mechanical engineering shows significant advantages of the proposed reasoning from
abstract cases over classical hierarchical planning 

   introduction
abstraction is one of the most challenging and also promising approaches to improve complex
problem solving and it is inspired by the way humans seem to solve problems  at first  less
relevant details of a given problem are ignored so that the abstracted problem can be
solved more easily  then  step by step  more details are added to the solution by taking an
increasingly more detailed look at the problem  thereby  the abstract solution constructed
first is refined towards a concrete solution  one typical characteristic of most work on
hierarchical problem solving is that abstraction is mostly performed by dropping sentences
of a domain description  sacerdoti              tenenberg        unruh   rosenbloom 
      yang   tenenberg        knoblock              bacchus   yang         a second
common characteristic is that a hierarchical problem solver usually derives an abstract
solution from scratch  without using experience from previous problem solving episodes 
giunchiglia and walsh        have presented a comprehensive formal framework for
abstraction and a comparison of the different abstraction approaches from theorem proving
 plaisted              tenenberg         planning  newell   simon        sacerdoti       
      tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock 
             and model based diagnosis  mozetic         for hierarchical planning  korf s
model of abstraction in problem solving  korf        allows the analysis of reductions in
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fibergmann   wilke

search caused by single and multiple levels of abstraction  he has shown that in the optimal
case  abstraction can reduce the expected search time from exponential to linear  knoblock
has developed an approach to construct a hierarchy of abstraction spaces automatically
from a given concrete level problem solving domain  knoblock                     these
so called ordered monotonic abstraction hierarchies  knoblock  tenenberg    yang      b 
have proven useful in many domains  recently  bacchus and yang        presented an
improved method for automatically generating abstraction hierarchies based on a more
detailed model of search costs 
all these abstraction methods  however  rely on abstraction by dropping sentences of
the domain description which is a kind of homomorphic abstraction  holte et al        
       it has been shown that these kinds of abstractions are highly representation dependent  holte et al                for two classical planning domains  different  natural 
representations have been analyzed and it turns out that there are several representations
for which the classical abstraction techniques do not lead to significantly improved problem
solvers  knoblock        holte et al          however  it is well known that normally many
different representations of the same domain exist as already pointed out by korf        
but up to now no theory of representation has been developed  in particular  there is no
theory of representation for hierarchical problem solving with dropping sentences 
from a knowledge engineering perspective  many different aspects such as simplicity 
understandability  and maintainability must be considered when developing a domain representation  therefore  we assume that representations of domains are given by knowledge
engineers and rely on representations which we consider most  natural  for certain kinds of
problems  we will demonstrate two simple example problems and related representations 
in which the usual use of abstraction in problem solving does not lead to any improvement 
in the first example  no improvement can be achieved because abstraction is restricted to
dropping sentences of a domain  in the second example  the abstract solution computed
from scratch does not decompose the original problem and consequently does not cut down
the search space at the next detailed level  we do not want to argue that the examples
can never be represented in a way that standard hierarchical problem solving works well 
however  we think it would require a large effort from a knowledge engineer to develop an
appropriate representation and we believe that it is often impossible to develop a representation which is appropriate from a knowledge engineering perspective and which also allows
ecient hierarchical problem solving based on dropping sentences 
we take these observations as the motivation to develop a more general model of abstraction in problem solving  as already pointed out by michalski         abstraction  in
general  can be seen as switching to a completely new representation language in which the
level of detail is reduced  in problem solving  such a new abstract representation language
must consist of completely new sentences and operators and not only of a subset of the
sentences and operators of the concrete language  to our knowledge  sipe  wilkins       
is the only planning system which currently allows the change of representation language
across different levels of abstraction  however  a general abstraction methodology which
allows ecient algorithms for abstraction and refinement has not yet been developed  we
want to propose a method of abstraction which allows the complete change of representation language of a problem and a solution from concrete to abstract and vice versa  if the
concrete and the abstract language are given  additionally  we propose to use experience
  

fibuilding and refining abstract planning cases

from previously solved problems  usually available as a set of cases  to come to abstract
solutions  the use of experience has already proven useful in various approaches to speedup learning such as explanation based learning  mitchell  keller    kedar cabelli       
dejong   mooney        rosenbloom   laird        minton        minton  carbonell 
knoblock  kuokka  etzioni    gil        shavlik   o rorke        etzioni        minton
  zweben        langley   allen        kambhampati   kedar         and analogical or
case based reasoning  carbonell        kambhampati   hendler        veloso   carbonell 
      veloso        
as the main contribution of this paper  we present an abstraction methodology and a
related learning method in which beneficial abstract planning cases are automatically derived
from given concrete cases  based on a given concrete and abstract language  this learning
approach allows the complete change of the representation of a case from the concrete to
the abstract level  however  to achieve such an unconstrained kind of abstraction  the
set of admissible abstractions must be implicitly predefined by a generic abstraction theory 
compared to approaches in which abstraction hierarchies are generated automatically  more
effort is required to specify the abstract language  but we feel that this is a price we have
to pay to make planning more tractable in certain situations 
this approach is fully implemented in paris  plan abstraction and refinement in an
integrated system   a system in which abstract cases are learned and organized in a case
base  during novel problem solving  this case base is searched for a suitable abstract case
which is further refined to a concrete solution to the current problem 
the presentation of this approach is organized as follows  the next section presents an
analysis of hierarchical problem solving in which the shortcomings of current approaches
are illustrated by simple examples  section three argues that a powerful case abstraction
and refinement method can overcome the identified problems  furthermore  we present the
paris approach informally  using a simple example  the next three sections of the paper
formalize the general abstraction approach  after introducing the basic terminology  section   defines a new formal model of case abstraction  section   contains a very detailed
description of a correct and complete learning algorithm for case abstraction  section  
explains the refinement of cases for solving new problems  section   gives a detailed description of the domain of process planning in mechanical engineering for the production
of rotary symmetric workpieces on a lathe and demonstrates the proposed approach on examples from this domain  section   reports on a detailed experimental evaluation of paris
in the described domain  finally  we discuss the presented approach in relation to similar
work in the field  the appendix of the article contains the formal proofs of the properties
of the abstraction approach and the related learning algorithm  additionally  the detailed
representation of the mechanical engineering domain used for the experimental evaluation
is given in online appendix   

   analysis of hierarchical problem solving
the basic intuition behind abstraction is as follows  by first ignoring less relevant features
of the problem description  abstraction allows problems to be solved in a coarse fashion with
less effort  then  the derived abstract  skeletal  solution serves as a problem decomposition
for the original  more detailed problem  korf        has shown that hierarchical problem
  

fibergmann   wilke

solving can reduce the required search space significantly  assume that a problem requires
a solution of length n and furthermore assume that the average branching factor is b 
i e   the average number of states that can be reached from a given state by applying a
single operator  the worst case time complexity for finding the required solution by search
is o bn    now  suppose that the problem is decomposed by an abstract solution into
k subproblems  each of which require a solution of length n           nk   respectively  with
n    n         nk   n  in this situation  the worst case time complexity for finding the
complete solution is o bn    bn         bnk   which is o bmax n  n       nk      please note that
this a significant reduction in search time complexity  in particular  we can easily see that
the reduction is maximal if all subproblems are of similar size  i e   n   n       nk  
however  to achieve a significant search reduction  the computed abstract solution must
not only be a solution to the abstracted problem  it must additionally fulfill a certain
requirement presupposed in the above analysis  the subproblems introduced by the abstract
solution must be independent  i e   each of them must be solvable without interaction with
the other subproblems  this avoids backtracking between the solution of each subproblem
and consequently cuts down the necessary overall search space  even if this restriction is not
completely fulfilled  i e   backtracking is still required in a few cases  several empirical studies
 especially knoblock                    have shown that abstraction can nevertheless lead
to performance improvements 
unfortunately  there are also domains and representations of domains  holte et al        
      in which the way abstraction is used in hierarchical problem solving cannot improve
problem solving because the derived abstract solutions don t fulfill the above mentioned
requirement at all  in the following  we will show two examples of such domains which
demonstrate two general drawbacks of hierarchical problem solving  please note that in
these examples  a particular representation is assumed  we feel that these representations
are somehow  natural  and very likely to be used by a knowledge engineer developing a domain  however  there might be other representations of these domains for which traditional
hierarchical planning works  we assume that such representations are very dicult to find 
especially if the domain representation should also fulfill additional knowledge engineering
requirements 

    abstraction by dropping sentences

in hierarchical problem solving  abstraction is mostly  achieved by dropping sentences of
the problem description from preconditions and or effects of operators  sacerdoti       
      tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock 
             the assumption which justifies this kind of abstraction is that less relevant
details of the problem description are expressed as isolated sentences in the representation
which can be addressed after the more relevant sentences have been established  ignoring
such sentences is assumed to lead to an abstract solution useful to reduce the search at the
more concrete planning levels 
however  this assumption does not hold in all domains  for example  in many real world
domains  certain events need to be counted  e g   when transporting a certain number of
   only tenenberg s        abstraction by analogical mappings and the planning system sipe  wilkins 
      contains first approaches that allow a change of representation language 

  

fibuilding and refining abstract planning cases

containers from one location to another  imagine a domain in which  in addition to several
other operators  there is an increment operator described as follows 
operator  inc
precondition  value x  
delete  value x  
add  value x     

in this representation  the integer value which is increased is represented by a single sentence  each state consists only of a single sentence  and also the operator contains only
one single sentence   we think that this representation is very  natural  and very likely to
be chosen by a knowledge engineer  in this domain  incrementing value    to value   
requires a sequential plan composed of   inc operators  leading to the state sequence 
value    value           value     in this example  however  abstraction by dropping sentences does not work because  if this single sentence would be dropped  nothing would remain in the operator description and the whole counting problem would have been dropped
completely  so there is only the empty problem at the abstract level  and the empty plan is
going to solve it  unfortunately  the empty plan cannot cause any complexity reduction for
solving the problem at the concrete level  consequently  abstraction by dropping sentences
completely fails to improve problem solving in this situation 
however  we can adequately cope with this counting problem by abstracting the
quantitative value expressed in the sentence towards a qualitative representation  e g  
low f          g  medium   f          g  high   f            g   such a qualitative representation would result in an abstract plan composed of two operators  subproblems  that
increase value from low to medium and further to high  this abstract plan defines two
independently refinable subproblems  to solve the first subproblem at the concrete level 
the problem solver has to search for a sequence of inc operators which increment the value
from   to any medium value  any value from the set f          g   this subproblem can be
solved by a sequence of   inc operators leading to the concrete state with a value of    similarly  the second subproblem at the concrete level is to find a sequence of operators which
change the value from   to the final value    also this second subproblem can be solved by
a sequence of   inc operators  so we can see that the complete problem which requires a
sequence of   concrete operators is divided into   subproblems where each subproblem can
be solved by a   step plan  because of the exponential nature of the search space  the two
  step problems together can be solved with much less search than the   step problem as a
whole  following korf s analysis sketched before  the time complexity is reduced from o b  
to o b      please note that the particular abstraction which leads to two subproblems is not
central for achieving the complexity reduction  the important point is that the problem is
decomposed into more than one subproblem  this kind of abstraction can be achieved by
introducing a new abstract representation language which consists of the qualitative values
and a corresponding abstract increment operator 
   however  we might assume that the term x     is modeled as a separate predicate in the precondition 
unfortunately  this does not change the described situation at all 
   because we assume many other operators besides the inc operator  b    holds 

  

fibergmann   wilke

we can even generalize from the specific example presented above  the problem with
the dropping condition approach is that it is not possible to abstract information  e g  
the value in our example  that is coded in a single sentence in the representation  this is
particularly a problem when the required solution contains a long sequence of states which
only differ in a single sentence  dropping this particular sentence leads to dropping the
whole problem  and not dropping the sentence does not lead to any abstraction  what is
really required is to abstract the information encoded in this single sentence which obviously
requires more than just dropping the complete information 
to summarize  we have seen that abstraction by dropping sentences does not work for
the particular kind of problems we have shown  in general  abstraction requires changing the complete representation language from concrete to abstract which usually involves
the introduction of completely new abstract terms  sentences or operators   within this
general view  dropping sentences is just a special case of abstraction  the reason why dropping sentences has been widely used in hierarchical planning is that due to its simplicity 
refinement is very easy because abstract states can directly be used as goals at the more
detailed levels  another very important property of abstraction by dropping sentences is
that useful hierarchies of abstraction spaces can be constructed automatically from domain
descriptions  knoblock                    bacchus   yang        

    generating of abstract solutions from scratch

another limiting factor of classical hierarchical problem solving can be the way abstract solutions are computed  as pointed out by korf  a good abstract solution must lead to mostly
independent subproblems of equal size  in classical problem solving  an abstract solution
is found by breadth first or depth first search using linear  e g   alpine  knoblock       
or non linear  e g   abtweak  yang   tenenberg        problem solvers  for these problem solvers  the upward solution property  tenenberg        usually holds  which means
that an abstract solution exists if a concrete level solution exists  usually  these problem
solvers find an arbitrary abstract solution  e g   the shortest possible solution   unfortunately  there is no way to guarantee that the computed solutions are refinable and lead to
mostly independent subproblems of suciently equal size  even if such a solution exists 
in general  there are not even heuristics which try to guide problem solving towards the
aspired kind of useful abstractions  this problem is illustrated by the following example 
which additionally shows the limitation of abstraction by dropping sentences 
imagine a large  or even infinite  state space which includes at least the   distinct states
shown on the left of figure    each of these   states is described by the presence or absence of
three sentences e    e    and e   in the state description  in the   bit vector shown in figure
       indicates the absence of the sentence and     represents the presence of the sentence 
the   different states described by these three sentences are arranged in a   dimensional
cube  using one dimension for each sentence  the arrows in this diagram show possible state
transitions by the available operators of the domain   each operator manipulates  adds or
deletes  exactly one sentence of the state description  if certain conditions on the other
sentences are fulfilled  the representation of two of these operators is shown on the right
   the dashed lines do not represent operators and are only introduced to make the shape of the cube more
easy to see 

  

fibuilding and refining abstract planning cases

z

   

   

two example operators 
   

   

x z
   

e 
y
x

   

   

e 
e 

   

o          
precondition 
e  and
 not e   and
 not e  

o          
precondition 
e  and
 not e   and
e 

add  e 

delete  e 

y

figure    state space of an example domain and representation of two operators
side of this figure  the subscript of the operator name relates to the respective transition
in the state diagram  in general  we can see that

 e   can be manipulated  if and only if e    e   holds 
 e   can be manipulated  if and only if e    e   holds  and
 e   can be manipulated  if and only if e     e   holds 
furthermore  assume that there are many more operators which connect some other states
of the domain  not shown in the diagram  to the   depicted states  consequently  we
must assume a branching factor of b    at each state  which makes the search space for
problem solving quite large  besides the description of the domain  figure   also shows
three example problems  x   x    y   y   and z   z     for example  the solution to the
problem x   x   is the   step path                                   
now  let s consider the abstract solutions which correspond to the concrete solutions for
each of the three problems  for each problem  we want to examine the three possible ways of
abstraction by dropping one of the sentences  for this purpose  the geometric arrangement
of the states turns out to be very useful because abstraction can be simply viewed as
projecting the   dimensional state space onto the plane defined by the sentences which are
not dropped by abstraction  the left part of figure   shows the three possible abstract
state spaces which result from dropping one of the sentences  here it is very important
to see that in each abstract state space  every sentence can be modified unconditionally
and independent of the other sentences  however  only one sentence can be modified by
each operator  thereby  all the constraints that exist at the concrete level are relaxed 
the abstraction of the concrete solution to each of the three problems  x   x    y   y  
and z   z    with respect to the three possible ways of dropping conditions is shown on
  

fibergmann   wilke

state spaces by
dropping conditions

x  x

y  y

e 

 

e 
 

 

 

 
 
e 

 

 

e 
e 

z  z

 

 

 

e 
 

 

 

e 
 

e   

 
 

 

e 

 

 
 

 
  e 

 
 

e 

 

 
e 

 

 

figure    abstract state spaces by dropping conditions
the right side of figure    each of the nine possible abstract solutions consists of three
or four abstract operators  the sequence in which they have to be applied is indicated
by the numbers which mark these operators  we can also see that whatever sentence we
drop for any of the problems  an appropriate abstract solution exists which decomposes
the original problem into independent refinable subproblems of suciently equal size  the
main point about this example is that none of these abstract solutions will be found by a
hierarchical problem solver  the reason for this is that for each of the abstracted problems
there also exists a   step or a   step solution in addition to the nine   step or   step solutions
indicated by the depicted paths  however  such a short solution is completely useless for
reducing the search at the next more concrete level because the original problem is not
decomposed at all  the central problem with this is that most problem solvers will find
the shorter but useless solutions first  and try to refine them  consequently  the search
space on the concrete level is not reduced so that no performance improvement is achieved
at all  however  there might be other representations of this example domain in which a
hierarchical problem solver comes to a useful abstract solution  we think  however  that
the representation shown is quite natural because it represents the   different states with
the minimal number of binary sentences 
to summarize  we presented an example in which a useful abstract solution is not found
by hierarchical planning although it exists  the reason for this is that planners usually try
to find shortest solutions  which is a good strategy for the ground level  but which may
not be appropriate at the abstract level  neither it is desirable to search for the longest
solutions because this might cause unnecessarily long concrete plans 

   case abstraction and refinement

as a way out of this problem  we propose to use experience given in the form of concrete
planning cases and to abstract this experience for its reuse in new situations  therefore 
we need a powerful abstraction methodology which allows the introduction of a completely
new abstract terminology at the abstract level  this makes it possible that useful abstract
solutions can be expressed for domains in which abstraction by dropping conditions is not
sucient  in particular  this methodology must not only serve as a means to analyze
different abstraction approaches  but it must allow ecient algorithms for abstracting and
refining problems and solutions 
  

fibuilding and refining abstract planning cases

    the basic idea
we now introduce an approach which achieves case abstraction and refinement by changing
the representation language  as a prerequisite  this approach requires that the abstract
language itself  state description and operators  is given by a domain expert in addition to
the concrete level description  we also require that a set of admissible ways of abstracting
states is implicitly predefined by a generic abstraction theory  this is of course an additional
knowledge engineering requirement  but we feel that this is a price we have to pay to
enhance the power of hierarchical problem solving  recent research on knowledge acquisition
already describes approaches and tools for the acquisition of concrete level and abstract level
operators in real world domains  schmidt   zickwolff        schmidt         an abstract
language which is given by the user has the additional advantage that abstracted cases are
expressed in a language with which the user is familiar  consequently  understandability and
explainability  which are always important issues when applying a system  can be achieved
more easily 
as a source for learning  we assume a set of concrete planning cases  each of which
consists of a problem statement together with a related solution  as is the case in prodigy
 minton et al          we only consider sequential plans  i e   plans with totally ordered
operators  the planning cases we assume do not include a problem solving trace as for example the problem solving cases in prodigy analogy  veloso        veloso   carbonell 
      veloso         in real world applications  a domain expert s solutions to previous
problems are usually recorded in a company s filing cabinet or database  these cases can
be seen as a collection of the company s experience  from which we want to draw power 
during a learning phase  a set of abstract planning cases is generated from each available
concrete case  an abstract planning case consists of an abstracted problem description
together with an abstracted solution  the case abstraction procedure guarantees that the
abstract solution contained in an abstract case can always be refined to become a solution
of the concrete problem contained in the concrete case that became abstracted  different
abstract cases may be situated at different levels of abstraction or may be abstractions
according to different abstraction aspects  different abstract cases can be of different utility
and can reduce the search space at the concrete level in different ways  it can also happen
that several concrete cases share the same abstraction  the set of all abstract planning cases
that are learned is organized in a case base for ecient retrieval during problem solving 
during the problem solving phase  this case base is searched until an abstract case is
found which can be applied to the current problem in hand  an abstract case is applicable
to the current problem if the abstracted problem contained in the abstract planning case
is an abstraction of the current problem  however  we cannot guarantee that an abstract
solution contained in a selected abstract case can really be refined to become a solution to
the current problem  it is at least known that each abstract solution from the case base
was already useful for solving one or more previous problems  i e   the problems contained
in those concrete cases from which the abstract case was learned  since the new problem is
similar to these previous problems because both can be abstracted in the same way  there is
at least a high chance that the abstract solution is also useful for solving the new problem 
when the new problem is solved by refinement a new concrete case arises which can be
used for further learning 
  

fibergmann   wilke

learning

the paris system

evaluation 
indexing

case base

generalization

abstraction

problem solving
retrieval

domain description
concrete domain 
abstract domain 
generic abstraction theory

new problem

specialization

refinement

solved problem

training cases

figure    the components of the paris system

    the paris architecture
paris  plan abstraction and refinement in an integrated system  follows the basic ap 

proach just described  figure   shows an overview of the whole system and its components 
besides case abstraction and refinement  paris also includes an explanation based approach
for generalizing cases during learning and for specializing them during problem solving  furthermore  the system also includes additional mechanisms for evaluating different abstract
cases and generalizations derived by the explanation based component  this evaluation
component measures the reduction in search time caused by each abstract plan when solving those concrete problems from the case base for which the abstract plan is applicable 
based on this evaluation  several different indexing and retrieval mechanisms have been developed  in these retrieval procedures those abstract cases are preferred which have caused
the most reduction in search during previous problem solving episodes  in particular  abstract cases which turn out to be useless for many concrete problems may even become
completely removed from the case base  the spectrum of developed retrieval approaches
ranges from simple sequential search  via hierarchical clustering up to a sophisticated approach for balancing a hierarchy of abstract cases according to the statistical distribution of
the cases within the problem space and their evaluated utility  more details on the generalization procedure can be found in  bergmann      a   while the evaluation and retrieval
mechanisms are reported in  bergmann   wilke        wilke         the whole multistrategy system including the various interactions of the described components will be the
topic of a forthcoming article  while first ideas can already be found in  bergmann      b 
       however  as the target of this paper we will concentrate on the core of paris  namely
the approach to abstraction and refinement 
  

fibuilding and refining abstract planning cases

state abstractions
abstract plan

a 

   

   

a 
   

   

   

a 

   

a 

a 

a 

a 

   
   
   

   

   

   
   
   

changing
representration

   

a 

   

figure    an example of case abstraction

    informal description of the abstraction approach

we first give an informal description of the abstraction approach in paris  based on our
small example shown in figure   to enhance the understanding of the subsequent formal
sections  suppose that the solution to the problem x   x   is available as a concrete problem solving experience  the task is now to learn an abstract case which can be beneficially
used to solve future problems such as y   y   and z   z     this learning task must be
achieved within an abstraction approach which is stronger than dropping sentences  if we
look at figure    it becomes obvious that by changing the representation a single abstract
case can be learned which is useful for all three concrete problems  the abstract plan shown
indicates which concrete states have to be abstracted towards a single abstract state  such
that a single abstract plan exists which is useful for all three problems 
      abstract language and generic abstraction theory

to achieve this kind of abstraction  our approach requires that the abstract language  states
and operators   as well as a generic abstraction theory is provided by the user  for the example in figure    the abstract language must contain the new abstract sentences a            a 
and the three abstract operators which allow the respective state transitions  these abstract
operators  called oai  i   f            g   can be defined as follows 
operator  oai
precondition  ai
delete  ai
add  ai  

for each new abstract sentence  the user must provide a set of generic abstraction rules
which describe how this sentence is defined in terms of the available sentences of the con  

fibergmann   wilke

crete language  the generic abstraction theory defined by these rules specifies a set of
admissible state abstractions  for our example  the generic abstraction theory must contain the following two rules to define the new abstract sentence a     e     e     a  and
 e      e      e     a   in general  the definition of the generic abstraction theory does
not require that all state abstractions are noted explicitly  abstract states can be derived
implicitly by the application of a combination of several rules from the generic abstraction
theory 
besides the kind of abstraction described above  the user may also want to specify
a different type of abstraction which she he also considers useful  for example  we can
assume that abstraction by dropping the sentence e   should also be realized  in this case 
the abstract language must contain a copy of the two sentences which are not dropped  i e  
the sentences e   and e    therefore  the user  may define two abstract sentences a  and
a  by the following rules of the generic abstraction theory  e     a  and e     a   of
course  the respective abstract operators must also be specified 
since the domain expert or knowledge engineer must provide the abstract language and
the generic abstraction theory  she he must already have one or more particular kinds of
abstraction in mind  she he must know what kind of details can be omitted when solving
a problem in an abstract fashion  with our approach  the knowledge engineer is given the
power to express the kind of abstraction she he considers useful 
      model of case abstraction

based on the given abstract language and the generic abstraction theory  the abstraction of
a planning case can be formally described by two abstraction mappings  a state abstraction
mapping and a sequence abstraction mapping  these two mappings describe two dimensions
for reducing the level of detail in a case  the state abstraction mapping reduces the level
of detail of a state description while changing the representation language  for the case
abstraction indicated in figure    the state abstraction mapping must map the concrete
states          and     onto an abstract state described by the new sentence a   and
simultaneously it must map all other concrete states occurring in the plan onto the respective
abstract states described by the new sentences a    a    and a    the sequence abstraction
mapping reduces the level of detail in the number of states which are considered at the
abstract level by relating some of the concrete states from the concrete case to abstract
states of the abstract case  while some of the concrete states can be skipped  each abstract
state must result from a particular concrete state  for example  in figure    the abstraction
of the plan                                   requires a sequence abstraction mapping
which relates the first abstract state described by a  to the first concrete state      the
second abstract state described by a  to the third concrete state      and so forth  in this
example  the second and the fifth concrete states are skipped 
      learning abstract planning cases

the procedure for learning such abstract planning cases from a given concrete planning case
is decomposed into four separate phases  for our simple example  these phases are shown in
   please note that for abstraction by dropping sentences  we can also consider an alpine like algorithm
which generates the required abstract language and the generic abstraction theory automatically 

  

fibuilding and refining abstract planning cases

a a 

a 

ca  
phase iv
ca   a 

oa  

phase iii

a 

oa  

oa  

a 

a 

oa  

oa  

oa  

a 

oa  

oa  

phase ii

a 

a   a 

a   a 

a   a  a 

a   a 

a   a 

phase i

   

   

   

   

   

   

figure    the four phases of case abstraction for the solution to the problem x   x  
figure    in phase i  the states which result from the execution of the plan contained in the
concrete case are determined  therefore  each operator contained in the plan  starting from
the first operator  is applied and the successor state is computed  this process starts at the
initial state contained in the case and leads to a final state  which should be the goal state
contained in the case  in phase ii  we derive all admissible abstractions for each concrete
state computed in the first phase  for this purpose  the generic abstraction theory is used
to determine all abstract sentences that can be derived from a respective concrete state by
applying the rules of the generic abstraction theory  figure   shows the abstract sentences
that can be derived by the generic abstraction theory sketched above  for example  we can
see that for the second concrete state an abstract description can be derived which contains
two abstract sentences  the abstract sentence a  required to achieve the type of abstraction
shown in figure   and additionally the abstract sentences a  required for abstraction by
dropping sentences  please note that by this process  the representation language of states
is changed from concrete to abstract  the next two phases deal with the abstract operators 
as already stated  abstract operators are given in the abstract language provided by the
user  however  we do not assume operator abstraction rules which associate an abstract
operator to a single concrete operator or a sequence of concrete operators  the reason for
this is that such operator abstraction rules are extremely hard to acquire and even harder
to keep complete  in the next two phases of case abstraction  we search for transitions of
abstract states based on the available abstract operators  in phase iii  an acyclic directed
graph is constructed  an edge leads from an abstract state i to a successor abstract state
j  not necessarily to the next abstract state   if the abstract operator is applicable in state
i and its application leads to the state j   the definition of the abstract operators are
used in this process  the available abstract operators determine which transitions can be
included in the graph  figure   shows the resulting graph  provided that the abstract
operators sketched in section       are contained in the abstract language  in this graph
  

fibergmann   wilke

the transitions shown in plain line style result from the operators oai   while the transitions
shown in dashed line style result from the operators required for abstraction by dropping
conditions 
in phase iv the graph is searched for consistent paths from the initial abstract state to
the final abstract state  the paths must be consistent in the sense that in the resulting
path  i e   an abstract plan  every abstract operator is correctly applicable in the state that
results from the previous operator  moreover  the state abstraction which is required for
this abstract plan must not change within the plan  in figure   two paths of this kind are
shown  the lower path represents the abstract planning case ca   abstract initial and final
state together with the operator sequence  that results from the kind of abstraction shown
in figure    the upper path represents the abstract planning case ca  that results from
abstraction by dropping the sentence e    this is the same abstract plan as shown in figure
  for the problem x   x    together with the two plans  the abstract state descriptions that
result from the operator application are shown  please note that these state descriptions
are always a subset of the description which are derived by the generic abstraction theory 
for example  the description of the fourth abstract state derived in phase ii  contains the
sentences a    a   a   this abstract state occurs in both abstract cases which are computed
in phase iv  in the case ca    the respective state is described by the sentences a  and
a  because these are the only sentences which result from the application of the operators
starting at the abstract initial state  in the case ca   the abstract state is described by
the sentence a  because this sentence results from the application of the operator oa  
from this example we can see that the abstract operators have two functions  the first
function is to select some of the concrete states that become abstracted  for example  in
the abstract case ca   the second concrete state is skipped  even if the first and the second
concrete states can be abstracted to different abstract descriptions in phase ii  the reason
for this is that there is no abstract operator that a  leads from the first abstracted state
to the second abstracted state and which b  is also consistent with the other operators in
the rest of the path  the second function of the abstract operators is to select some of the
abstract sentences that are considered in the abstract planning case  for example  in the
abstract case ca    the sentences a            a  are considered while the sentences a  and a 
are left out  the reason for this is that the abstract operators oa    oa   oa  which occur in
the plan don t use a  and a  in their precondition and don t manipulate these sentences 
after phase iv is finished  a set of abstract planning cases is available  these planning
cases can then be stored in the case base and used for further problem solving 
      selecting and refining abstract cases

during problem solving  an abstract case must be selected from a case base  and the abstract
plan contained in this case must be refined to become a solution to the current problem 
during case retrieval we must search for an abstract case which is applicable  i e   it contains
a problem description that is an abstraction of the current problem  for example  assume
that the problem y   y   should be solved after the case x   x   was presented for learning 
in this situation the case base contains the two abstract cases ca  and ca  shown in phaseiv of figure    the abstract case ca  can be used for solving the new problem  because
the initial state     of the new problem can be abstracted to a  by applying the generic
  

fibuilding and refining abstract planning cases

selected abstract case 

a 

defined search spaces 

   

refined solution 

   

oa  

   

a 

oa  

a 

 

 

   

   

oa  

a 

   

   

   

figure    refinement of an abstract case for the solution of the problem y   y  
abstraction theory  similarly  the final state     can be abstracted to a    however  the
abstract case ca  is not applicable because the final abstract state cannot be abstracted to
a   consequently  the lower abstract case must be used  during plan refinement we can
refine the abstract operators sequentially from left to right as shown in figure    thereby
each abstract operator defines an abstract goal state  i e   the state that results after the
execution of the operator  for example  the abstract operator oa  defines the abstract goal
a   to refine an abstract operator  we search for a concrete operator sequence  starting
from the current concrete state  i e   the initial state for the first operator   until a concrete
state is reached that can be abstracted to the desired goal state  if such a state is found
it can be used as a starting state for the refinement of the next abstract operator  for
the solution of the problem y   y     the refinement of the abstract operator oa  can be
achieved by a sequence of two concrete operators leading to the concrete state      this
concrete state is then used as a starting state to refine the next abstract operator oa  
this refinement procedure finishes if the last abstract operator is refined in a way that the
final concrete state is achieved  please note that in this type of refinement the operators
themselves are not used directly  instead the sequence of states which results from their
execution are used  alternatively  we could have also stored an abstract case as a sequence
of abstracted states  from our experience  storing a sequence of operators requires less
space than storing a sequence of states  this will become obvious when looking at the
domain that will be introduced in section    besides this the abstract operators play an
important role in the learning phase 

    relations to skeletal plans
a similar experience based or case based variant for finding an abstract solution can be
found in an early paper by friedland and iwasaki        in which the concept of skeletal
plans is introduced  a skeletal plan is        a sequence of generalized steps  which  when
instantiated by specific operations in a specific problem context will solve a given problem
 p             skeletal plans exist at many levels of generality  at the most general level  they
are only a few basic plans  but these are used as  fall backs   when more specific  easier to
refine plans cannot be found   p         skeletal plans are solutions to planning problems at
different levels of detail and are consequently abstract plans  during problem solving they
  

fibergmann   wilke

are recalled from a library and refined towards a concrete solution  so this approach can be
seen as an early idea for integrating abstraction and case based reasoning  however  there
are several differences between the skeletal plan approach and the paris approach  in the
skeletal plan approach no model of the operators  neither concrete nor abstract  is used to
describe the preconditions and effects of operators as is done in paris  there is no explicit
notion of states and abstraction or refinement of states  instead  the plan refinement is
achieved by stepping down a hierarchy of operators  guided by heuristic rules for operator
selection  in particular  no approach which supports the automatic acquisition of skeletal
plans was provided  unfortunately  the skeletal plan approach has not yet been investigated
in as much detail as current work in the field of speedup learning  there is neither a formal
model of skeletal planning nor empirical evaluations 
in the rest of this paper we will introduce and investigate the paris approach more
formally 

   basic terminology
in this section we want to introduce the basic formal terminology used throughout the rest
of this paper  therefore we will define a formal representation for problem solving domains 
we want to assume that problem solving in general can be viewed as transforming an initial
state into a final state by using a sequence of operators  newell   simon         following
a strips oriented representation  fikes   nilsson         the domain of problem solving
d   hl  e   o  ri is described by a first order language  l  a set of essential atomic sentences
e of l  lifschitz         a set of operators o with related descriptions  and additionally  a
set of rules  horn clauses  r out of l  the essential sentences  which must be atomic  are
the only sentences that are used to describe a state  a state s   s describes the dynamic
part of a situation in a domain and consists of a finite subset of ground instances of essential
sentences of e   with the symbol s   we denote the set of all possible states descriptions in a
domain  which is defined as s    e    with e    fe je   e and  is a substitution such that
e is groundg  in addition  the horn clauses r allow the representation of static properties
which are true in all situations  these horn clauses must not contain an essential sentence
in the head of a clause 
an operator o x           xn    o is described by a triple hpreo   addo  deloi  where the
precondition preo is a conjunction of atoms of l  and the add list addo and the deletelist delo are finite sets of  possibly instantiated  essential sentences of e   furthermore 
the variables occuring in the operator descriptions must follow the following restrictions 
fx           xng  v ar preo   v ar delo  and fx           xng  v ar addo   
an instantiated operator is an expression of the form o t           tn    with ti being ground
terms of l  a term ti describes the instantiation of the variable xi in the operator description  for notational convenience we define the instantiated precondition as well as the instantiated add list and delete list for an instantiated operator as follows  preo t       tn      preo   
addo t      tn     fa ja   addog  delo t      tn     fd  jd   delo g  with hpreo   addo  deloi is
   the basic language is first order  but with the deductive rules given in horn logic only a subset of the
full first order language is used 
   these restrictions can however be relaxed such that fx            xn g  v ar preo   is not required  but the
introduced restriction simplifies the subsequent presentation 

  

fibuilding and refining abstract planning cases

the description of the  uninstantiated  operator o x           xn   and    fx   t            xn  tn g
is the corresponding instantiation 
an instantiated operator o is applicable in a state s  if and only if s   r   pre
holds  
o o
an instantiated operator o transforms a state s  into a state s   we write  s     s    if and
only if o is applicable in s  and s     s  n delo     addo   a problem description p   hsi   sg i
consists of an initial state si together with a final state sg   the problem solving task
is to find a sequence of instantiated operators  a plan  o    o           ol   which transforms
ol
o 
the initial state into the final state  si   
     
sg    a case c   hp  oi is a problem
description p together with a plan o that solves p 
the introduced strips oriented formalism for defining a problem solving domain is
similar in form and expressiveness to the representations typically used in general problem
solving or planning  a state can be described by a finite set of ground atoms in which
functions can also be used  full horn logic is available to describe static rules  the restriction to horn clauses has the advantage of being powerful while allowing ecient proof
construction by using the well known sld refutation procedures  lloyd         compared
to the prodigy description language  pdl   minton        blythe et al         our language does not provide explicit quantification by a specific syntactic construct  but a similar
expressiveness can be reached by the implicit quantification in horn clauses  moreover  our
language does not provide any kind of type specification for constants or variables as in
pdl but we think that this is not a major disadvantage  besides these points our language
is quite similar to pdl 

   a formal model of case abstraction
in this section we present a new formal model of case abstraction which provides a theory
for changing the representation language of a case from concrete to abstract  as already
stated we assume that in addition to the concrete language the abstract language is supplied
by a domain expert  following the introduced formalism  we assume that the concrete level
of problem solving is defined by a concrete problem solving domain dc   hlc   ec  oc   rci
and the abstract level of  case based  problem solving is represented by an abstract problem solving domain da   hla   ea  oa  rai  for reasons of simplicity  we assume that both
domains do not share the same symbols    this condition can always be achieved by renaming symbols  in the remainder of this paper states and operators from the concrete
domain are denoted by sc and oc respectively  while states and operators from the abstract
domain are denoted by sa and oa respectively  the problem of case abstraction can now be
described as transforming a case from the concrete domain dc into a case in the abstract
domain da  see figure     this transformation will now be formally decomposed into two
independent mappings  a state abstraction mapping ff  and a sequence abstraction mapping
fi  bergmann      c   the state abstraction mapping transforms a selection of concrete
state descriptions that occur in the solution to a problem into abstract state descriptions 
   in the following  we will simply omit the parameters of operators and instantiated operators in case they
are unambiguous or not relevant 
   otherwise  a symbol  or a sentence  could become ambiguous which would be a problem when applying
the generic abstraction theory  it would be unclear whether a generic abstraction rule refers to a concrete
or an abstract sentence

  

fibergmann   wilke

abstract
domain 

da

a
o 

a

s 

s  a


concrete
domain 

dc

s c 

a
o 

a
oj

s ja


oc 

        

s c 

oc 

c

s 

oc 

c

s 
        

a
o j  

a
om

oci  

ocn


oc 

oci

s ci
  j    i

s am

s cn
  m    n

figure    general idea of abstraction
while the sequence abstraction mapping specifies which of the concrete states are mapped
and which are skipped 

    state abstraction

a state abstraction mapping translates states of the concrete world into the abstract world 
definition    state abstraction mapping  a state abstraction mapping ff   sc   sa is a
mapping from sc   the set of all states in the concrete domain  to sa  the set of all states in
the abstract domain  in particular  ff must be an effective total function 
this general definition of a state abstraction mapping does not impose any restrictions
on the kind of abstraction besides the fact that the mapping must be a total many toone function  however  to restrict the set of all possible state abstractions to a set of
abstractions which a user considers useful  we assume that additional domain knowledge
about how an abstract state relates to a concrete state can be provided  this knowledge
must be expressed in terms of a domain specific generic abstraction theory a  giordana 
roverso    saitta        

definition    generic abstraction theory  a generic abstraction theory is a set of horn
clauses of the form ea a            ak   in these rules ea is an abstract essential sentence 
i e   ea   ea for ea   ea and a substitution    the body of a generic abstraction rule
consists of a set of sentences from the concrete or abstract language  i e   ai are atoms out
of lc   la  
based on a generic abstraction theory  we can restrict the set of all possible state abstraction
mappings to those which are deductively justified by the generic abstraction theory 

definition    deductively justified state abstraction mapping  a state abstraction mapping ff is deductively justified by a generic abstraction theory a  if the following conditions
hold for all sc   sc  
 if    ff sc   then sc   rc   a    and
 if    ff sc   then for all s c such that s c   rc   a    holds     ff  sc   is also fulfilled 
  

fibuilding and refining abstract planning cases

in this definition the first condition assures that every abstract sentence reached by
the mapping is justified by the abstraction theory  additionally  the second requirement
guarantees that if an abstract sentence is used to describe an abstraction of one state  it
must also be used to describe the abstraction of all other states  if the abstract sentence can
be derived by the generic abstraction theory  please note that a deductively justified state
abstraction mapping can be completely induced by a set ff  ea with respect to a generic
abstraction theory as follows  ff sc      f   ff jsc   rc   a   g  unless otherwise stated
we always assume deductively justified state abstraction mappings  to summarize  the
state abstraction mapping transforms a concrete state description into an abstract state
description and thereby changes the representation of a state from concrete to abstract 
please note that deductively justified state abstraction mappings need not to be defined
by the user  they will be determined automatically by the learning algorithm that will be
presented in section   

    sequence abstraction

the solution to a problem consists of a sequence of operators and a corresponding sequence
of states  to relate an abstract solution to a concrete solution  the relationship between
the abstract states  or operators  and the concrete states  or operators  must be captured 
each abstract state must have a corresponding concrete state but not every concrete state
must have an associated abstract state  this is due to the fact that abstraction is always a
reduction in the level of detail  michalski   kodratoff         in this situation  a reduction
in the number of states  for the selection of those concrete states that have a corresponding
abstraction  the sequence abstraction mapping is defined as follows 

definition    sequence abstraction mapping  a sequence abstraction mapping fi   n   n

relates an abstract state sequence  sa            sam   to a concrete state sequence  sc           scn   by
mapping the indices j   f           mg of the abstract states saj into the indices i   f           ng
of the concrete states sci   such that the following properties hold 

 fi        and fi m    n  the initial state and the goal state of the abstract sequence

must correspond to the initial and goal state of the respective concrete state sequence 

 fi u    fi v  if and only if u   v  the order of the states defined through the concrete
state sequence must be maintained for the abstract state sequence 

note that the defined sequence abstraction mapping formally maps indices from the abstract
domain into the concrete domain  as an abstraction mapping it should better map indices
from the concrete domain to indices in the abstract domain  such as the inverse mapping
fi    does  however  such a mapping is more inconvenient to handle formally since the
range of definition of fi    must always be considered  therefore we stick to the presented
definition 

    case abstraction

based on the two abstraction functions introduced  our intuition of case abstraction is
captured in the following definition 
  

fibergmann   wilke

hierarchies of abstraction spaces
dl
different kinds of abstractions
d 

da
da 
dc

da

d 

da 
d 

d 

dc

figure    different kinds of abstractions  a  and abstraction hierarchies  b 

definition    case abstraction  a case ca   hhsa    sami   oa           oam i is an abstraction
of a case cc   hhsc   scn i   oc           ocn i with respect to the domain descriptions  dc   da  if
oaj a
oci c
sci     
si for all i   f           ng and saj     
sj for all j   f           mg and if there
exists a state abstraction mapping ff and a sequence abstraction mapping fi   such that 
saj   ff scfi j   holds for all j   f           mg 

this definition of case abstraction is demonstrated in figure    the concrete space shows
the sequence of n operations together with the resulting state sequence  selected states are
mapped by ff into states of the abstract space  the mapping fi maps the indices of the
abstract states back to the corresponding concrete states 

    generality of the case abstraction methodology

in the following  we briey discuss the generality of the presented case abstraction methodology  we will see that hierarchies of abstraction spaces as well as different kinds of abstractions can be represented simultaneously using the presented methodology 
      different kinds of abstractions

in general  there will be more than one possible abstraction of an object in the world 
abstraction can be performed in many different ways  an example of two different abstractions of the same case has already been shown in the example in figure    in this example 
two different abstractions  see the abstract cases ca  and ca   have been derived from the
same concrete case  our abstraction methodology is able cope with different abstractions
in case they are specified by the user  assume we are given one concrete domain dc and
two different abstract domains da  and da    each of which represents two different kinds
of abstraction  furthermore  assume that both abstract domains do not share the same
symbols     we can always define a single abstract domain da by joining the individual
abstract domains which then includes both kinds of abstractions  see figure    a    this
property is formally captured in the following simple lemma 
    if the abstract domains are not disjoint  symbols can be simply renamed to achieve this property 

  

fibuilding and refining abstract planning cases

lemma    joining different abstractions  if a concrete domain dc and two disjoint abstract domains da  and da  are given  then a joint abstract domain da   da    da  can be
defined as follows  let da     la   ea   oa   ra   and let da     la   ea   oa   ra    then
da   da    da     la    la    ea    ea    oa    oa    ra    ra    the joint abstract domain
da fulfills the following property  if ca is an abstraction of cc with respect to  dc  da   or
with respect to  dc   da    then ca is also an abstraction of cc with respect to  dc   da  
      hierarchy of abstraction spaces

most work on hierarchical problem solving assume a multi level hierarchy of abstraction
spaces for problem solving  e g   sacerdoti        knoblock         even if the presented
approach contains only two domain descriptions  a hierarchy of abstract domains can simply
be mapped onto the presented two level model as shown in figure    b   assume that a
hierarchy of disjoint domain descriptions  d           dl  is given  in particular  the domain
d   is assumed to be more abstract than the domain d   in such a multi level hierarchy
of abstraction spaces  a case c at the abstraction level d is an abstraction of a case c   if
there exists a sequence of cases  c            c      such that ci is out of the domain di and ci  
is an abstraction of ci with respect to  di   di    for all i   f               g  such a multilevel hierarchy of domain descriptions can always be reduced to a two level description  the
abstract domain of this two level description contains the union of all the levels from the
multi level hierarchy  this property is formally captured in the following lemma 

lemma    multi level hierarchy  let  d           dl  be an arbitrary multi level
hierarchy
s
l
of domain descriptions  for the two level description  dc   da   with da       d and
dc   d  holds that  if ca is an abstraction of cc with respect to  d           dl  then ca is
also an abstraction of cc with respect to  dc   da   
since we have shown that different kinds of abstractions as well as hierarchies of abstraction spaces can be directly represented within our two level case abstraction methodology 
we can further restrict ourselves to exactly these two levels 

   computing case abstractions

we now present the pabs algorithm  bergmann      c  wilke        for automatically
learning a set of abstract cases from a given concrete case  thereby  we assume that a
concrete domain dc and an abstract domain da are given together with a generic abstraction
theory a  we use the functional notation ca   pabs hdc   da  ai  cc  to denote that ca is
an element of the set of abstract cases returned by the pabs algorithm 
the algorithm consists of the four separate phases introduced in section    in the
following we will present these phases in more detail 
in the first three phases  we require a procedure for determining whether a conjunctive
formula is a consequence of a set of horn clauses  for this purpose  we use a sld refutation
procedure  lloyd        which is given a set of horn clauses  a logic program  c together
with conjunctive formula g  a goal clause   the refutation procedure determines a set of
answer substitutions 
 such that c   g holds for all    
  we write 
   sld c  g  
this sld refutation procedure performs some kind of backward chaining and works as
  

fibergmann   wilke

follows  it selects a literal from the goal clause g  i e   the left most literal  and searches
for a horn clause in the logic program c that contains a literal in its head that unifies with
the selected goal literal  the selected literal is removed from g and the body  if not empty 
of the applied clause is added at the beginning of the goal clause  then the most general
unifier of the goal literal and the head of the clause is applied to the whole new goal clause 
the resulting goal clause is called resolvent  this process continues until the goal clause
becomes empty or until no more resolvents can be built  in the former case  the goal has
been proven and an answer substitution is computed by composing the substitutions used
during resolution  backtracking is used to look for possible other selections of applicable
horn rules to determine alternative answer substitutions  the set of all answer substitutions
is returned as set 
  if the whole space of possible applications of the available horn rules
has been searched unsuccessfully  the goal clause is not a consequence of the logic program
c and the sld refutation procedure terminates without an answer substitution  
      
this must not be confused with the situation in which an empty substitution is returned
 
   f g   if no variables occur in g  in phase iii of the pabs algorithm  we will also require
the derivation trees in addition to the answer substitutions  then we write    sld c  g 
and assume that  is a set of pairs        where  is an answer substitution and  is a
derivation of c   g  
in order to assure the termination of the sld refutation procedure we have to require
that the abstract domain and the generic abstraction theory is designed according to the
following principles    
 for each concrete state sc   sc and each concrete operator oc   oc where oc is
described by hpreoc   addoc   deloc i  sld sc   rc   preoc   must lead to a finite set of
ground substitutions of all variables which occur in preoc  
 for each state abstract sa   sa and each abstract operator oa   oa where oa is
described by hpreoa   addoa   deloa i  sld sa   ra  preoa   must lead to a finite set of
ground substitutions of all variables which occur in preoa  
 for each state sc   sc and each abstract essential sentence e   ea  sld sc  rc  a  e  
must lead to a finite set of ground substitutions of all variables which occur in e  
in the following the four phases of the pabs algorithm are explained in detail 

    phase i  computing the concrete state sequence

as input to the case abstraction algorithm  we assume a concrete case cc  
hhsci   scgi   oc           ocn i  note that  oc           ocn  is a totally ordered sequence of instantiated operators similar to the plans in prodigy  minton        minton et al         veloso
  carbonell         in the first phase  the state sequence which results from the simulation
of problem solution is computed as follows 

    at first glance  this restrictions seem a bit hard to achieve but if we take a closer look at it we can see
that this is the standard requirement for a  terminating  logic program  i e   a prolog program  

  

fibuilding and refining abstract planning cases

algorithm    phase i  computing the concrete state sequence 
sc     sci
for i      to n do
if sld sci     rc  preoci       then stop  failure  operator not applicable 
sci     sci   n deloci     addoci

end
if scg   scn then stop  failure  goal state not reached 

oc

i
by this algorithm  the states sci are computed  such that sci     
sci holds for all
i   f           ng  if a failure occurs the given plan is not valid  i e   it does not solve the given
problem 

    phase ii  deriving abstract essential sentences

using the derived concrete state sequence as input  the following algorithm computes a
sequence of abstract state descriptions  sai   by applying the generic abstraction theory
separately to each concrete state 

algorithm    phase ii  state abstraction 
for i      to n do
sai     
for each e   ea do

    sld sci   rc   a  e  
for each    
 do
sai    sai   fe g
end
end
end
please note that we have claimed that the domain theories are designed in a way that

 is finite and only contains ground substitution of all variables in e   therefore  every
description sai consists only of ground atoms and is consequently a valid abstract state
description  within the introduced model of case abstraction we have now computed a
superset for the outcome of possible state abstraction mappings  each deductively justified
state abstraction mapping ff is restricted by ff sci    sai   fe   sa jsci   rc   a   eg for all
i   f           ng  consequently  we have determined all abstract sentences that an abstract
case might require 

    phase iii  computing possible abstract state transitions

in the next phase of the algorithm  we search for instantiated abstract operators which
can transform an abstract state s ai  sai into a subsequent abstract state s aj  saj  i   j   
therefore  the preconditions of the instantiated operator must at least be fulfilled in the
state s ai and consequently in also sai   furthermore  all added effects of the operator must
be true in s aj and consequently also in saj  
  

fibergmann   wilke

algorithm    phase iii  abstract state transitions 
g     
for i      to n     do
for j    i     to n do
for each o x           xu    oa do
let hpreo   delo  addoi be the description of o x           xu 
    sld sai   ra   preo 
for each h   i    do
letadd o   faja   addog
   compute all possible instantiations   
   of added sentences which hold in saj   
m    f g
   m is the set of possible substitutions   
   initially the empty substitution    

for each a   add o do
m       
for each    m do
for each e   saj do
if there is a substitution  such that a   e then m      m     fg
end
end
m    m  

end

   now  m contains the set of all possible substitutions   
   such that all added sentences are contained in saj   

for each    m do
g    g   fhi  j  o x           xu     ig
end
end
end
end
end

the set of all possible operator transitions are collected as directed edges of a graph which
vertices represent the abstract states  in the algorithm  the set g of edges of the acyclic
directed graph is constructed  for each pair of states  sai saj   with i   j it is checked
whether there exists an operator o x           xu   which is applicable in sai   for this purpose 
the sld refutation procedure computes the set of all possible answer substitutions  such
that the precondition of the operator is fulfilled in sai   the derivation  which belongs
to each answer substitution is stored together with the operator in the graph since it is
required for the next phase of case abstraction  this derivation is an  and tree  where
each inner node reects the resolution of a goal literal with the head of a clause and each
leaf node represents the resolution with a fact  note that for proving the precondition of
an abstract operator the inner nodes of the tree always refer to clauses of the horn rule set
ra  while the leave nodes represent facts stated in ra or essential sentences contained in
  

fibuilding and refining abstract planning cases

sai   then each answer substitution  is applied to the add list of the operator leading to a
partially instantiated add list add o  note that there can still be variables in add o because

the operator may contain variables which are not contained in its precondition but may
occur in the add list  therefore  the set m of all possible substitutions  is incrementally
constructed such that a   saj holds for all a   add o  the completely instantiated operator
derived thereby is finally included as a directed edge  from i to j   in the graph g 
by this algorithm it is guaranteed that each  instantiated  operator which leads from sai
to saj is applicable in sai and that all essential sentences added by this operator are contained
in saj   furthermore  if the applied sld refutation procedure is complete  it always finds all
answer substitutions   then every instantiated operator which is applicable in sai such that
all essential sentences added by this operator are contained in saj is also contained in the
oai
graph  from this follows immediately that if ff scfi  i       
ff scfi i    holds for an arbitrary
deductively justified state abstraction mapping ff and a sequence abstraction mapping fi  
then hfi  i       fi  i   oai   i   g also holds 

    phase iv  determining sound paths

based on the state abstractions sai derived in phase ii and on the graph g computed in the
previous phase  phase iv selects a set of sound paths from the initial abstract state to the
final abstract state  a set of significant abstract sentences ff and a sequence abstraction
mapping fi are also determined during the construction of each path 
algorithm    phase iv  searching sound paths   
paths    fh        fi        ig
while there exists h oa           oak   ff  fii   paths with fi k    n do
paths    paths n h oa            oak    ff  fii
for each hi  j  oa   i   g with i   fi k  do
let e be the set of essential sentences contained in the derivation 
let ff    e   addoa   ff
if for all    f    a      kg holds 
o a
 safi         ff      
 sfi       ff    and
a
o  sa   ff    then
 safi  k    ff      
j
paths    paths   fh oa            oak  oa   ff   fi   ffi k        j gi g

end
end

casesabs     
for each h oa            oak   ff  fii   paths with fi k    n do
casesabs    casesabs   fhhsa    ff   san   ff i   oa            oak ig

end
return casesabs

while the construction of the sequence abstraction mapping is obvious  the set ff represents the image of a state abstraction mapping ff and thereby determines the set of sentences

    please note that h oa            oak    ff  fi i matches fh        fi         ig with k      the operator n denotes
set difference 

  

fibergmann   wilke

that have to be reached in order to assure the applicability of the constructed operator sequence  note that from ff the state abstraction mapping ff can be directly determined as
follows  ff sci     fe   ff jsci   rc   a   eg  the idea of the algorithm is to start with an
empty path  a path is extended by an operator from g in each iteration of the algorithm
until the path leads to the final state with the index n  new essential sentences ff  may
occur in the proof of the precondition or as added effects of this new operator  the path
constructed so far must still be consistent according to the extension of the state description
and  in addition  the new operator must transform the sentences of ff correctly 
as a result  phase iv returns all cases that are abstractions of the given concrete input
case with respect to concrete and abstract domain definitions and the generic abstraction
theory  depending on the domain theory  more than a single abstract case can be learned
from a single concrete case as already shown in figure   

    correctness and completeness of the pabs algorithm

finally  we want to state again the strong connection between the formal model of case
abstraction and the presented algorithm  the algorithm terminates if the domain descriptions and the generic abstraction theory are formulated as required in the beginning of this
section  so that the sld resolution procedure always terminates  the algorithm is correct 
that is every abstract case computed by the pabs algorithm is a case abstraction according
to the introduced model  if the sld refutation procedure applied in pabs is complete every
case which is an abstraction according to definition   is returned by pabs  this property
is captured in the following theorem 

theorem    correctness and completeness of the pabs algorithm  if a complete sldrefutation procedure is used in the pabs algorithm  then case ca is an abstraction of case cc
with respect to  dc   da  and the generic theory a  if and only if ca   pabs hdc   da  ai  cc  

    complexity of the algorithm

the complexity of the algorithm is mainly determined by the phases iii and iv  the worst
case complexity of phase iii is o n   c   c   where n is the length of the concrete plan
and c  and c  are dependent on the domain theories as follows  c    joa j  j
j and c   
jaddoa j  jeajj
j jaddoaj  thereby  joaj represents the number of abstract operators  j
j is
the maximum number of substitutions found by the sld refutation procedure  jaddoa j is
the maximum number of added sentences in an abstract operator  and jeaj is the number of
abstract essential sentences  the complexity of phase iv can be determined as o n    n    
c    if we assume constant domain theories the overall complexity of the pabs algorithm can
be summarized as o n    n       the exponential factor comes from possibly exponential
number of paths in a directed acyclic graph with n nodes if every state is connected to
every successor state  whether a graph of this kind appears is very much dependent on
the abstract domain theory  because it determines which transitions of abstract states are
possible  this exponential nature does not lead to a time complexity problem in the domains
we have used  additionally  we want to make clear that this computational effort must be
spent during learning and not during problem solving  if the time required for learning is
very long  the learning phase can be executed off line 
  

fibuilding and refining abstract planning cases

the space complexity of the algorithm is mainly determined by phase iii because all
derivations of the proofs of the abstract operators  preconditions must be stored  this can
sum up to n   c   c  derivations in the worst case  this did not turn out to be a problem
in the domains we used because each derivation was very short  in most cases not more
  inferences with static horn rules   the reason for this is that the derivations relate to
abstract operators which very likely contain less preconditions than the concrete operators 

   refinement of abstract cases

in the previous section we have described how abstract cases can be automatically learned
from concrete cases  now we assume a case base which contains a set of abstract cases  we
want to show how these abstract cases can be used to solve problems at the concrete level 
furthermore  we discuss the impact of the specific form of the abstract problem solving
domain on the improvement in problem solving that can be achieved 

    applicability and refinability of abstract cases

for a given abstract case and a concrete problem description  the question arises in which
situations the abstract case can be refined to solve the concrete problem  for this kind of
refinability an a posterior definition can be easily given as follows 

definition    refinability of an abstract case  an abstract case ca can be refined to solve
a concrete problem p if there exists a solution oc to p  such that ca is an abstraction of
hp  oci 

obviously  the refinability property is undecidable in general since otherwise planning itself
would be decidable  however  we can define the applicability of an abstract case as a
decidable necessary property for refinability as follows 

definition     applicability of an abstract case  an abstract case ca   hhsa    sami 
 oa            oam i can be applied to solve a concrete problem p   hsci   scg i if there exists a state
abstraction mapping ff such that sai   im ff  for all i   f           mg and ff sci     sa  and
ff scg     sam   thereby  im ff  denotes the image of the state abstraction mapping ff  i e   all

abstract states that can be reached 

for an applicable abstract case  it is at least guaranteed that the concrete initial and goal
states map to the abstract ones and that concrete intermediate states exists that can be
abstracted as required by the abstract case 
even if applicability is a necessary precondition for refinability it does not formally
guarantee refinability  since the downward solution property  tenenberg         which states
that every abstract solution can be refined  is a too strong requirement to hold in general
for our abstraction methodology  however  it is indeed guaranteed that each abstract case
contained in the case base is already an abstraction of one or more previous concrete cases
due to the correctness of the pabs algorithm used for learning  if one of the problems
contained in these concrete cases has to be solved again it is guaranteed that the learned
abstract case can be refined to solve the problem  consequently  each abstract case in
the case base can at least be refined to solve one problem that has occurred in the past 
  

fibergmann   wilke

abstract solutions which are useless because they can never be refined to solve any concrete
problem will never be in the case base and are consequently never tried in solving a problem 
therefore  we expect that each abstract case from the case base has a high chance of being
also refinable for new similar problems for which it can be applied 

    selecting an applicable abstract case

to decide whether an abstract case can be applied to solve a concrete problem p   we
have to determine a suitable state abstraction mapping  because we assume deductively
justified state abstraction mappings 
the required state abstraction mapping ff can always
s
m

a
be induced by the set ff   i   si as shown in section      consequently  ca is applicable
to the problem p   hsci   scg i if and only if sa    f   ff j sci   rc   a   g and sam   f  
ff j scg  rc  a   g  since every abstract case we use for solving a new problem has been
learned from another concrete case  it is known that for each abstract state sai there must
be at least one concrete state  from that previous concrete state  that can be abstracted via
ff to sai   consequently  sai   im ff  holds  together with the introduced restrictions on the
definition of a and rc with respect to a complete sld refutation procedure  see section
    the applicability of an abstract case is decidable  algorithm   describes the selection of
an applicable abstract case for a problem p   hsci   scg i in more detail 
algorithm    selection of an applicable abstract case 
sai    sag     

for each e   ea do

    sld s
sci   rc   a  e  
a
a
si    si    
 e
for each e   ea do

    sld sscg   rc   a  e  
sag    sag    
 e
repeat
repeat
select a new case ca   hhsa    sam i   oa           oam i from the case base
with sa   sai and sam  sag
if no more cases available then
refinedfid  sci          scg 
return the result of refinedfid
for i   sm  to m     do sai     sai   n deloai     addoai
ff    i   sai
until  sai   ff    sa  and  sag   ff    sam
refinedfid  sci    sa           sam      ff  scg 
until refinedfid returns success p 
return success p 

at first  the initial and final concrete states of the problem are abstracted using the
generic abstraction theory  thereby  an abstract problem description hsai   sag i is determined 
then  in a pre selection step  an abstract case is chosen form the case base  all of the
abstract sentences contained in the initial and final abstract state of this case must be
  

fibuilding and refining abstract planning cases

contained in the abstracted problem description hsai   sag i  this condition  however  does not
guarantee that the selected case is applicable with respect to definition     the set ff
of abstract sentences inducing the respective state abstraction mapping is computed and
the applicability condition is checked to test whether the selected case is applicable  if
the selected case is not applicable  a new case must be retrieved  if an applicable abstract
case has been determined the refinement algorithm refinedfid  see following section  is
executed  this algorithm uses the sequence of intermediate abstract states  sa            sam     
previously determined from the abstract plan of the case  to guide the search at the concrete
level  the operators contained in the abstract plan are not used anymore  the refinement
procedure returns success p   if the refinement succeeds with the solution plan p  if the
refinement fails  the procedure returns failure   another case is selected  if no more cases
are available the problem is solved by pure search without any guidance by an abstract
plan 

    refining an abstract plan
the refinement of a selected abstract case starts with the concrete initial state from the
problem statement  the search proceeds until a sequence of concrete operations is found
which leads to a concrete state sc   such that sa    f   ff j sc   rc   a   g holds  the
applicability condition of the abstract case guarantees that such a state exists  sai   im ff  
but it is not guaranteed that the required concrete operator sequence exists too  therefore 
this search task may fail which causes the whole refinement process to fail also  if the first
abstract operator can be refined successfully a new concrete state is found  this state can
then be taken as a starting state to refine the next abstract operator in the same manner 
if this refinement fails we can backtrack to the refinement of the previous operator and try
to find an alternative refinement  if the whole refinement process reaches the final abstract
operator it must directly search for an operator sequence which leads to the concrete goal
state scg   if this concrete goal state has been reached the concatenation of concrete partial
solutions leads to a complete solution to original problem 
this refinement demands for a search procedure which allows an abstract goal specification  all kinds of forward directed search such as depth first iterative deepening  korf 
    b  or best first search  korf        procedures can be used for this purpose because
states are explicitly constructed during search  these states can then be tested to see if they
can be abstracted towards the desired goal  in paris we use depth first iterative deepening
search described by algorithm    this algorithm consists of two recursive procedures  the
top level procedure refinedfid receives the concrete initial state sci   the concrete final state
scg   the sequence of intermediate abstract states s a    sa            sak  derived from the abstract
case  as well as the set ff which induces the state abstraction mapping  this procedure
increments the maximum depth for the depth first search procedure searchbounded up to the
maximum deepmax  the procedure searchbounded performs the actual search  the goal for
this search is either an abstract state  i e   the first abstract state in s a   or the concrete
goal state scg if all abstract state have already been visited  the procedure performs a
depth first search by applying the available concrete operators and recursively calling the
search procedure with the concrete state scnew which results from the operator application 
  

fibergmann   wilke

if an abstract goal state has been reached it is removed from the list s a and the refinement
continues with the next abstract state which is then again the first one in the list 
algorithm    refinement by depth first iterative deepening  dfid  search 
procedure refinedfid  sci   s a  ff  scg 
deep     

repeat

searchbounded  sci   s a  ff  scg  deep 
if searchbounded returns success p  then return success p 
deep    deep        search unsuccessful  increment search deepness   
until deep   deepmax

return failure

procedure searchbounded  sci   s a  ff  scg  deep 
if s a         no more abstract goals  test the concrete final goal   
and sci   scg then return success    
if s a    sa           sak     at least one abstract goal   
and for all e   sa  holds  sld sci   rc   a  e      
and for all e   ff n sa  holds  sld sci   rc   a  e     
then    abstract state reached  refine next abstract operator   
refinedfid  sci    sa            sak    ff  scg 
if refinedfid returns success p  then return success p 
if deep     then return failure    maximum depth reached   
   apply operators  create successor states   

for all oc   oc do

   sld sci   rc  preoc      
 is the set of all possible operator instantiations   
for each    
 do
scnew     sci n  deloc       addoc       create successor state   
searchbounded  scnew   s a  ff  scg   deep         continue search with new state   
if searchbounded returns success p  then return success  oc   p  
return failure
please note that this kind of refinement is different from the standard notion of refinement in hierarchical problem solving  knoblock et al       b   this is because there is
no strong correspondence between an abstract operator and a possible concrete operator 
moreover  the justification structure of a refined abstract plan is completely different from
the justification structure of the abstract plan itself because of the completely independent
definition of abstract and concrete operators  even if this is a disadvantage compared to the
usual refinement procedure used in hierarchical problem solving  the main computational
advantage of abstraction caused by the decomposition of the original problem into smaller
subproblems is maintained 

    alternative search procedures for refinement

besides the forward directed search procedure currently used in paris backward directed
search as used in means end analysis  fikes   nilsson        or in nonlinear partial ordered
  

fibuilding and refining abstract planning cases

planning  mcallester   rosenblitt        can also be applied for refinement under certain
circumstances  therefore  we would either require a state concretion function or we have
to turn the rules of the generic abstraction theory a into virtual concrete operators 
a state concretion function must be able to determine a single state or a finite set of
concrete states from a given abstract state together with the concrete problem description 
thereby  the concrete problem description may help to reduce the number of possible concrete states  the derived state concretions can then be used as concrete goal states from
which a backward directed search may start 
alternatively  we can turn the process of state concretion directly into the search procedure by representing each rule in the generic abstraction theory as a virtual abstract
operator  the precondition of a rule in the generic abstraction theory becomes the precondition of the virtual operator and the conclusion of the rule becomes a positive effect
of this operator  when using the virtual concrete operators together with the operators of
the concrete domain  a backward directed planner can use the abstract state directly as a
goal for search  the part of the plan in the resulting solution which only consists of concrete operators  and not of virtual operators  can be taken as a refinement of the abstract
operator 

    criteria for developing an abstract problem solving domain
the abstract problem solving domain and the generic abstraction theory used have an important impact on the improvement in problem solving that can be achieved  therefore 
it is desirable to have a set of criteria which state how a  good  abstract domain definition should look  strong criteria allowing quantitative predictions of the resulting speedups
can hardly be developed  for other hierarchical planners such criteria don t exist either 
however  we can give a set of factors which determine the success of our approach  the
overall problem solving time is inuenced mainly by the following four factors  independent refinability of abstract operators  goal distance of abstract operators  concrete scope of
applicability of abstract operators  and the complexity of the generic abstraction theory 
      independent refinability of abstract operators

following korf s analysis of hierarchical problem solving  korf        introduced in
   our plan refinement approach reduces the overall search space from bn to
psection
m b fi  i  fi  i      thereby  b is the average branching factor  n is the length of the coni  
crete solution  and fi is the sequence abstraction mapping used in the abstraction of the
concrete case to the abstract case  as already mentioned  we cannot guarantee that an
abstract plan which is applicable to a problem can really be refined  furthermore  korf s
analysis assumes that no backtracking between the refinement of the individual abstract
operators is required which cannot be guaranteed  some of the computational advantage
of abstraction is lost in either of these two cases 
however  if the abstract operators occurring in the abstract problem solving domain
fulfill the strong requirement of independent refinability  then it is guaranteed that every
applicable abstract case can be refined without any backtracking  an abstract operator oa
is independently refinable if for each sc   s c   sc and every state abstraction mapping ff if
  

fibergmann   wilke

o
ff sc     
ff  sc   holds 
then there exists a sequence of concrete operators  oc           ock   such
c
c
ok c
o 
that sc   
        
s  holds 
a

the problem with this requirement is that it seems much to hard to develop an abstract
problem solving domain in which all operators fulfill this requirement  although we cannot
expect that all operators in the abstract problem solving domain are independently refinable 
a knowledge engineer developing an abstract domain should still try to define abstract
operators which can be independently refined in most situations  i e   for most sc   s c   sc
and most state abstraction mapping ff an applicable abstract operator can be refined to a
concrete operator sequence  although this notion of mostly independent refinability is not
formal we feel that it is practically useful when developing an abstract domain definition 
the more abstract operators that can be refined independently in many situations  the
higher is the chance that an abstract plan composed of these operators is also refinable 
      goal distance of abstract operators

the goal distance  cf  subgoal distance  korf        is the maximum length of the sequence
of concrete operators required to refine a particular abstract operator  the longer the goal
distance the larger is the search space required to refine the abstract operator  in particular 
the complexity of the search required to refine a complete abstract plan is determined
by the largest goal distance of the abstract operators that occur in the abstract plan 
hence there is a good reason to keep the goal distance short  however  the goal distance
negatively interacts with the next factor  namely the concrete scope of applicability of
abstract operators 
      concrete scope of applicability of abstract operators

the concrete scope of applicability of an abstract operator specifies how many concrete
states can be abstracted to an abstract state in which the abstract operator is applicable 
and how many concrete states can be abstracted to an abstract state that can be reached
by an abstract operator  this scope is determined by the definition of the abstract operator
and by the generic abstraction theory which is responsible for specifying admissible state
abstractions  the concrete scope of applicability of the abstract operators determines the
applicability of the abstract plans that can be learned  an abstract plan which is only applicable to a few concrete problems is only of limited use in domains in which the problems
to be solved vary very much  hence  the concrete scope of applicability of abstract operators should be as large as possible  unfortunately  according to our experience  abstract
operators which have a large scope usually also have a larger goal distance and operators
with a short goal distance don t have a large scope of applicability  therefore  a compromise
between these two contradicting issues must be found 
      complexity of the generic abstraction theory

the fourth factor which inuences the problem solving time is the complexity of the generic
abstraction theory  this theory must be applied each time a new concrete state is created
during concrete level search  the more complex the generic abstraction theory  the more
time is required to compute state abstractions  hence  the generic abstraction theory should
  

fibuilding and refining abstract planning cases

not require complicated inferences and should avoid backtracking within the sld refutation
procedure 
although these four factors don t allow a precise prediction of the expected problem
solving behavior of the resulting system  they provide a focus on what to consider when
designing an abstract problem solving domain and related generic abstraction theory 

   an example domain  process planning in mechanical engineering
the paris approach has been successfully tested with toy domains such as the familiar
towers of hanoi  simon         for these domains  hierarchical problem solvers which use
a dropping sentence approach have also proven very useful  knoblock        
this section presents a new example domain we have selected from the field of process planning in mechanical engineering and which really requires a stronger abstraction
approach    we have selected the goal of generating a process plan for the production of
a rotary symmetric workpiece on a lathe  the problem description  which may be derived
from a cad drawing  contains the complete specification  especially the geometry  of the
desired workpiece  goal state  together with a specification of the piece of raw material
 called mold  it has to be produced from  initial state  
the left side of figure   shows an example of a rotary symmetric workpiece which has to
be manufactured out of a cylindrical mold    rotary parts are manufactured by putting the
mold into the fixture  chuck  of a lathe  the chucking fixture  together with the attached
mold  is then rotated with the longitudinal axis of the mold as rotation center  as the
mold is rotated a cutting tool moves along some contour and thereby removes certain parts
of the mold until the desired goal workpiece is produced  within this process it is very
hard to determine the sequence in which the specific parts of the workpiece have to be
removed and the cutting tools to be used  when a workpiece is chucked a certain area of
the workpiece is covered by the chucking tool and cannot be processed by a cutting tool 
moreover  a workpiece can only be chucked if the area which is used for chucking is plain 
otherwise the fixation would not be suciently stable  hence  many workpieces are usually
processed by first chucking the workpiece on one side and processing the accessible area 
then the workpiece is chucked at the opposite side and the area that was previously covered
can be processed  processing the example workpiece shown in figure   requires that the
workpiece is first chucked at the left side while the right side is processed  then the processed
right side can be used to chuck the workpiece because the area is plain and allows stable
fixing  hence  the left side of the workpiece including the small groove can be processed 
now we explain the representation of this domain in more detail  the complete definition
of the domain can be found in online appendix    several simplifications of the real
domain were required in order to obtain a domain definition that could be eciently handled
in a large set of experiments  one restriction is that we can only represent workpieces
with right angled contour elements  for example  a conical contour cannot be represented 
many different cutting and chucking tools are available in real life process planning  we
    this domain was adapted from the caplan system  paulokat   wess         developed at the university of kaiserslautern 
    note that this figure shows a   dimensional drawing of the   dimensional workpiece  the measure   in 
equals      mm 

  

fibergmann   wilke

an example workpiece

grid representation for the example workpiece

  mm
   mm

y
   mm

    mm

raw
material
workpiece

   mm

 
 
 
 

  mm

 

 mm

     
     
   

 

 

x

  mm
  mm

figure    an example workpieces with grid representation
have restricted ourselves to a single chucking tool and three different cutting tools  the
specification of the tools themselves have also been simplified  for example  the rotation
speed of workpiece and the feed of the cutting tool are also parameters that can play a
role when processing a workpiece  the impact of these parameters has also been neglected 
despite these simplifications the remaining part of this real world domain is not trivial and
represents a substantial subset of the most critical problems in this domain 

    concrete domain
we now explain the concrete problem solving domain by giving a detailed description of
the states and the operators 
      state description

for the representation of this domain at the concrete level  the exact geometry of the
workpiece must be represented as a state  including the specific measures of each detail
of the contour  however  the complete workpiece can always be divided into atomic areas
which are always processed as a whole  therefore the state representation is organized by
using a grid which divides the entire workpiece into several disjoint rectangular areas of
different sizes  see the right side of figure     together with a grid coordinate the specific
position and size of the corresponding rectangular area are represented  this grid is used
as a static part of the state description which does not change during planning  however
different problems require different grids  the specific shape of a workpiece during planning
is represented by specifying the status for each grid rectangle  in table   the predicates
used to represent the workpiece are described in more detail 
besides the description of the workpiece  the state representation also contains information about how the workpiece is chucked and which kind of cutting tool is currently used 
table   describes the predicates which are used for this purpose 
  

fibuilding and refining abstract planning cases

predicate description
xpos max the predicates xpos max xgrid   and ypos max ygrid   specify the size of the
ypos max grid in the direction of the x coordinate and the y coordinate respectively 
a state consists of exactly one instance of each of these predicates  e g  
xpos max    and ypos max    in the example shown in figure   
grid xpos
grid ypos

the predicates grid xpos xgrid   xstart  xsize   and grid ypos ygrid   ystart  ysize  
specify the geometrical position and size of grid areas in the direction of
the x coordinate and y coordinate respectively  the first argument of these
predicates specifies the coordinate of the grid areas  the second argument
declares the geometrical starting position  and the third argument specifies
the size of the grid areas  a state consists of exactly one instance of each of
these predicates for each different x coordinate and y coordinate  for the
example above  grid xpos          grid xpos          grid xpos           
grid xpos           specify the grid in x direction and grid ypos                
grid ypos         specify the grid in y direction 

mat

the predicate mat xgrid   ygrid  status  describes the status of a particular
grid area specified by the coordinates  xgrid   ygrid   the argument status
can be instantiated with one of the three constants raw  workpiece  or none 
the constant raw indicates that the specified area still consists of raw material which must be removed by further cutting operators  the constant
workpiece specifies that the area consists of material that belongs to the
goal workpiece  the constant none specifies that the area does not contain
any material  i e   there was no material present in the mold or the material
has already been removed by previous cutting operations  one instance of
a mat predicate is required for each grid area to specify its current state 
while the previously mentioned predicates does not change during the execution of a plan  the mat predicate is changed by each cutting operator  in
particular  the initial state and the goal state of a problem differs in the status assigned to those grid areas that must become removed  for example 
in the initial state of the example shown above  the sentence mat     raw 
will be present while the final state contains the sentence mat     none  
table    essential sentences for the representation of the workpiece

      operators

a process plan to manufacture a certain workpiece consists of a sequence of operators  the
total order of the operators is not a problem for this domain because the manufacturing
steps are also executed sequentially on a lathe    we have chosen four different operators
    however  there are also a few new brands of lathe machine which also allow parallel processing 

  

fibergmann   wilke

predicate
chuck pos

description
the predicate chuck pos side  describes whether the workpiece is currently
chucked on either side  the parameter side can be instantiated with one
of the three constants none  right  or left  the constant none specifies that
the workpiece is not chucked at all and the constants right and left specify
that the workpiece is chucked at the respective side  each state contains
exactly one instance of this predicate 

covered

the predicate covered xmin   xmax  specifies the areas of the workpiece which
are currently covered by the chucking tool  this predicate declares those
areas with an x coordinate lying within the interval  xmin   xmax  as being
covered  covered areas cannot be processed by a cutting tool  a state
consist of exactly one instance of this predicate if the workpiece is chucked 

cut tool
the predicates cut tool id  and cut direction dir  specify a unique identicut direction fication  id  of the cutting tool which is currently used when an area is
processed and the direction  dir  in which the cutting tool moves  the parameter id can be any symbol that specifies a legal cutting tool described
by predicates included in the static rules rc of the concrete domain description  the parameter dir can be instantiated by one of the three constants
left  right and center  the value left specifies that the cutting tool moves
from left to right  right specifies that the cutting tool moves from right to
left  and center specifies that the cutting tool move from outside towards
the center of the workpiece 

table    essential sentences for the representation of the chucking and cutting tools
to represent the chucking of a workpiece  the selection of a cutting tool  and the cutting
process itself  these operators are described in table   
manufacturing the workpiece shown in figure   requires a    step plan as shown in
figure     at first  the workpiece is chucked on the left side  then a cutting tool is selected
which allows cutting from right to left  with this tool the indicated grid areas are removed 
please note that the left side of the workpiece cannot be processed since it is covered by
the chucking tool  then  see the right side of figure      the workpiece is unchucked and
chucked on its right side  with a tool that allows processing from left to right  the upper
part of the mold is removed  finally  a specific tool is used to manufacture the small groove 

    abstract domain

in this example we can see that the small groove can be considered a detail which can be
processed after the basic contour of the workpiece has been established  the most important
characteristic of this example is that the right part of the workpiece is processed before the
left side of the workpiece  this sequence is crucial to the success of the plan  if the groove
  

fibuilding and refining abstract planning cases

operator
chuck

description
the operator chuck side  specifies that the workpiece is chucked at the
specified side  the side parameter can be instantiated with the constants
left and right  chucking is only allowed if the workpiece is not chucked already and if the surface used for chucking is plain  as effect of the chucking
operation  respective instances of the predicate chuck pos and covered are
included in the state description 

unchuck

the operator unchuck specifies that the chucking of the workpiece is removed  this operation can only be executed if the workpiece is chucked already  as effect of this operation  the parameter of the predicate chuck pos
is changed to none and the predicate covered is deleted 

use tool

the operator use tool dir  id  specifies which tool is selected for the subsequent cutting operators and in which direction the cutting tool moves 
the workpiece must be chucked before a tool can be chosen  the effect
of the operator is that respective instantiations of the predicates cut tool
and cut direction are added to the state  the parameters of the use tool
operator have the same definition as in the respective predicates 

cut

the operator cut xgrid   ygrid  specifies that the raw material in the grid
area indicated by the coordinates  xgrid  ygrid   is removed  the effect of
this operator is that the predicate mat which specifies the status of this
particular area is changed from status raw to the status none  however  to
apply this operator several preconditions must be fulfilled  the workpiece
must be chucked and the chucking tool must not cover the specified area
and the area must be accessible by the cutting tool  moreover  a cutting
tool which allows the processing of the selected area must already have been
selected  each cutting tool imposes certain constraints on the geometrical
size of the area that can be processed with it  for details  see the full
description of the domain in online appendix   
table    concrete operators

would have been processed first the workpiece could never be chucked on the left side and
the processing of the right side would consequently be impossible  domain experts told us
that this situation is not specific for the example shown  it is of general importance for
many cases  this fact allows us to select parts of the problem description and the solution
which can be considered as details from which we can abstract  parts which are  essential 
must be maintained in an abstract case  we found out that we can abstract from the
detailed shape of the workpiece as long as we distinguish between the processing of the left
and right side of the workpiece  furthermore  it is important to distinguish between the
rough contour of the workpiece and the small details such as grooves  we have developed
  

fibergmann   wilke

   chuck left 

      unchuck  chuck right 

      use tool right  t    cut          cut     

       use tool left t   cut         cut     
        use tool center t    cut       unchuck

figure     a plan for manufacturing the workpiece
an abstract domain definition containing a new language for describing states and operators
based on this abstraction idea 
      state description

we introduce a new abstract grid which divides the workpiece into a left  a middle  and a
right area to abstract from the specific location of a concrete grid area  these areas are
called complex processing areas  each area is assigned a particular status  furthermore 
an abstract state contains the information whether a complex processing area contains
small contour elements  such as grooves   but not how these grooves exactly look like  to
abstract from the very detailed conditions for chucking a workpiece  an abstract state only
contains an approximation of these conditions  stating that a workpiece cannot be chucked
at a particular side  if this side contains small contour elements that have been already
processed  the predicates used to represent an abstract state are described in more detail
in table   
      operators

we consider an abstract operator which completely processes one complex area of the
workpiece  an operator which only processes a complex area roughly  and an operator which
processes all the small grooves of a complex area  we also consider an abstract chucking
operator because the chucking has a strong impact on the overall plan  table   shows the
available abstract operators 

    generic abstraction theory
the generic abstraction theory defines the sentences used to describe an abstract state  see
table    in terms of the sentences of the concrete state  see tables   and    by a set of
horn rules  the definition of abstract sentence is explained in more detail in table   
  

fibuilding and refining abstract planning cases

predicate
abs area state

description
the predicate abs area state area  status  describes the status of
each of the three complex processing areas  the argument area
specifies one of the complex processing areas left  middle  and right 
the argument status describes the status of the respective area 
the status can be either todo  rough  and ready  the status todo
specifies that the area needs some processing of large contour elements  while in a rough area only some small contour elements such
as grooves need to be processed  the status ready specifies that
the area is completed  an abstract initial state usually contains
one or more complex processing areas of the status todo  while in
the abstract goal state all complex processing areas have the status
ready 

abs small parts

the predicate abs small parts area  specifies that the complex processing area  area  contains small contour elements that need to be
manufactured 

abs chuck pos

the predicate abs chuck pos side  describes whether the workpiece
is currently chucked on either side  the parameter side can be
instantiated with one of the three constants none  right  or left  this
predicate has exactly the same meaning as the chuck pos predicate
at the concrete level  this predicate is not abstracted at all but
only renamed 

abs chuckable wp

the predicate abs chuckable wp side  describes whether the workpiece can be be chucked at the left or right side if this side has been
completely processed 

table    essential sentences for describing an abstract state
we have strongly considered the factors that inuence the quality of a domain  see section      during the development of the abstract problem solving domain and the generic
abstraction theory  although none of the defined abstract operators is independently refinable  all of them are mostly independently refinable  the preconditions of each abstract
operator still contains approximations of the conditions that must be fulfilled in order to assure that a concrete operator sequence exist that refines the abstract operator  for example 
the predicate abs chuckable wp side  is an approximation of the detailed condition  a plain
surface  required for chucking  the goal distance of each operator is quite different and
strongly depends on the problem to be solved  while the goal distance of the set fixation
operators is no more than two  possibly one unchuck operator followed by a chuck operator 
the goal distances of the other abstract operators are different  for example  the goal distance of the process ready operator depends on the number of concrete grid areas belonging
  

fibergmann   wilke

operator
set fixation

description
the operator set fixation side  specifies that the workpiece is chucked
at the specified side  the side parameter can be instantiated with the
constants left  right and none  the constant none specifies that the
chucking is removed  compared to the concrete operator chuck the
preconditions for chucking at a side have been simplified  the effect of
this operator is that the predicate abs chuck pos is modified 

process rough

the operator process rough area  specifies that the complex processing
area  area  is being processed completely up to the small contour elements  the parameter area can be either left  middle  or right  the
precondition of this operator only requires that the workpiece is chucked
at a different side than area  the effect of this operator is that the predicate abs area state is modified 

process fine

the operator process fine area  specifies that all small contour elements
of the complex processing area  area  are being processed  the parameter area can be either left  middle  or right  the precondition of this
operator only requires that the large contour elements of this side of
the workpiece are already processed and that the workpiece is chucked
at a different side  the effect of this operator is that the predicate
abs area state is modified 

process ready

the operator process ready area  specifies that the indicated complex
area of the workpiece is being completely processed  including large and
small contour elements  the effect of this operator is that the predicate
abs area state is modified 
table    abstract operators

to the respective abstract area and containing material that needs to be removed  the
goal distance is the number of these gird areas  say c  plus the number of required use tool
operations  less than or equal to c   hence  the goal distance is between c and  c  because
this goal distance can become very long for the more complex problems  the two operators
process rough and process fine are introduced  they only cover the processing of the small
and the large grid areas respectively and consequently have a smaller goal distance than
the process ready operator  while the goal distance of these two operators is smaller they
have a smaller concrete scope of applicability than the process ready operator  for example
the process ready operator can be applied in any state in which some arbitrary areas need
to be processed  but process fine can only be applied in states in which all large grid areas
are already processed 
although we have only developed a simplified version of the whole domain of production planning in mechanical engineering for rotary symmetrical workpieces we feel that
  

fibuilding and refining abstract planning cases

abstract predicate description in terms of the predicates of the concrete domain
abs area state
the predicate abs area state area  status  describes the status of
each of the three complex processing areas  the left processing area
consists of the areas of the concrete grid which are covered  if the
workpiece is chucked at the left side  similarly  the right processing
area consists of those concrete grid areas which are covered if the
workpiece is chucked at the right side  the middle processing area
consists of those areas which are never covered by any chucking
tool  the status of a complex processing area is todo  if there exists
a concrete large grid area which belongs to the complex processing
area and which needs to be processed  a grid area is considered
as large if its size in direction of the x coordinate is larger than  
mm  the status of a complex processing area is rough  if all large
grid areas of the complex processing area are already processed
and if there exists a concrete small grid area which belongs to the
complex processing area and which needs to be processed  a gird
area is considered as small if its size in direction of the x coordinate
is smaller or equal than   mm  the status of a complex processing
area is ready if all concrete grid areas which belong to the complex
processing area have been processed 
abs small parts

the sentence abs small parts area  holds if there exists a small concrete grid area  size smaller or equal than   mm  which belongs to
the complex processing area and which needs to be processed 

abs chuck pos

the sentence abs chuck pos side  holds if and only if the concrete
sentence chuck pos side  holds 

abs chuckable wp

the predicate abs chuckable wp side  describes whether the workpiece can still be chucked at the left or right side if this side is
completely processed  this sentence holds if the part of the desired
workpiece which belongs to respective side is completely plain  that
is  all concrete grid areas with the status workpiece range up to the
same y coordinate 
table    generic abstraction theory

a domain expert together with a knowledge engineer will be able to define an abstract
domain representation and a generic abstraction theory for a complete domain  in particular  model based interactive knowledge acquisition tools like mikado  schmidt       
schmidt   zickwolff        can make such a complete modeling task much more feasible 
  

fibergmann   wilke

case c 
initial state

goal state

solution
   chuck left 
  
chuck right 
    use tool center  t  
   use tool right t     
use tool left t       cut     
      cut           cut              cut           cut          unchuck
   unchuck

problem
abstraction

  

      

      

       

i 

ii 

iii 

iv 

        

   
problem
abstraction

abstraction
v 

vi 

abstract case ca
abstract initial state
abs area state left  todo 
abs area state right todo 
abs small parts left 
abs chuckable wp right 

problem
abstraction

abstract solution
i  set fixation left 
ii  process ready right 
iii  set fixation right 

abstract goal state

iv  process rough left 
v  process fine left 
vi  set fixation none 

i 

ii 

iii 

  

      

      

iv 

v 

vi 

        

   

abs area state left  ready 
abs area state right ready 
abs chuckable wp right 

refinement
       

new case c 

initial state

solution solution
   chuck left 
   use tool right t  
   cut     
   unchuck

problem
abstraction

goal state

  
chuck right  
    use tool center  t  
  
use tool left t        cut     
       cut          cut           cut     
    unchuck

figure     abstracting and refining an example case

    abstracting and refining a process planning case

we now explain how the example case shown in figure   can be abstracted and how
this abstract case can be reused to solve a different planning problem  this process is
demonstrated in figure     the top of this figure shows the concrete planning case c 
already presented in figure    this case is abstracted by the pabs algorithm presented in
section    the algorithm returns   different abstract cases    one of these abstract cases
is shown in the center of the figure  the abstract solution plan consists of a sequence of  
abstract operators  the sequence of the operators in the plan is indicated by the roman
numerals  the particular abstraction is indicated between the concrete and the abstract case
and denotes which sequence of concrete operators is turned into which abstract operator 
    the other   abstract cases differ from the shown abstract case in two aspects  in the shown abstract
solution the additional abstract step set fixation none  can be inserted between the steps ii and iii  the
abstract step v can also be replaced by the abstract step process ready  or the abstract steps iv and v
together can be replaced by the abstract step process ready 

  

fibuilding and refining abstract planning cases

the learned abstract case can now be used to solve the new problem c  whose initial and
final concrete states are shown in the bottom of the figure  even if the concrete workpiece
looks quite different from the workpiece in case c  the abstract case can be used to solve
the problem  the reason for this is that the new workpiece also requires that the left and
right side must be processed  in particular the right side must also be processed before
the left side is processed because the left side contains two small grooves which prevent the
workpiece from being be chucked at that side after it is processed  however  we can see that
most abstract operators  in particular the operators ii  vi  and v  are refined to completely
different sequences of concrete operators than those from which they were abstracted 
as already mentioned  the abstract operators used are not independently refinable but
only mostly independently refinable  consequently  it can happen that an applicable abstract case cannot be refined  figure    shows an example of a concrete planning problem
for which the abstract case shown in figure    is applicable but not refinable  the reason
for this is the location of the small abstract part at the left side of the workpiece  this small
part consists of the concrete grid area       in which raw material must be removed  however  in this specific situation  this small part must be removed before the large parts  the
left side of the workpiece contains  the grid areas               and         can be removed 
the reason for this is that without removing this small part  the larger parts located right
of the small part cannot be accessed by any cutting tool that is able to cut the areas      
and        consequently this problem can only be solved with the plan shown on the right
side of figure     unfortunately  this plan is not a refinement of the abstract plan shown in
figure     because this abstract plans requires that the large parts must be removed before
the small parts are removed  hence  the refinement of the operator process rough left  fails 
in this situation the problem solver must select a different abstract plan 

   empirical evaluation and results
this section presents the results of an empirical study of paris in the mechanical engineering domain already introduced  this evaluation was performed with the fully implemented
paris system using only the abstraction abilities of the system  the generalization component was switched off for this purpose  we have designed experiments which allow us
to judge the performance improvements caused by various abstract cases derived by pabs 
furthermore  we have analyzed the average speed up behavior of the system with respect
to a large set of randomly selected training and test cases 

    planning cases
for this empirical evaluation     concrete cases have been randomly generated  each case
requires about         sentences to describe the initial or final state  most of which are
instances of the mat predicate  the length of the solution plans ranges from   to   
operators  even if the generated cases only represent simple problems compared to the
problems a real domain expert needs to solve  the search space required to solve our sample
problems is already quite large  this is due to the fact that the branching factor b is between
    and      depending on the complexity of the problem  hence  for a    step solution the
complete search space consists of           states 
  

fibergmann   wilke

solution

new problem

y
  mm
 
 

 mm

 

workpiece

  mm

   chuck left 
   use tool right t  
   cut     
   cut     
   unchuck
   chuck right 
   use tool left t  
   cut     
   cut     
    cut     
    use tool center  t  
    cut     
    unchuck

   mm
abs small parts left 
   

 

 

x

figure     an example case in which the refinement of the abstract plan shown in figure
   fails 

the case generation procedure leads to solutions which are optimal or nearly optimal 
all solutions which require less than    steps are optimal solutions in the sense that they are
known to be the shortest solution to the problem they solve  all solutions which are longer
than    steps have been manually checked to see whether they contain steps which are
obviously redundant  such redundant steps have been removed  although these solutions
are not necessarily shortest solutions  they are nevertheless acceptably short 

    evaluating abstraction by dropping sentences
at first we used the recent version of alpine  knoblock        together with prodigy   blythe et al         to check whether abstraction by dropping sentences can improve
problem solving in our domain represented as described in section    therefore  we used
only the concrete problem solving domain as domain theory for prodigy  unfortunately 
for this representation  alpine was not able to generate an ordered monotonic abstraction
hierarchy  the reason for this is that alpine can only distinguish a few different groups of
literals because only a few different literal names  and argument types  can be used in the
problem space  for example  alpine cannot distinguish between the different sentences
which are described by the mat or the grid xpos predicate  but this is very important for
abstraction  we would like to drop those parts of the grid which represent small rectangles
such as grooves  however  this would require the examination of the measures associated
with a grid area  as argument  and also the relation to other surrounding grid areas  therefore  which sentence to drop  or which criticalities to assign  cannot be decided statically by
the name of the predicate or the type of the arguments  all hierarchical planners including
  

fibuilding and refining abstract planning cases

prodigy and alpine are highly dependent on the representation used  in particular if their

strategy is restricted to dropping sentences  holte et al                however  there might
be another representation of our domain for which those hierarchical planners can improve
performance but we think that our representation is quite  natural  for our domain 
from this first trial we can conclude that the application domain and representation we
have chosen for the following experiments with paris really require more than dropping
sentences to achieve an improvement by abstraction 

    evaluating the paris approach

the first experiment with paris was designed to evaluate the hypotheses that in our domain
there is a need  i  for changing the representation language during abstraction  and  ii  for
reusing abstract cases instead of generating abstract solutions from scratch  to test these
hypotheses we rely on the time for solving the randomly generated problems using different
modes of the paris system 
      experimental setting
in this experiment we used the paris system to solve the     problems from the randomly

generated cases  thereby the goal of abstraction is to improve the concrete level problem
solver  which performs a brute force search with a depth first iterative deepening search
strategy  korf      a  as introduced in section      the improvement is determined in
terms of problem solving time required to solve a single problem  paris is used to solve
the     problems in three different modes 

 pure search  the problem solver is used to solve each problem by pure search without
use of any abstraction 

 hierarchical planning  in this mode paris uses the introduced abstract domain  how 

ever  abstract cases are not recalled from a case library but they are computed automatically by search as in standard hierarchical planning  but using the new abstraction language  so  the problem solver first tries to search for a solution to the original
problem at the abstract domain and then tries to refine this solution  during this
hierarchical problem solving  backtracking between the two levels of abstraction and
between each subproblem can occur  thereby  we used hierarchical planning with the
new abstraction methodology instead of dropping sentences 

 reasoning from abstract cases  in this mode we first used paris to learn all abstract
cases which come out of the     concrete cases  for each problem  all abstract cases
that exists according to our abstraction methodology are available when one of the
problems is to be solved  during problem solving we measured the time required for
solving each problem using every applicable abstract cases  then  for each problem 
three abstract cases are determined  a  the best abstract case  i e   the case which leads
to the shortest solution time  b  the worst abstract case  longest solution time  which
is an abstraction of the aspired solution case  and c  the worst applicable abstract
case is determined  the difference between b  and c  relates to the difference between
applicable and refinable abstract cases introduced in section      an abstract case
  

fibergmann   wilke

selected in c  is applicable to the current problem  but might not be an abstraction
of the case from which the problem is taken  in b  only abstract cases are selected
which are indeed abstractions of the current problem  i e   abstract cases which have
been previously learned from the case from which the problem is taken  these three
different cases are selected to figure out the impact of case selection  which is not
addressed in this paper  on the proposed method 
although every problem can theoretically be solved by our brute force search procedure 
the exponential nature of the search space avoids the solution of complex problems within
reasonable time  therefore  a time bound of     cpu seconds on a sun sparc elc
computer was introduced in each of the three modes described above  if this limit bound
is exceeded the problem remains unsolved  increasing this time bound would increase the
number of solvable problems in each of the three modes 
      results

we have determined the solution time for each of the     problems in each of the described
modes  the average solution time as well as the number of problems that could be solved
within the time limit is shown in table    we have determined these values for reasoning
from abstract cases separately for each of the three types of abstract cases  the significance
of the speedup results has be investigated by using a maximally conservative sign test
 etzioni   etzioni         unfortunately it turned out that the speedup of hierarchical
planning over pure search was not significant  we also couldn t find a significant speedup
of reasoning from abstract cases when using always the worst applicable abstract case  c 
over pure search  this was due to the large number of doubly censored data  both problem
solvers cannot solve the problem within the time limit   which were counted against the
speedup hypothesis  however  the improvements of pure search by reasoning from refinable
abstract cases were significant  p             when using the best refinable case  a  and
when using the worst refinable case  b   furthermore  it turned out that the speedup of
reasoning from refinable cases over hierarchical planning was also significant for an upper
bound of the p value of        the mentioned p value is a standard value used in statistical
hypothesis tests  it is the probability  assuming that the hypothesis does not hold  of
encountering data that favors the hypothesis as much or more than the observed data in
the experiment  etzioni   etzioni         therefore a result is more significant if the
p value is smaller  from this analysis  we can clearly see  that our two basic hypotheses
are supported by our experimental data  even if not significant we can see a moderate
improvement in the problem solving time and in the number of solved problems when using
hierarchical planning with changing the representation language  please remember that
hierarchical planning by dropping conditions did not lead to any improvement at all  see
section       obviously  changing the representation language during abstraction is required
to improve problem solving in our domain as stated in the first hypothesis  i  
very strong support for the second hypothesis  ii  can also be found in the presented
data  we can see significant speedups by reasoning from abstract cases over pure search and
even over hierarchical planning  only if the worst abstract case is used for each problem
to be solved  the speedup is not significant and the problem solving behavior is slightly
worse than in hierarchical planning  please note that this situations is extremely unlikely
  

fibuilding and refining abstract planning cases

problem solving mode
average solution time  sec   solved problems
pure search
   
  
hierarchical planning
   
  
reasoning from abstract cases
 a  best refinable case
  
  
 b  worst refinable case
  
  
 c  worst applicable case
   
  
table    comparison of the average solution time per problem and the number of solved
problems within a time bound of     seconds  the table compares pure search
 depth first iterative deepening   hierarchical planning using the abstract problem solving domain  and reasoning from abstract cases with differently selected
abstract cases 
to happen at all  with a sophisticated indexing and retrieval of abstract cases this situation
can be avoided for the most part 

    evaluating the impact of different training sets
in one respect the previous experiment is based on a very optimistic assumption  we always
assume that all abstract cases required for solving a problem have been learned in advance 
this situation is not a realistic scenario for an application  usually  one set of cases is
available for training the system while a different set of problems needs to be solved  so
we cannot assume that good applicable abstract cases are always available to solve a new
problem  furthermore  the presented example also shows that the problem solving time can
vary a lot if different abstract cases are selected during problem solving  therefore  we have
designed a new experiment to evaluate the improvements caused by the paris approach in
a more realistic scenario 
      experimental setting

we have randomly chosen    training sets of   cases and    training sets of    cases from
the     available cases  these training sets are selected independently from each other 
then  each of the    training sets is used for a separate experiment  in each of the   
experiments  those of the     cases which are not used in the particular training set are
used to evaluate the performance of the resulting system  training set and test set are
completely independent by this procedure  during this problem solving task  we did not
determine the problem solving behavior for all applicable abstract cases  but we used a
simple automatic mechanism to retrieve one  hopefully a good  applicable abstract case
for a problem  therefore  the cases are organized linearly in the cases base  sorted by the
length of the abstract plan contained in the case  the case base is sequentially searched
from longer to shorter plans until an applicable case is found  this heuristic is based on the
assumption that a longer abstract plan is more specific than a shorter abstract plan and
  

fibergmann   wilke

size of training sets
 cases 
 
  

number of abstract cases
minimum
maximum
average
 
  
   
 
  
    

table    comparison of the number of learned abstract cases for a  the    training sets
each of which consists of   concrete cases and b  the    training sets each of
which consists of    concrete cases  the table shows the minimum  the maximum 
and the average number of abstract cases learned from the    training sets of the
respective size 
size of training sets
 cases 
 
  

average problem solving time  sec  
best set
worst set
average
  
  
  
  
  
  

table    comparison of the problem solving time required for reasoning from abstract cases
after separate training with a  the    training sets each of which consists of  
concrete cases and b  the    training sets each of which consists of    concrete
cases  the table shows the average problem solving time per problem for the best 
the worst and the average training set out of the    training sets of each size 
divides the actual problem into more  but smaller subproblems  consequently the longest
applicable plan should lead to the best improvement 
      results

we have statistically evaluated the second experiment  table   shows the number of abstract
cases which could be learned from the different training sets  the minimum  the maximum
and the average number of abstract cases that could be learned from the    training sets of
the same size is indicated  note that altogether    abstract cases can be learned if all    
cases would have been used for training as in the previous experiment  from the    training
sets which contained   cases each  between   and    abstract cases could be learned  as
expected  if the size of the training set is increased more abstract cases can be learned 
table   shows the average problem solving time after learning from the different sets  this
table also shows the minimum  the maximum and the average problem solving time for the
   different training sets of the two sizes  we can see that the best training sets leads to
a problem solving time which is similar or only slightly worse than the optimum shown in
table    even in the average case  considerable improvements over the pure search and
hierarchical problem solving  compare table   and table    can be discovered  the same
   

fibuilding and refining abstract planning cases

size of training sets
 cases 
 
  

percentage of solved problems
best set
worst set
average
  
  
  
  
  
  

table     comparison of the percentage of solved problems after separate training with
a  the    training sets each of which consists of   concrete cases and b  the   
training sets each of which consists of    concrete cases  the table shows the
percentage of solved problems for the best  the worst and the average training
set out of the    training sets of each size 
size of training sets
 cases 
 
  

number of training sets with significant speedups over
pure search
hierarchical planning
p         
p         
p       
 
 
 
  
 
 

table     comparison of the significance  p value  of the speedup results over pure search
and hierarchical planning after separate training with a  the    training sets each
of which consists of   concrete cases and b  the    training sets each of which
consists of    concrete cases  the table shows the number of training sets which
cause significant speedups for different p values 
positive results can also be identified when looking at the percentage of solved problems 
shown in table     here we can also see that for the best training sets the number of solved
problems is close to the maximum that can be achieved by this approach  even in the worst
training set considerably more problems could be solved than by pure search or hierarchical
planning 
additionally all of the above mentioned speedup results were analyzed with the maximally conservative sign test as described in  etzioni   etzioni         table    summarizes
the significance results for speeding up pure search and a hierarchical problem solver  it
turned out that    of the    training sets lead to highly significant speedups  p          
over pure search  for this hard upper bound on p values only about half of the training
sets lead to significant differences between reasoning from abstract cases and hierarchical
planning  at a slightly higher upper bound of p         about     of the training sets
caused a significantly better performance than hierarchical planning 
altogether  the reported experiment showed that even a small number of training cases
 i e      and      can already lead to strong improvements on problem solving  we can
see that not all abstract cases must be present  as in the first experiment  to be successful 
furthermore  this experiment has shown that even a simple retrieval mechanism  sequential
   

fibergmann   wilke

size of training sets
 cases 
 
  

average percentage of solutions with
shorter equal longer solution length
shorter
equal
longer
  
  
  
  
  
  

table     comparison of the length of the solutions created through reasoning from learned
abstract cases and the solutions available in the concrete cases  the table shows
the average percentage of solutions with shorter equal longer solution length
after separate training with a  the    training sets each of which consists of  
concrete cases and b  the    training sets each of which consists of    concrete
cases 
search  can select beneficial abstract cases from the library  neither of the training situations
in the second experiment lead to results which are as worse as the worst case shown in table
  

    quality of the produced solutions

although the main purpose of this approach is to improve the performance of a problem
solver  the quality of the produced solutions is also very important for a practical system 
the solution length can be used as a very simple criterion to determine the quality of a
solution  however  in general the quality of a solution should reect the execution costs
of a plan  the plans robustness  or certain user preferences  perez   carbonell        
because such quality measures are very dicult to assess  in particular in our manufacturing
domain  we rely on this simple criterion also used for evaluating the quality of solutions in
prodigy analogy  veloso        
      experimental setting

we have analyzed the solutions computed in the previous set of experiments to assess the
quality of the solutions produced by paris  therefore  the length of solutions derived
during problem solving  after learning from each of the    training sets  are compared to
the length of the nearly optimal solutions contained in the concrete cases 
      results

for each training set the length of each solution derived in the corresponding testing phase
is compared to the length of the solution noted in the concrete case  the percentage of
solutions with shorter  equal  or longer solution length is determined for each training set
separately  and the average over the    training sets with equal size is determined  table
   shows the result of this evaluation 
it turned out that there was no big difference in the quality results between the   
training sets  in particular  the size of the training sets did not have a strong inuence on
   

fibuilding and refining abstract planning cases

the results  in table    we can see that between                 and                
of the solutions produced are of equal or better quality than the solutions contained in the
concrete cases  please note that the concrete cases used for testing are always different
from the cases used for training  additionally  the solutions to which we compare the
results produced by paris are already nearly optimal solutions due to the case generation
procedure    taking this into account  these results are already fairly good 

    impact of the abstract problem solving domain
the experiments reported before were conducted with the concrete and abstract domain
representation presented in section   and in online appendix    in this final experiment
the impact of the specific choice of an abstract problem solving domain is investigated 
      experimental setting

we created a new abstract problem solving domain which is less constrained than the one
used before  for this purpose one operator was completely removed and certain conditions
of the remaining operators were removed also  in particular  the set fixation operator was
removed and the conditions abs chuck pos  abs chuckable wp  and chuck comp were removed
from the preconditions of the three remaining operators  hence  the fact that the chucking
of a workpiece has an impact on the production plan is now neglected at the abstract level 
however  the concrete problem solving domain and the generic abstraction theory was not
modified at all  consequently  chucking still plays an important role at the concrete level 
the set of experiments described in section     was repeated with the less constrained
abstract problem solving domain but using the same training and testing sets as before 
      results

table    and    summarize the results of these experiments  table    shows the average
problem solving time which occurs after learning from the different training sets  it turns
out that for all training sets  learning improves the concrete level problem solver  but that
the speedup is much smaller than when using the original abstract problem solving domain
 cf  table   and     in particular  none of the resulting speedups over concrete level problem
solving were significant  a similar result can be observed when comparing the percentage
of solved problems  see figure      there is still a slight improvement in the number of
problems that could be solved after learning but the improvement is much smaller than
when using the original abstract problem solving domain  cf  table   and     

    in all cases up to one  the shorter solutions produced by paris are only one step shorter than the solution
contained in the concrete case 

   

fibergmann   wilke

size of training sets
 cases 
 
  

average problem solving time  sec  
best set
worst set
average
   
   
   
   
   
   

table     using a less constrained abstract problem solving domain  comparison of the
problem solving time required for reasoning from abstract cases after separate
training with a  the    training sets each of which consists of   concrete cases
and b  the    training sets each of which consists of    concrete cases  the table
shows the average problem solving time per problem for the best  the worst and
the average training set out of the    training sets of each size 

size of training sets
 cases 
 
  

percentage of solved problems
best set
worst set
average
  
  
  
  
  
  

table     using a less constrained abstract problem solving domain  comparison of the
percentage of solved problems after separate training with a  the    training sets
each of which consists of   concrete cases and b  the    training sets each of which
consists of    concrete cases  the table shows the percentage of solved problems
for the best  the worst and the average training set out of the    training sets of
each size 
this experiment supported the general intuition that the abstract problem solving domain has a significant impact on the improvement in problem solving that can be achieved
through reasoning from abstract cases  the reason why the less constrained domain leads
to worse results than the original abstract domain can be explained with respect to the
criteria explained in section      since important preconditions of the abstract operators
were removed there are many situations in which the new operators cannot be refined  this
holds particularly for those situations in which a workpiece cannot be chucked to perform
the required cutting operations  the new abstract operators are not mostly independently
refinable  moreover  since the abstract operator set fixation is removed the concrete chuck
and unchuck operator must be introduced during the refinement of the remaining abstract
operators  consequently  the goal distance of these abstract operators is increased  these
two factors are the reason for worse results when using the less constrained abstract domain
theory 
   

fibuilding and refining abstract planning cases

    discussion
in this paper we have shown in detail that in hierarchical problem solving  sacerdoti       
tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock       
the limited view of abstraction by dropping sentences as well as the strategy by which
abstract solutions are computed lead to poor behavior in various relevant situations  this
observation is supported by comprehensive artificial examples  see section     and      and
a real world example from the domain of mechanical engineering  see section     further
supported by an experiment  see section       the recent results reported in  holte et al  
      support these observations very well 
in general  abstraction is the task of transforming a problem or a solution from a concrete representation into a different abstract representation  while reducing the level of
detail  michalski   kodratoff        giunchiglia   walsh        michalski         however  in most hierarchical problem solvers  the much more limited view of abstraction by
dropping sentences is shown to be the reason why ecient ways of abstracting a problem
and a solution are impossible  e g   see section     and figure     the second weakness
of most hierarchical problem solvers is that they usually compute arbitrary abstract solutions and not solutions which have a high chance of being refinable at the next concrete
level  although the upward solution property  tenenberg        guarantees that a refinable abstract solution exists  it is not guaranteed that the problem solver finds this abstract
solution  e g   see section       problem solvers are not even heuristically guided towards
refinable abstract solutions 
with the paris approach we present a new formal abstraction methodology for problem
solving  see section    which allows abstraction by changing the whole representation language from concrete to abstract  together with this formal model  a correct and complete
learning algorithm for abstracting concrete problem solving cases  see section    is given 
the abstract solutions determined by this procedure are useful for solving new concrete
problems  because they have a high chance of being refinable 
the detailed experimental evaluation with the fully implemented paris system in the
domain of mechanical engineering strongly demonstrates that paris can significantly improve problem solving in situations in which a hierarchical problem solver using dropping
sentences fails to show an advantage  see table   to     

     related work
we now discuss the paris approach in relation to other relevant work in the field 
       theory of abstraction

within giunchiglia and walsh s        theory of abstraction  the paris approach can be
classified as follows  the formal system of the ground space   is given by the concrete
problem solving domain dc using the situation calculus  green        for representation 
the language of the abstract formal system   is given by the language of the abstract
problem solving domain da   however  the operators of da are not turned into axioms of
    instead  the abstract cases build the axioms of     moreover  the generic abstraction
theory a defines the abstraction mapping f           within this framework  we can view
   

fibergmann   wilke

paris as a system which learns useful axioms of the abstract system  by composing several

smaller elementary axioms  the operators   however  to prove a formula  the existence of
a solution  in the abstract system  exactly one axiom  case  is selected  so the deductive
machinery of the abstract system is restricted with respect to the ground space  depending
on the learned abstract cases the abstractions of paris are either theory decreasing  td 
or theory increasing  ti   if the case base of abstract cases is completely empty then no
domain axiom is available and the resulting abstractions are consequently td  if the casebase contains the maximally abstract case hhtrue  truei nop i    and the generic abstraction
theory contains the clause   true   then this case can be applied to every concrete problem
and the resulting abstraction is consequently ti  even if this maximally abstract case does
not improve the ground level problem solving  it should be always included into the case base
to ensure the ti property  that is not loosing completeness  the case retrieval mechanism
must however guarantee  that this maximally abstract case is only chosen for refinement if
no other applicable case is available  note  that this is fulfilled for the retrieval mechanism
 sequential search from longer to shorter plans  we used in our experiments 
       skeletal plans

as already mentioned in section     the paris approach is inspired by the idea of skeletal
plans  friedland   iwasaki         a abstract cases can be seen as a skeletal plan  and
our learning algorithm is a means to learn skeletal plans automatically out of concrete
plans  even if the idea of skeletal plans is intuitively very appealing  to our knowledge  this
paper contains the first comprehensive experimental support of usefulness of planning with
skeletal plans  since we have shown that skeletal plans can be acquired automatically  this
planning method can be applied more easily 
for the same purpose  anderson and farley        and kramer and unger        proposed approaches for plan abstraction which go in the same direction as the paris algorithm 
however  this approach automatically forms abstract operators by generalization  mostly
based on dropping sentences  moreover  in the abstracted plan  every concrete operator is
abstracted  so that the number of operators is not reduced during abstraction  thereby
this abstraction approach is less powerful than paris style abstractions 
       alpine s ordered monotonic abstraction hierarchies
alpine  knoblock                          automatically learns hierarchies of abstraction

spaces from a given domain description or from a domain description together with a planning problem  as mentioned several times before  alpine relies on abstraction by dropping
sentences  however  this enables alpine to generate abstraction hierarchies automatically 
for a stronger abstraction framework such as the one we follow in paris  the automatic
generation of abstraction hierarchies  or abstract domain descriptions  does not seem to
be realistic due to the large  infinite  space of possible abstract spaces  to use our powerful abstraction methodology  we feel that we have to pay the price of losing the ability to
automatically construct an abstraction hierarchy 
another point is that the specific property of ordered monotonic abstraction hierarchies
generated by alpine  allows an ecient plan refinement  during this refinement  an ab    nop is the  no operation  operator which is always applicable and does not change the abstract state 

   

fibuilding and refining abstract planning cases

stract plan can be expanded at successively lower levels by inserting operators  furthermore 
already established conditions of the plan are guaranteed not to be violated anymore during refinement  unfortunately  this kind of refinement cannot be performed for paris style
abstractions  especially  there is no direct correspondence between the abstract operators
and concrete operators  consequently  an abstract plan cannot be extended to become a
concrete plan  however  the main function of the abstract plan is maintained  namely that
the original problem is decomposed into several smaller subproblems which causes the main
reduction in search 
       explanation based learning  case based reasoning and analogy

the presented paris approach uses experience to improve problem solving  similar to several
approaches from machine learning  mostly from explanation based learning  mitchell et al  
      dejong   mooney         case based reasoning  kolodner        schank        althoff   wess        kolodner        or analogical problem solving  carbonell        veloso
  carbonell         the basic ideas behind explanation based learning and case based or
analogical reasoning are very much related  the common goal of these approaches is to
avoid problem solving from scratch in situations which have already occurred in the past 
explanations  i e   proofs or justifications  are constructed for successful solutions already
known by the system  in explanation based approaches  these explanations mostly cover the
whole problem solving process  fikes  hart    nilsson        mooney        kambhampati
  kedar         but can also relate to to problem solving chunks  rosenbloom   laird 
      laird  rosenbloom    newell        of some smaller size or even to single decisions
within the problem solving process  minton        minton et al          explanation based
approaches generalize the constructed explanations during learning by extensive use of the
available domain knowledge and store the result in a control rule  minton        or schema
 mooney   dejong         in case based reasoning systems like priar  kambhampati
  hendler        or prodigy analogy  veloso   carbonell        veloso        cases
are usually not explicitly generalized in advance  they are kept fully instantiated in a
case library  annotated with the created explanations  unlike cases in paris which are
problem solution pairs  such cases are complete problem solving episodes containing detailed information of each decision that was taken during problem solving  during problem
solving  those cases are retrieved which contain explanations applicable to the current problem  kambhampati   hendler        veloso   carbonell        veloso         the detailed
decisions recorded in these cases are then replayed or modified to become a solution to the
current problem  all these approaches use some kind of generalization of experience  but
none of these approaches use the idea of abstraction to speedup problem solving based on
experience  as already noted in  michalski   kodratoff        michalski         abstraction and generalization must not be confused  while generalization transforms a description
along a set superset dimension  abstraction transforms a description along a level of detail
dimension 
the only exception is given in  knoblock  minton    etzioni      a  where alpine s
abstractions are combined with ebl component of prodigy  thereby  control rules are
learned which do not refer to the ground space of problem solving but also to the abstract
spaces  these control rules speedup problem solving at the abstract level  however  the
   

fibergmann   wilke

control rules guide the problem solver at the abstract level so that it finds solutions faster
and not in a manner that it finds refinable abstract solutions  although we did not have any
experience with this kind of integration of abstraction and explanation based learning  we
assume that the control rules generated by the ebl component will also guide the problem
solver towards short abstract solutions which do not cause much reduction in search in
several circumstances 

     requirements and limitations of paris

in the following  we will summarize again the requirements and limitations of the paris
approach  the main requirements are the availability of a good abstract domain description
and in the availability of concrete cases 
       abstract domain

the most important prerequisite of this method is the availability of the required background knowledge  namely the concrete world description  the abstract world description 
and the generic abstraction theory  for the construction of a planning system  the concrete
world descriptions must be acquired anyway  since they specify the  language  of the problem description  essential sentences  and the problem solution  operators   the abstract
world and the generic abstraction theory must also be acquired  we feel that this is indeed
the price we have to pay to make planning more tractable in certain practical situations 
nevertheless  the formulation of an adequate abstract domain theory is crucial to the
success of the approach  if those abstract operators are missing which are required to express
a useful abstract plan  no speedup can be achieved  what we need are mostly independently
refinable abstract operators  if such operators exist  they can be simply represented in the
abstract domain using the whole representational power  for hierarchical planning with
dropping conditions  such an abstract domain must also be implicitly contained in a concrete
domain in a way that the abstract domain remains  if certain literals of the concrete domain
are removed  see section       we feel that this kind of modeling is very much harder to
achieve than modeling the abstract view of a domain explicitly in a distinct planning space
as in paris  additionally  the requirement that the abstract domain is given by the user
has also the advantage that the learned abstract cases are expressed in terms the user is
familiar with  thereby  the user can understand an abstract case very easily  this can open
up the additional opportunity to involve the user in the planning process  for example in
the selection of an abstract cases she he favors 
research on knowledge acquisition has shown that human experts employ a lot of
abstract knowledge to cope with the complexity of real world planning problems  specific knowledge acquisition tools have been developed to comfortably acquire such abstract
knowledge from different sources  especially  the acquisition of planning operators is addressed in much detail in  schmidt   zickwolff        schmidt        
       availability of cases
as a second prerequisite  the paris approach needs concrete planning cases  problem 

solution pairs   in a real world scenario such cases are usually available in a company s
filing cabinet or database  according to this requirement we share the general view from
   

fibuilding and refining abstract planning cases

machine learning that the use of this kind of experience is the most promising way to cope
with highly intractable problems  for the paris approach the available cases must be
somehow representative for future problem solving tasks  the known cases must be similar
enough to the new problems that abstract cases can really be reused  our experiments
give strong indications that even a small set of concrete cases for training leads to high
improvements in problem solving  see table   to     

     generality of the achieved results

the reported experiments were performed with a specific base level problem solver which
performs a depth first iterative deepening search strategy  korf      a   however  we
strongly believe that the paris abstractions are also beneficial for other problem solvers
using backward chaining  means end analysis or nonlinear partial order planning  as shown
in  veloso   blythe         there is not one optimal planning strategy  different planning
strategies usually rely on different commitments during search  each strategy can be useful
in one domain but may be worse in others  however  for most search strategies  the length
of the shortest possible solution usually determines the amount of search which is required 
in paris  the whole search problem is decomposed into several subproblems which allow
short solutions  consequently  this kind of problem decomposition should be of use for most
search strategies 
moreover  we think that the idea of reasoning from abstract cases  formulated in a
completely new terminology than the ground space will also be useful for other kinds of
problem solving such as design or model based diagnosis  for model based diagnosis  we
have developed an approach  pews   wess        bergmann  pews    wilke        similar
to paris  the domain descriptions consist of a model of a technical system for which a
diagnosis has to be found  it describes the behavior of each elementary and composed
component of the system at different levels of abstraction  during model based diagnosis 
the behavior of the technical system is simulated and a possible faulty component is searched
which can cause the observed symptoms  using abstract cases  this search can be reduced
and focused onto components which have been already defective  in other similar machines 
and which are consequently more likely to be defective in new situations 

     future work

future research will investigate goal directed procedures for refinement such as backwarddirected search or non linear partial order planners  see section       additionally  more
experience must be gained with additional domains and different representations of them 
furthermore  we will address the development of highly ecient retrieval algorithms for
abstract cases  as table   shows  the retrieval mechanism has a strong inuence on the
achieved speedup  even if the linear retrieval we have presented turned out to be pretty
good  we expect a utility problem  minton        to occur when the size of the casebase grows  furthermore  a good selection procedure for abstract cases should also use
some feedback from the problem solver to evaluate the learned abstract cases based on the
speedup they cause  this would eliminate unbeneficial cases or abstract operators from the
case base or the abstract problem solving domain  experiments with different indexing and
retrieval mechanisms have recently indicated that this is possible 
   

fibergmann   wilke

furthermore  the speedup caused by a combination of different approaches such as
abstraction and explanation based learning should be addressed  within the paris system
an explanation based component for case generalization is still present  see figure     but
was not used for the experiments because the plain abstraction itself had to be evaluated 
in further experiments  abstraction  explanation based learning and the integration of both
has to be addressed comprehensively  this will hopefully lead to a better understanding of
the different strengths these methods have 
as a more long term research goal  paris like approaches should be developed and
evaluated for other kinds of problem solving tasks such as configuration and design or  as
already started  for model based diagnosis 

appendix a  proofs

this section contains the proofs of the various lemma and theorems 

lemma    joining different abstractions  if a concrete domain dc and two disjoint abstract domains da  and da  are given  then a joint abstract domain da   da    da  can be
defined as follows  let da     la   ea   oa   ra   and let da     la   ea   oa   ra    then
da   da    da     la    la    ea    ea    oa    oa    ra    ra    the joint abstract domain
da fulfills the following property  if ca is an abstraction of cc with respect to  dc  da   or
with respect to  dc   da    then ca is also an abstraction of cc with respect to  dc   da  
proof  the proof of this lemma is quite simple  if ca is an abstraction of cc with respect
to  dc   dai   then there exists a sequence abstraction mapping ff and a sequence abstraction
mapping fi as required in definition    as it is easy to see  the same abstraction mappings
will also lead to the respective case abstraction in  dc   da    

lemma    multi level hierarchy  let  d           dl  be an arbitrary multi level
s hierarchy
of domain descriptions  for the two level description  dc   da   with da   l    d and
dc   d  holds that  if ca is an abstraction of cc with respect to  d           dl  then ca is
also an abstraction of cc with respect to  dc   da   
proof  let c   hhs    smi  o i be a case in domain d  intermediate state are denoted by
sj    let c    hhs     s n i  o i be a case in domain d   intermediate state are denoted by s i   
and let c be an abstraction of case c  with respect to  d           d    then a sequence of
cases  c            c      exists such that ci is from the domain di and ci   is an abstraction of
the case ci with respect to  di   di    for all i   f               g  now we proof by induction
over  that c is also an abstraction of c  with respect to  dc   da    see figure      the basis
       is obvious  c  is abstraction of c  with respect to  d    d   and is consequently also
an abstraction with respect to  dc   da    now  assume that the lemma holds for any cases up
to the domain d      it follows immediately that c    is an abstraction of c  with respect
to  dc   da    let c      hhs    s k i  o i and let the intermediate states be denoted by s r   from

definition   follows  that a state abstraction mapping ff and a sequence abstraction mapping
fi exists  such that ff scfi r     s r for all r   f           kg  because c is an abstraction of c   
   

fibuilding and refining abstract planning cases

d










d  










d 

figure     abstraction mappings for hierarchies of abstraction spaces
with respect to  d      d    it also exists a state abstraction mapping ff  and a sequence
abstraction mapping fi   such that ff   s fi    j       sj for all j   f           mg  now  we can
define a state abstraction mapping ff   s    ff   ff s   and a sequence abstraction mapping
fi    j     fi fi  j     it is easy to see  that ff   is a well defined state abstraction mapping
 s  s    ff s   ff s     ff   ff s    ff   ff s      and that fi    is a well defined sequence
abstraction mapping  fi  fi              fi  fi   m     fi  k    n   u   v   fi   u    fi    v    
fi  fi    u     fi fi  v     furthermore it follows ff   scfi     j       ff   ff scfi  fi   j        ff   s fi  j       saj  
leading to the conclusion that c is an abstraction of c  with respect to  dc   da     

theorem    correctness and completeness of the pabs algorithm  if a complete sldrefutation procedure is used in the pabs algorithm  then case ca is an abstraction of case cc
with respect to  dc   da  and the generic theory a  if and only if ca   pabs hdc   da  ai  cc  
proof 

correctness       if ca is returned by pabs  then h oa            oak   ff  fi i   paths holds   
in phase iv  we can define a state abstraction mapping ff s     fe   ff jrc   a   s   eg 
which  together with the sequence abstraction mapping fi will lead to the desired conclusion 
for every operator oai  we know by construction of phase iv  that hfi  i       fi  i   oai   i   g
holds  by construction of phase iii  we can conclude that safi  i      ra   preoai holds and
that consequently e  ra   preoai also holds for the respective execution of the body of the
while loop in phase iv  since e  ff   ff holds and   is a monotonic derivation operator 
it is obvious that ff scfi  i     ra   preoai   furthermore  the  if for all  test  which is executed
oai
before the extension of the path  ensures that  safi  i      ff     
 safi  i    ff   holds  together
oai
with the fulfillment of the precondition of the operator we have ff scfi  i       
ff scfi i   
thus  we have shown  ca is correct abstraction with respect to definition   
completeness       assume  case ca   hhsa    sam i   oa           oam i is an abstraction of cc
based on a deductively justified state abstraction mapping  then there exists a state ab    note that ff refers to the set finally constructed after termination of the while loop  we use ff to
denote the respective set during the construction in this loop 

   

fibergmann   wilke

oa

i
ff scfi i  
straction mapping ff and a sequence abstraction mapping fi such that ff scfi  i       
holds for all i   f           mg  since ff is deductively justified by a  it follows by construction
of phase ii  that ff sci      sai     since   is a monotonic derivation operator  the preconditon of oai is also fulfilled in safi  i      furthermore  the addlist of the operator is fulfilled in
ff scfi  i   and is consequently also fulfilled in sai   by the construction of phase iii  it is now
guaranteed  that hfi  i       fi  i   oai   i   g  now  we would like to show  that in phase iv 

 there exists a sequence of assignments to the variable paths  such that h    fi   ff i  
paths  h oa     fi   ff  i   paths          h oa            oam   fim  ffm i   paths  
 fik       fi    for    f           kg
  ffk   sal   ff scl  for l   f           ng and
 ffk  skl   addoal  

the proof is by induction on i  the induction basis is obvious due to the initialization
of the paths variable  now  assume that h oa            oak   fik   ffk i   paths  with k   m 
at some state of the execution of phase iv  since  hfi  k   fi  k       oak     i   g holds as
argued before  and fi  k    fik  k  by induction hypothesis  the selected operator sequence
is tried to be extended by oa   oak   in the body of the while loop  additionally  we
know  that e contains exactly those sentences which are required to proof the precondition
of oak     note  that since the sld resolution procedure is assumed to be complete and
oak   is applicable in ff sck    e is required to proof the preconditition of oa if and only if
e  ff scfi k     since ff is deductively justified   e   e    l   f           mg holds  e   ff scfi  l  
if scfi  l    rc   a   e  by construction of the sal    e   e    l   f           mg holds  e   ff scfi  l  
if e   sal   consequently  e   sal  ff scl   for all l   f           mg  on the other hand  we
also know that oak   leads to ff scfi  k       consequently  addoak    ff scfi  k      following
the same argumentation as above  we can conclude that  addoak     sal    ff scl   for all
l   f           mg  consequently  for ff    ffk   e   addoak   holds that ff    sal  ff scl    now 
oa
we can conclude that paths is extended by oak   as follows  since ff scfi           
ff scfi     
holds and that addoa   ff  and  ff    safi        ff scfi        we can immediately follow that
oa
 ff    safi           
 ff    safi        consequently  h oa            oak  oak      ffk    fik   i   paths with
ffk     ff  and fik         fik       fi     for    f           kg and fik   k        fi k   so 
the induction hypothesis is fulfilled for k      thereby  it is shown that ca is returned by
pabs   

acknowledgements
the authors want to thank agnar aamodt  jaime carbonell  padraig cunningham  subbarao kambhampati  michael m  richter  manuela veloso  as well as all members of our
research group for many helpful discussions and for remarks on earlier versions of this paper  particularly  we want to thank padraig cunningham for carefully proof reading the
   

fibuilding and refining abstract planning cases

recent version of the paper  we are also greatly indebted to the anonymous jair reviewers who helped to significantly improve the paper  this research was partially supported
by the german  sonderforschungsbereich  sfb     and the commission of the european
communities  esprit contract p      the inreca project   the partners of inreca are
acknosoft  prime contractor  france   tecinno  germany   irish medical systems  ireland 
and the university of kaiserslautern  germany  

references
althoff  k  d     wess  s          case based reasoning and expert system development 
in schmalhofer  f   strube  g     wetter  t   eds    contemporary knowledge engineering amd cognition  springer  heidelberg 
anderson  j  s     farly  a  m          plan abstraction based on operator generalization  in
proceedings of the  th international conference on artifical intelligence  pp         
san mateo  morgan kaufmann 
bacchus  f     yang  q          downward refinement and eciency of hierarchical problem
solving  artificial intelligence             
bergmann  r       a   knowledge acquisition by generating skeletal plans  in schmalhofer  f   strube  g     wetter  t   eds    contemporary knowledge engineering and
cognition  pp          heidelberg  springer 
bergmann  r       b   learning abstract plans to speed up hierarchical planning  in
tadepalli  p   ed    proceedings of the ml   workshop on knowledge compilation
and speedup learning  university of aberdeen  scotland 
bergmann  r       c   learning plan abstractions  in ohlbach  h   ed    gwai      th
german workshop on artificial intelligence  vol      of springer lecture notes on
ai  pp          
bergmann  r          integrating abstraction  explanation based learning from multiple
examples and hierarchical clustering with a performance component for planning 
in plaza  e   ed    proceedings of the ecml    workshop on integrated learning
architectures  ila     vienna  austria 
bergmann  r   pews  g     wilke  w          explanation based similarity  a unifying
approach for integrating domain knowledge into case based reasoning  in richter  m  
wess  s   althoff  k     maurer  f   eds    topics in case based reasoning  vol     
of lecture notes on artificial intelligence  pp           springer 
bergmann  r     wilke  w          inkrementelles lernen von abstraktionshierarchien
aus maschinell abstrahierten planen  in fensel  d     nakhaeizadeh  g   eds   
proceedings of the workshop maschinelles lernen  theoretische ansatze und anwendungsaspekte  no       institut fur angewandte informatik und formale beschreibungsverfahren  university of karlsruhe  germany 
   

fibergmann   wilke

blythe  j   etzioni  o     et al          prodigy     the manual and tutorial  tech  rep 
cmu cs         carnegie mellon university  pittsburgh  pa 
carbonell  j  g          derivational analogy  a theory of reconstructive problem solving
and expertise aquisition  in michalski  r  s   carbonell  j  g     mitchell  t  m 
 eds    machine learning  an artificial intelligence approach  vol     chap      pp 
         morgan kaufmann  los altos  ca 
dejong  g     mooney  r          explanation based learning  an alternative view  machine learning                 
etzioni  o          a structural theory of explanation based learning  artificial intelligence 
           
etzioni  o     etzioni  r          statistical methods for analyzing speedup learning 
machine learning              
fikes  r  e   hart  p  e     nilsson  n  j          learning and executing generalized robot
plans  artificial intelligence             
fikes  r  e     nilsson  n  j          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence             
friedland  p  e     iwasaki  y          the concept and implementation of skeletal plans 
journal of automated reasoning                 
giordana  a   roverso  d     saitta  l          abstracting background knowledge for
concept learning  in kodratoff  y   ed    proceedings of the european working session
on learning  ewsl      lecture notes in artificial intelligence  pp       berlin 
springer 
giunchiglia  f     walsh  t          a theory of abstraction  artificial intelligence     
        
green  c          application of theorem proving to problem solving  in proceedings of
ijcai     pp          washington  dc 
holte  r   drummond  c   perez  m   zimmer  r     macdonald  a          searching
with abstractions  a unifying framework and new high performance algorithm  in
proceedings of the   th canadian conference on artificial intelligence  pp          
morgan kaufmann publishers 
holte  r   mkadmi  t   zimmer  r     macdonald  a          speeding up problem solving
by abstraction  a graph oriented approach  tech  rep  tr        computer science
dept   university of ottawa  ontario  canada 
kambhampati  s     hendler  j  a          a validation structure based theory of plan
modification and reuse  artificial intelligence              
   

fibuilding and refining abstract planning cases

kambhampati  s     kedar  s          a unified framework for explanation based generalization of partially ordered partially instantiated plans  artificial intelligence     
      
knoblock  c  a          a theory of abstraction for hierachical planning  in proceedings of
the workshop on change of representation and inductive bias  pp         boston 
ma  kluwer 
knoblock  c  a          learning abstraction hierarchies for problem solving  in proceedings
eighth national conference on artificial intelligence  vol     pp          london 
mit press 
knoblock  c  a          search reduction in hierarchical problem solving  in proceedings of
the  th national conference on artificial intelligence  vol     pp          anaheim 
ca 
knoblock  c  a          generating abstraction hierarchies  an automated approach to
reducing search in planning  kluwer academic publishers 
knoblock  c  a          automatically generating abstractions for planning  artificial
intelligence              
knoblock  c  a   minton  s     etzioni  o       a   integrating abstraction and
explanation based learning in prodigy  in proceedings of the  th national conference on artificial intelligence  vol     pp          anaheim  ca 
knoblock  c  a   tenenberg  j  d     yang  q       b   characterizing abstraction hierarchies for planning  in proceedings of the  th national conference on artificial
intelligence  vol     pp          anaheim  ca 
kolodner  j  l          retrieval and organizational strategies in conceptual memory 
ph d  thesis  yale university 
kolodner  j  l          case based reasoning  morgan kaufmann 
korf  r  e          toward a model of representation changes  artifical intelligence     
      
korf  r  e       a   depth first iterative deepening  an optimal admissible tree search 
artifical intelligence             
korf  r  e       b   macro operators  a weak method for learning  artifical intelligence 
          
korf  r  e          planning as search  a quantitative approach  artifical intelligence     
      
korf  r  e          linear space best first search  artifical intelligence            
   

fibergmann   wilke

kramer  m     unger  c          abstracting operators for hierarchical planning  in
hendler  j   ed    proceedings of the international conference on ai planning  pp 
         morgan kaufmann 
laird  j   rosenbloom  p     newell  a          universal subgoaling and chunking  the
automatic generation and learning of goal hierarchies  kluwer academic publishers  norwell  ma 
langley  p     allen  j          a unified framework for planning and learning  in minton 
s   ed    machine learning methods for planning  chap      pp           morgan
kaufmann 
lifschitz  v          on the semantics of strips  in reasoning about actions and plans 
proceedings of the      workshop  pp      timberline  oregon 
lloyd  j          foundations of logic programming  springer 
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings of
the  th national conference on artificial intelligence  pp          
michalski  r  s          inferential theory of learning as a conceptual basis for multistrategy
learning  in michalski  r     tecuci  g   eds    machine learning  a multistrategy
approach  no      chap     pp        morgan kaufmann 
michalski  r  s     kodratoff  y          research in machine learning  recent progress 
classification of methods  and future directions  in kodratoff  y     michalski  r  s 
 eds    machine learning  an artificial intelligence approach  vol     chap     pp 
      morgan kaufmann  san mateo  ca 
minton  s          learning search control knowledge  an explanation based approach 
kluwer  boston  ma 
minton  s          quantitativ results concerning the utility of explanation based learning 
artifical intelligence              
minton  s   carbonell  j  g   knoblock  c   kuokka  d  r   etzioni  o     gil  y         
explanation based learning  a problem solving perspective  artificial intelligence 
           
minton  s     zweben  m          learning  planning and scheduling  an overview  in
minton  s   ed    machine learning methods for planning  chap     pp        morgan
kaufmann 
mitchell  t  m   keller  r  m     kedar cabelli  s  t          explanation based generalization  a unifying view  machine learning               
mooney  r  j          generalizing the order of operators in macro operators  in laird 
j   ed    proceedings of the  th international conference on machine learning  pp 
        san mateo  ca  morgan kaufmann 
   

fibuilding and refining abstract planning cases

mooney  r  j     dejong  g  f          learning schemata for natural language processing 
in proceedings of ijcai  pp          los angeles  ca 
mozetic  i          abstraction in model based diagnosis  in aaai workshop on automatic
generation of approximations and abstractions  pp        boston  ma 
newell  a     simon  h          human problem solving  prentice hall englewood cliffs 
nj 
paulokat  j     wess  s          planning for machining workpieces with a partial order 
nonlinear planner  in aaai fall symposium on planning and learning  on to real
applications 
perez  m     carbonell  j          automated acquisition of control knowledge to improve
the quality of plans  tech  rep  cmu cs         carnegie mellon university 
pews  g     wess  s          combining model based approaches and case based reasoning
for similarity assessment and case adaptation in diagnositc applications  in richter 
m  m   wess  s   althoff  k     maurer  f   eds    preprints of the first european
workshop on case based reasoning  ewcbr      vol  ii  pp           university
of kaiserslautern  germany 
plaisted  d          theorem proving with abstraction  artifical intelligence             
plaisted  d          abstraction using generalization functions  in proceedings of the  th
conference on automated deduction  vol      pp          
rosenbloom  p     laird  j          mapping explanation based learning onto soar  in
proceedings national conference on artificial intelligence  vol    philadelphia  pa 
sacerdoti  e          planning in a hierarchy of abstraction spaces  artificial intelligence 
           
sacerdoti  e          a structure for plans and behavior  vol     american elsevier  new
york 
schank  r  c          dynamic memory  a theory of learning in computers and people 
cambridge university press  new york 
schmidt  g          modellbasierte  interaktive wissensakquisition und dokumentation von
domaenenwissen  ph d  thesis  university of kaiserslautern  germany 
schmidt  g     zickwolff  m          cases  models and integrated knowledge acquisition to
formalize operators in manufacturing  in proceedings of the  th knowledge acquisition
for knowledge based systems workshop  banff  
shavlik  j     o rorke  p          empirically evluation ebl  in investigating explanationbased learning  vol     chap     pp           kluwer academic publishers 
simon  h          the functional equivalence of problem solving skills  cognitive psychology 
           
   

fibergmann   wilke

tenenberg  j          preserving consistency across abstraction mappings  in mcdermott 
j   ed    proceedings of the   th international conference on artifical intelligence 
pp            los altos  ca  morgan kaufmann 
tenenberg  j          abstraction in planning  ph d  thesis  computer science department 
university of rochester  new york 
unruh  a     rosenbloom  p          abstraction in problem solving and learning  in
proceedings of the international joint conference on artifical intelligence     pp 
        detroit  mi  morgan kaufmann 
veloso  m  m          learning by analogical reasoning in general problem solving  ph d 
thesis  carnegie mellon university  pittsburgh  pa 
veloso  m  m          prodigy analogy  analogical reasoning in general problem
solving  in richer  m   wess  s   althoff  k     maurer  f   eds    topics in casebased reasoning  pp         lecture notes in ai  vol       springer 
veloso  m  m     blythe  j          linkability  examining causal link commitments
in partial order planning  in proceedings of the  nd international conference on
planning for ai systems aips    
veloso  m  m     carbonell  j  g          integrating derivational analogy into a general
problem solving architecture  in minton  s   ed    proceedings of the first workshop
on case based reasoning  morgan kaufmann 
veloso  m  m     carbonell  j  g          towards scaling up machine learning  a case
study with derivational analogy in prodigy  in minton  s   ed    machine learning
methods for planning  chap     pp           morgan kaufmann 
wilke  w          entwurf und implementierung eines algorithmus zum wissensintensiven
lernen von planabstraktionen nach der pabs methode  projektarbeit  universitat
kaiserslautern 
wilke  w          entwurf  implementierung und experimentelle bewertung von
auswahlverfahren fur abstrakte plane im fallbasierten planungssystem paris  master s thesis  university of kaiserslautern  germany 
wilkins  d          practical planning  extending the classical ai planning paradigm 
morgan kaufmann 
yang  q     tenenberg  j          abtweak  abstracting a nonlinear  least commitment
planner  in proceedings of the  th national conference on aritificial intelligence  pp 
        boston  ma 

   

fi