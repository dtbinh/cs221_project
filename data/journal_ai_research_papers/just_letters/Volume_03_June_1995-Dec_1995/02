journal artificial intelligence research                

submitted       published     

building refining abstract planning cases
change representation language
ralph bergmann
wolfgang wilke

bergmann informatik uni kl de
wilke informatik uni kl de

centre learning systems applications  lsa 
university kaiserslautern  p o  box       d       kaiserslautern  germany

abstract

abstraction one promising approaches improve performance problem
solvers  several domains abstraction dropping sentences domain description  
used hierarchical planners   proven useful  paper present examples
illustrate significant drawbacks abstraction dropping sentences  overcome
drawbacks  propose general view abstraction involving change
representation language  developed new abstraction methodology related
sound complete learning algorithm allows complete change representation
language planning cases concrete abstract  however  achieve powerful
change representation language  abstract language well rules
describe admissible ways abstracting states must provided domain model 
new abstraction approach core paris  plan abstraction refinement
integrated system   system abstract planning cases automatically
learned given concrete cases  empirical study domain process planning
mechanical engineering shows significant advantages proposed reasoning
abstract cases classical hierarchical planning 

   introduction
abstraction one challenging promising approaches improve complex
problem solving inspired way humans seem solve problems  first  less
relevant details given problem ignored abstracted problem
solved easily  then  step step  details added solution taking
increasingly detailed look problem  thereby  abstract solution constructed
first refined towards concrete solution  one typical characteristic work
hierarchical problem solving abstraction mostly performed dropping sentences
domain description  sacerdoti              tenenberg        unruh   rosenbloom 
      yang   tenenberg        knoblock              bacchus   yang         second
common characteristic hierarchical problem solver usually derives abstract
solution scratch  without using experience previous problem solving episodes 
giunchiglia walsh        presented comprehensive formal framework
abstraction comparison different abstraction approaches theorem proving
 plaisted              tenenberg         planning  newell   simon        sacerdoti       
      tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock 
             model based diagnosis  mozetic         hierarchical planning  korf s
model abstraction problem solving  korf        allows analysis reductions
c      ai access foundation morgan kaufmann publishers  rights reserved 

fibergmann   wilke

search caused single multiple levels abstraction  shown optimal
case  abstraction reduce expected search time exponential linear  knoblock
developed approach construct hierarchy abstraction spaces automatically
given concrete level problem solving domain  knoblock                    
called ordered monotonic abstraction hierarchies  knoblock  tenenberg    yang      b 
proven useful many domains  recently  bacchus yang        presented
improved method automatically generating abstraction hierarchies based
detailed model search costs 
abstraction methods  however  rely abstraction dropping sentences
domain description kind homomorphic abstraction  holte et al        
       shown kinds abstractions highly representation dependent  holte et al                two classical planning domains  different  natural 
representations analyzed turns several representations
classical abstraction techniques lead significantly improved problem
solvers  knoblock        holte et al          however  well known normally many
different representations domain exist already pointed korf        
theory representation developed  particular 
theory representation hierarchical problem solving dropping sentences 
knowledge engineering perspective  many different aspects simplicity 
understandability  maintainability must considered developing domain representation  therefore  assume representations domains given knowledge
engineers rely representations consider  natural  certain kinds
problems  demonstrate two simple example problems related representations 
usual use abstraction problem solving lead improvement 
first example  improvement achieved abstraction restricted
dropping sentences domain  second example  abstract solution computed
scratch decompose original problem consequently cut
search space next detailed level  want argue examples
never represented way standard hierarchical problem solving works well 
however  think would require large effort knowledge engineer develop
appropriate representation believe often impossible develop representation appropriate knowledge engineering perspective allows
ecient hierarchical problem solving based dropping sentences 
take observations motivation develop general model abstraction problem solving  already pointed michalski         abstraction 
general  seen switching completely new representation language
level detail reduced  problem solving  new abstract representation language
must consist completely new sentences operators subset
sentences operators concrete language  knowledge  sipe  wilkins       
planning system currently allows change representation language
across different levels abstraction  however  general abstraction methodology
allows ecient algorithms abstraction refinement yet developed 
want propose method abstraction allows complete change representation language problem solution concrete abstract vice versa 
concrete abstract language given  additionally  propose use experience
  

fibuilding refining abstract planning cases

previously solved problems  usually available set cases  come abstract
solutions  use experience already proven useful various approaches speedup learning explanation based learning  mitchell  keller    kedar cabelli       
dejong   mooney        rosenbloom   laird        minton        minton  carbonell 
knoblock  kuokka  etzioni    gil        shavlik   o rorke        etzioni        minton
  zweben        langley   allen        kambhampati   kedar         analogical
case based reasoning  carbonell        kambhampati   hendler        veloso   carbonell 
      veloso        
main contribution paper  present abstraction methodology
related learning method beneficial abstract planning cases automatically derived
given concrete cases  based given concrete abstract language  learning
approach allows complete change representation case concrete
abstract level  however  achieve unconstrained kind abstraction 
set admissible abstractions must implicitly predefined generic abstraction theory 
compared approaches abstraction hierarchies generated automatically 
effort required specify abstract language  feel price
pay make planning tractable certain situations 
approach fully implemented paris  plan abstraction refinement
integrated system   system abstract cases learned organized case
base  novel problem solving  case base searched suitable abstract case
refined concrete solution current problem 
presentation approach organized follows  next section presents
analysis hierarchical problem solving shortcomings current approaches
illustrated simple examples  section three argues powerful case abstraction
refinement method overcome identified problems  furthermore  present
paris approach informally  using simple example  next three sections paper
formalize general abstraction approach  introducing basic terminology  section   defines new formal model case abstraction  section   contains detailed
description correct complete learning algorithm case abstraction  section  
explains refinement cases solving new problems  section   gives detailed description domain process planning mechanical engineering production
rotary symmetric workpieces lathe demonstrates proposed approach examples domain  section   reports detailed experimental evaluation paris
described domain  finally  discuss presented approach relation similar
work field  appendix article contains formal proofs properties
abstraction approach related learning algorithm  additionally  detailed
representation mechanical engineering domain used experimental evaluation
given online appendix   

   analysis hierarchical problem solving
basic intuition behind abstraction follows  first ignoring less relevant features
problem description  abstraction allows problems solved coarse fashion
less effort  then  derived abstract  skeletal  solution serves problem decomposition
original  detailed problem  korf        shown hierarchical problem
  

fibergmann   wilke

solving reduce required search space significantly  assume problem requires
solution length n furthermore assume average branching factor b 
i e   average number states reached given state applying
single operator  worst case time complexity finding required solution search
o bn    now  suppose problem decomposed abstract solution
k subproblems  require solution length n           nk   respectively 
n    n      nk   n  situation  worst case time complexity finding
complete solution o bn    bn      bnk   o bmax n  n       nk      please note
significant reduction search time complexity  particular  easily see
reduction maximal subproblems similar size  i e   n  n  nk  
however  achieve significant search reduction  computed abstract solution must
solution abstracted problem  must additionally fulfill certain
requirement presupposed analysis  subproblems introduced abstract
solution must independent  i e   must solvable without interaction
subproblems  avoids backtracking solution subproblem
consequently cuts necessary overall search space  even restriction
completely fulfilled  i e   backtracking still required cases  several empirical studies
 especially knoblock                    shown abstraction nevertheless lead
performance improvements 
unfortunately  domains representations domains  holte et al        
      way abstraction used hierarchical problem solving cannot improve
problem solving derived abstract solutions don t fulfill mentioned
requirement all  following  show two examples domains
demonstrate two general drawbacks hierarchical problem solving  please note
examples  particular representation assumed  feel representations
somehow  natural  likely used knowledge engineer developing domain  however  might representations domains traditional
hierarchical planning works  assume representations dicult find 
especially domain representation fulfill additional knowledge engineering
requirements 

    abstraction dropping sentences

hierarchical problem solving  abstraction mostly  achieved dropping sentences
problem description preconditions and or effects operators  sacerdoti       
      tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock 
             assumption justifies kind abstraction less relevant
details problem description expressed isolated sentences representation
addressed relevant sentences established  ignoring
sentences assumed lead abstract solution useful reduce search
concrete planning levels 
however  assumption hold domains  example  many real world
domains  certain events need counted  e g   transporting certain number
   tenenberg s        abstraction analogical mappings planning system sipe  wilkins 
      contains first approaches allow change representation language 

  

fibuilding refining abstract planning cases

containers one location another  imagine domain which  addition several
operators  increment operator described follows 
operator  inc
precondition  value x  
delete  value x  
add  value x     

representation  integer value increased represented single sentence  state consists single sentence  operator contains
one single sentence   think representation  natural  likely
chosen knowledge engineer  domain  incrementing value    value   
requires sequential plan composed   inc operators  leading state sequence 
value    value           value     example  however  abstraction dropping sentences work because  single sentence would dropped  nothing would remain operator description whole counting problem would dropped
completely  empty problem abstract level  empty plan
going solve it  unfortunately  empty plan cannot cause complexity reduction
solving problem concrete level  consequently  abstraction dropping sentences
completely fails improve problem solving situation 
however  adequately cope counting problem abstracting
quantitative value expressed sentence towards qualitative representation  e g  
low f          g  medium   f          g  high   f            g   qualitative representation would result abstract plan composed two operators  subproblems 
increase value low medium high  abstract plan defines two
independently refinable subproblems  solve first subproblem concrete level 
problem solver search sequence inc operators increment value
  medium value  any value set f          g   subproblem
solved sequence   inc operators leading concrete state value    similarly  second subproblem concrete level find sequence operators
change value   final value    second subproblem solved
sequence   inc operators  see complete problem requires
sequence   concrete operators divided   subproblems subproblem
solved   step plan  exponential nature search space  two
  step problems together solved much less search   step problem
whole  following korf s analysis sketched before  time complexity reduced o b  
o b      please note particular abstraction leads two subproblems
central achieving complexity reduction  important point problem
decomposed one subproblem  kind abstraction achieved
introducing new abstract representation language consists qualitative values
corresponding abstract increment operator 
   however  might assume term x     modeled separate predicate precondition 
unfortunately  change described situation all 
   assume many operators besides inc operator  b   holds 

  

fibergmann   wilke

even generalize specific example presented above  problem
dropping condition approach possible abstract information  e g  
value example  coded single sentence representation 
particularly problem required solution contains long sequence states
differ single sentence  dropping particular sentence leads dropping
whole problem  dropping sentence lead abstraction 
really required abstract information encoded single sentence obviously
requires dropping complete information 
summarize  seen abstraction dropping sentences work
particular kind problems shown  general  abstraction requires changing complete representation language concrete abstract usually involves
introduction completely new abstract terms  sentences operators   within
general view  dropping sentences special case abstraction  reason dropping sentences widely used hierarchical planning due simplicity 
refinement easy abstract states directly used goals
detailed levels  another important property abstraction dropping sentences
useful hierarchies abstraction spaces constructed automatically domain
descriptions  knoblock                    bacchus   yang        

    generating abstract solutions scratch

another limiting factor classical hierarchical problem solving way abstract solutions computed  pointed korf  good abstract solution must lead mostly
independent subproblems equal size  classical problem solving  abstract solution
found breadth first depth first search using linear  e g   alpine  knoblock       
non linear  e g   abtweak  yang   tenenberg        problem solvers  problem solvers  upward solution property  tenenberg        usually holds  means
abstract solution exists concrete level solution exists  usually  problem
solvers find arbitrary abstract solution  e g   shortest possible solution   unfortunately  way guarantee computed solutions refinable lead
mostly independent subproblems suciently equal size  even solution exists 
general  even heuristics try guide problem solving towards
aspired kind useful abstractions  problem illustrated following example 
additionally shows limitation abstraction dropping sentences 
imagine large  or even infinite  state space includes least   distinct states
shown left figure      states described presence absence
three sentences e    e    e   state description    bit vector shown figure
       indicates absence sentence     represents presence sentence 
  different states described three sentences arranged   dimensional
cube  using one dimension sentence  arrows diagram show possible state
transitions available operators domain   operator manipulates  adds
deletes  exactly one sentence state description  certain conditions
sentences fulfilled  representation two operators shown right
   dashed lines represent operators introduced make shape cube
easy see 

  

fibuilding refining abstract planning cases

z

   

   

two example operators 
   

   

x z
   

e 

x

   

   

e 
e 

   

o          
precondition 
e 
 not e  
 not e  

o          
precondition 
e 
 not e  
e 

add  e 

delete  e 



figure    state space example domain representation two operators
side figure  subscript operator name relates respective transition
state diagram  general  see

e   manipulated  e   e   holds 
e   manipulated  e   e   holds 
e   manipulated  e     e   holds 
furthermore  assume many operators connect states
domain  shown diagram    depicted states  consequently 
must assume branching factor b   state  makes search space
problem solving quite large  besides description domain  figure   shows
three example problems  x   x        z   z     example  solution
problem x   x     step path                                   
now  let s consider abstract solutions correspond concrete solutions
three problems  problem  want examine three possible ways
abstraction dropping one sentences  purpose  geometric arrangement
states turns useful abstraction simply viewed
projecting   dimensional state space onto plane defined sentences
dropped abstraction  left part figure   shows three possible abstract
state spaces result dropping one sentences  important
see abstract state space  every sentence modified unconditionally
independent sentences  however  one sentence modified
operator  thereby  constraints exist concrete level relaxed 
abstraction concrete solution three problems  x   x       
z   z    respect three possible ways dropping conditions shown
  

fibergmann   wilke

state spaces
dropping conditions

x  x

y  y

e 

 

e 
 

 

 

 
 
e 

 

 

e 
e 

z  z

 

 

 

e 
 

 

 

e 
 

e   

 
 

 

e 

 

 
 

 
  e 

 
 

e 

 

 
e 

 

 

figure    abstract state spaces dropping conditions
right side figure    nine possible abstract solutions consists three
four abstract operators  sequence applied indicated
numbers mark operators  see whatever sentence
drop problems  appropriate abstract solution exists decomposes
original problem independent refinable subproblems suciently equal size 
main point example none abstract solutions found
hierarchical problem solver  reason abstracted problems
exists   step   step solution addition nine   step   step solutions
indicated depicted paths  however  short solution completely useless
reducing search next concrete level original problem
decomposed all  central problem problem solvers find
shorter useless solutions first  try refine them  consequently  search
space concrete level reduced performance improvement achieved
all  however  might representations example domain
hierarchical problem solver comes useful abstract solution  think  however 
representation shown quite natural represents   different states
minimal number binary sentences 
summarize  presented example useful abstract solution found
hierarchical planning although exists  reason planners usually try
find shortest solutions  good strategy ground level  may
appropriate abstract level  neither desirable search longest
solutions might cause unnecessarily long concrete plans 

   case abstraction refinement

way problem  propose use experience given form concrete
planning cases abstract experience reuse new situations  therefore 
need powerful abstraction methodology allows introduction completely
new abstract terminology abstract level  makes possible useful abstract
solutions expressed domains abstraction dropping conditions
sucient  particular  methodology must serve means analyze
different abstraction approaches  must allow ecient algorithms abstracting
refining problems solutions 
  

fibuilding refining abstract planning cases

    basic idea
introduce approach achieves case abstraction refinement changing
representation language  prerequisite  approach requires abstract
language  state description operators  given domain expert addition
concrete level description  require set admissible ways abstracting
states implicitly predefined generic abstraction theory  course additional
knowledge engineering requirement  feel price pay
enhance power hierarchical problem solving  recent research knowledge acquisition
already describes approaches tools acquisition concrete level abstract level
operators real world domains  schmidt   zickwolff        schmidt         abstract
language given user additional advantage abstracted cases
expressed language user familiar  consequently  understandability
explainability  always important issues applying system  achieved
easily 
source learning  assume set concrete planning cases 
consists problem statement together related solution  case prodigy
 minton et al          consider sequential plans  i e   plans totally ordered
operators  planning cases assume include problem solving trace example problem solving cases prodigy analogy  veloso        veloso   carbonell 
      veloso         real world applications  domain expert s solutions previous
problems usually recorded company s filing cabinet database  cases
seen collection company s experience  want draw power 
learning phase  set abstract planning cases generated available
concrete case  abstract planning case consists abstracted problem description
together abstracted solution  case abstraction procedure guarantees
abstract solution contained abstract case always refined become solution
concrete problem contained concrete case became abstracted  different
abstract cases may situated different levels abstraction may abstractions
according different abstraction aspects  different abstract cases different utility
reduce search space concrete level different ways  happen
several concrete cases share abstraction  set abstract planning cases
learned organized case base ecient retrieval problem solving 
problem solving phase  case base searched abstract case
found applied current problem hand  abstract case applicable
current problem abstracted problem contained abstract planning case
abstraction current problem  however  cannot guarantee abstract
solution contained selected abstract case really refined become solution
current problem  least known abstract solution case base
already useful solving one previous problems  i e   problems contained
concrete cases abstract case learned  since new problem
similar previous problems abstracted way 
least high chance abstract solution useful solving new problem 
new problem solved refinement new concrete case arises
used learning 
  

fibergmann   wilke

learning

paris system

evaluation 
indexing

case base

generalization

abstraction

problem solving
retrieval

domain description
concrete domain 
abstract domain 
generic abstraction theory

new problem

specialization

refinement

solved problem

training cases

figure    components paris system

    paris architecture
paris  plan abstraction refinement integrated system  follows basic ap 

proach described  figure   shows overview whole system components 
besides case abstraction refinement  paris includes explanation based approach
generalizing cases learning specializing problem solving  furthermore  system includes additional mechanisms evaluating different abstract
cases generalizations derived explanation based component  evaluation
component measures reduction search time caused abstract plan solving concrete problems case base abstract plan applicable 
based evaluation  several different indexing retrieval mechanisms developed  retrieval procedures abstract cases preferred caused
reduction search previous problem solving episodes  particular  abstract cases turn useless many concrete problems may even become
completely removed case base  spectrum developed retrieval approaches
ranges simple sequential search  via hierarchical clustering sophisticated approach balancing hierarchy abstract cases according statistical distribution
cases within problem space evaluated utility  details generalization procedure found  bergmann      a   evaluation retrieval
mechanisms reported  bergmann   wilke        wilke         whole multistrategy system including various interactions described components
topic forthcoming article  first ideas already found  bergmann      b 
       however  target paper concentrate core paris  namely
approach abstraction refinement 
  

fibuilding refining abstract planning cases

state abstractions
abstract plan

a 

   

   

a 
   

   

   

a 

   

a 

a 

a 

a 

   
   
   

   

   

   
   
   

changing
representration

   

a 

   

figure    example case abstraction

    informal description abstraction approach

first give informal description abstraction approach paris  based
small example shown figure   enhance understanding subsequent formal
sections  suppose solution problem x   x   available concrete problem solving experience  task learn abstract case beneficially
used solve future problems     z   z     learning task must
achieved within abstraction approach stronger dropping sentences 
look figure    becomes obvious changing representation single abstract
case learned useful three concrete problems  abstract plan shown
indicates concrete states abstracted towards single abstract state 
single abstract plan exists useful three problems 
      abstract language generic abstraction theory

achieve kind abstraction  approach requires abstract language  states
operators   well generic abstraction theory provided user  example figure    abstract language must contain new abstract sentences a            a 
three abstract operators allow respective state transitions  abstract
operators  called oai  i   f            g   defined follows 
operator  oai
precondition  ai
delete  ai
add  ai  

new abstract sentence  user must provide set generic abstraction rules
describe sentence defined terms available sentences con  

fibergmann   wilke

crete language  generic abstraction theory defined rules specifies set
admissible state abstractions  example  generic abstraction theory must contain following two rules define new abstract sentence a     e     e     a 
 e      e      e     a   general  definition generic abstraction theory
require state abstractions noted explicitly  abstract states derived
implicitly application combination several rules generic abstraction
theory 
besides kind abstraction described above  user may want specify
different type abstraction she he considers useful  example 
assume abstraction dropping sentence e   realized  case 
abstract language must contain copy two sentences dropped  i e  
sentences e   e    therefore  user  may define two abstract sentences a 
a  following rules generic abstraction theory  e     a  e     a  
course  respective abstract operators must specified 
since domain expert knowledge engineer must provide abstract language
generic abstraction theory  she he must already one particular kinds
abstraction mind  she he must know kind details omitted solving
problem abstract fashion  approach  knowledge engineer given
power express kind abstraction she he considers useful 
      model case abstraction

based given abstract language generic abstraction theory  abstraction
planning case formally described two abstraction mappings  state abstraction
mapping sequence abstraction mapping  two mappings describe two dimensions
reducing level detail case  state abstraction mapping reduces level
detail state description changing representation language  case
abstraction indicated figure    state abstraction mapping must map concrete
states              onto abstract state described new sentence a  
simultaneously must map concrete states occurring plan onto respective
abstract states described new sentences a    a    a    sequence abstraction
mapping reduces level detail number states considered
abstract level relating concrete states concrete case abstract
states abstract case  concrete states skipped  abstract
state must result particular concrete state  example  figure    abstraction
plan                                   requires sequence abstraction mapping
relates first abstract state described a  first concrete state     
second abstract state described a  third concrete state      forth 
example  second fifth concrete states skipped 
      learning abstract planning cases

procedure learning abstract planning cases given concrete planning case
decomposed four separate phases  simple example  phases shown
   please note abstraction dropping sentences  consider alpine like algorithm
generates required abstract language generic abstraction theory automatically 

  

fibuilding refining abstract planning cases

a a 

a 

ca  
phase iv
ca   a 

oa  

phase iii

a 

oa  

oa  

a 

a 

oa  

oa  

oa  

a 

oa  

oa  

phase ii

a 

  a 

  a 

  a  a 

  a 

  a 

phase i

   

   

   

   

   

   

figure    four phases case abstraction solution problem x   x  
figure    phase i  states result execution plan contained
concrete case determined  therefore  operator contained plan  starting
first operator  applied successor state computed  process starts
initial state contained case leads final state  goal state
contained case  phase ii  derive admissible abstractions concrete
state computed first phase  purpose  generic abstraction theory used
determine abstract sentences derived respective concrete state
applying rules generic abstraction theory  figure   shows abstract sentences
derived generic abstraction theory sketched above  example 
see second concrete state abstract description derived contains
two abstract sentences  abstract sentence a  required achieve type abstraction
shown figure   additionally abstract sentences a  required abstraction
dropping sentences  please note process  representation language states
changed concrete abstract  next two phases deal abstract operators 
already stated  abstract operators given abstract language provided
user  however  assume operator abstraction rules associate abstract
operator single concrete operator sequence concrete operators  reason
operator abstraction rules extremely hard acquire even harder
keep complete  next two phases case abstraction  search transitions
abstract states based available abstract operators  phase iii  acyclic directed
graph constructed  edge leads abstract state successor abstract state
j  not necessarily next abstract state   abstract operator applicable state
application leads state j   definition abstract operators
used process  available abstract operators determine transitions
included graph  figure   shows resulting graph  provided abstract
operators sketched section       contained abstract language  graph
  

fibergmann   wilke

transitions shown plain line style result operators oai   transitions
shown dashed line style result operators required abstraction dropping
conditions 
phase iv graph searched consistent paths initial abstract state
final abstract state  paths must consistent sense resulting
path  i e   abstract plan  every abstract operator correctly applicable state
results previous operator  moreover  state abstraction required
abstract plan must change within plan  figure   two paths kind
shown  lower path represents abstract planning case ca   abstract initial final
state together operator sequence  results kind abstraction shown
figure    upper path represents abstract planning case ca  results
abstraction dropping sentence e    abstract plan shown figure
  problem x   x    together two plans  abstract state descriptions
result operator application shown  please note state descriptions
always subset description derived generic abstraction theory 
example  description fourth abstract state derived phase ii  contains
sentences a    a   a   abstract state occurs abstract cases computed
phase iv  case ca    respective state described sentences a 
a  sentences result application operators
starting abstract initial state  case ca   abstract state described
sentence a  sentence results application operator oa  
example see abstract operators two functions  first
function select concrete states become abstracted  example 
abstract case ca   second concrete state skipped  even first second
concrete states abstracted different abstract descriptions phase ii  reason
abstract operator a  leads first abstracted state
second abstracted state b  consistent operators
rest path  second function abstract operators select
abstract sentences considered abstract planning case  example 
abstract case ca    sentences a            a  considered sentences a  a 
left out  reason abstract operators oa    oa   oa  occur
plan don t use a  a  precondition don t manipulate sentences 
phase iv finished  set abstract planning cases available  planning
cases stored case base used problem solving 
      selecting refining abstract cases

problem solving  abstract case must selected case base  abstract
plan contained case must refined become solution current problem 
case retrieval must search abstract case applicable  i e   contains
problem description abstraction current problem  example  assume
problem     solved case x   x   presented learning 
situation case base contains two abstract cases ca  ca  shown phaseiv figure    abstract case ca  used solving new problem 
initial state     new problem abstracted a  applying generic
  

fibuilding refining abstract planning cases

selected abstract case 

a 

defined search spaces 

   

refined solution 

   

oa  

   

a 

oa  

a 

 

 

   

   

oa  

a 

   

   

   

figure    refinement abstract case solution problem    
abstraction theory  similarly  final state     abstracted a    however 
abstract case ca  applicable final abstract state cannot abstracted
a   consequently  lower abstract case must used  plan refinement
refine abstract operators sequentially left right shown figure    thereby
abstract operator defines abstract goal state  i e   state results
execution operator  example  abstract operator oa  defines abstract goal
a   refine abstract operator  search concrete operator sequence  starting
current concrete state  i e   initial state first operator   concrete
state reached abstracted desired goal state  state found
used starting state refinement next abstract operator 
solution problem       refinement abstract operator oa 
achieved sequence two concrete operators leading concrete state     
concrete state used starting state refine next abstract operator oa  
refinement procedure finishes last abstract operator refined way
final concrete state achieved  please note type refinement operators
used directly  instead sequence states results
execution used  alternatively  could stored abstract case sequence
abstracted states  experience  storing sequence operators requires less
space storing sequence states  become obvious looking
domain introduced section    besides abstract operators play
important role learning phase 

    relations skeletal plans
similar experience based case based variant finding abstract solution
found early paper friedland iwasaki        concept skeletal
plans introduced  skeletal plan        sequence generalized steps  which 
instantiated specific operations specific problem context solve given problem
 p             skeletal plans exist many levels generality  general level 
basic plans  used  fall backs   specific  easier
refine plans cannot found   p         skeletal plans solutions planning problems
different levels detail consequently abstract plans  problem solving
  

fibergmann   wilke

recalled library refined towards concrete solution  approach
seen early idea integrating abstraction case based reasoning  however 
several differences skeletal plan approach paris approach 
skeletal plan approach model operators  neither concrete abstract  used
describe preconditions effects operators done paris  explicit
notion states abstraction refinement states  instead  plan refinement
achieved stepping hierarchy operators  guided heuristic rules operator
selection  particular  approach supports automatic acquisition skeletal
plans provided  unfortunately  skeletal plan approach yet investigated
much detail current work field speedup learning  neither formal
model skeletal planning empirical evaluations 
rest paper introduce investigate paris approach
formally 

   basic terminology
section want introduce basic formal terminology used throughout rest
paper  therefore define formal representation problem solving domains 
want assume problem solving general viewed transforming initial
state final state using sequence operators  newell   simon         following
strips oriented representation  fikes   nilsson         domain problem solving
  hl  e   o  ri described first order language  l  set essential atomic sentences
e l  lifschitz         set operators related descriptions  additionally 
set rules  horn clauses  r l  essential sentences  which must atomic 
sentences used describe state  state   describes dynamic
part situation domain consists finite subset ground instances essential
sentences e   symbol   denote set possible states descriptions
domain  defined    e   e   fe je   e substitution
e groundg  addition  horn clauses r allow representation static properties
true situations  horn clauses must contain essential sentence
head clause 
operator o x           xn    described triple hpreo   addo  deloi 
precondition preo conjunction atoms l  add list addo deletelist delo finite sets  possibly instantiated  essential sentences e   furthermore 
variables occuring operator descriptions must follow following restrictions 
fx           xng v ar preo  v ar delo  fx           xng v ar addo   
instantiated operator expression form o t           tn    ti ground
terms l  term ti describes instantiation variable xi operator description  notational convenience define instantiated precondition well instantiated add list delete list instantiated operator follows  preo t       tn      preo  
addo t      tn     fa ja   addog  delo t      tn     fd jd   delo g  hpreo   addo  deloi
   basic language first order  deductive rules given horn logic subset
full first order language used 
   restrictions however relaxed fx            xn g v ar preo   required 
introduced restriction simplifies subsequent presentation 

  

fibuilding refining abstract planning cases

description  uninstantiated  operator o x           xn     fx   t            xn  tn g
corresponding instantiation 
instantiated operator applicable state s    r   pre
holds  

instantiated operator transforms state s  state s   we write  s     s   
applicable s  s     s  n delo     addo   problem description p   hsi   sg
consists initial state si together final state sg   problem solving task
find sequence instantiated operators  a plan     o           ol   transforms
ol
o 
initial state final state  si   
  
sg    case c   hp  oi problem
description p together plan solves p 
introduced strips oriented formalism defining problem solving domain
similar form expressiveness representations typically used general problem
solving planning  state described finite set ground atoms
functions used  full horn logic available describe static rules  restriction horn clauses advantage powerful allowing ecient proof
construction using well known sld refutation procedures  lloyd         compared
prodigy description language  pdl   minton        blythe et al         language provide explicit quantification specific syntactic construct  similar
expressiveness reached implicit quantification horn clauses  moreover 
language provide kind type specification constants variables
pdl think major disadvantage  besides points language
quite similar pdl 

   formal model case abstraction
section present new formal model case abstraction provides theory
changing representation language case concrete abstract  already
stated assume addition concrete language abstract language supplied
domain expert  following introduced formalism  assume concrete level
problem solving defined concrete problem solving domain dc   hlc   ec  oc   rci
abstract level  case based  problem solving represented abstract problem solving domain da   hla   ea  oa  rai  reasons simplicity  assume
domains share symbols    condition always achieved renaming symbols  remainder paper states operators concrete
domain denoted sc oc respectively  states operators abstract
domain denoted sa oa respectively  problem case abstraction
described transforming case concrete domain dc case abstract
domain da  see figure     transformation formally decomposed two
independent mappings  state abstraction mapping ff  sequence abstraction mapping
 bergmann      c   state abstraction mapping transforms selection concrete
state descriptions occur solution problem abstract state descriptions 
   following  simply omit parameters operators instantiated operators case
unambiguous relevant 
   otherwise  symbol  or sentence  could become ambiguous would problem applying
generic abstraction theory  would unclear whether generic abstraction rule refers concrete
abstract sentence

  

fibergmann   wilke

abstract
domain 

da


o 



s 

 a


concrete
domain 

dc

c 


o 


oj

ja


oc 

       

c 

oc 

c

s 

oc 

c

s 
       


j  


om

oci  

ocn


oc 

oci

ci
 j   



cn
 m    n

figure    general idea abstraction
sequence abstraction mapping specifies concrete states mapped
skipped 

    state abstraction

state abstraction mapping translates states concrete world abstract world 
definition    state abstraction mapping  state abstraction mapping   sc   sa
mapping sc   set states concrete domain  sa  set states
abstract domain  particular  must effective total function 
general definition state abstraction mapping impose restrictions
kind abstraction besides fact mapping must total many toone function  however  restrict set possible state abstractions set
abstractions user considers useful  assume additional domain knowledge
abstract state relates concrete state provided  knowledge
must expressed terms domain specific generic abstraction theory  giordana 
roverso    saitta        

definition    generic abstraction theory  generic abstraction theory set horn
clauses form ea a            ak   rules ea abstract essential sentence 
i e   ea   ea ea   ea substitution   body generic abstraction rule
consists set sentences concrete abstract language  i e   ai atoms
lc   la  
based generic abstraction theory  restrict set possible state abstraction
mappings deductively justified generic abstraction theory 

definition    deductively justified state abstraction mapping  state abstraction mapping deductively justified generic abstraction theory a  following conditions
hold sc   sc  
  ff sc   sc   rc    
  ff sc   s c s c   rc     holds    ff  sc   fulfilled 
  

fibuilding refining abstract planning cases

definition first condition assures every abstract sentence reached
mapping justified abstraction theory  additionally  second requirement
guarantees abstract sentence used describe abstraction one state 
must used describe abstraction states  abstract sentence
derived generic abstraction theory  please note deductively justified state
abstraction mapping completely induced set ea respect generic
abstraction theory follows  ff sc      f   jsc   rc     g  unless otherwise stated
always assume deductively justified state abstraction mappings  summarize 
state abstraction mapping transforms concrete state description abstract state
description thereby changes representation state concrete abstract 
please note deductively justified state abstraction mappings need defined
user  determined automatically learning algorithm
presented section   

    sequence abstraction

solution problem consists sequence operators corresponding sequence
states  relate abstract solution concrete solution  relationship
abstract states  or operators  concrete states  or operators  must captured 
abstract state must corresponding concrete state every concrete state
must associated abstract state  due fact abstraction always
reduction level detail  michalski   kodratoff         situation  reduction
number states  selection concrete states corresponding
abstraction  sequence abstraction mapping defined follows 

definition    sequence abstraction mapping  sequence abstraction mapping   n   n

relates abstract state sequence  sa            sam   concrete state sequence  sc           scn  
mapping indices j   f           mg abstract states saj indices   f           ng
concrete states sci   following properties hold 

fi        fi m    n  initial state goal state abstract sequence

must correspond initial goal state respective concrete state sequence 

fi u    fi v  u   v  order states defined concrete
state sequence must maintained abstract state sequence 

note defined sequence abstraction mapping formally maps indices abstract
domain concrete domain  abstraction mapping better map indices
concrete domain indices abstract domain  inverse mapping
   does  however  mapping inconvenient handle formally since
range definition    must always considered  therefore stick presented
definition 

    case abstraction

based two abstraction functions introduced  intuition case abstraction
captured following definition 
  

fibergmann   wilke

hierarchies abstraction spaces
dl
different kinds abstractions
d 

da
da 
dc

da

d 

da 
d 

d 

dc

figure    different kinds abstractions  a  abstraction hierarchies  b 

definition    case abstraction  case ca   hhsa    sami   oa           oam i abstraction
case cc   hhsc   scn i   oc           ocn i respect domain descriptions  dc   da 
oaj
oci c
sci     
si   f           ng saj     
sj j   f           mg
exists state abstraction mapping sequence abstraction mapping   that 
saj   ff scfi j   holds j   f           mg 

definition case abstraction demonstrated figure    concrete space shows
sequence n operations together resulting state sequence  selected states
mapped states abstract space  mapping maps indices
abstract states back corresponding concrete states 

    generality case abstraction methodology

following  brie discuss generality presented case abstraction methodology  see hierarchies abstraction spaces well different kinds abstractions represented simultaneously using presented methodology 
      different kinds abstractions

general  one possible abstraction object world 
abstraction performed many different ways  example two different abstractions case already shown example figure    example 
two different abstractions  see abstract cases ca  ca   derived
concrete case  abstraction methodology able cope different abstractions
case specified user  assume given one concrete domain dc
two different abstract domains da  da    represents two different kinds
abstraction  furthermore  assume abstract domains share
symbols     always define single abstract domain da joining individual
abstract domains includes kinds abstractions  see figure    a   
property formally captured following simple lemma 
    abstract domains disjoint  symbols simply renamed achieve property 

  

fibuilding refining abstract planning cases

lemma    joining different abstractions  concrete domain dc two disjoint abstract domains da  da  given  joint abstract domain da   da    da 
defined follows  let da     la   ea   oa   ra   let da     la   ea   oa   ra   
da   da    da     la    la    ea    ea    oa    oa    ra    ra    joint abstract domain
da fulfills following property  ca abstraction cc respect  dc  da  
respect  dc   da    ca abstraction cc respect  dc   da  
      hierarchy abstraction spaces

work hierarchical problem solving assume multi level hierarchy abstraction
spaces problem solving  e g   sacerdoti        knoblock         even presented
approach contains two domain descriptions  hierarchy abstract domains simply
mapped onto presented two level model shown figure    b   assume
hierarchy disjoint domain descriptions  d           dl  given  particular  domain
d   assumed abstract domain   multi level hierarchy
abstraction spaces  case c abstraction level abstraction case c  
exists sequence cases  c            c      ci domain di ci  
abstraction ci respect  di   di      f              g  multilevel hierarchy domain descriptions always reduced two level description 
abstract domain two level description contains union levels
multi level hierarchy  property formally captured following lemma 

lemma    multi level hierarchy  let  d           dl  arbitrary multi level
hierarchy

l
domain descriptions  two level description  dc   da   da     
dc   d  holds that  ca abstraction cc respect  d           dl  ca
abstraction cc respect  dc   da   
since shown different kinds abstractions well hierarchies abstraction spaces directly represented within two level case abstraction methodology 
restrict exactly two levels 

   computing case abstractions

present pabs algorithm  bergmann      c  wilke        automatically
learning set abstract cases given concrete case  thereby  assume
concrete domain dc abstract domain da given together generic abstraction
theory a  use functional notation ca   pabs hdc   da  ai  cc  denote ca
element set abstract cases returned pabs algorithm 
algorithm consists four separate phases introduced section   
following present phases detail 
first three phases  require procedure determining whether conjunctive
formula consequence set horn clauses  purpose  use sld refutation
procedure  lloyd        given set horn clauses  a logic program  c together
conjunctive formula g  a goal clause   refutation procedure determines set
answer substitutions
c   g holds  
  write
  sld c  g  
sld refutation procedure performs kind backward chaining works
  

fibergmann   wilke

follows  selects literal goal clause g  i e   left literal  searches
horn clause logic program c contains literal head unifies
selected goal literal  selected literal removed g body  if empty 
applied clause added beginning goal clause  general
unifier goal literal head clause applied whole new goal clause 
resulting goal clause called resolvent  process continues goal clause
becomes empty resolvents built  former case  goal
proven answer substitution computed composing substitutions used
resolution  backtracking used look possible selections applicable
horn rules determine alternative answer substitutions  set answer substitutions
returned set
  whole space possible applications available horn rules
searched unsuccessfully  goal clause consequence logic program
c sld refutation procedure terminates without answer substitution  
     
must confused situation empty substitution returned
 
  f g   variables occur g  phase iii pabs algorithm  require
derivation trees addition answer substitutions  write   sld c  g 
assume set pairs       answer substitution
derivation c   g  
order assure termination sld refutation procedure require
abstract domain generic abstraction theory designed according
following principles    
concrete state sc   sc concrete operator oc   oc oc
described hpreoc   addoc   deloc i  sld sc   rc   preoc   must lead finite set
ground substitutions variables occur preoc  
state abstract sa   sa abstract operator oa   oa oa
described hpreoa   addoa   deloa i  sld sa   ra  preoa   must lead finite set
ground substitutions variables occur preoa  
state sc   sc abstract essential sentence e   ea  sld sc  rc  a  e  
must lead finite set ground substitutions variables occur e  
following four phases pabs algorithm explained detail 

    phase i  computing concrete state sequence

input case abstraction algorithm  assume concrete case cc  
hhsci   scgi   oc           ocn i  note  oc           ocn  totally ordered sequence instantiated operators similar plans prodigy  minton        minton et al         veloso
  carbonell         first phase  state sequence results simulation
problem solution computed follows 

    first glance  restrictions seem bit hard achieve take closer look see
standard requirement  terminating  logic program  i e   prolog program  

  

fibuilding refining abstract planning cases

algorithm    phase i  computing concrete state sequence 
sc     sci
     n
sld sci     rc  preoci       stop  failure  operator applicable 
sci     sci   n deloci     addoci

end
scg   scn stop  failure  goal state reached 

oc


algorithm  states sci computed  sci     
sci holds
  f           ng  failure occurs given plan valid  i e   solve given
problem 

    phase ii  deriving abstract essential sentences

using derived concrete state sequence input  following algorithm computes
sequence abstract state descriptions  sai   applying generic abstraction theory
separately concrete state 

algorithm    phase ii  state abstraction 
     n
sai     
e   ea

   sld sci   rc   a  e  
 

sai    sai   fe g
end
end
end
please note claimed domain theories designed way

finite contains ground substitution variables e   therefore  every
description sai consists ground atoms consequently valid abstract state
description  within introduced model case abstraction computed
superset outcome possible state abstraction mappings  deductively justified
state abstraction mapping restricted ff sci   sai   fe   sa jsci   rc     eg
  f           ng  consequently  determined abstract sentences abstract
case might require 

    phase iii  computing possible abstract state transitions

next phase algorithm  search instantiated abstract operators
transform abstract state s ai sai subsequent abstract state s aj saj  i   j   
therefore  preconditions instantiated operator must least fulfilled
state s ai consequently sai   furthermore  added effects operator must
true s aj consequently saj  
  

fibergmann   wilke

algorithm    phase iii  abstract state transitions 
g     
     n    
j        n
o x           xu    oa
let hpreo   delo  addoi description o x           xu 
   sld sai   ra   preo 
h   
letadd o   faja   addog
   compute possible instantiations   
   added sentences hold saj   
   f g
   set possible substitutions   
   initially empty substitution    

  add o
      
 
e   saj
substitution   e          fg
end
end
    

end

   now  contains set possible substitutions   
   added sentences contained saj   

 
g    g   fhi  j  o x           xu    ig
end
end
end
end
end

set possible operator transitions collected directed edges graph
vertices represent abstract states  algorithm  set g edges acyclic
directed graph constructed  pair states  sai saj     j checked
whether exists operator o x           xu   applicable sai   purpose 
sld refutation procedure computes set possible answer substitutions
precondition operator fulfilled sai   derivation belongs
answer substitution stored together operator graph since
required next phase case abstraction  derivation  and tree 
inner node ects resolution goal literal head clause
leaf node represents resolution fact  note proving precondition
abstract operator inner nodes tree always refer clauses horn rule set
ra  leave nodes represent facts stated ra essential sentences contained
  

fibuilding refining abstract planning cases

sai   answer substitution applied add list operator leading
partially instantiated add list add o  note still variables add o

operator may contain variables contained precondition may
occur add list  therefore  set possible substitutions incrementally
constructed   saj holds   add o  completely instantiated operator
derived thereby finally included directed edge  from j   graph g 
algorithm guaranteed  instantiated  operator leads sai
saj applicable sai essential sentences added operator contained
saj   furthermore  applied sld refutation procedure complete  it always finds
answer substitutions   every instantiated operator applicable sai
essential sentences added operator contained saj contained
oai
graph  follows immediately ff scfi  i       
ff scfi i    holds arbitrary
deductively justified state abstraction mapping sequence abstraction mapping  
hfi  i        i   oai    g holds 

    phase iv  determining sound paths

based state abstractions sai derived phase ii graph g computed
previous phase  phase iv selects set sound paths initial abstract state
final abstract state  set significant abstract sentences sequence abstraction
mapping determined construction path 
algorithm    phase iv  searching sound paths   
paths    fh        fi        ig
exists h oa           oak   ff  fii   paths fi k    n
paths    paths n h oa            oak    ff  fii
hi  j  oa    g   fi k 
let e set essential sentences contained derivation
let ff    e   addoa  
  f    a      kg holds 

 safi         ff      
 sfi       ff   

 sa   ff   
 safi  k    ff      
j
paths    paths   fh oa            oak  oa   ff     ffi k        j gi g

end
end

casesabs     
h oa            oak   ff  fii   paths fi k    n
casesabs    casesabs   fhhsa      san   i   oa            oak ig

end
return casesabs

construction sequence abstraction mapping obvious  set represents image state abstraction mapping thereby determines set sentences

    please note h oa            oak    ff  matches fh        fi         ig k      operator n denotes
set difference 

  

fibergmann   wilke

reached order assure applicability constructed operator sequence  note state abstraction mapping directly determined
follows  ff sci     fe   jsci   rc     eg  idea algorithm start
empty path  path extended operator g iteration algorithm
path leads final state index n  new essential sentences ff  may
occur proof precondition added effects new operator  path
constructed far must still consistent according extension state description
and  addition  new operator must transform sentences correctly 
result  phase iv returns cases abstractions given concrete input
case respect concrete abstract domain definitions generic abstraction
theory  depending domain theory  single abstract case learned
single concrete case already shown figure   

    correctness completeness pabs algorithm

finally  want state strong connection formal model case
abstraction presented algorithm  algorithm terminates domain descriptions generic abstraction theory formulated required beginning
section  sld resolution procedure always terminates  algorithm correct 
every abstract case computed pabs algorithm case abstraction according
introduced model  sld refutation procedure applied pabs complete every
case abstraction according definition   returned pabs  property
captured following theorem 

theorem    correctness completeness pabs algorithm  complete sldrefutation procedure used pabs algorithm  case ca abstraction case cc
respect  dc   da  generic theory a  ca   pabs hdc   da  ai  cc  

    complexity algorithm

complexity algorithm mainly determined phases iii iv  worst
case complexity phase iii o n  c  c   n length concrete plan
c  c  dependent domain theories follows  c    joa j j
j c   
jaddoa j  jeajj
j jaddoaj  thereby  joaj represents number abstract operators  j
j
maximum number substitutions found sld refutation procedure  jaddoa j
maximum number added sentences abstract operator  jeaj number
abstract essential sentences  complexity phase iv determined o n   n   
c    assume constant domain theories overall complexity pabs algorithm
summarized o n   n       exponential factor comes possibly exponential
number paths directed acyclic graph n nodes every state connected
every successor state  whether graph kind appears much dependent
abstract domain theory  determines transitions abstract states
possible  exponential nature lead time complexity problem domains
used  additionally  want make clear computational effort must
spent learning problem solving  time required learning
long  learning phase executed off line 
  

fibuilding refining abstract planning cases

space complexity algorithm mainly determined phase iii
derivations proofs abstract operators  preconditions must stored 
sum n  c  c  derivations worst case  turn problem
domains used derivation short  in cases
  inferences static horn rules   reason derivations relate
abstract operators likely contain less preconditions concrete operators 

   refinement abstract cases

previous section described abstract cases automatically learned
concrete cases  assume case base contains set abstract cases 
want show abstract cases used solve problems concrete level 
furthermore  discuss impact specific form abstract problem solving
domain improvement problem solving achieved 

    applicability refinability abstract cases

given abstract case concrete problem description  question arises
situations abstract case refined solve concrete problem  kind
refinability a posterior definition easily given follows 

definition    refinability abstract case  abstract case ca refined solve
concrete problem p exists solution oc p  ca abstraction
hp  oci 

obviously  refinability property undecidable general since otherwise planning
would decidable  however  define applicability abstract case
decidable necessary property refinability follows 

definition     applicability abstract case  abstract case ca   hhsa    sami 
 oa            oam i applied solve concrete problem p   hsci   scg exists state
abstraction mapping sai   im ff    f           mg ff sci     sa 
ff scg     sam   thereby  im ff  denotes image state abstraction mapping ff  i e  

abstract states reached 

applicable abstract case  least guaranteed concrete initial goal
states map abstract ones concrete intermediate states exists
abstracted required abstract case 
even applicability necessary precondition refinability formally
guarantee refinability  since downward solution property  tenenberg         states
every abstract solution refined  strong requirement hold general
abstraction methodology  however  indeed guaranteed abstract case
contained case base already abstraction one previous concrete cases
due correctness pabs algorithm used learning  one problems
contained concrete cases solved guaranteed learned
abstract case refined solve problem  consequently  abstract case
case base least refined solve one problem occurred past 
  

fibergmann   wilke

abstract solutions useless never refined solve concrete
problem never case base consequently never tried solving problem 
therefore  expect abstract case case base high chance
refinable new similar problems applied 

    selecting applicable abstract case

decide whether abstract case applied solve concrete problem p  
determine suitable state abstraction mapping  assume deductively
justified state abstraction mappings 
required state abstraction mapping always




induced set   i   si shown section      consequently  ca applicable
problem p   hsci   scg sa    f   j sci   rc     g sam   f  
j scg  rc  a   g  since every abstract case use solving new problem
learned another concrete case  known abstract state sai must
least one concrete state  from previous concrete state  abstracted via
sai   consequently  sai   im ff  holds  together introduced restrictions
definition rc respect complete sld refutation procedure  see section
    applicability abstract case decidable  algorithm   describes selection
applicable abstract case problem p   hsci   scg detail 
algorithm    selection applicable abstract case 
sai    sag     

e   ea

   sld s
sci   rc   a  e  


si    si    
e
e   ea

   sld sscg   rc   a  e  
sag    sag    
e
repeat
repeat
select new case ca   hhsa    sam i   oa           oam i case base
sa  sai sam sag
cases available
refinedfid  sci          scg 
return result refinedfid
  sm      sai     sai   n deloai     addoai
   i   sai
 sai   ff    sa   sag   ff    sam
refinedfid  sci    sa           sam      ff  scg 
refinedfid returns success p 
return success p 

first  initial final concrete states problem abstracted using
generic abstraction theory  thereby  abstract problem description hsai   sag determined 
then  pre selection step  abstract case chosen form case base 
abstract sentences contained initial final abstract state case must
  

fibuilding refining abstract planning cases

contained abstracted problem description hsai   sag i  condition  however 
guarantee selected case applicable respect definition     set
abstract sentences inducing respective state abstraction mapping computed
applicability condition checked test whether selected case applicable 
selected case applicable  new case must retrieved  applicable abstract
case determined refinement algorithm refinedfid  see following section 
executed  algorithm uses sequence intermediate abstract states  sa            sam     
previously determined abstract plan case  guide search concrete
level  operators contained abstract plan used anymore  refinement
procedure returns success p   refinement succeeds solution plan p 
refinement fails  the procedure returns failure   another case selected  cases
available problem solved pure search without guidance abstract
plan 

    refining abstract plan
refinement selected abstract case starts concrete initial state
problem statement  search proceeds sequence concrete operations found
leads concrete state sc   sa    f   j sc   rc     g holds 
applicability condition abstract case guarantees state exists  sai   im ff  
guaranteed required concrete operator sequence exists too  therefore 
search task may fail causes whole refinement process fail also  first
abstract operator refined successfully new concrete state found  state
taken starting state refine next abstract operator manner 
refinement fails backtrack refinement previous operator try
find alternative refinement  whole refinement process reaches final abstract
operator must directly search operator sequence leads concrete goal
state scg   concrete goal state reached concatenation concrete partial
solutions leads complete solution original problem 
refinement demands search procedure allows abstract goal specification  kinds forward directed search depth first iterative deepening  korf 
    b  best first search  korf        procedures used purpose
states explicitly constructed search  states tested see
abstracted towards desired goal  paris use depth first iterative deepening
search described algorithm    algorithm consists two recursive procedures 
top level procedure refinedfid receives concrete initial state sci   concrete final state
scg   sequence intermediate abstract states    sa            sak  derived abstract
case  well set induces state abstraction mapping  procedure
increments maximum depth depth first search procedure searchbounded
maximum deepmax  procedure searchbounded performs actual search  goal
search either abstract state  i e   first abstract state   concrete
goal state scg abstract state already visited  procedure performs
depth first search applying available concrete operators recursively calling
search procedure concrete state scnew results operator application 
  

fibergmann   wilke

abstract goal state reached removed list refinement
continues next abstract state first one list 
algorithm    refinement depth first iterative deepening  dfid  search 
procedure refinedfid  sci   a  ff  scg 
deep     

repeat

searchbounded  sci   a  ff  scg  deep 
searchbounded returns success p  return success p 
deep    deep        search unsuccessful  increment search deepness   
deep   deepmax

return failure

procedure searchbounded  sci   a  ff  scg  deep 
        abstract goals  test concrete final goal   
sci   scg return success    
   sa           sak     least one abstract goal   
e   sa  holds  sld sci   rc   a  e      
e   n sa  holds  sld sci   rc   a  e     
   abstract state reached  refine next abstract operator   
refinedfid  sci    sa            sak    ff  scg 
refinedfid returns success p  return success p 
deep     return failure    maximum depth reached   
   apply operators  create successor states   

oc   oc

  sld sci   rc  preoc     
set possible operator instantiations   
 

scnew     sci n  deloc       addoc      create successor state   
searchbounded  scnew   a  ff  scg   deep         continue search new state   
searchbounded returns success p  return success  oc  p  
return failure
please note kind refinement different standard notion refinement hierarchical problem solving  knoblock et al       b  
strong correspondence abstract operator possible concrete operator 
moreover  justification structure refined abstract plan completely different
justification structure abstract plan completely independent
definition abstract concrete operators  even disadvantage compared
usual refinement procedure used hierarchical problem solving  main computational
advantage abstraction caused decomposition original problem smaller
subproblems maintained 

    alternative search procedures refinement

besides forward directed search procedure currently used paris backward directed
search used means end analysis  fikes   nilsson        nonlinear partial ordered
  

fibuilding refining abstract planning cases

planning  mcallester   rosenblitt        applied refinement certain
circumstances  therefore  would either require state concretion function
turn rules generic abstraction theory virtual concrete operators 
state concretion function must able determine single state finite set
concrete states given abstract state together concrete problem description 
thereby  concrete problem description may help reduce number possible concrete states  derived state concretions used concrete goal states
backward directed search may start 
alternatively  turn process state concretion directly search procedure representing rule generic abstraction theory virtual abstract
operator  precondition rule generic abstraction theory becomes precondition virtual operator conclusion rule becomes positive effect
operator  using virtual concrete operators together operators
concrete domain  backward directed planner use abstract state directly
goal search  part plan resulting solution consists concrete operators  and virtual operators  taken refinement abstract
operator 

    criteria developing abstract problem solving domain
abstract problem solving domain generic abstraction theory used important impact improvement problem solving achieved  therefore 
desirable set criteria state  good  abstract domain definition look  strong criteria allowing quantitative predictions resulting speedups
hardly developed  hierarchical planners criteria don t exist either 
however  give set factors determine success approach 
overall problem solving time uenced mainly following four factors  independent refinability abstract operators  goal distance abstract operators  concrete scope
applicability abstract operators  complexity generic abstraction theory 
      independent refinability abstract operators

following korf s analysis hierarchical problem solving  korf        introduced
   plan refinement approach reduces overall search space bn
psection
b fi  i  fi  i      thereby  b average branching factor  n length coni  
crete solution  sequence abstraction mapping used abstraction
concrete case abstract case  already mentioned  cannot guarantee
abstract plan applicable problem really refined  furthermore  korf s
analysis assumes backtracking refinement individual abstract
operators required cannot guaranteed  computational advantage
abstraction lost either two cases 
however  abstract operators occurring abstract problem solving domain
fulfill strong requirement independent refinability  guaranteed every
applicable abstract case refined without backtracking  abstract operator oa
independently refinable sc   s c   sc every state abstraction mapping
  

fibergmann   wilke


ff sc     
ff  sc   holds 
exists sequence concrete operators  oc           ock  
c
c
ok c
o 
sc   
        
s  holds 


problem requirement seems much hard develop abstract
problem solving domain operators fulfill requirement  although cannot
expect operators abstract problem solving domain independently refinable 
knowledge engineer developing abstract domain still try define abstract
operators independently refined situations  i e   sc   s c   sc
state abstraction mapping applicable abstract operator refined
concrete operator sequence  although notion mostly independent refinability
formal feel practically useful developing abstract domain definition 
abstract operators refined independently many situations 
higher chance abstract plan composed operators refinable 
      goal distance abstract operators

goal distance  cf  subgoal distance  korf        maximum length sequence
concrete operators required refine particular abstract operator  longer goal
distance larger search space required refine abstract operator  particular 
complexity search required refine complete abstract plan determined
largest goal distance abstract operators occur abstract plan 
hence good reason keep goal distance short  however  goal distance
negatively interacts next factor  namely concrete scope applicability
abstract operators 
      concrete scope applicability abstract operators

concrete scope applicability abstract operator specifies many concrete
states abstracted abstract state abstract operator applicable 
many concrete states abstracted abstract state reached
abstract operator  scope determined definition abstract operator
generic abstraction theory responsible specifying admissible state
abstractions  concrete scope applicability abstract operators determines
applicability abstract plans learned  abstract plan applicable concrete problems limited use domains problems
solved vary much  hence  concrete scope applicability abstract operators large possible  unfortunately  according experience  abstract
operators large scope usually larger goal distance operators
short goal distance don t large scope applicability  therefore  compromise
two contradicting issues must found 
      complexity generic abstraction theory

fourth factor uences problem solving time complexity generic
abstraction theory  theory must applied time new concrete state created
concrete level search  complex generic abstraction theory 
time required compute state abstractions  hence  generic abstraction theory
  

fibuilding refining abstract planning cases

require complicated inferences avoid backtracking within sld refutation
procedure 
although four factors don t allow precise prediction expected problem
solving behavior resulting system  provide focus consider
designing abstract problem solving domain related generic abstraction theory 

   example domain  process planning mechanical engineering
paris approach successfully tested toy domains familiar
towers hanoi  simon         domains  hierarchical problem solvers use
dropping sentence approach proven useful  knoblock        
section presents new example domain selected field process planning mechanical engineering really requires stronger abstraction
approach    selected goal generating process plan production
rotary symmetric workpiece lathe  problem description  may derived
cad drawing  contains complete specification  especially geometry 
desired workpiece  goal state  together specification piece raw material
 called mold  produced  initial state  
left side figure   shows example rotary symmetric workpiece
manufactured cylindrical mold    rotary parts manufactured putting
mold fixture  chuck  lathe  chucking fixture  together attached
mold  rotated longitudinal axis mold rotation center 
mold rotated cutting tool moves along contour thereby removes certain parts
mold desired goal workpiece produced  within process
hard determine sequence specific parts workpiece
removed cutting tools used  workpiece chucked certain area
workpiece covered chucking tool cannot processed cutting tool 
moreover  workpiece chucked area used chucking plain 
otherwise fixation would suciently stable  hence  many workpieces usually
processed first chucking workpiece one side processing accessible area 
workpiece chucked opposite side area previously covered
processed  processing example workpiece shown figure   requires
workpiece first chucked left side right side processed  processed
right side used chuck workpiece area plain allows stable
fixing  hence  left side workpiece including small groove processed 
explain representation domain detail  complete definition
domain found online appendix    several simplifications real
domain required order obtain domain definition could eciently handled
large set experiments  one restriction represent workpieces
right angled contour elements  example  conical contour cannot represented 
many different cutting chucking tools available real life process planning 
    domain adapted caplan system  paulokat   wess         developed university kaiserslautern 
    note figure shows   dimensional drawing   dimensional workpiece  measure   in 
equals      mm 

  

fibergmann   wilke

example workpiece

grid representation example workpiece

  mm
   mm


   mm

    mm

raw
material
workpiece

   mm

 
 
 
 

  mm

 

 mm

     
     
   

 

 

x

  mm
  mm

figure    example workpieces grid representation
restricted single chucking tool three different cutting tools 
specification tools simplified  example  rotation
speed workpiece feed cutting tool parameters play
role processing workpiece  impact parameters neglected 
despite simplifications remaining part real world domain trivial
represents substantial subset critical problems domain 

    concrete domain
explain concrete problem solving domain giving detailed description
states operators 
      state description

representation domain concrete level  exact geometry
workpiece must represented state  including specific measures detail
contour  however  complete workpiece always divided atomic areas
always processed whole  therefore state representation organized
using grid divides entire workpiece several disjoint rectangular areas
different sizes  see right side figure     together grid coordinate specific
position size corresponding rectangular area represented  grid used
static part state description change planning  however
different problems require different grids  specific shape workpiece planning
represented specifying status grid rectangle  table   predicates
used represent workpiece described detail 
besides description workpiece  state representation contains information workpiece chucked kind cutting tool currently used 
table   describes predicates used purpose 
  

fibuilding refining abstract planning cases

predicate description
xpos max predicates xpos max xgrid   ypos max ygrid   specify size
ypos max grid direction x coordinate y coordinate respectively 
state consists exactly one instance predicates  e g  
xpos max    ypos max    example shown figure   
grid xpos
grid ypos

predicates grid xpos xgrid   xstart  xsize   grid ypos ygrid   ystart  ysize  
specify geometrical position size grid areas direction
x coordinate y coordinate respectively  first argument
predicates specifies coordinate grid areas  second argument
declares geometrical starting position  third argument specifies
size grid areas  state consists exactly one instance
predicates different x coordinate y coordinate 
example above  grid xpos          grid xpos          grid xpos           
grid xpos           specify grid x direction grid ypos                
grid ypos         specify grid y direction 

mat

predicate mat xgrid   ygrid  status  describes status particular
grid area specified coordinates  xgrid   ygrid   argument status
instantiated one three constants raw  workpiece  none 
constant raw indicates specified area still consists raw material must removed cutting operators  constant
workpiece specifies area consists material belongs
goal workpiece  constant none specifies area contain
material  i e   material present mold material
already removed previous cutting operations  one instance
mat predicate required grid area specify current state 
previously mentioned predicates change execution plan  mat predicate changed cutting operator 
particular  initial state goal state problem differs status assigned grid areas must become removed  example 
initial state example shown above  sentence mat     raw 
present final state contains sentence mat     none  
table    essential sentences representation workpiece

      operators

process plan manufacture certain workpiece consists sequence operators 
total order operators problem domain manufacturing
steps executed sequentially lathe    chosen four different operators
    however  new brands lathe machine allow parallel processing 

  

fibergmann   wilke

predicate
chuck pos

description
predicate chuck pos side  describes whether workpiece currently
chucked either side  parameter side instantiated one
three constants none  right  left  constant none specifies
workpiece chucked constants right left specify
workpiece chucked respective side  state contains
exactly one instance predicate 

covered

predicate covered xmin   xmax  specifies areas workpiece
currently covered chucking tool  predicate declares
areas x coordinate lying within interval  xmin   xmax 
covered  covered areas cannot processed cutting tool  state
consist exactly one instance predicate workpiece chucked 

cut tool
predicates cut tool id  cut direction dir  specify unique identicut direction fication  id  cutting tool currently used area
processed direction  dir  cutting tool moves  parameter id symbol specifies legal cutting tool described
predicates included static rules rc concrete domain description  parameter dir instantiated one three constants
left  right center  value left specifies cutting tool moves
left right  right specifies cutting tool moves right
left  center specifies cutting tool move outside towards
center workpiece 

table    essential sentences representation chucking cutting tools
represent chucking workpiece  selection cutting tool  cutting
process itself  operators described table   
manufacturing workpiece shown figure   requires    step plan shown
figure     first  workpiece chucked left side  cutting tool selected
allows cutting right left  tool indicated grid areas removed 
please note left side workpiece cannot processed since covered
chucking tool   see right side figure      workpiece unchucked
chucked right side  tool allows processing left right  upper
part mold removed  finally  specific tool used manufacture small groove 

    abstract domain

example see small groove considered detail
processed basic contour workpiece established  important
characteristic example right part workpiece processed
left side workpiece  sequence crucial success plan  groove
  

fibuilding refining abstract planning cases

operator
chuck

description
operator chuck side  specifies workpiece chucked
specified side  side parameter instantiated constants
left right  chucking allowed workpiece chucked already surface used chucking plain  effect chucking
operation  respective instances predicate chuck pos covered
included state description 

unchuck

operator unchuck specifies chucking workpiece removed  operation executed workpiece chucked already  effect operation  parameter predicate chuck pos
changed none predicate covered deleted 

use tool

operator use tool dir  id  specifies tool selected subsequent cutting operators direction cutting tool moves 
workpiece must chucked tool chosen  effect
operator respective instantiations predicates cut tool
cut direction added state  parameters use tool
operator definition respective predicates 

cut

operator cut xgrid   ygrid  specifies raw material grid
area indicated coordinates  xgrid  ygrid   removed  effect
operator predicate mat specifies status
particular area changed status raw status none  however 
apply operator several preconditions must fulfilled  workpiece
must chucked chucking tool must cover specified area
area must accessible cutting tool  moreover  cutting
tool allows processing selected area must already
selected  cutting tool imposes certain constraints geometrical
size area processed it  details  see full
description domain online appendix   
table    concrete operators

would processed first workpiece could never chucked left side
processing right side would consequently impossible  domain experts told us
situation specific example shown  general importance
many cases  fact allows us select parts problem description solution
considered details abstract  parts  essential 
must maintained abstract case  found abstract
detailed shape workpiece long distinguish processing left
right side workpiece  furthermore  important distinguish
rough contour workpiece small details grooves  developed
  

fibergmann   wilke

   chuck left 

      unchuck  chuck right 

      use tool right  t    cut          cut     

       use tool left t   cut         cut     
        use tool center t    cut       unchuck

figure     plan manufacturing workpiece
abstract domain definition containing new language describing states operators
based abstraction idea 
      state description

introduce new abstract grid divides workpiece left  middle 
right area abstract specific location concrete grid area  areas
called complex processing areas  area assigned particular status  furthermore 
abstract state contains information whether complex processing area contains
small contour elements  such grooves   grooves exactly look like 
abstract detailed conditions chucking workpiece  abstract state
contains approximation conditions  stating workpiece cannot chucked
particular side  side contains small contour elements already
processed  predicates used represent abstract state described detail
table   
      operators

consider abstract operator completely processes one complex area
workpiece  operator processes complex area roughly  operator
processes small grooves complex area  consider abstract chucking
operator chucking strong impact overall plan  table   shows
available abstract operators 

    generic abstraction theory
generic abstraction theory defines sentences used describe abstract state  see
table    terms sentences concrete state  see tables      set
horn rules  definition abstract sentence explained detail table   
  

fibuilding refining abstract planning cases

predicate
abs area state

description
predicate abs area state area  status  describes status
three complex processing areas  argument area
specifies one complex processing areas left  middle  right 
argument status describes status respective area 
status either todo  rough  ready  status todo
specifies area needs processing large contour elements  rough area small contour elements
grooves need processed  status ready specifies
area completed  abstract initial state usually contains
one complex processing areas status todo 
abstract goal state complex processing areas status
ready 

abs small parts

predicate abs small parts area  specifies complex processing area  area  contains small contour elements need
manufactured 

abs chuck pos

predicate abs chuck pos side  describes whether workpiece
currently chucked either side  parameter side
instantiated one three constants none  right  left 
predicate exactly meaning chuck pos predicate
concrete level  predicate abstracted
renamed 

abs chuckable wp

predicate abs chuckable wp side  describes whether workpiece chucked left right side side
completely processed 

table    essential sentences describing abstract state
strongly considered factors uence quality domain  see section      development abstract problem solving domain generic
abstraction theory  although none defined abstract operators independently refinable  mostly independently refinable  preconditions abstract
operator still contains approximations conditions must fulfilled order assure concrete operator sequence exist refines abstract operator  example 
predicate abs chuckable wp side  approximation detailed condition  a plain
surface  required chucking  goal distance operator quite different
strongly depends problem solved  goal distance set fixation
operators two  possibly one unchuck operator followed chuck operator 
goal distances abstract operators different  example  goal distance process ready operator depends number concrete grid areas belonging
  

fibergmann   wilke

operator
set fixation

description
operator set fixation side  specifies workpiece chucked
specified side  side parameter instantiated
constants left  right none  constant none specifies
chucking removed  compared concrete operator chuck
preconditions chucking side simplified  effect
operator predicate abs chuck pos modified 

process rough

operator process rough area  specifies complex processing
area  area  processed completely small contour elements  parameter area either left  middle  right 
precondition operator requires workpiece chucked
different side area  effect operator predicate abs area state modified 

process fine

operator process fine area  specifies small contour elements
complex processing area  area  processed  parameter area either left  middle  right  precondition
operator requires large contour elements side
workpiece already processed workpiece chucked
different side  effect operator predicate
abs area state modified 

process ready

operator process ready area  specifies indicated complex
area workpiece completely processed  including large
small contour elements  effect operator predicate
abs area state modified 
table    abstract operators

respective abstract area containing material needs removed 
goal distance number gird areas  say c  plus number required use tool
operations  less equal c   hence  goal distance c  c 
goal distance become long complex problems  two operators
process rough process fine introduced  cover processing small
large grid areas respectively consequently smaller goal distance
process ready operator  goal distance two operators smaller
smaller concrete scope applicability process ready operator  example
process ready operator applied state arbitrary areas need
processed  process fine applied states large grid areas
already processed 
although developed simplified version whole domain production planning mechanical engineering rotary symmetrical workpieces feel
  

fibuilding refining abstract planning cases

abstract predicate description terms predicates concrete domain
abs area state
predicate abs area state area  status  describes status
three complex processing areas  left processing area
consists areas concrete grid covered 
workpiece chucked left side  similarly  right processing
area consists concrete grid areas covered
workpiece chucked right side  middle processing area
consists areas never covered chucking
tool  status complex processing area todo  exists
concrete large grid area belongs complex processing
area needs processed  grid area considered
large size direction x coordinate larger  
mm  status complex processing area rough  large
grid areas complex processing area already processed
exists concrete small grid area belongs
complex processing area needs processed  gird
area considered small size direction x coordinate
smaller equal   mm  status complex processing
area ready concrete grid areas belong complex
processing area processed 
abs small parts

sentence abs small parts area  holds exists small concrete grid area  size smaller equal   mm  belongs
complex processing area needs processed 

abs chuck pos

sentence abs chuck pos side  holds concrete
sentence chuck pos side  holds 

abs chuckable wp

predicate abs chuckable wp side  describes whether workpiece still chucked left right side side
completely processed  sentence holds part desired
workpiece belongs respective side completely plain 
is  concrete grid areas status workpiece range
y coordinate 
table    generic abstraction theory

domain expert together knowledge engineer able define abstract
domain representation generic abstraction theory complete domain  particular  model based interactive knowledge acquisition tools mikado  schmidt       
schmidt   zickwolff        make complete modeling task much feasible 
  

fibergmann   wilke

case c 
initial state

goal state

solution
   chuck left 
  
chuck right 
    use tool center  t  
   use tool right t     
use tool left t       cut     
      cut           cut              cut           cut          unchuck
   unchuck

problem
abstraction

  

      

      

       

i 

ii 

iii 

iv 

        

   
problem
abstraction

abstraction
v 

vi 

abstract case ca
abstract initial state
abs area state left  todo 
abs area state right todo 
abs small parts left 
abs chuckable wp right 

problem
abstraction

abstract solution
i  set fixation left 
ii  process ready right 
iii  set fixation right 

abstract goal state

iv  process rough left 
v  process fine left 
vi  set fixation none 

i 

ii 

iii 

  

      

      

iv 

v 

vi 

        

   

abs area state left  ready 
abs area state right ready 
abs chuckable wp right 

refinement
       

new case c 

initial state

solution solution
   chuck left 
   use tool right t  
   cut     
   unchuck

problem
abstraction

goal state

  
chuck right  
    use tool center  t  
  
use tool left t        cut     
       cut          cut           cut     
    unchuck

figure     abstracting refining example case

    abstracting refining process planning case

explain example case shown figure   abstracted
abstract case reused solve different planning problem  process
demonstrated figure     top figure shows concrete planning case c 
already presented figure    case abstracted pabs algorithm presented
section    algorithm returns   different abstract cases    one abstract cases
shown center figure  abstract solution plan consists sequence  
abstract operators  sequence operators plan indicated roman
numerals  particular abstraction indicated concrete abstract case
denotes sequence concrete operators turned abstract operator 
      abstract cases differ shown abstract case two aspects  shown abstract
solution additional abstract step set fixation none  inserted steps ii iii 
abstract step v replaced abstract step process ready  abstract steps iv v
together replaced abstract step process ready 

  

fibuilding refining abstract planning cases

learned abstract case used solve new problem c  whose initial
final concrete states shown bottom figure  even concrete workpiece
looks quite different workpiece case c  abstract case used solve
problem  reason new workpiece requires left
right side must processed  particular right side must processed
left side processed left side contains two small grooves prevent
workpiece chucked side processed  however  see
abstract operators  in particular operators ii  vi  v  refined completely
different sequences concrete operators abstracted 
already mentioned  abstract operators used independently refinable
mostly independently refinable  consequently  happen applicable abstract case cannot refined  figure    shows example concrete planning problem
abstract case shown figure    applicable refinable  reason
location small abstract part left side workpiece  small
part consists concrete grid area       raw material must removed  however  specific situation  small part must removed large parts 
left side workpiece contains  the grid areas                       removed 
reason without removing small part  larger parts located right
small part cannot accessed cutting tool able cut areas      
       consequently problem solved plan shown right
side figure     unfortunately  plan refinement abstract plan shown
figure     abstract plans requires large parts must removed
small parts removed  hence  refinement operator process rough left  fails 
situation problem solver must select different abstract plan 

   empirical evaluation results
section presents results empirical study paris mechanical engineering domain already introduced  evaluation performed fully implemented
paris system using abstraction abilities system  generalization component switched off purpose  designed experiments allow us
judge performance improvements caused various abstract cases derived pabs 
furthermore  analyzed average speed up behavior system respect
large set randomly selected training test cases 

    planning cases
empirical evaluation     concrete cases randomly generated  case
requires         sentences describe initial final state 
instances mat predicate  length solution plans ranges     
operators  even generated cases represent simple problems compared
problems real domain expert needs solve  search space required solve sample
problems already quite large  due fact branching factor b
         depending complexity problem  hence     step solution
complete search space consists          states 
  

fibergmann   wilke

solution

new problem


  mm
 
 

 mm

 

workpiece

  mm

   chuck left 
   use tool right t  
   cut     
   cut     
   unchuck
   chuck right 
   use tool left t  
   cut     
   cut     
    cut     
    use tool center  t  
    cut     
    unchuck

   mm
abs small parts left 
   

 

 

x

figure     example case refinement abstract plan shown figure
   fails 

case generation procedure leads solutions optimal nearly optimal 
solutions require less    steps optimal solutions sense
known shortest solution problem solve  solutions longer
   steps manually checked see whether contain steps
obviously redundant  redundant steps removed  although solutions
necessarily shortest solutions  nevertheless acceptably short 

    evaluating abstraction dropping sentences
first used recent version alpine  knoblock        together prodigy   blythe et al         check whether abstraction dropping sentences improve
problem solving domain represented described section    therefore  used
concrete problem solving domain domain theory prodigy  unfortunately 
representation  alpine able generate ordered monotonic abstraction
hierarchy  reason alpine distinguish different groups
literals different literal names  and argument types  used
problem space  example  alpine cannot distinguish different sentences
described mat grid xpos predicate  important
abstraction  would drop parts grid represent small rectangles
grooves  however  would require examination measures associated
grid area  as argument  relation surrounding grid areas  therefore  sentence drop  or criticalities assign  cannot decided statically
name predicate type arguments  hierarchical planners including
  

fibuilding refining abstract planning cases

prodigy alpine highly dependent representation used  particular

strategy restricted dropping sentences  holte et al                however  might
another representation domain hierarchical planners improve
performance think representation quite  natural  domain 
first trial conclude application domain representation
chosen following experiments paris really require dropping
sentences achieve improvement abstraction 

    evaluating paris approach

first experiment paris designed evaluate hypotheses domain
need  i  changing representation language abstraction   ii 
reusing abstract cases instead generating abstract solutions scratch  test
hypotheses rely time solving randomly generated problems using different
modes paris system 
      experimental setting
experiment used paris system solve     problems randomly

generated cases  thereby goal abstraction improve concrete level problem
solver  performs brute force search depth first iterative deepening search
strategy  korf      a  introduced section      improvement determined
terms problem solving time required solve single problem  paris used solve
    problems three different modes 

pure search  problem solver used solve problem pure search without
use abstraction 

hierarchical planning  mode paris uses introduced abstract domain  how 

ever  abstract cases recalled case library computed automatically search standard hierarchical planning  using new abstraction language  so  problem solver first tries search solution original
problem abstract domain tries refine solution 
hierarchical problem solving  backtracking two levels abstraction
subproblem occur  thereby  used hierarchical planning
new abstraction methodology instead dropping sentences 

reasoning abstract cases  mode first used paris learn abstract
cases come     concrete cases  problem  abstract cases
exists according abstraction methodology available one
problems solved  problem solving measured time required
solving problem using every applicable abstract cases  then  problem 
three abstract cases determined  a  best abstract case  i e   case leads
shortest solution time  b  worst abstract case  longest solution time 
abstraction aspired solution case  c  worst applicable abstract
case determined  difference b  c  relates difference
applicable refinable abstract cases introduced section      abstract case
  

fibergmann   wilke

selected c  applicable current problem  might abstraction
case problem taken  b  abstract cases selected
indeed abstractions current problem  i e   abstract cases
previously learned case problem taken  three
different cases selected figure impact case selection  which
addressed paper  proposed method 
although every problem theoretically solved brute force search procedure 
exponential nature search space avoids solution complex problems within
reasonable time  therefore  time bound     cpu seconds sun sparc elc
computer introduced three modes described above  limit bound
exceeded problem remains unsolved  increasing time bound would increase
number solvable problems three modes 
      results

determined solution time     problems described
modes  average solution time well number problems could solved
within time limit shown table    determined values reasoning
abstract cases separately three types abstract cases  significance
speedup results investigated using maximally conservative sign test
 etzioni   etzioni         unfortunately turned speedup hierarchical
planning pure search significant  couldn t find significant speedup
reasoning abstract cases using always worst applicable abstract case  c 
pure search  due large number doubly censored data  both problem
solvers cannot solve problem within time limit   counted
speedup hypothesis  however  improvements pure search reasoning refinable
abstract cases significant  p             using best refinable case  a 
using worst refinable case  b   furthermore  turned speedup
reasoning refinable cases hierarchical planning significant upper
bound p value        mentioned p value standard value used statistical
hypothesis tests  probability  assuming hypothesis hold 
encountering data favors hypothesis much observed data
experiment  etzioni   etzioni         therefore result significant
p value smaller  analysis  clearly see  two basic hypotheses
supported experimental data  even significant see moderate
improvement problem solving time number solved problems using
hierarchical planning changing representation language  please remember
hierarchical planning dropping conditions lead improvement  see
section       obviously  changing representation language abstraction required
improve problem solving domain stated first hypothesis  i  
strong support second hypothesis  ii  found presented
data  see significant speedups reasoning abstract cases pure search
even hierarchical planning  worst abstract case used problem
solved  speedup significant problem solving behavior slightly
worse hierarchical planning  please note situations extremely unlikely
  

fibuilding refining abstract planning cases

problem solving mode
average solution time  sec   solved problems
pure search
   
  
hierarchical planning
   
  
reasoning abstract cases
 a  best refinable case
  
  
 b  worst refinable case
  
  
 c  worst applicable case
   
  
table    comparison average solution time per problem number solved
problems within time bound     seconds  table compares pure search
 depth first iterative deepening   hierarchical planning using abstract problem solving domain  reasoning abstract cases differently selected
abstract cases 
happen all  sophisticated indexing retrieval abstract cases situation
avoided part 

    evaluating impact different training sets
one respect previous experiment based optimistic assumption  always
assume abstract cases required solving problem learned advance 
situation realistic scenario application  usually  one set cases
available training system different set problems needs solved 
cannot assume good applicable abstract cases always available solve new
problem  furthermore  presented example shows problem solving time
vary lot different abstract cases selected problem solving  therefore 
designed new experiment evaluate improvements caused paris approach
realistic scenario 
      experimental setting

randomly chosen    training sets   cases    training sets    cases
    available cases  training sets selected independently other 
then     training sets used separate experiment    
experiments      cases used particular training set
used evaluate performance resulting system  training set test set
completely independent procedure  problem solving task 
determine problem solving behavior applicable abstract cases  used
simple automatic mechanism retrieve one  hopefully good  applicable abstract case
problem  therefore  cases organized linearly cases base  sorted
length abstract plan contained case  case base sequentially searched
longer shorter plans applicable case found  heuristic based
assumption longer abstract plan specific shorter abstract plan
  

fibergmann   wilke

size training sets
 cases 
 
  

number abstract cases
minimum
maximum
average
 
  
   
 
  
    

table    comparison number learned abstract cases a     training sets
consists   concrete cases b     training sets
consists    concrete cases  table shows minimum  maximum 
average number abstract cases learned    training sets
respective size 
size training sets
 cases 
 
  

average problem solving time  sec  
best set
worst set
average
  
  
  
  
  
  

table    comparison problem solving time required reasoning abstract cases
separate training a     training sets consists  
concrete cases b     training sets consists    concrete
cases  table shows average problem solving time per problem best 
worst average training set    training sets size 
divides actual problem more  smaller subproblems  consequently longest
applicable plan lead best improvement 
      results

statistically evaluated second experiment  table   shows number abstract
cases could learned different training sets  minimum  maximum
average number abstract cases could learned    training sets
size indicated  note altogether    abstract cases learned    
cases would used training previous experiment     training
sets contained   cases each       abstract cases could learned 
expected  size training set increased abstract cases learned 
table   shows average problem solving time learning different sets 
table shows minimum  maximum average problem solving time
   different training sets two sizes  see best training sets leads
problem solving time similar slightly worse optimum shown
table    even average case  considerable improvements pure search
hierarchical problem solving  compare table   table    discovered 
   

fibuilding refining abstract planning cases

size training sets
 cases 
 
  

percentage solved problems
best set
worst set
average
  
  
  
  
  
  

table     comparison percentage solved problems separate training
a     training sets consists   concrete cases b    
training sets consists    concrete cases  table shows
percentage solved problems best  worst average training
set    training sets size 
size training sets
 cases 
 
  

number training sets significant speedups
pure search
hierarchical planning
p         
p         
p       
 
 
 
  
 
 

table     comparison significance  p value  speedup results pure search
hierarchical planning separate training a     training sets
consists   concrete cases b     training sets
consists    concrete cases  table shows number training sets
cause significant speedups different p values 
positive results identified looking percentage solved problems 
shown table     see best training sets number solved
problems close maximum achieved approach  even worst
training set considerably problems could solved pure search hierarchical
planning 
additionally mentioned speedup results analyzed maximally conservative sign test described  etzioni   etzioni         table    summarizes
significance results speeding pure search hierarchical problem solver 
turned       training sets lead highly significant speedups  p          
pure search  hard upper bound p values half training
sets lead significant differences reasoning abstract cases hierarchical
planning  slightly higher upper bound p             training sets
caused significantly better performance hierarchical planning 
altogether  reported experiment showed even small number training cases
 i e           already lead strong improvements problem solving 
see abstract cases must present  first experiment  successful 
furthermore  experiment shown even simple retrieval mechanism  sequential
   

fibergmann   wilke

size training sets
 cases 
 
  

average percentage solutions
shorter equal longer solution length
shorter
equal
longer
  
  
  
  
  
  

table     comparison length solutions created reasoning learned
abstract cases solutions available concrete cases  table shows
average percentage solutions shorter equal longer solution length
separate training a     training sets consists  
concrete cases b     training sets consists    concrete
cases 
search  select beneficial abstract cases library  neither training situations
second experiment lead results worse worst case shown table
  

    quality produced solutions

although main purpose approach improve performance problem
solver  quality produced solutions important practical system 
solution length used simple criterion determine quality
solution  however  general quality solution ect execution costs
plan  plans robustness  certain user preferences  perez   carbonell        
quality measures dicult assess  particular manufacturing
domain  rely simple criterion used evaluating quality solutions
prodigy analogy  veloso        
      experimental setting

analyzed solutions computed previous set experiments assess
quality solutions produced paris  therefore  length solutions derived
problem solving  learning    training sets  compared
length nearly optimal solutions contained concrete cases 
      results

training set length solution derived corresponding testing phase
compared length solution noted concrete case  percentage
solutions shorter  equal  longer solution length determined training set
separately  average    training sets equal size determined  table
   shows result evaluation 
turned big difference quality results   
training sets  particular  size training sets strong uence
   

fibuilding refining abstract planning cases

results  table    see                                
solutions produced equal better quality solutions contained
concrete cases  please note concrete cases used testing always different
cases used training  additionally  solutions compare
results produced paris already nearly optimal solutions due case generation
procedure    taking account  results already fairly good 

    impact abstract problem solving domain
experiments reported conducted concrete abstract domain
representation presented section   online appendix    final experiment
impact specific choice abstract problem solving domain investigated 
      experimental setting

created new abstract problem solving domain less constrained one
used before  purpose one operator completely removed certain conditions
remaining operators removed also  particular  set fixation operator
removed conditions abs chuck pos  abs chuckable wp  chuck comp removed
preconditions three remaining operators  hence  fact chucking
workpiece impact production plan neglected abstract level 
however  concrete problem solving domain generic abstraction theory
modified all  consequently  chucking still plays important role concrete level 
set experiments described section     repeated less constrained
abstract problem solving domain using training testing sets before 
      results

table       summarize results experiments  table    shows average
problem solving time occurs learning different training sets  turns
training sets  learning improves concrete level problem solver 
speedup much smaller using original abstract problem solving domain
 cf  table       particular  none resulting speedups concrete level problem
solving significant  similar result observed comparing percentage
solved problems  see figure      still slight improvement number
problems could solved learning improvement much smaller
using original abstract problem solving domain  cf  table       

    cases one  shorter solutions produced paris one step shorter solution
contained concrete case 

   

fibergmann   wilke

size training sets
 cases 
 
  

average problem solving time  sec  
best set
worst set
average
   
   
   
   
   
   

table     using less constrained abstract problem solving domain  comparison
problem solving time required reasoning abstract cases separate
training a     training sets consists   concrete cases
b     training sets consists    concrete cases  table
shows average problem solving time per problem best  worst
average training set    training sets size 

size training sets
 cases 
 
  

percentage solved problems
best set
worst set
average
  
  
  
  
  
  

table     using less constrained abstract problem solving domain  comparison
percentage solved problems separate training a     training sets
consists   concrete cases b     training sets
consists    concrete cases  table shows percentage solved problems
best  worst average training set    training sets
size 
experiment supported general intuition abstract problem solving domain significant impact improvement problem solving achieved
reasoning abstract cases  reason less constrained domain leads
worse results original abstract domain explained respect
criteria explained section      since important preconditions abstract operators
removed many situations new operators cannot refined 
holds particularly situations workpiece cannot chucked perform
required cutting operations  new abstract operators mostly independently
refinable  moreover  since abstract operator set fixation removed concrete chuck
unchuck operator must introduced refinement remaining abstract
operators  consequently  goal distance abstract operators increased 
two factors reason worse results using less constrained abstract domain
theory 
   

fibuilding refining abstract planning cases

    discussion
paper shown detail hierarchical problem solving  sacerdoti       
tenenberg        unruh   rosenbloom        yang   tenenberg        knoblock       
limited view abstraction dropping sentences well strategy
abstract solutions computed lead poor behavior various relevant situations 
observation supported comprehensive artificial examples  see section         
real world example domain mechanical engineering  see section    
supported experiment  see section       recent results reported  holte et al  
      support observations well 
general  abstraction task transforming problem solution concrete representation different abstract representation  reducing level
detail  michalski   kodratoff        giunchiglia   walsh        michalski         however  hierarchical problem solvers  much limited view abstraction
dropping sentences shown reason ecient ways abstracting problem
solution impossible  e g   see section     figure     second weakness
hierarchical problem solvers usually compute arbitrary abstract solutions solutions high chance refinable next concrete
level  although upward solution property  tenenberg        guarantees refinable abstract solution exists  guaranteed problem solver finds abstract
solution  e g   see section       problem solvers even heuristically guided towards
refinable abstract solutions 
paris approach present new formal abstraction methodology problem
solving  see section    allows abstraction changing whole representation language concrete abstract  together formal model  correct complete
learning algorithm abstracting concrete problem solving cases  see section    given 
abstract solutions determined procedure useful solving new concrete
problems  high chance refinable 
detailed experimental evaluation fully implemented paris system
domain mechanical engineering strongly demonstrates paris significantly improve problem solving situations hierarchical problem solver using dropping
sentences fails show advantage  see table       

     related work
discuss paris approach relation relevant work field 
       theory abstraction

within giunchiglia walsh s        theory abstraction  paris approach
classified follows  formal system ground space   given concrete
problem solving domain dc using situation calculus  green        representation 
language abstract formal system   given language abstract
problem solving domain da   however  operators da turned axioms
    instead  abstract cases build axioms     moreover  generic abstraction
theory defines abstraction mapping f           within framework  view
   

fibergmann   wilke

paris system learns useful axioms abstract system  composing several

smaller elementary axioms  the operators   however  prove formula  the existence
solution  abstract system  exactly one axiom  case  selected  deductive
machinery abstract system restricted respect ground space  depending
learned abstract cases abstractions paris either theory decreasing  td 
theory increasing  ti   case base abstract cases completely empty
domain axiom available resulting abstractions consequently td  casebase contains maximally abstract case hhtrue  truei nop i    and generic abstraction
theory contains clause   true   case applied every concrete problem
resulting abstraction consequently ti  even maximally abstract case
improve ground level problem solving  always included case base
ensure ti property  loosing completeness  case retrieval mechanism
must however guarantee  maximally abstract case chosen refinement
applicable case available  note  fulfilled retrieval mechanism
 sequential search longer shorter plans  used experiments 
       skeletal plans

already mentioned section     paris approach inspired idea skeletal
plans  friedland   iwasaki         abstract cases seen skeletal plan 
learning algorithm means learn skeletal plans automatically concrete
plans  even idea skeletal plans intuitively appealing  knowledge 
paper contains first comprehensive experimental support usefulness planning
skeletal plans  since shown skeletal plans acquired automatically 
planning method applied easily 
purpose  anderson farley        kramer unger        proposed approaches plan abstraction go direction paris algorithm 
however  approach automatically forms abstract operators generalization  mostly
based dropping sentences  moreover  abstracted plan  every concrete operator
abstracted  number operators reduced abstraction  thereby
abstraction approach less powerful paris style abstractions 
       alpine s ordered monotonic abstraction hierarchies
alpine  knoblock                          automatically learns hierarchies abstraction

spaces given domain description domain description together planning problem  mentioned several times before  alpine relies abstraction dropping
sentences  however  enables alpine generate abstraction hierarchies automatically 
stronger abstraction framework one follow paris  automatic
generation abstraction hierarchies  or abstract domain descriptions  seem
realistic due large  infinite  space possible abstract spaces  use powerful abstraction methodology  feel pay price losing ability
automatically construct abstraction hierarchy 
another point specific property ordered monotonic abstraction hierarchies
generated alpine  allows ecient plan refinement  refinement  ab    nop  no operation  operator always applicable change abstract state 

   

fibuilding refining abstract planning cases

stract plan expanded successively lower levels inserting operators  furthermore 
already established conditions plan guaranteed violated anymore refinement  unfortunately  kind refinement cannot performed paris style
abstractions  especially  direct correspondence abstract operators
concrete operators  consequently  abstract plan cannot extended become
concrete plan  however  main function abstract plan maintained  namely
original problem decomposed several smaller subproblems causes main
reduction search 
       explanation based learning  case based reasoning analogy

presented paris approach uses experience improve problem solving  similar several
approaches machine learning  mostly explanation based learning  mitchell et al  
      dejong   mooney         case based reasoning  kolodner        schank        althoff   wess        kolodner        analogical problem solving  carbonell        veloso
  carbonell         basic ideas behind explanation based learning case based
analogical reasoning much related  common goal approaches
avoid problem solving scratch situations already occurred past 
explanations  i e   proofs justifications  constructed successful solutions already
known system  explanation based approaches  explanations mostly cover
whole problem solving process  fikes  hart    nilsson        mooney        kambhampati
  kedar         relate problem solving chunks  rosenbloom   laird 
      laird  rosenbloom    newell        smaller size even single decisions
within problem solving process  minton        minton et al          explanation based
approaches generalize constructed explanations learning extensive use
available domain knowledge store result control rule  minton        schema
 mooney   dejong         case based reasoning systems priar  kambhampati
  hendler        prodigy analogy  veloso   carbonell        veloso        cases
usually explicitly generalized advance  kept fully instantiated
case library  annotated created explanations  unlike cases paris
problem solution pairs  cases complete problem solving episodes containing detailed information decision taken problem solving  problem
solving  cases retrieved contain explanations applicable current problem  kambhampati   hendler        veloso   carbonell        veloso         detailed
decisions recorded cases replayed modified become solution
current problem  approaches use kind generalization experience 
none approaches use idea abstraction speedup problem solving based
experience  already noted  michalski   kodratoff        michalski         abstraction generalization must confused  generalization transforms description
along set superset dimension  abstraction transforms description along level of detail
dimension 
exception given  knoblock  minton    etzioni      a  alpine s
abstractions combined ebl component prodigy  thereby  control rules
learned refer ground space problem solving abstract
spaces  control rules speedup problem solving abstract level  however 
   

fibergmann   wilke

control rules guide problem solver abstract level finds solutions faster
manner finds refinable abstract solutions  although
experience kind integration abstraction explanation based learning 
assume control rules generated ebl component guide problem
solver towards short abstract solutions cause much reduction search
several circumstances 

     requirements limitations paris

following  summarize requirements limitations paris
approach  main requirements availability good abstract domain description
availability concrete cases 
       abstract domain

important prerequisite method availability required background knowledge  namely concrete world description  abstract world description 
generic abstraction theory  construction planning system  concrete
world descriptions must acquired anyway  since specify  language  problem description  essential sentences  problem solution  operators   abstract
world generic abstraction theory must acquired  feel indeed
price pay make planning tractable certain practical situations 
nevertheless  formulation adequate abstract domain theory crucial
success approach  abstract operators missing required express
useful abstract plan  speedup achieved  need mostly independently
refinable abstract operators  operators exist  simply represented
abstract domain using whole representational power  hierarchical planning
dropping conditions  abstract domain must implicitly contained concrete
domain way abstract domain remains  certain literals concrete domain
removed  see section       feel kind modeling much harder
achieve modeling abstract view domain explicitly distinct planning space
paris  additionally  requirement abstract domain given user
advantage learned abstract cases expressed terms user
familiar with  thereby  user understand abstract case easily  open
additional opportunity involve user planning process  example
selection abstract cases she he favors 
research knowledge acquisition shown human experts employ lot
abstract knowledge cope complexity real world planning problems  specific knowledge acquisition tools developed comfortably acquire abstract
knowledge different sources  especially  acquisition planning operators addressed much detail  schmidt   zickwolff        schmidt        
       availability cases
second prerequisite  paris approach needs concrete planning cases  problem 

solution pairs   real world scenario cases usually available company s
filing cabinet database  according requirement share general view
   

fibuilding refining abstract planning cases

machine learning use kind experience promising way cope
highly intractable problems  paris approach available cases must
somehow representative future problem solving tasks  known cases must similar
enough new problems abstract cases really reused  experiments
give strong indications even small set concrete cases training leads high
improvements problem solving  see table       

     generality achieved results

reported experiments performed specific base level problem solver
performs depth first iterative deepening search strategy  korf      a   however 
strongly believe paris abstractions beneficial problem solvers
using backward chaining  means end analysis nonlinear partial order planning  shown
 veloso   blythe         one optimal planning strategy  different planning
strategies usually rely different commitments search  strategy useful
one domain may worse others  however  search strategies  length
shortest possible solution usually determines amount search required 
paris  whole search problem decomposed several subproblems allow
short solutions  consequently  kind problem decomposition use
search strategies 
moreover  think idea reasoning abstract cases  formulated
completely new terminology ground space useful kinds
problem solving design model based diagnosis  model based diagnosis 
developed approach  pews   wess        bergmann  pews    wilke        similar
paris  domain descriptions consist model technical system
diagnosis found  describes behavior elementary composed
component system different levels abstraction  model based diagnosis 
behavior technical system simulated possible faulty component searched
cause observed symptoms  using abstract cases  search reduced
focused onto components already defective  in similar machines 
consequently likely defective new situations 

     future work

future research investigate goal directed procedures refinement backwarddirected search non linear partial order planners  see section       additionally 
experience must gained additional domains different representations them 
furthermore  address development highly ecient retrieval algorithms
abstract cases  table   shows  retrieval mechanism strong uence
achieved speedup  even linear retrieval presented turned pretty
good  expect utility problem  minton        occur size casebase grows  furthermore  good selection procedure abstract cases use
feedback problem solver evaluate learned abstract cases based
speedup cause  would eliminate unbeneficial cases abstract operators
case base abstract problem solving domain  experiments different indexing
retrieval mechanisms recently indicated possible 
   

fibergmann   wilke

furthermore  speedup caused combination different approaches
abstraction explanation based learning addressed  within paris system
explanation based component case generalization still present  see figure    
used experiments plain abstraction evaluated 
experiments  abstraction  explanation based learning integration
addressed comprehensively  hopefully lead better understanding
different strengths methods have 
long term research goal  paris like approaches developed
evaluated kinds problem solving tasks configuration design or 
already started  model based diagnosis 

appendix a  proofs

section contains proofs various lemma theorems 

lemma    joining different abstractions  concrete domain dc two disjoint abstract domains da  da  given  joint abstract domain da   da    da 
defined follows  let da     la   ea   oa   ra   let da     la   ea   oa   ra   
da   da    da     la    la    ea    ea    oa    oa    ra    ra    joint abstract domain
da fulfills following property  ca abstraction cc respect  dc  da  
respect  dc   da    ca abstraction cc respect  dc   da  
proof  proof lemma quite simple  ca abstraction cc respect
 dc   dai   exists sequence abstraction mapping sequence abstraction
mapping required definition    easy see  abstraction mappings
lead respective case abstraction  dc   da    

lemma    multi level hierarchy  let  d           dl  arbitrary multi level
hierarchy
domain descriptions  two level description  dc   da   da   l   
dc   d  holds that  ca abstraction cc respect  d           dl  ca
abstraction cc respect  dc   da   
proof  let c   hhs    smi  case domain  intermediate state denoted
sj    let c    hhs     s n i  o i case domain d   intermediate state denoted s i   
let c abstraction case c  respect  d              sequence
cases  c            c      exists ci domain di ci   abstraction
case ci respect  di   di      f              g  proof induction
c abstraction c  respect  dc   da    see figure      basis
       obvious  c  abstraction c  respect  d    d   consequently
abstraction respect  dc   da    now  assume lemma holds cases
domain      follows immediately c    abstraction c  respect
 dc   da    let c      hhs    s k i  o i let intermediate states denoted s r  

definition   follows  state abstraction mapping sequence abstraction mapping
exists  ff scfi r     s r r   f           kg  c abstraction c   
   

fibuilding refining abstract planning cases












 










d 

figure     abstraction mappings hierarchies abstraction spaces
respect  d         exists state abstraction mapping ff  sequence
abstraction mapping   ff   s fi    j       sj j   f           mg  now 
define state abstraction mapping ff   s    ff   ff s   sequence abstraction mapping
   j     fi fi  j     easy see  ff   well defined state abstraction mapping
 s s    ff s  ff s     ff   ff s   ff   ff s         well defined sequence
abstraction mapping  fi  fi               fi   m      k    n   u   v     u       v    
 fi    u     fi fi  v     furthermore follows ff   scfi     j       ff   ff scfi  fi   j        ff   s fi  j       saj  
leading conclusion c abstraction c  respect  dc   da     

theorem    correctness completeness pabs algorithm  complete sldrefutation procedure used pabs algorithm  case ca abstraction case cc
respect  dc   da  generic theory a  ca   pabs hdc   da  ai  cc  
proof 

correctness       ca returned pabs  h oa            oak   ff    paths holds   
phase iv  define state abstraction mapping ff s     fe   jrc       eg 
which  together sequence abstraction mapping lead desired conclusion 
every operator oai  know construction phase iv  hfi  i        i   oai    g
holds  construction phase iii  conclude safi  i      ra   preoai holds
consequently e  ra   preoai holds respective execution body
while loop phase iv  since e ff  holds   monotonic derivation operator 
obvious ff scfi  i     ra   preoai   furthermore   if all  test  executed
oai
extension path  ensures  safi  i          
 safi  i      holds  together
oai
fulfillment precondition operator ff scfi  i       
ff scfi i   
thus  shown  ca correct abstraction respect definition   
completeness       assume  case ca   hhsa    sam i   oa           oam i abstraction cc
based deductively justified state abstraction mapping  exists state ab    note refers set finally constructed termination while loop  use
denote respective set construction loop 

   

fibergmann   wilke

oa


ff scfi i  
straction mapping sequence abstraction mapping ff scfi  i       
holds   f           mg  since deductively justified a  follows construction
phase ii  ff sci     sai     since   monotonic derivation operator  preconditon oai fulfilled safi  i      furthermore  addlist operator fulfilled
ff scfi  i   consequently fulfilled sai   construction phase iii 
guaranteed  hfi  i        i   oai    g  now  would show  phase iv 

exists sequence assignments variable paths  h    fi   ff i  
paths  h oa     fi   ff    paths          h oa            oam   fim  ffm   paths  
fik       fi      f           kg
 ffk   sal  ff scl  l   f           ng
ffk skl   addoal  

proof induction i  induction basis obvious due initialization
paths variable  now  assume h oa            oak   fik   ffk   paths  with k   m 
state execution phase iv  since  hfi  k    k       oak      g holds
argued before   k    fik  k  induction hypothesis  selected operator sequence
tried extended oa   oak   body while loop  additionally 
know  e contains exactly sentences required proof precondition
oak     note  since sld resolution procedure assumed complete
oak   applicable ff sck    e required proof preconditition oa
e ff scfi k     since deductively justified   e   e    l   f           mg holds  e   ff scfi  l  
scfi  l    rc     e  construction sal    e   e    l   f           mg holds  e   ff scfi  l  
e   sal   consequently  e   sal ff scl   l   f           mg  hand 
know oak   leads ff scfi  k       consequently  addoak   ff scfi  k      following
argumentation above  conclude  addoak     sal   ff scl  
l   f           mg  consequently  ff    ffk   e   addoak   holds ff    sal ff scl    now 
oa
conclude paths extended oak   follows  since ff scfi           
ff scfi     
holds addoa   ff   ff    safi       ff scfi        immediately follow
oa
 ff    safi           
 ff    safi        consequently  h oa            oak  oak      ffk    fik     paths
ffk     ff  fik         fik             f           kg fik   k        fi k   so 
induction hypothesis fulfilled k      thereby  shown ca returned
pabs   

acknowledgements
authors want thank agnar aamodt  jaime carbonell  padraig cunningham  subbarao kambhampati  michael m  richter  manuela veloso  well members
research group many helpful discussions remarks earlier versions paper  particularly  want thank padraig cunningham carefully proof reading
   

fibuilding refining abstract planning cases

recent version paper  greatly indebted anonymous jair reviewers helped significantly improve paper  research partially supported
german  sonderforschungsbereich  sfb     commission european
communities  esprit contract p      inreca project   partners inreca
acknosoft  prime contractor  france   tecinno  germany   irish medical systems  ireland 
university kaiserslautern  germany  

references
althoff  k  d     wess  s          case based reasoning expert system development 
schmalhofer  f   strube  g     wetter  t   eds    contemporary knowledge engineering amd cognition  springer  heidelberg 
anderson  j  s     farly  a  m          plan abstraction based operator generalization 
proceedings  th international conference artifical intelligence  pp         
san mateo  morgan kaufmann 
bacchus  f     yang  q          downward refinement eciency hierarchical problem
solving  artificial intelligence             
bergmann  r       a   knowledge acquisition generating skeletal plans  schmalhofer  f   strube  g     wetter  t   eds    contemporary knowledge engineering
cognition  pp          heidelberg  springer 
bergmann  r       b   learning abstract plans speed hierarchical planning 
tadepalli  p   ed    proceedings ml   workshop knowledge compilation
speedup learning  university aberdeen  scotland 
bergmann  r       c   learning plan abstractions  ohlbach  h   ed    gwai      th
german workshop artificial intelligence  vol      springer lecture notes
ai  pp          
bergmann  r          integrating abstraction  explanation based learning multiple
examples hierarchical clustering performance component planning 
plaza  e   ed    proceedings ecml    workshop integrated learning
architectures  ila     vienna  austria 
bergmann  r   pews  g     wilke  w          explanation based similarity  unifying
approach integrating domain knowledge case based reasoning  richter  m  
wess  s   althoff  k     maurer  f   eds    topics case based reasoning  vol     
lecture notes artificial intelligence  pp           springer 
bergmann  r     wilke  w          inkrementelles lernen von abstraktionshierarchien
aus maschinell abstrahierten planen  fensel  d     nakhaeizadeh  g   eds   
proceedings workshop maschinelles lernen  theoretische ansatze und anwendungsaspekte  no       institut fur angewandte informatik und formale beschreibungsverfahren  university karlsruhe  germany 
   

fibergmann   wilke

blythe  j   etzioni  o     et al          prodigy     manual tutorial  tech  rep 
cmu cs         carnegie mellon university  pittsburgh  pa 
carbonell  j  g          derivational analogy  theory reconstructive problem solving
expertise aquisition  michalski  r  s   carbonell  j  g     mitchell  t  m 
 eds    machine learning  artificial intelligence approach  vol     chap      pp 
         morgan kaufmann  los altos  ca 
dejong  g     mooney  r          explanation based learning  alternative view  machine learning                 
etzioni  o          structural theory explanation based learning  artificial intelligence 
           
etzioni  o     etzioni  r          statistical methods analyzing speedup learning 
machine learning              
fikes  r  e   hart  p  e     nilsson  n  j          learning executing generalized robot
plans  artificial intelligence             
fikes  r  e     nilsson  n  j          strips  new approach application theorem
proving problem solving  artificial intelligence             
friedland  p  e     iwasaki  y          concept implementation skeletal plans 
journal automated reasoning                 
giordana  a   roverso  d     saitta  l          abstracting background knowledge
concept learning  kodratoff  y   ed    proceedings european working session
learning  ewsl      lecture notes artificial intelligence  pp       berlin 
springer 
giunchiglia  f     walsh  t          theory abstraction  artificial intelligence     
        
green  c          application theorem proving problem solving  proceedings
ijcai     pp          washington  dc 
holte  r   drummond  c   perez  m   zimmer  r     macdonald  a          searching
abstractions  unifying framework new high performance algorithm 
proceedings   th canadian conference artificial intelligence  pp          
morgan kaufmann publishers 
holte  r   mkadmi  t   zimmer  r     macdonald  a          speeding problem solving
abstraction  graph oriented approach  tech  rep  tr        computer science
dept   university ottawa  ontario  canada 
kambhampati  s     hendler  j  a          validation structure based theory plan
modification reuse  artificial intelligence              
   

fibuilding refining abstract planning cases

kambhampati  s     kedar  s          unified framework explanation based generalization partially ordered partially instantiated plans  artificial intelligence     
      
knoblock  c  a          theory abstraction hierachical planning  proceedings
workshop change representation inductive bias  pp         boston 
ma  kluwer 
knoblock  c  a          learning abstraction hierarchies problem solving  proceedings
eighth national conference artificial intelligence  vol     pp          london 
mit press 
knoblock  c  a          search reduction hierarchical problem solving  proceedings
 th national conference artificial intelligence  vol     pp          anaheim 
ca 
knoblock  c  a          generating abstraction hierarchies  automated approach
reducing search planning  kluwer academic publishers 
knoblock  c  a          automatically generating abstractions planning  artificial
intelligence              
knoblock  c  a   minton  s     etzioni  o       a   integrating abstraction
explanation based learning prodigy  proceedings  th national conference artificial intelligence  vol     pp          anaheim  ca 
knoblock  c  a   tenenberg  j  d     yang  q       b   characterizing abstraction hierarchies planning  proceedings  th national conference artificial
intelligence  vol     pp          anaheim  ca 
kolodner  j  l          retrieval organizational strategies conceptual memory 
ph d  thesis  yale university 
kolodner  j  l          case based reasoning  morgan kaufmann 
korf  r  e          toward model representation changes  artifical intelligence     
      
korf  r  e       a   depth first iterative deepening  optimal admissible tree search 
artifical intelligence             
korf  r  e       b   macro operators  weak method learning  artifical intelligence 
          
korf  r  e          planning search  quantitative approach  artifical intelligence     
      
korf  r  e          linear space best first search  artifical intelligence            
   

fibergmann   wilke

kramer  m     unger  c          abstracting operators hierarchical planning 
hendler  j   ed    proceedings international conference ai planning  pp 
         morgan kaufmann 
laird  j   rosenbloom  p     newell  a          universal subgoaling chunking 
automatic generation learning goal hierarchies  kluwer academic publishers  norwell  ma 
langley  p     allen  j          unified framework planning learning  minton 
s   ed    machine learning methods planning  chap      pp           morgan
kaufmann 
lifschitz  v          semantics strips  reasoning actions plans 
proceedings      workshop  pp      timberline  oregon 
lloyd  j          foundations logic programming  springer 
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
 th national conference artificial intelligence  pp          
michalski  r  s          inferential theory learning conceptual basis multistrategy
learning  michalski  r     tecuci  g   eds    machine learning  multistrategy
approach  no      chap     pp        morgan kaufmann 
michalski  r  s     kodratoff  y          research machine learning  recent progress 
classification methods  future directions  kodratoff  y     michalski  r  s 
 eds    machine learning  artificial intelligence approach  vol     chap     pp 
      morgan kaufmann  san mateo  ca 
minton  s          learning search control knowledge  explanation based approach 
kluwer  boston  ma 
minton  s          quantitativ results concerning utility explanation based learning 
artifical intelligence              
minton  s   carbonell  j  g   knoblock  c   kuokka  d  r   etzioni  o     gil  y         
explanation based learning  problem solving perspective  artificial intelligence 
           
minton  s     zweben  m          learning  planning scheduling  overview 
minton  s   ed    machine learning methods planning  chap     pp        morgan
kaufmann 
mitchell  t  m   keller  r  m     kedar cabelli  s  t          explanation based generalization  unifying view  machine learning               
mooney  r  j          generalizing order operators macro operators  laird 
j   ed    proceedings  th international conference machine learning  pp 
        san mateo  ca  morgan kaufmann 
   

fibuilding refining abstract planning cases

mooney  r  j     dejong  g  f          learning schemata natural language processing 
proceedings ijcai  pp          los angeles  ca 
mozetic  i          abstraction model based diagnosis  aaai workshop automatic
generation approximations abstractions  pp        boston  ma 
newell  a     simon  h          human problem solving  prentice hall englewood cliffs 
nj 
paulokat  j     wess  s          planning machining workpieces partial order 
nonlinear planner  aaai fall symposium planning learning  real
applications 
perez  m     carbonell  j          automated acquisition control knowledge improve
quality plans  tech  rep  cmu cs         carnegie mellon university 
pews  g     wess  s          combining model based approaches case based reasoning
similarity assessment case adaptation diagnositc applications  richter 
m  m   wess  s   althoff  k     maurer  f   eds    preprints first european
workshop case based reasoning  ewcbr      vol  ii  pp           university
kaiserslautern  germany 
plaisted  d          theorem proving abstraction  artifical intelligence             
plaisted  d          abstraction using generalization functions  proceedings  th
conference automated deduction  vol      pp          
rosenbloom  p     laird  j          mapping explanation based learning onto soar 
proceedings national conference artificial intelligence  vol    philadelphia  pa 
sacerdoti  e          planning hierarchy abstraction spaces  artificial intelligence 
           
sacerdoti  e          structure plans behavior  vol     american elsevier  new
york 
schank  r  c          dynamic memory  theory learning computers people 
cambridge university press  new york 
schmidt  g          modellbasierte  interaktive wissensakquisition und dokumentation von
domaenenwissen  ph d  thesis  university kaiserslautern  germany 
schmidt  g     zickwolff  m          cases  models integrated knowledge acquisition
formalize operators manufacturing  proceedings  th knowledge acquisition
knowledge based systems workshop  banff  
shavlik  j     o rorke  p          empirically evluation ebl  investigating explanationbased learning  vol     chap     pp           kluwer academic publishers 
simon  h          functional equivalence problem solving skills  cognitive psychology 
           
   

fibergmann   wilke

tenenberg  j          preserving consistency across abstraction mappings  mcdermott 
j   ed    proceedings   th international conference artifical intelligence 
pp            los altos  ca  morgan kaufmann 
tenenberg  j          abstraction planning  ph d  thesis  computer science department 
university rochester  new york 
unruh  a     rosenbloom  p          abstraction problem solving learning 
proceedings international joint conference artifical intelligence     pp 
        detroit  mi  morgan kaufmann 
veloso  m  m          learning analogical reasoning general problem solving  ph d 
thesis  carnegie mellon university  pittsburgh  pa 
veloso  m  m          prodigy analogy  analogical reasoning general problem
solving  richer  m   wess  s   althoff  k     maurer  f   eds    topics casebased reasoning  pp         lecture notes ai  vol       springer 
veloso  m  m     blythe  j          linkability  examining causal link commitments
partial order planning  proceedings  nd international conference
planning ai systems aips    
veloso  m  m     carbonell  j  g          integrating derivational analogy general
problem solving architecture  minton  s   ed    proceedings first workshop
case based reasoning  morgan kaufmann 
veloso  m  m     carbonell  j  g          towards scaling machine learning  case
study derivational analogy prodigy  minton  s   ed    machine learning
methods planning  chap     pp           morgan kaufmann 
wilke  w          entwurf und implementierung eines algorithmus zum wissensintensiven
lernen von planabstraktionen nach der pabs methode  projektarbeit  universitat
kaiserslautern 
wilke  w          entwurf  implementierung und experimentelle bewertung von
auswahlverfahren fur abstrakte plane im fallbasierten planungssystem paris  master s thesis  university kaiserslautern  germany 
wilkins  d          practical planning  extending classical ai planning paradigm 
morgan kaufmann 
yang  q     tenenberg  j          abtweak  abstracting nonlinear  least commitment
planner  proceedings  th national conference aritificial intelligence  pp 
        boston  ma 

   


