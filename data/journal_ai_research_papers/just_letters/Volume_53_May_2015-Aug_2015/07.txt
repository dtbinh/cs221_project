journal of artificial intelligence research                  

submitted        published      

itsat  an efficient sat based temporal planner
masood feyzbakhsh rankooh
gholamreza ghassem sani

feyzbakhsh ce sharif edu
sani sharif edu

computer engineering department 
sharif university of technology 
azadi ave   tehran  iran

abstract
planning as satisfiability is known as an efficient approach to deal with many types of
planning problems  however  this approach has not been competitive with the state space
based methods in temporal planning  this paper describes itsat as an efficient sat based
 satisfiability based  temporal planner capable of temporally expressive planning  the
novelty of itsat lies in the way it handles temporal constraints of given problems without
getting involved in the difficulties of introducing continuous variables into the corresponding
satisfiability problems  we also show how  as in sat based classical planning  carefully
devised preprocessing and encoding schemata can considerably improve the efficiency of
sat based temporal planning  we present two preprocessing methods for mutex relation
extraction and action compression  we also show that the separation of causal and temporal
reasoning enables us to employ compact encodings that are based on the concept of parallel
execution semantics  although such encodings have been shown to be quite effective in
classical planning  itsat is the first temporal planner utilizing this type of encoding  our
empirical results show that not only does itsat outperform the state of the art temporally
expressive planners  it is also competitive with the fast temporal planners that cannot
handle required concurrency 

   introduction
temporal planning is an extension of classical planning where actions are durative rather
than being instantaneous  the introduction of durative actions adds a new dimension to
solving planning problems  namely reasoning about time  temporal reasoning is per se very
different from causal reasoning  because time is a real valued quantity  whereas the causal
aspects of planning are normally represented by propositions 
the current standard language for defining temporal planning problems is pddl   
 fox   long         although pddl   fox   long        has been introduced to the
planning community as a more expressive language for defining temporal and numerical
planning problems  throughout this paper  we will focus on pddl     because the planning
problems that we have tackled do not need the expressive power of pddl   in pddl    
actions can have separate preconditions and effects upon starting and ending  each temporal
action can also have some invariants  which must be preserved during the execution of that
action  an important subset of problems defined by pddl    are problems for which every
valid plan includes the concurrent execution of two or more actions  this subset is called the
problems with required concurrency  it has been shown that the concurrent execution of two
actions may be necessary for solving some temporal problems  halsey  long    fox       
cushing  kambhampati  mausam    weld         for instance  in some temporal planning
c
    
ai access foundation  all rights reserved 

firankooh   ghassem sani

problems  actions may require a proposition that is only available during the execution of
another action  in such cases  these two actions must be executed concurrently  a more
specific example is given in section    where we describe the driverlogshift domain  a
common approach in many planners that are not temporally expressive is to eliminate such
cases by compressing all temporal actions to create non durative classical actions 
in this paper  we describe itsat  a temporally expressive sat based  i e   satisfiability
based  planner  itsat uses an approach that takes advantage of parallel execution semantics without rendering it incomplete for the problems with required concurrency  in this
approach  the durations of all actions of a given problem are first abstracted out  this is
done by breaking each temporal action into two starting and ending instantaneous events 
then the obtained temporally abstract problem is encoded into a sat formula using novel
 step and  step semantics for causally valid plans  we show how these semantics can be
used to encode a given temporal planning problem into a sat formula  classical  step
and  step encoding methods have been introduced before  rintanen  heljanko    niemela 
       in addition to extending these methods to the temporal planning context  we also
introduce a new encoding method based on  step semantics for causally valid plans  we
show that our new encoding often results in a significant reduction of the number of required
steps 
after generating a causally valid plan  itsat performs a scheduling phase  during this
phase  itsat tries to satisfy those temporal constraints that are imposed by considering the
durations of actions  this is done by solving a simple temporal problem  stp   dechter 
meiri    pearl         however  for problems with required concurrency  the posed stp
may be inconsistent  in such cases  the cause of inconsistency  which manifests itself as a
negative cycle in the corresponding simple temporal network  stn   is detected  itsat
then generates a number of clauses that if added to the sat formula  collectively prevent
the reoccurrence of the particular negative cycle that has occurred and other similar cycles 
this process is repeated until a temporally valid plan is found 
similar to other sat based planners  itsat takes advantage of a preprocessing phase
to extract some information about the structure of problems  such information is used
throughout the encoding phase to produce a formula whose satisfiability can be checked
more efficiently by the sat solver  in section    we describe the preprocessing phase of
itsat  which includes the reasoning about mutual exclusion and the so called safe action
compression  coles  coles  fox    long         two propositions are regarded as mutually
exclusive if they can never be jointly true in the same state of a valid temporal plan  here  we
show that one can detect the mutually exclusive propositions of temporal problems by using
planning graph analysis  blum   furst         it is known that employing mutual exclusion
reasoning can significantly improve the performance of sat based planners  gerevini  
schubert        
as we mentioned earlier  itsat breaks down each temporal action into two starting
and ending instantaneous events  although in some cases such breaking down might be
necessary for producing concurrent plans  there are situations where this is not necessary
for finding valid plans  in section    we show that by using the mutual exclusion information 
one can identify those temporal actions that can safely be compressed into a classical action
without falsifying the validity of temporal plans  this analysis results in a smaller number
of distinct events and therefore a simpler planning problem 
   

fiitsat  an efficient sat based temporal planner

we empirically show that by taking advantage of its preprocessing  encoding  and
scheduling phases  not only does itsat significantly outperform state of the art temporally expressive planners  it is also competitive with the best temporally simple planners
which are incapable of solving problems with required concurrency property  the components of itsat are shown in figure    in this figure  the processing components of
itsat system are shown by rectangular blocks  while links represents the data produced
and received by these components 

figure    the block diagram of itsat

   

firankooh   ghassem sani

    motivation
as we mentioned earlier  temporal planners need to reason about time  which is a continuous
quantity  nevertheless  causal structures of problems in temporal planning are still very
similar to those in classical planning  the existence of abundant temporal planning domains
that also have classical versions can be regarded as an evidence to this claim  this suggests
that temporal planners can benefit from using approaches that have been previously shown
to be effective in dealing with classical problems 
the usage of boolean satisfiability checking is a well known paradigm in tackling classical
planning problems  kautz   selman         in this approach  a given planning problem is
translated into a formula in propositional logic  each variable of the sat formula typically
represents the occurrence of the corresponding action or proposition in a certain place of
potential plan  the causal constraints of the planning problem are represented by a number
of ground clauses  the output plan is assumed to have a finite number of steps  each step
may include one or more actions  the original sat based planner allowed only one action
per step  kautz   selman         however  the previously introduced sat based planners
allow multiple occurrence of actions in each step  the produced formula is given as the
input to an off the shelf sat solver  which tries to find a model for it  if such a model is
found  a plan is extracted from it  otherwise  the number of steps in the output plan is
increased by one and the corresponding sat formula is given again to the sat solver  this
process is repeated until a valid plan is extracted or some predefined termination condition
is reached  in order to obtain an efficient sat based planner  one important issue that
should be considered is how to encode the given planning problem into a sat formula 
sat based planning was originally used to find optimal plans  i e   plans with minimum
number of actions  kautz   selman         to guarantee the optimality of the output plan 
the formula must include certain clauses to ban each step from containing more than one
action  however  in the so called satisficing planning  in which optimality is not the main
objective  forcing single action steps is not necessary  an alternative approach is to consider
actions that can be executed in parallel in each step of the output plan  ernst  millstein 
  weld         exploiting such parallelism can result in a smaller number of steps in the
sat formula  another important benefit of producing compact formulae is lower memory
requirements  several encoding methods have been introduced to take advantage of action
parallelism  these encoding methods are based on the so called  step and  step semantics
of valid plans  rintanen et al         
the  step and  step semantics are different in the extent of action parallelism that they
allow to occur in each step  the  step semantics allows a set of actions to be executed in
parallel  only if those actions can be executed in every possible ordering without affecting the
validity of the plan  the  step semantics  on the other hand  imposes a weaker restriction 
for each step of a plan  there must exist at least one possible ordering in which the actions
can be executed without falsifying the validity of the plan  it should be clear that the  step
semantics potentially allows more parallelism than is permitted by the  step semantics  in
fact  by taking advantage of  step semantics  the most efficient sat based classical planner 
i e   mp  rintanen         is competitive with the state of the art state space planners  in
this paper  we show that the separation of causal and temporal reasoning phases of temporal
planning enables us to employ these compact encodings for efficient temporal planning 
   

fiitsat  an efficient sat based temporal planner

    related work
previous research in the field of temporal planning has benefited enormously from employing
well developed classical planning strategies  for instance  many successful temporal planners have utilized the ideas of partial order planning  e g  vhpop  younes   simmons 
      and cpt  vidal   geffner         planning graph analysis has also been adopted by
temporal planners such as tgp  smith   weld        and tpsys  garrido  fox    long 
       some other temporal planners have embedded temporal reasoning into heuristic
state space search  tfd  eyerich  mattmuller    roger         lpg td  gerevini  saetti 
  serina         and popf  coles  coles  fox    long        are the successful instances
of this latter approach 
the usage of boolean satisfiability checking is one of the well known paradigms in tackling classical planning problems  kautz   selman         in order to obtain an efficient
sat based planner  one important issue that should be considered is how to encode the
given planning problem into a sat formula  in fact  devising efficient encoding methods
has been an important research trend in the field of sat based planning  examples of
efficient encodings are  the split action representation  kautz   selman        ernst et al  
      robinson  gretton  pham    sattar         the sas  based encoding  huang  chen 
  zhang         and the compact mutual exclusion representation  rintanen         based
on parallel semantics of plans  another effective encoding method has been introduced  rintanen et al          this latter encoding method is of particular interest in this paper 
satisfiability checking has also been employed in the field of temporal planning  however 
sat based temporal planners do encounter a major challenge  representing temporal aspects of problems  since time is a continuous quantity  it cannot be treated in the exact same
way in which discrete causality is handled  to tackle this problem  step  huang  chen   
zhang         scp   lu  huang  chen  xu  zhang    chen         and t satplan  mali
  liu        use a discrete representation of time  these planners assign explicit discrete
time labels to each step of the encoding  generally speaking  in this approach  each step i
is exactly one time unit ahead of step i      as a result  if an action with duration d starts
in step i  it is forced to end in step i   d  one immediate outcome of such an approach
is the introduction of an enormous number of steps into the encoding  many of which will
not contribute to the output plan  this drawback of the explicit time representation causes
step  scp   and t satplan to be inefficient in terms of both speed and memory usage  to obtain a better performance  scp  uses  step semantic to allow causal relations
between actions in each time point  lu et al         
tm lpsat  shin   davis         which has been designed to solve planning problems
defined in pddl   fox   long         is another sat based planner capable of handling
temporal planning problems  similar to step and t satplan  tm lpsat attaches
time labels to each step  however  in tm lpsat  these labels are not predefined discrete
numbers  instead  each label is a numeric variable whose value will be determined after
the problem is solved by an smt solver  armando   giunchiglia         this approach
can result in encodings which are more compact than those produced by step and tsatplan 
a major disadvantage of assigning a time label to each step of the formula is that the parallelism mentioned above cannot be exploited effectively  that is because when two events
   

firankooh   ghassem sani

are to happen in a certain step of the plan  their time labels must be the same  and thus 
they must be simultaneous when the final plan is executed  this compulsory simultaneity
is a restriction that reduces the number of events that can happen in each step of the final
plan  which in turn  increases the number of steps needed for solving input problems  this
implies that all the efficiency gain one could obtain from using parallel execution semantics
will be sacrificed to achieve an easy way to deal with temporal constraints  however  in the
majority of current temporal planning problems  satisfying temporal constrains is not the
hardest task in finding a valid plan  it was shown that for the problems without required
concurrency  one can omit the temporal constraints altogether  find a causally valid plan 
and then  by considering temporal constraints only in a postproccessing step  schedule the
actions of that plan to find a temporally valid plan  cushing et al          this approach
has actually been used by many previous temporal planners including yahsp  mt  vidal 
       the winner of the temporal satisficing track of ipc       despite being efficient in
solving many temporal problems  such planners are incomplete  as they are incapable of
solving problems with required concurrency 
in addition to classical planning problems  sat based methods have also been used to
deal with other categories of planning problems  examples are planning under uncertainty
 castellini  giunchiglia    tacchella         cost optimal planning  robinson  gretton 
pham    sattar        and numerical planning  hoffmann  gomes  selman    kautz 
      

   preliminaries
the standard language used for defining temporal planning problems is pddl     fox  
long         figure   presents an example of the pddl    representation of a temporal
planning domain  this domain  which is a simplified version of driverlogshift  halsey        
will be referred to several times throughout this paper  as figure   shows  in pddl    
each action can have separate conditions and effects upon starting and ending  the starting
and ending conditions  or effects  of an action are specified by the at start and at end
tokens  respectively  each action may also have some conditions that need to be preserved
during execution  these conditions are specified using the over all token  moreover  the
duration of each action is defined by an     duration x  statement  where x is a rational
number or a function specifying the actual duration of that action 
driverlogshift is the temporal version of the driverlog domain from ipc   as in its
classical counterpart  in driverlogshift  the objective is to transfer several objects from their
original places to their destinations  each object can be loaded into and unloaded from a
certain truck by using the load and unload operators  respectively  a truck can move
between locations using the move operator  the main difference between driverlogshift and
driverlog is that the trucks here must be rested during the intervals between their working
shifts  each working shift is defined by the work operator  which produces the  working
truck  proposition upon starting  and deletes that proposition upon ending  load  unload 
and move have  working truck  as their invariant  once  working truck  is deleted by
the ending of work  it may be reproduced by the rest operator  which defines the resting
shift of a certain truck 
   

fiitsat  an efficient sat based temporal planner

 define  domain driverlogshift 
  requirements  typing  durative actions 
  types
location locatable   object
truck obj   locatable 
  predicates
 at  obj   locatable  loc   location 
 in  obj    obj  obj   truck 
 link  x  y   location 
 working  t   truck 
 need rest t   truck 
 rested t   truck  
  durative action work
 parameters
  truck   truck 
 duration     duration     
 condition  and
 at start  rested  truck   
 effect  and  at start  working  truck  
 at end  not  working  truck   
 at start  not  rested  truck   
 at end  need rest  truck    
  durative action rest
 parameters
  truck   truck 
 duration     duration    
 condition  and
 at start  need rest  truck   
 effect  and
 at start  not  need rest  truck   
 at end  rested  truck    
  durative action load
 parameters
  obj   obj
 truck   truck
 loc   location 
 duration     duration    
 condition  and
 over all  at  truck  loc  
 over all  working  truck  
 at start  at  obj  loc   
 effect  and
 at start  not  at  obj  loc   
 at end  in  obj  truck    

  durative action unload
 parameters
  obj   obj
 truck   truck
 loc   location 
 duration     duration    
 condition  and
 over all  at  truck  loc  
 over all  working  truck  
 at start  in  obj  truck   
 effect  and
 at start  not  in  obj  truck   
 at end  at  obj  loc    
  durative action move
 parameters
  truck   truck
 loc from   location
 loc to   location 
 duration     duration    
 condition  and
 at start  at  truck  loc from  
 at start  link  loc from  loc to  
 over all  working  truck   
 effect  and
 at start  not  at  truck  loc from   
 at end  at  truck  loc to     

figure    pddl    description of driverlogshift domain

note that the version of driverlogshift described in figure   is slightly different from
its original version  halsey         in which there are drivers that can walk to  board  and
disembark trucks  furthermore  the rest and work actions are performed by the drivers
rather than trucks  however  in order to make the examples simpler  we have merged drivers
and trucks into a single entity of just trucks 
a simple example of problems in driverlogshift is shown in figure    in this problem 
there are three locations  s   s   and s    one truck  truck    and one object  package   
in the initial state  truck  and package  are at s   the objective of the problem is to
transfer package  to s  
    formalism of pddl   
now we present our formalism of the specifications of pddl     our formalism is devised in
a way that simplifies the description of the preprocessing  encoding  and scheduling phases
of itsat  we should mention that our formalism has some limitations compared to the
full specifications of pddl     these limitations will be discussed in details in section     
   

firankooh   ghassem sani

 define  problem dlog 
  domain driverlogshift 
  objects
truck 
  truck
package    obj
s  s  s    location 
  init
 rested truck  
 at truck  s  
 at package  s  
 link s  s  
 link s  s  
 link s  s  
 link s  s  
 
  goal  and
 at package  s     

figure    pddl    description of a problem in driverlogshift domain

definition    events   an event  e  is a triple  pre e   add e   del e    where pre e  
add e   and del e  are three sets of atomic propositions  facts  representing preconditions 
positive effects  and negative effects of e  respectively 
definition    temporal actions  a temporal action  a  is a quadruple  start a   end a  
inv a   dur a    where start a  and end a  are two events denoting the starting and ending
events of a  inv a  is a set of atomic propositions representing the invariants of a  and
dur a  is a positive rational number specifying the duration of a 
example    figure   shows a temporal action a   load package   truck   s    which
is an instance of the load operator defined in figure    in figure    a is depicted by a rectangular box  conditions and effects of a are written above and below the box  respectively 
the at start conditions and effects of a are placed at the left hand side of the box  and
the at end conditions and effects are placed at the right hand side of the box  the over
all conditions of a are placed at the middle of the box  here  start a  and end a  are
two events  where pre start a       at package  s     add start a       del start a    
  at package  s     pre end a       add end a       at package  truck     and also
del end a       moreover  we have inv a      at truck  s     working truck     and
dur a       
   

fiitsat  an efficient sat based temporal planner

figure    a temporal action

definition    temporal states   a temporal state  s  is a pair  state s   agenda s   
where state s  is a classical planning state represented by a set of atomic propositions  and
agenda s  contains a finite set of open actions  i e   actions started prior to s and not yet
ended  
definition    applicability   the starting event e of an action a is applicable in state s 
if the following conditions hold 
    state s  contains all the preconditions of e and
s all the invariants of a  except for those
invariants of a that are added by e   pre e   inv a   add e    state s 
    a is not already open in s  a 
  agenda s 
    esdoes not delete thetinvariants of any open action of s 

del e    
a agenda s  inv a  
the ending event e of an action a is applicable in state s  if the following conditions hold 
    state s  contains all the preconditions of e  pre e   state s 
    a is open in s  a  agenda s 
    s
e does not delete the invariants
of any open action of s  other than a  
t
 
inv a
del e 
 
a agenda s  a 
definition    successors   if the starting event e of action a is applicable in state s  it
will change s to the unique state s satisfying the following conditions 


 the set of open
s actions of s is equal to the set of open actions of s with a  agenda s    
agenda s   a 

 all positive and negative effects
s of e are respectively added to and deleted from s  

state s      state s   del e   add e 

if the ending event e of action a is applicable in state s  it will change s to the unique state
s satisfying the following conditions 
   

firankooh   ghassem sani

 the set of open actions of s is equal to the set of open actions of s without a 
agenda s     agenda s    a 
 all positive and negative
effects of e are respectively added and deleted in s   state s    
s
 state s   del e   add e 
from now on  we may use succ s  e  to represent the successor state s obtained by applying
e to s 
definition   and definition   can be easily extended to also cover any sequence of events 
succ s  he         en i    succ succ s  he         en  i   en    and succ s  hi    s  a sequence of
events he         en i is applicable in a temporal state s  if succ s  he         en i  is defined 
example    let s be a temporal state such that
state s      at package  s     at truck  s     working truck     link s  s   
and
agenda s     
let a   load package   truck   s   and a   move truck   s   s   be two temporal actions  which are respectively instances of the load and move operators presented in figure
   the event start a  is applicable in s and it changes s to s such that
state s       at truck  s     working truck     link s  s   
and
agenda s      load package   truck   s    
now  start a  is not applicable in s because a is already open in s   nor isstart a   applicable in s   as it deletes  at truck  s   that is an invariant of a  which is still open in s  
however  end a  is applicable in s and changes it to s such that
state s       at package  truck     at truck  s     working truck     link s  s   
and
agenda s      

definition    temporal problems   a temporal problem  p  is a triple  i  g  a   where
i  representing the initial state  is a temporal state such that agenda i      g is a set
of atomic propositions denoting the goal conditions  and a is the finite set of all possible
temporal actions of p 
definition    causally valid plans   let p    i  g  a  be a temporal problem and
   he         en i be a sequence of events where for each i  ei is a starting or an ending event of
an action in a   is a causally valid plan for p  if it is applicable in i  g  state succ s     
and agenda succ s        
   

fiitsat  an efficient sat based temporal planner

definition    pairing events   let    he         en i be a causally valid plan for problem p    i  g  a   assume that ei and ej are respectively the starting and ending events of
a certain action a  a and i   j  if for all k such that i   k   j  ek is neither the starting
nor the ending event of a  we say that ei  ej   is the pairing event of ej  ei   in   in other
words  ei and ej are pairing events in  if they are related to the same occurrence of a in  
definition    valid temporal plans and makespan   let    he         en i be a causally
valid plan for p    i  g  a   and             n   q be a scheduling function for   where q
is the set of rational numbers        is a valid temporal plan for p if  has the following
properties 
 for all i    i      i      
 for each a  a  if start a    ei   and ej is the pairing event of ei   then   j   
  i    dur a  
the maximum value assigned by  to the events of  is called the makespan of  
example    consider the problem p    i  g  a  depicted in figure    where state i 
and g contain the propositions listed after the labels  init and  goal  respectively  and a
is the set of all possible instantiations of operators presented in figure   with the objects
listed after label  objects of figure    let
   hstart work truck    
start load truck   package   s    
end  load truck   package   s    
start move truck   s   s    
end  move truck   s   s    
start move truck   s   s    
end  move truck   s   s    
start unload truck   package   s    
end  unload truck   package   s    
end  work truck   i
a schematic representation of  is depicted in figure    a straightforward checking shows
that  is a causally valid plan for p  however   is not a valid temporal plan because the
duration of work truck   is       requires the serial execution of two move actions  one
load action  and one unload action  with the total duration of      while work truck  
is still open  in other words  one single working shift of truck  is not sufficient to transfer
package  from s  to s   therefore  no scheduling function  with the properties of
definition   exists for   a valid temporal plan for p is depicted in figure    in this
plan  two working shifts of truck  are used 
   

firankooh   ghassem sani

figure    a causally valid plan

figure    a valid plan

    limitations
we end this section by describing the differences between our formalism of valid temporal
plans and that of pddl     the main limitations of our formalism are listed below 
 according to definition    the starting event of an action a is applicable in the state
s only if a is not already open in s  this means that  similar to many previous
temporal planners  we do not permit two versions of the same action to overlap 
consequently  the current implementation of itsat does not allow self overlapping
actions  however  the specification of pddl    allows plans to have such actions 
which have been shown to be necessary for solving certain temporal problems  fox  
long         our experimental results indicate that this restriction does not render
itsat incapable of solving current benchmark problems  nevertheless  it has been
shown that  in theory  having self overlapping actions may cause the complexity of
temporal planning to become expspace hard rather than pspace hard  rintanen 
      
 our formalism does not allow two or more events to be simultaneously applied to any
state  as an example of cases where such a simultaneity is required  consider two
temporal actions a and b  such that the starting event of a adds an invariant of b 
   

fiitsat  an efficient sat based temporal planner

and the starting event of b adds an invariant of a  in this case  it might be necessary
to simultaneously apply the starting event of both actions to a given state  it is not
clear from the specification of pddl    whether such a simultaneity is permitted or
not  on the other hand  it has been shown that almost none of current benchmark
problems require such a simultaneity for being solvable  rankooh   ghassem sani 
      
 pddl    allows the usage of numerical variables  this is not supported by itsat 
pddl    also allows duration dependent effects and state dependent durations for
actions in numerical planning problems  these features are not supported by itsat
either  because itsat does not currently handle numerical fluents 
 according to our formalism  the duration of a temporal action is defined by an   
 duration x  assignment  where x is a rational number or a function specifying
the actual duration of that action  pddl     on the other hand  also allows using
inequalities such as    duration x  and    duration x  to define a range for
the duration of any temporal action  nevertheless  the current benchmark problems
do not include such inequalities  although the current implementation of itsat does
not support these inequalities  it is quite easy to include this feature  as these kinds
of constraints on the duration of actions are handled by simple temporal problems
 dechter et al         

   preprocessing phase
preprocessing is an important phase in many planners  the main objective of this phase
is to extract certain information from the problem  this information can later be used to
enhance search performance  one important issue that should be addressed when devising
any preprocessing method is the correctness of extracted information  in other words  the
constraints inferred during the preprocessing phase must be correct in the sense that  it
does not cause the planner to become incapable of finding valid plans  moreover  for a
preprocessing method to be effective  it is required to be performed in at most polynomial
time  in this section  we explain two different preprocessing methods used by itsat  mutual
exclusion analysis and action compression  we also formally prove that these methods are
both correct and can be performed in polynomial time 
    mutual exclusion analysis
mutual exclusion analysis is a preprocessing method to find pairs of propositions that cannot be mutually true in any state of a valid plan  sat based planners typically add an
explicit clause to their sat formula for each pair of mutually exclusive propositions  such
clauses prevent mutually exclusive pairs of propositions from being true true at the same
time  although such information can be obtained through the search phase itself  by acquiring it beforehand  one can prune the search tree of the sat solver and thereby improve
performance 
polynomial time mutual exclusion analysis for classical planning problems was originally performed by constructing planning graphs  a data structure which was introduced
   

firankooh   ghassem sani

in graphplan  blum   furst         it has been shown that the mutual exclusion
information obtained from planning graphs can be quite effective in improving the performance of sat based planners  gerevini   schubert         other methods have also been
introduced to compute n way mutexes  instead of the pairwise mutexes computed by the
planning graphs   the hn heuristic  haslum   geffner         which analyzes the reachability of any set of n propositions from the initial state  is an example of such methods 
it has been shown that a generalization of the hn heuristic can be efficiently computed by
using a syntactic regression operation  rintanen   gretton        
the method used by itsat for finding mutual exclusion relations is based on the
planning graph analysis  a classical planning graph is a layered structure  the first layer
includes all the propositions that are present in the initial state of the problem  in each
layer of planning graph  mutual exclusion  mutex   relations between pairs of proposition
are computed  two propositions are non mutex in the first layer if and only if they are
both present in the initial state  an action is applicable in a layer if all its preconditions
are non mutex in that layer  two different actions are mutex in layer i  if at least one of
the following conditions holds     they have interference with each other  i e   one action
deletes any effect of the other action      they have conflict with each other  i e   one action
deletes any precondition of the other action   or    their preconditions are mutex in layer i 
layer i     includes all the effects of the actions applicable in layer i  two propositions that
are mutex in layer i become non mutex in layer i     if they are produced by non mutex
actions of layer i  to transfer propositions from one layer to the next layer  there exists a
special noopp action for each proposition p that both requires and adds p  the construction
of planning graph may continue until no change take places between two consecutive layers 
in that case  we say the graph has leveled off 
planning graphs have previously been employed to tackle temporal planning problems
 smith   weld         in fact  the first completely domain independent temporal planner
called tgp  was an extension of graphplan  blum   furst         tgp requires all
preconditions of each temporal action to be preserved throughout the time that the action
is open  and also does not allow actions to have effects upon starting  as a result  tgp
is not compatible with the requirements of pddl     tpsys  garrido et al          an
extension of tgp  is another planning graph based temporal planner that can produce
plans in domains with required concurrency  similar to graphplan  in addition to the
construction of a planning graph  both tpsys and tgp perform a backward search for a
valid temporal plan 
lpgp  long   fox        is another planning graph based temporal planner  in lpgp 
the mutex relations between proposition and actions are computed by considering only
the causal constraints of the problem  whereas the temporal constraints are taken into
account later while a plan is being extracted by solving a linear programming  lp  problem 
omitting the temporal constraints of the problem is done by converting the given temporal
problem into a classical problem  as a result  the graph construction of lpgp is very
similar to that of graphplan 
as mentioned earlier  in itsat  the temporal constraints of the problem are considered
only after a causally valid plan is produced  therefore  those constraints are not needed to
be dealt with in the planning graph construction phase  this makes the graph structure of
lpgp suitable for itsat  here  we explain the graph construction phase of lpgp  the
   

fiitsat  an efficient sat based temporal planner

correctness of mutual exclusion information obtained by this method is essential for the
correctness of our action compression and sat encoding methods  however  the description
of lpgp was not accompanied by any formal proof of correctness  therefore  here  we
formally prove the correctness and tractability of this preprocessing method 
definition     causal abstraction of temporal problems   let p    i  g  a  be a
temporal planning problem and ac be a set of classical actions such that for each a  a
there are exactly three classical actions as   ai   and ae in ac   with the following properties 
 pre as     pre start a     inv a   add a  
 add as     add start a     opena    where opena is a new proposition specifying that
a is started but not yet finished
 del as     del start a    add start a  
 pre ai     inv a    opena  
 add ai     inv a    opena  
 del ai     
 pre ae     pre end a     opena  
 add ae     add end a  
 del ae      del end a    add end a      opena  
the causal abstraction of p is the classical problem p c    state i   g  ac   
in fact  by definition     to produce a causal abstraction of a given temporal planning problem  we split any temporal action a into three classical actions as   ai   and ae  
actions as and ae correspond respectively to the starting and ending events of a  in addition to their normal effects and preconditions  as adds a special proposition named opena  
which is required and deleted by ae   the action ai is called the invariant checking action
of a  and requires all invariants of a plus opena as its preconditions  and produces opena as
its effect 
for a given temporal planning problem p    i  g  a   itsat produces
c
p    state i   g  ac   i e   the causal abstraction of p  itsat then constructs a classical planning graph for p c  
the planning graph in itsat is very similar to that of graphplan  there is only one
difference between the planning graphs of these two planners  in graphplan  as mentioned earlier  all propositions are propagated through layers by the so called noop actions 
however  in itsat  there is an exception to this usage of noop actions  the new proposition
of form opena introduced by our causal abstraction of action a  this particular proposition
is propagated by ai   the invariant checking action of a  therefore  ai can be seen as a new
kind of noop action used to cover the invariants during the reasoning about mutex relations 

   

firankooh   ghassem sani

theorem    let p    i  g  a  be a temporal planning problem and p c    state i   g  ac  
be the causal abstraction of p  let    he         en i be any finite sequence of events that is
applicable in i  and sn   succ i     then the following conditions must hold 
 if two propositions p and q are both members of state sn    then p and q are non mutex
in the layer n of the planning graph of p c  
 if proposition p is a member of state sn    and action a is a member of agenda sn   
then p and opena are non mutex in layer n of the planning graph of p c  
proof  see appendix a 
after a planning graph has been leveled off  all the subsequent extensions of the graph
has no effect on the new layers  therefore  if two propositions are mutex in the last layer of
a leveled off graph  they will remain mutex in all subsequently produced layers  in this case 
theorem   implies that such pairs of propositions can never appear at the same temporal
state during the execution of a valid temporal plan  the only matter that remains is to
show that the mutual exclusion analysis of itsat can be performed in polynomial time 
let p be a temporal planning problem  and p c be the causal abstraction of p  it can be
deduced from definition     that the size of p c is greater than that of p only by a constant
factor  the process of constructing the planning graph of p c can be obtained by modifying
the construction process of planning graphs in graphplan planner  in such a way that
for any temporal action a  noopopena is never used  graphplan constructs its planning
graphs in polynomial time  blum   furst         therefore  the overall time needed for
the mutual exclusion analysis of itsat is also polynomial in the size of any given temporal
planning problem 
    action compression
temporal actions can have a variety of temporal relations with one another  a popular
model for representing temporal relations between actions was initially introduced by james
allen         the model included    possible temporal relations between any two actions 
some of allens temporal relations require the starting and or ending events of actions to
be executed simultaneously  as it was mentioned in section      none of the temporal plans
produced by itsat can necessitate such a simultaneity  as a result  the set of temporal
relations between any two temporal actions will be confined to a proper subset of all allens
temporal relations  these possible temporal relations are depicted in figure    as it is
shown in figure    in   out of   types of these relations  the actions are concurrent  i e  
there exists a time in which the two actions are both being executed  such a concurrency is
unnecessary for solving some temporal planning problems  if we know that two actions are
not required to be concurrently executed  in order to find a valid plan  checking only the
two temporal relations depicted in figure    c  is sufficient in the searching phase of any
planner  however  if all valid plans include concurrent executions of two or more actions 
restricting the temporal relations of actions to just the two relations depicted in figure
   c  will render the planner incomplete 

   

fiitsat  an efficient sat based temporal planner

figure    temporal relations between two pddl    actions

definition     compression safe sets of actions and compressed plans   let
p    i  g  a  be a temporal planning problem for which there exists at least one valid
temporal plan  and a be a subset of a  we say a is compression safe for p  if there exists
a causally valid plan for p that is compressed with respect to a   a causally valid plan
   he         en i is compressed with respect to a if it has the following property 
 for each k  if ek is the starting event of action a  a   then ek   is the ending event
of a 
according to definition     the starting and ending events of all members of a are
assumed to be executed consecutively in at least one causally valid plan  therefore  while
that plan is being executed  no other event is causally needed to happen between the starting
and ending of any member of a   this suggests that members of a can be regarded as a
single event in the environment  rather than having two separate starting and ending events 
   

firankooh   ghassem sani

in other words  for each member of a   we can compress the starting and ending events
into a single event without rendering the problem unsolvable  as an example  consider the
driverlogshift temporal planning problem presented in example    the plan  presented
in example   shows that the set of all load  move  and unload actions is a compressionsafe set of actions for that problem  a straightforward analysis of this example shows that
neither of work actions presented in example   can be a member of any compression safe
subset of actions 
note that  according to definition     only a causally valid plan can be regarded as a
compressed sequence of events  although the concept of compression can be extended to
cover even those sequences of events that do not lead to any goal state  for the sake of
simplicity  we have focused our attention to only those sequences that are causally valid
plans  and defined compression safe actions only for solvable temporal planning problems 
as we explain later in section    the information obtained by our compression safety analysis
is incorporated into the encoding of the problem by adding some extra sat formulae  which
makes the problem at hand tighter  in other words  this information is only used to prune
the search space of the sat solver  as a result  our handling of compression safety can
never cause the planner to produce any  invalid  plan for an unsolvable planning problem 
safe action compression has been employed before in the field of temporal planning
 coles et al          it has been shown that in the temporal problems that do not possess the
property of required concurrency  all temporal actions can be safely compressed into classical
actions  cushing et al          a temporal problem is said to have required concurrency  if
its every valid temporal plan includes at least one action whose execution overlaps with the
execution of some other action  in the problems without required concurrency  all temporal
actions can be compressed into classical actions  in this case  the problem is transformed
into a classical planning problem  this phenomenon is completely consistent with the
semantics of definition     as it can be easily shown that in the problems without required
concurrency  the set of all actions is indeed a compression safe set of actions  however 
as it is the case in example    even when the problem does have the required concurrency
property  there may still exist a non empty compression safe set of actions 
crikey  and its successor  popf  are two state space based temporal planners that
detect the compression safe actions as a preprocessing task  coles et al          however 
the concept of compression safety in those planners is different from what we presented
in definition     crikey  does not assume that the ending event of a compression safe
action must be executed immediately after its corresponding starting event  instead  once
the starting event of a compression safe action is applied to a state  using a simple inference
method  crikey  can determine when to apply the corresponding ending event  this
method can reduce the branching factor of the search space in state space based temporal
planning  here  we show that by using the idea of detecting compression safe actions 
one can significantly reduce the search space of the satisfiability checking based temporal
planning  as it is later explained in section      for each compression safe action a  we add
a clause to the sat formula to guarantee that the starting event of a is present in a step
if and only if the ending event of a is present in the same step  these clauses can be used
to prune the search tree when the sat solver is checking the satisfiability of the produced
formula 
crikey  considers action a to be compression safe if the following two conditions hold 
   

fiitsat  an efficient sat based temporal planner

 pre end a    inv a 
 del end a     
figure    a  shows a temporal plan that is executed to reach proposition q  in this example the ending event of action b does not have any precondition or delete effect  therefore 
crikey  considers b to be compression safe  however  if our goal is to produce q  the
singleton a    b  is not a compression safe set by definition     in fact  the method used
by crikey  has been specifically devised for the state space based temporal planners  and
cannot be easily employed by the sat based planners such as itsat  in contrast  as it is
later shown  our method can be easily used by both state space based temporal planners
and sat based planners 
there are also cases where the method used by crikey  cannot detect actions that
are compression safe according to definition     consider the plan depicted in figure   b   suppose that proposition p is the only member of the initial state  and the goal is
to produce proposition g  in this plan  actions a and b must be executed consecutively to
produce g  that is because p and q  which are respectively the overall conditions of a and
b are mutually exclusive  and can never be true together  however  neither a nor b has
the second property required by crikey  to be regarded as a compression safe action  in
this section we show how the mutex information can be used for detecting compression safe
actions 
definition     swappable events   let a and a be two different temporal actions  e be
the starting or ending event of a  and e be the starting or ending event of a   we say e and
e are swappable if all the following conditions hold 
 e and e do not have interference with each other  add e   del e      and add e   
del e     
 e and e do not have conflict with each other  del e    pre e    inv a       and
del e     pre e   inv a      
 e and e are not supporting each other  add e    pre e     inv a    add e       
and add e     pre e    inv a   add e       
according to definition     two events are swappable if there is no causal relation
between them  this means in any causally valid plan    he         e  e        en i  we can swap
e and e to reach another causally valid plan    he         e   e       en i  we can use such
swapping to reorder the events of a given causally valid plan without falsifying it 
consider a causally valid plan    he         en i  let ei and ej be the starting and
ending event of the same action  if all other events of this plan are swappable with ej  
then  by repeatedly swapping  one can reorder  to produce another causally valid plan
    he         ei   ej   ei          ej    ej          en i  in which ei and ej are two consecutive events 
therefore  here  a  is a compression safe set  in this case  we say that a is compressed
towards its start  similarly  if every event of the plan other than ei and ej is swappable
with ei   then  by repeatedly swapping  one can reorder  to produce the causally valid
plan     he         ei    ei          ej    ei   ej        en i  once again  we can conclude that  a  is
a compression safe set  in this latter case  we say that a is compressed towards its end 
   

firankooh   ghassem sani

figure    temporal actions that are not regarded as compressible by itsat  a  and crikey   b 

to find out whether it is safe to compress a given action a  there is no need to check if
all events are swappable with the starting and or ending events of a  in fact  by considering
the mutex relations obtained from the planning graph of the problem  we already know that
some events can never be executed while a is open  this information can be effectively used
to find out if a given set of actions is compression safe 
definition     compressible actions   let p    i  g  a  be a temporal planning problem  and a  a be a particular temporal action  we say that a is compressible towards its
start  if for every event e such that e is the starting or ending event of a  a   a   at least
one of the following conditions holds 
 a precondition or add effect of e is mutex with opena in the last layer of the leveled off
planning graph of the causal abstraction of p 
 e is swappable with end a  
   

fiitsat  an efficient sat based temporal planner

similarly  we say that a is compressible towards its end  if for every event e such that e is
the starting or ending event of a  a   a   at least one of the following conditions holds 
 a precondition or add effect of e is mutex with opena in the last layer of the leveled off
planning graph of the causal abstraction of p 
 e is swappable with start a  
theorem    let p    i  g  a  be a solvable temporal planning problem  let a be the set
of every member of a that is either compressible towards its start or compressible towards
its end  a is compression safe for p 
proof  see appendix a 
we now give an example for further clarification of this matter 
example    let p    i  g  a  be a temporal planning problem  where a is the set of
three temporal actions a  b  and c  consider the hypothetical causally valid plan depicted
in figure    a   where the execution of action a includes the execution of action b that in
turn includes the execution of action c  assume that a is compressible towards its start 
and b is compressible towards its end  we show how this plan can be converted to another
causally valid plan in which a  b  and c are being executed sequentially  figures    b  and
   c  show the results of doing two consecutive swaps by which b is compressed towards its
end  the starting event of b has been swapped with the starting event of c to transform
the plan of figure    a  into the plan of figure    b   since b is compressible towards its
end  this swapping cannot result in an invalid plan  similarly  the starting event of b has
been swapped with the ending event of c to transform the plan of figure    b  into the
plan of figure    c   figures    d  to    g  show the results of doing four consecutive swaps
by which a is compressed towards its start  as a result of doing these swaps  the fully
sequential plan shown in figure    g  is produced  this implies that even if a planner does
not allow the execution of any event while a or b is open  it will still be capable of producing
the temporally valid plan of figure    g  
for any given problem p    i  g  a   itsat computes the compression safe set a
of theorem    to check the first condition of definition     itsat needs to construct
a planning graph for the causal abstraction of p which  as we showed in the previous
subsection  can be done in polynomial time  for the second condition of definition     it
suffices to check every possible pair of events to see if they are swappable  since this can
be done for each pair in constant time  the total time will be o  a      we conclude that
finding a can be performed in polynomial time 
the method described here for finding compression safe actions can be used by statespace temporal planners  too  state space temporal planners can be divided into two categories  the first category includes the planners that are based on the so called decision
epoch planning method  cushing et al          examples of decision epoch planners are
tp   haslum         sapa  do   kambhampati         and tfd  eyerich et al         
   

firankooh   ghassem sani

figure    action compression

in this method  the start of each action is restricted to be immediately after the start or
end of another action  each state has an explicit time stamp  when an action is applied to
a state  the starting time of the action will be set to time stamp of that state  as a result 
once the starting event of an action is added to the plan  the time of its corresponding
ending event will be exactly known  when searching for a valid plan  in each state  the
   

fiitsat  an efficient sat based temporal planner

planner has to make a decision between either advancing to the time of the ending event of
an open action  or to open a new action  however  if we know that an action is compressionsafe  the planner can advance the time to the ending of that action and thereby prune the
search space  plans produced in this way might have larger makespans in comparison to
those produced without pruning the search space  nevertheless  the produced plans can
be rescheduled to find plans with improved makespans by the method we explain later in
section   
an alternative approach for the state space search is the so called temporally lifted
progression planning  which has been proved to be complete for pddl     fox   long 
       crikey  and popf are examples of the planners that are using this approach 
each state in the temporally lifted progression planning represents a permutation of a
number of events  at each state  the consistency of temporal constraints imposed by the
sequence of events in that state is checked by solving a simple temporal problem  stp  
similar to the decision epoch planning  in each state  there may exist two possible choices  to
add the ending event of an open action  or to open a new action  however  for compressionsafe actions  the ending event of actions can be applied immediately after the starting event 
which in turn reduces the future choices of the planner  we will show in section   that by
taking advantage of compression safe actions in this manner  the planner can still visit all
the stps of all causally valid permutations of events 
table   shows the comparison between the average percentage of actions regarded as
compression safe by our new method and the method used in crikey  and popf  in various temporal planning domains  we will explain more information regarding our benchmark
domains and problems later in section    at it can be seen in table    our compression
method can detect significantly more compressible actions in a number of benchmark domain 

   encoding phase
in this section  we explain how the abstract causal problem associated with a given temporal
problem is encoded into a sat formula  as in classical planning  there exist more than one
way to translate a particular planning problem into its corresponding sat formula  previous
investigations in the field of classical planning show that the choice of the encoding method
can have a major impact on the efficiency of a sat based planner  as mentioned earlier 
the most successful sat based classical planners have used special encoding methods that
are based on the so called  step and  step semantics of valid plans  rintanen et al         
in this section  we define the temporal versions of the classical  step and  step plans 
we also show how exactly these semantics can be used to translate a given temporal planning
problem into a sat formula  we introduce a  step encoding and two different types of
 step encodings in temporal planning  the  step and the first  step encoding methods
are temporal versions of the classical  step and  step encodings  similar to their classical
versions  in these new encodings  a few restrictive simplifying assumptions are assumed to
hold  our second type of the  step encoding  however  is obtained by relaxing one of these
assumptions  as we later show  this new  step encoding often requires fewer steps than the
other one  besides  as our experimental results show  among these new encoding methods 
the second  step encoding results in the best performance of itsat in terms of both speed
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

crikey 
  
  
   
 
   
   
   
   
   
   
   
   
  
  
   
  
   
   
  
  
  
  

itsat
   
   
   
  
   
   
   
   
   
   
  
   
  
  
   
  
  
  
  
  
  
  

table    average percentage of compressed actions
and memory usage of the planner  the necessary proofs of soundness and completeness of
our encoding methods are also given in this section 
    parallel semantics for causally valid plans
as mentioned earlier  the classical  step semantics permits the parallel execution of more
than one action in each step  only if the validity of the plan does not depend on the execution
order of those actions  this can simply be guaranteed by adding a particular clause for
each pair of mutually exclusive actions to ensure that such actions will not be included in
the same step  however  this strategy does not work in temporal planning  in temporal
planning  because of the temporal constraints imposed on the starting and ending events
of the actions  the validity of a particular ordering of events in a certain step  also depends
on the ordering of events in the other steps  nevertheless  in itsat this problem has been
tackled by separating the causal and temporal reasoning phases  in general  if we focus only
on finding causally valid plans  and postpone the scheduling phase  the mentioned problem 
about checking the feasibility of imposing different orderings of events in each step  will no
longer exist  we next introduce our semantics for causally valid  step and  step temporal
plans 

   

fiitsat  an efficient sat based temporal planner

definition     temporal  steps and  steps   let e    e         en   be a set of events 
and s  and s  be two temporal states  s is a temporal  step from s  to s  only if for all
one to one ordering functions o            n            n   i e   all permutations of events  
we have  s    succ s    heo           eo n  i   s is a temporal  step from s  to s  only if there
exist at least a one to one ordering function o            n            n   i e   at least one
permutation of events   such that  s    succ s    heo           eo n  i  
definition     causally valid  step and  step plans   let p    i  g  a  be a temporal planning problem  suppose s         sn is a sequence of temporal states such that s    i 
g  state sn    and agenda sn       if for each    i  n  stepi is a  step   step  from
si  to si   then we call the sequence    hstep         stepn i  a causally valid  step   step 
plan for p  we say that hs         sn i is the state transition sequence of  
classical  step and  step encodings  rintanen et al         are based on the  step
and  step semantics for classical valid plans  respectively  however  in the  step encoding 
for the sake of improving the efficiency of the planner  the following restrictive rules have
been also enforced on the semantics 
 rule    instead of accepting all possible orderings among the actions of each step 
only a fixed arbitrary ordering is allowed  as a result  by this rule  the execution of a
step necessitates the execution of its actions according to this fixed ordering 
 rule    preconditions of all actions of each step must be members of the state immediately before that step  similarly  the effects of all actions of each step must be
consistent with the state reached immediately after that step 
in this section  we present one  step and two  step encodings for planning in causal
abstractions of temporal planning  our encodings are based on the  step and  step
semantics for causally valid plans  definition      by considering events  instead of actions 
both of the above rules can be applied to temporal planning  too  while in our first  step
encoding  we respect both rules  in our second  step encoding  the second restrictive rule
is relaxed 
in fact  the second rule imposes some serious restrictions on the applicability of actions
in each step  for instance  it prevents a proposition from being both produced and used
in the same step of a plan  neither does it allow the deletion and production of any
particular proposition in the same step  by relaxing these restrictions  the encoding can be
more compact  i e   the relaxation permits more events to occur in each step  in classical
planning  a less relaxed form of rule   has been introduced so that the effects of actions
in each step can be used by other actions in that step  wehrle   rintanen         here 
however  we totally relax rule   and allow each proposition to be required  added  and
deleted many times in the same step 
before explaining our sat encodings  we first define sat variables and auxilary clauses
commonly used in our three encoding methods  let    hstep         stepn i be a causally
valid  step  or  step  plan for a given temporal planning problem p    i  g  a   and
hs         sn i be the state transition sequence of   in order to encode p into a sat formula
whose model can be translated back into   we use the following sat variables 
   

firankooh   ghassem sani

 for each proposition p  and each t such that    t  n  we define a sat variable pt  
assigning true  f alse  to pt implies that p is  is not  a member of state st   
 for each action a  a  and each t such that    t  n  we define a sat variable at  
assigning true  f alse  to at implies that a is  is not  a member of agenda st   
 for each event e such that e is the starting or ending event of an action in a  and
each t such that    t  n  we define a sat variable et   assigning true  f alse  to et
implies that e is  is not  a member of stept  
if a sat formula is satisfiable there exists a model for it  this model is a binary function
that assigns a value of true or f alse to each variable of the formula in such a way that the
formula is satisfied  for each of our encoding methods  if the produced formula has a
model m   one can easily translate m to a corresponding causally valid  step  or  step 
plan  using the description given above about the variables of the formula  we denote the
resulting plan by plan m    for showing the correctness of a particular encoding method 
two issues must be addressed  first  we must show that if there exists a causally valid
plan for the temporal problem p  then the encoding of p has a model  we call this the
completeness of our encoding method  second  we must show that if the encoding of p has
a model m   then plan m   is a causally valid plan for p  this is called the soundness of
our encoding method 
note that here  we prove the finite horizon completeness and not the  completeness for
our encodings  in other words  we prove that if there exists a  step  or  step  plan  with
l steps for a given problem  then the problem can be translated by our  step  or  step 
encoding into a satisfiable sat formula with at most l steps  so that the model of the formula
can be translated back into   on the other hand  proof of  completeness would need the
value of l to be determined  our proofs of the finite horizon completeness could have implied
the  completeness if at least an upper bound on the value of l had been determined  recent
research in the field of classical planning has shown that in some classical planning domains 
tight upper bounds on the length of optimal plans can be determined  rintanen   gretton 
       however  determining such upper bounds in temporal planning is beyond the scope
of the current work  to find a causally valid plan  itsat starts from an encoding with only
one step  and sequentially produces and tries to satisfy formulae with increasing number
of steps  until a satisfiable formula will be encountered or a predefined time limit will be
reached 
in classical sat based planning  in order to produce linear size encodings for  step
and  step semantics of valid plans  special sets of clauses  named chains  have been used
 rintanen et al          since we have also used these chains in itsat  the formal definition
of their temporal version is given here  let e         en be an arbitrary fixed ordering of all
events  e and r be two sets of events  k be a natural number  and m be special symbol
that assigns a unique name to the chain at hand  we define chain e         en   e  r  k  m  by
the conjunction of formulae  c    to  c    stated below 
 c   

v

 eki  bkj m  i   j  ei  e  ej  r   ei          ej     r    

 c   

v

 bki m  bkj m  i   j   ei   ej    r   ei          ej     r    
   

fiitsat  an efficient sat based temporal planner

 c   

v

 bki m  eki  ei  r 

the above formulae in fact encodes a message passing strategy  the symbol m specifies
the name of the message and is used to distinguish the sat variables of a certain chain
from those of other chains  the number k specifies the step whose variables are affected
by the message to be produced  the message may be produced by any member of e  the
receivers of the message are the members of r  if bki m is true  it means that message is
received by the i th event of the k th step of the formula  if ei is a member of e  and eki
is true  then a message will be produced and sent to ej   which is the first member of r
located after ei in the fixed ordering  this is represented in chain e         en   e  r  k  m  by
the clauses of the form eki  bkj m in formula  c     once the message is produced  it will be
transmitted forward according to the fixed ordering by the clauses of the form bki m  bkj m
in formula  c     if an event ei receives the message  its corresponding sat variable will
bef alse by the clauses of the form bki m  eki in formula  c     in fact  the members of r
that receive the message will certainly be excluded from the final plan 
we now present some examples to show how these chains are practically used to guarantee particular characteristics that the output plan will have 
example    assume that e    e    e    e  are four events  suppose that proposition x is
required by e  and e    deleted by e    and added by e    also assume that four propositions
p         p  are respectively added by e         e    consider the following two cases 
 case    we want to prevent proposition x from being both required and deleted in the
same step  say k  of the final plan  for this purpose  we can add the conjunction of
chain e         e    e  r  k  mx    and chain e         e    e  r  k  mx    to the formula  where e
is the set of all events that delete x  i e   e    e      and r is the set of all events that
require x  i e   r    e    e      note that mx  and mx  are two symbols that enable us to
distinguish between the sat variables used in these two different chains  in this case 
adding chain e         e    e  r  k  mx    will add the following formulae to the encoding of
the problem 
 ek   bk  mx
 



bk  mx
 



bk  mx
 

 bk  mx  ek 
 

 bk  mx  ek 
 

assume that there exists a model m for the produced sat encoding such that
m  ek      true  in this case  since m satisfies ek   bk  mx   we have m  bk  mx     true 
 
 
consequently  since m satisfies bk  mx  ek    we have m  ek      f alse  in other words 
 
if e  is a member of step k  then e  cannot be a member of the same step  similarly 
adding chain e         e    e  r  k  mx    will add the following formulae to the encoding of
the problem 
 ek   bk  mx
 

   

firankooh   ghassem sani

 bk  mx  bk  mx
 



bk  mx
 

 



ek 

 bk  mx  ek 
 

an argument similar to the one given for chain e         e    e  r  k  mx    shows that after
adding chain e         e    e  r  k  x     if e  is a member of step k  then e  cannot be a
member of the same step  as a result  by adding both mentioned chains to the sat
formula  if the execution of step k produces p    it then cannot produce p  or p    this
is actually how the occurrence of conflicting actions in each step of the final plan is
avoided by the linear size classical  step encoding  rintanen et al         
 case    we allow proposition x to be both required and deleted in a particular step
k only if the deleting event does not precede the requiring event in the fixed ordering
he    e    e    s  i  for this purpose  we only need to add chain e         en   e  r  k  mx   to
the formula  where e and r are the same as e and r in case    in this case  if the
execution of step k produces p    it can also produce p    but not p    this strategy  too 
was initially introduced for the linear size classical  step encoding  rintanen et al  
      
note that if one admits the second restrictive rule mentioned above  which is the case in
classical  step and  step encodings  no proposition can be added by an event in any step
while being deleted by another event in the same step  as a result  if the execution of step
k produces p    it cannot produce p  in any of the above cases 

    temporal versions of classical  step and  step encodings
we first present the temporal versions of the classical  step and  step encodings  similar
to their classical forms  in the temporal versions of these encodings  we assume an arbitrary
but fixed ordering e         en for all events of the given temporal problem p    i  g  a  
we also assume that the output plan will have a fixed number of steps  denoted by l 
let    hstep         stepl i be an output plan for p  and hs         sl i be the state transition
sequence of   for each event e  let action e  be the member of a whose starting or
ending event is equal to e  let p be the set of all propositions of p  for each proposition
p  p   let ep    e p  del e    ep     e p  add e   and rp    e p  pre e     e p 
inv action e    add e    moreover  assume that there are two dummy events e  and en    
which do not have any precondition  add effect  or delete effect 
      the  step encoding
given the temporal problem p    i  g  a   we produce the sat formula l   which is based
on the  step semantics of causally valid plans  for p by the conjunction of all formulae
described below 
v
      p   p  state i     p   p 
  state i  
v l
      p  p  g 
   

fiitsat  an efficient sat based temporal planner

    

v

 a   a  a 

    

v

 al  a  a 

    

v

 ek  pk       k  l  p  p  e  rp  

    

v

 ek  pk      k  l  p  p  e  ep   

    

v

    

v

     

v

     

v

     

v

 ek  ak   ak      k  l  a  a  e   start a  

     

v

 ek  ak   ak      k  l  a  a  e   end a  

 ek  pk      k  l  p  p  e  ep  
v
w
      pk   pk  eep  ek      k  l  p  p  
 pk   pk 

w

eep

ek      k  l  p  p  

 chain e         en     ep   rp   en      k  mp        k  l  p  p   
  bkn   mp  ak       k  l  p  inv a  
 

 chain en        e    ep   rp   e     k  mp        k  l  p  p   
  bk  mp  ak        k  l  p  inv a  
 

formula      indicates that any member of state s    is true iff it is present in the initial state  similarly  formula      states that all members of the goal state must be true in
state sl    formulae      and      imply that agenda s    and agenda sl   are both empty 
formulae      to      show that when an event is applied to step k  its preconditions must
be present in state sk     and its effects must be consistent with state sk    formulae     and      are responsible for encoding the so called explanatory frame axioms  formula
     implies that if p is present after but not before step k  then there must exist at least
one event in step k that has p in its add effects  similarly  formula      implies that if p is
present before but not after step k  then there must exist at least one event in step k that
deletes p  formulae       and       are added to guarantee that the events of each step
can be executed in any possible ordering  formula       implies that if p is deleted by an
event ei in step k  then p cannot be required by any other event ej of step k such that j   i 
it also implies that if p is deleted by any event in step k  and action a has p as an invariant 
then a cannot be a member of agenda sk    note that in chain e         en     ep   rp   k  mp   
used in formula        the value of bn   mp  indicates whether or not p is deleted by any
event in step k  the reason why we are using the dummy event en   is to have such an
indicator  analogously  formula       implies that if p is deleted by an event ei in step k 
then p cannot be needed by any other event ej of step k such that j   i  formula      
also implies that if p is deleted by any event in step k  and action a has p as an invariant 
then a cannot be a member of agenda sk     formulae       and       are responsible for
applying appropriate changes in the agendas of the states that are located before and after
each step of the final plan  formula       implies that if the starting event of an action a
is a member of the step k of the output plan  then a must be a member of agenda sk   but
not agenda sk     similarly  formula       implies that if the ending event of action a is a
   

firankooh   ghassem sani

member of step k of the plan  then a must be a member of agenda sk    but not agenda sk   
theorem    completeness of temporal  step encoding   let p    i  g  a  be a
solvable temporal planning problem   e         en   be the set of all events of p  and   
hstep         stepl i be a causally valid  step plan for p  there exists a model m for l such
that    plan m   
proof  see appendix a 
theorem    soundness of  step encoding   let p    i  g  a  be a temporal planning
problem   e         en   be the set of all events of p  and l be the  step encoding for p  if
l has a model m   then plan m   is a causally valid  step plan for p 
proof  see appendix a 
      the  step encoding
in this part  we present the sat formula l   which is based on the  step semantics of
causally valid plans  by considering the two restrictive rules stated above  our  step
encoding is very similar to the  step encoding described previously in this section  however 
there are two major differences between these two kinds of encoding  first  our  step
encoding allows each proposition to be both required and deleted in each step  provided
that the deleting event does not precede the requiring event in the fixed ordering he         sn i 
this is in contrast with our  step encoding  where a proposition could not be both deleted
and required in the same step of the final plan  second  in our  step encoding  each
step may also contain both the starting and ending event of the same action  given the
temporal problem p    i  g  a   we produce the sat formula l   which is based on the
 step semantics of causally valid plans  for p by the conjunction of all formulae described
below 
v
      p   p  state i     p   p 
  state i  
v l
      p  p  g 
v
      a   a  a 
v
      al  a  a 
v
      ek  pk       k  l  p  p  e  rp  
v
      ek  pk      k  l  p  p  e  ep   
v
      ek  pk      k  l  p  p  e  ep  
v
w
      pk   pk  eep  ek      k  l  p  p  
    

v

 pk   pk 

w

     

v

 chain e         en     ep   rp   en      k  mp        k  l  p  p      bkn   mp 

eep

ek      k  l  p  p  
 

ak       k  l  p  inv a  
   

fiitsat  an efficient sat based temporal planner

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

 eki  ak       k  l  a  a  ei   start a   ej   end a   i   j 
 eki  ak  ekj      k  l  a  a  ei   start a   ej   end a   i   j 
 ekj  ak      k  l  a  a  ei   start a   ej   end a   i   j 
 ekj  ak   eki      k  l  a  a  ei   start a   ej   end a   i   j 
 eki  ak   ekj      k  l  a  a  ei   start a   ej   end a   j   i 
 eki  ak      k  l  a  a  ei   start a   ej   end a   j   i 
 ekj  ak  eki      k  l  a  a  ei   start a   ej   end a   j   i 
 ekj  ak       k  l  a  a  ei   start a   ej   end a   j   i 
 ak   ak  eki      k  l  a  a  ei   start a  
 ak   ak  ekj      k  l  a  a  ej   end a  

note that formulae      to      are exactly the same as formulae      to       similar
to our  step encoding  these formulae are responsible for the validity of the initial state  goal
state  conditions and effects of events  and also for the explanatory frame axioms explained
before  moreover  notice that while formula       is also present in our  step encoding as
formula        formula       is not present in l   this results in the first major difference
stated above between our  step encoding and  step encoding  formulae      to      
enforce appropriate changes to agenda sk    and agenda sk    which are the agendas of the
states immediately before and after step k of the final plan  according to their definitions 
formulae       to       are added for each action a with the property that start a  is
located before end a  in the fixed ordering he         en i  formula       ensures that a can
be started in step k  only if it is not open in sk    formula       guarantees that if a is
started but not ended in step k  it must be open in sk   formula       ensures that if a
is ended in step k  it will not be open in sk   formula       implies that if a is ended but
not started in step k  then it must be open in sk    analogously  formulae       to      
guarantee similar properties for each action a with the property that start a  is located
after end a  in the fixed ordering he         en i  formula       ensures that if a is a member
of agenda sk   but not agenda sk     it must be started in step k  similarly  formula      
ensures that if a is a member of agenda sk    but not agenda sk    it must be ended in step
k 
since our  step encoding conforms to the two restrictive rules stated earlier in this
section  there may exist a  step causally valid plan with l steps for a given problem while
l would be unsatisfiable for the same problem  this is also the case in the linear size step encoding of the classical planning problems  rintanen et al          however  since we
showed by theorem   that our  step encoding is complete  the completeness of our  step
encoding can be proved by showing that the satisfiability of l entails the satisfiability of l  
theorem    completeness of  step encoding   let p    i  g  a  be a solvable temporal planning problem   e         en   be the set of all events of p  and    hstep         stepl i
be a causally valid  step plan for p  there exists a model m for l such that    plan m   
   

firankooh   ghassem sani

proof  see appendix a 
theorem   also shows that in our  step encoding  the number of required steps to
solve a temporal planning problem is less than  or equal to  what is required by our  step
encoding  in other words  our  step encoding is more compact than its  step counterpart 
theorem    soundness of  step encoding   let p    i  g  a  be a temporal planning
problem   e         en   be the set of all events of p  and l be the  step encoding for p  if
l has a model m   then plan m   is a causally valid  step plan p 
proof  see appendix a 
    the relaxed  step encoding
as we mentioned in section        our  step encoding allows each proposition to be both
required and deleted by any two events of the same step  only if the deleting event does not
precede the requiring event in the fixed ordering he         en i  besides  since formulae     
and      are present in both of our  step and  step encodings  no proposition can be
both added and deleted in the same step of these encodings  these restrictions  which are
also present in the classical  step and  step encodings  rintanen et al          are lifted in
our new relaxed version of  step encoding  as a result  each proposition can be required 
added  and deleted in any step as many times as it is needed  this property has not been
previously examined in classical  step encoding  and consequently  the chaining mechanism
explained in section     is not compatible with it  here  we introduce a generalized version
of the chains and explain the conceptual difference with those used in classical encodings 
we also present new kinds of chains to be used specially in temporal planning for preserving
the invariants of temporal actions while the plan is being produced  note that  similar to
our non relaxed  step encoding  here we assume that the events of each step are executed
according to a fixed ordering he         en i 
let k be a natural number and e         en be a fixed ordering of all events  for some reasons to be discussed later  we assume that if ei is the starting event of an action  then ei  
is the ending event of that action  in other words  we assume that the ending event of each
action is located immediately after its starting event in the fixed ordering  note that here 
we do not demand the end of an action to immediately follow its start in the final plan  we
only put this constraint on the fixed ordering  this cannot compromise the completeness of
itsat  the sat solver can still choose the start of an action a from step k  choose whatever
actions are needed from steps k to k   m for an arbitrary m  and then choose the end of a
from step k  m  moreover  suppose that there are two dummy events e  and en     which do
not have any precondition  add effect  or delete effect  let p be the set of all propositions of
p  for each proposition p  p   let ep    e p  del e    ep     e p  add e    op    e p 
inv action e      e    en      and rp    e p  pre e     e p  inv action e    add e   
we define chain  e         en     ep    ep   rp   k  mp   by the conjunction of formulae  c     to
 c     stated below  note that mp is a symbol used for distinguishing the sat varibales
used in the formula chain  e         en     ep    ep   rp   k  mp   from other variables used in other
formulae 

   

fiitsat  an efficient sat based temporal planner

 c    

v

 eki  bkj mp  i   j  ei  ep    ej  rp  ep    ei          ej      rp  ep      

 c    

v

 eki  bkj mp  i   j  ei  ep   ej  rp  ep     ei          ej      rp  ep       

v

 bki mp  bkj mp  i   j  ei  rp   ep   ep    ej  r  ep   ep    ei          ej    
 rp  ep   ep      
v
 c       bki mp  eki    bkj mp  i   j   ei   ej    rp  ep   ep    ei          ej      rp  ep  
ep      
v
 c       bki mp  eki    bkj mp  i   j   ei   ej    rp  ep   ep    ei          ej      rp 
ep   ep      
v
 c      bki mp  eki  ei  rp  

 c    

 c     bk  mp  pk 
 c     bkn   mp  pk
in fact  chain  e         en     ep    ep   rp   k  mp   encodes a message passing method that is
different from that of chain e         en   e  r  k  m   in chain  e         en     ep    ep   rp   k  mp   
the conveyed message is in fact the value of proposition p  and is therefore either true or
f alse  similar to the message passing strategy of chain e         en   e  r  k  m   the received
message is transferred only in the forward direction of the fixed ordering e         en   each
event in ep    ep   or rp receives a message from its previous event in the fixed ordering 
every event may or may not change the value of the received message  in either cases  the
message is then passed to the next event  the events in ep  can only change the value
of the received message to true  as these events have p in their add effects  similarly  the
events in ep can only change the value of the received message to f alse  the formulae
 c     and  c     impose such changes on the value of a received message  if an event is
not a member of ep  or ep   it neither adds nor deletes p  and thus  it will pass the received
message without altering its value  this is enforced by  c       c     and  c     ensure
that received messages are passed without being changed by those events that are not to
be chosen for stepk of the output plan  according to  c      if an event in rp receives a
message with the value of f alse  the event cannot be chosen as a member of stepk   that
is because members of rp require p  which necessitates their received messages to have a
value of true   c     implies that the initial value of the message produced in stepk is equal
to the value of p in the state immediately before the execution of stepk   similarly   c    
implies that the value of p in the state immediately after the execution of stepk will be
equal to the final value of the message in stepk  
example    consider the same events given in example    let e   be the set of events
that add x  i e   e      a      e  be the set of events that delete x  i e   e     a     
and r be the set of events that require x  i e   r    a    a      moreover  suppose that
there are two dummy events e  and e    which do not have any precondition  add effect  or
delete effect  assume that we have added chain  e         e    e     e    r   e    e     k  mx   to
   

firankooh   ghassem sani

the sat formula  according to formulae  c     to  c      this chain is the conjunction of
the following formulae 
 ek   bk  mp
 ek   bk  mp
 bk  mp  bk  mp
 bk  mp  bk  mp
 bk  mp  bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek   bk  mp
 bk  mp  ek 
 bk  mp  ek 
 bk  mp  ek 
 bk  mp  ek 
 bk  mp  xk 
 bk  mp  xk
   

fiitsat  an efficient sat based temporal planner

a straightforward examination shows that we can have a model m for the chain mentioned above such that m  ek      m  ek      m  ek      m  ek      m  ek      m  ek      true 
m  bk  mp     m  bk  mp     m  bk  mp     m  bk  mp     m  bk  mp     true  and m  bk  mp     f alse 
in other words  if x is deleted by e  in stepk of the final plan  it can later be produced again
by e    and as a result  e  can appear in stepk   too  here  m  bk  mp     f alse represents the
fact that x has been deleted after the execution of e    in this example  all four propositions
p    p    p    and p  can be produced by a single step of the final plan  note that in neither
of the cases of example    producing all these propositions by only one step was possible 
this is an example of how our new  step encoding  which employs the generalized message
passing strategy  can permit more parallelism than is allowed by the temporal versions of
classical  step and  step encodings 
in addition to chain  e         en     ep    ep   rp   k  mp    which is responsible for tracking
the value of p inside stepk   we also need some extra formulae to prevent p from being deleted
whenever p is an invariant of an open temporal action  therefore  we introduce two new
ob

ob
chain formulae  chainof  e         en     ep   op   k  mof
p   and chain  e         en   ep   op   k  mp   
formula chainof  e         en     ep   op   k  mof
p   is produced by the conjunction of formulae
of
of
 c     to  c      similar to the chains explained before  mof
p is a symbol used to distinguish the sat varibales of this chain from those of other formulae 
v
 cof      eki  bk of  i   j  ei  ep   ej  op    ei          ej     op    
j mp

 cof    

v

 bk

 cof    

v

  bk

 ekj    eki  ei  op   ei   start a   ej   end a  

 cof    

v

  bk

 ak    eki  a  a  ei   start a   ei  op  

i mof
p

 bk

j mof
p

j mof
p

n   mof
p

 i   j   ei   ej    op    ei          ej     op    

similar to chain e         en   ep   rp   k  mp    chainof  e         en   ep   op   k  mof
p   represents a
message that is produced and sent in the forward direction of the fixed ordering  whenever a
proposition p is deleted by an event   cof     and  cof     are responsible for the production
and propagation of the mentioned message  respectively  by  cof      if the ending event of
an action a with p as its invariant receives this message in step k  then step k must also
include the starting event of a  in these cases   cof     prevents a from being open when p
is deleted  that is because we assume that in the fixed ordering  the ending event of each
action is located immediately after its starting event   cof     guarantees that if p is deleted
somewhere in step k  and an action a with p as its invariant is open after step k  then step
k must also include the starting event of a  otherwise  a is open everywhere in step k  and
thus  p  which is an invariant of a  is deleted while a is open  
in chainof  e         en     ep   op   k  mof
p    the message that indicates p is deleted is only sent
forward  thus  it cannot help preserving the invariants of those members of op that
are started prior to the deletion of p  to tackle this problem  we add another chain 
namely chainob  e         en   ep   op   k  mob
p    to the formula  this chain is quite analogous to
of
of

chain  e         en     ep   op   k  mp    that whenever p is deleted by an event  the chain sends
   

firankooh   ghassem sani

the message backward according to the fixed ordering  chainob  e         en   ep   op   k  mob
p   is
ob
ob
produced by the conjunction of formulae  c     to  c     
 cob    

v

 eki  bkj mob  j   i  ei  ep   ej  op    ej          ei     op    

 cob    

v

 bki mob  bkj mob  j   i   ei   ej    op    ej          ei     op    

 cob    

v

  bki mob  eki    ekj  ei  op   ei   start a   ej   end a  

 cob    

v

  bk  mob  ak     ekj  a  a  ej   end a   ej  op  

p

p

p

p

p



we now present the sat formula l   which represents our relaxed  step encoding and

is based on the  step semantics of causally valid plans  l is produced by the conjunction
of all formulae described below 
v
       p   p  state i     p   p 
  state i  
v
       pl  p  g 
v
       a   a  a 
v
       al  a  a 
v
       chain  e    e         en     ep    ep   rp   e    en      k  mp       k  l  p  p  
     

v

 chainof  e         en     ep   op   k  mof
p       k  l  p  p  

     

v

 chainob  e         en   ep   op   k  mob
p       k  l  p  p  

     

v

     

v

 eki  ak       k  l  a  a  ei   start a  

      

v

 ekj  ak      k  l  a  a  ej   end a  

      

v

 ekj  ak   eki      k  l  a  a  ei   start a   ej   end a  

      

v

      

v

 ak   ak  eki      k  l  a  a  ei   start a  

 eki  ak  ekj      k  l  a  a  ei   start a   ej   end a  

 ak   ak  ekj      k  l  a  a  ej   end a  

      ensures that any member of state s    is true if and only if that member is present in
the initial state  similarly        guarantees that all members of the goal state are true in
state sl          and       imply that agenda s    and agenda sl   are both empty        
as explained before  is responsible for imposing appropriate changes in the value of the sat
variables  whenever proposition p is added or deleted by an event in a certain step of the
output plan        and       prevent the invariants of an action a from being deleted
while a is open        to        are responsible for enforcing the appropriate changes to
agenda sk    and agenda sk    which are agendas of the states immediately before and after
   

fiitsat  an efficient sat based temporal planner

step k of the output plan        ensures that a can be started in step k only if it is not
open in sk          indicates that if a is started but not ended in step k  then it has to be
open in sk          ensures that if a is ended in step k  it will not be open in sk         
implies that if a is ended but not started in step k  then it has to be open in sk          
ensures that if a is a member of agenda sk   but not a member of agenda sk     then a is
started in step k  similarly         ensures that if a is a member of agenda sk    but not
agenda sk    then a is ended in step k 
by theorem    we know that if a temporal planning problem p is satisfiable  then there
exists a positive number l  such that the non relaxed  step encoding of p with l steps
 i e   l   is satisfiable  accordingly  the completeness of our relaxed  step encoding can be

proved by showing that if l is satisfiable then l will also be satisfiable 
theorem    completeness of the relaxed  step encoding   let p    i  g  a  be a

temporal planning problem and formulae l and l be two  step encodings of p explained

above  if m is a model for l   then l has a model m  such that plan m      plan m   
proof  see appendix a 
theorem   also shows that  in our   step encoding  the number of required steps to
solve a temporal planning problem is less than  or equal to  what is required by our  step
encoding  provided that the same fixed ordering has been used in these two encodings  in
other words  our   step encoding is more compact than our  step encoding 
theorem    soundness of the relaxed  step encoding   let p    i  g  a  be a

temporal planning problem   e         en   be the set of all events of p  and l be the relaxed

 step encoding for p  if l has a model m   then plan m   is a causally valid  step plan
p 
proof  see appendix a 
    mutual exclusion relations and action compression
as we mentioned earlier in section    the performance of any sat based temporal planner
can be improved by mutual exclusion analysis and action compression  in this section 
we show how the information obtained by these tasks has been utilized in itsat  let
p    i  g  a  be a temporal planning problem  mu t be the set of all mutually exclusive
pairs of propositions of p  and com be the set of all compression safe actions of p  see

section     let l be the encoding of p  which can be any of l   l   or l   for taking
advantage of mutual exclusion relations  we add an extra formula mut
to l   where mut
 
l
l
v
k
k
 p  q   p  q   mu t      k  l   as theorem   shows  two mutually exclusive
propositions p and q can never be both true in any state that is achieved by the execution
of a valid temporal plan starting from i  as a result  adding mut
to the encoding cannot
l
render the planner incapable of finding valid plans 
let a  a be a compression safe action  as it was showed in section      it is safe
to assume that in any causally valid plan  the ending event of a occurs immediately after
its starting event  one way to impose such constraint is to add some extra clauses to the
   

firankooh   ghassem sani

encoding to guarantee that both starting and ending events of a are always included in the
same step  however  these two events may have conflicting effects  in which case l and
l will not allow such events to be both present at any step  therefore  the information

regarding compression safe actions is only added
to our relexed  step encoding  l   this
v

is done by adding com
to l   where com
   eki  eki    a  com  ei   start a     
l
l


k  l   note that in l   if ei is the starting event of an action  ei   denotes its ending
event 

   scheduling phase
in this section  we describe how a causally valid plan is augmented by temporal information
to produce a valid temporal plan  let    he         en i be a causally valid plan produced by
our planner  the scheduling of  is done by defining the scheduling function  of definition
   which assigns a rational number to each event of  as its execution time  suppose that
we have given different names to different occurrences of the same action in this plan  so
all the events e         en are unique  we can assume that for each i    i      i       and
thereby satisfy the first condition of definition    however  this can lead to the plans with
unnecessarily large makespans  alternatively  for obtaining plans with improved quality 
we impose a more relaxed set of constraints on the function   
definition     relaxed scheduling functions   let  be a causally valid plan  the
scheduling function  is a relaxed scheduling function if it has the following properties 
 s    for all i and j such that ei is located before ej in   and ei is not swappable with ej
 cf  definition      we require that   i      j  
 s    for all i and j  if ei is the starting event of a particular action a  and ej is the pairing
event of ei in   cf  definition     we require that   j      i    dur a  
theorem    let p    i  g  a  be a temporal planning problem     he         en i be a
causally valid plan for p  and             n   q be a relaxed scheduling function for  
there exists a valid temporal plan for p 
proof  see appendix a 
theorem   shows that whenever a relaxed scheduling function exists for a causally valid
plan of p  a valid temporal plan can be produced for p  to prove that our scheduling
method does not render itsat incomplete  we also need to show that if p is solvable 
our planner will be able to produce a causally valid plan  and a scheduling function 
such that  is a relaxed scheduling function for   let       be a valid temporal plan
for p  every causally valid plan can also be regarded as a causally valid  step plan with
singleton steps  therefore  by theorem    l has a model m such that    plan m   

by theorem    m also satisfies l   moreover  by theorem    l has a model m  such
that    plan m      plan m    therefore  if any of our encoding methods are used for
translating p to a sat formula  the resulting formula has a model that will be translated
to   on the other hand  according to definition     satisfies all constraints of the form
 s    and  s     and therefore  is a relaxed scheduling function of   however  as mentioned
   

fiitsat  an efficient sat based temporal planner

in section        we may add certain clauses to the encoding to ensure that the produced
causally valid plan is always compressed  definition      we now show that for each solvable temporal plan  there exists a compressed causally valid plan that can be scheduled to
a valid temporal plan by a relaxed scheduling function 
theorem     let p    i  g  a  be a solvable temporal planning problem  and com
be the set of every member of a that is either compressible towards its start or compressible towards its end  definition      there exists a valid temporal plan       for p such
that  is a causally valid plan for p   is compressed with respect to com  and  is a
relaxed scheduling function for  
proof  see appendix a 
to check the existence of the function  with the properties stated above  we solve an
instance of a simple temporal problem  stp   dechter et al          each stp is associated
with a weighted graph named a simple temporal network  stn   we construct an stn in
which node xi corresponds to the event ei in the causally valid plan   let  be an arbitrary
small rational number  for each constraint of the form   i      j   we add an edge with
the weight  from xi to xj   for each constraint of the form   j      i    dur a   we
add an edge with the weight  dur a  from xi to xj   and another edge with weight dur a 
from xj to xi   we also add a reference node x  to the constructed stn  x  has an edge
with the weight   to every other node  a solution of any stp can be found by computing
the length of the shortest path form x  to all other nodes  dechter et al          suppose
that such shortest paths exist and the length of the shortest from x  to xi is shown by
distance x    xi    for each event ei   we define   i  to be equal to distance x    xi    in
this case  theorem   guarantees that the resulting plan has all the specifications of a valid
temporal plan 
to see the intuition behind the explained method of defining the function    suppose that in the constructed stn  there is an edge with the weight  from xi to xj  
this means that distance x    xj    distance x    xi      which implies distance x    xi   
distance x    xj      this  in turn  implies that distance x    xi     distance x    xj   
and   i      j   similarly  it can be easily shown that if there exists an edge with the
weight  dur a  from xi to xj   and another edge with weight dur a  from xj to xi   then
we will have    j      i    dur a   bellman ford algorithm  cormen  leiserson  rivest 
  stein        can be used to find all single source shortest paths of any weighted graph
in polynomial time  besides  the number of the nodes of the produced stn is equal to
the number of events of the causally valid plan  therefore  we can conclude that  if the
mentioned shortest paths exist    i  can be computed in polynomial time 
however  there are situations in which such shortest paths do not exist  it happens when
the corresponding stn has a negative cycle  in these situations  the stp is inconsistent
and consequently  all the temporal constraints cannot be satisfied at the same time  an
example of such a case is depicted in figure    
in figure     action a adds propositions p and g by its starting and ending events 
respectively  a needs proposition q as a precondition for its ending event  action b requires
p upon starting and adds q upon ending  durations of actions a and b  are   and    
respectively  the goal of planning is reaching fact g  for this problem     has   bs   be   ae i
   

firankooh   ghassem sani

figure     negative cycles

is a causally valid plan  where as   start a   ae   end a   bs   start b   be   end b   this
plan is depicted in figure     a   in this plan  the execution of action b must be entirely
inside that of action a  i e   b is started after starting a and is ended before ending a  
however  this is impossible considering the fact that the duration of a is less than that of
b  the invalidity of this plan is caused by the fact that while producing this causally valid
plan  all the durations are abstracted out  the stn constructed for the plan of figure
    a  is depicted in figure     b   as bs be ae as is a negative cycle with the total weight of
     
    negative cycle prevention
if the stn of a causally valid plan includes a negative cycle  the plan cannot be transformed
into a valid temporal plan  in such cases  the sat solver will be forced to find a different
solution  this can be done by adding an extra clause such that at least one of the events
of the current negative cycle will be prevented from occurring in its current step  however 
after adding such a blocking clause  the planner can still produce new plans that are basically
equivalent to the previous plan  for instance  consider the example given in figure    
suppose as   bs   be   and ae are members of steps   to    respectively  assume that the
output plan is to have   steps  if we forbid the exact occurrence of the negative cycle  a
   

fiitsat  an efficient sat based temporal planner

new causally valid plan can still be produced by shifting ae to layer   and maintaining all
other events in their current steps  the new solution will have the same negative cycle and
therefore cannot be transformed to a valid temporal plan  in fact  here the cause of the
invalidity of the plan has not changed  we now show how by exploiting the simple structure
of negative cycles  one can prevent the reoccurrence of such cycles more effectively 
from the discussion given above  it should be clear that the main reason that such
negative cycles are encountered in the stn of a particular causally valid plan  is some
specific order of events in that plan  in fact  if the events of any negative cycle reoccur with
the same order in a new causally valid plan  the new plan will include the same negative
cycle  too 
for any temporal planning problem p  p
we can regard the set of all possible sequences
of events as a language over the alphabet
   e         en    where n is the number of all
events of p  the set of all sequences of events in which certain p
events have appeared in
a particular order can also be regarded as another language over   it is straightforward
to show that this latter language is in fact a regular language and can be accepted by a
finite state machine  fsm   figure     c  shows a finite state machine that detects the
sequences of events in which as   ae   bs   and be appear according to the order has   bs   be   ae i 
note that  for the sake of clarity  the self loop transitions of the finite state machine are
not shown in figure     c  
p
definition     fsms   ap
finite state machine  is a   tuple  s     t   xp
    a    where
s is a finite set of states 
is a finite set of alphabet symbols  t   s 
 s is a
mapping defining all transitions of   x   s is the starting state  and a  s is a set of
accepting states 
we now show how by adding certain formulae to our sat encodings  one can avoid
the members of a given regular language
from being produced as causally valid plans  let
p
p be a temporal problem p
and
   e         en   be the set of all events of p  let l be
any regular
  assume that l is accepted p
by the finite state machine
p langaue over
out
 t  xi   e    xj   i    j  and
    s    p
t   a    for each xi  s   let ei    e 
eiin    e 
 t  xj   e    xi   i    j   assume that there are two dummy events e  and
en     which do not have any precondition  add effect  or delete effect  we define the sat
variable xk i for    k  l     i  n      and x  s   assigning a value of true to xk i
means that  will be in state x  after operating on the sequence of all events of the steps  
to k    and the events of step k with the indices less than i of the final plan  we construct
the formula 
l by the conjunction of formulae      to      stated below 
    

v

k j
out  e in   e
 eki  xk i
s  xt     k  l  i   j  t  xs   ei     xt   ej  et
n     
t
in
out
 ei          ej      et  et      

    

v

    

v

k j
in
out
out
 eki  xk i
s  xs     k  l  i   j  ei  es   ej  es  es   en     
in
out
 ei          ej      es  es      

k i
in
out
 xk  
s  xs     k  l     i  n  xs  s   ei  es  es  
in
out
 e         ei      es  es      

   

firankooh   ghassem sani

    

v

 xk n  
 xk    
    k   l  xs  s  
s
s

    

v

 xk i
      k  l     i  n 

    

v

 xk i  x  a      k  l     i  n     

adding 
l to the encoding of a problem makes the sat solver to somehow simulate
the behavior of   while finding a model that represents a causally valid plan  assume that
observing ei causes  to make a transition from xs to xt   moreover  let ej be the first event
after ei  according to the fixed ordering e         en   that may cause a transition to or from
xt   formula      guarantees that if ei is a member of stepk   and  is at state xs at the
time of observing ei   then the state of  will be changed to xt   and the next relevant event
of xt  i e   ej   will become aware of this transition       implies that if ei is not a member
of stepk   and  is at state xs at the time of observing ei   then  will remain at xs   and
the next relevant event of xs will become aware of the current state of        causes the
information regarding the state of  at the start of each step to be propagated to the first
relevant event of that step       propagates the information regarding the state of  at
the end of each step to the next step       ensures that  can be at its starting state
at any place of the final plan  this means that the simulation of  can be started from
anywhere in the plan that is being produced  this enables the sat solver to detect not
only the strings accepted by   but also strings that have some subsequences accepted by
  finally       guarantees that  will never be at one of its accepting states 

example    let  be the finite state machine depicted in figure     c   this finite
state machine detects the sequences of events in which as   ae   bs   and be appear according
to the order has   bs   be   ae i  assume that we have four events  e    as   e    ae   e    bs   and
e    be   also assume that there are two dummy events e  and e    for the sake of simplicity 
suppose that the problem does not have any events other than e  to e    and the encoding has
only two steps  consider a boolean assignment m   such that m  e       m  e       m  e      
m  e       true  and m  e       f alse  in other words  m is choosing as   bs   and be from the
first step  and ae from the second step  in fact  we have plan m     has   bs   be   ae i  in this
example  we have e in    e     because e    ae is the only event that causes a transition to
state s  of   similarly  we have  e out    e     e in    e     e out    e    e     e in    e    
e out    e    e     e in    e     e out    e     e in    e     and e out     we show that if we
use the formulae      to      stated above to encode   then m cannot be a model for
the produced sat formula  we show this by contradiction  assume that m is a model for
the produced sat formula 
 s  is the starting state of   hence  according to       we have m  s         true 
which means that  is in state s    prior to checking whether e  is present in the first
step of the final plan 
 
 s   
 according to       we have e    s   
    since we have m  e      true and
 
   
m  s   
      true  we must also have m  s      true  in other words   verifies that e 
is present in the first step of the final plan  which causes the current state of  to be

   

fiitsat  an efficient sat based temporal planner

changed from s  to s    m  s   
      true implies that  is in state s    prior to checking
whether e  is present in the first step of the final plan 
   
 
 according to       we have e    s   
   s    since we have m  e      f alse and
   
   
m  s      true  we must also have m  s      true  in other words   verifies that
e  is not present in the first step of the final plan  which causes the state of  to
remain s    m  s   
      true implies that  is in state s    prior to checking whether e 
is present in the first step of the final plan 
 
 according to       we have e    s   
 s   
 
    since we have m  e      true and
   
   
m  s      true  we must have m  s      true  in other words   verifies that e  is
present in the first step of the final plan  which causes the state of  to be changed
from s  to s    m  s   
      true implies that  is in state s    prior to checking whether
e  is present in the first step of the final plan 
 
 s   
 according to       we have e    s   
    since we have m  e      true and
 
   
m  s   
      true  we must have m  s      true  in other words   finds out that e  is
present in the first step of the final plan  which causes the state of  to be changed
from s  to s    m  s   
      true implies that  is in state s    after visiting all events of
the first step of the final plan 
   
   
 according to       we have s   
   s    since we have m  s      true  we must also
have m  s   
      true  which implies that  is in state s    prior to visiting any event
of the second step of the final plan 
   
   
 according to       we have s   
   s    since we have m  s      true  we must also
have m  s   
      true  which implies that  is in state s    prior to checking whether e 
is present in the second step of the final plan 
 
 s   
 according to       we have e    s   
    since we have m  e      true and
 
   
m  s   
      true  we must also have m  s      true  in other words   verifies that
e  is present in the second step of the final plan  which causes the state of  to be
changed from s  to s    m  s   
      true implies that  is in state s    after visiting all
events of the first two steps of the final plan  on the other hand  s  is an accepting
state of   hence  according to       we have m  s   
      f alse  this is clearly a
contradiction  therefore  we can conclude that m cannot be a model for the produced
sat formula 

we now prove that adding 
l to the encoding of the given problem  prevents the planner
from producing those causally valid plans with a subsequence of events that is equivalent to
any string accepted by   this means that once a negative cycle has been translated into
an fsm  the reoccurrence of the negative cycle can be avoided by translating that fsm
into a sat formula  and adding the formula to the encoding of the problem 
p
theorem     let p    i  g  a  be a temporal planning problem 
   e         en   be the




set of all events of p  l be any of the three formulae l   l   l  defined in section
p     and 
be a non empty causally valid plan for p obtained by solving l   let     s     t   x    a  
   

firankooh   ghassem sani

be an fsm that accepts a subsequence     he         em i of   and 
l be the encoding of
 presented by      to       there does not exist any model m for l  
l such that
   plan m   
proof  see appendix a 
we also need to show that adding 
l to the encoding will not render our planner incapable of producing those plans that do not contain any subsequence accepted by  
p
theorem     let p    i  g  a  be a temporal planning problem 
   e         en   be

the set of all events of p  and l be any of the three formulae l   l   l  defined in
section     let m be a model that satisfies l   and    he         em i   plan m    let
p
    s     t   x    a   be an fsm that does not accept any subsequence of   and 
l be


the encoding of  composed of      to       there exists a model m for l  l such
that    plan m    
proof  see appendix a 
we now explain how a sequence of events that introduce a negative cycle in the stn of a
causally valid plan can be used to prevent similar negative cycles from reoccurringp
in future
plans produced for the problem at hand  let p be a temporal planning problem 
be the
set of all events of p  and    e         en be a causally valid plan for p  assume that the stn
representing the scheduling function of  has a negative cycle n with nodes xi         xim   note
that xik is the node corresponding to event eik of   without loss of generality  we assume
that i          im   i e   the events of the negative cycle are ordered by the same order that
that are started but not finished
they have in   let oik be the set of all temporal actions p
 e action e   oik     eik   
before reaching eik in the sequence ei         eim   and p
ik  
consider the regular language ln over the alphabet
defined by ln   ei  i  ei     im eim  
where ik denotes any string of the symbols in ik   in fact  in the strings of ln   events other
than those already present in the current negative cycle can be inserted in the sequence in
such a way that the temporal constraints among ei         eim remain unchanged  to see why
we exclude the events of open actions from ik   consider two hypothetical events eij and eij 
that are respectively the starting event and the ending event of an action a  therefore  there
is a temporal constraint on the scheduling function  in the form of   ij     ij     dur a  
here  if we insert another copy of the ending event of a between these two events  then a is
ended before the execution of eij  and  as a result  eij  will no longer be the pairing event
of eij   and the mentioned constraint will no longer exist 
theorem     let n   xi         xim be a negative cycle in the stn corresponding to a
causally valid plan    e         en of a temporal problem p  where xik is the node corresponding to event eik of   let   be another causally valid plan for p  if a subsequence of
  is a member of ln  defined above   the corresponding stn of   will also have n as a
negative cycle 
proof  see appendix a 
   

fiitsat  an efficient sat based temporal planner

consrtucting an fsm that accepts ln is straightforward  let  be that fsm  theorem
   shows that if  is added to the encoding of the input problem  itsat will still be
capable of finding a valid temporal plan  provided that such a plan exists 

   empirical results
in this section  we show how our preprocessing  encoding  and scheduling methods contribute to the overall performance of itsat  since the contribution of the preprocessing
part can be investigated only when the encoding is fixed  we first analyze the performance of
the three encodings explained in section    we also compare the performance of itsat with
several state of the art temporal planners on all non numerical temporal planning problems
of the previous international planning competitions 
in section    we theoretically showed that our novel relaxed  step encoding is at least as
compact as the temporal versions of the  step and  step encodings for fixed ordering  i e  
the number of steps needed by our relaxed  step encoding to solve a given problem is less
than or equal to that of the temporal versions of the  step and  step encodings   here  we
empirically show that our relaxed  step often needs a significantly smaller number of steps 
compared to the  step and  step encodings  we also show that the mentioned compactness
causes our relaxed  step to significantly outperform  step and  step encodings in the
benchmark problems in terms of both memory and speed 
in section    we explained two preprocessing methods  namely mutual exclusion analysis
and action compression  in this section we show how each of these methods contribute to the
overall performance of itsat on the benchmark problems  for this purpose  we compare
four versions of itsat     itsat without preprocessing     itsat with mutual exclusion
analysis     itsat with action compression  and    itsat with both mutual exclusion
analysis and action compression  our experimental results show that each of these methods
separately enhance the performance of itsat 
in section    we discussed that by adding certain blocking clauses to the encoding of
the problem  one can prevent negative cycles from reoccurring in the stns of the produced
causally valid plans  we also introduced a more elaborate method for preventing such negative cycles  by adding some extra clauses that are based on certain finite state machines 
here  we empirically show that our fsm based method is crucial for the efficiency of itsat
in the problems with required concurrency 
finally  we compare the performance of itsat with that of the state of the art temporal planners  namely optic  coles et al          lpg td  gerevini et al          and
tfd  eyerich et al          optic and tfd have different degrees of temporal expressivity  whereas lpg td is not temporally expressive at all  i e   it is not capable of solving
the problems with required concurrency   we show that itsat significantly outperforms
optic and tfd  while it is competitive with lpg td in many domains 
    implementation details
in order to parse the planning problems and domain  and also validating output plans
produced by itsat  we have used val  which is a plan validation tool developed by the
organizers of in ipc       the schematic operators of a given domain are instantiated by the
objects of the input problem to produce all possible valid ground temporal actions  itsat
   

firankooh   ghassem sani

then performs a polynomial reachability analysis to recognize those actions and prepositions
that are relevant to the given problem  for this purpose  all the goal conditions are initially
assumed to be relevant propositions  any action that produces a relevant proposition upon
starting or ending is considered to be a relevant action  itsat then adds all preconditions of
starting and ending events of all relevant actions to the current set of relevant propositions 
the invariants of relevant actions will be added to this set  too  updating the sets of relevant
propositions and actions are repeated until no further changes will occur in these sets  we
then update the set of relevant propositions by omitting some of relevant propositions that
are present in the initial state of the given problem  the omitted propositions are those that
are not deleted by any relevant action  these propositions will also be omitted from the
at start  at end  and invariants of all relevant actions  mutual exclusion analysis and action
compression methods described in section    are then performed on the sets of relevant
actions and propositions 
as we mentioned in section    in all our encoding methods we assume that there exists a
predefined fixed ordering on all events of the given problem  in the current implementation
of itsat  the ordering in which the events are produced while constructing ground actions 
is taken as the presumed fixed ordering of events  the starting event of each action is
placed immediately before its corresponding ending event in the mentioned ordering  more
elaborate heuristic methods for producing such an ordering may result in a more compact
encoding  rintanen et al          investigating such methods is beyond the scope of this
paper and is left for future research 
in the current version of itsat  we use p recosat  biere         which is a free off theshelf system  as our sat solver  we have also examined two other sat solvers  namely
m inisat  een   biere        and lingeling  biere        for satisfying the formulae 
however  precosat had the best overall performance among these three sat solvers  though
lingeling had a better performance in terms of memory usage 
since p recosat accepts formulae only in the conjunctive normal form  cnf   all formulae described throughout this paper had to be translated to their equivalent cnf formulae  this has been performed simply by using logical equivalence relations such as
              and                  
for each problem  we start with a formula with just one step  we set a time limit
of three minutes for precosat to find a model for the formula  in the case of the failure 
we add three more steps to the formula and repeat this process until either a model is
found or a predetermined maximum time of    minutes is reached  in the case of success
in finding a model  a causally valid plan is extracted from the model  the plan is then
given to a scheduling process to find a valid temporal plan  if the scheduling function
fails  an appropriate fsm is generated and encoded in the problem formula  see section
   without increasing the number of steps  the new formula is again given to p recosat
to find a new model  although parallel solving of formulae with different number of steps
was shown to be more effective than a nave sequential approach  rintanen et al        
streeter   smith         our empirical results show that even our simple sequential method
is sufficient to outperform current temporal planners in many planning domains  we leave
the investigation regarding the effect of using such parallelism for our future research 
all the experiments explained in this section have been conducted on a    ghz corei 
cpu with  gb main memory  as our benchmark problems  we have used the problem
   

fiitsat  an efficient sat based temporal planner

sets of all previous ipcs  these problems are from different planning domains including
zenotravel  rovers  and depots of ipc       airport of ipc       pegsol  crewplanning 
openstacks  elevators  sokoban  and parcprinter of ipc       and driverlog  f loortile 
matchcellar  mapanalyser  parking  rtam  satellite  storage  turnandopen  and tms of
ipc       note that some of these domains have been used in different ipcs  for such
domains  we have chosen the problem set of the most recent competition with those domains 
that is why no problem set of ipc      is present in our experiments 
among the domains used in previous ipcs  only matchcellar  turnandopen  and tms
include problems with the required concurrency  these are the problem sets in which only
temporally expressive planners are capable of producing valid plans  in order to achieve
a better assessment of itsat in problems with required concurrency  we have used two
extra domains driverlogshift and matchlift  halsey         we have also performed our
experiments on time window variants of satellite and airport domains  these domains 
which have been used in ipc      and do have required concurrency  are referred throughout
this section by satellite tw and airport tw  respectively  the mentioned domains with the
required concurrency are explained in more details in section     
    the impact of different encoding methods
to evaluate our  step   step  and relaxed  step encodings we have produced three different versions of itsat  namely  itsat   itsat   and itsat    respectively  in all
these versions  the formula mut   which encodes the mutex relations  is also added to the
encoding  none of these versions take advantage of action compression  the negative cycle
prevention method described in section   has been used in all the three versions of itsat 
table   shows a comparison in each domain among these versions with regard to the number
of solved problems 
as it can be seen in table    itsat  has the best performance among the three
versions  in fact  itsat  has been able to solve    problems more than itsat   and
    problems more than itsat   furthermore  almost all problems solved by itsat 
or itsat  were also solved by itsat    this means that our relaxed  step encoding
is significantly more efficient than the temporal versions of the classical  step and  step
encodings 
table    shows a more detailed comparison among the mentioned encodings  the different columns of table   represent the following items  the name of the domain  the problem
number  the used encoding method  the number of steps in the encoding  the result of
p recosat in terms of satisfiability or unsatisfiability of the formula  the number of clauses
and variables divided by       the amount of time taken by p recosat to determine the
result  and the amount of memory needed for solving the formula  for each problem and
each encoding method  the results are presented for two cases  unsatisfiable formula with
the highest number of steps  and satisfiable formula with the lowest number of steps  note
that to produce these results  we have increased the number of steps by one when a formula
was unsatisfiable  symbol  is used in the time column for those cases in which p recosat
has failed to find a model for the formula in      seconds  the results are presented only for
those domains in which at least one of the problems has been solved by at least two of the
planners  accordingly  openstacks  elevators  matchcellar  and rtam have been omitted
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift
total

problems
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   

itsat 
  
  
  
 
  
  
  
 
 
 
 
  
 
  
  
 
  
 
 
 
 
  
  
  
   

solved
itsat 
  
  
  
 
  
  
  
 
 
 
 
  
 
  
  
 
  
 
 
 
 
  
  
  
   

itsat 
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
  
 
 
 
 
  
  
  
   

table    overall comparison of different encoding methods
from table    moreover  in satellite and storage  the results are only presented for the
  step and  step encodings 
in each domain  table   presents only the results for the hardest problem  i e   the
problem with the greatest number of propositions   in our experiments  we have observed a
pattern similar to that of the chosen problems for other problems of each domain  note that
the results presented in table   are only for finding the first causally valid plan  therefore 
these results do not include the information regarding fsm encoding method described in
section    we will explain the impact of our fsm based negative cycle prevention later in
this section 

   

fiitsat  an efficient sat based temporal planner

domain

zenotravel

rovers

depots

satellite tw

airport tw

airport

prob encoding steps

  

 

  

 

  

 

 

  

  

  

 

  

  

 

  

 

  

 

  

 


 

  

  

 

 

  

  


 

  

  

  

 

  

  


 

  

  
  

 

  

  


 
continued on next page

result
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t

   

c
    

v
    

   
   
  
   
   
  
    
    
   
    
    
   
    
    
    
    
    
    
  
  
 
  
  
 
    
    
   
    
    
   
    
    
   
    
    
   

   
  
  
   
  
  
   
   
  
   
   
  
    
   
   
    
   
   
 
 
 
  
 
 
    
   
  
    
   
  
    
   
  
    
   
  

time
 s 
  
   
    
  
    
    


    
  
  
    
   
   
    
   
 
   
   
   
   
   
   
   
  
   
    
  
   
   
  
   
    
  
   
    

mem
 mb 
   
  
  
   
  
  
   
   
  
   
   
  
   
   
   
    
   
   
 
 
 
 
 
 
   
   
  
   
   
  
   
   
  
   
   
  

firankooh   ghassem sani

domain

prob encoding steps

  

  

pegsol
  

 

  

  


 

  

  

crewplanning  

 

  

  

 

  

  

sokoban
 

 

  

  

 

  

  

parcprinter
  

 

  

  


 

 

driverlog
 

 

 

 

  

  

floortile
  

 

  

  

 

  

 

mapanalyser   

 
continued on next page

result
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t
f
f
f
t
t
t
f
f
t
t
f
f
f
t
t
t
f
f
f

   

c
    

v
    

  
  
  
  
  
  
   
   
 
   
   
 
   
   
   
   
   
   
    
    
   
    
    
   
    
    
    
    
   
  
  
   
  
  
      
      
     

 
 
 
  
 
 
  
  
 
  
  
 
   
  
  
   
  
  
   
   
  
   
   
  
   
   
   
   
  
  
 
  
  
 
    
   
   

time
 s 


    
    
   
   


 
  
  
 

  
   
  
  
   

  
   
  
  
   
   
  
  
    
  
 
    
  
    
    
  
  
   

mem
 mb 
  
  
 
  
  
 
  
  
 
  
  
 
   
  
  
   
   
  
   
   
  
   
   
  
   
  
   
   
  
  
 
  
  
 
    
   
  

fiitsat  an efficient sat based temporal planner

time
domain
prob encoding steps result
 s 

  
t
           
  

  
t
          
  


 
t
     
   
   

 
f
    
   
   

 
f
   
  
   

parking
  

 
f
   
  
   

 
t
    
   
   

 
t
   
   
   


 
t
   
  
 

  
f
   
   


satellite
 

 
f
   
  


  
t
   
   
   

 
t
   
   
   

  
f
    
   


storage
 

 
f
   
  
  

  
t
    
   
   


 
t
   
  
   

  
f
    
   


  
f
   
   
  

turnandopen  

  
f
   
  
   

  
t
    
   
   

  
t
   
   
  

  
t
   
  
   

 
f
   
  
   

 
f
   
  
   

tms
  

 
f
  
  
   

  
t
   
  
   

 
t
   
  
   


 
t
   
  
   

  
f
   
  
   

  
f
   
  
 

driverlogshift   

 
f
  
  
 

  
t
   
  
   

  
t
   
  
   


  
t
  
  
   
table    detailed comparison of the encoding methods
c
    

   

v
    

mem
 mb 
    
   
   
   
  
  
   
  
  
   
  
   
  
   
  
   
  
   
   
  
   
   
  
  
  
  
  
  
  
  
  
 
  
  
 

firankooh   ghassem sani

figure     speed comparison between itsat  and itsat 

in section    we theoretically showed that in order to solve a given planning problem 
our relaxed  step encoding requires fewer steps than the temporal versions of classical
 step and  step encodings when the ordering is fixed  table   shows that itsat 
often needs a considerably smaller number of steps  this phenomenon is most prominent
in airport  crewplanning  and mapanalyser  moreover  in openstacks and matchcellar 
neither itsat  nor itsat  was able to solve any problem due to the very large number
of steps that had been required  this suggests a correlation between the performance of
the planner  and the compactness of the encoding  generally speaking  when a relatively
high number of steps is needed for  step encoding to solve a problem  we can deduce that
there is a strong causal connection between the actions of the produced plan  on the other
hand  our   step encoding has been devised to take advantage of such causal connections 
therefore  the   step encoding is expected to have more advantage over the  step encoding
in such domains  this phenomenon is most visible in airport  crewplanning  openstacks 
and matchcellar domains  as the numbers of steps required by the  step encoding in these
domains are exceptionally high  table   also shows that our relaxed  step encoding results
in a significant improvement of the planner in terms of the memory usage 
   

fiitsat  an efficient sat based temporal planner

figure     speed comparison between itsat  and itsat 

we have also compared the speed of itsat  with that of itsat  and itsat  in
solving all the benchmark problems  the results are depicted in figure    and figure    
as it can be seen  itsat  has outperformed itsat  and itsat  in almost all the
problems 
    the impact of the mutual exclusion analysis and action compression
in section    we explained how mutual exclusion analysis and action compression are performed as preprocessing components of itsat  here  we empirically show that these components are both quite effective in enhancing the performance of our planner  as we showed

before   is the encoding that results the best performance of itsat  we have fixed this
formula as the base of comparison  and produced three other formulae to investigate the

impact of each preprocessing method  these three formulae are   mut  the base encod
ing plus the mutual exclusion information     com  the base encoding plus the action

compression information   and   mut  com  the base encoding plus both mutual exclusion and action compression information   table   shows the number of problems solved
by each of the mentioned versions of itsat 
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandpen
tms
driverlogshift
matchlift
total

problems
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   




  
  
  
 
  
  
  
  
 
 
 
  
 
 
  
 
 
 
 
 
 
 
  
  
   



  mut
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
  
 
 
 
 
  
  
  
   



  com
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
 
 
 
 
 
  
  
  
   



  mut  com
  
  
  
 
  
  
  
  
  
 
 
  
 
  
  
  
  
 
  
  
 
  
  
  
   

table    the impact of the mutual exclusion analysis and action compression
as it can be seen in table    these preprocessing methods result in a significant improvement in terms of overall coverage  in fact  the version of itsat that uses both methods
solves     problems more than the base planner  besides  the version that uses both methods even considerably outperforms any of the two versions that only use one preprocessing
method  this suggest that both preprocessing components are necessary for producing the
best performance of itsat 
to investigate the effectiveness of our action compression method in the domains that
itsat compresses considerably more actions than crikey  we have performed another
experiment  we compressed only the actions that itsat considers compression safe but
crikey  does not  in this new version of itsat  we also used the mutual exclusion
information  this version of itsat solves six problems more than the version where only
   

fiitsat  an efficient sat based temporal planner

mutual exclusion information was used  of these six problems  four problems are from
zenotravel  one is from airport  and one is from mapanalyser  the results does not change
much in other domains  note that the three mentioned domains are those in which itsat
compresses considerably more actions than crikey 
    the impact of the fsm based negative cycle detection
as mentioned earlier  among the domains used to evaluate itsat  matchcellar  turnandopen  tms  driverlogshift  matchlift  and time window versions of airport and satellite can
have problems with required concurrency  in fact  in these domains  it may be impossible
to schedule a causally valid plan produced by solving a sat formula  into a valid temporal
plan  here  we briefly explain why the problems in each of these domains may require concurrency  and how this may introduce some negative cycles into the stn associated with a
causally valid plan 
in matchcellar and matchlift  there exists an action for lighting a match  this action
produces light for a certain amount of time  the objective is to mend some fuses  the
actions for mending a fuse can only be executed if there is light  as a result  the actions of
lighting a match and mending a fuse must be executed concurrent  however  in a causally
valid plan  since the planner does not consider the durations of actions  it may assume that
any match can remain lit until all the fuses are mended  as it was discussed in section   
this can introduce a negative cycle into the stn of a produced causally valid plan 
in tms  the objective is to produce a certain number of ceramic structures  these
structures need several preparations that can be done only while a furnace is producing
heat  it should be clear that this domain is very similar to matchcellar and matchlift  and
requires concurrency in a similar way 
a simplified version of driverlogshift was introduced in section    the only difference
between that simplified version and the one used in this section to evaluate the planners  is
that here  there are drivers that can walk to  board  and disembark trucks  furthermore 
the rest and work actions are performed by the drivers rather than trucks  in this domain 
the working shifts of the drivers are analogous to the action of lighting a match in the
matchcellar domain 
in turnandopen  there exists a robot that needs to move between a number of rooms 
there are doors between each pair of adjacent rooms  all these doors  which are closed in
the initial state  should be opened by the robot  the robot can open a door only while it
is turning the doorknob  in this domain  the actions of turning the doorknob and opening
the door must be executed concurrently  however  the duration of the action for turning
the knob is    whereas that of opening the door is    this enables itsat to schedule every
causally valid plan into a valid temporal plan  therefore  preventing negative cycles is not
necessary in this domain 
in time window versions of airport and satellite  there is a specific time by which all
goals must be obtained  such a deadline is introduced into a problem by using a specific
frame action with the duration equal to the time of that deadline  all other actions can
be executed only when this frame action is being executed  in other words  all the actions
must be concurrent with the is frame action  however  in a causally valid plan  since the
planner does not consider the durations of actions  it may assume that the frame action can
   

firankooh   ghassem sani

domain
problem
satellite tw
 
airport tw
  
matchcellar
  
tms
  
driverlogshift
  
matchlift
  

restarts
   
 
  
 
  
 

c
    


  
   
  
   
  
  

fsm
    
 
   
  
   
   

v
    


 
  
  
  
  
  

fsm
   
 
   
  
   
   

memory  mb 

fsm
 
   
  
 
 
  
  
 
  
   
  
  

table    the collective size of the sat encodings of fsms
be arbitrarily long  and thereby neglect to meet the deadline for achieving the goals  this
can introduce negative cycles into the stns of produced causally valid plans 
as we explained in section    if the stn of a causally valid plan includes a negative
cycle  we must force the sat solver to find a different solution  this can be done simply
by adding an extra blocking clause to the current sat formula to prevent at least one of
the events of that negative cycle from reoccurring in its current step  alternatively  we
introduced a more elaborate method for doing the same thing  by adding the encoding of
certain fsms into the encoding  in this method  when the stn of a causally valid plan with
k steps includes a negative cycle  an fsm that detects that negative cycle will be encoded
into a sat formula  and the solver will be restarted  in order to decrease the number of
restarts  whenever a sequence of events corresponding to a negative cycle is found  itsat
tries to find other potential negative cycles by replacing the actions of current sequence by
other actions of the problem and checking the stn of the resulting sequence for negative
cycles 
table   shows the collective size of the sat encodings of the fsms required for solving
the problems of the above domains  as our base encoding  we have used the relaxed
 step encoding with both mutual exclusion analysis and action compression  for each
domain  the results are shown in table   only for the hardest problem solved by itsat  the
turnandopen domain has been excluded from table    as no negative cycle is encountered
when solving problems of this domain  the different columns of table   represent the
following items  the name of the domain  the problem number  the number of clauses and
variables divided by       and the amount of memory needed to produce the formula  the
results for the number of causes  number of variables  and the used memory are presented
with separated columns for the base encoding and the encoding of the fsms 
as it can be seen in table    our negative cycle prevention method helps itsat solve
a considerable number of problems with required concurrency  nevertheless  the sat encoding of the required fsms is significantly larger than the base encoding in the domains
where the number of restarts are relatively high  on the other hand  as the number of the
restarts increase  the speed of itsat declines  that is because after each restart  the sat
solver must verify the satisfiability of the formula  from scratch  in fact  these numerous
restarts are the main reason for the poor performance of itsat in the time window version
of satellite 
   

fiitsat  an efficient sat based temporal planner

    itsat versus the state of the art temporal planners
we now compare itsat with three efficient temporal planners  namely  optic  benton 
coles    coles         tfd  eyerich et al          and lpg td  gerevini et al         
because of the similarities between the approach used in itsat and that of scp   lu
et al          we have also included the results of this planner in our experimental results 
optic is the newest version of popf  coles et al          it is a heuristic state space
temporal planner based on the so called temporally lifted progression planning  cushing
et al          using this approach of planning enables optic to solve problems with
required concurrency  besides  optic handles self overlapping actions  which makes it
more expressive than itsat  although handling self overlapping actions is hardly necessary
for solving non numerical temporal planning problems  fox   long         among the
current benchmark domains  zenotravel  rovers  and airport do permit such actions due to
some modeling errors  for a fair comparison between itsat and optic  we have used the
corrected versions of these three domains  in our evaluations  for guiding its search  optic
benefits from a heuristic function that is based on the relaxed planning graph  hoffmann
  nebel        
tfd is another heuristic state space temporal planner  tfd is based on the so called
decision epoch planning  cushing et al          the planners that use this approach are
not as temporally expressive as the planners that are based on temporally lifted progression planning  in other words  in theory  there are temporal planning problems defined in
pddl    that can be solved by itsat and optic but not by tfd  however  all the current benchmark problems can potentially be solved by using decision epoch planning  for
guiding its search  tfd benefits from a temporal version of the so called context enhanced
additive heuristic  helmert   geffner        
lpg td is a very fast temporal planner  which is not temporally expressive  in fact 
lpg td at first generates a sequential plan for a given problem  and then tries to reschedule
the plan to produce one with an improved quality  this renders lpg td incapable of
solving any problem in matchcellar  turnandopen  tms  driverlogshift  or matchlift  similar
to optic  lpg td benefits from a heuristic based on the relaxed planning graph  however 
instead of searching in the state space of the problem  lpg td performs its search by making
some local improvements to a structure that is similar to partial plans  which is called linear
action graph  two different configurations of lpg td can be used based on whether we
prefer speed of the planner or the quality of produced plans  here  we only present the
results of the quality configuration of lpg td  as it produced better results than the speed
configuration in our experiments 
scp   lu et al          is a sat based temporal planner that uses a discrete representation of time  this planner assigns explicit discrete time labels to each step of the encoding 
in this approach  each step i is exactly one time unit ahead of step i      as a result  if an
action with duration d starts in step i  it is forced to end in step i   d  this means that the
number of layers required for producing a plan  is greater than or equal to the makespan
of   spc  starts with a formula with only one step  an increases the number of steps by
one  every time the formula is unsatisfiable  this enables spc  to find the optimal plan for
   the corrected version of mentioned domains can be downloaded from the official website of popf
planner 

   

firankooh   ghassem sani

a number of given problems  to obtain a better performance  scp  uses  step semantic
to allow causal relations between actions in each time point 
we have compared itsat with the above planners based on the number of problems
they can solve in each domain and also by the total score given to each planner using the
scoring strategy of recent ipcs  that is  if a planner cannot solve a problem  it will get a
score of   for that problem  otherwise  its score will be equal to the makespan of the best
produced plan divided by the makespan of the plan found by this planner  the results are
presented in table   
as it can be seen in table    itsat significantly outperforms optic  tfd  and scp  
in fact  itsat solves     problems more than optic      problems more than tfd  and
    problems more than scp   itsat also solves    problems more than lpg td  however 
this is mainly because lpg td is incapable of solving problems with required concurrency 
if we exclude satellite tw  airport tw  matchcellar  turnandopen  tms  driverlogshift  and
matchlift that are the domains in which lpg td cannot solve any problem  itsat solves
only    problems less than lpg td  this shows that itsat is quite competitive with
lpg td even in solving the problems without required concurrency 
as it is shown in table    optic solves zero problems in parcprinter  driverlog  floortile 
mapanalyser  matchcellar  rtam  storage  and tms  in all of these domains  the main reason
of poor performance of optic is that it runs out of memory  early during its search  tfd
solves zero problems in satellite tw  airport tw  parcprinter  driverlog  floortile  rtam  storage 
and tms  except for parcprinter  in which tfd runs out of memory  in other domains
tfd performs poorly because it is unable to find a plan within      seconds  as we
mentioned before  lpg td solves zero problems in the domains with required concurrency 
the performance of scp  is rather poor in many of the benchmark domains  the reason of
the poor performance of scp  is that  for many of the benchmark problems  the makespan
of the optimal plan is relatively large  as a result  in most of the problems  scp  is unable
to check the satisfiability of all the formulae with numbers of steps less than the makespan
of the optimal plan  within the      seconds time limit 
to compare the quality of the plans produced by itsat with those of other competing
planners  consider table    the numbers presented in table   are the average makespan
ratio of plans mutually solved by the corresponding planner and itsat in the corresponding
domain  ratios less than one indicate better average quality of the solutions produced by
itsat in comparison with the competing planners  for those cases that neither itsat nor
the competing planner has been able to solve any problem of a domain  the corresponding
cell of table   has remained blank 
we have also performed some experiments based on a number of two planners portfolios
of different pairs of the above planners  the portfolios enabled us to combine the advantages
of two planners  to do this  the    minutes time limit is divided equally between each pair
of planners  the results of running these portfolios are presented in table    the results
show that the best configuration has been obtained by combining itsat and lpg td  the
resulting planner was capable of solving     out of     benchmark problems  moreover 
each of these planners has produced its best results when it was combined with itsat 

   

fiitsat  an efficient sat based temporal planner

solved

domain

n

zenotravel

  

  

rovers

  

depots

itsat

optic

scp 

ipc

score

itsat

optic

tfd

lpg td

scp 

tfd

lpg td

  

  

  

 

     

     

     

     

 

  

  

  

  

 

     

     

     

     

 

  

  

 

 

  

 

    

    

    

     

 

satellite tw

  

 

 

 

 

 

 

 

 

 

 

airport tw

  

  

 

 

 

 

  

 

 

 

 

airport

  

  

  

  

  

 

    

     

     

     

 

pegsol

  

  

  

  

  

  

     

     

     

     

  

crewplanning

  

  

  

  

 

 

     

  

     

    

 

openstacks

  

  

  

  

  

 

    

     

     

     

 

elevators

  

 

 

 

 

 

 

 

 

    

 

sokoban

  

 

 

 

 

 

    

    

 

    

 

parcprinter

  

  

 

 

 

 

  

 

 

    

 

driverlog

  

 

 

 

  

 

    

 

 

     

 

floortile

  

  

 

 

  

  

     

 

 

     

  

mapanalyser

  

  

 

  

  

 

     

 

     

     

 

matchcellar

  

  

  

  

 

 

  

  

  

 

 

parking

  

  

  

  

  

 

    

     

     

     

 

rtam

  

 

 

 

  

 

 

 

 

  

 

satellite

  

  

 

  

  

 

    

    

    

  

 

storage

  

  

 

 

  

  

     

 

 

    

  

turnandopen

  

 

 

  

 

 

 

    

     

 

 

tms

  

  

 

 

 

 

  

 

 

 

 

driverlogshift

  

  

  

 

 

 

    

    

    

 

 

matchlift

  

  

  

  

 

  

  

  

  

 

  

total

       

   

   

   

  

                   

table    itsat versus state of the art temporal planners

   

         

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

optic

tfd

lpg td

scp 

    
    
    
 
 
    
    
    
    

    




 
    

    

    

    
 

    
    
    


    
    
    
    

    



    
    
    

    

    

    
 

    
    
    


    
    
    
    

    
    
    
    
    

    

    
    





 
    
    



    



 


    


    


    
 

    
 

table    average makespan ratio

itsat
optic
tfd
lpg td
scp 

itsat

   
   
   
   

optic
   

   
   
   

tfd
   
   

   
   

table      planners portfolio

   

lpg td
   
   
   
   

scp 
   
   
   
   


fiitsat  an efficient sat based temporal planner

figure     speed comparison between itsat and optic

although itsat is quite competitive with the state of the art temporal planners  our
empirical results reveal a few drawbacks of the planner  we have compared the speed of
itsat with that of optic  tfd  lpg td  and scp  on all of our benchmark problems 
the results are presented in figure     figure     figure     and figure     respectively 
in these figures  the results for the required concurrency domains have been separated
from that of other domains by using different symbols in the scatterplots  the star symbol
represents the problems with required concurrency  and the diamond symbol represents
other problems  as it can be seen  itsat is slower than optic  tfd  and lpg td in a
number of the benchmark problems  a major cause of this drawback is that in itsat  the
sat solver spends too much time refuting several formulae before it will finally find the
first satisfiable formula  as it has been shown in the case of classical planning  the speed of
sat based planners can be significantly improved by checking the satisfiability of several
formulae with different number of steps in parallel  we discuss this in more detail in section
  as our future research 
another observation is that  itsat performs rather slowly in solving a number of
problems with required concurrency that are quickly solved by optic and tfd  this is
mainly due to restarting the sat solver whenever negative cycles are encountered  as we
   

firankooh   ghassem sani

figure     speed comparison between itsat and tfd

explained earlier  when the stn of a causally valid plan with k steps includes a negative
cycle  an fsm detecting that negative cycle will be encoded into a sat formula  and the
solver will try to satisfy the new formula with k steps  from scratch  in the domains where
these negative cycles are abundant  the performance of itsat can be significantly affected
by the numerous restarts of the sat solver 
the performance of itsat is particularly poor in three domains  namely elevators 
driverlog  and rtam  in these domains  the number of ground actions is higher than
that of other domains  a linear increase in the number of ground actions may cause an
exponential growth in the size of the search space of the problem  to tackle this problem 
state space based planners take advantage of heuristic functions that are devised specially
for pruning the search space of planning problems  it has also been shown that using sat
solvers tailored for solving planning problems can result in a significant improvement of the
performance of sat based classical planning  rintanen         we think that employing
this idea can also improve the speed of itsat in the mentioned domains 
another drawback of itsat is the poor quality of its produced plans in some benchmark
domains  most notably  although itsat solves most of the problems in depots  openstacks 
parking  and satellite  the quality of its plans is rather low in these domains  according to
   

fiitsat  an efficient sat based temporal planner

figure     speed comparison between itsat and lpg td

table    this is mainly due to the fact that itsat abstracts out the duration of actions 
and thus  its sat solver lacks the competency for evaluating the quality of the plans that
are being produced  nevertheless  the quality of the plans produced by itsat is generally
comparable to that of other planners in most benchmark domains  in section    we explain
an idea for improving the quality of the plans produced by itsat 

   conclusions and future research
in this paper  we described itsat  a temporally expressive sat based planner  itsat is
based on an approach that takes advantage of parallel encodings  in this approach  at first 
the durations of all actions of a given problem are abstracted out  then the abstract problem
is encoded into a sat formula using  step and  step semantics for causally valid plans 
after generating a causally valid plan  itsat performs a scheduling process  during this
process  itsat tries to satisfy those temporal constraints that are imposed by considering
the durations of actions  this is done by solving a simple temporal problem  stp   in the
cases with an inconsistent stp  the cause  which is a negative cycle in the corresponding
simple temporal network  stn   is detected  itsat then adds certain clauses to the sat
formula at hand to prevent the reoccurrence of such negative cycles  this process is then
   

firankooh   ghassem sani

figure     speed comparison between itsat and scp 

repeated until a temporally valid plan will be produced  or a predefined time limit will be
reached 
the main contributions of this paper can be summarized as follows 
 we introduced a novel method to detect temporal actions that can be compressed into
classical ones  the new compression technique is performed as a preprocessing task
and thus is independent from the planning algorithm and can be used by any other
temporal planner  this makes our compression technique more general than that of
popf  which is specifically tailored for that planner  our empirical results showed
that such action compression results in an improved performance for itsat  we also
empirically showed that our method is capable of detecting more compression safe
temporal actions than the only previous action compression method  used by popf 
 we introduced three new encoding methods based on the concept of parallel plans for
sat based temporal planning  while two of these methods have been adopted from
classical planning  our third method  which produces more compact formulae  has
been employed by itsat for the first time  our empirical results show that this new
encoding can significantly enhance the performance of sat based temporal planning 
   

fiitsat  an efficient sat based temporal planner

 we introduced a method to avoid producing the plans that are members of a given
regular language over the set of all events  this was done by embedding the sat
encoding of a particular fsm that accepts the language into the sat encoding of
the input problem  we used this method for preventing the temporal inconsistencies
of the produced causally valid plans from reoccurring in subsequent causally valid
plans  our experiments showed that this method contributed considerably to the
performance of itsat in current benchmark problems with required concurrency 
according to our empirical results  by taking advantage of these new approaches  not
only does itsat outperform the state of the art temporally expressive planners  it is also
competitive with the most efficient temporal planners that do not handle required concurrency  nevertheless  we believe that the performance of itsat can be improved in several
ways  which are discussed below 
in the current version of itsat  the satisfiability of formulae with different number of
steps are checked in a sequential manner  starting with a formula encoding one step  this
means that the sat solver has to refute several formulae until it finds the first satisfiable
formula  if the time required for checking the satisfiability of formulae increased with the
number of steps  this policy would result in the best performance of itsat  however  this
is almost never the case  as it has been shown in the case of classical planning  for a fixed
planning problem  the time needed for finding a model for a satisfiable formula is usually
considerably less than the time needed for refuting an unsatisfiable formula  rintanen et al  
       based on our experiments  the same phenomenon happens in the case of temporal
planning  too  similar to the sat based classical planning  one can take advantage of this
phenomenon by checking for the satisfiability of formulae with different numbers of steps
in parallel  the applicability of such parallelisms can be very sensistive to the amount
of memory required for saving the formulae  as it was shown in section    our newly
introduced   step encoding is considerably more efficient than the temporal version of the
classical  step encoding in terms of the memory usage  this suggests that our   step
encoding is more suitable for employing such parallelism 
as in linear sized classical  step and  step encodings  in all our encoding methods 
we assume that there exists a predefined fixed ordering on all events of a given problem 
this ordering can have a great impact on the number of steps needed for solving the input
problem  for example  consider a sequential plan in which no ground action is applied more
than once  if this potential plan is a subsequence of the mentioned fixed ordering  then only
one step will be sufficient for finding the plan  on the other hand  if in this case we reversed
this fixed ordering  the number of steps that would be required to find the model might be as
large as the size of the plan itself  in the current implementation of itsat  the ordering in
which the events are produced while constructing ground actions  is taken as the predefined
fixed ordering of events  however  considering the causal relationships among the actions
of a given problem  one might be able to find more effective orderings that would result
in a fewer steps for solving the problem  we believe that this enhancement would result
in an improved version of itsat  which will be more efficient in terms of both speed and
memory usage 
the current version of itsat uses off the shelf general purpose sat solvers  this
means that any advancement in designing such solvers can also improve the performance of
itsat  recent investigations in the field of sat based classical planning have shown that
   

firankooh   ghassem sani

designing a sat solver tailored for solving planning problems can result in a much improved
performance of sat based planners  in particular  the most efficient sat based classical
planner  mp  rintanen         has been able to be competitive with the sate of the art
state space based planners by employing this idea  since the causal structures of temporal
planning problems are generally very similar to that of classical planning problems  we
believe that itsat can benefit enormously from employing a planning oriented sat solver 
as mentioned in section    one of the main drawbacks of itsat is the poor quality of
its produced plans in some of the benchmark domains  this is mainly due to the fact that
itsat abstracts out the duration of actions  and thus  the sat solver does not have the
needed resources for evaluating the quality of the plans that are being produced  alternatively  one can add an explicit representation of the time into the encoding  shin   davis 
       this can be done by using smt solvers  armando   giunchiglia         which handle continuous variables  however  as it was discussed in section    this solution may result
in a considerably slower search  we think that itsat can benefit from a combination of
these two approaches  after that the first plan is produced by itsat  it can proceed by
introducing appropriate numerical constraint to the sat formula at hand  and then use an
smt solver to produce improved plans  this is the subject of our ongoing research 
finally  we should mention that some of the components of itsat  can also be used in
other fields of ai planning  most notably  our   step encoding can also be employed in
sat based classical planning  our empirical results show that this encoding method can
be quite effective in reducing the number of steps needed to produce valid plans in several
temporal planning domains that also have a classical version  we think that the improved
performance of the   step encoding in comparison to the  step encoding can be achieved
in classical planning  too  moreover  in section    we showed how to prevent members of
any given regular language on the events of the input problem from being produced as the
output plan  we used this method to prevent itsat from producing temporally invalid
plans  the same method can be employed to enforce a variety of constraints on the plan
that is being produced  for example  consider the case where we require certain actions
to be executed only in a specific order  it must be clear that the set of all plans violating
this constraint can be regarded as a regular language over the set of all actions  therefore 
such a constraint can be introduced to the encoding of the problem by the same method
discussed in section   

acknowledgments
the authors would like to thank the handling editor  jorg hoffmann  and the anonymous
reviewers for their invaluable contributions to the quality of this paper 

appendix a  proofs
theorem    let p    i  g  a  be a temporal planning problem and p c    state i   g  ac  
be the causal abstraction of p  assume that    he         en i is a sequence of events that is
applicable in i  and sn   succ i     then the following conditions must hold 
 if two propositions p and q are both members of state sn    then p and q are non mutex
in the layer n of the planning graph of p c  
   

fiitsat  an efficient sat based temporal planner

 if proposition p is a member of state sn    and action a is a member of agenda sn   
then p and opena are non mutex in layer n of the planning graph of p c  
proof  we give the proof by induction on n  the length of    for n      i e   when no
event is applied to i  the conclusions obviously hold because every member of state i  is
present in the first layer of the graph  we have no mutex in the first layer  and we have
agenda i     by definition    now suppose the conclusions hold for n   k     we show
that they will also hold for n   k  assume that    he         ek i is a sequence of events that
is applicable in i  sk   succ i     and sk    succ i  he         ek  i  
 let p and q be two members of state sk    there are three possible cases 
case    if both p and q are members of sk    then by the induction hypothesis  p and
q are non mutex in layer k    of the planning graph of p c and thus noopp and noopq
are non mutex in layer k     hence  p and q will not be mutex in layer k 
case    if neither p nor q are members of state sk    then by definition    p and q
must be both members of add ek    assume that ek is the ending event of action a
 the case where ek is the starting event of a is analogous and thus is omitted here  
since ek is applicable in state sk    by definition    all members of pre ek   must be
also members of state sk     and a must be a member of agenda sk     therefore  by
the induction hypothesis  all members of pre ae   are non mutex in layer k     as a
result  p and q  which based on definition    are both added by ae   will be non mutex
in layer k 
case    if only p is a member of state sk     then by definition    q must be a member
of add ek    and p cannot be a member del ek    assume that ek is the ending event of
action a  again  the case where ek is the starting event of a is analogous and thus is
omitted here   by the induction hypothesis  all members of pre ae   are non mutex in
layer k     and by definition     ae does not delete p  therefore  ae will be present
in layer k    and it cannot be mutex with noopp   as a result  p and q are non mutex
in layer k 
 let p be a member of state sk    and action a be a member of agenda sk    there are
two possible cases 
case    if a is also a member of agenda sk     then a is started but not yet ended
before reaching sk    and all invariants of a have to be members of state sk     by
the induction hypothesis  these invariants must be non mutex in layer k    hence  ai
is present in layer k     by definition     ai adds opena   now  we must show that p
can be added by an action that is not mutex with ai in layer k     if p is a member of
state sk     then by the induction hypothesis  p is present in layer k     therefore 
noopp   which is not mutex with ai   is applicable in layer k    and  as a result  p
and opena are not mutex in layer k  on the other hand  if p is not a member of
state sk     it must be added by ek   since ek is applicable in sk  and a is a member
of agenda sk     by definition    ek cannot delete any invariant of a  assume that ek
is the ending event of action b  the case where ek the starting event of b is analogous
and thus is omitted here   by the induction hypothesis  be   which is not mutex with
   

firankooh   ghassem sani

ai must be applicable in layer k     this means that p and opena will not be mutex
in layer k 
case    if a is not a member of agenda sk     then by definition    ek must be the
starting event of a  and a does not delete p  moreover  by definition    all starting and
invariants of a must be present in state sk     therefore  by the induction hypothesis 
as is applicable in layer k     if p is not present in state sk     then it must be added
by ek   by definition     all propositions added by the starting event of a are also
added by as   since as also adds opena   then p and opena cannot be mutex in layer k 
on the other hand  if p is a member of state sk     then by the induction hypothesis 
p is present in layer k     therefore  noopp   which is not mutex with as   is applicable
in layer k     this means that p and opena will not be mutex in layer k 

theorem    let p    i  g  a  be a solvable temporal planning problem  let a be the set
of every member of a that is either compressible towards its start or compressible towards
its end  a is compression safe for p 
proof  let   be a causally valid plan for p  such a plan must exist because p is solvable  
starting from     we produce a sequence of causally valid plans by swapping the events
that are next to each other in the plan at hand  assume an arbitrary order ha         an i
on all members of a   without loss of generality  we assume that no action is repeated in
   otherwise  different names can be given to the different occurrences of the same action
to eliminate such a repetition   for producing the causally valid plan i   we consider the
causally valid plan i    if ai is compressible towards its start  we keep swapping the ending
event of ai with its previous event in i  until that previous event becomes the starting
event of ai   in fact  doing these swaps collectively cause ai to become compressed towards
its start  doing such swaps can never falsify the causally valid plan at hand  assume that
e is the event immediately prior to the ending event of ai in a causally valid plan  and e
is not the starting event of ai   then each precondition and effect of e must be present
in at least one state whose agenda includes ai   thus  by theorem    no precondition or
effect of e can be mutex with openai in the last layer of the levelled off planning graph of
the causal abstraction of p  then by definition     e must be swappable with the ending
event ai   therefore  i is a causally valid plan in which the starting and ending events of
ai are located next to each other  similarly  if ai is compressible towards its end  we keep
swapping the starting event of ai with its next event in i  until that next event becomes
the ending event of ai   as a result  in n   the ending event of all members of a are located
next to their corresponding starting events  and therefore  according to definition     a is
compression safe for p 
lemma    let s    e         en   be a set of events  e and r  be two subsets of s  assume
that s  is a subset of s such that if ei  s   e  we have ej 
  s   r for all j   i  let m
be the function that is defined by the following rules and assigns a value of true or f alse
to each sat variable of chain e         en   e  r  k  m  
   

fiitsat  an efficient sat based temporal planner

 for each i  m  eki     true if and only if ei is a member of s   
 for each i  m  bki m     true if and only if there is ej  s   e such that j   i 
then m satisfies chain e         en   e  r  k  m  
proof  we show that m satisfies formulae  c    to  c     and therefore it satisfies
chain e         en   e  r  k  m  
  s  then
 c    consider an arbitrary formula eki  bkj m from the formula  c     if ei 
m  eki     f alse  and thus the formula is trivially satisfied  now consider the case
where ei  s    by the definition of formula  c     we know that i   j and ei  e 
therefore  according to the definition of m   we must have m  bkj m     true  and thus
again the formula is satisfied 
 c    consider an arbitrary formula bki m  bkj m from the formula  c     if m  bki m    
f alse  the formula is trivially satisfied  on the other hand  if m  bki m     true  then
there must exist an l  such that l   i and el  s   e  since i   j  we must have
l   j  and therefore  we have m  bkj m     true  and hence the formula is satisfied 
 c    consider an arbitrary formula bki m  eki from the formula  c     if m  bki m    
f alse  the formula is trivially satisfied  on the other hand  if m  bki m     true 
then there must exist an l  such that l   i and el  s   e  then according to
the properties of s    we must have ei 
  s   r  however  by the definition of
chain e         en   e  r  t  m   we have ei  r and  as a result  ei 
  s    therefore 
k
m  ei     f alse and the formula is satisfied 

lemma    let s    e         en   be a set of events  and e and r be two subsets of s  assume
that m is a model for chain e         en   e  r  k  m   if ei  e and m  eki     true  then for all
j   i such that ej  r  we have m  bkj m     true  and consequently m  ekj     f alse 
proof  suppose that in sequence e         en   event ej is the first event after ei such that
ej  r  since in the formula  c    of chain e         en   e  r  k  m   we have eki  bkj m   then
m  bkj m     true  similarly  if in sequence e         en   event ej  is the first event after ej
such that ej   r  then we must have the formula bkj m  bkj  m in  c     which implies
that m  bkj  m     true  by repeating the argument of the latter case  we infer that for
all j   i such that ej  r  we have m  bkj m     true  and according to  c     we have
m  ekj     f alse 
theorem    completeness of temporal  step encoding   let p    i  g  a  be a
solvable temporal planning problem   e         en   be the set of all events of p  and   
hstep         stepl i be a causally valid  step plan for p  there exists a model m for l such
that    plan m   
   

firankooh   ghassem sani

proof  we construct a function m that assigns true or f alse to all sat variables of the
formula l   let hs         sl i be the state transition sequence of   m is defined by the
following rules 
 for each proposition p  and each k such that    k  l  m  pk     true iff p is a
member of state sk   
 for each action a  a  and each k such that    k  l  m  ak     true iff a is a member
of agenda sk   
 for each each i such that    i  n  and each k such that    k  l  m  eki     true
iff ei is a member of stepk   moreover  for each k such that    k  l  m  ek     
m  ekn       f alse 
 for each proposition p  each i such that    i  n      and each k such that    k  l 
m  bki mp     true iff there exists and event ej   such that j   i  ej  ep   and ej  stepk  
 

 for each proposition p  each i such that    i  n      and each k such that    k  l 
m  bki mp     true iff there exists and event ej   such that j   i  ej  ep   and ej  stepk  
 

we show that m satisfies all formulae      to        and therefore is a model for l   note
that by the way m is constructed  we directly have    plan m   
     according to definition     we have s    i  and thus formula      is clearly satisfied 
     according to definition     we have g  state sl    and thus formula      is clearly
satisfied 
     according to definition    we have agenda i      and thus formula      is clearly
satisfied 
     according to definition     we have agenda sl       and thus formula      is clearly
satisfied 
     let p be an arbitrary proposition  and e be an event such that e  rp   if e 
  stepk  
then m  ek     f alse and  therefore  formula      is trivially satisfied  consider the
case where e  stepk   according to definition     stepk must be a  step from sk 
to sk   thus  by definition     for any possible ordering on the events of stepk   we
must be able to execute these events according to the ordering  starting from state
sk    one possible ordering can be an specific ordering that puts e in the front of
all other events  therefore  e must be applicable to sk    then  by definition    we
have p  state sk     this implies that m  pk      true  from which the satisfaction
of formula      easily follows 
  stepk  
     let p be an arbitrary proposition  and e be an event such that e  ep    if e 
then m  ek     f alse and  therefore  formula      is trivially satisfied  consider the
case where e  stepk   similar to the previous case  starting from state sk    we
must be able to execute the events of stepk by any possible ordering and reach sk  
   

fiitsat  an efficient sat based temporal planner

one such possible ordering is one that puts e after all other events  therefore  addeffects of e must be members of state sj    and by definition    we have p  state sk   
this implies that m  pk     true  from which the satisfaction of formula      easily
follows 
  stepk
     let p be an arbitrary proposition  and e be an event such that e  ep   if e 
k
then m  e     f alse and  therefore  formula      is trivially satisfied  otherwise 
by the same argument given case       we have p 
  state sk    and the satisfaction
of formula      easily follows 
     let p be an arbitrary proposition  consider the nontrivial case where p is a member
of state sk   but not state sk     it can be easily derived from definition    that if p
is added by the application of a sequence of events  then at least one of those events
must add p  this implies the satisfaction of formula      
     this case is analogous to case     
      lemma   is used to prove that m satisfies chain e         en     ep   rp   en      k  mp    
it is straightforward to see that m has all the properties of the model m in lemma
   we only need to show that for any proposition p  provided that ei  stepk  ep
and j   i  then ej 
  stepk  rp   suppose that ej  stepk   by definition     for any
possible ordering on the events of stepk   we must be able to execute those events
according to the ordering  starting from the state sk    one such possible ordering
can be one that puts ei immediately before ej   notice that ei deletes p  because
ei  ep   thus  ej cannot have p as its precondition  and ej 
  rp   we can infer
that ej 
  stepk  rp   therefore  by lemma    m satisfies chain e         en     ep   rp 
 en      k  mp     now  we show that m also satisfies bkn   mp  ak   consider the
 

nontrivial case  where m  bkn   mp     true  based on the way we construct m   at
 
least one of e         en   say ej   must delete p  again  since stepk is a  step from sk 
to sk   we must be able to execute the events of stepk by any possible ordering and
reach sk   consider an specific ordering that puts ej after all other events  now 
if a  agenda sk    according to definition    ej cannot be the ending event of a 
therefore  by definition    a is also a member of the agenda of the state to which
ej is applied  this clearly contradicts the applicability of ej   because ej deletes p 
which is an invariant of a  therefore  m  ak     f alse  which implies that m satisfies
bkn   mp  ak  
 

      in this case  too  lemma   is used to prove that m satisfies chain en        e    ep   rp 
 e     k  mp     similar to the previous case  it is straightforward to confirm that m
has all the properties of lemma    since the ordering in chain e         en     ep   rp 
 en      k  mp    is reversed in chain en        e    ep   rp   e     k  mp     we need to show
that for any proposition p  provided that ei  stepk  ep and j   i  then ej 
 
stepk  rp   suppose that ej  stepk   by definition     for any possible ordering
on the events of stepk   we must be able to execute these events according to the
ordering  starting from state sk    one such possible ordering can be one that
puts ei immediately before ej   by the same argument as the one given in case
   

firankooh   ghassem sani

       we infer that ej 
  stepk  rp and  therefore  by lemma    m satisfies
chain en        e    ep   rp   e     k  mp     now  we show that m also satisfies bk  mp 
 

ak    consider the nontrivial case  where m  bk  mp     true  based on the way we
 
construct m   at least one of e         en   say ej   must delete p  again  because stepk is
a  step from sk  to sk   starting from the state sk    we must be able to execute the
events of stepk by any possible ordering  consider the specific ordering that puts ej
before all other events  by definition    since ej deletes p  which is an invariant of
a  a cannot be a member of agenda sk     therefore  m  ak     f alse  which implies
that m satisfies bk  mp  ak   
 

      assume that e is the starting event of action a  because stepk is a  step from sk 
to sk   starting from the state sk    we must be able to execute the events of stepk
by any possible ordering  consider the specific ordering that puts e before all other
events  therefore  e must be applicable to sk    then  by definition    a cannot be
a member of agenda sk     and thus m  ak      f alse  to see that m  ak     true 
consider the specific ordering of events that puts e after all other events  if the events
are executed by this ordering  the results of applying e will appear in state sk   and
thus a must be a member of agenda sk    hence  m satisfies ek  ak   ak  
      analogous to case        assume that e is the ending event of action a  since stepk
is a  step from sk  to sk   starting from state sk    we must be able to execute the
events of stepk by any possible ordering  consider a specific ordering that puts e
before all other events  therefore  e must be applicable to sk    then  by definition
   a must be a member of agenda sk     and thus m  ak      true  to see that
m  ak     f alse  consider the specific ordering of events that puts e after all other
events  if the events are executed by this ordering  the results of applying e will
appear in state sk   and thus a cannot be a member of agenda sk    we conclude that
m satisfies ek  ak   ak  

theorem    soundness of  step encoding   let p    i  g  a  be a temporal planning
problem   e         en   be the set of all events of p  and l be the  step encoding for p  if
l has a model m   then plan m   is a causally valid  step plan for p 
proof  we can obtain plan m   as follows  for each k such that    k  l  let stepk
be the set of all events e for which m  ek     true  for each k such that    k  l  let
sk be a temporal state  assume that state sk   is the set of all propositions p for which
m  pk     true  and agenda sk   is the set of all actions a for which m  ak     true  we now
show that    plan m     hstep         stepl i is a causally valid  step plan for p with the
state transition sequence hs         sl i 
from formula       it immediately follows that i   state s     formula      implies
that g  state sl    formulae      and      respectively imply that agenda s    and
agenda sn   are empty sets  now  we only need to show that for each k such that    k  l 
stepk    e         em     e         en   is a  step from sk  to sk   we first show that for any
   

fiitsat  an efficient sat based temporal planner

proposition p  stepk cannot include two different events ei and ej such that ei  rp   and
ej  ep   if j   i  since m satisfies formula        by lemma    we can infer m  eki   and
m  ekj   cannot be both equal to true  on the other hand  if i   j  since m satisfies formula
       again by lemma    we can infer m  eki   and m  ekj   cannot be both equal to true 
thus  ei and ej cannot be both members of stepk   let o            m            m  be an
arbitrary ordering function  we now show by induction on k    where k   m  the sequence
heo           eo k   i is applicable to sk    for k       i e   the case where no event is to be
applied to sk     the conclusion trivially holds  as the induction hypothesis  let sk be the
temporal state resulting from applying the sequence heo           eo k   i to sk    let eo k    
be the starting event of action a  we omit the very similar case where eo k     is the ending
event of a   we show that conditions     to     of definition   hold and thereby eo k     is
applicable to sk   as a result  heo           eo k     i will be applicable to sk   
    from formula       it easily follows that all preconditions of eo k     and all invariants of a  except for those invariants of a that are added by eo k       are members
if state sk     as mentioned above  neither of these propositions can be deleted by
another member of stepk   thus  these propositions are also members of state sk   
    from formula       it easily follows that a is not a member agenda sk     notice that
according to definition    the starting event of a  i e   eo k       is the only event that
can add a to the agenda of any state  therefore  a cannot be a member of agenda sk   
either 
    let a be any action with an invariant p such that p  del eo k        clearly we have
start a    rp   and thus  as it was argued above  start a   and eo k    cannot be both
members of stepk   hence  start a   
  stepk   on the other hand  since p is deleted in
step k  and m satisfies chain en        e    ep   rp  e     k  mp     then according to lemma   
we have  m  b  mp      true  therefore  by formula        we can infer that m  ak     
f alse  and thus  a 
  agenda sk     start a   
  stepk and a 
  agenda sk    jointly


imply that a 
  agenda sk   
we now show that sm   which is the result of applying heo           eo m  i to sk    is equal to
sk  
 let p be an arbitrary member of state sm    from formulae      and      it follows
that if p is deleted by any member of stepk   it cannot be added by any other member
    therefore  p is not deleted by
of stepk and thus  p cannot be a member
m
wof state s
k
any member of stepk   and the formula eep e is not satisfied by m   besides  if p
is not added by any member of stepk   it must be a member of state sk     and thus
m  pk      true  now  by formula       we can infer that m  pk     true  and hence
p  state sk    on the other hand  if p is added by a member of stepk   from formula
      we can deduce that m  pk     true  and again we have p  state sk    therefore 
state sm    state sk   
 let p be an arbitrary member of state sk    according to formula       p cannot be
deleted by any member of stepk   besides  by formula       p is either a member of
   

firankooh   ghassem sani

state sk    or is added by a member of stepk   in both cases  definition   implies that
p  state sm    therefore  state sk    state sm   
 let a be an arbitrary member of agenda sm    from formulae       and        it
follows that the starting and ending events of no single action can be both members of
stepk   if a  agenda sk     then because a is still open in state sm   we can infer that
end a  
  stepk   therefore  according to formula        m  ak     true  and a must
be a member of agenda sk    on the other hand  if a 
  agenda sk     then start a 
must be a member of stepk   then  by formula        we have  m  ak     true  and
again  a must be a member of agenda sk    therefore  agenda sm    agenda sk   
 let a be an arbitrary member of agenda sk    according to formula        start a 
cannot be a member of stepk   besides  by formula        a is either a member of
agenda sk    or start a  is a member of stepk   in both cases  definition   implies
that a  agenda sm    therefore  agenda sk    agenda sm   
above argument shows that state sk     state sm   and agenda sk     agenda sm    hence 
sk   sm   succ sk    heo           eo m  i   therefore  stepk is a  step from sk  to sk  
theorem    completeness of  step encoding   let p    i  g  a  be a solvable temporal planning problem   e         en   be the set of all events of p  and    hstep         stepl i
be a causally valid  step plan for p  there exists a model m for l such that    plan m   
proof  by theorem    there exists a model m for l such that    plan m    we show that
m can be translated into a model for l   since formulae     to      are shared between
l and l   then m also satisfies all these formulae  we now show that m also satisfies
all formulae       to        and therefore can be translated into a model for l   in the
following cases  a is an arbitrary temporal action  ei is the starting event of a  and ej is the
ending event of a 
      if m  eki     f alse  then formula       is trivially satisfied  if m  eki     true  then by
formula       we have  m  ak      f alse  and therefore formula       is satisfied 
      if m  eki     f alse  then formula       is trivially satisfied  if m  eki     true  then
by formula       we have  m  ak     true  and therefore formula       is satisfied 
      if m  ekj     f alse  then formula       is trivially satisfied  if m  ekj     true  then by
formula       we have  m  ak     f alse  and therefore formula       is satisfied 
      if m  ekj     f alse  then formula       is trivially satisfied  if m  ekj     true  then by
formula       we have  m  ak      true  and therefore formula       is satisfied 
      exactly the same as case       
      exactly the same as case       
      exactly the same as case       
      exactly the same as case       
   

fiitsat  an efficient sat based temporal planner

      follows immediately from the fact that m satisfies formula       
      follows immediately from the fact that m satisfies formula       

theorem    soundness of  step encoding   let p    i  g  a  be a temporal planning
problem   e         en   be the set of all events of p  and l be the  step encoding for p  if
l has a model m   then plan m   is a causally valid  step plan p 
proof  we can obtain plan m   as follows  for each k such that    k  l  let stepk be
the set of all events e for which we have m  ek     true  moreover  for each k such that
   k  l  let sk be a temporal state  assume that state sk   is the set of all propositions p
such that m  pk     true and agenda sk   is the set of all actions a such that m  ak     true 
we construct    plan m     hstep         stepl i and show that  is a causally valid  step
plan for p with state transition sequence hs         sl i 
from formula       it immediately follows that i   state s     formula      implies
that g  state sl    formulae      and      imply that agenda s    and agenda sn  
are both empty sets  now  we only need to show that for each k such that    k  l 
stepk    e         em     e         en   is a  step from sk  to sk   without loss of generality 
assume that the sequence he         em i is ordered by the fixed ordering he         en i  note that
since m satisfies formula        by lemma    for any proposition p  stepk cannot include
any two events ei and ej such that ei  rp   ej  ep   and j   i  by induction on k    we show
that for every k   m  the sequence he         ek i is applicable to sk    for k       i e   the
case where no event is applied to sk     the conclusion obviously holds  as the induction
hypothesis  let sk be the temporal state resulting from applying the sequence he         ek i
to sk    assume that ek    is the starting event of action a  we omit the very similar case
where ek    is the ending event of a   we show that conditions     to     of definition  
hold and thereby ek    is too applicable to sk  
    from formula       it clearly results that all preconditions of ek    and all invariants of a
 except for those invariants of a that are added by eo k       are members of state sk    
as we stated before  neither of these propositions can be deleted by ei for i   k    thus 
these propositions are also members of state sk   
    there are two possible cases  consider the first case  where according to the fixed
ordering he         en i  the ending event of a is located after ek      formula       implies
that a cannot be a member agenda sk     notice that according to definition    the
starting event of a  i e   ek      is the only event that can add a to the agenda of any
state  therefore  a cannot be a member of agenda sk    in the other case  where the
ending event of a is located before ek      formula       implies that either a is not
a member of agenda sk     or end a  is a member of stepk   however  if end a  is a
member of stepk   it will certainly remove a from the agenda of its resulting state  since
ek    is the only event that can add a to the agenda of any state  we can conclude that
a cannot be a member of agenda sk    therefore  in neither of these two cases  a is a
member of agenda sk   
   

firankooh   ghassem sani

    let a be an action that has p  del ek      as an invariant  since p is deleted in step k 
and m satisfies chain e         en   ep   rp  en      k  mp     then according to lemma    we
have m  bn   np      true  therefore  by formula        we have a 
  agenda sk    on
the other hand  we clearly have end a    rp   and thus  as we argued before  if end a  
is a member of stepk   it cannot be located after ek    in the fixed ordering he         en i 
hence  if a is not a member of agenda sk    it cannot be a member of agenda sk   
either  therefore  we can infer that a 
  agenda sk   
we now show that sm   which is the result of applying he         em i to sk    is equal to sk  
 by the same argument given in the proof of theorem    we have state sm    state sk  
and state sk    state sm    hence  state sm     state sk   
 let a be an arbitrary member of agenda sm    let ei and ej be the starting and ending
events of a  respectively  there are three possible cases  consider the first case where
a  agenda sk     ei 
  stepk   and ej 
  stepk  i e   a is open immediately before step
k and is neither started nor ended in step k   in this case  since m satisfies        we
have m  ak     true  and therefore  a  agenda sk    consider the second case where
a  agenda sk     ei  stepk   ej  stepk   and j   i  i e   a is open immediately
before step k  and is first ended and then started again in step k   in this case  since
m satisfies formula        we have m  ak     true  and therefore  a  agenda sk   
finally  consider the third case where a 
  agenda sk     ei  stepk   and ej 
  stepk
 i e   a is not open immediately before step k  and it is started but not ended in
step k   in this case  if j   i  then m must satisfy formula       and we have
m  ak     true  on the other hand  if i   j  then m must satisfy formula       and 
since m  ekj     f alse  we must have m  ak     true  and therefore  a  agenda sk   
consequently  in all these three cases  a must be a member of agenda sk    hence
agenda sm    agenda sk   
 let a be an arbitrary member of agenda sk    i e   m  ak     true  there are two
possible cases  case    a is not a member of agenda sk     and hence m  ak     
f alse  by formula        we have  m  eki     true  this means that a is started in
step k  now  if j   i  the ending event of a cannot happen after its starting event 
and therefore  a must remain open after the execution of step k  i e   a  agenda sm   
on the other hand  if i   j  by formula       we have  m  ekj     f alse  this
means that a is started but not ended in step k  and therefore a must remain open
after the execution of step k  i e   a  agenda sm    now consider case    a is a
member of agenda sk     and hence m  ak      true  if i   j  by formula      
we have m  eki     f alse  and by formula       we have m  ekj     f alse  this means
that a is open immediately before the execution of step k  and is neither started nor
ended in step k  therefore  a must also be open after the execution of step k  i e  
a  agenda sm    on the other hand  if j   i  since both m  ak   and m  ak    are
false  formulae       and       can be combined to form the formula  eki  ekj   
this means that a is ended in step k if and only if it is later started again in the same
step  therefore  again a must be open after the execution of step k  and we have
a  agenda sm    therefore  agenda sk    agenda sm   
   

fiitsat  an efficient sat based temporal planner

above arguments show that state sk     state sm   and agenda sk     agenda sm    hence 
sk   sm   succ sk    he         em i   therefore  for the ordering functions o            m  
         m   such that o i    i  we have sk   succ sk    heo           eo m  i   and thus stepk is
a  step from sk  to sk  
lemma    let m be a model for chain  e         en   ep    ep   rp   k  mp    ej be a member of
rp   and epm    e e  ep   ep   m  ek     true   m have the following properties 
 if there exists no event ei such that ei  epm and i   j  then m  bkj mp     m  pk    
 if there exists an event ei such that ei  ep    i   j   ei          ej     epm     and
m  eki     true  then m  bkj mp     true 
 if there exists an event ei such that ei  ep   i   j   ei          ej     epm     and
m  eki     true  then m  bkj mp     f alse 
proof 
 assume that there exists no event ei such that ei  epm and i   j  consider the
case where we have m  pk      true  let  ei         eim   be the set of all events ei
such that ei  rp  ep   ep   and    i  j  without loss of generality  we can
assume that     i    i          im   j  since m must satisfy  c      we know that
m  bki  m     true  assume that for an arbitrary s  m  bkis  mp     true  if eis  ep  ep  
 

p

then we know that m  ekis     f alse  and by  c     we have m  bki


s    mp

other hand  if eis 

rp ep  ep  

by

 c     

we have

m  bki  m  
p
s  

    true  on the

  true  we can infer

that for each    s  j  we have m  bkis  mp     true  and thereby m  bkj mp     m  pk    
the proof for the case where we have m  pk      f alse is analogous  except that
instead of  c      we need to use  c      
 assume that there exists an event ei such that ei  ep    i   j   ei          ej    
epm     and m  eki     true  let  ei         eim   be the set of all events ei such that
ei  rp  ep   ep   and i  i  j  without loss of generality  we can assume that i  
i    i          im   j  since m must satisfy  c      we know that m  bki  m     true 
 

p

assume that for an arbitrary s     m  bkis  mp     true  if eis  ep   ep   then we
know that m  ekis     f alse  and by  c      we have m  bki
hand  if eis  rp 

ep 



     true  on the other
s    mp
k
by
we have m  bi  m     true  we can infer
p
s  
k
have m  bis  mp     true  and thereby m  bkj mp     true 

ep  

that for each    s  j  we

 c     

 assume that there exists an event ei such that ei  ep   i   j   ei          ej    
epm     and m  eki     true  let  ei         eim   be the set of all events ei such that
ei  rp  ep   ep   and i  i  j  without loss of generality  we can assume that i  
   

firankooh   ghassem sani

i    i          im   j  since m must satisfy  c      we know that m  bki  m     f alse 
 

p

assume that for an arbitrary s     m  bkis  mp     f alse  if eis  ep   ep   then we
know that m  ekis     f alse  and by  c      we have m  bki
hand  if eis  rp 

ep 



     f alse  on the other
s    mp
k
by
we have m  bi  m     f alse  we can infer
p
s  
k
have m  bis  mp     f alse  and thereby m  bkj mp     f alse 

ep  

that for each    s  j  we

 c     


lemma    let m be a model for chain e         en     ep   rp   k  mof
p    assume that ei  ep  
m  eki     true  and p  inv a   let ej and ej   be the starting event and ending event of
a  respectively  m has the following properties 

 if m  ekj       true  and i   j  then m  ekj     true 
 if m  ak     true  then m  ekj     true 
proof  let  ei         eim   be equal to the set  es  es  op   i   s  n       without loss
of generality  we can assume that i    i          im   n      since m  eki     true  by
 cof      we can infer that m  bi   mof     true  for each s  such that m  bis  mof     true  by
p

p

 cof      we can deduce that m  bis    mof     true  therefore  we have m  bn   mof     true 
p
p
furthermore  if i   j  we have ej     ei         eim    and thus m  bj   mof     true  besides 
p

if m  ekj       true  then by  cof      we have m  ekj     true  on the other hand  if m  ak    
true  we can infer from formula  cof     that m  ekj     true 

lemma    let m be a model for chain e         en   ep   rp   k  mob
p    assume that ei  ep  
m  eki     true  and p  inv a   let ej and ej   be the starting event and ending event of
a  respectively  m has the following properties 

 if m  ekj     true  and j       i  then m  ekj       true 
 if m  ak      true  then m  ekj       true 
proof  the proof is very analogous to that of lemma    and thus is omitted 
theorem    completeness of the relaxed  step encoding   let p    i  g  a 

be a temporal planning problem and formulae l and l be two  step encodings of

p explained in section    if m is a model for l   then l has a model m  such that
plan m      plan m   
proof  let m be a model for l   we construct the function m  to assign a value of true

or f alse to each binary variable of l   by using the following rules 
 r    for    i  n and    k  l  m   eki     m  eki   
   

fiitsat  an efficient sat based temporal planner

 r    for    k  l  m   ek      m   ekn       f alse 
 r    for    k  l and each proposition p  m   pk     m  pk   
 r    for    k  l and each action a  m   ak     m  ak   
 r    for    i  n         k  l  and each proposition p  if there exist j   i such that
m  ekj     true and ej  ep   ep then m   bki mp     m  pk    otherwise  m   bki mp    
m  pk    
 r    for    i  n         k  l  and each proposition p  if there exist j   i such that
m  ekj     true and ej  ep then m   bk of     true  otherwise  m   bk of     f alse 
i mp

i mp

 r    for    i  n     k  l  and each proposition p  if there exist j   i such that
m  ekj     true and ej  ep then m   bki mob     true  otherwise  m   bki mob     f alse 
p

p

we now show that m  satisfies all formulae       to         and therefore is a model for

l   from above rules  it should be clear that we have plan m      plan m   
      formula       is exactly the same as       besides  m and m  assign the same
value to each variable of this formula 
      formula       is exactly the same as       besides  m and m  assign the same
value to each variable of this formula 
      formula       is exactly the same as       besides  m and m  assign the same
value to each variable of this formula 
      formula       is exactly the same as       besides  m and m  assign the same
value to each variable of this formula 
      formula       is the conjunction of formulae  c     to  c      we show that m 
satisfies all formulae  c     to  c      and thereby  it satisfies       
 consider an arbitrary formula eki  bkj mp from  c      if m  eki     f alse  then
the formula is trivially satisfied  if m  eki     true  then by  r     we have
m   bki mp     m  pk    on the other hand  because m satisfies       we have
m  pk     true  therefore  m   bki mp     true  and the formula is satisfied again 
 consider an arbitrary formula eki  bkj mp from  c      if m  eki     f alse 
then the formula is trivially satisfied  if m  eki     true  then by  r     we have
m   bki mp     m  pk    on the other hand  because m satisfies       we have
m  pk     f alse  therefore  m   bki mp     f alse  and the formula is satisfied
again 
 consider an arbitrary formula bki mp  bkj mp from  c      since ei is not a
member of ep   ep   and none of the events located between ei and ej in the
fixed ordering are members of ep   ep   then by  r     we can easily show
that m   bki mp     m   bkj mp    thus  the formula is satisfied 
   

firankooh   ghassem sani

 consider an arbitrary formula bki mp  eki  bkj mp from  c      if m  eki    
true  then the formula is trivially satisfied  if m  eki     f alse  then since none
of the events located between ei and ej in the fixed ordering are members of
ep  ep   then by  r     we can easily show that m   bki mp     m   bkj mp    thus 
the formula is satisfied 
 consider an arbitrary formula bki mp eki  bkj mp from  c      by the same
argument as the one given for  c      we can infer that m   bki mp     m   bkj mp   
thus  the formula is satisfied 
 consider an arbitrary formula bki mp  eki from  c      if m   bki mp     true 
then the formula is trivially satisfied  if m   bki mp     f alse  then there exist two
possible cases  case    there exists an event ej such that j   i  m  ekj     true 
and ej  ep  ep   in this case  by  r     we have m  pk     m   bki mp     f alse 
since m must also satisfy       we have ej 
  ep    and thus ej  ep   besides 
m must satisfy        which implies m  eki     f alse  by  r     we have
m   eki     m  eki     f alse  and therefore  the formula is satisfied  case    there
does not exist any event ej such that j   i  m  ekj     true  and ej  ep   ep  
in this case  by  r     we have m  pk      m   bki mp     f alse  now  since
m must satisfy       we can infer that m  eki     f alse  by  r     we have
m   eki     m  eki     f alse  and therefore  the formula is satisfied again 
 consider the formula bk  mp  pk  from  c      from  r     it can be easily deducted that m   bk  mp   is always equal to m  pk     by  r     we have
m   pk      m  pk     as a result  m   bk  mp     m   pk     and the formula is
satisfied 
 consider the formula bkn   mp  pk from  c      there are two possible cases 
case    there exists an event e such that m  ek     true  and e  ep   ep  
in this case  by  r     we have m   bn   mp     m  pk    now  by  r     we
have m  pk     m   pk    therefore  m   bn   mp     m   pk    and the formula is
satisfied  case    there does not exist any event e such that m  ek     true and
e  ep  ep   in this case  by  r     we have m   bn   mp     m  pk     besides 
since m satisfies formulae      and the right hand side of      becomes f alse 
the left hand side of       i e   pk   pk   has to be f alse  too  thus  if
m  pk      f alse  then we have m  pk     f alse  a similar argument about
     can show that if m  pk      true  then we have m  pk     true  thus 
m  pk      m  pk    and by  r     we have m   pk     m  pk     therefore 
m   bn   mp     m  pk      m   pk    and the formula is satisfied again 
      we show that m  satisfies all formulae  cof     to  cof      and thereby  it satisfies
      
 consider an arbitrary formula eki  bk

j mof
p

from  cof      we know from  cof  

   that i   j  if m   eki     f alse  the formula is trivially satisfied  if m   eki    
true  by  r     we have m   bj mof     true  and the formula is satisfied 
p

   

fiitsat  an efficient sat based temporal planner

 consider an arbitrary formula bk

i mof
p

from  cof      if m   bk

 bk

j mof
p

i mof
p

  f alse  the formula is trivially satisfied  if m   bk

i mof
p

 

    true  by the rule

i

 r     there must exist an event ei   such that
  i  m  eki     true  and
ei  ep   since we have i   j  we must also have i   j  now  by  r     we
have m   bj mof     true  and the formula is satisfied 
p

 consider an arbitrary formula bk

j mof
p

 ekj  eki from  cof      if m   bk

j mof
p

f alse  the formula is trivially satisfied  if m   bk

j mof
p

  

    true  by  r     there

must exist an event ej  such that j    j  m  ekj     true  and ej   ep   now 
since m satisfies        we can infer that m  ekj     f alse  by  r     we have
m   ekj     m  ekj     f alse  and therefore  the formula is satisfied 
 consider an arbitrary formula bk

n   mof
p

ak  eki from  cof      if m   bk

n   mof
p

  f alse  the formula is trivially satisfied  if m   bk

 

    true  by  r    

n   mof
p
k
an event ej such that m  ej     true and ej  ep   now 
       we can infer that m  ak     f alse  by  r     we have

there must exist
since m satisfies
m   ak     m  ak     f alse  and therefore  the formula is satisfied 

      we show that m  satisfies all formulae  cob     to  cof      and thereby  it satisfies
      
 consider an arbitrary formula eki  bkj mob from  cob      we know from  cob    
p

that j   i  if m   eki     f alse  the formula is trivially satisfied  if m   eki    
true  by  r     we have m   bj mob
    true  and the formula is satisfied 
p
 consider an arbitrary formula bki mob  bkj mob from  cob      if m   bki mob    
p

p

p

f alse  the formula is trivially satisfied  if m   bki mob     true  by the rule  r    
p

there must exist an event ei such that i   i   m  eki     true  and ei  ep  
since we have j   i  we must also have j   i   now  by  r     we have
    true  and the formula is satisfied 
m   bj mob
p
 consider an arbitrary formula bki mob  eki  ekj from  cob      if m   bki mob    
p

p

f alse or m   eki     f alse  the formula is trivially satisfied  if m   bki mob     true
p

and m   eki     true  by  r     there must exist an event ei   such that i   i  
m  eki     true  and ei  ep   since m satisfies        we can infer that
m  ak     f alse  however  we know that i   j      j  thus m must satisfy       therefore  we have m  ekj     true  by  r     we have m   ekj     m  ekj    
true  and therefore  the formula is satisfied 
 consider an arbitrary formula bk  mob  ak   ekj from  cob      if m   bk  mob    
p

p

f alse or m   ak      f alse  the formula is trivially satisfied  if m   bk  mob    
p

true and m   ak      true  by  r     there must exist an event ei such that
m  eki     true  and ei  ep   since m satisfies        we can infer that
m  ak     f alse  however  m must satisfy        therefore  we have m  ekj    
   

firankooh   ghassem sani

true  by  r     we have m   ekj     m  ekj     true  and therefore  the formula
is satisfied 
      consider an arbitrary formula eki  ak  from        let ej be the ending event
of a  we know that i   j      j  therefore  m must satisfy             
is exactly the same as        besides  m and m  assign the same value to each
variable of these formulae  thus        is satisfied by m   
      consider an arbitrary formula eki  ak ekj from        we know that i   j     j 
therefore  m must satisfy formula              is exactly the same as       
besides  m and m  assign the same value to each variable of these formulae  thus 
      is satisfied by m   
       consider an arbitrary formula ekj  ak from         let ei be the starting event
of a  we know that i   j      j  therefore  m must satisfy              
is exactly the same as        besides  m and m  assign the same value to each
variable of these formulae  thus        is satisfied by m   
       consider an arbitrary formula ekj  ak   eki from         we know that i  
j      j  therefore  m must satisfy               is exactly the same as       
besides  m and m  assign the same value to each variable of these formulae  thus 
       is satisfied by m   
              is exactly the same as        besides  m and m  assign the same value to
each variable of these formulae  thus         is satisfied by m   
              is exactly the same as        besides  m and m  assign the same value to
each variable of these formulae  thus         is satisfied by m   

theorem    soundness of the relaxed  step encoding   let p    i  g  a  be a

temporal planning problem   e         en   be the set of all events of p  and l be the relaxed

 step encoding for p  if l has a model m   then plan m   is a causally valid  step plan
p 
proof  we can obtain plan m   as follows  for each k such that    k  l  let stepk be
the set of all events e for which we have m  ek     true  for each k such that    k  l 
let sk be a temporal state  assume that state sk   is the set of all propositions p such that
m  pk     true  and agenda sk   is the set of all actions a such that m  ak     true  we
construct    plan m     hstep         stepl i and show that  is a causally valid  step plan
for p with state transition sequence hs         sl i 
from        it immediately follows that i   state s     also        implies that g 
state sl    besides        and       imply that agenda s    and agenda sn   are empty sets 
respectively  now we only need to show that for each k such that    k  l  stepk  
 ei         eim     e         en   is a  step from sk  to sk   without loss of generality  we
   

fiitsat  an efficient sat based temporal planner

assume that the sequence hei         eim i is ordered according to the fixed ordering he         en i 
i e   i    i          im  
by induction on k    we can conclude that for each k   m  the sequence hei         eik i is
applicable to sk    for k       i e   the case  where no event is applied to sk     the conclusion obviously holds  let sk be the temporal state resulting from applying hei         eik i
to sk    assume that eik    is the starting event of action a  we omit the very similar case
where eik    is an ending event of a  we show that conditions     to     of definition  
holds and thereby eik    is applicable to sk  
    assume that p 
  state sk    where p is either a precondition of eik    or an invariant
of a that is not added by eik      there are two possible cases  case    p is not a
member of state sk     and is not added or deleted by any member of  ei         eik   
in this case  we have m  pk      f alse  moreover  there exists no event ei such that
ei  ep   ep   i   k       and m  eki     true  case    p is deleted by an event
ei  stepk and is not added or deleted by any event ej  stepk   such that i   j  k   
in this case  we have ei  ep   i   ik       ei          eik       epm     and m  eki     true 
where epm    e e  ep   ep   m  ek     true   in both cases  by lemma    we have
m  bkik     mp     f alse  which contradicts the fact that m satisfies  c     
    since m satisfies        a is not a member of agenda sk     however  eik    is the only
event in stepk that can add a to the agenda of any state  thus  a is not a member of
agenda sk   
    let b be any action other than a  with an invariant p  del eik       let ej and ej  
be the starting and ending events of b  respectively  as mentioned earlier  we assume
that the ending event of each action is located immediately after its starting event in
the fixed ordering  we show that b cannot be a member of agenda sk    there are
two possible cases in which b may be a member of agenda sk    case    b is an open
action immediately before the execution of stepk   and b it is not ended in stepk until
eik    is executed  in this case  we have m  bk      true  and m  ekik        true  since
m satisfies        by lemma    we have m  ekj       true  as we just assumed that b
is not ended until the execution of eik      we have ik      j      on the other hand 
since ej is the starting event of b  we have ik       j  and thus  ik      j  therefore 
by lemma    we have m  ekj     true  this contradicts the fact that m satisfies       
because here we have m  bk      true  m  ekj     true  and ej   start b   case    b is
started in step k  and it is not ended during step k until the execution of eik      in this
case  we have m  ekj     true  m  ekj       f alse  j       ik      and m  ekik        true 
since m satisfies        by lemma    we must have m  ekj       true  which again is a
contradiction 
we now show that sm   which is the result of applying hei         eim i to sk    is equal to sk  
 let p be an arbitrary proposition  if p  state sm    there are two possible cases 
case    p is a member of state sk     and is not added or deleted by any member of
 ei         eim    in this case  we have m  pk      true  moreover  there exists no event ei
such that ei  ep   ep   i   n      and m  eki     true  case    p is added by an event
   

firankooh   ghassem sani

ei  stepk and is not added or deleted by any event ej  stepk   such that i   n     
in this case  we have ei  ep    i   n       ei          en    epm     and m  eki     true 
where epm    e e  ep   ep   m  ek     true   in both cases  by lemma    we
have m  bkn   mp     true  since m satisfies  c      we have m  pk     true  and thus
p  state sk    therefore  state sm    state sk   
 let p be an arbitrary proposition  if p 
  state sm    there are two possible cases  case
   p is not a member of state sk     and is not added or deleted by any member of
 ei         eim    in this case  we have m  pk      f alse  moreover  there exists no event
ei such that ei  ep   ep   i   n      and m  eki     true  case    p is deleted by
an event ei  stepk and is not added or deleted by any event ej  stepk   such that
i   j   n      in this case  we have ei  ep   i   n       ei          en    epm     and
m  eki     true  where epm    e e  ep  ep   m  ek     true   in both cases  by lemma
   we have m  bkn   mp     f alse  since m satisfies  c      we have m  pk     f alse 
and thus p 
  state sk    therefore  state sk    state sm   
 let a be an arbitrary action  and ei and ej be its starting event and ending event 
respectively  if a  agenda sm    since we assume that the ending event of each action
is located immediately after its starting event in the fixed ordering  there are only two
possible cases  case    a is open immediately before step k  and is not ended during
step k  in this case  we have m  ak      true and m  ekj     f alse  since m satisfies
        we must have m  ak     true  therefore  a  agenda sk    case    a is started
but not ended in step k  in this case  we have m  eki     true and m  ekj     f alse  as
m satisfies        we must have m  ak     true  therefore  a  agenda sk    since in
both cases  we have a  agenda sk    we can infer that agenda sm    agenda sk   
 let a be an arbitrary action  and ei and ej be its starting event and ending event of a 
respectively  if a 
  agenda sm    since we assume that ending event of each action is
located immediately after its starting event in the fixed ordering  there are only two
possible cases  case    a is not open immediately before execution of step k  and is
not started during step k  in this case  we have m  ak      f alse and m  eki     f alse 
since m satisfies         we must have m  ak     f alse  therefore  a 
  agenda sk   
k
case    a is ended in step k  in this case  we have m  ej     true  since m satisfies
        we must have m  ak     f alse  therefore  a 
  agenda sk    because in both
cases  we have a 
  agenda sk    we can infer that agenda sk    agenda sm   
the above arguments show that state sk     state sm   and agenda sk     agenda sm   
hence  we have sk   sm and sk   succ sk    hei         eim i   therefore  for the ordering functions o            m            m   where o i    i  we have sk   succ sk    heo i           eo im   i  
and thus stepk is a  step from sk  to sk  

theorem    let p    i  g  a  be a temporal planning problem     he         en i be a
causally valid plan for p  and             n   q be a relaxed scheduling function for  
there exists a valid temporal plan for p 
   

fiitsat  an efficient sat based temporal planner

proof  by using the bubble sort algorithm  we can sort the events of  in an increasing order
according the values given to them by    this algorithm takes two consecutive members
of a sequence  and swaps them only if the value of the first one is greater than that of the
second one  it continues doing the swaps until the whole sequence is properly sorted  let ei
and ej be two events swapped by the bubble sort in any stage of the algorithm  assume that
ei is located before ej in the sequence prior to swapping   then  we must have   i      j  
thus  according to  s     we know that ei and ej are swappable  c f   definition      as a
result  if the whole sequence was a causally valid plan prior to swapping  it would also be a
causally valid plan after that swapping  this means that sorting  according to the values
given by  will result in another causally valid plan  say     the plan   obviously satisfies
the two conditions of definition    and therefore          is a valid temporal plan for p 

theorem     let p    i  g  a  be a solvable temporal planning problem  and com be
the set of every member of a that is either compressible towards its start or compressible
towards its end  definition      there exists a valid temporal plan       for p such that
 is a causally valid plan for p   is compressed with respect to com  and  is a relaxed
scheduling function for  
proof  let     e         ei   ei          en be a causally valid plan for p such that ei and ei   are
two swappable events  let     e         ei     ei        en be the result of swapping ei and ei  
in     we show that if  is a relaxed scheduling function for     then it is also a relaxed
scheduling function for    
 consider any two events ej and ek such that in     ej is located before ek   if j    i    
or k    i  then in     ej is definitely located before ek   too  and therefore the property
 s    holds for ej and ek   on the other hand  if j   i     and k   i  ej and ek are
swappable and therefore the property  s    trivially holds for ej and ek  
 assume that ej is the starting event of a particular action a  and ek is the pairing
event of ej in     from definition    we can easily infer that if in     ei is located
between ej and ek   then ei cannot be the starting or ending event of a  similarly  if
ei   is located between ej and ek   then ei   cannot be the starting or ending event of
a  on the other hand  since ei and ei   are swappable  we know that they cannot be
both some events of the same action  and therefore  either j    i     or k    i  thus 
swapping ei and ei   cannot falsify the fact that ej and ek are pairing events  in other
words  in     too  ek is the pairing event of ej   this implies that the property  s   
holds for ej and ek  
let         be an arbitrary valid temporal plan for p  since  is a scheduling function for
    it can obviously be also regarded as a relaxed scheduling function for     as we showed
in section        can be transformed to a causally valid plan  that is compressed with
respect to com  by doing a series of swaps  where each swapping occurs between a pair
of consecutive swappable events  therefore   must also be a relaxed scheduling function
for   and       is a valid temporal plan for p  where  is the same scheduling function
as   
   

firankooh   ghassem sani

p
theorem     let p    i  g  a  be a temporal planning problem 
   e         en   be the




set of all events of p  l be any of the three formulae l   l   l  defined in section
p     and 
be a non empty causally valid plan for p obtained by solving l   let     s     t   x    a  
be an fsm that accepts a subsequence     he         em i of   and 
l be the encoding of
 presented by      to       there does not exist any model m for l  
l such that
   plan m   
proof  we give the proof by contradiction  assume that there exists a model m for l  
l
such that    plan m    let f            m      p
     n  be a function such that for each i 
f  i  is equal to the index of the i th event of   in   moreover  let g            m            l 
be a function such that for each i  g i  is equal to the step number of the sat variable in
l that corresponds to the i th event of     assume x         xm to be a sequence of states
of  such that for     i  m  we have xi   t  xi    ef  i     since  accepts     we must
f     g   

have xm  a   as m satisfies       we have m  x 
    true  here  two cases can be
considered  case    g      g     in this case  since    plan m    for f       j   f      we
g   
must have m  ej     f alse  now  by considering       and        we can infer that
g    f    

m  x 
    true  case    g      g     in this case  by considering       and       
g    n  
we can infer that m  x 
    true  then by  considering        we can deduce that
g       
m  x 
    true  by the same argument plus considering       we can show that
g    f    
g i  f  i 
m  x 
    true  the whole deduction can be repeated to show that m  xi 
    true
g m  f  m 

for    i  m  therefore  we have m  xm 
    true  since xm   t  xm    ef  m    
out  e in   e
by considering        we can infer that for j  such that ej  em
n     and
m
g m  j
in
out
    true  however  since xm  a  
 ef  m           ej      em  em       we have m  xm
this contradicts the assumption that m satisfies       
p
theorem     let p    i  g  a  be a temporal planning problem 
   e         en   be



the set of all events of p  and l be any of the three formulae l   l   l  defined in
section     let m be a model that satisfies l   and    he         em i   plan m    let
p
    s     t   x    a   be an fsm that does not accept any subsequence of   and 
l be


the encoding of  composed of      to       there exists a model m for l  l such
that    plan m    
proof  let us introduce a total order relation  on those sat variables of l that correspond


to events of the input problem  for any two sat variables eki and eki   we have eki  eki if
and only if one of the following two conditions holds     k   k       k   k  and i   i  
assume that f            m           pn  is a function such that for each i  f  i  is equal to
the index of the i th event of  in   moreover  assume that g            m            l  is
a function such that for each k  g k  is equal to the step number of the sat variable in l
that corresponds to the k th event of   let uk i   heu        et i denote a subsequence of 
with the following properties 
g t 

 m  ef  t      true 
   

fiitsat  an efficient sat based temporal planner

g t 





 for all i and k  such that ef  t   eki  eki   we have m  eki     f alse 
in fact  uk i is a substring of  that spans from the u th event of  to the last event of 
whose corresponding sat variable is located before eki in l   we define the model m  for
l  
l by the following rules 
 r    for each sat variable v of l   m   v    m  v  
 r    for    k  l and    i  n  m   xk i
      true 
 r    for    k  l      i  n  and xs  s   m   xk i
s     true iff for some j  the sequence
jk i transforms  from x  to xs  
from  r     we can infer that m  satisfies l   we now show that m  also satisfies all
formulae      to       and thereby  it satisfies 
l  
 xk j
be an arbitrary formula from       if m   eki     f alse or
     let eki  xk i
s
t
 k i
 k
m   xk i
s     f alse  the formula is trivially satisfied  assume that m  ei     m  xs    
k i
true  by  r     for some u  the sequence u transforms  from x  to xs   since
eki  ekj   by the way we defined uk j   we can deduce that uk j   uk i  hei i      where   
denotes the concatenation operator and   is a sequence of events from  ei          ej    
by       we have t  xs   ei     xt   and therefore ei causes  to transit from xs to
xt   besides   ei          ej     etout     and thus  no member of   can cause  to
transit to a state other than xt   therefore  uk j transforms  from x  to xt   and
m   xk j
t     true  hence  the formula is satisfied 
k j
be an arbitrary formula from       if m   eki     true or
     let eki  xk i
s  xs
 k
m   xk i
s     f alse  the formula is trivially satisfied  assume that m  ei     f alse and
k i
m   xk i
s     true  by  r     for some u  the sequence u transforms  from x  to xs  
k j
since eki  ekj   by the way we defined u   we can deduce that uk j   uk i      where
  is a sequence of events from  ei          ej     besides   ei          ej     esout    
and thus  no member of   can cause  to transit to a state other than xs   therefore 
uk j transforms  from x  to xs   and m   xk j
s     true  hence  the formula is satisfied 
k i
 k  
     let xk  
s  xs be an arbitrary formula from       if m  xs     f alse  the formula
is trivially satisfied  assume that m   xk  
s     true  by  r     for some u  the
k  
sequence u transforms  from x  to xs   since ek   eki   by the way we defined uk i  
we can deduce that uk i   uk       where   is a sequence of events from  e         ei    
besides   e         ei   esout     and thus  no member of   can cause  to transit to a
state other than xs   therefore  uk i transforms  from x  to xs   and m   xk i
s     true 
hence  the formula is satisfied 

     let xk n  
 xk    
be an arbitrary formula from       by the way we defined
s
s
k    
   
  we can deduce that uk n     uk     for every u  therefore  m   xk n  
u
s
k    

m  xs
   hence  the formula is satisfied 
     according to  r     any formula from      is directly satisfied by m     
   

firankooh   ghassem sani

     let xk i be an arbitrary formula from       accorrding to our assumptions  uk i
cannot cause  to transit to any of its accepting states  since we have x  a    r   
implies that m   xk i     f alse  hence  the formula is satisfied 

theorem     let n   xi         xim be a negative cycle in the stn corresponding to a
causally valid plan    e         en of a temporal problem p  where xik is the node corresponding to event eik of   let   be another causally valid plan for p  if a subsequence of
  is a member of ln  defined in section     the corresponding stn of   will also have n
as a negative cycle 
proof  let ei    e         e  k    ei         eim    em          em km   eim be a subsequence of     where
ej          ej kj is a string of symbols in j   for     j  m  consider two arbitraty events
eij and eij  from this sequence  such that ij   ij    we show that any temporal constraints
between   eij   and   eij    is also present between   ij   and   ij    
 if we have the constraint   ij       ij     then by the scheduling constraint  s   
explained in section    eij and eij  are not swappable  besides  in     eij is clearly
located before eij    consequently  we must have   ij       ij    according to the
scheduling constraint  s    
 if we have the constraint   ij     ij     dur a   then by the scheduling rule  s     eij
and eij  have to be the starting event and the ending event of a  respectively  moreover 
for j   j    j    we have action eij       a  this indicates that for j   j   j    a is
in oj    and therefore eij  
  j    since ej          ej   k  is a string of symbols in j   
j
we conclude that in     a is not yet ended before reaching eij    this means that eij
and eij  are pairing events in     thus  by the scheduling constraint  s     we have
  ij       ij     dur a  
this shows that any edge between xij and xij  in the corresponding stn of  is also present
in the corresponding stn of     and thus the latter stn has n as its negative cycle 

references
allen  j  f          towards a general theory of action and time  artif  intell          
       
armando  a     giunchiglia  e          embedding complex decision procedures inside an
interactive theorem prover  ann  math  artif  intell                   
benton  j   coles  a  j     coles  a          temporal planning with preferences and
time dependent continuous costs  in proceedings of the twenty second international
conference on automated planning and scheduling  icaps       atibaia  sao paulo 
brazil  june             
biere  a          p re i cosat sc    solver description for sat competition       in sat
     competitive event booklet 
   

fiitsat  an efficient sat based temporal planner

biere  a          lingeling  plingeling and treengeling entering the sat competition      
in proceedings of sat competition      
blum  a     furst  m  l          fast planning through planning graph analysis  artif 
intell                    
castellini  c   giunchiglia  e     tacchella  a          sat based planning in complex
domains  concurrency  constraints and nondeterminism  artif  intell                
    
coles  a  j   coles  a   fox  m     long  d          extending the use of inference in
temporal planning as forwards search  in proceedings of the   th international conference on automated planning and scheduling  icaps       thessaloniki  greece 
september             
coles  a  j   coles  a   fox  m     long  d          forward chaining partial order planning  in proceedings of the   th international conference on automated planning and
scheduling  icaps       toronto  ontario  canada  may              pp       
cormen  t  h   leiserson  c  e   rivest  r  l     stein  c          introduction to algorithms
    ed    mit press 
cushing  w   kambhampati  s   mausam    weld  d  s          when is temporal planning
really temporal   in ijcai       proceedings of the   th international joint conference on artificial intelligence  hyderabad  india  january             pp           
dechter  r   meiri  i     pearl  j          temporal constraint networks  artif  intell  
               
do  m  b     kambhampati  s          sapa  a multi objective metric temporal planner 
j  artif  intell  res   jair              
een  n     biere  a          effective preprocessing in sat through variable and clause
elimination  in theory and applications of satisfiability testing   th international
conference  sat       st  andrews  uk  june              proceedings  pp       
ernst  m  d   millstein  t  d     weld  d  s          automatic sat compilation of planning
problems  in proceedings of the fifteenth international joint conference on artificial
intelligence  ijcai     nagoya  japan  august                volumes  pp      
     
eyerich  p   mattmuller  r     roger  g          using the context enhanced additive
heuristic for temporal and numeric planning  in proceedings of the   th international conference on automated planning and scheduling  icaps       thessaloniki 
greece  september             
fox  m     long  d          pddl   modelling continuous time dependent effects  in the
third international nasa workshop on planning and scheduling for space 
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  j  artif  intell  res   jair             
fox  m     long  d          a note on concurrency and complexity in temporal planning 
in the   th workshop of the uk planning and scheduling special interest group 
   

firankooh   ghassem sani

garrido  a   fox  m     long  d          a temporal planning system for durative actions of
pddl     in proceedings of the   th eureopean conference on artificial intelligence 
ecai      lyon  france  july       pp         
gerevini  a   saetti  a     serina  i          an approach to temporal planning and scheduling in domains with predictable exogenous events  j  artif  intell  res   jair      
       
gerevini  a     schubert  l  k          inferring state constraints for domain independent
planning  in proceedings of the fifteenth national conference on artificial intelligence
and tenth innovative applications of artificial intelligence conference  aaai    
iaai     july              madison  wisconsin  usa   pp         
halsey  k          crikey  its co ordination in temporal planning  ph d  thesis  university of durham 
halsey  k   long  d     fox  m          multiple relaxations in temporal planning  in
proceedings of the   th eureopean conference on artificial intelligence  ecai     
including prestigious applicants of intelligent systems  pais       valencia  spain 
august              pp           
haslum  p          improving heuristics through relaxed search   an analysis of tp  and
hsp a in the      planning competition  j  artif  intell  res   jair              
haslum  p     geffner  h          admissible heuristics for optimal planning  in proceedings of the fifth international conference on artificial intelligence planning systems 
breckenridge  co  usa  april              pp         
helmert  m     geffner  h          unifying the causal graph and additive heuristics  in
proceedings of the eighteenth international conference on automated planning and
scheduling  icaps       sydney  australia  september              pp         
hoffmann  j   gomes  c  p   selman  b     kautz  h  a          sat encodings of statespace reachability problems in numeric domains  in ijcai       proceedings of the
  th international joint conference on artificial intelligence  hyderabad  india  january             pp           
hoffmann  j     nebel  b          the ff planning system  fast plan generation through
heuristic search  j  artif  intell  res   jair              
huang  r   chen  y     zhang  w          an optimal temporally expressive planner 
initial results and application to p p network optimization  in proceedings of the
  th international conference on automated planning and scheduling  icaps      
thessaloniki  greece  september             
huang  r   chen  y     zhang  w          sas  planning as satisfiability  j  artif  intell 
res   jair              
kautz  h  a     selman  b          planning as satisfiability  in ecai  pp         
kautz  h  a     selman  b          pushing the envelope  planning  propositional logic and
stochastic search  in proceedings of the thirteenth national conference on artificial
intelligence and eighth innovative applications of artificial intelligence conference 
aaai     iaai     portland  oregon  august            volume     pp           
   

fiitsat  an efficient sat based temporal planner

long  d     fox  m          exploiting a graphplan framework in temporal planning  in
proceedings of the thirteenth international conference on automated planning and
scheduling  icaps        june             trento  italy  pp       
lu  q   huang  r   chen  y   xu  y   zhang  w     chen  g          a sat based approach
to cost sensitive temporally expressive planning  acm tist            
mali  a  d     liu  y          t satplan  a sat based temporal planner  international
journal on artificial intelligence tools                 
rankooh  m  f     ghassem sani  g          new encoding methods for sat based temporal
planning  in proceedings of the twenty third international conference on automated
planning and scheduling  icaps       rome  italy  june             
rintanen  j          compact representation of sets of binary constraints  in ecai      
  th european conference on artificial intelligence  august      september         
riva del garda  italy  including prestigious applications of intelligent systems  pais
       proceedings  pp         
rintanen  j          complexity of concurrent temporal planning  in proceedings of the
seventeenth international conference on automated planning and scheduling  icaps
      providence  rhode island  usa  september              pp         
rintanen  j          planning as satisfiability  heuristics  artif  intell             
rintanen  j     gretton  c  o          computing upper bounds on lengths of transition
sequences  in ijcai       proceedings of the   rd international joint conference on
artificial intelligence  beijing  china  august           
rintanen  j   heljanko  k     niemela  i          planning as satisfiability  parallel plans
and algorithms for plan search  artif  intell                         
robinson  n   gretton  c   pham  d  n     sattar  a          sat based parallel planning
using a split representation of actions  in proceedings of the   th international conference on automated planning and scheduling  icaps       thessaloniki  greece 
september             
robinson  n   gretton  c   pham  d  n     sattar  a          partial weighted maxsat
for optimal planning  in pricai       trends in artificial intelligence    th pacific
rim international conference on artificial intelligence  daegu  korea  august   september          proceedings  pp         
shin  j  a     davis  e          processes and continuous change in a sat based planner 
artif  intell                     
smith  d  e     weld  d  s          temporal planning with mutual exclusion reasoning  in
proceedings of the sixteenth international joint conference on artificial intelligence 
ijcai     stockholm  sweden  july      august            volumes       pages  pp 
       
streeter  m  j     smith  s  f          using decision procedures efficiently for optimization 
in proceedings of the seventeenth international conference on automated planning
and scheduling  icaps       providence  rhode island  usa  september             
pp         
   

firankooh   ghassem sani

vidal  v          yahsp  and yahsp  mt in the  th international planning competition  in
international planning competition 
vidal  v     geffner  h          branching and pruning  an optimal temporal pocl
planner based on constraint programming  artif  intell                   
wehrle  m     rintanen  j          planning as satisfiability with relaxed  step plans 
in ai       advances in artificial intelligence    th australian joint conference on
artificial intelligence  gold coast  australia  december            proceedings  pp 
       
younes  h  l  s     simmons  r  g          vhpop  versatile heuristic partial order
planner  j  artif  intell  res   jair              

   

fi