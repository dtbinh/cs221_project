journal artificial intelligence research                  

submitted        published      

placement loading stations electric vehicles 
detours necessary 
stefan funke
andre nusser

funke fmi uni stuttgart de
nusser fmi uni stuttgart de

universitat stuttgart
institut fur formale methoden der informatik
      stuttgart  germany

sabine storandt

storandt cs uni freiburg de

albert ludwigs universitat freiburg
institut fur informatik
      freiburg  germany

abstract
compared conventional cars  electric vehicles  evs  still suffer considerably
shorter cruising ranges  combined sparsity battery loading stations  complete transition e mobility still seems long way go  paper  consider
problem placing loading stations possible shortest path
sufficiently many run energy  show model problem
introduce heuristics provide close to optimal solutions even large road networks 

   introduction
battery powered  electric vehicles  evs  important means towards reduction
carbon dioxide emissions recharged using renewable energies  e g  solar wind
power  despite environmental advantages evs still wait breakthrough
main reason limited cruising range  often less    km  together
sparsity battery loading stations  blss   planning trip b ev
nowadays non trivial undertaking  locations blss taken account 
many destinations completely range 
hence  early phase e mobility important goal establish network
blss using ev becomes worry free enterprise  modern blss require
little space  see figure    left  illustration   placed almost everywhere 
generates costs  natural objective minimize number installed blss 
previous work  storandt   funke         heuristic proposed determine bls
locations one get anywhere anywhere road network without
running energy  when choosing suitable route   unfortunately  approach
guarantees connectivity reasonability routes  fact  even rather close
destinations routes one recharging stop possible  might require long
detours several recharging stops due placement blss  related approach
lam  leung chu        suffers similar drawbacks  long run  e mobility
prevail road trip ev undertaken without unreasonable detours
c
    
ai access foundation  rights reserved 

fifunke  nusser    storandt

figure    inner city battery loading station  left image   feasible loading station cover
small map cut out  right image  

introduced  paper ask placement blss
shortest path enough blss get stranded starting fully loaded
battery typically case gas stations conventional cars  call
set bls locations ev shortest path cover  esc  define respective
optimization problem follows 
definition    ev shortest path cover  esc    given  di graph g v  e   edge costs
c   e r  function path decides whether path traveled
along without recharging ev  problem determining minimum subset l v
blss every shortest path wrt c traveled without running energy
called ev shortest path cover problem 
see figure    right  idea valid esc looks like  remainder
define n    v      e  otherwise noted  consider sake
clearer presentation assume unique shortest paths  which enforced using
standard techniques symbolic perturbation   describe deal ambiguous shortest paths towards end paper  function captures energy
characteristics network considered vehicle  typically  mountainous areas
roads rough surfaces  minimal paths ev runs energy
considerably shorter flat terrain downhill  experiments determined
energy consumption road segment e    v  w  e elevations h v   h w 
distance e    max h w  h v      weighting parameter  dependent
ev   is  energy consumption determined euclidean distance
height differences  similar energy model used previous work  artmeier  haselmayr 
leucker    sachenbacher        disregarding energy recuperation  negative edge costs  
function compares path accumulated energy consumption along edges
evs battery capacity b r  determine recharging necessary  note
one could employ kind monotonous function here  approaches introduce
following work notwithstanding particular choice 
   

fiplacement loading stations electric vehicles

    contribution
describe model esc problem instance hitting set problem
sets shortest paths require least one battery recharge  allows
us use algorithms developed solving hitting set problems  e g  standard greedy
approach  unfortunately  turns difficulty computing esc solution
already instance construction   n     n    v   shortest paths network 
extracting storing naively requires much time space practical 
therefore design new shortest path extraction representation techniques 
allow tackle even large road networks  moreover  develop several refinements
heuristics provide feasible esc solutions efficiently  priori
approximation guarantee shown solutions  prove posteriori using
instance based lower bounds real world instances actual approximation ratio
small constant 
extended version original paper  funke  nusser    storandt      b  
present following new results insights regarding esc  prove esc problem np hard  and even hard approximate   proven hardness motivation
justification development heuristic algorithms  furthermore  explain
transform shortest paths one  newly developed  representation another  along
theoretical run time analysis experiments  ability transform representations allows flexibility might prove useful applications
compact representations shortest paths used  describe simple minimality
checks shortest paths deciding whether need considered respective hitting set instance  especially large networks  checks reduce number shortest
paths stored significantly  addition  provide details involved
lower bound constructions  finally  lay methods dealing ambiguous shortest
paths  augmenting already existing loading station set case loading
station locations restricted subset nodes network 

   theoretical analysis
let us first prove esc problem np hard  hope efficient algorithms
solve esc optimality  unless p np   hence remainder paper
focus designing algorithms compute good approximate solutions 
theorem    hardness   ev shortest path cover problem  esc  np hard 
prove np hardness esc solution size preserving reduction vertex cover
 vc   one classical np hard problems  use following definition
notation vc 
definition    vertex cover   given graph g v  e   goal find vertex set c v
minimal cardinality e e   e c     
prove theorem    show ability solve esc problem efficiently implies
ability solve vc efficiently well  hence  esc np hard otherwise
would contradiction np hardness vc  end construct given
   

fifunke  nusser    storandt

 
 

 

 
 

 
 

 

 

 

 

 

 
 

figure    left  vertex cover instance optimal solution size    red circled nodes  
right  respective esc instance constructed inserting auxiliary edge per
node graph left  augmenting edges cost    circled
nodes indicate optimal hitting set path cost least   unhit 

vc instance gvc  vvc   evc   corresponding instance esc specified g v  e   c
follows 
v   vvc   e   evc i e  esc instance initially contains nodes edges
vc instance
v v add auxiliary vertex v   auxiliary edge  v  v     g
e e set costs c e  uniformly  
true paths consisting less three edges false otherwise  i e  every
shortest path traverses least three edges loading station
make set loading stations feasible esc
construction requires polynomial time size gvc   figure   illustrates
transformation vertex cover instance esc instance small example 
first show vertex cover solution gvc esc solution esc
instance constructed described above 
lemma    vertex cover c gvc yields esc l g  c   l     c  
proof  let c vvc vc solution gvc   esc graph g contains corresponding
vertex every v vvc   simply set l   c  so obviously  l     c    remains show
placing loading stations according l  every shortest path g traveled
without running energy  assume contradiction exists shortest path
g consisting three edges  u  v  v  w  w  x  neither v w l  every
edge e evc least one two vertices l  because l   c vertex cover
evc    follows  v  w  auxiliary edge present g
gvc   auxiliary edges cannot middle path containing three edges 
every auxiliary vertex degree    every path consisting three edges contains
loading station  hence l valid esc 
complete proof theorem    show valid esc solution leads
valid vertex cover solution well 
   

fiplacement loading stations electric vehicles

lemma    esc l g  c  yields vertex cover c gvc  c   l  
proof  let l valid esc solution  l might contain auxiliary vertices  construct
c replacing every auxiliary vertex v   l respective original vertex v  v
might part l  conclude  c   l   show c valid vertex
cover gvc   prove every edge  v  w  evc either v w c 
assume contradiction exists edge  v  w  evc  v  w  c    
accordingly  neither v  w  respective auxiliary vertices v   w  part
esc solution l  implies shortest path  v     v    v  w    w  w    three edges
loading station g  contradicts l valid esc solution  conclude
every edge  v  w  c    therefore c valid vertex cover 
l optimal solution esc  obviously  c     l  fulfilled lemma   
placing loading station auxiliary vertex v   corresponding original vertex v
time renders loading station v   superfluous  hence optimal solution 
never vertices v v   l  combination lemma    showed
every instance vc  construct polynomial time instance esc
optimal solution translates optimal solution vc instance
size straightforward manner  therefore hardness results vc carry
esc  proves theorem   furthermore rules existence       
polynomial time approximation schemes esc via proven apx hardness factor
better        vc  dinur   safra        
corollary    esc cannot approximated better        
proven hardness  efficient algorithms solve esc problem optimality
might difficult design unless one make use certain problem aspects battery
capacity parameter road network characteristics 

   modeling esc hitting set problem
following  aim good approximation algorithms heuristics solve
esc problem practice  particular  exploit fact esc modeled
instance well known hitting set problem therefore algorithms suitable
hitting set computations transfer esc  classical hitting set  hs  problem defined
follows 
definition    hitting set   given set system  u  s  u universe elements
collection subsets u   goal find minimum cardinality subset l u
set hit least one element l  i e    l     
case  u consists nodes road network  the possible bls locations  
set composed vertex sets shortest s t paths  excluding themselves 
fully charged battery suffice reach t  function characterizes
paths energy consumption traversing exceeds battery capacity
b r  call paths b violating  clearly  need consider set minimal
paths supersets hit automatically  theorem   shows hitting set formulation
indeed solves esc problem  see figure   illustration  
   

fifunke  nusser    storandt

v

b

l
l

v

l


b


b


b


v





figure    shortest path exhibits b violating prefix  s v  marked red  
according hitting set formulation loading station l
subpath  vehicle fully reloads l  argumentation applies
subpath l t  illustrated picture cutting prefix
s l every layer  final s t path b violating anymore  therefore
originally considered s t path traveled visiting three indicated
loading stations  blue bs mark nodes battery fully loaded 
i e  charge level equal battery capacity 

theorem    correctness   hitting set formulation leads feasible esc solution 
i e  placing loading stations according hitting set solution l  every shortest
path g traversed ev without running energy according  
proof  let  s  t  shortest path g b violating  let ev
fully loaded s  let  s  v  minimal b violating prefix  s  t   prefix
hit loading station l l l    s  l    v demanded hitting set
formulation  ev reach l s   s  v  minimal b violating prefix l
appears v  s  v   l ev fully re charged  hence whole argumentation
transfers subpath  l  t   applying argument recursively  ev finally
reach loading station  s  t  suffix path longer b violating 
therefore ev reach via  s  t  without running energy 

note precision loss reformulating esc hitting set problem
instance  since every solution esc feasible solution exactly cardinality
respective hitting set problem instance 
point  common hitting set solving techniques applied solve esc  e g 
standard greedy algorithm  greedy algorithm repeatedly picks node hitting
far unhit sets adds solution  terminates soon sets
hit  solution computed greedy algorithm guaranteed   ln  s         approximation  chvatal         ignore lower order term     on 
application  number sets system upper bounded number shortest
paths graph  therefore   s  n  hence greedy algorithm provides
  ln n  approximation guarantee  running time greedy algorithm depends
crucially fast access far unhit sets round 
   

fiplacement loading stations electric vehicles

   
  

  
  
  
 

  

 
 

 

  





 

figure    cut out ch graph  black edges original edges  blue edges indicate shortcuts  red node labels reflect contraction order  so  example 
moment node labeled   contracted  shortcut node    node  
inserted shortest path      went    right side 
search space query leftmost rightmost node illustrated 
green edges show gout  s  purple edges gin  t  

remainder paper  investigate efficient construction set
system using different path extraction representation schemes study influence
greedy algorithm 

   basics practical esc computation
determine suitable bls positions  first construct set shortest paths
ev would run energy  according    computing shortest path
two nodes one nodes classically performed using dijkstras
algorithm  also shortly called dijkstra   large street networks dijkstra slow
process large number queries  as necessary application   though 
therefore  instrument speed up techniques developed accelerating shortest path
queries achieve better running times approaches  particular  employ
contraction hierarchies  ch   geisberger  sanders  schultes    delling       
purpose  basic idea behind ch augment graph g v  e  set e  
called shortcuts  span  large  sections shortest paths  using shortcuts instead
original edges allows dramatic reduction operations dijkstra run 
central operation ch preprocessing node contraction  considering
graph g v  e  node v contracted  goal remove v g without
affecting shortest path distances remaining nodes  achieved
creating additional shortcut edges neighbors v follows  every pair
neighbors u  w v  u  v    v  w  e  shortcut  u  w  created  with cost
path uvw  uvw shortest path u w  resulting graph  with
v removed necessary shortcuts added  exhibits shortest path distances
original graph  ch preprocessing phase instruments node contraction first
assigning label l   v n node  then  nodes contracted increasing label
order  contracted nodes constructed set shortcuts e   way 
   

fifunke  nusser    storandt

return result preprocessing phase ch graph g   v  e e      is  original
graph augmented shortcuts  and labeling   see figure    left  example 
according labels  original shortcut edges  v  w  referred upwards
l v    l w  downwards otherwise  paths called up downwards consist
exclusively edges type  shown way created shortcuts 
node pair s  v shortest path exists g    g v  e e    
decomposed upward path starting followed downward path ending t 
highest node path wrt l called peak node following  property
path allows restrict bidirectional dijkstra run gout  s  gin  t  refer
subgraphs g  containing upwards paths starting downwards paths
ending respectively  figure    right   subgraphs illustrated  resulting
optimal path found bidirectional dijkstra costs shortest path
original graph  representation path different  path
consists  partly  shortcuts  get shortest path original graph 
unpacking procedure applied  every shortcut  two edges  original shortcut 
directly spans memorized ch construction  thus  unpacking one
recursively replace shortcuts spanned edges original edges identified 
note ch scheme employed represent shortest path
concisely replacing many subpaths possible shortcuts  call
representation ch path  experiments turns ch paths
extremely economic representation scheme shortest paths 
one to all shortest path problem  phast algorithm  delling  goldberg 
nowatzyk    werneck        takes advantage ch preprocessing scheme 
first phase nodes gout  s  source v settled via dijkstra run 
second phase downward edges  v  w  relaxed decreasing order induced l w  
thereby computing correct distances nodes v   second phase simply sweep
subset edges requires linear time  correctness phast results
fact every node shortest path decomposed
upwards path  with contained nodes settled first phase  downwards
path  set downwards edges forms directed acyclic graph labels l w 
induce topological order  sweep edges order assures moment
edge  v  w  relaxed  node v already settled  hence phast computes exact shortest
path distances nodes network  note single shortest path query
phast method choice  techniques pure ch dijktra computations
normally run time clearly sublinear number edges practice 

   construction set system
section  investigate several strategies extract set system given esc
instance  i e  set minimal shortest paths g b violating  along
different extraction strategies  present different ways represent store respective
set shortest paths discuss advantages disadvantages representations 
   

fiplacement loading stations electric vehicles

    naive extraction
simplest approach comes mind compute shortest path tree  via dijkstra 
every v identify nodes tree accumulated energy cost values
b  nodes priority queue dijkstra settled predecessors
already belong b violating paths  abort exploration source s 
respective paths search tree backtracked stored e g  complete
vertex sets  small exploration radii  small bounds b  practical approach 

larger b space consumption o n  n   n    v   enormous  assuming average

path length n   even store dijkstra search tree v via
predecessor labels  still space consumption o n     course  could easily
achieve linear space consumption number b violating paths  storing
source vertex target vertex path  want access
nodes certain path  run dijkstra computation network
t  huge sets paths computing nodes always demand
time intensive  matter representation use store paths  time
complexity o n  n log n   m       e  naive extraction already limits usability
real world instances  o n log n   m  runtime one dijkstra run 
fact  main difficulty hitting set type problems street
networks  example  speed up techniques shortest path queries transit nodes
 tn   bast  funke    matijevic        hub labeling  hl   abraham  delling  goldberg 
  werneck        based hitting certain set shortest paths well  methods
complete instance construction impractical there  therefore several custom tailored
heuristics developed allow efficient computation without explicitly constructing
 arz  luxen    sanders         setting differs significantly ours 
setting poses additional criterion c identifying paths contained s  hence
distance bound employed setting leads set equal length paths 
scenario  due different energy consumption driving uphill downhill 
lengths minimal b violating paths differ vastly  unfortunately tn hl  and
related  heuristics carry setting  therefore need explore new
ways extracting storing shortest path sets 
    phast based extraction
large bounds b finding b violating paths source node resembles one to all
shortest path problem  phast explicitly designed solve task efficiently 
paths backtrack respective search tree ch representation  i e 
consist partly shortcuts  huge advantage compared conventional paths
terms storage  shortcuts spanning large portions shortest path
number nodes ch path significantly smaller  about two orders magnitude
street network germany   downsides  though  nodes processed
second phase phast l order increasingly distance  hence incorporating
b stopping criterion seems difficult  moreover  b large leads paths
vastly differing lengths   n    lower bound  accumulated  runtime phast
every source might already result large overhead  hence propose different
strategy based ch potential significantly faster 
   

fifunke  nusser    storandt

p

b     
 

 
 
 
 

 

 

g 
        

g 

p

 

 
 

 
 

 
       

 
     

 

     

 

figure    left  schematic representation ch graph height nodes indicating contraction order  blue marked peak p  g     gin  p  colored
red g     gout  p  colored green  note nodes bottom
layer  g  g  empty nothing done  which practice
true     nodes   right  energy cost labels  black  assigned
g  g  resulting two dijkstra runs starting blue node 
resulting intervals nodes g  expressed purple  we  example 
search matching targets source node labeled   g    intervals
reveal node labeled   g  suitable candidate 

    peak node mapping  pnm 
large number b violating paths originate source v   exploring
paths dijkstra phast time consuming  core idea pnm
enumerate b violating paths completely different taking ch representation
paths consideration  explained above  shortest ch paths unimodal respect
labeling l node maximal label called peak  intuitively  nodes
high label appear shortest paths peaks  fact  real world graphs 
   nodes highest level constitute peaks reasonably long shortest paths 
gives rise path enumeration algorithm  explores paths source
peak  resulting dramatically reduced search spaces majority nodes 
algorithm  pnm algorithm works follows  consider one one every node
p v potential peak  shortest paths peak p contain nodes
smaller label  need search upwards paths ending p downwards paths
starting p prefix suffix candidates  respective subgraphs ch graph
g  containing paths called g     gin  p  g     gout  p   see figure    left 
illustration  conventional dijkstra run g  g   which typically
sparse  reveals distances p contained nodes  interested
combinations shortest  upward  paths g  shortest  downward  paths g 
leading minimal b violating paths  testing naively expensive  therefore 
construct p interval tree  berg  cheong  kreveld    overmars       
nodes g    interval  a  b   associate node t  denotes range
possible energy consumption values path prefix  s  p  g   s  p   p  t 
minimal b violating path  intervals easily computed single pass
dijkstra search tree g    see figure    right  example  every possible
   

fiplacement loading stations electric vehicles

figure    illustration three methods representing storing shortest paths  stored
elements always colored orange   left complete vertex set 
middle shortcut set ch path  the heights vertices image correspond l value   right triple consisting source  target
peak vertex 

source g    query interval tree set targets time o log  g        t   
storing resulting paths quadruples  s  p  t  c s  p    c p  t      note
employment interval trees make use special choice   different choices
interval computation procedure adapted 
filtering  nodes processed  set b violating paths which 
unfortunately  shortest paths  concatenation two shortest paths   s  p 
 p  t   need shortest path itself  remains filter set
appropriately  achieved using distance oracles quasi constant look up
time e g  provided hl another pass nodes role peak  always
pruning quadruple s  shorter path found p     p  note  pruning
already employed construction phase intermediate path set sizes
become large  final set paths stored list triples  s  p  t  even
compact representation ch representation  figure    visual comparison
provided storing path vertex set  shortcut set  pnm triple 
accessing nodes respective shortest s t path g required greedy
hitting set algorithm longer trivial sophisticated representation schemes 
though  therefore  develop suitable adaptions greedy algorithm work
ch representations pnm triples section   
    minimality checks
mentioned introducing hitting set formulation esc  need extract
store minimal b violating shortest paths  i e  paths subpath b violating
well  adding non minimal paths set system course invalidate
solution  increases complexity storing sets  running time greedy
algorithm later on 
naive extraction scheme  b violating path   sv        vk identified dijkstra run might minimal  path might still b violating without
prefix  precisely  check path remains b violating removing
first edge  s  v     so  dont include s  respective dijkstra run
considering v  source ensure b violating path missed 
   

fifunke  nusser    storandt

phast based extraction  minimality check becomes complex 
paths ch representation  might direct access first edge path
original graph  if path starts shortcut   unpack first
shortcut performing minimality check 
pnm prefix suffix deletion might lead subpath still b violating 
immediately decision favor triple  s  p  t   check first edge
path p last edge path p removal
destroy property path b violating  again  phast  paths
ch representation construction  therefore unpack shortcuts first 
    transformability
note  extraction scheme tie us certain path representation  fact 
mentioned representations  vertex sets  source target pairs  ch paths  triples 
converted other  especially transformation vertex sets ch paths
turn favorable  ch paths yield fair trade off space consumption
applicability greedy algorithm explained detail section   
provide details transformations including theoretical transformation times 
latter assume complete vertex set representation contains k elements 
source target pairs vertex sets  given s  t  complete path computed via
dijkstra run g backtracking  requiring o n log n   m  time 
vertex sets ch paths  assume ch labels l   v n available 
recursive procedure allows turn vertex set ch path  first
identify node v  vertex set highest l value  the peak  
split vertex set prefix v  suffix v   
sub paths search node highest l value  providing us
v    v    two nodes connected v  via direct edge shortcut chgraph  as nodes contracted before    v    v      v    v    
provides us prefix  nodes v    suffix  nodes v   
recurse  algorithm stops prefix suffix
 or prefix monotonously increasing wrt l suffix monotonously
decreasing   see figure    top  illustration  assuming ch representation
contains h shortcuts  transformation performed o k h  
ch paths pnm triples  need extract peak vertex  besides
source target  done o h  ch path consists h shortcuts 
pnm triples ch paths  given source s  target t  peak p  run dijkstra
starting p g     gin  p  g     gout  p  settled 
number edges ch graph assumed o m   runtime single
transformation o n log n m  transformation source targetpairs vertex sets  typically peak small l value small g 
g    peak high l value generates many s t paths once  amortized
costs per path considerably smaller 
   

fiplacement loading stations electric vehicles

figure    vertex sets ch paths back  first row  vertex set given 
l values derived ch construction indicated vertex elevations 
recursively vertex highest l value  marked red images 
prefix suffix path extracted shortcuts added span
path sections lower l value  second row  ch path recursively
unpacked  shortcuts colored blue  red arrows point replacement
edges next unpacking step  final path started
first row  contain shortcuts 

ch paths vertex sets  given ch path  apply unpacking method
described section    i e  recursively replace shortcuts spanned edges
path consists original edges  see figure    bottom   resulting
path consists k vertices  unpacking performed o k  
vertex sets source target pairs  first last vertex complete
path stored rest neglected  transformation costs o    o k 
consider deletion k   elements well 
following  longer investigate source target pair representation 
storing pnm triples requires one item per path time allows
efficient access paths vertices 

   greedy hitting set computation
explained above  greedy approach natural strategy solve hitting set
problem approximately  theoretically yields solutions within factor   ln n 
optimum setting  practice greedy performs much better theoretical 
priori approximation guarantee implies 
simplest set system representation application greedy hitting
set algorithm straightforward requires deliberate operations set
system path representations see following 
    complete vertex sets
paths simply given set contained vertices  single scan
sets determine best node hitting paths  another scan remove paths
   

fifunke  nusser    storandt

hit selected node  two scans combined one
updating counter values removing newly hit paths  an initial count
still necessary   unfortunately  space consumption approach enormous 
making single scan quite expensive 
    ch paths
representing minimal b violating paths ch paths  could convert single
paths original paths unpacking shortcuts operate complete
vertex set path  note paths would processed one one one
unpacked path would kept memory time  much better strategy
uncompressing every single ch path get original node sets  maintaining
usage counter edge  counting many shortest paths use edge   first
scan edges ch paths set system hit  incrementing respective
counters  traverse shortcut edges graph decreasing order
construction ch preprocessing  incrementing counters spanned edges 
node counters  maintained identify maximum node  derived final
scan original  non shortcut  edges  keeping reverse information edges
spanned shortcut allows identification sets hit
node  update edge counters removing ch paths set  picking
node requires one scan edges push counts non shortcut
edges  one scan usage counters one scan set ch paths 
    peak node triples
paths described triples source  target  peak node  get chpath representation described section      proceed ch path
representation  note  ch path representation computed demand
peak every round avoid keeping paths ch representation permanently memory 

   multi stage construction
country sized graphs  even improved set system extraction methods representations reduce space time consumption enough practical  therefore
introduce procedure interleaves set extraction greedy hitting set
computation multi stage algorithm  multi stage algorithm requires significantly
less space complete construction set system  therefore applied
considerably larger instances 
    nested hitting sets
instance esc problem determined battery capacity b  make
following important observation  every capacity b   b  hitting set l 
instance corresponding b   feasible original instance  having enough blss
smaller battery capacity suffices larger battery capacity   so  example 
b     kwh  solving problem e g  b      kwh would feasible well 
construction l  b   b might considerably faster due smaller exploration
   

fiplacement loading stations electric vehicles

 

 

 


 



 

 

 



b        b b       



b         b b       



b         b b      

 
 

 
 

b     

 

 
 



 

 

 
 

 
 

figure    battery capacity b      kwh  shortest path needs
hit loading station exhibits energy costs     conventional
construction  complete s t path would part hitting set instance 
three lower images illustrate happens use nested construction different values b     red purple dashed subpath indicates
minimal b    violating path starting s  brown square possible hitter
path  purple dashed blue path indicates minimal  b b     violating
path starting brown square  path always subpath s t matter b   chosen  hitting blue purple path  large dot image 
assures b violating paths hit well  nodes marked brown
squares part final solution 

radii  l  typically much larger necessary instance defined b 
simply using solution b      kwh although real battery capacity b     kwh 
expect result many superfluous loading stations 
another advantage first quickly computing hitting set small value
b     allows us construct new  smaller problem instance feasible hitting
set l   feasible original problem  defined b  l   hopefully much
smaller l    second instance defined set paths originating l 
 b b     violating 
prove lemma   hitting set l   second instance indeed
hitting set original instance 
lemma    given battery capacity b  second capacity b     b  let l  feasible
esc solution b     l feasible hitting set minimal shortest  b b     violating
paths originating l    l valid esc solution battery capacity b 
proof  consider b violating s t path original instance  must hit
node v l  less b   away s  path v          hitter
target  or prefix thereof  new constructed path set  b b     violating
paths originating l    therefore subpath hitter l  hence l hits bviolating shortest path  makes l valid esc solution battery capacity b  figure
  illustrates proof small example 
   

fifunke  nusser    storandt

    path cover
small values b  even compute hitting sets without exploration
evaluation function purely based connectivity structure graph using
so called k hop path cover  funke  nusser    storandt      a  generalization
vertex cover  construct set vertices c v directed  not
necessarily shortest  k hop path g contains least one vertex c  for k    
simply vertex cover   c esc solution b b maximal energy
cost k hop path  easily upper bounded k times maximal energy
cost edge  values k    takes minutes even large graphs using
variant depth first search  making step negligible overall running time 
    combination
implementation combined nested hitting sets k hop path covers multistage procedure  constructing sequence hitting sets lr   lr      l    l sequence
values br   br      b    b  finally returning l hitting set given
instance 
first br results k hop cover small value k  subsequent solutions
apply nested hitting set approach  and choose bi manually   might
loss terms quality compared greedy algorithm full set system due
nested construction  experimental evaluation show  though  loss terms
quality pronounced  running times drastically improved 
graph sizes handle approach much larger 

   refinements lower bounds
section introduce speed up strategy greedy algorithm independent employed set representation  develop algorithms construct
instance based lower bounds esc solution  bounds helpful
experimental evaluation  prove posteriori  running algorithms
computed solutions fact pretty close optima 
    multiple hitters heuristic
even non naive representations  considerable work involved picking
next best node greedy algorithm  might worthwhile add several
nodes hitting set round  normally  pick node hits
far unhit sets  refrain picking nodes round picking
first node influences hit counters others  hand  pick nodes
interfere other  quality solution decline severely 
one way achieve generate list nodes sorted ascending order
hit counters  always picking first one going list selecting next
nodes shortest path distances least nodes already picked 
appropriately chosen  e g  upper bound longest shortest path
b violating  thereby make sure path set increased hit counter two
nodes picked one round 
   

fiplacement loading stations electric vehicles

figure    set seven node disjoint b violating paths  highlighted grey  small example graph  every valid hitting set b violating paths graph
contain least seven vertices  vertex hit one grey
marked paths  therefore size set node disjoint paths feasible lower
bound optimal hitting set size 

    simple instance based lower bounds
evaluate quality heuristics  would compare outcome
optimal solution  optimal value typically unknown  instead compare
good  easily computable lower bound  study transit nodes  eisner   funke 
      rather involved lower bound proposed  takes effort comparable
solving hitting set problem itself  propose much simpler alternative suffices
purposes  by product generation set system obtain
set node disjoint b violating paths  two paths set non empty
intersection  clearly  feasible solution must contain extra node per path set 
hence size set node disjoint paths yields valid lower bound  see figure  
illustration 
case generate set system explicitly  because use nested hitting sets  
greedily extract set node disjoint paths running dijkstra computations
random sources adding b violating paths set long intersect
previously selected ones  size set provides valid lower bound time 

   dealing real world settings
throughout paper  made assumptions esc problem sake
clean definition easier algorithm descriptions  assumptions necessarily
met practice  explain following adapt algorithms still perform
well real world settings 
   

fifunke  nusser    storandt

    ambiguous shortest paths
exposition always assume uniqueness shortest paths  section
discuss necessary modifications case shortest paths ambiguous 
first all  enforce uniqueness shortest paths symbolic perturbation 
end define cost path   v  v        vk sum c edge costs 
vector  c   v    v            vk    two cost vectors compared lexicographically 
is  two t paths     sv            sw        aggregated edge
costs  minimal vi    wi     considered shorter vi   wi   otherwise
  considered shorter  symbolic perturbation easily incorporated e g 
dijkstras algorithm  computation shortest paths node consider
 possibly tentative  distance label node v aggregated edge costs
ds  v  along respective path tuple  ds  v   preds  v    preds  v  denotes
predecessor current path v  ordering case identical ds  v  values
determined node id predecessor  edge relaxations well organization
priority queue made according augmented distance labels  easy
see yields canonical unique shortest paths described above 
edge lengths typically measured precision around one meter rarely happens two paths exhibit exactly length  circumstances  though 
might desirable actually maintain multiple shortest paths nodes  hitting
  allowing travel along without running energy   fortunately  adapt algorithms cater shortest paths  minimal
change backtracking dijkstra exploration well pnm approach
slight change ch construction  former  retrieve paths sets  instead
following predecessor reference node v  which set edge relaxation  
inspect adjacent nodes check whether distance labels respective edge
cost sums distance label v  yields neighbors v lie shortest
path v  recursing neighbors obtain shortest paths  ch
construction  crucial operation contraction node v  original version 
every pair neighbors u  w v  u  v    v  w  e  shortcut  u  w  created
 with cost path uvw  uvw shortest path u w  maintain
shortest paths  add shortcut uvw shortest path u w  but possible
existence shortest paths   way every shortest path ch representation 
comes cost slightly shortcuts added 
lower bound construction section     modified yield lower bound
case ambiguous shortest paths follows  s t pair contribute
lower bound shortest paths require least one recharging event 
compute valid lower bound retrieve maximal set vertex pairs 
two vertex pairs set respective shortest path node sets allowed overlap 
generalizes idea node disjoint shortest paths case ambiguous shortest paths 
experiments showed  though  considering shortest paths yield
noticeably different results mainly due rarity reasonably long ambiguous shortest
paths  disregard ambiguities implementation  extremely small
battery capacities  corresponding cruising range less  km   found ambiguous
   

fiplacement loading stations electric vehicles

shortest paths covered bls placement  larger battery capacities
bls placement fact covered  of few  ambiguous shortest paths 
    restricted loading station placement
assume esc problem definition loading stations placed every
node network  practice  though  set possible locations might restricted
due technical  financial legal reasons  set v   v candidate nodes
loading stations  incorporate algorithms follows  construction
set system  check every shortest path whether least one nodes
v     otherwise  ignore path completely  as never hit anyway  
ch based extraction methods  set flag every edge shortcut indicating whether
spanned path contains node v   not  allows perform check
ch path without unpack it  actual hitting set computation simply
skip nodes v   compute feasible solution 
note  depending choice v   final hitting set might allow drive
shortest paths without running energy  though  incorporate
locations suitable become loading stations others without losing global
reachability demanded esc problem formulation  introduce prize function
p   v r    higher prize complicated expensive place
charging station node  exploit weighted hitting set problem
basis computations  goal find set l elements
p universe
hit sets set system minimizing accumulated prize p l  
set system extraction methods remain unaffected prizes  greedy hitting
set computation step  selection next best hitter changes  previously  selected
node next hits far unhit sets  now  s v  denotes set far unhit
sets contain v  select node minimizes average prize per set p v   s v   
approximation guarantee greedy algorithm weighted hitting set problem
unweighted hitting set problem  chvatal         expect
solution consist mainly cheap charging stations possibly expensive ones
required establish reachability two nodes 
    placement given initial loading station set
another assumption made esc problem definition try construct
network loading stations scratch  i e  starting loading stations all 
loading stations still sparse many areas  ones already installed
ignored  existing loading stations easily taken account solving
esc problem  given initial set loading stations l    check extraction
set system path already hit l    case  path
pruned  remaining steps hitting set computation work before 

    experimental evaluation
proposed techniques computing esc solutions evaluated multi threaded
implementation written c   executed  nd generation intel core desktop hard   

fifunke  nusser    storandt

ware  i          cores    gb ram  complete set generations i         
cores    gb ram  multi stage construction nested hitting sets  use
following abbreviations state results  k       m       s seconds  m minutes  h hours 
d days  gb     bytes  distinguish cpu time  total cpu usage  real time
 wall clock time   several road networks germany derived openstreetmap data
region
pforzheim
tubingen
baden wurttemberg south
southern germany
germany

abb 
 pf 
 tu 
 bw 
 sg 
 ge 

 v  
   m
   m
   m
   m
    m

 e 
   m
   m
   m
   m
    m

table    test graph characteristics 
 osm        used evaluation  see table   overview  edge cost function
c used travel time along edge  paths hit indeed quickest paths  the
term shortest paths conventionally used subsuming kinds metrics   energy consumption ev modeled explained introduction using distance data
osm elevations provided shuttle radar topography mission  nasa         b
corresponds battery capacity translates certain terrain dependent cruising
range  use capacity b pf tu allows drive    kilometers average 
    kilometers larger graphs    models much going uphill
increases energy consumption  equals   
     dealing complete set systems
construction representation  let us first examine time space complexity
extracting complete set minimal b violating paths  constructed set systems
using naive strategy  naive representing path complete sequence
vertices   phast based exploration  phast paths ch representation  
peak node mapping  pnm representing path source peak target triple  
respective results found table    unfortunately  two smallest instances
feasible process using strategies  already bw graph  time space
consumption naive exploded  extrapolated    gb    cpu
days   comparison  phast factor   faster naive  space
consumption ch paths improvement least order magnitude  pnm
construct bw instance     cpu hours  compared week needed phast 
space consumption using triples decreases another factor    note longer
paths advantage pnm vs  ch representation increases   sg ge 
phast pnm took much time space  e g  extrapolated    gb    days
phast   larger networks  constructing complete set systems seems infeasible 

comparison path representations  explained section      path extraction
scheme tie us path representation  instead  transform extracted
   

fiplacement loading stations electric vehicles

graph

pf
tu
bw
graph

pf
tu
bw

  paths

  m
   m
    m

space consumption
naive
phast
pnm
vertex sets ch paths
triples
   gb
   gb
   gb
    gb
   gb
   gb
      gb 
    gb     gb

computation time
naive
phast
pnm
cpu
real
cpu
real
cpu
real
   h
   h     m    m
   m     m
    h
   h
   h
   h     m
   m
     d      d 
   d     h
   h     m

table    comparison path extraction representation schemes  b corresponds
  km  pf tu     km  bw  cruising range flat terrain  timings include
ch construction phast pnm  values brackets extrapolated 

paths introduced representations storing them  representation
provides trade off space consumption access times single paths  figure
   illustrates values small large benchmark instance  tu ger  
note  access times paths represented triples amortized  really
want extract single path only  costs comparable ones  s  t 
representation  greedy algorithm  require access huge sets paths
every round   s  p  t  representation pays off  ch representation  access
times reported figure purely completeness  significant
greedy hitting set computation  though  specialized greedy algorithm ch paths
require unpack paths  fact  access times relevant greedy
algorithm even ones vertex set representation  ch representation
contains far less elements sweep over  hence  regard ch paths best
path representation soon set system fits memory representation 
transformation times two path representations estimated
results reported figure    well  every transformation runs constant linear
time according analysis cost less comparable accessing paths vertex
set representation  transformation time ch paths vertex sets vice versa
corresponds access time paths ch representation  transform triples
ch paths  need time access path triple form minus time unpack
ch path 
hitting set computation  evaluated standard greedy algorithm well
multiple hitters  mh  variation set systems pf  tu  bw varying choices
b  figure    shows performance terms quality  standard greedy vs  mh 
well running time  how much faster mh compared standard greedy   ratios
averaged test graphs  bound b chosen almost zero    percent
   

fifunke  nusser    storandt

figure     comparison several path representation schemes terms space consumption access time  axes log scale 

maximum energy consumption shortest path respective network  in fact
long paths  set systems got simple greedy even constructed optimum 
hence approximation ratio   figure      cases  greedy produces results much
closer optimum theoretical   ln n guarantee  maximum deviation
lower bound indeed less      employing mh strategy increases hs size
slightly  yields significantly decreased running times especially smaller bounds b
 where hitters chosen   still  compared construction time
set systems  hitting set computation times negligible  state
explicitly here  change employ multi stage construction  though 
     multi stage construction
construction complete set system proven infeasible larger road
networks  make use idea multi stage construction 
k hop cover pnm  let us first examine compact set system constructed
using pnm approach initial k hop path cover  bw network
computed k      hop cover c           nodes  corresponds esc solution
b           and cruising range  km flat terrain   pnm used
create final compact set system considering  b b     violating paths start
nodes c  surprisingly  number paths hit reduces drastically
    m table     m table    running times still quite high  though 
approach save exploration peak  therefore stages
   

fiplacement loading stations electric vehicles

  
  
runtime ratio

 
quality greedy
quality mh
runtime greedy runtime mh

 

  
 

  
  

 

  
  

 

approximation factor

  

 
 

 
  

  
  
  
percentage max b

  

  

figure     performance greedy algorithm multiple hitters variant  mh 
averaged pf  tu bw 
graph
bw
sg
ge

 c 
       
       
       

b 
    
     
     

cpu
   h
   h
    h

real
    m
   h
    h

  paths
  m
  m
    m

table    instance creation  b     k  via pnm initial k hop solution c k      
help much here   since improvements terms running time using pnm
multi stage approach cannot expected  let us concentrate naive approach
extracted paths converted ch representation 
multi stage hitting sets  employ following strategy  first  construct k hop cover
c e g  k      yields initial hitting set lr bound br  
construct reduced set system consisting  br  br   violating paths starting
nodes lr compute hitting set lr  set system  here  use naive
graph
tu
sg
tu
sg
ge
ge
ge

br


   k
   k
    k
   k
    k

bi nested hs
 k  k   k
 k   k    k
   k   k
    k    k
    k     k    k
   k     k    k
    k     k     k    k

 l 
   
   
   
   
   
   
    

lb
  
  
  
  
   
   
   

apx
    
    
    
    
    
    
    

cpu
 m
   m
 m
   m
   m
    m
   m

real
 m
   m
 m
  m
   m
   m
   m

table    multi stage hitting set computation  lb   lower bound  apx   approximation
factor   last two experiments seen detail table   

   

fifunke  nusser    storandt


 
 
 
 
p

bi
   k
   k
    k
   k


 
 
 
 
 
p

bi
    k
    k
    k
    k
   k

tss

   m
   m
   m
    m
tss

   m
   m
  m
   m
   m

 paths

    m
    m
    m

 paths

    m
    m
   m
   m


ths
  s
  m
  m
  m
  m
ths
  s
  m
  m
  m
  m
   m

 li  
    k
   k
  k
   

 li  
   k
   k
    k
    
    


cpu
  s
   m
   m
   m
    m
cpu
  s
   m
   m
  m
   m
   m

table    statistics   stage run starting k      hop cover  above    stage construction initialized k      hop cover  below  ge  column
 paths gives number sets hit respective stage  tss ths
denote cpu time set system construction hitting set computation
respectively 

extraction transform vertex sets ch paths efficient storage  proceed
iteratively reaching b    b final hitting set l    l  intuitive demand
gap b  b  large make sure last hitting set
instance still faithfully characterizes original hitting set instance  table   shows
results various choices multi stage parameters  table   give detailed
account intermediate calculations large ge graph  experiments confirm
larger gap b  b  is  better quality final hitting
set  comes cost expensive last stage  though  contrast
experiments  first two calculations table   conducted without initial
k hop cover  results obtained tu sg suggest initial k hop cover
accelerates calculation maintaining similar hitting set size  furthermore 
apx values remain low even though lower bounds obtained naive way 
note example graph germany  priori approximation guarantee
plain greedy algorithm  which feasible due excessive running time space
consumption    ln n       proves excellent quality hitting sets
particular instances  table   shows introducing multiple stages keeps intermediate
set systems rather compact  efficient computation actually possible 

    conclusions future work
showed model solve natural important facility location problem
e mobility context  taking radically different approach previous ones avoiding
detours loading stations evs 
   

fiplacement loading stations electric vehicles

naive strategy allows solution small instances hundred
thousand nodes  compact representation schemes underlying set systems
heuristic modifications standard greedy approach make computation solution
even country sized networks germany possible  instance based lower bounds
certify solution quality close optimal  within factor    far
pessimistic theoretically achievable approximation bound  fact remarkable
all  possible compute   approximate solution seemingly intractable hitting
set problem within hours quadcore desktop pc  computation determined
around     locations placing blss would establish complete coverage germany 
framework require metric decides shortest paths
hit identical metric determines paths shortest  fact
factored using function  depending application scenario
used implement hitting criteria  e g  hop distances risk values  
future work intend examine exact hitting requirement relaxed 
naturally  necessary always bls right respective shortest
path  nearby one suffices  could modeled enlarging vertex sets
respective shortest paths surrounding vertices  hitting set sizes variant
expected considerably smaller hitting shortest paths directly  another
direction research take account capacity constraints blss  lam et al  
       particular urban areas certainly necessary provide recharging stations
large number vehicles 

references
abraham  i   delling  d   goldberg  a  v     werneck  r  f          hierarchical hub
labelings shortest paths  european symposium algorithms  esa   pp    
    springer 
artmeier  a   haselmayr  j   leucker  m     sachenbacher  m          shortest path
problem revisited  optimal routing electric vehicles  german conference
artificial intelligence  ki   pp         
arz  j   luxen  d     sanders  p          transit node routing reconsidered  international
symposium experimental algorithms  sea   pp        springer 
bast  h   funke  s     matijevic  d          ultrafast shortest path queries via transit
nodes  shortest path problem    th dimacs implemenation challenge  vol    
dimacs series discrete mathematics theoretical computer science  pp 
        providence  ri  ams 
berg  m  d   cheong  o   kreveld  m  v     overmars  m          computational geometry 
algorithms applications   rd ed  edition   springer verlag telos  santa clara 
ca  usa 
chvatal  v          greedy heuristic set covering problem  math  oper  res  
              
   

fifunke  nusser    storandt

delling  d   goldberg  a  v   nowatzyk  a     werneck  r  f  f          phast  hardwareaccelerated shortest path trees  international parallel distributed processing
symposium  ipdps   pp         
dinur  i     safra  s          hardness approximating minimum vertex cover 
annals mathematics            
eisner  j     funke  s          transit nodes   lower bounds refined construction 
algorithm engineering experiments  alenex  
funke  s   nusser  a     storandt  s       a   k path covers applications 
international conference large databases  vldb  
funke  s   nusser  a     storandt  s       b   placement loading stations electric
vehicles  detours necessary   aaai conference artificial intelligence 
geisberger  r   sanders  p   schultes  d     delling  d          contraction hierarchies 
faster simpler hierarchical routing road networks  international workshop
experimental algorithms  wea   pp          springer 
lam  a   leung  y  w     chu  x          electric vehicle charging station placement 
international conference smart grid communications  smartgridcomm   pp 
       
nasa         shuttle radar topography mission  online  http   www  jpl nasa gov srtm 
osm         openstreetmap project  online  http   www openstreetmap org 
storandt  s     funke  s          enabling e mobility  facility location battery loading
stations  conference artificial intelligence  aaai  

   


