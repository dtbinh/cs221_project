journal artificial intelligence research                  

submitted        published      

itsat  efficient sat based temporal planner
masood feyzbakhsh rankooh
gholamreza ghassem sani

feyzbakhsh ce sharif edu
sani sharif edu

computer engineering department 
sharif university technology 
azadi ave   tehran  iran

abstract
planning satisfiability known efficient approach deal many types
planning problems  however  approach competitive state space
based methods temporal planning  paper describes itsat efficient sat based
 satisfiability based  temporal planner capable temporally expressive planning 
novelty itsat lies way handles temporal constraints given problems without
getting involved difficulties introducing continuous variables corresponding
satisfiability problems  show how  sat based classical planning  carefully
devised preprocessing encoding schemata considerably improve efficiency
sat based temporal planning  present two preprocessing methods mutex relation
extraction action compression  show separation causal temporal
reasoning enables us employ compact encodings based concept parallel
execution semantics  although encodings shown quite effective
classical planning  itsat first temporal planner utilizing type encoding 
empirical results show itsat outperform state of the art temporally
expressive planners  competitive fast temporal planners cannot
handle required concurrency 

   introduction
temporal planning extension classical planning actions durative rather
instantaneous  introduction durative actions adds new dimension
solving planning problems  namely reasoning time  temporal reasoning per se
different causal reasoning  time real valued quantity  whereas causal
aspects planning normally represented propositions 
current standard language defining temporal planning problems pddl   
 fox   long         although pddl   fox   long        introduced
planning community expressive language defining temporal numerical
planning problems  throughout paper  focus pddl     planning
problems tackled need expressive power pddl   pddl    
actions separate preconditions effects upon starting ending  temporal
action invariants  must preserved execution
action  important subset problems defined pddl    problems every
valid plan includes concurrent execution two actions  subset called
problems required concurrency  shown concurrent execution two
actions may necessary solving temporal problems  halsey  long    fox       
cushing  kambhampati  mausam    weld         instance  temporal planning
c
    
ai access foundation  rights reserved 

firankooh   ghassem sani

problems  actions may require proposition available execution
another action  cases  two actions must executed concurrently 
specific example given section    describe driverlogshift domain 
common approach many planners temporally expressive eliminate
cases compressing temporal actions create non durative classical actions 
paper  describe itsat  temporally expressive sat based  i e   satisfiability
based  planner  itsat uses approach takes advantage parallel execution semantics without rendering incomplete problems required concurrency 
approach  durations actions given problem first abstracted out 
done breaking temporal action two starting ending instantaneous events 
obtained temporally abstract problem encoded sat formula using novel
 step  step semantics causally valid plans  show semantics
used encode given temporal planning problem sat formula  classical  step
 step encoding methods introduced  rintanen  heljanko    niemela 
       addition extending methods temporal planning context 
introduce new encoding method based  step semantics causally valid plans 
show new encoding often results significant reduction number required
steps 
generating causally valid plan  itsat performs scheduling phase 
phase  itsat tries satisfy temporal constraints imposed considering
durations actions  done solving simple temporal problem  stp   dechter 
meiri    pearl         however  problems required concurrency  posed stp
may inconsistent  cases  cause inconsistency  manifests
negative cycle corresponding simple temporal network  stn   detected  itsat
generates number clauses added sat formula  collectively prevent
reoccurrence particular negative cycle occurred similar cycles 
process repeated temporally valid plan found 
similar sat based planners  itsat takes advantage preprocessing phase
extract information structure problems  information used
throughout encoding phase produce formula whose satisfiability checked
efficiently sat solver  section    describe preprocessing phase
itsat  includes reasoning mutual exclusion so called safe action
compression  coles  coles  fox    long         two propositions regarded mutually
exclusive never jointly true state valid temporal plan  here 
show one detect mutually exclusive propositions temporal problems using
planning graph analysis  blum   furst         known employing mutual exclusion
reasoning significantly improve performance sat based planners  gerevini  
schubert        
mentioned earlier  itsat breaks temporal action two starting
ending instantaneous events  although cases breaking might
necessary producing concurrent plans  situations necessary
finding valid plans  section    show using mutual exclusion information 
one identify temporal actions safely compressed classical action
without falsifying validity temporal plans  analysis results smaller number
distinct events therefore simpler planning problem 
   

fiitsat  efficient sat based temporal planner

empirically show taking advantage preprocessing  encoding 
scheduling phases  itsat significantly outperform state of the art temporally expressive planners  competitive best temporally simple planners
incapable solving problems required concurrency property  components itsat shown figure    figure  processing components
itsat system shown rectangular blocks  links represents data produced
received components 

figure    block diagram itsat

   

firankooh   ghassem sani

    motivation
mentioned earlier  temporal planners need reason time  continuous
quantity  nevertheless  causal structures problems temporal planning still
similar classical planning  existence abundant temporal planning domains
classical versions regarded evidence claim  suggests
temporal planners benefit using approaches previously shown
effective dealing classical problems 
usage boolean satisfiability checking well known paradigm tackling classical
planning problems  kautz   selman         approach  given planning problem
translated formula propositional logic  variable sat formula typically
represents occurrence corresponding action proposition certain place
potential plan  causal constraints planning problem represented number
ground clauses  output plan assumed finite number steps  step
may include one actions  original sat based planner allowed one action
per step  kautz   selman         however  previously introduced sat based planners
allow multiple occurrence actions step  produced formula given
input off the shelf sat solver  tries find model it  model
found  plan extracted it  otherwise  number steps output plan
increased one corresponding sat formula given sat solver 
process repeated valid plan extracted predefined termination condition
reached  order obtain efficient sat based planner  one important issue
considered encode given planning problem sat formula 
sat based planning originally used find optimal plans  i e   plans minimum
number actions  kautz   selman         guarantee optimality output plan 
formula must include certain clauses ban step containing one
action  however  so called satisficing planning  optimality main
objective  forcing single action steps necessary  alternative approach consider
actions executed parallel step output plan  ernst  millstein 
  weld         exploiting parallelism result smaller number steps
sat formula  another important benefit producing compact formulae lower memory
requirements  several encoding methods introduced take advantage action
parallelism  encoding methods based so called  step  step semantics
valid plans  rintanen et al         
 step  step semantics different extent action parallelism
allow occur step   step semantics allows set actions executed
parallel  actions executed every possible ordering without affecting
validity plan   step semantics  hand  imposes weaker restriction 
step plan  must exist least one possible ordering actions
executed without falsifying validity plan  clear  step
semantics potentially allows parallelism permitted  step semantics 
fact  taking advantage  step semantics  efficient sat based classical planner 
i e   mp  rintanen         competitive state of the art state space planners 
paper  show separation causal temporal reasoning phases temporal
planning enables us employ compact encodings efficient temporal planning 
   

fiitsat  efficient sat based temporal planner

    related work
previous research field temporal planning benefited enormously employing
well developed classical planning strategies  instance  many successful temporal planners utilized ideas partial order planning  e g  vhpop  younes   simmons 
      cpt  vidal   geffner         planning graph analysis adopted
temporal planners tgp  smith   weld        tpsys  garrido  fox    long 
       temporal planners embedded temporal reasoning heuristic
state space search  tfd  eyerich  mattmuller    roger         lpg td  gerevini  saetti 
  serina         popf  coles  coles  fox    long        successful instances
latter approach 
usage boolean satisfiability checking one well known paradigms tackling classical planning problems  kautz   selman         order obtain efficient
sat based planner  one important issue considered encode
given planning problem sat formula  fact  devising efficient encoding methods
important research trend field sat based planning  examples
efficient encodings are  split action representation  kautz   selman        ernst et al  
      robinson  gretton  pham    sattar         sas  based encoding  huang  chen 
  zhang         compact mutual exclusion representation  rintanen         based
parallel semantics plans  another effective encoding method introduced  rintanen et al          latter encoding method particular interest paper 
satisfiability checking employed field temporal planning  however 
sat based temporal planners encounter major challenge  representing temporal aspects problems  since time continuous quantity  cannot treated exact
way discrete causality handled  tackle problem  step  huang  chen   
zhang         scp   lu  huang  chen  xu  zhang    chen         t satplan  mali
  liu        use discrete representation time  planners assign explicit discrete
time labels step encoding  generally speaking  approach  step
exactly one time unit ahead step      result  action duration starts
step i  forced end step   d  one immediate outcome approach
introduction enormous number steps encoding  many
contribute output plan  drawback explicit time representation causes
step  scp   t satplan inefficient terms speed memory usage  obtain better performance  scp  uses  step semantic allow causal relations
actions time point  lu et al         
tm lpsat  shin   davis         designed solve planning problems
defined pddl   fox   long         another sat based planner capable handling
temporal planning problems  similar step t satplan  tm lpsat attaches
time labels step  however  tm lpsat  labels predefined discrete
numbers  instead  label numeric variable whose value determined
problem solved smt solver  armando   giunchiglia         approach
result encodings compact produced step tsatplan 
major disadvantage assigning time label step formula parallelism mentioned cannot exploited effectively  two events
   

firankooh   ghassem sani

happen certain step plan  time labels must same  thus 
must simultaneous final plan executed  compulsory simultaneity
restriction reduces number events happen step final
plan  turn  increases number steps needed solving input problems 
implies efficiency gain one could obtain using parallel execution semantics
sacrificed achieve easy way deal temporal constraints  however 
majority current temporal planning problems  satisfying temporal constrains
hardest task finding valid plan  shown problems without required
concurrency  one omit temporal constraints altogether  find causally valid plan 
then  considering temporal constraints postproccessing step  schedule
actions plan find temporally valid plan  cushing et al          approach
actually used many previous temporal planners including yahsp  mt  vidal 
       winner temporal satisficing track ipc       despite efficient
solving many temporal problems  planners incomplete  incapable
solving problems required concurrency 
addition classical planning problems  sat based methods used
deal categories planning problems  examples planning uncertainty
 castellini  giunchiglia    tacchella         cost optimal planning  robinson  gretton 
pham    sattar        numerical planning  hoffmann  gomes  selman    kautz 
      

   preliminaries
standard language used defining temporal planning problems pddl     fox  
long         figure   presents example pddl    representation temporal
planning domain  domain  simplified version driverlogshift  halsey        
referred several times throughout paper  figure   shows  pddl    
action separate conditions effects upon starting ending  starting
ending conditions  or effects  action specified start end
tokens  respectively  action may conditions need preserved
execution  conditions specified using token  moreover 
duration action defined     duration x  statement  x rational
number function specifying actual duration action 
driverlogshift temporal version driverlog domain ipc  
classical counterpart  driverlogshift  objective transfer several objects
original places destinations  object loaded unloaded
certain truck using load unload operators  respectively  truck move
locations using move operator  main difference driverlogshift
driverlog trucks must rested intervals working
shifts  working shift defined work operator  produces  working
truck  proposition upon starting  deletes proposition upon ending  load  unload 
move  working truck  invariant   working truck  deleted
ending work  may reproduced rest operator  defines resting
shift certain truck 
   

fiitsat  efficient sat based temporal planner

 define  domain driverlogshift 
  requirements  typing  durative actions 
  types
location locatable   object
truck obj   locatable 
  predicates
 at  obj   locatable  loc   location 
 in  obj    obj  obj   truck 
 link  x  y   location 
 working  t   truck 
 need rest   truck 
 rested   truck  
  durative action work
 parameters
  truck   truck 
 duration     duration     
 condition  and
 at start  rested  truck   
 effect  and  at start  working  truck  
 at end  not  working  truck   
 at start  not  rested  truck   
 at end  need rest  truck    
  durative action rest
 parameters
  truck   truck 
 duration     duration    
 condition  and
 at start  need rest  truck   
 effect  and
 at start  not  need rest  truck   
 at end  rested  truck    
  durative action load
 parameters
  obj   obj
 truck   truck
 loc   location 
 duration     duration    
 condition  and
 over  at  truck  loc  
 over  working  truck  
 at start  at  obj  loc   
 effect  and
 at start  not  at  obj  loc   
 at end  in  obj  truck    

  durative action unload
 parameters
  obj   obj
 truck   truck
 loc   location 
 duration     duration    
 condition  and
 over  at  truck  loc  
 over  working  truck  
 at start  in  obj  truck   
 effect  and
 at start  not  in  obj  truck   
 at end  at  obj  loc    
  durative action move
 parameters
  truck   truck
 loc from   location
 loc to   location 
 duration     duration    
 condition  and
 at start  at  truck  loc from  
 at start  link  loc from  loc to  
 over  working  truck   
 effect  and
 at start  not  at  truck  loc from   
 at end  at  truck  loc to     

figure    pddl    description driverlogshift domain

note version driverlogshift described figure   slightly different
original version  halsey         drivers walk to  board 
disembark trucks  furthermore  rest work actions performed drivers
rather trucks  however  order make examples simpler  merged drivers
trucks single entity trucks 
simple example problems driverlogshift shown figure    problem 
three locations  s   s   s    one truck  truck    one object  package   
initial state  truck  package  s   objective problem
transfer package  s  
    formalism pddl   
present formalism specifications pddl     formalism devised
way simplifies description preprocessing  encoding  scheduling phases
itsat  mention formalism limitations compared
full specifications pddl     limitations discussed details section     
   

firankooh   ghassem sani

 define  problem dlog 
  domain driverlogshift 
  objects
truck 
  truck
package    obj
s  s  s    location 
  init
 rested truck  
 at truck  s  
 at package  s  
 link s  s  
 link s  s  
 link s  s  
 link s  s  
 
  goal  and
 at package  s     

figure    pddl    description problem driverlogshift domain

definition    events   event  e  triple  pre e   add e   del e    pre e  
add e   del e  three sets atomic propositions  facts  representing preconditions 
positive effects  negative effects e  respectively 
definition    temporal actions  temporal action  a  quadruple  start a   end a  
inv a   dur a    start a  end a  two events denoting starting ending
events a  inv a  set atomic propositions representing invariants a 
dur a  positive rational number specifying duration a 
example    figure   shows temporal action   load package   truck   s   
instance load operator defined figure    figure    depicted rectangular box  conditions effects written box  respectively 
start conditions effects placed left hand side box 
end conditions effects placed right hand side box 
conditions placed middle box  here  start a  end a 
two events  pre start a       at package  s     add start a       del start a    
  at package  s     pre end a       add end a       at package  truck    
del end a       moreover  inv a      at truck  s     working truck    
dur a       
   

fiitsat  efficient sat based temporal planner

figure    temporal action

definition    temporal states   temporal state  s  pair  state s   agenda s   
state s  classical planning state represented set atomic propositions 
agenda s  contains finite set open actions  i e   actions started prior yet
ended  
definition    applicability   starting event e action applicable state s 
following conditions hold 
    state s  contains preconditions e
invariants  except
invariants added e   pre e   inv a  add e   state s 
    already open s 
  agenda s 
    esdoes delete thetinvariants open action s 

del e   
agenda s  inv a  
ending event e action applicable state s  following conditions hold 
    state s  contains preconditions e  pre e  state s 
    open s  agenda s 
   
e delete invariants
open action  other a  

 
inv a
del e 
 
agenda s  a 
definition    successors   starting event e action applicable state s 
change unique state satisfying following conditions 


set open
actions equal set open actions a  agenda s    
agenda s   a 

positive negative effects
e respectively added deleted  

state s      state s  del e   add e 

ending event e action applicable state s  change unique state
satisfying following conditions 
   

firankooh   ghassem sani

set open actions equal set open actions without a 
agenda s     agenda s   a 
positive negative
effects e respectively added deleted   state s    

 state s  del e   add e 
on  may use succ s  e  represent successor state obtained applying
e s 
definition   definition   easily extended cover sequence events 
succ s  he         en i    succ succ s  he         en  i   en    succ s  hi    s  sequence
events he         en applicable temporal state s  succ s  he         en i  defined 
example    let temporal state
state s      at package  s     at truck  s     working truck     link s  s   

agenda s     
let   load package   truck   s     move truck   s   s   two temporal actions  respectively instances load move operators presented figure
   event start a  applicable changes
state s       at truck  s     working truck     link s  s   

agenda s      load package   truck   s    
now  start a  applicable already open   isstart a   applicable   deletes  at truck  s   invariant a  still open  
however  end a  applicable changes
state s       at package  truck     at truck  s     working truck     link s  s   

agenda s      

definition    temporal problems   temporal problem  p  triple  i  g  a  
i  representing initial state  temporal state agenda i      g set
atomic propositions denoting goal conditions  finite set possible
temporal actions p 
definition    causally valid plans   let p    i  g  a  temporal problem
  he         en sequence events i  ei starting ending event
action a  causally valid plan p  applicable i  g state succ s     
agenda succ s        
   

fiitsat  efficient sat based temporal planner

definition    pairing events   let   he         en causally valid plan problem p    i  g  a   assume ei ej respectively starting ending events
certain action   j  k   k   j  ek neither starting
ending event a  say ei  ej   pairing event ej  ei    
words  ei ej pairing events related occurrence  
definition    valid temporal plans makespan   let   he         en causally
valid plan p    i  g  a              n  q scheduling function   q
set rational numbers       valid temporal plan p following
properties 
i   i     i      
a  start a    ei   ej pairing event ei    j   
 i    dur a  
maximum value assigned events called makespan  
example    consider problem p    i  g  a  depicted figure    state i 
g contain propositions listed labels  init  goal  respectively 
set possible instantiations operators presented figure   objects
listed label  objects figure    let
  hstart work truck    
start load truck   package   s    
end  load truck   package   s    
start move truck   s   s    
end  move truck   s   s    
start move truck   s   s    
end  move truck   s   s    
start unload truck   package   s    
end  unload truck   package   s    
end  work truck   i
schematic representation depicted figure    straightforward checking shows
causally valid plan p  however  valid temporal plan
duration work truck        requires serial execution two move actions  one
load action  one unload action  total duration      work truck  
still open  words  one single working shift truck  sufficient transfer
package  s  s   therefore  scheduling function properties
definition   exists   valid temporal plan p depicted figure   
plan  two working shifts truck  used 
   

firankooh   ghassem sani

figure    causally valid plan

figure    valid plan

    limitations
end section describing differences formalism valid temporal
plans pddl     main limitations formalism listed below 
according definition    starting event action applicable state
already open s  means that  similar many previous
temporal planners  permit two versions action overlap 
consequently  current implementation itsat allow self overlapping
actions  however  specification pddl    allows plans actions 
shown necessary solving certain temporal problems  fox  
long         experimental results indicate restriction render
itsat incapable solving current benchmark problems  nevertheless 
shown that  theory  self overlapping actions may cause complexity
temporal planning become expspace hard rather pspace hard  rintanen 
      
formalism allow two events simultaneously applied
state  example cases simultaneity required  consider two
temporal actions b  starting event adds invariant b 
   

fiitsat  efficient sat based temporal planner

starting event b adds invariant a  case  might necessary
simultaneously apply starting event actions given state 
clear specification pddl    whether simultaneity permitted
not  hand  shown almost none current benchmark
problems require simultaneity solvable  rankooh   ghassem sani 
      
pddl    allows usage numerical variables  supported itsat 
pddl    allows duration dependent effects state dependent durations
actions numerical planning problems  features supported itsat
either  itsat currently handle numerical fluents 
according formalism  duration temporal action defined   
 duration x  assignment  x rational number function specifying
actual duration action  pddl     hand  allows using
inequalities    duration x     duration x  define range
duration temporal action  nevertheless  current benchmark problems
include inequalities  although current implementation itsat
support inequalities  quite easy include feature  kinds
constraints duration actions handled simple temporal problems
 dechter et al         

   preprocessing phase
preprocessing important phase many planners  main objective phase
extract certain information problem  information later used
enhance search performance  one important issue addressed devising
preprocessing method correctness extracted information  words 
constraints inferred preprocessing phase must correct sense that 
cause planner become incapable finding valid plans  moreover 
preprocessing method effective  required performed polynomial
time  section  explain two different preprocessing methods used itsat  mutual
exclusion analysis action compression  formally prove methods
correct performed polynomial time 
    mutual exclusion analysis
mutual exclusion analysis preprocessing method find pairs propositions cannot mutually true state valid plan  sat based planners typically add
explicit clause sat formula pair mutually exclusive propositions 
clauses prevent mutually exclusive pairs propositions true true
time  although information obtained search phase itself  acquiring beforehand  one prune search tree sat solver thereby improve
performance 
polynomial time mutual exclusion analysis classical planning problems originally performed constructing planning graphs  data structure introduced
   

firankooh   ghassem sani

graphplan  blum   furst         shown mutual exclusion
information obtained planning graphs quite effective improving performance sat based planners  gerevini   schubert         methods
introduced compute n way mutexes  instead pairwise mutexes computed
planning graphs   hn heuristic  haslum   geffner         analyzes reachability set n propositions initial state  example methods 
shown generalization hn heuristic efficiently computed
using syntactic regression operation  rintanen   gretton        
method used itsat finding mutual exclusion relations based
planning graph analysis  classical planning graph layered structure  first layer
includes propositions present initial state problem 
layer planning graph  mutual exclusion  mutex   relations pairs proposition
computed  two propositions non mutex first layer
present initial state  action applicable layer preconditions
non mutex layer  two different actions mutex layer i  least one
following conditions holds     interference  i e   one action
deletes effect action      conflict  i e   one action
deletes precondition action      preconditions mutex layer i 
layer     includes effects actions applicable layer i  two propositions
mutex layer become non mutex layer     produced non mutex
actions layer i  transfer propositions one layer next layer  exists
special noopp action proposition p requires adds p  construction
planning graph may continue change take places two consecutive layers 
case  say graph leveled off 
planning graphs previously employed tackle temporal planning problems
 smith   weld         fact  first completely domain independent temporal planner
called tgp  extension graphplan  blum   furst         tgp requires
preconditions temporal action preserved throughout time action
open  allow actions effects upon starting  result  tgp
compatible requirements pddl     tpsys  garrido et al         
extension tgp  another planning graph based temporal planner produce
plans domains required concurrency  similar graphplan  addition
construction planning graph  tpsys tgp perform backward search
valid temporal plan 
lpgp  long   fox        another planning graph based temporal planner  lpgp 
mutex relations proposition actions computed considering
causal constraints problem  whereas temporal constraints taken
account later plan extracted solving linear programming  lp  problem 
omitting temporal constraints problem done converting given temporal
problem classical problem  result  graph construction lpgp
similar graphplan 
mentioned earlier  itsat  temporal constraints problem considered
causally valid plan produced  therefore  constraints needed
dealt planning graph construction phase  makes graph structure
lpgp suitable itsat  here  explain graph construction phase lpgp 
   

fiitsat  efficient sat based temporal planner

correctness mutual exclusion information obtained method essential
correctness action compression sat encoding methods  however  description
lpgp accompanied formal proof correctness  therefore  here 
formally prove correctness tractability preprocessing method 
definition     causal abstraction temporal problems   let p    i  g  a 
temporal planning problem ac set classical actions
exactly three classical actions   ai   ae ac   following properties 
pre as     pre start a    inv a  add a  
add as     add start a    opena    opena new proposition specifying
started yet finished
del as     del start a   add start a  
pre ai     inv a   opena  
add ai     inv a   opena  
del ai    
pre ae     pre end a    opena  
add ae     add end a  
del ae      del end a   add end a     opena  
causal abstraction p classical problem p c    state i   g  ac   
fact  definition     produce causal abstraction given temporal planning problem  split temporal action three classical actions   ai   ae  
actions ae correspond respectively starting ending events a  addition normal effects preconditions  adds special proposition named opena  
required deleted ae   action ai called invariant checking action
a  requires invariants plus opena preconditions  produces opena
effect 
given temporal planning problem p    i  g  a   itsat produces
c
p    state i   g  ac   i e   causal abstraction p  itsat constructs classical planning graph p c  
planning graph itsat similar graphplan  one
difference planning graphs two planners  graphplan  mentioned earlier  propositions propagated layers so called noop actions 
however  itsat  exception usage noop actions  new proposition
form opena introduced causal abstraction action a  particular proposition
propagated ai   invariant checking action a  therefore  ai seen new
kind noop action used cover invariants reasoning mutex relations 

   

firankooh   ghassem sani

theorem    let p    i  g  a  temporal planning problem p c    state i   g  ac  
causal abstraction p  let   he         en finite sequence events
applicable i  sn   succ i     following conditions must hold 
two propositions p q members state sn    p q non mutex
layer n planning graph p c  
proposition p member state sn    action member agenda sn   
p opena non mutex layer n planning graph p c  
proof  see appendix a 
planning graph leveled off  subsequent extensions graph
effect new layers  therefore  two propositions mutex last layer
leveled off graph  remain mutex subsequently produced layers  case 
theorem   implies pairs propositions never appear temporal
state execution valid temporal plan  matter remains
show mutual exclusion analysis itsat performed polynomial time 
let p temporal planning problem  p c causal abstraction p 
deduced definition     size p c greater p constant
factor  process constructing planning graph p c obtained modifying
construction process planning graphs graphplan planner  way
temporal action a  noopopena never used  graphplan constructs planning
graphs polynomial time  blum   furst         therefore  overall time needed
mutual exclusion analysis itsat polynomial size given temporal
planning problem 
    action compression
temporal actions variety temporal relations one another  popular
model representing temporal relations actions initially introduced james
allen         model included    possible temporal relations two actions 
allens temporal relations require starting and or ending events actions
executed simultaneously  mentioned section      none temporal plans
produced itsat necessitate simultaneity  result  set temporal
relations two temporal actions confined proper subset allens
temporal relations  possible temporal relations depicted figure   
shown figure        types relations  actions concurrent  i e  
exists time two actions executed  concurrency
unnecessary solving temporal planning problems  know two actions
required concurrently executed  order find valid plan  checking
two temporal relations depicted figure    c  sufficient searching phase
planner  however  valid plans include concurrent executions two actions 
restricting temporal relations actions two relations depicted figure
   c  render planner incomplete 

   

fiitsat  efficient sat based temporal planner

figure    temporal relations two pddl    actions

definition     compression safe sets actions compressed plans   let
p    i  g  a  temporal planning problem exists least one valid
temporal plan  subset a  say compression safe p  exists
causally valid plan p compressed respect   causally valid plan
  he         en compressed respect following property 
k  ek starting event action   ek   ending event
a 
according definition     starting ending events members
assumed executed consecutively least one causally valid plan  therefore 
plan executed  event causally needed happen starting
ending member   suggests members regarded
single event environment  rather two separate starting ending events 
   

firankooh   ghassem sani

words  member   compress starting ending events
single event without rendering problem unsolvable  example  consider
driverlogshift temporal planning problem presented example    plan presented
example   shows set load  move  unload actions compressionsafe set actions problem  straightforward analysis example shows
neither work actions presented example   member compression safe
subset actions 
note that  according definition     causally valid plan regarded
compressed sequence events  although concept compression extended
cover even sequences events lead goal state  sake
simplicity  focused attention sequences causally valid
plans  defined compression safe actions solvable temporal planning problems 
explain later section    information obtained compression safety analysis
incorporated encoding problem adding extra sat formulae 
makes problem hand tighter  words  information used prune
search space sat solver  result  handling compression safety
never cause planner produce  invalid  plan unsolvable planning problem 
safe action compression employed field temporal planning
 coles et al          shown temporal problems possess
property required concurrency  temporal actions safely compressed classical
actions  cushing et al          temporal problem said required concurrency 
every valid temporal plan includes least one action whose execution overlaps
execution action  problems without required concurrency  temporal
actions compressed classical actions  case  problem transformed
classical planning problem  phenomenon completely consistent
semantics definition     easily shown problems without required
concurrency  set actions indeed compression safe set actions  however 
case example    even problem required concurrency
property  may still exist non empty compression safe set actions 
crikey  successor  popf  two state space based temporal planners
detect compression safe actions preprocessing task  coles et al          however 
concept compression safety planners different presented
definition     crikey  assume ending event compression safe
action must executed immediately corresponding starting event  instead 
starting event compression safe action applied state  using simple inference
method  crikey  determine apply corresponding ending event 
method reduce branching factor search space state space based temporal
planning  here  show using idea detecting compression safe actions 
one significantly reduce search space satisfiability checking based temporal
planning  later explained section      compression safe action a  add
clause sat formula guarantee starting event present step
ending event present step  clauses used
prune search tree sat solver checking satisfiability produced
formula 
crikey  considers action compression safe following two conditions hold 
   

fiitsat  efficient sat based temporal planner

pre end a   inv a 
del end a    
figure    a  shows temporal plan executed reach proposition q  example ending event action b precondition delete effect  therefore 
crikey  considers b compression safe  however  goal produce q 
singleton    b  compression safe set definition     fact  method used
crikey  specifically devised state space based temporal planners 
cannot easily employed sat based planners itsat  contrast 
later shown  method easily used state space based temporal planners
sat based planners 
cases method used crikey  cannot detect actions
compression safe according definition     consider plan depicted figure   b   suppose proposition p member initial state  goal
produce proposition g  plan  actions b must executed consecutively
produce g  p q  respectively overall conditions
b mutually exclusive  never true together  however  neither b
second property required crikey  regarded compression safe action 
section show mutex information used detecting compression safe
actions 
definition     swappable events   let two different temporal actions  e
starting ending event a  e starting ending event   say e
e swappable following conditions hold 
e e interference other  add e  del e     add e  
del e     
e e conflict other  del e   pre e   inv a     
del e    pre e  inv a      
e e supporting other  add e   pre e    inv a   add e      
add e    pre e   inv a  add e       
according definition     two events swappable causal relation
them  means causally valid plan   he         e  e        en i  swap
e e reach another causally valid plan   he         e   e       en i  use
swapping reorder events given causally valid plan without falsifying it 
consider causally valid plan   he         en i  let ei ej starting
ending event action  events plan swappable ej  
then  repeatedly swapping  one reorder produce another causally valid plan
  he         ei   ej   ei          ej    ej          en i  ei ej two consecutive events 
therefore   a  compression safe set  case  say compressed
towards start  similarly  every event plan ei ej swappable
ei   then  repeatedly swapping  one reorder produce causally valid
plan   he         ei    ei          ej    ei   ej        en i  again  conclude  a 
compression safe set  latter case  say compressed towards end 
   

firankooh   ghassem sani

figure    temporal actions regarded compressible itsat  a  crikey   b 

find whether safe compress given action a  need check
events swappable starting and or ending events a  fact  considering
mutex relations obtained planning graph problem  already know
events never executed open  information effectively used
find given set actions compression safe 
definition     compressible actions   let p    i  g  a  temporal planning problem  particular temporal action  say compressible towards
start  every event e e starting ending event  a   least
one following conditions holds 
precondition add effect e mutex opena last layer leveled off
planning graph causal abstraction p 
e swappable end a  
   

fiitsat  efficient sat based temporal planner

similarly  say compressible towards end  every event e e
starting ending event  a   least one following conditions holds 
precondition add effect e mutex opena last layer leveled off
planning graph causal abstraction p 
e swappable start a  
theorem    let p    i  g  a  solvable temporal planning problem  let set
every member either compressible towards start compressible towards
end  compression safe p 
proof  see appendix a 
give example clarification matter 
example    let p    i  g  a  temporal planning problem  set
three temporal actions a  b  c  consider hypothetical causally valid plan depicted
figure    a   execution action includes execution action b
turn includes execution action c  assume compressible towards start 
b compressible towards end  show plan converted another
causally valid plan a  b  c executed sequentially  figures    b 
   c  show results two consecutive swaps b compressed towards
end  starting event b swapped starting event c transform
plan figure    a  plan figure    b   since b compressible towards
end  swapping cannot result invalid plan  similarly  starting event b
swapped ending event c transform plan figure    b 
plan figure    c   figures    d     g  show results four consecutive swaps
compressed towards start  result swaps  fully
sequential plan shown figure    g  produced  implies even planner
allow execution event b open  still capable producing
temporally valid plan figure    g  
given problem p    i  g  a   itsat computes compression safe set
theorem    check first condition definition     itsat needs construct
planning graph causal abstraction p which  showed previous
subsection  done polynomial time  second condition definition    
suffices check every possible pair events see swappable  since
done pair constant time  total time o  a      conclude
finding performed polynomial time 
method described finding compression safe actions used statespace temporal planners  too  state space temporal planners divided two categories  first category includes planners based so called decision
epoch planning method  cushing et al          examples decision epoch planners
tp   haslum         sapa  do   kambhampati         tfd  eyerich et al         
   

firankooh   ghassem sani

figure    action compression

method  start action restricted immediately start
end another action  state explicit time stamp  action applied
state  starting time action set time stamp state  result 
starting event action added plan  time corresponding
ending event exactly known  searching valid plan  state 
   

fiitsat  efficient sat based temporal planner

planner make decision either advancing time ending event
open action  open new action  however  know action compressionsafe  planner advance time ending action thereby prune
search space  plans produced way might larger makespans comparison
produced without pruning search space  nevertheless  produced plans
rescheduled find plans improved makespans method explain later
section   
alternative approach state space search so called temporally lifted
progression planning  proved complete pddl     fox   long 
       crikey  popf examples planners using approach 
state temporally lifted progression planning represents permutation
number events  state  consistency temporal constraints imposed
sequence events state checked solving simple temporal problem  stp  
similar decision epoch planning  state  may exist two possible choices 
add ending event open action  open new action  however  compressionsafe actions  ending event actions applied immediately starting event 
turn reduces future choices planner  show section  
taking advantage compression safe actions manner  planner still visit
stps causally valid permutations events 
table   shows comparison average percentage actions regarded
compression safe new method method used crikey  popf  various temporal planning domains  explain information regarding benchmark
domains problems later section    seen table    compression
method detect significantly compressible actions number benchmark domain 

   encoding phase
section  explain abstract causal problem associated given temporal
problem encoded sat formula  classical planning  exist one
way translate particular planning problem corresponding sat formula  previous
investigations field classical planning show choice encoding method
major impact efficiency sat based planner  mentioned earlier 
successful sat based classical planners used special encoding methods
based so called  step  step semantics valid plans  rintanen et al         
section  define temporal versions classical  step  step plans 
show exactly semantics used translate given temporal planning
problem sat formula  introduce  step encoding two different types
 step encodings temporal planning   step first  step encoding methods
temporal versions classical  step  step encodings  similar classical
versions  new encodings  restrictive simplifying assumptions assumed
hold  second type  step encoding  however  obtained relaxing one
assumptions  later show  new  step encoding often requires fewer steps
one  besides  experimental results show  among new encoding methods 
second  step encoding results best performance itsat terms speed
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

crikey 
  
  
   
 
   
   
   
   
   
   
   
   
  
  
   
  
   
   
  
  
  
  

itsat
   
   
   
  
   
   
   
   
   
   
  
   
  
  
   
  
  
  
  
  
  
  

table    average percentage compressed actions
memory usage planner  necessary proofs soundness completeness
encoding methods given section 
    parallel semantics causally valid plans
mentioned earlier  classical  step semantics permits parallel execution
one action step  validity plan depend execution
order actions  simply guaranteed adding particular clause
pair mutually exclusive actions ensure actions included
step  however  strategy work temporal planning  temporal
planning  temporal constraints imposed starting ending events
actions  validity particular ordering events certain step  depends
ordering events steps  nevertheless  itsat problem
tackled separating causal temporal reasoning phases  general  focus
finding causally valid plans  postpone scheduling phase  mentioned problem 
checking feasibility imposing different orderings events step 
longer exist  next introduce semantics causally valid  step  step temporal
plans 

   

fiitsat  efficient sat based temporal planner

definition     temporal  steps  steps   let e    e         en   set events 
s  s  two temporal states  temporal  step s  s 
one to one ordering functions            n           n   i e   permutations events  
have  s    succ s    heo           eo n  i   temporal  step s  s 
exist least one to one ordering function            n           n   i e   least one
permutation events   that  s    succ s    heo           eo n  i  
definition     causally valid  step  step plans   let p    i  g  a  temporal planning problem  suppose s         sn sequence temporal states s    i 
g state sn    agenda sn         n  stepi  step   step 
si  si   call sequence   hstep         stepn i  causally valid  step   step 
plan p  say hs         sn state transition sequence  
classical  step  step encodings  rintanen et al         based  step
 step semantics classical valid plans  respectively  however   step encoding 
sake improving efficiency planner  following restrictive rules
enforced semantics 
rule    instead accepting possible orderings among actions step 
fixed arbitrary ordering allowed  result  rule  execution
step necessitates execution actions according fixed ordering 
rule    preconditions actions step must members state immediately step  similarly  effects actions step must
consistent state reached immediately step 
section  present one  step two  step encodings planning causal
abstractions temporal planning  encodings based  step  step
semantics causally valid plans  definition      considering events  instead actions 
rules applied temporal planning  too  first  step
encoding  respect rules  second  step encoding  second restrictive rule
relaxed 
fact  second rule imposes serious restrictions applicability actions
step  instance  prevents proposition produced used
step plan  neither allow deletion production
particular proposition step  relaxing restrictions  encoding
compact  i e   relaxation permits events occur step  classical
planning  less relaxed form rule   introduced effects actions
step used actions step  wehrle   rintanen         here 
however  totally relax rule   allow proposition required  added 
deleted many times step 
explaining sat encodings  first define sat variables auxilary clauses
commonly used three encoding methods  let   hstep         stepn causally
valid  step  or  step  plan given temporal planning problem p    i  g  a  
hs         sn state transition sequence   order encode p sat formula
whose model translated back   use following sat variables 
   

firankooh   ghassem sani

proposition p    n  define sat variable pt  
assigning true  f alse  pt implies p  is not  member state st   
action a    n  define sat variable  
assigning true  f alse  implies  is not  member agenda st   
event e e starting ending event action a 
  n  define sat variable et   assigning true  f alse  et
implies e  is not  member stept  
sat formula satisfiable exists model it  model binary function
assigns value true f alse variable formula way
formula satisfied  encoding methods  produced formula
model   one easily translate corresponding causally valid  step  or  step 
plan  using description given variables formula  denote
resulting plan plan m    showing correctness particular encoding method 
two issues must addressed  first  must show exists causally valid
plan temporal problem p  encoding p model  call
completeness encoding method  second  must show encoding p
model   plan m   causally valid plan p  called soundness
encoding method 
note here  prove finite horizon completeness  completeness
encodings  words  prove exists  step  or  step  plan
l steps given problem  problem translated  step  or  step 
encoding satisfiable sat formula l steps  model formula
translated back   hand  proof  completeness would need
value l determined  proofs finite horizon completeness could implied
 completeness least upper bound value l determined  recent
research field classical planning shown classical planning domains 
tight upper bounds length optimal plans determined  rintanen   gretton 
       however  determining upper bounds temporal planning beyond scope
current work  find causally valid plan  itsat starts encoding
one step  sequentially produces tries satisfy formulae increasing number
steps  satisfiable formula encountered predefined time limit
reached 
classical sat based planning  order produce linear size encodings  step
 step semantics valid plans  special sets clauses  named chains  used
 rintanen et al          since used chains itsat  formal definition
temporal version given here  let e         en arbitrary fixed ordering
events  e r two sets events  k natural number  special symbol
assigns unique name chain hand  define chain e         en   e  r  k  m 
conjunction formulae  c     c    stated below 
 c   

v

 eki bkj m  i   j  ei e  ej r   ei          ej    r    

 c   

v

 bki m bkj m  i   j   ei   ej   r   ei          ej    r    
   

fiitsat  efficient sat based temporal planner

 c   

v

 bki m eki  ei r 

formulae fact encodes message passing strategy  symbol specifies
name message used distinguish sat variables certain chain
chains  number k specifies step whose variables affected
message produced  message may produced member e 
receivers message members r  bki m true  means message
received i th event k th step formula  ei member e  eki
true  message produced sent ej   first member r
located ei fixed ordering  represented chain e         en   e  r  k  m 
clauses form eki bkj m formula  c     message produced 
transmitted forward according fixed ordering clauses form bki m bkj m
formula  c     event ei receives message  corresponding sat variable
bef alse clauses form bki m eki formula  c     fact  members r
receive message certainly excluded final plan 
present examples show chains practically used guarantee particular characteristics output plan have 
example    assume e    e    e    e  four events  suppose proposition x
required e  e    deleted e    added e    assume four propositions
p         p  respectively added e         e    consider following two cases 
case    want prevent proposition x required deleted
step  say k  final plan  purpose  add conjunction
chain e         e    e  r  k  mx    chain e         e    e  r  k  mx    formula  e
set events delete x  i e   e    e      r set events
require x  i e   r    e    e      note mx  mx  two symbols enable us
distinguish sat variables used two different chains  case 
adding chain e         e    e  r  k  mx    add following formulae encoding
problem 
ek  bk  mx
 



bk  mx
 



bk  mx
 

bk  mx ek 
 

bk  mx ek 
 

assume exists model produced sat encoding
 ek      true  case  since satisfies ek  bk  mx    bk  mx     true 
 
 
consequently  since satisfies bk  mx ek     ek      f alse  words 
 
e  member step k  e  cannot member step  similarly 
adding chain e         e    e  r  k  mx    add following formulae encoding
problem 
ek  bk  mx
 

   

firankooh   ghassem sani

bk  mx bk  mx
 



bk  mx
 

 



ek 

bk  mx ek 
 

argument similar one given chain e         e    e  r  k  mx    shows
adding chain e         e    e  r  k  x     e  member step k  e  cannot
member step  result  adding mentioned chains sat
formula  execution step k produces p    cannot produce p  p   
actually occurrence conflicting actions step final plan
avoided linear size classical  step encoding  rintanen et al         
case    allow proposition x required deleted particular step
k deleting event precede requiring event fixed ordering
he    e    e    s  i  purpose  need add chain e         en   e  r  k  mx  
formula  e r e r case    case 
execution step k produces p    produce p    p    strategy  too 
initially introduced linear size classical  step encoding  rintanen et al  
      
note one admits second restrictive rule mentioned above  case
classical  step  step encodings  proposition added event step
deleted another event step  result  execution step
k produces p    cannot produce p  cases 

    temporal versions classical  step  step encodings
first present temporal versions classical  step  step encodings  similar
classical forms  temporal versions encodings  assume arbitrary
fixed ordering e         en events given temporal problem p    i  g  a  
assume output plan fixed number steps  denoted l 
let   hstep         stepl output plan p  hs         sl state transition
sequence   event e  let action e  member whose starting
ending event equal e  let p set propositions p  proposition
p p   let ep    e p del e    ep     e p add e   rp    e p pre e    e p
inv action e   add e    moreover  assume two dummy events e  en    
precondition  add effect  delete effect 
       step encoding
given temporal problem p    i  g  a   produce sat formula l   based
 step semantics causally valid plans  p conjunction formulae
described below 
v
      p   p state i    p   p
  state i  
v l
      p  p g 
   

fiitsat  efficient sat based temporal planner

    

v

 a   a a 

    

v

 al  a a 

    

v

 ek pk       k l  p p  e rp  

    

v

 ek pk      k l  p p  e ep   

    

v

    

v

     

v

     

v

     

v

 ek ak  ak      k l  a  e   start a  

     

v

 ek ak  ak      k l  a  e   end a  

 ek pk      k l  p p  e ep  
v
w
      pk  pk eep  ek      k l  p p  
 pk  pk

w

eep

ek      k l  p p  

 chain e         en     ep   rp  en      k  mp        k l  p p  
  bkn   mp ak       k l  p inv a  
 

 chain en        e    ep   rp  e     k  mp        k l  p p  
  bk  mp ak        k l  p inv a  
 

formula      indicates member state s    true iff present initial state  similarly  formula      states members goal state must true
state sl    formulae           imply agenda s    agenda sl   empty 
formulae           show event applied step k  preconditions must
present state sk     effects must consistent state sk    formulae          responsible encoding so called explanatory frame axioms  formula
     implies p present step k  must exist least
one event step k p add effects  similarly  formula      implies p
present step k  must exist least one event step k
deletes p  formulae             added guarantee events step
executed possible ordering  formula       implies p deleted
event ei step k  p cannot required event ej step k j   i 
implies p deleted event step k  action p invariant 
cannot member agenda sk    note chain e         en     ep   rp   k  mp   
used formula        value bn   mp  indicates whether p deleted
event step k  reason using dummy event en  
indicator  analogously  formula       implies p deleted event ei step k 
p cannot needed event ej step k j   i  formula      
implies p deleted event step k  action p invariant 
cannot member agenda sk     formulae             responsible
applying appropriate changes agendas states located
step final plan  formula       implies starting event action
member step k output plan  must member agenda sk  
agenda sk     similarly  formula       implies ending event action
   

firankooh   ghassem sani

member step k plan  must member agenda sk    agenda sk   
theorem    completeness temporal  step encoding   let p    i  g  a 
solvable temporal planning problem   e         en   set events p   
hstep         stepl causally valid  step plan p  exists model l
  plan m   
proof  see appendix a 
theorem    soundness  step encoding   let p    i  g  a  temporal planning
problem   e         en   set events p  l  step encoding p 
l model   plan m   causally valid  step plan p 
proof  see appendix a 
       step encoding
part  present sat formula l   based  step semantics
causally valid plans  considering two restrictive rules stated above   step
encoding similar  step encoding described previously section  however 
two major differences two kinds encoding  first   step
encoding allows proposition required deleted step  provided
deleting event precede requiring event fixed ordering he         sn i 
contrast  step encoding  proposition could deleted
required step final plan  second   step encoding 
step may contain starting ending event action  given
temporal problem p    i  g  a   produce sat formula l   based
 step semantics causally valid plans  p conjunction formulae described
below 
v
      p   p state i    p   p
  state i  
v l
      p  p g 
v
      a   a a 
v
      al  a a 
v
      ek pk       k l  p p  e rp  
v
      ek pk      k l  p p  e ep   
v
      ek pk      k l  p p  e ep  
v
w
      pk  pk eep  ek      k l  p p  
    

v

 pk  pk

w

     

v

 chain e         en     ep   rp  en      k  mp        k l  p p     bkn   mp

eep

ek      k l  p p  
 

ak       k l  p inv a  
   

fiitsat  efficient sat based temporal planner

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

     

v

 eki ak       k l  a  ei   start a   ej   end a     j 
 eki ak ekj      k l  a  ei   start a   ej   end a     j 
 ekj ak      k l  a  ei   start a   ej   end a     j 
 ekj ak  eki      k l  a  ei   start a   ej   end a     j 
 eki ak  ekj      k l  a  ei   start a   ej   end a   j   i 
 eki ak      k l  a  ei   start a   ej   end a   j   i 
 ekj ak eki      k l  a  ei   start a   ej   end a   j   i 
 ekj ak       k l  a  ei   start a   ej   end a   j   i 
 ak  ak eki      k l  a  ei   start a  
 ak  ak ekj      k l  a  ej   end a  

note formulae           exactly formulae            similar
 step encoding  formulae responsible validity initial state  goal
state  conditions effects events  explanatory frame axioms explained
before  moreover  notice formula       present  step encoding
formula        formula       present l   results first major difference
stated  step encoding  step encoding  formulae      to      
enforce appropriate changes agenda sk    agenda sk    agendas
states immediately step k final plan  according definitions 
formulae             added action property start a 
located end a  fixed ordering he         en i  formula       ensures
started step k  open sk    formula       guarantees
started ended step k  must open sk   formula       ensures
ended step k  open sk   formula       implies ended
started step k  must open sk    analogously  formulae            
guarantee similar properties action property start a  located
end a  fixed ordering he         en i  formula       ensures member
agenda sk   agenda sk     must started step k  similarly  formula      
ensures member agenda sk    agenda sk    must ended step
k 
since  step encoding conforms two restrictive rules stated earlier
section  may exist  step causally valid plan l steps given problem
l would unsatisfiable problem  case linear size step encoding classical planning problems  rintanen et al          however  since
showed theorem    step encoding complete  completeness  step
encoding proved showing satisfiability l entails satisfiability l  
theorem    completeness  step encoding   let p    i  g  a  solvable temporal planning problem   e         en   set events p    hstep         stepl
causally valid  step plan p  exists model l   plan m   
   

firankooh   ghassem sani

proof  see appendix a 
theorem   shows  step encoding  number required steps
solve temporal planning problem less  or equal to  required  step
encoding  words   step encoding compact  step counterpart 
theorem    soundness  step encoding   let p    i  g  a  temporal planning
problem   e         en   set events p  l  step encoding p 
l model   plan m   causally valid  step plan p 
proof  see appendix a 
    relaxed  step encoding
mentioned section         step encoding allows proposition
required deleted two events step  deleting event
precede requiring event fixed ordering he         en i  besides  since formulae     
     present  step  step encodings  proposition
added deleted step encodings  restrictions 
present classical  step  step encodings  rintanen et al          lifted
new relaxed version  step encoding  result  proposition required 
added  deleted step many times needed  property
previously examined classical  step encoding  consequently  chaining mechanism
explained section     compatible it  here  introduce generalized version
chains explain conceptual difference used classical encodings 
present new kinds chains used specially temporal planning preserving
invariants temporal actions plan produced  note that  similar
non relaxed  step encoding  assume events step executed
according fixed ordering he         en i 
let k natural number e         en fixed ordering events  reasons discussed later  assume ei starting event action  ei  
ending event action  words  assume ending event
action located immediately starting event fixed ordering  note here 
demand end action immediately follow start final plan 
put constraint fixed ordering  cannot compromise completeness
itsat  sat solver still choose start action step k  choose whatever
actions needed steps k k   arbitrary m  choose end
step k  m  moreover  suppose two dummy events e  en    
precondition  add effect  delete effect  let p set propositions
p  proposition p p   let ep    e p del e    ep     e p add e    op    e p
inv action e     e    en      rp    e p pre e    e p inv action e   add e   
define chain  e         en     ep    ep   rp   k  mp   conjunction formulae  c    
 c     stated below  note mp symbol used distinguishing sat varibales
used formula chain  e         en     ep    ep   rp   k  mp   variables used
formulae 

   

fiitsat  efficient sat based temporal planner

 c    

v

 eki bkj mp  i   j  ei ep    ej rp ep    ei          ej     rp ep      

 c    

v

 eki bkj mp  i   j  ei ep   ej rp ep     ei          ej     rp ep       

v

 bki mp bkj mp  i   j  ei rp  ep  ep    ej r ep  ep    ei          ej   
 rp ep  ep      
v
 c       bki mp eki   bkj mp  i   j   ei   ej   rp ep  ep    ei          ej     rp ep 
ep      
v
 c       bki mp eki   bkj mp  i   j   ei   ej   rp ep  ep    ei          ej     rp
ep  ep      
v
 c      bki mp eki  ei rp  

 c    

 c     bk  mp pk 
 c     bkn   mp pk
fact  chain  e         en     ep    ep   rp   k  mp   encodes message passing method
different chain e         en   e  r  k  m   chain  e         en     ep    ep   rp   k  mp   
conveyed message fact value proposition p  therefore either true
f alse  similar message passing strategy chain e         en   e  r  k  m   received
message transferred forward direction fixed ordering e         en  
event ep    ep   rp receives message previous event fixed ordering 
every event may may change value received message  either cases 
message passed next event  events ep  change value
received message true  events p add effects  similarly 
events ep change value received message f alse  formulae
 c      c     impose changes value received message  event
member ep  ep   neither adds deletes p  thus  pass received
message without altering value  enforced  c       c      c     ensure
received messages passed without changed events
chosen stepk output plan  according  c      event rp receives
message value f alse  event cannot chosen member stepk  
members rp require p  necessitates received messages
value true   c     implies initial value message produced stepk equal
value p state immediately execution stepk   similarly   c    
implies value p state immediately execution stepk
equal final value message stepk  
example    consider events given example    let e   set events
add x  i e   e      a      e set events delete x  i e   e    a     
r set events require x  i e   r    a    a      moreover  suppose
two dummy events e  e    precondition  add effect 
delete effect  assume added chain  e         e    e     e   r  e    e     k  mx  
   

firankooh   ghassem sani

sat formula  according formulae  c      c      chain conjunction
following formulae 
ek  bk  mp
ek  bk  mp
bk  mp bk  mp
bk  mp bk  mp
bk  mp bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek  bk  mp
bk  mp ek 
bk  mp ek 
bk  mp ek 
bk  mp ek 
bk  mp xk 
bk  mp xk
   

fiitsat  efficient sat based temporal planner

straightforward examination shows model chain mentioned  ek       ek       ek       ek       ek       ek      true 
 bk  mp      bk  mp      bk  mp      bk  mp      bk  mp     true   bk  mp     f alse 
words  x deleted e  stepk final plan  later produced
e    result  e  appear stepk   too  here   bk  mp     f alse represents
fact x deleted execution e    example  four propositions
p    p    p    p  produced single step final plan  note neither
cases example    producing propositions one step possible 
example new  step encoding  employs generalized message
passing strategy  permit parallelism allowed temporal versions
classical  step  step encodings 
addition chain  e         en     ep    ep   rp   k  mp    responsible tracking
value p inside stepk   need extra formulae prevent p deleted
whenever p invariant open temporal action  therefore  introduce two new
ob

ob
chain formulae  chainof  e         en     ep   op   k  mof
p   chain  e         en   ep   op   k  mp   
formula chainof  e         en     ep   op   k  mof
p   produced conjunction formulae


 c      c      similar chains explained before  mof
p symbol used distinguish sat varibales chain formulae 
v
 cof      eki bk  i   j  ei ep   ej op    ei          ej    op    
j mp

 cof    

v

 bk

 cof    

v

  bk

ekj   eki  ei op   ei   start a   ej   end a  

 cof    

v

  bk

ak   eki  a a  ei   start a   ei op  

i mof
p

bk

j mof
p

j mof
p

n   mof
p

 i   j   ei   ej   op    ei          ej    op    

similar chain e         en   ep   rp   k  mp    chainof  e         en   ep   op   k  mof
p   represents
message produced sent forward direction fixed ordering  whenever
proposition p deleted event   cof      cof     responsible production
propagation mentioned message  respectively   cof      ending event
action p invariant receives message step k  step k must
include starting event a  cases   cof     prevents open p
deleted  assume fixed ordering  ending event
action located immediately starting event   cof     guarantees p deleted
somewhere step k  action p invariant open step k  step
k must include starting event  otherwise  open everywhere step k 
thus  p  invariant a  deleted open  
chainof  e         en     ep   op   k  mof
p    message indicates p deleted sent
forward  thus  cannot help preserving invariants members op
started prior deletion p  tackle problem  add another chain 
namely chainob  e         en   ep   op   k  mob
p    formula  chain quite analogous



chain  e         en     ep   op   k  mp    whenever p deleted event  chain sends
   

firankooh   ghassem sani

message backward according fixed ordering  chainob  e         en   ep   op   k  mob
p  
ob
ob
produced conjunction formulae  c      c     
 cob    

v

 eki bkj mob  j   i  ei ep   ej op    ej          ei    op    

 cob    

v

 bki mob bkj mob  j   i   ei   ej   op    ej          ei    op    

 cob    

v

  bki mob eki   ekj  ei op   ei   start a   ej   end a  

 cob    

v

  bk  mob ak    ekj  a a  ej   end a   ej op  

p

p

p

p

p



present sat formula l   represents relaxed  step encoding

based  step semantics causally valid plans  l produced conjunction
formulae described below 
v
       p   p state i    p   p
  state i  
v
       pl  p g 
v
       a   a a 
v
       al  a a 
v
       chain  e    e         en     ep    ep   rp  e    en      k  mp       k l  p p  
     

v

 chainof  e         en     ep   op   k  mof
p       k l  p p  

     

v

 chainob  e         en   ep   op   k  mob
p       k l  p p  

     

v

     

v

 eki ak       k l  a  ei   start a  

      

v

 ekj ak      k l  a  ej   end a  

      

v

 ekj ak  eki      k l  a  ei   start a   ej   end a  

      

v

      

v

 ak  ak eki      k l  a  ei   start a  

 eki ak ekj      k l  a  ei   start a   ej   end a  

 ak  ak ekj      k l  a  ej   end a  

      ensures member state s    true member present
initial state  similarly        guarantees members goal state true
state sl                imply agenda s    agenda sl   empty        
explained before  responsible imposing appropriate changes value sat
variables  whenever proposition p added deleted event certain step
output plan              prevent invariants action deleted
open               responsible enforcing appropriate changes
agenda sk    agenda sk    agendas states immediately
   

fiitsat  efficient sat based temporal planner

step k output plan        ensures started step k
open sk          indicates started ended step k 
open sk          ensures ended step k  open sk         
implies ended started step k  open sk          
ensures member agenda sk   member agenda sk    
started step k  similarly         ensures member agenda sk   
agenda sk    ended step k 
theorem    know temporal planning problem p satisfiable 
exists positive number l  non relaxed  step encoding p l steps
 i e   l   satisfiable  accordingly  completeness relaxed  step encoding

proved showing l satisfiable l satisfiable 
theorem    completeness relaxed  step encoding   let p    i  g  a 

temporal planning problem formulae l l two  step encodings p explained

above  model l   l model plan m     plan m   
proof  see appendix a 
theorem   shows that   step encoding  number required steps
solve temporal planning problem less  or equal to  required  step
encoding  provided fixed ordering used two encodings 
words   step encoding compact  step encoding 
theorem    soundness relaxed  step encoding   let p    i  g  a 

temporal planning problem   e         en   set events p  l relaxed

 step encoding p  l model   plan m   causally valid  step plan
p 
proof  see appendix a 
    mutual exclusion relations action compression
mentioned earlier section    performance sat based temporal planner
improved mutual exclusion analysis action compression  section 
show information obtained tasks utilized itsat  let
p    i  g  a  temporal planning problem  mu set mutually exclusive
pairs propositions p  com set compression safe actions p  see

section     let l encoding p  l   l   l   taking
advantage mutual exclusion relations  add extra formula mut
l   mut
 
l
l
v
k
k
 p q   p  q  mu     k l   theorem   shows  two mutually exclusive
propositions p q never true state achieved execution
valid temporal plan starting i  result  adding mut
encoding cannot
l
render planner incapable finding valid plans 
let compression safe action  showed section      safe
assume causally valid plan  ending event occurs immediately
starting event  one way impose constraint add extra clauses
   

firankooh   ghassem sani

encoding guarantee starting ending events always included
step  however  two events may conflicting effects  case l
l allow events present step  therefore  information

regarding compression safe actions added
relexed  step encoding  l  
v

done adding com
l   com
   eki eki    a com  ei   start a    
l
l


k l   note l   ei starting event action  ei   denotes ending
event 

   scheduling phase
section  describe causally valid plan augmented temporal information
produce valid temporal plan  let   he         en causally valid plan produced
planner  scheduling done defining scheduling function definition
   assigns rational number event execution time  suppose
given different names different occurrences action plan 
events e         en unique  assume i   i     i      
thereby satisfy first condition definition    however  lead plans
unnecessarily large makespans  alternatively  obtaining plans improved quality 
impose relaxed set constraints function  
definition     relaxed scheduling functions   let causally valid plan 
scheduling function relaxed scheduling function following properties 
 s    j ei located ej   ei swappable ej
 cf  definition      require  i     j  
 s    j  ei starting event particular action a  ej pairing
event ei  cf  definition     require  j     i    dur a  
theorem    let p    i  g  a  temporal planning problem    he         en
causally valid plan p             n  q relaxed scheduling function  
exists valid temporal plan p 
proof  see appendix a 
theorem   shows whenever relaxed scheduling function exists causally valid
plan p  valid temporal plan produced p  prove scheduling
method render itsat incomplete  need show p solvable 
planner able produce causally valid plan scheduling function
relaxed scheduling function   let      valid temporal plan
p  every causally valid plan regarded causally valid  step plan
singleton steps  therefore  theorem    l model   plan m   

theorem    satisfies l   moreover  theorem    l model
  plan m     plan m    therefore  encoding methods used
translating p sat formula  resulting formula model translated
  hand  according definition    satisfies constraints form
 s     s     therefore  relaxed scheduling function   however  mentioned
   

fiitsat  efficient sat based temporal planner

section        may add certain clauses encoding ensure produced
causally valid plan always compressed  definition      show solvable temporal plan  exists compressed causally valid plan scheduled
valid temporal plan relaxed scheduling function 
theorem     let p    i  g  a  solvable temporal planning problem  com
set every member either compressible towards start compressible towards end  definition      exists valid temporal plan      p
causally valid plan p  compressed respect com 
relaxed scheduling function  
proof  see appendix a 
check existence function properties stated above  solve
instance simple temporal problem  stp   dechter et al          stp associated
weighted graph named simple temporal network  stn   construct stn
node xi corresponds event ei causally valid plan   let arbitrary
small rational number  constraint form  i     j   add edge
weight xi xj   constraint form  j     i    dur a  
add edge weight  dur a  xi xj   another edge weight dur a 
xj xi   add reference node x  constructed stn  x  edge
weight   every node  solution stp found computing
length shortest path form x  nodes  dechter et al          suppose
shortest paths exist length shortest x  xi shown
distance x    xi    event ei   define  i  equal distance x    xi   
case  theorem   guarantees resulting plan specifications valid
temporal plan 
see intuition behind explained method defining function   suppose constructed stn  edge weight xi xj  
means distance x    xj   distance x    xi     implies distance x    xi  
distance x    xj     this  turn  implies distance x    xi     distance x    xj   
 i     j   similarly  easily shown exists edge
weight  dur a  xi xj   another edge weight dur a  xj xi  
have   j     i    dur a   bellman ford algorithm  cormen  leiserson  rivest 
  stein        used find single source shortest paths weighted graph
polynomial time  besides  number nodes produced stn equal
number events causally valid plan  therefore  conclude that 
mentioned shortest paths exist   i  computed polynomial time 
however  situations shortest paths exist  happens
corresponding stn negative cycle  situations  stp inconsistent
consequently  temporal constraints cannot satisfied time 
example case depicted figure    
figure     action adds propositions p g starting ending events 
respectively  needs proposition q precondition ending event  action b requires
p upon starting adds q upon ending  durations actions b       
respectively  goal planning reaching fact g  problem      bs     ae
   

firankooh   ghassem sani

figure     negative cycles

causally valid plan    start a   ae   end a   bs   start b     end b  
plan depicted figure     a   plan  execution action b must entirely
inside action  i e   b started starting ended ending a  
however  impossible considering fact duration less
b  invalidity plan caused fact producing causally valid
plan  durations abstracted out  stn constructed plan figure
    a  depicted figure     b   bs ae negative cycle total weight
    
    negative cycle prevention
stn causally valid plan includes negative cycle  plan cannot transformed
valid temporal plan  cases  sat solver forced find different
solution  done adding extra clause least one events
current negative cycle prevented occurring current step  however 
adding blocking clause  planner still produce new plans basically
equivalent previous plan  instance  consider example given figure    
suppose   bs     ae members steps      respectively  assume
output plan   steps  forbid exact occurrence negative cycle 
   

fiitsat  efficient sat based temporal planner

new causally valid plan still produced shifting ae layer   maintaining
events current steps  new solution negative cycle
therefore cannot transformed valid temporal plan  fact  cause
invalidity plan changed  show exploiting simple structure
negative cycles  one prevent reoccurrence cycles effectively 
discussion given above  clear main reason
negative cycles encountered stn particular causally valid plan 
specific order events plan  fact  events negative cycle reoccur
order new causally valid plan  new plan include negative
cycle  too 
temporal planning problem p  p
regard set possible sequences
events language alphabet
   e         en    n number
events p  set sequences events certain p
events appeared
particular order regarded another language   straightforward
show latter language fact regular language accepted
finite state machine  fsm   figure     c  shows finite state machine detects
sequences events   ae   bs   appear according order   bs     ae i 
note that  sake clarity  self loop transitions finite state machine
shown figure     c  
p
definition     fsms   ap
finite state machine   tuple  s       xp
      
finite set states 
finite set alphabet symbols   

mapping defining transitions   x  starting state  set
accepting states 
show adding certain formulae sat encodings  one avoid
members given regular language
produced causally valid plans  let
p
p temporal problem p

   e         en   set events p  let l
regular
  assume l accepted p
finite state machine
p langaue

 t  xi   e    xj      j 
   s    p
     xi   let ei    e
eiin    e
 t  xj   e    xi      j   assume two dummy events e 
en     precondition  add effect  delete effect  define sat
variable xk i   k l    n      x   assigning value true xk i
means state x  operating sequence events steps  
k   events step k indices less final plan  construct
formula
l conjunction formulae           stated below 
    

v

k j
e  e
 eki xk i
xt    k l    j   xs   ei     xt   ej et
n     



 ei          ej     et et      

    

v

    

v

k j



 eki xk i
xs    k l    j  ei es   ej es es  en     


 ei          ej     es es      

k i


 xk  
xs    k l    n  xs   ei es es  


 e         ei     es es      

   

firankooh   ghassem sani

    

v

 xk n  
xk    
   k   l  xs  



    

v

 xk i
     k l    n 

    

v

 xk i  x     k l    n     

adding
l encoding problem makes sat solver somehow simulate
behavior   finding model represents causally valid plan  assume
observing ei causes make transition xs xt   moreover  let ej first event
ei  according fixed ordering e         en   may cause transition
xt   formula      guarantees ei member stepk   state xs
time observing ei   state changed xt   next relevant event
xt  i e   ej   become aware transition       implies ei member
stepk   state xs time observing ei   remain xs  
next relevant event xs become aware current state        causes
information regarding state start step propagated first
relevant event step       propagates information regarding state
end step next step       ensures starting state
place final plan  means simulation started
anywhere plan produced  enables sat solver detect
strings accepted   strings subsequences accepted
  finally       guarantees never one accepting states 

example    let finite state machine depicted figure     c   finite
state machine detects sequences events   ae   bs   appear according
order   bs     ae i  assume four events  e      e    ae   e    bs  
e      assume two dummy events e  e    sake simplicity 
suppose problem events e  e    encoding
two steps  consider boolean assignment    e        e        e      
 e       true   e       f alse  words  choosing   bs  
first step  ae second step  fact  plan m       bs     ae i 
example  e in    e     e    ae event causes transition
state s    similarly  have  e out    e     e in    e     e out    e    e     e in    e    
e out    e    e     e in    e     e out    e     e in    e     e out     show
use formulae           stated encode   cannot model
produced sat formula  show contradiction  assume model
produced sat formula 
s  starting state   hence  according        s         true 
means state s    prior checking whether e  present first
step final plan 
 
s   
according       e   s   
    since  e      true
 
   
 s   
      true  must  s      true  words  verifies e 
present first step final plan  causes current state

   

fiitsat  efficient sat based temporal planner

changed s  s     s   
      true implies state s    prior checking
whether e  present first step final plan 
   
 
according       e   s   
  s    since  e      f alse
   
   
 s      true  must  s      true  words  verifies
e  present first step final plan  causes state
remain s     s   
      true implies state s    prior checking whether e 
present first step final plan 
 
according       e   s   
s   
 
    since  e      true
   
   
 s      true  must  s      true  words  verifies e 
present first step final plan  causes state changed
s  s     s   
      true implies state s    prior checking whether
e  present first step final plan 
 
s   
according       e   s   
    since  e      true
 
   
 s   
      true  must  s      true  words  finds e 
present first step final plan  causes state changed
s  s     s   
      true implies state s    visiting events
first step final plan 
   
   
according       s   
  s    since  s      true  must
 s   
      true  implies state s    prior visiting event
second step final plan 
   
   
according       s   
  s    since  s      true  must
 s   
      true  implies state s    prior checking whether e 
present second step final plan 
 
s   
according       e   s   
    since  e      true
 
   
 s   
      true  must  s      true  words  verifies
e  present second step final plan  causes state
changed s  s     s   
      true implies state s    visiting
events first two steps final plan  hand  s  accepting
state   hence  according        s   
      f alse  clearly
contradiction  therefore  conclude cannot model produced
sat formula 

prove adding
l encoding given problem  prevents planner
producing causally valid plans subsequence events equivalent
string accepted   means negative cycle translated
fsm  reoccurrence negative cycle avoided translating fsm
sat formula  adding formula encoding problem 
p
theorem     let p    i  g  a  temporal planning problem 
   e         en  




set events p  l three formulae l   l   l  defined section
p    
non empty causally valid plan p obtained solving l   let    s       x     
   

firankooh   ghassem sani

fsm accepts subsequence   he         em  
l encoding
presented            exist model l
l
  plan m   
proof  see appendix a 
need show adding
l encoding render planner incapable producing plans contain subsequence accepted  
p
theorem     let p    i  g  a  temporal planning problem 
   e         en  

set events p  l three formulae l   l   l  defined
section     let model satisfies l     he         em   plan m    let
p
   s       x      fsm accept subsequence  
l


encoding composed            exists model l l
  plan m   
proof  see appendix a 
explain sequence events introduce negative cycle stn
causally valid plan used prevent similar negative cycles reoccurringp
future
plans produced problem hand  let p temporal planning problem 

set events p    e         en causally valid plan p  assume stn
representing scheduling function negative cycle n nodes xi         xim   note
xik node corresponding event eik   without loss generality  assume
i          im   i e   events negative cycle ordered order
started finished
  let oik set temporal actions p
 e action e  oik    eik   
reaching eik sequence ei         eim   p
ik  
consider regular language ln alphabet
defined ln   ei  i  ei     im eim  
ik denotes string symbols ik   fact  strings ln   events
already present current negative cycle inserted sequence
way temporal constraints among ei         eim remain unchanged  see
exclude events open actions ik   consider two hypothetical events eij eij
respectively starting event ending event action a  therefore 
temporal constraint scheduling function form  ij    ij     dur a  
here  insert another copy ending event two events 
ended execution eij and  result  eij longer pairing event
eij   mentioned constraint longer exist 
theorem     let n   xi         xim negative cycle stn corresponding
causally valid plan   e         en temporal problem p  xik node corresponding event eik   let another causally valid plan p  subsequence
member ln  defined above   corresponding stn n
negative cycle 
proof  see appendix a 
   

fiitsat  efficient sat based temporal planner

consrtucting fsm accepts ln straightforward  let fsm  theorem
   shows added encoding input problem  itsat still
capable finding valid temporal plan  provided plan exists 

   empirical results
section  show preprocessing  encoding  scheduling methods contribute overall performance itsat  since contribution preprocessing
part investigated encoding fixed  first analyze performance
three encodings explained section    compare performance itsat
several state of the art temporal planners non numerical temporal planning problems
previous international planning competitions 
section    theoretically showed novel relaxed  step encoding least
compact temporal versions  step  step encodings fixed ordering  i e  
number steps needed relaxed  step encoding solve given problem less
equal temporal versions  step  step encodings   here 
empirically show relaxed  step often needs significantly smaller number steps 
compared  step  step encodings  show mentioned compactness
causes relaxed  step significantly outperform  step  step encodings
benchmark problems terms memory speed 
section    explained two preprocessing methods  namely mutual exclusion analysis
action compression  section show methods contribute
overall performance itsat benchmark problems  purpose  compare
four versions itsat     itsat without preprocessing     itsat mutual exclusion
analysis     itsat action compression     itsat mutual exclusion
analysis action compression  experimental results show methods
separately enhance performance itsat 
section    discussed adding certain blocking clauses encoding
problem  one prevent negative cycles reoccurring stns produced
causally valid plans  introduced elaborate method preventing negative cycles  adding extra clauses based certain finite state machines 
here  empirically show fsm based method crucial efficiency itsat
problems required concurrency 
finally  compare performance itsat state of the art temporal planners  namely optic  coles et al          lpg td  gerevini et al         
tfd  eyerich et al          optic tfd different degrees temporal expressivity  whereas lpg td temporally expressive  i e   capable solving
problems required concurrency   show itsat significantly outperforms
optic tfd  competitive lpg td many domains 
    implementation details
order parse planning problems domain  validating output plans
produced itsat  used val  plan validation tool developed
organizers ipc       schematic operators given domain instantiated
objects input problem produce possible valid ground temporal actions  itsat
   

firankooh   ghassem sani

performs polynomial reachability analysis recognize actions prepositions
relevant given problem  purpose  goal conditions initially
assumed relevant propositions  action produces relevant proposition upon
starting ending considered relevant action  itsat adds preconditions
starting ending events relevant actions current set relevant propositions 
invariants relevant actions added set  too  updating sets relevant
propositions actions repeated changes occur sets 
update set relevant propositions omitting relevant propositions
present initial state given problem  omitted propositions
deleted relevant action  propositions omitted
at start  at end  invariants relevant actions  mutual exclusion analysis action
compression methods described section    performed sets relevant
actions propositions 
mentioned section    encoding methods assume exists
predefined fixed ordering events given problem  current implementation
itsat  ordering events produced constructing ground actions 
taken presumed fixed ordering events  starting event action
placed immediately corresponding ending event mentioned ordering 
elaborate heuristic methods producing ordering may result compact
encoding  rintanen et al          investigating methods beyond scope
paper left future research 
current version itsat  use p recosat  biere         free off theshelf system  sat solver  examined two sat solvers  namely
inisat  een   biere        lingeling  biere        satisfying formulae 
however  precosat best overall performance among three sat solvers  though
lingeling better performance terms memory usage 
since p recosat accepts formulae conjunctive normal form  cnf   formulae described throughout paper translated equivalent cnf formulae  performed simply using logical equivalence relations
                         
problem  start formula one step  set time limit
three minutes precosat find model formula  case failure 
add three steps formula repeat process either model
found predetermined maximum time    minutes reached  case success
finding model  causally valid plan extracted model  plan
given scheduling process find valid temporal plan  scheduling function
fails  appropriate fsm generated encoded problem formula  see section
   without increasing number steps  new formula given p recosat
find new model  although parallel solving formulae different number steps
shown effective nave sequential approach  rintanen et al        
streeter   smith         empirical results show even simple sequential method
sufficient outperform current temporal planners many planning domains  leave
investigation regarding effect using parallelism future research 
experiments explained section conducted    ghz corei 
cpu  gb main memory  benchmark problems  used problem
   

fiitsat  efficient sat based temporal planner

sets previous ipcs  problems different planning domains including
zenotravel  rovers  depots ipc       airport ipc       pegsol  crewplanning 
openstacks  elevators  sokoban  parcprinter ipc       driverlog  f loortile 
matchcellar  mapanalyser  parking  rtam  satellite  storage  turnandopen  tms
ipc       note domains used different ipcs 
domains  chosen problem set recent competition domains 
problem set ipc      present experiments 
among domains used previous ipcs  matchcellar  turnandopen  tms
include problems required concurrency  problem sets
temporally expressive planners capable producing valid plans  order achieve
better assessment itsat problems required concurrency  used two
extra domains driverlogshift matchlift  halsey         performed
experiments time window variants satellite airport domains  domains 
used ipc      required concurrency  referred throughout
section satellite tw airport tw  respectively  mentioned domains
required concurrency explained details section     
    impact different encoding methods
evaluate  step   step  relaxed  step encodings produced three different versions itsat  namely  itsat   itsat   itsat    respectively 
versions  formula mut   encodes mutex relations  added
encoding  none versions take advantage action compression  negative cycle
prevention method described section   used three versions itsat 
table   shows comparison domain among versions regard number
solved problems 
seen table    itsat  best performance among three
versions  fact  itsat  able solve    problems itsat  
    problems itsat   furthermore  almost problems solved itsat 
itsat  solved itsat    means relaxed  step encoding
significantly efficient temporal versions classical  step  step
encodings 
table    shows detailed comparison among mentioned encodings  different columns table   represent following items  name domain  problem
number  used encoding method  number steps encoding  result
p recosat terms satisfiability unsatisfiability formula  number clauses
variables divided       amount time taken p recosat determine
result  amount memory needed solving formula  problem
encoding method  results presented two cases  unsatisfiable formula
highest number steps  satisfiable formula lowest number steps  note
produce results  increased number steps one formula
unsatisfiable  symbol used time column cases p recosat
failed find model formula      seconds  results presented
domains least one problems solved least two
planners  accordingly  openstacks  elevators  matchcellar  rtam omitted
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift
total

problems
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   

itsat 
  
  
  
 
  
  
  
 
 
 
 
  
 
  
  
 
  
 
 
 
 
  
  
  
   

solved
itsat 
  
  
  
 
  
  
  
 
 
 
 
  
 
  
  
 
  
 
 
 
 
  
  
  
   

itsat 
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
  
 
 
 
 
  
  
  
   

table    overall comparison different encoding methods
table    moreover  satellite storage  results presented
 step  step encodings 
domain  table   presents results hardest problem  i e  
problem greatest number propositions   experiments  observed
pattern similar chosen problems problems domain  note
results presented table   finding first causally valid plan  therefore 
results include information regarding fsm encoding method described
section    explain impact fsm based negative cycle prevention later
section 

   

fiitsat  efficient sat based temporal planner

domain

zenotravel

rovers

depots

satellite tw

airport tw

airport

prob encoding steps

  

 

  

 

  

 

 

  

  

  

 

  

  

 

  

 

  

 

  

 


 

  

  

 

 

  

  


 

  

  

  

 

  

  


 

  

  
  

 

  

  


 
continued next page

result
f
f
f



f
f
f



f
f
f



f
f
f



f
f
f



f
f
f




   

c
    

v
    

   
   
  
   
   
  
    
    
   
    
    
   
    
    
    
    
    
    
  
  
 
  
  
 
    
    
   
    
    
   
    
    
   
    
    
   

   
  
  
   
  
  
   
   
  
   
   
  
    
   
   
    
   
   
 
 
 
  
 
 
    
   
  
    
   
  
    
   
  
    
   
  

time
 s 
  
   
    
  
    
    


    
  
  
    
   
   
    
   
 
   
   
   
   
   
   
   
  
   
    
  
   
   
  
   
    
  
   
    

mem
 mb 
   
  
  
   
  
  
   
   
  
   
   
  
   
   
   
    
   
   
 
 
 
 
 
 
   
   
  
   
   
  
   
   
  
   
   
  

firankooh   ghassem sani

domain

prob encoding steps

  

  

pegsol
  

 

  

  


 

  

  

crewplanning  

 

  

  

 

  

  

sokoban
 

 

  

  

 

  

  

parcprinter
  

 

  

  


 

 

driverlog
 

 

 

 

  

  

floortile
  

 

  

  

 

  

 

mapanalyser   

 
continued next page

result
f
f
f



f
f
f



f
f
f



f
f
f



f
f


f
f
f



f
f
f

   

c
    

v
    

  
  
  
  
  
  
   
   
 
   
   
 
   
   
   
   
   
   
    
    
   
    
    
   
    
    
    
    
   
  
  
   
  
  
      
      
     

 
 
 
  
 
 
  
  
 
  
  
 
   
  
  
   
  
  
   
   
  
   
   
  
   
   
   
   
  
  
 
  
  
 
    
   
   

time
 s 


    
    
   
   


 
  
  
 

  
   
  
  
   

  
   
  
  
   
   
  
  
    
  
 
    
  
    
    
  
  
   

mem
 mb 
  
  
 
  
  
 
  
  
 
  
  
 
   
  
  
   
   
  
   
   
  
   
   
  
   
  
   
   
  
  
 
  
  
 
    
   
  

fiitsat  efficient sat based temporal planner

time
domain
prob encoding steps result
 s 

  

           
  

  

          
  


 

     
   
   

 
f
    
   
   

 
f
   
  
   

parking
  

 
f
   
  
   

 

    
   
   

 

   
   
   


 

   
  
 

  
f
   
   


satellite
 

 
f
   
  


  

   
   
   

 

   
   
   

  
f
    
   


storage
 

 
f
   
  
  

  

    
   
   


 

   
  
   

  
f
    
   


  
f
   
   
  

turnandopen  

  
f
   
  
   

  

    
   
   

  

   
   
  

  

   
  
   

 
f
   
  
   

 
f
   
  
   

tms
  

 
f
  
  
   

  

   
  
   

 

   
  
   


 

   
  
   

  
f
   
  
   

  
f
   
  
 

driverlogshift   

 
f
  
  
 

  

   
  
   

  

   
  
   


  

  
  
   
table    detailed comparison encoding methods
c
    

   

v
    

mem
 mb 
    
   
   
   
  
  
   
  
  
   
  
   
  
   
  
   
  
   
   
  
   
   
  
  
  
  
  
  
  
  
  
 
  
  
 

firankooh   ghassem sani

figure     speed comparison itsat  itsat 

section    theoretically showed order solve given planning problem 
relaxed  step encoding requires fewer steps temporal versions classical
 step  step encodings ordering fixed  table   shows itsat 
often needs considerably smaller number steps  phenomenon prominent
airport  crewplanning  mapanalyser  moreover  openstacks matchcellar 
neither itsat  itsat  able solve problem due large number
steps required  suggests correlation performance
planner  compactness encoding  generally speaking  relatively
high number steps needed  step encoding solve problem  deduce
strong causal connection actions produced plan 
hand   step encoding devised take advantage causal connections 
therefore   step encoding expected advantage  step encoding
domains  phenomenon visible airport  crewplanning  openstacks 
matchcellar domains  numbers steps required  step encoding
domains exceptionally high  table   shows relaxed  step encoding results
significant improvement planner terms memory usage 
   

fiitsat  efficient sat based temporal planner

figure     speed comparison itsat  itsat 

compared speed itsat  itsat  itsat 
solving benchmark problems  results depicted figure    figure    
seen  itsat  outperformed itsat  itsat  almost
problems 
    impact mutual exclusion analysis action compression
section    explained mutual exclusion analysis action compression performed preprocessing components itsat  here  empirically show components quite effective enhancing performance planner  showed

before  encoding results best performance itsat  fixed
formula base comparison  produced three formulae investigate

impact preprocessing method  three formulae mut  the base encod
ing plus mutual exclusion information   com  the base encoding plus action

compression information   mut com  the base encoding plus mutual exclusion action compression information   table   shows number problems solved
mentioned versions itsat 
   

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandpen
tms
driverlogshift
matchlift
total

problems
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   




  
  
  
 
  
  
  
  
 
 
 
  
 
 
  
 
 
 
 
 
 
 
  
  
   



mut
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
  
 
 
 
 
  
  
  
   



com
  
  
  
 
  
  
  
  
 
 
 
  
 
  
  
  
 
 
 
 
 
  
  
  
   



mut com
  
  
  
 
  
  
  
  
  
 
 
  
 
  
  
  
  
 
  
  
 
  
  
  
   

table    impact mutual exclusion analysis action compression
seen table    preprocessing methods result significant improvement terms overall coverage  fact  version itsat uses methods
solves     problems base planner  besides  version uses methods even considerably outperforms two versions use one preprocessing
method  suggest preprocessing components necessary producing
best performance itsat 
investigate effectiveness action compression method domains
itsat compresses considerably actions crikey  performed another
experiment  compressed actions itsat considers compression safe
crikey  not  new version itsat  used mutual exclusion
information  version itsat solves six problems version
   

fiitsat  efficient sat based temporal planner

mutual exclusion information used  six problems  four problems
zenotravel  one airport  one mapanalyser  results change
much domains  note three mentioned domains itsat
compresses considerably actions crikey 
    impact fsm based negative cycle detection
mentioned earlier  among domains used evaluate itsat  matchcellar  turnandopen  tms  driverlogshift  matchlift  time window versions airport satellite
problems required concurrency  fact  domains  may impossible
schedule causally valid plan produced solving sat formula  valid temporal
plan  here  briefly explain problems domains may require concurrency  may introduce negative cycles stn associated
causally valid plan 
matchcellar matchlift  exists action lighting match  action
produces light certain amount time  objective mend fuses 
actions mending fuse executed light  result  actions
lighting match mending fuse must executed concurrent  however  causally
valid plan  since planner consider durations actions  may assume
match remain lit fuses mended  discussed section   
introduce negative cycle stn produced causally valid plan 
tms  objective produce certain number ceramic structures 
structures need several preparations done furnace producing
heat  clear domain similar matchcellar matchlift 
requires concurrency similar way 
simplified version driverlogshift introduced section    difference
simplified version one used section evaluate planners 
here  drivers walk to  board  disembark trucks  furthermore 
rest work actions performed drivers rather trucks  domain 
working shifts drivers analogous action lighting match
matchcellar domain 
turnandopen  exists robot needs move number rooms 
doors pair adjacent rooms  doors  closed
initial state  opened robot  robot open door
turning doorknob  domain  actions turning doorknob opening
door must executed concurrently  however  duration action turning
knob    whereas opening door    enables itsat schedule every
causally valid plan valid temporal plan  therefore  preventing negative cycles
necessary domain 
time window versions airport satellite  specific time
goals must obtained  deadline introduced problem using specific
frame action duration equal time deadline  actions
executed frame action executed  words  actions
must concurrent frame action  however  causally valid plan  since
planner consider durations actions  may assume frame action
   

firankooh   ghassem sani

domain
problem
satellite tw
 
airport tw
  
matchcellar
  
tms
  
driverlogshift
  
matchlift
  

restarts
   
 
  
 
  
 

c
    


  
   
  
   
  
  

fsm
    
 
   
  
   
   

v
    


 
  
  
  
  
  

fsm
   
 
   
  
   
   

memory  mb 

fsm
 
   
  
 
 
  
  
 
  
   
  
  

table    collective size sat encodings fsms
arbitrarily long  thereby neglect meet deadline achieving goals 
introduce negative cycles stns produced causally valid plans 
explained section    stn causally valid plan includes negative
cycle  must force sat solver find different solution  done simply
adding extra blocking clause current sat formula prevent least one
events negative cycle reoccurring current step  alternatively 
introduced elaborate method thing  adding encoding
certain fsms encoding  method  stn causally valid plan
k steps includes negative cycle  fsm detects negative cycle encoded
sat formula  solver restarted  order decrease number
restarts  whenever sequence events corresponding negative cycle found  itsat
tries find potential negative cycles replacing actions current sequence
actions problem checking stn resulting sequence negative
cycles 
table   shows collective size sat encodings fsms required solving
problems domains  base encoding  used relaxed
 step encoding mutual exclusion analysis action compression 
domain  results shown table   hardest problem solved itsat 
turnandopen domain excluded table    negative cycle encountered
solving problems domain  different columns table   represent
following items  name domain  problem number  number clauses
variables divided       amount memory needed produce formula 
results number causes  number variables  used memory presented
separated columns base encoding encoding fsms 
seen table    negative cycle prevention method helps itsat solve
considerable number problems required concurrency  nevertheless  sat encoding required fsms significantly larger base encoding domains
number restarts relatively high  hand  number
restarts increase  speed itsat declines  restart  sat
solver must verify satisfiability formula  scratch  fact  numerous
restarts main reason poor performance itsat time window version
satellite 
   

fiitsat  efficient sat based temporal planner

    itsat versus state of the art temporal planners
compare itsat three efficient temporal planners  namely  optic  benton 
coles    coles         tfd  eyerich et al          lpg td  gerevini et al         
similarities approach used itsat scp   lu
et al          included results planner experimental results 
optic newest version popf  coles et al          heuristic state space
temporal planner based so called temporally lifted progression planning  cushing
et al          using approach planning enables optic solve problems
required concurrency  besides  optic handles self overlapping actions  makes
expressive itsat  although handling self overlapping actions hardly necessary
solving non numerical temporal planning problems  fox   long         among
current benchmark domains  zenotravel  rovers  airport permit actions due
modeling errors  fair comparison itsat optic  used
corrected versions three domains  evaluations  guiding search  optic
benefits heuristic function based relaxed planning graph  hoffmann
  nebel        
tfd another heuristic state space temporal planner  tfd based so called
decision epoch planning  cushing et al          planners use approach
temporally expressive planners based temporally lifted progression planning  words  theory  temporal planning problems defined
pddl    solved itsat optic tfd  however  current benchmark problems potentially solved using decision epoch planning 
guiding search  tfd benefits temporal version so called context enhanced
additive heuristic  helmert   geffner        
lpg td fast temporal planner  temporally expressive  fact 
lpg td first generates sequential plan given problem  tries reschedule
plan produce one improved quality  renders lpg td incapable
solving problem matchcellar  turnandopen  tms  driverlogshift  matchlift  similar
optic  lpg td benefits heuristic based relaxed planning graph  however 
instead searching state space problem  lpg td performs search making
local improvements structure similar partial plans  called linear
action graph  two different configurations lpg td used based whether
prefer speed planner quality produced plans  here  present
results quality configuration lpg td  produced better results speed
configuration experiments 
scp   lu et al          sat based temporal planner uses discrete representation time  planner assigns explicit discrete time labels step encoding 
approach  step exactly one time unit ahead step      result 
action duration starts step i  forced end step   d  means
number layers required producing plan greater equal makespan
  spc  starts formula one step  increases number steps
one  every time formula unsatisfiable  enables spc  find optimal plan
   corrected version mentioned domains downloaded official website popf
planner 

   

firankooh   ghassem sani

number given problems  obtain better performance  scp  uses  step semantic
allow causal relations actions time point 
compared itsat planners based number problems
solve domain total score given planner using
scoring strategy recent ipcs  is  planner cannot solve problem  get
score   problem  otherwise  score equal makespan best
produced plan divided makespan plan found planner  results
presented table   
seen table    itsat significantly outperforms optic  tfd  scp  
fact  itsat solves     problems optic      problems tfd 
    problems scp   itsat solves    problems lpg td  however 
mainly lpg td incapable solving problems required concurrency 
exclude satellite tw  airport tw  matchcellar  turnandopen  tms  driverlogshift 
matchlift domains lpg td cannot solve problem  itsat solves
   problems less lpg td  shows itsat quite competitive
lpg td even solving problems without required concurrency 
shown table    optic solves zero problems parcprinter  driverlog  floortile 
mapanalyser  matchcellar  rtam  storage  tms  domains  main reason
poor performance optic runs memory  early search  tfd
solves zero problems satellite tw  airport tw  parcprinter  driverlog  floortile  rtam  storage 
tms  except parcprinter  tfd runs memory  domains
tfd performs poorly unable find plan within      seconds 
mentioned before  lpg td solves zero problems domains required concurrency 
performance scp  rather poor many benchmark domains  reason
poor performance scp  that  many benchmark problems  makespan
optimal plan relatively large  result  problems  scp  unable
check satisfiability formulae numbers steps less makespan
optimal plan  within      seconds time limit 
compare quality plans produced itsat competing
planners  consider table    numbers presented table   average makespan
ratio plans mutually solved corresponding planner itsat corresponding
domain  ratios less one indicate better average quality solutions produced
itsat comparison competing planners  cases neither itsat
competing planner able solve problem domain  corresponding
cell table   remained blank 
performed experiments based number two planners portfolios
different pairs planners  portfolios enabled us combine advantages
two planners  this     minutes time limit divided equally pair
planners  results running portfolios presented table    results
show best configuration obtained combining itsat lpg td 
resulting planner capable solving         benchmark problems  moreover 
planners produced best results combined itsat 

   

fiitsat  efficient sat based temporal planner

solved

domain

n

zenotravel

  

  

rovers

  

depots

itsat

optic

scp 

ipc

score

itsat

optic

tfd

lpg td

scp 

tfd

lpg td

  

  

  

 

     

     

     

     

 

  

  

  

  

 

     

     

     

     

 

  

  

 

 

  

 

    

    

    

     

 

satellite tw

  

 

 

 

 

 

 

 

 

 

 

airport tw

  

  

 

 

 

 

  

 

 

 

 

airport

  

  

  

  

  

 

    

     

     

     

 

pegsol

  

  

  

  

  

  

     

     

     

     

  

crewplanning

  

  

  

  

 

 

     

  

     

    

 

openstacks

  

  

  

  

  

 

    

     

     

     

 

elevators

  

 

 

 

 

 

 

 

 

    

 

sokoban

  

 

 

 

 

 

    

    

 

    

 

parcprinter

  

  

 

 

 

 

  

 

 

    

 

driverlog

  

 

 

 

  

 

    

 

 

     

 

floortile

  

  

 

 

  

  

     

 

 

     

  

mapanalyser

  

  

 

  

  

 

     

 

     

     

 

matchcellar

  

  

  

  

 

 

  

  

  

 

 

parking

  

  

  

  

  

 

    

     

     

     

 

rtam

  

 

 

 

  

 

 

 

 

  

 

satellite

  

  

 

  

  

 

    

    

    

  

 

storage

  

  

 

 

  

  

     

 

 

    

  

turnandopen

  

 

 

  

 

 

 

    

     

 

 

tms

  

  

 

 

 

 

  

 

 

 

 

driverlogshift

  

  

  

 

 

 

    

    

    

 

 

matchlift

  

  

  

  

 

  

  

  

  

 

  

total

       

   

   

   

  

                   

table    itsat versus state of the art temporal planners

   

         

firankooh   ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

optic

tfd

lpg td

scp 

    
    
    
 
 
    
    
    
    

    




 
    

    

    

    
 

    
    
    


    
    
    
    

    



    
    
    

    

    

    
 

    
    
    


    
    
    
    

    
    
    
    
    

    

    
    





 
    
    



    



 


    


    


    
 

    
 

table    average makespan ratio

itsat
optic
tfd
lpg td
scp 

itsat

   
   
   
   

optic
   

   
   
   

tfd
   
   

   
   

table      planners portfolio

   

lpg td
   
   
   
   

scp 
   
   
   
   


fiitsat  efficient sat based temporal planner

figure     speed comparison itsat optic

although itsat quite competitive state of the art temporal planners 
empirical results reveal drawbacks planner  compared speed
itsat optic  tfd  lpg td  scp  benchmark problems 
results presented figure     figure     figure     figure     respectively 
figures  results required concurrency domains separated
domains using different symbols scatterplots  star symbol
represents problems required concurrency  diamond symbol represents
problems  seen  itsat slower optic  tfd  lpg td
number benchmark problems  major cause drawback itsat 
sat solver spends much time refuting several formulae finally find
first satisfiable formula  shown case classical planning  speed
sat based planners significantly improved checking satisfiability several
formulae different number steps parallel  discuss detail section
  future research 
another observation that  itsat performs rather slowly solving number
problems required concurrency quickly solved optic tfd 
mainly due restarting sat solver whenever negative cycles encountered 
   

firankooh   ghassem sani

figure     speed comparison itsat tfd

explained earlier  stn causally valid plan k steps includes negative
cycle  fsm detecting negative cycle encoded sat formula 
solver try satisfy new formula k steps  scratch  domains
negative cycles abundant  performance itsat significantly affected
numerous restarts sat solver 
performance itsat particularly poor three domains  namely elevators 
driverlog  rtam  domains  number ground actions higher
domains  linear increase number ground actions may cause
exponential growth size search space problem  tackle problem 
state space based planners take advantage heuristic functions devised specially
pruning search space planning problems  shown using sat
solvers tailored solving planning problems result significant improvement
performance sat based classical planning  rintanen         think employing
idea improve speed itsat mentioned domains 
another drawback itsat poor quality produced plans benchmark
domains  notably  although itsat solves problems depots  openstacks 
parking  satellite  quality plans rather low domains  according
   

fiitsat  efficient sat based temporal planner

figure     speed comparison itsat lpg td

table    mainly due fact itsat abstracts duration actions 
thus  sat solver lacks competency evaluating quality plans
produced  nevertheless  quality plans produced itsat generally
comparable planners benchmark domains  section    explain
idea improving quality plans produced itsat 

   conclusions future research
paper  described itsat  temporally expressive sat based planner  itsat
based approach takes advantage parallel encodings  approach  first 
durations actions given problem abstracted out  abstract problem
encoded sat formula using  step  step semantics causally valid plans 
generating causally valid plan  itsat performs scheduling process 
process  itsat tries satisfy temporal constraints imposed considering
durations actions  done solving simple temporal problem  stp  
cases inconsistent stp  cause  negative cycle corresponding
simple temporal network  stn   detected  itsat adds certain clauses sat
formula hand prevent reoccurrence negative cycles  process
   

firankooh   ghassem sani

figure     speed comparison itsat scp 

repeated temporally valid plan produced  predefined time limit
reached 
main contributions paper summarized follows 
introduced novel method detect temporal actions compressed
classical ones  new compression technique performed preprocessing task
thus independent planning algorithm used
temporal planner  makes compression technique general
popf  specifically tailored planner  empirical results showed
action compression results improved performance itsat 
empirically showed method capable detecting compression safe
temporal actions previous action compression method  used popf 
introduced three new encoding methods based concept parallel plans
sat based temporal planning  two methods adopted
classical planning  third method  produces compact formulae 
employed itsat first time  empirical results show new
encoding significantly enhance performance sat based temporal planning 
   

fiitsat  efficient sat based temporal planner

introduced method avoid producing plans members given
regular language set events  done embedding sat
encoding particular fsm accepts language sat encoding
input problem  used method preventing temporal inconsistencies
produced causally valid plans reoccurring subsequent causally valid
plans  experiments showed method contributed considerably
performance itsat current benchmark problems required concurrency 
according empirical results  taking advantage new approaches 
itsat outperform state of the art temporally expressive planners 
competitive efficient temporal planners handle required concurrency  nevertheless  believe performance itsat improved several
ways  discussed below 
current version itsat  satisfiability formulae different number
steps checked sequential manner  starting formula encoding one step 
means sat solver refute several formulae finds first satisfiable
formula  time required checking satisfiability formulae increased
number steps  policy would result best performance itsat  however 
almost never case  shown case classical planning  fixed
planning problem  time needed finding model satisfiable formula usually
considerably less time needed refuting unsatisfiable formula  rintanen et al  
       based experiments  phenomenon happens case temporal
planning  too  similar sat based classical planning  one take advantage
phenomenon checking satisfiability formulae different numbers steps
parallel  applicability parallelisms sensistive amount
memory required saving formulae  shown section    newly
introduced  step encoding considerably efficient temporal version
classical  step encoding terms memory usage  suggests  step
encoding suitable employing parallelism 
linear sized classical  step  step encodings  encoding methods 
assume exists predefined fixed ordering events given problem 
ordering great impact number steps needed solving input
problem  example  consider sequential plan ground action applied
once  potential plan subsequence mentioned fixed ordering 
one step sufficient finding plan  hand  case reversed
fixed ordering  number steps would required find model might
large size plan itself  current implementation itsat  ordering
events produced constructing ground actions  taken predefined
fixed ordering events  however  considering causal relationships among actions
given problem  one might able find effective orderings would result
fewer steps solving problem  believe enhancement would result
improved version itsat  efficient terms speed
memory usage 
current version itsat uses off the shelf general purpose sat solvers 
means advancement designing solvers improve performance
itsat  recent investigations field sat based classical planning shown
   

firankooh   ghassem sani

designing sat solver tailored solving planning problems result much improved
performance sat based planners  particular  efficient sat based classical
planner  mp  rintanen         able competitive sate of the art
state space based planners employing idea  since causal structures temporal
planning problems generally similar classical planning problems 
believe itsat benefit enormously employing planning oriented sat solver 
mentioned section    one main drawbacks itsat poor quality
produced plans benchmark domains  mainly due fact
itsat abstracts duration actions  thus  sat solver
needed resources evaluating quality plans produced  alternatively  one add explicit representation time encoding  shin   davis 
       done using smt solvers  armando   giunchiglia         handle continuous variables  however  discussed section    solution may result
considerably slower search  think itsat benefit combination
two approaches  first plan produced itsat  proceed
introducing appropriate numerical constraint sat formula hand  use
smt solver produce improved plans  subject ongoing research 
finally  mention components itsat  used
fields ai planning  notably   step encoding employed
sat based classical planning  empirical results show encoding method
quite effective reducing number steps needed produce valid plans several
temporal planning domains classical version  think improved
performance  step encoding comparison  step encoding achieved
classical planning  too  moreover  section    showed prevent members
given regular language events input problem produced
output plan  used method prevent itsat producing temporally invalid
plans  method employed enforce variety constraints plan
produced  example  consider case require certain actions
executed specific order  must clear set plans violating
constraint regarded regular language set actions  therefore 
constraint introduced encoding problem method
discussed section   

acknowledgments
authors would thank handling editor  jorg hoffmann  anonymous
reviewers invaluable contributions quality paper 

appendix a  proofs
theorem    let p    i  g  a  temporal planning problem p c    state i   g  ac  
causal abstraction p  assume   he         en sequence events
applicable i  sn   succ i     following conditions must hold 
two propositions p q members state sn    p q non mutex
layer n planning graph p c  
   

fiitsat  efficient sat based temporal planner

proposition p member state sn    action member agenda sn   
p opena non mutex layer n planning graph p c  
proof  give proof induction n  the length    n      i e  
event applied i  conclusions obviously hold every member state i 
present first layer graph  mutex first layer 
agenda i    definition    suppose conclusions hold n   k    show
hold n   k  assume   he         ek sequence events
applicable i  sk   succ i     sk    succ i  he         ek  i  
let p q two members state sk    three possible cases 
case    p q members sk    induction hypothesis  p
q non mutex layer k   planning graph p c thus noopp noopq
non mutex layer k    hence  p q mutex layer k 
case    neither p q members state sk    definition    p q
must members add ek    assume ek ending event action
 the case ek starting event analogous thus omitted here  
since ek applicable state sk    definition    members pre ek   must
members state sk     must member agenda sk     therefore 
induction hypothesis  members pre ae   non mutex layer k   
result  p q  based definition    added ae   non mutex
layer k 
case    p member state sk     definition    q must member
add ek    p cannot member del ek    assume ek ending event
action  again  case ek starting event analogous thus
omitted here   induction hypothesis  members pre ae   non mutex
layer k    definition     ae delete p  therefore  ae present
layer k   cannot mutex noopp   result  p q non mutex
layer k 
let p member state sk    action member agenda sk   
two possible cases 
case    member agenda sk     started yet ended
reaching sk    invariants members state sk    
induction hypothesis  invariants must non mutex layer k    hence  ai
present layer k    definition     ai adds opena   now  must show p
added action mutex ai layer k    p member
state sk     induction hypothesis  p present layer k    therefore 
noopp   mutex ai   applicable layer k   and  result  p
opena mutex layer k  hand  p member
state sk     must added ek   since ek applicable sk  member
agenda sk     definition    ek cannot delete invariant a  assume ek
ending event action b  the case ek starting event b analogous
thus omitted here   induction hypothesis    mutex
   

firankooh   ghassem sani

ai must applicable layer k    means p opena mutex
layer k 
case    member agenda sk     definition    ek must
starting event a  delete p  moreover  definition    starting
invariants must present state sk     therefore  induction hypothesis 
applicable layer k    p present state sk     must added
ek   definition     propositions added starting event
added   since adds opena   p opena cannot mutex layer k 
hand  p member state sk     induction hypothesis 
p present layer k    therefore  noopp   mutex   applicable
layer k    means p opena mutex layer k 

theorem    let p    i  g  a  solvable temporal planning problem  let set
every member either compressible towards start compressible towards
end  compression safe p 
proof  let   causally valid plan p  such plan must exist p solvable  
starting     produce sequence causally valid plans swapping events
next plan hand  assume arbitrary order ha        
members   without loss generality  assume action repeated
   otherwise  different names given different occurrences action
eliminate repetition   producing causally valid plan   consider
causally valid plan i    ai compressible towards start  keep swapping ending
event ai previous event i  previous event becomes starting
event ai   fact  swaps collectively cause ai become compressed towards
start  swaps never falsify causally valid plan hand  assume
e event immediately prior ending event ai causally valid plan  e
starting event ai   precondition effect e must present
least one state whose agenda includes ai   thus  theorem    precondition
effect e mutex openai last layer levelled off planning graph
causal abstraction p  definition     e must swappable ending
event ai   therefore  causally valid plan starting ending events
ai located next other  similarly  ai compressible towards end  keep
swapping starting event ai next event i  next event becomes
ending event ai   result  n   ending event members located
next corresponding starting events  therefore  according definition    
compression safe p 
lemma    let    e         en   set events  e r  two subsets s  assume
subset ei e  ej
  r j   i  let
function defined following rules assigns value true f alse
sat variable chain e         en   e  r  k  m  
   

fiitsat  efficient sat based temporal planner

i   eki     true ei member  
i   bki m     true ej e j   i 
satisfies chain e         en   e  r  k  m  
proof  show satisfies formulae  c     c     therefore satisfies
chain e         en   e  r  k  m  
 
 c    consider arbitrary formula eki bkj m formula  c     ei
 eki     f alse  thus formula trivially satisfied  consider case
ei   definition formula  c     know   j ei e 
therefore  according definition   must  bkj m     true  thus
formula satisfied 
 c    consider arbitrary formula bki m bkj m formula  c      bki m    
f alse  formula trivially satisfied  hand   bki m     true 
must exist l  l   el e  since   j  must
l   j  therefore   bkj m     true  hence formula satisfied 
 c    consider arbitrary formula bki m eki formula  c      bki m    
f alse  formula trivially satisfied  hand   bki m     true 
must exist l  l   el e  according
properties   must ei
  r  however  definition
chain e         en   e  r  t  m   ei r and  result  ei
    therefore 
k
 ei     f alse formula satisfied 

lemma    let    e         en   set events  e r two subsets s  assume
model chain e         en   e  r  k  m   ei e  eki     true 
j   ej r   bkj m     true  consequently  ekj     f alse 
proof  suppose sequence e         en   event ej first event ei
ej r  since formula  c    chain e         en   e  r  k  m   eki bkj m  
 bkj m     true  similarly  sequence e         en   event ej first event ej
ej r  must formula bkj m bkj  m  c     implies
 bkj  m     true  repeating argument latter case  infer
j   ej r   bkj m     true  according  c    
 ekj     f alse 
theorem    completeness temporal  step encoding   let p    i  g  a 
solvable temporal planning problem   e         en   set events p   
hstep         stepl causally valid  step plan p  exists model l
  plan m   
   

firankooh   ghassem sani

proof  construct function assigns true f alse sat variables
formula l   let hs         sl state transition sequence   defined
following rules 
proposition p  k   k l   pk     true iff p
member state sk   
action a  k   k l   ak     true iff member
agenda sk   
  n  k   k l   eki     true
iff ei member stepk   moreover  k   k l   ek     
 ekn       f alse 
proposition p    n      k   k l 
 bki mp     true iff exists event ej   j   i  ej ep   ej stepk  
 

proposition p    n      k   k l 
 bki mp     true iff exists event ej   j   i  ej ep   ej stepk  
 

show satisfies formulae             therefore model l   note
way constructed  directly   plan m   
     according definition     s    i  thus formula      clearly satisfied 
     according definition     g state sl    thus formula      clearly
satisfied 
     according definition    agenda i      thus formula      clearly
satisfied 
     according definition     agenda sl       thus formula      clearly
satisfied 
     let p arbitrary proposition  e event e rp   e
  stepk  
 ek     f alse and  therefore  formula      trivially satisfied  consider
case e stepk   according definition     stepk must  step sk 
sk   thus  definition     possible ordering events stepk  
must able execute events according ordering  starting state
sk    one possible ordering specific ordering puts e front
events  therefore  e must applicable sk    then  definition   
p state sk     implies  pk      true  satisfaction
formula      easily follows 
  stepk  
     let p arbitrary proposition  e event e ep    e
 ek     f alse and  therefore  formula      trivially satisfied  consider
case e stepk   similar previous case  starting state sk   
must able execute events stepk possible ordering reach sk  
   

fiitsat  efficient sat based temporal planner

one possible ordering one puts e events  therefore  addeffects e must members state sj    definition    p state sk   
implies  pk     true  satisfaction formula      easily
follows 
  stepk
     let p arbitrary proposition  e event e ep   e
k
 e     f alse and  therefore  formula      trivially satisfied  otherwise 
argument given case       p
  state sk    satisfaction
formula      easily follows 
     let p arbitrary proposition  consider nontrivial case p member
state sk   state sk     easily derived definition    p
added application sequence events  least one events
must add p  implies satisfaction formula      
     case analogous case     
      lemma   used prove satisfies chain e         en     ep   rp  en      k  mp    
straightforward see properties model lemma
   need show proposition p  provided ei stepk ep
j   i  ej
  stepk rp   suppose ej stepk   definition    
possible ordering events stepk   must able execute events
according ordering  starting state sk    one possible ordering
one puts ei immediately ej   notice ei deletes p 
ei ep   thus  ej cannot p precondition  ej
  rp   infer
ej
  stepk rp   therefore  lemma    satisfies chain e         en     ep   rp
 en      k  mp     now  show satisfies bkn   mp ak   consider
 

nontrivial case   bkn   mp     true  based way construct  
 
least one e         en   say ej   must delete p  again  since stepk  step sk 
sk   must able execute events stepk possible ordering
reach sk   consider specific ordering puts ej events  now 
agenda sk    according definition    ej cannot ending event a 
therefore  definition    member agenda state
ej applied  clearly contradicts applicability ej   ej deletes p 
invariant a  therefore   ak     f alse  implies satisfies
bkn   mp ak  
 

      case  too  lemma   used prove satisfies chain en        e    ep   rp
 e     k  mp     similar previous case  straightforward confirm
properties lemma    since ordering chain e         en     ep   rp
 en      k  mp    reversed chain en        e    ep   rp  e     k  mp     need show
proposition p  provided ei stepk ep j   i  ej
 
stepk rp   suppose ej stepk   definition     possible ordering
events stepk   must able execute events according
ordering  starting state sk    one possible ordering one
puts ei immediately ej   argument one given case
   

firankooh   ghassem sani

       infer ej
  stepk rp and  therefore  lemma    satisfies
chain en        e    ep   rp  e     k  mp     now  show satisfies bk  mp
 

ak    consider nontrivial case   bk  mp     true  based way
 
construct   least one e         en   say ej   must delete p  again  stepk
 step sk  sk   starting state sk    must able execute
events stepk possible ordering  consider specific ordering puts ej
events  definition    since ej deletes p  invariant
a  cannot member agenda sk     therefore   ak     f alse  implies
satisfies bk  mp ak   
 

      assume e starting event action a  stepk  step sk 
sk   starting state sk    must able execute events stepk
possible ordering  consider specific ordering puts e
events  therefore  e must applicable sk    then  definition    cannot
member agenda sk     thus  ak      f alse  see  ak     true 
consider specific ordering events puts e events  events
executed ordering  results applying e appear state sk  
thus must member agenda sk    hence  satisfies ek ak  ak  
      analogous case        assume e ending event action a  since stepk
 step sk  sk   starting state sk    must able execute
events stepk possible ordering  consider specific ordering puts e
events  therefore  e must applicable sk    then  definition
   must member agenda sk     thus  ak      true  see
 ak     f alse  consider specific ordering events puts e
events  events executed ordering  results applying e
appear state sk   thus cannot member agenda sk    conclude
satisfies ek ak  ak  

theorem    soundness  step encoding   let p    i  g  a  temporal planning
problem   e         en   set events p  l  step encoding p 
l model   plan m   causally valid  step plan p 
proof  obtain plan m   follows  k   k l  let stepk
set events e  ek     true  k   k l  let
sk temporal state  assume state sk   set propositions p
 pk     true  agenda sk   set actions  ak     true 
show   plan m     hstep         stepl causally valid  step plan p
state transition sequence hs         sl i 
formula       immediately follows   state s     formula      implies
g state sl    formulae           respectively imply agenda s   
agenda sn   empty sets  now  need show k   k l 
stepk    e         em    e         en    step sk  sk   first show
   

fiitsat  efficient sat based temporal planner

proposition p  stepk cannot include two different events ei ej ei rp  
ej ep   j   i  since satisfies formula        lemma    infer  eki  
 ekj   cannot equal true  hand    j  since satisfies formula
       lemma    infer  eki    ekj   cannot equal true 
thus  ei ej cannot members stepk   let            m           m 
arbitrary ordering function  show induction k   k m  sequence
heo           eo k   applicable sk    k      i e   case event
applied sk     conclusion trivially holds  induction hypothesis  let sk
temporal state resulting applying sequence heo           eo k   sk    let eo k    
starting event action  we omit similar case eo k     ending
event a   show conditions         definition   hold thereby eo k    
applicable sk   result  heo           eo k     applicable sk   
    formula       easily follows preconditions eo k     invariants  except invariants added eo k       members
state sk     mentioned above  neither propositions deleted
another member stepk   thus  propositions members state sk   
    formula       easily follows member agenda sk     notice
according definition    starting event a  i e   eo k       event
add agenda state  therefore  cannot member agenda sk   
either 
    let action invariant p p del eo k        clearly
start a   rp   thus  argued above  start a   eo k    cannot
members stepk   hence  start a  
  stepk   hand  since p deleted
step k  satisfies chain en        e    ep   rp  e     k  mp     according lemma   
have   b  mp      true  therefore  formula        infer  ak     
f alse  thus 
  agenda sk     start a  
  stepk
  agenda sk    jointly


imply
  agenda sk   
show sm   result applying heo           eo m  sk    equal
sk  
let p arbitrary member state sm    formulae           follows
p deleted member stepk   cannot added member
   therefore  p deleted
stepk thus  p cannot member

wof state s
k
member stepk   formula eep e satisfied   besides  p
added member stepk   must member state sk     thus
 pk      true  now  formula       infer  pk     true  hence
p state sk    hand  p added member stepk   formula
      deduce  pk     true  p state sk    therefore 
state sm   state sk   
let p arbitrary member state sk    according formula       p cannot
deleted member stepk   besides  formula       p either member
   

firankooh   ghassem sani

state sk    added member stepk   cases  definition   implies
p state sm    therefore  state sk   state sm   
let arbitrary member agenda sm    formulae             
follows starting ending events single action members
stepk   agenda sk     still open state sm   infer
end a 
  stepk   therefore  according formula         ak     true  must
member agenda sk    hand 
  agenda sk     start a 
must member stepk   then  formula        have   ak     true 
again  must member agenda sk    therefore  agenda sm   agenda sk   
let arbitrary member agenda sk    according formula        start a 
cannot member stepk   besides  formula        either member
agenda sk    start a  member stepk   cases  definition   implies
agenda sm    therefore  agenda sk   agenda sm   
argument shows state sk     state sm   agenda sk     agenda sm    hence 
sk   sm   succ sk    heo           eo m  i   therefore  stepk  step sk  sk  
theorem    completeness  step encoding   let p    i  g  a  solvable temporal planning problem   e         en   set events p    hstep         stepl
causally valid  step plan p  exists model l   plan m   
proof  theorem    exists model l   plan m    show
translated model l   since formulae          shared
l l   satisfies formulae  show satisfies
formulae              therefore translated model l  
following cases  arbitrary temporal action  ei starting event a  ej
ending event a 
       eki     f alse  formula       trivially satisfied   eki     true 
formula       have   ak      f alse  therefore formula       satisfied 
       eki     f alse  formula       trivially satisfied   eki     true 
formula       have   ak     true  therefore formula       satisfied 
       ekj     f alse  formula       trivially satisfied   ekj     true 
formula       have   ak     f alse  therefore formula       satisfied 
       ekj     f alse  formula       trivially satisfied   ekj     true 
formula       have   ak      true  therefore formula       satisfied 
      exactly case       
      exactly case       
      exactly case       
      exactly case       
   

fiitsat  efficient sat based temporal planner

      follows immediately fact satisfies formula       
      follows immediately fact satisfies formula       

theorem    soundness  step encoding   let p    i  g  a  temporal planning
problem   e         en   set events p  l  step encoding p 
l model   plan m   causally valid  step plan p 
proof  obtain plan m   follows  k   k l  let stepk
set events e  ek     true  moreover  k
  k l  let sk temporal state  assume state sk   set propositions p
 pk     true agenda sk   set actions  ak     true 
construct   plan m     hstep         stepl show causally valid  step
plan p state transition sequence hs         sl i 
formula       immediately follows   state s     formula      implies
g state sl    formulae           imply agenda s    agenda sn  
empty sets  now  need show k   k l 
stepk    e         em    e         en    step sk  sk   without loss generality 
assume sequence he         em ordered fixed ordering he         en i  note
since satisfies formula        lemma    proposition p  stepk cannot include
two events ei ej ei rp   ej ep   j   i  induction k   show
every k m  sequence he         ek applicable sk    k      i e  
case event applied sk     conclusion obviously holds  induction
hypothesis  let sk temporal state resulting applying sequence he         ek
sk    assume ek    starting event action  we omit similar case
ek    ending event a   show conditions         definition  
hold thereby ek    applicable sk  
    formula       clearly results preconditions ek    invariants
 except invariants added eo k       members state sk    
stated before  neither propositions deleted ei   k   thus 
propositions members state sk   
    two possible cases  consider first case  according fixed
ordering he         en i  ending event located ek      formula       implies
cannot member agenda sk     notice according definition   
starting event a  i e   ek      event add agenda
state  therefore  cannot member agenda sk    case 
ending event located ek      formula       implies either
member agenda sk     end a  member stepk   however  end a 
member stepk   certainly remove agenda resulting state  since
ek    event add agenda state  conclude
cannot member agenda sk    therefore  neither two cases 
member agenda sk   
   

firankooh   ghassem sani

    let action p del ek      invariant  since p deleted step k 
satisfies chain e         en   ep   rp  en      k  mp     according lemma   
 bn   np      true  therefore  formula       
  agenda sk   
hand  clearly end a   rp   thus  argued before  end a  
member stepk   cannot located ek    fixed ordering he         en i 
hence  member agenda sk    cannot member agenda sk   
either  therefore  infer
  agenda sk   
show sm   result applying he         em sk    equal sk  
argument given proof theorem    state sm   state sk  
state sk   state sm    hence  state sm     state sk   
let arbitrary member agenda sm    let ei ej starting ending
events a  respectively  three possible cases  consider first case
agenda sk     ei
  stepk   ej
  stepk  i e   open immediately step
k neither started ended step k   case  since satisfies       
 ak     true  therefore  agenda sk    consider second case
agenda sk     ei stepk   ej stepk   j    i e   open immediately
step k  first ended started step k   case  since
satisfies formula         ak     true  therefore  agenda sk   
finally  consider third case
  agenda sk     ei stepk   ej
  stepk
 i e   open immediately step k  started ended
step k   case  j   i  must satisfy formula      
 ak     true  hand    j  must satisfy formula       and 
since  ekj     f alse  must  ak     true  therefore  agenda sk   
consequently  three cases  must member agenda sk    hence
agenda sm   agenda sk   
let arbitrary member agenda sk    i e    ak     true  two
possible cases  case    member agenda sk     hence  ak     
f alse  formula        have   eki     true  means started
step k  now  j   i  ending event cannot happen starting event 
therefore  must remain open execution step k  i e   agenda sm   
hand    j  formula       have   ekj     f alse 
means started ended step k  therefore must remain open
execution step k  i e   agenda sm    consider case   
member agenda sk     hence  ak      true    j  formula      
 eki     f alse  formula        ekj     f alse  means
open immediately execution step k  neither started
ended step k  therefore  must open execution step k  i e  
agenda sm    hand  j   i  since  ak    ak   
false  formulae             combined form formula  eki ekj   
means ended step k later started
step  therefore  must open execution step k 
agenda sm    therefore  agenda sk   agenda sm   
   

fiitsat  efficient sat based temporal planner

arguments show state sk     state sm   agenda sk     agenda sm    hence 
sk   sm   succ sk    he         em i   therefore  ordering functions            m 
         m   o i    i  sk   succ sk    heo           eo m  i   thus stepk
 step sk  sk  
lemma    let model chain  e         en   ep    ep   rp   k  mp    ej member
rp   epm    e e ep  ep    ek     true   following properties 
exists event ei ei epm   j   bkj mp      pk    
exists event ei ei ep      j   ei          ej    epm    
 eki     true   bkj mp     true 
exists event ei ei ep     j   ei          ej    epm    
 eki     true   bkj mp     f alse 
proof 
assume exists event ei ei epm   j  consider
case  pk      true  let  ei         eim   set events ei
ei rp ep  ep     j  without loss generality 
assume     i    i          im   j  since must satisfy  c      know
 bki  m     true  assume arbitrary s   bkis  mp     true  eis ep  ep  
 

p

know  ekis     f alse   c      bki


s    mp

hand  eis

rp ep  ep  



 c     



 bki  m  
p
s  

    true 

  true  infer

  j   bkis  mp     true  thereby  bkj mp      pk    
proof case  pk      f alse analogous  except
instead  c      need use  c      
assume exists event ei ei ep      j   ei          ej   
epm      eki     true  let  ei         eim   set events ei
ei rp ep  ep   j  without loss generality  assume  
i    i          im   j  since must satisfy  c      know  bki  m     true 
 

p

assume arbitrary     bkis  mp     true  eis ep  ep  
know  ekis     f alse   c       bki
hand  eis rp

ep 



    true 
s    mp
k

 bi  m     true  infer
p
s  
k
 bis  mp     true  thereby  bkj mp     true 

ep  

  j 

 c     

assume exists event ei ei ep     j   ei          ej   
epm      eki     true  let  ei         eim   set events ei
ei rp ep  ep   j  without loss generality  assume  
   

firankooh   ghassem sani

i    i          im   j  since must satisfy  c      know  bki  m     f alse 
 

p

assume arbitrary     bkis  mp     f alse  eis ep  ep  
know  ekis     f alse   c       bki
hand  eis rp

ep 



    f alse 
s    mp
k

 bi  m     f alse  infer
p
s  
k
 bis  mp     f alse  thereby  bkj mp     f alse 

ep  

  j 

 c     


lemma    let model chain e         en     ep   rp   k  mof
p    assume ei ep  
 eki     true  p inv a   let ej ej   starting event ending event
a  respectively  following properties 

 ekj       true    j   ekj     true 
 ak     true   ekj     true 
proof  let  ei         eim   equal set  es  es op     n       without loss
generality  assume i    i          im   n      since  eki     true 
 cof      infer  bi   mof     true  s   bis  mof     true 
p

p

 cof      deduce  bis    mof     true  therefore   bn   mof     true 
p
p
furthermore    j  ej    ei         eim    thus  bj   mof     true  besides 
p

 ekj       true   cof       ekj     true  hand   ak    
true  infer formula  cof      ekj     true 

lemma    let model chain e         en   ep   rp   k  mob
p    assume ei ep  
 eki     true  p inv a   let ej ej   starting event ending event
a  respectively  following properties 

 ekj     true  j       i   ekj       true 
 ak      true   ekj       true 
proof  proof analogous lemma    thus omitted 
theorem    completeness relaxed  step encoding   let p    i  g  a 

temporal planning problem formulae l l two  step encodings

p explained section    model l   l model
plan m     plan m   
proof  let model l   construct function assign value true

f alse binary variable l   using following rules 
 r      n   k l   eki      eki   
   

fiitsat  efficient sat based temporal planner

 r      k l   ek       ekn       f alse 
 r      k l proposition p   pk      pk   
 r      k l action a   ak      ak   
 r      n        k l  proposition p  exist j  
 ekj     true ej ep  ep  bki mp      pk    otherwise   bki mp    
 pk    
 r      n        k l  proposition p  exist j  
 ekj     true ej ep  bk     true  otherwise   bk     f alse 
i mp

i mp

 r      n    k l  proposition p  exist j  
 ekj     true ej ep  bki mob     true  otherwise   bki mob     f alse 
p

p

show satisfies formulae               therefore model

l   rules  clear plan m     plan m   
      formula       exactly       besides  assign
value variable formula 
      formula       exactly       besides  assign
value variable formula 
      formula       exactly       besides  assign
value variable formula 
      formula       exactly       besides  assign
value variable formula 
      formula       conjunction formulae  c      c      show
satisfies formulae  c      c      thereby  satisfies       
consider arbitrary formula eki bkj mp  c       eki     f alse 
formula trivially satisfied   eki     true   r    
 bki mp      pk    hand  satisfies      
 pk     true  therefore   bki mp     true  formula satisfied again 
consider arbitrary formula eki bkj mp  c       eki     f alse 
formula trivially satisfied   eki     true   r    
 bki mp      pk    hand  satisfies      
 pk     f alse  therefore   bki mp     f alse  formula satisfied
again 
consider arbitrary formula bki mp bkj mp  c      since ei
member ep  ep   none events located ei ej
fixed ordering members ep  ep    r     easily show
 bki mp      bkj mp    thus  formula satisfied 
   

firankooh   ghassem sani

consider arbitrary formula bki mp eki bkj mp  c       eki    
true  formula trivially satisfied   eki     f alse  since none
events located ei ej fixed ordering members
ep  ep    r     easily show  bki mp      bkj mp    thus 
formula satisfied 
consider arbitrary formula bki mp eki bkj mp  c     
argument one given  c      infer  bki mp      bkj mp   
thus  formula satisfied 
consider arbitrary formula bki mp eki  c       bki mp     true 
formula trivially satisfied   bki mp     f alse  exist two
possible cases  case    exists event ej j   i   ekj     true 
ej ep  ep   case   r      pk      bki mp     f alse 
since must satisfy       ej
  ep    thus ej ep   besides 
must satisfy        implies  eki     f alse   r    
 eki      eki     f alse  therefore  formula satisfied  case   
exist event ej j   i   ekj     true  ej ep  ep  
case   r      pk       bki mp     f alse  now  since
must satisfy       infer  eki     f alse   r    
 eki      eki     f alse  therefore  formula satisfied again 
consider formula bk  mp pk   c       r     easily deducted  bk  mp   always equal  pk      r    
 pk       pk     result   bk  mp      pk     formula
satisfied 
consider formula bkn   mp pk  c      two possible cases 
case    exists event e  ek     true  e ep  ep  
case   r      bn   mp      pk    now   r    
 pk      pk    therefore   bn   mp      pk    formula
satisfied  case    exist event e  ek     true
e ep  ep   case   r      bn   mp      pk     besides 
since satisfies formulae      right hand side      becomes f alse 
left hand side       i e   pk  pk   f alse  too  thus 
 pk      f alse   pk     f alse  similar argument
     show  pk      true   pk     true  thus 
 pk       pk     r      pk      pk     therefore 
 bn   mp      pk       pk    formula satisfied again 
      show satisfies formulae  cof      cof      thereby  satisfies
      
consider arbitrary formula eki bk

j mof
p

 cof      know  cof  

     j   eki     f alse  formula trivially satisfied   eki    
true   r      bj mof     true  formula satisfied 
p

   

fiitsat  efficient sat based temporal planner

consider arbitrary formula bk

i mof
p

 cof       bk

bk

j mof
p

i mof
p

  f alse  formula trivially satisfied   bk

i mof
p

 

    true  rule



 r     must exist event ei  
  i   eki     true 
ei ep   since   j  must   j  now   r    
 bj mof     true  formula satisfied 
p

consider arbitrary formula bk

j mof
p

ekj eki  cof       bk

j mof
p

f alse  formula trivially satisfied   bk

j mof
p

  

    true   r    

must exist event ej j   j   ekj     true  ej ep   now 
since satisfies        infer  ekj     f alse   r    
 ekj      ekj     f alse  therefore  formula satisfied 
consider arbitrary formula bk

n   mof
p

ak eki  cof       bk

n   mof
p

  f alse  formula trivially satisfied   bk

 

    true   r    

n   mof
p
k
event ej  ej     true ej ep   now 
       infer  ak     f alse   r    

must exist
since satisfies
 ak      ak     f alse  therefore  formula satisfied 

      show satisfies formulae  cob      cof      thereby  satisfies
      
consider arbitrary formula eki bkj mob  cob      know  cob    
p

j   i   eki     f alse  formula trivially satisfied   eki    
true   r      bj mob
    true  formula satisfied 
p
consider arbitrary formula bki mob bkj mob  cob       bki mob    
p

p

p

f alse  formula trivially satisfied   bki mob     true  rule  r    
p

must exist event ei      eki     true  ei ep  
since j   i  must j     now   r    
    true  formula satisfied 
 bj mob
p
consider arbitrary formula bki mob eki ekj  cob       bki mob    
p

p

f alse  eki     f alse  formula trivially satisfied   bki mob     true
p

 eki     true   r     must exist event ei      
 eki     true  ei ep   since satisfies        infer
 ak     f alse  however  know   j     j  thus must satisfy       therefore   ekj     true   r      ekj      ekj    
true  therefore  formula satisfied 
consider arbitrary formula bk  mob ak  ekj  cob       bk  mob    
p

p

f alse  ak      f alse  formula trivially satisfied   bk  mob    
p

true  ak      true   r     must exist event ei
 eki     true  ei ep   since satisfies        infer
 ak     f alse  however  must satisfy        therefore   ekj    
   

firankooh   ghassem sani

true   r      ekj      ekj     true  therefore  formula
satisfied 
      consider arbitrary formula eki ak         let ej ending event
a  know   j     j  therefore  must satisfy             
exactly        besides  assign value
variable formulae  thus        satisfied  
      consider arbitrary formula eki ak ekj        know   j     j 
therefore  must satisfy formula              exactly       
besides  assign value variable formulae  thus 
      satisfied  
       consider arbitrary formula ekj ak         let ei starting event
a  know   j     j  therefore  must satisfy              
exactly        besides  assign value
variable formulae  thus        satisfied  
       consider arbitrary formula ekj ak  eki         know  
j     j  therefore  must satisfy               exactly       
besides  assign value variable formulae  thus 
       satisfied  
              exactly        besides  assign value
variable formulae  thus         satisfied  
              exactly        besides  assign value
variable formulae  thus         satisfied  

theorem    soundness relaxed  step encoding   let p    i  g  a 

temporal planning problem   e         en   set events p  l relaxed

 step encoding p  l model   plan m   causally valid  step plan
p 
proof  obtain plan m   follows  k   k l  let stepk
set events e  ek     true  k   k l 
let sk temporal state  assume state sk   set propositions p
 pk     true  agenda sk   set actions  ak     true 
construct   plan m     hstep         stepl show causally valid  step plan
p state transition sequence hs         sl i 
       immediately follows   state s     also        implies g
state sl    besides              imply agenda s    agenda sn   empty sets 
respectively  need show k   k l  stepk  
 ei         eim    e         en    step sk  sk   without loss generality 
   

fiitsat  efficient sat based temporal planner

assume sequence hei         eim ordered according fixed ordering he         en i 
i e   i    i          im  
induction k   conclude k m  sequence hei         eik
applicable sk    k      i e   case  event applied sk     conclusion obviously holds  let sk temporal state resulting applying hei         eik
sk    assume eik    starting event action a  omit similar case
eik    ending event a  show conditions         definition  
holds thereby eik    applicable sk  
    assume p
  state sk    p either precondition eik    invariant
added eik      two possible cases  case    p
member state sk     added deleted member  ei         eik   
case   pk      f alse  moreover  exists event ei
ei ep  ep     k       eki     true  case    p deleted event
ei stepk added deleted event ej stepk     j k  
case  ei ep     ik       ei          eik      epm      eki     true 
epm    e e ep  ep    ek     true   cases  lemma   
 bkik     mp     f alse  contradicts fact satisfies  c     
    since satisfies        member agenda sk     however  eik   
event stepk add agenda state  thus  member
agenda sk   
    let b action a  invariant p del eik       let ej ej  
starting ending events b  respectively  mentioned earlier  assume
ending event action located immediately starting event
fixed ordering  show b cannot member agenda sk   
two possible cases b may member agenda sk    case    b open
action immediately execution stepk   b ended stepk
eik    executed  case   bk      true   ekik        true  since
satisfies        lemma     ekj       true  assumed b
ended execution eik      ik      j      hand 
since ej starting event b  ik       j  thus  ik      j  therefore 
lemma     ekj     true  contradicts fact satisfies       
 bk      true   ekj     true  ej   start b   case    b
started step k  ended step k execution eik     
case   ekj     true   ekj       f alse  j       ik       ekik        true 
since satisfies        lemma    must  ekj       true 
contradiction 
show sm   result applying hei         eim sk    equal sk  
let p arbitrary proposition  p state sm    two possible cases 
case    p member state sk     added deleted member
 ei         eim    case   pk      true  moreover  exists event ei
ei ep  ep     n       eki     true  case    p added event
   

firankooh   ghassem sani

ei stepk added deleted event ej stepk     n     
case  ei ep      n       ei          en   epm      eki     true 
epm    e e ep  ep    ek     true   cases  lemma   
 bkn   mp     true  since satisfies  c       pk     true  thus
p state sk    therefore  state sm   state sk   
let p arbitrary proposition  p
  state sm    two possible cases  case
   p member state sk     added deleted member
 ei         eim    case   pk      f alse  moreover  exists event
ei ei ep  ep     n       eki     true  case    p deleted
event ei stepk added deleted event ej stepk  
  j   n      case  ei ep     n       ei          en   epm    
 eki     true  epm    e e ep  ep    ek     true   cases  lemma
    bkn   mp     f alse  since satisfies  c       pk     f alse 
thus p
  state sk    therefore  state sk   state sm   
let arbitrary action  ei ej starting event ending event 
respectively  agenda sm    since assume ending event action
located immediately starting event fixed ordering  two
possible cases  case    open immediately step k  ended
step k  case   ak      true  ekj     f alse  since satisfies
        must  ak     true  therefore  agenda sk    case    started
ended step k  case   eki     true  ekj     f alse 
satisfies        must  ak     true  therefore  agenda sk    since
cases  agenda sk    infer agenda sm   agenda sk   
let arbitrary action  ei ej starting event ending event a 
respectively 
  agenda sm    since assume ending event action
located immediately starting event fixed ordering  two
possible cases  case    open immediately execution step k 
started step k  case   ak      f alse  eki     f alse 
since satisfies         must  ak     f alse  therefore 
  agenda sk   
k
case    ended step k  case   ej     true  since satisfies
        must  ak     f alse  therefore 
  agenda sk   
cases 
  agenda sk    infer agenda sk   agenda sm   
arguments show state sk     state sm   agenda sk     agenda sm   
hence  sk   sm sk   succ sk    hei         eim i   therefore  ordering functions            m           m   o i    i  sk   succ sk    heo i           eo im   i  
thus stepk  step sk  sk  

theorem    let p    i  g  a  temporal planning problem    he         en
causally valid plan p             n  q relaxed scheduling function  
exists valid temporal plan p 
   

fiitsat  efficient sat based temporal planner

proof  using bubble sort algorithm  sort events increasing order
according values given   algorithm takes two consecutive members
sequence  swaps value first one greater
second one  continues swaps whole sequence properly sorted  let ei
ej two events swapped bubble sort stage algorithm  assume
ei located ej sequence prior swapping   then  must  i     j  
thus  according  s     know ei ej swappable  c f   definition     
result  whole sequence causally valid plan prior swapping  would
causally valid plan swapping  means sorting according values
given result another causally valid plan  say   plan obviously satisfies
two conditions definition    therefore        valid temporal plan p 

theorem     let p    i  g  a  solvable temporal planning problem  com
set every member either compressible towards start compressible
towards end  definition      exists valid temporal plan      p
causally valid plan p  compressed respect com  relaxed
scheduling function  
proof  let     e         ei   ei          en causally valid plan p ei ei  
two swappable events  let     e         ei     ei        en result swapping ei ei  
    show relaxed scheduling function     relaxed
scheduling function    
consider two events ej ek     ej located ek   j       
k    i      ej definitely located ek   too  therefore property
 s    holds ej ek   hand  j       k   i  ej ek
swappable therefore property  s    trivially holds ej ek  
assume ej starting event particular action a  ek pairing
event ej     definition    easily infer     ei located
ej ek   ei cannot starting ending event a  similarly 
ei   located ej ek   ei   cannot starting ending event
a  hand  since ei ei   swappable  know cannot
events action  therefore  either j        k    i  thus 
swapping ei ei   cannot falsify fact ej ek pairing events 
words      too  ek pairing event ej   implies property  s   
holds ej ek  
let       arbitrary valid temporal plan p  since scheduling function
  obviously regarded relaxed scheduling function   showed
section      transformed causally valid plan compressed
respect com  series swaps  swapping occurs pair
consecutive swappable events  therefore  must relaxed scheduling function
       valid temporal plan p  scheduling function
 
   

firankooh   ghassem sani

p
theorem     let p    i  g  a  temporal planning problem 
   e         en  




set events p  l three formulae l   l   l  defined section
p    
non empty causally valid plan p obtained solving l   let    s       x     
fsm accepts subsequence   he         em  
l encoding
presented            exist model l
l
  plan m   
proof  give proof contradiction  assume exists model l
l
  plan m    let f            m     p
     n  function i 
f  i  equal index i th event   moreover  let g            m           l 
function i  g i  equal step number sat variable
l corresponds i th event   assume x         xm sequence states
    m  xi    xi    ef  i     since accepts   must
f     g   

xm   satisfies        x 
    true  here  two cases
considered  case    g      g     case  since   plan m    f       j   f     
g   
must  ej     f alse  now  considering            infer
g    f    

 x 
    true  case    g      g     case  considering           
g    n  
infer  x 
    true  by  considering       deduce
g       
 x 
    true  argument plus considering      show
g    f    
g i  f  i 
 x 
    true  whole deduction repeated show  xi 
    true
g m  f  m 

  m  therefore   xm 
    true  since xm    xm    ef  m    
e  e
considering       infer j  ej em
n    

g m  j


    true  however  since xm  
 ef  m           ej     em em        xm
contradicts assumption satisfies      
p
theorem     let p    i  g  a  temporal planning problem 
   e         en  



set events p  l three formulae l   l   l  defined
section     let model satisfies l     he         em   plan m    let
p
   s       x      fsm accept subsequence  
l


encoding composed            exists model l l
  plan m   
proof  let us introduce total order relation sat variables l correspond


events input problem  two sat variables eki eki   eki eki
one following two conditions holds     k   k      k   k    
assume f            m          pn  function i  f  i  equal
index i th event   moreover  assume g            m           l 
function k  g k  equal step number sat variable l
corresponds k th event   let uk i   heu        et denote subsequence
following properties 
g t 

 ef  t      true 
   

fiitsat  efficient sat based temporal planner

g t 





k ef  t  eki eki    eki     f alse 
fact  uk i substring spans u th event last event
whose corresponding sat variable located eki l   define model
l
l following rules 
 r    sat variable v l    v     v  
 r      k l   n   xk i
      true 
 r      k l      n  xs    xk i
    true iff j  sequence
jk i transforms x  xs  
 r     infer satisfies l   show satisfies
formulae            thereby  satisfies
l  
xk j
arbitrary formula        eki     f alse
     let eki xk i


k i
k
 xk i
    f alse  formula trivially satisfied  assume  ei      xs    
k i
true   r     u  sequence u transforms x  xs   since
eki ekj   way defined uk j   deduce uk j   uk i hei     
denotes concatenation operator sequence events  ei          ej    
       xs   ei     xt   therefore ei causes transit xs
xt   besides   ei          ej    etout     thus  member cause
transit state xt   therefore  uk j transforms x  xt  
 xk j
    true  hence  formula satisfied 
k j
arbitrary formula        eki     true
     let eki xk i
xs
k
 xk i
    f alse  formula trivially satisfied  assume  ei     f alse
k i
 xk i
    true   r     u  sequence u transforms x  xs  
k j
since eki ekj   way defined u   deduce uk j   uk i  
sequence events  ei          ej     besides   ei          ej    esout    
thus  member cause transit state xs   therefore 
uk j transforms x  xs    xk j
    true  hence  formula satisfied 
k i
k  
     let xk  
xs arbitrary formula        xs     f alse  formula
trivially satisfied  assume  xk  
    true   r     u 
k  
sequence u transforms x  xs   since ek  eki   way defined uk i  
deduce uk i   uk     sequence events  e         ei    
besides   e         ei   esout     thus  member cause transit
state xs   therefore  uk i transforms x  xs    xk i
    true 
hence  formula satisfied 

     let xk n  
xk    
arbitrary formula       way defined


k    
   
  deduce uk n     uk     every u  therefore   xk n  
u

k    

 xs
   hence  formula satisfied 
     according  r     formula      directly satisfied    
   

firankooh   ghassem sani

     let xk i arbitrary formula       accorrding assumptions  uk i
cannot cause transit accepting states  since x    r   
implies  xk i     f alse  hence  formula satisfied 

theorem     let n   xi         xim negative cycle stn corresponding
causally valid plan   e         en temporal problem p  xik node corresponding event eik   let another causally valid plan p  subsequence
member ln  defined section     corresponding stn n
negative cycle 
proof  let ei    e         e  k    ei         eim    em          em km   eim subsequence  
ej          ej kj string symbols j       j m  consider two arbitraty events
eij eij sequence  ij   ij   show temporal constraints
 eij    eij   present  ij    ij   
constraint  ij      ij    scheduling constraint  s   
explained section    eij eij swappable  besides    eij clearly
located eij   consequently  must  ij      ij   according
scheduling constraint  s    
constraint  ij    ij     dur a   scheduling rule  s     eij
eij starting event ending event a  respectively  moreover 
j   j   j   action eij      a  indicates j   j j  
oj   therefore eij
  j   since ej         ej  k string symbols j  
j
conclude   yet ended reaching eij   means eij
eij pairing events   thus  scheduling constraint  s    
 ij    ij     dur a  
shows edge xij xij corresponding stn present
corresponding stn   thus latter stn n negative cycle 

references
allen  j  f          towards general theory action time  artif  intell          
       
armando  a     giunchiglia  e          embedding complex decision procedures inside
interactive theorem prover  ann  math  artif  intell                   
benton  j   coles  a  j     coles  a          temporal planning preferences
time dependent continuous costs  proceedings twenty second international
conference automated planning scheduling  icaps       atibaia  sao paulo 
brazil  june             
biere  a          p re i cosat sc    solver description sat competition       sat
     competitive event booklet 
   

fiitsat  efficient sat based temporal planner

biere  a          lingeling  plingeling treengeling entering sat competition      
proceedings sat competition      
blum  a     furst  m  l          fast planning planning graph analysis  artif 
intell                    
castellini  c   giunchiglia  e     tacchella  a          sat based planning complex
domains  concurrency  constraints nondeterminism  artif  intell                
    
coles  a  j   coles  a   fox  m     long  d          extending use inference
temporal planning forwards search  proceedings   th international conference automated planning scheduling  icaps       thessaloniki  greece 
september             
coles  a  j   coles  a   fox  m     long  d          forward chaining partial order planning  proceedings   th international conference automated planning
scheduling  icaps       toronto  ontario  canada  may              pp       
cormen  t  h   leiserson  c  e   rivest  r  l     stein  c          introduction algorithms
    ed    mit press 
cushing  w   kambhampati  s   mausam    weld  d  s          temporal planning
really temporal   ijcai       proceedings   th international joint conference artificial intelligence  hyderabad  india  january             pp           
dechter  r   meiri  i     pearl  j          temporal constraint networks  artif  intell  
               
do  m  b     kambhampati  s          sapa  multi objective metric temporal planner 
j  artif  intell  res   jair              
een  n     biere  a          effective preprocessing sat variable clause
elimination  theory applications satisfiability testing   th international
conference  sat       st  andrews  uk  june              proceedings  pp       
ernst  m  d   millstein  t  d     weld  d  s          automatic sat compilation planning
problems  proceedings fifteenth international joint conference artificial
intelligence  ijcai     nagoya  japan  august                volumes  pp      
     
eyerich  p   mattmuller  r     roger  g          using context enhanced additive
heuristic temporal numeric planning  proceedings   th international conference automated planning scheduling  icaps       thessaloniki 
greece  september             
fox  m     long  d          pddl   modelling continuous time dependent effects 
third international nasa workshop planning scheduling space 
fox  m     long  d          pddl     extension pddl expressing temporal
planning domains  j  artif  intell  res   jair             
fox  m     long  d          note concurrency complexity temporal planning 
  th workshop uk planning scheduling special interest group 
   

firankooh   ghassem sani

garrido  a   fox  m     long  d          temporal planning system durative actions
pddl     proceedings   th eureopean conference artificial intelligence 
ecai      lyon  france  july       pp         
gerevini  a   saetti  a     serina  i          approach temporal planning scheduling domains predictable exogenous events  j  artif  intell  res   jair      
       
gerevini  a     schubert  l  k          inferring state constraints domain independent
planning  proceedings fifteenth national conference artificial intelligence
tenth innovative applications artificial intelligence conference  aaai    
iaai     july              madison  wisconsin  usa   pp         
halsey  k          crikey  co ordination temporal planning  ph d  thesis  university durham 
halsey  k   long  d     fox  m          multiple relaxations temporal planning 
proceedings   th eureopean conference artificial intelligence  ecai     
including prestigious applicants intelligent systems  pais       valencia  spain 
august              pp           
haslum  p          improving heuristics relaxed search   analysis tp 
hsp a      planning competition  j  artif  intell  res   jair              
haslum  p     geffner  h          admissible heuristics optimal planning  proceedings fifth international conference artificial intelligence planning systems 
breckenridge  co  usa  april              pp         
helmert  m     geffner  h          unifying causal graph additive heuristics 
proceedings eighteenth international conference automated planning
scheduling  icaps       sydney  australia  september              pp         
hoffmann  j   gomes  c  p   selman  b     kautz  h  a          sat encodings statespace reachability problems numeric domains  ijcai       proceedings
  th international joint conference artificial intelligence  hyderabad  india  january             pp           
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  j  artif  intell  res   jair              
huang  r   chen  y     zhang  w          optimal temporally expressive planner 
initial results application p p network optimization  proceedings
  th international conference automated planning scheduling  icaps      
thessaloniki  greece  september             
huang  r   chen  y     zhang  w          sas  planning satisfiability  j  artif  intell 
res   jair              
kautz  h  a     selman  b          planning satisfiability  ecai  pp         
kautz  h  a     selman  b          pushing envelope  planning  propositional logic
stochastic search  proceedings thirteenth national conference artificial
intelligence eighth innovative applications artificial intelligence conference 
aaai     iaai     portland  oregon  august            volume     pp           
   

fiitsat  efficient sat based temporal planner

long  d     fox  m          exploiting graphplan framework temporal planning 
proceedings thirteenth international conference automated planning
scheduling  icaps        june             trento  italy  pp       
lu  q   huang  r   chen  y   xu  y   zhang  w     chen  g          sat based approach
cost sensitive temporally expressive planning  acm tist            
mali  a  d     liu  y          t satplan  sat based temporal planner  international
journal artificial intelligence tools                 
rankooh  m  f     ghassem sani  g          new encoding methods sat based temporal
planning  proceedings twenty third international conference automated
planning scheduling  icaps       rome  italy  june             
rintanen  j          compact representation sets binary constraints  ecai      
  th european conference artificial intelligence  august      september         
riva del garda  italy  including prestigious applications intelligent systems  pais
       proceedings  pp         
rintanen  j          complexity concurrent temporal planning  proceedings
seventeenth international conference automated planning scheduling  icaps
      providence  rhode island  usa  september              pp         
rintanen  j          planning satisfiability  heuristics  artif  intell             
rintanen  j     gretton  c  o          computing upper bounds lengths transition
sequences  ijcai       proceedings   rd international joint conference
artificial intelligence  beijing  china  august           
rintanen  j   heljanko  k     niemela  i          planning satisfiability  parallel plans
algorithms plan search  artif  intell                         
robinson  n   gretton  c   pham  d  n     sattar  a          sat based parallel planning
using split representation actions  proceedings   th international conference automated planning scheduling  icaps       thessaloniki  greece 
september             
robinson  n   gretton  c   pham  d  n     sattar  a          partial weighted maxsat
optimal planning  pricai       trends artificial intelligence    th pacific
rim international conference artificial intelligence  daegu  korea  august   september          proceedings  pp         
shin  j  a     davis  e          processes continuous change sat based planner 
artif  intell                     
smith  d  e     weld  d  s          temporal planning mutual exclusion reasoning 
proceedings sixteenth international joint conference artificial intelligence 
ijcai     stockholm  sweden  july      august            volumes       pages  pp 
       
streeter  m  j     smith  s  f          using decision procedures efficiently optimization 
proceedings seventeenth international conference automated planning
scheduling  icaps       providence  rhode island  usa  september             
pp         
   

firankooh   ghassem sani

vidal  v          yahsp  yahsp  mt  th international planning competition 
international planning competition 
vidal  v     geffner  h          branching pruning  optimal temporal pocl
planner based constraint programming  artif  intell                   
wehrle  m     rintanen  j          planning satisfiability relaxed  step plans 
ai       advances artificial intelligence    th australian joint conference
artificial intelligence  gold coast  australia  december            proceedings  pp 
       
younes  h  l  s     simmons  r  g          vhpop  versatile heuristic partial order
planner  j  artif  intell  res   jair              

   


