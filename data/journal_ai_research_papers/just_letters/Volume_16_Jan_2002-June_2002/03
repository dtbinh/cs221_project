journal artificial intelligence research                  

submitted       published     

improving eciency inductive logic programming
use query packs
hendrik blockeel cs kuleuven ac be

hendrik blockeel

katholieke universiteit leuven  department computer science
celestijnenlaan    a  b      leuven  belgium

luc dehaspe pharmadm com

luc dehaspe
pharmadm  ambachtenlaan   d  b      leuven  belgium

bart demoen
gerda janssens
jan ramon

bart demoen cs kuleuven ac be
gerda janssens cs kuleuven ac be
jan ramon cs kuleuven ac be

katholieke universiteit leuven  department computer science
celestijnenlaan    a  b      leuven  belgium

henk vandecasteele pharmadm com

henk vandecasteele

pharmadm  ambachtenlaan   d  b      leuven  belgium

abstract

inductive logic programming  relational learning  powerful paradigm machine
learning data mining  however  order ilp become practically useful 
eciency ilp systems must improve substantially  end  notion query pack
introduced  structures sets similar queries  furthermore  mechanism described
executing query packs  complexity analysis shows considerable eciency
improvements achieved use query pack execution mechanism 
claim supported empirical results obtained incorporating support query
pack execution two existing learning systems 
   introduction

many data mining algorithms employ extent generate and test approach  large
amounts partial complete hypotheses generated evaluated data
mining process  evaluation usually involves testing hypothesis large data set 
process typically linear size data set  examples data mining
algorithms apriori  agrawal et al          decision tree algorithms  quinlan      a 
breiman et al          algorithms inducing decision rules  clark   niblett         etc 
even though search hypothesis space seldom exhaustive practical
situations  clever branch and bound greedy search strategies employed  number hypotheses generated evaluated approaches may still huge 
especially true complex hypothesis space used  often case inductive
logic programming  ilp   sheer size hypothesis space important
contribution high computational complexity ilp approaches  computational complexity reduced  however  exploiting fact many
similarities hypotheses 

c      ai access foundation morgan kaufmann publishers  rights reserved 

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
ilp systems build hypothesis one clause time  search single clause
concerned rest paper  word  hypothesis 
usually refer single clause  clause search space typically structured
lattice  clauses close one another lattice similar  computations
involved evaluating similar well  words  many computations
performed evaluating one clause  which boils executing query
consisting body clause  performed evaluating
next clause  storing certain intermediate results computation later use could
solution  e g   tabling xsb prolog engine  chen   warren         may
infeasible practice memory requirements  becomes feasible
search reorganised intermediate results always used shortly
computed  achieved extent rearranging computations 
best way removing redundancy  however  seems re implement execution
strategy queries way much computation possible effectively
shared 
paper discuss strategy executing sets queries  organised so called
query packs  avoids redundant computations  strategy presented adaptation standard prolog execution mechanism  adapted execution mechanism
implemented ilprolog  prolog system dedicated inductive logic programming  several inductive logic programming systems re implemented make use
dedicated engine  using new implementations obtained experimental
results showing cases speed up order magnitude  thus 
work significantly contributes applicability inductive logic programming real
world data mining tasks  addition  believe may contribute state art
query optimisation relational databases  indeed  latter field lot
work optimisation individual queries relatively small sets queries  much
less optimisation large groups similar queries  understandably
get much attention advent data mining  optimisation groups queries
relational databases seems interesting research area now  believe techniques
similar ones proposed might relevant area 
remainder paper structured follows  section   precisely describe
ilp problem setting work set  section   define notion
query pack indicate would executed standard prolog interpreter
computational redundancy causes  describe execution mechanism
query packs makes possible avoid redundant computations would arise
queries pack run separately  show implemented making
small significant extensions wam  standard prolog execution mechanism 
section   describe query pack execution strategy incorporated two
existing inductive logic programming algorithms  tilde warmr   section  
present experimental results illustrate speed up systems achieve
using query pack execution mechanism  section   discuss related work
section   present conclusions directions future work 

   

fiimproving efficiency ilp query packs
   inductive logic programming

inductive logic programming  muggleton   de raedt        situated intersection
machine learning data mining one hand  logic programming
hand  shares former fields goal finding patterns data  patterns
used build predictive models gain insight data  logic programming
shares use clausal first order logic representation language data
hypotheses  remainder text use basic notions logic
programming  literals  conjunctive queries  variable substitutions  use
prolog notation throughout paper  introduction prolog logic programming
see bratko        
inductive logic programming used many different purposes  problem
statements found ilp papers consequently vary  article consider so called
learning interpretations setting  de raedt   dzeroski        de raedt        
argued elsewhere setting  slightly less powerful standard
ilp setting  it problems with  e g   learning recursive predicates   sucient
practical purposes scales better  blockeel et al         
formulate learning task way covers number different problem
statements  specifically  consider problem detecting set conjunctive
queries instantiations certain variables query succeeds  variables
called key variables  grounding substitution called key instantiation 
intuition example learning task uniquely identified single key
instantiation 
link ilp systems learn clauses follows  search performed
ilp system directed regularly evaluating candidate clauses  let us denote
candidate clause head x  
body  x    x represents vector variables
appearing head clause represents additional variables occur
body  assume head single literal list examples given 
example form head x   substitution grounds x   examples
may labelled  e g   positive negative   essential setting 
example represented fact head x   learning definite horn clauses 
consider tuple x  notations used paper 
intuitively  positive negative examples given  one wants find clause
covers many positive examples possible  covering negatives 
whether single example head x   covered clause determined
running query   body x     words  evaluating clause boils
running number queries consisting body clause  simplicity notation 
often denote conjunctive query conjunction  without   symbol  
less typical ilp settings  ilp algorithm search horn clauses
rather general clauses  e g   claudien  de raedt   dehaspe        frequent
patterns expressed conjunctive queries  e g   warmr dehaspe   toivonen 
       settings handled approach well  needed mapping
hypotheses queries allow evaluate hypotheses  mapping
defined de raedt dehaspe        claudien  warmr trivial 

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
given set queries set examples e   main task determine
queries q   cover examples e   e   formalise using notion result
set 

definition    result set  result set set queries deductive database
key k example set e  
rs  s  k  d  e  

  f k  i jqi   k   e qi succeeds dg

similar learning interpretations setting defined  de raedt        
problem setting stated as 

given  set conjunctive queries   deductive database d  tuple k variables
occur query s  example set e
find  result set rs  s  k  d  e    i e   find query q ground
instantiations k k   e q succeeds d 
example   assume ilp system learning definition grandfather   wants evaluate following hypotheses 

grandfather x y     parent x z   parent z y   male x  
grandfather x y     parent x z   parent z y   female x  

examples form grandfather gf  gc  gf gc constants  hence
example uniquely identified ground substitution tuple  x    
problem setting set prolog queries equals f    parent x z   parent z y  
male x        parent x z   parent z y   female x  g key k equals  x    
given query qi     finding tuples  x  y    x  y   i    r  with r result
set defined above  equivalent finding grandfather x y  facts
example set predicted clause grandfather x y     qi  

generality problem setting follows fact known
queries succeed examples  statistics heuristics typical ilp systems
use readily obtained this  examples 






discovery frequent patterns  dehaspe   toivonen         query qi
number key instantiations succeeds needs counted  i e  
f req  qi     jfk j k  i    rgj r result set 
induction horn clauses  muggleton        quinlan      b   accuracy
clause h    qi  defined number examples body head hold 
divided number examples body holds  computed
jfkj k i  r dj hgj r result set 
jfkj k i  rgj
induction first order classification regression trees  kramer        blockeel  
de raedt        blockeel et al          class entropy variance examples
covered  or covered  query computed probability distribution
target variable  computing distribution involves simple counts similar
ones above 

   

fiimproving efficiency ilp query packs
transforming grandfather   clauses
grandfather  x y   i     parent x z   parent z y   male x       
grandfather  x y   i     parent x z   parent z y   female x       

result set clearly computed collecting grounding  s k   e
answers query    grandfather k i    section   queries literal
  end another goal side effects results collecting result set 
practice  natural compute result set using double loop  one examples
one queries one choice outer loop   examples
outer loop   queries outer loop  used data mining systems 
context decision trees  see instance quinlan      a  mehta et al         
shall see redundancy removal approach propose uses  examples
outer loop  strategy  approaches however  given query key instantiation 
interested whether query succeeds key instantiation  implies
particular query succeeded example  execution stopped 
words  computing result set defined boils evaluating
query example  interested existence success
evaluation  computing one solution one query one example unnecessary 
   query packs

simplicity  make abstraction existence keys following examples 
relevant here  query interested whether succeeds not 
finding answer substitutions 
given following set queries
p x  
p x  
p x  
p x  
p x  

    
q x a  
q x b  
q x y  
q x y  

    
    
t x       
t x   r y         

choose evaluate separately  since interested one   first  
success query  would evaluate prolog queries
once  p x  
once  p x  
once  p x  
once  p x  
once  p x  

      
q x a         
q x b         
q x y   t x         
q x y   t x   r y           

wrapper once   pruning primitive prevents unnecessary search
solutions  definition prolog simply
once goal     call goal     

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
alternative way evaluate queries consists merging one  nested 
disjunction in 
p x    i  

 

q x a   i  

 

q x b   i  

 

q x y   t x    i  

 

r y     i     

set queries evaluated whole  success one branch
disjunctive query corresponds success corresponding individual query 
compared evaluation individual queries  disjunctive query
advantage disadvantage 
  queries prefix p x   evaluated individual
query  disjunctive query  goal p x  evaluated once  depending
evaluation cost p    lead arbitrary performance gains 
usual prolog pruning primitives powerful enough prevent unnecessary backtracking branch disjunctive query succeeded 
explained example   

example   example literals

contribute discussion 

  left out 



p x   q x  
p x   r x  

evaluating queries separately means evaluating
once  p x   q x    
once  p x   r x    

equivalently
p x   q x     
p x   r x     

corresponding disjunctive query
p x    q x    r x   

try place pruning primitive disjunctive query      end
branch results
p x    q x       r x     

scope first cut clearly large  goal q x  succeeded  cut
prevent entering second branch  means adding cut disjunctive
query leads wrong result 
using once   disjunctive query results
p x    once q x     once r x   

   

fiimproving efficiency ilp query packs
results correct query  however  branches still executed every
binding goal p x  produces  even branches succeeded already 

combination advantage disjunctive query advantage
individual query pruning  once cut  results notion query pack  syntactically  query pack looks disjunctive query   control construct
replaced new control construct denoted or  query pack corresponding
disjunctive query
p x    i  



q x a   i  



q x b   i  



q x y   t x    i  



r y     i    

query pack represented tree figure    query pack q
tree literals conjunctions literals nodes  path root leaf
node represents conjunctive query q member q  denoted q   q 
construct implicit branching points 
p x 
i  

q x a  
i  

q x b  
i  

q x c  
i  
i  

q x y   t x 
r y    
i  

r y    
i  

figure    query pack 
intended procedural behaviour construct branch succeeded  effectively pruned away pack evaluation query pack
current example  pruning must recursive  i e   branches subtree
query pack succeeded  whole subtree must pruned  evaluation
query pack terminates subtrees pruned remaining
queries fail example 
semantics construct ecient implementation subject
rest section  however clear already case
answers query needed  pruning cannot performed disjunctive query
already sucient  i e   query packs useful single success per query suces 

    ecient execution query packs
section        meta interpreter given defines behaviour query packs 
practice meta interpreter useful  many cases meta interpreter
causes overhead use query packs compensate for  indeed  previously
reported results  demoen et al         blockeel        indicate overhead involved
high level prolog implementation destroys eciency gain obtained redundancy
reduction  moreover discussed section        meta interpreter
desired time complexity  shows desired procedural semantics

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
implemented prolog itself  desired performance prolog lacks
appropriate primitives 
conclusion changes needed level prolog engine itself 
requires extension wam  warren abstract machine  underlying
abstract machine prolog implementations  extended wam provides
operator discussed above  permanently removes branches pack
need investigated anymore  extended wam become basis new prolog
engine dedicated inductive logic programming  called ilprolog  section continues
introduction basic terminology query packs explains high level
query pack execution works  next meta interpreter query pack execution
given finally changes needed wam clarified 
      principles query packs  execution 

discuss query pack execution detail  note following two points     
pack execution  pruning branch must survive backtracking      executing
pack interested variable instantiations  whether member
pack succeeds not  previous description interested binding
variable i  since branch bind one value   query number   collect
values practice side effect denoted section     report success 
starting point query pack execution mechanism usual prolog execution
query q given prolog program p   backtracking prolog generate
solutions q giving possible instantiations q succeeds p  
query pack consists conjunction literals set alternatives 
alternative query pack  note leaves query packs empty set
alternatives  query pack q  conj  q  denotes conjunction children q 
denotes set alternatives  set queries represented so called root query
pack  every query pack q  path query packs starting root query
pack qroot ending query pack itself  namely   qroot   q         qn   q   
query packs path predecessors q  every query pack set dependent
queries  dependent queries q   let   qroot   qi         qin   q   path q 
dependent queries q    fconj  qroot     conj  qi              conj  qin     conj  q    conj  qj     
        conj  qjm     conj  ql   j   q  qj         qjm   ql   path q leaf ql g  note
dependent queries qroot   actually members query pack described
earlier 

qroot root tree  conj  qroot  
qroot   contains   query packs correspond trees

example   query pack figure   
p x    set children 

rooted   sons root tree  suppose query packs named  from
left right  q    q    q    q    conj  q    equals  q x  a         children q   
equals empty set  conj  q    equals  q x     t x     dependent queries q    equals
f p x    q x     t x           p x    q x     t x    r y          g 

execution root query pack qroot aims finding queries set
dependent queries qroot   succeed  query pack executed ors usual
disjunctions  backtracking occurs queries already succeeded many

   

fiimproving efficiency ilp query packs
 
 
 
 
 
 
 
 
 
 
  
  

execute qp  pack q  substitution   f
  next solution  conj  q  

f

qchild children q 

f
g

g

  execute qp  qchild        success 
children q 
children q  n fqchild g

  children q  empty set  return success 

return fail 

g

figure    query pack execution algorithm 
successes detected  avoid this  case soon query succeeds 
corresponding part query pack longer considered backtracking  approach realises reporting success queries  and query packs 
predecessors query pack   non root  query pack q safely removed
queries depend  i e   queries dependent queries q   succeeded once 
leaf q  empty set children   success conj  q  sucient remove it 
non leaf q  wait dependent queries report success equivalently
query packs children q  report success 
start evaluation root query pack  set children every query
pack contains alternatives given query pack  execution  query
packs removed children sets thus values children q  change
accordingly  due backtracking query pack executed again  might case
fewer alternatives considered 
execution query pack q defined algorithm execute qp q     figure
   imposes additional control usual prolog execution 
usual prolog execution backtracking behaviour modelled loop
 line    generates possible solutions conjunction query pack 
solutions found  fail returned backtracking occur level
calling query pack 
additional control manages children q   solution   necessary
children q executed  important notice initial set children
query pack changed destructively execution algorithm  firstly 
leaf reached  success returned  line    corresponding child removed
query pack  line     secondly  query pack initially several children  finally
ends empty set children  line     query pack removed  line    
fact children destructively removed  implies due backtracking
query pack executed different   alternatives
initially there  executed more  moreover  returning success

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
qp   
ch   

ch   
ch   

b qp   
ch   

f

q   

g qp   
ch   

ch   
ch   

c q   

q   

ch   
ch   

e q   

h q   

q   

j

q   

figure    query pack numbers qp i   query numbers q i  child numbers ch i 
example 
backtracking current query pack conjunction conj  q  stopped  branches
reported success 
      meta interpreter query packs

first implementation query pack execution algorithm meta interpreter
meta execute qp q   meta interpreter uses following labelling representation
query pack 

query pack number non leaf query packs tree numbered  depth
first  left right  qp i   

query number leaf numbered  left right  original queries
numbered sequentially  numbers leaves correspond  q i   

child number non leaf query pack n children  children numbered
  n sequentially  ch i   

consider query pack a   b   c e  f g   h j    note
atoms example could general arbitrary conjunctions non ground terms 
labelling shown figure   
labelled query pack q represented prolog term follows  with qf
father q  



leaf

q represented term  c  leaf  qpnbf  chnb  qnb   c conj  q  
query pack number qf   chnb child number q w r t  qf   qnb
query number q 



non leaf q represented term  c  or cs  qpnbf  qpnb  chnb  totcs  c
conj  q   cs list children q   qpnbf query pack number qf   qpnb query
pack number q  chnb child number q w r t  qf   totcs total number
children q    query pack number father root query pack
assumed zero 

qpnbf

   

fiimproving efficiency ilp query packs
example figure   following representation  as prolog term  
 a  or   b or   c leaf          d leaf          e leaf                    
 f leaf         
 g or   h leaf          i leaf          j leaf                     
         

execution meta interpreter  solved   facts asserted  fact
solved qpnb  chnb  denotes child number chnb query pack number

succeeded  facts asserted reaching leaf children
query pack succeeded  meta interpreter executes children
solved   fact asserted 
note time complexity meta interpreter yet desired  execution
query pack always dependent number original children  instead
number remaining  as yet unsuccessful  children 
qpnb

run querypack q   preprocess q  qlabeled                  
  code preprocessing given appendix
retractall solved       
meta execute qp qlabeled  
solved         
meta execute qp  a b        
call a  
meta execute qp b  
meta execute qp or cs  qpnbf  qpnb  childnb  totcs          or  corresponds non leaf query pack
handlechildren cs  qpnb     
solved qpnb     totcs  
assert solved qpnbf childnb   
meta execute qp leaf qpnbf  childnb   querynb          leaf  corresponds end query
write succeed querynb    nl 
assert solved qpnbf childnb   
handlechildren         
handlechildren  c     qpnb  childnb   not solved qpnb childnb   
once meta execute qp c    fail 
handlechildren    cs   qpnb  childnb   childnb  childnb     
handlechildren cs  qpnb  childnb   
solved qpnb  childnb  totcs    childnb   totcs    true
 
childnb  childnb     
solved qpnb  childnb   
solved qpnb  childnb   totcs 
  

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
      wam extensions

fully exploit potential query pack  shared computation avoidance unnecessary backtracking  changes made level prolog engine itself 
explanation assumes wam based prolog engine  at kaci        short explanation
execution disjunction prolog given first  becomes easy see
newly introduced wam 
assume body clause executed a   b c     e   assume
predicates several clauses  moment execution reached first
clause c  choice point stack looks figure   a   choice points
activation a  disjunction itself  b c  choice points linked together
backtracking easily pop top one  choice point contains pointer
next alternative tried  disjunction choice point  alternative pointer
shown  points beginning second branch disjunction 
alternatives b c exhausted  second branch entered becomes
active  situation shown figure   b   point  alternative
disjunction choice point refers last alternative branch disjunction  finally 
e entered  disjunction choice point already popped 
a   b  c     e 

a   b  c     e 

a   b  c     e 







 

 

e

b



c

 a  choice points
entering c 

 b  choice points
entering d 

 c  choice points
entering e 

figure    illustration execution disjunction wam 
goal produces new solution  branches disjunction must tried
again  exactly want avoid query packs  branch succeeded once 
never re entered  therefore adapt disjunction choice point become
or choice point set point data structure contains references
alternative disjunction  data structure named pack table  figure
  a  shows state execution reached c  similar figure   a  
or choice point contains information first branch executed 
execution proceeds  two possibilities  either first branch succeeds fails 
describe failing situation first branch explain happens success

   

fiimproving efficiency ilp query packs
second branch  first branch solution  backtracking updates alternative
or choice point  point next branch pack table  situation
second branch entered shown   b  similar   b   suppose
branch goal succeeds  entry pack table or alternatives
adapted erasing second alternative branch  backtracking occurs  next
alternative branch or choice point taken  shown   c  
produces new solution or disjunction entered again  pack table
longer contain second alternative branch never re entered  pack
table actually arranged way entries really removed instead erased
cause overhead later 
a   b  c e 

a   b  c e 

a   b  c e 













b



e

c

 a  choice points
entering c 

 b  choice points
entering  the first
branch succeed  

 c  choice points
entering e  d succeeded  

figure    illustration execution pack disjunction wam 
two issues must explained  first  pack table alternatives must
constructed runtime every time query pack entered evaluation  done
emitting necessary instructions beginning code query pack 
example  show code query pack a   b c e  figure   
finally  example clear moment alternatives ordisjunction succeeded  stop producing solutions  computation
stopped  general   nested query packs   means one pack table entry
next higher or node erased recursive way  recursive removal
entries pack tables  done instruction query pack prune 
implemented schema ilprolog  section   presents measurements
ilprolog 

    using query packs
figure   shows algorithm makes use pack execution mechanism compute
result set r defined problem statement  set queries typically

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
construct pack table           
call
query pack try
    call b
call c
query pack prune
    call
query pack prune
    call e
query pack prune

figure    abstract machine code a   b c e   
set refinements given query  i e   correspond whole hypothesis
space  query pack q containing queries   derived pack q  constructed
adding report success   literal leaf pack   procedural  task
report success k i  simply add  k  i  result set r  obviously specific
ilp system interested result set could provide report success  
predicate thus avoid overhead explicitly building result set  
  evaluate set examples e   pack q  key k   f
 
q  q 
 
q
  
 
leaf q  f
 
add report success k  q  right conjunction leaf
 
increment q
 
g
 
c
 evaluate pack k      q    
 
compile load c  
  
example e e f
  
evaluate pack e  
  
g
   g
figure    using query packs compute result set 
note algorithm figure   follows strategy running queries
single example moving next example  could called  examples
outer loop  strategy  opposed  queries outer loop  strategy used ilp
   current implementation result set implemented bit matrix indexed queries
examples  implementation practically feasible  on typical computers time writing  even
number queries pack multiplied number examples billion  bound
holds current ilp applications 

   

fiimproving efficiency ilp query packs
systems   examples outer loop  strategy important advantages processing
large data sets  mainly due ability process eciently without data
main memory time  mehta et al         blockeel et al         

    computational complexity
estimate speedup factor achieved using query pack execution two
steps  first consider one level packs  extend results towards deeper packs 
lower upper bounds speedup factor achieved executing
one level pack instead separate queries obtained follows  pack containing
n queries qi    a  bi    let ti time needed compute first answer substitution
qi any  obtain failure otherwise  let ti part ti spent within
t i part ti spent bi   ts    ti   t i   tp   max ti     t i ts
representing total time needed executing queries separately tp total time
needed executing pack  introducing c   ti   t i   roughly represents
ratio computational complexity shared part non shared part 

 
c  
ts
ti  
ti
 
  maxi ti
   
 
tp
maxi ti   ti
  
t 

p

p

p

p p

p
p

p



defining k ratio maximal ti average ti   i e 

rewrite equation    

since

p

ti
n

pmaxt  nt


k

 

ts
tp

 



c  

k
nc

   

  

max ti pi ti know   k n  leads following bounds 
 

ts
tp



c  

c
n

  

  min c      n 

   

thus speedup factor bounded branching factor n
ratio c computational complexity shared part computational complexity
non shared part  maximal speedup attained max ti   ti  n  or 
k       words ti queries approximately equal 
multi level packs  estimate eciency gain follows  given query qi  
let ti defined  the total time finding   answer qi obtaining failure  
instead ti t i   define ti l time spent level l pack solving qi  
counting root level   denoting depth pack ti   dl   ti l  
define ti l time spent level l deeper  ti l   dj l ti j depth
pack   thus ti   ti       assume constant branching factor b pack 
finally  define tl   ti l  n n   bd   simplicity  formulae implicitly
assume always ranges   n n number queries  unless explicitly

p

p

p

   

p

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
specified otherwise 
tp

  max ti  


x
 


i  

  max ti  


x
   max
b

j   

 

gj

i  

xt

 

 

gj

i  

 

   

j           b index child root gj set indexes
queries belonging child  define k    maxi ti    t  define k  smallest
number maxi gj ti   k  tj   tj     i gj ti    b  note   k    k  b 
follows
b
b
max ti   k  tj     k  bt 
   
i gj
j   
j   

p

x

x

allows us rewrite equation    
tp

k t    k  bt   

xt


   

i  

equality holds maxi gj ti   equal gj   reasoning continued
till lowest level pack  yielding
tp

k t    bk t    b k  t      bd

finally
tp

k  t    bk  t    b  k t      bd



 k

  td  

 k

 



  td  

xt

i d

   



  bd td

   

kl   b  simplify comparison ts assuming
 l   kl      kl dropped inequality becomes equality  because
maxima must equal  
tp

  t    bt    b  t      bd   td

 

  bd td

   

 

  bd td

    

note ts
ts

  bd t    bd t    bd t      bd td

clear  then  speedup governed bd tk terms compare
bk tk terms   in worst case  kk   b  latter become bk   tk    therefore
introduce rl m follows 

bm tk
    
rl m   km l k

k  l b tk

p
p

r coecients always    if tm dominates  bm l  if tl strongly dominates  
tl equal  rl m approximately l 
further  similar c previous analysis  define

p    b
c   p

     b
l

l
k


k l

   

k

k

k

k

    

fiimproving efficiency ilp query packs
algebra gives

ts
tp

 

bd l cl r  l   rl   d
cl    

    

needs hold l  interpret follows  certain level l  cl roughly
ects speedup gained fact part till level l needs executed
once  r factors ect speedup obtained within parts pack
mechanism 
inequality holds l  hence find best lower bound speedup factor maximizing right hand side  note cl increases bd l decreases
monotonically l  clear point cl becomes much larger   
speedup factor roughly bd l obtained  hand  cl smaller   
behaviour bd l cl crucial  now 
bd l cl

tl     tl       b l t 
    b
 
td   b td       bd  l   tl  

conclusion similar one level pack  l  cl       i e  
upper part pack  up till level l  computations take place expensive
dominate computations level l  even taking account latter
performed bd l times often   speedup bd l expected  cl      
usually case l except near d  speedup roughly
estimated tl  td   maximum factors determine actual speedup 
   adapting ilp algorithms use query packs

section discuss execution method included ilp algorithms  illustrate detail two existing ilp algorithms  experimental
results concerning actual eciency improvements yields presented next section 

    refinement single rule
many systems inductive logic programming use algorithm consists repeatedly
refining clauses  systems could principle rewritten make use query
pack evaluation mechanism thus achieve significant eciency gain  first show
concrete algorithm decision tree induction  discuss general case 
      induction decision trees

first algorithm discuss tilde  blockeel   de raedt         algorithm
builds first order decision trees  first order decision tree  nodes contain literals
together conjunction literals nodes node  i e   path
root node  form query run example decide
subtree sorted into  building tree  literal  or conjunction
literals  put one node chosen follows  given query corresponding path
root node  generate refinements query  a refinement query

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
formed adding one literals query   evaluate refinements
relevant subset data   computing  e g   information gain  quinlan      a  yielded
refinement  choose best refinement  put literals added
original clause form refinement node 
point clear lot computational redundancy exists refinement
evaluated separately  indeed refinements contain exactly literals except
added single refinement step  organising refinements one query pack 
obtain query pack essentially one level  the root immediately branches
leaves   tilde s lookahead facility used  blockeel   de raedt         refinements
form lattice query pack may contain multiple  though usually few  levels 
note root packs may consist conjunction many literals  giving
pack broom like form  literals root pack  greater benefit
query pack execution expected be 

example   assume node currently refined following query associated

it     circle a c  leftof a c d  above a d e   i e   node covers examples
circle left object yet another object 
query pack generated refinement could instance

circle a c   leftof a c d   above a d e  

triangle a f 
circle a h 
small a i 
large a j 
in a e k 
in a d l 
in a c m 
above a e n 
above a d o 
above a c p 
leftof a e q 
leftof a d r 
leftof a c s 

evaluating pack  backtracking root pack  the  stick 
broom  happen once  instead refinement  words 
evaluating queries one one  query prolog engine needs search
objects c   e fulfilling constraint circle a c   leftof a c d  
above a d e   executing pack search done once 
      algorithms based rule refinement

mentioned  ilp algorithm consists repeatedly refining clauses could principle rewritten make use query pack evaluation mechanism thus achieve
significant eciency gain  consider  e g   rule induction system performing search
refinement lattice  progol  muggleton         since imposes certain order clauses considered refinement  hard reorganise
computation level  however  taking one node list open nodes
producing refinements  evaluation refinements involves executing
them  replaced pack execution  case positive eciency gain
guaranteed  principle one could perform several levels refinement stage 
   i e   subset original data set parent query succeeded  or  decision tree
context  examples sorted node refined 

   

fiimproving efficiency ilp query packs
adding refinements  s queue  part eciency lost 
pack execution mechanism exploited larger extent  two effects
dominant depend application  first level refinements would
refined anyway point search  clearly gain
executing two level pack  otherwise may loss eciency  instance 
executing two level pack takes x times much time one level pack  bring
eciency gain least x first level refinements would afterwards refined
themselves 

    level wise frequent pattern discovery
alternative family data mining algorithms scans refinement lattice breadthfirst manner queries whose frequency exceeds user defined threshold  bestknown instance level wise algorithms apriori method finding frequent
item sets  agrawal et al          warmr  dehaspe   toivonen        ilp variant
attribute value based apriori 
query packs warmr correspond hash trees item sets apriori  used
store subgraph total refinement lattice level n  paths root
level n   subgraph correspond frequent patterns  paths root
leaves depth n correspond candidates whose frequency computed 
hash trees apriori  query packs warmr exploit massive similarity
candidates make evaluation ecient  essentially warmr algorithm starts
empty query pack iterates pack evaluation pack extension  see
figure     latter achieved adding potentially frequent refinements  leaves
pack  i e   adding another level total refinement lattice 
   experiments

goal experimental evaluation empirically investigate actual speedups
obtained re implementing ilp systems use pack execution
mechanism  moment re implementations exist tilde warmr
systems  hence used experiments  re implementations
available within ace data mining tool  available academic use upon request  
attempt quantify  a  speedup packs w r t  separate execution queries  thus
validating complexity analysis    b  total speedup yield
ilp system 
data sets used experiments following 



mutagenesis data set   ilp benchmark data set  introduced ilp community srinivasan et al          consists structural descriptions    
molecules classified mutagenic not  next standard mutagenesis data set  consider versions example occurs n times 

   refinements found specialisations infrequent queries cannot frequent themselves 
pruned consequently 
   see http   www cs kuleuven ac be  dtai ace  

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele

circle a b 

triangle a b 

leftof a b c  above a b c  leftof a b c 

expand

circle a b 

leftof a b c 

triangle a b 

above a b c 

leftof a b c 

circle a c triangle a c  circle a c triangle a c  circle a c triangle a c 
evaluate
circle a b  triangle a b 
above a b c 

leftof a b c 

triangle a c  circle a c triangle a c 

circle a b 

expand

above a b c 
triangle a c 

triangle a b 
leftof a b c 

circle a c 

triangle a c 

leftof a c d  leftof a c d  above a c d  leftof a c d 

figure    sequence   query packs warmr  refinement left query
pack results   level pack right  removal queries found infrequent
pack evaluation results bottom left pack  finally  another level
added second query expansion step produce bottom right pack 
iteration expansion evaluation continues pack empty 
allows us easily generate data sets larger size average example
query complexity constant equal original data set 



bongard data sets   introduced ilp de raedt van laer         so called
 bongard problems  simplified version problems used bongard       
research pattern recognition  number drawings shown containing
number elementary geometrical figures  drawings classified according
relations hold figures them  use bongard problem generator
create data sets varying size 

experiments run sun workstations  sparc ultra        mhz
tilde  sparc ultra        mhz warmr  tilde warmr run
default settings  except mentioned differently 

    tilde
consider three different ways tilde run ilprolog implementation 
   packs  normal implementation tilde described blockeel de raedt
        queries generated one one evaluated relevant
examples  since queries represented terms  evaluation query involves
meta call prolog 

   

fiimproving efficiency ilp query packs
   disjoint execution packs  query pack executed queries pack
put beside one another  i e   common parts shared queries 
computational redundancy executing pack executing
queries one another  main difference case queries
compiled 
   packed execution packs  compiled query pack executed queries share
much possible 
interesting information obtained comparing  a  actual query evaluation time settings      gives view eciency gain obtained
removal redundant computation  we abbreviate exec tables  
 b  total execution time settings      provides indication
much gained implementing packs ilp system  taking effects account  re implementation computation heuristics via bit matrix  use compiled
queries instead meta calls  etc    words  net effect whole
re implementation  indicated net tables  
first experiment used bongard problems  varying     size data sets 
    complexity target hypothesis      tilde s lookahead parameter 
complexity target hypothesis small  medium  none  latter case
examples random  causes tilde grow ever larger trees attempt find
good hypothesis  size final tree typically depends size data
set  lookahead parameter used control number levels pack contains 
lookahead n  packs depth n     generated 
table   gives overview results bongard problems  total induction
time reported  well  for pack based execution mechanisms  time needed
pack compilation pack execution  note total time includes pack
compilation execution  computations directly related packs
 e g   computation heuristics bitmatrix   results interpreted
follows 
first all  table shows significant speedups obtained using pack
mechanism  net speedups factor     obtained  execution
   times faster compared disjoint execution 
observation complex target hypotheses greater speedups
obtained  explained broom like form packs tilde  complex
target hypotheses correspond deep trees  refinement node lower level
tree yields pack long clause branching  accordance
previous analysis yield speedup closer branching factor b case
lookahead    and generally  closer bl   lookahead l  although latter
much harder achieve   note maximum branching factor occurring pack
included table column bf  
finally  deeper packs yield higher speedups  effect larger complex
theories  understandable considering following  let us call clause
refined c  lookahead l  conjunctions l     literals added clause 
cases first l     literals may fail immediately  causes branch
pack almost execution time  cutting away bl queries  remember

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
la

bf

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

 
 
 
 

  
  
  
  

original

    
    
    
    

    
    
    
    

    
    
    
   

    
    
    
    

    
    
    
   

    
     
   
   

    
     
    
   

    
    
   
    

    
   
    
    

disjoint
packed
comp exec total comp
simple target hypothesis
     examples
    
    
    
    
    
    
    
    
    
    
    
   
    
    
    
     
    
    
    
    
     examples
    
    
    
    
    
    
    
    
    
    
    
    
    
   
    
    
    
    
    
    
     examples
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
medium complexity target hypothesis
     examples
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     examples
    
    
    
    
   
    
   
    
   
    
    
          
    
    
     
    
    
    
    
     examples
    
    
   
    
    
     
   
    
   
    
    
    
    
    
    
   
   
    
   
    
target hypothesis
     examples
    
    
    
    
    
     
                     
   
    
    
    
    
   
   
    
   
    
     examples
    
    
    
   
    
    
    
    
     
    
   
   
  
     
     
    
    
   
   
   
     examples
    
    
    
    
    
   
    
    
    
    
    
    
   
   
   
    
              
   
total

speedup

exec

net

exec

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

   

    

   

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

 

    

    

    

    

    

    

    

    

    

    

    

    

   

    

    

    

    

    

    

    

    

    

    

    

   

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

 

    

    

    

    

    

table    timings tilde runs bongard data sets  la   lookahead setting  bf  
maximum branching factor  reported times  in seconds  total time needed
build tree  time spent compilation respectively execution packs 

   

fiimproving efficiency ilp query packs
la original
 
 
 

    
      
    

 
 
 

    
     
   

disjoint
packed
total comp exec total comp
regression      examples
                        
                     
 
 
 
   
   
classification      examples
                        
                        
 
 
 
        

table    timings tilde runs mutagenesis 
ended prematurely 

exec

speedup ratio
net
exec

          
         
         

    
    
 

    
    
    

    
    
 

    
    
   

table indicates run

according analysis  speedup limit approximate bl complexity
clause c dominates complexity rest pack   early failing branches 
pack cause actual situation approximate closer ideal case 
run experiments mutagenesis data set  table     regression
classification setting  here  query packs much larger bongard data set
 there higher branching factor   lookahead   largest packs      
queries  large packs significant amount time spent compiling pack 
even clear net speedups obtained   comparison execution times turned
infeasible disjoint execution setting pack structures consumed much
memory 

    warmr
      used implementations

warmr consider following implementations 
   packs  normal implementation warmr  queries generated 
examples queries evaluated one one 
   packs  implementation first queries one level generated
put pack  pack evaluated example 
      datasets

mutagenesis used mutagenesis dataset     molecules  example
repeated    times make accurate timings possible better idea
effect larger datasets  used three different language biases   small  language
   one case  relatively small pack  system became slower  timings indicate
due compilation time  changes implementation relatively
simple problem compensated faster execution packs 

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele

level
 
 
 
 
 
 
 
 
 

small

mutagenesis

medium

large

queries frequent queries frequent queries frequent
 
 
  
  
  
  
  
  
   
  
    
   
  
  
   
   
    
    
   
  
   
   
  
  
   
   
  
  
    
    
  
  
 
 
  
  
 
 
 
 
 
 

table    number queries mutagenesis experiment warmr 
bias chosen generate limited number refinements  i e   relatively
small branching factor search lattice   allows us generate query packs
relatively deep narrow   medium   large  use broader shallow packs 
table   summarises number queries number frequent queries found
level different languages 

bongard use bongard      experiments

warmr system
construct theory hence existence simple theory expected make much
difference 
      results

tables        execution times warmr mutagenesis given  maximal
search depth varying   large language   levels small language  here 
 total  total execution time  exec  time needed test queries
examples  table   execution times warmr bongard given 
      discussion

execution time warmr large component used evaluate queries 
caused fact warmr needs lot administrative work 
particular  theta subsumption tests done queries check wether query
equivalent another candidate  query specialisation infrequent one 
propositional case  the apriori algorithm   tests simple 
first order case require exponential time size queries  course 
using larger datasets  relative contribution administrative costs decrease
proportionally  observed deeper levels  costs less setting
using packs  one causes fact no packs version uses memory
packs setting  and hence causes proportionally memory management  
again  important numbers speedup factors execution
queries  speedup factors query execution always increase increasing depth

   

fiimproving efficiency ilp query packs

level
 
 
 
 
 
 
 
 
 

packs
packs ilprolog
total
exec
total
exec
    
    
    
    
    
    
    
    
     
           
    
            
     
     
                    
     
                    
     
                    
     
                    
     
                      
     

speedup ratio
net
exec
         
         
         
         
         
         
         
         
         

table    results warmr mutagenesis dataset using small language 

level
 
 
 
 
 
 

packs
packs ilprolog
total
exec
total
exec
    
    
    
    
      
     
     
     
                    
     
                      
     
                       
     
                        
      

speedup ratio
net
exec
         
         
         
         
         
         

table    results warmr mutagenesis dataset using medium language 

level
 
 
 

packs
packs ilprolog
total
exec
total
exec
    
    
    
    
      
             
     
                        
      

speedup ratio
net
exec
         
         
         

table    results warmr mutagenesis dataset using large language 

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
level
 
 
 
 
 
 
 
 
 
  

packs
total
exec
    
    
    
    
    
    
          
           
           
            
            
            
            
table   

packs ilprolog
total
exec
    
    
    
    
    
    
    
    
     
    
     
     
     
     
      
     
      
     
      
     

warmr

speedup ratio
net
exec
         
         
         
         
         
         
         
         
         
         

results bongard 

packs  contrast tilde larger packs yielded higher speedups  first sight
found surprising  however becomes less following observation made 
refining pack new pack adding level  warmr prunes away branches
lead infrequent queries  thus two effects adding level pack 
one widening pack lowest level  at least first levels  new
pack typically leaves previous one   second narrowing
pack whole  because pruning   since speedup obtained using packs largely
depends branching factor pack  speedup factors expected decrease
narrowing effect stronger widening at the bottom effect 
seen  e g  small mutagenesis experiment  deepest levels queries
becoming less frequent  mutagenesis experiment medium size language 
query execution speedup factors larger number queries increases much faster 
mutagenesis experiment large language  total speedup large 
language generates many queries time consuming part becomes
administration storage memory  packs version much faster stores
queries trees  requiring significantly less memory 

    comparison engines
implementing new special purpose prolog engine  different already existing ones 
carries risk  given level sophistication popular prolog engines  useful check
whether new engine performs comparably existing engines  least
tasks consideration here  eciency gain obtained query pack execution
offset less ecient implementation engine itself 
originally tilde warmr systems implemented masterprolog 
attempt allow run platforms  parts systems reimplemented kind  generic  prolog implementations specific prolog engines  sicstus  ilprolog  easily derived  the low level standardisation
prolog made necessary   given situation  two questions answered 

   

fiimproving efficiency ilp query packs
data set
la
bongard       
bongard       
bongard       
bongard       
bongard       
bongard       
bongard       
bongard       
bongard       
table   

masterprolog ilprolog original  ilprolog packs 
   
    
  
    
    
   
   
    
  

    
    
  
    
    
   
   
    
  

    
   
  
    
    
   
   
   
   

compared engines  times seconds  several data sets
lookahead settings 

ilprolog

 a  move masterprolog prolog engines uence performance
negative way   b  performance loss  any  reduce performance improvements due use packs 
tilde warmr tuned fast execution masterprolog ilprolog sicstus  makes comparison latter unfair  therefore
report former   engines  table   shows results  confirm
ilprolog competitive state of the art prolog engines 

    summary experimental results
experiments confirm  a  query pack execution much ecient
executing many highly similar queries separately   b  existing ilp systems  we use tilde
warmr examples  use mechanism advantage  achieving significant
speedups  c  although new prolog engine needed achieve this  current state
development engine respect execution speed compete
state of the art engines  further  experiments consistent complexity
analysis execution time packs 
   related work

re implementation tilde related work mehta et al        
first describe  examples outer loop  strategy decision tree induction 
query pack execution mechanism  described prolog execution point view 
seen first order counterpart apriori s mechanism counting item sets
 agrawal et al         
lines work eciency improvements ilp involves stochastic methods
trade certain amount optimality eciency by  e g   evaluating clauses
sample data set instead full data set  srinivasan         exploring clause
search space random fashion  srinivasan         stochastically testing whether

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
query succeeds example  sebag   rouveirol         first entirely
orthogonal query pack execution easily combined it 
idea optimising sets queries instead individual queries existed
database community  typical context considered earlier research
multi query optimisation  e g   sellis        database system needs
handle disjunctions conjunctive queries  server may receive many queries
different clients brief time interval  several queries expected compute
intermediary relations  may ecient materialise relations
instead recomputed query  data mining provides sense new
context multi query optimisation  multi query optimisation approach
time easier  the similarities among queries systematic  one need
look them  promising  given huge number queries may
generated once  
tsur et al         describe algorithm ecient execution so called query ocks
context  query pack execution mechanism  query ock execution mechanism inspired extent apriori set deductive database setting 
main difference query packs query ocks described tsur et al 
       query packs hierarchically structured queries pack
structurally less similar queries ock   a ock represented single query
placeholders constants  equal set queries obtained
instantiating placeholders constants  flocks could used applications
consider here  
dekeyser paredaens        describe work multi query optimisation context
relational databases  consider tree like structures multiple queries
combined  main difference trees rooted one single table
queries select tuples  whereas queries correspond joins multiple tables  further 
dekeyser paredaens define cost measure trees well operators map trees
onto semantically equivalent  but less costly  trees  whereas considered
creation packs ecient top down execution mechanism them  combining
approaches seems interesting topic research 
finally  optimisation techniques ilp proposed exploit results
program analysis  santos costa et al         blockeel et al         propositional
data mining technology  blockeel et al          complementary pack
execution optimisation  especially approach blockeel et al         easily
combined pack mechanism  techniques discussed santos costa et al 
       blockeel et al         involve optimisations single query execution 
extent upgraded pack setting  future work 
   conclusions

lot redundancy computations performed ilp systems 
paper identified source redundancy proposed method avoiding it 
execution query packs  discussed query pack execution incorporated
ilp systems  query pack execution mechanism implemented new
prolog system called ilprolog dedicated data mining tasks  two ilp systems

   

fiimproving efficiency ilp query packs
re implemented make use mechanism  experimentally evaluated
re implementations  results experiments confirm large speedups
may obtained way  conjecture query pack execution mechanism
incorporated ilp systems similar speedups expected 
problem setting query pack execution introduced general 
allows technique used kind task many queries executed
data  long queries organised hierarchy 
future work includes improvements ilprolog engine implementation techniques increase suitability engine handle large data sets 
best case one might hope combine techniques known database optimisation
program analysis pack execution mechanism improve speed
ilp systems 

acknowledgements
hendrik blockeel post doctoral fellow fund scientific research  fwo 
flanders  jan ramon funded flemish institute promotion scientific
research industry  iwt   henk vandecasteele funded part fwo project
g           query languages database mining   authors thank luc de raedt
uence work  ashwin srinivasan suggesting term  query packs  
anonymous reviewers useful comments  kurt driessens proofreading
text  work motivated part esprit project        aladin 
appendix a  preparing query meta interpreter

note following preprocessor assumes pack form a   b   c
e  f g   h j   already transformed form   or   b 
or  c d e     f   g  or  h i j      
preprocess  a b   a newb  prevnode nodenr  leafnr  branchnr nodenr  leafnr       
preprocess b newb prevnode nodenr  leafnr  branchnr nodenr  leafnr   
preprocess or querys  or nquerys prevnode nodenr  branchnr length  
prevnode nodenr  leafnr  branchnr  nodenr  leafnr       
nodenr  nodenr      
preprocessbranches querys nquerys nodenr  nodenr  leafnr  
  nodenr  leafnr  length  
preprocess a  a leaf prevnode branchnr leafnr    
prevnode nodenr  leafnr   branchnr nodenr  leafnr   leafnr  leafnr      
preprocessbranches         nodenr leafnr branchnr  nodenr leafnr branchnr  
preprocessbranches  queryjquerys   newqueryjnewquerys  prevnode 
nodenr  leafnr  branchnr  nodenr  leafnr  length  preprocess query newquery 
prevnode nodenr  leafnr  branchnr  nodenr  leafnr   
branchnr  branchnr     
preprocessbranches querys newquerys  prevnode 
nodenr  leafnr  branchnr   nodenr  leafnr  length  

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele

references

agrawal  r   mannila  h   srikant  r   toivonen  h     verkamo  a          fast discovery
association rules  fayyad  u   piatetsky shapiro  g   smyth  p     uthurusamy 
r   eds    advances knowledge discovery data mining  pp           mit
press 
at kaci  h          warren s abstract machine  tutorial reconstruction  mit
press  cambridge  massachusetts 
http   www isg sfu ca  hak documents wam html 
blockeel  h          top down induction first order logical decision trees  ph d  thesis 
department computer science  katholieke universiteit leuven 
http   www cs kuleuven ac be  ml ps blockeel   phd ps gz 
blockeel  h     de raedt  l          lookahead discretization ilp  proceedings
seventh international workshop inductive logic programming  vol      
lecture notes artificial intelligence  pp         springer verlag 
blockeel  h     de raedt  l          top down induction first order logical decision trees 
artificial intelligence                     
blockeel  h   de raedt  l   jacobs  n     demoen  b          scaling inductive logic programming learning interpretations  data mining knowledge discovery 
             
blockeel  h   de raedt  l     ramon  j          top down induction clustering trees 
proceedings   th international conference machine learning  pp        
http   www cs kuleuven ac be  ml ps ml      ps 
blockeel  h   demoen  b   janssens  g   vandecasteele  h     van laer  w          two
advanced transformations improving eciency ilp system    th
international conference inductive logic programming  work in progress reports 
pp         london  uk 
bongard  m          pattern recognition  spartan books 
bratko  i          prolog programming artificial intelligence  addison wesley  wokingham  england   nd edition 
breiman  l   friedman  j   olshen  r     stone  c          classification regression
trees  wadsworth  belmont 
chen  w     warren  d  s          tabled evaluation delaying general logic programs  journal acm                 http   www cs sunysb edu  sbprolog 
clark  p     niblett  t          cn  algorithm  machine learning                 
de raedt  l          logical settings concept learning  artificial intelligence          
    
de raedt  l     dehaspe  l          clausal discovery  machine learning             

   

fiimproving efficiency ilp query packs
de raedt  l     dzeroski  s          first order jk clausal theories pac learnable 
artificial intelligence              
de raedt  l     van laer  w          inductive constraint logic  jantke  k  p   shinohara  t     zeugmann  t   eds    proceedings sixth international workshop
algorithmic learning theory  vol      lecture notes artificial intelligence  pp 
       springer verlag 
dehaspe  l     toivonen  h          discovery frequent datalog patterns  data mining
knowledge discovery              
dekeyser  s     paredaens  j          query pack trees multi query optimization  tech 
rep         university antwerp  ftp   wins uia ac be pub dekeyser qpt ps 
demoen  b   janssens  g     vandecasteele  h          executing query flocks ilp 
etalle  s   ed    proceedings eleventh benelux workshop logic programming 
pp        maastricht  netherlands     pages 
kramer  s          structural regression trees  proceedings thirteenth national
conference artificial intelligence  pp           cambridge menlo park  aaai
press mit press 
mehta  m   agrawal  r     rissanen  j          sliq  fast scalable classifier data
mining  proceedings fifth international conference extending database
technology 
muggleton  s          inverse entailment progol  new generation computing  special
issue inductive logic programming                    
muggleton  s     de raedt  l          inductive logic programming   theory methods 
journal logic programming                 
quinlan  j  r       a   c     programs machine learning  morgan kaufmann series
machine learning  morgan kaufmann 
quinlan  j       b   foil  midterm report  brazdil  p   ed    proceedings  th
european conference machine learning  lecture notes artificial intelligence 
springer verlag 
santos costa  v   srinivasan  a     camacho  r          note two simple transformations improving eciency ilp system  proceedings tenth
international conference inductive logic programming  vol       lecture notes
artificial intelligence  pp           springer verlag 
sebag  m     rouveirol  c          tractable induction classification first order
logic via stochastic matching  proceedings   th international joint conference artificial intelligence  morgan kaufmann 
sellis  t          multiple query optimization  acm transactions database systems 
              
srinivasan  a          study two sampling methods analysing large datasets
ilp  data mining knowledge discovery                
srinivasan  a          study two probabilistic methods searching large spaces
ilp  tech  rep  prg tr        oxford university computing laboratory 

   

fiblockeel  dehaspe  demoen  janssens  ramon    vandecasteele
srinivasan  a   muggleton  s     king  r          comparing use background knowledge inductive logic programming systems  de raedt  l   ed    proceedings
fifth international workshop inductive logic programming 
tsur  d   ullman  j   abiteboul  s   clifton  c   motwani  r   nestorov  s     rosenthal  a 
        query ocks  generalization association rule mining  proceedings
acm sigmod international conference management data  sigmod     
vol       acm sigmod record  pp        new york  acm press 

   


