journal artificial intelligence research                  

submitted       published     

planning rewriting
jose luis ambite
craig a  knoblock

ambite isi edu
knoblock isi edu

information sciences institute department computer science 
university southern california 
     admiralty way  marina del rey  ca        usa

abstract
domain independent planning hard combinatorial problem  taking account
plan quality makes task even difficult  article introduces planning rewriting  pbr   new paradigm efficient high quality domain independent planning  pbr
exploits declarative plan rewriting rules efficient local search techniques transform
easy to generate  possibly suboptimal  initial plan high quality plan  addition addressing issues planning efficiency plan quality  framework offers
new anytime planning algorithm  implemented planner applied
several existing domains  experimental results show pbr approach provides
significant savings planning effort generating high quality plans 

   introduction

planning process generating network actions  plan  achieves desired
goal initial state world  many problems practical importance
cast planning problems  instead crafting individual planner solve specific
problem  long line research focused constructing domain independent planning
algorithms  domain independent planning accepts input  descriptions
initial state goal particular problem instance  declarative domain
specification  is  set actions change properties state  domainindependent planning makes development planning algorithms efficient  allows
software domain reuse  facilitates principled extension capabilities
planner  unfortunately  domain independent planning  like planning problems 
computationally hard  bylander        erol  nau    subrahmanian        backstrom
  nebel         given complexity limitations  previous work domainindependent planning focused finding solution plan without careful consideration
plan quality  usually simple cost functions  length plan 
used  however  many practical problems plan quality crucial  paper
present new planning paradigm  planning rewriting  pbr   addresses
planning efficiency plan quality maintaining benefits domain independence 
framework fully implemented present empirical results several planning
domains 
c
    
ai access foundation morgan kaufmann publishers  rights reserved 

fiambite   knoblock

    solution approach
two observations guided present work  first one two sources
complexity planning 
satisfiability  difficulty finding solution planning problem  regardless
quality solution  
optimization  difficulty finding optimal solution given cost metric 
given domain  facets may contribute differently complexity
planning  particular  many domains satisfiability problem
relatively easy complexity dominated optimization problem  example 
may many plans would solve problem  finding one efficient
practice  cost solution varies greatly  thus finding optimal one
computationally hard  refer domains optimization domains 
optimization domains great practical interest query optimization manufacturing
process planning  
second observation planning problems great deal structure  plans
type graph strong semantics  determined general properties
planning particular domain specification  structure
exploited improve efficiency planning process 
prompted previous observations  developed novel approach efficient
planning optimization domains  planning rewriting  pbr   framework works
two phases 
   generate initial solution plan  recall optimization domains efficient 
however  quality initial plan may far optimal 
   iteratively rewrite current solution plan improving quality using set declarative plan rewriting rules  either acceptable solution found resource
limit reached 
motivation  consider optimization domains distributed query processing
manufacturing process planning   distributed query processing  yu   chang        involves generating plan efficiently computes user query data resides
different nodes network  query plan composed data retrieval actions diverse
information sources operations data  such relational algebra 
join  selection  etc   systems use general purpose planner solve problem
 knoblock         domain easy construct initial plan  any parse
query suffices  transform using gradient descent search reduce cost 
plan transformations exploit commutative associative properties  relational algebra  operators  facts group operators executed
together remote information source generally efficient so  figure  
   interestingly  one widely studied planning domains  blocks world  property 
   domains analyzed section    graphical examples rewriting process appear figure   
query planning figure    manufacturing process planning  reader may want consult
figures even details explained point 

   

fiplanning rewriting

shows sample transformations  simple join swap transforms two join trees according commutative associative properties join operator  remote join eval
executes join two subqueries remote source  source able so 
simple join swap 
retrieve q   source      retrieve q   source     retrieve q   source   
retrieve q   source      retrieve q   source     retrieve q   source   
remote join eval 
 retrieve q   source    retrieve q   source   capability source  join 
retrieve q    q   source 
figure    transformations query planning
manufacturing  problem find economical plan machining operations
implement desired features design  feature based approach  nau  gupta 
  regli         possible enumerate actions involved building piece
analyzing cad model  difficult find ordering operations
setups optimize machining cost  however  similar query planning  possible
incrementally transform  possibly inefficient  initial plan  often  order actions
affect design goal  quality plan  thus many actions commute 
also  important minimize number setups fixing piece machine
rather time consuming operation  interestingly  grouping machining operations
setup analogous evaluating subquery remote information source 
suggested examples  many problems combine characteristics traditional planning satisfiability quality optimization  domains
often exist natural transformations may used efficiently obtain high quality plans
iterative rewriting  planning rewriting provides domain independent framework
allows plan transformations conveniently specified declarative plan rewriting
rules facilitates exploration efficient  local  search techniques 
    advantages planning rewriting
several advantages planning style pbr introduces  first  pbr
declarative domain independent framework  facilitates specification planning
domains  evolution  principled extension planner new capabilities  moreover  declarative rewriting rule language provides natural convenient
mechanism specify complex plan transformations 
second  pbr accepts sophisticated quality measures operates complete
plans  previous planning approaches either addressed quality issues
simple quality measures  number steps plan  partial
plans available planning process  general  partial plan cannot offer
enough information evaluate complex cost metric and or guide planning search
effectively 
   

fiambite   knoblock

third  pbr use local search methods remarkably successful scaling
large problems  aarts   lenstra          using local search techniques  high quality
plans efficiently generated  fourth  search occurs space solution plans 
generally much smaller space partial plans explored planners based
refinement search 
fifth  framework yields anytime planning algorithm  dean   boddy        
planner always solution offer point computation  modulo initial
plan generation needs fast   clear advantage traditional planning
approaches  must run completion producing solution  thus  system
allows possibility trading planning effort plan quality  example  query
planning quality plan execution time may make sense keep
planning cost current plan small enough  even cheaper one could
found  discussion concrete examples advantages given throughout
following sections 
    contributions
main contribution paper development planning rewriting  novel
domain independent paradigm efficient high quality planning  first  define language declarative plan rewriting rules present algorithms domain independent
plan rewriting  rewriting rules provide natural convenient mechanism specify complex plan transformations  techniques plan rewriting generalize traditional
graph rewriting  graph rewriting rules need specify rule consequent complete
embedding replacement subplan  introduce novel class partially specified
plan rewriting rules relax restriction  taking advantage semantics
planning  embedding automatically computed  single partially specified rule
concisely represent great number fully specified rules  rules easier
write understand fully specified counterparts  second  adapt local
search techniques  gradient descent  efficiently explore space plan rewritings optimize plan quality  finally  demonstrate empirically usefulness
pbr approach several planning domains 
    outline
remainder paper structured follows  section   provides background
planning  rewriting  local search  fields upon pbr builds  section  
presents basic framework planning rewriting domain independent approach
local search  section describes detail plan rewriting declarative rewriting rule
language  section   describes several application domains shows experimental results
comparing pbr planners  section   reviews related work  finally  section  
summarizes contributions paper discusses future work 
   although space rewritings explored complete search methods  application domains
analyzed search space large experience suggests local search
appropriate  however  extent complete search methods useful planning rewriting
framework remains open issue  paper focus local search 

   

fiplanning rewriting

   preliminaries  planning  rewriting  local search
framework planning rewriting arises confluence several areas research  namely  artificial intelligence planning algorithms  graph rewriting  local search
techniques  section give background areas explain
relate pbr 
    ai planning
assume reader familiar classical ai planning  section
highlight main concepts relate pbr framework  weld             
russell   norvig        provide excellent introductions ai planning 
pbr follows classical ai planning representation actions transform state 
state set ground propositions understood conjunctive formula  pbr 
ai planners  follows closed world assumption  is  proposition explicitly
mentioned state assumed false  similarly negation failure semantics
logic programming  propositions state modified  asserted negated 
actions domain  actions domain specified operator schemas 
operator schema consists two logical formulas  precondition  defines
conditions operator may applied  postcondition  specifies
changes state effected operator  propositions mentioned
postcondition assumed change application operator  type
representation initially introduced strips system  fikes   nilsson        
language operators pbr sage  knoblock            b  
extension ucpop  penberthy   weld         operator description
language pbr accepts arbitrary function free first order formulas preconditions
operators  conditional universally quantified effects  but disjunctive effects  
addition  operators specify resources use  sage pbr address unit
non consumable resources  resources fully acquired operator
completion action released reused 
figure   shows sample operator schema specification simple blocks world
domain   representation accepted pbr  domain two actions  stack 
puts one block top another  unstack  places block table  
state described two predicates   on  x  y   denotes block  x top
another block  y  or table    clear  x  denotes  x block
block top it 
example complex operator process manufacturing domain shown
figure    operator describes behavior punch  machine used
make holes parts  punch operation requires available clamp
machine orientation width hole appropriate using punch 
executing operation part desired hole
   illustrate basic concepts planning  use examples simple blocks world domain 
reader find real world application planning techniques  query planning  section     
    stack  x  y  z  read stack block  x top block  y  z 
 unstack  x  y  read lift block  x top block  y put table 
   convention  variables preceded question mark symbol       x 

   

fiambite   knoblock

 define  operator stack 
 parameters   x  y  z 
 precondition
  and  on  x  z   clear  x   clear  y 
  neq  y  z    neq  x  z    neq  x  y 
  neq  x table    neq  y table  
 effect   and  on  x  y    not  on  x  z  
 clear  z    not  clear  y    

 define  operator unstack 
 parameters   x  y 
 precondition
  and  on  x  y   clear  x    neq  x  y 
  neq  x table    neq  y table  
 effect   and  on  x table   clear  y 
  not  on  x  y    

figure    blocks world operators
 define  operator punch 
 parameters   x  width  orientation 
 resources   machine punch   is object  x  
 precondition   and  is object  x 
 is punchable  x  width  orientation 
 has clamp punch  
 effect   and   forall   surf    when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 has hole  x  width  orientation   

figure    manufacturing operator
rough surface   note specification resources slot  declaring  machine punch 
resource enforces operator use punch concurrently  similarly 
declaring part   is object  x   resource means one operation time
performed object  examples operator specifications appear
figures            
plan pbr represented graph  spirit partial order causal link planners  pocl  ucpop  penberthy   weld         nodes plan steps 
is  instantiated domain operators  edges specify temporal ordering relation among
steps imposed causal links ordering constraints  causal link record
proposition established plan  record contains proposition  sometimes
called condition   producer step  consumer step  producer step
plan asserts proposition  is  proposition one effects  consumer
step needs proposition  is  proposition one preconditions 
causality  producer must precede consumer 
ordering constraints needed ensure plan consistent  arise
resolving operator threats resource conflicts  operator threat occurs
step negates condition causal link ordered producer
consumer steps causal link  prevent situation  makes plan inconsistent  pocl planners order threatening step either producer  demotion 
consumer  promotion  posting appropriate ordering constraints 
   operator uses idiom combining universal quantification negated conditional effects enforce
attribute surface condition part single valued 

   

fiplanning rewriting

unit non consumable resources considered  steps requiring resource
sequentially ordered  chain ordering constraints appear plan 
example plan blocks world using graph representation given
figure    plan transforms initial state consisting two towers  c a 
table  b d  table  final state consisting one tower  b  b c 
c d  table  initial state represented step   preconditions
propositions initial state postconditions  similarly  goal state
represented step goal postconditions goal formula precondition 
plan achieves goal using two unstack steps disassemble two initial towers
using three stack steps build desired tower  causal links shown
solid arrows ordering constraints dashed arrows  additional effects step
used causal links  sometimes called side effects  shown step
pointed thin dashed arrows  negated propositions preceded   note need
ordering link steps    stack b c table      stack a b table  
step   could ordered concurrently step    would negate precondition
clear b  step    making plan inconsistent  similar situation occurs steps
    another ordering link introduced 

clear b 

causal link
ordering constraint
side effect

on a table 
on c a 

clear a 

  stack a b table 

  unstack c a 
on c table 

on c a 
clear c 
on d table 

on a table 
clear b 

clear c 

 
clear b 

on b table 
on a b 
clear c 
  stack b c table 
on b c 
on c d 
  stack c table 
goal
clear d 
on c table 
clear d 


on b d 

b

on b table 
  unstack b d 
on b d 
clear b 

c

b

c







clear c 
initial state

goal state

figure    sample plan blocks world domain

    rewriting
plan rewriting pbr related term graph rewriting  term rewriting originated
context equational theories reduction normal forms effective way
perform deduction  avenhaus   madlener        baader   nipkow         rewrite
system specified set rules  rule corresponds preferred direction
equivalence theorem  main issue term rewriting systems convergence  is 
two arbitrary terms rewritten finite number steps unique normal form 
pbr two plans considered equivalent solutions problem 
   

fiambite   knoblock

although may differ cost operators  that is  equivalent
respect satisfiability introduced above   however  interested using
rewriting rules prove equivalence  instead  framework uses rewriting
rules explore space solution plans 
graph rewriting  akin term rewriting  refers process replacing subgraph
given graph  conditions satisfied  another subgraph  graph rewriting
found broad applications  high level programming languages  database
data description query languages  etc  schurr        presents good survey 
main drawback general graph rewriting complexity  graph matching
reduced  sub graph isomorphism problem np complete  nevertheless 
restrictions graph rewriting performed efficiently  dorr        
planning rewriting adapts general graph rewriting semantics partial order
planning strips like operator representation  plan rewriting rule pbr specifies
replacement  certain conditions  subplan another subplan  however 
formalism rule need specify completely detailed embedding
consequent graph rewriting systems  consistent embeddings rule consequent 
generation edges necessary  automatically computed according
semantics partial order planning  algorithm ensures rewritten plans always
remain valid  section         plan rewriting rules intended explore space
solution plans reach high quality plans 
    local search combinatorial optimization
pbr inspired local search techniques used combinatorial optimization 
instance combinatorial optimization problem consists set feasible solutions
cost function solutions  problem consists finding solution optimal
cost among feasible solutions  generally problems addressed computationally
intractable  thus approximation algorithms used  one class approximation
algorithms surprisingly successful spite simplicity local search
methods  aarts   lenstra        papadimitriou   steiglitz        
local search based concept neighborhood  neighborhood solution
p set solutions sense close p  example
easily computed p share significant amount structure p 
neighborhood generating function may  may not  able generate optimal
solution  neighborhood function generate global optima  starting
initial feasible point  called exact  papadimitriou   steiglitz        page     
local search seen walk directed graph whose vertices solutions
points whose arcs connect neighboring points  neighborhood generating function
determines properties graph  particular  graph disconnected 
neighborhood exact since exist feasible points would lead local optima
global optima  pbr points solution plans neighbors plan
plans generated application set declarative plan rewriting rules 
basic version local search iterative improvement  iterative improvement starts
initial solution searches neighborhood solution lower cost solution  solution found  replaces current solution search continues 
   

fiplanning rewriting

otherwise  algorithm returns locally optimal solution  figure   a  shows graphical
depiction basic iterative improvement  several variations basic algorithm  first improvement generates neighborhood incrementally selects first
solution better cost current one  best improvement generates complete
neighborhood selects best solution within neighborhood 

neighborhood

local optima

local optima

 a  basic iterative improvement

 b  variable depth search

figure    local search
basic iterative improvement obtains local optima  necessarily global optimum 
one way improve quality solution restart search several initial points choose best local optima reached them  advanced
algorithms  variable depth search  simulated annealing tabu search  attempt
minimize probability stuck low quality local optimum 
variable depth search based applying sequence steps opposed one
step iteration  moreover  length sequence may change iteration
iteration  way system overcomes small cost increases eventually lead
strong cost reductions  figure   b  shows graphical depiction variable depth search 
simulated annealing  kirkpatrick  gelatt    vecchi        selects next point randomly  lower cost solution chosen  selected  solution higher cost
chosen  still selected probability  probability decreased algorithm progresses  analogously temperature physical annealing   function
governs behavior acceptance probability called cooling schedule 
proven simulated annealing converges asymptotically optimal solution  unfortunately  convergence requires exponential time  so  practice  simulated annealing
used faster cooling schedules  not guaranteed converge optimal  thus
behaves approximation algorithm 
tabu search  glover        accept cost increasing neighbors  next solution
randomly chosen legal neighbor even cost worse current solution 
neighbor legal limited size tabu list  dynamically updated tabu list
prevents solution points considered period time  intuition
decide consider solution higher cost least lie
unexplored part space  mechanism forces exploration solution space
local minima 
finally  stress appeal local search relies simplicity good
average case behavior  could expected  number negative worst case results  example  traveling salesman problem known exact neighborhoods 
   

fiambite   knoblock

depend problem instance  must exponential size  savage  weiner 
  bagchi         moreover  improving move neighborhoods cannot found
polynomial time unless p   np  papadimitriou   steiglitz         nevertheless  best
approximation algorithm traveling salesman problem local search algorithm
 johnson        

   planning rewriting local search
planning rewriting viewed domain independent framework local search 
pbr accepts arbitrary domain specifications  declarative plan rewriting rules generate
neighborhood plan  arbitrary  local  search methods  therefore  assuming
given combinatorial problem encoded planning problem  pbr take
input experiment different neighborhoods search methods 
describe main issues planning rewriting instantiation
local search idea typical combinatorial optimization algorithms 
selection initial feasible point  pbr phase consists efficiently generating
initial solution plan 
generation local neighborhood   pbr neighborhood plan set
plans obtained application set declarative plan rewriting rules 
cost function minimize  measure plan quality planner
optimizing  plan quality function range simple domain independent
cost metric  number steps  complex domain specific ones 
query evaluation cost total manufacturing time set parts 
selection next point  pbr  consists deciding solution plan
consider next  choice determines global space explored
significant impact efficiency planning  variety local search strategies
used pbr  steepest descent  simulated annealing  etc  search
method yields best results may domain problem specific 
following subsections expand issues  first  discuss use
declarative rewriting rules generate local neighborhood plan  constitutes
main contribution paper  present syntax semantics rules 
plan rewriting algorithm  formal properties complexity analysis plan rewriting 
rule taxonomy  second  address selection next plan associated
search techniques plan optimization  third  discuss measures plan quality 
finally  describe approaches initial plan generation 
    local neighborhood generation  plan rewriting rules
neighborhood solution plan generated application set declarative
plan rewriting rules  rules embody domain specific knowledge transformations solution plan likely result higher quality solutions  application
given rule may produce one several rewritten plans fail produce plan 
rewritten plans guaranteed valid solutions  first  describe syntax
   

fiplanning rewriting

semantics rules  second  introduce two approaches rule specification  third 
present rewriting algorithm  formal properties  complexity plan rewriting 
finally  present taxonomy plan rewriting rules 
      plan rewriting rules  syntax semantics
first  introduce rule syntax semantics examples  then  provide
formal description  plan rewriting rule three components      antecedent   if
field  specifies subplan matched       replace field identifies subplan
going removed  subset steps links antecedent       with field
specifies replacement subplan  figure   shows two rewriting rules blocks world
domain introduced figure    intuitively  rule avoid move twice says that  whenever
possible  better stack block top another directly  rather first moving
table  situation occurs plans generated simple algorithm first
puts blocks table build desired towers  plan figure   
rule avoid undo says actions moving block table back
original position cancel could removed plan 
 define rule  name avoid move twice
 if   operators    n   unstack  b   b   
  n   stack  b   b  table   
 links   n   on  b  table   n  
 constraints   possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators   n   stack  b   b   b     

 define rule  name avoid undo
 if   operators
   n   unstack  b   b   
  n   stack  b   b  table   
 constraints
  possibly adjacent  n   n   
 replace   operators   n   n   
 with nil  

figure    blocks world rewriting rules
rule manufacturing domain  minton      b  shown figure   
domain additional rewriting rules described detail section      rule states
plan includes two consecutive punching operations order make holes two
different objects  another machine  drill press  available  plan quality may
improved replacing one punch operations drill press  domain
plan quality  parallel  time manufacture parts  rule helps parallelize
plan thus improve plan quality 
 define rule  name punch by drill press
 if   operators    n   punch  o   width   orientation   
  n   punch  o   width   orientation    
 links   n   n  
 constraints    neq  o   o  
 possibly adjacent  n   n    
 replace   operators   n   
 with   operators   n   drill press  o   width   orientation     

figure    manufacturing process planning rewriting rule
   

fiambite   knoblock

plan rewriting rule syntax described bnf specification given figure   
bnf generates rules follow template shown figure    next  describe
semantics three components rule   if   replace   with fields  detail 
 rule       define rule  name  name 
 if   graph spec with constraints  
 replace   graph spec  
 with   graph spec   
 graph spec with constraints        graph spec  
  constraints   constraints   
 graph spec        operators   nodes   
  links   edges      nil
 nodes       node     node   nodes 
 edges       edge     edge   edges 
 constraints       constraint     constraint   constraints 
 node        node var    node predicate     resource  
 edge        node var   node var    
  node var   edge predicate   node var    
  node var   threat  node var  
 constraint       interpreted predicate   
  neq  pred var   pred var  
 node var   pred var           optional      alternative

figure    bnf rewriting rules

 define rule  name  rule name 
 if   operators    nv   np    resource       
 links    nv    lp   threat   nv       
 constraints   ip       
 replace   operators   nv      
 links    nv    lp   threat   nv        
 with   operators    nv   np    resource       
 links    nv    lp    nv         
 nv    node variable   np    node predicate       optional
 lp    causal link predicate   ip    interpreted predicate 

    alternative

figure    rewriting rule template
antecedent   if field  specifies subplan matched current
plan  graph structure subplan defined  operators  links fields 
 operators field specifies nodes  operators  graph  links field
specifies edges  causal ordering links   finally   constraints field specifies
set constraints operators links must satisfy 
 operators field consists list node variable node predicate pairs 
step number steps plan match given node predicate would
correspondingly bound node variable  node predicate interpreted
two ways  step action  resource used step  example  node
specification   n   stack  b   b  table   antecedent avoid move twice
figure   shows node predicate denotes step action  node specification
collect tuples  composed step number  n  blocks  b   b   obtained matching
steps whose action stack block  b  table moved top
another block  b   node specification applied plan figure   would result
   

fiplanning rewriting

three matches     c d      b c      b   variables   n   b   b   respectively 
optional keyword  resource present  node predicate interpreted one
resources used plan step  opposed describing step action  example
rule matches resources operator given figure     node
specification   n   machine  x   resource  match steps use resource
type machine collect pairs step number  n  machine object  x 
 define rule  name resource swap
 if   operators    n   machine  x   resource 
  n   machine  x   resource  
 links    n   threat  n    
 replace   links   n   n   
 with   links   n   n    

figure     resource swap rewriting rule
 links field consists list link specifications  language admits link
specifications three types  first type specified pair node variables 
example    n   n   figure    specification matches temporal ordering link
plan  regardless imposed causal links resolution threats 
second type link specification matches causal links  causal links specified
triples composed producer step node variable  edge predicate  consumer
step node variable  semantics causal link producer step asserts
effects predicate  turn needed preconditions consumer step 
example  link specification   n   on  b  table   n   figure   matches steps  n 
put block  b  table steps  n  subsequently pick block 
link specification applied plan figure   would result matches     c   
   b     variables   n   b   n   
third type link specification matches ordering links originating resolution
threats  coming either resource conflicts operator conflicts   links
selected using keyword  threat place condition  example 
resource swap rule figure    uses link specification   n   threat  n   ensure
steps ordered involved threat situation matched 
helps identify critical steps reasons  i e 
causal links  order  therefore rule may attempt reorder them 
useful plan quality depends degree parallelism plan
different ordering may help parallelize plan  recall threats solved either
promotion demotion  reverse ordering may produce valid plan 
often case conflict among resources rule figure    
interpreted predicates  built in user defined  specified  constraints
field  predicates implemented programmatically opposed obtained
matching components plan  built in predicates currently implemented
inequality    neq   comparison              arithmetic           predicates 
user add arbitrary predicates corresponding programmatic implementa   equality denoted sharing variables rule specification 

   

fiambite   knoblock

tions  interpreted predicates may act filters previous variables introduce
new variables  and compute new values them   example  user defined predicate
possibly adjacent rules figure   ensures steps consecutive
linearization plan   plan figure   extension possibly adjacent
predicate is                                                             goal  
user easily add interpreted predicates including function definition
implements predicate  rule matching algorithm passes arguments calls
functions appropriate  current plan passed default first argument
interpreted predicates order provide context computation predicate
 but ignored   figure    show skeleton  lisp  implementation
possibly adjacent less than interpreted predicates 
 defun possibly adjacent  plan node  node  
 not  necessarily not adjacent
node 
node 
   accesses current plan
 plan ordering plan   

 defun less than  plan n  n  
 declare  ignore plan  
 when  and  numberp n    numberp n   
 if    n  n  
 nil     true
nil       false

figure     sample implementation interpreted predicates
consequent composed  replace  with fields   replace field
specifies subplan going removed plan  subset
steps links identified antecedent  step removed  links refer
step removed   with field specifies replacement subplan 
see sections              replacement subplan need completely
specified  example   with field avoid move twice rule figure  
specifies addition stack step step embedded plan 
links rest plan automatically computed rewriting process 
      plan rewriting rules  full versus partial specification
pbr gives user total flexibility defining rewriting rules  section describe two
approaches guaranteeing rewriting rule specification preserves plan correctness 
is  produces valid rewritten plan applied valid plan 
full specification approach rule specifies steps links involved
rewriting  rule antecedent identifies anchoring points operators
consequent  embedding replacement subplan unambiguous results
valid plan  burden proving rule correct lies upon user automated
rule defining procedure  cf  section     kind rules ones typically used
graph rewriting systems  schurr        
partial specification approach rule defines operators links constitute gist plan transformation  rule prescribe precise
   interpreted predicate possibly adjacent makes link expression antecedent avoid move twice redundant  unstack puts block  b  table picked
stack operator  thus causal link   n   on  b  table   n   already implied  operators
 constraints specification could removed rule specification 

   

fiplanning rewriting

embedding replacement subplan  burden producing valid plan lies upon
system  pbr takes advantage semantics domain independent planning accept
relaxed rule specification  fill details  produce valid rewritten plan 
moreover  user free specify rules may necessarily able compute
rewriting plan matches antecedent necessary condition
checked antecedent  is  partially specified rule may overgeneral 
may seem undesirable  often rule may cover useful cases naturally
specified form  rule may fail rarely occurring plans  effort
defining matching complete specification may worthwhile  case 
plan rewriting algorithm ensures application rewriting rule either generates
valid plan fails produce plan  theorem    section        
example two approaches rule specification  consider figure   
shows avoid move twice full rule  fully specified version avoid move twice
rule  of figure    reprinted convenience   avoid move twice full rule
complex less natural specify avoid move twice  but  importantly 
avoid move twice full making commitments avoid move twice  particular  avoid move twice full fixes producer  clear  b    n   n 
 n  known valid candidate  general  several alternative producers
precondition replacement subplan  consequently many possible embeddings 
different fully specified rule needed capture embedding  number rules
grows exponentially permutations embeddings enumerated  however 
using partial specification approach express general plan transformation
single natural rule 
 define rule  name avoid move twice full
 if   operators    n   unstack  b   b   
  n   stack  b   b  table   
 links    n   clear  b    n  
  n   on  b   b    n  
  n   clear  b    n  
  n   on  b  table   n  
  n   clear  b    n  
  n   clear  b    n  
  n   on  b   b    n   
 constraints   possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators    n   stack  b   b   b    
 links    n   clear  b    n  
  n   clear  b    n  
  n   on  b   b    n  
  n   on  b   b    n     

 define rule  name avoid move twice
 if   operators
   n   unstack  b   b   
  n   stack  b   b  table   
 links   n   on  b  table   n  
 constraints
  possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators
  n   stack  b   b   b     

figure     fully specified versus partially specified rewriting rule
summary  main advantage full specification rules rewriting
performed efficiently embedding consequent already specified 
disadvantages number rules represent generic plan transformation
may large resulting rules quite lengthy  problems may decrease
   

fiambite   knoblock

performance match algorithm  also  rule specification error prone written
user  conversely  main advantage partial specification rules single
rule represent complex plan transformation naturally concisely  rule
cover large number plan structures even may occasionally fail  also  partial
specification rules much easier specify understand users system 
seen  pbr provides high degree flexibility defining plan rewriting rules 
      plan rewriting algorithm
section  first describe basic plan rewriting algorithm pbr  second 
prove algorithm sound discuss formal properties rewriting  finally 
discuss family algorithms plan rewriting depending parameters
language defining plan operators  specification language rewriting rules 
requirements search method 
plan rewriting algorithm shown figure     algorithm takes two inputs 
valid plan p   rewriting rule r    qm   pr   pc    qm antecedent query  pr
replaced subplan  pc replacement subplan   output valid rewritten
plan p     matching antecedent rewriting rule  qm   determines rule
applicable identifies steps links interest  line     matching seen
subgraph isomorphism antecedent subplan current plan  with
results filtered applying  constraints   however  take different approach 
pbr implements rule matching conjunctive query evaluation  implementation keeps
relational representation steps links current plan similar node
link specifications rewriting rules  example  database plan
figure   contains one table unstack steps schema   n   b   b   tuples
   c a     b d   another table causal links involving clear condition
schema   n   n   b  tuples      c        b        c        b        c        b     
  a       d   similar tables operator link types  match
process consists interpreting rule antecedent conjunctive query interpreted
predicates  executing query relational view plan structures 
running example  analyze application avoid move twice rule figure  
plan figure    matching rule antecedent identifies steps     
precisely  considering antecedent query  result single tuple    c   d 
variables   n   b   b   n   b   
choosing match work  line     algorithm instantiates subplan
specified  replace field  pr   according match  line    removes
instantiated subplan pir original plan p  line     edges incoming
emanating nodes replaced subplan removed  effects
replaced plan pir achieving remainder plan  p pir    usefuleffects pir  
achieved replacement subplan  or steps p pir    order
facilitate process  addflaws procedure records effects open conditions   
    pocl planners operate keeping track repairing flaws found partial plan  open conditions  operator threats  resource threats collectively called flaws  penberthy   weld        
addflaws f p  adds set flaws f plan structure p  

   

fiplanning rewriting

procedure rewriteplan
input  valid partial order plan p
rewriting rule r    qm   pr   pc    v ariables pr   v ariables qm  
output  valid rewritten partial order plan p    or failure 
      atch qm   p  
match rule antecedent qm   if field  p   result set substitutions
               variables qm  
     return failure
   choose match
   pir    pr
instantiate subplan removed pr  the  replace field  according  
   pri    addflaws usefuleffects pir    p pir  
remove instantiated subplan pir plan p add usefuleffects pir
open conditions  resulting plan pri incomplete 
   pic    pc
instantiate replacement subplan pc  the  with field  according  
   pci    addf laws p reconditions pic   f indt hreats pri pic    pri pic  
add instantiated replacement subplan pic pri   find new threats open
conditions add flaws  pci potentially incomplete  several flaws
need resolved 
   p      rp op  pci  
complete plan using partial order causal link planning algorithm  restricted
step reuse  step addition  order resolve threats open conditions 
rp op returns failure valid plan found 
   return p  
figure     plan rewriting algorithm
result partial plan pri  line     continuing example  figure    a  shows
plan resulting removing steps     plan figure   
finally  algorithm embeds instantiated replacement subplan pic remainder original plan  lines       rule completely specified  algorithm simply
adds  already instantiated  replacement subplan plan  work
necessary  rule partially specified  algorithm computes embeddings
replacement subplan remainder original plan three stages  first 
algorithm adds instantiated steps links replacement plan pic  line   
current partial plan pri  line     figure    b  shows state example
pic   new stack step      incorporated plan  note open conditions
 clear a  on c d   second  findthreats procedure computes possible threats 
operator threats resource conflicts  occurring pri pic partial plan  line    
example  threat situation clear c  proposition step     figure    b   threats preconditions replacement plan pic recorded
addflaws resulting partial plan pci   finally  algorithm completes plan using
rpop  partial order causal link planning procedure restricted reuse steps  i e  
   

fiambite   knoblock

step addition   line     rpop allows us support expressive operator language
flexibility computing one embeddings  one rewriting needed 
rpop stops first valid plan  otherwise  continues exhausting alternative ways satisfying open preconditions resolving conflicts  produces valid
rewritings  running example  one embedding possible resulting plan
figure    c   new stack step     produces  clear a  on c d  
preconditions satisfied  ordering       ensures plan valid 
rewriting algorithm figure    sound sense produces valid plan
input valid plan  outputs failure input plan cannot rewritten using
given rule  since elementary plan rewriting step sound  sequence rewritings
performed pbrs optimization search sound 
lemma    soundness rpop  partial order causal link  pocl  planning without
step addition  rp op   sound 
proof  pocl planning  precondition step plan achieved either
inserting new step snew reusing step sreuse already present current plan  the
steps effect unifies precondition   forbidding step addition decreases
set available steps used satisfy precondition  step found
rpop proceeds general pocl  since  pocl completion partial plan sound
 penberthy   weld         rp op sound   
theorem    soundness plan rewriting  rewriteplan  figure     produces
valid plan input p valid plan  outputs failure input plan cannot
rewritten using given rewriting rule r    qm   pr   pc   
proof  assume plan p solution planning problem goals g initial
state i  pocl planning  plan valid iff preconditions steps supported
causal links  the goals g preconditions goal step  initial state
conditions effects initial step   operator threatens causal link
 mcallester   rosenblitt        penberthy   weld        
rule r match plan p   algorithm trivially returns failure  line     assuming
match   removing p steps links specified pir  including
links causal ordering incoming outgoing steps pir    open
conditions exist resulting plan pri pir achieving  line    
adding instantiated replacement subplan pic introduces open conditions
partial plan  preconditions steps pic  line     sources
open conditions algorithm 
since plan p valid initially   operator and or resource  threats present
plan pci  line    caused removal subplan pir  line    addition
subplan pic  line     threats may occur operators causal links pri pic
regardless whether operator causal link initially pri pic   threats
combined plan pri pic effectively computed finding relative positions
steps comparing causal link steps may ordered
producer consumer condition causal link  findthreats  line    
point  shown plan  pci   flaws  threats
open conditions  explicitly recorded  by addflaws lines       since rp op sound
 lemma     conclude rp op complete pci output valid plan p     output
failure flaws plan cannot repaired   
   

fiplanning rewriting

clear b 

removed subplan

on a table 
on c a 

causal link
ordering constraint
side effect

clear a 

  unstack c a 
on c a 
clear c 
on d table 

on a table 
clear b 

  stack a b table 
on c table 
  stack b c table 

clear c 
  stack c table 

 

on b table 
on a b 
clear c 
on b c 
on c d 
goal

clear d 
clear b 

on c table 

clear d 



on b d 

b

on b table 
  unstack b d 
on b d 
clear b 

c

b

c







clear c 
initial state

goal state

 a  application rewriting rule  removing subplan
clear b 

causal link
ordering constraint
open conditions

on a table 

clear a 
clear c 
on d table 
 

on c a 
clear b 

  stack a b table 
on b table 
on a b 
clear c 
on b c 

  stack b c table 
clear c 

clear a 

on c a 
clear d 

on b d 

on a table 
clear b 

on c d 

  stack c a 

on c d 
clear d 
on c a 

goal


clear d 

b

on b table 
  unstack b d 
on b d 

clear b 

c

b

c







clear c 
initial state

goal state

 b  application rewriting rule  adding replacement subplan
on a table 
clear b 

on a table 

  stack a b table 

clear b 
clear a 

on d table 
on c a 

  stack b c table 

clear c 

 

  stack c a 
clear b 

on b table 
on a b 
clear c 
on b c 
on c d 
goal

clear d 
on c a 

clear d 

causal link
ordering constraint
side effect

on b d 
on b table 
  unstack b d 
on b d 
clear b 


b

c

b

c







clear c 
initial state

goal state

 c  rewritten plan
figure     plan rewriting  applying rule avoid move twice figure   plan figure  
   

fiambite   knoblock

corollary    soundness pbr search  optimization search pbr sound 
proof  induction  assume initial valid plan single step rewriting search 
theorem    output either valid rewritten plan failure  output failure 
search trivially sound  assume valid plan pn  n   rewriting steps 
according theorem    applying single rewriting rule plan pn  produces valid
plan pn failure  thus  arbitrary number rewritings produces valid plan  or
plan   pbrs search sound   
although rewriteplan sound  may certainly produce plans
minimal number steps faced arbitrary rules  example  imagine
consequent rewriting rule specified two identical steps s  s   both
effects e  e   flaws pci exactly open conditions e  e  
then  sound non step minimal plan would using s  satisfy e  using s 
satisfy e   although step could satisfy open conditions   pbr
discard plan make restriction types acceptable cost
functions  cost function took robustness plan account 
plan steps may desirable 
cannot guarantee pbrs optimization search complete sense
optimal plan would found  pbr uses local search well known that  general 
local search cannot complete  even pbr exhaustively explores space plan
rewritings induced given initial plan set rewriting rules  still cannot prove
solution plans reached  property initial plan generator 
set rewriting rules  semantics planning domain  rewriting rules pbr
play similar role traditional declarative search control completeness
search may traded efficiency  perhaps using techniques inferring invariants
planning domain  gerevini   schubert        fox   long        rintanen        proving
convergence term graph rewriting systems  baader   nipkow         conditions
completeness plan rewriting search given planning domain could obtained 
design plan rewriting algorithm depends several parameters  language
operators  language rewriting rules  choice full specification partialspecification rewriting rules  need rewritings one rewriting required
search method 
language operators affects way initial rewritten plans
constructed  framework supports expressive operator definition language described
section      provide support language using standard techniques causal
link establishment threat checking sage  knoblock        ucpop
 penberthy   weld        
language antecedents rewriting rules affects efficiency matching 
system implements conjunctive query language described section       
however  system could easily accommodate expressive query language
rule antecedent  relationally complete language  i e   conjunction  disjunction 
safe negation   abiteboul  hull    vianu         recursive language datalog
stratified negation  without significantly increasing computational complexity
approach important way  discuss section       
choice fully versus partially specified rewriting rules affects way
replacement plan embedded current plan  rule completely specified 
   

fiplanning rewriting

embedding already specified rule consequent  replacement subplan
simply added current plan  rule partially specified  algorithm
compute valid embeddings 
choice one versus rewritings affects antecedent matching
embedding rule consequent  rule matches computed either
time  bottom up evaluation logic databases  one at a time prolog  depending whether search strategy requires one rewritings  rule fully specified
one embedding per match possible  but  rule partially specified multiple
embeddings may result single match  search strategy requires one rewriting  must provide mechanism choosing rule applied  match
computed  embedding generated  rpop stop first embedding
compute embeddings   implemented rewriting algorithm modular design
support different combinations choices 
      complexity plan rewriting
complexity plan rewriting pbr originates two sources  matching rule
antecedent plan  computing embeddings replacement plan 
order analyze complexity matching plan rewriting rules  introduce following
database theoretic definitions complexity  abiteboul et al         
data complexity  complexity evaluating fixed query variable database inputs 
expression complexity  complexity evaluating  fixed database instance 
queries specifiable given query language 
data complexity measures complexity respect size database 
expression complexity measures complexity respect size queries
 taken given language   case  database steps links plan
queries antecedents plan rewriting rules 
formally  language rule antecedents described section       conjunctive
queries interpreted predicates  worst case combined data expression complexity conjunctive queries exponential  abiteboul et al          is  size
query  rule antecedent  size database  plan  grow simultaneously 
little hope matching efficiently  fortunately  relationally complete languages data
complexity contained logarithmic space  is  turn  contained polynomial time
 abiteboul et al          thus conjunctive query language complexity 
encouraging result shows cost evaluating fixed query grows
slowly database size increases  pbr means matching antecedent
rules strongly affected size plans  moreover  experience
useful rule antecedents large contain many constant labels  at least 
node edge predicate names  help reduce size intermediate results
improve efficiency matching  result indicates could extend
language antecedent relationally complete without affecting significantly
performance system    another possible extension use datalog stratified
negation  polynomial time data complexity  graph theoretic properties
    figure    section   proposes example rule relationally complete antecedent using
appropriate syntax 

   

fiambite   knoblock

plans could easily described datalog  example  possibly adjacent interpreted predicate figure   could described declaratively datalog program instead
piece code  summary  rule match moderately sized rules  even quite expressive
languages large plans  remains tractable made efficient using production
match  forgy        query optimization techniques  sellis        
second source complexity computing embeddings replacement plan
given consequent plan rewriting rule  definition full specification rules 
embedding completely specified rule itself  thus  suffices simply remove
undesired subplan directly add replacement subplan  linear size
consequent 
partial specification rules  computing embeddings replacement subplan
exponential size plan worst case  however  occurs
pathological cases  example  consider plan figure    a  going
compute embeddings step x remainder plan order satisfy open
precondition g   step x preconditions two effects b g   step
plan proposition b effect  therefore  new step x conflicts every step
plan    n  ordered respect steps  unfortunately 
exponential number orderings  effect  orderings imposed adding step
x correspond partitions set steps    n  two sets  one ordered
x one after  figure    b  shows one possible orderings  subplan
embedding contained several steps contained similar conflicts problem would
compounded  even deciding single embedding exists np hard  example 
add two additional effects g  operator x  valid embedding 
worst case  solving first flaws induced conflicts proposition b 
explore exponential number positions step x plan  end
failure  nevertheless  given quasi decomposability useful planning domains expect
number conflicts relatively small  useful rewriting rules specify
replacement subplans small compared plan embedding into 
experience indicates plan rewriting partial specification rules performed
efficiently shown results section   
b

b

 

 

g 





b

g 
b

 

 

g 
g 
b



 

g

 

g 


b

x

g

g 

x

g 



n

gn

gn



b

n

 a  embedding

b

 b  one possible embedding

figure     exponential embeddings

   

fiplanning rewriting

      taxonomy plan rewriting rules
order guide user defining plan rewriting rules domain help designing
algorithms may automatically deduce rules domain specification  see
section     helpful know kinds rules useful  identified
following general types transformation rules 
reorder  rules based algebraic properties operators  commutative  associative distributive laws  example  commutative rule reorders
two operators need resource figure     join swap rule figure   
combines commutative associative properties relational algebra 
collapse  rules replace subplan smaller subplan  example 
several operators replaced one  remote join eval rule figure    
rule replaces two remote retrievals information source local join
operation single remote join operation  remote source capability
performing joins  example application rule query plan shown
figure     examples blocks world rules figure   replace unstack
stack operators either equivalent single stack operator empty plan 
expand  rules replace subplan bigger subplan  although may
appear counter intuitive initially  easy imagine situation expensive
operator replaced set operators cheaper whole  interesting
case operators already present plan synergistically reused  find rule type domains analyzed far  backstrom
     a  presents framework adding actions improves quality plans 
quality metric plan execution time  similarly manufacturing domain section      figure    shows example planning domain adding actions improves
quality  from backstrom      a   example  removing link bm c 
inserting new action shortens significantly time execute plan 
p

rn 

r 

r 


c 

c 
r 

p

p

q 

qm

b 

rn
cn

p

rn
cn

p
q 

rn 

r 

r 


b 

bm

bm qm

qm 

qm 

 a  low quality plan

 b  high quality plan

figure     adding actions improve quality
parallelize  rules replace subplan equivalent alternative subplan
requires fewer ordering constraints  typical case redundant alternative resources operators use  example  rule punch by drill press
figure    another example rule figure    suggests could seen
combination expand parallelize types 
   

fiambite   knoblock

    selection next plan  search strategies
although space rewritings explored systematically  planning rewriting
framework better suited local search techniques typical combinatorial optimization algorithms  characteristics planning domain  initial plan generator 
rewriting rules determine local search method performs best  first  discuss
initial plan generator affects choice local search methods  second  consider impact rewriting rules  third  discuss role domain knowledge
search process  finally  describe several local search methods work pbr 
important difference pbr traditional combinatorial algorithms
generation feasible solutions  usually  combinatorial optimization problems exists
effective procedure generate feasible solutions  e g   permutations schedule  
thus  even local search graph disconnected  choosing appropriate initial
solution generator  e g   random  could fall component graph contains
global optimum  pbr cannot assume powerful initial plan generators  even
optimization domains  efficient initial plan generators  may
guarantees coverage solution space provide  therefore  optimal plan
may reachable applying rewriting rules starting initial plans
available generator  nevertheless  many domains initial plan generator
provides good sample solution space sufficient multiple restart search methods
escape low quality local minima provide high quality solutions 
plan rewriting rules define neighborhood function  may exact  cf 
section      not  example  query planning domain define set
rules completely generate space solution plans  because properties
relational algebra   domains may hard prove exact set
rules  limitations initial plan generation plan rewriting rules affect
possibility theoretically reaching global optimum  surprising since many
problems  regardless whether cast planning formalisms 
converging local search algorithms  e g   papadimitriou   steiglitz         nevertheless 
practice  good local optima still obtained many domains 
many local search methods  first best improvement  simulated annealing 
tabu search  variable depth search  applied straightforwardly pbr 
experiments section   used first best improvement  performed
well  next  describe details application two methods pbr 
section    discuss ideas using variable depth plan rewriting 
first improvement generates rewritings incrementally selects first plan
better cost current one  order implement method efficiently use
tuple at a time evaluation rule antecedent  similarly behavior prolog  then 
rule instantiation  generate one embedding  test cost resulting plan 
better current plan  repeat  choice generating another
embedding rule instantiation  generate another instantiation rule 
generate match different rule 
best improvement generates complete set rewritten plans selects best 
method requires computing matches embeddings match 
matches obtained evaluating rule antecedent set at a time database
   

fiplanning rewriting

query  discussed section       query evaluation quite efficient 
experience  computing plan embeddings usually expensive computing
rule matches 
planning rewriting choice initial plan generator  rewriting rules 
search methods intertwined  initial plan generator fixed  determines
shape plans would modified rewriting rules  according
neighborhood  appropriate search mechanism chosen  pbr
modular design facilitate experimentation different initial plan generators  sets
rewriting rules  search strategies 
    plan quality
practical planning domains quality plans crucial  one
motivations planning rewriting approach  pbr user defines measure
plan quality appropriate application domain  quality metric could
range simple domain independent cost metric  number steps 
complex domain specific ones  example  query planning domain measure
plan quality usually estimation query execution cost based size
database relations  data manipulation operations involved answering query 
cost network transfer  decentralized environment  cost metric may involve
actual monetary costs information sources require payments  jobshop scheduling domain simple cost functions schedule length  that is 
parallel time finish pieces   sum times finish piece 
sophisticated manufacturing domain may include variety concerns cost 
reliability  precision operator process  costs resources materials used
operators  utilization machines  etc  reader find detailed
examples quality metrics domains sections         
significant advantage pbr complete plan available assess quality 
generative planners complete plan available search solution
completed  usually simple plan quality metrics  number steps 
used  work incorporate quality concerns generative planners  estlin
  mooney        borrajo   veloso        perez         systems automatically
learn search control rules improve efficiency planning quality
resulting plans  pbr rewriting rules seen post facto optimization search
control  opposed guiding search generative planner towards high quality
solutions based information available partial plans  pbr improves quality
complete solution plans without restriction types quality metrics  moreover 
plan cost additive  plan refinement strategy impractical since may need
exhaustively explore search space find optimal plan  example nonadditive cost function appears unix planning domain  etzioni   weld       
plan transfer files two machines may cheaper files compressed
initially  and uncompressed arrival   is  plan includes compression
 and necessary uncompression  operations cost effective  plan refinement
search would naturally lead it  using complete plans  pbr accurately assess
arbitrary measures quality 
   

fiambite   knoblock

    initial plan generation
fast initial plan generation domain specific nature  requires user specify
efficient mechanism compute initial solution plan  general  generating initial
plan may hard generating optimal plan  however  crucial intuition behind
planning algorithms practical problems quasi decomposable  simon        
is  interactions among parts problems limited  interactions
problem pervasive    puzzle  operator based representation algorithms classical planning little use  would behave search based
problem solver  fortunately  many practical problems indeed quasi decomposable 
intuition suggests finding initial plan generators planning problems may
hard appears  system solve subproblems independently 
combine simplest way  example  concatenating solutions sequentially  moreover  many circumstances problems may easily transformed
state minimizes interactions solving problem state much easier 
example  blocks world state blocks table minimizes
interactions  simple design algorithm solves blocks world problem
passing intermediate state  using methods initial plan generator may
produce suboptimal initial plans reasonable planning cost 
ideas constructing initial plan generators embodied two general ways 
implemented system  first one bootstrap results
general purpose planning algorithm strong search control bias  second one
provide user convenient high level facilities describe plan construction
algorithms programmatically 
      biased generative planners
variety ways control search generic planner  planners
accept search control rules  others accept heuristic functions  built in search
control  present examples techniques 
general way efficiently constructing plans use domain independent
generative planner accepts search control rules  example  prodigy  carbonell 
knoblock    minton         ucpop  penberthy   weld        sage  knoblock       
planners  setting type search providing strong bias means
search control rules  planner quickly generate valid  although possibly suboptimal 
initial plan  example  manufacturing domain  minton      a   analyzed
detail section      depth first search goal selection heuristic based abstraction
hierarchies  knoblock      a  quickly generates feasible plan  often quality
plan  defined time required manufacture objects  suboptimal 
tlplan  bacchus   kabanza              efficient forward chaining planner
uses search control expressed temporal logic  forward chaining complete
state available  much refined domain control knowledge specified 
preferred search strategy used tlplan depth first search  although finds plans
efficiently  plans may low quality  note generative planner
explores partial sequences steps  cannot use sophisticated quality measures 
   

fiplanning rewriting

hsp  bonet  loerincs    geffner        bonet   geffner        forward search
planner performs variation heuristic search applied classical ai planning 
built in heuristic function relaxed version planning problem  computes
number required steps reach goal disregarding negated effects operators 
metric computed efficiently  despite simplicity heuristic
admissible  scales surprisingly well many domains  plans generated
according fixed heuristic function  planner cannot incorporate quality metric 
types planners quite efficient practice although often produce suboptimal plans  excellent candidates generate initial plans
subsequently optimized pbr 
      facilitating algorithmic plan construction
many domains  simple domain dependent approximation algorithms provide good
initial plans  example  query planning domain  system easily generate
initial query evaluation plans randomly  or greedily  parsing given query 
blocks world straightforward generate solution linear time using naive
algorithm  put blocks table build desired towers bottom up 
algorithm produces plans length worse twice optimal  makes
already good approximation algorithm  however  interest blocks world
traditionally optimal solutions  np hard problem  gupta   nau        
system facilitates creation initial plans freeing user specifying detailed graph structure plan  user needs specify algorithm
produces sequence instantiated actions  is  action names ground
parameters action takes    example   user defined  naive algorithm
blocks world domain described applied problem figure   produces
sequence  unstack c a   unstack b d   stack c table   stack b c table  
stack a b table   then  system automatically converts sequence actions
fully detailed partial order plan using operator specification domain  resulting plan conforms internal data structures pbr uses  process includes
creating nodes fully detailed operators preconditions effects  adding
edges represent necessary causal links ordering constraints  blocks
world example resulting plan figure   
algorithm transforms user defined sequence actions partial order
plan presented figure     algorithm first constructs causal structure plan
 lines      adds necessary ordering links avoid threats  lines       
user needs specify action names corresponding instantiated action
parameters  algorithm consults operator specification find preconditions
effects  instantiate them  construct causal links  check operator threats 
operator threats always resolved favor ordering given user input
plan  reason input plan may overconstrained total order 
assumed valid  therefore  processing step last first  orderings
indeed avoid threats included partial order plan 
    algorithm accepts extra ordering constraints addition sequence available
initial plan generator 

   

fiambite   knoblock

procedure to po
input  valid total order plan  a          
output  equivalent partial order plan
      n  
  
p preconditions ai  
  
choose k  
  
   p positiveeffects ak  
  
     l k   l   p negativeeffects al  
  
add order ak ai
  
p negativeeffects ai  
  
j     i     
  
p preconditions aj  
   
add order aj ai
    return   a             
figure     algorithm converting total order partial order plans
algorithm extension greedy algorithm presented veloso  perez    carbonell         algorithm explores non deterministically producers proposition  line     opposed taking latest producer sequence algorithm   
is  algorithm explored exhaustively  produces partially ordered causal
structures consistent input sequence  generalization stems criticism
backstrom      b  algorithm veloso et al         desire able
produce alternative initial plans 
problem transforming sequence steps least constrained plan analyzed
backstrom      b  several natural definitions optimality  definitions
least constrained plan shortest parallel execution problem np hard  backstrom
shows velosos algorithm  although polynomial  conform natural definitions  algorithm greedy  suffer drawbacks
pointed backstrom  moreover  purposes need optimal initial plans 
space partial orders explored rewriting process 
regardless method producing initial plans  generators provide multiple
plans preferable  different initial plans used conjunction multiple restart
search techniques order escape low quality local minima 

   empirical results
section show broad applicability planning rewriting analyzing four
domains different characteristics  process manufacturing domain  minton      b  
transportation logistics domain  blocks world domain used examples
throughout paper  domain distributed query planning 
    implement algorithm enough replace line   figure    with 
find max k  

   

fiplanning rewriting

    manufacturing process planning
task manufacturing process planning domain find plan manufacture
set parts  implemented pbr translation domain specification  minton 
    b   domain contains variety machines  lathe  punch  spray painter 
welder  etc  total ten machining operations  operator specification shown
figures        features part described set predicates 
temperature  painted  has hole  etc  features changed operators 
predicates state  has clamp  is drillable  etc  set initial state
problem 
example behavior operator  consider polish operator figure    
requires part manufacture cold polisher clamp secure
part machine  effect applying operator leave surface
part polished  attributes part  surface condition  single valued 
others  has hole  multivalued  note drill press punch
operators figure    prevent several has hole conditions asserted
part  interesting operators weld bolt  operators join two
parts particular orientation form new part  operations performed
separate parts joined 
measure plan cost schedule length   parallel  time manufacture
parts  domain machining operations assumed take unit time 
machines objects  parts  modeled resources order enforce one
part placed machine time machine operate single
part time  except bolt weld operate two parts simultaneously  
already shown types rewriting rules domain figures  
    set rules used experiments shown figure     top
eight rules quite straightforward one becomes familiar domain  two
top rules explore space alternative orderings originated resource conflicts 
machine swap rule allows system explore possible orderings operations
require machine  rule finds two consecutive operations machine
swaps order  similarly  rule object swap allows system explore
orderings operations object  two rules use interpreted predicate
adjacent in critical path focus attention steps contribute cost
function  adjacent in critical path checks two steps consecutive along one
critical paths schedule  critical path sequence steps take longest
time accomplish  words  critical path one sequences steps
determine schedule length 
next six rules exchange operators equivalent respect achieving
effects  rules ip by sp sp by ip propose exchange immersion paint
spray paint operators  examining operator definitions figure    
readily noticed operators change value painted predicate  similarly 
pu by dp dp by pu exchange drill press punch operators  produce
has hole predicate  finally  roll by lathe lathe by roll exchange roll lathe
operators make parts cylindrical  focus search promising
   

fiambite   knoblock

 define  operator polish 
 parameters   x 
 resources   machine polisher   is object  x  
 precondition   and  is object  x 
 temperature  x cold 
 has clamp polisher  
 effect
  and   forall   surf 
  when   neq  surf polished 
  not  surface condition  x  surf   
 surface condition  x polished   

 define  operator grind 
 parameters   x 
 resources   machine grinder   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   surf 
  when   neq  surf smooth 
  not  surface condition  x  surf    
 surface condition  x smooth   

 define  operator lathe 
 parameters   x 
 resources   machine lathe   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   shape 
  when   neq  shape cylindrical 
  not  shape  x  shape    
  forall   surf 
  when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 shape  x cylindrical   

 define  operator roll 
 parameters   x 
 resources   machine roller   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   shape 
  when   neq  shape cylindrical 
  not  shape  x  shape    
  forall   temp 
  when   neq  temp hot 
  not  temperature  x  temp    
  forall   surf 
  not  surface condition  x  surf   
  forall   width  orientation 
  not  has hole  x  width  orientation   
 temperature  x hot 
 shape  x cylindrical   

 define  operator drill press 
 parameters   x  width  orientation 
 resources   machine drill press 
 is object  x  
 precondition
  and  is object  x 
 have bit  width 
 is drillable  x  orientation  
 effect  has hole  x  width  orientation  

 define  operator punch 
 parameters   x  width  orientation 
 resources   machine punch   is object  x  
 precondition
  and  is object  x 
 has clamp punch 
 is punchable  x  width  orientation  
 effect
  and   forall   surf 
  when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 has hole  x  width  orientation   

figure     operators manufacturing process planning  i 

exchanges rules match operators critical path  by means interpreted
predicate in critical path  
six bottom rules figure    sophisticated  lathe sp by sp rule
takes care undesirable effect simple depth first search used initial plan
generator  domain  order spray paint part  part must regular shape 
cylindrical regular shape  therefore initial planner may decide make
part cylindrical lathing order paint it  however  may necessary
part may already regular shape  for example  could rectangular 
regular shape   thus  lathe sp by sp substitutes pair spray paint lathe
single spray paint operation  supporting regular shapes interpreted predicate
   

fiplanning rewriting

 define  operator immersion paint 
 parameters   x  color 
 resources   machine immersion painter 
 is object  x  
 precondition
  and  is object  x 
 have paint for immersion  color  
 effect  painted  x  color  

 define  operator spray paint 
 parameters   x  color  shape 
 resources   machine spray painter 
 is object  x  
 precondition   and  is object  x 
 sprayable  color 
 temperature  x cold 
 regular shape  shape 
 shape  x  shape 
 has clamp spray painter  
 effect  painted  x  color  

 define  operator bolt 
 define  operator weld 
 parameters   x  y  new obj  orient  width 
 parameters   x  y  new obj  orient 
 resources   machine bolter 
 resources   machine welder 
 is object  x   is object  y  
 is object  x   is object  y  
 precondition
 precondition
  and  is object  x   is object  y 
  and  is object  x   is object  y 
 composite object  new obj  orient  x  y 
 composite object  new obj  orient  x  y 
 has hole  x  width  orient 
 can be welded  x  y  orient  
 has hole  y  width  orient 
 effect   and  temperature  new obj hot 
 bolt width  width 
 joined  x  y  orient 
 can be bolted  x  y  orient  
  not  is object  x  
 effect   and   not  is object  x  
  not  is object  y    
  not  is object  y  
 joined  x  y  orient   

figure     operators manufacturing process planning  ii 

enumerates regular shapes  rules partially specified
guaranteed always produce rewriting  nevertheless  often successful
producing plans lower cost 
remaining rules explore bolting two parts using bolts different size fewer operations may needed plan  developed rules analyzing differences
quality optimal plans rewritten plans  example  consider
both providers diff bolt rule  rule states parts bolted already
compatible holes them  better reuse operators produced
holes  initial plan generator may drilled  or punched  holes whose purpose
bolt parts  however  goal problem may already require holes
performed parts joined  reusing available holes produces economical plan  rules has hole x diff bolt add pu  has hole x diff bolt add dp 
has hole y diff bolt add pu  has hole y diff bolt add dp address cases
one holes reused  thus additional punch drill press
operation needs added 
illustration rewriting process manufacturing domain  consider figure     plan top figure result simple initial plan generator
solves part independently concatenates corresponding subplans  although
plan generated efficiently  poor quality  requires six time steps manufacture parts  figure shows application two rewriting rules  machine swap
ip by sp  improve quality plan  operators matched rule antecedent shown italics  operators introduced rule consequent shown
bold  first  machine swap rule reorders punching operations parts b 
   

fiambite   knoblock

 define rule  name machine swap
 if   operators    n   machine  x   resource 
  n   machine  x   resource  
 links    n   threat  n   
 constraints
 adjacent in critical path  n   n   
 replace   links   n   n   
 with   links   n   n    

 define rule  name object swap
 if   operators    n   is object  x   resource 
  n   is object  x   resource  
 links    n   threat  n   
 constraints
 adjacent in critical path  n   n   
 replace   links   n   n   
 with   links   n   n    

 define rule  name sp by ip
 define rule  name ip by sp
 if   operators   n   spray paint  x  c  s  
 if   operators   n   immersion paint  x  c  
 constraints   in critical path  n    
 constraints   regular shapes  s 
 replace   operators   n   
 in critical path  n    
 with   operators   n   immersion paint  x  c    
 replace   operators   n   
 with   operators   n   spray paint  x  c  s    
 define rule  name dp by pu
 define rule  name pu by dp
 if   operators    n   drill press  x  w  o   
 if   operators   n   punch  x  w  o  
 constraints   in critical path  n    
 constraints   in critical path  n    
 replace   operators   n   
 replace   operators   n   
 with   operators   n   punch  x  w  o    
 with   operators   n   drill press  x  w  o    
 define rule  name roll by lathe
 if   operators    n   roll  x   
 constraints   in critical path  n    
 replace   operators   n   
 with   operators   n   lathe  x    

 define rule  name lathe by roll
 if   operators    n   lathe  x   
 constraints   in critical path  n    
 replace   operators   n   
 with   operators   n   roll  x    

 define rule  name both providers diff bolt
 define rule  name lathe sp by sp
 if   operators    n   bolt  x  y  z  o  w    
 if   operators
 links    n   has hole  x  w   o   n  
   n   lathe  x  
  n   has hole  y  w   o   n  
  n   spray paint  x  color  shape    
  n   has hole  x  w   o   n  
 constraints   regular shapes  shape    
  n   has hole  y  w   o   n   
 replace   operators   n   n   
 constraints    neq  w   w    
 with   operators
   n   spray paint  x  color  shape        replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
 define rule  name has hole x diff bolt add dp
 define rule  name has hole x diff bolt add pu
 if   operators    n   bolt  x  y  z  o  w    
 if   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  x  w   o   n   
  n   has hole  x  w   o   n   
 constraints    neq  w   w    
 constraints    neq  w   w    
 replace   operators   n   n   n   
 replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w   
 with   operators    n   bolt  x  y  z  o  w   
  n   drill press  y  w   o   
  n   punch  y  w   o   
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
  n   has hole  y  w   o   n     
 define rule  name has hole y diff bolt add dp
 define rule  name has hole y diff bolt add pu
 if   operators    n   bolt  x  y  z  o  w    
 if   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n   
  n   has hole  y  w   o   n   
 constraints    neq  w   w    
 constraints    neq  w   w    
 replace   operators   n   n   n   
 replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w   
 with   operators    n   bolt  x  y  z  o  w   
  n   drill press  x  w   o   
  n   punch  x  w   o   
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
  n   has hole  y  w   o   n     

figure     rewriting rules manufacturing process planning
   

fiplanning rewriting

lathe

ipaint red

punch  

punch c  

ipaint c blue

roll b

ipaint b red

reorder parts machine
lathe

ipaint red
punch c  

cost   

punch  

cost   

ipaint c blue

ipaint b red

roll b

immersion paint    spray paint
lathe
roll b

ipaint red

punch  

punch c  

ipaint c blue

cost   

spray paint b red

figure     rewriting manufacturing domain
breaks long critical path resulted simple concatenation respective
subplans  schedule length improves six four time steps  still  three parts
a  b  c use painting operation  immersion paint   immersion painter
process one piece time  three operations must done serially  fortunately  domain another painting operation  spray paint  ip by sp
rule takes advantage fact substitutes immersion paint operation part b
spray paint operation  parallelizes plan obtaining schedule length
three time steps  optimal plan 
compare four planners  ipp  initial  two configurations pbr  
ipp  one efficient domain independent planners  koehler  nebel  hoffman    dimopoulos        planning competition held fourth international
conference artificial intelligence planning systems  aips      ipp optimized reimplementation extension graphplan  blum   furst               ipp produces
shortest parallel plans  manufacturing domain  exactly schedule length 
cost function optimizing 
initial  initial plan generator uses divide and conquer heuristic order generate
plans fast possible  first  produces subplans part joined goals
independently  subplans generated sage using depth first search without
regard plan cost  then  concatenates subsequences actions merges
using facilities section       
pbr  present results two configurations pbr  refer pbr    
pbr      configurations use first improvement gradient search strategy
random walk cost plateaus  rewriting rules used figure    
problem pbr starts search plan generated initial  two configurations
differ many total plateau plans allowed  pbr     allows considering
    plans improve cost without terminating search  similarly  pbr   

fiambite   knoblock

    allows     plateau plans  note limit across plateaus encountered
search problem  plateau 
tested four systems     problems  machining    parts  ranging
     goals  goals distributed randomly    parts  so    goal problems  average   goals per part  results shown figure    
graphs data point average    problems given number goals 
   provably unsolvable problems  initial pbr solved     problems  or
proved unsolvable   ipp solved    problems total  problems      goals 
      goals       goals  ipp could solve problem    goals
     cpu seconds time limit 
figure    a  shows average time solvable problems problem set
four planners  figure    b  shows average schedule length problems solved
planners  is     problems solved ipp    goals 
fastest planner initial  produces plans cost twice optimal  ipp
produces optimal plans  cannot solve problems    goals  two
configurations pbr scale much better ipp solving problems producing good
quality plans  pbr     matches optimal cost ipp plans  except one problem
 the reason difference interesting explain below   faster pbr    
stays close optimal  less      average cost difference  
figure    c  shows average schedule length problems solved
planners    goal range  pbr configurations scale gracefully across
range improving considerably cost plans generated initial  additional
exploration pbr     allows improve plans even further  reason
difference pbr ipp    goal complexity level cost results
ipp   problems could solve  results pbr initial
average    problems  as shown figure    b   pbr matches cost
  optimal plans produced ipp  
figure    d  shows average number operators plans problems solved
three planners  up    goals   figure    e  shows average number operators
plans problems solved planner across whole range    problems 
plans generated initial use     additional operators  pbr ipp
produce plans require fewer steps  interestingly  ipp sometimes produces plans
use operations pbr  ipp produces shortest parallel plan  one
minimum number steps  particular  observed ipp plans
suffer problem initial  ipp would lathe part order paint
it  opposed initial would affect optimal schedule
length  surprisingly  adding additional steps domain may improve schedule
length  albeit fairly rare situations  case problem ipp
produced better schedule pbr      could introduced rewriting rule
substituted immersion paint operator lathe spray paint operators
cases  however  rule low utility  in sense minton      b  
expands rewriting search space  adds cost match  random
search provides benefit rarely 
   

fiplanning rewriting

average planning time  cpu seconds 

    
pbr fi
initial
ipp

   

  

 

   

    
 

  

  

  

  
  
  
  
number blocks

  

  

   

 a  average planning time
  

average plan cost  schedule length 

average plan cost  schedule length 

 
pbr    
pbr    
initial
ipp

 
 
 
 
 
 
 

 b 

 

 

  
  
  
number goals

  

  

  
  
  
  
  
 

  

 

average plan cost
 problems solved all 

 c 

  

  

  

  
  
  
  
number goals

  

  

  

average plan cost
 problems solved each 

  

  

pbr    
pbr    
initial
ipp

  

average number plan operators

average number plan operators

pbr    
pbr    
initial
ipp

 
 

  
  
  
  
  
 
 
 

  
  
  
  
  

pbr    
pbr    
initial
ipp

  
  
  
  
  
 

 

 d 

  

 

 

  
  
  
number goals

  

  

  

 

number plan operators
 problems solved all 

 e 

  

  

  
  
  
  
number goals

number plan operators
 problems solved each 

figure     experimental results  manufacturing process planning

   

  

  

  

fiambite   knoblock

experiment illustrates flexibility pbr specifying complex rules planning domain  results show benefits finding suboptimal initial plan quickly
efficiently transforming improve quality 
    logistics
task logistics domain transport several packages initial location
desired destinations  used version logistics strips planning domain
aips   planning competition restricted using trucks planes   
domain shown figure     package transported one location another
loading truck  driving truck destination  unloading truck 
truck load number packages  cost function  parallel  time deliver
packages  measured number operators critical path plan  
 define  operator load truck 
 parameters   obj  truck  loc 
 precondition
  and  obj  obj   truck  truck   location  loc 
 at  truck  loc   at  obj  loc  
 effect   and   not  at  obj  loc  
 in  obj  truck   

 define  operator unload truck 
 parameters   obj  truck  loc 
 precondition
  and  obj  obj   truck  truck   location  loc 
 at  truck  loc   in  obj  truck  
 effect   and   not  in  obj  truck  
 at  obj  loc   

 define  operator drive truck 
 parameters   truck  loc from  loc to  city 
 precondition   and  truck  truck   location  loc from   location  loc to   city  city 
 at  truck  loc from   in city  loc from  city   in city  loc to  city  
 effect   and   not  at  truck  loc from    at  truck  loc to   

figure     operators logistics
compare three planners domain 
ipp 

ipp  koehler et al         produces optimal plans domain 

initial  initial plan generator picks distinguished location delivers packages
one one starting returning distinguished location  example  assume
truck t  distinguished location l   package p  must delivered location
l  location l   plan would be  drive truck t  l  l  c   load truck p  t  l   
drive truck t  l  l  c   unload truck p  t  l    drive truck t  l  l  c  
initial plan generator would keep producing circular trips remaining packages 
although algorithm efficient produces plans low quality 
pbr  pbr starts plan produced initial uses plan rewriting rules shown
figure    optimize plan quality  loop rule states driving location
returning back immediately useless  fact operators must adjacent
important implies intervening load unload performed 
vein  triangle rule states better drive directly two
locations third point operation performed point 
    logistics domain aips    problems moving packages plane among different cities
truck among different locations city isomorphic  focused one better
analyze rewriting rules learned  ambite  knoblock    minton        

   

fiplanning rewriting

load earlier rule captures situation package loaded truck
first time packages location visited  occurs initial planner
concerned trip another package  unload later rule captures dual case 
pbr applies first improvement search strategy one run  no restarts  
 define rule  name loop
 if   operators
   n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
 links    n   n   
 constraints
  adjacent in critical path  n   n    
 replace   operators   n   n   
 with nil 

 define rule  name triangle
 if   operators
   n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
 links    n   n   
 constraints
  adjacent in critical path  n   n    
 replace   operators   n   n   
 with   operators
   n   drive truck  t  l   l   c     

 define rule  name unload later
 define rule  name load earlier
 if   operators
 if   operators
   n   drive truck  t  l   l   c  
   n   drive truck  t  l   l   c  
  n   unload truck  p  t  l   
  n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
  n   load truck  p  t  l    
 links    n   n   
 links    n   n   
 constraints
 constraints
  adjacent in critical path  n   n  
  adjacent in critical path  n   n  
 before  n   n    
 before  n   n    
 replace   operators   n   
 replace   operators   n   
 with   operators    n   unload truck  p  t  l    
 with   operators    n   load truck  p  t  l    
 links    n   n     
 links    n   n     

figure     logistics rewriting rules

   

pbr
initial
ipp

    

pbr
initial
ipp

   

average plan cost

average planning time  cpu seconds 

     

   
  
 

   

   

  

   
    

 
 

 

  

              
number packages

  

  

  

 

 a  average planning time

 

  

  

  
  
  
  
number packages

  

  

  

 b  average plan cost

figure     experimental results  logistics  scaling number packages
compared performance ipp  initial  pbr set logistics problems
involving    packages  problem instance number packages 
locations  goals  single truck single city  performance results
shown figure     graphs data point average    problems
given number packages  problems satisfiable  ipp could solve
   

fiambite   knoblock

problems   packages  it solved         packages      
  packages  shown figure   figure    a  shows average
planning time  figure    b  shows average cost    packages range  results
similar previous experiment  initial efficient highly suboptimal  pbr
able considerably improve cost plans approach optimal 
    blocks world
implemented classical blocks world domain two operators figure   
domain two actions  stack puts one block top another  and  unstack
places block table start new tower  plan quality domain simply
number steps  optimal planning domain np hard  gupta   nau        
however  trivial generate correct  suboptimal  plan linear time using
naive algorithm  put blocks table build desired towers bottom
up  compare three planners domain 
ipp  experiment used gam goal ordering heuristic  koehler        koehler
  hoffmann        tested blocks world problems good scaling results 
initial  planner programmatic implementation naive algorithm using
facilities introduced section       
pbr  configuration pbr starts plan produced initial uses
two plan rewriting rules shown figure   optimize plan quality  pbr applies first
improvement strategy one run  no restarts  
generated random blocks world problems scaling number blocks  problem
set consists    random problems                                                     
blocks total     problems  problems may multiple towers initial
state goal state 
figure    a  shows average planning time    problems block quantity 
ipp cannot solve problems    blocks within time limit      cpu
seconds  problem solving behavior ipp interesting  ipp either solved given
problem fast timed out  example  able solve         block problems     seconds  timed      seconds remaining   
problems  seems typical behavior complete search algorithms  gomes 
selman    kautz         local search pbr allows scale much better solve
problems 
figure    b  shows average plan cost number blocks increases  pbr
improves considerably quality initial plans  optimal quality known
small problems  pbr approximates it  achieve  we ran sage
problems less   blocks   larger plans know optimal cost  however 
slaney   thiebaux        performed extensive experimental analysis blocks world
planning using domain ours  comparison among different approximation
algorithms found initial plan generator  unstack stack  achieves empirically
quality around      optimal range problem sizes analyzed  figure  
slaney   thiebaux         value average initial plans divided      suggests
   

fiplanning rewriting

quality optimal plans  quality achieved pbr comparable value 
fact slightly better may due relatively small number problems
tested     per block size  skew random problem generator  interestingly
plans found ipp actually low quality  due fact ipp produces
shortest parallel plans  means plans constructed fewest time
steps  ipp may introduce actions time step required 
summary  experiments previous sections show across variety
domains pbr scales large problems still producing high quality plans 
   

average plan cost  number operators 

average planning time  cpu seconds 

    
pbr fi
initial
ipp

   

  

 

   

    
 

  

  

  

  
  
  
  
number blocks

  

  

pbr fi
initial
ipp
initial     

   
   
   
   
  
  
  
  
 

   

 

 a  average planning time

  

  

  

           
number blocks

  

  

   

 b  average plan cost

figure     experimental results  blocks world  scaling number blocks

    query planning
query planning problem considerable practical importance  central traditional
database mediator systems  section present results distributed query
planning highlight use pbr domain complex cost function  detailed
description query planning  including novel query processing algorithm mediators
based pbr  extensive experimental analysis appear  ambite   knoblock 
      ambite        
query planning involves generating plan efficiently computes user query
relevant information sources  plan composed data retrieval actions distributed information sources data manipulation operations  relational algebra  join  selection  union  etc  specification operators query
planning encoding information goals using first introduced
knoblock         sample information goal shown figure     goal asks send
output device mediator names airports tunisia  two sample
operators shown figure     retrieve operator executes query remote
information source transports data mediator  provided source
operation  source available  source capable processing query
 source acceptable query   join operator takes two subqueries  available
locally mediator  combines using conditions produce joined
query 
   

fiambite   knoblock

 available sims  retrieve   ap name 
  and  airport  aport 
 country name  aport  tunisia  
 port name  aport  ap name    

figure     sample information goal
 define  operator retrieve 
 parameters   source  query 
 resources   processor  source  
 precondition   and  source available  source 
 source acceptable query  query  source  
 effect  available sims  query  
 define  operator join 
 parameters   join conds  query  query a  query b 
 precondition   and  available sims  query a
 available sims  query b 
 join query  query  join conds  query a  query b  
 effect  available sims  query  

figure     query planning operators
quality distributed query plan estimation execution cost 
function size intermediate results  cost performing data manipulation
operations  transmission network intermediate results
remote sources mediator  system estimates plan cost based statistics
obtained source relations  number tuples relation  number
distinct values attribute  maximum minimum values numeric
attributes  silberschatz  korth    sudarshan        chapter      sources accessed 
type ordering data processing operations critical plan cost 
rewriting rules derived properties distributed environment
relational algebra    first set rules rely fact that  distributed environment 
generally efficient execute group operations together remote information source transmit data network execute operations
local system  example consider remote join eval rule figure     shown
pbr syntax  shown algebraically figure     rule specifies
plan exist two retrieval operations remote database whose results
consequently joined remote source capable performing joins  system
rewrite plan one contains single retrieve operation pushes join
remote database 
second class rules derived commutative  associative  distributive
properties operators relational algebra  example  join swap rule
figure     cf  figure    specifies two consecutive joins operators reordered
allows planner explore space join trees  since query planning
    mediators  rules address resolution semantic heterogeneity necessary  see
 ambite   knoblock        ambite        details 

   

fiplanning rewriting

 define rule  name remote join eval
 define rule  name join swap
 if   operators
 if   operators
   n   retrieve  query   source  
   n   join  q   jc   sq a  sq b  
  n   retrieve  query   source  
  n   join  q   jc   sq a  sq b   
  n   join  query  jc  query   query    
 links   n   n  
 constraints
 constraints
  capability  source join   
 join swappable
 replace   operators   n   n   n   
 q   jc   sq a  sq b
  
 with   operators
 q   jc   sq a  sq b
  
   n   retrieve  query  source    
 q   jc   sq a  sq b
  
 q   jc   sq a  sq b  
  
 replace   operators   n   n   
 with   operators
   n   join  q   jc   sq a  sq b  
  n   join  q   jc   sq a  sq b   
 links   n   n    

figure     query planning rewriting rules
domain queries expressed complex terms  knoblock         pbr rules use
interpreted predicates  constraints field manipulate query expressions 
example  join swappable predicate checks queries two join operators
exchanged computes new subqueries 
figure    shows example local search space query plan rewritings simple distributed domain describes company  figure shows alternative
query evaluation plans conjunctive query asks names employees 
salaries  projects working on  three relations requested query
 employees  payroll  project  distributed among two databases  one companys headquarters hq db another branch branch db   assume
leftmost plan initial plan  plan first retrieves employee relation hq db
project relation branch db  joins two tables employee name  finally  plan retrieves payroll relation hq db joins
ssn result previous join  although valid plan  initial plan suboptimal  applying join swap rule initial plan generates two rewritings  one
involves cross product  expensive operation  system  following gradient descent search strategy  prefers plan  system applies
remote join eval rule generates new rewritten plan evaluates join
employee project tables remotely headquarters database  final plan
much better quality 
compare planning efficiency plan quality four query planners 
sage  original query planner  knoblock              sims mediator 
performs best first search heuristic commonly used query optimization
explores space left join trees  sage refinement planner  kambhampati 
knoblock    yang        generates optimal left tree query plans 
dp  implementation dynamic programming bottom up enumeration
query plans  ono   lohman        find optimal plan  since distributed
domain subqueries execute parallel cost function reflects preference 
   

fiambite   knoblock

a name sal proj     emp name ssn    payroll ssn sal    projects name proj 

hq db
emp name ssn 
payroll ssn sal 

name ssn

branch db
project name proj 

ret emp
  hq db
ret payroll ret project
  hq db   branch db

ssn

name

ret payroll
  hq db

join
swap

name

remote
join
eval
name

ret emp ret project
  hq db   branch db

ssn

ret project
  branch db

ret emp ret payroll
  hq db   hq db

ret project
 branch db
ret  emp
 hq db

payroll 

figure     rewriting query planning
dp algorithm considers bushy join trees  however  improve planning time  dp
applies heuristic avoiding cross products join enumeration  thus  rare
cases dp may produce optimal plan 
initial  initial plan generator pbr  generates query plans according
random depth first search parse query  non random choice places
selections soon executed  fastest planner may produce
low quality plans 
pbr  used remote join eval join swap rules defined figure    
two rules sufficient optimize queries test set  tested two gradientdescent search strategies pbr  first improvement four random restarts  pbr fi  
steepest descent three random restarts  pbr sd  
experiment compare behavior sage  dp  initial  pbr fi  pbr sd
distributed query planning domain size queries increases  generated
synthetic domain sims mediator defined set conjunctive queries involving
     relations  queries one selection attribute table 
information source contains two relations perform remote operations  therefore 
optimal plans involve pushing operations evaluated remotely sources 
results experiment shown figure     figure    a  shows planning
time  logarithmic scale  sage  dp  initial  pbr fi  pbr sd query size
grows  times pbr include generation random initial plans
rewriting  times initial average initial plan construction across
restarts query  sage able solve queries involving   relations  larger
   

fiplanning rewriting

queries cannot solved within search limit         partial plan nodes  dp scales
better sage  cannot solve queries   relations      second time
limit  configurations pbr scale better sage dp  first improvement
search strategy pbr fi faster steepest descent pbr sd 
figure    b  shows cost query plans five planners  cost initial
average initial plans across restarts query  plan cost
estimate query execution cost  logarithmic scale used increasingly
larger absolute values plan costs conjunctive chain queries high
cost initial plans  pbr rewrites poor quality plans generated initial
high quality plans  pbr dp produce better plans sage  in range
tractable sage  experiment  happens searching larger
space bushy query trees take greater advantage parallel execution plans  pbr
produces plans quality comparable dp tractable range beyond range
pbr scales gracefully  two configurations pbr produce plans similar cost  though
pbr fi needed less planning time pbr sd  pbr sd generates plans local
neighborhood order select cheapest one  pbr fi generates portion
neighborhood since chooses first plan cheaper cost  pbr fi faster
average  figure    shows empirically domain locally optimal moves
steepest descent translate final solutions better cost produced
first improvement strategy 

    

 e   
sage
dp
initial
pbr fi
pbr sd

   

 e   
 e   

  

plan cost

planning time  cpu seconds 

 e   

 
sage
dp
initial
pbr fi
pbr sd

   

 e   
 e   
 e   
     
   

    

 
 

 

  

  
query size

  

  

  

 

 a  planning time

 

  

  
query size

  

  

  

 b  plan quality

figure     experimental results  distributed query planning

   related work
section review previous work related planning rewriting framework 
first  discuss work disciplines upon pbr builds  namely  classical ai
planning  local search  graph rewriting  then  discuss work related planrewriting algorithm 
   

fiambite   knoblock

    ai planning
pbr designed find balance among requirements planning efficiency  high quality
plans  flexibility  extensibility  great amount work ai planning focused
improving average case efficiency given general cases computationally hard
 erol et al          one possibility incorporate domain knowledge form search
control  recent example tlplan  bacchus   kabanza               forward search
planner shown remarkable scalability using control knowledge expressed temporal logic  systems automatically learn search control given planning domain
even specific problem instances  minton      b  shows deduce search control rules
problem solver applying explanation based learning problem solving traces 
discusses impact utility problem  utility problem  simply stated  says
 computational  benefits using additional knowledge must outweigh cost
applying it  pbr plan rewriting rules subject utility problem  quality
improvement obtained adding rewriting rules pbr based planner may
worth performance degradation  another approach automatically generating search
control analyzing statically operators  etzioni        inferring invariants
planning domain  gerevini   schubert        fox   long        rintanen         abstraction provides yet another form search control  knoblock      a  presents system
automatically learns abstraction hierarchies planning domain particular problem
instance order speed planning  plan rewriting rules learned techniques
analogous used learn search control  ambite  knoblock    minton        present
approach automatically learn plan rewriting rules based comparing initial
optimal plans example problems  alternatively  analyzing planning operators
combinations operators equivalent respect achievement
goals lead automatic generation rewriting rules 
local search algorithms used improve planning efficiency although
somewhat indirect way  planning reduced solving series propositional
satisfiability problems  kautz   selman         thus  kautz   selman        used
efficient satisfiability testing algorithm based local search solve sat encodings
planning problem  approach proved efficient specialized planning
algorithms  believe power approach stems use local search 
pbr directly applies local search plan structures  opposed translating first
larger propositional representation 
although approaches improve efficiency planning  specifically address plan quality  else consider simple cost metrics  such
number steps   systems learn search control addresses planning efficiency
plan quality  estlin   mooney        borrajo   veloso        perez         however 
reported experimental results  pbr appears scalable  moreover  pbr
provides anytime algorithm approaches must run completion 
    local search
local search long tradition combinatorial optimization  aarts   lenstra       
papadimitriou   steiglitz         local improvement ideas found application many
   

fiplanning rewriting

domains  general work relevant pbr constraint satisfaction 
scheduling  satisfiability testing  heuristic search 
constraint satisfaction  local search techniques able solve problems
orders magnitude complex respective complete  backtracking  approaches 
minton et al   minton  johnston  philips    laird        minton        developed simple
repair heuristic  min conflicts  could solve large constraint satisfaction scheduling
problems  scheduling operations hubble space telescope  minconflicts heuristic selects variable value assignment minimizes number
constraints violated  heuristic used cost function gradient descent
search informed backtracking search 
satisfiability testing similar method  gsat  introduced selman  levesque 
  mitchell         gsat solves hard satisfiability problems using local search
repairs consist changing truth value randomly chosen variable  cost function
number clauses satisfied current truth assignment  approach scales
much better corresponding complete method  the davis putnam procedure  
work scheduling rescheduling  zweben  daun    deale        define set
general  fixed  repair methods  use simulated annealing search space
schedules  plans networks actions opposed metric time totally ordered
tasks  easily specify different rewriting rules  general specific  suit
domain  opposed fixed strategies 
work inspired approaches several differences  first  pbr
operates complex graph structures  partial order plans  opposed variable assignments  second  repairs declaratively specified may changed problem
domain  opposed general fixed repair strategies  third  pbr accepts arbitrary measures quality  constraint violations min conflicts  number
unsatisfied clauses gsat  finally  pbr searches space valid solution plans 
opposed space variable assignments may internally inconsistent 
iterative repair ideas used heuristic search  ratner   pohl       
present two phase approach similar pbr  first phase  find initial valid
sequence operators using approximation algorithm  second phase  perform
local search starting initial sequence  cost function plan length 
local neighborhood generated identifying segments current solution sequence
attempting optimize them  repair consists heuristic search initial
state beginning segment goal end segment  shorter
path found  original sequence replaced new shorter segment  significant
difference pbr state space search  pbr planspace search  least committed partial order nature pbr allows optimize
plans ways cannot achieved optimizing linear subsequences 
    graph rewriting
pbr builds ideas graph rewriting  schurr         plan rewriting rules
pbr extension traditional graph rewriting rules  taking advantage
semantics planning pbr introduces partially specified plan rewriting rules 
rules need specify completely detailed embedding consequent pure
   

fiambite   knoblock

graph rewriting  nevertheless  several techniques transfer graph
rewriting planning rewriting  particularly fully specified rules  dorr       
defines abstract machine graph isomorphism studies set conditions
traditional graph rewriting performed efficiently  perhaps similar abstract
machine plan rewriting defined  idea rule programs appears
field implemented progres system  schurr              
    plan rewriting
work closely related plan rewriting algorithm plan merging  foulser  li   
yang         foulser et al  provide formal analysis algorithms exploiting positive
interactions within plan across set plans  however  work considers
case set operators replaced one operator provides
effects rest plan consumes fewer preconditions  focus
optimal approximate algorithms type operator merging  plan rewriting
pbr seen generalization operator merging subplan replace
another subplan  difference pbr concerned finding optimal merge
 rewritten plan  single pass optimization algorithm approach does 
pbr interested generating possible plan rewritings rewriting phase 
optimal one  optimization occurs  local  search progresses 
case based planning  e g   kambhampati        veloso        nebel   koehler       
hanks   weld        munoz avila        solves problem modifying previous solution 
two phases case based planning  first one identifies plan library
similar current problem  second phase previous plan adapted
solve new problem  pbr modifies solution current problem 
need retrieval phase associated similarity metrics  plan rewriting pbr
seen type adaptation solution problem alternate solution
problem  is  plan rewriting rule pbr identifies pair subplans  the
replaced replacement subplans  may interchangeable 
veloso        describes general approach case based planning based derivational
analogy  approach works three steps  first  retrieval phase selects similar
plan library  second  parts plan irrelevant current problem
removed  finally  system searches completion plan selecting much
possible decisions old plan did  sense planning knowledge
encoded previous solution transferred generation new solution plan 
plan rewriting algorithm partially specified rules pbr seen strongly
constrained version approach  pbr subplan rule consequent fixes
steps added repair plan  could use technique respecting
previous choice points completing plan way ensuring
structure plan repair maintained  could useful
constrain number rewritten plans large rewriting rules 
nebel koehler        present computational analysis case based planning 
context show worst case complexity plan modification better
plan generation point limitations reuse methods  related problem
pbr framework embedding replacement subplan partially specified rules 
   

fiplanning rewriting

explained section       may pathological cases number
embeddings exponential size plan deciding embedding exists
np hard  however  often interested finding rewritings  example
following first improvement search strategy  experience average case behavior
seems much better presented section   
systematic algorithms case based planning  such hanks   weld        invert
decisions done refinement planning find path solution similar old
problem new problem  rewriting rules pbr indicate transform
solution another solution plan based domain knowledge  opposed generic
inversion refinement operations  plan rewriting pbr done constrained
way instead open search space partial plans  however  rules
pbr may search space rewritings non systematically  effect ameliorated
using local search 

   discussion future work
paper presented planning rewriting  new paradigm efficient high quality
domain independent planning  pbr adapts graph rewriting local search techniques
semantics domain independent partial order planning  basic idea pbr
consists transforming easy to generate  possibly suboptimal  initial plan
high quality plan applying declarative plan rewriting rules iterative repair style 
several important advantages pbr planning approach  first  pbr
declarative domain independent framework  brings benefits reusability
extensibility  second  addresses sophisticated plan quality measures  work
domain independent planning addressed quality simple ways 
third  pbr scalable uses efficient local search methods  finally  pbr
anytime planning algorithm allows balancing planning effort plan quality order
maximize utility planning process 
planning rewriting provides domain independent framework local search  pbr
accepts declarative domain specifications expressive operator language  declarative
plan rewriting rules generate neighborhood plan  complex quality metrics  interchangeable initial plan generators  arbitrary  local  search methods 
planning rewriting well suited mixed initiative planning  mixed initiative
planning  user planner interact defining plan  example  user
specify available preferred actions moment  change quality criteria interest  etc  fact  domains approached mixed initiative
planning  example  quality metric expensive evaluate 
geometric analysis manufacturing  user must guide planner towards good quality
plans way small number plans generated evaluated  another example
plan quality metric multi objective changes time  several characteristics pbr support mixed initiative planning  first  pbr offers complete plans 
user easily understand plan perform complex quality assessment  second 
rewriting rule language convenient mechanism user propose modifications plans  third  selecting rules apply order application
user guide planner 
   

fiambite   knoblock

framework achieves balance domain knowledge  expressed plan rewriting
rules  general local search techniques proved useful many hard combinatorial problems  expect ideas push frontier solvable problems
many practical domains high quality plans anytime behavior needed 
planning style introduced pbr opens several areas future research 
great potential applying machine learning techniques pbr  important issue
generation plan rewriting rules  conceptually  plan rewriting rules arise
chosen plan equivalence relation  valid plans achieve given goals finite
number steps  i e  solution plans   satisfiability  equivalent  rule arises
theorem states two subplans equivalent purposes achieving
goals  addition conditions indicate context rule
usefully applied  plan rewriting rules generated automated procedures 
methods range static analysis domain operators analysis sample
equivalent plans achieve goals different costs  note similarity
methods automatically infer search control domain invariants  minton      b 
etzioni        gerevini   schubert        fox   long        rintanen        
need deal utility problem  ambite  knoblock    minton        present
results learning plan rewriting rules based comparing initial optimal plans
sample problems 
beyond learning rewriting rules  intend develop system automatically learn optimal planner configuration given planning domain problem
distribution manner analogous mintons multi tac system  minton        
system would perform search configuration space pbr planner proposing
candidate sets rewriting rules different search methods  testing proposed
configuration training set simple problems  system would hill climb
configuration space order arrive useful rewriting rules search strategies
given planning domain distribution problems 
many advanced techniques local search literature adapted
extended framework  particular  idea variable depth rewriting leads
naturally creation rule programs  specify set rules applied
plan  already seen query planning could find transformations
better specified program simple rewriting rules  example  sequence
join swap transformations may put two retrieve operators database together
query tree remote join eval would collapse explicit join operator
two retrieves single retrieval remote join  cherniack   zdonik             
present complex examples sort programs rewriting rules context
query optimizer object oriented databases 
discussed sections             language antecedent rewriting rules expressive conjunctive queries still remaining computationally efficient  example  figure    shows rule manufacturing domain
section     relationally complete antecedent  rule matches subplan contains spray paint operator  contain either punch drill press operators
create holes diameter smaller   millimeter  case  rule replaces
spray paint operator immersion paint operator  rule would useful
situation painting immersion could clog small holes 
   

fiplanning rewriting

 define rule  name sp by ip no small holes
 if   and   operator  n   spray paint  x  c  s  
  not   and   or   operator  n   punch  x  w  o  
  operator  n   drill press  x  w  o   
  less  w  mm    
 replace   operators   n   
 with   operator  n   immersion paint  x  c   

figure     rule relationally complete antecedent
another area research interplay plan rewriting plan execution 
sometimes best transformations plan may known portion
plan executed  information obtained run time guide planner
select appropriate rewritings  example  query planning plans may contain
information gathering actions  ashish  knoblock    levy        depend run time
conditions  yields form dynamic query optimization  interleaved planning
execution necessary order deal effectively unexpected situations
environment database network failures 
open area research relax framework accept incomplete plans
rewriting process  expands search space considerably benefits
pbr  anytime property  lost  domains shortest path
rewritings initial plan optimal may pass incomplete inconsistent
plans  idea could embodied planning style combines characteristics
generative planning planning rewriting  reminiscent plan critics
approach  sacerdoti        sussman         resulting plan rewriting rules seen
declarative specifications plan critics  plan refinements partial order
planning  kambhampati et al         hierarchical task network planning  erol  nau 
  hendler        easily specified plan rewriting rules 
applying pbr domains surely provide new challenges possibility
discovering transferring general planning techniques one domain another 
hope local search methods used pbr help planning techniques scale
large practical problems conversely domain independent nature pbr
help analysis principled extension local search techniques 

acknowledgments
paper extended version  ambite   knoblock        
research reported supported part fulbright ministerio educacion
ciencia spain scholarship  part defense advanced research projects agency
 darpa  air force research laboratory  air force materiel command  usaf 
agreement number f                 part national science foundation
grant number iri          part rome laboratory air force systems command defense advanced research projects agency  darpa  contract numbers f         c       f                 f                 f                 part
united states air force contract number f                 part
integrated media systems center  national science foundation engineering research
   

fiambite   knoblock

center  cooperative agreement no  eec          u s government authorized
reproduce distribute reports governmental purposes notwithstanding copyright
annotation thereon  views conclusions contained herein authors
interpreted necessarily representing official policies endorsements 
either expressed implied  organizations person connected
them 

references
aarts  e     lenstra  j  k          local search combinatorial optimization  john wiley
sons  chichester  england 
abiteboul  s   hull  r     vianu  v          foundations databases  addison wesley 
ambite  j  l          planning rewriting  ph d  thesis  university southern california 
ambite  j  l     knoblock  c  a          planning rewriting  efficiently generating
high quality plans  proceedings fourteenth national conference artificial
intelligence  pp         providence  ri 
ambite  j  l     knoblock  c  a          flexible scalable cost based query planning
mediators  transformational approach  artificial intelligence                    
ambite  j  l   knoblock  c  a     minton  s          learning plan rewriting rules 
proceedings fifth international conference artificial intelligence planning
scheduling systems breckenridge  co 
ashish  n   knoblock  c  a     levy  a          information gathering plans sensing
actions  steel  s     alami  r   eds    recent advances ai planning   th
european conference planning  ecp    springer verlag  new york 
avenhaus  j     madlener  k          term rewriting equational reasoning  formal
techniques artificial intelligence  pp       elsevier  north holland 
baader  f     nipkow  t          term rewriting that  cambridge university
press 
bacchus  f     kabanza  f          using temporal logic control search forward
chaining planner  proceedings  rd european workshop planning 
bacchus  f     kabanza  f          using temporal logics express search control knowledge planning  artificial intelligence                   
backstrom  c       a   executing parallel plans faster adding actions  cohn  a  g 
 ed    proceedings eleventh european conference artificial intelligence  pp 
       amsterdam  netherlands  john wiley sons 
backstrom  c       b   finding least constrained plans optimal parallel executions
harder thought  backstrom  c     sandewell  e   eds    current trends
ai planning  proceedings  nd european workshop planning  ewsp     
pp       vadstena  sweeden  ios press  amsterdam  
   

fiplanning rewriting

backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                 
blum  a  l     furst  m  l          fast planning planning graph analysis 
proceedings fourteenth international joint conference artificial intelligence
montreal  canada 
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                  
bonet  b     geffner  h          planning heuristic search  new results  proceedings
fifth european conference planning  ecp     durham  uk 
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism planning  proceedings fourteenth national conference artificial
intelligence  pp         providence  ri 
borrajo  d     veloso  m          lazy incremental learning control knowledge
efficiently obtaining quality plans  ai review             
bylander  t          computation complexity propositional strips  artificial intelligence                   
carbonell  j  g   knoblock  c  a     minton  s          prodigy  integrated architecture planning learning  vanlehn  k   ed    architectures intelligence 
pp          lawrence erlbaum  hillsdale  nj 
cherniack  m     zdonik  s  b          rule languages internal algebras rule based
optimizers  sigmod record  acm special interest group management data  
               
cherniack  m     zdonik  s  b          changing rules  transformations rulebased optimizers  proceedings acm sigmod international conference
management data  pp       seattle  wa 
dean  t     boddy  m          analysis time dependent planning  proceedings
seventh national conference artificial intelligence  pp       saint paul  mn 
dorr  h          efficient graph rewriting implementation  vol      lecture notes
computer science  springer verlag inc   new york  ny  usa 
erol  k   nau  d     hendler  j          umcp  sound complete planning procedure
hierarchical task network planning  proceedings second international
conference artificial intelligence planning systems  pp         chicago  il 
erol  k   nau  d     subrahmanian  v  s          decidability undecidability results
domain independent planning  artificial intelligence                 
estlin  t  a     mooney  r  j          learning improve efficiency quality
planning  proceedings fifteenth international joint conference artificial
intelligence  pp           nagoya  japan 
   

fiambite   knoblock

etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence                 
etzioni  o     weld  d  s          softbot based interface internet  communications acm         
fikes  r  e     nilsson  n  j          strips  new approach application
theorem proving problem solving  artificial intelligence                  
forgy  c  l          rete  fast algorithm many pattern many object pattern
match problem  artificial intelligence           
foulser  d  e   li  m     yang  q          theory algorithms plan merging  artificial
intelligence                  
fox  m     long  d          automatic inference state invariants tim  journal
artificicial intelligence research            
gerevini  a     schubert  l          inferring state constraints domain independent
planning  proceedings fifteenth national conference artificial intelligence  pp         madison  wi 
glover  f          tabu searchpart i  orsa journal computing                
gomes  c  p   selman  b     kautz  h          boosting combinatorial search
randomization  proceedings fifteenth national conference artificial intelligence madison  wi 
gupta  n     nau  d  s          complexity blocks world planning  artificial
intelligence                  
hanks  s     weld  d  s          domain independent algorithm plan adaptation 
journal artificicial intelligence research            
johnson  d  s          local optimization traveling salesman problem  paterson 
m  s   ed    automata  languages programming  proc    th international
colloquium  pp          springer  new york 
kambhampati  s          validation structure based theory plan modification
reuse  artificial intelligence                   
kambhampati  s   knoblock  c  a     yang  q          planning refinement search 
unified framework evaluating design tradeoffs partial order planning 
artificial intelligence                   
kautz  h     selman  b          planning satisfiability  neumann  b   ed    proceedings   th european conference artificial intelligence  pp         vienna 
austria  john wiley   sons 
   

fiplanning rewriting

kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings thirteenth national conference artificial
intelligence  pp           portland  or 
kirkpatrick  s   gelatt  c  d     vecchi  m  p          optimization simulated annealing 
science              
knoblock  c  a       a   automatically generating abstractions planning  artificial
intelligence                 
knoblock  c  a       b   generating parallel execution plans partial order planner  proceedings second international conference artificial intelligence
planning systems chicago  il 
knoblock  c  a          planning  executing  sensing  replanning information gathering  proceedings fourteenth international joint conference artificial
intelligence montreal  canada 
knoblock  c  a          building planner information gathering  report
trenches  proceedings third international conference artificial intelligence planning systems edinburgh  scotland 
koehler  j          solving complex planning tasks extraction subproblems 
simmons  r   veloso  m     smith  s   eds    proceedings fourth international
conference artificial intelligence planning systems  pp       pittsburgh  pa 
koehler  j     hoffmann  j          reasonable forced goal orderings use
agenda driven planning algorithm  journal artificial intelligence research 
           
koehler  j   nebel  b   hoffman  j     dimopoulos  y          extending planning graphs
adl subset  steel  s     alami  r   eds    proceedings fourth european
conference planning  ecp      recent advances ai planning  vol      
lnai  pp         berlin  springer 
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
ninth national conference artificial intelligence anaheim  ca 
minton  s       a   learning effective search control knowledge  explanation based
approach  ph d  thesis  computer science department  carnegie mellon university 
minton  s       b   learning search control knowledge  explanation based approach 
kluwer  boston  ma 
minton  s          minimizing conflicts  heuristic repair method constraintsatisfaction scheduling problems  artificial intelligence                   
minton  s          automatically configuring constraint satisfaction programs  case
study  constraints             
   

fiambite   knoblock

minton  s   johnston  m  d   philips  a  b     laird  p          solving large scale constraint satisfaction scheduling problems using heuristic repair method  proceedings eighth national conference artificial intelligence  pp       boston 
ma 
munoz avila  h          integrating twofold case retrieval complete decision replay
caplan cbc  ph d  thesis  university kaiserslautern 
nau  d  s   gupta  s  k     regli  w  c          ai planning versus manufacturingoperation planning  case study  proceedings fourteenth international
joint conference artificial intelligence montreal  canada 
nebel  b     koehler  j          plan reuse versus plan generation  theoretical
empirical analysis  artificial intelligence                     
ono  k     lohman  g  m          measuring complexity join enumeration query
optimization  mcleod  d   sacks davis  r     schek  h  j   eds      th international conference large data bases  pp         brisbane  queensland 
australia  morgan kaufmann 
papadimitriou  c  h     steiglitz  k          complexity local search
traveling salesman problem  siam              
papadimitriou  c  h     steiglitz  k          combinatorial optimization  algorithms
complexity  prentice hall  englewood cliffs  nj 
penberthy  j  s     weld  d  s          ucpop  sound  complete  partial order planner
adl  third international conference principles knowledge representation
reasoning  pp         cambridge  ma 
perez  m  a          representing learning quality improving search control knowledge 
proceedings thirteenth international conference machine learning bari 
italy 
ratner  d     pohl  i          joint lpa   combination approximation search 
proceedings fifth national conference artificial intelligence philadelphia 
pa 
rintanen  j          iterative algorithm synthesizing invariants  proceedings
seventeenth national conference artificial intelligence austin  tx 
russell  s     norvig  p          artificial intelligence  modern approach  prentice hall 
sacerdoti  e  d          nonlinear nature plans  proceedings fourth
international joint conference artificial intelligence  pp         tbilisi  georgia 
ussr 
savage  s   weiner  p     bagchi  a          neighborhood search algorithms guaranteeing optimal traveling salesman tours must inefficient  journal computer
system sciences               
   

fiplanning rewriting

schurr  a          introduction progres  attribute graph grammar based specification language  nagl  m   ed    graph theoretic concepts computer science 
vol      lecture notes computer science  pp         
schurr  a          programmed graph replacement systems  rozenberg  g   ed   
handbook graph grammars  foundations  vol     pp          world scientific 
singapore 
sellis  t  k          multiple query optimization  acm transactions database systems 
             
selman  b   levesque  h     mitchell  d          new method solving hard satisfiability
problems  proceedings tenth national conference artificial intelligence
 aaai      pp         san jose  california  aaai press 
silberschatz  a   korth  h  f     sudarshan  s          database system concepts  third
edition   mcgraw hill 
simon  h          sciences artificial  mit press 
slaney  j     thiebaux  s          linear time near optimal planning blocks world 
proceedings thirteenth national conference artificial intelligence
eighth innovative applications artificial intelligence conference  pp          
menlo park  aaai press   mit press 
sussman  g  j          computer model skill acquisition  american elsevier  new
york 
veloso  m          planning learning analogical reasoning  springer verlag 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning parallel
resource allocation  proceedings workshop innovative approaches
planning  scheduling control  pp         san diego  ca 
weld  d  s          introduction least commitment planning  ai magazine         
weld  d  s          recent advances ai planning  ai magazine         
yu  c     chang  c          distributed query processing  acm computing surveys         
       
zweben  m   daun  b     deale  m          scheduling rescheduling iterative
repair  intelligent scheduling  pp          morgan kaufman  san mateo  ca 

   


