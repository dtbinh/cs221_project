journal artificial intelligence research               

submitted        published     

goal recognition goal graph analysis
j hong ulst ac uk

jun hong
school information software engineering
university ulster jordanstown
newtownabbey  co  antrim bt    qb  uk

abstract
present novel approach goal recognition based two stage paradigm graph
construction analysis  first  graph structure called goal graph constructed
represent observed actions  state world  achieved goals well
various connections nodes consecutive time steps  then  goal graph
analysed time step recognise partially fully achieved goals
consistent actions observed far  goal graph analysis reveals valid
plans recognised goals part goals 
approach goal recognition need plan library  suer
problems acquisition hand coding large plan libraries  neither
problems searching plan space exponential size  describe two algorithms
goal graph construction analysis paradigm  algorithms
provably sound  polynomial time  polynomial space  number goals recognised
algorithms usually small sequence observed actions
processed  thus sequence observed actions well explained recognised goals
little ambiguity  evaluated algorithms unix domain 
excellent performance achieved terms accuracy  eciency  scalability 

   introduction
plan recognition involves inferring intentions agent set observations 
typical approach plan recognition uses explicit representation possible plans
goals  often called plan library  conducts type reasoning basis set
observations identify plans goals plan library  could caused
observations 
plan recognition useful many areas  including discourse analysis natural language question answering systems  story understanding  intelligent user interfaces 
multi agent coordination  much early research plan recognition done natural language question answering systems  allen   perrault        allen        sidner 
      litman   allen        carberry        pollack        grosz   sidner        
systems  plan recognition used support intelligent response generation 
understand sentence fragments  ellipsis indirect speech acts  track speakers ow
discourse  deal correctness completeness discrepancies
knowledge users systems 
plan recognition enhance user interfaces  recognition users goals
plans interaction interface facilitates intelligent user help  carver  lesser 
  mccue        hu   lesser        goodman   litman        bauer   paul       
lesh   etzioni         plan recognition enables interface assist user task
c
    
ai access foundation morgan kaufmann publishers  rights reserved 

fihong

completion  error detection recovery  wilensky   et al          interface
watching users shoulder infer goals plans  decide
help assistance user needs 
story understanding  schank   abelson        wilensky        charniak   goldman 
       useful recognise goals plans characters described
actions order understand characters doing  multi agent coordination 
ecient eective coordination among multiple agents requires modelling agents
goals plans  huber  durfee    wellman        huber   durfee        
given set observations  plan recognition systems  allen   perrault       
carberry        litman   allen        kautz        pollack         search space
possible plan hypotheses candidate plans goals account observations 
form search space given domain  kind plan library required 
instance  kautzs event hierarchy  kautz         plan decompositions required
describe low level actions make complex actions  despite obvious advantage
expressive richness  use plan library limitations  first  able deal
new plans whose types appear plan library  second  acquiring handcoding plan library large complex domain presents tedious impractical task 
third  domains  knowledge plans might readily available 
attempts  mooney        forbes  huang  kanazawa    russell        lesh  
etzioni        albrecht  zukerman    nicholson        bauer        recently
made apply machine learning techniques automated acquisition coding plan
libraries  even leaving aside plan library consideration  searching plan space
can  however  exponentially expensive number possible plan hypotheses
exponential number actions  kautz         plan recognition systems
developed domains peoples behaviour characterized fewer
    plans goals  lesh   etzioni        
paper  focus goal recognition  special case plan recognition 
introduce novel approach goal recognition  graph construction analysis
used paradigm  approach signicantly diers plan recognition systems 
first  approach need plan library  instead dene constitutes valid
plan goal  need consider observed actions organised plans 
hence problems associated acquisition hand coding
plan library large complex domain well availability planning knowledge
domain  plan recognition systems cannot recognise new plans whose types
appear plan library  without using plan library  approach suer
limitation  second  instead immediately searching plan plan space
plan recognition systems  approach explicitly constructs graph structure 
called goal graph  analysed recognise goals plans  approach
therefore problems searching plan space exponential size  third 
approach recognises partially fully achieved goals consistent
actions observed far  number recognised goals usually small
sequence observed actions processed  thus sequence observed actions
well explained recognised goals little ambiguity 
emphasised approach goal recognition  purpose recognising partially fully achieved goals explain past actions rather predicting
 

figoal recognition goal graph analysis

future actions  particularly useful problem areas story understanding 
software advisory systems  database query optimisation  customer data mining 
problem areas several specic characteristics  first  actions either described observed  second  likely users intended goal partially
fully achieved actions  third  recognising intended goal aims explaining past actions rather predicting future actions  finally  distinguishing partially
fully achieved goals others greatly reduces ambiguity involved recognising
intended goal 
story understanding  actions characters described story  recognising goals plans account described actions enables better understanding
characters doing  software advisory systems  user
observed issue sequence operations software application  system rst
recognise task user performed  system decide whether user
performed task suboptimal way  advice given user
better perform task  database query optimisation  user conducted sequence data retrieval manipulation operations  recognising underlying
query lead advice query optimisation query executed
optimal way  customer data mining  individual customers shopping goals
recognised logged customer on line shopping data  form basis
performing customer data mining tasks 
algorithms goal graph construction analysis provably sound 
polynomial time  polynomial space  empirical results unix domain show
algorithms perform well terms accuracy  eciency  scalability 
show algorithms scaled applied domains tens
thousands possible goals plans  though algorithm goal graph analysis
complete  recognised every goal intended successfully achieved
subject unix data set used evaluation  since new graph based
approach goal recognition fundamentally dierent existing methods plan
recognition  provides alternative methods new perspective plan
recognition problem 
rest paper organised follows  first  give overview novel
approach goal recognition  section    discuss domain representation 
section   dene goal graphs  valid plans  consistent goals  section   present
goal recognition algorithms together analysis algorithms  section  
discuss empirical results  summarise paper discuss limitations future
work last section 

   novel approach goal recognition
section  describe basic assumptions make goal recognition problem
outline approach  discuss previous work planning planning graphs
graph based approach goal recognition  briey describe empirical results
favour approach 
 

fihong

    basic assumptions
start example unix domain  observe user types two
commands  cd papers ls  one another  able infer user
wants nd le subdirectory directory  papers  two reasons  first  goal
fully achieved  second  relevant commands consistent way
sense rst command satises one preconditions second command
second command achieves recognised goal  recognised goal might
intermediate goal user  users intended goal might one le related
goals  instance  deleting le directory  since commands
part plans almost le related goals  impossible us uniquely identify
users intended goal current time step  yet goal nding le directory
well explains commands  user next types command  rm oldpaper tex 
infer users goal delete le  oldpaper tex  directory  papers 
goal fully achieved relevant commands observed
far consistent way sense rst command satises one preconditions
second third commands  second command satises one preconditions
third command  third command achieves recognised goal 
example highlights way new approach goal recognition works  make
following assumptions goal recognition problem  first  set actions
observed consecutive time steps   second  initial state world immediately
set actions observed known   third  domain knowledge
actions goals  is  know preconditions eects every observed action 
every possible goal explicitly specied set goal descriptions 
given assumptions  action observed time step  want infer
goals partially fully achieved time step whether
achieved goals relevant strict majority actions observed far consistent
way sense actions organised plan structure goal
part it 
    goal recognition goal graph
propose use graph structure  called goal graph  new approach goal
recognition  view goal recognition problem process graph construction
analysis  goal graph  action nodes represent actions observed consecutive time
steps  proposition nodes represent state world consecutive time steps 
changed initial state subsequent states observed actions  goal
nodes represent goals partially fully achieved consecutive time steps 
edges goal graph explicitly represent relations actions propositions
well relations propositions goals  based explicit relations
constructed goal graph  causal links either two actions action goal
recognised  recognised causal links  decided whether fully
partially achieved goal time step relevant strict majority observed
   observed actions partially ordered sense one action observed
time step temporal ordering constraint actions 
   approach however reasons state world subsequent time steps 

 

figoal recognition goal graph analysis

actions far consistent way sense relevant actions organised
plan structure goal part it  approach  extraneous  redundant 
partially ordered actions plans handled 
attempt use graph construction analysis paradigm goal recognition
spirit inuenced blum fursts eorts planning planning graphs  blum
  furst         introduced new graph based approach planning strips
domains  graph structure called planning graph rst constructed explicitly
rather searching immediately plan standard planning methods  many useful
constraints inherent planning problem made explicitly available planning
graph reduce amount search needed  planning graph analysed
generate possible plans 
goal graph based approach goal recognition seen counterpart
planning planning graph  though graph structures used approaches 
composed dierent kinds nodes edges  time step  planning graph
represents possible propositions either added actions previous time step
brought forward maintenance actions previous time step  possible
actions whose preconditions satised propositions time step 
hand  goal graph  time step  represents propositions either added
actions observed previous time step brought forward maintenance actions
previous time step  actions observed time step  addition  goal
graph  time step  represents possible goals  either fully partially achieved
time step  planning graph represent goal all  accordingly 
planning graph represents relations actions propositions  goal
graph represents relations propositions goals 
analysis planning graph aims search possible subgraphs
planning graph  form valid plans given goal  hand 
analysis goal graph aims search every possible partially fully goal
exists subgraph goal graph  consisting strict majority observed
actions  subgraph forms valid plan goal part shows
strict majority observed actions relevant goal consistent way 
domain representation planning planning graph
goal recognition goal graph  regard  previous eorts handling
expressive representation languages  gazen   knoblock        anderson  smith    weld 
      koehler  nebel  homann    dimopoulos        still useful goal recognition 
languages allow use disjunctive preconditions  conditional eects  universally
quantied preconditions  goal descriptions  eects action goal representation 
adl like domain representation actually based work  allows use
conditional eects  universally quantied eects  existentially universally quantied
preconditions goal descriptions action goal representation 
goal graph based approach extends lesh etzionis previous work
use graph representation actions goals goal recognition problem  lesh  
etzioni         used graph representation  called consistency graph  goal
recognition problem  consistency graph consists action goal nodes representing
possible actions goals  edges representing possible connections nodes
 

fihong

graph  initially  action goal nodes fully connected consistency
graph  inconsistent goals repeatedly pruned consistency graph 
number major dierences lesh etzionis approach ours 
first  two dierent graph representations used  apart action goal nodes 
consistency graph nodes representing propositions model
state world changed observed actions  therefore  consistency graph
explicitly reveal causal links actions goals  neither system
know whether goal partially fully achieved observed actions  goal
graph consists action  goal  proposition nodes  explicitly reveals causal links
actions goals  hence system knows observed actions composed
valid plans recognised goals part goals  systems knows whether
goal partially fully achieved observed actions 
second  goal consistency dened dierently  lesh etzionis approach  goal
consistent exists plan includes observed actions achieves
goal  approach  goal consistent partially fully achieved
observed actions relevant strict majority observed actions  also  two
dierent recognition processes used  approach pruning process used
prune inconsistent goals consistency graph  pruning process guarantees
goals pruned consistency graph inconsistent goals  however  number
consistent goals  still remaining consistency graph pruning  usually large  thus
ambiguity intended goal remains issue addressed  approach instead
uses graph analysis process directly recognise consistent goals fully
partially achieved goals  number consistent goals recognised goal graph
usually small  third  approach requires every observed action relevant
goal  strict majority observed actions required relevant
goal approach 
developed two algorithms  goalgraphconstructor goalgraphanalyser 
based two stage paradigm goal graph construction analysis  goalgraphconstructor algorithm takes set actions observed dierent time
steps constructs goal graph  goalgraphanalyser algorithm analyses constructed goal graph recognise consistent goals valid plans  prove
algorithms sound  polynomial time  polynomial space 
algorithms implemented prolog tested unix domain
desktop pentium iii processor     mhz  used set data  collected
unix domain university washington  domain representation    action
schemata     goal schemata  entire unix data set  average took
cpu seconds update goal graph observed action processed  usually
small number consistent goals remained sequence actions
observed  test cases intended goals successfully achieved
subjects  intended goals among remaining goals recognised
complete sequences actions observed  test scalability algorithms 
tested series spaces approximate                   candidate goals
respectively unix domain  approximate linear time performance
achieved  empirical results show algorithms scaled applied
domains tens thousands possible goals plans 
 

figoal recognition goal graph analysis

   domain representation
use adl like representation  pednault         including actions conditional
universally quantied eects  existentially well universally quantied preconditions
goal descriptions  approach goal recognition  goal recognition problem
consists
set action schemata specifying primitive actions 
nite  dynamic universe typed objects objects either added
deleted action 
set propositions called initial conditions 
set goal schemata specifying possible goals 
set actions observed consecutive time steps  
solution goal recognition problem consists set partially fully achieved
goals consistent set observed actions together valid plans
consisting observed actions recognised goals part them 
goal schema consists set goal descriptions  gds  dened
following ebnf denitions 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 

   
   
   
   
   
   
   
   
   

 term 
 not  term  
 neg  term  
 and  gd   
 imply  gd   gd  
 exist  term   gd  
 forall  term   gd  
 eq  argument   argument  
 neq  argument   argument  

action schema consists set preconditions set eects  set
preconditions dened goal descriptions  set eects dened
following ebnf denitions 
 effect 
 effect 
 effect 
 effect 
 effect 

   
   
   
   
   

 term 
 neg  term  
 and  effect   
 when  gd   effect  
 forall  term   effect  

   say observed action  mean action observed successfully executed 
ignore invalid actions  unix domain  instance  invalid actions issued
commands unix failed execute responded error messages 

 

fihong

two sets ebnf denitions   term  atomic expression form 
 term        predicate name   argument   
 argument       constant name 
 argument       variable name 
use eq neq specify equality inequality constraints  two negation
connectives  neg not  use  neg a  specically mean truth value
made explicitly known false action  use  not a  mean truth value
known false either explicitly implicitly  latter kind representation
used necessary represent truth value explicitly known
false long known false  closed world assumption therefore
implemented follows  initial state world  explicitly represent
propositions known true initial conditions  proposition explicitly
represented state world implicitly known false  actions however may
add propositions explicitly known false state world  proposition
become explicitly known false made explicitly known
false action  important represent propositions explicitly known
false  want explicitly represent eects actions causal links
either two actions action goal established 
goal action schemata parameterised typed variables represented
terms object type predicates  goal ground instance goal schema 
action ground instance action schema  set goal descriptions goal must
satised state world goal fully achieved 
goal descriptions satised instead  goal partially achieved  positive literals
goal descriptions represent propositions true state world  negative literals
goal descriptions represent propositions known false state world 
use imply specify dependency constraints goal descriptions  goal description gd 
implied another goal description gd    gd  satised gd  satised
gd  satised without gd  satised  goal description existentially
universally quantied dynamic universe objects 
set preconditions must satised state world action
executed  set preconditions syntax semantics
set goal descriptions  set eects taken state world
action executed  positive literals eects represent propositions true state
world action executed  propositions added state
world  negative literals eects represent propositions longer true state
world action executed  propositions deleted state
world  negations propositions added state world 
representing propositions explicitly known false state world
action executed  furthermore  conditional eect consists antecedent
consequent  antecedent set preconditions consequent set
eects  eects consequent taken preconditions
antecedent satised state world action executed  eect
action schema universally quantied dynamic universe objects 
 

figoal recognition goal graph analysis

use simple example domain extended pednaults famous example  pednault 
       involves transportation two physical objects  dictionary  chequebook 
home oce using briefcase  assume one physical object
carried briefcase time  extended briefcase domain consists
special physical object  briefcase 
two physical objects  dictionary chequebook 
two locations  home oce 
three action schemata 
moving briefcase one location another 
putting physical object briefcase 
taking physical object briefcase 
three goal schemata 
moving physical object one location another 
keeping physical object location 
keeping physical object briefcase 
action goal schemata example domain shown figure   
used throughout paper 
actual implementation goal recognition algorithms  universally quantied
preconditions eects  conditional eects action schemata eliminated 
equivalent schemata created  use particular approach call dynamic expansion 
dynamic expansion involves two steps  rst step  universally quantied preconditions
eects action schema dynamically compiled corresponding herbrand
bases  taking account universe objects current time step  universally
quantied preconditions eects dynamically compiled assume
universe objects dynamically changed  assumption needed
domain unix shell system destruction creation objects required 
assumption dynamic universe objects  object universe 
object type must declared time step immediately action
executed  object initial universe objects  type must declared
initial conditions  object either added deleted universe objects
action time step  eect either stating proposition new object
negating proposition existing object 
instance  suppose time step immediately instance action
schema mov b shown figure   executed  universe objects consists three physical
objects  b  c  d  action schema mov b dynamically compiled action schema
mov b   follows 
 

fihong

  action mov b
 paras   l  m   loc 
 pre  and  neq  l  m  at b  l  
 eff  and  at b  m   neg  at b  l  
 forall   z   physob 
 when  in  z 
 and  at  z  m 
 neg  at  z  l        
  action put in
 paras   x   physob  l loc 
 pre  and  neq  x b  at  x  l  at b  l  
 forall   z   physob 
 not  in  z    
 eff  in  x   
  action take out
 paras   x   physob 
 pre  in  x 
 eff  neg  in  x    
  goal move object
 paras   x   physob  l  m   loc 
 goal des  and  neq  l  m 
 neq  x b 
 imply  neg  at  x  l  
 at  x  m     
  goal keep object at
 paras   x   physob  l   loc 
 goal des  and  neq  x b 
 imply  at  x  l 
 not  in  x      
  goal keep object in
 paras   x   physob 
 goal des  in  x   
figure    action goal schemata extended briefcase domain

  

figoal recognition goal graph analysis

  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l  
 eff  and  at b  m   neg  at b  l  
 when  in b 
 and  at b  m 
 neg  at b  l    
 when  in c 
 and  at c  m 
 neg  at c  l    
 when  in d 
 and  at  m 
 neg  at  l       
second step  conditional eects mov b   eliminated  assume
that  time step  following propositions true   at b h    at c h    at h  
 in d   conditional eects mov b    whose antecedents satised
time step  removed  therefore action schema mov b   
  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l  
 eff  and  at b  m   neg  at b  l  
 when  in d 
 and  at  m 
 neg  at  l       
antecedent remaining conditional eect mov b   already satised
time step moved existing preconditions  nally action schema
mov b   current time step  action schema mov b   equivalent original
action schema mov b current time step  mov b   actually used
action schema  moving briefcase one location another  time step 
  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l 
 in d  
 eff  and  at b  m   neg  at b  l  
 at  m   neg  at  l    
universally quantied goal descriptions goal schema treated
way universally quantied preconditions action schema 

   goal graphs  valid plans consistent goals
section  rst describe structure goal graph  dene
mean say set observed actions forms valid plan achieving goal given
  

fihong

mov b h

put in h

mov b h

actions

b
h

b h
b

b h

b

b

b h

c h

h

h



c h

c h

h
c h




keep object at h

keep object at h

keep object at c h

keep object at c h
keep object in d 

propositions

move object h o 

keep object at c h

goals

keep object at c h
keep object in
keep object at

level  

level  

level  

level  

figure    goal graph example extended briefcase domain
initial conditions  nally dene mean say goal consistent
set observed actions 
    goal graphs
goal graph represents actions observed  propositions true explicitly known
false  fully partially achieved goals consecutive time steps  goal graph
explicitly represents connections propositions  actions  goals graph 
goal graph directed  levelled graph  levels alternate proposition
levels containing proposition nodes  each labelled proposition negation proposition   representing state world consecutive time steps  goal levels containing
goal nodes  each labelled goal   representing goals fully partially achieved consecutive time steps  action levels containing action nodes  each labelled action  
representing actions observed consecutive time steps  levels goal graph start
proposition level time step    consisting one node proposition true
initial conditions  end goal level last time step  consisting
node goals either fully partially achieved actions observed far 
levels are  propositions true time step    goals achieved time step    actions
observed time step    propositions true explicitly known false time step   
goals achieved time step    actions observed time step    propositions true explicitly
known false time step    goals achieved time step    forth 
goal nodes goal level connected description edges goal descriptions proposition level i  action nodes action level connected precondition
edges preconditions proposition level i  eect edges eects
proposition level      proposition nodes proposition level connected via
persistence edges corresponding proposition nodes proposition level     
truth values aected actions action level i  persistence edges
represent eects maintenance actions simply bring forward proposition nodes
proposition level i  aected actions action level i  proposition level     
example shown figure    three actions observed three consecutive time steps   mov b h    put in h    mov b h o   initial conditions
  

figoal recognition goal graph analysis

consist of   at b o    at h    at c h   action goal nodes top
bottom parts graph respectively  proposition nodes middle part
graph  edges connecting proposition nodes action node level
precondition edges  edges connecting action node one level propositions
subsequent level eect edges  edges connecting proposition nodes goal
nodes level description edges  edges connecting proposition nodes
one level proposition nodes subsequent level persistence edges  goal nodes
bold represent consistent goals  among goal nodes italics represent partially
achieved goals  others represent fully achieved goals  edges bold show
causal link paths  goal nodes asterisk represent recognised goals 
    valid plans
dene mean say set observed actions forms valid plan
goal  given initial conditions 
definition    causal link  let ai aj two observed actions time steps j
respectively    j  exists causal link ai aj   written ai aj  
one eects ai satises one preconditions aj  
instance  example shown figure    exists causal link actions
 mov b h  time step    put in h  time step    since one eects
rst action   at b h   satised one preconditions second action 
goal treated action goal descriptions preconditions
empty set eects  therefore  causal links established observed actions
goals 
instance  example shown figure    exists causal link action
 mov b h o  time step   goal  move object h o  time step    since one
eects action   at o   satised one goal descriptions goal 
valid plan goal dened basis temporal ordering constraints
causal links set observed actions  valid plan p goal g  given initial
conditions  represented   tuple    a  o  l    set observed actions 
set temporal ordering constraints a  l set causal links a 
definition    valid plan  let g goal  p    a  o  l    set
observed actions  set temporal ordering constraints   ai   aj    a  l
set causal links   ai aj    a  let initial conditions  p valid plan
g  given i 
   actions executed order consistent o 
   goal g fully achieved actions executed order
consistent o 
instance  example shown figure    given initial conditions      at
b o    at h    at c h    p     a     mov b h   a     put in h   a     mov b
h o     a    a    a    a      a  a    a  a    a  a     valid plan goal g  
 move object h o  
  

fihong

    consistent goals
dene mean say goal consistent set observed
actions  set observed actions represented   tuple    a    
set observed actions set temporal ordering constraints   ai   aj    a  
definition    relevant action  given goal g set observed actions    a    
action said relevant g context   a    
   exists causal link  g 
   exists causal link  b  b relevant g   b consistent
o 
definition    consistent goal  goal g consistent set observed actions 
  a     strict majority relevant g context
  a    
proposition    valid plan consistent goal  let   a    set observed
actions  initial conditions   a     g goal consistent   a    
exists set causal links  l    ai aj    given i  p    a  o  l  
valid plan either g g fully achieved time step   a   
observed achieved part g g partially achieved time step
  a    observed 
proof  g fully achieved time step set actions observed 
directly follows denitions     exists set causal links  l    ai aj   
a  follows denition   given i  p    a  o  l   valid plan g 
g partially achieved time step set actions observed 
let g achieved part g  g fully achieved time step set
actions observed  directly follows denitions        exists
set causal links  l    ai aj    given i  p    a  o  l   valid plan
g   
instance  example shown figure      a         a     mov b
h   a     put in h   a     mov b h o     a    a    a    a       g    move object
h o  fully achieved goal time step   a    observed  according
denition      g consistent   a    exist causal links  a  g
a  g  a  a  a  a    a  a  a  a    a  a 
a  a    let initial conditions   a     l    a  a    a  a   
a  a     according proposition    p    a  o  l   valid plan g  furthermore 
causal link  a  g  explains purpose a   
summary  according denition   proposition    say goal consistent
set observed actions  mean strict majority observed actions
relevant goal set observed actions forms valid plan goal
achieved part it 
   assume actions observed consecutive time steps one action observed
time step 

  

figoal recognition goal graph analysis

   goal recognition algorithms
describe goal recognition algorithms  goal recognition algorithms run
two stage cycle time step  rst stage  goalgraphconstructor algorithm
takes actions observed time step tries extend goal graph  second
stage  goalgraphanalyser algorithm analyses constructed goal graph recognise
fully partially achieved goals  consistent actions observed far 
valid plans goals part them  two stage cycle continues
action observed next time step 
    constructing goal graph
use   tuple   p  ao   gr   e   represent goal graph  p set proposition nodes  ao set action nodes  gr set goal nodes  e set edges 
proposition node represented prop p  i   p positive negative ground literal 
time step  action node represented action a  i   observed action
time step  goal node represented goal g  i   g goal
time step  precondition edge represented precondition edge prop p  i   action a  i   
eect edge represented eect edge action a  i   prop p         description edge
represented description edge prop p  i   goal g  i    persistence edge represented
persistence edge prop p      prop p  i   
goalgraphconstructor algorithm consists two algorithms  goal expansion
algorithm action expansion algorithm  goalgraphconstructor algorithm starts
goal graph    p                consists proposition level   nodes
representing initial conditions 
given goal graph ending proposition level i  goal expansion algorithm rst
extends goal graph goal level i  nodes representing goals fully partially
achieved time step i  algorithm goes every possible ground instance goal
schemata  every goal instance  rst gets set goal descriptions  eliminates
universally quantied goal descriptions dynamic expansion get equivalent
set goal descriptions  goal node added onto goal level represent achieved
goal  least one goal descriptions satised proposition level i 
decided whether goal fully partially achieved  based whether
goal descriptions satised respectively proposition level i  meanwhile 
node proposition level satises goal description  description edge connecting
proposition node goal node added onto goal graph  figure   shows
goal expansion algorithm  algorithm takes goal graph   p  ao   gr   e   ending
proposition level i  time step i  set goal schemata g input  returns
updated goal graph ending goal level goal expansion 
actions observed time step i  action expansion algorithm extends goal graph ending goal level i  action level i  nodes representing
observed actions  time  algorithm extends goal graph
proposition level      nodes representing propositions true explicitly known
false actions observed 
every action observed time step i  algorithm rst instantiates action schema
observed action get precondition set eect set  eliminates
  

fihong

goal expansion   p  ao   gr   e    i  g 
   every gk g
every instance g gk
a  get set goal descriptions sg  
b  get equivalent set sg   sg  
c  every pg sg   pg   not pg   
prop neg pg    i  p  
add description edge prop neg pg   i   goal g  i   e 
d  every pg sg   pg   not pg   
prop pg   i  p  
add description edge prop pg  i   goal g  i   e 
e  one goal descriptions g satised 
add goal g  i  gr  
   return   p  ao   gr   e   
figure    goal expansion algorithm

universally quantied preconditions eects  well conditional eects 
dynamic expansion get equivalent precondition eect sets  meanwhile  node
proposition level satises precondition action  precondition edge  connecting
proposition node action node  added onto goal graph  every eect
action  action expansion algorithm simply adds proposition node representing
eect proposition level      eect edge action node proposition
node added onto goal graph 
expansion  every proposition node proposition level brought
forward proposition level     maintenance action  truth value
changed action observed time step  and added onto goal graph
action observed time step i    persistence edges  connecting corresponding
proposition nodes two proposition levels  added onto goal graph 
figure   shows action expansion algorithm  algorithm takes goal graph
  p  ao   gr   e   ending goal level i  set actions observed time step i  ai  
time step i  set action schemata input  returns updated goal graph
ending proposition level     action expansion  expansion goal
graph proposition level proposition level     simulates eects executing
actions observed time step i 
otherwise action observed time step i  goalgraphconstructor algorithm nishes nodes goal level i  representing possible goals either fully
partially achieved actions observed 

   goal recognition algorithms allow redundant actions 

  

figoal recognition goal graph analysis

action expansion   p  ao   gr  e    ai   i  a 
   every ai ai
a  add action ai  i  ao  
b  instantiate action schema ai get precondition set
sp   eect set se  
c  get equivalent sets sp se   sp se  
d  every pp sp   pp   not pp   
prop neg pp  i  p  
add precondition edge prop neg pp  i   action ai  i   e 
e  every pp sp   pp   not pp   
prop pp  i  p  
add precondition edge prop pp  i   action ai  i   e 
f  every pe se
i  add prop pe       p  
ii  add eect edge action ai  prop pe        e 
   every prop p  i  p
prop p      
  p  
prop p      
  p   add prop p       p  
add persistence edge prop p  i   prop p        e 
   return   p  ao   gr   e   
figure    action expansion algorithm
theorem    polynomial size time  consider goal recognition problem
observed actions time steps  nite number objects time step  p propositions
initial conditions  goal schemata constant number parameters 
let l  largest number eects action schema  l  largest number
goal descriptions goal schema  let n largest number objects time
steps  then  size goal graph     levels created goalgraphconstructor
algorithm  time needed create graph  polynomial n  m  p  l    l    s 
proof  maximum number nodes proposition level o p   l  s   let k
largest number parameters goal schema  since goal schema
instantiated nk distinct ways  maximum numbers nodes edges
goal level o mnk   o l  mnk   respectively  obvious time needed
create nodes edges level polynomial number nodes edges
level   
theorem   goalgraphconstructor algorithm sound  goal adds goal
graph time step one either fully partially achieved time step state
world  algorithm complete  goal either fully partially achieved
observed actions time step    algorithm add goal graph
time step i  assumption possible goals restricted categories
goal schemata 
  

fihong

proof  soundness   proposition level   goal graph consists initial
conditions  representing state world time step   action
observed  goal graph extended proposition level   proposition level i 
adding eects actions observed time step i   bringing forward
proposition nodes aected actions proposition level
  proposition level i  therefore  proposition level goal graph represents
state world time step i  changed initial conditions
actions observed time steps           
goal added goal graph time step algorithm fully partially
achieved goal proposition level goal graph  therefore  goal fully
partially achieved state world time step i 
proof  completeness   suppose goal either fully partially achieved
actions observed time steps            goal either fully partially achieved
proposition level goal graph  since goal level goal graph consists
possible instances goal schemata  fully partially achieved
proposition level goal graph  goal instance goal schema  one
fully partially achieved goal instances proposition level i  algorithm
therefore add goal goal level goal graph   
    recognising consistent goals valid plans
goalgraphanalyser algorithm analyses constructed goal graph recognise consistent goals valid plans  assume strict majority observed actions
relevant goal intended agent context agents actions  therefore 
goal intended agent consistent set observed actions  goal
may intended goal consistent set observed actions  order
decide whether goal consistent set observed actions  is  whether
relevant strict majority observed actions  need recognise causal links
either two observed actions observed action goal  dene
two particular types paths  call causal link paths  constructed goal graph 
prove theorems     causal links recognised identifying causal link
paths 
definition   given goal graph  let ai action observed time step gj
goal fully partially achieved time step j    j  path connects ai gj
via eect edge  zero persistence edges  description edge  called causal
link path ai gj  
theorem   given goal graph  exists causal link  ai gj   action ai
time step goal gj time step j    j  ai connected gj via causal
link path 
proof  according denition    causal link path ai gj consists
eect edge  zero persistence edges  description edge  eect edge
path connects ai proposition node proposition level      representing one
eects ai   j        persistence edge path proposition
  

figoal recognition goal graph analysis

node connected gj description edge  j        proposition node
brought forward proposition level j via j i  persistence edges j i  maintenance
actions  brought forward proposition node proposition level j connected gj
description edge  either case  one eects ai satised one goal
descriptions gj   since goal treated action goal descriptions
preconditions empty set eects  according denition    exists causal
link ai gj    
definition   given goal graph  let ai aj two actions observed time steps
j respectively    j  path connects ai aj via eect edge  zero
persistence edges  precondition edge  called causal link path ai
aj  
theorem   given goal graph  exist causal link  ai aj   action ai
time step action aj time step j    j  ai connected aj via
causal link path 
proof theorem   similar theorem    details proof omitted 
given constructed goal graph   p  ao   gr   e   levels  goalgraphanalyser
algorithm shown figure   recognises every consistent goal goals goal level t 
deciding whether strict majority observed actions relevant it 
done rst nding relevant actions observed actions  connected
goal causal link paths  already known relevant actions  algorithm
tries nd relevant actions observed actions  connected
causal link paths  continues relevant action found  consistent
goal recognised valid plan goal part represented   tuple 
  gt    ao   o  la    lg    gt goal  la set causal links observed
actions  lg set causal links observed actions goal 
  ao   o  la   represents valid plan gt part it  lg explains
purposes observed actions 
proposition   goalgraphanalyser algorithm sound  goal g recognises
time step consistent observed actions far  plan organises g
part g valid 
proof  goalgraphanalyser algorithm recognises goal g time step t 
strict majority observed actions connected g  either directly causal link
path indirectly chain causal link paths  observed action connected
g directly causal link path  according theorem   denition    exists
causal link observed action g  observed action relevant
g  observed action connected g indirectly chain causal link paths 
according theorem    theorem    denition    chain causal links
observed action g  observed action relevant g  since strict
majority observed actions relevant g  according denition    g consistent
set observed actions  furthermore  according proposition    plan
goalgraphanalyser algorithm organises g part g    ao   o  la    valid plan  
  

fihong

goalgraphanalyser   p  ao   gr   e    t 
   every gt gr goal level
a  ao         lg     la    
b  every ai ao connected gt causal link path
add ai gt lg  
add ai ao  
add ai a 
c       ai ao   ai ao  
get ordering constraints  o  ao  
add   gt     ao   o  la    lg   goalplan 
d       
remove action aj a 
every ai ao connected aj causal link path
add ai aj la  
  ao   add ai ao   ai a 
ai
go  c 
   return goalplan 
figure    goalgraphanalyser algorithm

example shown figure    goal nodes bold represent three consistent
goals  among goal node italics represents partially achieved goal 
two represent two fully achieved goals  edges bold show causal link paths 

theorem    polynomial space time  consider t level goal graph  let l 
number fully partially achieved goals time step t  m  largest number
goal descriptions goals  l  number observed actions  m 
largest number preconditions actions  space size possible
causal link paths  connect goals observed actions connect observed
actions observed actions  time needed recognise consistent goals 
polynomial l    l    m    m   

proof  persistence edges branch goal graph  goals
goal level t  maximum number paths searched observed actions 
connected goal causal link paths hence relevant it  o m    
relevant actions goal  maximum number paths searched observed
actions  connected relevant action causal link paths hence
relevant goal  o m     maximum l  goals goal level
l  relevant actions goals  space size possible causal link paths
o l   m    l  m      time needed recognise consistent goals polynomial
space size   
  

figoal recognition goal graph analysis

    goal redundancy
goalgraphanalyser algorithm recognises fully partially achieved goals time step 
consistent actions observed far  among consistent goals  fully
achieved goals better explain actions observed far  instance  example shown
figure    two consistent goals recognised goalgraphanalyser algorithm time
step     move object h o  fully achieved  keep object at o  partially
achieved  two consistent goals  fully achieved goal better explains
observed actions far  if  instance  another action  take out d  observed next
time step   keep object at o  becomes fully achieved remains consistent
observed actions  time step  best explains observed actions  partially
achieved goal  consistent observed actions far  remain consistent
actions observed future becomes fully achieved  choosing
fully achieved goal making partially achieved goal redundant rule
possibility partially achieved goal remaining consistent becoming fully achieved
future  based principle  make partially achieved consistent goal
time step redundant  satised goal descriptions implied satised goal
descriptions another fully partially achieved consistent goal 
definition   partially achieved consistent goal time step redundant  set
satised goal descriptions either subset goal descriptions fully achieved consistent goal proper subset satised goal descriptions another partially achieved
consistent goal time step 
instance  time step   set satised goal descriptions  keep object at
o  subset goal descriptions  move object h o   partial achievement
 keep object at o  implied full achievement  move object h
o    keep object at o  made redundant  move object h o  time step
  
fully achieved consistent goal time step  however  made redundant
goal descriptions implied goal descriptions another fully achieved consistent
goal time step 
definition   fully achieved consistent goal time step redundant  set
goal descriptions subset goal descriptions another fully achieved consistent goal
time step 
    consistent goals
redundant goals removed set consistent goals time
step  might still one consistent goal set  case 
numbers observed actions relevant remaining consistent goals
compared  remaining goals maximum number relevant actions
chosen consistent goals time step 
definition   given set consistent goals time step  consistent goal set
consistent goal set  maximum number relevant actions among
consistent goals set 
  

fihong

instance  example shown figure    another action  take out d 
observed time step     move object h o   keep object at o  consistent goals time step    neither redundant   keep object at o 
relevant observed actions   move object h o  relevant
four observed actions  according denition     keep object at o 
consistent goal time step   
example shown figure    goal nodes asterisk represent consistent
goals eventually remaining two processes removing redundant goals selecting
consistent goals 

   experimental results
implemented goal recognition algorithms prolog tested terms
accuracy  eciency  scalability desktop pentium iii processor     mhz 
tested algorithms set data unix domain collected university
washington  collect data  subjects given goals described english rst
tried achieve goal executing unix commands  commands
issued unix subject responses unix commands
recorded data set  commands issued subject valid
could executed unix  responses unix invalid commands
actually error messages  goals subjects tried achieve 
indicated success failure regard achievement goal 
   goals unix data set  goals tried   subjects
average  shown table    goals classied four types  rst type
goals locating le properties  extension  size 
contents  ownership  date  word count  compression  second type goals
locating machine properties  load logged in users 
third type goals locating printer properties 
print jobs paper  fourth type goals compressing large
les directory  fourth type goals  universally quantied goal descriptions
needed corresponding goal schemata  addition  two compound
goals  g  g    conjunctions two goals second type 
test algorithms  sequences unix commands  recorded data set 
taken observed actions consecutive time steps  took valid commands 
successfully executed unix  ltered invalid commands 
unix failed execute responded error messages  created    action
schemata set commonly used unix commands  including executed
subjects  created     goal schemata  including     le search goal schemata  for
goals locating le properties      non le search goal schemata  for goals
locating machine printer properties goals compressing
large les directory      goal schemata paired non le search goals 
   goals unix data set instances goal schemata  rst
tested algorithms respect accuracy eciency  is  number goals
remaining sequence observed actions processed  average time
  

figoal recognition goal graph analysis

g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

find le named core 
find le contains motivating whose name ends  tex 
find machine low         load 
determine oren etzioni logged machine named chum 
compress large           bytes  les testgrounds subdirectory tree 
compress les directory named backups  dont use    
find large le            bytes  hasnt changed month 
find le contains less    words 
find laser printer sieg hall active print job 
find sun fourth oor low         load 
determine dan weld active machine named chum 
find printer paper 
find le named oldpaper neal testgrounds subdirectory 
find le length   neal testgrounds subdirectory 
see dan weld logged chum 
find machine dan weld logged into 

table       goals unix data set collected university washington
taken construct goal graph  analyse constructed goal graph  run
cycle goal graph construction analysis  action observed time step 
table   gives summary empirical results showing accuracy algorithms 
rst column shows goals subject tried achieve  achieved goals
goals fully partially achieved last observed action processed 
consistent goals fully partially achieved goals consistent
sequence observed actions   remaining goals goals remained
redundant goals removed consistent goals selected 
last column shows whether given goal among remaining goals 
shown table    algorithms successfully recognised       given goals 
failed recognise one given goal  g     simply sequence commands
executed subject actually failed achieve goal  terms unix data set 
goal recognition occurs algorithms return single  consistent goal  occurred
g    g    g    g    g    g     g     g    g    g    g     g     one goal
recognised  including goal given subject  g    g    g     g    
algorithms recognised subject tried nd one les properties
directory know le was  instance  g    intended
goal nd le named core  subject successfully found le named core
directory  other  executing command  ls  list les directory  since
les  greenmouse  paper tex  action ps z  directory 
   experiments unix data set  goal  two third observed actions
relevant  recognised consistent goal  threshold number relevant actions
dependent application domain though strict majority actions must relevant 
threshold high  algorithms might fail recognise intended goal  hand 
low  set recognised goals might large provide much value great ambiguity
intended goal 

  

fihong

goal
g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

achieved
goals
  
  
  
  
  
   
  
 
  
 
  
  
 
 

consistent
goals
  
 
 
  
  
  
 
 
 
 
  
  
 
 

remaining
goals
 
 
 
 
 
 
 
 
 
 
 
 
 
 

given goal
recognised















table    empirical results unix domain showing accuracy algorithms

les listed command  algorithms recognised four
goals  nding le named core  nding le named greenmouse  nding le named
paper extension tex  nding le named action extension ps
compressed  g    algorithms recognised subject tried nd one
users machine know was  good human
observer could simply could tell observed actions le
user subject trying nd  recognised goals generalised single 
consistent goal nding le directory nding user using machine 
variables allowed recognised goals 
g    algorithms recognised   consistent goals  among goals  goals
nd les properties compression extension
directory named backups  another goal gunzip les directory
named backups  human observer could probably better recognising goal
gunzipping les directory named backups  accounted better
gunzip command observed  unlikely subject gunzipped
les directory order nd le gunzip compression 
among goals tested  g    g    g    g  originally tested lesh
etzioni         empirical results show signicant improvement accuracy
goal recogniser implemented terms remaining goals  algorithms
           remaining goals g    g    g    g  respectively  goal
recogniser                remaining goals g    g    g    g  respectively 
last observed action processed  furthermore      remaining goals
algorithms g  g  generalised two single goals  results
show algorithms perform extremely well regard accuracy 
  

figoal recognition goal graph analysis

goal
g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

length
observation
    
  
   
    
 
    
    
   
  
  
 
  
 
 

construction
time
     
     
     
     
     
      
      
     
     
     
     
     
     
     

analysis
time
     
     
     
     
     
     
     
     
     
     
     
     
     
     

time
per cycle
     
     
     
     
     
      
      
     
     
     
     
     
     
     

table    empirical results unix domain showing eciency algorithms

worth noting lesh etzionis algorithm converges last observed
action processed  algorithm works towards goal prediction  algorithms emphasise explanation observed actions  recognising fully partially
achieved goals consistent actions  algorithm quickly prune
inconsistent goals get converged set hypothesised goals  though number
hypothesised goals set sometimes large  next step work might
assign probabilities hypothesised goals dierentiate single goal
others  exists one intended goal  hand  less desirable
goals recognised algorithms dierentiated accuracy
algorithms usually high  algorithms  however  cannot recognise goal
fully partially achieved 
table   gives summary empirical results showing eciency algorithms 
length observation average number observed actions executed
subjects achieve given goal  construction time average time took
construct goal graph time step  analysis time average time took
analyse constructed goal graph time step  time per cycle average
time took go two stage cycle goal graph construction analysis 
observed action processed time step  including constructing goal
graph  recognising consistent goals  removing redundant goals  selecting
consistent goals  shown table    average time step  took       cpu seconds
construct goal graph        cpu seconds analyse goal graph       
cpu seconds process observed action  since algorithms written
less ecient prolog run desktop pentium iii processor     mhz 
eciency could achieved  construction time  analysis time  time per cycle could
  

fihong

average cpu seconds

   
   

c time

   

a time
   

p time

  
 
     

     

     

     

     

     

     

     

            

number goals

figure    empirical results unix domain showing scalability algorithms

reduced well cpu second  algorithms coded ecient
programming language run faster machine 
compared empirical results eciency goal recogniser implemented
lesh etzioni         average  took                            cpu seconds
process observed action algorithms g    g    g    g  respectively 
                           cpu seconds taken goal recogniser process
observed action goals  average time process observed action
roughly around     cpu seconds desktop pentium iii processor
    mhz algorithms coded prolog sparc    goal recogniser
coded lisp  given two dierent programming languages machines used
implementation two dierent systems  comparison hardly meaningful 
however apparent use ecient programming languages machines
signicantly speed algorithms 
tested scalability goal recognition algorithms unix domain 
tested eciency algorithms aected number possible goals 
turn aected number objects universe objects  created
series spaces approximate                           possible goals respectively
based data recorded g  unix data set   this  changed
les directories le hierarchy  well properties les  original
data set g    increase decrease number objects universe objects 
keeping les directories related intended goal properties
related les unchanged  sense part initial conditions
intended goal remained same  rest initial conditions changed create
   number goal schemata remains unchanged 

  

figoal recognition goal graph analysis

appropriate number candidate goals  change le hierarchy reected
change complexity le hierarchy 
original sequences commands recorded data set used experiments  conjunction dierent sets initial conditions  creation
dierent spaces candidate goals  figure   shows average cpu time taken
time step construct analyse goal graph  shown c time a time respectively figure     process observed action whole  shown p time
figure    approximately linear number candidate goals 

   conclusion future work
paper  presented new approach goal recognition graph structure
called goal graph constructed analysed goal recognition  described two
algorithms constructing analysing goal graph  algorithms recognise partially
fully achieved goals consistent observed actions  reveal valid plans
recognised goals part them  algorithms need plan library 
allow redundant  extraneous  partially ordered actions  sound  polynomialtime  polynomial space 
empirical experiments show algorithms recognise goals great accuracy 
computationally ecient  scaled applied domains
tens thousands goals plans  even though one goal recognition
algorithms  goalgraphanalyser algorithm  complete  recognised
intended goals unix data set successfully achieved subjects 
limitation goal recognition algorithms sometimes one goal
recognised  though number recognised goals usually small  algorithms
cannot tell goal probable one one intended goal 
instance  g  unix data set  algorithms recognised   goals  even though
intended goal  gunzipping les directory called backups  among goals 
probably likely one compared others  algorithms could
dierentiate others  sometimes algorithms recognise unique goal
implies intended goal cannot make specic  instance  g  unix
data set  algorithms recognised unique goal  nding le  index tex  word
count extension  even though achievement goal implied achievement
intended goal  nding le contains less    words  algorithms could
specic  problems due incomplete information
observed actions  g    observed actions indication likelihood
recognised goals intended goal  subject actually achieved g 
knew word count less    words knowing word count le 
observed action directly used achieve this 
several attempts  carberry        charniak   goldman        huber et al        
forbes et al         pynadath   wellman        bauer        albrecht et al        
made incorporate uncertainty representation reasoning techniques plan
recognition handling uncertain incomplete information  single plan
distinguished set candidate plans  however  systems rely heavily
availability planning knowledge certain extent use plan libraries  future
  

fihong

work  intend investigate possibility incorporating uncertainty representation
reasoning mechanisms goal graph based approach goal recognition 
unique  specic goal recognised one intended goal 
good features goal graph based approach kept 
future work  intend explore extent goal graph representation used probabilistic goal recognition  particular  consider problem
settings eects actions probabilistic objective goal recognition
recognise consistent goals highest probability achievement 
another area future work recognise goals even partially
fully achieved actions observed far  regard  current goal recognition
algorithms used recognise goals sequence actions large data
set achieve  sequence actions data set recognised goals
used acquire probabilistic model goal prediction machine learning method 
probabilistic model takes actions observed far predicts possible goals even
partially fully achieved 

acknowledgments
paper revised extended version paper appeared proceedings
aaai       hong         author wishes thank neal lesh providing unix
data set  anonymous referees insights constructive criticisms 
helped improve paper signicantly 

references
albrecht  d  w   zukerman  i     nicholson  a  e          bayesian model keyhole
plan recognition adventure game  user modeling user adapted interaction 
             
allen  j  f          recognizing intentions natural language utterances  brady  m  
  berwick  b   eds    computational models discourse  pp          mit press 
cambridge  ma 
allen  j  f     perrault  c  r          analyzing intention utterances  articial intelligence             
anderson  c   smith  d  e     weld  d          conditional eects graphplan 
proceedings  th international conference ai planning systems  pp       
bauer  m          dempster shafer approach modeling agent preferences plan recognition  user modeling user adapted interaction                  
bauer  m          acquisition abstract plan descriptions plan recognition  proceedings aaai     pp         
bauer  m     paul  g          logic based plan recognition intelligent help systems 
backstrom  c     sandewall  e   eds    current trends ai planning  pp       
ios press 
  

figoal recognition goal graph analysis

blum  a  l     furst  m  l          fast planning planning graph analysis 
articial intelligence             
carberry  s          user models  problem disparity  proceedings   th
international conference computational linguistics  pp       
carberry  s          modeling users plans goals  computational linguistics         
     
carberry  s          incorporating default inferences plan recognition  proceedings
aaai     pp         
carver  n  f   lesser  v  r     mccue  d  l          focusing plan recognition 
proceedings aaai     pp       
charniak  e     goldman  r  p          bayesian model plan recognition  articial
intelligence           
forbes  j   huang  t   kanazawa  k     russell  s          batmobile  towards
bayesian automated taxi  proceedings ijcai     pp           
gazen  b     knoblock  c          combining expressivity ucpop eciency
graphplan  proceedings  th european conference planning  pp     
    
goodman  b  a     litman  d  j          interaction plan recognition
intelligent interfaces  user modeling user adapted interaction           
grosz  b  j     sidner  c  l          plans discourse  p  r  cohen  j  m     pollack 
m  e   eds    intentions communication  pp          mit press  cambridge  ma 
hong  j          goal graph construction analysis paradigm plan recognition 
proceedings aaai       pp         
huber  m  j     durfee  e  h          deciding commit action
observation based coordination  proceedings first international conference
multi agent systems  pp         
huber  m  j   durfee  e  h     wellman  m  p          automated mapping plans
plan recognition  proceedings   th conference uncertainty articial
intelligence  pp         
hu  k     lesser  v          plan based intelligent assistant supports software
development process  proceedings acm sigsoft sigplan software engineering symposium practical software development environments  pp        
kautz  h  a          formal theory plan recognition  phd thesis  university
rochester 
koehler  j   nebel  b   homann  j     dimopoulos  y          extending planning graphs
adl subset  proceedings  th european conference planning  pp 
       
lesh  n     etzioni  o          sound fast goal recognizer  proceedings ijcai    pp           
  

fihong

lesh  n     etzioni  o          scaling goal recognition  proceedings  th
international conference principles knowledge representation reasoning 
pp         
litman  d  j     allen  j  f          plan recognition model sub dialogues conversation  cognitive science                 
mooney  r  j          learning plan schemata observation  explanation based learning
plan recognition  cognitive science                 
pednault  e  p  d          synthesizing plans contain actions context dependent
eects  computational intelligence                
pednault  e  p  d          adl  exploring middle ground strips
situation calculus  proceedings  st international conference knowledge
representation reasoning  pp         
pollack  m  e          plans complex mental attitudes  cohen  p  r   morgan 
j     pollack  m  e   eds    intentions communication  pp         mit press 
cambridge  ma 
pynadath  d  v     wellman  m  p          accounting context plan recognition 
application trac monitoring  proceedings   th conference uncertainty
articial intelligence  pp         
schank  r     abelson  r          scripts  plans  goals  understanding  erlbaum 
sidner  c  l          plan parsing intended response recognition discourse  computational intelligence             
wilensky  r          planning understanding  addison wesley publishing company 
reading  ma 
wilensky  r     et al          berkeley unix consultant project  computational linguistics               

  


