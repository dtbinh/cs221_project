journal of artificial intelligence research               

submitted        published     

goal recognition through goal graph analysis
j hong ulst ac uk

jun hong
school of information and software engineering
university of ulster at jordanstown
newtownabbey  co  antrim bt    qb  uk

abstract
we present a novel approach to goal recognition based on a two stage paradigm of graph
construction and analysis  first  a graph structure called a goal graph is constructed to
represent the observed actions  the state of the world  and the achieved goals as well as
various connections between these nodes at consecutive time steps  then  the goal graph
is analysed at each time step to recognise those partially or fully achieved goals that are
consistent with the actions observed so far  the goal graph analysis also reveals valid
plans for the recognised goals or part of these goals 
our approach to goal recognition does not need a plan library  it does not suer from
the problems in the acquisition and hand coding of large plan libraries  neither does it have
the problems in searching the plan space of exponential size  we describe two algorithms
for goal graph construction and analysis in this paradigm  these algorithms are both
provably sound  polynomial time  and polynomial space  the number of goals recognised
by our algorithms is usually very small after a sequence of observed actions has been
processed  thus the sequence of observed actions is well explained by the recognised goals
with little ambiguity  we have evaluated these algorithms in the unix domain  in which
excellent performance has been achieved in terms of accuracy  eciency  and scalability 

   introduction
plan recognition involves inferring the intentions of an agent from a set of observations  a
typical approach to plan recognition uses an explicit representation of possible plans and
goals  often called a plan library  and conducts some type of reasoning on the basis of a set
of observations to identify plans and goals from the plan library  that could have caused the
observations 
plan recognition is useful in many areas  including discourse analysis in natural language question answering systems  story understanding  intelligent user interfaces  and
multi agent coordination  much early research in plan recognition has been done in natural language question answering systems  allen   perrault        allen        sidner 
      litman   allen        carberry        pollack        grosz   sidner         in
these systems  plan recognition has been used to support intelligent response generation  to
understand sentence fragments  ellipsis and indirect speech acts  to track a speakers ow
through a discourse  and to deal with correctness and completeness discrepancies between
the knowledge of users and systems 
plan recognition can enhance user interfaces  the recognition of the users goals and
plans from his interaction with the interface facilitates intelligent user help  carver  lesser 
  mccue        hu   lesser        goodman   litman        bauer   paul       
lesh   etzioni         plan recognition enables the interface to assist the user in task
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

fihong

completion  and error detection and recovery  wilensky   et al          the interface does
this by watching over the users shoulder to infer his goals and plans  it can then decide
what help and assistance the user needs 
in story understanding  schank   abelson        wilensky        charniak   goldman 
       it is useful to recognise the goals and plans of the characters from the described
actions in order to understand what the characters were doing  in multi agent coordination 
ecient and eective coordination among multiple agents requires modelling each agents
goals and plans  huber  durfee    wellman        huber   durfee        
given a set of observations  most plan recognition systems  allen   perrault       
carberry        litman   allen        kautz        pollack         search a space of
possible plan hypotheses for candidate plans and goals that account for the observations 
to form the search space in a given domain  some kind of plan library is required  for
instance  in kautzs event hierarchy  kautz         plan decompositions are required that
describe how low level actions make up complex actions  despite its obvious advantage of
expressive richness  use of a plan library has a few limitations  first  it is not able to deal
with new plans whose types do not appear in the plan library  second  acquiring and handcoding the plan library in a large and complex domain presents a tedious or impractical task 
third  in some other domains  the knowledge about plans might not be readily available 
some attempts  mooney        forbes  huang  kanazawa    russell        lesh  
etzioni        albrecht  zukerman    nicholson        bauer        have recently been
made to apply machine learning techniques to the automated acquisition and coding of plan
libraries  even when leaving aside the plan library consideration  searching the plan space
can  however  be exponentially expensive because the number of possible plan hypotheses
can be exponential in the number of actions  kautz         most plan recognition systems
have been developed in domains in which peoples behaviour is characterized by fewer than
    plans and goals  lesh   etzioni        
in this paper  we focus on goal recognition  a special case of plan recognition  we
introduce a novel approach to goal recognition  in which graph construction and analysis is
used as a paradigm  our approach signicantly diers from most plan recognition systems 
first  our approach does not need a plan library  instead we dene what constitutes a valid
plan for a goal  we need to consider only how observed actions can be organised into plans 
hence we do not have the problems associated with the acquisition and hand coding of the
plan library in a large and complex domain as well as the availability of planning knowledge
in a domain  most plan recognition systems cannot recognise any new plans whose types do
not appear in the plan library  without using a plan library  our approach does not suer
from this limitation  second  instead of immediately searching for a plan in the plan space
as in most plan recognition systems  our approach explicitly constructs a graph structure 
called a goal graph  which is then analysed to recognise goals and plans  our approach
therefore does not have the problems in searching the plan space of exponential size  third 
our approach recognises only partially or fully achieved goals that are consistent with the
actions observed so far  the number of such recognised goals is usually very small after a
sequence of observed actions has been processed  thus the sequence of observed actions is
well explained by the recognised goals with little ambiguity 
it should be emphasised that in our approach to goal recognition  the purpose of recognising partially or fully achieved goals is to explain past actions rather than predicting
 

figoal recognition through goal graph analysis

future actions  this is particularly useful in such problem areas as story understanding 
software advisory systems  database query optimisation  and customer data mining  these
problem areas have several specic characteristics  first  most actions have been either described or observed  second  it is very likely that the users intended goal has been partially
or fully achieved by these actions  third  recognising the intended goal aims at explaining past actions rather than predicting future actions  finally  distinguishing partially or
fully achieved goals from the others greatly reduces ambiguity involved in recognising the
intended goal 
in story understanding  most actions of the characters are described in the story  recognising goals and plans that account for the described actions enables better understanding
of what the characters were doing  in software advisory systems  after a user has been
observed to issue a sequence of operations in a software application  the system can rst
recognise the task the user has performed  the system can then decide whether the user
has performed the task in a suboptimal way  and advice can be given to the user as to
how to better perform the task  in database query optimisation  after a user has conducted a sequence of data retrieval and manipulation operations  recognising the underlying
query can lead to advice on query optimisation when the query has not been executed in
an optimal way  in customer data mining  the individual customers shopping goals can
be recognised from logged customer on line shopping data  this can also form a basis for
performing other customer data mining tasks 
our algorithms for goal graph construction and analysis are both provably sound 
polynomial time  and polynomial space  our empirical results in the unix domain show
that our algorithms perform well in terms of accuracy  eciency  and scalability  they also
show that our algorithms can be scaled up and applied to domains in which there are tens
of thousands of possible goals and plans  though our algorithm for goal graph analysis
is not complete  it recognised every goal that was intended and successfully achieved by
the subject in the unix data set we used in our evaluation  since our new graph based
approach to goal recognition is fundamentally dierent from the existing methods for plan
recognition  it provides an alternative to these methods and a new perspective on the plan
recognition problem 
the rest of the paper is organised as follows  first  we give an overview of our novel
approach to goal recognition  in section    we discuss the domain representation  in
section   we dene goal graphs  valid plans  and consistent goals  in section   we present
our goal recognition algorithms together with our analysis of these algorithms  in section  
we discuss the empirical results  we summarise the paper and discuss limitations and future
work in the last section 

   a novel approach to goal recognition
in this section  we describe the basic assumptions we make on the goal recognition problem
and outline our approach  we discuss previous work on planning with planning graphs
and a graph based approach to goal recognition  we briey describe empirical results that
are in favour of our approach 
 

fihong

    basic assumptions
we start with an example in the unix domain  when we observe that a user types two
commands  cd papers and ls  one after another  we should be able to infer that the user
wants to nd a le or subdirectory in the directory  papers  for two reasons  first  this goal
has been fully achieved  second  it is relevant to both commands in a consistent way in
the sense that the rst command satises one of the preconditions of the second command
and the second command achieves the recognised goal  the recognised goal might be just
an intermediate goal of the user  the users intended goal might be one of the le related
goals  for instance  deleting a le from the directory  since these commands can both be
part of plans for almost all the le related goals  it is impossible for us to uniquely identify
the users intended goal at the current time step  yet the goal of nding a le or directory
well explains these commands  if the user next types a command  rm oldpaper tex  we
can then infer that the users goal is to delete a le  oldpaper tex  in the directory  papers 
because this goal is now fully achieved and it is relevant to all the commands observed so
far in a consistent way in the sense that the rst command satises one of the preconditions
of the second and third commands  the second command satises one of the preconditions
of the third command  and the third command achieves the recognised goal 
this example highlights the way our new approach to goal recognition works  we make
the following assumptions on the goal recognition problem  first  a set of actions are
observed at consecutive time steps   second  the initial state of the world immediately
before the set of actions are observed is known   third  we have domain knowledge on
actions and goals  that is  we know the preconditions and eects of every observed action 
and every possible goal is explicitly specied by a set of goal descriptions 
given these assumptions  when an action is observed at a time step  we want to infer
which goals have been partially or fully achieved at this time step and whether each of the
achieved goals is relevant to the strict majority of the actions observed so far in a consistent
way in the sense that these actions can be organised into a plan structure for the goal or
part of it 
    goal recognition with goal graph
we propose to use a graph structure  called a goal graph  in our new approach to goal
recognition  we view the goal recognition problem as a process of graph construction and
analysis  in a goal graph  action nodes represent the actions observed at consecutive time
steps  proposition nodes represent the state of the world at consecutive time steps  as it is
changed from the initial state to the subsequent states by the observed actions  and goal
nodes represent the goals that are partially or fully achieved at consecutive time steps 
edges in a goal graph explicitly represent relations between actions and propositions as
well as relations between propositions and goals  based on these explicit relations in the
constructed goal graph  causal links between either two actions or an action and a goal
can be recognised  having recognised these causal links  it can be decided whether a fully
or partially achieved goal at a time step is relevant to the strict majority of the observed
   the observed actions can be partially ordered in the sense that more than one action can be observed
at a time step and there is no temporal ordering constraint on these actions 
   our approach however reasons about the state of the world at subsequent time steps 

 

figoal recognition through goal graph analysis

actions so far in a consistent way in the sense that these relevant actions can be organised
into a plan structure for the goal or part of it  in our approach  extraneous  redundant  and
partially ordered actions in plans are all handled 
our attempt to use graph construction and analysis as a paradigm for goal recognition
is in spirit inuenced by blum and fursts eorts on planning with planning graphs  blum
  furst         they introduced a new graph based approach to planning in strips
domains  in which a graph structure called a planning graph is rst constructed explicitly
rather than searching immediately for a plan as in standard planning methods  many useful
constraints inherent in the planning problem are made explicitly available in a planning
graph to reduce the amount of search needed  the planning graph is then analysed to
generate possible plans 
our goal graph based approach to goal recognition can be seen as a counterpart of
planning with planning graph  though graph structures are used in both approaches 
they are composed of dierent kinds of nodes and edges  in a time step  a planning graph
represents all the possible propositions either added by the actions in the previous time step
or brought forward by maintenance actions from the previous time step  and all the possible
actions whose preconditions have been satised by the propositions in the time step  on the
other hand  a goal graph  in a time step  represents only the propositions either added by
the actions observed in the previous time step or brought forward by maintenance actions
from the previous time step  and the actions observed in the time step  in addition  a goal
graph  in a time step  also represents all the possible goals  either fully or partially achieved
in the time step  while a planning graph does not represent any goal at all  accordingly 
a planning graph represents only relations between actions and propositions  while a goal
graph also represents relations between propositions and goals 
the analysis of a planning graph aims to search for all the possible subgraphs of the
planning graph  that form valid plans for the only given goal  on the other hand  the
analysis of a goal graph aims to search for every possible partially or fully goal for which
there exists a subgraph of the goal graph  consisting of the strict majority of the observed
actions  such a subgraph forms a valid plan for the goal or part of it and shows that the
strict majority of the observed actions are relevant to the goal in a consistent way 
the domain representation can be the same for both planning with planning graph
and goal recognition with goal graph  in this regard  previous eorts on handling more
expressive representation languages  gazen   knoblock        anderson  smith    weld 
      koehler  nebel  homann    dimopoulos        are still useful for goal recognition 
these languages allow use of disjunctive preconditions  conditional eects  and universally
quantied preconditions  goal descriptions  and eects in action and goal representation 
our adl like domain representation is actually based on this work  that allows use of
conditional eects  universally quantied eects  and existentially and universally quantied
preconditions and goal descriptions in the action and goal representation 
our goal graph based approach further extends lesh and etzionis previous work on
use of a graph representation of actions and goals for the goal recognition problem  lesh  
etzioni         they used a graph representation  called a consistency graph  for the goal
recognition problem  a consistency graph consists of action and goal nodes representing
possible actions and goals  and edges representing possible connections between nodes in
 

fihong

the graph  initially  action and goal nodes are fully connected to each other in a consistency
graph  and inconsistent goals are then repeatedly pruned from the consistency graph 
there are a number of major dierences between lesh and etzionis approach and ours 
first  two dierent graph representations are used  apart from action and goal nodes  a
consistency graph does not have nodes representing the propositions that model how the
state of the world is changed by the observed actions  therefore  the consistency graph
does not explicitly reveal causal links over actions and goals  neither does their system
know whether a goal has been partially or fully achieved by the observed actions  our goal
graph consists of action  goal  and proposition nodes  it explicitly reveals causal links over
actions and goals  hence our system knows how the observed actions are composed into
valid plans for the recognised goals or part of these goals  our systems also knows whether
a goal is partially or fully achieved by the observed actions 
second  goal consistency is dened dierently  in lesh and etzionis approach  a goal
is consistent if there exists a plan that includes the observed actions and achieves the
goal  in our approach  a goal is consistent if it has been partially or fully achieved by the
observed actions and is relevant to the strict majority of the observed actions  also  two
dierent recognition processes are used  in their approach a pruning process is used to
prune inconsistent goals from the consistency graph  the pruning process guarantees that
the goals pruned from the consistency graph are inconsistent goals  however  the number of
consistent goals  still remaining in the consistency graph after pruning  is usually large  thus
ambiguity on the intended goal remains an issue to be addressed  our approach instead
uses a graph analysis process to directly recognise consistent goals from only those fully or
partially achieved goals  the number of consistent goals recognised in the goal graph is
usually small  third  their approach requires that every observed action is relevant to the
goal  while only the strict majority of the observed actions are required to be relevant to
the goal in our approach 
we have developed two algorithms  goalgraphconstructor and goalgraphanalyser 
based on our two stage paradigm of goal graph construction and analysis  the goalgraphconstructor algorithm takes a set of actions as they are observed at dierent time
steps and constructs a goal graph  the goalgraphanalyser algorithm analyses the constructed goal graph to recognise consistent goals and valid plans  we prove that our
algorithms are sound  polynomial time  and polynomial space 
our algorithms have been implemented in prolog and tested in the unix domain on a
desktop with a pentium iii processor at     mhz  we used a set of data  collected in the
unix domain at the university of washington  with a domain representation of    action
schemata and     goal schemata  on the entire unix data set  on average it took just a few
cpu seconds to update the goal graph when an observed action was processed  and usually
only a very small number of consistent goals remained after a sequence of actions had been
observed  in all those test cases where the intended goals had been successfully achieved
by the subjects  these intended goals were all among the remaining goals recognised after
complete sequences of actions had been observed  to test the scalability of our algorithms 
we tested them on a series of spaces of approximate                up to     candidate goals
respectively in the unix domain  where the approximate linear time performance has been
achieved  our empirical results show that our algorithms can be scaled up and applied to
domains in which there are tens of thousands of possible goals and plans 
 

figoal recognition through goal graph analysis

   the domain representation
we use an adl like representation  pednault         including actions with conditional and
universally quantied eects  and existentially as well as universally quantied preconditions
and goal descriptions  in our approach to goal recognition  a goal recognition problem
consists of
 a set of action schemata specifying primitive actions 
 a nite  dynamic universe of typed objects where objects can be either added or
deleted by an action 
 a set of propositions called the initial conditions 
 a set of goal schemata specifying possible goals 
 a set of actions that are observed at consecutive time steps  
the solution to a goal recognition problem consists of a set of partially or fully achieved
goals that are consistent with the set of observed actions together with the valid plans
consisting of observed actions for the recognised goals or part of them 
the goal schema consists of a set of goal descriptions  gds  that are dened by the
following ebnf denitions 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 
 gd 

   
   
   
   
   
   
   
   
   

 term 
 not  term  
 neg  term  
 and  gd   
 imply  gd   gd  
 exist  term   gd  
 forall  term   gd  
 eq  argument   argument  
 neq  argument   argument  

the action schema consists of a set of preconditions and a set of eects  the set of
preconditions are dened as the same as goal descriptions  the set of eects are dened by
the following ebnf denitions 
 effect 
 effect 
 effect 
 effect 
 effect 

   
   
   
   
   

 term 
 neg  term  
 and  effect   
 when  gd   effect  
 forall  term   effect  

   when we say an observed action  we mean an action that has been observed and successfully executed 
we ignore those invalid actions  in the unix domain  for instance  these invalid actions are those issued
commands that unix failed to execute and responded only in error messages 

 

fihong

in the above two sets of ebnf denitions  a  term  is an atomic expression of the form 
 term        predicate name   argument   
 argument       constant name 
 argument       variable name 
we use eq and neq to specify equality and inequality constraints  we have two negation
connectives  neg and not  we use  neg a  to specically mean that the truth value of a is
made explicitly known to be false by an action  we use  not a  to mean that the truth value
of a is known to be false either explicitly or implicitly  the latter kind of representation can
be used when it is not necessary to represent that the truth value of a is explicitly known
to be false as long as it is known to be false  the closed world assumption is therefore
implemented as follows  in the initial state of the world  we explicitly represent only the
propositions known to be true in the initial conditions  any proposition not explicitly
represented in the state of the world is implicitly known to be false  actions however may
add some propositions explicitly known to be false to the state of the world  a proposition
can become explicitly known to be false only if it has been made explicitly known to be
false by an action  it is important to represent the propositions that are explicitly known
to be false  because we want to explicitly represent the eects of actions so that causal links
between either two actions or an action and a goal can be established 
both goal and action schemata are parameterised by typed variables that are represented
by terms with object type predicates  a goal is a ground instance of a goal schema  an
action is a ground instance of an action schema  the set of goal descriptions for a goal must
be satised in the state of the world when the goal is fully achieved  if some but not all the
goal descriptions are satised instead  the goal is partially achieved  positive literals in the
goal descriptions represent propositions true in the state of the world  negative literals in
the goal descriptions represent propositions known to be false in the state of the world  we
use imply to specify dependency constraints on goal descriptions  if a goal description gd 
is implied by another goal description gd    gd  can only be satised when gd  is satised
but gd  can be satised without gd  being satised  a goal description can be existentially
and universally quantied over a dynamic universe of objects 
the set of preconditions must be satised in the state of the world before the action
can be executed  the set of preconditions have the same syntax and semantics as the
set of goal descriptions  the set of eects are taken in the state of the world when the
action is executed  positive literals in the eects represent propositions true in the state
of the world after the action is executed  these propositions are added to the state of the
world  negative literals in the eects represent propositions no longer true in the state of
the world after the action is executed  these propositions are deleted from the state of
the world  while the negations of these propositions are added to the state of the world 
representing that these propositions are explicitly known to be false in the state of the world
after the action is executed  furthermore  a conditional eect consists of an antecedent and
a consequent  where the antecedent is a set of preconditions and the consequent is a set
of eects  the eects in the consequent can be taken only when the preconditions in the
antecedent are satised in the state of the world before the action is executed  an eect in
an action schema can be universally quantied over a dynamic universe of objects 
 

figoal recognition through goal graph analysis

we use a simple example domain extended from pednaults famous example  pednault 
       it involves transportation of two physical objects  a dictionary  and a chequebook 
between home and oce using a briefcase  we assume that only one physical object can be
carried in the briefcase at a time  the extended briefcase domain consists of
 a special physical object  a briefcase 
 two physical objects  a dictionary and a chequebook 
 two locations  home and oce 
 three action schemata 
moving the briefcase from one location to another 
putting a physical object in the briefcase  and
taking out a physical object from the briefcase 
 three goal schemata 
moving a physical object from one location to another 
keeping a physical object at a location  and
keeping a physical object in the briefcase 
the action and goal schemata of this example domain are shown in figure    they are
used throughout the paper 
in the actual implementation of our goal recognition algorithms  universally quantied
preconditions and eects  and conditional eects in action schemata are eliminated  and
equivalent schemata are created  we use a particular approach we call dynamic expansion 
dynamic expansion involves two steps  in the rst step  universally quantied preconditions
and eects in an action schema are dynamically compiled into the corresponding herbrand
bases  taking into account the universe of objects at the current time step  these universally
quantied preconditions and eects can only be dynamically compiled because we assume
that the universe of objects can be dynamically changed  this assumption is needed in a
domain like the unix shell system where destruction and creation of objects are required 
under our assumption on the dynamic universe of objects  for each object in the universe 
its object type must have been declared at the time step immediately before the action is
executed  for each object in the initial universe of objects  its type must be declared in the
initial conditions  an object can be either added to or deleted from the universe of objects
by an action at a time step  with an eect either stating a proposition about the new object
or negating a proposition about the existing object 
for instance  suppose that at the time step immediately before an instance of action
schema mov b shown in figure   is executed  the universe of objects consists of three physical
objects  b  c  and d  action schema mov b is then dynamically compiled into action schema
mov b   as follows 
 

fihong

  action mov b
 paras   l  m   loc 
 pre  and  neq  l  m  at b  l  
 eff  and  at b  m   neg  at b  l  
 forall   z   physob 
 when  in  z 
 and  at  z  m 
 neg  at  z  l        
  action put in
 paras   x   physob  l loc 
 pre  and  neq  x b  at  x  l  at b  l  
 forall   z   physob 
 not  in  z    
 eff  in  x   
  action take out
 paras   x   physob 
 pre  in  x 
 eff  neg  in  x    
  goal move object
 paras   x   physob  l  m   loc 
 goal des  and  neq  l  m 
 neq  x b 
 imply  neg  at  x  l  
 at  x  m     
  goal keep object at
 paras   x   physob  l   loc 
 goal des  and  neq  x b 
 imply  at  x  l 
 not  in  x      
  goal keep object in
 paras   x   physob 
 goal des  in  x   
figure    the action and goal schemata of the extended briefcase domain

  

figoal recognition through goal graph analysis

  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l  
 eff  and  at b  m   neg  at b  l  
 when  in b 
 and  at b  m 
 neg  at b  l    
 when  in c 
 and  at c  m 
 neg  at c  l    
 when  in d 
 and  at d  m 
 neg  at d  l       
in the second step  the conditional eects in mov b   are further eliminated  assume
that  at this time step  the following propositions are true   at b h    at c h    at d h  
and  in d   those conditional eects in mov b    whose antecedents are not satised at
the time step  are removed  we therefore have action schema mov b   
  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l  
 eff  and  at b  m   neg  at b  l  
 when  in d 
 and  at d  m 
 neg  at d  l       
the antecedent of the remaining conditional eect in mov b   is already satised at the
time step and it is moved into the existing preconditions  we nally have action schema
mov b   at the current time step  action schema mov b   is equivalent to the original
action schema mov b at the current time step  it is mov b   that is actually used for the
action schema  moving the briefcase from one location to another  at the time step 
  action mov b  
 paras   l  m   loc 
 pre  and  neq  l  m   at b  l 
 in d  
 eff  and  at b  m   neg  at b  l  
 at d  m   neg  at d  l    
the universally quantied goal descriptions in a goal schema are treated in the same
way as the universally quantied preconditions in an action schema 

   goal graphs  valid plans and consistent goals
in this section  we rst describe the structure of the goal graph  we then dene what we
mean when we say a set of observed actions forms a valid plan for achieving a goal given
  

fihong

mov b h o

put in d h

mov b o h

actions

at b o
at d h

at b h
 at b o

at b h

at b o

 at b o

 at b h

at c h

at d h

at d h

at d o

at c h

at c h

 at d h
at c h
in d

in d

keep object at d h

keep object at d h

keep object at c h

keep object at c h
keep object in d 

propositions

move object d h o 

keep object at c h

goals

keep object at c h
keep object in d
keep object at d o

level  

level  

level  

level  

figure    a goal graph for an example of the extended briefcase domain
the initial conditions  we nally dene what we mean when we say a goal is consistent
with a set of observed actions 
    goal graphs
a goal graph represents the actions observed  the propositions true or explicitly known to
be false  and the fully or partially achieved goals at consecutive time steps  a goal graph
also explicitly represents connections between propositions  actions  and goals in the graph 
a goal graph is a directed  levelled graph  the levels alternate between proposition
levels containing proposition nodes  each labelled with a proposition or negation of a proposition   representing the state of the world at consecutive time steps  goal levels containing
goal nodes  each labelled with a goal   representing goals fully or partially achieved at consecutive time steps  and action levels containing action nodes  each labelled with an action  
representing actions observed at consecutive time steps  the levels in a goal graph start
with a proposition level at time step    consisting of one node for each proposition true
in the initial conditions  they end with a goal level at the last time step  consisting of a
node for each of the goals either fully or partially achieved by the actions observed so far 
these levels are  propositions true at time step    goals achieved at time step    actions
observed at time step    propositions true or explicitly known to be false at time step   
goals achieved at time step    actions observed at time step    propositions true or explicitly
known to be false at time step    goals achieved at time step    and so forth 
the goal nodes in goal level i are connected by description edges to their goal descriptions in proposition level i  the action nodes in action level i are connected by precondition
edges to their preconditions in proposition level i  and by eect edges to their eects in
proposition level i      those proposition nodes in proposition level i are connected via
persistence edges to the corresponding proposition nodes in proposition level i      if their
truth values have not been aected by the actions in action level i  these persistence edges
represent the eects of maintenance actions that simply bring forward proposition nodes in
proposition level i  not aected by the actions in action level i  to proposition level i     
in the example shown in figure    three actions have been observed at three consecutive time steps   mov b o h    put in d h   and  mov b h o   the initial conditions
  

figoal recognition through goal graph analysis

consist of   at b o    at d h   and  at c h   action and goal nodes are on the top and
bottom parts of the graph respectively  the proposition nodes are in the middle part of
the graph  the edges connecting proposition nodes and the action node in the same level
are precondition edges  the edges connecting the action node in one level and propositions
in a subsequent level are eect edges  the edges connecting proposition nodes and goal
nodes in the same level are description edges  the edges connecting proposition nodes in
one level to proposition nodes in a subsequent level are persistence edges  the goal nodes
in bold represent consistent goals  among which the goal nodes in italics represent partially
achieved goals  while the others represent fully achieved goals  the edges in bold show
causal link paths  the goal nodes with an asterisk represent the recognised goals 
    valid plans
we now dene what we mean when we say a set of observed actions forms a valid plan for
a goal  given the initial conditions 
definition    causal link  let ai and aj be two observed actions at time steps i and j
respectively  where i   j  there exists a causal link between ai and aj   written as ai  aj  
if and only if one of the eects of ai satises one of the preconditions of aj  
for instance  in the example shown in figure    there exists a causal link between actions
 mov b o h  at time step   and  put in d h  at time step    since one of the eects of
the rst action   at b h   satised one of the preconditions of the second action 
a goal can be treated as an action with goal descriptions as its preconditions and an
empty set of eects  therefore  causal links can also be established from observed actions
to goals 
for instance  in the example shown in figure    there exists a causal link between action
 mov b h o  at time step   and goal  move object d h o  at time step    since one of
the eects of action   at d o   satised one of the goal descriptions of the goal 
now a valid plan for a goal can be dened on the basis of temporal ordering constraints
and causal links over a set of observed actions  a valid plan p for a goal g  given the initial
conditions  is represented as a   tuple    a  o  l    in which a is a set of observed actions 
o is a set of temporal ordering constraints over a  and l is a set of causal links over a 
definition    valid plan  let g be a goal  and p    a  o  l    where a is a set of
observed actions  o is a set of temporal ordering constraints   ai   aj    over a  and l is a
set of causal links   ai  aj    over a  let i be the initial conditions  p is a valid plan
for g  given i  if and only if
   the actions in a can be executed in i in any order consistent with o 
   the goal g is fully achieved after the actions in a are executed in i in any order
consistent with o 
for instance  in the example shown in figure    given the initial conditions  i     at
b o    at d h    at c h    p     a     mov b o h   a     put in d h   a     mov b
h o     a    a    a    a      a   a    a   a    a   a     is a valid plan for goal g  
 move object d h o  
  

fihong

    consistent goals
we now dene what we mean when we say a goal is consistent with a set of observed
actions  a set of observed actions is represented by a   tuple    a  o    in which a is a
set of observed actions and o is a set of temporal ordering constraints   ai   aj    over a  
definition    relevant action  given a goal g and a set of observed actions    a  o   
an action a  a is said to be relevant to g in the context of   a  o    if and only if
   there exists a causal link  a  g  or
   there exists a causal link  a  b  where b  a is relevant to g and a   b is consistent
with o 
definition    consistent goal  a goal g is consistent with a set of observed actions 
  a  o    if and only if the strict majority of a  a are relevant to g in the context of
  a  o   
proposition    valid plan for consistent goal  let   a  o   be a set of observed
actions  i be the initial conditions of   a  o    g be a goal consistent with   a  o   
there exists a set of causal links  l    ai  aj    over a and given i  p    a  o  l  
is a valid plan for either g when g is fully achieved in the time step after   a  o   has
been observed or the achieved part of g when g is partially achieved in the time step after
  a  o   has been observed 
proof  when g is fully achieved in the time step after a set of actions has been observed 
it directly follows denitions   and   that there exists a set of causal links  l    ai  aj   
over a  it then follows denition   that given i  p    a  o  l   is a valid plan for g 
when g is partially achieved in the time step after a set of actions has been observed 
let g be the achieved part of g  so g is fully achieved in the time step after the set of
actions has been observed  and it directly follows denitions      and   that there exists a
set of causal links  l    ai  aj    over a and given i  p    a  o  l   is a valid plan for
g   
for instance  in the example shown in figure    we have   a  o        a     mov b o
h   a     put in d h   a     mov b h o     a    a    a    a       and g    move object
d h o  is a fully achieved goal in the time step after   a  o   has been observed  according
to denition   and    g is consistent with   a  o   because there exist causal links  a   g
between a  and g  a   a  between a  and a    a   a  between a  and a    and a   a 
between a  and a    let i be the initial conditions of   a  o    l    a   a    a   a   
a   a     according to proposition    p    a  o  l   is a valid plan for g  furthermore 
causal link  a   g  explains the purpose of a   
in summary  according to denition   and proposition    when we say a goal is consistent
with a set of observed actions  we mean that the strict majority of the observed actions are
relevant to the goal and the set of observed actions forms a valid plan for the goal or the
achieved part of it 
   we assume that actions are observed at consecutive time steps but more than one action can be observed
at a time step 

  

figoal recognition through goal graph analysis

   goal recognition algorithms
we now describe our goal recognition algorithms  our goal recognition algorithms run in a
two stage cycle at each time step  in the rst stage  the goalgraphconstructor algorithm
takes the actions observed in the time step and tries to extend the goal graph  in the second
stage  the goalgraphanalyser algorithm analyses the constructed goal graph to recognise
those fully or partially achieved goals  that are consistent with the actions observed so far 
and the valid plans for these goals or part of them  this two stage cycle continues until no
action is observed at the next time step 
    constructing a goal graph
we use a   tuple   p  ao   gr   e   to represent a goal graph  where p is a set of proposition nodes  ao is a set of action nodes  gr is a set of goal nodes  and e is a set of edges  a
proposition node is represented by prop p  i   where p is a positive or negative ground literal 
i is a time step  an action node is represented by action a  i   where a is an observed action
and i is a time step  a goal node is represented by goal g  i   where g is a goal and i is a
time step  a precondition edge is represented by precondition edge prop p  i   action a  i   
an eect edge is represented by eect edge action a  i   prop p  i        a description edge is
represented by description edge prop p  i   goal g  i    and a persistence edge is represented
by persistence edge prop p  i      prop p  i   
the goalgraphconstructor algorithm consists of two algorithms  the goal expansion
algorithm and the action expansion algorithm  the goalgraphconstructor algorithm starts
with a goal graph    p                that consists of only proposition level   with nodes
representing the initial conditions 
given a goal graph ending with proposition level i  the goal expansion algorithm rst
extends the goal graph to goal level i  with nodes representing goals fully or partially
achieved at time step i  the algorithm goes through every possible ground instance of goal
schemata  for every goal instance  it rst gets a set of goal descriptions  it then eliminates
all the universally quantied goal descriptions by dynamic expansion to get an equivalent
set of goal descriptions  a goal node is added onto goal level i to represent an achieved
goal  if at least one of its goal descriptions has been satised at proposition level i  it can
then be decided whether a goal is fully or partially achieved  based on whether all or some
of its goal descriptions have been satised respectively at proposition level i  meanwhile 
if a node in proposition level i satises a goal description  a description edge connecting
the proposition node and the goal node is added onto the goal graph  figure   shows the
goal expansion algorithm  the algorithm takes a goal graph   p  ao   gr   e   ending
with proposition level i  time step i  and a set of goal schemata g as input  it returns an
updated goal graph ending with goal level i after the goal expansion 
when actions are observed at time step i  the action expansion algorithm then extends the goal graph ending with goal level i  to action level i  with nodes representing
the observed actions  at the same time  the algorithm also extends the goal graph to
proposition level i      with nodes representing propositions true or explicitly known to be
false after the actions have been observed 
for every action observed at time step i  the algorithm rst instantiates an action schema
with the observed action to get a precondition set and an eect set  it then eliminates
  

fihong

goal expansion   p  ao   gr   e    i  g 
   for every gk  g
for every instance g of gk
a  get a set of goal descriptions sg  
b  get the equivalent set of sg   sg  
c  for every pg  sg   where pg   not pg   
if prop neg pg    i   p   then
add description edge prop neg pg   i   goal g  i   to e 
d  for every pg  sg   where pg    not pg   
if prop pg   i   p   then
add description edge prop pg  i   goal g  i   to e 
e  if one of the goal descriptions of g is satised  then
add goal g  i  to gr  
   return with   p  ao   gr   e   
figure    the goal expansion algorithm

all the universally quantied preconditions and eects  as well as conditional eects  by
dynamic expansion to get equivalent precondition and eect sets  meanwhile  if a node in
proposition level i satises a precondition of the action  a precondition edge  connecting the
proposition node and the action node  is added onto the goal graph  for every eect of
the action  the action expansion algorithm simply adds a proposition node representing the
eect to proposition level i      the eect edge from the action node to the proposition
node is also added onto the goal graph 
after the above expansion  every proposition node at proposition level i is brought
forward to proposition level i     by a maintenance action  if its truth value has not been
changed by an action observed at time step i  and it has not been added onto the goal graph
by an action observed at time step i    persistence edges  connecting the corresponding
proposition nodes at the two proposition levels  are added onto the goal graph 
figure   shows the action expansion algorithm  the algorithm takes a goal graph
  p  ao   gr   e   ending with goal level i  the set of actions observed at time step i  ai  
time step i  and a set of action schemata a as input  it returns an updated goal graph
ending with proposition level i     after the action expansion  the expansion of the goal
graph from proposition level i to proposition level i     simulates the eects of executing
the actions observed at time step i 
if otherwise there is no action observed at time step i  the goalgraphconstructor algorithm nishes with nodes in goal level i  representing all the possible goals either fully or
partially achieved after all these actions have been observed 

   our goal recognition algorithms allow redundant actions 

  

figoal recognition through goal graph analysis

action expansion   p  ao   gr  e    ai   i  a 
   for every ai  ai
a  add action ai  i  to ao  
b  instantiate an action schema in a with ai to get a precondition set
sp   and an eect set se  
c  get the equivalent sets of sp and se   sp  and se  
d  for every pp  sp   where pp   not pp   
if prop neg pp  i   p   then
add precondition edge prop neg pp  i   action ai  i   to e 
e  for every pp  sp   where pp    not pp   
if prop pp  i   p   then
add precondition edge prop pp  i   action ai  i   to e 
f  for every pe  se
i  add prop pe  i      to p  
ii  add eect edge action ai  prop pe  i       to e 
   for every prop p  i   p
if prop p  i      
  p   then
if prop p  i      
  p   then add prop p  i      to p  
add persistence edge prop p  i   prop p  i       to e 
   return with   p  ao   gr   e   
figure    the action expansion algorithm
theorem    polynomial size and time  consider a goal recognition problem with s
observed actions in t time steps  a nite number of objects at each time step  p propositions
in the initial conditions  and m goal schemata each having a constant number of parameters 
let l  be the largest number of eects of any action schema  and l  be the largest number
of goal descriptions of any goal schema  let n be the largest number of objects at all time
steps  then  the size of the goal graph of t     levels created by the goalgraphconstructor
algorithm  and the time needed to create the graph  are polynomial in n  m  p  l    l    and s 
proof  the maximum number of nodes in any proposition level is o p   l  s   let k
be the largest number of parameters in any goal schema  since any goal schema can be
instantiated in at most nk distinct ways  the maximum numbers of nodes and edges in any
goal level are o mnk   and o l  mnk   respectively  it is obvious that the time needed to
create both nodes and edges in any level is polynomial in the number of nodes and edges
in the level   
theorem   the goalgraphconstructor algorithm is sound  any goal it adds to the goal
graph at time step i is one either fully or partially achieved at time step i in the state of the
world  the algorithm is complete  if a goal has been either fully or partially achieved by the
observed actions up to time step i     then the algorithm will add it to the goal graph at
time step i  under the assumption that all the possible goals are restricted to the categories
of goal schemata 
  

fihong

proof  soundness   proposition level   of the goal graph consists of only the initial
conditions  representing the state of the world at time step   before any action has been
observed  the goal graph is extended from proposition level i    to proposition level i  by
adding only the eects of the actions observed at time step i   and bringing forward all the
other proposition nodes that have not been aected by these actions from proposition level
i    to proposition level i  therefore  proposition level i of the goal graph represents the
state of the world at time step i  that has been changed from the initial conditions after
the actions have been observed at time steps         i   
a goal added to the goal graph at time step i by the algorithm is a fully or partially
achieved goal in proposition level i of the goal graph  therefore  it is a goal that is fully
or partially achieved in the state of the world at time step i 
proof  completeness   suppose a goal has been either fully or partially achieved by the
actions observed at time steps         i    this goal is then either fully or partially achieved
in proposition level i of the goal graph  since goal level i of the goal graph consists
of all the possible instances of the goal schemata  that are fully or partially achieved in
proposition level i of the goal graph  and the goal is an instance of a goal schema  it is one
of the fully or partially achieved goal instances in proposition level i  the algorithm will
therefore add the goal to goal level i in the goal graph   
    recognising consistent goals and valid plans
the goalgraphanalyser algorithm analyses the constructed goal graph to recognise consistent goals and valid plans  we assume that the strict majority of the observed actions are
relevant to the goal intended by the agent in the context of the agents actions  therefore 
the goal intended by the agent is consistent with the set of observed actions  and a goal
may be the intended goal if it is consistent with the set of observed actions  in order to
decide whether a goal is consistent with a set of observed actions  that is  whether it is
relevant to the strict majority of the observed actions  we need to recognise causal links
between either two observed actions or an observed action and the goal  we now dene
two particular types of paths  we call causal link paths  in the constructed goal graph  we
prove in theorems   and   that causal links can be recognised by identifying causal link
paths 
definition   given a goal graph  let ai be an action observed at time step i and gj be a
goal fully or partially achieved in time step j  where i   j  a path that connects ai to gj
via an eect edge  zero or more persistence edges  and a description edge  is called a causal
link path between ai and gj  
theorem   given a goal graph  there exists a causal link  ai  gj   between an action ai
at time step i and a goal gj at time step j  where i   j  if ai is connected to gj via a causal
link path 
proof  according to denition    a causal link path between ai and gj consists of an
eect edge  zero or more persistence edges  and a description edge  the eect edge on the
path connects ai to a proposition node in proposition level i      representing one of the
eects of ai   when j   i      there is no persistence edge on the path and this proposition
  

figoal recognition through goal graph analysis

node is connected to gj by a description edge  when j   i      this proposition node is
brought forward to proposition level j via j i  persistence edges by j i  maintenance
actions  and the brought forward proposition node in proposition level j is connected to gj
by a description edge  in either case  one of the eects of ai satised one of the goal
descriptions of gj   since a goal can be treated as an action with the goal descriptions as the
preconditions and an empty set of eects  according to denition    there exists a causal
link between ai and gj    
definition   given a goal graph  let ai and aj be two actions observed at time steps i
and j respectively  where i   j  a path that connects ai to aj via an eect edge  zero or
more persistence edges  and a precondition edge  is called a causal link path between ai and
aj  
theorem   given a goal graph  there exist a causal link  ai  aj   between an action ai
at time step i and an action aj at time step j  where i   j  if ai is connected to aj via a
causal link path 
the proof of theorem   is similar to theorem    the details of the proof are omitted 
given a constructed goal graph   p  ao   gr   e   of t levels  the goalgraphanalyser
algorithm shown in figure   recognises every consistent goal from the goals in goal level t 
by deciding whether the strict majority of the observed actions are relevant to it  this is
done by rst nding those relevant actions from the observed actions  that are connected to
the goal by causal link paths  for each of the already known relevant actions  the algorithm
tries to nd more relevant actions from the observed actions  that are connected to it by
causal link paths  this continues until no more relevant action is found  the consistent
goal recognised and the valid plan for the goal or part of it are represented by a   tuple 
  gt    ao   o  la    lg    where gt is the goal  la is a set of causal links over the observed
actions  and lg is a set of causal links between some of the observed actions and the goal 
  ao   o  la   represents a valid plan for gt or part of it  and lg further explains the
purposes of some of the observed actions 
proposition   the goalgraphanalyser algorithm is sound  any goal g it recognises at
time step t is consistent with the observed actions so far  and the plan it organises for g or
part of g is valid 
proof  the goalgraphanalyser algorithm recognises a goal g at time step t  when the
strict majority of the observed actions are connected to g  either directly by a causal link
path or indirectly by a chain of causal link paths  when an observed action is connected
to g directly by a causal link path  according to theorem   and denition    there exists
a causal link between the observed action and g  and the observed action is relevant to
g  when an observed action is connected to g indirectly by a chain of causal link paths 
according to theorem    theorem    and denition    there is a chain of causal links
between the observed action and g  and the observed action is relevant to g  since the strict
majority of the observed actions are relevant to g  according to denition    g is consistent
with the set of observed actions  furthermore  according to proposition    the plan the
goalgraphanalyser algorithm organises for g or part of g    ao   o  la    is a valid plan  
  

fihong

goalgraphanalyser   p  ao   gr   e    t 
   for every gt  gr in goal level t
a  ao       a      lg      la     
b  for every ai  ao connected to gt by a causal link path
add ai  gt to lg   and
add ai to ao   and
add ai to a 
c  if a      and for most of ai  ao   ai  ao   then
get all the ordering constraints  o  over ao   and
add   gt     ao   o  la    lg   to goalplan 
d  if a        then
remove an action aj from a  and
for every ai  ao connected to aj by a causal link path
add ai  aj to la   and
  ao   then add ai to ao   ai to a  and
if ai 
go to  c 
   return with goalplan 
figure    the goalgraphanalyser algorithm

in the example shown in figure    the goal nodes in bold represent three consistent
goals  among which the goal node in italics represents a partially achieved goal  while the
other two represent two fully achieved goals  the edges in bold show causal link paths 

theorem    polynomial space and time  consider a t level goal graph  let l  be
the number of fully or partially achieved goals at time step t  m  be the largest number of
goal descriptions in any of these goals  l  be the number of the observed actions  and m 
be the largest number of preconditions in any of these actions  the space size of possible
causal link paths  that connect the goals to the observed actions and that connect the observed
actions to other observed actions  and the time needed to recognise all the consistent goals 
are polynomial in l    l    m    and m   

proof  persistence edges do not branch in a goal graph  for each of the goals in
goal level t  the maximum number of paths searched for those observed actions  that are
connected to the goal by causal link paths and hence relevant to it  is o m     for each of
the relevant actions to the goal  the maximum number of paths searched for those observed
actions  that are connected to the relevant action by causal link paths and hence also
relevant to the goal  is o m     there are at maximum only l  goals in goal level t and
l  relevant actions to any of these goals  so the space size of possible causal link paths is
o l   m    l  m      the time needed to recognise all the consistent goals is polynomial in
the space size   
  

figoal recognition through goal graph analysis

    goal redundancy
the goalgraphanalyser algorithm recognises fully or partially achieved goals at a time step 
that are consistent with the actions observed so far  among these consistent goals  fully
achieved goals better explain the actions observed so far  for instance  in the example shown
in figure    two consistent goals are recognised by the goalgraphanalyser algorithm at time
step     move object d h o  is fully achieved and  keep object at d o  is partially
achieved  between these two consistent goals  the fully achieved goal better explains the
observed actions so far  if  for instance  another action  take out d  is observed at next
time step   keep object at d o  becomes fully achieved and remains consistent with the
observed actions  so at that time step  it best explains the observed actions  a partially
achieved goal  that is consistent with the observed actions so far  can remain consistent
when more actions are observed in the future and becomes fully achieved  so choosing the
fully achieved goal and making the partially achieved goal redundant does not rule out the
possibility of the partially achieved goal remaining consistent and becoming fully achieved
in the future  based on this principle  we can make a partially achieved consistent goal
at a time step redundant  if its satised goal descriptions are implied by the satised goal
descriptions of another fully or partially achieved consistent goal 
definition   a partially achieved consistent goal at a time step is redundant  if the set of
its satised goal descriptions is either a subset of the goal descriptions of a fully achieved consistent goal or a proper subset of the satised goal descriptions of another partially achieved
consistent goal at the same time step 
for instance  at time step   the set of satised goal descriptions of  keep object at d
o  is a subset of the goal descriptions of  move object d h o   the partial achievement
of  keep object at d o  has been implied by the full achievement of  move object d h
o   so  keep object at d o  is made redundant by  move object d h o  at time step
  
a fully achieved consistent goal at a time step  however  can be made redundant only if
its goal descriptions are implied by the goal descriptions of another fully achieved consistent
goal at the same time step 
definition   a fully achieved consistent goal at a time step is redundant  if the set of its
goal descriptions is a subset of the goal descriptions of another fully achieved consistent goal
at the same time step 
    the most consistent goals
after all the redundant goals have been removed from the set of consistent goals at a time
step  there might still be more than one consistent goal in the set  if this is the case  the
numbers of observed actions that are relevant to these remaining consistent goals will be
compared  those remaining goals that have the maximum number of relevant actions will
be chosen as the most consistent goals at the time step 
definition   given a set of consistent goals at a time step  a consistent goal in the set is
the most consistent goal in the set  if it has the maximum number of relevant actions among
all the consistent goals in the set 
  

fihong

for instance  in the example shown in figure    if another action  take out d  is
observed at time step    both  move object d h o  and  keep object at d o  are consistent goals at time step    and neither of them is redundant   keep object at d o 
is relevant to all the ve observed actions  while  move object d h o  is relevant to only
four of the observed actions  according to denition     keep object at d o  is the most
consistent goal at time step   
in the example shown in figure    the goal nodes with an asterisk represent the consistent
goals eventually remaining after the two processes of removing redundant goals and selecting
the most consistent goals 

   experimental results
we implemented our goal recognition algorithms in prolog and tested them in terms of
accuracy  eciency  and scalability on a desktop with a pentium iii processor at     mhz 
we tested our algorithms on a set of data in the unix domain collected at the university
of washington  to collect the data  the subjects were given goals described in english rst
and they then tried to achieve each goal by executing unix commands  the commands
issued to unix by the subject and the responses from unix to these commands were
recorded in the data set  some of the commands issued by the subject were not valid and
could not be executed in unix  so the responses from unix to these invalid commands
were actually error messages  for each of the goals the subjects tried to achieve  they
indicated success or failure with regard to the achievement of the goal 
there are    goals in the unix data set  and each of these goals was tried by   subjects
on average  as shown in table    these goals can be classied into four types  the rst type
of goals are those of locating a le that has some of the properties  such as extension  size 
contents  ownership  date  word count  and compression  the second type of goals are those
of locating a machine that has some of the properties  such as load and logged in users  the
third type of goals are those of locating a printer that has some of the properties  such as
print jobs and out of paper  the fourth type of goals are those of compressing all or large
les in a directory  for the fourth type of goals  universally quantied goal descriptions
are needed in the corresponding goal schemata  in addition  there are also two compound
goals  g  and g    that are the conjunctions of two goals of the second type 
to test our algorithms  the sequences of unix commands  recorded in the data set  were
taken as the observed actions at consecutive time steps  we took only the valid commands 
that were successfully executed in unix  and ltered out the invalid commands  that
unix failed to execute and responded only in the error messages  we created    action
schemata for a set of commonly used unix commands  including those executed by the
subjects  we also created     goal schemata  including     le search goal schemata  for
goals of locating a le that has some properties      non le search goal schemata  for goals
of locating a machine or a printer that has some properties and goals of compressing all
or large les in a directory  and     goal schemata of paired non le search goals  the
   goals in the unix data set are the instances of some of these goal schemata  we rst
tested our algorithms with respect to accuracy and eciency  that is  the number of goals
remaining after a sequence of observed actions has been processed  and the average time
  

figoal recognition through goal graph analysis

g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

find a le named core 
find a le that contains motivating and whose name ends in  tex 
find a machine that has low         load  and
determine if oren etzioni is logged into the machine named chum 
compress all large           bytes  les in the testgrounds subdirectory tree 
compress all les in the directory named backups  dont use    
find a large le            bytes  that hasnt been changed for over a month 
find a le that contains less than    words 
find a laser printer in sieg hall that has an active print job 
find a sun on the fourth oor that has low         load 
and determine if dan weld is active on the machine named chum 
find a printer that is out of paper 
find a le named oldpaper in neal testgrounds subdirectory 
find a le of length   in neal testgrounds subdirectory 
see if dan weld is logged into chum 
find a machine that dan weld is logged into 

table    the    goals in the unix data set collected at the university of washington
taken to construct a goal graph  analyse the constructed goal graph  and run through a
cycle of goal graph construction and analysis  when an action was observed at a time step 
table   gives a summary of the empirical results showing the accuracy of our algorithms 
the rst column shows the goals the subject tried to achieve  the achieved goals were the
goals fully or partially achieved after the last observed action had been processed  the
consistent goals were the fully or partially achieved goals that were consistent with the
sequence of observed actions   the remaining goals were the goals that remained after the
redundant goals had been removed and the most consistent goals had been selected  the
last column shows whether the given goal was among the remaining goals 
as shown in table    our algorithms successfully recognised    out of    given goals 
they failed to recognise only one given goal  g     simply because the sequence of commands
executed by the subject actually failed to achieve the goal  in terms of the unix data set 
goal recognition occurs when our algorithms return a single  consistent goal  this occurred
on g    g    g    g    g    g     and g     on g    g    g    g     and g     more than one goal
was recognised  including the goal given to the subject  on g    g    g     and g     our
algorithms recognised that the subject tried to nd one of the les with some properties
in the directory but did not know which le it was  for instance  on g    the intended
goal was to nd a le named core  the subject successfully found the le named core in
the directory  other  by executing a command  ls  to list all les in the directory  since
there were other les  greenmouse  paper tex  and action ps z  in the same directory 
   in our experiments on the unix data set  a goal  to which more than two third of the observed actions
were relevant  was recognised as a consistent goal  the threshold on the number of relevant actions is
dependent on the application domain though the strict majority of the actions must be relevant  if the
threshold is too high  our algorithms might fail to recognise the intended goal  on the other hand  if it is
too low  the set of recognised goals might be too large to provide much value because of great ambiguity
on the intended goal 

  

fihong

goal
g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

achieved
goals
  
  
  
  
  
   
  
 
  
 
  
  
 
 

consistent
goals
  
 
 
  
  
  
 
 
 
 
  
  
 
 

remaining
goals
 
 
 
 
 
 
 
 
 
 
 
 
 
 

given goal
recognised















table    empirical results of the unix domain showing the accuracy of our algorithms

and all these les were also listed by the same command  our algorithms recognised four
goals  nding a le named core  nding a le named greenmouse  nding a le named
paper with extension tex  and nding a le named action with extension ps which
is also compressed  on g    our algorithms recognised that the subject tried to nd one
of the users on a machine but did not know who he was  this was as good as a human
observer could do because you simply could not tell from the observed actions which le or
user the subject was trying to nd  these recognised goals can be generalised into a single 
consistent goal nding a le in the directory or nding a user using a machine  where
variables are allowed in the recognised goals 
on g    our algorithms recognised   consistent goals  among these goals  ve goals
were to nd each of the ve les with the same properties of compression and extension
in the directory named backups  another goal was to gunzip all les in the directory
named backups  a human observer could probably do better by recognising the goal of
gunzipping all les in the directory named backups  because it accounted better for the
gunzip command that had been observed  it was very unlikely that the subject gunzipped
all les in the directory in order to nd a le with gunzip compression 
among the goals we tested  g    g    g    and g  were originally tested by lesh and
etzioni         our empirical results show a signicant improvement on the accuracy of
the goal recogniser implemented by them in terms of the remaining goals  our algorithms
have          and   remaining goals on g    g    g    and g  respectively  while their goal
recogniser has             and    remaining goals on g    g    g    and g  respectively  after
the last observed action has been processed  furthermore  the   and   remaining goals that
our algorithms have on g  and g  can be generalised into two single goals  these results
show that our algorithms perform extremely well with regard to accuracy 
  

figoal recognition through goal graph analysis

goal
g 
g 
g 
g 
g 
g 
g 
g 
g 
g  
g  
g  
g  
g  

length of
observation
    
  
   
    
 
    
    
   
  
  
 
  
 
 

construction
time
     
     
     
     
     
      
      
     
     
     
     
     
     
     

analysis
time
     
     
     
     
     
     
     
     
     
     
     
     
     
     

time
per cycle
     
     
     
     
     
      
      
     
     
     
     
     
     
     

table    empirical results of the unix domain showing the eciency of our algorithms

it is worth noting that lesh and etzionis algorithm converges before the last observed
action has been processed  so their algorithm works towards goal prediction  while our algorithms emphasise the explanation of the observed actions  by recognising fully or partially
achieved goals that are consistent with these actions  their algorithm can quickly prune
out inconsistent goals to get a converged set of hypothesised goals  though the number of
hypothesised goals in the set can sometimes be large  the next step of their work might
be to assign probabilities to these hypothesised goals to dierentiate a single goal from the
others  when there exists only one intended goal  on the other hand  it is less desirable for
the goals recognised by our algorithms to be dierentiated from each other as the accuracy
of the algorithms is usually high  our algorithms  however  cannot recognise a goal until it
has been fully or partially achieved 
table   gives a summary of the empirical results showing the eciency of our algorithms 
the length of observation was the average number of observed actions executed by the
subjects to achieve the given goal  the construction time was the average time it took to
construct the goal graph at a time step  the analysis time was the average time it took
to analyse the constructed goal graph at a time step  the time per cycle was the average
time it took to go through a two stage cycle of goal graph construction and analysis 
when an observed action was processed at a time step  including constructing the goal
graph  recognising the consistent goals  removing redundant goals  and selecting the most
consistent goals  as shown in table    on average at a time step  it took       cpu seconds
to construct the goal graph        cpu seconds to analyse the goal graph  and      
cpu seconds to process an observed action  since our algorithms have been written in the
less ecient prolog and run on a desktop with a pentium iii processor at     mhz  more
eciency could be achieved  the construction time  analysis time  and time per cycle could
  

fihong

average cpu seconds

   
   

c time

   

a time
   

p time

  
 
     

     

     

     

     

     

     

     

            

number of goals

figure    empirical results of the unix domain showing the scalability of our algorithms

be reduced to well below a cpu second  if the algorithms are coded in a more ecient
programming language and run on a faster machine 
compared to the empirical results on the eciency of the goal recogniser implemented
by lesh and etzioni         on average  it took                      and       cpu seconds
to process an observed action by our algorithms on g    g    g    and g  respectively  while
                     and       cpu seconds were taken by their goal recogniser to process
an observed action on the same goals  the average time to process an observed action
was roughly around     cpu seconds on both a desktop with a pentium iii processor at
    mhz by our algorithms coded in prolog and a sparc    by their goal recogniser
coded in lisp  given that two dierent programming languages and machines were used
for the implementation of two dierent systems  this comparison is hardly meaningful  it is
however apparent that the use of more ecient programming languages and machines can
signicantly speed up our algorithms 
we also tested the scalability of our goal recognition algorithms in the unix domain 
we tested how the eciency of our algorithms was aected by the number of possible goals 
that was in turn aected by the number of objects in the universe of objects  we created a
series of spaces of approximate                         up to     possible goals respectively
based on the data recorded on g  in the unix data set   for doing this  we changed the
les and directories in the le hierarchy  as well as the properties of the les  in the original
data set for g    to increase or decrease the number of objects in the universe of objects 
while keeping the les and directories related to the intended goal and the properties of
the related les unchanged  in the sense that while part of the initial conditions on the
intended goal remained the same  the rest of the initial conditions were changed to create
   the number of goal schemata remains unchanged 

  

figoal recognition through goal graph analysis

the appropriate number of candidate goals  the change in the le hierarchy reected the
change in the complexity of the le hierarchy 
the original sequences of commands recorded in the data set were used in the experiments  in conjunction with the dierent sets of the initial conditions  for the creation of
dierent spaces of candidate goals  figure   shows that the average cpu time taken at
a time step to construct and analyse the goal graph  shown as c time and a time respectively in figure     and to process the observed action as a whole  shown as p time in
figure    was approximately linear in the number of candidate goals 

   conclusion and future work
in this paper  we presented a new approach to goal recognition in which a graph structure
called a goal graph is constructed and analysed for goal recognition  we described two
algorithms for constructing and analysing a goal graph  our algorithms recognise partially
or fully achieved goals that are consistent with the observed actions  and reveal valid plans
for the recognised goals or part of them  our algorithms do not need a plan library  they
allow redundant  extraneous  and partially ordered actions  they are sound  polynomialtime  and polynomial space 
our empirical experiments show that our algorithms recognise goals with great accuracy 
they are computationally ecient  they can be scaled up and applied to domains where
there are tens of thousands of goals and plans  even though one of our goal recognition
algorithms  the goalgraphanalyser algorithm  is not complete  they recognised all the
intended goals in the unix data set that were successfully achieved by the subjects 
a limitation of our goal recognition algorithms is that sometimes more than one goal
is recognised  though the number of recognised goals is usually very small  our algorithms
cannot tell which goal is the most probable one when there is only one intended goal  for
instance  on g  in the unix data set  our algorithms recognised   goals  even though the
intended goal  gunzipping all les in the directory called backups  was among these goals 
and it was probably the most likely one compared to the others  our algorithms could not
dierentiate it from the others  sometimes our algorithms can recognise a unique goal that
implies the intended goal but cannot make it more specic  for instance  on g  in the unix
data set  our algorithms recognised a unique goal  nding the le  index tex  with its word
count and extension  even though the achievement of this goal implied the achievement of
the intended goal  nding a le that contains less than    words  our algorithms could not
be more specic  these problems are due to the incomplete information we had from the
observed actions  on g    the observed actions did not have any indication on the likelihood
of the recognised goals being the intended goal  the subject actually achieved g  because
he knew that the word count was less than    words by knowing the word count of the le 
but no observed action was directly used to achieve this 
several attempts  carberry        charniak   goldman        huber et al        
forbes et al         pynadath   wellman        bauer        albrecht et al         have
been made to incorporate uncertainty representation and reasoning techniques into plan
recognition for handling uncertain and incomplete information  so that a single plan can
be distinguished from a set of candidate plans  however  these systems rely heavily on the
availability of planning knowledge and to a certain extent the use of plan libraries  in future
  

fihong

work  we intend to investigate the possibility of incorporating uncertainty representation
and reasoning mechanisms into our goal graph based approach to goal recognition  so that
a unique  specic goal can be recognised when there is only one intended goal  while all the
good features of our goal graph based approach are kept 
in future work  we also intend to explore the extent to which our goal graph representation can be used for probabilistic goal recognition  in particular  we will consider problem
settings in which the eects of actions are probabilistic and the objective of goal recognition
is to recognise consistent goals with the highest probability of achievement 
another area of future work is to recognise goals even before they have been partially
or fully achieved by the actions observed so far  in this regard  our current goal recognition
algorithms can be used to recognise goals that each sequence of actions in a very large data
set can achieve  then each sequence of actions in the data set and the recognised goals can
be used to acquire a probabilistic model of goal prediction by a machine learning method 
this probabilistic model takes the actions observed so far and predicts possible goals even
when they are not partially or fully achieved 

acknowledgments
this paper is a revised and extended version of a paper appeared in the proceedings of
aaai       hong         the author wishes to thank neal lesh for providing the unix
data set  and anonymous referees for their insights and constructive criticisms  which have
helped improve the paper signicantly 

references
albrecht  d  w   zukerman  i     nicholson  a  e          bayesian model for keyhole
plan recognition in an adventure game  user modeling and user adapted interaction 
             
allen  j  f          recognizing intentions from natural language utterances  in brady  m  
  berwick  b   eds    computational models of discourse  pp          mit press 
cambridge  ma 
allen  j  f     perrault  c  r          analyzing intention in utterances  articial intelligence             
anderson  c   smith  d  e     weld  d          conditional eects in graphplan  in
proceedings of the  th international conference on ai planning systems  pp       
bauer  m          dempster shafer approach to modeling agent preferences for plan recognition  user modeling and user adapted interaction                  
bauer  m          acquisition of abstract plan descriptions for plan recognition  in proceedings of aaai     pp         
bauer  m     paul  g          logic based plan recognition for intelligent help systems  in
backstrom  c     sandewall  e   eds    current trends in ai planning  pp       
ios press 
  

figoal recognition through goal graph analysis

blum  a  l     furst  m  l          fast planning through planning graph analysis 
articial intelligence             
carberry  s          user models  the problem of disparity  in proceedings of the   th
international conference on computational linguistics  pp       
carberry  s          modeling the users plans and goals  computational linguistics         
     
carberry  s          incorporating default inferences into plan recognition  in proceedings
of aaai     pp         
carver  n  f   lesser  v  r     mccue  d  l          focusing in plan recognition  in
proceedings of aaai     pp       
charniak  e     goldman  r  p          a bayesian model of plan recognition  articial
intelligence           
forbes  j   huang  t   kanazawa  k     russell  s          the batmobile  towards a
bayesian automated taxi  in proceedings of ijcai     pp           
gazen  b     knoblock  c          combining the expressivity of ucpop with the eciency
of graphplan  in proceedings of the  th european conference on planning  pp     
    
goodman  b  a     litman  d  j          on the interaction between plan recognition and
intelligent interfaces  user modeling and user adapted interaction           
grosz  b  j     sidner  c  l          plans in discourse  in p  r  cohen  j  m     pollack 
m  e   eds    intentions in communication  pp          mit press  cambridge  ma 
hong  j          goal graph construction and analysis as a paradigm for plan recognition 
in proceedings of aaai       pp         
huber  m  j     durfee  e  h          deciding when to commit to action during
observation based coordination  in proceedings of the first international conference
on multi agent systems  pp         
huber  m  j   durfee  e  h     wellman  m  p          the automated mapping of plans for
plan recognition  in proceedings of the   th conference on uncertainty in articial
intelligence  pp         
hu  k     lesser  v          a plan based intelligent assistant that supports the software
development process  in proceedings of the acm sigsoft sigplan software engineering symposium on practical software development environments  pp        
kautz  h  a          a formal theory of plan recognition  phd thesis  university of
rochester 
koehler  j   nebel  b   homann  j     dimopoulos  y          extending planning graphs
to an adl subset  in proceedings of the  th european conference on planning  pp 
       
lesh  n     etzioni  o          a sound and fast goal recognizer  in proceedings of ijcai    pp           
  

fihong

lesh  n     etzioni  o          scaling up goal recognition  in proceedings of the  th
international conference on principles of knowledge representation and reasoning 
pp         
litman  d  j     allen  j  f          a plan recognition model for sub dialogues in conversation  cognitive science                 
mooney  r  j          learning plan schemata from observation  explanation based learning
for plan recognition  cognitive science                 
pednault  e  p  d          synthesizing plans that contain actions with context dependent
eects  computational intelligence                
pednault  e  p  d          adl  exploring the middle ground between strips and the
situation calculus  in proceedings of the  st international conference on knowledge
representation and reasoning  pp         
pollack  m  e          plans as complex mental attitudes  in cohen  p  r   morgan 
j     pollack  m  e   eds    intentions in communication  pp         mit press 
cambridge  ma 
pynadath  d  v     wellman  m  p          accounting for context in plan recognition  with
application to trac monitoring  in proceedings of the   th conference on uncertainty
in articial intelligence  pp         
schank  r     abelson  r          scripts  plans  goals  and understanding  erlbaum 
sidner  c  l          plan parsing for intended response recognition in discourse  computational intelligence             
wilensky  r          planning and understanding  addison wesley publishing company 
reading  ma 
wilensky  r     et al          the berkeley unix consultant project  computational linguistics               

  

fi