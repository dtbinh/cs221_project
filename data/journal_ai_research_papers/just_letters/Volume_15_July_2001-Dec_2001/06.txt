journal of artificial intelligence research                  

submitted       published     

planning by rewriting
jose luis ambite
craig a  knoblock

ambite isi edu
knoblock isi edu

information sciences institute and department of computer science 
university of southern california 
     admiralty way  marina del rey  ca        usa

abstract
domain independent planning is a hard combinatorial problem  taking into account
plan quality makes the task even more difficult  this article introduces planning by rewriting  pbr   a new paradigm for efficient high quality domain independent planning  pbr
exploits declarative plan rewriting rules and efficient local search techniques to transform
an easy to generate  but possibly suboptimal  initial plan into a high quality plan  in addition to addressing the issues of planning efficiency and plan quality  this framework offers
a new anytime planning algorithm  we have implemented this planner and applied it to
several existing domains  the experimental results show that the pbr approach provides
significant savings in planning effort while generating high quality plans 

   introduction

planning is the process of generating a network of actions  a plan  that achieves a desired
goal from an initial state of the world  many problems of practical importance can be
cast as planning problems  instead of crafting an individual planner to solve each specific
problem  a long line of research has focused on constructing domain independent planning
algorithms  domain independent planning accepts as input  not only descriptions of the
initial state and the goal for each particular problem instance  but also a declarative domain
specification  that is  the set of actions that change the properties of the state  domainindependent planning makes the development of planning algorithms more efficient  allows
for software and domain reuse  and facilitates the principled extension of the capabilities of
the planner  unfortunately  domain independent planning  like most planning problems 
is computationally hard  bylander        erol  nau    subrahmanian        backstrom
  nebel         given the complexity limitations  most of the previous work on domainindependent planning has focused on finding any solution plan without careful consideration
of plan quality  usually very simple cost functions  such as the length of the plan  have
been used  however  for many practical problems plan quality is crucial  in this paper
we present a new planning paradigm  planning by rewriting  pbr   that addresses both
planning efficiency and plan quality while maintaining the benefits of domain independence 
the framework is fully implemented and we present empirical results in several planning
domains 
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

fiambite   knoblock

    solution approach
two observations guided the present work  the first one is that there are two sources of
complexity in planning 
 satisfiability  the difficulty of finding any solution to the planning problem  regardless
of the quality of the solution  
 optimization  the difficulty of finding the optimal solution under a given cost metric 
for a given domain  each of these facets may contribute differently to the complexity of
planning  in particular  there are many domains in which the satisfiability problem is
relatively easy and their complexity is dominated by the optimization problem  for example 
there may be many plans that would solve the problem  so that finding one is efficient
in practice  but the cost of each solution varies greatly  thus finding the optimal one is
computationally hard  we will refer to these domains as optimization domains  some
optimization domains of great practical interest are query optimization and manufacturing
process planning  
the second observation is that planning problems have a great deal of structure  plans
are a type of graph with strong semantics  determined by both the general properties
of planning and each particular domain specification  this structure should and can be
exploited to improve the efficiency of the planning process 
prompted by the previous observations  we developed a novel approach for efficient
planning in optimization domains  planning by rewriting  pbr   the framework works in
two phases 
   generate an initial solution plan  recall that in optimization domains this is efficient 
however  the quality of this initial plan may be far from optimal 
   iteratively rewrite the current solution plan improving its quality using a set of declarative plan rewriting rules  until either an acceptable solution is found or a resource
limit is reached 
as motivation  consider the optimization domains of distributed query processing and
manufacturing process planning   distributed query processing  yu   chang        involves generating a plan that efficiently computes a user query from data that resides at
different nodes in a network  this query plan is composed of data retrieval actions at diverse
information sources and operations on this data  such as those of the relational algebra 
join  selection  etc   some systems use a general purpose planner to solve this problem
 knoblock         in this domain it is easy to construct an initial plan  any parse of the
query suffices  and then transform it using a gradient descent search to reduce its cost 
the plan transformations exploit the commutative and associative properties of the  relational algebra  operators  and facts such as that when a group of operators can be executed
together at a remote information source it is generally more efficient to do so  figure  
   interestingly  one of the most widely studied planning domains  the blocks world  also has this property 
   these domains are analyzed in section    graphical examples of the rewriting process appear in figure   
for query planning and in figure    for manufacturing process planning  the reader may want to consult
those figures even if not all details can be explained at this point 

   

fiplanning by rewriting

shows some sample transformations  simple join swap transforms two join trees according to the commutative and associative properties of the join operator  remote join eval
executes a join of two subqueries at a remote source  if the source is able to do so 
simple join swap 
retrieve q   source      retrieve q   source     retrieve q   source    
retrieve q   source      retrieve q   source     retrieve q   source   
remote join eval 
 retrieve q   source    retrieve q   source    capability source  join 
 retrieve q    q   source 
figure    transformations in query planning
in manufacturing  the problem is to find an economical plan of machining operations
that implement the desired features of a design  in a feature based approach  nau  gupta 
  regli         it is possible to enumerate the actions involved in building a piece by
analyzing its cad model  it is more difficult to find an ordering of the operations and the
setups that optimize the machining cost  however  similar to query planning  it is possible
to incrementally transform a  possibly inefficient  initial plan  often  the order of actions
does not affect the design goal  only the quality of the plan  thus many actions can commute 
also  it is important to minimize the number of setups because fixing a piece on a machine
is a rather time consuming operation  interestingly  such grouping of machining operations
on a setup is analogous to evaluating a subquery at a remote information source 
as suggested by these examples  there are many problems that combine the characteristics of traditional planning satisfiability with quality optimization  for these domains there
often exist natural transformations that may be used to efficiently obtain high quality plans
by iterative rewriting  planning by rewriting provides a domain independent framework
that allows plan transformations to be conveniently specified as declarative plan rewriting
rules and facilitates the exploration of efficient  local  search techniques 
    advantages of planning by rewriting
there are several advantages to the planning style that pbr introduces  first  pbr is a
declarative domain independent framework  this facilitates the specification of planning
domains  their evolution  and the principled extension of the planner with new capabilities  moreover  the declarative rewriting rule language provides a natural and convenient
mechanism to specify complex plan transformations 
second  pbr accepts sophisticated quality measures because it operates on complete
plans  most previous planning approaches either have not addressed quality issues or have
very simple quality measures  such as the number of steps in the plan  because only partial
plans are available during the planning process  in general  a partial plan cannot offer
enough information to evaluate a complex cost metric and or guide the planning search
effectively 
   

fiambite   knoblock

third  pbr can use local search methods that have been remarkably successful in scaling
to large problems  aarts   lenstra          by using local search techniques  high quality
plans can be efficiently generated  fourth  the search occurs in the space of solution plans 
which is generally much smaller than the space of partial plans explored by planners based
on refinement search 
fifth  our framework yields an anytime planning algorithm  dean   boddy         the
planner always has a solution to offer at any point in its computation  modulo the initial
plan generation that needs to be fast   this is a clear advantage over traditional planning
approaches  which must run to completion before producing a solution  thus  our system
allows the possibility of trading off planning effort and plan quality  for example  in query
planning the quality of a plan is its execution time and it may not make sense to keep
planning if the cost of the current plan is small enough  even if a cheaper one could be
found  further discussion and concrete examples of these advantages are given throughout
the following sections 
    contributions
the main contribution of this paper is the development of planning by rewriting  a novel
domain independent paradigm for efficient high quality planning  first  we define a language of declarative plan rewriting rules and present the algorithms for domain independent
plan rewriting  the rewriting rules provide a natural and convenient mechanism to specify complex plan transformations  our techniques for plan rewriting generalize traditional
graph rewriting  graph rewriting rules need to specify in the rule consequent the complete
embedding of the replacement subplan  we introduce the novel class of partially specified
plan rewriting rules that relax that restriction  by taking advantage of the semantics of
planning  this embedding can be automatically computed  a single partially specified rule
can concisely represent a great number of fully specified rules  these rules are also easier
to write and understand than their fully specified counterparts  second  we adapt local
search techniques  such as gradient descent  to efficiently explore the space of plan rewritings and optimize plan quality  finally  we demonstrate empirically the usefulness of the
pbr approach in several planning domains 
    outline
the remainder of this paper is structured as follows  section   provides background on
planning  rewriting  and local search  some of the fields upon which pbr builds  section  
presents the basic framework of planning by rewriting as a domain independent approach to
local search  this section describes in detail plan rewriting and our declarative rewriting rule
language  section   describes several application domains and shows experimental results
comparing pbr with other planners  section   reviews related work  finally  section  
summarizes the contributions of the paper and discusses future work 
   although the space of rewritings can be explored by complete search methods  in the application domains
we have analyzed the search space is very large and our experience suggests that local search is more
appropriate  however  to what extent complete search methods are useful in a planning by rewriting
framework remains an open issue  in this paper we focus on local search 

   

fiplanning by rewriting

   preliminaries  planning  rewriting  and local search
the framework of planning by rewriting arises as the confluence of several areas of research  namely  artificial intelligence planning algorithms  graph rewriting  and local search
techniques  in this section we give some background on these areas and explain how they
relate to pbr 
    ai planning
we assume that the reader is familiar with classical ai planning  but in this section we will
highlight the main concepts and relate them to the pbr framework  weld              and
russell   norvig        provide excellent introductions to ai planning 
pbr follows the classical ai planning representation of actions that transform a state 
the state is a set of ground propositions understood as a conjunctive formula  pbr  as most
ai planners  follows the closed world assumption  that is  if a proposition is not explicitly
mentioned in the state it is assumed to be false  similarly to the negation as failure semantics
of logic programming  the propositions of the state are modified  asserted or negated  by
the actions in the domain  the actions of a domain are specified by operator schemas 
an operator schema consists of two logical formulas  the precondition  which defines the
conditions under which the operator may be applied  and the postcondition  which specifies
the changes on the state effected by the operator  propositions not mentioned in the
postcondition are assumed not to change during the application of the operator  this type
of representation was initially introduced in the strips system  fikes   nilsson        
the language for the operators in pbr is the same as in sage  knoblock            b  
which is an extension of ucpop  penberthy   weld         the operator description
language in pbr accepts arbitrary function free first order formulas in the preconditions of
the operators  and conditional and universally quantified effects  but no disjunctive effects  
in addition  the operators can specify the resources they use  sage and pbr address unit
non consumable resources  these resources are fully acquired by an operator until the
completion of its action and then released to be reused 
figure   shows a sample operator schema specification for a simple blocks world
domain   in the representation accepted by pbr  this domain has two actions  stack 
which puts one block on top of another  and unstack  which places a block on the table  
the state is described by two predicates   on  x  y   denotes that a block  x is on top of
another block  y  or on the table   and  clear  x  denotes that a  x block does not have
any other block on top of it 
an example of a more complex operator from a process manufacturing domain is shown
in figure    this operator describes the behavior of a punch  which is a machine used to
make holes in parts  the punch operation requires that there is an available clamp at the
machine and that the orientation and width of the hole is appropriate for using the punch 
after executing the operation the part will have the desired hole but it will also have a
   to illustrate the basic concepts in planning  we will use examples from a simple blocks world domain 
the reader will find a real world application of planning techniques  query planning  in section     
    stack  x  y  z  can be read as stack the block  x on top of block  y from  z 
 unstack  x  y  can be read as lift block  x from the top of block  y and put it on the table 
   by convention  variables are preceded by a question mark symbol      as in  x 

   

fiambite   knoblock

 define  operator stack 
 parameters   x  y  z 
 precondition
  and  on  x  z   clear  x   clear  y 
  neq  y  z    neq  x  z    neq  x  y 
  neq  x table    neq  y table  
 effect   and  on  x  y    not  on  x  z  
 clear  z    not  clear  y    

 define  operator unstack 
 parameters   x  y 
 precondition
  and  on  x  y   clear  x    neq  x  y 
  neq  x table    neq  y table  
 effect   and  on  x table   clear  y 
  not  on  x  y    

figure    blocks world operators
 define  operator punch 
 parameters   x  width  orientation 
 resources   machine punch   is object  x  
 precondition   and  is object  x 
 is punchable  x  width  orientation 
 has clamp punch  
 effect   and   forall   surf    when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 has hole  x  width  orientation   

figure    manufacturing operator
rough surface   note the specification on the resources slot  declaring  machine punch 
as a resource enforces that no other operator can use the punch concurrently  similarly 
declaring the part   is object  x   as a resource means that only one operation at a time
can be performed on the object  further examples of operator specifications appear in
figures         and    
a plan in pbr is represented by a graph  in the spirit of partial order causal link planners  pocl  such as ucpop  penberthy   weld         the nodes are plan steps  that
is  instantiated domain operators  the edges specify a temporal ordering relation among
steps imposed by causal links and ordering constraints  a causal link is a record of how a
proposition is established in a plan  this record contains the proposition  sometimes also
called a condition   a producer step  and a consumer step  the producer is a step in the
plan that asserts the proposition  that is  the proposition is one of its effects  the consumer
is a step that needs that proposition  that is  the proposition is one of its preconditions  by
causality  the producer must precede the consumer 
the ordering constraints are needed to ensure that the plan is consistent  they arise
from resolving operator threats and resource conflicts  an operator threat occurs when a
step that negates the condition of a causal link can be ordered between the producer and the
consumer steps of the causal link  to prevent this situation  which makes the plan inconsistent  pocl planners order the threatening step either before the producer  demotion 
or after the consumer  promotion  by posting the appropriate ordering constraints  for the
   this operator uses an idiom combining universal quantification and negated conditional effects to enforce
that the attribute surface condition of a part is single valued 

   

fiplanning by rewriting

unit non consumable resources we considered  steps requiring the same resource have to be
sequentially ordered  and such a chain of ordering constraints will appear in the plan 
an example of a plan in the blocks world using this graph representation is given in
figure    this plan transforms an initial state consisting of two towers  c on a  a on the
table  b on d  and d on the table  to the final state consisting of one tower  a on b  b on c 
c on d  and d on the table  the initial state is represented as step   with no preconditions
and all the propositions of the initial state as postconditions  similarly  the goal state is
represented as a step goal with no postconditions and the goal formula as the precondition 
the plan achieves the goal by using two unstack steps to disassemble the two initial towers
and then using three stack steps to build the desired tower  the causal links are shown as
solid arrows and the ordering constraints as dashed arrows  the additional effects of a step
that are not used in causal links  sometimes called side effects  are shown after each step
pointed by thin dashed arrows  negated propositions are preceded by   note the need
for the ordering link between the steps    stack b c table   and    stack a b table  
if step   could be ordered concurrently or before step    it would negate the precondition
clear b  of step    making the plan inconsistent  a similar situation occurs between steps
  and   where another ordering link is introduced 

clear b 

causal link
ordering constraint
side effect

on a table 
on c a 

clear a 

  stack a b table 

  unstack c a 
on c table 

on c a 
clear c 
on d table 

on a table 
clear b 

clear c 

 
clear b 

on b table 
on a b 
clear c 
  stack b c table 
on b c 
on c d 
  stack c d table 
goal
clear d 
on c table 
clear d 
a

on b d 

b

on b table 
  unstack b d 
on b d 
clear b 

c

b

c

a

d

d

clear c 
initial state

goal state

figure    sample plan in the blocks world domain

    rewriting
plan rewriting in pbr is related to term and graph rewriting  term rewriting originated
in the context of equational theories and reduction to normal forms as an effective way
to perform deduction  avenhaus   madlener        baader   nipkow         a rewrite
system is specified as a set of rules  each rule corresponds to a preferred direction of an
equivalence theorem  the main issue in term rewriting systems is convergence  that is  if
two arbitrary terms can be rewritten in a finite number of steps into a unique normal form 
in pbr two plans are considered equivalent if they are solutions to the same problem 
   

fiambite   knoblock

although they may differ on their cost or operators  that is  they are equivalent with
respect to satisfiability as introduced above   however  we are not interested in using
the rewriting rules to prove such equivalence  instead  our framework uses the rewriting
rules to explore the space of solution plans 
graph rewriting  akin to term rewriting  refers to the process of replacing a subgraph of
a given graph  when some conditions are satisfied  by another subgraph  graph rewriting
has found broad applications  such as very high level programming languages  database
data description and query languages  etc  schurr        presents a good survey  the
main drawback of general graph rewriting is its complexity  because graph matching can
be reduced to  sub graph isomorphism the problem is np complete  nevertheless  under
some restrictions graph rewriting can be performed efficiently  dorr        
planning by rewriting adapts general graph rewriting to the semantics of partial order
planning with a strips like operator representation  a plan rewriting rule in pbr specifies
the replacement  under certain conditions  of a subplan by another subplan  however  in
our formalism the rule does not need to specify the completely detailed embedding of the
consequent as in graph rewriting systems  the consistent embeddings of the rule consequent 
with the generation of edges if necessary  are automatically computed according to the
semantics of partial order planning  our algorithm ensures that the rewritten plans always
remain valid  section         the plan rewriting rules are intended to explore the space of
solution plans to reach high quality plans 
    local search in combinatorial optimization
pbr is inspired by the local search techniques used in combinatorial optimization  an
instance of a combinatorial optimization problem consists of a set of feasible solutions and a
cost function over the solutions  the problem consists in finding a solution with the optimal
cost among all feasible solutions  generally the problems addressed are computationally
intractable  thus approximation algorithms have to be used  one class of approximation
algorithms that have been surprisingly successful in spite of their simplicity are local search
methods  aarts   lenstra        papadimitriou   steiglitz        
local search is based on the concept of a neighborhood  a neighborhood of a solution
p is a set of solutions that are in some sense close to p  for example because they can be
easily computed from p or because they share a significant amount of structure with p 
the neighborhood generating function may  or may not  be able to generate the optimal
solution  when the neighborhood function can generate the global optima  starting from
any initial feasible point  it is called exact  papadimitriou   steiglitz        page     
local search can be seen as a walk on a directed graph whose vertices are solutions
points and whose arcs connect neighboring points  the neighborhood generating function
determines the properties of this graph  in particular  if the graph is disconnected  then the
neighborhood is not exact since there exist feasible points that would lead to local optima
but not the global optima  in pbr the points are solution plans and the neighbors of a plan
are the plans generated by the application of a set of declarative plan rewriting rules 
the basic version of local search is iterative improvement  iterative improvement starts
with an initial solution and searches a neighborhood of the solution for a lower cost solution  if such a solution is found  it replaces the current solution and the search continues 
   

fiplanning by rewriting

otherwise  the algorithm returns a locally optimal solution  figure   a  shows a graphical
depiction of basic iterative improvement  there are several variations of this basic algorithm  first improvement generates the neighborhood incrementally and selects the first
solution of better cost than the current one  best improvement generates the complete
neighborhood and selects the best solution within this neighborhood 

neighborhood

local optima

local optima

 a  basic iterative improvement

 b  variable depth search

figure    local search
basic iterative improvement obtains local optima  not necessarily the global optimum 
one way to improve the quality of the solution is to restart the search from several initial points and choose the best of the local optima reached from them  more advanced
algorithms  such as variable depth search  simulated annealing and tabu search  attempt to
minimize the probability of being stuck in a low quality local optimum 
variable depth search is based on applying a sequence of steps as opposed to only one
step at each iteration  moreover  the length of the sequence may change from iteration to
iteration  in this way the system overcomes small cost increases if eventually they lead to
strong cost reductions  figure   b  shows a graphical depiction of variable depth search 
simulated annealing  kirkpatrick  gelatt    vecchi        selects the next point randomly  if a lower cost solution is chosen  it is selected  if a solution of a higher cost is
chosen  it is still selected with some probability  this probability is decreased as the algorithm progresses  analogously to the temperature in physical annealing   the function that
governs the behavior of the acceptance probability is called the cooling schedule  it can be
proven that simulated annealing converges asymptotically to the optimal solution  unfortunately  such convergence requires exponential time  so  in practice  simulated annealing
is used with faster cooling schedules  not guaranteed to converge to the optimal  and thus
it behaves like an approximation algorithm 
tabu search  glover        can also accept cost increasing neighbors  the next solution
is a randomly chosen legal neighbor even if its cost is worse than the current solution  a
neighbor is legal if it is not in a limited size tabu list  the dynamically updated tabu list
prevents some solution points from being considered for some period of time  the intuition
is that if we decide to consider a solution of a higher cost at least it should lie in an
unexplored part of the space  this mechanism forces the exploration of the solution space
out of local minima 
finally  we should stress that the appeal of local search relies on its simplicity and good
average case behavior  as could be expected  there are a number of negative worst case results  for example  in the traveling salesman problem it is known that exact neighborhoods 
   

fiambite   knoblock

that do not depend on the problem instance  must have exponential size  savage  weiner 
  bagchi         moreover  an improving move in these neighborhoods cannot be found in
polynomial time unless p   np  papadimitriou   steiglitz         nevertheless  the best
approximation algorithm for the traveling salesman problem is a local search algorithm
 johnson        

   planning by rewriting as local search
planning by rewriting can be viewed as a domain independent framework for local search 
pbr accepts arbitrary domain specifications  declarative plan rewriting rules that generate
the neighborhood of a plan  and arbitrary  local  search methods  therefore  assuming that
a given combinatorial problem can be encoded as a planning problem  pbr can take it as
input and experiment with different neighborhoods and search methods 
we will describe the main issues in planning by rewriting as an instantiation of the
local search idea typical of combinatorial optimization algorithms 
 selection of an initial feasible point  in pbr this phase consists of efficiently generating
an initial solution plan 
 generation of a local neighborhood   in pbr the neighborhood of a plan is the set of
plans obtained from the application of a set of declarative plan rewriting rules 
 cost function to minimize  this is the measure of plan quality that the planner is
optimizing  the plan quality function can range from a simple domain independent
cost metric  such as the number of steps  to more complex domain specific ones  such
as the query evaluation cost or the total manufacturing time for a set of parts 
 selection of the next point  in pbr  this consists of deciding which solution plan to
consider next  this choice determines how the global space will be explored and has
a significant impact on the efficiency of planning  a variety of local search strategies
can be used in pbr  such as steepest descent  simulated annealing  etc  which search
method yields the best results may be domain or problem specific 
in the following subsections we expand on these issues  first  we discuss the use of
declarative rewriting rules to generate a local neighborhood of a plan  which constitutes
the main contribution of this paper  we present the syntax and semantics of the rules  the
plan rewriting algorithm  the formal properties and a complexity analysis of plan rewriting 
and a rule taxonomy  second  we address the selection of the next plan and the associated
search techniques for plan optimization  third  we discuss the measures of plan quality 
finally  we describe some approaches for initial plan generation 
    local neighborhood generation  plan rewriting rules
the neighborhood of a solution plan is generated by the application of a set of declarative
plan rewriting rules  these rules embody the domain specific knowledge about what transformations of a solution plan are likely to result in higher quality solutions  the application
of a given rule may produce one or several rewritten plans or fail to produce a plan  but
the rewritten plans are guaranteed to be valid solutions  first  we describe the syntax and
   

fiplanning by rewriting

semantics of the rules  second  we introduce two approaches to rule specification  third  we
present the rewriting algorithm  its formal properties  and the complexity of plan rewriting 
finally  we present a taxonomy of plan rewriting rules 
      plan rewriting rules  syntax and semantics
first  we introduce the rule syntax and semantics through some examples  then  we provide
a formal description  a plan rewriting rule has three components      the antecedent   if
field  specifies a subplan to be matched      the  replace field identifies the subplan that
is going to be removed  a subset of steps and links of the antecedent      the  with field
specifies the replacement subplan  figure   shows two rewriting rules for the blocks world
domain introduced in figure    intuitively  the rule avoid move twice says that  whenever
possible  it is better to stack a block on top of another directly  rather than first moving
it to the table  this situation occurs in plans generated by the simple algorithm that first
puts all blocks on the table and then build the desired towers  such as the plan in figure   
the rule avoid undo says that the actions of moving a block to the table and back to its
original position cancel each other and both could be removed from a plan 
 define rule  name avoid move twice
 if   operators    n   unstack  b   b   
  n   stack  b   b  table   
 links   n   on  b  table   n  
 constraints   possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators   n   stack  b   b   b     

 define rule  name avoid undo
 if   operators
   n   unstack  b   b   
  n   stack  b   b  table   
 constraints
  possibly adjacent  n   n   
 replace   operators   n   n   
 with nil  

figure    blocks world rewriting rules
a rule for the manufacturing domain of  minton      b  is shown in figure    this
domain and additional rewriting rules are described in detail in section      the rule states
that if a plan includes two consecutive punching operations in order to make holes in two
different objects  but another machine  a drill press  is also available  the plan quality may
be improved by replacing one of the punch operations with the drill press  in this domain
the plan quality is the  parallel  time to manufacture all parts  this rule helps to parallelize
the plan and thus improve the plan quality 
 define rule  name punch by drill press
 if   operators    n   punch  o   width   orientation   
  n   punch  o   width   orientation    
 links   n   n  
 constraints    neq  o   o  
 possibly adjacent  n   n    
 replace   operators   n   
 with   operators   n   drill press  o   width   orientation     

figure    manufacturing process planning rewriting rule
   

fiambite   knoblock

the plan rewriting rule syntax is described by the bnf specification given in figure   
this bnf generates rules that follow the template shown in figure    next  we describe
the semantics of the three components of a rule   if   replace  and  with fields  in detail 
 rule       define rule  name  name 
 if   graph spec with constraints  
 replace   graph spec  
 with   graph spec   
 graph spec with constraints        graph spec  
  constraints   constraints   
 graph spec        operators   nodes   
  links   edges      nil
 nodes       node     node   nodes 
 edges       edge     edge   edges 
 constraints       constraint     constraint   constraints 
 node        node var    node predicate     resource  
 edge        node var   node var    
  node var   edge predicate   node var    
  node var   threat  node var  
 constraint       interpreted predicate   
  neq  pred var   pred var  
 node var    pred var           optional      alternative

figure    bnf for the rewriting rules

 define rule  name  rule name 
 if   operators    nv   np    resource       
 links    nv    lp   threat   nv       
 constraints   ip       
 replace   operators   nv      
 links    nv    lp   threat   nv        
 with   operators    nv   np    resource       
 links    nv    lp    nv         
 nv    node variable   np    node predicate       optional
 lp    causal link predicate   ip    interpreted predicate 

    alternative

figure    rewriting rule template
the antecedent  the  if field  specifies a subplan to be matched against the current
plan  the graph structure of the subplan is defined in the  operators and  links fields 
the  operators field specifies the nodes  operators  of the graph and the  links field
specifies the edges  causal and ordering links   finally  the  constraints field specifies a
set of constraints that the operators and links must satisfy 
the  operators field consists of a list of node variable and node predicate pairs  the
step number of those steps in the plan that match the given node predicate would be
correspondingly bound to the node variable  the node predicate can be interpreted in
two ways  as the step action  or as a resource used by the step  for example  the node
specification   n   stack  b   b  table   in the antecedent of avoid move twice in
figure   shows a node predicate that denotes a step action  this node specification will
collect tuples  composed of step number  n  and blocks  b  and  b   obtained by matching
steps whose action is a stack of a block  b  that is on the table and it is moved on top of
another block  b   this node specification applied to the plan in figure   would result in
   

fiplanning by rewriting

three matches     c d      b c   and    a b   for the variables   n   b   b   respectively 
if the optional keyword  resource is present  the node predicate is interpreted as one of
the resources used by a plan step  as opposed to describing a step action  an example of a
rule that matches against the resources of an operator is given in figure     where the node
specification   n   machine  x   resource  will match all steps that use a resource of
type machine and collect pairs of step number  n  and machine object  x 
 define rule  name resource swap
 if   operators    n   machine  x   resource 
  n   machine  x   resource  
 links    n   threat  n    
 replace   links   n   n   
 with   links   n   n    

figure     resource swap rewriting rule
the  links field consists of a list of link specifications  our language admits link
specifications of three types  the first type is specified as a pair of node variables  for
example    n   n   in figure    this specification matches any temporal ordering link in
the plan  regardless if it was imposed by causal links or by the resolution of threats 
the second type of link specification matches causal links  causal links are specified
as triples composed of a producer step node variable  an edge predicate  and a consumer
step node variable  the semantics of a causal link is that the producer step asserts in its
effects the predicate  which in turn is needed in the preconditions of the consumer step  for
example  the link specification   n   on  b  table   n   in figure   matches steps  n 
that put a block  b  on the table and steps  n  that subsequently pick up this block  that
link specification applied to the plan in figure   would result in the matches     c    and
   b     for the variables   n   b   n   
the third type of link specification matches ordering links originating from the resolution
of threats  coming either from resource conflicts or from operator conflicts   these links
are selected by using the keyword  threat in the place of a condition  for example  the
resource swap rule in figure    uses the link specification   n   threat  n   to ensure
that only steps that are ordered because they are involved in a threat situation are matched 
this helps to identify which are the critical steps that do not have any other reasons  i e 
causal links  to be in such order  and therefore this rule may attempt to reorder them 
this is useful when the plan quality depends on the degree of parallelism in the plan as a
different ordering may help to parallelize the plan  recall that threats can be solved either
by promotion or demotion  so the reverse ordering may also produce a valid plan  which is
often the case when the conflict is among resources as in the rule in figure    
interpreted predicates  built in and user defined  can be specified in the  constraints
field  these predicates are implemented programmatically as opposed to being obtained by
matching against components from the plan  the built in predicates currently implemented
are inequality    neq   comparison              and arithmetic           predicates  the
user can also add arbitrary predicates and their corresponding programmatic implementa   equality is denoted by sharing variables in the rule specification 

   

fiambite   knoblock

tions  the interpreted predicates may act as filters on the previous variables or introduce
new variables  and compute new values for them   for example  the user defined predicate
possibly adjacent in the rules in figure   ensures that the steps are consecutive in some
linearization of the plan   for the plan in figure   the extension of the possibly adjacent
predicate is                                                          and    goal  
the user can easily add interpreted predicates by including a function definition that
implements the predicate  during rule matching our algorithm passes arguments and calls
such functions when appropriate  the current plan is passed as a default first argument to
the interpreted predicates in order to provide a context for the computation of the predicate
 but it can be ignored   figure    show a skeleton for the  lisp  implementation of the
possibly adjacent and less than interpreted predicates 
 defun possibly adjacent  plan node  node  
 not  necessarily not adjacent
node 
node 
   accesses the current plan
 plan ordering plan   

 defun less than  plan n  n  
 declare  ignore plan  
 when  and  numberp n    numberp n   
 if    n  n  
 nil     true
nil       false

figure     sample implementation of interpreted predicates
the consequent is composed of the  replace and  with fields  the  replace field
specifies the subplan that is going to be removed from the plan  which is a subset of the
steps and links identified in the antecedent  if a step is removed  all the links that refer to
the step are also removed  the  with field specifies the replacement subplan  as we will
see in sections       and        the replacement subplan does not need to be completely
specified  for example  the  with field of the avoid move twice rule of figure   only
specifies the addition of a stack step but not how this step is embedded into the plan  the
links to the rest of the plan are automatically computed during the rewriting process 
      plan rewriting rules  full versus partial specification
pbr gives the user total flexibility in defining rewriting rules  in this section we describe two
approaches to guaranteeing that a rewriting rule specification preserves plan correctness 
that is  produces a valid rewritten plan when applied to a valid plan 
in the full specification approach the rule specifies all steps and links involved in a
rewriting  the rule antecedent identifies all the anchoring points for the operators in the
consequent  so that the embedding of the replacement subplan is unambiguous and results
in a valid plan  the burden of proving the rule correct lies upon the user or an automated
rule defining procedure  cf  section     these kind of rules are the ones typically used in
graph rewriting systems  schurr        
in the partial specification approach the rule defines the operators and links that constitute the gist of the plan transformation  but the rule does not prescribe the precise
   the interpreted predicate possibly adjacent makes the link expression in the antecedent of avoid move twice redundant  unstack puts the block  b  on the table from where it is picked up by the
stack operator  thus the causal link   n   on  b  table   n   is already implied by the  operators
and  constraints specification and could be removed from the rule specification 

   

fiplanning by rewriting

embedding of the replacement subplan  the burden of producing a valid plan lies upon the
system  pbr takes advantage of the semantics of domain independent planning to accept
such a relaxed rule specification  fill in the details  and produce a valid rewritten plan 
moreover  the user is free to specify rules that may not necessarily be able to compute
a rewriting for a plan that matches the antecedent because some necessary condition was
not checked in the antecedent  that is  a partially specified rule may be overgeneral  this
may seem undesirable  but often a rule may cover more useful cases and be more naturally
specified in this form  the rule may only fail for rarely occurring plans  so that the effort in
defining and matching the complete specification may not be worthwhile  in any case  the
plan rewriting algorithm ensures that the application of a rewriting rule either generates a
valid plan or fails to produce a plan  theorem    section        
as an example of these two approaches to rule specification  consider figure    that
shows the avoid move twice full rule  a fully specified version of the avoid move twice
rule  of figure    reprinted here for convenience   the avoid move twice full rule is
more complex and less natural to specify than avoid move twice  but  more importantly 
avoid move twice full is making more commitments than avoid move twice  in particular  avoid move twice full fixes the producer of  clear  b   for  n  to be  n  when
 n  is also known to be a valid candidate  in general  there are several alternative producers
for a precondition of the replacement subplan  and consequently many possible embeddings 
a different fully specified rule is needed to capture each embedding  the number of rules
grows exponentially as all permutations of the embeddings are enumerated  however  by
using the partial specification approach we can express a general plan transformation by a
single natural rule 
 define rule  name avoid move twice full
 if   operators    n   unstack  b   b   
  n   stack  b   b  table   
 links    n   clear  b    n  
  n   on  b   b    n  
  n   clear  b    n  
  n   on  b  table   n  
  n   clear  b    n  
  n   clear  b    n  
  n   on  b   b    n   
 constraints   possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators    n   stack  b   b   b    
 links    n   clear  b    n  
  n   clear  b    n  
  n   on  b   b    n  
  n   on  b   b    n     

 define rule  name avoid move twice
 if   operators
   n   unstack  b   b   
  n   stack  b   b  table   
 links   n   on  b  table   n  
 constraints
  possibly adjacent  n   n  
  neq  b   b    
 replace   operators   n   n   
 with   operators
  n   stack  b   b   b     

figure     fully specified versus partially specified rewriting rule
in summary  the main advantage of the full specification rules is that the rewriting can
be performed more efficiently because the embedding of the consequent is already specified 
the disadvantages are that the number of rules to represent a generic plan transformation
may be very large and the resulting rules quite lengthy  both of these problems may decrease
   

fiambite   knoblock

the performance of the match algorithm  also  the rule specification is error prone if written
by the user  conversely  the main advantage of the partial specification rules is that a single
rule can represent a complex plan transformation naturally and concisely  the rule can
cover a large number of plan structures even if it may occasionally fail  also  the partial
specification rules are much easier to specify and understand by the users of the system 
as we have seen  pbr provides a high degree of flexibility for defining plan rewriting rules 
      plan rewriting algorithm
in this section  first we describe the basic plan rewriting algorithm in pbr  second  we
prove this algorithm sound and discuss some formal properties of rewriting  finally  we
discuss a family of algorithms for plan rewriting depending on parameters such as the
language for defining plan operators  the specification language for the rewriting rules  and
the requirements of the search method 
the plan rewriting algorithm is shown in figure     the algorithm takes two inputs 
a valid plan p   and a rewriting rule r    qm   pr   pc    qm is the antecedent query  pr is
the replaced subplan  and pc is the replacement subplan   the output is a valid rewritten
plan p     the matching of the antecedent of the rewriting rule  qm   determines if the rule is
applicable and identifies the steps and links of interest  line     this matching can be seen
as subgraph isomorphism between the antecedent subplan and the current plan  with the
results then filtered by applying the  constraints   however  we take a different approach 
pbr implements rule matching as conjunctive query evaluation  our implementation keeps
a relational representation of the steps and links in the current plan similar to the node
and link specifications of the rewriting rules  for example  the database for the plan in
figure   contains one table for the unstack steps with schema   n   b   b   and tuples
   c a  and    b d   another table for the causal links involving the clear condition with
schema   n   n   b  and tuples      c        b        c        b        c        b     
  a  and      d   and similar tables for the other operator and link types  the match
process consists of interpreting the rule antecedent as a conjunctive query with interpreted
predicates  and executing this query against the relational view of the plan structures  as a
running example  we will analyze the application of the avoid move twice rule of figure  
to the plan in figure    matching the rule antecedent identifies steps   and    more
precisely  considering the antecedent as a query  the result is the single tuple    c a   d 
for the variables   n   b   b   n   b   
after choosing a match i to work on  line     the algorithm instantiates the subplan
specified by the  replace field  pr   according to such match  line    and removes the
instantiated subplan pir from the original plan p  line     all the edges incoming and
emanating from nodes of the replaced subplan are also removed  the effects that the
replaced plan pir was achieving for the remainder of the plan  p pir    the usefuleffects of pir  
will now have to be achieved by the replacement subplan  or other steps of p  pir    in order
to facilitate this process  the addflaws procedure records these effects as open conditions   
    pocl planners operate by keeping track and repairing flaws found in a partial plan  open conditions  operator threats  and resource threats are collectively called flaws  penberthy   weld        
addflaws f p  adds the set of flaws f to the plan structure p  

   

fiplanning by rewriting

procedure rewriteplan
input  a valid partial order plan p
a rewriting rule r    qm   pr   pc    v ariables pr    v ariables qm  
output  a valid rewritten partial order plan p    or failure 
       m atch qm   p  
match the rule antecedent qm   if field  against p   the result is a set of substitutions
         i        for variables in qm  
   if     then return failure
   choose a match i  
   pir    i pr
instantiate the subplan to be removed pr  the  replace field  according to i  
   pri    addflaws usefuleffects pir    p  pir  
remove the instantiated subplan pir from the plan p and add the usefuleffects of pir
as open conditions  the resulting plan pri is now incomplete 
   pic    i pc
instantiate the replacement subplan pc  the  with field  according to i  
   pci    addf laws p reconditions pic    f indt hreats pri  pic    pri  pic  
add the instantiated replacement subplan pic to pri   find new threats and open
conditions and add them as flaws  pci is potentially incomplete  having several flaws
that need to be resolved 
   p      rp op  pci  
complete the plan using a partial order causal link planning algorithm  restricted to
do only step reuse  but no step addition  in order to resolve threats and open conditions 
rp op returns failure if no valid plan can be found 
   return p  
figure     plan rewriting algorithm
the result is the partial plan pri  line     continuing with our example  figure    a  shows
the plan resulting from removing steps   and   from the plan in figure   
finally  the algorithm embeds the instantiated replacement subplan pic into the remainder of the original plan  lines       if the rule is completely specified  the algorithm simply
adds the  already instantiated  replacement subplan to the plan  and no further work is
necessary  if the rule is partially specified  the algorithm computes the embeddings of the
replacement subplan into the remainder of the original plan in three stages  first  the
algorithm adds the instantiated steps and links of the replacement plan pic  line    into
the current partial plan pri  line     figure    b  shows the state of our example after
pic   the new stack step      has been incorporated into the plan  note the open conditions
 clear a  and on c d   second  the findthreats procedure computes the possible threats 
both operator threats and resource conflicts  occurring in the pri  pic partial plan  line    
for example  the threat situation on the clear c  proposition between step   and   in figure    b   these threats and the preconditions of the replacement plan pic are recorded by
addflaws resulting in the partial plan pci   finally  the algorithm completes the plan using
rpop  a partial order causal link planning procedure restricted to only reuse steps  i e   no
   

fiambite   knoblock

step addition   line     rpop allows us to support our expressive operator language and to
have the flexibility for computing one or all embeddings  if only one rewriting is needed 
rpop stops at the first valid plan  otherwise  it continues until exhausting all alternative ways of satisfying open preconditions and resolving conflicts  which produces all valid
rewritings  in our running example  only one embedding is possible and the resulting plan
is that of figure    c   where the new stack step     produces  clear a  and on c d  
its preconditions are satisfied  and the ordering       ensures that the plan is valid 
the rewriting algorithm in figure    is sound in the sense that it produces a valid plan
if the input is a valid plan  or it outputs failure if the input plan cannot be rewritten using
the given rule  since this elementary plan rewriting step is sound  the sequence of rewritings
performed during pbrs optimization search is also sound 
lemma    soundness of rpop  partial order causal link  pocl  planning without
step addition  rp op   is sound 
proof  in pocl planning  a precondition of a step of a plan is achieved either by
inserting a new step snew or reusing a step sreuse already present in the current plan  the
steps having an effect that unifies with the precondition   forbidding step addition decreases
the set of available steps that can be used to satisfy a precondition  but once a step is found
rpop proceeds as general pocl  since  the pocl completion of a partial plan is sound
 penberthy   weld         rp op is also sound   
theorem    soundness of plan rewriting  rewriteplan  figure     produces a
valid plan if the input p is a valid plan  or outputs failure if the input plan cannot be
rewritten using the given rewriting rule r    qm   pr   pc   
proof  assume plan p is a solution to a planning problem with goals g and initial
state i  in pocl planning  a plan is valid iff the preconditions of all steps are supported
by causal links  the goals g are the preconditions of the goal step  and the initial state
conditions i are the effects of the initial step   and no operator threatens any causal link
 mcallester   rosenblitt        penberthy   weld        
if rule r does not match plan p   the algorithm trivially returns failure  line     assuming
there is a match i   after removing from p the steps and links specified in pir  including
all links  causal and ordering  incoming and outgoing from steps of pir    the only open
conditions that exist in the resulting plan pri are those that pir was achieving  line    
adding the instantiated replacement subplan pic introduces more open conditions in the
partial plan  the preconditions of the steps of pic  line     there are no other sources of
open conditions in the algorithm 
since plan p is valid initially  the only  operator and or resource  threats present in
plan pci  line    are those caused by the removal of subplan pir  line    and the addition of
subplan pic  line     the threats may occur between any operators and causal links of pri pic
regardless whether the operator or causal link was initially in pri or in pic   the threats in
the combined plan pri  pic can be effectively computed by finding the relative positions of
its steps and comparing each causal link against the steps that may be ordered between the
producer and the consumer of the condition in the causal link  findthreats  line    
at this point  we have shown that we have a plan  pci   with all the flaws  threats and
open conditions  explicitly recorded  by addflaws in lines   and     since rp op is sound
 lemma     we conclude that rp op will complete pci and output a valid plan p     or output
failure if the flaws in the plan cannot be repaired   
   

fiplanning by rewriting

clear b 

removed subplan

on a table 
on c a 

causal link
ordering constraint
side effect

clear a 

  unstack c a 
on c a 
clear c 
on d table 

on a table 
clear b 

  stack a b table 
on c table 
  stack b c table 

clear c 
  stack c d table 

 

on b table 
on a b 
clear c 
on b c 
on c d 
goal

clear d 
clear b 

on c table 

clear d 

a

on b d 

b

on b table 
  unstack b d 
on b d 
clear b 

c

b

c

a

d

d

clear c 
initial state

goal state

 a  application of a rewriting rule  after removing subplan
clear b 

causal link
ordering constraint
open conditions

on a table 

clear a 
clear c 
on d table 
 

on c a 
clear b 

  stack a b table 
on b table 
on a b 
clear c 
on b c 

  stack b c table 
clear c 

clear a 

on c a 
clear d 

on b d 

on a table 
clear b 

on c d 

  stack c d a 

on c d 
clear d 
on c a 

goal
a

clear d 

b

on b table 
  unstack b d 
on b d 

clear b 

c

b

c

a

d

d

clear c 
initial state

goal state

 b  application of a rewriting rule  after adding replacement subplan
on a table 
clear b 

on a table 

  stack a b table 

clear b 
clear a 

on d table 
on c a 

  stack b c table 

clear c 

 

  stack c d a 
clear b 

on b table 
on a b 
clear c 
on b c 
on c d 
goal

clear d 
on c a 

clear d 

causal link
ordering constraint
side effect

on b d 
on b table 
  unstack b d 
on b d 
clear b 

a
b

c

b

c

a

d

d

clear c 
initial state

goal state

 c  rewritten plan
figure     plan rewriting  applying rule avoid move twice of figure   to plan of figure  
   

fiambite   knoblock

corollary    soundness of pbr search  the optimization search of pbr is sound 
proof  by induction  assume an initial valid plan and a single step rewriting search 
by theorem    the output is either a valid rewritten plan or failure  if the output is failure 
the search is trivially sound  assume there is a valid plan pn  after n    rewriting steps 
according to theorem    applying a single rewriting rule to plan pn  produces a valid
plan pn or failure  thus  an arbitrary number of rewritings produces a valid plan  or no
plan   so pbrs search is sound   
although rewriteplan is sound  it may certainly produce plans that do not have the
minimal number of steps when faced with arbitrary rules  for example  imagine that the
consequent of a rewriting rule specified two identical steps s  and s   both having as only
effects e  and e   and that the only flaws in pci were exactly the open conditions e  and e  
then  a sound but non step minimal plan would be using s  to satisfy e  and using s  to
satisfy e   although each step by itself could satisfy both open conditions   pbr does not
discard this plan because we do not make any restriction on the types of acceptable cost
functions  if we had a cost function that took the robustness of the plan into account  a
plan with both steps may be desirable 
we cannot guarantee that pbrs optimization search is complete in the sense that the
optimal plan would be found  pbr uses local search and it is well known that  in general 
local search cannot be complete  even if pbr exhaustively explores the space of plan
rewritings induced by a given initial plan and a set of rewriting rules  we still cannot prove
that all solution plans will be reached  this is a property of the initial plan generator  the
set of rewriting rules  and the semantics of the planning domain  the rewriting rules of pbr
play a similar role as traditional declarative search control where the completeness of the
search may be traded for efficiency  perhaps using techniques for inferring invariants in a
planning domain  gerevini   schubert        fox   long        rintanen        or proving
convergence of term and graph rewriting systems  baader   nipkow         conditions for
completeness of a plan rewriting search in a given planning domain could be obtained 
the design of a plan rewriting algorithm depends on several parameters  the language of
the operators  the language of the rewriting rules  the choice of full specification or partialspecification rewriting rules  and the need for all rewritings or one rewriting as required by
the search method 
the language of the operators affects the way in which the initial and rewritten plans are
constructed  our framework supports the expressive operator definition language described
in section      we provide support for this language by using standard techniques for causal
link establishment and threat checking like those in sage  knoblock        and ucpop
 penberthy   weld        
the language of the antecedents of the rewriting rules affects the efficiency of matching 
our system implements the conjunctive query language that was described in section       
however  our system could easily accommodate a more expressive query language for the
rule antecedent  such as a relationally complete language  i e   conjunction  disjunction  and
safe negation   abiteboul  hull    vianu         or a recursive language such as datalog
with stratified negation  without significantly increasing the computational complexity of
the approach in an important way  as we discuss in section       
the choice of fully versus partially specified rewriting rules affects the way in which the
replacement plan is embedded into the current plan  if the rule is completely specified 
   

fiplanning by rewriting

the embedding is already specified in the rule consequent  and the replacement subplan
is simply added to the current plan  if the rule is partially specified  our algorithm can
compute all the valid embeddings 
the choice of one versus all rewritings affects both the antecedent matching and the
embedding of rule consequent  the rule matches can be computed either all at the same
time  as in bottom up evaluation of logic databases  or one at a time as in prolog  depending on whether the search strategy requires one or all rewritings  if the rule is fully specified
only one embedding per match is possible  but  if the rule is partially specified multiple
embeddings may result from a single match  if the search strategy only requires one rewriting  it must also provide a mechanism for choosing which rule is applied  which match is
computed  and which embedding is generated  rpop can stop at the first embedding or
compute all embeddings   our implemented rewriting algorithm has a modular design to
support different combinations of these choices 
      complexity of plan rewriting
the complexity of plan rewriting in pbr originates from two sources  matching the rule
antecedent against the plan  and computing the embeddings of the replacement plan  in
order to analyze the complexity of matching plan rewriting rules  we introduce the following
database theoretic definitions of complexity  abiteboul et al         
data complexity  complexity of evaluating a fixed query for variable database inputs 
expression complexity  complexity of evaluating  on a fixed database instance  the
queries specifiable in a given query language 
data complexity measures the complexity with respect to the size of the database 
expression complexity measures the complexity with respect to the size of the queries
 taken from a given language   in our case  the database is the steps and links of the plan
and the queries are the antecedents of the plan rewriting rules 
formally  the language of the rule antecedents described in section       is conjunctive
queries with interpreted predicates  the worst case combined data and expression complexity of conjunctive queries is exponential  abiteboul et al          that is  if the size of the
query  rule antecedent  and the size of the database  plan  grow simultaneously  there is
little hope of matching efficiently  fortunately  relationally complete languages have a data
complexity contained in logarithmic space  which is  in turn  contained in polynomial time
 abiteboul et al          thus our conjunctive query language has at most this complexity 
this is a very encouraging result that shows that the cost of evaluating a fixed query grows
very slowly as the database size increases  for pbr this means that matching the antecedent
of the rules is not strongly affected by the size of the plans  moreover  in our experience
useful rule antecedents are not very large and contain many constant labels  at least  the
node and edge predicate names  that help to reduce the size of the intermediate results
and improve the efficiency of matching  this result also indicates that we could extend the
language of the antecedent to be relationally complete without affecting significantly the
performance of the system    another possible extension is to use datalog with stratified
negation  which also has polynomial time data complexity  graph theoretic properties of
    figure    in section   proposes an example of a rule with a relationally complete antecedent using an
appropriate syntax 

   

fiambite   knoblock

our plans could be easily described in datalog  for example  the possibly adjacent interpreted predicate of figure   could be described declaratively as a datalog program instead of
a piece of code  in summary  rule match for moderately sized rules  even for quite expressive
languages and large plans  remains tractable and can be made efficient using production
match  forgy        and query optimization techniques  sellis        
the second source of complexity is computing the embeddings of the replacement plan
given in the consequent of a plan rewriting rule  by the definition of full specification rules 
the embedding is completely specified in the rule itself  thus  it suffices simply to remove
the undesired subplan and directly add the replacement subplan  this is linear in the size
of the consequent 
for partial specification rules  computing all the embeddings of the replacement subplan
can be exponential in the size of the plan in the worst case  however  this occurs only in
pathological cases  for example  consider the plan in figure    a  in which we are going to
compute the embeddings of step x into the remainder of the plan in order to satisfy the open
precondition g   step x has no preconditions and has two effects b and g   each step in
the plan has proposition b as an effect  therefore  the new step x conflicts with every step
in the plan    to n  and has to be ordered with respect to these steps  unfortunately  there
are an exponential number of orderings  in effect  the orderings imposed by adding the step
x correspond to all the partitions of the set of steps    to n  into two sets  one ordered
before x and one after  figure    b  shows one of the possible orderings  if the subplan we
were embedding contained several steps that contained similar conflicts the problem would
be compounded  even deciding if a single embedding exists is np hard  for example  if
we add two additional effects a and g  to operator x  there is no valid embedding  in
the worst case  solving first the flaws induced by the conflicts on proposition b  we have to
explore an exponential number of positions for step x in the plan  all of which end up in
failure  nevertheless  given the quasi decomposability of useful planning domains we expect
the number of conflicts to be relatively small  also most of the useful rewriting rules specify
replacement subplans that are small compared with the plan they are embedding into  our
experience indicates that plan rewriting with partial specification rules can be performed
efficiently as shown by the results of section   
b

b

 

 

g 

a

a

b

g 
b

 

 

g 
g 
b

a

 

g

 

g 

a
b

x

g

g 

x

g 

a

n

gn

gn

a

b

n

 a  before embedding

b

 b  one possible embedding

figure     exponential embeddings

   

fiplanning by rewriting

      a taxonomy of plan rewriting rules
in order to guide the user in defining plan rewriting rules for a domain or to help in designing
algorithms that may automatically deduce the rules from the domain specification  see
section     it is helpful to know what kinds of rules are useful  we have identified the
following general types of transformation rules 
reorder  these are rules based on algebraic properties of the operators  such as commutative  associative and distributive laws  for example  the commutative rule that reorders
two operators that need the same resource in figure     or the join swap rule in figure   
that combines the commutative and associative properties of the relational algebra 
collapse  these are rules that replace a subplan by a smaller subplan  for example  when
several operators can be replaced by one  as in the remote join eval rule in figure    
this rule replaces two remote retrievals at the same information source and a local join
operation by a single remote join operation  when the remote source has the capability of
performing joins  an example of the application of this rule to a query plan is shown in
figure     other examples are the blocks world rules in figure   that replace an unstack
and a stack operators either by an equivalent single stack operator or the empty plan 
expand  these are rules that replace a subplan by a bigger subplan  although this may
appear counter intuitive initially  it is easy to imagine a situation in which an expensive
operator can be replaced by a set of operators that are cheaper as a whole  an interesting
case is when some of these operators are already present in the plan and can be synergistically reused  we did not find this rule type in the domains analyzed so far  but backstrom
     a  presents a framework in which adding actions improves the quality of the plans 
his quality metric is the plan execution time  similarly to the manufacturing domain of section      figure    shows an example of a planning domain where adding actions improves
quality  from backstrom      a   in this example  removing the link between bm and c 
and inserting a new action a shortens significantly the time to execute the plan 
p

rn 

r 

r 
a

c 

c 
r 
a
p

p

q 

qm

b 

rn
cn

p

rn
cn

p
q 

rn 

r 

r 
a

b 

bm

bm qm

qm 

qm 

 a  low quality plan

 b  high quality plan

figure     adding actions can improve quality
parallelize  these are rules that replace a subplan with an equivalent alternative subplan
that requires fewer ordering constraints  a typical case is when there are redundant or alternative resources that the operators can use  for example  the rule punch by drill press
in figure    another example is the rule that figure    suggests that could be seen as a
combination of the expand and parallelize types 
   

fiambite   knoblock

    selection of next plan  search strategies
although the space of rewritings can be explored systematically  the planning by rewriting
framework is better suited to the local search techniques typical of combinatorial optimization algorithms  the characteristics of the planning domain  the initial plan generator  and
the rewriting rules determine which local search method performs best  first  we discuss
how the initial plan generator affects the choice of local search methods  second  we consider the impact of the rewriting rules  third  we discuss the role of domain knowledge in
the search process  finally  we describe how several local search methods work in pbr 
an important difference between pbr and traditional combinatorial algorithms is the
generation of feasible solutions  usually  in combinatorial optimization problems there exists
an effective procedure to generate all feasible solutions  e g   the permutations of a schedule  
thus  even if the local search graph is disconnected  by choosing an appropriate initial
solution generator  e g   random  we could fall in a component of the graph that contains
the global optimum  in pbr we cannot assume such powerful initial plan generators  even
in optimization domains  which have efficient initial plan generators  we may not have
guarantees on the coverage of the solution space they provide  therefore  the optimal plan
may not be reachable by applying the rewriting rules when starting from the initial plans
available from the generator  nevertheless  for many domains an initial plan generator that
provides a good sample of the solution space is sufficient for multiple restart search methods
to escape from low quality local minima and provide high quality solutions 
the plan rewriting rules define the neighborhood function  which may be exact  cf 
section      or not  for example  in the query planning domain we can define a set of
rules that completely generate the space of solution plans  because of the properties of the
relational algebra   in other domains it may be hard to prove that we have an exact set of
rules  both the limitations on initial plan generation and the plan rewriting rules affect the
possibility of theoretically reaching the global optimum  this is not surprising since many
problems  regardless of whether they are cast as planning or in other formalisms  do not have
converging local search algorithms  e g   papadimitriou   steiglitz         nevertheless  in
practice  good local optima can still be obtained for many domains 
many local search methods  such as first and best improvement  simulated annealing 
tabu search  or variable depth search  can be applied straightforwardly to pbr  in our
experiments in section   we have used first and best improvement  which have performed
well  next  we describe some details of the application of these two methods in pbr  in
section    we discuss our ideas for using variable depth plan rewriting 
first improvement generates the rewritings incrementally and selects the first plan of
better cost than the current one  in order to implement this method efficiently we can use a
tuple at a time evaluation of the rule antecedent  similarly to the behavior of prolog  then 
for that rule instantiation  generate one embedding  test the cost of the resulting plan  and
if it is not better that the current plan  repeat  we have the choice of generating another
embedding of the same rule instantiation  generate another instantiation of the same rule 
or generate a match for a different rule 
best improvement generates the complete set of rewritten plans and selects the best 
this method requires computing all matches and all embeddings for each match  all the
matches can be obtained by evaluating the rule antecedent as a set at a time database
   

fiplanning by rewriting

query  as we discussed in section       such query evaluation can be quite efficient  in our
experience  computing the plan embeddings was usually more expensive than computing
the rule matches 
in planning by rewriting the choice of the initial plan generator  the rewriting rules 
and the search methods is intertwined  once the initial plan generator is fixed  it determines
the shape of the plans that would have to be modified by the rewriting rules  then according
to this neighborhood  the most appropriate search mechanism can be chosen  pbr has a
modular design to facilitate experimentation with different initial plan generators  sets of
rewriting rules  and search strategies 
    plan quality
in most practical planning domains the quality of the plans is crucial  this is one of the
motivations for the planning by rewriting approach  in pbr the user defines the measure
of plan quality most appropriate for the application domain  this quality metric could
range from a simple domain independent cost metric  such as the number of steps  to more
complex domain specific ones  for example  in the query planning domain the measure of
plan quality usually is an estimation of the query execution cost based on the size of the
database relations  the data manipulation operations involved in answering a query  and
the cost of network transfer  in a decentralized environment  the cost metric may involve
actual monetary costs if some of the information sources require payments  in the jobshop scheduling domain some simple cost functions are the schedule length  that is  the
parallel time to finish all pieces   or the sum of the times to finish each piece  a more
sophisticated manufacturing domain may include a variety of concerns such as the cost 
reliability  and precision of each operator process  the costs of resources and materials used
by the operators  the utilization of the machines  etc  the reader will find more detailed
examples of quality metrics in these domains in sections     and     
a significant advantage of pbr is that the complete plan is available to assess its quality 
in generative planners the complete plan is not available until the search for a solution is
completed  so usually only very simple plan quality metrics  such as the number of steps 
can be used  some work does incorporate quality concerns into generative planners  estlin
  mooney        borrajo   veloso        perez         these systems automatically
learn search control rules to improve both the efficiency of planning and the quality of the
resulting plans  in pbr the rewriting rules can be seen as post facto optimization search
control  as opposed to guiding the search of a generative planner towards high quality
solutions based only on the information available in partial plans  pbr improves the quality
of complete solution plans without any restriction on the types of quality metrics  moreover 
if the plan cost is not additive  a plan refinement strategy is impractical since it may need
to exhaustively explore the search space to find the optimal plan  an example of nonadditive cost function appears in the unix planning domain  etzioni   weld        where
a plan to transfer files between two machines may be cheaper if the files are compressed
initially  and uncompressed after arrival   that is  the plan that includes the compression
 and the necessary uncompression  operations is more cost effective  but a plan refinement
search would not naturally lead to it  by using complete plans  pbr can accurately assess
arbitrary measures of quality 
   

fiambite   knoblock

    initial plan generation
fast initial plan generation is domain specific in nature  it requires the user to specify an
efficient mechanism to compute the initial solution plan  in general  generating an initial
plan may be as hard as generating the optimal plan  however  the crucial intuition behind
planning algorithms is that most practical problems are quasi decomposable  simon        
that is  that the interactions among parts of the problems are limited  if interactions in a
problem are pervasive  such as in the   puzzle  the operator based representation and the algorithms of classical planning are of little use  they would behave as any other search based
problem solver  fortunately  many practical problems are indeed quasi decomposable  this
same intuition also suggests that finding initial plan generators for planning problems may
not be as hard as it appears  because the system can solve the subproblems independently 
and then combine them in the simplest way  for example  concatenating the solutions sequentially  moreover  in many circumstances the problems may be easily transformed into a
state that minimizes the interactions and solving the problem from this state is much easier 
for example  in the blocks world the state in which all blocks are on the table minimizes
the interactions  it is simple to design an algorithm that solves any blocks world problem
passing through such intermediate state  using these methods an initial plan generator may
produce suboptimal initial plans but at a reasonable planning cost 
these ideas for constructing initial plan generators can be embodied in two general ways 
which are both implemented in our system  the first one is to bootstrap on the results of
a general purpose planning algorithm with a strong search control bias  the second one is
to provide the user convenient high level facilities in which to describe plan construction
algorithms programmatically 
      biased generative planners
there are a variety of ways in which to control the search of a generic planner  some planners
accept search control rules  others accept heuristic functions  and some have built in search
control  we present examples of these techniques 
a very general way of efficiently constructing plans is to use a domain independent
generative planner that accepts search control rules  for example  prodigy  carbonell 
knoblock    minton         ucpop  penberthy   weld        and sage  knoblock       
are such planners  by setting the type of search and providing a strong bias by means of the
search control rules  the planner can quickly generate a valid  although possibly suboptimal 
initial plan  for example  in the manufacturing domain of  minton      a   analyzed in
detail in section      depth first search and a goal selection heuristic based on abstraction
hierarchies  knoblock      a  quickly generates a feasible plan  but often the quality of this
plan  which is defined as the time required to manufacture all objects  is suboptimal 
tlplan  bacchus   kabanza              is an efficient forward chaining planner that
uses search control expressed in temporal logic  because in forward chaining the complete
state is available  much more refined domain control knowledge can be specified  the
preferred search strategy used by tlplan is depth first search  so although it finds plans
efficiently  the plans may be of low quality  note that because it is a generative planner
that explores partial sequences of steps  it cannot use sophisticated quality measures 
   

fiplanning by rewriting

hsp  bonet  loerincs    geffner        bonet   geffner        is a forward search
planner that performs a variation of heuristic search applied to classical ai planning  the
built in heuristic function is a relaxed version of the planning problem  it computes the
number of required steps to reach the goal disregarding negated effects in the operators 
such metric can be computed efficiently  despite its simplicity and that the heuristic is not
admissible  it scales surprisingly well for many domains  because the plans are generated
according to the fixed heuristic function  the planner cannot incorporate a quality metric 
these types of planners are quite efficient in practice although they often produce suboptimal plans  they are excellent candidates to generate the initial plans that will be
subsequently optimized by pbr 
      facilitating algorithmic plan construction
for many domains  simple domain dependent approximation algorithms will provide good
initial plans  for example  in the query planning domain  the system can easily generate
initial query evaluation plans by randomly  or greedily  parsing the given query  in the
blocks world it is also straightforward to generate a solution in linear time using the naive
algorithm  put all blocks on the table and build the desired towers from the bottom up 
this algorithm produces plans of length no worse than twice the optimal  which makes it
already a good approximation algorithm  however  the interest in the blocks world has
traditionally been on optimal solutions  which is an np hard problem  gupta   nau        
our system facilitates the creation of these initial plans by freeing the user from specifying the detailed graph structure of a plan  the user only needs to specify an algorithm
that produces a sequence of instantiated actions  that is  action names and the ground
parameters that each action takes    for example  the  user defined  naive algorithm for
the blocks world domain described above applied to the problem in figure   produces
the sequence  unstack c a   unstack b d   stack c d table   stack b c table   and
stack a b table   then  the system automatically converts this sequence of actions into
a fully detailed partial order plan using the operator specification of the domain  the resulting plan conforms to the internal data structures that pbr uses  this process includes
creating nodes that are fully detailed operators with preconditions and effects  and adding
edges that represent all the necessary causal links and ordering constraints  in our blocks
world example the resulting plan is that of figure   
the algorithm that transforms the user defined sequence of actions into a partial order
plan is presented in figure     the algorithm first constructs the causal structure of the plan
 lines   to    and then adds the necessary ordering links to avoid threats  lines   to     
the user only needs to specify action names and the corresponding instantiated action
parameters  our algorithm consults the operator specification to find the preconditions
and effects  instantiate them  construct the causal links  and check for operator threats 
operator threats are always resolved in favor of the ordering given by the user in the input
plan  the reason is that the input plan may be overconstrained by the total order  but it
is assumed valid  therefore  by processing each step last to first  only the orderings that
indeed avoid threats are included in the partial order plan 
    the algorithm also accepts extra ordering constraints in addition to the sequence if they are available
from the initial plan generator 

   

fiambite   knoblock

procedure to po
input  a valid total order plan  a         an  
output  an equivalent partial order plan
   for i    n to  
  
for p  preconditions ai  
  
choose k   i such that
  
   p  positiveeffects ak   
  
      l such that k   l   i  p  negativeeffects al  
  
add order ak  ai
  
for p  negativeeffects ai  
  
for j     i     to  
  
if p  preconditions aj  
   
then add order aj  ai
    return   a         an     
figure     algorithm for converting total order to partial order plans
our algorithm is an extension of the greedy algorithm presented by veloso  perez    carbonell         our algorithm explores non deterministically all the producers of a proposition  line     as opposed to taking the latest producer in the sequence as in their algorithm   
that is  if our algorithm is explored exhaustively  it produces all partially ordered causal
structures consistent with the input sequence  our generalization stems from the criticism
by backstrom      b  to the algorithm by veloso et al         and our desire of being able
to produce alternative initial plans 
the problem of transforming a sequence of steps into a least constrained plan is analyzed
by backstrom      b  under several natural definitions of optimality  under his definitions
of least constrained plan and shortest parallel execution the problem is np hard  backstrom
shows that velosos algorithm  although polynomial  does not conform to any of these natural definitions  because our algorithm is not greedy  it does not suffer from the drawbacks
pointed out by backstrom  moreover  for our purposes we do not need optimal initial plans 
the space of partial orders will be explored during the rewriting process 
regardless of the method for producing initial plans  generators that provide multiple
plans are preferable  the different initial plans are used in conjunction with multiple restart
search techniques in order to escape from low quality local minima 

   empirical results
in this section we show the broad applicability of planning by rewriting by analyzing four
domains with different characteristics  a process manufacturing domain  minton      b  
a transportation logistics domain  the blocks world domain that we used in the examples
throughout the paper  and a domain for distributed query planning 
    to implement their algorithm it is enough to replace line   in figure    with 
find max k   i such that

   

fiplanning by rewriting

    manufacturing process planning
the task in the manufacturing process planning domain is to find a plan to manufacture
a set of parts  we implemented a pbr translation of the domain specification in  minton 
    b   this domain contains a variety of machines  such as a lathe  punch  spray painter 
welder  etc  for a total of ten machining operations  the operator specification is shown in
figures    and     the features of each part are described by a set of predicates  such as
temperature  painted  has hole  etc  these features are changed by the operators  other
predicates in the state  such as has clamp  is drillable  etc  are set in the initial state
of each problem 
as an example of the behavior of an operator  consider the polish operator in figure    
it requires the part to manufacture to be cold and that the polisher has a clamp to secure
the part to the machine  the effect of applying this operator is to leave the surface of the
part polished  some attributes of a part  such as surface condition  are single valued 
but others  like has hole  are multivalued  note how the drill press and the punch
operators in figure    do not prevent several has hole conditions from being asserted on
the same part  other interesting operators are weld and bolt  these operators join two
parts in a particular orientation to form a new part  no further operations can be performed
on the separate parts once they have been joined 
the measure of plan cost is the schedule length  the  parallel  time to manufacture all
parts  in this domain all of the machining operations are assumed to take unit time  the
machines and the objects  parts  are modeled as resources in order to enforce that only one
part can be placed on a machine at a time and that a machine can only operate on a single
part at a time  except bolt and weld which operate on two parts simultaneously  
we have already shown some of the types of rewriting rules for this domain in figures  
and     the set of rules that we used for our experiments is shown in figure     the top
eight rules are quite straightforward once one becomes familiar with this domain  the two
top rules explore the space of alternative orderings originated by resource conflicts  the
machine swap rule allows the system to explore the possible orderings of operations that
require the same machine  this rule finds two consecutive operations on the same machine
and swaps their order  similarly  the rule object swap allows the system to explore the
orderings of the operations on the same object  these two rules use the interpreted predicate
adjacent in critical path to focus the attention on the steps that contribute to our cost
function  adjacent in critical path checks if two steps are consecutive along one of the
critical paths of a schedule  a critical path is a sequence of steps that take the longest
time to accomplish  in other words  a critical path is one of the sequences of steps that
determine the schedule length 
the next six rules exchange operators that are equivalent with respect to achieving
some effects  rules ip by sp and sp by ip propose the exchange of immersion paint
and spray paint operators  by examining the operator definitions in figure     it can be
readily noticed that both operators change the value of the painted predicate  similarly 
pu by dp and dp by pu exchange drill press and punch operators  which produce the
has hole predicate  finally  roll by lathe and lathe by roll exchange roll and lathe
operators as they both can make parts cylindrical  to focus the search on the most promising
   

fiambite   knoblock

 define  operator polish 
 parameters   x 
 resources   machine polisher   is object  x  
 precondition   and  is object  x 
 temperature  x cold 
 has clamp polisher  
 effect
  and   forall   surf 
  when   neq  surf polished 
  not  surface condition  x  surf   
 surface condition  x polished   

 define  operator grind 
 parameters   x 
 resources   machine grinder   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   surf 
  when   neq  surf smooth 
  not  surface condition  x  surf    
 surface condition  x smooth   

 define  operator lathe 
 parameters   x 
 resources   machine lathe   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   shape 
  when   neq  shape cylindrical 
  not  shape  x  shape    
  forall   surf 
  when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 shape  x cylindrical   

 define  operator roll 
 parameters   x 
 resources   machine roller   is object  x  
 precondition  is object  x 
 effect
  and   forall   color 
  not  painted  x  color   
  forall   shape 
  when   neq  shape cylindrical 
  not  shape  x  shape    
  forall   temp 
  when   neq  temp hot 
  not  temperature  x  temp    
  forall   surf 
  not  surface condition  x  surf   
  forall   width  orientation 
  not  has hole  x  width  orientation   
 temperature  x hot 
 shape  x cylindrical   

 define  operator drill press 
 parameters   x  width  orientation 
 resources   machine drill press 
 is object  x  
 precondition
  and  is object  x 
 have bit  width 
 is drillable  x  orientation  
 effect  has hole  x  width  orientation  

 define  operator punch 
 parameters   x  width  orientation 
 resources   machine punch   is object  x  
 precondition
  and  is object  x 
 has clamp punch 
 is punchable  x  width  orientation  
 effect
  and   forall   surf 
  when   neq  surf rough 
  not  surface condition  x  surf    
 surface condition  x rough 
 has hole  x  width  orientation   

figure     operators for manufacturing process planning  i 

exchanges these rules only match operators in the critical path  by means of the interpreted
predicate in critical path  
the six bottom rules in figure    are more sophisticated  the lathe sp by sp rule
takes care of an undesirable effect of the simple depth first search used by our initial plan
generator  in this domain  in order to spray paint a part  the part must have a regular shape 
being cylindrical is a regular shape  therefore the initial planner may decide to make the
part cylindrical by lathing it in order to paint it  however  this may not be necessary as the
part may already have a regular shape  for example  it could be rectangular  which is also
a regular shape   thus  the lathe sp by sp substitutes the pair spray paint and lathe
by a single spray paint operation  the supporting regular shapes interpreted predicate
   

fiplanning by rewriting

 define  operator immersion paint 
 parameters   x  color 
 resources   machine immersion painter 
 is object  x  
 precondition
  and  is object  x 
 have paint for immersion  color  
 effect  painted  x  color  

 define  operator spray paint 
 parameters   x  color  shape 
 resources   machine spray painter 
 is object  x  
 precondition   and  is object  x 
 sprayable  color 
 temperature  x cold 
 regular shape  shape 
 shape  x  shape 
 has clamp spray painter  
 effect  painted  x  color  

 define  operator bolt 
 define  operator weld 
 parameters   x  y  new obj  orient  width 
 parameters   x  y  new obj  orient 
 resources   machine bolter 
 resources   machine welder 
 is object  x   is object  y  
 is object  x   is object  y  
 precondition
 precondition
  and  is object  x   is object  y 
  and  is object  x   is object  y 
 composite object  new obj  orient  x  y 
 composite object  new obj  orient  x  y 
 has hole  x  width  orient 
 can be welded  x  y  orient  
 has hole  y  width  orient 
 effect   and  temperature  new obj hot 
 bolt width  width 
 joined  x  y  orient 
 can be bolted  x  y  orient  
  not  is object  x  
 effect   and   not  is object  x  
  not  is object  y    
  not  is object  y  
 joined  x  y  orient   

figure     operators for manufacturing process planning  ii 

just enumerates which are the regular shapes  these rules are partially specified and are
not guaranteed to always produce a rewriting  nevertheless  they are often successful in
producing plans of lower cost 
the remaining rules explore bolting two parts using bolts of different size if fewer operations may be needed for the plan  we developed these rules by analyzing differences
in the quality of the optimal plans and the rewritten plans  for example  consider the
both providers diff bolt rule  this rule states that if the parts to be bolted already
have compatible holes in them  it is better to reuse those operators that produced the
holes  the initial plan generator may have drilled  or punched  holes whose only purpose
was to bolt the parts  however  the goal of the problem may already require some holes to
be performed on the parts to be joined  reusing the available holes produces a more economical plan  the rules has hole x diff bolt add pu  has hole x diff bolt add dp 
has hole y diff bolt add pu  and has hole y diff bolt add dp address the cases in
which only one of the holes can be reused  and thus an additional punch or drill press
operation needs to be added 
as an illustration of the rewriting process in the manufacturing domain  consider figure     the plan at the top of the figure is the result of a simple initial plan generator that
solves each part independently and concatenates the corresponding subplans  although
such plan is generated efficiently  it is of poor quality  it requires six time steps to manufacture all parts  the figure shows the application of two rewriting rules  machine swap and
ip by sp  that improve the quality of this plan  the operators matched by the rule antecedent are shown in italics  the operators introduced in the rule consequent are shown in
bold  first  the machine swap rule reorders the punching operations on parts a and b  this
   

fiambite   knoblock

 define rule  name machine swap
 if   operators    n   machine  x   resource 
  n   machine  x   resource  
 links    n   threat  n   
 constraints
 adjacent in critical path  n   n   
 replace   links   n   n   
 with   links   n   n    

 define rule  name object swap
 if   operators    n   is object  x   resource 
  n   is object  x   resource  
 links    n   threat  n   
 constraints
 adjacent in critical path  n   n   
 replace   links   n   n   
 with   links   n   n    

 define rule  name sp by ip
 define rule  name ip by sp
 if   operators   n   spray paint  x  c  s  
 if   operators   n   immersion paint  x  c  
 constraints   in critical path  n    
 constraints   regular shapes  s 
 replace   operators   n   
 in critical path  n    
 with   operators   n   immersion paint  x  c    
 replace   operators   n   
 with   operators   n   spray paint  x  c  s    
 define rule  name dp by pu
 define rule  name pu by dp
 if   operators    n   drill press  x  w  o   
 if   operators   n   punch  x  w  o  
 constraints   in critical path  n    
 constraints   in critical path  n    
 replace   operators   n   
 replace   operators   n   
 with   operators   n   punch  x  w  o    
 with   operators   n   drill press  x  w  o    
 define rule  name roll by lathe
 if   operators    n   roll  x   
 constraints   in critical path  n    
 replace   operators   n   
 with   operators   n   lathe  x    

 define rule  name lathe by roll
 if   operators    n   lathe  x   
 constraints   in critical path  n    
 replace   operators   n   
 with   operators   n   roll  x    

 define rule  name both providers diff bolt
 define rule  name lathe sp by sp
 if   operators    n   bolt  x  y  z  o  w    
 if   operators
 links    n   has hole  x  w   o   n  
   n   lathe  x  
  n   has hole  y  w   o   n  
  n   spray paint  x  color  shape    
  n   has hole  x  w   o   n  
 constraints   regular shapes  shape    
  n   has hole  y  w   o   n   
 replace   operators   n   n   
 constraints    neq  w   w    
 with   operators
   n   spray paint  x  color  shape        replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
 define rule  name has hole x diff bolt add dp
 define rule  name has hole x diff bolt add pu
 if   operators    n   bolt  x  y  z  o  w    
 if   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  x  w   o   n   
  n   has hole  x  w   o   n   
 constraints    neq  w   w    
 constraints    neq  w   w    
 replace   operators   n   n   n   
 replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w   
 with   operators    n   bolt  x  y  z  o  w   
  n   drill press  y  w   o   
  n   punch  y  w   o   
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
  n   has hole  y  w   o   n     
 define rule  name has hole y diff bolt add dp
 define rule  name has hole y diff bolt add pu
 if   operators    n   bolt  x  y  z  o  w    
 if   operators    n   bolt  x  y  z  o  w    
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n  
  n   has hole  y  w   o   n   
  n   has hole  y  w   o   n   
 constraints    neq  w   w    
 constraints    neq  w   w    
 replace   operators   n   n   n   
 replace   operators   n   n   n   
 with   operators    n   bolt  x  y  z  o  w   
 with   operators    n   bolt  x  y  z  o  w   
  n   drill press  x  w   o   
  n   punch  x  w   o   
 links    n   has hole  x  w   o   n  
 links    n   has hole  x  w   o   n  
  n   has hole  y  w   o   n     
  n   has hole  y  w   o   n     

figure     rewriting rules for manufacturing process planning
   

fiplanning by rewriting

lathe a

ipaint a red

punch a  

punch c  

ipaint c blue

roll b

ipaint b red

reorder parts on a machine
lathe a

ipaint a red
punch c  

cost   

punch a  

cost   

ipaint c blue

ipaint b red

roll b

immersion paint    spray paint
lathe a
roll b

ipaint a red

punch a  

punch c  

ipaint c blue

cost   

spray paint b red

figure     rewriting in the manufacturing domain
breaks the long critical path that resulted from the simple concatenation of their respective
subplans  the schedule length improves from six to four time steps  still  the three parts
a  b  and c use the same painting operation  immersion paint   as the immersion painter
can only process one piece at a time  the three operations must be done serially  fortunately  in our domain there is another painting operation  spray paint  the ip by sp
rule takes advantage of this fact and substitutes an immersion paint operation on part b
by a spray paint operation  this further parallelizes the plan obtaining a schedule length
of three time steps  which is the optimal for this plan 
we compare four planners  ipp  initial  and two configurations of pbr  
ipp  this is one of the most efficient domain independent planners  koehler  nebel  hoffman    dimopoulos        in the planning competition held at the fourth international
conference on artificial intelligence planning systems  aips      ipp is an optimized reimplementation and extension of graphplan  blum   furst               ipp produces
shortest parallel plans  for our manufacturing domain  this is exactly the schedule length 
the cost function that we are optimizing 
initial  the initial plan generator uses a divide and conquer heuristic in order to generate
plans as fast as possible  first  it produces subplans for each part and for the joined goals
independently  these subplans are generated by sage using a depth first search without any
regard to plan cost  then  it concatenates the subsequences of actions and merges them
using the facilities of section       
pbr  we present results for two configurations of pbr  which we will refer to as pbr    
and pbr      both configurations use a first improvement gradient search strategy with
random walk on the cost plateaus  the rewriting rules used are those of figure     for each
problem pbr starts its search from the plan generated by initial  the two configurations
differ only on how many total plateau plans are allowed  pbr     allows considering up
to     plans that do not improve the cost without terminating the search  similarly  pbr   

fiambite   knoblock

    allows     plateau plans  note that the limit is across all plateaus encountered during
the search for a problem  not for each plateau 
we tested each of the four systems on     problems  for machining    parts  ranging
from   to    goals  the goals are distributed randomly over the    parts  so  for the   goal problems  there is an average of   goals per part  the results are shown in figure    
in these graphs each data point is the average of    problems for each given number of goals 
there were    provably unsolvable problems  initial and pbr solved all     problems  or
proved them unsolvable   ipp solved    problems in total  all problems at   and    goals 
   at    goals  and   at    goals  ipp could not solve any problem with more than    goals
under the      cpu seconds time limit 
figure    a  shows the average time on the solvable problems for each problem set for
the four planners  figure    b  shows the average schedule length for the problems solved
by all the planners  that is  over the    problems solved by ipp up to    goals  the
fastest planner is initial  but it produces plans with a cost of about twice the optimal  ipp
produces the optimal plans  but it cannot solve problems of more than    goals  the two
configurations of pbr scale much better than ipp solving all problems and producing good
quality plans  pbr     matches the optimal cost of the ipp plans  except in one problem
 the reason for the difference is interesting and we explain it below   the faster pbr    
also stays very close to the optimal  less than      average cost difference  
figure    c  shows the average schedule length for the problems solved by each of
the planners for the    goal range  the pbr configurations scale gracefully across this
range improving considerably the cost of the plans generated by initial  the additional
exploration of pbr     allows it to improve the plans even further  the reason for the
difference between pbr and ipp at the    goal complexity level is because the cost results
for ipp are only for the   problems that it could solve  while the results for pbr and initial
are the average of all of the    problems  as shown in figure    b   pbr matches the cost
of these   optimal plans produced by ipp  
figure    d  shows the average number of operators in the plans for the problems solved
by all three planners  up to    goals   figure    e  shows the average number of operators
in the plans for the problems solved by each planner across the whole range of    problems 
the plans generated by initial use about     additional operators  both pbr and ipp
produce plans that require fewer steps  interestingly  ipp sometimes produces plans that
use more operations than pbr  ipp produces the shortest parallel plan  but not the one
with the minimum number of steps  in particular  we observed that some of the ipp plans
suffer from the same problem as initial  ipp would also lathe a part in order to paint
it  but as opposed to initial it would only do so if it did not affect the optimal schedule
length  surprisingly  adding such additional steps in this domain may improve the schedule
length  albeit in fairly rare situations  this was the case in the only problem in which ipp
produced a better schedule than pbr      we could have introduced a rewriting rule that
substituted an immersion paint operator by both a lathe and spray paint operators
for such cases  however  such rule is of very low utility  in the sense of minton      b  
it expands the rewriting search space  adds to the cost of match  and during the random
search provides some benefit very rarely 
   

fiplanning by rewriting

average planning time  cpu seconds 

    
pbr fi
initial
ipp

   

  

 

   

    
 

  

  

  

  
  
  
  
number of blocks

  

  

   

 a  average planning time
  

average plan cost  schedule length 

average plan cost  schedule length 

 
pbr    
pbr    
initial
ipp

 
 
 
 
 
 
 

 b 

 

 

  
  
  
number of goals

  

  

  
  
  
  
  
 

  

 

average plan cost
 problems solved by all 

 c 

  

  

  

  
  
  
  
number of goals

  

  

  

average plan cost
 problems solved by each 

  

  

pbr    
pbr    
initial
ipp

  

average number of plan operators

average number of plan operators

pbr    
pbr    
initial
ipp

 
 

  
  
  
  
  
 
 
 

  
  
  
  
  

pbr    
pbr    
initial
ipp

  
  
  
  
  
 

 

 d 

  

 

 

  
  
  
number of goals

  

  

  

 

number of plan operators
 problems solved by all 

 e 

  

  

  
  
  
  
number of goals

number of plan operators
 problems solved by each 

figure     experimental results  manufacturing process planning

   

  

  

  

fiambite   knoblock

this experiment illustrates the flexibility of pbr in specifying complex rules for a planning domain  the results show the benefits of finding a suboptimal initial plan quickly and
then efficiently transforming it to improve its quality 
    logistics
the task in the logistics domain is to transport several packages from their initial location to
their desired destinations  we used a version of the logistics strips planning domain of
the aips   planning competition which we restricted to using only trucks but not planes   
the domain is shown in figure     a package is transported from one location to another
by loading it into a truck  driving the truck to the destination  and unloading the truck  a
truck can load any number of packages  the cost function is the  parallel  time to deliver
all packages  measured as the number of operators in the critical path of a plan  
 define  operator load truck 
 parameters   obj  truck  loc 
 precondition
  and  obj  obj   truck  truck   location  loc 
 at  truck  loc   at  obj  loc  
 effect   and   not  at  obj  loc  
 in  obj  truck   

 define  operator unload truck 
 parameters   obj  truck  loc 
 precondition
  and  obj  obj   truck  truck   location  loc 
 at  truck  loc   in  obj  truck  
 effect   and   not  in  obj  truck  
 at  obj  loc   

 define  operator drive truck 
 parameters   truck  loc from  loc to  city 
 precondition   and  truck  truck   location  loc from   location  loc to   city  city 
 at  truck  loc from   in city  loc from  city   in city  loc to  city  
 effect   and   not  at  truck  loc from    at  truck  loc to   

figure     operators for logistics
we compare three planners on this domain 
ipp 

ipp  koehler et al         produces optimal plans in this domain 

initial  the initial plan generator picks a distinguished location and delivers packages
one by one starting and returning to the distinguished location  for example  assume that
truck t  is at the distinguished location l   and package p  must be delivered from location
l  to location l   the plan would be  drive truck t  l  l  c   load truck p  t  l   
drive truck t  l  l  c   unload truck p  t  l    drive truck t  l  l  c   the
initial plan generator would keep producing these circular trips for the remaining packages 
although this algorithm is very efficient it produces plans of very low quality 
pbr  pbr starts from the plan produced by initial and uses the plan rewriting rules shown
in figure    to optimize plan quality  the loop rule states that driving to a location and
returning back immediately after is useless  the fact that the operators must be adjacent
is important because it implies that no intervening load or unload was performed  in
the same vein  the triangle rule states that it is better to drive directly between two
locations than through a third point if no other operation is performed at such point  the
    in the logistics domain of aips    the problems of moving packages by plane among different cities and
by truck among different locations in a city are isomorphic  so we focused on only one of them to better
analyze how the rewriting rules can be learned  ambite  knoblock    minton        

   

fiplanning by rewriting

load earlier rule captures the situation in which a package is not loaded in the truck the
first time that the packages location is visited  this occurs when the initial planner was
concerned with a trip for another package  the unload later rule captures the dual case 
pbr applies a first improvement search strategy with only one run  no restarts  
 define rule  name loop
 if   operators
   n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
 links    n   n   
 constraints
  adjacent in critical path  n   n    
 replace   operators   n   n   
 with nil 

 define rule  name triangle
 if   operators
   n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
 links    n   n   
 constraints
  adjacent in critical path  n   n    
 replace   operators   n   n   
 with   operators
   n   drive truck  t  l   l   c     

 define rule  name unload later
 define rule  name load earlier
 if   operators
 if   operators
   n   drive truck  t  l   l   c  
   n   drive truck  t  l   l   c  
  n   unload truck  p  t  l   
  n   drive truck  t  l   l   c  
  n   drive truck  t  l   l   c   
  n   load truck  p  t  l    
 links    n   n   
 links    n   n   
 constraints
 constraints
  adjacent in critical path  n   n  
  adjacent in critical path  n   n  
 before  n   n    
 before  n   n    
 replace   operators   n   
 replace   operators   n   
 with   operators    n   unload truck  p  t  l    
 with   operators    n   load truck  p  t  l    
 links    n   n     
 links    n   n     

figure     logistics rewriting rules

   

pbr
initial
ipp

    

pbr
initial
ipp

   

average plan cost

average planning time  cpu seconds 

     

   
  
 

   

   

  

   
    

 
 

 

  

              
number of packages

  

  

  

 

 a  average planning time

 

  

  

  
  
  
  
number of packages

  

  

  

 b  average plan cost

figure     experimental results  logistics  scaling the number of packages
we compared the performance of ipp  initial  and pbr on a set of logistics problems
involving up to    packages  each problem instance has the same number of packages 
locations  and goals  there was a single truck and a single city  the performance results
are shown in figure     in these graphs each data point is the average of    problems for
each given number of packages  all the problems were satisfiable  ipp could only solve
   

fiambite   knoblock

problems up to   packages  it also solved    out of    for   packages  and   out of   
for   packages  but these are not shown in the figure   figure    a  shows the average
planning time  figure    b  shows the average cost for the    packages range  the results
are similar to the previous experiment  initial is efficient but highly suboptimal  pbr is
able to considerably improve the cost of these plans and approach the optimal 
    blocks world
we implemented a classical blocks world domain with the two operators in figure    this
domain has two actions  stack that puts one block on top of another  and  unstack that
places a block on the table to start a new tower  plan quality in this domain is simply
the number of steps  optimal planning in this domain is np hard  gupta   nau        
however  it is trivial to generate a correct  but suboptimal  plan in linear time using the
naive algorithm  put all blocks on the table and build the desired towers from the bottom
up  we compare three planners on this domain 
ipp  in this experiment we used the gam goal ordering heuristic  koehler        koehler
  hoffmann        that had been tested in blocks world problems with good scaling results 
initial  this planner is a programmatic implementation of the naive algorithm using the
facilities introduced in section       
pbr  this configuration of pbr starts from the plan produced by initial and uses the
two plan rewriting rules shown in figure   to optimize plan quality  pbr applies a first
improvement strategy with only one run  no restarts  
we generated random blocks world problems scaling the number of blocks  the problem
set consists of    random problems at                                                  and    
blocks for a total of     problems  the problems may have multiple towers in the initial
state and in the goal state 
figure    a  shows the average planning time of the    problems for each block quantity 
ipp cannot solve problems with more than    blocks within the time limit of      cpu
seconds  the problem solving behavior of ipp was interesting  ipp either solved a given
problem very fast or it timed out  for example  it was able to solve    out of the      block problems under     seconds  but it timed out at      seconds for the remaining   
problems  this seems to be the typical behavior of complete search algorithms  gomes 
selman    kautz         the local search of pbr allows it to scale much better and solve
all the problems 
figure    b  shows the average plan cost as the number of blocks increases  pbr
improves considerably the quality of the initial plans  the optimal quality is only known
for very small problems  where pbr approximates it  but does not achieve it  we ran sage for
problems of less than   blocks   for larger plans we do not know the optimal cost  however 
slaney   thiebaux        performed an extensive experimental analysis of blocks world
planning using a domain like ours  in their comparison among different approximation
algorithms they found that our initial plan generator  unstack stack  achieves empirically a
quality around      the optimal for the range of problem sizes we have analyzed  figure   in
slaney   thiebaux         the value of our average initial plans divided by      suggests
   

fiplanning by rewriting

the quality of the optimal plans  the quality achieved by pbr is comparable with that value 
in fact it is slightly better which may be due to the relatively small number of problems
tested     per block size  or to skew in our random problem generator  interestingly the
plans found by ipp are actually of low quality  this is due to the fact that ipp produces
shortest parallel plans  that means that the plans can be constructed in the fewest time
steps  but ipp may introduce more actions in each time step than are required 
in summary  the experiments in this and the previous sections show that across a variety
of domains pbr scales to large problems while still producing high quality plans 
   

average plan cost  number of operators 

average planning time  cpu seconds 

    
pbr fi
initial
ipp

   

  

 

   

    
 

  

  

  

  
  
  
  
number of blocks

  

  

pbr fi
initial
ipp
initial     

   
   
   
   
  
  
  
  
 

   

 

 a  average planning time

  

  

  

           
number of blocks

  

  

   

 b  average plan cost

figure     experimental results  blocks world  scaling the number of blocks

    query planning
query planning is a problem of considerable practical importance  it is central to traditional
database and mediator systems  in this section we present some results in distributed query
planning to highlight the use of pbr in a domain with a complex cost function  a detailed
description of query planning  including a novel query processing algorithm for mediators
based on pbr  and a more extensive experimental analysis appear in  ambite   knoblock 
      ambite        
query planning involves generating a plan that efficiently computes a user query from
the relevant information sources  this plan is composed of data retrieval actions at distributed information sources and data manipulation operations  such as those of the relational algebra  join  selection  union  etc  the specification of the operators for query
planning and the encoding of information goals that we are using was first introduced by
knoblock         a sample information goal is shown in figure     this goal asks to send
to the output device of the mediator all the names of airports in tunisia  two sample
operators are shown in figure     the retrieve operator executes a query at a remote
information source and transports the data to the mediator  provided that the source is
in operation  source available  and that the source is capable of processing the query
 source acceptable query   the join operator takes two subqueries  which are available
locally at the mediator  and combines them using some conditions to produce the joined
query 
   

fiambite   knoblock

 available sims  retrieve   ap name 
  and  airport  aport 
 country name  aport  tunisia  
 port name  aport  ap name    

figure     sample information goal
 define  operator retrieve 
 parameters   source  query 
 resources   processor  source  
 precondition   and  source available  source 
 source acceptable query  query  source  
 effect  available sims  query  
 define  operator join 
 parameters   join conds  query  query a  query b 
 precondition   and  available sims  query a
 available sims  query b 
 join query  query  join conds  query a  query b  
 effect  available sims  query  

figure     some query planning operators
the quality of a distributed query plan is an estimation of its execution cost  which
is a function of the size of intermediate results  the cost of performing data manipulation
operations  and the transmission through the network of the intermediate results from the
remote sources to the mediator  our system estimates the plan cost based on statistics
obtained from the source relations  such as the number of tuples in a relation  the number
of distinct values for each attribute  and the maximum and minimum values for numeric
attributes  silberschatz  korth    sudarshan        chapter      the sources accessed  and
the type and ordering of the data processing operations are critical to the plan cost 
the rewriting rules are derived from properties of the distributed environment and the
relational algebra    the first set of rules rely on the fact that  in a distributed environment 
it is generally more efficient to execute a group of operations together at a remote information source than to transmit the data over the network and execute the operations at the
local system  as an example consider the remote join eval rule in figure     shown here
in the pbr syntax  it was shown algebraically in figure     this rule specifies that if in
a plan there exist two retrieval operations at the same remote database whose results are
consequently joined and the remote source is capable of performing joins  the system can
rewrite the plan into one that contains a single retrieve operation that pushes the join to
the remote database 
the second class of rules are derived from the commutative  associative  and distributive
properties of the operators of the relational algebra  for example  the join swap rule of
figure     cf  figure    specifies that two consecutive joins operators can be reordered
and allows the planner to explore the space of join trees  since in our query planning
    in mediators  rules that address the resolution of the semantic heterogeneity are also necessary  see
 ambite   knoblock        ambite        for details 

   

fiplanning by rewriting

 define rule  name remote join eval
 define rule  name join swap
 if   operators
 if   operators
   n   retrieve  query   source  
   n   join  q   jc   sq a  sq b  
  n   retrieve  query   source  
  n   join  q   jc   sq a  sq b   
  n   join  query  jc  query   query    
 links   n   n  
 constraints
 constraints
  capability  source join   
 join swappable
 replace   operators   n   n   n   
 q   jc   sq a  sq b
   in
 with   operators
 q   jc   sq a  sq b
   in
   n   retrieve  query  source    
 q   jc   sq a  sq b
   out
 q   jc   sq a  sq b  
   out
 replace   operators   n   n   
 with   operators
   n   join  q   jc   sq a  sq b  
  n   join  q   jc   sq a  sq b   
 links   n   n    

figure     some query planning rewriting rules
domain queries are expressed as complex terms  knoblock         the pbr rules use the
interpreted predicates in the  constraints field to manipulate such query expressions  for
example  the join swappable predicate checks if the queries in the two join operators can
be exchanged and computes the new subqueries 
figure    shows an example of the local search through the space of query plan rewritings in a simple distributed domain that describes a company  the figure shows alternative
query evaluation plans for a conjunctive query that asks for the names of employees  their
salaries  and the projects they are working on  the three relations requested in the query
 employees  payroll  and project  are distributed among two databases  one at the companys headquarters  hq db  and another at a branch  branch db   assume that the
leftmost plan is the initial plan  this plan first retrieves the employee relation at the hq db
and the project relation at the branch db  and then it joins these two tables on the employee name  finally  the plan retrieves the payroll relation from the hq db and joins it
on ssn with the result of the previous join  although a valid plan  this initial plan is suboptimal  applying the join swap rule to this initial plan generates two rewritings  one of
them involves a cross product  which is a very expensive operation  so the system  following a gradient descent search strategy  prefers the other plan  now the system applies the
remote join eval rule and generates a new rewritten plan that evaluates the join between
the employee and project tables remotely at the headquarters database  this final plan is
of much better quality 
we compare the planning efficiency and plan quality of four query planners 
sage  this is the original query planner  knoblock              for the sims mediator 
which performs a best first search with a heuristic commonly used in query optimization
that explores only the space of left join trees  sage is a refinement planner  kambhampati 
knoblock    yang        that generates optimal left tree query plans 
dp  this is our implementation of a dynamic programming bottom up enumeration of
query plans  ono   lohman        to find the optimal plan  since in our distributed
domain subqueries can execute in parallel and the cost function reflects such preference 
   

fiambite   knoblock

a name sal proj     emp name ssn    payroll ssn sal    projects name proj 

hq db
emp name ssn 
payroll ssn sal 

name ssn

branch db
project name proj 

ret emp
  hq db
ret payroll ret project
  hq db   branch db

ssn

name

ret payroll
  hq db

join
swap

name

remote
join
eval
name

ret emp ret project
  hq db   branch db

ssn

ret project
  branch db

ret emp ret payroll
  hq db   hq db

ret project
 branch db
ret  emp
 hq db

payroll 

figure     rewriting in query planning
our dp algorithm considers bushy join trees  however  to improve its planning time  dp
applies the heuristic of avoiding cross products during join enumeration  thus  in some rare
cases dp may not produce the optimal plan 
initial  this is the initial plan generator for pbr  it generates query plans according to a
random depth first search parse of the query  the only non random choice is that it places
selections as soon as they can be executed  it is the fastest planner but may produce very
low quality plans 
pbr  we used the remote join eval and join swap rules defined in figure     these
two rules are sufficient to optimize the queries in the test set  we tested two gradientdescent search strategies for pbr  first improvement with four random restarts  pbr fi  
and steepest descent with three random restarts  pbr sd  
in this experiment we compare the behavior of sage  dp  initial  pbr fi  and pbr sd
in a distributed query planning domain as the size of the queries increases  we generated a
synthetic domain for the sims mediator and defined a set of conjunctive queries involving
from   to    relations  the queries have one selection on an attribute of each table  each
information source contains two relations and can perform remote operations  therefore 
the optimal plans involve pushing operations to be evaluated remotely at the sources 
the results of this experiment are shown in figure     figure    a  shows the planning
time  in a logarithmic scale  for sage  dp  initial  pbr fi  and pbr sd as the query size
grows  the times for pbr include both the generation of all the random initial plans and
their rewriting  the times for initial are the average of the initial plan construction across
all restarts of each query  sage is able to solve queries involving up to   relations  but larger
   

fiplanning by rewriting

queries cannot be solved within its search limit of         partial plan nodes  dp scales
better than sage  but cannot solve queries of more than   relations in the      second time
limit  both configurations of pbr scale better than sage and dp  the first improvement
search strategy of pbr fi is faster than the steepest descent of pbr sd 
figure    b  shows the cost of the query plans for the five planners  the cost for initial
is the average of the initial plans across all the restarts of each query  the plan cost is an
estimate of the query execution cost  a logarithmic scale is used because of the increasingly
larger absolute values of the plan costs for our conjunctive chain queries and the very high
cost of the initial plans  pbr rewrites the very poor quality plans generated by initial
into high quality plans  both pbr and dp produce better plans than sage  in the range
tractable for sage  for this experiment  this happens because they are searching the larger
space of bushy query trees and can take greater advantage of parallel execution plans  pbr
produces plans of quality comparable to dp for its tractable range and beyond that range
pbr scales gracefully  the two configurations of pbr produce plans of similar cost  though
pbr fi needed less planning time than pbr sd  pbr sd generates all the plans in the local
neighborhood in order to select the cheapest one  but pbr fi only generates a portion of
the neighborhood since it chooses the first plan of a cheaper cost  so pbr fi is faster in
average  figure    shows empirically that in this domain the locally optimal moves of
steepest descent do not translate in final solutions of a better cost than those produced by
the first improvement strategy 

    

 e   
sage
dp
initial
pbr fi
pbr sd

   

 e   
 e   

  

plan cost

planning time  cpu seconds 

 e   

 
sage
dp
initial
pbr fi
pbr sd

   

 e   
 e   
 e   
     
   

    

 
 

 

  

  
query size

  

  

  

 

 a  planning time

 

  

  
query size

  

  

  

 b  plan quality

figure     experimental results  distributed query planning

   related work
in this section we review previous work related to the planning by rewriting framework 
first  we discuss work on the disciplines upon which pbr builds  namely  classical ai
planning  local search  and graph rewriting  then  we discuss work related to our planrewriting algorithm 
   

fiambite   knoblock

    ai planning
pbr is designed to find a balance among the requirements of planning efficiency  high quality
plans  flexibility  and extensibility  a great amount of work on ai planning has focused on
improving its average case efficiency given that the general cases are computationally hard
 erol et al          one possibility is to incorporate domain knowledge in the form of search
control  a recent example is tlplan  bacchus   kabanza               a forward search
planner that has shown a remarkable scalability using control knowledge expressed in temporal logic  some systems automatically learn search control for a given planning domain or
even specific problem instances  minton      b  shows how to deduce search control rules
for a problem solver by applying explanation based learning to problem solving traces  he
also discusses the impact of the utility problem  the utility problem  simply stated  says
that the  computational  benefits of using the additional knowledge must outweigh the cost
of applying it  pbr plan rewriting rules also are subject to the utility problem  the quality
improvement obtained by adding more rewriting rules to a pbr based planner may not be
worth the performance degradation  another approach to automatically generating search
control is by analyzing statically the operators  etzioni        or inferring invariants in the
planning domain  gerevini   schubert        fox   long        rintanen         abstraction provides yet another form of search control  knoblock      a  presents a system that
automatically learns abstraction hierarchies from a planning domain or a particular problem
instance in order to speed up planning  plan rewriting rules can be learned with techniques
analogous to those used to learn search control  ambite  knoblock    minton        present
an approach to automatically learn the plan rewriting rules based on comparing initial and
optimal plans for example problems  alternatively  analyzing the planning operators and
which combinations of operators are equivalent with respect to the achievement of some
goals can also lead to the automatic generation of the rewriting rules 
local search algorithms have also been used to improve planning efficiency although
in a somewhat indirect way  planning can be reduced to solving a series of propositional
satisfiability problems  kautz   selman         thus  kautz   selman        used an
efficient satisfiability testing algorithm based on local search to solve the sat encodings
of a planning problem  their approach proved more efficient than specialized planning
algorithms  we believe that the power of their approach stems from the use of local search 
pbr directly applies local search on the plan structures  as opposed to translating it first
to a larger propositional representation 
although all these approaches do improve the efficiency of planning  they do not specifically address plan quality  or else they consider only very simple cost metrics  such as the
number of steps   some systems learn search control that addresses both planning efficiency
and plan quality  estlin   mooney        borrajo   veloso        perez         however 
from the reported experimental results  pbr appears to be more scalable  moreover  pbr
provides an anytime algorithm while other approaches must run to completion 
    local search
local search has a long tradition in combinatorial optimization  aarts   lenstra       
papadimitriou   steiglitz         local improvement ideas have found application in many
   

fiplanning by rewriting

domains  some of the general work most relevant to pbr is on constraint satisfaction 
scheduling  satisfiability testing  and heuristic search 
in constraint satisfaction  local search techniques have been able to solve problems
orders of magnitude more complex than the respective complete  backtracking  approaches 
minton et al   minton  johnston  philips    laird        minton        developed a simple
repair heuristic  min conflicts  that could solve large constraint satisfaction and scheduling
problems  such as the scheduling of operations in the hubble space telescope  the minconflicts heuristic just selects the variable value assignment that minimizes the number of
constraints violated  this heuristic was used as the cost function of a gradient descent
search and also in an informed backtracking search 
in satisfiability testing a similar method  gsat  was introduced by selman  levesque 
  mitchell         gsat solves hard satisfiability problems using local search where the
repairs consist in changing the truth value of a randomly chosen variable  the cost function
is the number of clauses satisfied by the current truth assignment  their approach scales
much better than the corresponding complete method  the davis putnam procedure  
in work on scheduling and rescheduling  zweben  daun    deale        define a set
of general  but fixed  repair methods  and use simulated annealing to search the space of
schedules  our plans are networks of actions as opposed to their metric time totally ordered
tasks  also we can easily specify different rewriting rules  general or specific  to suit each
domain  as opposed to their fixed strategies 
our work is inspired by these approaches but there are several differences  first  pbr
operates on complex graph structures  partial order plans  as opposed to variable assignments  second  our repairs are declaratively specified and may be changed for each problem
domain  as opposed to their general but fixed repair strategies  third  pbr accepts arbitrary measures of quality  not just constraint violations as in min conflicts  or number of
unsatisfied clauses as gsat  finally  pbr searches the space of valid solution plans  as
opposed to the space of variable assignments which may be internally inconsistent 
iterative repair ideas have also been used in heuristic search  ratner   pohl       
present a two phase approach similar to pbr  in the first phase  they find an initial valid
sequence of operators using an approximation algorithm  in the second phase  they perform
local search starting from that initial sequence  the cost function is the plan length  the
local neighborhood is generated by identifying segments in the current solution sequence
and attempting to optimize them  the repair consists of a heuristic search with the initial
state being the beginning of the segment and the goal the end of the segment  if a shorter
path is found  the original sequence is replaced by the new shorter segment  a significant
difference with pbr is that they are doing a state space search  while pbr is doing a planspace search  the least committed partial order nature of pbr allows it to optimize the
plans in ways that cannot be achieved by optimizing linear subsequences 
    graph rewriting
pbr builds on ideas from graph rewriting  schurr         the plan rewriting rules in
pbr are an extension of traditional graph rewriting rules  by taking advantage of the
semantics of planning pbr introduces partially specified plan rewriting rules  where the
rules do not need to specify the completely detailed embedding of the consequent as in pure
   

fiambite   knoblock

graph rewriting  nevertheless  there are several techniques that can transfer from graph
rewriting into planning by rewriting  particularly for fully specified rules  dorr       
defines an abstract machine for graph isomorphism and studies a set of conditions under
which traditional graph rewriting can be performed efficiently  perhaps a similar abstract
machine for plan rewriting can be defined  the idea of rule programs also appears in this
field and has been implemented in the progres system  schurr              
    plan rewriting
the work most closely related to our plan rewriting algorithm is plan merging  foulser  li   
yang         foulser et al  provide a formal analysis and algorithms for exploiting positive
interactions within a plan or across a set of plans  however  their work only considers the
case in which a set of operators can be replaced by one operator that provides the same
effects to the rest of the plan and consumes the same or fewer preconditions  their focus is
on optimal and approximate algorithms for this type of operator merging  plan rewriting
in pbr can be seen as a generalization of operator merging where a subplan can replace
another subplan  a difference is that pbr is not concerned with finding the optimal merge
 rewritten plan  in a single pass of an optimization algorithm as their approach does  in
pbr we are interested in generating possible plan rewritings during each rewriting phase 
not the optimal one  the optimization occurs as the  local  search progresses 
case based planning  e g   kambhampati        veloso        nebel   koehler       
hanks   weld        munoz avila        solves a problem by modifying a previous solution 
there are two phases in case based planning  the first one identifies a plan from the library
that is most similar to the current problem  in the second phase this previous plan is adapted
to solve the new problem  pbr modifies a solution to the current problem  so there is no
need for a retrieval phase nor the associated similarity metrics  plan rewriting in pbr can
be seen as a type of adaptation from a solution to a problem to an alternate solution for
the same problem  that is  a plan rewriting rule in pbr identifies a pair of subplans  the
replaced and replacement subplans  that may be interchangeable 
veloso        describes a general approach to case based planning based on derivational
analogy  her approach works in three steps  first  the retrieval phase selects a similar
plan from the library  second  the parts of this plan irrelevant to the current problem
are removed  finally  her system searches for a completion of this plan selecting as much
as possible the same decisions as the old plan did  in this sense the planning knowledge
encoded in the previous solution is transferred to the generation of the new solution plan 
the plan rewriting algorithm for partially specified rules of pbr can be seen as a strongly
constrained version of this approach  in pbr the subplan in the rule consequent fixes the
steps that can be added to repair the plan  we could use her technique of respecting
previous choice points when completing the plan as a way of ensuring that most of the
structure of the plan before and after the repair is maintained  this could be useful to
constrain the number of rewritten plans for large rewriting rules 
nebel and koehler        present a computational analysis of case based planning  in
this context they show that the worst case complexity of plan modification is no better than
plan generation and point to the limitations of reuse methods  the related problem in the
pbr framework is the embedding of the replacement subplan for partially specified rules 
   

fiplanning by rewriting

as we explained in section       there may be pathological cases in which the number of
embeddings is exponential in the size of the plan or deciding if the embedding exists is
np hard  however  often we are not interested in finding all rewritings  for example when
following a first improvement search strategy  in our experience the average case behavior
seems to be much better as was presented in section   
systematic algorithms for case based planning  such as hanks   weld        invert the
decisions done in refinement planning to find a path between the solution to a similar old
problem and the new problem  the rewriting rules in pbr indicate how to transform a
solution into another solution plan based on domain knowledge  as opposed to the generic
inversion of the refinement operations  plan rewriting in pbr is done in a very constrained
way instead of an open search up and down the space of partial plans  however  the rules in
pbr may search the space of rewritings non systematically  such an effect is ameliorated
by using local search 

   discussion and future work
this paper has presented planning by rewriting  a new paradigm for efficient high quality
domain independent planning  pbr adapts graph rewriting and local search techniques
to the semantics of domain independent partial order planning  the basic idea of pbr
consists in transforming an easy to generate  but possibly suboptimal  initial plan into a
high quality plan by applying declarative plan rewriting rules in an iterative repair style 
there are several important advantages to the pbr planning approach  first  pbr is
a declarative domain independent framework  which brings the benefits of reusability and
extensibility  second  it addresses sophisticated plan quality measures  while most work in
domain independent planning has not addressed quality or does it in very simple ways 
third  pbr is scalable because it uses efficient local search methods  finally  pbr is an
anytime planning algorithm that allows balancing planning effort and plan quality in order
to maximize the utility of the planning process 
planning by rewriting provides a domain independent framework for local search  pbr
accepts declarative domain specifications in an expressive operator language  declarative
plan rewriting rules to generate the neighborhood of a plan  complex quality metrics  interchangeable initial plan generators  and arbitrary  local  search methods 
planning by rewriting is well suited to mixed initiative planning  in mixed initiative
planning  the user and the planner interact in defining the plan  for example  the user can
specify which are the available or preferred actions at the moment  change the quality criteria of interest  etc  in fact  some domains can only be approached through mixed initiative
planning  for example  when the quality metric is very expensive to evaluate  such as in
geometric analysis in manufacturing  the user must guide the planner towards good quality
plans in a way that a small number of plans are generated and evaluated  another example
is when the plan quality metric is multi objective or changes over time  several characteristics of pbr support mixed initiative planning  first  because pbr offers complete plans 
the user can easily understand the plan and perform complex quality assessment  second 
the rewriting rule language is a convenient mechanism by which the user can propose modifications to the plans  third  by selecting which rules to apply or their order of application
the user can guide the planner 
   

fiambite   knoblock

our framework achieves a balance between domain knowledge  expressed as plan rewriting
rules  and general local search techniques that have proved useful in many hard combinatorial problems  we expect that these ideas will push the frontier of solvable problems for
many practical domains in which high quality plans and anytime behavior are needed 
the planning style introduced by pbr opens several areas for future research  there
is great potential for applying machine learning techniques to pbr  an important issue is
the generation of the plan rewriting rules  conceptually  plan rewriting rules arise from the
chosen plan equivalence relation  all valid plans that achieve the given goals in a finite
number of steps  i e  all solution plans  are  satisfiability  equivalent  each rule arises from
a theorem that states that two subplans are equivalent for the purposes of achieving some
goals  with the addition of some conditions that indicate in which context that rule can
be usefully applied  the plan rewriting rules can be generated by automated procedures 
the methods can range from static analysis of the domain operators to analysis of sample
equivalent plans that achieve the same goals but at different costs  note the similarity
with methods to automatically infer search control and domain invariants  minton      b 
etzioni        gerevini   schubert        fox   long        rintanen         and also the
need to deal with the utility problem  ambite  knoblock    minton        present some
results on learning plan rewriting rules based on comparing initial and optimal plans for
sample problems 
beyond learning the rewriting rules  we intend to develop a system that can automatically learn the optimal planner configuration for a given planning domain and problem
distribution in a manner analogous to mintons multi tac system  minton         our
system would perform a search in the configuration space of the pbr planner proposing
candidate sets of rewriting rules and different search methods  by testing each proposed
configuration against a training set of simple problems  the system would hill climb in the
configuration space in order to arrive at the most useful rewriting rules and search strategies
for the given planning domain and distribution of problems 
there are many advanced techniques in the local search literature that can be adapted
and extended in our framework  in particular  the idea of variable depth rewriting leads
naturally to the creation of rule programs  which specify how a set of rules are applied to
a plan  we have already seen how in query planning we could find transformations that
are better specified as a program of simple rewriting rules  for example  a sequence of
join swap transformations may put two retrieve operators on the same database together
in the query tree and then remote join eval would collapse the explicit join operator and
the two retrieves into a single retrieval of a remote join  cherniack   zdonik             
present more complex examples of this sort of programs of rewriting rules in the context of
a query optimizer for object oriented databases 
as we discussed in sections       and       the language of the antecedent of the rewriting rules can be more expressive than conjunctive queries while still remaining computationally efficient  for example  figure    shows a rule from the manufacturing domain of
section     with a relationally complete antecedent  this rule matches a subplan that contains a spray paint operator  but does not contain either punch or drill press operators
that create holes of diameter smaller than   millimeter  in such case  the rule replaces the
spray paint operator by an immersion paint operator  this rule would be useful in a
situation in which painting by immersion could clog small holes 
   

fiplanning by rewriting

 define rule  name sp by ip no small holes
 if   and   operator  n   spray paint  x  c  s  
  not   and   or   operator  n   punch  x  w  o  
  operator  n   drill press  x  w  o   
  less  w  mm    
 replace   operators   n   
 with   operator  n   immersion paint  x  c   

figure     rule with a relationally complete antecedent
another area for further research is the interplay of plan rewriting and plan execution 
sometimes the best transformations for a plan may only be known after some portion of
the plan has been executed  this information obtained at run time can guide the planner
to select the appropriate rewritings  for example  in query planning the plans may contain
information gathering actions  ashish  knoblock    levy        and depend on run time
conditions  this yields a form of dynamic query optimization  interleaved planning and
execution is also necessary in order to deal effectively with unexpected situations in the
environment such as database or network failures 
an open area of research is to relax our framework to accept incomplete plans during
the rewriting process  this expands the search space considerably and some of the benefits
of pbr  such as its anytime property  are lost  but for some domains the shortest path of
rewritings from the initial plan to the optimal may pass through incomplete or inconsistent
plans  this idea could be embodied as a planning style that combines the characteristics
of generative planning and planning by rewriting  this is reminiscent of the plan critics
approach  sacerdoti        sussman         the resulting plan rewriting rules can be seen
as declarative specifications for plan critics  the plan refinements of both partial order
planning  kambhampati et al         and hierarchical task network planning  erol  nau 
  hendler        can be easily specified as plan rewriting rules 
applying pbr to other domains will surely provide new challenges and the possibility
of discovering and transferring general planning techniques from one domain to another 
we hope that the local search methods used by pbr will help planning techniques to scale
to large practical problems and conversely that the domain independent nature of pbr will
help in the analysis and principled extension of local search techniques 

acknowledgments
this paper is an extended version of  ambite   knoblock        
the research reported here was supported in part by a fulbright ministerio of educacion
y ciencia of spain scholarship  in part by the defense advanced research projects agency
 darpa  and air force research laboratory  air force materiel command  usaf  under
agreement number f                 in part by the national science foundation under
grant number iri          in part by the rome laboratory of the air force systems command and the defense advanced research projects agency  darpa  under contract numbers f         c       f                 f                 f                 in part by
the united states air force under contract number f                 and in part by the
integrated media systems center  a national science foundation engineering research
   

fiambite   knoblock

center  cooperative agreement no  eec          the u s government is authorized to
reproduce and distribute reports for governmental purposes notwithstanding any copyright
annotation thereon  the views and conclusions contained herein are those of the authors and
should not be interpreted as necessarily representing the official policies or endorsements 
either expressed or implied  of any of the above organizations or any person connected with
them 

references
aarts  e     lenstra  j  k          local search in combinatorial optimization  john wiley
and sons  chichester  england 
abiteboul  s   hull  r     vianu  v          foundations of databases  addison wesley 
ambite  j  l          planning by rewriting  ph d  thesis  university of southern california 
ambite  j  l     knoblock  c  a          planning by rewriting  efficiently generating
high quality plans  in proceedings of the fourteenth national conference on artificial
intelligence  pp         providence  ri 
ambite  j  l     knoblock  c  a          flexible and scalable cost based query planning
in mediators  a transformational approach  artificial intelligence                    
ambite  j  l   knoblock  c  a     minton  s          learning plan rewriting rules  in
proceedings of the fifth international conference on artificial intelligence planning
and scheduling systems breckenridge  co 
ashish  n   knoblock  c  a     levy  a          information gathering plans with sensing
actions  in steel  s     alami  r   eds    recent advances in ai planning   th
european conference on planning  ecp    springer verlag  new york 
avenhaus  j     madlener  k          term rewriting and equational reasoning  in formal
techniques in artificial intelligence  pp       elsevier  north holland 
baader  f     nipkow  t          term rewriting and all that  cambridge university
press 
bacchus  f     kabanza  f          using temporal logic to control search in a forward
chaining planner  in proceedings of the  rd european workshop on planning 
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for planning  artificial intelligence                   
backstrom  c       a   executing parallel plans faster by adding actions  in cohn  a  g 
 ed    proceedings of the eleventh european conference on artificial intelligence  pp 
       amsterdam  netherlands  john wiley and sons 
backstrom  c       b   finding least constrained plans and optimal parallel executions is
harder that we thought  in backstrom  c     sandewell  e   eds    current trends in
ai planning  proceedings of the  nd european workshop on planning  ewsp     
pp       vadstena  sweeden  ios press  amsterdam  
   

fiplanning by rewriting

backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence                 
blum  a  l     furst  m  l          fast planning through planning graph analysis  in
proceedings of the fourteenth international joint conference on artificial intelligence
montreal  canada 
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence                  
bonet  b     geffner  h          planning as heuristic search  new results  in proceedings
of the fifth european conference on planning  ecp     durham  uk 
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism for planning  in proceedings of the fourteenth national conference on artificial
intelligence  pp         providence  ri 
borrajo  d     veloso  m          lazy incremental learning of control knowledge for
efficiently obtaining quality plans  ai review             
bylander  t          the computation complexity of propositional strips  artificial intelligence                   
carbonell  j  g   knoblock  c  a     minton  s          prodigy  an integrated architecture for planning and learning  in vanlehn  k   ed    architectures for intelligence 
pp          lawrence erlbaum  hillsdale  nj 
cherniack  m     zdonik  s  b          rule languages and internal algebras for rule based
optimizers  sigmod record  acm special interest group on management of data  
               
cherniack  m     zdonik  s  b          changing the rules  transformations for rulebased optimizers  in proceedings of the acm sigmod international conference on
management of data  pp       seattle  wa 
dean  t     boddy  m          an analysis of time dependent planning  in proceedings of
the seventh national conference on artificial intelligence  pp       saint paul  mn 
dorr  h          efficient graph rewriting and its implementation  vol      of lecture notes
in computer science  springer verlag inc   new york  ny  usa 
erol  k   nau  d     hendler  j          umcp  a sound and complete planning procedure
for hierarchical task network planning  in proceedings of the second international
conference on artificial intelligence planning systems  pp         chicago  il 
erol  k   nau  d     subrahmanian  v  s          decidability and undecidability results
for domain independent planning  artificial intelligence                 
estlin  t  a     mooney  r  j          learning to improve both efficiency and quality of
planning  in proceedings of the fifteenth international joint conference on artificial
intelligence  pp           nagoya  japan 
   

fiambite   knoblock

etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence                 
etzioni  o     weld  d  s          a softbot based interface to the internet  communications of the acm         
fikes  r  e     nilsson  n  j          strips  a new approach to the application of
theorem proving to problem solving  artificial intelligence                  
forgy  c  l          rete  a fast algorithm for the many pattern many object pattern
match problem  artificial intelligence           
foulser  d  e   li  m     yang  q          theory and algorithms for plan merging  artificial
intelligence                  
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificicial intelligence research            
gerevini  a     schubert  l          inferring state constraints for domain independent
planning  in proceedings of the fifteenth national conference on artificial intelligence  pp         madison  wi 
glover  f          tabu searchpart i  orsa journal on computing                
gomes  c  p   selman  b     kautz  h          boosting combinatorial search through
randomization  in proceedings of the fifteenth national conference on artificial intelligence madison  wi 
gupta  n     nau  d  s          on the complexity of blocks world planning  artificial
intelligence                  
hanks  s     weld  d  s          a domain independent algorithm for plan adaptation 
journal of artificicial intelligence research            
johnson  d  s          local optimization and the traveling salesman problem  in paterson 
m  s   ed    automata  languages and programming  proc  of the   th international
colloquium  pp          springer  new york 
kambhampati  s          a validation structure based theory of plan modification and
reuse  artificial intelligence                   
kambhampati  s   knoblock  c  a     yang  q          planning as refinement search 
a unified framework for evaluating the design tradeoffs in partial order planning 
artificial intelligence                   
kautz  h     selman  b          planning as satisfiability  in neumann  b   ed    proceedings of the   th european conference on artificial intelligence  pp         vienna 
austria  john wiley   sons 
   

fiplanning by rewriting

kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proceedings of the thirteenth national conference on artificial
intelligence  pp           portland  or 
kirkpatrick  s   gelatt  c  d     vecchi  m  p          optimization by simulated annealing 
science              
knoblock  c  a       a   automatically generating abstractions for planning  artificial
intelligence                 
knoblock  c  a       b   generating parallel execution plans with a partial order planner  in proceedings of the second international conference on artificial intelligence
planning systems chicago  il 
knoblock  c  a          planning  executing  sensing  and replanning for information gathering  in proceedings of the fourteenth international joint conference on artificial
intelligence montreal  canada 
knoblock  c  a          building a planner for information gathering  a report from the
trenches  in proceedings of the third international conference on artificial intelligence planning systems edinburgh  scotland 
koehler  j          solving complex planning tasks through extraction of subproblems  in
simmons  r   veloso  m     smith  s   eds    proceedings of the fourth international
conference on artificial intelligence planning systems  pp       pittsburgh  pa 
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
koehler  j   nebel  b   hoffman  j     dimopoulos  y          extending planning graphs to
an adl subset  in steel  s     alami  r   eds    proceedings of the fourth european
conference on planning  ecp      recent advances in ai planning  vol       of
lnai  pp         berlin  springer 
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings of
the ninth national conference on artificial intelligence anaheim  ca 
minton  s       a   learning effective search control knowledge  an explanation based
approach  ph d  thesis  computer science department  carnegie mellon university 
minton  s       b   learning search control knowledge  an explanation based approach 
kluwer  boston  ma 
minton  s          minimizing conflicts  a heuristic repair method for constraintsatisfaction and scheduling problems  artificial intelligence                   
minton  s          automatically configuring constraint satisfaction programs  a case
study  constraints             
   

fiambite   knoblock

minton  s   johnston  m  d   philips  a  b     laird  p          solving large scale constraint satisfaction and scheduling problems using a heuristic repair method  in proceedings of the eighth national conference on artificial intelligence  pp       boston 
ma 
munoz avila  h          integrating twofold case retrieval and complete decision replay
in caplan cbc  ph d  thesis  university of kaiserslautern 
nau  d  s   gupta  s  k     regli  w  c          ai planning versus manufacturingoperation planning  a case study  in proceedings of the fourteenth international
joint conference on artificial intelligence montreal  canada 
nebel  b     koehler  j          plan reuse versus plan generation  a theoretical and
empirical analysis  artificial intelligence                     
ono  k     lohman  g  m          measuring the complexity of join enumeration in query
optimization  in mcleod  d   sacks davis  r     schek  h  j   eds      th international conference on very large data bases  pp         brisbane  queensland 
australia  morgan kaufmann 
papadimitriou  c  h     steiglitz  k          on the complexity of local search for the
traveling salesman problem  siam              
papadimitriou  c  h     steiglitz  k          combinatorial optimization  algorithms and
complexity  prentice hall  englewood cliffs  nj 
penberthy  j  s     weld  d  s          ucpop  a sound  complete  partial order planner for
adl  in third international conference on principles of knowledge representation
and reasoning  pp         cambridge  ma 
perez  m  a          representing and learning quality improving search control knowledge 
in proceedings of the thirteenth international conference on machine learning bari 
italy 
ratner  d     pohl  i          joint and lpa   combination of approximation and search 
in proceedings of the fifth national conference on artificial intelligence philadelphia 
pa 
rintanen  j          an iterative algorithm for synthesizing invariants  in proceedings of
the seventeenth national conference on artificial intelligence austin  tx 
russell  s     norvig  p          artificial intelligence  a modern approach  prentice hall 
sacerdoti  e  d          the nonlinear nature of plans  in proceedings of the fourth
international joint conference on artificial intelligence  pp         tbilisi  georgia 
ussr 
savage  s   weiner  p     bagchi  a          neighborhood search algorithms for guaranteeing optimal traveling salesman tours must be inefficient  journal of computer and
system sciences               
   

fiplanning by rewriting

schurr  a          introduction to progres  an attribute graph grammar based specification language  in nagl  m   ed    graph theoretic concepts in computer science 
vol      of lecture notes in computer science  pp         
schurr  a          programmed graph replacement systems  in rozenberg  g   ed   
handbook on graph grammars  foundations  vol     pp          world scientific 
singapore 
sellis  t  k          multiple query optimization  acm transactions on database systems 
             
selman  b   levesque  h     mitchell  d          a new method for solving hard satisfiability
problems  in proceedings of the tenth national conference on artificial intelligence
 aaai      pp         san jose  california  aaai press 
silberschatz  a   korth  h  f     sudarshan  s          database system concepts  third
edition   mcgraw hill 
simon  h          the sciences of the artificial  mit press 
slaney  j     thiebaux  s          linear time near optimal planning in the blocks world  in
proceedings of the thirteenth national conference on artificial intelligence and the
eighth innovative applications of artificial intelligence conference  pp          
menlo park  aaai press   mit press 
sussman  g  j          a computer model of skill acquisition  american elsevier  new
york 
veloso  m          planning and learning by analogical reasoning  springer verlag 
veloso  m  m   perez  m  a     carbonell  j  g          nonlinear planning with parallel
resource allocation  in proceedings of the workshop on innovative approaches to
planning  scheduling and control  pp         san diego  ca 
weld  d  s          an introduction to least commitment planning  ai magazine         
weld  d  s          recent advances in ai planning  ai magazine         
yu  c     chang  c          distributed query processing  acm computing surveys         
       
zweben  m   daun  b     deale  m          scheduling and rescheduling with iterative
repair  in intelligent scheduling  pp          morgan kaufman  san mateo  ca 

   

fi