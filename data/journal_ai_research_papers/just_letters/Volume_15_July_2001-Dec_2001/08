journal artificial intelligence research                  

submitted       published      

ecient methods qualitative spatial reasoning
renz dbai tuwien ac at

jochen renz
institut f
ur informationssysteme  technische universit
wien
favoritenstr    a      wien  austria

nebel informatik uni freiburg de

bernhard nebel
institut f
ur informatik  albert ludwigs universit

flughafen     d       freiburg  germany

abstract

theoretical properties qualitative spatial reasoning rcc   framework
analyzed extensively  however  empirical investigation made yet 
experiments show adaption algorithms used qualitative temporal
reasoning solve large rcc   instances  even phase transition region
  provided one uses maximal tractable subsets rcc   identified
us  particular  demonstrate orthogonal combination heuristic methods
successful solving almost apparently hard instances phase transition region
certain size reasonable time 
   introduction

representing qualitative spatial information reasoning information
important subproblem many applications  natural language understanding  document interpretation  geographical information systems  rcc   calculus  randell 
cui    cohn      b  well suited representing topological relationships spatial
regions  inference full calculus is  however  np hard  grigni  papadias    papadimitriou        renz   nebel         means unlikely large
instances solved reasonable time  result rule possibility
solve instances certain size reasonable time  recently  maximal tractable
subsets rcc   identified  renz   nebel        renz        used
speed backtracking search general np complete reasoning problem reducing
search space considerably 
paper address several questions emerge previous theoretical results
rcc    renz   nebel        renz         size possible solve
instances reasonable time  heuristic best  really much ecient
use maximal tractable subsets solving instances np complete consistency
problem theoretical savings given smaller branching factors indicate
effect out balanced forward checking power interleaved path consistency
computations  case similar temporal problems  pointisable vs  ord horn
relations   nebel         possible combine different heuristics way
instances solved reasonable time heuristic alone 
treat questions randomly generating instances solving using
different heuristics  so  particularly interested hardest randomly
c      ai access foundation morgan kaufmann publishers  rights reserved 

firenz   nebel

generated instances leads question phase transitions  cheeseman  kanefsky 
  taylor         parameter randomly generating instances consistency
problem rcc   results phase transition behavior  so  case
hardest instances mainly located phase transition region instances
contained phase transition region easily solvable  order generate instances
harder higher probability  generate two different kinds instances 
one hand generated instances contain constraints rcc   relations 
hand generated instances contain constraints relations
contained maximal tractable subsets  expect instances
harder average former instances 
algorithmic techniques use solving randomly generated instances
borrowed similar work qualitative temporal reasoning  nebel        van beek  
manchak        ladkin   reinefeld         additionally  make use fragments
rcc    named hb    q    c   permit polynomial time inferences  renz   nebel 
      renz         backtracking algorithm  used solve reasoning
problem full rcc    decompose every disjunctive relation relations one
tractable subsets instead decomposing base relations  reduces
average branching factor backtracking tree     base relations
       hb          c         q    although theoretical savings
cannot observed experiments  using maximal tractable subsets instead
base relations leads significant performance improvements 
paper structured follows  section    give brief sketch rcc  
calculus algorithms used solving instances rcc    section   describe
procedure randomly generating instances  different heuristics apply solving
instances  measure quality heuristics  section   evaluate
different path consistency algorithms order find ecient one used
forward checking backtracking search  section   observe phase transition
behavior randomly generated instances show instances phasetransition region harder solve instances  section   report
outcome running different heuristics solving instances identify several
hard instances mainly located phase transition region  section   try
solve hard instances orthogonally combining different heuristics  turns
effective leads ecient solution strategy  finally  section  
evaluate strategy trying solve large instances  
   region connection calculus rcc  

region connection calculus  rcc  first order language representation
reasoning topological relationships extended spatial regions  randell et al  
    b   spatial regions rcc non empty regular subsets topological space
internally connected  i e   spatial region may consist different
disconnected pieces  different relationships spatial regions defined based
one dyadic relation  connected relation c    true topological closures
spatial regions share common point 
a  b



b

   programs available online appendix 

   

fiefficient methods qualitative spatial reasoning






















x

x





dc x  y 

x





x

tpp x  y  tpp    x  y 

ec x  y 

x

x



po x  y 

x





x

ntpp x  y  ntpp    x  y 

eq x  y 

figure    two dimensional examples eight base relations rcc  
region connection calculus rcc   constraint language formed eight
jointly exhaustive pairwise disjoint base relations dc  ec  po  eq  tpp  ntpp  tpp    
ntpp   definable rcc theory possible unions base relations 
giving total number          different relations  base relations meaning
disconnected  externally connected  partial overlap  equal  tangential proper part 
non tangential proper part  converses  examples relations shown
figure    constraints written form
variables spatial
regions rcc   relation  write union base relations f g 
union base relations  universal relation  written fg  apart union
     operations relations defined  namely  converse      intersection     
composition     formal definitions operations are 
xry

x 

r

r 

 

 
 
 
 

x 
x 
x 
x 

 
 
 
 

     
     

x r



x r



xr

 

   

x r





 
 
 
   

 
 
 
  

xry

xs

xry

xs

yrx
z

xrz

 
 

 

 

zsy  

composition base relations computed semantics relations
usually provided composition table  randell  cohn    cui      a  bennett        
rcc   composition table corresponds given extensional definition composition
universal region permitted  bennett         based table  compositions
disjunctive relations easily computed  following  sb denotes closure
set rcc   relations composition  intersection  converse 
finite set rcc   constraints describing topological relationships different
regions represented matrix   entry represents rcc  
relation holding region region   without loss generality    feqg
 
assumed  fundamental reasoning problem  named rsat 
framework deciding consistency set spatial formulas   i e   whether
spatial configuration relations regions described  
interesting reasoning problem reduced polynomial time  golumbic
  shamir         unfortunately  rsat np complete  renz   nebel         i e  
unlikely polynomial algorithm deciding consistency  however 
shown nebel s        paper subsets rcc   consistency
n

n



mji

n



j

 

mij

   

mij

mii

firenz   nebel

problem  written rsat s   decided polynomial time   particular set
eight base relations b shown tractable  follows bb consisting
   relations tractable  even larger tractable subset containing base relations
hb    renz   nebel         contains         rcc   relations  set
shown maximal respect tractability  i e   rcc   relation
added  consistency problem becomes np complete  renz        made complete
analysis tractability rsat identifying maximal tractable subsets contain
base relations  altogether three subsets hb    q       relations   c       relations  
np   set relations result np completeness combined
set base relations  contains following    relations contained
one hb   q  c   renz        
np     f j fpog    fntppg ftppg  
 fntpp  g ftpp  g  g
  ffec ntpp eqg fdc ec ntpp eqg
fec ntpp   eqg fdc ec ntpp   eqgg
maximal tractable subsets contain following relations  renz        
hb      rcc   n np     n f j  feq ntppg ftppg    
 feq ntpp   g ftpp  g    g
c     rcc   n np     n f j fecg fpog  
  ftpp ntpp tpp   ntpp   eqg     g
q     rcc   n np     n f j feqg fpog  
  ftpp ntpp tpp   ntpp   g     g
 

 

r

r

r

r

r

 

 

 

 

 

 

 

 

 

 

 

 

 

r

r

r

 

 

r

r

 

r

 

 

 

r

r

r

r

 

 

r

r

r

 

r

 

relations q  contained one hb   c   i e   hb     c    rcc   n np    
although hb   smallest three maximal tractable subsets  best decomposes
rcc   relations  decomposing rcc   relation
sub relations one
maximal tractable subsets  i e             one needs average        hb   relations 
      q  relations        c  relations decomposing rcc   relations  renz       
gives detailed enumeration relations three sets 
r

r



   

si

sk

    path consistency algorithm

area qualitative temporal reasoning based allen s interval calculus  allen 
       path consistency algorithm  montanari        mackworth        mackworth  
freuder        used approximate consistency realize forward checking
 haralick   elliot        backtracking algorithm 
path consistency algorithm checks consistency triples relations
eliminates relations impossible  done iteratively performing following
operation
 
mij

mij

mik

mkj

   strictly speaking  applies systems regions require regularity 

   

fiefficient methods qualitative spatial reasoning

algorithm  path consistency
input  set binary constraints variables x    x            x

n



represented matrix  
path consistent set equivalent   fail  set
exist 
n

output 

n



      f        j  

      g 
  indicates  th variable   analogously  
       
   select delete path      
   revise   
  

    return fail
  
else      f 
      j         g 
q

i  j  k  

k  i  j



i  j  k

n    j  k

i  k

j



j

k

q

p  r  q

q

p  r  q

mpq

q

q

p  q   

s  p  q



n 

p 

q

function  revise i  k  j  
input  three labels i  k j indicating variables x   x   x
output  true  revised  false otherwise 
side effects  revised using operations  


j

k

ij

ij

ji

constraints involving      
xi

xk

xj

   oldm     
  
         
    oldm     return false 
  
    
   return true 
mij

mij

mij

mj

mij

mik

mkj

mij

 

figure    path consistency algorithm 
triples regions
fixed point reached 
    pair
  know inconsistent  otherwise path consistent  computing
done      time  see figure     achieved using queue triples
regions relations recomputed  mackworth   freuder         pathconsistency imply consistency  instance  following set spatial constraints
path consistent consistent 
i  j  k

i  j



ij







n

lhh   l
hhh
l  hhhj  l 

x

dc   tpp

z

tpp   tpp  
ec   tpp
ec   tpp

eq   ntpp



ec   ntpp

w

hand  consistency imply path consistency  since path consistency
form consistency  in logical sense   form disjunctive non redundancy 
nevertheless  path consistency enforced consistent set constraints ap   

firenz   nebel

algorithm  consistency
input  set rcc   constraints variables x    x            x

subset rcc   contains base relations
decide sound complete decision
procedure 
output  true  iff consistent 
   path consistency  
   contains empty relation return false
   else choose unprocessed constraint

split  
         
   constraint split return decide  
   refinements     
  
replace


  
consistency   return true

n

xi rxj

r

          sk

sl

xi rxj

l



   

sk

r

k

xi sl xj

figure    backtracking algorithm deciding consistency 
plying path consistency algorithm  relations hb    q    c  used  however 
path consistency algorithm sucient deciding consistency  i e   path consistency
decides rsat hb     rsat q     rsat c      renz   nebel        renz        
    backtracking algorithm

order solve instance rsat  explore corresponding search space
using sort backtracking  experiments  used backtracking algorithm
employed solving qualitative temporal reasoning problems  nebel         based
algorithm proposed ladkin reinefeld         algorithm  see figure   
necessary subset rcc   consistency decided using
sound complete  and preferably polynomial  decision procedure decide  contains
base relations  thens relation   rcc   decomposed sub relations
   
  size particular decomposition minimal number
sub relations used decompose   backtracking algorithm successively
selects constraints   backtracks sub relations constraints according
decomposition decides sub instances contain constraints using
decide 
 optional  procedure path consistency line   used forward checking
restricts remaining search space  nebel        showed restriction
effect soundness completeness algorithm  enforcing path consistency
sucient deciding rsat s   decide   line   necessary  instead possible
always return true there 
eciency backtracking algorithm depends several factors  one is 
course  size search space explored  common way measuring
r

si

r



si

si

r

   

fiefficient methods qualitative spatial reasoning

size search space average branching factor search space  i e  
average number branches node search space  a node recursive  call
    
consistency   average size search space computed  
 
 
    number constraints split variables
given  backtracking algorithm described figure   branching factor depends
average number relations split set relation split 
less splits average better  i e   expected eciency
backtracking algorithm depends split set branching factor  another factor
search space explored  backtracking algorithm figure   offers two
possibilities applying heuristics  one line   next unprocessed constraint
chosen  line   next refinement chosen  two
choices uence search space path search space 
b

b

n

n  

n

n  

n

   test instances  heuristics  measurement

previous work empirical evaluation algorithms reasoning rcc  
benchmark problems known  therefore randomly generated test instances
given number regions   average label size   average degree
constraint graph  further  used two different sets relations generating test
instances  set rcc   relations set hard rcc   relations np    i e  
   relations contained maximal tractable subsets hb    c   
q    based sets relations  used two models generate instances  denoted
         former model uses relations generate instances 
latter relations np    instances generated follows 
   constraint graph nodes average degree node generated 
accomplished selecting          possible edges using
uniform distribution 
   edge th th node  set   universal
relation 
   otherwise non universal relation selected according parameter
average size relations selected edges   accomplished selecting
one base relations uniform distribution remaining   relations
one probability          results allowed relation  i e   relation
np        rcc   relation       assign relation
edge  otherwise repeat process 
reason generating instances using relations np   assume
instances dicult solve since every relation split
backtracking search  even use maximal tractable subclass split set 
generated instances average label size        since case relations equally
distributed 
n

n  d  l

l



h n  d  l

n



nd 



n n

j

 

mij

mji

l

l

l

 

h n  d  l

n  d  l

l

 

   method could result assignment universal constraint selected link  thereby changing
degree node  however  since probability getting universal relation low 
ignore following 

   

firenz   nebel

way generating random instances similar way random csp instances finite domains usually generated  gent  macintyre  prosser  smith   
walsh         achlioptas et al         found standard models generating
random csp instances finite domains lead trivially awed instances     
i e   instances become locally inconsistent without propagate constraints  since
using csp instances infinite domains  achlioptas et al  s result necessarily hold random instances  we  therefore  analyze following whether
instances trivially awed      order obtain csp finite domain  first transform constraint graph dual graph
       edges
constraint graph corresponds node
dual graph  moreover  variables constraint graph corresponds
  edges dual graph  i e   dual graph contains      edges       
nodes  dual graph  node corresponds variable eight valued domain
  fdc ec po tpp tpp   ntpp ntpp   eqg  ternary constraints variables imposed composition table  i e   composition rules


must hold connected
dual graph    
triples nodes
n
                  connected triples dual graph 


n n     
overall number triples dual graph
 
  unary constraints
 

domain variables given  i e   nd     triples dual graph
nodes restricted unary constraints  therefore  expected number
connected triples unary constraints given computed
 
 
 
   
 
 
      
 
     expected number triples   tends      instances generated
according model      probability unary constraints
assigned triple lead local inconsistency          only       
                  possible assignments inconsistent   since one locally inconsistent
triple makes whole instance inconsistent  interested average degree
expected number locally inconsistent triples equal one  model
    occurs value                                
expected number locally inconsistent triples one                   
         model      none possible assignments triples leads
local inconsistency  i e   triples randomly generated instances    
model locally consistent   analysis shows contrary achlioptas et
al  found randomly generated csp instances finite domains  model     
model     small suffer trivial local inconsistencies 
n

n

n n

 

mij

n

n

n n

 

 

 

 

 

 

n n

 

mij

mik

mij   mik   mkj

i  j

n n

 

n

mkj

 

mij

mj

 

nd 

mij

n
ct

e

n

nd 

n

 

ec

n n

n

 

ec

 

n  d  l

 

 

 



n
e


n  d  l



 

e



 







 

 

 

n

e



 

h n  d  l

h n  d  l

h n  d  l

n  d  l



   similar result csps finite domains restricting constraint type  e g  
 not equal  constraints graph coloring used  possible ensure problems cannot
trivially awed 

   

fiefficient methods qualitative spatial reasoning

solve randomly generated instances using backtracking algorithm described
previous section  search space backtracking performed depends
split set  i e   set sub relations allowed decompositions  choosing
right split set uences search noticeably uences average branching factor
search space  choose five different split sets  three maximal tractable subsets
hb   q  c   set base relations b closure set bb consists
   relations  sets following branching factors b       b b       hb          
c          q           is  course  worst case measure interleaved pathconsistency computations reduce branching factor considerably  ladkin   reinefeld 
      
apart choice split set heuristics uence eciency search  general best search strategy proceed constraint
constraining relation  line   figure    least constraining choice
sub relation  line   figure     investigated two different aspects choosing
next constraint processed  nebel        
static dynamic  constraints processed according heuristic evaluation
constrainedness determined statically backtracking starts dynamically search 
local global  evaluation constrainedness based local heuristic weight
criterion global heuristic criterion  van beek   manchak        
gives us four possibilities combine five different split sets  i e  
total number    different heuristics  evaluation constrainedness well
relations decomposed relations different split sets depends restrictiveness
relations  heuristic criterion  van beek   manchak         restrictiveness
relation measure relation restricts neighborhood  instance 
universal relation given constraint network restrict neighboring relations
all  result composition relation universal relation universal
relation  identity relation  contrast  restricts neighborhood lot  every triple
variables one relation identity relation  two relations must equal 
therefore  universal relation usually least restricting relation  identity
relation usually restricting relation  restrictiveness relations represented
weight range      assigned every relation    value
   value least restricting relation  discuss following section
detail restrictiveness weight relation determined 
given weights assigned every relation  compute decompositions estimate
constrainedness follows  split set rcc   relation compute
smallest decomposition sub relations s  i e   decomposition requires least number sub relations s  one possibility  choose
decomposition least restricting sub relations  line   backtracking algorithm  see figure     least restricting sub relation decomposition processed
first  local strategy  constrainedness constraint determined size
decomposition  which different every split set  weight  choose
constraint smallest decomposition larger one and 
 

 

r

r

   

firenz   nebel

one constraint  one smallest weight  reason choosing relation
smallest decomposition expected forward checking refines relations larger decomposition relations smaller decomposition  reduces
backtracking effort  global strategy  constrainedness constraint

determined adding weights neighboring relations



weight   idea behind strategy refining relation
restricted neighborhood  inconsistency detected faster refining
relation less restricted neighborhood 
order evaluate quality different heuristics  measured run time used
solving instances well number visited nodes search space  comparing
different approaches run time often reliable depends several
factors implementation algorithms  used hardware  current
load used machine makes results sometimes reproducible  reason 
ran run time experiments machine  sun ultra       mb
main memory  nevertheless  suggest use run time results mainly qualitatively
comparing different heuristics getting rough idea order magnitude
instances solved 
contrast this  number visited nodes solving instance particular
heuristic always every machine  allows comparing path
search space taken single heuristics judge heuristic makes better
choices average  however  take account time needed make
choice single node  computing local constrainedness constraint certainly
faster computing global constrainedness  similarly  computing constrainedness
statically faster computing dynamically  furthermore  larger instances
require time nodes smaller instances  computing path consistency
computing constrainedness  taking running time number visited nodes
together gives good indications quality heuristics 
choice make evaluating measurements aggregate
measurements single instances total picture  possibilities use
either average different percentiles median  i e       percentile 
  percentile value  
    obtained sorting measurements increasing
order picking measurement   element  i e     values less
value  suppose instances low value  e g  running time 
instances large value  average might larger values
almost instances  case median better indication distribution
values  case     percentile  instance  gives good indication
value hardest among  normal  instances  chosen use average
value measurements well distributed use         percentile
exceptional values distribution measurements 
xry

s 

r



xs z

zt

r

   





   empirical evaluation path consistency algorithm

since eciency backtracking algorithm depends eciency underlying
path consistency algorithm  first compare different implementations pathconsistency algorithm  previous empirical investigations  van beek   manchak       
   

fiefficient methods qualitative spatial reasoning

reasoning allen s interval relations  allen         different methods computing
composition two relations evaluated  mainly full composition
table interval relations contains                    entries  large
time stored main memory  setting  simply use composition
table specifies compositions rcc   relations          table
consuming approximately     kb main memory  means composition
two arbitrary relations done simple table lookup 
van beek manchak        studied effect weighting relations
queue according restrictiveness process restricting relation first 
restrictiveness measured base relation successively composing base
relation every possible label  summing cardinalities  i e   number base
relations contained result composition  suitably scaling result 
reason restricting relation restricts relations
average therefore decreases probability processed again 
restrictiveness complex relation approximated summing restrictiveness
involved base relations  van beek manchak        found method
weighting triples queue much ecient randomly picking arbitrary
triple  relatively small number rcc   relations  computed exact
restrictiveness composing relation every relation summing
cardinalities resulting compositions  scaled result weights    the
restricting relation      the least restricting relations  
gives us three different implementations path consistency algorithm  one
entries queue weighted  one approximated restrictiveness
done van beek manchak  one exact restrictiveness   order compare
implementations  randomly generated instances          regions 
value average degree ranging     stepping          generated
   different instances  figure   displays average cpu time different methods
applying path consistency algorithm generated instances 
seen positive effect using weighted queue much greater problem
temporal problem  about    faster using ordinary queue without
weights compared   faster  van beek   manchak          determining
weights every relation using exact restrictiveness much advantage
approximating restrictiveness using approach van beek manchak        
however  experiments always used  exact weights  method
determining restrictiveness amounts one table lookup 
mentioned previous section  one way measuring quality heuristics
count number visited nodes backtrack search  backtracking
algorithm  path consistency enforced every visited node  note adequate
multiply average running time enforcing path consistency instance
particular size number visited nodes order obtain approximation
required running time instance  average running time enforcing pathconsistency given figure   holds possible paths entered
queue beginning computation  see line   figure     paths
   weighted versions select path  i  k  j   queue q line   algorithm figure  
according weights different paths q computed specified above 

   

firenz   nebel

average cpu time pca using different queue methods a n d     
    
   

 exact  weights
 approx   weights
weights

cpu time  sec 

  
 
   
    
     
   

   

   

   

   
   
nodes

   

   

   

    

figure    comparing performance path consistency algorithm using different
methods weighting queue     instances data point             


 

 

checked algorithm  path consistency computation
backtracking search different  however  there  paths involving currently
changed constraint entered queue  since paths might result changes
constraint graph  much faster full computation path consistency
done beginning backtrack search 
   phase transition rcc  

randomly generating problem instances usually problem dependent parameter determines solubility instances  one parameter range instances
underconstrained therefore soluble high probability  another range 
problems overconstrained soluble low probability 
ranges phase transition region probability solubility changes abruptly
high low values  cheeseman et al          order study quality
different heuristics algorithms randomly generated instances np complete
problem  important aware phase transition behavior problem 
instances contained phase transition region often
easily solvable algorithms heuristics are  thus  useful
comparing quality  conversely  hard instances better suited comparing
quality algorithms heuristics usually found phase transition region 
section identify phase transition region randomly generated instances
rsat problem  instances using rcc   relations instances using
relations np    similarly empirical analysis qualitative temporal reasoning
problems  nebel         turns phase transition depends strongly
average degree nodes constraint graph  relations allowed  phased

   

fiefficient methods qualitative spatial reasoning

probability satisfiability a n d     

median cpu time a n d     
cpu time s 

probability    
   

   
   
   
   
   
   
 

  
   
  
  
   
    
     
average degree
     

  

nodes

   
  
  

   
    
     
average degree
     

  

  

nodes

  

figure    probability satisfiability median cpu time  
hb   static global heuristic      instances per data point 

n  d 

     using
 

transition around          depending instance size  see figure    
result theoretical analysis occurrence trivial aws  see section    
expected larger instance sizes phase transition behavior overlaid
mainly determined expected number locally inconsistent triples depends
average degree   thus  although seems phase transition shifts towards
larger values instance size increases  phase transition asymptotically
        theoretical value      see section     instances pathconsistent solved fast one application path consistency algorithm
without need backtracking  looking median cpu times given
figure    one notices sharp decline median cpu times phase
transition  indicates values average degree higher
phase transition occurs  least     instances path consistent 
using  hard  relations  i e   relations np    phase transition appears
higher values   namely             see figure     median
runtime shows  instances much harder phase transition former
case  previous case  even strongly  seems phase transition
shifts towards larger values instance size increases  phasetransition region narrows 
order evaluate quality path consistency method approximation
consistency  counted number instances inconsistent path consistent
 see figure     i e   instances approximation path consistency algorithm consistency wrong  first all  one notes instances close
phase transition region  general case  i e   constraints rcc   relations
employed  low percentage instances path consistent inconsistent 
therefore  figure looks erratic  data points would required order
obtain smooth curve  however  important observations made
figure  namely  path consistency gives excellent approximation consistency even
instances large size  except instances phase transition region 
almost instances path consistent consistent  picture changes










 

n









   

firenz   nebel

probability satisfiability h n d     

median cpu time h n d     

probability    

cpu time s 

   

 
   

  

 
  
  
  

   
     
     
average degree
     

  

   

  

 

nodes

   
     
     
average degree
     

  

  

nodes

  

figure    probability satisfiability median cpu time  
hb   static global heuristic      instances per data point 

h n  d 

percentage points incorrect pca answers a n d     

     using
 

percentage points incorrect pca answers h n d     

pc failures    
pc failures    
   
   

  
  
  
  
  
  
  
  
 

   
   
   

   

   

  
  

 
 

  

 

    
     
average degree
     

nodes

  
  
  

 

    
     
     
average degree
  

  

nodes

  

figure    percentage points incorrect answers path consistency algorithm
             
n  d 

 

h n  d 

 

looking        case  almost instances phase transition
region many instances mostly insoluble region path consistent  though
consistent 
following evaluation different heuristics randomly generate instances average degree                 case
                case  covers large area around
phase transition  expect instances phase transition region       
particularly hard makes interesting comparing quality
different heuristics 
h n  d 

 







h n  d 



n  d 

 

 

h n  d 

 

   empirical evaluation heuristics

section compare different heuristics running randomly
generated instances  instances        ran    different heuristics
n  d 

   

 

fiefficient methods qualitative spatial reasoning

number hard instances a n d     

number hard instances h n d     

 hard instances

 hard instances

  
 
 
 
 
 
 
 
 
 
 

   
   
   
   
   
   
   
   
  
 

   
  
  

   
    
     
     
average degree
  

  

nodes

  
  
  

   
     
     
average degree
     

  

nodes

  

figure    number instances using        visited nodes heuristic
             
n  d 

 

h n  d 

 

 static dynamic local global combined five split sets b bb hb   c  q   
randomly generated instances size             instances
       restricted instances      regions larger
ones appeared dicult 
first experiments found instances solved fast
less       visited nodes search space using one maximal tractable
subsets splitting  however  instances turned extremely hard  could
solved within limit   million visited nodes      hours cpu
time  therefore  ran programs maximal number        visited nodes
stored instances least one different heuristics used
       visited nodes experiments  see next section   call instances
hard instances  distribution hard instances shown figure    turned
heuristics using b split set heuristics using dynamic
global evaluation constrainedness many instances hard
combinations heuristics  we  therefore  include figure   hard instances
b dynamic global heuristic        hard instances heuristics
b dynamic global heuristic        
using b split set b 
figure   shows  almost hard instances phase transition region 
           instances per data point hard       
almost instances phase transition hard  altogether     hard instances
        out total number         generated instances         hard
instances         out total number         generated instances   table  
shows number hard instances heuristic except excluded
mentioned above  heuristics using hb   split set solve instances
heuristics using split sets  using c  q  split set seem
improvement using b b among different ways computing constrainedness  static
global appears effective combination using one maximal
tractable subsets split set  split sets  dynamic local seems
 

n

h n  d 

 

 

 

n

 

n

n  d 

 

h n  d 

n  d 

 

n  d 

 

 

h n  d 

h n  d 

 

   

 

firenz   nebel

heuristics

hb   sta loc
hb   sta glo
hb   dyn loc
hb   dyn glo
c   sta loc
c   sta glo
c   dyn loc
c   dyn glo
q   sta loc
q   sta glo
q   dyn loc
q   dyn glo
bb sta loc
bb sta glo
bb dyn loc
bb dyn glo
b sta loc
b sta glo
b dyn loc
b dyn glo
total

 

n  d 

    

  
  
  
   
  
  
  
   
  
  
  
   
  
  
  
   
   
   
   
     
   

 
    
       
       
      
       
       
       
       
       
       
       
       
       
       
       
       
 
 
 
 
 
       

h n  d 

h

               
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
 
 
 
 
   

table    number hard instances heuristic
effective combination combining dynamic global cases worst choice
respect number solved instances 
figure   compare         percentiles different heuristics
        give average run times since ran heuristics
       visited nodes reduces real average run time values  data point
average values           took average different degrees
order cover whole phase transition region     instances
size           instances size        different combinations
computing constrainedness  ordering run times different split
sets  b bb c  hb   q    run times using static local  static global  dynamic local
computing constrainedness almost combined split set
longer split sets using dynamic global  about   times longer
using bb split set     times longer using split sets  
    percentile run times     times longer     percentile run
times  thus  even harder among  normal  instances solved easily  i e   apart
hard instances  instances solved eciently within size range
analyzed  erratic behavior median curves results aggregation
effect observed figure    namely  median elements
phase transition inconsistent easily solvable 
n  d 

 







n



 

 

n

 

   

fiefficient methods qualitative spatial reasoning

median cpu time using static local a n d     

    percentile cpu time using static local a n d     

   

   
b split
b  split
c split
h   split
q split

   
   
   
   

  

  

  

  
  
nodes

  

  

  

   

   

  

median cpu time using static global a n d     

  

  

  

  
  
nodes

  

  

  

   

    percentile cpu time using static global a n d     

   

   
b split
b  split
c split
h   split
q split

   

b split
b  split
c split
h   split
q split

   
cpu time  sec 

   
cpu time  sec 

   

 
  

   
   
   

   
   
   
   

 

 
  

  

  

  

  
  
nodes

  

  

  

   

  

median cpu time using dynamic local a n d     

  

  

  

  
  
nodes

  

  

  

   

    percentile cpu time using dynamic local a n d     

   

   
b split
b  split
c split
h   split
q split

   

b split
b  split
c split
h   split
q split

   
cpu time  sec 

   
cpu time  sec 

   

   

 

   
   
   

   
   
   
   

 

 
  

  

  

  

  
  
nodes

  

  

  

   

  

median cpu time using dynamic global a n d     

  

  

  

  
  
nodes

  

  

  

   

    percentile cpu time using dynamic global a n d     

   

   
b split
b  split
c split
h   split
q split

   

b split
b  split
c split
h   split
q split

   
cpu time  sec 

   
cpu time  sec 

b split
b  split
c split
h   split
q split

   
cpu time  sec 

cpu time  sec 

   

   
   
   

   
   
   
   

 

 
  

  

  

  

  
  
nodes

  

  

  

   

  

  

  

  

  
  
nodes

  

  

  

   

figure    percentile         cpu time different heuristics solving
                             instances per data point 
n  d 

 



 



 

   

firenz   nebel

runtime studies        noticed many hard instances
    see figure          almost instances phase transition region
hard  see last column table     also  table   shows  number hard instances
varies lot different heuristics  therefore  possible compare percentile
running times different heuristics                see last column
table     instance          percentile element c  dynamic global
heuristic element no    element no     element no     element no    
hb   dynamic local heuristic  out     sorted elements   respectively 
reason show results size       see figure      again 
took average different degrees           order cover whole
phase transition region  order run times different combinations
computing constrainedness  b bb c  q  hb    hb   cases fastest 
       instances  run times dynamic global much longer
combinations      percentile run times static global combination
hb   q  dynamic local combination faster
combinations  although median cpu times       
    percentile     cpu times much longer  already shown figure  
   evidence hard instances phase transition
region        
h n  d 

n  

 

n

n  

n



n



 

n  d 



 

 

n  d 

 

n  

h n  d 

 

   orthogonal combination heuristics

previous section studied quality different heuristics solving randomly
generated rsat instances  found several instances mainly located
phase transition region could solved heuristics within limit       
visited nodes search space  since different heuristics different search space
 depending split set  use different path search space  determined
different possibilities computing constrainedness   possible instances
hard heuristics easily solvable heuristics  nebel        observed
running different heuristics parallel solve instances particular hard set
temporal reasoning instances proposed van beek manchak        single
heuristic alone solve  using altogether number visited nodes
heuristic alone  open question nebel s investigation  nebel        whether
case hard instances phase transition region 
section evaluate power  orthogonally combining  different heuristics
solving rsat instances  i e   running different heuristics instance parallel
one heuristics solves instance  different ways simulating
parallel processing single processor machine  one use time slicing
different heuristics  another run heuristics fixed random order
certain number nodes search space visited unsuccessful try next
heuristic  cf  huberman  lukose    hogg         possibility chosen
parameters  e g   order heuristics run number visited
nodes spent heuristic  determines eciency single processor
simulation orthogonal combination  order find best parameters  ran
heuristics using        visited nodes heuristic set hard instances
   

fiefficient methods qualitative spatial reasoning

median cpu time using static local h n d     

    percentile cpu time using static local h n d     

     

 
b split
c split
b  split
q split
h   split

cpu time  sec 

     
    

b split
c split
b  split
q split
h   split

 
cpu time  sec 

    

     
    
     
    

 

 

 

     
 

 
  

  

  

  
nodes

  

  

  

  

median cpu time using static global h n d     

  

  
nodes

  

  

  

    percentile cpu time using static global h n d     

     

 
b split
c split
b  split
q split
h   split

     
    

b split
c split
b  split
q split
h   split

 
cpu time  sec 

    
cpu time  sec 

  

     
    
     
    

 

 

 

     
 

 
  

  

  

  
nodes

  

  

  

  

median cpu time using dynamic local h n d     

  

  
nodes

  

  

  

    percentile cpu time using dynamic local h n d     

     

 
b split
c split
b  split
q split
h   split

     
    

b split
c split
b  split
q split
h   split

 
cpu time  sec 

    
cpu time  sec 

  

     
    
     
    

 

 

 

     
 

 
  

  

  

  
nodes

  

  

  

  

median cpu time using dynamic global h n d     

  

  
nodes

  

  

  

    percentile cpu time using dynamic global h n d     

     

 
b split
c split
b  split
q split
h   split

     
    

b split
c split
b  split
q split
h   split

 
cpu time  sec 

    
cpu time  sec 

  

     
    
     
    

 

 

 

     
 

 
  

  

  

  
nodes

  

  

  

  

  

  

  
nodes

  

  

  

figure     percentile         cpu time different heuristics solving
                              instances per data point 
h n  d 

 



 



 

   

firenz   nebel

a n  d      
heuristics solved instances    response
      
      
hb   sta loc
hb   sta glo
      
      
hb   dyn loc
      
      
hb   dyn glo
      
      
c   sta loc
      
     
c   sta glo
      
     
c   dyn loc
      
     
c   dyn glo
      
     
q   sta loc
      
     
q   sta glo
      
      
q   dyn loc
      
      
q   dyn glo
      
      
      
     
bb sta loc
bb sta glo
      
     
bb dyn loc
      
     
bb dyn glo
      
     
b sta loc
      
     
b sta glo
      
     
b dyn loc
      
     
b dyn glo
 
     
combined
      

h  n  d      
solved instances    response
      
     
      
      
      
      
      
      
      
     
      
     
      
     
      
     
      
     
      
     
      
     
      
     
      
     
      
     
      
     
 
     
 
     
 
     
 
     
 
     
      

table    percentage solved hard instances heuristic percentage first response orthogonally running heuristics  note sometimes different
heuristics equally fast  therefore sum      

identified previous section  those instances least one heuristic required
       visited nodes  compared behavior  since ran heuristics
instances already experiments previous section  evaluate
outcomes  led surprising result        instances  namely 
    hard instances except single one solved least one heuristics
using less        visited nodes  table   list percentage hard instances
could solved different heuristics percentage first response
running heuristics parallel  i e   heuristic required smallest
number visited nodes solving instance   turns heuristics using hb  
split set solve instances heuristics 
often fastest finding solution  although heuristics using two
maximal tractable subsets q  c  split set solve significantly instances
heuristics using b b much faster finding solution  despite solving
least number instances  heuristics using b split set cases
fastest producing solution 
n  d 

   

 

fiefficient methods qualitative spatial reasoning

first response solving hard instances a n d     

first response solving hard instances h n d     

  
   
number solved instances

number solved instances

inconsistent
consistent
  

  

 

inconsistent
consistent

   
   
   
   
   
   

 

 
 

  
   
    
minimal number visited nodes

     

 

  
   
    
minimal number visited nodes

     

figure     fastest solution hard instances running heuristics parallel
comparing minimal number visited nodes heuristics
hard instances  found five  which inconsistent  required
    visited nodes  particularly remarkable instances
phase transition region np hard problem  i e   instances usually
considered dicult ones  note                pathconsistent  instances inconsistent  much higher usual  cf  figure    
interestingly  inconsistent instances solved faster consistent
instances  point  noted combining heuristics orthogonally
similar randomized search techniques restarts  selman  levesque    mitchell        
however  contrast randomized search  method determine whether
instance inconsistent  figure    chart number hard instances solved
smallest number visited nodes respect solubility  due low number
hard instances         figure left looks bit ugly one least
approximate behavior curves comparing second figure
right curve         see below   oscillating behavior
inconsistent instances  more instances solved odd even number
visited nodes  might due sizes instances we generated instances
even number nodes only  dicult instance              solved
b static global heuristic using        visited nodes
inconsistent b 
heuristics using one maximal tractable subsets split set failed solve even
allowed visit            nodes search space 
examination set        hard instances              
instances could solved    different heuristics using        visited
nodes each  distribution shown figure    a   similar hard instances
        heuristics using hb   split set successful ones
solving hard instances         shown table    solved
hard instances heuristics produced fastest response
    hard instances  significant difference using c  q  bb
split set  neither number solved instances percentage first
response  previous case  computing constrainedness using static global
dynamic local heuristics resulted successful paths search space
n  d 

 

h n  d 

 

n

 d

h n  d 

n  d 

 

 

h n  d 

 

 

   

 

firenz   nebel

first response solving hard instances h n d     
number hard instances h n d      using orthogonal combination
inconsistent
consistent

 hard instances
   
  
  
  
  
 

  
  
  

   
     
     
average degree
     

nodes

number solved instances

   

  

  

  

  

  
 
     

     
     
     
number visited nodes

      

 a 
 b 
figure     hard instances using orthogonal combination heuristic        
 a  shows distribution   b  shows fastest solution using
        visited nodes per heuristic
h n  d 

 

instances solved within        visited nodes combinations 
average produced faster solutions combinations 
observations        made charting fastest solutions
hard instances         see figure                   solved
instances inconsistent  were  again  solved faster consistent
instances      hard instances solved     visited nodes 
    solved       visited nodes  since hb   dynamic local heuristic
alone solves     instances  seems dicult combine different heuristics
way hard instances solved using        visited
nodes altogether  however  orthogonally combining two best performing heuristics
 hb    dynamic local hb   static global  allowing maximal number      
visitable nodes  solve              hard instances 
tried solve       hard instances        solvable using
orthogonal combination heuristics        visited nodes using maximal
number         visited nodes      instances still solvable 
    solved instances inconsistent  fastest response solved instances
charted figure    b   successful heuristics giving fastest response
hb    dynamic local         hb   static global          three heuristics using
static global computation constrainedness combined using q  c  bb split
set gave fastest response       solved instances bb strategy
far best among three        
n  d 

h n  d 

 

 

h n  d 

 

 

 

   combining heuristics solving large instances

previous section found combining different heuristics orthogonally solve
instances using amount visited nodes heuristic alone solve 
section use results order identify size randomly generated instances
   

fiefficient methods qualitative spatial reasoning

almost them  especially phase transition region  still
solved acceptable time  since many instances        already dicult
size       see figure      restrict analysis instances       
study randomly generated instances size       nodes 
instances large size allowing maximal number        visited nodes
search space much obtaining acceptable runtime         visited nodes
instances size       corresponds runtime    seconds sun ultra  
larger instances gets much slower  therefore  restrict maximal number
visited nodes order achieve acceptable runtime  given multi processor machine 
different heuristics run orthogonally different processors using maximal
number visited nodes each  orthogonal combination different heuristics
simulated single processor machine  maximal number nodes divided
number used heuristics obtain available number visitable nodes
heuristic  thus  different heuristics use  less visitable nodes available
heuristic  therefore  order achieve best performance  find
combination heuristics solves instances within given number visitable
nodes  chosen heuristics solve many instances alone 
complement well  i e   instances cannot solved one heuristic
solvable heuristic 
started finding optimal combination heuristics set     hard
instances         empirical evaluation given section   know
many visited nodes heuristic needs order solve     hard instances 
therefore  computed number solved instances     possible combinations
heuristics using increasing maximal number visitable nodes heuristics
together  since tried find combination solves instances 
computed quite fast  results given table    show
good performance obtained maximal number     visited nodes 
case four heuristics involved  i e       visitable nodes spent four
heuristics  since combination heuristics  hb   static global  hb    dynamic local 
b static local  best       visitable nodes  choose
c  dynamic local  b 
combination analysis  choose order processed
b static local according
   hb   dynamic local     hb    static global     c  dynamic local     b 
first response behavior given table    note although two heuristics
b static local show particularly good performance
c  dynamic local b 
running alone  see table     seem best complement two heuristics 
find next maximal number visitable nodes spend
heuristics  ran best performing heuristic  hb   dynamic local  instances
phase transition region varying sizes  turned almost consistent
instances number visited nodes required solving slightly less twice
size instances inconsistent instances path consistent and 
thus  solvable one visited node  therefore  ran four heuristics
following allowing   visited nodes each  size instance  i e   together
allow   visitable nodes  randomly generated test instances according
       model size       regions size       regions
step    regions     instances size average degree ranging
h n  d 

 

n

n  d 

n

n

n  d 

 

n

n

n

n  d 

 

n

n

   

 

firenz   nebel

max nodes solved instances
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
   
    
   
    
   

combination heuristics
hb   d l
hb   s g
hb   s g  hb   d l
hb   s g  c   d l
hb   s g  hb   d l  c   d l
b
hb   s g  hb   d l  c   d l  b s l
b
b
b
h  s g  h  d l  c   d l  b s l
b
hb   s g  hb   d l  c   d l  b s l
b
b
b
h  s g  h  d l  c   d l  b s l
b b s g
b
hb   s g  hb   d l  c   d l  b s l 
b b s g
b
hb   s g  hb   d l  b s l 
b
b
b
h  s g  h  d l  b d l

table    best performance combining different heuristics solving     solvable hard
instances        fixed maximal number visited nodes
n  d 

 

probability satisfiability a n d     

probability    

average number visited nodes a n d     

visited nodes

   

    
   
   
   
   
   
   
   
   
   

  

   
    
     
average degree
     

   
   
   
   
   
    nodes
   
   

   
    
     
average degree
     

   
   
   
   
   
    nodes
   
   

figure     probability satisfiability             instances per data point 
average number visited nodes path consistent instances using
orthogonal combination four selected heuristics
n  d 

 

             step      total number         instances  since solving
large instances using backtracking requires lot memory  solved instances
sun ultra    gb main memory 
generated instances display phase transition behavior continues one
given figure    phase transition ranges                    
       see figure      apart     instances  instances generated solvable orthogonal combination four heuristics  hb    static global 
b static local  spending less  n visited nodes
hb   dynamic local  c  dynamic local  b 


 



 



n

   

 

n



 

fiefficient methods qualitative spatial reasoning

percentile     cpu time using orthogonal combination a n d     

percentile     cpu time using orthogonal combination a n d     
cpu time  s 

cpu time  s 
   
  
  
  
  
 
 

  
  

   
    
     
average degree
     

  

   
   
   
   
   
    nodes
   
   

  
 
   
    
     
average degree
     

   
   
   
   
   
    nodes
   
   

figure     percentile         cpu time orthogonal combination four different heuristics solving large randomly generated instances       
n  d 

 

each  figure    give average number visited nodes path consistent
instances  seen test instances average number visited nodes
linear size instances  percentile     cpu time instances
phase transition size       regions    seconds  percentile     cpu
time    seconds  size       regions  percentile     cpu time
less minute  see figure     
        test instances already solved hb   static global heuristic 
   instances hb   dynamic local heuristic required     instances
c  dynamic local heuristic produced solution  none     instances
b static local heuristic 
solved one three heuristics solved b 
tried solve instances using heuristics  using maximal number  
visited nodes each  best performing among heuristics c  dynamic global
heuristic solved        instances followed c   static global heuristic     
q   dynamic global heuristic         instances solved heuristic
within maximal number   visited nodes 
n

n

n

n

   discussion

empirically studied behavior solving randomly generated rsat instances using
different backtracking heuristics make use maximal tractable subsets
identified previous work  generated instances according two different models
 general model  allows     rcc   relations used  hard
model  allows relations contained maximal tractable
subsets  theoretical analysis two models showed model model
small average degree nodes constraint graph suffer trivial
local inconsistencies case similar generation procedures csps finite
domains  achlioptas et al          turned randomly generated instances
models show phase transition behavior depends strongly average
degree instances  instances outside phase transition region


h

h



   

firenz   nebel

solved eciently heuristics  instances phase transition region
extremely hard  instances general model  path consistent instances
consistent  conversely  path consistency bad approximation consistency
instances hard model  instances much harder solve instances
general model 
comparing different heuristics  found heuristics using one
maximal tractable subsets split set much faster deciding consistency
rsat instances theoretical advantage given reduced average branching factor
resulting exponentially smaller size search space indicates 
using path consistency forward checking method considerably reduces search space
cases  nevertheless  using one maximal tractable subsets split set 
particular hb    still leads much faster solution solves instances reasonable
time heuristics  although two maximal tractable subsets q  c 
contain relations hb     average branching factor lower  i e   using
hb   one decompose relations                 using two
sets        relations  respectively   hb   splits relations better
two sets  relations decomposed two hb   sub relations  many
relations must decomposed three c  sub relations three q  sub relations 
explains superior performance heuristics involving hb   decomposition 
among instances generated  stored could solved
heuristics within maximum number        visited nodes search space order
find different heuristics perform hard instances  found almost
hard instances located phase transition region many
hard instances hard model general model  orthogonally combined
heuristics ran hard instances  turned successful  apart
one instance  hard instances general model could solved 
low number visited nodes  hard instances hard model much
dicult  many could solved heuristics  nevertheless 
many instances solved orthogonally combining heuristics
heuristic alone  again  solved using low number visited nodes 
based observations orthogonally combining different heuristics  tried
identify combination heuristics successful eciently solving many
instances used combination solving large instances  turned
best combination involves heuristics use maximal tractable subsets decomposition  combination able solve almost randomly generated
instances phase transition region general model size       regions
eciently  seems impossible considering enormous size
search space  average         instances size       using hb  
split set 
results show despite np hardness  able solve almost randomly generated rsat instances general model eciently  neither due
low number different rcc   relations  instances generated according hard model
hard phase transition region  generation procedure random
instances lead trivially awed instances asymptotically  mainly due
maximal tractable subsets cover large fraction rcc   lead
n

n

   

fiefficient methods qualitative spatial reasoning

extremely low branching factors  since different maximal tractable subsets 
allow choosing many different backtracking heuristics increases
eciency  instances solved easily one heuristic  instances
heuristics  heuristics involving maximal tractable subclasses showed best behavior
instances solved faster tractable subsets used  full classification tractable subsets gives possibility generating hard instances high
probability  many randomly generated instances phase transition region
hard using relations contained tractable subsets
consist      regions  next step developing ecient reasoning
methods rcc   find methods successful solving hard
instances hard model 
n

results empirical evaluation reasoning rcc   suggest analyzing
computational properties reasoning problem identifying tractable subclasses
problem excellent way achieving ecient reasoning mechanisms  particular
maximal tractable subclasses used develop ecient methods solving
full problem since average branching factor lowest  using refinement
method developed renz s        paper  tractable subclasses set relations forming
relation algebra identified almost automatically  method makes easy
develop ecient algorithms  indication empirical evaluation
much effective  even especially hard instances phase transition
region  orthogonally combine different heuristics try get final epsilon
single heuristic  answers question raised nebel        whether orthogonal
combination heuristics useful phase transition region  experiments
lead much better results even simulating orthogonal combination different
heuristics single processor machine spending altogether resources
one heuristic alone  contrast method time slicing different
heuristics  started new heuristic previous heuristic failed certain
number visited nodes search space  order ran heuristics
depended performance well complemented other 
successful heuristics used first  similar using algorithm portfolios proposed
huberman et al          heuristics perform better combination
successful one matter empirical evaluation depends particular
problem  heuristics depending maximal tractable subclasses  however  lead
best performance 
csps finite domains many theoretical results localizing
phase transition behavior predicting hard instances located  contrast this  basically theoretical results csps infinite domains
used spatial temporal reasoning  initial theoretical analysis shows  theoretical results csps finite domains necessarily extend csps infinite
domains  would interesting develop general theory csps
infinite domains  possibly similar williams hogg s  deep structure   williams  
hogg        gent et al  s  kappa  theory  gent  macintyre  prosser    walsh        
   

firenz   nebel
acknowledgments

would thank ronny fehling assistance developing programs  malte
helmert proof reading paper  three anonymous reviewers
helpful comments 
research supported dfg part project fast qual space 
part dfg special research effort  spatial cognition   first author
partially supported marie curie fellowship european community programme
 improving human potential  contract number hpmf ct             preliminary version paper appeared proceedings   th european conference
artificial intelligence  renz   nebel        
references

achlioptas  d   kirousis  l   kranakis  e   krizanc  d   molloy  m     stamatiou  y         
random constraint satisfaction  accurate picture   rd conference
principles practice constraint programming  cp      vol       lncs  pp 
         springer verlag 
allen  j  f          maintaining knowledge temporal intervals  communications
acm                   
bennett  b          spatial reasoning propositional logic  doyle  j   sandewall 
e     torasso  p   eds    principles knowledge representation reasoning 
proceedings  th international conference  pp         bonn  germany  morgan
kaufmann 
bennett  b          logical representations automated reasoning spatial relationships  ph d  thesis  school computer studies  university leeds 
cheeseman  p   kanefsky  b     taylor  w  m          really hard problems are 
proceedings   th international joint conference artificial intelligence 
pp           sydney  australia  morgan kaufmann 
gent  i   macintyre  e   prosser  p   smith  b     walsh  t          random constraint
satisfaction  flaws structure  constraints                 
gent  i   macintyre  e   prosser  p     walsh  t          constrainedness search 
proceedings   th national conference ai  aaai      pp          
golumbic  m  c     shamir  r          complexity algorithms reasoning time 
graph theoretic approach  journal association computing machinery 
                  
grigni  m   papadias  d     papadimitriou  c          topological inference  proceedings
  th international joint conference artificial intelligence  pp          
montreal  canada 
   

fiefficient methods qualitative spatial reasoning

haralick  r  m     elliot  g  l          increasing tree search eciency constraint
satisfaction problems  artificial intelligence              
huberman  b   lukose  r     hogg  t          economics approach hard computational problems  science             
ladkin  p  b     reinefeld  a          effective solution qualitative interval constraint
problems  artificial intelligence                  
ladkin  p  b     reinefeld  a          fast algebraic methods interval constraint problems  annals mathematics artificial intelligence           
mackworth  a  k          consistency networks relations  artificial intelligence    
       
mackworth  a  k     freuder  e  c          complexity polynomial network
consistency algorithms constraint satisfaction problems  artificial intelligence     
      
montanari  u          networks constraints  fundamental properties applications
picture processing  information science            
nebel  b          computational properties qualitative spatial reasoning  first results 
wachsmuth  i   rollinger  c  r     brauer  w   eds    ki     advances artificial
intelligence  vol      lecture notes artificial intelligence  pp           bielefeld 
germany  springer verlag 
nebel  b          solving hard qualitative temporal reasoning problems  evaluating
eciency using ord horn class  constraints                 
randell  d  a   cohn  a  g     cui  z       a   computing transitivity tables  challenge
automated theorem provers  proceedings   th cade  springer verlag 
randell  d  a   cui  z     cohn  a  g       b   spatial logic based regions
connection  nebel  b   swartout  w     rich  c   eds    principles knowledge
representation reasoning  proceedings  rd international conference  pp 
         cambridge  ma  morgan kaufmann 
renz  j          maximal tractable fragments region connection calculus  complete analysis  proceedings   th international joint conference artificial
intelligence  pp           stockholm  sweden 
renz  j          qualitative spatial reasoning topological information  ph d  thesis 
institut fur informatik  albert ludwigs universitat freiburg 
renz  j     nebel  b          ecient methods qualitative spatial reasoning  proceedings   th european conference artificial intelligence  pp           amsterdam  netherlands  wiley 
   

firenz   nebel

renz  j     nebel  b          complexity qualitative spatial reasoning  maximal
tractable fragment region connection calculus  artificial intelligence                   
selman  b   levesque  h  j     mitchell  d          new method solving hard satisfiability problems  proceedings   th national conference american
association artificial intelligence  pp           san jose  ca  mit press 
van beek  p     manchak  d  w          design experimental analysis algorithms
temporal reasoning  journal artificial intelligence research          
williams  c  p     hogg  t          exploiting deep structure constraint problems 
artificial intelligence             

   


