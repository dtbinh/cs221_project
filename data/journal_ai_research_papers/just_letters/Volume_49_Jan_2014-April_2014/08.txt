journal of artificial intelligence research                  

submitted        published      

algorithms for argumentation semantics  labeling attacks as a
generalization of labeling arguments
samer nofal

s amer  n ofal   gju   edu   jo

dept  of computer science  german jordanian university
p o  box        amman        jordan

katie atkinson
paul e  dunne

k m atkinson   liverpool   ac   uk
p e d unne   liverpool   ac   uk

dept  of computer science  university of liverpool
ashton street  liverpool l    bx  united kingdom

abstract
a dung argumentation framework  af  is a pair  a  r   a is a set of abstract arguments and
r  a  a is a binary relation  so called the attack relation  for capturing the conflicting arguments  labeling based algorithms for enumerating extensions  i e  sets of acceptable arguments 
have been set out such that arguments  i e  elements of a  are the only subject for labeling  in
this paper we present implemented algorithms for listing extensions by labeling attacks  i e  elements of r  along with arguments  specifically  these algorithms are concerned with enumerating
all extensions of an af under a number of argumentation semantics  preferred  stable  complete 
semi stable  stage  ideal and grounded  our algorithms have impact  in particular  on enumerating
extensions of af extended models that allow attacks on attacks  to demonstrate this impact  we
instantiate our algorithms for an example of such models  namely argumentation frameworks with
recursive attacks  afra   thereby we end up with unified algorithms that enumerate extensions of
any af   afra 

   introduction
computational argumentation  covering its theory and applications  has attracted major attention in
the ai research community  notably in the last twenty years  e g  bench capon   dunne       
besnard   hunter        rahwan   simari        modgil  toni  bex  bratko  chesnevar  dvorak 
falappa  fan  gaggl  garca  gonzalez  gordon  leite  mozina  reed  simari  szeider  torroni   
woltran         dungs abstract argumentation frameworks  afs   dung        are a widely studied
model in which an af is described by a pair  a  r   a is a set of abstract arguments and r  aa is a
binary relation  so called the attack relation  to represent the conflicting arguments  a central notion
in afs is an argumentation semantics  a set of criteria that characterise the acceptable arguments 
we define these criteria rigorously in section    for different reasons a number of argumentation
semantics have been proposed in the literature  explaining these reasons in detail is out of the scope
of this paper  however  see the work of baroni  caminada  and giacomin      a  for an excellent
introduction to argumentation semantics 
under various argumentation semantics  one might find multiple distinct extensions  defined in
section     labeling based algorithms  e g  dimopoulos  magirou    papadimitriou        doutre
  mengin        modgil   caminada        for listing all extensions have been developed such
that arguments  i e  elements of a  are the only target to be labeled  in this paper we illustrate how to
enumerate extensions under several argumentation semantics by labeling attacks  i e  elements of r 
c
    
ai access foundation  all rights reserved 

fin ofal   atkinson     d unne

along with arguments  instead of labeling arguments solely  this is particularly of interest in listing
extensions of af extended formalisms that allow attacks on attacks  e g  modgil      b  gabbay 
      baroni  cerutti  giacomin    guida      b   as we show throughout the paper  the term
labeling based algorithms for argumentation semantics is distinguished from the common term
labeling based semantics  although both concepts involve a labeling mapping  the former term
 i e  labeling based algorithms  refers to the course of actions by which an extension enumeration
process classifies arguments  those which might be in an extension from those which are excluded
from the respective extension  this classification is essential in order to construct all concrete
extensions of a given af  the later term  i e  labeling based semantics  refers to an approach to
describing  i e  not constructing  extensions using a labeling mapping 
in section   we provide necessary background materials  in section   we review explicit algorithms for a selection of dominant argumentation semantics  preferred  stable  complete  semi
stable  stage  ideal and grounded  these algorithms list extensions by labeling arguments only 
then in section   we develop  under the respective argumentation semantics  definite algorithms
for enumerating extensions of an argumentation framework with recursive attacks  afra   an afextended model that allows attacks on attacks  baroni et al       b   these algorithms construct
extensions by labeling attacks together with arguments  since an af is a special case of afra  baroni et al       b   the developed algorithms for afra also list extensions of an af  in section   we
report on experiments concerning the practical efficiency of the algorithms  section   concludes the
paper with a summary and a review of related work 

   preliminaries
we start with the definition of dungs argumentation frameworks  dung        
definition     dungs argumentation frameworks 
an argumentation framework  or af  is a pair  a  r  where a is a set of arguments and r  a  a
is a binary relation 
we refer to  x  y   r as x attacks y  or y is attacked by x   we denote by  x  respectively
the subset of a containing those arguments that attack  resp  are attacked by  the argument x 
extending this notation in the natural way to sets of arguments  so that for s  a 
 x  

s
s 

 
 

  y  a    x  s s t  y   x   
  y  a    x  s s t  y   x    

given a subset s  a  then
 x  a is acceptable w r t  s if and only if for every  y  x   r  there is some z  s for which
 z  y   r 
 s is conflict free if and only if for each  x  y   s  s   x  y  
  r 
 s is admissible if and only if it is conflict free and every x  s is acceptable w r t  s 
 s is a preferred extension if and only if it is a maximal  w r t    admissible set 
 s is a stable extension if and only if it is conflict free and s    a   s 
   

fia lgorithms for a rgumentation s emantics

figure    an argumentation framework 
 s is a complete extension if and only if it is an admissible set such that for each x acceptable
w r t  s  x  s 
 s is a stage extension if and only if it is conflict free and s  s  is maximal  w r t    
 s is a semi stable extension if and only if it is admissible and s  s  is maximal  w r t    
 s is the ideal extension if and only if it is the maximal  w r t    admissible set that is contained in every preferred extension 
 s is the grounded extension if and only if it is the least fixed point of f t      x  a  
x is acceptable w r t  t   
preferred  complete  stable and grounded semantics are introduced in the work of dung        
whereas stage semantics  ideal semantics and semi stable semantics are presented in the papers
of verheij         dung  mancarella  and toni        and caminada  carnielli  and dunne       
respectively  to give an example  consider the framework depicted in figure   where nodes represent
arguments and edges correspond to attacks  i e  elements of r   for this example  b  d  is the
preferred  grounded  stable  ideal  complete  semi stable and stage extension  note that we do not
intend by this example to show differences between semantics 
offering an explicit means to weaken attacks  the formalisms of modgil      b   gabbay
       and baroni et al       b  extend afs such that attacks  i e  elements of r  are subject
to attacks themselves  we present extension enumeration algorithms for an instance of such formalisms  namely argumentation frameworks with recursive attacks  afra  introduced by baroni et
al       b  
definition    an argumentation framework with recursive attacks  afra  is a pair  a  r  where a
is a set of arguments and r is a set of pairs  x  y  such that x  a and  y  a or y  r  
let x    y  z   r then we say that y is the source of x  denoted as src x    y  and z is the target
of x  denoted as trg x    z 
let x  a  r and y  r then we say that y directly de f eats x if and only if x   trg y  
let x  y  r then we say y indirectly de f eats x if and only if src x    trg y  
let x  a  r and y  r  we say y de f eats x if and only if y directly or indirectly defeats x 
given a subset s  a  r  then
 s is conflict free if and only if there does not exist x  y  s s t  x defeats y 
 an element x  a  r is acceptable w r t  s if and only if for each y  r   y defeats x  there is
some z  s such that z defeats y 
 s is admissible if and only if s is conflict free and for each x  s  x is acceptable w r t  s 
   

fin ofal   atkinson     d unne

figure    an argumentation framework with recursive attacks 
 s is a preferred extension if it is a maximal  w r t    admissible set 
  s  there
 s is a stable extension if and only if it is conflict free and for each x  a  r   x 
exists y  s such that y de f eats x 
 s is a complete extension if and only if it is admissible and every element of a  r  which is
acceptable w r t  s  belongs to s 
 s is a stage  resp  semi stable  extension if and only if s is conflict free  resp  admissible  and
s   x   y  s s t  y defeats x  is maximal  w r t    
 s is the ideal extension if and only if it is the maximal  w r t    admissible set that is contained in every preferred extension 
 s is the grounded extension if and only if it is the least fixed point of f t      x  a  r  
x is acceptable w r t  t   
referring to figure     b  d  h  e  is the grounded  stable  preferred  ideal  complete  stage and
semi stable extension 
we consider now the issue of expressing an afra as an af  let h    a  r  be an afra 
then the corresponding af h     a   r   is defined such that a   a  r and r     x  y    x  y 
a  r and x de f eats y   for example  the corresponding af of the afra depicted in figure   is
described by a    b  c  d  e  f   g  h  and r     e  g     f   e    g  e    g  d    h  c    h  f     h  g   

   algorithms for a selection of argumentation semantics
in this section we review explicit algorithms that list  under a number of argumentation semantics 
all extensions of an af by labeling arguments solely  particularly  in subsection     we recall the
algorithm of nofal  atkinson and dunne        for preferred semantics  in section     we present
a new implementation of the algorithm of dimopoulos et al         for stable semantics  then
we modify the algorithm of nofal  atkinson and dunne        to produce specific algorithms for
complete  stage  semi stable and ideal semantics in subsections               and     respectively 
in subsection     we present an implementation for building the grounded extension 
    enumerating preferred extensions of any af
algorithm   lists all preferred extensions of an af  algorithm   is taken from the work of nofal 
atkinson and dunne        where it has been shown that the algorithm is likely to be more efficient
than the algorithms of doutre and mengin         and modgil and caminada         we recall
   

fia lgorithms for a rgumentation s emantics

algorithm   because other implemented algorithms of the present paper can be seen as an extension
of this algorithm  the algorithm is a backtracking procedure that traverses an abstract binary search
tree  a core notion of the algorithm is related to the use of five labels  in  out  must out 
blank and undec  informally  the in label identifies arguments that might be in a preferred
extension  the out label identifies an argument that is attacked by an in argument  the blank
label is for any unprocessed argument whose final label is not decided yet  the must out label
identifies arguments that attack in arguments  the undec label designates arguments which might
not be included in a preferred extension because they might not be defended by any in argument 
to enumerate all preferred extensions algorithm   starts with blank as the default label for all
arguments  this initial state represents the root node of the search tree  then the algorithm forks to
a left  resp  right  child  i e  state  by picking an argument  that is blank  to be labeled in  resp 
undec   every time an argument  say x  is labeled in some of the neighbour arguments labels
might change such that for every y   x   the label of y becomes out and for every z   x    x  
the label of z becomes must out  this process  i e  forking to new children  continues until for
every x  a the label of x is not blank  at this point  the algorithm captures a preferred extension
if and only if for every x  a the label of x belongs to  in out undec  and  x   the label of x is
in  is not a subset of a previously found preferred extension  if such exists   then the algorithm
backtracks to try to find all preferred extensions  it is important in these kinds of algorithms to
exploit properties whereby we might bypass expanding a child of the search tree  thus considerable
time might be saved  algorithm   uses two pruning properties 
   algorithm    lines        skips labeling an argument y in  i e  skips expanding a left child 
if and only if there is z   y  such that the label of z is not out while there is no w   z 
with the blank label  in other words  such z can not be labeled out later while for each
w   z  the label of w is out  must out or undec  thus  it is more efficient to skip
trying to include any argument that is attacked by such z in a preferred extension 
   algorithm    lines        skips labeling an argument y undec  i e  skips expanding a right
child  if and only if for every z   y  the current label of z is out or must out  this
is because if an admissible set  say s  is constructed while such y is undec then s   y  is
admissible also  recall that preferred extensions are the maximal admissible sets  hence no
need to label such y undec 
another fundamental issue to take into account is the selection of blank arguments that are
to be labeled in  the point behind adopting a selection strategy is to try to achieve a preferred extension more efficiently  this is critical when the problem is about constructing only one extension 
therefore  algorithm    line    applies the following selection options 
   algorithm   tries to select first a blank argument  say y  that is not attacked at all or is
attacked by out must out arguments only  the justification of this selection is related to
the second pruning property used by the algorithm  note that the earlier we pick such y to be
labeled in  the bigger part of the search tree to be avoided  recall that such y will not lead to
expanding a right child according to the second pruning property 
   otherwise the algorithm picks up a blank argument  say y  such that   z   z   y   and
the label of z is not out   is maximal  the intuition is that maximising the number of
out arguments will minimise the number of blank must out arguments  thus  the
   

fin ofal   atkinson     d unne

figure    enumerating preferred extensions of an af using algorithm   
new generated state  i e  child   due to selecting such y  is much closer to the state where
a preferred extension is captured  recall that a preferred extension is achieved if and only if
for each x  a the label of x is in  out or undec 
algorithm    like all algorithms in this paper  is self contained and self explanatory  figure   
however  illustrates algorithm   running on an af 
    enumerating stable extensions of any af
algorithm   lists all stable extensions  algorithm   can be seen as a new implementation of the
algorithm of dimopoulos et al          algorithm   differs from algorithm   in two ways 
   

fia lgorithms for a rgumentation s emantics

algorithm    enumerating all preferred extensions of an af  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out  must out undec  blank   lab    
 
foreach x  a do lab  lab    x  blank   
e pre f erred   a   e pre f erred    
 
call find preferred extensions lab  
report e pre f erred is the set of all preferred extensions 
procedure find preferred extensions lab  begin
while y  a   lab y    blank do
select y with lab y    blank and z   y  lab z    out  must out   
otherwise select y with lab y    blank s t  z  a   lab z    blank    x   x 
 y    lab x    out       x   x   z    lab x    out    
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    undec  blank  then
lab  z   must out  
if  w   z    lab  w    blank then
lab y   undec 
goto line   
call find preferred extensions lab   
if z   y    lab z    blank undec  then
lab y   undec 
else
lab  lab  
if  x   lab x    must out then
s   x   lab x    in  
if  t  e pre f erred   s  t then e pre f erred  e pre f erred   s  
end procedure

   

fin ofal   atkinson     d unne

   algorithm   uses four labels  in  out  blank and must out  the usage of these labels
is as outlined in algorithm   with one distinction  the role of the undec label used in algorithm   is now overloaded to the must out label  meaning  in algorithm   the must out
label is used also for labeling an argument  say x  trying to build a stable extension without x 
this is because any argument  say x  outside a candidate stable extension should be attacked
by an argument in the extension  hence x should be labeled must out  not undec as it is
the case in algorithm    
   in algorithm    p    w   the label of w is in  is a preferred extension if and only if for each
x  a  the label of x is not blank nor must out and p is not a subset of a previously
found preferred extension  in algorithm    line     the set  w   the label of w is in  is a stable
extension if and only if for every x  a  the label of x is not blank nor must out 
algorithm    enumerating all stable extensions of an af  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out  must out  blank   lab    
 
foreach x  a do lab  lab    x  blank   
estable   a   estable    
 
call find stable extensions lab  
report estable is the set of all stable extensions 
procedure find stable extensions lab  begin
while y  a   lab y    blank do
select y with lab y    blank and z   y  lab z    out  must out   
otherwise select y with lab y    blank s t  z   lab z    blank    x   x 
 y    lab x    out       x   x   z    lab x    out    
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    blank then
lab  z   must out  
if w   z  lab  w    blank then
lab y   must out  
goto line   
call find stable extensions lab   
if z   y    lab z    blank then
lab y   must out  
else
lab  lab  
if x   lab x    must out then
s   x   lab x    in  
estable  estable   s  
end procedure

   

fia lgorithms for a rgumentation s emantics

    enumerating complete extensions of any af
algorithm   lists all complete extensions  algorithm   is a modification of algorithm   that enumerates preferred extensions  in algorithm    p    w   the label of w is in  is a preferred extension
if and only if for each x  a  the label of x is not blank nor must out and p is not a subset of
a previously found preferred extension  in algorithm    line     the set  w   the label of w is in  is
a complete extension if and only if
c   for every x  a  the label of x is not must out and
c   there is no z with undec  or blank  label such that for every y   z  the label of y is
out 
recall that a complete extension is an admissible set s such that for every x acceptable with respect
to s  x belongs to s  thus  the condition c  ensures admissibility while c  guarantees completeness 
    enumerating stage extensions of any af
algorithm   lists all stage extensions  algorithm   is an alteration of algorithm   that enumerates
preferred extensions  algorithm   uses four labels  in  out  undec and blank  the usage of
these labels is as outlined in algorithm   with one distinction  the role of the must out label used
in algorithm   is now overloaded to the undec label  meaning  in algorithm   the undec label is
used also for identifying arguments that attack an in argument  this is because any argument attacks
an argument of a stage extension is not necessarily attacked by an argument of the extension 
algorithm   constructs conflict free subsets of a  in particular  algorithm    line     keeps a
record of the conflict free set  w   the label of w is in  if and only if for each x  a  the label of
x is not blank  after constructing such conflict free subsets  algorithm   decides that a conflict
free subset  say s  is a stage extension if and only if s  s  is maximal  see lines      as might
be expected  argument selection and pruning strategies used in admissibility based semantics will
not be applicable to stage semantics  which are based on conflict free sets  therefore  as a pruning
strategy we skip labeling an argument  say y  undec if and only if for each z   y     y    the
label of z is out or undec  this is based on the following property  if a conflict free set  say s 
will be captured while such y is undec then s   y  is also conflict free  and hence  there is no
need to label y with undec since s   y   s  recall that algorithm   labels an argument undec
trying to build a stage extension excluding the argument  on selecting the next blank argument
to be labeled in  we consider the rule 
r   select a blank argument y s t  for each z   y     y    the label of z is out or undec 
r   otherwise select a blank argument y such that   x   x   y     y  and the label of x is
blank   is maximal 
note the correlation between r  and the applied pruning strategy  the earlier we label the
argument selected by r  with in  the bigger the part of the search tree that will be bypassed 
regarding the benefit of r   recall that the aim of argument selection is to accelerate achieving a
goal state  which is a conflict free subset s such that s  s  is maximal and there is no x  a with the
blank label  indeed  r  minimises the number of blank arguments by maximising the number
of out undec arguments 
   

fin ofal   atkinson     d unne

algorithm    enumerating all complete extensions of an af  a  r  
 
 
 
 
 

 
 
 
 
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out  must out undec  blank   lab    
 
foreach x  a do lab  lab    x  blank   
ecomplete   a   ecomplete    
 
call find complete extensions lab  
report ecomplete is the set of all complete extensions 
procedure find complete extensions lab  begin
if  y  a   lab y    must out then
if  x   lab x    undec  blank   z   x  lab z    out then
s   w  a   lab w    in  
ecomplete  ecomplete   s  
while y  a   lab y    blank do
select y with lab y    blank and z   y  lab z    out  must out   
otherwise select y with lab y    blank s t  z  a   lab z    blank    x   x 
 y    lab x    out       x   x   z    lab x    out    
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    undec  blank  then
lab  z   must out  
if  w   z    lab  w    blank then
lab y   undec 
goto line    
call find complete extensions lab   
if z   y    lab z    blank undec  then
lab y   undec 
else
lab  lab  
end procedure

   

fia lgorithms for a rgumentation s emantics

algorithm    enumerating all stage extensions of an af  a  r  
 
 
 
 
 
 
 
 
 
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out undec  blank   lab    
 
foreach x  a do lab  lab    x  blank   
estage   lab    lab    a   in  out undec  blank    estage    
 
call find conflict free sets lab  
foreach lab   estage do
foreach lab   estage do
if  x   lab   x    in  out       z   lab   z    in  out    then
estage  estage    lab    
continue to next iteration from line   
foreach lab   estage do
report  x   lab   x    in  is a stage extension  
procedure find conflict free sets lab  begin
while y  a   lab y    blank do
select y with lab y    blank such that z   y     y  lab z    out undec  
otherwise select y with lab y    blank such that z   lab z    blank    x   x 
 y     y   lab x    blank      x   x   z     z   lab x    blank   
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    blank  then
lab  z   undec 
call find conflict free sets lab   
if z   y     y  with lab z    blank then
lab y   undec 
else
lab  lab  
estage  estage   lab  
end procedure

   

fin ofal   atkinson     d unne

    enumerating semi stable extensions of any af
algorithm   enumerates all semi stable extensions  again  algorithm   is a reproduction of algorithm    actually  algorithm   firstly builds admissible sets  then  the algorithm decides that an
admissible set  say s  is a semi stable extension if and only if s  s  is maximal  see lines      

algorithm    enumerating all semi stable extensions of an af  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out  must out undec  blank   lab    
 
foreach x  a do lab  lab    x  blank   
esemistable   lab    lab    a   in  out  must out undec  blank   
esemistable    
 
call find admissible sets lab  
foreach lab   esemistable do
foreach lab   esemistable do
if  x   lab   x    in  out       z   lab   z    in  out    then
esemistable  esemistable    lab    
continue to next iteration from line   
foreach lab   esemistable do
report  x   lab   x    in  is a semi stable extension  
procedure find admissible sets lab  begin
while y  a   lab y    blank do
select y with lab y    blank and z   y  lab z    out  must out   
otherwise select y with lab y    blank s t  z  a   lab z    blank    x   x 
 y    lab x    out       x   x   z    lab x    out    
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    undec  blank  then
lab  z   must out  
if  w   z    lab  w    blank then
lab y   undec 
goto line    
call find admissible sets lab   
if z   y    lab z    blank undec  then
lab y   undec 
else
lab  lab  
if  x  a   lab x    must out then
esemistable  esemistable   lab  
end procedure

   

fia lgorithms for a rgumentation s emantics

    constructing the ideal extension of any af
algorithm   builds the ideal extension  the algorithm is a modification of algorithm    algorithm  
 line     records  w   the label of w is in  as an admissible set if and only if for each x  a  the label
of x is not blank nor must out  however  the algorithm also constructs  line     s    x  a  
there exists an admissible set t such that x  t      after building a set of admissible sets and
having s constructed  algorithm   considers an admissible set i as the ideal extension if and only
if i  s     
  see lines      recall that the ideal extension is the maximal  w r t    admissible
set that is contained in every preferred extension  satisfying the condition i  s      implies that
the arguments of i are not attacked by any admissible set  see the definition of s above   which
means i is contained in every preferred extension  to ensure such i is maximal  algorithm   collects
admissible sets in descending order  from larger sets to smaller ones  in consequence  the algorithm
checks the collected admissible sets with the condition i  s      starting from larger admissible sets
to smaller ones 
    constructing the grounded extension of any af
algorithm   can be viewed as another implementation of the algorithm described by modgil and
caminada        for building the grounded extension 

   labeling attacks as a generalization of labeling arguments
in this section we illustrate how to enumerate extensions  under a number of argumentation semantics  by labeling attacks together with arguments instead of labeling arguments solely  to this end 
we develop algorithms for listing extensions of an afra  baroni et al       b  under preferred 
stable  complete  stage  semi stable  ideal and grounded semantics in subsections                    
         and     respectively  all these algorithms are basically a generalization of the algorithms
presented in the previous section  hence these algorithms list extensions of any af   afra 
    enumerating preferred extensions of any af   afra
algorithm   enumerates all preferred extensions of an afra  algorithm   is a generalization of
algorithm    the idea is based on using five labels  in  out  must out  blank and undec 
the blank label is the initial label for all arguments and attacks  a blank attack y  r is labeled
in to indicate that y might be in a preferred extension  an argument x is labeled out if and only if
there is y  r with the label in such that trg y    x  an attack z  r is labeled out if and only if
there is y  r with the label in such that trg y    z  src z    a blank argument x is labeled in 
implying that x might be in a preferred extension  if and only if there is y  r with the label in such
that src y    x or for each z  r   trg z    x the label of z is out  an attack y is labeled undec to
try to find a preferred extension excluding y  an attack z with the label blank undec is labeled
must out if and only if there is y  r with the label in such that trg z    y  src y    every
time an attack is labeled in the labels of some attacks and arguments might change accordingly  see
lines       of algorithm    as a selection rule  line   represents the strategy by which the algorithm
selects the next attack  that is blank  to be labeled in  the rule and its grounds is in parallel to
the selection rule applied in algorithm   for enumerating preferred extensions of an af  likewise 
algorithm   applies two pruning tactics 
   

fin ofal   atkinson     d unne

algorithm    constructing the ideal extension of an af  a  r  
 
 
 
 
 
 
 
 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab   a   in  out  must out undec  blank   lab    
 
foreach x  a do lab  lab    x  blank   
eideal   z   a   eideal    
 
s    
 
call find admissible sets lab  
foreach i         eideal   do
if eideal  i   s      then
report eideal  i  is the ideal extension  exit 
procedure find admissible sets lab  begin
while y  a   lab y    blank do
select y with lab y    blank and z   y  lab z    out  must out   
otherwise select y with lab y    blank s t  z  a   lab z    blank    x   x 
 y    lab x    out       x   x   z    lab x    out    
lab  lab 
lab  y   in 
foreach z   y   do lab  z   out  
foreach z   y  do
if lab  z    undec  blank  then
lab  z   must out  
if  w   z    lab  w    blank then
lab y   undec 
goto line    
call find admissible sets lab   
if z   y    lab z    blank undec  then
lab y   undec 
else
lab  lab  
if  w  a   lab w    must out then
s  s   x   lab x    out   
eideal  eideal     eideal         z   lab z    in    
end procedure

algorithm    constructing the grounded extension of an af  a  r  
 
 
 
 
 
 
 

lab   a   in  out undec   lab    
 
foreach w  a do lab  lab    w undec   
while x with lab x    undec   y   x  lab y    out do
foreach x with lab x    undec   y   x  lab y    out do
lab x   in 
foreach z   x   do lab z   out  
report the grounded extension is  w   lab w    in  

   

fia lgorithms for a rgumentation s emantics

figure    how algorithm   works on an afra 
   algorithm    lines         skips labeling an attack y in  i e  skips expanding a left child  if
and only if
z   trg z    y  src y   and the label o f z is not out and
  w with the label blank   trg w    z  src z   
   algorithm    lines         skips labeling an attack y undec  i e  skips expanding a right
child  if and only if for each z  r   trg z    y  src y    the label of z is out or must out 
to get the general idea of algorithm   see figure   that shows how the algorithm works on the
afra depicted in figure   
    enumerating stable extensions of any af   afra
algorithm   enumerates all stable extensions  actually  algorithm   is a modification of algorithm  
that lists preferred extensions  however there are two differences 
   algorithm   uses four labels  in  out  blank and must out  the usage of these labels
is as outlined in algorithm   with one difference  the role of the undec label used in algorithm   is now overloaded to the must out label  that is  in algorithm   the must out
label is used also for labeling an attack  say x  trying to build a stable extension without x 
this is because any attack  say x  outside a candidate stable extension should be defeated by
an attack in the extension  hence x should be labeled must out 
   in algorithm   we find a preferred extension  say p  if and only if for each x  a  r  x is not
blank nor must out and p is not a subset of a previously found preferred extension  in
algorithm   we encounter a stable extension if and only if for each x  a  r  x is not blank
nor must out 
   

fin ofal   atkinson     d unne

algorithm    enumerating all preferred extensions of an afra  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  

lab    a  r    in  out  must out undec  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e pre f erred   ar   e pre f erred    
 
call find preferred extensions lab  
report e pre f erred is the set of all preferred extensions 
procedure find preferred extensions lab  begin
while y  r   lab y    blank do
select y  r with lab y    blank such that
z  r   trg z    y  src y   lab z    out  must out    otherwise select y  r with
lab y    blank such that z  r   lab z    blank
  x   src x    trg y   lab x    out       x   src x    trg z   lab x    out    
lab  lab 
lab  y   in 
lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do
lab  z   out  
foreach z  r   lab  z    blank undec   trg z    y  src y   do
lab  z   must out  
if   w  r   lab  w    blank  trg w    z  src z   then
lab y   undec 
goto line   
call find preferred extensions lab   
if z  r   lab z    blank undec   trg z    y  src y   then
lab y   undec 
else
lab  lab  
if  w  r   lab w    must out then
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
s   x  a  r   lab x    in  
if t  e pre f erred  s  t   then
e pre f erred  e pre f erred   s  
end procedure

   

fia lgorithms for a rgumentation s emantics

algorithm    enumerating all stable extensions of an afra  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a  r    in  out  must out  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e stable   ar   e stable    
 
call find stable extensions lab  
report e stable is the set of all stable extensions 
procedure find stable extensions lab  begin
while y  r   lab y    blank do
select y  r with lab y    blank such that
z  r   trg z    y  src y   lab z    out  must out    otherwise select y  r with
lab y    blank such that z  r   lab z    blank
  x   src x    trg y   lab x    out       x   src x    trg z   lab x    out    
lab  lab 
lab  y   in 
lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do
lab  z   out  
foreach z  r   lab  z    blank  trg z    y  src y   do
lab  z   must out  
if   w  r   lab  w    blank  trg w    z  src z   then
lab y   must out  
goto line   
call find stable extensions lab   
if z  r   lab z    blank  trg z    y  src y   then
lab y   must out  
else
lab  lab  
if  w  r   lab w    must out then
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
e stable  e stable    x  a  r   lab x    in   
end procedure

   

fin ofal   atkinson     d unne

    enumerating complete extensions of any af   afra
algorithm    enumerates all complete extensions  again  algorithm    is a modification of algorithm   that lists preferred extensions  in algorithm   we achieve a preferred extension  say p  if and
only if for each x  a  r  the label of x is not blank nor must out and p is not a subset of a
previously found preferred extension  however  in algorithm     line    we encounter a complete
extension if and only if
c   there is no z  r with the must out label and
c   there does not exist w  r such that
 a  the label of w is undec or blank and
 b  for each y  r   trg y    w  src w    the label of y is out 
thus  c  ensures admissibility while c  guarantees completeness 
    enumerating stage extensions of any af   afra
algorithm    lists all stage extensions  the algorithm is a rewrite of algorithm    however  algorithm    uses four labels  in  out  blank and undec  the usage of these labels is as outlined
in algorithm   with one difference  the role of the must out label used in algorithm   is now
overloaded to the undec label  that is  in algorithm    the undec label is used also for identifying attacks that attack an in argument attack  this is because any attack defeats an argument attack
of a stage extension is not necessarily defeated by an attack of the extension 
algorithm     lines        finds a set of conflict free subsets of a  r rather than constructing
admissible subsets as done by algorithm    in algorithm   the set  w  a  r   the label of w is in 
is reported as an admissible set if and only if for each x  a  r  the label of x is not blank nor
must out  in algorithm    the set  w  a  r   the label of w is in  is recorded as a conflict free
set  i e  a stage extension candidate  if and only if for each x  a  r  the label of x is not blank 
see lines          after building a set of conflict free subsets  algorithm    decides that a conflict
free subset s  a  r is a stage extension if and only if s   x   y  s   y defeats x  is maximal  see
lines       as we stated earlier  argument selection and pruning strategies used in semantics that are
based on admissible sets will not be applicable to stage semantics  which are based on conflict free
sets  therefore  as a pruning strategy  line    of algorithm     we skip labeling an attack y undec
 i e  skip expanding a right child  if and only if
z  r   trg z    y  src y    trg y    z  src z   
the label o f z is out or undec 
this is based on the property that if a conflict free set  say s  is formed while such y is undec
then s   y  is also conflict free  and hence  there is no need to label y undec since s   y   s 
on selecting the next blank attack to be labeled in  we apply the following rule  see line     
r   select a blank attack y s t  for each z  r   trg z    y  src y    trg y    z  src z    the
label of z is out or undec 
r   otherwise select a blank attack y such that   x   the label of x is blank and  src x   
trg y   trg x    y  src y      is maximal 
   

fia lgorithms for a rgumentation s emantics

algorithm     enumerating all complete extensions of an afra  a  r  
 
 
 
 
 

 
 

 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    a  r    in  out  must out undec  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e complete   ar   e complete    
 
call find complete extensions lab  
report e complete is the set of all complete extensions 
procedure find complete extensions lab  begin
if  v  r with lab v    must out and  w  r   lab w    undec  blank  with
y  r   trg y    w  src w   lab y    out then
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
e complete  e complete    x  a  r   lab x    in    
while y  r   lab y    blank do
select y  r with lab y    blank such that
z  r   trg z    y  src y   lab z    out  must out    otherwise select y  r with
lab y    blank such that z  r   lab z    blank
  x   src x    trg y   lab x    out       x   src x    trg z   lab x    out    
lab  lab 
lab  y   in 
lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do
lab  z   out  
foreach z  r   lab  z    blank undec   trg z    y  src y   do
lab  z   must out  
if   w  r   lab  w    blank  trg w    z  src z   then
lab y   undec 
goto line    
call find complete extensions lab   
if z  r   lab z    blank undec   trg z    y  src y   then
lab y   undec 
else
lab  lab  
end procedure

   

fin ofal   atkinson     d unne

the aim of r  is to maximise the gain of the applied pruning strategy  meaning  the earlier
we label the selected argument by r  with in  the greater the saving will be in terms of the part
of the search tree pruned  regarding r   note that a goal state  i e  conflict free set  is reached
if and only if for each x  a  r  the label of x is not blank  thus  r  tries to maximise the
number of out undec attacks arguments  which implies minimising the number of blank
attacks arguments 
    enumerating semi stable extensions of any af   afra
algorithm    lists all semi stable extensions  algorithm    is a variation of algorithm   such that it
basically constructs admissible sets  algorithm     line     records the set  w   the label of w is in 
as an admissible set  that is a semi stable extension candidate  if and only if for each x  a  r  the
label of x is not blank nor must out  after constructing a set of admissible sets  algorithm   
decides that an admissible set s is a semi stable extension if and only if s   x   y  s   y defeats x 
is maximal  see lines      
    constructing the ideal extension of any af   afra
algorithm    builds the ideal extension  in particular  algorithm    finds admissible sets  lines       in the same way algorithm   does  however  in enumerating admissible sets algorithm   
 line     also builds the set
s    x  a  r   there is y in an admissible set such that trg y    x  src x   
after building a set of admissible sets and having such s constructed  algorithm    decides
that an admissible set i is the ideal extension if and only if i  s     
  see lines      recall that
the ideal extension is the maximal  w r t    admissible set that is contained in every preferred
extension  satisfying the condition i  s      implies that the arguments attacks of i are not defeated
by any admissible set  see the definition of s above   which means i is contained in every preferred
extension  to ensure such i is maximal  algorithm    collects admissible sets in descending order 
from larger sets to smaller ones  in consequence  the algorithm checks the collected admissible sets
with the condition i  s      starting from larger admissible sets to smaller ones 
    constructing the grounded extension of any af   afra
algorithm    builds the grounded extension  algorithm    is actually a generalization of algorithm   

   practical efficiency
all algorithms presented in this paper were implemented in c   on a fedora  release     based
machine with   processors  intel core i          ghz  and   gb of memory  as an evaluation criterion  we considered the average elapsed time measured in seconds  the elapsed time was obtained
by using the time command of linux  we present experimental results for two purposes  first 
we explore the efficiency of the algorithms of section    for the second purpose  we confirm that
the generalized algorithms of section    which enumerate extensions by labeling attacks together
with arguments  perform as efficiently as the algorithms of section    which enumerate extensions
by labeling arguments alone 
   

fia lgorithms for a rgumentation s emantics

algorithm     enumerating all stage extensions of an afra  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a  r    in  out undec  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e stage   lab    lab     a  r    in  out undec  blank   
e stage    
 
call find conflict free sets lab  
foreach lab   e stage do
foreach lab   e stage do
if  x   lab   x    in  out       z   lab   z    in  out    then
e stage  e stage    lab    
continue to next iteration from line   
foreach lab   e stage do
report  x   lab   x    in  is a stage extension  
procedure find conflict free sets lab  begin
while y  r   lab y    blank do
select y  r with lab y    blank s t 
z  r   trg z    y  src y    trg y    z  src z    lab z    out undec   
otherwise select y  r with lab y    blank s t 
z  r   lab z    blank   x   lab x    blank   src x    trg y   trg x  
 y  src y         x   lab x    blank   src x    trg z   trg x    z  src z      
lab  lab 
lab  y   in 
lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do
lab  z   out  
foreach z  r   lab  z    blank  trg z    y  src y   do
lab  z   undec 
call find conflict free sets lab   
if z  r   lab z    blank   trg z    y  src y    trg y    z  src z    then
lab y   undec 
else
lab  lab  
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
e stage  e stage   lab  
end procedure

   

fin ofal   atkinson     d unne

algorithm     enumerating all semi stable extensions of an afra  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a  r    in  out  must out undec  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e semistable   lab    lab     a  r    in  out  must out undec  blank   
e semistable    
 
call find admissible sets lab  
foreach lab   e semistable do
foreach lab   e semistable do
if  x   lab   x    in  out       z   lab   z    in  out    then
e semistable  e semistable    lab    
continue to next iteration from line   
foreach lab   e semistable do
report  x   lab   x    in  is a semi stable extension  
procedure find admissible sets lab  begin
while y  r   lab y    blank do
select y  r with lab y    blank s t 
z  r   trg z    y  src y   lab z    out  must out    otherwise select y  r with
lab y    blank s t  z  r   lab z    blank   x   src x    trg y   lab x   
out       x   src x    trg z   lab x    out    
lab  lab  lab  y   in  lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do lab  z   out  
foreach z  r   lab z    blank undec   trg z    y  src y   do
lab  z   must out  
if   w  r   lab  w    blank  trg w    z  src z   then
lab y   undec  goto line    
call find admissible sets lab   
if z  r   lab z    blank undec   trg z    y  src y   then
lab y   undec 
else
lab  lab  
if  y  r   lab y    must out then
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
e semistable  e semistable   lab  
end procedure

   

fia lgorithms for a rgumentation s emantics

algorithm     constructing the ideal extension of an afra  a  r  
 
 
 
 
 
 
 
 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  

lab    a  r    in  out  must out undec  blank   lab    
 
foreach x  a  r do lab  lab    x  blank   
e ideal   z   ar   e ideal    
 
s    
 
call find admissible sets lab  
foreach i     to  e ideal   do
  s  then
if x  e ideal  i   x 
report e ideal  i  is the ideal extension  exit 
procedure find admissible sets lab  begin
while y  r   lab y    blank do
select y  r with lab y    blank s t 
z  r   trg z    y  src y   lab z    out  must out    otherwise select y  r with
lab y    blank such that z  r   lab z    blank
  x   src x    trg y   lab x    out       x   src x    trg z   lab x    out    
lab  lab 
lab  y   in 
lab  src y    in 
lab  trg y    out  
if trg y   a then
foreach z  r   src z    trg y  do
lab  z   out  
foreach z  r   lab  z    blank undec   trg z    y  src y   do
lab  z   must out  
if   w  r   lab  w    blank  trg w    z  src z   then
lab y   undec 
goto line    
call find admissible sets lab   
if z  r   lab z    blank undec  and trg z    y  src y   then
lab y   undec 
else
lab  lab  
if  w  r   lab w    must out then
foreach x  a with lab x    blank s t  z  r   trg z    x  lab z    out   do
lab x   in 
s  s   x  a  r   lab x    out   
e ideal  e ideal     e ideal         z   lab z    in    
end procedure

   

fin ofal   atkinson     d unne

algorithm     constructing the grounded extension of an afra  a  r  
 
 
 
 

 
 
 
 
 
  
  

  

lab    a  r    in  out undec   lab    
 
foreach w  a  r do lab  lab    w undec   
while x  r with lab x    undec s t  y  r   trg y    x  src x    lab y    out   do
foreach x  r with lab x    undec s t  y  r   trg y    x  src x    lab y    out  
do
lab x   in 
lab src x    in 
lab trg x    out  
if trg x   a then
foreach z  r   trg x    src z  do
lab z   out  
foreach x  a with lab x    undec s t  z  r   trg z    x  lab z    out   do
lab x   in 
report the grounded extension is  w  a  r   lab w    in  

we compared the algorithms with dynpartix  which is an implemented system based on the
dynamic programming algorithm of dvorak  pichler  and woltran      b   given an af  dynpartix basically computes a tree decomposition of the af then the extensions are enumerated based
on the tree decomposition  the algorithm used in dynpartix is fixed parameter tractable such that
its time complexity depends on the tree width of the given af while it is linear in the size of the
af  dvorak et al       b   since dynpartix computes only extensions under preferred  stable and
complete semantics  figures          depict respectively the efficiency of algorithms          versus dynpartix  in summary  the figures show that these algorithms are likely to be more efficient
than dynpartix  in running the experiments that are represented by these figures  we set a time
limit of     seconds for every execution  out of      runs  dynpartix encountered     timeouts
in enumerating preferred extensions and     timeouts in enumerating complete extensions  these
timeouts are plotted within the figures as     seconds  this explains the steady behavior of dynpartix that can be noted  particularly  in figure    to see the performance of algorithms     in
contrast to the behavior of algorithms      we present figures      respectively  in profiling algorithms      we reported running times including the time needed to get the corresponding af of
an afra  note that such process  i e  expressing an afra as an af  runs in polynomial time  at
worst quadratic time  the figures      plot the running times for      instances of afra randomly
generated with  a      and r   r   r  s t  r   a  a and r   a  r    for these instances  r 
grows from   to     as the probability  which was used for setting attacks in the random generation  goes over                         note that instances with  a      should not be considered
quite small  for example  a randomly generated afra with  a      and  r       has a corresponding af with  a       and  r         again  we emphasize that the aim of the experiments is to
compare the performance of algorithms     with the performance of algorithms       we do not
mean by the experiments to check the scalability of these algorithms  although an important issue
to be examined  said that  it is not crucial in such evaluation to consider very large frameworks or
higher level of recursive attacks  back to the results of the experiments  the only case that involved
exceeding the     second time limit occurred in enumerating semi stable extensions  referring
   

fia lgorithms for a rgumentation s emantics

figure    enumerating all preferred extensions of      instances of af with  a      for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p  i e  the probability that x attacks y for any x  y  a  

to figure    we note that algorithm    resp      encountered     resp      timeouts  the bottom
line conclusion of these figures is  enumerating extensions of an afra by labeling attacks together
with arguments seems to be as efficient as enumerating the extensions of the corresponding af via
labeling arguments alone 

   discussion and conclusion
we started the paper by refining implemented algorithms  for enumerating all extensions of dungs
argumentation frameworks  afs  under a number of argumentation semantics  preferred  stable 
complete  stage  semi stable  ideal and grounded  algorithms for all these semantics  except stage
and grounded semantics  share a similar core structure  they all basically build admissible sets in
order to construct extensions  in the case of stage semantics  the algorithm actually constructs
conflict free sets for the purpose of listing stage extensions  and hence  the algorithm applies a
slightly different approach to expanding the search tree as we elaborated earlier  concerning the
grounded semantics  the presented algorithm builds the grounded extension in polynomial time 
furthermore  we explored the practical efficiency of these algorithms by profiling their performance
running on a wide spectrum of af instances  from sparse instances to dense ones  in essence
these algorithms construct extensions by using a total function that maps arguments solely to a
set of labels reflecting different states as we illustrated in the paper  then  we generalized these
algorithms by using a total mapping that labels attacks together with arguments  we implemented
the generalized algorithms to enumerate extensions of an afra  which is an af extended model that
   c   implementations can be found at http   sourceforge net projects argtools files 

   

fin ofal   atkinson     d unne

figure    enumerating all stable extensions of      instances of af with  a      for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

figure    enumerating all complete extensions of      instances of af with  a      for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

   

fia lgorithms for a rgumentation s emantics

figure    enumerating all preferred extensions of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

figure    enumerating all stable extensions of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

   

fin ofal   atkinson     d unne

figure     enumerating all complete extensions of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

figure     listing all stage extensions of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated randomly with a probability p 

   

fia lgorithms for a rgumentation s emantics

figure     listing all semi stable extensions of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

figure     constructing the ideal extension of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

   

fin ofal   atkinson     d unne

figure     constructing the grounded extension of      instances of afra  for each p 
                           we tracked the average elapsed time for    instances generated
randomly with a probability p 

allows attacks on attacks  in other words  we offered a unified approach to enumerating extensions
of any af afra  given the fact that an af is a special case of afra  baroni et al       b   on
the other hand  we showed how labeling attacks alongside arguments can be potentially used as a
basis for enumerating extensions of related formalisms that allow attacks on attacks  e g  modgil 
    b  gabbay         nonetheless this is to be confirmed by further research  in fact  extensions
of an instance of such formalisms can be listed by working on the corresponding af  however  we
demonstrated how to enumerate extensions of an afra by applying labeling directly on its native
form without compromising the running time efficiency  we omitted the soundness completeness
proof of the presented algorithms since it follows immediately from the proof of the algorithm of
nofal  atkinson and dunne        for preferred semantics  the algorithms presented in this paper
do not handle frameworks with self attacking arguments perfectly  however  the algorithms can
be easily modified such that the initial label for any self attacking argument is undec instead of
blank  for instance  the only change necessary to be made in algorithm   is to modify line   as
follows
foreach x  a do
if  x  x   r then lab  lab    x undec   
else lab  lab    x  blank   
in general  the undec label  instead of the blank label  should be the default label for any
argument attack that can not be in any extension  like self attacking arguments and their outgoing
attacks because simply such arguments present conflict by themselves  recall that only blank
arguments attacks are to be tried with the in label 
for future work  we plan to study additional options for argument selection  also  we intend to
evaluate further strategies for pruning the search space 
   

fia lgorithms for a rgumentation s emantics

we discuss now related work  the existing algorithms of doutre and mengin        and modgil
and caminada        for listing preferred extensions can also be re engineered towards enumerating
extensions under other argumentation semantics  for example  the papers of caminada             
presented algorithms for enumerating semi stable  respectively stage  extensions building up on the
algorithm of modgil and caminada         however  the algorithms of the present paper are based
on the algorithm of nofal  atkinson and dunne        for enumerating preferred extensions  which
is likely to be more efficient than existing algorithms  nofal et al          we give now some
examples of related work on labeling based semantics  the theory of caminada and gabbay       
defined argumentation semantics by using a total mapping    a   in  out undec  such that 
broadly speaking  the in labeled arguments correspond to an extension  say s  while the out
labeled arguments correspond to s  and the undec labeled arguments correspond to a    s  s    
it is not hard to see the connection between our algorithms and the theory of caminada and gabbay
        for example  in algorithm   we capture a preferred extension when all arguments are
mapped to one of those labels  in  out and undec  listing other works that present labelingbased semantics  the paper of modgil      a  defined labeling based semantics for the extended
af s of modgil      b  while villata  boella  and van der torre        described argumentation
semantics in terms of attacks and arguments  also  the work of gabbay        set argumentation
semantics for the af extended model of barringer  gabbay  and woods        that among other
features allow attacks on attacks  on the topic of extension computation in general  the study of
li  oren  and norman        examined approximation versus exact computations  whereas the
experiments of baumann  brewka  and wong         liao  lei  and dai        evaluated the effect
of splitting an af on the computation of preferred extensions  the work of dondio        studied 
under the grounded semantics  how the acceptance status of an argument varies in all the subgraphs
of the given af  computational complexity of argumentation semantics are widely studied  see e g 
dimopoulos  nebel    toni        dunne              ordyniak   szeider         another line of
research concerns encoding computational problems of afs into other formalisms and then solving
them by using a respective solver  e g  besnard   doutre        nieves  cortes    osorio       
egly  gaggl    woltran        amgoud   devred        dvorak  jarvisalo  wallner    woltran 
    a  cerutti  dunne  giacomin    vallati        charwat  dvorak  gaggl  wallner    woltran 
       such approaches are called reduction based methods  we stress that the focus of this paper
was on algorithmic based implementations of argumentation semantics 

acknowledgments
we thank the anonymous reviewers for the comments that improved the presentation of this work 

references
amgoud  l     devred  c          argumentation frameworks as constraint satisfaction problems 
in benferhat  s     grant  j   eds    sum  vol       of lecture notes in computer science 
pp          springer 
baroni  p   caminada  m     giacomin  m       a   an introduction to argumentation semantics 
the knowledge engineering review                
   

fin ofal   atkinson     d unne

baroni  p   cerutti  f   giacomin  m     guida  g       b   argumentation framework with recursive attacks  international journal of approximate reasoning              
barringer  h   gabbay  d     woods  j          temporal dynamics of support and attack networks 
from argumentation to zoology  in hutter  d     stephan  w   eds    mechanizing mathematical reasoning  vol       of lecture notes in computer science  pp        springer 
baumann  r   brewka  g     wong  r          splitting argumentation frameworks  an empirical
evaluation  in modgil  s   oren  n     toni  f   eds    first international workshop on theory
and applications of formal argumentation       vol       of lecture notes in computer
science  pp        springer 
bench capon  t     dunne  p          argumentation in artificial intelligence  artificial intelligence              
besnard  p     doutre  s          checking the acceptability of a set of arguments  in delgrande 
j     schaub  t   eds    nmr  pp       
besnard  p     hunter  a          elements of argumentation  mit press 
caminada  m          an algorithm for computing semi stable semantics  in mellouli  k   ed   
ecsqaru  vol       of lecture notes in computer science  pp          springer 
caminada  m          an algorithm for stage semantics  in baroni  p   cerutti  f   giacomin  m    
simari  g   eds    comma  vol      of frontiers in artificial intelligence and applications 
pp          ios press 
caminada  m   carnielli  w     dunne  p          semi stable semantics  j  log  comput         
         
caminada  m     gabbay  d          a logical account of formal argumentation  studia logica 
                
cerutti  f   dunne  p   giacomin  m     vallati  m          a sat based approach for computing
extensions in abstract argumentation  in tafa  second international workshop on theory
and applications of formal argumentation 
charwat  g   dvorak  w   gaggl  s   wallner  j     woltran  s          implementing abstract argumentation   a survey  tech  rep  dbai tr          technische universitat wien  database
and artificial intelligence group 
dimopoulos  y   magirou  v     papadimitriou  c          on kernels  defaults and even graphs 
annals of mathematics and artificial intelligence          
dimopoulos  y   nebel  b     toni  f          finding admissible and preferred arguments can
be very hard  in cohn  a   giunchiglia  f     selman  b   eds    kr  pp        morgan
kaufmann 
dondio  p          computing the grounded semantics in all the subgraphs of an argumentation
framework  an empirical evaluation  in clima  xiv workshop on computational logic in
multi agent systems 
doutre  s     mengin  j          preferred extensions of argumentation frameworks  query answering and computation  in gore  r   leitsch  a     nipkow  t   eds    ijcar  vol       of
lecture notes in computer science  pp          springer 
   

fia lgorithms for a rgumentation s emantics

dung  p          on the acceptability of arguments and its fundamental role in non monotonic
reasoning  logic programming and n person games  artificial intelligence                
dung  p   mancarella  p     toni  f          computing ideal skeptical argumentation  artificial
intelligence                     
dunne  p          computational properties of argument systems satisfying graph theoretic constraints  artificial intelligence              
dunne  p          the computational complexity of ideal semantics  artificial intelligence          
           
dvorak  w   jarvisalo  m   wallner  j  p     woltran  s       a   complexity sensitive decision
procedures for abstract argumentation  in brewka  g   eiter  t     mcilraith  s   eds    kr 
aaai press 
dvorak  w   pichler  r     woltran  s       b   towards fixed parameter tractable algorithms for
abstract argumentation  artificial intelligence           
egly  u   gaggl  s     woltran  s          answer set programming encodings for argumentation
frameworks  argument and computation               
gabbay  d          semantics for higher level attacks in extended argumentation frames part   
overview  studia logica                  
li  h   oren  n     norman  t          probabilistic argumentation frameworks  in modgil  s  
oren  n     toni  f   eds    first international workshop on theory and applications of
formal argumentation       vol       of lecture notes in computer science  pp      
springer 
liao  b   lei  l     dai  j          computing preferred labellings by exploiting sccs and most
sceptically rejected arguments  in tafa  second international workshop on theory and applications of formal argumentation 
modgil  s       a   labellings and games for extended argumentation frameworks  in boutilier  c 
 ed    ijcai  pp         
modgil  s       b   reasoning about preferences in argumentation frameworks  artificial intelligence              
modgil  s     caminada  m          proof theories and algorithms for abstract argumentation
frameworks  in rahwan  i     simari  g   eds    argumentation in artificial intelligence  pp 
        springer 
modgil  s   toni  f   bex  f   bratko  i   chesnevar  c   dvorak  w   falappa  m   fan  x   gaggl  s  
garca  a   gonzalez  m   gordon  t   leite  j   mozina  m   reed  c   simari  g   szeider  s  
torroni  p     woltran  s          the added value of argumentation  in ossowski  s   ed   
agreement technologies  vol    of law  governance and technology series  pp         
springer netherlands 
nieves  j   cortes  u     osorio  m          preferred extensions as stable models  theory and
practice of logic programming               
nofal  s   atkinson  k     dunne  p          algorithms for decision problems in argument systems
under preferred semantics  artif  intell             
   

fin ofal   atkinson     d unne

ordyniak  s     szeider  s          augmenting tractable fragments of abstract argumentation  in
walsh  t   ed    proceedings of the   nd international joint conference on artificial intelligence ijcai       pp           
rahwan  i     simari  g          argumentation in artificial intelligence  springer 
verheij  b          two approaches to dialectical argumentation  admissible sets and argumentation
stages  in proceedings of the eighth dutch conference on ai  pp         
villata  s   boella  g     van der torre  l          attack semantics for abstract argumentation  in
walsh  t   ed    proceedings of the   nd international joint conference on artificial intelligence ijcai       pp         

   

fi