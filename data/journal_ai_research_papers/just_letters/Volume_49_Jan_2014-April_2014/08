journal artificial intelligence research                  

submitted        published      

algorithms argumentation semantics  labeling attacks
generalization labeling arguments
samer nofal

amer  n ofal   gju   edu   jo

dept  computer science  german jordanian university
p o  box        amman        jordan

katie atkinson
paul e  dunne

k m atkinson   liverpool   ac   uk
p e d unne   liverpool   ac   uk

dept  computer science  university liverpool
ashton street  liverpool l    bx  united kingdom

abstract
dung argumentation framework  af  pair  a  r   set abstract arguments
r binary relation  so called attack relation  capturing conflicting arguments  labeling based algorithms enumerating extensions  i e  sets acceptable arguments 
set arguments  i e  elements a  subject labeling 
paper present implemented algorithms listing extensions labeling attacks  i e  elements r  along arguments  specifically  algorithms concerned enumerating
extensions af number argumentation semantics  preferred  stable  complete 
semi stable  stage  ideal grounded  algorithms impact  particular  enumerating
extensions af extended models allow attacks attacks  demonstrate impact 
instantiate algorithms example models  namely argumentation frameworks
recursive attacks  afra   thereby end unified algorithms enumerate extensions
af   afra 

   introduction
computational argumentation  covering theory applications  attracted major attention
ai research community  notably last twenty years  e g  bench capon   dunne       
besnard   hunter        rahwan   simari        modgil  toni  bex  bratko  chesnevar  dvorak 
falappa  fan  gaggl  garca  gonzalez  gordon  leite  mozina  reed  simari  szeider  torroni   
woltran         dungs abstract argumentation frameworks  afs   dung        widely studied
model af described pair  a  r   set abstract arguments r aa
binary relation  so called attack relation  represent conflicting arguments  central notion
afs argumentation semantics  set criteria characterise acceptable arguments 
define criteria rigorously section    different reasons number argumentation
semantics proposed literature  explaining reasons detail scope
paper  however  see work baroni  caminada  giacomin      a  excellent
introduction argumentation semantics 
various argumentation semantics  one might find multiple distinct extensions  defined
section     labeling based algorithms  e g  dimopoulos  magirou    papadimitriou        doutre
  mengin        modgil   caminada        listing extensions developed
arguments  i e  elements a  target labeled  paper illustrate
enumerate extensions several argumentation semantics labeling attacks  i e  elements r 
c
    
ai access foundation  rights reserved 

fin ofal   atkinson     unne

along arguments  instead labeling arguments solely  particularly interest listing
extensions af extended formalisms allow attacks attacks  e g  modgil      b  gabbay 
      baroni  cerutti  giacomin    guida      b   show throughout paper  term
labeling based algorithms argumentation semantics distinguished common term
labeling based semantics  although concepts involve labeling mapping  former term
 i e  labeling based algorithms  refers course actions extension enumeration
process classifies arguments  might extension excluded
respective extension  classification essential order construct concrete
extensions given af  later term  i e  labeling based semantics  refers approach
describing  i e  constructing  extensions using labeling mapping 
section   provide necessary background materials  section   review explicit algorithms selection dominant argumentation semantics  preferred  stable  complete  semi
stable  stage  ideal grounded  algorithms list extensions labeling arguments only 
section   develop  respective argumentation semantics  definite algorithms
enumerating extensions argumentation framework recursive attacks  afra   afextended model allows attacks attacks  baroni et al       b   algorithms construct
extensions labeling attacks together arguments  since af special case afra  baroni et al       b   developed algorithms afra list extensions af  section  
report experiments concerning practical efficiency algorithms  section   concludes
paper summary review related work 

   preliminaries
start definition dungs argumentation frameworks  dung        
definition     dungs argumentation frameworks 
argumentation framework  or af  pair  a  r  set arguments r
binary relation 
refer  x  y  r x attacks  or attacked x   denote  x  respectively
subset containing arguments attack  resp  attacked by  argument x 
extending notation natural way sets arguments  a 
 x  


s 

 
 

    x s t   x   
    x s t   x    

given subset a 
x acceptable w r t  every  y  x  r  z
 z  y  r 
conflict free  x  y  s   x  y 
  r 
admissible conflict free every x acceptable w r t  s 
preferred extension maximal  w r t    admissible set 
stable extension conflict free s      s 
   

fia lgorithms rgumentation emantics

figure    argumentation framework 
complete extension admissible set x acceptable
w r t  s  x s 
stage extension conflict free s  maximal  w r t    
semi stable extension admissible s  maximal  w r t    
ideal extension maximal  w r t    admissible set contained every preferred extension 
grounded extension least fixed point f t      x  
x acceptable w r t    
preferred  complete  stable grounded semantics introduced work dung        
whereas stage semantics  ideal semantics semi stable semantics presented papers
verheij         dung  mancarella  toni        caminada  carnielli  dunne       
respectively  give example  consider framework depicted figure   nodes represent
arguments edges correspond attacks  i e  elements r   example  b  d 
preferred  grounded  stable  ideal  complete  semi stable stage extension  note
intend example show differences semantics 
offering explicit means weaken attacks  formalisms modgil      b   gabbay
       baroni et al       b  extend afs attacks  i e  elements r  subject
attacks themselves  present extension enumeration algorithms instance formalisms  namely argumentation frameworks recursive attacks  afra  introduced baroni et
al       b  
definition    argumentation framework recursive attacks  afra  pair  a  r 
set arguments r set pairs  x  y  x  y r  
let x    y  z  r say source x  denoted src x    y  z target
x  denoted trg x    z 
let x r r say directly de f eats x x   trg y  
let x  r say indirectly de f eats x src x    trg y  
let x r r  say de f eats x directly indirectly defeats x 
given subset r 
conflict free exist x  s t  x defeats y 
element x r acceptable w r t  r   defeats x 
z z defeats y 
admissible conflict free x s  x acceptable w r t  s 
   

fin ofal   atkinson     unne

figure    argumentation framework recursive attacks 
preferred extension maximal  w r t    admissible set 
  s 
stable extension conflict free x r   x
exists de f eats x 
complete extension admissible every element r 
acceptable w r t  s  belongs s 
stage  resp  semi stable  extension conflict free  resp  admissible 
 x   s t  defeats x  maximal  w r t    
ideal extension maximal  w r t    admissible set contained every preferred extension 
grounded extension least fixed point f t      x r  
x acceptable w r t    
referring figure     b  d  h  e  grounded  stable  preferred  ideal  complete  stage
semi stable extension 
consider issue expressing afra af  let h    a  r  afra 
corresponding af h    a   r   defined   r r     x  y    x 
r x de f eats y   example  corresponding af afra depicted figure  
described    b  c  d  e  f   g  h  r     e  g     f   e    g  e    g  d    h  c    h  f     h  g   

   algorithms selection argumentation semantics
section review explicit algorithms list  number argumentation semantics 
extensions af labeling arguments solely  particularly  subsection     recall
algorithm nofal  atkinson dunne        preferred semantics  section     present
new implementation algorithm dimopoulos et al         stable semantics 
modify algorithm nofal  atkinson dunne        produce specific algorithms
complete  stage  semi stable ideal semantics subsections                   respectively 
subsection     present implementation building grounded extension 
    enumerating preferred extensions af
algorithm   lists preferred extensions af  algorithm   taken work nofal 
atkinson dunne        shown algorithm likely efficient
algorithms doutre mengin         modgil caminada         recall
   

fia lgorithms rgumentation emantics

algorithm   implemented algorithms present paper seen extension
algorithm  algorithm backtracking procedure traverses abstract binary search
tree  core notion algorithm related use five labels  in  out  must out 
blank undec  informally  label identifies arguments might preferred
extension  label identifies argument attacked argument  blank
label unprocessed argument whose final label decided yet  must label
identifies arguments attack arguments  undec label designates arguments might
included preferred extension might defended argument 
enumerate preferred extensions algorithm   starts blank default label
arguments  initial state represents root node search tree  algorithm forks
left  resp  right  child  i e  state  picking argument  blank  labeled  resp 
undec   every time argument  say x  labeled neighbour arguments labels
might change every  x   label becomes every z  x    x  
label z becomes must out  process  i e  forking new children  continues
every x label x blank  point  algorithm captures preferred extension
every x label x belongs  in out undec   x   label x
in  subset previously found preferred extension  if exists   algorithm
backtracks try find preferred extensions  important kinds algorithms
exploit properties whereby might bypass expanding child search tree  thus considerable
time might saved  algorithm   uses two pruning properties 
   algorithm    lines        skips labeling argument  i e  skips expanding left child 
z  y  label z w  z 
blank label  words  z labeled later
w  z  label w out  must undec  thus  efficient skip
trying include argument attacked z preferred extension 
   algorithm    lines        skips labeling argument undec  i e  skips expanding right
child  every z  y  current label z must out 
admissible set  say s  constructed undec  y 
admissible also  recall preferred extensions maximal admissible sets  hence
need label undec 
another fundamental issue take account selection blank arguments
labeled in  point behind adopting selection strategy try achieve preferred extension efficiently  critical problem constructing one extension 
therefore  algorithm    line    applies following selection options 
   algorithm   tries select first blank argument  say y  attacked
attacked out must arguments only  justification selection related
second pruning property used algorithm  note earlier pick
labeled in  bigger part search tree avoided  recall lead
expanding right child according second pruning property 
   otherwise algorithm picks blank argument  say y    z   z  y  
label z out   maximal  intuition maximising number
arguments minimise number blank must arguments  thus 
   

fin ofal   atkinson     unne

figure    enumerating preferred extensions af using algorithm   
new generated state  i e  child   due selecting y  much closer state
preferred extension captured  recall preferred extension achieved
x label x in  undec 
algorithm    algorithms paper  self contained self explanatory  figure   
however  illustrates algorithm   running af 
    enumerating stable extensions af
algorithm   lists stable extensions  algorithm   seen new implementation
algorithm dimopoulos et al          algorithm   differs algorithm   two ways 
   

fia lgorithms rgumentation emantics

algorithm    enumerating preferred extensions af  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out  must out undec  blank   lab   
 
foreach x lab lab   x  blank   
e pre f erred  a   e pre f erred   
 
call find preferred extensions lab  
report e pre f erred set preferred extensions 
procedure find preferred extensions lab  begin
  lab y    blank
select lab y    blank z  y  lab z   out  must   
otherwise select lab y    blank s t  z   lab z    blank    x   x
 y   lab x         x   x  z   lab x       
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z   undec  blank 
lab  z  must  
w  z    lab  w    blank
lab y  undec 
goto line   
call find preferred extensions lab   
z  y    lab z   blank undec 
lab y  undec 
else
lab lab  
x   lab x    must
 x   lab x    in  
e pre f erred   e pre f erred e pre f erred  s  
end procedure

   

fin ofal   atkinson     unne

   algorithm   uses four labels  in  out  blank must out  usage labels
outlined algorithm   one distinction  role undec label used algorithm   overloaded must label  meaning  algorithm   must
label used labeling argument  say x  trying build stable extension without x 
argument  say x  outside candidate stable extension attacked
argument extension  hence x labeled must  not undec
case algorithm    
   algorithm    p    w   label w in  preferred extension
x a  label x blank must p subset previously
found preferred extension  algorithm    line     set  w   label w in  stable
extension every x a  label x blank must out 
algorithm    enumerating stable extensions af  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out  must out  blank   lab   
 
foreach x lab lab   x  blank   
estable  a   estable   
 
call find stable extensions lab  
report estable set stable extensions 
procedure find stable extensions lab  begin
  lab y    blank
select lab y    blank z  y  lab z   out  must   
otherwise select lab y    blank s t  z   lab z    blank    x   x
 y   lab x         x   x  z   lab x       
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z    blank
lab  z  must  
w  z  lab  w    blank
lab y  must  
goto line   
call find stable extensions lab   
z  y    lab z    blank
lab y  must  
else
lab lab  
x   lab x    must
 x   lab x    in  
estable estable  s  
end procedure

   

fia lgorithms rgumentation emantics

    enumerating complete extensions af
algorithm   lists complete extensions  algorithm   modification algorithm   enumerates preferred extensions  algorithm    p    w   label w in  preferred extension
x a  label x blank must p subset
previously found preferred extension  algorithm    line     set  w   label w in 
complete extension
c   every x a  label x must
c   z undec  or blank  label every  z  label
out 
recall complete extension admissible set every x acceptable respect
s  x belongs s  thus  condition c  ensures admissibility c  guarantees completeness 
    enumerating stage extensions af
algorithm   lists stage extensions  algorithm   alteration algorithm   enumerates
preferred extensions  algorithm   uses four labels  in  out  undec blank  usage
labels outlined algorithm   one distinction  role must label used
algorithm   overloaded undec label  meaning  algorithm   undec label
used identifying arguments attack argument  argument attacks
argument stage extension necessarily attacked argument extension 
algorithm   constructs conflict free subsets a  particular  algorithm    line     keeps
record conflict free set  w   label w in  x a  label
x blank  constructing conflict free subsets  algorithm   decides conflict
free subset  say s  stage extension s  maximal  see lines      might
expected  argument selection pruning strategies used admissibility based semantics
applicable stage semantics  based conflict free sets  therefore  pruning
strategy skip labeling argument  say y  undec z  y    y   
label z undec  based following property  conflict free set  say s 
captured undec  y  conflict free  hence 
need label undec since  y  s  recall algorithm   labels argument undec
trying build stage extension excluding argument  selecting next blank argument
labeled in  consider rule 
r   select blank argument s t  z  y    y    label z undec 
r   otherwise select blank argument   x   x  y    y  label x
blank   maximal 
note correlation r  applied pruning strategy  earlier label
argument selected r  in  bigger part search tree bypassed 
regarding benefit r   recall aim argument selection accelerate achieving
goal state  conflict free subset s  maximal x
blank label  indeed  r  minimises number blank arguments maximising number
out undec arguments 
   

fin ofal   atkinson     unne

algorithm    enumerating complete extensions af  a  r  
 
 
 
 
 

 
 
 
 
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out  must out undec  blank   lab   
 
foreach x lab lab   x  blank   
ecomplete  a   ecomplete   
 
call find complete extensions lab  
report ecomplete set complete extensions 
procedure find complete extensions lab  begin
  lab y    must
x   lab x   undec  blank  z  x  lab z   
 w   lab w    in  
ecomplete ecomplete  s  
  lab y    blank
select lab y    blank z  y  lab z   out  must   
otherwise select lab y    blank s t  z   lab z    blank    x   x
 y   lab x         x   x  z   lab x       
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z   undec  blank 
lab  z  must  
w  z    lab  w    blank
lab y  undec 
goto line    
call find complete extensions lab   
z  y    lab z   blank undec 
lab y  undec 
else
lab lab  
end procedure

   

fia lgorithms rgumentation emantics

algorithm    enumerating stage extensions af  a  r  
 
 
 
 
 
 
 
 
 
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out undec  blank   lab   
 
foreach x lab lab   x  blank   
estage  lab    lab     in  out undec  blank    estage   
 
call find conflict free sets lab  
foreach lab  estage
foreach lab  estage
 x   lab   x   in        z   lab   z   in    
estage estage    lab    
continue next iteration line   
foreach lab  estage
report  x   lab   x    in  stage extension  
procedure find conflict free sets lab  begin
  lab y    blank
select lab y    blank z  y    y  lab z   out undec  
otherwise select lab y    blank z   lab z    blank    x   x
 y    y  lab x    blank     x   x  z    z  lab x    blank   
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z   blank 
lab  z  undec 
call find conflict free sets lab   
z  y    y  lab z    blank
lab y  undec 
else
lab lab  
estage estage  lab  
end procedure

   

fin ofal   atkinson     unne

    enumerating semi stable extensions af
algorithm   enumerates semi stable extensions  again  algorithm   reproduction algorithm    actually  algorithm   firstly builds admissible sets  then  algorithm decides
admissible set  say s  semi stable extension s  maximal  see lines      

algorithm    enumerating semi stable extensions af  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out  must out undec  blank   lab   
 
foreach x lab lab   x  blank   
esemistable  lab    lab     in  out  must out undec  blank   
esemistable   
 
call find admissible sets lab  
foreach lab  esemistable
foreach lab  esemistable
 x   lab   x   in        z   lab   z   in    
esemistable esemistable    lab    
continue next iteration line   
foreach lab  esemistable
report  x   lab   x    in  semi stable extension  
procedure find admissible sets lab  begin
  lab y    blank
select lab y    blank z  y  lab z   out  must   
otherwise select lab y    blank s t  z   lab z    blank    x   x
 y   lab x         x   x  z   lab x       
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z   undec  blank 
lab  z  must  
w  z    lab  w    blank
lab y  undec 
goto line    
call find admissible sets lab   
z  y    lab z   blank undec 
lab y  undec 
else
lab lab  
x   lab x    must
esemistable esemistable  lab  
end procedure

   

fia lgorithms rgumentation emantics

    constructing ideal extension af
algorithm   builds ideal extension  algorithm modification algorithm    algorithm  
 line     records  w   label w in  admissible set x a  label
x blank must out  however  algorithm constructs  line        x  
exists admissible set x      building set admissible sets
constructed  algorithm   considers admissible set ideal extension
    
  see lines      recall ideal extension maximal  w r t    admissible
set contained every preferred extension  satisfying condition      implies
arguments attacked admissible set  see definition above  
means contained every preferred extension  ensure maximal  algorithm   collects
admissible sets descending order  larger sets smaller ones  consequence  algorithm
checks collected admissible sets condition      starting larger admissible sets
smaller ones 
    constructing grounded extension af
algorithm   viewed another implementation algorithm described modgil
caminada        building grounded extension 

   labeling attacks generalization labeling arguments
section illustrate enumerate extensions  number argumentation semantics  labeling attacks together arguments instead labeling arguments solely  end 
develop algorithms listing extensions afra  baroni et al       b  preferred 
stable  complete  stage  semi stable  ideal grounded semantics subsections                    
             respectively  algorithms basically generalization algorithms
presented previous section  hence algorithms list extensions af   afra 
    enumerating preferred extensions af   afra
algorithm   enumerates preferred extensions afra  algorithm   generalization
algorithm    idea based using five labels  in  out  must out  blank undec 
blank label initial label arguments attacks  blank attack r labeled
indicate might preferred extension  argument x labeled
r label trg y    x  attack z r labeled
r label trg y   z  src z    blank argument x labeled in 
implying x might preferred extension  r label
src y    x z r   trg z    x label z out  attack labeled undec
try find preferred extension excluding y  attack z label blank undec labeled
must r label trg z   y  src y    every
time attack labeled labels attacks arguments might change accordingly  see
lines       algorithm    selection rule  line   represents strategy algorithm
selects next attack  blank  labeled in  rule grounds parallel
selection rule applied algorithm   enumerating preferred extensions af  likewise 
algorithm   applies two pruning tactics 
   

fin ofal   atkinson     unne

algorithm    constructing ideal extension af  a  r  
 
 
 
 
 
 
 
 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    in  out  must out undec  blank   lab   
 
foreach x lab lab   x  blank   
eideal   z  a   eideal   
 
  
 
call find admissible sets lab  
foreach         eideal  
eideal  i      
report eideal  i  ideal extension  exit 
procedure find admissible sets lab  begin
  lab y    blank
select lab y    blank z  y  lab z   out  must   
otherwise select lab y    blank s t  z   lab z    blank    x   x
 y   lab x         x   x  z   lab x       
lab lab 
lab  y  in 
foreach z  y   lab  z   
foreach z  y 
lab  z   undec  blank 
lab  z  must  
w  z    lab  w    blank
lab y  undec 
goto line    
call find admissible sets lab   
z  y    lab z   blank undec 
lab y  undec 
else
lab lab  
w   lab w    must
 x   lab x      
eideal eideal    eideal         z   lab z    in    
end procedure

algorithm    constructing grounded extension af  a  r  
 
 
 
 
 
 
 

lab    in  out undec   lab   
 
foreach w lab lab   w undec   
x lab x    undec    x  lab y   
foreach x lab x    undec    x  lab y   
lab x  in 
foreach z  x   lab z   
report grounded extension  w   lab w    in  

   

fia lgorithms rgumentation emantics

figure    algorithm   works afra 
   algorithm    lines         skips labeling attack  i e  skips expanding left child 

z   trg z   y  src y   label f z
w label blank   trg w   z  src z   
   algorithm    lines         skips labeling attack undec  i e  skips expanding right
child  z r   trg z   y  src y    label z must out 
get general idea algorithm   see figure   shows algorithm works
afra depicted figure   
    enumerating stable extensions af   afra
algorithm   enumerates stable extensions  actually  algorithm   modification algorithm  
lists preferred extensions  however two differences 
   algorithm   uses four labels  in  out  blank must out  usage labels
outlined algorithm   one difference  role undec label used algorithm   overloaded must label  is  algorithm   must
label used labeling attack  say x  trying build stable extension without x 
attack  say x  outside candidate stable extension defeated
attack extension  hence x labeled must out 
   algorithm   find preferred extension  say p  x r  x
blank must p subset previously found preferred extension 
algorithm   encounter stable extension x r  x blank
must out 
   

fin ofal   atkinson     unne

algorithm    enumerating preferred extensions afra  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  

lab    a r   in  out  must out undec  blank   lab   
 
foreach x r lab lab   x  blank   
e pre f erred  ar   e pre f erred   
 
call find preferred extensions lab  
report e pre f erred set preferred extensions 
procedure find preferred extensions lab  begin
r   lab y    blank
select r lab y    blank
z r   trg z   y  src y   lab z   out  must    otherwise select r
lab y    blank z r   lab z    blank
  x   src x    trg y  lab x         x   src x    trg z  lab x       
lab lab 
lab  y  in 
lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y 
lab  z   
foreach z r   lab  z   blank undec  trg z   y  src y  
lab  z  must  
w r   lab  w    blank trg w   z  src z  
lab y  undec 
goto line   
call find preferred extensions lab   
z r   lab z   blank undec  trg z   y  src y  
lab y  undec 
else
lab lab  
w r   lab w    must
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
 x r   lab x    in  
e pre f erred  s  
e pre f erred e pre f erred  s  
end procedure

   

fia lgorithms rgumentation emantics

algorithm    enumerating stable extensions afra  a  r  
 
 
 
 
 

 
 
 

 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a r   in  out  must out  blank   lab   
 
foreach x r lab lab   x  blank   
e stable  ar   e stable   
 
call find stable extensions lab  
report e stable set stable extensions 
procedure find stable extensions lab  begin
r   lab y    blank
select r lab y    blank
z r   trg z   y  src y   lab z   out  must    otherwise select r
lab y    blank z r   lab z    blank
  x   src x    trg y  lab x         x   src x    trg z  lab x       
lab lab 
lab  y  in 
lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y 
lab  z   
foreach z r   lab  z    blank trg z   y  src y  
lab  z  must  
w r   lab  w    blank trg w   z  src z  
lab y  must  
goto line   
call find stable extensions lab   
z r   lab z    blank trg z   y  src y  
lab y  must  
else
lab lab  
w r   lab w    must
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
e stable e stable   x r   lab x    in   
end procedure

   

fin ofal   atkinson     unne

    enumerating complete extensions af   afra
algorithm    enumerates complete extensions  again  algorithm    modification algorithm   lists preferred extensions  algorithm   achieve preferred extension  say p 
x r  label x blank must p subset
previously found preferred extension  however  algorithm     line    encounter complete
extension
c   z r must label
c   exist w r
 a  label w undec blank
 b  r   trg y   w  src w    label out 
thus  c  ensures admissibility c  guarantees completeness 
    enumerating stage extensions af   afra
algorithm    lists stage extensions  algorithm rewrite algorithm    however  algorithm    uses four labels  in  out  blank undec  usage labels outlined
algorithm   one difference  role must label used algorithm  
overloaded undec label  is  algorithm    undec label used identifying attacks attack argument attack  attack defeats argument attack
stage extension necessarily defeated attack extension 
algorithm     lines        finds set conflict free subsets r rather constructing
admissible subsets done algorithm    algorithm   set  w r   label w in 
reported admissible set x r  label x blank
must out  algorithm    set  w r   label w in  recorded conflict free
set  i e  stage extension candidate  x r  label x blank 
see lines          building set conflict free subsets  algorithm    decides conflict
free subset r stage extension  x     defeats x  maximal  see
lines       stated earlier  argument selection pruning strategies used semantics
based admissible sets applicable stage semantics  based conflict free
sets  therefore  pruning strategy  line    algorithm     skip labeling attack undec
 i e  skip expanding right child 
z r   trg z   y  src y   trg y   z  src z   
label f z undec 
based property conflict free set  say s  formed undec
 y  conflict free  hence  need label undec since  y  s 
selecting next blank attack labeled in  apply following rule  see line     
r   select blank attack s t  z r   trg z   y  src y   trg y   z  src z   
label z undec 
r   otherwise select blank attack   x   label x blank  src x   
trg y  trg x   y  src y      maximal 
   

fia lgorithms rgumentation emantics

algorithm     enumerating complete extensions afra  a  r  
 
 
 
 
 

 
 

 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

lab    a r   in  out  must out undec  blank   lab   
 
foreach x r lab lab   x  blank   
e complete  ar   e complete   
 
call find complete extensions lab  
report e complete set complete extensions 
procedure find complete extensions lab  begin
v r lab v    must w r   lab w   undec  blank 
r   trg y   w  src w   lab y   
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
e complete e complete   x r   lab x    in    
r   lab y    blank
select r lab y    blank
z r   trg z   y  src y   lab z   out  must    otherwise select r
lab y    blank z r   lab z    blank
  x   src x    trg y  lab x         x   src x    trg z  lab x       
lab lab 
lab  y  in 
lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y 
lab  z   
foreach z r   lab  z   blank undec  trg z   y  src y  
lab  z  must  
w r   lab  w    blank trg w   z  src z  
lab y  undec 
goto line    
call find complete extensions lab   
z r   lab z   blank undec  trg z   y  src y  
lab y  undec 
else
lab lab  
end procedure

   

fin ofal   atkinson     unne

aim r  maximise gain applied pruning strategy  meaning  earlier
label selected argument r  in  greater saving terms part
search tree pruned  regarding r   note goal state  i e  conflict free set  reached
x r  label x blank  thus  r  tries maximise
number out undec attacks arguments  implies minimising number blank
attacks arguments 
    enumerating semi stable extensions af   afra
algorithm    lists semi stable extensions  algorithm    variation algorithm  
basically constructs admissible sets  algorithm     line     records set  w   label w in 
admissible set  that semi stable extension candidate  x r 
label x blank must out  constructing set admissible sets  algorithm   
decides admissible set semi stable extension  x     defeats x 
maximal  see lines      
    constructing ideal extension af   afra
algorithm    builds ideal extension  particular  algorithm    finds admissible sets  lines       way algorithm   does  however  enumerating admissible sets algorithm   
 line     builds set
   x r   admissible set trg y   x  src x   
building set admissible sets constructed  algorithm    decides
admissible set ideal extension     
  see lines      recall
ideal extension maximal  w r t    admissible set contained every preferred
extension  satisfying condition      implies arguments attacks defeated
admissible set  see definition above   means contained every preferred
extension  ensure maximal  algorithm    collects admissible sets descending order 
larger sets smaller ones  consequence  algorithm checks collected admissible sets
condition      starting larger admissible sets smaller ones 
    constructing grounded extension af   afra
algorithm    builds grounded extension  algorithm    actually generalization algorithm   

   practical efficiency
algorithms presented paper implemented c   fedora  release     based
machine   processors  intel core i          ghz    gb memory  evaluation criterion  considered average elapsed time measured seconds  elapsed time obtained
using time command linux  present experimental results two purposes  first 
explore efficiency algorithms section    second purpose  confirm
generalized algorithms section    enumerate extensions labeling attacks together
arguments  perform efficiently algorithms section    enumerate extensions
labeling arguments alone 
   

fia lgorithms rgumentation emantics

algorithm     enumerating stage extensions afra  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a r   in  out undec  blank   lab   
 
foreach x r lab lab   x  blank   
e stage  lab    lab     a r   in  out undec  blank   
e stage   
 
call find conflict free sets lab  
foreach lab  e stage
foreach lab  e stage
 x   lab   x   in        z   lab   z   in    
e stage e stage    lab    
continue next iteration line   
foreach lab  e stage
report  x   lab   x    in  stage extension  
procedure find conflict free sets lab  begin
r   lab y    blank
select r lab y    blank s t 
z r   trg z   y  src y   trg y   z  src z    lab z   out undec   
otherwise select r lab y    blank s t 
z r   lab z    blank   x   lab x    blank  src x    trg y  trg x 
 y  src y        x   lab x    blank  src x    trg z  trg x   z  src z      
lab lab 
lab  y  in 
lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y 
lab  z   
foreach z r   lab  z    blank trg z   y  src y  
lab  z  undec 
call find conflict free sets lab   
z r   lab z    blank  trg z   y  src y   trg y   z  src z   
lab y  undec 
else
lab lab  
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
e stage e stage  lab  
end procedure

   

fin ofal   atkinson     unne

algorithm     enumerating semi stable extensions afra  a  r  
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  

lab    a r   in  out  must out undec  blank   lab   
 
foreach x r lab lab   x  blank   
e semistable  lab    lab     a r   in  out  must out undec  blank   
e semistable   
 
call find admissible sets lab  
foreach lab  e semistable
foreach lab  e semistable
 x   lab   x   in        z   lab   z   in    
e semistable e semistable    lab    
continue next iteration line   
foreach lab  e semistable
report  x   lab   x    in  semi stable extension  
procedure find admissible sets lab  begin
r   lab y    blank
select r lab y    blank s t 
z r   trg z   y  src y   lab z   out  must    otherwise select r
lab y    blank s t  z r   lab z    blank   x   src x    trg y  lab x   
     x   src x    trg z  lab x       
lab lab  lab  y  in  lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y  lab  z   
foreach z r   lab z   blank undec  trg z   y  src y  
lab  z  must  
w r   lab  w    blank trg w   z  src z  
lab y  undec  goto line    
call find admissible sets lab   
z r   lab z   blank undec  trg z   y  src y  
lab y  undec 
else
lab lab  
r   lab y    must
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
e semistable e semistable  lab  
end procedure

   

fia lgorithms rgumentation emantics

algorithm     constructing ideal extension afra  a  r  
 
 
 
 
 
 
 
 

 
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  

lab    a r   in  out  must out undec  blank   lab   
 
foreach x r lab lab   x  blank   
e ideal   z  ar   e ideal   
 
  
 
call find admissible sets lab  
foreach      e ideal  
  s 
x e ideal  i   x
report e ideal  i  ideal extension  exit 
procedure find admissible sets lab  begin
r   lab y    blank
select r lab y    blank s t 
z r   trg z   y  src y   lab z   out  must    otherwise select r
lab y    blank z r   lab z    blank
  x   src x    trg y  lab x         x   src x    trg z  lab x       
lab lab 
lab  y  in 
lab  src y   in 
lab  trg y    
trg y 
foreach z r   src z    trg y 
lab  z   
foreach z r   lab  z   blank undec  trg z   y  src y  
lab  z  must  
w r   lab  w    blank trg w   z  src z  
lab y  undec 
goto line    
call find admissible sets lab   
z r   lab z   blank undec  trg z   y  src y  
lab y  undec 
else
lab lab  
w r   lab w    must
foreach x lab x    blank s t  z r   trg z    x  lab z     
lab x  in 
 x r   lab x      
e ideal e ideal    e ideal         z   lab z    in    
end procedure

   

fin ofal   atkinson     unne

algorithm     constructing grounded extension afra  a  r  
 
 
 
 

 
 
 
 
 
  
  

  

lab    a r   in  out undec   lab   
 
foreach w r lab lab   w undec   
x r lab x    undec s t  r   trg y   x  src x    lab y     
foreach x r lab x    undec s t  r   trg y   x  src x    lab y     

lab x  in 
lab src x   in 
lab trg x    
trg x 
foreach z r   trg x    src z 
lab z   
foreach x lab x    undec s t  z r   trg z    x  lab z     
lab x  in 
report grounded extension  w r   lab w    in  

compared algorithms dynpartix  implemented system based
dynamic programming algorithm dvorak  pichler  woltran      b   given af  dynpartix basically computes tree decomposition af extensions enumerated based
tree decomposition  algorithm used dynpartix fixed parameter tractable
time complexity depends tree width given af linear size
af  dvorak et al       b   since dynpartix computes extensions preferred  stable
complete semantics  figures          depict respectively efficiency algorithms          versus dynpartix  summary  figures show algorithms likely efficient
dynpartix  running experiments represented figures  set time
limit     seconds every execution       runs  dynpartix encountered     timeouts
enumerating preferred extensions     timeouts enumerating complete extensions 
timeouts plotted within figures     seconds  explains steady behavior dynpartix noted  particularly  figure    see performance algorithms    
contrast behavior algorithms      present figures      respectively  profiling algorithms      reported running times including time needed get corresponding af
afra  note process  i e  expressing afra af  runs polynomial time 
worst quadratic time  figures      plot running times      instances afra randomly
generated  a      r   r  r  s t  r  r  r    instances  r 
grows       probability  used setting attacks random generation  goes                         note instances  a      considered
quite small  example  randomly generated afra  a       r       corresponding af  a        r         again  emphasize aim experiments
compare performance algorithms     performance algorithms      
mean experiments check scalability algorithms  although important issue
examined  said that  crucial evaluation consider large frameworks
higher level recursive attacks  back results experiments  case involved
exceeding     second time limit occurred enumerating semi stable extensions  referring
   

fia lgorithms rgumentation emantics

figure    enumerating preferred extensions      instances af  a      p
                           tracked average elapsed time    instances generated
randomly probability p  i e  probability x attacks x  a  

figure    note algorithm    resp      encountered     resp      timeouts  bottom
line conclusion figures is  enumerating extensions afra labeling attacks together
arguments seems efficient enumerating extensions corresponding af via
labeling arguments alone 

   discussion conclusion
started paper refining implemented algorithms  enumerating extensions dungs
argumentation frameworks  afs  number argumentation semantics  preferred  stable 
complete  stage  semi stable  ideal grounded  algorithms semantics  except stage
grounded semantics  share similar core structure  basically build admissible sets
order construct extensions  case stage semantics  algorithm actually constructs
conflict free sets purpose listing stage extensions  hence  algorithm applies
slightly different approach expanding search tree elaborated earlier  concerning
grounded semantics  presented algorithm builds grounded extension polynomial time 
furthermore  explored practical efficiency algorithms profiling performance
running wide spectrum af instances  sparse instances dense ones  essence
algorithms construct extensions using total function maps arguments solely
set labels reflecting different states illustrated paper  then  generalized
algorithms using total mapping labels attacks together arguments  implemented
generalized algorithms enumerate extensions afra  af extended model
   c   implementations found http   sourceforge net projects argtools files 

   

fin ofal   atkinson     unne

figure    enumerating stable extensions      instances af  a      p
                           tracked average elapsed time    instances generated
randomly probability p 

figure    enumerating complete extensions      instances af  a      p
                           tracked average elapsed time    instances generated
randomly probability p 

   

fia lgorithms rgumentation emantics

figure    enumerating preferred extensions      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

figure    enumerating stable extensions      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

   

fin ofal   atkinson     unne

figure     enumerating complete extensions      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

figure     listing stage extensions      instances afra  p
                           tracked average elapsed time    instances generated randomly probability p 

   

fia lgorithms rgumentation emantics

figure     listing semi stable extensions      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

figure     constructing ideal extension      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

   

fin ofal   atkinson     unne

figure     constructing grounded extension      instances afra  p
                           tracked average elapsed time    instances generated
randomly probability p 

allows attacks attacks  words  offered unified approach enumerating extensions
af afra  given fact af special case afra  baroni et al       b  
hand  showed labeling attacks alongside arguments potentially used
basis enumerating extensions related formalisms allow attacks attacks  e g  modgil 
    b  gabbay         nonetheless confirmed research  fact  extensions
instance formalisms listed working corresponding af  however 
demonstrated enumerate extensions afra applying labeling directly native
form without compromising running time efficiency  omitted soundness completeness
proof presented algorithms since follows immediately proof algorithm
nofal  atkinson dunne        preferred semantics  algorithms presented paper
handle frameworks self attacking arguments perfectly  however  algorithms
easily modified initial label self attacking argument undec instead
blank  instance  change necessary made algorithm   modify line  
follows
foreach x
 x  x  r lab lab   x undec   
else lab lab   x  blank   
general  undec label  instead blank label  default label
argument attack extension  self attacking arguments outgoing
attacks simply arguments present conflict themselves  recall blank
arguments attacks tried label 
future work  plan study additional options argument selection  also  intend
evaluate strategies pruning search space 
   

fia lgorithms rgumentation emantics

discuss related work  existing algorithms doutre mengin        modgil
caminada        listing preferred extensions re engineered towards enumerating
extensions argumentation semantics  example  papers caminada             
presented algorithms enumerating semi stable  respectively stage  extensions building
algorithm modgil caminada         however  algorithms present paper based
algorithm nofal  atkinson dunne        enumerating preferred extensions 
likely efficient existing algorithms  nofal et al          give
examples related work labeling based semantics  theory caminada gabbay       
defined argumentation semantics using total mapping    in  out undec  that 
broadly speaking  labeled arguments correspond extension  say s 
labeled arguments correspond s  undec labeled arguments correspond    s s    
hard see connection algorithms theory caminada gabbay
        example  algorithm   capture preferred extension arguments
mapped one labels  in  undec  listing works present labelingbased semantics  paper modgil      a  defined labeling based semantics extended
af modgil      b  villata  boella  van der torre        described argumentation
semantics terms attacks arguments  also  work gabbay        set argumentation
semantics af extended model barringer  gabbay  woods        among
features allow attacks attacks  topic extension computation general  study
li  oren  norman        examined approximation versus exact computations  whereas
experiments baumann  brewka  wong         liao  lei  dai        evaluated effect
splitting af computation preferred extensions  work dondio        studied 
grounded semantics  acceptance status argument varies subgraphs
given af  computational complexity argumentation semantics widely studied  see e g 
dimopoulos  nebel    toni        dunne              ordyniak   szeider         another line
research concerns encoding computational problems afs formalisms solving
using respective solver  e g  besnard   doutre        nieves  cortes    osorio       
egly  gaggl    woltran        amgoud   devred        dvorak  jarvisalo  wallner    woltran 
    a  cerutti  dunne  giacomin    vallati        charwat  dvorak  gaggl  wallner    woltran 
       approaches called reduction based methods  stress focus paper
algorithmic based implementations argumentation semantics 

acknowledgments
thank anonymous reviewers comments improved presentation work 

references
amgoud  l     devred  c          argumentation frameworks constraint satisfaction problems 
benferhat  s     grant  j   eds    sum  vol       lecture notes computer science 
pp          springer 
baroni  p   caminada  m     giacomin  m       a   introduction argumentation semantics 
knowledge engineering review                
   

fin ofal   atkinson     unne

baroni  p   cerutti  f   giacomin  m     guida  g       b   argumentation framework recursive attacks  international journal approximate reasoning              
barringer  h   gabbay  d     woods  j          temporal dynamics support attack networks 
argumentation zoology  hutter  d     stephan  w   eds    mechanizing mathematical reasoning  vol       lecture notes computer science  pp        springer 
baumann  r   brewka  g     wong  r          splitting argumentation frameworks  empirical
evaluation  modgil  s   oren  n     toni  f   eds    first international workshop theory
applications formal argumentation       vol       lecture notes computer
science  pp        springer 
bench capon  t     dunne  p          argumentation artificial intelligence  artificial intelligence              
besnard  p     doutre  s          checking acceptability set arguments  delgrande 
j     schaub  t   eds    nmr  pp       
besnard  p     hunter  a          elements argumentation  mit press 
caminada  m          algorithm computing semi stable semantics  mellouli  k   ed   
ecsqaru  vol       lecture notes computer science  pp          springer 
caminada  m          algorithm stage semantics  baroni  p   cerutti  f   giacomin  m    
simari  g   eds    comma  vol      frontiers artificial intelligence applications 
pp          ios press 
caminada  m   carnielli  w     dunne  p          semi stable semantics  j  log  comput         
         
caminada  m     gabbay  d          logical account formal argumentation  studia logica 
                
cerutti  f   dunne  p   giacomin  m     vallati  m          sat based approach computing
extensions abstract argumentation  tafa  second international workshop theory
applications formal argumentation 
charwat  g   dvorak  w   gaggl  s   wallner  j     woltran  s          implementing abstract argumentation   survey  tech  rep  dbai tr          technische universitat wien  database
artificial intelligence group 
dimopoulos  y   magirou  v     papadimitriou  c          kernels  defaults even graphs 
annals mathematics artificial intelligence          
dimopoulos  y   nebel  b     toni  f          finding admissible preferred arguments
hard  cohn  a   giunchiglia  f     selman  b   eds    kr  pp        morgan
kaufmann 
dondio  p          computing grounded semantics subgraphs argumentation
framework  empirical evaluation  clima  xiv workshop computational logic
multi agent systems 
doutre  s     mengin  j          preferred extensions argumentation frameworks  query answering computation  gore  r   leitsch  a     nipkow  t   eds    ijcar  vol      
lecture notes computer science  pp          springer 
   

fia lgorithms rgumentation emantics

dung  p          acceptability arguments fundamental role non monotonic
reasoning  logic programming n person games  artificial intelligence                
dung  p   mancarella  p     toni  f          computing ideal skeptical argumentation  artificial
intelligence                     
dunne  p          computational properties argument systems satisfying graph theoretic constraints  artificial intelligence              
dunne  p          computational complexity ideal semantics  artificial intelligence          
          
dvorak  w   jarvisalo  m   wallner  j  p     woltran  s       a   complexity sensitive decision
procedures abstract argumentation  brewka  g   eiter  t     mcilraith  s   eds    kr 
aaai press 
dvorak  w   pichler  r     woltran  s       b   towards fixed parameter tractable algorithms
abstract argumentation  artificial intelligence           
egly  u   gaggl  s     woltran  s          answer set programming encodings argumentation
frameworks  argument computation               
gabbay  d          semantics higher level attacks extended argumentation frames part   
overview  studia logica                  
li  h   oren  n     norman  t          probabilistic argumentation frameworks  modgil  s  
oren  n     toni  f   eds    first international workshop theory applications
formal argumentation       vol       lecture notes computer science  pp      
springer 
liao  b   lei  l     dai  j          computing preferred labellings exploiting sccs
sceptically rejected arguments  tafa  second international workshop theory applications formal argumentation 
modgil  s       a   labellings games extended argumentation frameworks  boutilier  c 
 ed    ijcai  pp         
modgil  s       b   reasoning preferences argumentation frameworks  artificial intelligence              
modgil  s     caminada  m          proof theories algorithms abstract argumentation
frameworks  rahwan  i     simari  g   eds    argumentation artificial intelligence  pp 
        springer 
modgil  s   toni  f   bex  f   bratko  i   chesnevar  c   dvorak  w   falappa  m   fan  x   gaggl  s  
garca  a   gonzalez  m   gordon  t   leite  j   mozina  m   reed  c   simari  g   szeider  s  
torroni  p     woltran  s          added value argumentation  ossowski  s   ed   
agreement technologies  vol    law  governance technology series  pp         
springer netherlands 
nieves  j   cortes  u     osorio  m          preferred extensions stable models  theory
practice logic programming               
nofal  s   atkinson  k     dunne  p          algorithms decision problems argument systems
preferred semantics  artif  intell             
   

fin ofal   atkinson     unne

ordyniak  s     szeider  s          augmenting tractable fragments abstract argumentation 
walsh  t   ed    proceedings   nd international joint conference artificial intelligence ijcai       pp           
rahwan  i     simari  g          argumentation artificial intelligence  springer 
verheij  b          two approaches dialectical argumentation  admissible sets argumentation
stages  proceedings eighth dutch conference ai  pp         
villata  s   boella  g     van der torre  l          attack semantics abstract argumentation 
walsh  t   ed    proceedings   nd international joint conference artificial intelligence ijcai       pp         

   


