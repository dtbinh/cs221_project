journal of artificial intelligence research                 

submitted       published     

teleo reactive programs for agent control
nils j  nilsson

nilsson cs stanford edu

robotics laboratory  department of computer science
stanford university  stanford  ca       usa

abstract

a formalism is presented for computing and organizing actions for autonomous agents
in dynamic environments  we introduce the notion of teleo reactive  t r  programs whose
execution entails the construction of circuitry for the continuous computation of the parameters and conditions on which agent action is based  in addition to continuous feedback 
t r programs support parameter binding and recursion  a primary difference between
t r programs and many other circuit based systems is that the circuitry of t r programs
is more compact  it is constructed at run time and thus does not have to anticipate all
the contingencies that might arise over all possible runs  in addition  t r programs are
intuitive and easy to write and are written in a form that is compatible with automatic
planning and learning methods  we briey describe some experimental applications of t r
programs in the control of simulated and actual mobile robots 
   introduction

autonomous agents  such as mobile robots  typically operate in dynamic and uncertain
environments  such environments can be sensed only imperfectly  effects on them are not
always completely predictable  and they may be subject to changes not under the agent s
control  designing agents to operate in these environments has presented challenges to the
standard methods of artificial intelligence  which are based on explicit declarative representations and reasoning processes  prominent among the alternative approaches are the
so called behavior based  situated  and animat methods  brooks        maes        kaelbling   rosenschein        wilson         which convert sensory inputs into actions in a
much more direct fashion than do ai systems based on representation and reasoning  many
of these alternative approaches share with control theory the central notion that continuous
feedback from the environment is a necessary component of effective action 
perhaps it is relatively easier for control theorists than it is for computer scientists
to deal with continuous feedback because control theorists are accustomed to thinking of
their controlling mechanisms as composed of analog electrical circuits or other physical
systems rather than as automata with discrete read compute write cycles  the notions of
goal seeking servo mechanisms  homeostasis  feedback  filtering  and stability so essential
to control in dynamic environments were all developed with analog circuitry in mind 
circuits  by their nature  are continously responsive to their inputs 
in contrast  some of the central ideas of computer science  namely sequences  events 
discrete actions  and subroutines  seem at odds with the notion of continuous feedback 
for example  in conventional programming when one program calls another  the calling
program is suspended until the called program returns control  this feature is awkward
in applications in which the called program might encounter unexpected environmental

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

finilsson

circumstances with which it was not designed to cope  in such cases  the calling program
can regain control only through interrupts explicitly provided by the programmer 
to be sure  there have been attempts to blend control theory and computer science  for
example  the work of ramadge and wonham  ramadge   wonham        on discrete event
systems has used the computer science notions of events  grammars  and discrete states to
study the control of processes for which those ideas are appropriate  a book by dean
and wellman  dean   wellman        focusses on the overlap between control theory and
artificial intelligence  but there has been little effort to import fundamental control theory
ideas into computer science  that is precisely what i set out to do in this paper 
i propose a computational system that works differently than do conventional ones  the
formalism has what i call circuit semantics  nilsson         program execution produces
 at least conceptually  electrical circuits  and it is these circuits that are used for control 
while importing the control theory concept of continuous feedback  i nevertheless want to
retain useful ideas of computer science  my control programs will have parameters that can
be bound at run time and passed to subordinate routines  they can have a hierarchical
organization  and they can be recursive  in contrast with some of the behavior based
approaches  i want the programs to be responsive to stored models of the environment as
well as to their immediate sensory inputs 
the presentation of these ideas will be somewhat informal in line with my belief that
formalization is best done after a certain amount of experience has been obtained  although
preliminary experiments indicate that the formalism works quite well  more work remains
to be done to establish its place in agent control 
   teleo reactive sequences
    condition action rules

a teleo reactive  t r  sequence is an agent control program that directs the agent toward a
goal  hence teleo  in a manner that takes into account changing environmental circumstances
 hence reactive   in its simplest form  it consists of an ordered set of production rules 

k 
k 

 
 

a 
a 

   

ki

 

ai

   

km

 

am

the ki are conditions  on sensory inputs and on a model of the world   and the ai
are actions  on the world or which change the model   a t r sequence is interpreted in a
manner roughly similar to the way in which some production systems are interpreted  the
list of rules is scanned from the top for the first rule whose condition part is satisfied  and
the corresponding action is executed  t r sequences differ substantively from conventional
production systems  however  t r actions can be durative rather than discrete  a durative
   

fiteleo reactive programs

action is one that continues indefinitely  for example  a mobile robot is capable of executing
the durative action move  which propels the robot ahead  say at constant speed  indefinitely 
such an action contrasts with a discrete one  such as move forward one meter  in a t r
sequence  a durative action continues so long as its corresponding condition remains the first
true condition  when the first true condition changes  the action changes correspondingly 
thus  unlike production systems in computer science  the conditions must be continuously
evaluated  the action associated with the currently first true condition is always the one
being executed  an action terminates only when its energizing condition ceases to be the
first true condition 
indeed  rather than thinking of t r sequences in terms of the computer science idea of
discrete events  it is more appropriate to think of them as being implemented by circuitry 
for example  the sequence above can be implemented by the circuit shown in figure   
furthermore  we imagine that the conditions  ki   are also being continuously computed 
sensors
and
model

conditioncomputing
circuits

k 

a 


 

k 

a 



k 

 

a 

 

am



km

figure    implementing a t r sequence in circuitry
the actions  ai   of a t r sequence can either be primitive actions  or they can be t r
sequences themselves  thus  programs written in this formalism can be hierarchical  even
recursive  as we shall see later   in the case of hierarchical programs  it is important to
realize that all conditions at all levels of the hierarchy are continuously being evaluated  a
high level sequence can redirect control through a different path of lower level sequences as
dictated by the values of the conditions at the various levels 
   

finilsson

in writing a t r sequence  a programmer ordinarily works backward from whatever goal
condition the sequence is being designed to achieve  the condition k  is taken to be the
goal condition  and the corresponding action  a   is the null action  the condition k  is
the weakest condition such that when it is satisfied  and k  is not   the durative execution
of a  will  all other things being equal  eventually achieve k    and so on  each non null
action  ai   is supposed to achieve a condition  kj   strictly higher in the list  j   i   the
conditions are therefore regressions  nilsson        of higher conditions through the actions
that achieve those higher conditions 
formally  we say that a t r sequence satisfies the regression property if each condition 
 i       is the regression of some higher condition in the sequence  kj  j   i  
through the action ai   we say that a t r sequence is complete if and only if k            ki  
        km is a tautology  a t r sequence is universal if it satisfies the regression property
and is complete  it is easy to see that a universal t r sequence will always achieve its goal
condition  k    if there are no sensing or execution errors 

ki  m

sometimes an action does not have the effect that was anticipated by the agent s designer
 the normal effect   and sometimes exogenous events  separate from the actions of the
agent  change the world in unexpected ways  these phenomena  of course  are the reason
continuous feedback is required  universal t r sequences  like universal plans  schoppers 
       are robust in the face of occasional deviations from normal execution  they can
also exploit serendipitous effects  it may accidentally happen that an action achieves a
condition higher in the list of condition action rules than normally expected  even if an
action sometimes does not achieve its normal effect  due to occasional sensing or execution
errors   nevertheless some action will be executed  so long as the environment does not
too often frustrate the achievement of the normal effects of actions  the goal condition of a
universal t r sequence will ultimately be achieved 

    an example

the following rather simple example should make these ideas more concrete  consider the
simulated robots in figure    let s suppose that these robots can move bars around in
their two dimensional world  the robot on the right is holding a bar  and we want the
other robot to go to and grab the bar marked a  we presume that this robot can sense its
environment and can evaluate conditions which tell it whether or not it is already grabbing
bar a  is grabbing   facing toward bar a  facing bar   positioned with respect to bar a
so that it can reach and grab it  at bar center   on the perpendicular bisector of bar a
 on bar midline   and facing a zone on the perpendicular bisector of bar a from which it
would be appropriate to move toward bar a  facing midline zone   let s assume also that
these conditions have some appropriate amount of hysteresis so that hunting behavior is
dampened  suppose the robot is capable of executing the primitive actions grab bar  move 
and rotate with the obvious effects  execution of the following t r sequence will result in
the robot grabbing bar a 
   

fibar midline

a

bar center

midline zone

figure    robots and bars
notice how each properly executed action in this sequence achieves the condition in
the rule above it  in this way  the actions inexorably proceed toward the goal  occasional
setbacks merely cause delays in achieving the goal so long as the actions usually  achieve
their normal effects 
   teleo reactive programs
    rules with variables

we can generalize the notion of a t r sequence by permitting the rules to contain free
variables that are bound when the sequence is  called   we will call such a sequence a t r
program  additional generality is obtained if we assume that the variables are not necessarily
bound to constants but to quantities whose values are continuously being computed  as if
by circuitry  as the environment changes 
a simple example involving having a robot go to a designated goal location in two
dimensions will serve to illustrate  suppose the goal location is given by the value of the
variable loc  at run time  loc will be bound to a pair of x  y coordinates  although we allow
the binding to change during run time  at any time during the process  the robot s x  y
position is given by the value of the variable position   we assume that the robot has some
kind of navigational aid that reliably and continuously computes the value of position  
from the instantaneous values of loc and position  the robot can compute the direction that
   we do not choose to define usually more precisely here  although a probabilistic analysis could be given 

   

finilsson

it should face to proceed in a straight line toward loc  let the value of this direction at any
time be given by the value of the function course position  loc   at any time during the
process  the robot s angular heading is given by the value of the variable heading  using
these variables  the t r program to drive the robot to loc is 
goto loc 
equal position  loc 
equal heading  course position  loc  
t

 
 
 

nil
move
rotate

implementing goto loc  in circuitry is straightforward  the single parameter of the
program is loc whose  possibly changing  value is specified at run time by a user  by a
higher level program  or by circuitry  the other  global  parameters  position and heading 
are provided by circuitry  and we assume that the function course is continuously being
computed by circuitry  given the values of all of these parameters  computing which action
to energize is then computed by circuitry in the manner of figure   
    hierarchical programs

our formalism allows writing hierarchical and recursive programs in which the actions in
the rules are themselves t r programs  as an example  we can write a recursive navigation
program that calls goto  our new navigation program requires some more complex sensory
functions  imagine a function clear path place   place   that has value t if and only if
the direct path is clear between place  and place    we assume the robot can compute
this function  continuously  for place    position  and place  equal to any target location  
also imagine a function new point place   place   that computes an intermediate position
between place  and place  whenever clear path does not have value t   the value of newpoint lies appropriately to the side of the obstacle determined to be between place  and
place   so that if the robot heads toward new point first and then toward place   it can
navigate around the obstacle   both clear path and new point are continuously computed
by perceptual systems with which we endow the robot  we ll name our new navigation
program amble loc   here is the code 
amble loc 
equal position  loc 
clear path position  loc 
t

 
 
 

nil
goto loc 
amble new point position  loc  

we show in figure   the path that a robot controlled by this program might take in
navigating around the obstacles shown   the program doesn t necessarily compute shortest
paths  we present the program here simply as an illustration of recursion   note that if the
obstacle positions or goal location change during execution  these changes will be reected
in the values of the parameters used by the program  and program execution will proceed in
a manner appropriate to the changes  in particular  if a clear path ever becomes manifest
   

figoal location

figure    navigating using amble
the continuous computation of parameters involved in t r programs and the ability of
high level programs to redirect control account for the great robustness of this formalism 
a formal syntax for t r programs is given in  nilsson        
    implementational issues

the t r formalism  with its implicit assumption of continuous computation of conditions
and parameters  should be thought of as a fully legitimate  level  in the hierarchy of program
structure controlling the agent  regardless of how this level is implemented by levels below 
just as computer scientists think of list processing as a level of actual operation even though
it is implemented by more primitive logical operations below  if we assume  as we do  that
the pace of events in the agent s environment is slow compared with the amount of time
taken to perform the  continuous  computations required in a t r program  then the t r
programmer is justified in assuming  real  continuous sensing as s he writes programs  even
though the underlying implentation may involve discrete sampling   we recommend the
t r formalism only for those applications for which this assumption is justified  for those
applications  the t r level shields the programmer from having to worry about how that
level is implemented and greatly facilitates program construction 
there are several different ways in which t r programs can be interpreted into lower
level implementations  it is beyond the scope of this paper to do more than point out some
obvious methods  and we leave important questions about the properties of these methods
to subsequent research  one method of implementation involves the construction of actual
or simulated circuits according to the basic scheme of figure    first  the top level conditioncomputing circuits  including circuits for computing parameters used in the conditions  are
constructed and allowed to function  a specific action  say ai   is energized as a result  if ai
   

finilsson

is primitive  it is turned on  keeping the circuitry in place and functioning until some other
top level action is energized  and so on  if ai is a t r sequence  the circuitry needed to
implement it is constructed  just as was done at the top level   an action is selected  and
so on and all the while levels of circuitry above are left functioning  as new lower level
circuitry is constructed  any circuitry no longer functioning  that is  circuitry no longer
 called  by functioning higher level circuitry  can be garbage collected 
there are important questions of parameter passing and of timing in this process which
i do not deal with here relying on the assumption that the times needed to create circuitry and for the circuitry to function are negligible compared to the pace of events in the
world  this assumption is similar to the synchrony hypothesis in the esterel programming language  berry   gonthier        where it is assumed that a program s reaction       
takes no time with respect to the external environment  which remains invariant during  the
reaction   
although there is no reason in principle that circuitry could not be simulated or actually
constructed  using some sort of programmable network of logic gates   it is also straightforward to implement a t r program using more standard computational techniques  t r
programs can be written as lisp cond statements  and durative actions can be simulated
by iterating very short action increments  for example  the increment for the move action
for a simulated robot might move the robot ahead by a small amount  after each action
increment  the top level lisp cond is executed anew  and of course all of the functions and
parameters that it contains are evaluated anew  in our simulations of robots moving in
two dimensional worlds  to be discussed below   the computations involved are suciently
fast to effect a reasonable pace with apparent smooth motion 
this implementation method essentially involves sampling the environment at irregular
intervals  of course  there are questions concerning how the computation times  and thus
the sampling rate  affect the real time aspects of agent behavior which we do not address
here again assuming the sampling rate to be very short 
whatever method is used to interpret t r programs  care must be taken not to conate
the t r level with the levels below  the programmer ought not to have to think about
circuit simulators or sampling intervals but should imagine that sensing is done continuously
and immediately 
    graphical representations

the goto program can be represented by a graph as well as by the list of rules used earlier 
the graphical representation of this program is shown in figure    the nodes are labeled
by conditions  and the arcs by actions  to execute the graphical version of the program  we
look for the shallowest true node  taking the goal condition as the root  and execute the
action labeling the arc leading out from that node 
in the graph of figure    each action normally achieves the condition at the head of its arc
 when the condition at the tail of the arc is the shallowest true condition   if there is more
than one action that can achieve a condition  we would have a tree instead of a single path
graph  a more general graph  then  is a teleo reactive tree such as that depicted in figure   
t r trees are executed by searching for the shallowest true node and executing the action
labeling the arc leaving that node  alternatively  we could search for that true node judged
   

fiteleo reactive programs

equal position  loc 

move
equal heading  course position  loc  

rotate
t

figure    graphical representation of goto
to be on a path of least cost to the goal  where some appropriate heuristic measure of cost
is used   for simplicity  the phrase  shallowest true node  will be taken to mean either the
shallowest true node  literally  or the true node on a path of least cost to the goal   ties
among several equally shallow true nodes are broken according to a fixed tie breaking rule 
in figure   we see that  in particular  there are at least two ways to achieve condition k   
one way uses action a   when k  is the shallowest true node   and one way uses action a 
 when k  is the shallowest true node  
in analogy with the definitions given for t r sequences  a t r tree satisfies the regression
property if every non root node is the regression of its parent node through the action linking
it with its parent  a t r tree is complete if the disjunction of all of its conditions is a
tautology  a t r tree is universal if and only if it satisfies the regression property and is
also complete  with a fixed tie breaking rule  a t r tree becomes a t r sequence  if a
t r tree is universal  then so will be the corresponding t r sequence 
one might at first object to this method for executing a t r tree on the grounds that
the sequence of actions that emerge will hop erratically from one path to another  but
if the tree satisfies the regression property  and if the heuristic for measuring cost to the
goal is reasonable  then  however erratic the actions may appear to be   each successfully
executed action brings the agent closer to the goal 
   experiments

we have carried out several preliminary experiments with agents programmed in this language  using lisp cond statements and short action increments   one set of experiments
uses simulated robots acting in a two dimensional space  called botworld    of construction
   the original botworld interface  including the primitive perceptual functions and actions for its robots 
was designed and implemented by jonas karlsson for the next computer system  karlsson         sub 

   

finilsson

k 
a 

a 

k 

k 

km   
am
km

figure    a t r tree
materials  structures made from these materials  and other robots  the construction materials are bars  and the robots are to build structures by connecting the bars in various ways 
a robot can turn and move  can grab and release a suitably adjacent bar  can turn and move
a grabbed bar  and can connect a bar to other bars or structures  the robots continuously
sense whether or not they are holding a bar  and they  see  in front of them  giving them
information about the location of bars and structures   because of the existence of other
robots which may change the world in sometimes unexpected ways  it is important for each
robot to sense certain critical aspects of its environment continuously 
a typical botworld graphical display is shown in figure   
we have written various t r programs that cause the robots to build structures of
various kinds  like the triangle being constructed in figure     a robot controlled by one
of these programs exhibits homeostatic behavior  so long as the main goal  whatever it is 
is satisfied  the robot is inactive  whenever the goal  for whatever reason  is not satisfied 
the robot becomes active and persists until it achieves the goal  if another agent achieves
part or all of the goal  the robot carries on appropriately from the situation it finds itself
in to complete the process 
in our experiments  the conditions used in the t r rules are conditions on a model of
the environment that the robot constructs from its sensory system and maintains separately
from the t r mechanism  the use of a model permits a robot to perform its actions in
response to all the sensory stimuli  past and present  that have been used to help construct
the model  but  if the t r actions include direct changes to the model  in addition to those
sequently  patrick teo implemented a version that runs under x windows on any of several different workstations  teo               the latter version allows the simulation of several robots simultaneously 
each under the control of its own independently running process 

   

fiteleo reactive programs

figure    botworld display
changes resulting from perceived changes to the environment   then there is a potential for
undesirable instabilities  as with any system with positive feedback    the problem of how
to model the environment and how this model should be updated in response to sensory
data is a separate major research problem outside the scope of the work reported here  
in other experiments  we have used the nomadic technologies     series mobile robot 
the robot is equipped with a ring of    infrared sensors and a ring of    sonar sensors 
it is controlled via a radio modem by a macintosh ii running allegro common lisp  we
have implemented robust t r programs for some simple oce environment tasks  such as
wall following and corridor following  galles         the programs were initially developed
and debugged using the nomadics simulator of the actual robot  very few changes had to be
made in porting the programs from the simulator to the robot  in performing these tasks 
the robot is highly reactive and persistent even in the face of occasional extreme sonar or
infrared range errors and deliberate attempts to confuse it  the robot quickly adapts to
sudden changes in the environment  such as those caused by people sharing the hallways 
in writing t r programs  one need only be concerned with inventing the appropriate
predicates using the available perceptual functions and model database  one does not need
to worry about providing interrupts of lower level programs so higher level ones can regain
control  we have found that debugging t r programs presents some challenges  though 
since they are designed to be quite robust in the face of environmental uncertainty  they
also sometimes work rather well even though they are not completely debugged  these
residual errors might not have undesirable effects until the programs are used in higher
level programs making the higher ones more dicult to debug 
   

finilsson

   other approaches for specifying behavior

there have been several formalisms proposed for prescribing sensory directed  real time
activity in dynamic environments  some of these are closely related to the t r formalism
proposed here  in this section i point out the major similarities and differences between t r
programs and a representative  though not complete  sample of their closest relatives  the
other reactive formalisms are of two types  namely  those that sample their environments
at discrete intervals  perhaps rapidly enough to be suciently reactive   and those that
create circuitry  like t r programs   the discrete sampling systems do not abstract this
activity into a higher level in which the environment is monitored continuously  and most
of the circuitry creating systems do so prior to run time  unlike t r programs which create
circuitry at run time  
    discrete sampling systems
      production systems

as has already been mentioned  t r programs are similar to production systems  waterman   hayes roth         the intermediate level actions  ilas  used in the sri robot
shakey  nilsson        were programmed using production rules and were very much like
t r programs  a t r program also resembles a plan represented in triangle table form
constructed by strips  fikes  hart   nilsson         each of the conditions of a t r
sequence corresponds to a triangle table kernel  in the planex execution system for triangle tables  the action corresponding to the highest numbered satisfied kernel is executed 
a major difference between all of these previous production system style programs and tr programs is that t r programs are continuously responsive to the environment while
ordinary production systems are not 
      reactive plans

several researchers have adopted the approach of using the current situation to index into
a set of pre arranged action sequences  georgeff   lansky        schoppers        firby 
       this set can either be large enough to cover a substantial number of the situations
in which an agent is likely to find itself or it can cover all possible situations  in the latter
case  the plan set is said to be universal  unlike t r programs  these systems explicitly
sample their environments at discrete time steps rather than continuously  as with t r
programs  time space trade offs must be taken into account when considering how many
different conditions must be anticipated in providing reactive plans  ginsberg has noted
that in several domains  the number of situations likely to be encountered by the agent is
so intractably large that the agent is forced to postpone most of its planning until run time
when situations are actually encountered  ginsberg          for further discussion of this
point  see  selman          t r programs have the advantage that at least a rudimentary
form of planning  namely parameter binding  is done at run time  the prs system  georgeff
  lansky        is capable of more extensive planning at run time as well as reacting
appropriately to its current situation 
   

fiteleo reactive programs

      situated control rules

drummond  drummond        introduces the notion of a plan net which is a kind of petri
net  reisig        for representing the effects of actions  which can be executed in parallel  
taking into account the possible interactions of actions  he then projects the effects of all
possible actions from a present state up to some horizon  these effects are represented in
a structure called a plan projection  the plan projection is analyzed to see  for each state
in it  which states possibly have a path to the goal state  this analysis is a forward version
of the backward analysis used by a programmer in producing a t r tree  situated control
rules are the result of this analysis  they constrain the actions that might be taken at any
state to those which will result in a state that still possibly has a path to the goal  plan
nets and petri nets are based on discrete events and thus are not continuously responsive
to their environments in the way that t r programs are 
    circuit based systems

kaelbling has proposed a formalism called gapps  kaelbling        kaelbling   rosenschein         involving goal reduction rules  for implicitly describing how to achieve goals 
the gapps programmer defines the activity of an agent by providing sucient goal reduction rules to connect the agent s goals with the situations in which it might find itself 
these rules are then compiled into circuitry for real time control of the agent  rosenschein
and kaelbling  rosenschein   kaelbling        call such circuitry situated automata 
a collection of gapps rules for achieving a goal can be thought of as an implicit
specification of a t r program in which the computations needed to construct the program
are performed when the rules are compiled  the gapps programmer typically exerts less
specific control over the agent s activity leaving some of the work to the search process
performed by the gapps compiler  for example  a t r program to achieve a goal  p   can
be implicitly specified by the following gapps rule 
 defgoalr  ach  p 
 if   holds  p   do nil  
  holds  regress  a  p    do  a  
 t ach  regress  a  p     

the recursion defined by this rule bottoms out in rules of the form 
 defgoalr  ach  
  holds

   do

ff    

where  and are conditions and ff is a specific action 
gapps compiles its rules into circuitry before run time  whereas the circuit implementation of a t r program depends on parameters that are bound at run time  both systems
result in control that is continuously responsive to the environment 
in implementing a system to play a video game  chapman  chapman        compiles
production like rules into digital circuitry for real time control using an approach that he
calls  arbitration macrology   as in situated automata  the compilation process occurs
prior to run time 
brooks has developed a behavior language  bl   brooks         for writing reactive
robot control programs based on his  subsumption architecture   brooks         a similar
language  alfa  has been implemented by gat  gat         programs written in these
   

finilsson

languages compile into structures very much like circuits  again  compilation occurs prior
to run time  it has been relatively straightforward to translate examples of subsumptionarchitecture programs into t r programs 
in all of these circuit based systems  pre run time compiling means that more circuitry
must be built than might be needed in any given run because all possible contingencies
must be anticipated at compile time   but in t r programs  parameters are bound at run
time  and only that circuitry required for these specific bindings is constructed 
   future work

the t r formalism might easily be augmented to embody some features that have not been
discussed in this paper  explicit reference to time in specifying actions might be necessary 
for example  we might want to make sure that some action a is not initiated until after some
time t  and ceases after some time t   time predicates  whose time terms are evaluated
using an internal clock  may suce for this purpose 
also  in some applications we may want to control which conditions in a t r program
are actually tested  it may be  for example  that some conditions won t have to be checked
because their truth or falsity can be guessed with compelling accuracy 
simultaneous and asynchronous execution of multiple actions can be achieved by allowing the right hand side of rules to contain sets of actions  each member of the set is
then duratively executed asynchronously and independently  so long as the condition in the
rule that sustains this set remains the highest true condition   of course  the programmer
must decide under what conditions it is appropriate to call for parallel actions  future
work on related formalisms might reveal ways in which parallel actions might emerge from
the interaction of the program and its environment rather than having to be explicitly
programmed 
although we intend that t r programs for agent control be written by human programmers  we are also interested in methods for modifying them by automatic planning
and machine learning  we will briey discuss some of our preliminary ideas on planning
and learning here 
t r trees resemble the search trees constructed by those planning systems that work
backwards from a goal condition  the overall goal is the root of the tree  any non root
node gi is the regression of its parent node  gj through the action  ak   connecting them 
this similarity suggests that t r trees can be constructed  and modified  by an automatic
planning system capable of regressing conditions through durative actions  indeed triangle
tables  fikes  hart   nilsson         a degenerate form of t r tree consisting of only a
single path  were constructed by an automatic planning system and an ebl style generalizer
 mitchell  keller   kedar cabelli        
the reader might object that there is no reason to suppose that the search trees produced by an automatic planning process will contain nodes whose conditions are those that
the agent is likely to encounter in its behavior  a process of incremental modification  however  should gradually make these constructed trees more and more matched to the agent s
environment  if a tree for achieving a desired goal has no true nodes in a certain situation 
   agre s  running arguments  construct  agre        is one example of a circuit based system that can
add circuitry at run time as needed 

   

fiteleo reactive programs

it is as if the search process employed by an automatic planner had not yet terminated
because no subgoal in the search tree was satisfied in the current state  in this case  the
planning system can be called upon to continue to search  that is  the existing t r tree will
be expanded until a true node is produced  pruning of t r trees can be accomplished by
keeping statistics on how often their nodes are satisfied  portions of the trees that are never
or seldom used can be erased  early unpublished work by scott benson indicates that t r
programs can be effectively generated by automatic planning methods  benson        
in considering learning mechanisms  we note first that t r sequences are related to a
class of boolean functions that rivest has termed k decision lists  rivest        kohavi  
benson         a k decision list is an ordered list of condition value pairs in which each
condition is a conjunction of boolean variables of length at most k  and each value is a truth
value  t or f    the value of the boolean function represented by a k decision list is that
value associated with the highest true condition  rivest has shown that such functions are
polynomially pac learnable and has presented a supervised learning procedure for them 
we can see that a t r sequence whose conditions are limited to k length conjunctions of
boolean features is a slight generalization of k decision lists  the only difference is that
such a t r sequence can have more than two different  values   that is  actions   we
observe that such a t r sequence  with  say  n different actions  is also pac learnable
since its actions can be encoded with log  n decision lists  george john  john        has
investigated a supervised learning mechanism for learning t r sequences 
typically  the conditions used in t r programs are conjunctions of propositional features of the robot s world and or model  because a linear threshold function can implement
conjunctions  one is led to propose a neural net implementation of a t r sequence  the neural net implementation  in turn  evokes ideas about possible learning mechanisms  consider
the t r sequence 

k 
k 

 
 

a 
a 

   

ki

 

ai

   

km

 

am

suppose we stipulate that the ki are linear threshold functions of a set of propositional
features  the ai are not all necessarily distinct  in fact we will assume that there are only
k  m distinct actions  let these be denoted by b           bk   the network structure in figure
  implements such a t r sequence 
the propositional features tested by the conditions are grouped into an n dimensional
binary       vector  x called the input vector  the m conditions are implemented by m
threshold elements having weighted connections to the components of the input vector  the
process of finding the first true condition is implemented by a layer containing appropriate
inhibitory weights and and units such that only one and unit can ever have an output
value of    and that unit corresponds to the first true condition  a unique action is associated
with each condition through a layer of binary valued weights and or unit associators  each
   

finilsson

inhibitory weights
  or   weights

x

k 

v

b 

k 

v

b 

   

   

bi

v

ki

   

   

km
input
vector

   
   
bk

v
and
units

conditions

associators

actions

 or
units 

figure    a neural net that implements a t r sequence
and unit is connected to one and only one associator by a non zero weight  since only
one and unit can have a non zero output  only that unit s associator can have a non zero
output   but each associator could be connected to multiple and units   for example  if
action bi is to be associated with conditions kj and kl   then there will be unit weights from
the j th and l th and units to the associator representing action bi and zero valued weights
from all other and units to that associator  the action selected for execution is the action
corresponding to the single associator having the non zero output  we are investigating
various learning methods suggested by this neural net implementation 
work must also be done on the question of what constitutes a goal  i have assumed
goals of achievement  can mechanisms be found that continously avoid making certain
conditions true  or false  while attempting to achieve others  or suppose priorities on a
number of possibly mutually contradictory conditions are specified  what are reasonable
methods for attending to those achievable goals having the highest priorities 
also  it will be interesting to ask in what sense t r programs can be proved to be correct 
it would seem that verification would have to make assumptions about the dynamics of the
environment  some environments might be so malevolent that agents in them could never
achieve their goals  even so  a verifier equipped with a model of the effects of actions could
at least check to see that the regression property was satisfied and note any lapses 
more work remains on methods of implementing or interpreting t r programs and
the real time properties of implementations  these properties will  of course  depend on
the depth of the t r program hierarchy and on the conditions and features that must be
evaluated 
   

fiteleo reactive programs

finally  it might be worthwhile to investigate  fuzzy  versions of t r trees  one could
imagine fuzzy predicates that would energize actions with a  strength  that depends on
the degree to which the predicates are true  the sri robot  flakey  uses a fuzzy controller
 saotti  ruspini   konolige        
   conclusions

i have presented a formalism for specifying actions in dynamic and uncertain domains  since
this work rests on ideas somewhat different than those of conventional computer science  i
expect that considerably more analysis and experimentation will be required before the t r
formalism can be fully evaluated  the need in robotics for control theoretic ideas such as
homeostasis  continuous feedback  and stability appears to be suciently strong  however 
that it seems appropriate for candidate formalisms embodying these ideas to be put forward
for consideration 
experiments with the language will produce a stock of advice about how to write t r
programs effectively  already  for example  it is apparent that a sustaining condition in a
t r sequence must be carefully specified so that it is no more restrictive than it really needs
to be  an overly restrictive condition is likely to be rendered false by the very action that
it is supposed to sustain before that action succeeds in making a higher condition in the
sequence true  but  of course  overly restrictive conditions won t occur in t r programs
that satisfy the regression property 
to be usefully employed  t r programs  or any programs controlling agent action 
need to be embodied in an overall agent architecture that integrates perceptual processing 
goal selection  action computation  environmental modeling  and planning and learning
mechanisms  several architectural schemes have been suggested  and we will not summarize
them here except to say that three layers of control are often delineated  a typical example
is the sss architecture of connell  connell         his top  symbolic  layer does overall
goal setting and sequencing  the middle  subsumption  level selects specific actions  and
the lower  servo  level exerts standard feedback control over the effectors  we believe t r
programs would most appropriately be used in the middle level of such architectures 
the major limitation of t r programs is that they involve much more computation
than do programs that check only relevant conditions  most of the conditions computed by
a t r program in selecting an action are either irrelevant to the situation at hand or have
values that might be accurately predicted  if the programmer wanted to take the trouble
to do so   we are essentially trading computing time for ease of programming  and our
particular trade will only be advantageous in certain applications  among these  i think  is
the mid level control of robots and  possibly  software agents 
in conclusion  there are three main features embodied in the t r formalism  one is
continuous computation of the parameters and conditions on which action is based  tr programs allow for continuous feedback while still supporting parameter binding and
recursion  the second feature is the regression relationship between conditions in a t r
program  each condition is the regression of some condition closer to the goal through an
action that normally achieves that closer to the goal condition  the regression property
assures robust goal seeking behavior  third  the conceptual circuitry controlling action is
constructed at run time  and this feature permits programs to be universal while still being
   

finilsson

compact  in addition  t r programs are intuitive and easy to write and are written in a
formalism that is compatible with automatic planning and learning methods 
acknowledgements

i trace my interest in reactive  yet purposive  systems to my early collaborative work on
triangle tables and ilas  several former stanford students  including jonas karlsson  eric
ly  rebecca moore  and mark torrance  helped in the early stages of this work  i also
want to thank my sabbatical hosts  prof  rodney brooks at mit  prof  barbara grosz at
harvard  and the people at the santa fe institute  more recently  i have benefitted from
discussions with scott benson  george john  and ron kohavi  i also thank the anonymous
referees for their helpful suggestions  this work was performed under nasa grant ncc     and nsf grant iri         
references

agre  p          the dynamic structure of everyday life  tech  rep  tr       ai lab  
massachusetts institute of technology 
benson  s          unpublished working paper  robotics laboratory  stanford university 
berry  g     gonthier  g          the esterel synchronous programming language 
science of computer programming      no             november 
brooks  r          a robust layered control system for a mobile robot  ieee journal of
robotics and automation  march 
brooks  r          the behavior language user s guide  seymour implementation note   
ai lab   massachusetts institute of technology 
chapman  d          vision  instruction and action  tech  rep        ai lab   massachusetts institute of technology 
connell  j          sss  a hybrid architecture applied to robot navigation  research
report  ibm research division  t  j  watson research center  yorktown heights 
ny       
dean  t     wellman  m          planning and control  san francisco  ca  morgan kaufmann 
drummond  m          situated control rules  in proc  first international conf  on principles of knowledge representation and reasoning  san francisco  ca  morgan kaufmann 
fikes  r   hart  p     nilsson  n          learning and executing generalized robot plans 
artificial intelligence             
firby  r          an investigation into reactive planning in complex domains  in proc 
aaai     san francisco  ca  morgan kaufmann 
   

fiteleo reactive programs

galles  d          map building and following using teleo reactive trees  in intelligent
autonomous systems  ias    groen  f  c  a   hirose  s    thorpe  c  e   eds   
         washington  ios press 
gat  e          alfa  a language for programming reactive robotic control systems 
in proceedings      ieee robotics and automation conference 
georgeff  m     lansky  a          reactive reasoning and planning  in proc  aaai    
san francisco  ca  morgan kaufmann 
ginsberg  m  l          universal planning  an  almost  universally bad idea  aaai
magazine      no            winter 
john  g           squish  a preprocessing method for supervised learning of t r trees
from solution paths   unpublished   robotics laboratory  stanford university 
kaelbling  l  p          goals as parallel program specifications  in proceedings aaai    
       menlo park  ca  american association for artificial intelligence 
kaelbling  l  p     rosenschein  s  j          action and planning in embedded agents 
robotics and autonomous systems     nos    and           june 
karlsson  j          building a triangle using action nets  unpublished project paper 
computer science dept   stanford university  june 
kohavi  r     benson  s          research note on decision lists  machine learning     
        
maes  p          how to do the right thing  connection science     no            
mitchell  t  m   keller  r  m     kedar cabelli  s  t          explanation based generalization  a unifying view  machine learning           
nilsson  n  j          principles of artificial intelligence  san francisco  ca  morgan kaufmann 
nilsson  n   ed           shakey the robot  tech  note      artificial intelligence center 
sri international  menlo park  ca       
nilsson  n          toward agent programs with circuit semantics  tech  rep  stan cs         department of computer science  stanford university 
ramadge  p  j  g     wonham  w  m          the control of discrete event systems 
proceedings of the ieee      no            january 
reisig  w          petri nets  an introduction  springer verlag 
rivest  r  l          learning decision lists  machine learning             
   

finilsson

rosenschein  s  j    kaelbling  l p          the synthesis of machines with provable
epistemic properties  in proceedings of the      conference on theoretical aspects
of reasoning about knowledge  halpern  j   ed           san francisco  ca  morgan
kaufmann   updated version  technical note      artificial intelligence center  sri
international  menlo park  ca  
saotti  a   ruspini  e     konolige  k          integrating reactivity and goaldirectedness in a fuzzy controller  in proc  of the  nd fuzzy ieee conference  san
francisco  ca 
schoppers  m  j          universal plans for reactive robots in unpredictable domains 
in proceedings of ijcai     san francisco  ca  morgan kaufmann 
selman  b          near optimal plans  tractability  and reactivity  tech  rep   ai dept  
at t bell laboratories 
teo  p  c s           botworld    unpublished   robotics laboratory  computer science
dept   stanford university  december 
teo  p  c s          botworld structures   unpublished   robotics laboratory  computer
science dept   stanford university  june 
waterman  d  a    hayes roth  f          an overview of pattern directed inference
systems  in pattern directed inference systems  waterman  d  a    hayes roth  f 
 eds          new york academic press 
wilson  s          the animat path to ai  in from animals to animats  proceedings of
the first international conference on the simulation of adaptive behavior  meyer  j 
a     wilson  s   eds    cambridge  ma  the mit press bradford books 

   

fi