journal artificial intelligence research                 

submitted       published     

teleo reactive programs agent control
nils j  nilsson

nilsson cs stanford edu

robotics laboratory  department computer science
stanford university  stanford  ca       usa

abstract

formalism presented computing organizing actions autonomous agents
dynamic environments  introduce notion teleo reactive  t r  programs whose
execution entails construction circuitry continuous computation parameters conditions agent action based  addition continuous feedback 
t r programs support parameter binding recursion  primary difference
t r programs many circuit based systems circuitry t r programs
compact  constructed run time thus anticipate
contingencies might arise possible runs  addition  t r programs
intuitive easy write written form compatible automatic
planning learning methods  brie describe experimental applications t r
programs control simulated actual mobile robots 
   introduction

autonomous agents  mobile robots  typically operate dynamic uncertain
environments  environments sensed imperfectly  effects
always completely predictable  may subject changes agent s
control  designing agents operate environments presented challenges
standard methods artificial intelligence  based explicit declarative representations reasoning processes  prominent among alternative approaches
so called behavior based  situated  animat methods  brooks        maes        kaelbling   rosenschein        wilson         convert sensory inputs actions
much direct fashion ai systems based representation reasoning  many
alternative approaches share control theory central notion continuous
feedback environment necessary component effective action 
perhaps relatively easier control theorists computer scientists
deal continuous feedback control theorists accustomed thinking
controlling mechanisms composed analog electrical circuits physical
systems rather automata discrete read compute write cycles  notions
goal seeking servo mechanisms  homeostasis  feedback  filtering  stability so essential
control dynamic environments were developed analog circuitry mind 
circuits  nature  continously responsive inputs 
contrast  central ideas computer science  namely sequences  events 
discrete actions  subroutines  seem odds notion continuous feedback 
example  conventional programming one program calls another  calling
program suspended called program returns control  feature awkward
applications called program might encounter unexpected environmental

c      ai access foundation morgan kaufmann publishers  rights reserved 

finilsson

circumstances designed cope  cases  calling program
regain control interrupts explicitly provided programmer 
sure  attempts blend control theory computer science 
example  work ramadge wonham  ramadge   wonham        discrete event
systems used computer science notions events  grammars  discrete states
study control processes ideas appropriate  book dean
wellman  dean   wellman        focusses overlap control theory
artificial intelligence  little effort import fundamental control theory
ideas computer science  precisely set paper 
propose computational system works differently conventional ones 
formalism call circuit semantics  nilsson         program execution produces
 at least conceptually  electrical circuits  circuits used control 
importing control theory concept continuous feedback  nevertheless want
retain useful ideas computer science  control programs parameters
bound run time passed subordinate routines  hierarchical
organization  recursive  contrast behavior based
approaches  want programs responsive stored models environment
well immediate sensory inputs 
presentation ideas somewhat informal line belief
formalization best done certain amount experience obtained  although
preliminary experiments indicate formalism works quite well  work remains
done establish place agent control 
   teleo reactive sequences
    condition action rules

teleo reactive  t r  sequence agent control program directs agent toward
goal  hence teleo  manner takes account changing environmental circumstances
 hence reactive   simplest form  consists ordered set production rules 

k 
k 

 
 

a 
a 

   

ki

 

ai

   

km

 



ki conditions  on sensory inputs model world   ai
actions  on world change model   t r sequence interpreted
manner roughly similar way production systems interpreted 
list rules scanned top first rule whose condition part satisfied 
corresponding action executed  t r sequences differ substantively conventional
production systems  however  t r actions durative rather discrete  durative
   

fiteleo reactive programs

action one continues indefinitely  example  mobile robot capable executing
durative action move  propels robot ahead  say constant speed  indefinitely 
action contrasts discrete one  move forward one meter  t r
sequence  durative action continues long corresponding condition remains first
true condition  first true condition changes  action changes correspondingly 
thus  unlike production systems computer science  conditions must continuously
evaluated  action associated currently first true condition always one
executed  action terminates energizing condition ceases
first true condition 
indeed  rather thinking t r sequences terms computer science idea
discrete events  appropriate think implemented circuitry 
example  sequence implemented circuit shown figure   
furthermore  imagine conditions  ki   continuously computed 
sensors

model

conditioncomputing
circuits

k 

a 


 

k 

a 



k 

 

a 

 





km

figure    implementing t r sequence circuitry
actions  ai   t r sequence either primitive actions  t r
sequences themselves  thus  programs written formalism hierarchical  even
recursive  shall see later   case hierarchical programs  important
realize conditions levels hierarchy continuously evaluated 
high level sequence redirect control different path lower level sequences
dictated values conditions various levels 
   

finilsson

writing t r sequence  programmer ordinarily works backward whatever goal
condition sequence designed achieve  condition k  taken
goal condition  corresponding action  a   null action  condition k 
weakest condition satisfied  and k  not   durative execution
a   all things equal  eventually achieve k    on  non null
action  ai   supposed achieve condition  kj   strictly higher list  j   i  
conditions therefore regressions  nilsson        higher conditions actions
achieve higher conditions 
formally  say t r sequence satisfies regression property condition 
      regression higher condition sequence  kj  j   i  
action ai   say t r sequence complete k            ki  
        km tautology  t r sequence universal satisfies regression property
complete  easy see universal t r sequence always achieve goal
condition  k    sensing execution errors 

ki  m

sometimes action effect anticipated agent s designer
 the normal effect   sometimes exogenous events  separate actions
agent  change world unexpected ways  phenomena  course  reason
continuous feedback required  universal t r sequences  universal plans  schoppers 
       robust face occasional deviations normal execution 
exploit serendipitous effects  may accidentally happen action achieves
condition higher list condition action rules normally expected  even
action sometimes achieve normal effect  due occasional sensing execution
errors   nevertheless action executed  long environment
often frustrate achievement normal effects actions  goal condition
universal t r sequence ultimately achieved 

    example

following rather simple example make ideas concrete  consider
simulated robots figure    let s suppose robots move bars around
two dimensional world  robot right holding bar  want
robot go grab bar marked a  presume robot sense
environment evaluate conditions tell whether already grabbing
bar  is grabbing   facing toward bar  facing bar   positioned respect bar
reach grab  at bar center   perpendicular bisector bar
 on bar midline   facing zone perpendicular bisector bar
would appropriate move toward bar  facing midline zone   let s assume
conditions appropriate amount hysteresis hunting behavior
dampened  suppose robot capable executing primitive actions grab bar  move 
rotate obvious effects  execution following t r sequence result
robot grabbing bar a 
   

fibar midline



bar center

midline zone

figure    robots bars
notice properly executed action sequence achieves condition
rule it  way  actions inexorably proceed toward goal  occasional
setbacks merely cause delays achieving goal long actions usually  achieve
normal effects 
   teleo reactive programs
    rules variables

generalize notion t r sequence permitting rules contain free
variables bound sequence  called   call sequence t r
program  additional generality obtained assume variables necessarily
bound constants quantities whose values continuously computed  as
circuitry  environment changes 
simple example involving robot go designated goal location two
dimensions serve illustrate  suppose goal location given value
variable loc  run time  loc bound pair x  coordinates  although allow
binding change run time  time process  robot s x 
position given value variable position   we assume robot
kind navigational aid reliably continuously computes value position  
instantaneous values loc position  robot compute direction
   choose define usually precisely here  although probabilistic analysis could given 

   

finilsson

face proceed straight line toward loc  let value direction
time given value function course position  loc   time
process  robot s angular heading given value variable heading  using
variables  t r program drive robot loc is 
goto loc 
equal position  loc 
equal heading  course position  loc  


 
 
 

nil
move
rotate

implementing goto loc  circuitry straightforward  single parameter
program loc whose  possibly changing  value specified run time user 
higher level program  circuitry   global  parameters  position heading 
provided circuitry  assume function course continuously
computed circuitry  given values parameters  computing action
energize computed circuitry manner figure   
    hierarchical programs

formalism allows writing hierarchical recursive programs actions
rules t r programs  example  write recursive navigation
program calls goto  new navigation program requires complex sensory
functions  imagine function clear path place   place   value
direct path clear place  place    we assume robot compute
function  continuously  place    position  place  equal target location  
imagine function new point place   place   computes intermediate position
place  place  whenever clear path value   value newpoint lies appropriately side obstacle determined place 
place   so robot heads toward new point first toward place  
navigate around obstacle   clear path new point continuously computed
perceptual systems endow robot  we ll name new navigation
program amble loc   code 
amble loc 
equal position  loc 
clear path position  loc 


 
 
 

nil
goto loc 
amble new point position  loc  

show figure   path robot controlled program might take
navigating around obstacles shown   the program doesn t necessarily compute shortest
paths  present program simply illustration recursion   note
obstacle positions goal location change execution  changes ected
values parameters used program  program execution proceed
manner appropriate changes  particular  clear path ever becomes manifest
   

figoal location

figure    navigating using amble
continuous computation parameters involved t r programs ability
high level programs redirect control account great robustness formalism 
formal syntax t r programs given  nilsson        
    implementational issues

t r formalism  implicit assumption continuous computation conditions
parameters  thought fully legitimate  level  hierarchy program
structure controlling agent  regardless level implemented levels below 
computer scientists think list processing level actual operation even though
implemented primitive logical operations below  assume  as do 
pace events agent s environment slow compared amount time
taken perform  continuous  computations required t r program  t r
programmer justified assuming  real  continuous sensing s he writes programs  even
though underlying implentation may involve discrete sampling   recommend
t r formalism applications assumption justified 
applications  t r level shields programmer worry
level implemented greatly facilitates program construction 
several different ways t r programs interpreted lower
level implementations  beyond scope paper point
obvious methods  leave important questions properties methods
subsequent research  one method implementation involves construction actual
simulated circuits according basic scheme figure    first  top level conditioncomputing circuits  including circuits computing parameters used conditions 
constructed allowed function  specific action  say ai   energized result  ai
   

finilsson

primitive  turned on  keeping circuitry place functioning
top level action energized  on  ai t r sequence  circuitry needed
implement constructed  just done top level   action selected 
on and levels circuitry left functioning  new lower level
circuitry constructed  circuitry longer functioning  that is  circuitry longer
 called  functioning higher level circuitry  garbage collected 
important questions parameter passing timing process
deal here relying assumption times needed create circuitry circuitry function negligible compared pace events
world  assumption similar synchrony hypothesis esterel programming language  berry   gonthier        assumed program s reaction       
takes time respect external environment  remains invariant  the
reaction   
although reason principle circuitry could simulated actually
constructed  using sort programmable network logic gates   straightforward implement t r program using standard computational techniques  t r
programs written lisp cond statements  durative actions simulated
iterating short action increments  example  increment move action
simulated robot might move robot ahead small amount  action
increment  top level lisp cond executed anew  course functions
parameters contains evaluated anew  simulations robots moving
two dimensional worlds  to discussed below   computations involved suciently
fast effect reasonable pace apparent smooth motion 
implementation method essentially involves sampling environment irregular
intervals  course  questions concerning computation times  and thus
sampling rate  affect real time aspects agent behavior address
here again assuming sampling rate short 
whatever method used interpret t r programs  care must taken con ate
t r level levels below  programmer ought think
circuit simulators sampling intervals imagine sensing done continuously
immediately 
    graphical representations

goto program represented graph well list rules used earlier 
graphical representation program shown figure    nodes labeled
conditions  arcs actions  execute graphical version program 
look shallowest true node  taking goal condition root  execute
action labeling arc leading node 
graph figure    action normally achieves condition head arc
 when condition tail arc shallowest true condition  
one action achieve condition  would tree instead single path
graph  general graph  then  teleo reactive tree depicted figure   
t r trees executed searching shallowest true node executing action
labeling arc leaving node  alternatively  could search true node judged
   

fiteleo reactive programs

equal position  loc 

move
equal heading  course position  loc  

rotate


figure    graphical representation goto
path least cost goal  appropriate heuristic measure cost
used   for simplicity  phrase  shallowest true node  taken mean either
shallowest true node  literally  true node path least cost goal   ties
among several equally shallow true nodes broken according fixed tie breaking rule 
figure   see that  particular  least two ways achieve condition k   
one way uses action a   when k  shallowest true node   one way uses action a 
 when k  shallowest true node  
analogy definitions given t r sequences  t r tree satisfies regression
property every non root node regression parent node action linking
parent  t r tree complete disjunction conditions
tautology  t r tree universal satisfies regression property
complete  fixed tie breaking rule  t r tree becomes t r sequence 
t r tree universal  corresponding t r sequence 
one might first object method executing t r tree grounds
sequence actions emerge hop erratically one path another 
tree satisfies regression property  heuristic measuring cost
goal reasonable   however erratic actions may appear be   successfully
executed action brings agent closer goal 
   experiments

carried several preliminary experiments agents programmed language  using lisp cond statements short action increments   one set experiments
uses simulated robots acting two dimensional space  called botworld    construction
   original botworld interface  including primitive perceptual functions actions robots 
designed implemented jonas karlsson next computer system  karlsson         sub 

   

finilsson

k 
a 

a 

k 

k 

km   

km

figure    t r tree
materials  structures made materials  robots  construction materials bars  robots build structures connecting bars various ways 
robot turn move  grab release suitably adjacent bar  turn move
grabbed bar  connect bar bars structures  robots continuously
sense whether holding bar   see  front  giving
information location bars structures   existence
robots may change world sometimes unexpected ways  important
robot sense certain critical aspects environment continuously 
typical botworld graphical display shown figure   
written various t r programs cause robots build structures
various kinds  like triangle constructed figure     robot controlled one
programs exhibits homeostatic behavior  long main goal  whatever is 
satisfied  robot inactive  whenever goal  for whatever reason  satisfied 
robot becomes active persists achieves goal  another agent achieves
part goal  robot carries appropriately situation finds
complete process 
experiments  conditions used t r rules conditions model
environment robot constructs sensory system maintains separately
t r mechanism  use model permits robot perform actions
response sensory stimuli  past present  used help construct
model  but  t r actions include direct changes model  in addition
sequently  patrick teo implemented version runs x windows several different workstations  teo               latter version allows simulation several robots simultaneously 
control independently running process 

   

fiteleo reactive programs

figure    botworld display
changes resulting perceived changes environment   potential
undesirable instabilities  as system positive feedback    the problem
model environment model updated response sensory
data separate major research problem outside scope work reported here  
experiments  used nomadic technologies     series mobile robot 
robot equipped ring    infrared sensors ring    sonar sensors 
controlled via radio modem macintosh ii running allegro common lisp 
implemented robust t r programs simple oce environment tasks 
wall following corridor following  galles         programs initially developed
debugged using nomadics simulator actual robot  changes
made porting programs simulator robot  performing tasks 
robot highly reactive persistent even face occasional extreme sonar
infrared range errors deliberate attempts confuse it  robot quickly adapts
sudden changes environment  caused people sharing hallways 
writing t r programs  one need concerned inventing appropriate
predicates using available perceptual functions model database  one need
worry providing interrupts lower level programs higher level ones regain
control  found debugging t r programs presents challenges  though 
since designed quite robust face environmental uncertainty 
sometimes work rather well even though completely debugged 
residual errors might undesirable effects programs used higher
level programs making higher ones dicult debug 
   

finilsson

   approaches specifying behavior

several formalisms proposed prescribing sensory directed  real time
activity dynamic environments  closely related t r formalism
proposed here  section point major similarities differences t r
programs representative  though complete  sample closest relatives 
reactive formalisms two types  namely  sample environments
discrete intervals  perhaps rapidly enough suciently reactive  
create circuitry  like t r programs   discrete sampling systems abstract
activity higher level environment monitored continuously 
circuitry creating systems prior run time  unlike t r programs create
circuitry run time  
    discrete sampling systems
      production systems

already mentioned  t r programs similar production systems  waterman   hayes roth         intermediate level actions  ilas  used sri robot
shakey  nilsson        programmed using production rules much
t r programs  t r program resembles plan represented triangle table form
constructed strips  fikes  hart   nilsson         conditions t r
sequence corresponds triangle table kernel  planex execution system triangle tables  action corresponding highest numbered satisfied kernel executed 
major difference previous production system style programs tr programs t r programs continuously responsive environment
ordinary production systems not 
      reactive plans

several researchers adopted approach using current situation index
set pre arranged action sequences  georgeff   lansky        schoppers        firby 
       set either large enough cover substantial number situations
agent likely find cover possible situations  latter
case  plan set said universal  unlike t r programs  systems explicitly
sample environments discrete time steps rather continuously  t r
programs  time space trade offs must taken account considering many
different conditions must anticipated providing reactive plans  ginsberg noted
several domains  number situations likely encountered agent
intractably large agent forced postpone planning run time
situations actually encountered  ginsberg          for discussion
point  see  selman          t r programs advantage least rudimentary
form planning  namely parameter binding  done run time  prs system  georgeff
  lansky        capable extensive planning run time well reacting
appropriately current situation 
   

fiteleo reactive programs

      situated control rules

drummond  drummond        introduces notion plan net kind petri
net  reisig        representing effects actions  which executed parallel  
taking account possible interactions actions  projects effects
possible actions present state horizon  effects represented
structure called plan projection  plan projection analyzed see  state
it  states possibly path goal state  analysis forward version
backward analysis used programmer producing t r tree  situated control
rules result analysis  constrain actions might taken
state result state still possibly path goal  plan
nets petri nets based discrete events thus continuously responsive
environments way t r programs are 
    circuit based systems

kaelbling proposed formalism called gapps  kaelbling        kaelbling   rosenschein         involving goal reduction rules  implicitly describing achieve goals 
gapps programmer defines activity agent providing sucient goal reduction rules connect agent s goals situations might find itself 
rules compiled circuitry real time control agent  rosenschein
kaelbling  rosenschein   kaelbling        call circuitry situated automata 
collection gapps rules achieving goal thought implicit
specification t r program computations needed construct program
performed rules compiled  gapps programmer typically exerts less
specific control agent s activity leaving work search process
performed gapps compiler  example  t r program achieve goal  p  
implicitly specified following gapps rule 
 defgoalr  ach  p 
 if   holds  p   do nil  
  holds  regress  a  p    do  a  
 t ach  regress  a  p     

recursion defined rule bottoms rules form 
 defgoalr  ach  
  holds

   do

ff    

conditions specific action 
gapps compiles rules circuitry run time  whereas circuit implementation t r program depends parameters bound run time  systems
result control continuously responsive environment 
implementing system play video game  chapman  chapman        compiles
production like rules digital circuitry real time control using approach
calls  arbitration macrology   situated automata  compilation process occurs
prior run time 
brooks developed behavior language  bl   brooks         writing reactive
robot control programs based  subsumption architecture   brooks         similar
language  alfa  implemented gat  gat         programs written
   

finilsson

languages compile structures much circuits  again  compilation occurs prior
run time  relatively straightforward translate examples subsumptionarchitecture programs t r programs 
circuit based systems  pre run time compiling means circuitry
must built might needed given run possible contingencies
must anticipated compile time   t r programs  parameters bound run
time  circuitry required specific bindings constructed 
   future work

t r formalism might easily augmented embody features
discussed paper  explicit reference time specifying actions might necessary 
example  might want make sure action initiated
time t  ceases time t   time predicates  whose time terms evaluated
using internal clock  may suce purpose 
also  applications may want control conditions t r program
actually tested  may be  example  conditions won t checked
truth falsity guessed compelling accuracy 
simultaneous asynchronous execution multiple actions achieved allowing right hand side rules contain sets actions  member set
duratively executed asynchronously independently  so long condition
rule sustains set remains highest true condition   course  programmer
must decide conditions appropriate call parallel actions  future
work related formalisms might reveal ways parallel actions might emerge
interaction program environment rather explicitly
programmed 
although intend t r programs agent control written human programmers  interested methods modifying automatic planning
machine learning  brie discuss preliminary ideas planning
learning here 
t r trees resemble search trees constructed planning systems work
backwards goal condition  overall goal root tree  non root
node gi regression parent node  gj action  ak   connecting them 
similarity suggests t r trees constructed  and modified  automatic
planning system capable regressing conditions durative actions  indeed triangle
tables  fikes  hart   nilsson         degenerate form t r tree consisting
single path  constructed automatic planning system ebl style generalizer
 mitchell  keller   kedar cabelli        
reader might object reason suppose search trees produced automatic planning process contain nodes whose conditions
agent likely encounter behavior  process incremental modification  however  gradually make constructed trees matched agent s
environment  tree achieving desired goal true nodes certain situation 
   agre s  running arguments  construct  agre        one example circuit based system
add circuitry run time needed 

   

fiteleo reactive programs

search process employed automatic planner yet terminated
subgoal search tree satisfied current state  case 
planning system called upon continue search  is  existing t r tree
expanded true node produced  pruning t r trees accomplished
keeping statistics often nodes satisfied  portions trees never
seldom used erased  early unpublished work scott benson indicates t r
programs effectively generated automatic planning methods  benson        
considering learning mechanisms  note first t r sequences related
class boolean functions rivest termed k decision lists  rivest        kohavi  
benson         k decision list ordered list condition value pairs
condition conjunction boolean variables length k  value truth
value  t f    value boolean function represented k decision list
value associated highest true condition  rivest shown functions
polynomially pac learnable presented supervised learning procedure them 
see t r sequence whose conditions limited k length conjunctions
boolean features slight generalization k decision lists  difference
t r sequence two different  values   that is  actions  
observe t r sequence  with  say  n different actions  pac learnable
since actions encoded log  n decision lists  george john  john       
investigated supervised learning mechanism learning t r sequences 
typically  conditions used t r programs conjunctions propositional features robot s world and or model  linear threshold function implement
conjunctions  one led propose neural net implementation t r sequence  neural net implementation  turn  evokes ideas possible learning mechanisms  consider
t r sequence 

k 
k 

 
 

a 
a 

   

ki

 

ai

   

km

 



suppose stipulate ki linear threshold functions set propositional
features  ai necessarily distinct  fact assume
k distinct actions  let denoted b           bk   network structure figure
  implements t r sequence 
propositional features tested conditions grouped n dimensional
binary       vector  x called input vector  conditions implemented
threshold elements weighted connections components input vector 
process finding first true condition implemented layer containing appropriate
inhibitory weights units one unit ever output
value    unit corresponds first true condition  unique action associated
condition layer binary valued weights or unit associators 
   

finilsson

inhibitory weights
    weights

x

k 

v

b 

k 

v

b 

   

   

bi

v

ki

   

   

km
input
vector

   
   
bk

v

units

conditions

associators

actions

 or
units 

figure    neural net implements t r sequence
unit connected one one associator non zero weight  since
one unit non zero output  unit s associator non zero
output   but associator could connected multiple units   example 
action bi associated conditions kj kl   unit weights
j th l th units associator representing action bi zero valued weights
units associator  action selected execution action
corresponding single associator non zero output  investigating
various learning methods suggested neural net implementation 
work must done question constitutes goal  assumed
goals achievement  mechanisms found continously avoid making certain
conditions true  or false  attempting achieve others  suppose priorities
number possibly mutually contradictory conditions specified  reasonable
methods attending achievable goals highest priorities 
also  interesting ask sense t r programs proved correct 
would seem verification would make assumptions dynamics
environment  environments might malevolent agents could never
achieve goals  even so  verifier equipped model effects actions could
least check see regression property satisfied note lapses 
work remains methods implementing interpreting t r programs
real time properties implementations  properties will  course  depend
depth t r program hierarchy conditions features must
evaluated 
   

fiteleo reactive programs

finally  might worthwhile investigate  fuzzy  versions t r trees  one could
imagine fuzzy predicates would energize actions  strength  depends
degree predicates true  sri robot  flakey  uses fuzzy controller
 saotti  ruspini   konolige        
   conclusions

presented formalism specifying actions dynamic uncertain domains  since
work rests ideas somewhat different conventional computer science 
expect considerably analysis experimentation required t r
formalism fully evaluated  need robotics control theoretic ideas
homeostasis  continuous feedback  stability appears suciently strong  however 
seems appropriate candidate formalisms embodying ideas put forward
consideration 
experiments language produce stock advice write t r
programs effectively  already  example  apparent sustaining condition
t r sequence must carefully specified restrictive really needs
be  overly restrictive condition likely rendered false action
supposed sustain action succeeds making higher condition
sequence true  but  course  overly restrictive conditions won t occur t r programs
satisfy regression property 
usefully employed  t r programs  or programs controlling agent action 
need embodied overall agent architecture integrates perceptual processing 
goal selection  action computation  environmental modeling  planning learning
mechanisms  several architectural schemes suggested  summarize
except say three layers control often delineated  typical example
sss architecture connell  connell         top  symbolic  layer overall
goal setting sequencing  middle  subsumption  level selects specific actions 
lower  servo  level exerts standard feedback control effectors  believe t r
programs would appropriately used middle level architectures 
major limitation t r programs involve much computation
programs check relevant conditions  conditions computed
t r program selecting action either irrelevant situation hand
values might accurately predicted  if programmer wanted take trouble
so   essentially trading computing time ease programming 
particular trade advantageous certain applications  among these  think 
mid level control robots  possibly  software agents 
conclusion  three main features embodied t r formalism  one
continuous computation parameters conditions action based  tr programs allow continuous feedback still supporting parameter binding
recursion  second feature regression relationship conditions t r
program  condition regression condition closer goal
action normally achieves closer to the goal condition  regression property
assures robust goal seeking behavior  third  conceptual circuitry controlling action
constructed run time  feature permits programs universal still
   

finilsson

compact  addition  t r programs intuitive easy write written
formalism compatible automatic planning learning methods 
acknowledgements

trace interest reactive  yet purposive  systems early collaborative work
triangle tables ilas  several former stanford students  including jonas karlsson  eric
ly  rebecca moore  mark torrance  helped early stages work 
want thank sabbatical hosts  prof  rodney brooks mit  prof  barbara grosz
harvard  people santa fe institute  recently  benefitted
discussions scott benson  george john  ron kohavi  thank anonymous
referees helpful suggestions  work performed nasa grant ncc     nsf grant iri         
references

agre  p          dynamic structure everyday life  tech  rep  tr       ai lab  
massachusetts institute technology 
benson  s          unpublished working paper  robotics laboratory  stanford university 
berry  g     gonthier  g          esterel synchronous programming language 
science computer programming      no             november 
brooks  r          robust layered control system mobile robot  ieee journal
robotics automation  march 
brooks  r          behavior language user s guide  seymour implementation note   
ai lab   massachusetts institute technology 
chapman  d          vision  instruction action  tech  rep        ai lab   massachusetts institute technology 
connell  j          sss  hybrid architecture applied robot navigation  research
report  ibm research division  t  j  watson research center  yorktown heights 
ny       
dean  t     wellman  m          planning control  san francisco  ca  morgan kaufmann 
drummond  m          situated control rules  proc  first international conf  principles knowledge representation reasoning  san francisco  ca  morgan kaufmann 
fikes  r   hart  p     nilsson  n          learning executing generalized robot plans 
artificial intelligence             
firby  r          investigation reactive planning complex domains  proc 
aaai     san francisco  ca  morgan kaufmann 
   

fiteleo reactive programs

galles  d          map building following using teleo reactive trees  intelligent
autonomous systems  ias    groen  f  c  a   hirose  s    thorpe  c  e   eds   
         washington  ios press 
gat  e          alfa  language programming reactive robotic control systems 
proceedings      ieee robotics automation conference 
georgeff  m     lansky  a          reactive reasoning planning  proc  aaai    
san francisco  ca  morgan kaufmann 
ginsberg  m  l          universal planning   almost  universally bad idea  aaai
magazine      no            winter 
john  g           squish  preprocessing method supervised learning t r trees
solution paths   unpublished   robotics laboratory  stanford university 
kaelbling  l  p          goals parallel program specifications  proceedings aaai    
       menlo park  ca  american association artificial intelligence 
kaelbling  l  p     rosenschein  s  j          action planning embedded agents 
robotics autonomous systems     nos              june 
karlsson  j          building triangle using action nets  unpublished project paper 
computer science dept   stanford university  june 
kohavi  r     benson  s          research note decision lists  machine learning     
        
maes  p          right thing  connection science     no            
mitchell  t  m   keller  r  m     kedar cabelli  s  t          explanation based generalization  unifying view  machine learning           
nilsson  n  j          principles artificial intelligence  san francisco  ca  morgan kaufmann 
nilsson  n   ed           shakey robot  tech  note      artificial intelligence center 
sri international  menlo park  ca       
nilsson  n          toward agent programs circuit semantics  tech  rep  stan cs         department computer science  stanford university 
ramadge  p  j  g     wonham  w  m          control discrete event systems 
proceedings ieee      no            january 
reisig  w          petri nets  introduction  springer verlag 
rivest  r  l          learning decision lists  machine learning             
   

finilsson

rosenschein  s  j    kaelbling  l p          synthesis machines provable
epistemic properties  proceedings      conference theoretical aspects
reasoning knowledge  halpern  j   ed           san francisco  ca  morgan
kaufmann   updated version  technical note      artificial intelligence center  sri
international  menlo park  ca  
saotti  a   ruspini  e     konolige  k          integrating reactivity goaldirectedness fuzzy controller  proc   nd fuzzy ieee conference  san
francisco  ca 
schoppers  m  j          universal plans reactive robots unpredictable domains 
proceedings ijcai     san francisco  ca  morgan kaufmann 
selman  b          near optimal plans  tractability  reactivity  tech  rep   ai dept  
at t bell laboratories 
teo  p  c s           botworld    unpublished   robotics laboratory  computer science
dept   stanford university  december 
teo  p  c s          botworld structures   unpublished   robotics laboratory  computer
science dept   stanford university  june 
waterman  d  a    hayes roth  f          overview pattern directed inference
systems  pattern directed inference systems  waterman  d  a    hayes roth  f 
 eds          new york academic press 
wilson  s          animat path ai  animals animats  proceedings
first international conference simulation adaptive behavior  meyer  j 
a     wilson  s   eds    cambridge  ma  mit press bradford books 

   


