journal artificial intelligence research                

submitted       published      

diculties learning logic programs cut
francesco bergadano

bergadan di unito it

daniele gunetti
umberto trinchero

gunetti di unito it
trincher di unito it

universita di catania  dipartimento di matematica 
via andrea doria          catania  italy
universita di torino  dipartimento di informatica 
corso svizzera            torino  italy

abstract

real logic programmers normally use cut      effective learning procedure logic
programs able deal it  cut predicate procedural
meaning  clauses containing cut cannot learned using extensional evaluation method 
done learning systems  hand  searching space possible
programs  instead space independent clauses  unfeasible  alternative solution
generate first candidate base program covers positive examples 
make consistent inserting cut appropriate  problem learning programs
cut investigated seems natural reasonable
approach  generalize scheme investigate diculties arise 
major shortcomings actually caused  general  need intensional evaluation 
conclusion  analysis paper suggests  precise technical grounds 
learning cut dicult  current induction techniques probably restricted
purely declarative logic languages 

   introduction

much recent research ai machine learning addressing problem learning
relations examples  especially title inductive logic programming  muggleton         one goal line research  although certainly one 
inductive synthesis logic programs  generally  interested construction
program development tools based machine learning techniques  techniques
include ecient algorithms induction logical descriptions recursive relations 
however  real logic programs contain features purely logical  notably
cut     predicate  problem learning programs cut studied
inductive logic programming  paper analyzes diculties involved 

    learn programs cut 

two main motivations learning logic programs cut 
   ilp provide practical tools developing logic programs  context
general program development methodology  e g    bergadano      b    real
size logic programs normally contain cut  learning cut important creating
integrated software engineering framework 

c      ai access foundation morgan kaufmann publishers  rights reserved 

fibergadano  gunetti    trinchero

   extensive use cut make programs sensibly shorter  diculty learning
given logic program much related length 
objectives  need cuts make programs
ecient without changing input output behavior   green cuts    cuts
eliminate possible computed results   red cuts    red cuts sometimes considered
bad programming style  often useful  moreover  red cuts effective
making programs shorter  green cuts important  less controversial 
correct program inferred via inductive methods  could made ecient
insertion green cuts  either manually means automated program
transformation techniques  lau   clement        

    standard approaches cannot used 
machine learning algorithms generate rules clauses one time independently
other  rule useful  it covers positive example  correct  it
cover negative example   added description program
generated  positive examples covered  means searching
space possible clauses  without backtracking  obviously great advantage 
programs sets clauses  therefore space possible programs exponentially
larger 
one principle allows simplification problem extensional
evaluation possible clauses  used determine whether clause c covers example
e  fact clause c covers example e used approximation
fact logic program containing c derives e  consider  instance  clause c  
 p x y  ff   suppose example e p a b   order see whether c covers e 
extensionality principle makes us evaluate literal true matches
given positive example  instance    q x z    p z y   example p a b 
extensionally covered iff ground term c q a c  p c b  given
positive examples  particular  order obtain truth value p c b  
need call clauses learned previously  reason  determining
whether c covers e depends c positive examples  therefore  learning
system decide whether accept c part final program p independently
clauses p contain 
extensionality principle found foil  quinlan        derivatives 
used bottom up methods golem  muggleton   feng         shapiro s mis
system  shapiro        uses refining clauses  although backtracing
inconsistencies  used extensional evaluation clauses filp system
 bergadano   gunetti        
learning programs cut  clauses longer independent standalone extensional evaluation meaningless  cut predicate evaluated  possible clauses proving goal ignored  changes meaning
clauses  even clause extensionally covers example e  may case
final program derive e  derivation paths eliminated
evaluation cut predicate 
  

fithe difficulties learning logic programs cut

however  exhaustive search space programs prohibitive  learning methods 
even based extensionality  often considered inecient sucient prior information
available  searching sets clauses exponentially worse  would amount
brute force enumeration possible logic programs containing cut  program
consistent given examples found 

    alternative method 

cut eliminate computed results  i e   adding cut program 
may case example longer derived  observation suggests general
learning strategy  base program p induced standard techniques  given positive
maybe negative examples  remaining negative examples ruled
inserting cut clause p  obviously  inserting cut  must make sure
positive examples may still derived 
given present technology discussion above  seems viable
path possible solution  using standard techniques  base program p would generated one clause time  positive examples extensionally covered  however 
think view restrictive  programs derive given positive
examples  although cover extensionally  bergadano      a  deraedt 
lavrac    dzeroski         generally  consider traces positive examples 

definition   given hypothesis space possible clauses  example e
 

e  set clauses ts used derivation e called trace e 

use candidate base program p subset union
traces positive examples  ps extensionally covers positive examples 
union traces  converse always true  candidate
program generated  attempt made insert cuts negative examples
derived  successful  solution  otherwise  backtrack another
candidate base program  analyze many problems inherent learning cut
class trace based learning methods  but  discuss later  section    
problems need faced restrictive framework extensional evaluation 
words  even choose learn base program p extensionally 
try make consistent using cut  computational problems would still arise 
main difference standard approaches based extensionality allow
backtracking guarantee correct solution found  bergadano      a  
far computational complexity concerned  trace based methods complexity
standing search space independent clauses  for extensional methods 
exhaustive search space possible programs  need following 

definition   given hypothesis space s  depth example e maximum

number clauses successfully used derivation e 

example  list processing domain  contains recursive calls
type  p  hjt           p t        depth example p l  length l 
practical program induction tasks  often case depth example
  

fibergadano  gunetti    trinchero

related complexity  hypothesis space s  maximum depth
given positive examples  complexity trace based methods order
js jmd  extensional methods enumerate possible clauses complexity
linear js j  enumerating possible programs exponential js j 

   simple induction procedure
trace based induction procedure analyze takes input finite set clauses
set positive negative examples e  e  tries find subset
derives positive examples none negative examples  every
positive example e    e   assume large enough derive it  moreover 
assume clauses attened    case  clauses attened
preprocessing step 
consider one possible proof   e   build intermediate program
containing trace derivation  done positive examples 
corresponding traces merged  every time updated  checked
negative examples  derived t  cut     inserted antecedents
clauses t  consistent program found  exists  case 
procedure backtracks different proof   e   algorithm informally
described follows 
input  set clauses
set positive examples e 
set negative examples es    atten s 
 
positive example e    e 
find t  t   sld e   backtracking point   
  t 
derives negative example e  trycut t e  
trycut t e   fails backtrack
output clauses listed
trycut t e   
insert   somewhere  backtracking point   
   previously covered positive examples still derived t 
     sld e 

complexity adding cut somewhere trace t  negative example eis longer derived  obviously depends size t  size depends
depth positive examples  size hypothesis space s  although
   clause flattened contain functional symbol  given un attened clause  alway
possible atten  by turning functions new predicates additional argument representing
result function  vice versa  rouveirol  press  

  

fithe difficulties learning logic programs cut

clever ways devised  based particular example e   propose
simple enumerative technique implementation described appendix 

   example  simplifying list

section show example use induction procedure learn logic
program  simplify    simplify takes input list whose members may lists 
transforms   attened  list single members  containing repetitions
lists members  program appears exercise number     coelho   cotta        
composed nine clauses  plus clauses append member   six
recursive  one doubly recursive cut extensively used  even simplify
complex logic program  complex usual ilp test cases  instance 
quicksort partition program  often used  composed five
clauses  plus append   three recursive  moreover  note
conciseness simplify essentially due extensive use cut  without cut 
program would much longer  general  longer logic program  dicult
learn it 
consequence  start relatively strong bias  suppose following
hypothesis space n      possible clauses defined user 



clause  simplify l nl     atten l l    remove l  nl   
clauses whose head   atten x l   whose body composed conjunction
following literals 
head x h   tail x l    equal x  l  t    null t   null h   null l    equal x  l    
atten h x    atten l  x   
append x  x  l   assign x  l   assign x  l   list x l  



clauses whose head  remove il ol   whose body composed conjunction following literals 
cons x n ol   null il   assign    ol  
head il x   tail il l   member x l   remove l ol   remove l n  



correct clauses null  head  tail  equal  assign  member  append given 
null     
head  hj   h  
tail   jt  t  
equal x x  
assign x x  
member x  xj    
member x   jt      member x t  
  

fibergadano  gunetti    trinchero

append    z z  
append  hjx  y  hjz      append x y z  
using various kinds constraints  initial number clauses strongly reduced 
possible constraints following 
output produced must instantiated again  means
variable cannot occur output antecedent once 
inputs must used  input variables head clause must occur
antecedent 
conjunctions literals ruled never true  e g 
null il  head il x  
applying various combination constraints possible strongly restrict
initial hypothesis space  given input learning procedure  set
positive negative examples used learning task is 
simplify pos       b a a        b a    remove pos  a a   a   
 simplify neg       b a a       x  not equal x  b a    
simplify neg   a b a       a  b a     remove neg  a a   a a   
note define negative examples simplify examples
input given positive example different output  instance simplify neg       b a a        a b    obviously  possible give negative examples
normal ground literals  learning procedure outputs program simplify reported
below  turns substantially equivalent one described  coelho  
cotta         we kept clauses un attened  
simplify l nl     atten l l    remove l  nl  
atten x l     equal x  l  t    null t      atten l  x    assign x  l  
atten x l     head x h   tail x l    null h      atten l  x    assign x  l  
atten x l     equal x  l        atten l  x    assign x  l  
atten x l     head x h   tail x l      
atten h x       atten l  x    append x  x  l  
atten x l     list x l  
remove il ol     head il x   tail il l   member x l      remove l ol  
remove il ol     head il x   tail il l   remove l n   cons x n ol  
remove il ol     null il   assign    ol  
learning task takes    seconds implementation  however  obtained
special conditions  thoroughly discussed next sections 
constraints listed applied  final hypothesis space
reduced less one hundred clauses 
  

fithe difficulties learning logic programs cut





clauses hypothesis space generated correct order  must appear
final program  moreover  literals clause correct position 
important  since logic program cut relative position clauses
literals significant  consequence  learn simplify without test
different clause literal orderings  see subsections          
tell learning procedure use two cuts per clause  seems
quite intuitive constraint since  fact  many classical logic programs
one cut per clause  see subsections          

   problems

experiments induction procedure shown many problems arise
learning logic programs containing cut  following  analyze problems 
major contribution present paper  cut cannot evaluated extensionally 
analysis general  depend specific induction method adopted 
possible partial solutions discussed section   

    problem    intensional evaluation  backtracking cut

learning procedure section   simple  inecient  however 
believe common every intensional method  clauses cannot learned
independently one another  consequence  backtracking cannot avoided
impact complexity learning process  moreover  cut must
added every trace covering negative examples  constraints force 
range one cut whole trace cut two literals clause
trace  clearly  number possibilities exponential number literals
trace  fortunately  number usually much smaller size hypothesis
space  depends depth positive examples 
however  backtracking advantages  particular  useful search
alternative solutions  alternative programs confronted basis
required characteristic  simplicity eciency  example  using backtracking
discovered version simplify equivalent one given without cut predicate
two recursive calls fourth clause flatten 

    problem    ordering clauses trace

logic program containing cut  mutual position clauses significant  different ordering lead different  perhaps wrong  behavior program  example 
following program intersection 

c   int x s  y     null x   null y  
c   int x s  y     head x h   tail x tail   member h s       int tail s  s   cons h s y  
c   int x s  y     head x h   tail x tail   int tail s  y  
behaves correctly c  comes c   suppose hypothesis space given input
induction procedure consists three clauses above  c 
  

fibergadano  gunetti    trinchero

c    int  a   a      given negative example  learning task fails 
clauses c  c  derive example 

words  learning program containing cut means learn set
clauses  specific ordering clauses  terms induction procedure
means every trace covering negative example  must check
every position inserting cuts  every possible clause ordering trace 
 generate test  behavior dicult implement  dramatically decrease
performance learning task  worst case possible permutations must
generated checked  requires time proportional  md   trace md
clauses   
necessity test different permutations clauses trace primary source
ineciency learning programs cut  probably dicult problem
solve 

    problem    kinds given examples

induction procedure able learn programs traces  i e  every
clause program used derive least one positive example  learning definite
clauses  problem  derivation monotone  every program p 
complete consistent w r t  given examples  program p p
complete consistent trace   hand  learning clauses containing cut  may happen complete consistent program s  hypothesis
space neither trace  contains subset  derivation longer
monotone case negative example derived set clauses 
superset them  following simple example 
  fsum a b c     a       a    sum m b n   c n   
sum a b c     c b g
sum pos         sum neg        
two clauses hypothesis space represent complete consistent program
given examples  procedure unable learn it  observe negative
example derived second clause  trace positive example 
first second together 
problem avoided require that  every negative example  corresponding positive example input given  in case  example
required sum pos          way  complete program exists hypothesis
space  trace  learned  made consistent using
cut  order rule derivation negative examples  constraint positive
negative examples seems quite intuitive  fact  writing program 
   must noted learning programs two different predicates  j k clauses
respectively  that is  md   j  k   consider  j  k   different programs 
j   k   better if  inside program  known non recursive clauses fixed
position  put recursive clauses 
   learned program p complete derives given positive examples  consistent
derive given negative examples

  

fithe difficulties learning logic programs cut

programmer usually thinks terms program compute given inputs 
tries avoid wrong computations inputs 

    problem    ordering given examples
learning clauses cut  even order positive examples may significant 
example above  sum pos        comes sum pos        learning task
fails learn correct program sum  cannot find program consistent w r t 
first positive example negative one s  
general  given set positive examples problem remedied
testing different example orderings  again  worst case k  different orderings set
k positive examples must checked  moreover  situations favorable ordering
exist  consider following hypothesis space 

c   int x y w     head x a   tail x b   notmember a y   int b y w  
c   int x y w     head x a   tail x b   notmember a y      int b y w  
c   int x y z     head x a   tail x b   int b y w   cons a w z  
c   int x y z     head x a   tail x b      int b y w   cons a w z  
c   int x y z     null z  
together set examples 

e    int pos  a   b       
e    int pos  a   a   a   
e    int neg  a   b   a   
e    int neg  a   a       
induction procedure able find correct program ordering
two positive examples  even program exist   c  c  c     program
union two traces   c  c    covers e     c  c    covers e    traces
inconsistent  first covers e    second covers e    problem
remedied positive examples derived check negative
examples done 
however  case loss eciency  inconsistent
traces discarded end  words  would need learn program
covering positive examples  make consistent using cut reordering clauses  moreover  way make program consistent using cut
reorderings  consequence  time used build program wasted 
example  suppose given following hypothesis space 

c    int x y z     head x a   tail x b   int b y w   cons a w z  
c    int x y z     null x   null z  
c    int x y z     null z  
  

fibergadano  gunetti    trinchero

examples 

e    int pos  a   a   a   
e     int pos  a b   c      
e     int neg  a   b   a   
learn trace  c   c    e   trace  c    e      c   c   c    covers
e    way make consistent using cut reordering clauses  fact 
first partial trace responsible inconsistency  hence time used learn
 c    totally wasted 
possible understand need attened clauses  consider following program intersection  equivalent  c  c  c    three clauses
un attened 

u    int  ajb  y w     notmember a y      int b y w  
u    int  ajb  y  ajw         int b y w  
u    int         
now  program covers int neg  a   a       i e   u   u  u      int  a   a       fact  clause
u  fails example member  a   clause u  fails empty
list cannot matched  ajw   clause u  succeeds arguments match
negative example  consequence  program would rejected
induction procedure 
problem that  use un attened clauses  may happen clause body
evaluated example match head clause  consequence 
possible cuts clause evaluated cannot uence behavior entire
program  example  cut clause u  effect output argument
int  a   a      match  ajw   body u  evaluated all  u 
fired negative example covered  attened version  clause c  fails
cons a        reached  point cut force clause c  cannot activated 
note program  u   u  u   behaves correctly query int  a   a  x   gives x  a 
output 

    problem    ordering literals

even relative position literals cut clause significant  consider
correct program intersection   c  c  c     c  modified putting
cons literal front antecedent 

c    int x y z     cons a w z   head x a   tail x b   int b y w  
then  way get correct program intersection using clause  rule
negative example int neg  a   a      must put cut cons predicate 
order prevent activation c   but  then  positive examples longer
covered  int pos  a          fact  wrong behavior every time clause c  
   

fithe difficulties learning logic programs cut

called fails  since prevents activation c    general  problem cannot
avoided even reordering clauses  put c   c  c    int neg  a   a     
covered  consequence  test every possible permutation literals
every clause candidate program 

   situations learning cut still practical
analysis  learning cut appears dicult since  general  learning
procedure able backtrack candidate base programs  e g   traces  
position cut s  program  order clauses program 
order literals clauses order given positive examples  however 
spotted general conditions learning cut could still practical  clearly 
conditions cannot final solution learning cut  but  applicable  alleviate
computational problems task 

    small hypothesis space

first all  restricted hypothesis space necessary  clauses cannot learned independently one another  small hypothesis space would help limit backtracking
required candidate traces  problem     moreover  even number clauses trace
would probably smaller  hence number different permutations
number different positions inserted cuts  problems       small trace would
slight positive impact need test different literal orderings clauses
 problem    
general  many kinds constraints applied keep hypothesis space small 
ij determinism  muggleton   feng         rule sets schemata  kietz   wrobel 
      bergadano   gunetti         determinations  russell         locality  cohen        
etc  in fact  restrictions others  listed section   
available actual implementation procedure   see appendix     moreover 
candidate recursive clauses must designed infinite chains recursive calls
take place  bergadano   gunetti         otherwise learning task could
non terminating   general  number possible recursive calls must kept small 
order avoid much backtracking searching possible traces  however  general
constraints may sucient  hypothesis space must designed carefully
beginning  dicult  example learning simplify initial
hypothesis space  only       clauses obtained specifying set required
predicates  even variables occurring every literal 
clauses cannot learned independently  experiments shown us dramatic improvement learning task obtained generating clauses
hypothesis space recursive clauses  general complex clauses  taken
consideration simpler non recursive ones  since simpler non recursive
clauses require less time evaluated  small impact learning time 
moreover  learning simpler clauses  i e  shorter  alleviates problem   
   found constraints particularly useful  using often able restrict hypothesis
space one order magnitude without ruling possible solution 

   

fibergadano  gunetti    trinchero

finally  must noted induction procedure necessarily require
hypothesis space possible clauses represented explicitly  learning task could
start empty set implicit description hypothesis space  example
one given section    positive example cannot derived s  new clause
asked clause generator added s  step repeated example
derivable updated s  learning task proceed normally 

    simple examples

another improvement achieved using examples simple possible 
fact  example may involve recursive call potentially responsible
activation corresponding clauses hypothesis space  complex
example  larger number consecutive recursive activations clauses larger
number traces considered backtracking  problem     instance  learn
append relation  may sucient use example append  a   b   a b   instead
one append  a b c d   b   a b c d b    since simple examples would probably require
smaller number different clauses derived  would result smaller traces 
alleviating problem permutation clauses literals trace  problems     
decreasing number positions cuts  problem    

    small number examples

since candidate program formed taking union partial traces learned single
examples  want small trace  problems      must use examples
possible  still completely describing required concept  words 
avoid redundant information  example  want learn program append 
normally sucient use one two positive examples append  a   b   a b  
append  c   d   c d    obviously may happen different examples derived
set clauses  case final program change 
check possible orderings set positive examples  small number
examples solution problem    fortunately  experiments shown normally
positive examples needed learn program  hence corresponding
number different orderings is  case  small number  moreover  since
method positive example sucient learn clauses necessary derive it 
time complete program learned using one well chosen example 
example found  as case learning task section    one
example simplify one remove given   computational problem testing
different example orderings automatically solved 
however  must noted that  general  small number examples may
sucient  except simple programs  fact  want learn logic programs
member  append  reverse on  example involving recursion
sucient  complex programs choice may trivial  example 
procedure able learn quicksort  plus partition  program one  good 
example  one know quicksort partition work  likely
provide example allowing learn partial description partition 
particularly clear example simplify   used positive example
   

fithe difficulties learning logic programs cut

simplify pos       b a a     b a    which close one effectively used   first clause
flatten would learned  words  give examples must give
good examples  often possible mind  at least partially
informal way  target program  moreover  complex programs  good examples
mean complex examples  contrast previous requirement 
studies learning good examples refer reader work ling       
aha  ling  matwin lapointe        

    constrained positions cut literals

experiments shown practical allow learning procedure test
possible positions cut trace  even able keep number clauses
trace small  user must able indicate positions cut allowed
occur  e g   beginning clause body  recursive call  case  many
alternative programs cut automatically ruled thus tested
negative examples  may useful limit maximum number cuts
per clause per trace  example  time one cut per clause sucient
learn correct program  actual implementation procedure  fact
possible specify exact position cut w r t  literal group literals within
clause hypothesis space  information known 
eliminate need test different ordering literals  problem     may
impose particular global order  must maintained every clause hypothesis
space  however requires deep knowledge program want  otherwise
 or even all  solutions lost  moreover  solution contrast use
constrained positions cut  since solution program particular literal ordering
particular positions cuts may exist 

   conclusion

induction procedure based intensional evaluation clauses  since cut
predicate declarative meaning  believe intensional evaluation clauses
cannot abandoned  independently kind learning method adopted 
decrease performance learning task  compared extensional methods 
examine clauses one time without backtracking  however  computational problems
outlined section   remain even choose learn complete program extensionally 
try make consistent inserting cut  difference
backtracking  problem     situation probably worse  since extensional
methods fail learn complete program even exists hypothesis space 
 bergadano      a  
even ability learn clauses containing procedural predicates cut seems
fundamental learning  real  logic programs  particular short ecient programs 
many problems uencing complexity learning task must faced  include
number relative ordering clauses literals hypothesis space  kind
relative ordering given examples  problems seem related need
intensional evaluation clauses general  particular learning method
adopted  even alleviate problems  seems necessary know lot
   

fibergadano  gunetti    trinchero

target program  alternative solution simply ignore problems  is 
avoid testing different clause and or literal and or example orderings  clearly 
way learning process become feasible  fail find solution even
exists  however  many ilp systems  such foil  adopt  incomplete but fast 
approach  guided heuristic information 
consequence  view results presented paper as  least partially  negative  problems raised appear computationally dicult  suggest attention
restricted purely declarative logic languages  are  case  suciently
expressive 

acknowledgements
work part supported bra esprit project      inductive logic programming 

appendix
induction procedure section   written c prolog  interpreted  runs
sunsparcstation    planning translate quintus prolog  appendix
contains simplified description implementation  preliminary step  order
record trace clauses deriving positive example e   every clause hypothesis
space  must numbered modified adding body two literals  first
one  allowed n m  used activate clauses must checked
negative examples  second one  marker n   used remember clause number n
successfully used deriving e   hence  general  clause hypothesis
space takes following form 

p  x          xm     allowed n m    marker n  
actual body clause  n number clause set
number used deal cuts  every clause n  one without cut augmented
allowed n     containing cut somewhere body augmented
allowed n     allowed n          on  moreover  every augmented clause above 
fact  alt n m    inserted s  order implement enumeration mechanism 
simplified  but running  version learning algorithm reported below 
algorithm  output  any  variable trace containing list  numbers the 
clauses representing learned program p  using backtracking mechanism prolog 
one solution  trace  found  assume two predicates listpositive
listnegative build list given positive negative examples  respectively 
consult file containing set clauses s  
   assume clauses hypothesis space attened

   

fithe difficulties learning logic programs cut

allowed x    
marker x     assert trace x   
marker x     retract trace x       fail 
main    listpositive posexamplelist   tracer    posexamplelist trace  
tracer covered  examplejcdr  trace     example     backtracking point     
setof l trace l  trace   
notneg trace   examplejcovered  cdr  
tracer  examplejcovered  cdr trace  
tracer      trace     setof  i j  allowed i j  trace   asserta  marker x     true      
assertem     
assertem  ijcdr      alt i j   backassert allowed i j    assertem cdr  
prep t     retract allowed x      assertem t  
backassert x     assert x  
backassert x     retract x      fail 
resetallowed          
resetallowed       abolish allowed     assert allowed x        
notneg t covered remaining     listnegative     
notneg t covered remaining     listnegative negexamplelist  
asserta  marker x     true     
prep t      backtracking point     
trypos covered   trynegs negexamplelist  
resetallowed remaining  
retract  marker x     true     
notneg t covered remaining     resetallowed remaining  
retract  marker x     true         fail 
trypos  examplejcdr      example     trypos cdr  
trypos          
trynegs  examplejcdr      example   fail 
trynegs  examplejcdr      trynegs cdr  
trynegs          
actually  complete implementation complex  order achieve greater
eciency  behavior learning task quite simple  initially  set clauses
read prolog interpreter  together learning algorithm  learning
task started calling predicate main  list positive examples formed
   

fibergadano  gunetti    trinchero

tracer procedure called list  every positive example  tracer calls
example itself  firing clauses may resolved example 
observe that  initially  allowed x    predicate asserted database  way
clauses containing cut allowed used  this clauses cut
employed negative example derived   then  trace  any   the numbers
associated to  clauses successfully used derivation example built  using
setof predicate 
trace added traces found previous examples  result
checked set negative examples calling notneg procedure  notneg
fail  i e  negative examples covered trace  new positive
example taken consideration  otherwise notneg modifies trace cut
tests again  fails  backtracking occurs new trace current example
 and possibly previous ones  searched for 
notneg procedure works follows  first  clauses trace allowed
checked negative examples  retracting allowed x    clause
asserting allowed n    n th clause  without cut  trace  done
prep assertem predicates  list negative examples formed
check derived clauses trace  least one negative example
covered   i e   trynegs fails  backtrack prep procedure  backtracking point
   clause trace substituted equivalent one cut inserted
somewhere  or different position   correct program found way
trying possible alternatives  i e  using cut possible ways   notneg fails 
backtracking backtracking point   occurs  another trace searched for  otherwise 
clauses without cut reactivated asserting allowed x     next
positive example considered  note trypos used notneg verify modified
trace still derives set positive examples derived initially  possibility substitute
clauses current trace others cut inserted somewhere achieved
alt predicate assertem procedure  finally  note simplified version
learning procedure able generate test different orderings clauses
trace different ordering literals clause  use different orderings
set positive examples 
order derive positive examples check negative ones
 see subsection       must change first clause tracer procedure into 
tracer  pos        posn    pos        posn  setof l trace l  t   notneg t  
actual implementation induction procedure available ftp 
information contact gunetti di unito it 

references

aha  d   ling  c   matwin  s     lapointe  s          learning singly recursive relations
small datasets  proceedings ijcai    workshop ilp 
bergadano  f       a   inductive database relations  ieee transactions data
knowledge engineering        
   

fithe difficulties learning logic programs cut

bergadano  f       b   test case generation means learning techniques  proceedings acm sigsoft    
bergadano  f     gunetti  d          interactive system learn functional logic programs  proceedings ijcai    
coelho  h     cotta  j  c          prolog example  learn teach use it  berlin 
springer verlag 
cohen  w          rapid prototyping ilp systems using explicit bias  proceedings
ijcai    workshop ilp 
deraedt  l   lavrac  n     dzeroski  s          multiple predicate learning  proceedings
ijcai    
kietz  j  u     wrobel  s          controlling complexity learning logic
syntactic task oriented models  muggleton  s   ed    inductive logic programming  london  academic press 
lau  k  k     clement  t   eds            logic program synthesis transformation 
berlin  springer verlag 
ling  x  c          learning good examples  proceedings ijcai    
muggleton  s   ed            inductive logic programming  london  academic press 
muggleton  s     feng  c          ecient induction logic programs  proceedings
first conference algorithmic learning theory 
quinlan  r          learning logical definitions relations  machine learning    
        
rouveirol  c   in press   flattening  representation change generalization  machine
learning 
russell  s          tree structured bias  proceedings aaai    
shapiro  e  y          algorithmic program debugging  cambridge  ca  mit press 

   


