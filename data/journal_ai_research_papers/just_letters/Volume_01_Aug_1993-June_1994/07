journal artificial intelligence research                 

submitted       published     

semantics complete algorithm
subsumption classic description logic
alex borgida

borgida cs rutgers edu

department computer science
rutgers university
new brunswick  nj       u  s  a 

peter f  patel schneider

pfps research att com

at t bell laboratories
    mountain avenue
murray hill  nj       u  s  a 

abstract

paper analyzes correctness subsumption algorithm used classic 
description logic based knowledge representation system used practical
applications  order deal eciently individuals classic descriptions  developers use algorithm incomplete respect standard 
model theoretic semantics description logics  provide variant semantics descriptions respect current implementation complete 
independently motivated  soundness completeness polynomial time subsumption algorithm established using description graphs  abstracted version
implementation structures used classic  independent interest 

   introduction description logics

data knowledge bases models part natural world  models
often built individual objects inter related relationships grouped
classes capture commonalities among instances  description logics  dls  
known terminological logics  form class languages used build access
models  distinguishing feature classes  usually called concepts  defined
intensionally in terms descriptions specify properties objects must satisfy
belong concept  descriptions expressed using language allows
construction composite descriptions  including restrictions binary relationships
 usually called roles  connecting objects 
example  consider description
game u   participants u  participants  person u gender   female   
description characterizes objects intersection  u  three sub descriptions 
game objects belong atomic concept    participants objects least
four fillers participants role   participants  person u gender   female  objects
whose participants fillers restricted belong persons 
gender role filled value female 
   notation used descriptions standard notation description logic community
 baader et al          classic notation used verbose 

c      ai access foundation morgan kaufmann publishers  rights reserved 

fiborgida   patel schneider

key difference dls standard representation formalisms based
first order logic  e g   relational deductive databases  dls provide arena
exploring new sets  logical connectives  the constructors used form composite
descriptions that different standard connectives conjunction  universal
quantifiers  etc   therefore  dls provide new space search expressive
yet effectively computable representation languages  moreover  although possible
translate many aspects dls currently encountered first order logic  reasoning
translation would poor substitute dl based systems reason
way resemble standard theorem proving  e g   making use imperative
programming features  
descriptions one used several ways knowledge base
management system  kbms  based description logic 
   state queries  kbms locate objects satisfy description s
properties 
   define classify concepts  identifiers attached descriptions  manner views relational dbmss  system addition automatically determine
 subclass  relationship pairs concepts based definitions 
example  concept defined description would subsumed
concept defined  games least two participants   game u   participants  
   provide partial information objects  important understand distinct dl descriptions ascribed arbitrary individuals  e g    today s game
cards individual bgm     will exactly two participants following
set three         tea rum    note unlike database systems  dl based kbmss require descriptions predefined  provides
considerable power recording partial knowledge objects 
   detect errors  possible determine whether two descriptions disjoint 
whether description incoherent not  whether ascribing description
individual leads inconsistency 
quite number kbmss based description logics built  including classic
 resnick et al          loom  macgregor   bates         back  peltason et al         
systems used several practical situations  including software information
bases  devanbu et al          financial management  mays et al          configuration management  owsnicki klewe        wright et al          data exploration  additional
signs dls significant subjects study several recent workshops dls
 nebel et al         peltason et al         aaai        

    tractability completeness dl implementations

fundamental operation descriptions determining whether one description
general  subsumes  another  sense object satisfying latter would
satisfy conditions former  parallel surge work finding tractable
yet expressive subsets first order logic  dl research community investigating
complexity reasoning various constructors  first result area  levesque
   

fisubsumption classic

  brachman        showed even seemingly simple addition small language
lead subsumption determination becoming np hard  recent  striking pair
results  patel schneider      b  schmidt schauss        shows adding ability
represent equalities role compositions makes complexity subsumption problem
leap quadratic undecidable 
three possible responses intractability results 
provide incomplete implementation dl reasoner  sense
inferences sanctioned standard semantics constructors
performed algorithm  approach  explicitly adopted loom system
implementers  macgregor   bates         advocated users  doyle  
patil         one major diculty  one describe users inferences
actually drawn implementation systems known properties
implemented top kbms  two solutions problem suggested  alternative semantic accounts  based weaker    valued logics  example 
 patel schneider      a   proof theoretic semantics  borgida        
provide complete implementation specific dl reasoner  acknowledging
certain circumstances may take inordinate amount time  approach 
followed systems kris  baader   hollunder         problem
unpredictability  system  go wild blue yonder  
course  circumstances impossible even attempt since reasoning
problem undecidable 
carefully devise language limited expressive power reasoning tractable 
provide complete implementation it  approach chosen
designers languages kandor  patel schneider        krypton
 brachman et al          close approach classic  borgida et al  
      
hidden diculty second third approach produce implementation
correct   complete   respect semantics  diculty illustrated
discovery  several years later  implementation kandor  well candide
 beck et al          fact incomplete  subsumption problem np hard  nebel 
       rather polynomial  claimed  happened despite fact kandor
 small  language comparison dls  implementation appeared
evidently correct  avoid problems  necessary produce convincing
demonstrations algorithm correct  several proofs fact already appeared dl literature  e g    patel schneider        hollunder   nutt        donini
et al           albeit languages seen use practical applications 

    outline

classic    system reasoner based moderately complicated dl 
used commercial  wright et al         prototype applications at t  made
available academic researchers at t bell laboratories 
   classic   first released version classic  new version  classic    expressive dl 
recently released 

   

fiborgida   patel schneider

one purpose paper provide rigorous formal analysis correctness
eciency classic dl subsumption algorithm   start presenting
result subset language  call basic classic  subsumption
algorithm relies transformation descriptions data structure  call
description graphs  generalization a kaci s psi terms        
process normalizing graph canonical form  remove obvious redundancies
explicate certain implicit facts  encoding particular infinite set inferences
drawn so called  coreference constraints   correctness subsumption
algorithm demonstrated rigorously showing construct  inductively  countermodel case algorithm returns answer  no  
next  explore effect adding individuals descriptions  show that  using
individuals  one encode disjunctive information leading need examine combinatorially many possibilities  classic implementation fact incomplete respect
standard semantics  second contribution paper well motivated 
understandable  small change standard semantics alleviates problem 
extend subsumption algorithm proof correctness deal individuals
modified semantics  thereby characterizing sense  incompleteness 
reasoner 
paper therefore illustrates three paradigms described above  albeit nonstandard manner second paradigm  first time realistic
language significant practical use 

   basic classic
descriptions basic classic built collection atomic concept names  role
names  attribute names  roles attributes always atomic descriptions
built using operators constructors value restrictions number restrictions 
indicate below 
basic classic incorporates objects host programming language   called host
individuals  form distinct group classic individuals  latter
roles attributes own  former restricted role attribute fillers 
denotational semantics classic descriptions starts  usual  domain
values    subsets extensions descriptions  subsets
extensions roles attributes  domain fact disjointly divided two realms 
host realm  h   containing objects corresponding host language individuals 
classic realm c   containing objects  every description  except thing 
denotes entire domain extension subset either classic realm
host realm   nothing denotes empty set  therefore classic host
concept   extension role possible world relation classic realm
entire domain  extension attribute function classic realm
entire domain 
   empirical tests  heinsohn et al          classic emerged fastest current dl
implementations 
   general scheme incorporating host objects described  baader   hanschke        

   

fisubsumption classic

host descriptions relatively simple   i  host thing  denoting entire host realm 
h    ii  special  pre defined names corresponding types host programming language   iii  conjunctions descriptions  descriptions corresponding
host programming language types pre defined extensions subsumption relationships  mirroring subtype relationship host programming language 
subtype relationship satisfied possible worlds interpretations  require  i 
host concepts extension either infinite size empty   ii 
extensions two host concepts overlap  one must subsumed other  i e  
types disjoint  unless subtypes other   iii  host concept
infinite number extra instances child concepts   these conditions
needed avoid able infer conclusions size host descriptions  
allows host concepts integer  real  complex  string  boolean
non zero integer  
non host  classic  descriptions basic classic formed according following
syntax 
syntax
constructor name
classic thing
e
atomic concept name
cud
intersection
 r c
role value restriction
 a c
attribute value restriction
n r
minimum number restriction
r
maximum number restriction
a        ak   b        bh equality restriction
e atomic concept name  c classic descriptions  r role  a  ai  
bj attributes  n k h positive integers  non negative integer  set
constructors basic classic judiciously chosen result language
subsumption easy compute 
denotational semantics descriptions basic classic recursively built
extensions assigned atomic names possible world 
definition   possible world interpretation    consists domain    interpretation function  i   domain disjointly divided classic realm  c   host
realm  h   interpretation function assigns extensions atomic identifiers follows 
extension atomic concept name e subset ei classic realm 
extension atomic role name r subset ri c  
extension atomic attribute name total function ai c
 
extension ci non atomic classic description computed follows 
classic thingi   c  
 c u d i   ci   di  
   

fiborgida   patel schneider

  p c i   fd   c j  x  d  x    pi   x   ci g  i e   objects c
whose p role p attribute fillers extension c 

 n p i  resp   n p i   objects c least  resp  most  n fillers
role p 

 a        ak   b        bh  i   fd   c j ak        a i  d     bhi        b i  d  g  i e  

objects c property applying composition extension
ai composition extension bj object result
value  

description  d   said subsume another  d    possible worlds   d i
d   

key interest computation subsumption relationship descriptions
basic classic  subsumption computation multi part process  first  descriptions
turned description graphs  next  description graphs put canonical form 
certain inferences explicated redundancies reduced combining
nodes edges graph  finally  subsumption determined description
canonical description graph 
describe detail process  start formal definition notion
description graph  definition     present techniques

translating description description graph  section       requires merging
pairs nodes  pairs graphs  definitions      

putting description graph canonical form  section      
determining whether description subsumes description graph  algorithm    
prove correctness approach  need show first two steps
lead us right direction  i e   following three questions equivalent   does
description subsume description c     does description subsume graph gc    
 does description subsume graph canonical gc      this  need define
formal semantics descriptions graphs  definitions       prove
results  theorems       prove  completeness  subsumption algorithm 
show algorithm indicate subsumes canonical gc   
construct interpretation   graphical world   object denotation
canonical gc   d 

    description graphs

one way developing subsumption algorithm first transform descriptions
canonical form  determine subsumption relationships them  canonical
descriptions normally thought trees since descriptions terms first order
term language  presence equality restrictions classic significantly changes
   note attribute chains must definite value  last cannot evaluate
host individuals  since cannot attributes 

   

fisubsumption classic

fclassic thing
g


fthing
g
 




 


 


captain 
coach



 


participants   fpersong


 

fgameg

father

      

figure    description graph 
handling subsumption introduce relationships different pieces
normal form  significantly  presence equalities  small description 
 friend tall u friend   friendfriend  subsumed descriptions arbitrary size 

 friend   friend          friend tall          
order record sets inferences canonical form  resort graphbased representation  suggested semantic network origins description logics 
work a kaci        
intuitively  description graph labelled  directed multigraph  distinguished
node  nodes graph correspond descriptions  edges graph correspond
restrictions roles attributes  edges graph labelled role name
minimum maximum number fillers associated edge 
attribute name  nodes graph labelled concept names associated
node concept  example  figure   description graph  which  shall see later 
corresponds description game u  participants  person u coach    captainfather  
equality restrictions  and hence non tree portions graph  involve
attributes  edges labelled roles cut edges  i e   removal increases one
number connected components graph  restriction important
graph tree form  really difference graphical linear notation 
semantics simple develop  graph general directed acyclic graph 
problem relating semantics generated two different paths
graph share beginning ending nodes  graph contains cycles 
problem developing correct semantics even dicult  simplistic semantics
non well founded  sort fixed point model preference semantics
required  fortunately  non tree parts graphical notation involve attributes
only  attributes functional  job much easier 
result restrictions  possible view description graph
following recursive structure   i  distinguished node r   island 
nodes connected edges labelled attributes   ii  nodes island may
  edges labelled roles leaving them  pointing distinguished nodes
description graphs   iii  graphs share nodes edges common
other  islands them 
   

fiborgida   patel schneider

recursive structure  easier represent description graphs using
recursive definition  instead usual graph definition  recursive definition similar
recursive definition tree  states tree consists information
 the information root tree  plus set trees  the children root
tree   description graphs complex simple trees  use
two part definition 

definition   description graph triple  hn  e  ri  consisting set n nodes 

bag e edges  a edges  labelled attribute names  distinguished node r n  
elements e written hn    n   ai n  n  nodes attribute
name 
node description graph pair  hc  h consisting set c concept names
 the atoms node   bag h tuples  the r edges node   r edge
tuple  hr  m  m  gi  role name  r  min  m  non negative integer  max 
  non negative integer     recursively nested  description graph g 
representing restriction fillers role   g often called restriction
graph node  
concept names description graph atomic concept names  host concept names 
thing  classic thing  host thing 

descriptions graphs provided extensions starting possible worlds
used descriptions  however  addition need way identifying individuals
related attributes  given function  

definition   let g   hn  e  ri description graph let possible world 

interpretation gi g  interpretation ni nodes n   recursively  and mutually  defined follows 
element  d  gi   iff function    n
      r  
   n   n  n    ni  
   hn    n   ai   e h n      n  i   ai    which equivalent  n     
ai   n     since ai function  
element  d  ni   n   hc  h i  iff
   c   c     ci  
   hr  m  m  gi   h  
 a  elements  d   domain hd  d i   ri

 b  d    gi d  hd  d i   ri  
   

fisubsumption classic

    translating descriptions description graphs

basic classic description turned description graph recursive process 
working  inside out   process  description graphs nodes often
merged 

definition   merge two nodes  n  n   new node whose atoms union

atoms two nodes whose r edges union r edges two
nodes  

definition   merge two description graphs  g  g   description graph whose

nodes disjoint union  non distinguished nodes g  g  plus new
distinguished node  edges merged graph union edges g  g  
except edges touching distinguished nodes g  g  modified touch
new distinguished node  new distinguished node merge two distinguished
nodes g  g  

rules translating description c basic classic description graph gc
follows 
   description consists concept name turned description graph
one node a edges  atoms node contains concept name 
node r edges 
   description form n r turned description graph one node
a edges  node atoms classic thing single r edge
role r  min n  max    restriction gthing  
   description form n r turned description graph one node
a edges  node atoms classic thing single r edge role
r  min    max n  restriction gthing  
   description form  r c  r role  turned description graph
one node a edges  node atoms classic thing single
r edge role r  min    max    restriction gc 
   turn description form c u description graph  construct gc
gd merge them 
   turn description form  a c  attribute  description graph 
first construct description graph hnc   ec   rc c  description graph
 a c hnc   ftg  ec   fht  rc   aig  ti  node hfclassic thingg  fgi 
   turn description form a          b        bm description graph
first create distinguished node  node r  classic thing atoms 
node e  thing atoms    n     create node ai   atoms
   note duplicate edges  ones joining ni ni   removed  since edges form bag 
   taking disjoint union two sets  elements one may systematically renamed first make
sure sets non overlapping 

   

fiborgida   patel schneider

classic thing    j     create node bj   atoms
classic thing  none ai bj r edges 
n      create edge hr  e  a i  n     create edges hr  a   a i  han     e  i 
hai     ai  ai   n     
similarly       create edge hr  e  b i      create edges hr  b   b  i 
hbm    e  bmi  hbi    bi  bii       
creates two disjoint paths  one ai one bj   distinguished node end node 
figure   presents view description graph constructed fashion
description game u  participants person u coach   captainfather 
want show process preserves extensions  use merge
operations first show work correctly 

lemma   n  n  nodes  n  n  i   ni    ni    d  d  description
graphs  d  d  i   d i   d i  
proof  since components  atoms r edges  merged node obtained

unioning components respective nodes  since interpretation node
intersection interpretation components  result obviously true
nodes 
merging graphs  difference root nodes replaced
merger edges  well root  element  d  d  i clearly
element d i d i   conversely  since take disjoint union nodes
two graphs  mapping functions     definition   simply unioned 
element d i d i element merged root node  hence
 d  d   i  

theorem   possible worlds  extension description ex 

tension description graph 
proof  proof structural induction descriptions 
extension concept names  cardinality restrictions    restrictions roles
easily seen agree extension description graphs formed them 
lemma   shows conjunction properly handled    restrictions attributes 
construction correct attributes functional 
equalities a          b        bm construction forms description graph
two disjoint paths distinguished node end node  one labelled ai  
nodes ai   labelled bj   nodes bj  

   a          b        bm i   fd   c j ak        a   d     bh        b   d  g 
defining  ai     ai        a   d    bj     bj        b   d  g  yields mapping

required definition    converse satisfied requirement definition  
a edge hn    n   ai   e    n      ai   n     
   

fisubsumption classic

    canonical description graphs

following sections occasionally refer  marking node incoherent  
consists replacing special node outgoing r edges  including
atoms nothing  always empty interpretation  marking description
graph incoherent consists replacing description graph consisting
incoherent node   incoherent graphs thought representing concepts
empty extension  
description graphs transformed canonical form repeating following normalization steps whenever possible description graph descendants 
   node atoms pre defined host concept  add host thing
atoms  node atomic concept name atoms  add classic thing
atoms  pre defined host concept atoms node  add
more general pre defined host concepts atoms 
   node host thing classic thing atoms  mark
node incoherent  node atoms pair host concepts
related pre defined subsumption relationship  mark node incoherent  since
intersection empty 
   node description graph marked incoherent  mark description graph
incoherent   reason  even node root  attributes must always value 
value cannot belong empty set  
   r edge node min greater max  mark node incoherent 
   r edge node description graph marked incoherent  change max
    reason  cannot fillers belong empty set  
   r edge node max    mark description graph incoherent 
 reason  normalization step records equivalence   r  r nothing 
used infer concept  r c arbitrary c subsumes   r  
   node two r edges labelled role  merge two edges 
described below 
   description graph two a edges node labelled
attribute  merge two edges 
merge two r edges node  identical roles  replace one redge  new r edge role role  maximum two mins min 
minimum two maxs max  merge two description graphs
restriction 
merge two a edges hn  n    ai hn  n   ai  replace single new edge
hn  n   ai  n  results merging n  n   i e   n    n  n    if n    n 
n    n    addition  replace n  n  n  a edges description graph 
   

fiborgida   patel schneider

need show transformations canonical form change extension
graph  main diculty showing two edge merging processes
change extension 

lemma   let g   hn  e  ri description graph two mergeable a edges let
g    hn    e    r i result merging two a edges  gi   g i  
proof  let two edges hn  n   ai hn  n   ai new node n  n  n  
choose   gi   let function n domain satisfying conditions

extensions  definition     r    d   n       n   
equal ai   n    let   except    n       n       n    
  satisfies definition    part    g   replace n  n  n  everywhere 
moreover     n      n      ni    ni    which  lemma    equals  n  n   i   part  
satisfied too  since n    n  n    finally  root modified merger  i e   n 
n  r  say n      n        n    part   definition satisfied 
conversely  given arbitrary   g i   let   function stipulated definition  
   r     d  let   except  n       n     n         n    
argument traversed reverse verify satisfies definition   
  gi  

lemma   let n node two mergeable r edges let n  node

edges merged  ni   n i  
proof  let two r edges hr  m   m   g i hr  m   m   g i 
let   ni   m   m   m   m   elements domain  d  
hd  d i   ri   therefore maximum m  m 
minimum m  m  elements domain  d   hd  d i   ri   also  d 
hd  d i   ri gi   gi     therefore  d  hd  d i   ri gi    gi   
equals  g  g  i lemma    thus   n i  
let   n i   maximum m  m  minimum
m  m  elements domain  d    hd  d i   ri   therefore
m   m   m   m   elements domain  d   hd  d i   ri   also  d 
hd  d i   ri  g  g   i   gi    gi    therefore  d  hd  d i   ri
gi   gi     therefore   ni  

dealt issue merging  return desired result  showing
 normalization  affect meaning description graphs 

theorem   possible worlds   extension canonical form description

graph  g  resulting basic classic description extension
description 
proof  steps     justified since gi subset either h c  
disjoint 
step   justified fact that  definition description graphs  must
element domain extension node description graph 
steps         easily derived definition   
steps     dealt preceding two lemmas 
   

fisubsumption classic

    subsumption algorithm
final part subsumption process checking see canonical description graph
subsumed description  turns possible carry subsumption
test without expense normalizing candidate subsumer concept 

algorithm    subsumption algorithm  given description description graph
g   hn  e  ri  subsumes  d  g  defined true following

conditions hold 

   description graph g marked incoherent 
   equivalent thing   this determined checking first d thing 
recursively testing whether subsumes canonical description graph gthing   
   concept name element atoms r 
   n r r edge r r role min greater equal n 
   n r r edge r r role max less equal n 
    r c r edge r r role g  restriction graph
subsumes  c  g   
    r c subsumes  c  gthing  r classic thing atoms   reason   r thing requires possibility r applicable object  absent
host values  
    a c a edge g form hr  r   ai  subsumes  c  hn  e  r i  
    a c subsumes  c  gthing  r classic thing atoms 
    a          b        bm paths a           b           bm exist g
starting r end node 
    a          b        bm bm paths a           an  
b           bm   exist g starting r end node 
classic thing atoms   reason  aii   a         bj   b      
   



   



 aii        a i  d       bj        b   d   

attribute f  long attribute applicable  i e   value host
domain   

    c u e subsumes  c  g  subsumes  e  g  true 
   

fiborgida   patel schneider

    correctness subsumption algorithm

soundness algorithm fairly obvious  shall dwell it  completeness algorithm is  usual  dicult establish  first show
canonical description graph node marked incoherent  possible
world non empty extension description graph node constructed 
constructive  inductive manner  constructing collection possible worlds  called graphical worlds description graph  graphical world
distinguished domain element extension description graph node 
common operation merge two possible worlds 
definition   let i  i  two possible worlds  merge i  i   i  i  
possible world classic realm disjoint union classic realm i 
classic realm i    extension atomic names i  i  disjoint union
extensions i  i   
easy show extension description  description graph  node
i  i  union  disjoint union classic realm  regular union host realm 
extensions i  i   
another operation add new domain elements possible world  new domain
elements must classic realm  extension atomic identifiers remain
except new domain elements belong arbitrary set atomic concept
names arbitrary set fillers  filler  role  attribute   again 
easy show domain element original world extension original
world iff extension augmented world 
given node  n  marked incoherent  construct graphical worlds
n follows 
   atoms n precisely thing  n r edges 
constructs cause r edges created add classic thing atoms 
possible world  domain element distinguished domain element 
graphical world n 
   atoms n include host thing  n r edges  possible
world  distinguished element domain element extension
atoms n host concepts  graphical world n   because
requirements host domain  infinite number domain
elements  
   atoms n include classic thing  r edge  hr  m  m  gi  n 
construct graphical worlds g  done number
    g marked incoherent  g
marked incoherent     
two graphical worlds host domain element
distinguished element   again  possible extension host concept
either empty infinite   merge graphical worlds r edge
one possible world  add new domain elements one exactly
   

fisubsumption classic

extensions atoms n fillers r exactly distinguished
elements appropriate graphical worlds  domain element
correct number fillers r edge  disjoint union classic
realms merge process different host domain elements picked
above  therefore extension n  thus resulting world graphical
world n 
given description graph  g   hn  e  ri  marked incoherent  construct
graphical worlds g follows  node n   n construct graphical world
n  done none marked incoherent  merge graphical
worlds  modify resulting world hn    n   ai   e a filler
distinguished node graphical world n  distinguished node graphical
world n    easy show distinguished node graphical world r
extension g  making graphical world g 
show final part result 

theorem   subsumption algorithm indicates canonical description
graph g subsumed basic classic description d  possible world
domain element extension graph extension d 
therefore g subsumed d 
proof  proof actually shows subsumption algorithm indicates
canonical description graph  g  subsumed description  d 
graphical worlds g distinguished domain elements
extension d  remember subsumption algorithm indicates g subsumed
d  g must marked incoherent thus graphical worlds g 
proof proceeds structural induction d  let g   hn  e  ri 
atomic concept name pre defined host concept  occur
atoms r  construction  graphical world g distinguished
domain element extension d  similarly  classic thing
host thing  distinguished domain elements wrong realm 
thing  possible subsumption algorithm indicate
non subsumption  case graphical world g property
distinguished domain element extension d 

form d  u d  subsumption algorithm must indicate g

subsumed least one d  d    inductive hypothesis  get
graphical worlds g distinguished domain elements
extension d  extension d   thus extension d 

form n r either r edge r labelled r min less
n r edge 
former case graphical worlds g distinguished node
n     fillers r  n greater min r edge r  thus
distinguished node extension d 
   

fiborgida   patel schneider

latter case  graphical worlds g distinguished node
number fillers r  n     fillers property
distinguished node extension d 

form n r either r edge r labelled r max greater
n  including    r edge 
former case graphical worlds g distinguished node
n     fillers r  n less max r edge r  thus
distinguished node extension d 
latter case  graphical worlds g distinguished node
number fillers r  n     fillers property
distinguished node extension d 

form  r c  r role  two cases arise 
   subsumes  c  gthing  classic thing atoms r 
graphical worlds g whose distinguished element host

realm  thus extension d 
   otherwise  either r edge r role r description graph h
subsumes  c  h   false r edge r role r  note
extension c entire domain  thus must subset
either host realm classic realm 
former case h marked incoherent  or else subsumption could
false  max r edge cannot    thus graphical
worlds h whose distinguished element extension c
graphical worlds g use graphical worlds h distinguished
domain element r fillers  graphical worlds g distinguished element extension d 
latter case  pick graphical worlds g distinguished node
r filler wrong realm  graphical worlds g distinguished
element extension d 

form  a c attribute two cases arise 
   subsumes  c  gthing  classic thing atoms r 
graphical worlds g whose distinguished element host
realm  thus extension d 
   otherwise  either a edge r attribute node
r  subsumes  c  h   false  h   hn  e  r i  a edge
r attribute a  note extension c entire domain 
thus must subset either host realm classic realm 
former case h marked incoherent  g marked incoherent  thus graphical worlds h whose distinguished element
extension c  given graphical world h   graphical world
g formed simply changing distinguished domain element 
   

fisubsumption classic

original graphical world s distinguished element extension c 
new graphical world s distinguished element extension
d  required 
latter case  pick graphical worlds g distinguished node
a filler wrong realm  graphical worlds g distinguished
element extension d 
form a          b        bm several cases arise 
   one paths a           an   b           bm   exist g starting
r  find end partial path use graphical worlds
domain element node element host domain filler
next attribute path  one full paths filler 
   paths a           b           bm exist g starting r end
different nodes  use graphical worlds domain elements
two nodes different 
   one paths a           b           bm exist g starting
r paths a           an   b          bm   exist g starting r
end node either classic thing atoms
node    bm  former case use graphical worlds domain
element node host realm  latter case use graphical worlds
different fillers bm domain element node 
   one paths a           b           bm exist g starting
r paths a           an   b          bm   exist g starting r
end different nodes use graphical worlds different fillers
domain elements nodes domain elements
host realm 
cases either one        a    d  bmi        b    d 
exist        a    d     bmi        b    d   distinguished domain element
extension d 

    implementing subsumption algorithm

section provide comments actual subsumption algorithm
used classic system  including rough analysis complexity 
described it  deciding whether description c subsumes accomplished
three phases 
   convert description graph gd  
   normalize gd  
   verify whether c subsumes gd  
step    conversion accomplished simple recursive descent parser  takes
advantage fact syntax description logics  i e   leading term constructor  makes amenable predictive parsing  clearly  constructing graphs fixed sized
   

fiborgida   patel schneider

terms  like at least  constant time  if measure size integer size   matter large   time non recursive terms  like same as  proportional
length  finally  recursive terms  like all  and  require fixed amount additional
work  top recursive processing  therefore  first stage accomplished
time proportional size input description  order speed later processing 
useful maintain various lists  lists atomic concept identifiers 
roles attributes  sorted order  sorting needs done initially  later  ordering
maintained performing list merges  incurs  worst case quadratic
overhead processing    case  total size graph constructed  including
sizes nodes  etc   proportional size original concept description 
step    checking whether description c subsumes description graph gd  
seen run time proportional size subsuming concept  modulo cost
lookups various lists  since sorted  lookup costs bounded
logarithm size candidate subsumee graph  total cost bounded
o j c j log j gd j  
step    normalization accomplished post order traversal description
graph  processing description graph hn  e  ri  node n normalized first independently  see details below   afterwards attribute edges e normalized 
later task involves identifying multiple identically labelled attribute edges leaving node
 this done one pass since attribute edges grouped source node  sorted
attribute name    merging  them  merging two edges quite easy itself  merging nodes tips  must careful node mergers
may cascade  example  concept form a    b  u a    b  u       u   bn u
a    a  u a    a  u       u an     original graph  n     nodes   n
collapsed normalization step    discover eciently  use version
a kaci s algorithm unifying  terms  at kaci        at kaci   nasr        
algorithm relies union find technique identify nodes merged  runs
time slightly linear number nodes n   therefore cost
non recursive portion graph normalization roughly linear number nodes
it 
merging two description graph nodes quite similar normalization
single node  atomic concept identifier lists need sorted merged  duplicates
eliminated y  done time proportional size nodes
themselves  make size node include size various lists it 
atoms  processing role edges leaving node is  again  one identifying merging
identically labelled edges   but case mergers labelled edges interact 
single pass role edge list sucient   cost non recursive aspects
merger proportional size local information 
therefore left problem bounding total number procedure calls
normalizegraph  normalizenode  mergeedge  mergenode  bounding
sizes nodes merged 
normalizegraph normalizenode called exactly every  sub graph
node original graph  part depth first traversal  argued above 
   tend use fancy sorting techniques since lists likely long 

   

fisubsumption classic

contribute time proportional total size original graph 
proportional size original description 
number calls mergeedge mergenode simply bounded however  
node may merged several times others  however  calls paired 
invocation mergenode reduces number nodes graph one  therefore  since number nodes incremented elsewhere  total number calls
mergeedge mergenode bounded number nodes original graph 
problem non recursive cost call mergenode depends size
argument nodes  call may increase size remaining node
sum sizes two original nodes 
therefore  original concept size s  graph n nodes  size
vi  worst case cost would result iterative summation sizes 
 vi    vi       vi    vi    vi       vi    vi    vi    vi           
  n vi     n      vi              vi
n

given n vj bounded
  clearly worst case o s    
p
fact  given constraint j    nvj     possible argue worst case
cost occur vj     every j   i e   n      case cost really
o s    
theoretical improvements could attempted algorithm
 e g   merging nodes correct order increasing size  well analysis  e g  
nodes graphs depth tree merged  
remark description logics  classic permits identifiers associated complex descriptions identifiers used descriptions
 though recursion allowed   expansion identifiers standard operation
lead exponential growth size certain pathological cases  nebel         making
subsumption problem inherently intractable  type system programming language standard ml  pathological cases encountered practice 
correct algorithm simple  straightforward ecient normal cases  unlike
correct algorithm reasoning set constructor  say  
users rarely ask whether concept subsumes another  rather
interested relationship pairs concepts  classic fact constructs
normalized description graph description given it  suggests might
better check whether one description graph subsumes another one  rather checking
whether description subsumes graph  general  works quite well  except
would verify attribute edges subsumer graph form subgraph
subsumee s attribute edges  since edges uniquely labelled normalization 
inherently hard  still requires complete traversal  and hence marking unmarking 
upper graph  therefore found useful encode part description
graph s root same as restrictions lead construction corresponding aedges  then  subsumption testing  aspect subsumer related same as
checked list same as pairs 
also  description algorithm tried optimize cost normalization  dominates checking single subsumption  overall use
   

fiborgida   patel schneider

system  e g   processing individuals   inquiries restrictions roles attributes
frequent  space usage problem  may practically advantageous
maintain r edges a edges node hash table  rather sorted list 
order speed access   note merging r edges  one must however still
way iterating values stored hash table  

   individuals descriptions

practical applications dls used  integrity constraint checking 
often useful able specify ranges atomic values roles  common
examples involve integers  e g    the year student          
called enumerated types pascal  e g    the gender person either f   one way
allow constraints introduce new description constructor  set description 
creates description list individual names  whose obvious extension
set consisting extensions individuals appear list  construct
could used terms  year f       g  another useful constructor involving individuals
fills restriction  p   i  denotes objects extension individual
one fillers relationship denoted role attribute p   note
attribute  q   q fig q   i  
within paradigm dls  constructors quite useful fact used
express new forms incomplete information  example  know ringo
early fifties  simply assert ringo described  age f              g 
constructors used ask useful queries  example  find
male persons suces determine instances gender   m 
new constructors interact previous ones  cardinality constraints 
clearly size set upper cardinality bound role restricts  interaction
problematic long individuals set host values  since individuals
properties fixed known ahead time  however  allow classic
individuals members sets  properties individuals might
affect subsumption  simple example  know ringo instance
concept rock singer  which shall write ringo   rock singer   extension
 friends rock singer always superset extension  friends fringog 
disturbing classification hierarchy definitions would change
new facts individuals added knowledge base  definitions meant
contingent facts current world  therefore  subsumption usually defined
independent  contingent  assertions  shall see below  use individual
properties description subsumption leads intractability 

    complex subsumption reasoning  example

traditional proofs intractability  e g   levesque   brachman         occasionally
left users dls puzzled intuitive aspects language make reasoning
dicult  reason present example illustrates complexity reasoning
set description 
suppose concept jaded person one wants
visit arctic and or antarctic  wherever penguins 
   

fisubsumption classic

jaded person     wantstovisit  farctic antarcticg u  haspenguins   fyesg 

suppose remember arctic antarctic  know
south pole located one two places  penguins there 
north pole located one two places  penguins there 
assuming islocatedin  haspenguins  attributes roles exactly one filler 
record
southpole    islocatedin   farctic antarcticg u  haspenguins   fyesg 
northpole    islocatedin   farctic antarcticg u  haspenguins   fnog 

thus unable distinguish exact location southpole northpole  however 
since haspenguins  single filler  exactly one arctic antarctic  and fact
must  yes filler haspenguins   therefore exactly one location
southpole  
result facts  know extension jaded person must
subset extension   wantstovisit database containing facts
southpole northpole 
observe occasional worse case behavior  generalized
diculty reasoning set descriptions  subsumption ignores assertions
individuals   yet  show subsumption per se must perform inferences 
simple transformation  given appendix  establishes fact  converting
recognition individuals question subsumption two descriptions
making individuals involved attribute fillers new dummy attributes 
descriptions restrictions attributes  result  description non empty
attribute values must satisfy corresponding restrictions 

    modified semantics individuals

seen two problems individuals appearing descriptions      effect
 mutable facts  extensional relationships  immutable  descriptions     
computational intractability subsumption caused appearance individuals
descriptions 
deal first problem  reasonable restrict computation subsumption cannot access  database facts  individuals  role fillers 
individuals treated host identifiers  procedural description
aspect reasoning  sense negation by failure prolog  prolog 
would desirable find semantic account phenomenon 
semantics ignores mutable facts determining subsumption hard
devise all required two different sets possible worlds corresponding
kb containing concepts individuals  one set consists possible worlds
model information kb  second consists possible worlds
model information concepts  and roles attributes   asking questions individuals  first set possible worlds must considered  asking
subsumption questions  second  larger  set must considered  thus ignoring effects
mutable facts 
   

fiborgida   patel schneider

however  semantics solve computational problem individuals
descriptions  deal problem  semantics individuals modified
follows  instead mapping individuals separate elements domain  done
standard semantics  individuals mapped disjoint subsets domain  intuitively
representing different possible realizations  platonic  individual 
therefore  semantics set constructor stated follows  domain value
belongs extension fb        bn g iff belongs extension one bi  
associated change notion cardinality required two elements domain
considered congruent belong extension individual
identical  cardinality set elements domain size set
modulo congruence relationship  means occurrences different identifiers
description s  guaranteed unequal  distinct occurrences individual
identifier guaranteed denote individual 
two consequences stance 
   looking descriptions southpole northpole section      distinct
occurrences arctic might satisfied distinct domain elements  different role
fillers   in greater detail  extension arctic might include domain elements d 
d   d  satisfying condition haspenguins    yes  d  satisfies haspenguins    no 
southpole located d   northpole located d    still
satisfying islocatedin    arctic  similarly domain elements d  d 
extension antarctic  therefore one could two places visit
penguins  d  d   
   even though individual may description includes
islocatedin    arctic u originatesin    arctic 
need satisfy condition islocatedin    originatesin   since equality restriction requires identity domain values 

   adding individuals classic

individuals occur classic host descriptions  following constructs create
classic descriptions 
r i
a i
fi        ing
attribute  r role  name classic individual host value 
collectively called individuals  ij names classic individuals  new host descriptions
constructed using fi        g  ij host values 
interpretation function  i extended individual identifiers  requiring ii
non empty subset c   syntactically recognized host individual 
making ii   fig host values i  stated earlier  interpretations distinct identifiers
must non overlapping 
interpretation ci non atomic descriptions modified follows 
   

fisubsumption classic

p   ii   fd   c j  x  d  x    pi   x   ii g
fi        ingi   sk iik ik classic individuals  fi        ingi   fi        g ik
host individuals  empty otherwise 

 n p i  resp   n p i   objects c least  resp  most  n noncongruent fillers role p

development subsumption algorithm section   modified take
account added constructs modified semantics introduced earlier 
first description graphs extended  node description graph given third
field  either finite set individuals special marker denoting  universal 
set  field often called dom node  a edges r edges given
extra field  called fillers edge  field finite set individuals 
unspecified  constructions previous sections  dom node universal set
fillers a edge r edge empty set 
semantics description graphs definition   extended following 

definition   let g   hn  e  ri description graph let possible world 

element  d  gi   iff function    n

      r  
   n   n  n    ni  
   hn    n   a  f   e h n      n  i   ai   f   f    n      f  
element  d  ni   n   hc  h  i  iff
   c   c     ci  
   hr  m  m  g  f   h  
 a 
 b 
 c 

elements  d   domain hd  d i   ri  
d    gi d  hd  d i   ri  
f   f domain element  d    hd  d i   ri d    f

   universal set  f     f  

merging nodes  dom sets intersected  merging description graphs unchanged  merging a edges r edges  sets fillers unioned 
translation descriptions description graphs extended following rules 
   description form r   turned description graph one node
a edges  node atoms classic thing single r edge role
r  min    max    fillers fig  description graph restricting r edge
gclassic thing classic individual  ghost thing otherwise 
   

fiborgida   patel schneider

   description form   turned description graph two nodes
single a edge them  distinguished node graph source
a edge  r edges atoms classic thing  node
r edges  atoms classic thing classic individual 
host thing otherwise  a edge single filler i 
    description form fi        g turned description graph one node 
node dom set containing i    r edges  atoms
node host thing individuals host values  classic thing
individuals classic individual names   note parser ensures
individuals either must host values must classic individual names  
short examination shows theorem   true graphs  i e   extension
description graphs formed using rules extension description
formed 
following transformations added canonicalization algorithm 
   dom node empty  mark node incoherent 
    host value dom node atoms node  remove
dom 
    a edge one filler  mark description graph incoherent 
    a edge filler node end universal dom  make dom
filler 
    filler a edge included dom node end  mark
description graph incoherent 
    node one element dom  make element filler
a edges pointing it 
    fillers r edge subset dom distinguished node
restriction graph edge  mark node r edge incoherent 
    min r edge less cardinality fillers it  let min
cardinality 
    max r edge greater cardinality dom distinguished node description graph r edge  make max edge
cardinality dom 
    min r edge greater equal cardinality dom
distinguished node restriction graph r edge  let fillers edge
union fillers dom above   if min greater cardinality 
steps      detect inconsistency  
   

fisubsumption classic

    max edge equal cardinality fillers edge  let dom
distinguished node description graph r edge intersection
dom fillers   if max less cardinality  steps      detect
inconsistency  
note new canonical form a edges pointing single node
value fillers  empty set  node set
value dom 
proofs lemmas     work extension description graphs 
proof theorem   extended graphs 
subsumption algorithm page     extended follows 
    r   r edge r role r fillers including i 
      a edge r attribute fillers including i 
    fi        g dom r subset fi        g 
again  soundness extended algorithm fairly obvious  completeness
proof following additions construction graphical worlds 

extension classic individual names starts empty 
constructing graphical worlds node includes host thing
atoms non universal dom  pick domain elements corresponding
elements dom 

constructing graphical worlds node includes classic thing
atoms non universal dom  add distinguished domain element
extension one dom elements 

constructing graphical worlds r edges node  ensure element

fillers r edge distinguished element least one graphical
worlds extension either adding extension using appropriate
host domain elements   this done fillers must subset
dom distinguished node graphical world host values must belong
atoms  

fillers a edges need considered  pushed  onto nodes
canonicalization process 
proof theorem   extended following cases 

form fi        ing dom r subset fi          ing  thus
graphical worlds g distinguished domain element
extension ij 

form   either a edge r labelled
filler a edge 

   

fiborgida   patel schneider

former case node pointed a edge cannot domain
singleton consisting i  therefore graphical worlds g
distinguished node a filler extension i  required 
latter case  pick graphical worlds g distinguished node afiller wrong realm  graphical worlds g distinguished element
extension d 

form r   either r edge r labelled r
filler r edge 
former case either cardinality dom distinguished node
description graph r edge greater min  m  r edge  dom
include i  dom include i  graphical worlds
node distinguished element extension i  required 
dom include i  least elements dom besides i 
fillers r edge subset set elements  thus graphical
worlds g use elements  required 
latter case  pick graphical worlds g distinguished node rfiller wrong realm  graphical worlds g distinguished element
extension d 

shows subsumption algorithm given sound complete
modified semantics presented here 

   complete classic

make final pass deal less problematic aspects classic descriptions
appropriately covered far 
classic allows primitive descriptions form  primitive t  
description  symbol  extension arbitrary subset
extension d  extension  primitive e t   provided
e subsume other  way one express employee  kind person
must employee number 
 primitive  person u   employeenr  employee 
construct removed creating every primitive atomic concept  e g  
employeehood  replacing definition concept conjunction
necessary conditions atom  case employeehood u  person u
  employeenr   care taken use atomic concept equivalent primitives 
classic permits declaration disjoint primitives  essentially allowing one state
extensions various atomic concepts must disjoint possible worlds 
deal declarations  need modify algorithm creating canonical graphs
adding step marks node incoherent whenever atoms contains two identifiers
declared disjoint 
   

fisubsumption classic

allow approximate representation ideas cannot encoded using
constructors expressly provided  classic allows use test defined concepts  using
following syntax 
 test  host language boolean function  
e g    test prime number testing function    purposes subsumption 
treated  black boxes   semantics assigned atomic concepts   test concepts
real effect reasoning level individuals  perform constraint
checking  
simple additions  algorithm sound complete subsumption
algorithm descriptions classic    modified semantics introduced
paper 

   summary  related work  conclusions
believe paper makes two kinds contributions  first  paper presents abstracted form subsumption algorithm classic description logic  shows
ecient correct modified semantics  significant
previous claims correct ecient subsumption algorithms implemented dls
kandor  patel schneider        candide  beck et al         turned
unfounded  nebel        
tractability proof language basic classic claimed exist  but
proven   donini et al          alternate proof technique may found considering restriction  corrected  subsumption algorithm  hollunder   nutt        
description graphs turned interest support
theoretical results dls  concerning learnability  cohen   hirsh        pitt  
frazier        results would seem harder obtain using standard notation
dls 
second  paper investigates effect allowing individuals appear descriptions dls  independently demonstrated  lenzerini   schaerf         adding
set description introduces yet another source intractability  provided
intuitive example illustrating source diculties  implementers classic
system  others use refutation tableaux theorem proving techniques  chose
perform inferences validated standard semantics 
formal intractability result obvious algorithm apparent  short enumerating possible ways filling roles  subset inferences actually performed
initially described procedurally   facts  individuals taken account
subsumption algorithm  paper provides denotational semantic account
incomplete set inferences  formal proof correct account corollary
completeness proof subsumption algorithm section    observation
graph construction subsumption algorithms section indeed ignore
   order deal two realms  classic fact provides two constructors  h test ctest  host classic descriptions  cause added complications besides
keeping track correct realm 

   

fiborgida   patel schneider

properties individuals involved  one difference original implementation classic current semantics attribute paths ending
filler used imply equality condition  noted section      modified
semantics support inference  taken implementation
classic  significant change standard semantics small  easy explain
users  either procedurally semantically   affects desired aspects
language  i e   reasoning basic classic remains exactly before  

acknowledgments

wish thank ronald brachman colleagues classic project
collaboration  jair referees excellent suggestions improving
paper  particular  one referees deserves medal thoroughness care
taken locating weaknesses arguments  thankful  remaining
errors course responsibility 

references

at kaci  h          lattice theoretic approach computation based calculus
partially ordered type structures  ph d  thesis  university pennsylvania 
at kaci  h     nasr  r          login  logic programming language built in
inheritance  journal logic programming             
american association artificial intelligence         issues description logics  users
meet developers  working notes aaai      fall symposium 
baader  f   burckert  h  j   heinsohn  j   hollunder  b   muller  j   nebel  b   nutt  w  
  profitlich  h  j          terminological knowledge representation  proposal
terminological logic  german research center artificial intelligence  dfki  
baader  f     hanschke  p          scheme integrating concrete domains concept
languages  proceedings twelfth international joint conference artificial
intelligence  pp           international joint committee artificial intelligence 
long version appears research report rr       german research center
artificial intelligence  dfki   april      
baader  f     hollunder  b          kris  knowledge representation inference system 
sigart bulletin              
beck  h  w   gala  s  k     navathe  s  b          classification query processing
technique candide semantic data model  proceedings fifth international data engineering conference  pp           institute electric electronic
engineers 
borgida  a   brachman  r  j   mcguinness  d  l     resnick  l  a          classic 
structural data model objects  proceedings      acm sigmod international conference mangement data  pp         association computing
machinery 
   

fisubsumption classic

borgida  a          type systems knowledge representation  natural semantics
specifications description logics  international journal intelligent cooperative information systems                
brachman  r  j   fikes  r  e     levesque  h  j          krypton  functional approach
knowledge representation  ieee computer                 
cohen  w  w     hirsh  h   forthcoming   learnability description logics equality
constraints  machine learning  preliminary version appears proceedings
fourth annual workshop computational learning theory 
devanbu  p   brachman  r  j   ballard  b     selfridge  p  g          lassie  knowledgebased software information system  communications acm                
donini  f  m   lenzerini  m   nardi  d     nutt  w          tractable concept languages 
proceedings twelfth international joint conference artificial intelligence 
pp           international joint committee artificial intelligence 
doyle  j     patil  r          two theses knowledge representation  language restrictions  taxonomic classification  utility representation services  artificial
intelligence                  
pitt  l     frazier  m          classic learning  proceedings seventh annual acm
conference computational learning theory new brunswick  nj  acm press 
heinsohn  j   kudenko  d   nebel  b     profitlich  h  j          empirical analysis terminological representation systems  proceedings tenth national
conference artificial intelligence  pp           american association artificial
intelligence 
hollunder  b     nutt  w          subsumption algorithms concept languages  research
report rr        german research center artificial intelligence  dfki  
lenzerini  m     schaerf  a          concept languages query languages  proceedings
ninth national conference artificial intelligence  pp           american
association artificial intelligence 
levesque  h  j     brachman  r  j          expressiveness tractability knowledge
representation reasoning  computational intelligence               
macgregor  r  m     bates  r          loom knowledge representation language  tech 
rep  isi rs         information sciences institute  university southern california 
mays  e   apte  c   griesmer  j     kastner  j          organizing knowledge complex
financial domain  ieee expert           
nebel  b          computational complexity terminological reasoning back  artificial
intelligence                  
nebel  b          terminological reasoning inherently intractable  artificial intelligence 
                
   

fiborgida   patel schneider

nebel  b   peltason  c     von luck  k   eds            international workshop terminological logics  document d        german research center artificial intelligence
 dfki  
owsnicki klewe  b          configuration consistency maintenance task  hoeppner  w   ed    proceedings gwai    the   th german workshop artificial
intelligence  pp         springer verlag 
patel schneider  p  f          small beautiful knowledge representation 
proceedings ieee workshop principles knowledge based systems  pp 
       ieee computer society 
patel schneider  p  f          decidable  logic based knowledge representation  ph d 
thesis  department computer science  university toronto 
patel schneider  p  f       a   four valued semantics terminological logics  artificial
intelligence                  
patel schneider  p  f       b   undecidability subsumption nikl  artificial intelligence                  
peltason  c   von luck  k     kindermann  c   eds            terminological logic users
workshop  fachbereich informatik  technische universitat berlin 
peltason  c   von luck  k   nebel  b     schmiedel  a          user s guide
back system  kit report     fachbereich informatik  technische universitat berlin 
resnick  l  a   borgida  a   brachman  r  j   mcguinness  d  l     patel schneider 
p  f          classic description reference manual common lisp
implementation  ai principles research department  at t bell laboratories 
schmidt schauss  m          subsumption kl one undecidable  proceedings
first international conference principles knowledge representation
reasoning  pp           morgan kaufmann 
wright  j  r   weixelbaum  e  s   brown  k   vesonder  g  t   palmer  s  r   berman 
j  i     moore  h  h          knowledge based configurator supports sales 
engineering  manufacturing at t network systems  proceedings
innovative applications artificial intelligence conference  pp           american
association artificial intelligence 

a  intractability reasoning one of

present formal proof subsumption set descriptions fact np hard   
show term language allows set description need
 case analysis  order check whether extension individual belongs
description not  constructor behaves disjunction elements
    original result submitted publication       different  independent  proof
result since outlined  lenzerini   schaerf        

   

fisubsumption classic

extensions individuals whose membership terms known priori  i e   nonhost individuals  particular  show encode testing unsatisfiability
formula  cnf question recognizing individual instance description 
since problem known np hard  strong indication intractability 
start formula f    cnf  using demorgan s laws  construct formula g 
negation f    dnf  testing validity g equivalent checking
unsatisfiability f  
construct every propositional symbol p used f   two individual names p p   
 here p  represent negation p   individual attribute truthvalue 
possible fillers true false
p  p     truthvalue  ftrue falseg 
make sure p p  exactly one  opposite  truth values  create two
individual names  yesp nop  additional attributes approve deny respectively 
whose fillers need truth value true false respectively 
yesp    approve  fp p  g u  truthvalue  ftrueg 
nop    deny  fp p  g u  truthvalue  ffalseg 
now  given formula g   c     c             cn  create individual names c   c  
        cn  role conjuncts containing propositions conjuncts 
example  c     p    q    r
c     conjuncts  fp q  r  g u   conjuncts 
finally  construct individual g c   c           cn possible fillers new role

disjunctsholding  

g    disjunctsholding  fc  c        cng 

formula g valid iff always least one disjunct holds 
equivalent membership concept valid formulae defined

  disjunctsholding u  disjunctsholding   conjuncts   truthvalue ftrueg   
shows recognizing whether individuals instances descriptions
intractable presence set descriptions  minimum number restrictions  value
restrictions 
convert question concerning subsumption two descriptions
essentially making individuals involved attribute fillers new dummy attributes 
descriptions restrictions attributes  description nonempty attribute values must satisfy corresponding restrictions 
so  define concept upper

 formula valid formulae
define concept lower
   

fiborgida   patel schneider

 dummy  p  fpg u  p  s concept descriptor    u
 dummy  p  fp g u  p   s concept descriptor    u
 dummy  p  fyespg u        u
 dummy  p  fnopg u        u
   
 dummy  ci  fcig u        u
   
 formula  fgg u       
database state either concept lower instances  case
subset extension upper  least one instance  case
individual names filling various dummy attributes must properties ascribed
them  whence c valid formulae  and hence upper subsume lower  iff
c valid  completes proof 

   


