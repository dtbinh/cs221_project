journal of artificial intelligence research                 

submitted       published     

a semantics and complete algorithm for
subsumption in the classic description logic
alex borgida

borgida cs rutgers edu

department of computer science
rutgers university
new brunswick  nj       u  s  a 

peter f  patel schneider

pfps research att com

at t bell laboratories
    mountain avenue
murray hill  nj       u  s  a 

abstract

this paper analyzes the correctness of the subsumption algorithm used in classic 
a description logic based knowledge representation system that is being used in practical
applications  in order to deal eciently with individuals in classic descriptions  the developers have had to use an algorithm that is incomplete with respect to the standard 
model theoretic semantics for description logics  we provide a variant semantics for descriptions with respect to which the current implementation is complete  and which can
be independently motivated  the soundness and completeness of the polynomial time subsumption algorithm is established using description graphs  which are an abstracted version
of the implementation structures used in classic  and are of independent interest 

   introduction to description logics

data and knowledge bases are models of some part of the natural world  such models
are often built from individual objects that are inter related by relationships and grouped
into classes that capture commonalities among their instances  description logics  dls  
also known as terminological logics  form a class of languages used to build and access such
models  their distinguishing feature is that classes  usually called concepts  can be defined
intensionally in terms of descriptions that specify the properties that objects must satisfy
to belong to the concept  these descriptions are expressed using some language that allows
the construction of composite descriptions  including restrictions on the binary relationships
 usually called roles  connecting objects 
as an example  consider the description
game u   participants u  participants  person u gender   female   
this description characterizes objects in the intersection  u  of three sub descriptions 
game objects that belong to the atomic concept    participants objects with at least
four fillers for the participants role  and  participants  person u gender   female  objects
all of whose participants fillers are restricted to belong to persons  which themselves have
gender role filled by the value female 
   the notation used for descriptions here is the standard notation in the description logic community
 baader et al          the classic notation is not used because it is more verbose 

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fiborgida   patel schneider

a key difference between dls and the standard representation formalisms based on
first order logic  e g   relational and deductive databases  is that dls provide an arena
for exploring new sets of  logical connectives  the constructors used to form composite
descriptions that are different from the standard connectives such as conjunction  universal
quantifiers  etc   therefore  dls provide a new space in which to search for expressive
yet effectively computable representation languages  moreover  although it is possible to
translate many aspects of dls currently encountered into first order logic  reasoning with
such a translation would be a very poor substitute because dl based systems reason in a
way that does not resemble standard theorem proving  e g   by making use of imperative
programming features  
descriptions such as the one above can be used in several ways in a knowledge base
management system  kbms  based on a description logic 
   to state queries  the kbms can locate all the objects that satisfy the description s
properties 
   to define and classify concepts  identifiers can be attached to descriptions  in the manner of views in relational dbmss  the system can in addition automatically determine
the  subclass  relationship between pairs of such concepts based on their definitions 
for example  a concept defined by the above description would be subsumed by a
concept defined by  games with at least two participants   game u   participants  
   to provide partial information about objects  it is important to understand that distinct dl descriptions can be ascribed to arbitrary individuals  e g    today s game
of cards individual bgm     will have exactly two participants from the following
set of three         all of whom like tea and rum    note that unlike database systems  dl based kbmss do not require descriptions to be predefined  this provides
considerable power in recording partial knowledge about objects 
   to detect errors  it is possible to determine whether two descriptions are disjoint 
whether a description is incoherent or not  and whether ascribing a description to an
individual leads to an inconsistency 
quite a number of kbmss based on description logics have been built  including classic
 resnick et al          loom  macgregor   bates         and back  peltason et al         
such systems have been used in several practical situations  including software information
bases  devanbu et al          financial management  mays et al          configuration management  owsnicki klewe        wright et al          and data exploration  additional
signs that dls are significant subjects of study are the several recent workshops on dls
 nebel et al         peltason et al         aaai        

    on the tractability and completeness of dl implementations

the fundamental operation on descriptions is determining whether one description is more
general  or subsumes  another  in the sense that any object satisfying the latter would also
satisfy the conditions of the former  in parallel with the surge of work on finding tractable
yet expressive subsets of first order logic  the dl research community has been investigating
the complexity of reasoning with various constructors  the first result in this area  levesque
   

fisubsumption in classic

  brachman        showed that even a seemingly simple addition to a very small language
can lead to subsumption determination becoming np hard  a more recent  striking pair of
results  patel schneider      b  schmidt schauss        shows that adding the ability to
represent equalities of role compositions makes the complexity of the subsumption problem
leap from quadratic to undecidable 
there are three possible responses to these intractability results 
 provide an incomplete implementation of the dl reasoner  in the sense that there
are inferences sanctioned by the standard semantics of the constructors that are not
performed by the algorithm  this approach  explicitly adopted by the loom system
implementers  macgregor   bates         and advocated by some users  doyle  
patil         has one major diculty  how can one describe to users the inferences
actually drawn by the implementation so that systems with known properties can be
implemented on top of such kbms  two solutions to this problem have been suggested  alternative semantic accounts  based on weaker    valued logics  for example 
 patel schneider      a   and proof theoretic semantics  borgida        
 provide a complete implementation of a specific dl reasoner  acknowledging that in
certain circumstances it may take an inordinate amount of time  this approach 
followed in systems such as kris  baader   hollunder         has the problem of
unpredictability  when will the system  go off into the wild blue yonder   and of
course  in some circumstances this is impossible to even attempt since the reasoning
problem is undecidable 
 carefully devise a language of limited expressive power for which reasoning is tractable 
and then provide a complete implementation for it  this was the approach chosen
by the designers of such languages as kandor  patel schneider        and krypton
 brachman et al          and is close to the approach in classic  borgida et al  
      
a hidden diculty in the second and third approach is to produce an implementation
that is correct   complete   with respect to the semantics  this diculty is illustrated by
the discovery  several years later  that the implementation of kandor  as well as candide
 beck et al          was in fact incomplete  and its subsumption problem is np hard  nebel 
       rather than polynomial  as was claimed  this happened despite the fact that kandor
is a very  small  language in comparison with other dls  and its implementation appeared
to be evidently correct  to avoid such problems  it is necessary to produce convincing
demonstrations that the algorithm is correct  several such proofs have in fact already appeared in the dl literature  e g    patel schneider        hollunder   nutt        donini
et al           albeit only for languages that have not seen use in practical applications 

    outline

the classic    system is a reasoner based on a moderately complicated dl  it is being
used in commercial  wright et al         and prototype applications at at t  and is made
available to academic researchers by at t bell laboratories 
   classic   is the first released version of classic  a new version  classic    with a more expressive dl 
has recently been released 

   

fiborgida   patel schneider

one purpose of this paper is to provide a rigorous formal analysis of the correctness
and eciency for the classic dl subsumption algorithm   we start by presenting such
a result for a subset of the language  which we call basic classic  the subsumption
algorithm relies on the transformation of descriptions into a data structure  which we call
description graphs  and which are a generalization of a kaci s psi terms         in the
process of normalizing such a graph to a canonical form  we remove obvious redundancies
and explicate certain implicit facts  encoding in particular the infinite set of inferences that
can be drawn from so called  coreference constraints   the correctness of the subsumption
algorithm is demonstrated rigorously by showing how to construct  inductively  a countermodel in case the algorithm returns the answer  no  
next  we explore the effect of adding individuals to descriptions  we show that  using
individuals  one can encode disjunctive information leading to the need to examine combinatorially many possibilities  the classic implementation is in fact incomplete with respect
to the standard semantics  the second contribution of this paper is then a well motivated 
understandable  and small change to the standard semantics that alleviates this problem 
we extend the subsumption algorithm and its proof of correctness to deal with individuals
under the modified semantics  thereby characterizing in some sense the  incompleteness 
of the reasoner 
this paper therefore illustrates all three paradigms described above  albeit in a nonstandard manner for the second paradigm  and does so for the first time on a realistic
language with significant practical use 

   basic classic
descriptions in basic classic are built up from a collection of atomic concept names  role
names  and attribute names  roles and attributes are always atomic but descriptions can
be built up using operators constructors such as value restrictions and number restrictions 
as we indicate below 
basic classic incorporates objects from the host programming language   called host
individuals  which form a distinct group from classic individuals  only the latter can have
roles or attributes of their own  the former being restricted to be role or attribute fillers 
the denotational semantics of classic descriptions starts  as usual  with a domain of
values    subsets of which are extensions for descriptions  while subsets of    are
extensions of roles and attributes  this domain is in fact disjointly divided into two realms 
the host realm  h   containing objects corresponding to host language individuals  and the
classic realm c   containing the other objects  every description  except for thing  which
denotes the entire domain has as its extension a subset of either the classic realm or the
host realm   nothing denotes the empty set  which is therefore both a classic and host
concept   the extension of a role in a possible world is a relation from the classic realm to
the entire domain  while the extension of an attribute is a function from the classic realm
into the entire domain 
   in empirical tests  heinsohn et al          classic has emerged as the fastest of the current dl
implementations 
   a general scheme for incorporating such host objects is described in  baader   hanschke        

   

fisubsumption in classic

host descriptions are relatively simple   i  host thing  denoting the entire host realm 
h    ii  special  pre defined names corresponding to the types in the host programming language  and  iii  conjunctions of the above descriptions  the descriptions corresponding to
the host programming language types have pre defined extensions and subsumption relationships  mirroring the subtype relationship in the host programming language  this
subtype relationship is satisfied in all possible worlds interpretations  we require that  i 
all host concepts have an extension that is either of infinite size or is empty   ii  that if
the extensions of two host concepts overlap  then one must be subsumed by the other  i e  
types are disjoint  unless they are subtypes of each other  and  iii  that a host concept has
an infinite number of extra instances than each of its child concepts   these conditions are
needed to avoid being able to infer conclusions from the size of host descriptions   this
allows for host concepts like integer  real  complex  and string  but not boolean
or non zero integer  
non host  classic  descriptions in basic classic are formed according to the following
syntax 
syntax
constructor name
classic thing
e
atomic concept name
cud
intersection
 r c
role value restriction
 a c
attribute value restriction
n r
minimum number restriction
m r
maximum number restriction
a         ak   b         bh equality restriction
where e is an atomic concept name  c and d are classic descriptions  r is a role  a  ai  
and bj are attributes  n k h are positive integers  and m is a non negative integer  the set
of constructors in basic classic was judiciously chosen to result in a language in which
subsumption is easy to compute 
the denotational semantics for descriptions in basic classic is recursively built on the
extensions assigned to atomic names by a possible world 
definition   a possible world interpretation  i   consists of a domain    and an interpretation function  i   the domain is disjointly divided into a classic realm  c   and a host
realm  h   the interpretation function assigns extensions to atomic identifiers as follows 
 the extension of an atomic concept name e is some subset ei of the classic realm 
 the extension of an atomic role name r is some subset ri of c   
 the extension of an atomic attribute name a is some total function ai from c to
 
the extension ci of a non atomic classic description is computed as follows 
 classic thingi   c  
  c u d i   ci   di  
   

fiborgida   patel schneider

   p c i   fd   c j  x  d  x    pi   x   ci g  i e   those objects in c all of
whose p role or p attribute fillers are in the extension of c 

  n p i  resp   n p i   is those objects in c with at least  resp  at most  n fillers
for role p 

  a        ak   b        bh  i   fd   c j ak i        a i  d     bhi        b i  d  g  i e  

those objects in c with the property that applying the composition of the extension
of the ai s and the composition of the extension of the bj s to the object both result in
the same value  

a description  d   is then said to subsume another  d    if for all possible worlds i   d i 
d  i  

of key interest is the computation of the subsumption relationship between descriptions
in basic classic  subsumption computation is a multi part process  first  descriptions
are turned into description graphs  next  description graphs are put into canonical form 
where certain inferences are explicated and other redundancies are reduced by combining
nodes and edges in the graph  finally  subsumption is determined between a description
and a canonical description graph 
to describe in detail the above process  we start with a formal definition of the notion
of description graph  definition     and then present techniques for

 translating a description to a description graph  section       which requires merging
pairs of nodes  and pairs of graphs  definitions   and    

 putting a description graph into canonical form  section      
 determining whether a description subsumes a description graph  algorithm    
to prove the correctness of this approach  we need to show that the first two steps
lead us in the right direction  i e   that the following three questions are equivalent   does
description d subsume description c     does description d subsume graph gc     and
 does description d subsume graph canonical gc      to do this  we need to define the
formal semantics of both descriptions and graphs  definitions   and     and then prove the
results  theorems   and     to prove the  completeness  of the subsumption algorithm  we
show that if the algorithm does not indicate that d subsumes canonical gc    then we can
construct an interpretation   graphical world   in which some object is in the denotation
of canonical gc   but not that of d 

    description graphs

one way of developing a subsumption algorithm is to first transform descriptions into a
canonical form  and then determine subsumption relationships between them  canonical
descriptions can normally be thought of as trees since descriptions are terms in a first order
term language  the presence of equality restrictions in classic significantly changes the
   note that both attribute chains must have a definite value  and that all but the last cannot evaluate to
host individuals  since these cannot have attributes 

   

fisubsumption in classic

fclassic thing
g
t

fthing
t g
 




 


 


captain 
coach



 


participants   t fpersong
t 

 

fgameg

father

      

figure    a description graph 
handling of subsumption because they introduce relationships between different pieces of
the normal form  most significantly  in the presence of equalities  a small description  such
as  friend tall u friend   friendfriend  can be subsumed by descriptions of arbitrary size 
such as
 friend   friend          friend tall          
in order to record such sets of inferences in the canonical form  we will resort to a graphbased representation  suggested by the semantic network origins of description logics  and
the work of a kaci        
intuitively  a description graph is a labelled  directed multigraph  with a distinguished
node  nodes of the graph correspond to descriptions  while edges of the graph correspond
to restrictions on roles or attributes  the edges of the graph are labelled with the role name
and the minimum and maximum number of fillers associated with the edge  or just with the
attribute name  the nodes of the graph are labelled with concept names associated with
the node concept  for example  figure   is a description graph  which  as we shall see later 
corresponds to the description game u  participants  person u coach    captainfather  
because equality restrictions  and hence the non tree portions of the graph  involve only
attributes  edges labelled with roles are all cut edges  i e   their removal increases by one the
number of connected components of the graph  this restriction is important because if the
graph is in tree form  there is really no difference between a graphical and a linear notation 
and a semantics is simple to develop  if the graph is a general directed acyclic graph 
then there is the problem of relating the semantics generated by two different paths in the
graph that share the same beginning and ending nodes  if the graph contains cycles  the
problem of developing a correct semantics is even more dicult  as a simplistic semantics
will be non well founded  and some sort of fixed point or model preference semantics will be
required  fortunately  any non tree parts of our graphical notation will involve attributes
only  and because attributes are functional  our job will be much easier 
as a result of the above restrictions  it is possible to view a description graph as having
the following recursive structure   i  there is a distinguished node r  which has an  island 
of nodes connected to it by edges labelled with attributes   ii  nodes in this island may
have   or more edges labelled with roles leaving them  pointing to distinguished nodes of
other description graphs   iii  these graphs share no nodes or edges in common with each
other  nor with the islands above them 
   

fiborgida   patel schneider

because of this recursive structure  it is easier to represent description graphs using a
recursive definition  instead of the usual graph definition  this recursive definition is similar
to the recursive definition of a tree  which states that a tree consists of some information
 the information on the root of the tree  plus a set of trees  the children of the root of the
tree   as description graphs are more complex than simple trees  we will have to use a
two part definition 

definition   a description graph is a triple  hn  e  ri  consisting of a set n of nodes  a

bag e of edges  a edges  labelled with attribute names  and a distinguished node r in n  
elements of e will be written hn    n   ai where n  and n  are nodes and a is an attribute
name 
a node in a description graph is a pair  hc  h i consisting of a set c of concept names
 the atoms of the node   and a bag h of tuples  the r edges of the node   an r edge is a
tuple  hr  m  m  gi  of a role name  r  a min  m  which is a non negative integer  a max 
m   which is a non negative integer or    and a  recursively nested  description graph g 
representing the restriction on the fillers of the role   g will often be called the restriction
graph of the node  
concept names in a description graph are atomic concept names  host concept names 
thing  classic thing  or host thing 

descriptions graphs are provided extensions starting from the same possible worlds i
as used for descriptions  however  in addition we need a way of identifying the individuals
to be related by attributes  which will be given by the function  

definition   let g   hn  e  ri be a description graph and let i be a possible world  then

the interpretation gi of g  and the interpretation ni of each of the nodes in n   are recursively  and mutually  defined as follows 
an element  d  of  is in gi   iff there is some function    from n into  such that
   d    r  
   for all n   n  n    ni  
   for all hn    n   ai   e we have h n      n  i   ai    which is equivalent to  n     
ai   n     since ai is a function  
an element  d  of  is in ni   where n   hc  h i  iff
   for all c   c   we have d   ci   and
   for all hr  m  m  gi   h  
 a  there are between m and m elements  d   of the domain such that hd  d i   ri
and
 b  d    gi for all d  such that hd  d i   ri  
   

fisubsumption in classic

    translating descriptions to description graphs

a basic classic description is turned into a description graph by a recursive process 
working from the  inside out   in this process  description graphs and nodes are often
merged 

definition   the merge of two nodes  n   n   is a new node whose atoms are the union

of the atoms of the two nodes and whose r edges are the union of the r edges of the two
nodes  

definition   the merge of two description graphs  g   g   is a description graph whose

nodes are the disjoint union  of the non distinguished nodes of g  and g  plus a new
distinguished node  the edges of the merged graph are the union of the edges of g  and g  
except that edges touching on the distinguished nodes of g  or g  are modified to touch the
new distinguished node  the new distinguished node is the merge of the two distinguished
nodes of g  and g  

the rules for translating a description c in basic classic into a description graph gc
are as follows 
   a description that consists of a concept name is turned into a description graph with
one node and no a edges  the atoms of the node contains only the concept name 
the node has no r edges 
   a description of the form n r is turned into a description graph with one node and
no a edges  the node has as its atoms classic thing and has a single r edge with
role r  min n  max    and restriction gthing  
   a description of the form n r is turned into a description graph with one node and
no a edges  the node has as its atoms classic thing and a single r edge with role
r  min    max n  and restriction gthing  
   a description of the form  r c  with r a role  is turned into a description graph with
one node and no a edges  the node has as its atoms classic thing and has a single
r edge with role r  min    max    and restriction gc 
   to turn a description of the form c u d into a description graph  construct gc and
gd and merge them 
   to turn a description of the form  a c  with a an attribute  into a description graph 
first construct the description graph hnc   ec   rc i for c  the description graph for
 a c is hnc   ftg  ec   fht  rc   aig  ti  where t is the node hfclassic thingg  fgi 
   to turn a description of the form a         an   b         bm into a description graph
first create a distinguished node  node r  with classic thing as its atoms  and a
node e  with thing as its atoms  for    i  n     create a node ai   with its atoms
   note that duplicate edges  such as ones joining ni to ni   are not removed  since the edges form a bag 
   in taking the disjoint union of two sets  elements of one may be systematically renamed first to make
sure that the sets are non overlapping 

   

fiborgida   patel schneider

being classic thing  for    j  m     create a node bj   with its atoms being
classic thing  none of the ai or bj have r edges 
if n      create the edge hr  e  a i  if n     then create edges hr  a   a i  han     e  an i 
and hai     ai  ai i for    i  n     
similarly  if m      create the edge hr  e  b i  if m     then create edges hr  b   b  i 
hbm    e  bmi  and hbi    bi  bii for    i  m     
this creates two disjoint paths  one for the ai and one for the bj   from the distinguished node to the end node 
figure   presents a view of a description graph constructed in this fashion from the
description game u  participants person u coach   captainfather 
now we want to show that this process preserves extensions  as we use the merge
operations we first show that they work correctly 

lemma   if n  and n  are nodes then  n   n  i   ni    ni    if d  and d  are description
graphs then  d   d  i   d i   d i  
proof  since the components  atoms and r edges  of the merged node are obtained by

unioning the components of the respective nodes  and since the interpretation of a node
is the intersection of the interpretation of its components  the result is obviously true for
nodes 
for merging graphs  the only difference is that the root nodes are replaced by their
merger in all edges  as well as the root  but then an element of  d   d  i is clearly an
element of both d i and d i   conversely  since we take the disjoint union of the other nodes
in the two graphs  the mapping functions   and   in definition   can simply be unioned 
so that an element of both d i and d i is an element of the merged root node  and hence
of  d   d   i  

theorem   for all possible worlds  the extension of a description is the same as the ex 

tension of its description graph 
proof  the proof is by structural induction on descriptions 
the extension of concept names  cardinality restrictions  and   restrictions on roles
can be easily seen to agree with the extension of description graphs formed from them 
lemma   shows that conjunction is properly handled  for   restrictions on attributes  the
construction is correct because attributes are functional 
for equalities a         an   b         bm the construction forms a description graph with
two disjoint paths from the distinguished node to an end node  one labelled by the ai  
through nodes ai   and the other labelled by the bj   through nodes bj   if

d    a         an   b         bm i   fd   c j ak i        a  i  d     bh i        b  i  d  g 
then defining  ai     ai i        a  i  d   and  bj     bj i        b  i  d  g  yields the mapping

required by definition    the converse is satisfied by the requirement in definition   that
for each a edge hn    n   ai   e   we have  n      ai   n     
   

fisubsumption in classic

    canonical description graphs

in the following sections we will occasionally refer to  marking a node incoherent   this
consists of replacing it with a special node having no outgoing r edges  and including in
its atoms nothing  which always has the empty interpretation  marking a description
graph as incoherent consists of replacing it with a description graph consisting only of an
incoherent node   incoherent graphs are to be thought of as representing concepts with
empty extension  
description graphs are transformed into canonical form by repeating the following normalization steps whenever possible for the description graph and all its descendants 
   if some node has in its atoms a pre defined host concept  add host thing to its
atoms  if some node has an atomic concept name in its atoms  add classic thing
to its atoms  for each pre defined host concept in the atoms of the node  add all the
more general pre defined host concepts to its atoms 
   if some node has both host thing and classic thing in its atoms  mark the
node incoherent  if some node has in its atoms a pair of host concepts that are not
related by the pre defined subsumption relationship  mark the node incoherent  since
their intersection will be empty 
   if any node in a description graph is marked incoherent  mark the description graph
as incoherent   reason  even if the node is not a root  attributes must always have a value 
and this value cannot belong to the empty set  
   if some r edge in a node has its min greater than its max  mark the node incoherent 
   if some r edge in a node has its description graph marked incoherent  change its max
to     reason  it cannot have any fillers that belong to the empty set  
   if some r edge in a node has a max of    mark its description graph as incoherent 
 reason  this normalization step records the equivalence between   r and  r nothing 
and is used then to infer that a concept with  r c for arbitrary c subsumes   r  
   if some node has two r edges labelled with the same role  merge the two edges  as
described below 
   if some description graph has two a edges from the same node labelled with the same
attribute  merge the two edges 
to merge two r edges of a node  which have identical roles  replace them with one redge  the new r edge has the role as its role  the maximum of the two mins as its min  the
minimum of the two maxs as its max  and the merge of the two description graphs as its
restriction 
to merge two a edges hn  n    ai and hn  n   ai  replace them with a single new edge
hn  n   ai  where n  results from merging n  and n   i e   n    n   n    if n    n  then
n    n    in addition  replace n  and n  by n  in all other a edges of this description graph 
   

fiborgida   patel schneider

we need to show that the transformations to canonical form do not change the extension
of the graph  the main diculty is in showing that the two edge merging processes do not
change the extension 

lemma   let g   hn  e  ri be a description graph with two mergeable a edges and let
g    hn    e    r i be the result of merging these two a edges  then gi   g i  
proof  let the two edges be hn  n   ai and hn  n   ai and the new node n  be n   n  
choose d   gi   and let  be a function from n into the domain satisfying the conditions

for extensions  definition    such that  r    d  then  n       n    because both are
equal to ai   n    let   be the same as  except that    n       n       n     then
  satisfies definition    part    for g   because we replace n  and n  by n  everywhere 
moreover     n      n      ni    ni    which  by lemma    equals  n   n   i   so part   is
satisfied too  since n    n   n    finally  if the root is modified by the merger  i e   n  or
n  is r  say n   then d    n        n    so part   of the definition is also satisfied 
conversely  given arbitrary d   g i   let   be the function stipulated by definition   such
that    r     d  let  be the same as   except that  n       n    and  n         n    
then the above argument can be traversed in reverse to verify that  satisfies definition   
so that d   gi  

lemma   let n be a node with two mergeable r edges and let n  be the node with these

edges merged  then ni   n i  
proof  let the two r edges be hr  m   m   g i and hr  m   m   g i 
let d   ni   then there are between m   m   and m   m   elements of the domain  d  
such that hd  d i   ri   therefore there are between the maximum of m  and m  and the
minimum of m  and m  elements of the domain  d   such that hd  d i   ri   also  all d  such
that hd  d i   ri are in gi   gi     therefore  all d  such that hd  d i   ri are in gi    gi   
which equals  g   g  i by lemma    thus d   n i  
let d   n i   then there are between the maximum of m  and m  and the minimum of
m  and m  elements of the domain  d    such that hd  d i   ri   therefore there are between
m   m   and m   m   elements of the domain  d   such that hd  d i   ri   also  all d  such
that hd  d i   ri are in  g   g   i   gi    gi    therefore  all d  such that hd  d i   ri are
in gi   gi     therefore d   ni  

having dealt with the issue of merging  we can now return to our desired result  showing
that  normalization  does not affect the meaning of description graphs 

theorem   for all possible worlds i   the extension of the canonical form of a description

graph  g  resulting from a basic classic description is the same as the extension of the
description 
proof  steps   and   are justified since gi is a subset of either h or c   which are
disjoint 
step   is justified by the fact that  by the definition of description graphs  there must
be an element of the domain in the extension of each node in a description graph 
steps       and   are easily derived from definition   
steps   and   are dealt with in the preceding two lemmas 
   

fisubsumption in classic

    subsumption algorithm
the final part of the subsumption process is checking to see if a canonical description graph
is subsumed by a description  it turns out that it is possible to carry out the subsumption
test without the expense of normalizing the candidate subsumer concept 

algorithm    subsumption algorithm  given a description d and description graph
g   hn  e  ri  subsumes  d  g  is defined to be true if and only if any of the following

conditions hold 

   the description graph g is marked incoherent 
   d is equivalent to thing   this is determined by checking first if d thing  or by
recursively testing whether d subsumes the canonical description graph gthing   
   d is a concept name and is an element of the atoms of r 
   d is n r and some r edge of r has r as its role and min greater than or equal to n 
   d is n r and some r edge of r has r as its role and max less than or equal to n 
   d is  r c and some r edge of r has r as its role and g  as its restriction graph and
subsumes  c  g   
   d is  r c and subsumes  c  gthing  and r has classic thing in its atoms   reason   r thing only requires the possibility that r be applicable to an object  which is absent
for host values  
   d is  a c and some a edge of g is of the form hr  r   ai  and subsumes  c  hn  e  r i  
   d is  a c and subsumes  c  gthing  and r has classic thing in its atoms 
    d is a         an   b         bm and the paths a           an and b           bm exist in g
starting from r and end at the same node 
    d is a         an   b         bm with an the same as bm and the paths a           an  
and b           bm   exist in g starting from r and end at the same node  which has
classic thing in its atoms   reason  if aii   a  i        bj i   b  i      then
   

d

   

d

fi  aii        a i  d      fi  bj i        b  i  d   

for any attribute f  as long as the attribute is applicable  i e   the value is not in the host
domain   

    d is c u e and both subsumes  c  g  and subsumes  e  g  are true 
   

fiborgida   patel schneider

    correctness of subsumption algorithm

the soundness of this algorithm is fairly obvious  so we shall not dwell on it  the completeness of the algorithm is  as usual  more dicult to establish  first we have to show that
for any canonical description graph or node that is not marked as incoherent  a possible
world having a non empty extension for the description graph or node can be constructed 
we will do this in a constructive  inductive manner  constructing a collection of such possible worlds  called the graphical worlds of a description graph  a graphical world has a
distinguished domain element that is in the extension of the description graph or node 
a common operation is to merge two possible worlds 
definition   let i  and i  be two possible worlds  the merge of i  and i   i   i   is
a possible world with classic realm the disjoint union of the classic realm of i  and the
classic realm of i    the extension of atomic names in i   i  is the disjoint union of their
extensions in i  and i   
it is easy to show that the extension of a description  a description graph  or a node in
i   i  is the union  disjoint union for the classic realm  regular union for the host realm 
of its extensions in i  and i   
another operation is to add new domain elements to a possible world  these new domain
elements must be in the classic realm  the extension of all atomic identifiers remain the
same except that the new domain elements belong to some arbitrary set of atomic concept
names and have some arbitrary set of fillers  filler  for each role  attribute   again  it is
easy to show that a domain element of the original world is in an extension in the original
world iff it is in the extension in the augmented world 
given a node  n  that is not marked as incoherent  we construct the graphical worlds
for n as follows 
   if the atoms of n are precisely thing  then n can have no r edges  because the only
constructs that cause r edges to be created also add classic thing to the atoms 
any possible world  with any domain element the distinguished domain element  is a
graphical world for n 
   if the atoms of n include host thing  then n can have no r edges  any possible
world  with distinguished element any domain element in the extension of all the
atoms of n and in no other host concepts  is a graphical world for n   because of
the requirements on the host domain  there are an infinite number of these domain
elements  
   if the atoms of n include classic thing  then for each r edge  hr  m  m  gi  in n 
construct between m and m graphical worlds for g  this can be done for any number
between m and m because if m     then g is not marked incoherent  and if g is
marked incoherent then m     
no two of these graphical worlds should have the same host domain element as their
distinguished element   again  this is possible because the extension of a host concept
is either empty or infinite   now merge all the graphical worlds for each r edge into
one possible world  add some new domain elements such that one of them is in exactly
   

fisubsumption in classic

the extensions of the atoms of n and has as fillers for each r exactly the distinguished
elements of the appropriate graphical worlds  this domain element will have the
correct number of fillers for each r edge  because of the disjoint union of the classic
realms in the merge process and because of the different host domain elements picked
above  therefore it is in the extension of n  thus the resulting world is a graphical
world for n 
given a description graph  g   hn  e  ri  that is not marked incoherent  we construct
the graphical worlds for g as follows  for each node n   n construct a graphical world for
n  this can be done because none of them are marked incoherent  merge these graphical
worlds  modify the resulting world so that for each hn    n   ai   e the a filler for the
distinguished node of the graphical world from n  is the distinguished node of the graphical
world from n    it is easy to show that the distinguished node of the graphical world of r is
in the extension of g  making this a graphical world for g 
now we can show the final part of the result 

theorem   if the subsumption algorithm indicates that the canonical description of some
graph g is not subsumed by the basic classic description d  then for some possible world
there is a domain element in the extension of the graph but not in the extension of d 
therefore g is not subsumed by d 
proof  the proof actually shows that if the subsumption algorithm indicates that some
canonical description graph  g  is not subsumed by some description  d  then there are
some graphical worlds for g such that their distinguished domain elements are not in the
extension of d  remember that the subsumption algorithm indicates that g is not subsumed
by d  so g must not be marked as incoherent and thus there are graphical worlds for g 
the proof proceeds by structural induction on d  let g   hn  e  ri 
 if d is an atomic concept name or a pre defined host concept  then d does not occur
in the atoms of r  by construction  in any graphical world for g the distinguished
domain element will not be in the extension of d  similarly  if d is classic thing
or host thing  then the distinguished domain elements will be in the wrong realm 
if d is thing  then it is not possible for the subsumption algorithm to indicate a
non subsumption  in each case any graphical world for g has the property that its
distinguished domain element is not in the extension of d 

 if d is of the form d  u d  then the subsumption algorithm must indicate that g

is not subsumed by at least one of d  or d    by the inductive hypothesis  we get
some graphical worlds of g where the distinguished domain elements are not in the
extension of d  or not in the extension of d   and thus are not in the extension of d 

 if d is the form n r then either the r edge from r labelled with r has min less than
n or there is no such r edge 
in the former case there are graphical worlds for g in which the distinguished node
has n     fillers for r  because n is greater than the min on the r edge for r  and thus
the distinguished node is not in the extension of d 
   

fiborgida   patel schneider

in the latter case  there are graphical worlds for g in which its distinguished node
has any number of fillers for r  those with n     fillers have the property that their
distinguished node is not in the extension of d 

 if d is of the form n r then either the r edge from r labelled with r has max greater
than n  including    or there is no such r edge 
in the former case there are graphical worlds for g in which the distinguished node
has n     fillers for r  because n is less than the max on the r edge for r  and thus
the distinguished node is not in the extension of d 
in the latter case  there are graphical worlds for g in which its distinguished node
has any number of fillers for r  those with n     fillers have the property that their
distinguished node is not in the extension of d 

 if d is of the form  r c  where r is a role  then two cases arise 
   if subsumes  c  gthing  then classic thing is not in the atoms of r  then
there are some graphical worlds for g whose distinguished element is in the host

realm  and thus not in the extension of d 
   otherwise  either there is an r edge from r with role r and description graph h
such that subsumes  c  h   is false or there is no r edge from r with role r  note
that the extension of c is not the entire domain  and thus must be a subset of
either the host realm or the classic realm 
in the former case h is not marked incoherent  or else the subsumption could
not be false  and the max on the r edge cannot be    thus there are graphical
worlds for h whose distinguished element is not in the extension of c and there
are graphical worlds for g that use these graphical worlds for h as distinguished
domain element r fillers  in these graphical worlds for g the distinguished element is not in the extension of d 
in the latter case  pick graphical worlds for g that have some distinguished node
r filler in the wrong realm  in these graphical worlds for g the distinguished
element is not in the extension of d 

 if d is of the form  a c where a is an attribute then two cases arise 
   if subsumes  c  gthing  then classic thing is not in the atoms of r  then
there are some graphical worlds for g whose distinguished element is in the host
realm  and thus not in the extension of d 
   otherwise  either there is an a edge from r with attribute a to some other node
r  such that subsumes  c  h   is false  where h   hn  e  r i  or there is no a edge
from r with attribute a  note that the extension of c is not the entire domain 
and thus must be a subset of either the host realm or the classic realm 
in the former case h is not marked incoherent  because g is not marked incoherent  thus there are graphical worlds for h whose distinguished element is
not in the extension of c  given any graphical world for h   a graphical world
for g can be formed simply by changing the distinguished domain element  if
   

fisubsumption in classic

the original graphical world s distinguished element is not in the extension of c 
then the new graphical world s distinguished element will not be in the extension
of d  as required 
in the latter case  pick graphical worlds for g that have their distinguished node
a filler in the wrong realm  in these graphical worlds for g the distinguished
element is not in the extension of d 
 if d is of the form a        an   b         bm several cases again arise 
   if one of the paths a           an   or b           bm   does not exist in g starting
from r  then find the end of the partial path and use graphical worlds in which
the domain element for this node has an element of the host domain as its filler
for the next attribute in the path  then one of the full paths will have no filler 
   if the paths a           an and b           bm exist in g starting from r but end at
different nodes  then use graphical worlds in which the domain elements for
these two nodes are different 
   if one of the paths a           an and b           bm does not exist in g starting from
r but the paths a           an   and b          bm   both exist in g starting from r
and end at the same node then either classic thing is not in the atoms of this
node or an    bm  in the former case use graphical worlds in which the domain
element for this node is in the host realm  in the latter case use graphical worlds
that have different fillers for an and bm for the domain element for this node 
   if one of the paths a           an and b           bm does not exist in g starting from
r but the paths a           an   and b          bm   both exist in g starting from r
and end at different nodes then use graphical worlds that have different fillers
for the domain elements of these nodes or that have the domain elements in the
host realm 
in all cases we have that either one of an i        a  i   d  or bmi        b  i   d  does not
exist or an i        a  i   d     bmi        b  i   d   so the distinguished domain element is
not in the extension of d 

    implementing the subsumption algorithm

in this section we provide some further comments about the actual subsumption algorithm
used by the classic system  including a rough analysis of its complexity 
as we have described it  deciding whether description c subsumes d is accomplished in
three phases 
   convert d into a description graph gd  
   normalize gd  
   verify whether c subsumes gd  
step    conversion is accomplished by a simple recursive descent parser  which takes
advantage of the fact that the syntax of description logics  i e   the leading term constructor  makes them amenable to predictive parsing  clearly  constructing graphs for fixed sized
   

fiborgida   patel schneider

terms  like at least  is constant time  if we measure size so that an integer is size   no matter how large   while the time for non recursive terms  like same as  is proportional to their
length  finally  recursive terms  like all  and  only require a fixed amount of additional
work  on top of the recursive processing  therefore  the first stage can be accomplished in
time proportional to the size of the input description  in order to speed up later processing 
it will be useful to maintain various lists  such as the lists of atomic concept identifiers 
or roles attributes  in sorted order  this sorting needs to be done initially  later  ordering
will be maintained by performing list merges  and this incurs  in the worst case a quadratic
overhead in processing    in any case  the total size of the graph constructed  including the
sizes of the nodes  etc   is proportional to the size of the original concept description 
step    checking whether a description c subsumes a description graph gd   can be
seen to run in time proportional to the size of the subsuming concept  modulo the cost
of lookups in various lists  since these are sorted  the lookup costs are bounded by the
logarithm of the size of the candidate subsumee graph  so the total cost is bounded by
o j c j  log j gd j  
step    normalization is accomplished by a post order traversal of the description
graph  in processing a description graph hn  e  ri  each node in n is normalized first independently  see details below   and afterwards the attribute edges e are normalized  this
later task involves identifying multiple identically labelled attribute edges leaving a node
 this is done in one pass since the attribute edges are grouped by source node  and sorted
by attribute name   and  merging  them  merging two edges is quite easy in and of itself  but when merging the nodes at their tips  we must be careful because node mergers
may cascade  for example  if a concept has the form a    b  u a    b  u       u an   bn u
a    a  u a    a  u       u an     an then the original graph will have  n     nodes  but  n
of these are collapsed by normalization step    to discover this eciently  we use a version
of a kaci s algorithm for unifying   terms  at kaci        at kaci   nasr         the
algorithm relies on the union find technique to identify nodes to be merged  and runs
in time just slightly more than linear in the number of nodes in n   therefore the cost of
the non recursive portion of graph normalization is roughly linear in the number of nodes
in it 
the merging of two description graph nodes is quite similar to the normalization of
a single node  the atomic concept identifier lists need to sorted merged  with duplicates
eliminated on the y  this can be done in time proportional to the size of the nodes
themselves  if we make the size of the node include the size of the various lists in it  such as
atoms  the processing of role edges leaving a node is  again  one of identifying and merging
identically labelled edges   but in this case the mergers of labelled edges do not interact  so
a single pass over the role edge list is sucient   the cost of non recursive aspects of any
such merger is once again proportional to the size of the local information 
we are therefore left with the problem of bounding the total number of procedure calls
to normalizegraph  normalizenode  mergeedge  and mergenode  and then bounding the
sizes of the nodes being merged 
normalizegraph and normalizenode are called exactly once on every  sub graph and
node in the original graph  as part of the depth first traversal  and as argued above  on
   we tend not to use fancy sorting techniques since these lists are not likely to be very long 

   

fisubsumption in classic

their own they contribute at most time proportional to the total size of the original graph 
which was proportional to the size of the original description 
the number of calls to mergeedge and mergenode is not so simply bounded however  
the same node may be merged several times with others  however  these calls are paired 
and each invocation of mergenode reduces the number of nodes in the graph by one  therefore  since the number of nodes is not incremented elsewhere  the total number of calls to
mergeedge and mergenode is bounded by the number of nodes in the original graph  the
only problem is that the non recursive cost of a call to mergenode depends on the size of
the argument nodes  and each call may increase the size of the remaining node to be the
sum of the sizes of the two original nodes 
therefore  if the original concept had size s  with the graph having n nodes  each of size
vi  then the worst case cost would result from the iterative summation of sizes 
 vi    vi       vi    vi    vi       vi    vi    vi    vi           
  n  vi     n       vi               vi
n

given that n and all vj are bounded
by s   clearly the above is in the worst case o s    
p
in fact  given the constraint that j    nvj   s   it is possible to argue that the worst case
cost will occur when vj     for every j   i e   when n   s    in which case the cost is really
just o s    
there are other theoretical improvements that could be attempted for the algorithm
 e g   merging nodes in the correct order of increasing size  as well as its analysis  e g   only
nodes in graphs at the same depth in the tree can be merged  
we remark that like all other description logics  classic permits identifiers to be associated with complex descriptions and then these identifiers can be used in other descriptions
 though no recursion is allowed   the expansion of identifiers is a standard operation which
can lead to exponential growth in size in certain pathological cases  nebel         making
the subsumption problem inherently intractable  as with the type system of the programming language standard ml  such pathological cases are not encountered in practice  and
the correct algorithm is simple  straightforward and ecient in normal cases  unlike the
correct algorithm for reasoning with the set constructor  say  
because users rarely ask only whether some concept subsumes another  but rather are
interested in the relationship between pairs of concepts  classic in fact constructs the
normalized description graph of any description given to it  this suggests that it might be
better to check whether one description graph subsumes another one  rather than checking
whether a description subsumes a graph  in general  this works quite well  except that we
would have to verify that the attribute edges in the subsumer graph form a subgraph of the
subsumee s attribute edges  since edges are uniquely labelled after normalization  this is not
inherently hard  but it still requires a complete traversal  and hence marking unmarking 
of the upper graph  we have therefore found it useful to encode as part of the description
graph s root the same as restrictions that lead to the construction of the corresponding aedges  then  during subsumption testing  the only aspect of the subsumer related to same as
which is checked is this list of same as pairs 
also  the above description of the algorithm has tried to optimize the cost of normalization  which dominates when checking a single subsumption  if in the overall use of a
   

fiborgida   patel schneider

system  e g   processing individuals   inquiries about the restrictions on roles attributes are
frequent  and space usage is not a problem  then it may be practically advantageous to
maintain the r edges and a edges of a node in a hash table  rather than a sorted list  in
order to speed up access   note that for merging r edges  one must however still have some
way of iterating through all the values stored in the hash table  

   individuals in descriptions

in practical applications where dls have been used  such as integrity constraint checking  it
is often very useful to be able to specify ranges of atomic values for roles  the most common
examples of this involve integers  e g    the year of a student can be       or     or what are
called enumerated types in pascal  e g    the gender of a person is either m or f   one way
to allow such constraints is to introduce a new description constructor  a set description 
which creates a description from a list of individual names  and whose obvious extension is
the set consisting of the extensions of the individuals that appear in the list  this construct
could be used in terms like  year f       g  another useful constructor involving individuals
is a fills restriction  p   i  which denotes objects that have the extension of the individual i
as one of the fillers for the relationship denoted by role or attribute p   note that for an
attribute  q   q fig is the same as q   i  
within the paradigm of dls  these constructors are quite useful and can in fact be used
to express new forms of incomplete information  for example  if we only know that ringo
is in his early fifties  we can simply assert that ringo is described by  age f              g 
the constructors can also be used to ask very useful queries  for example  to find all the
male persons it suces to determine the instances of gender   m 
the new constructors do interact with previous ones  such as cardinality constraints 
clearly the size of a set is an upper cardinality bound for any role it restricts  this interaction
is not problematic as long as the individuals in the set are host values  since such individuals
have properties that are fixed and known ahead of time  however  once we allow classic
individuals as members of sets  then the properties of these individuals might themselves
affect subsumption  as a simple example  if we know that ringo is an instance of the
concept rock singer  which we shall write as ringo   rock singer   then the extension
of  friends rock singer is always a superset of the extension of  friends fringog 
this is disturbing because then the classification hierarchy of definitions would change as
new facts about individuals are added to the knowledge base  definitions are not meant to
be contingent of facts about the current world  therefore  subsumption is usually defined to
be independent of these  contingent  assertions  as we shall see below  the use of individual
properties in description subsumption also leads to intractability 

    complex subsumption reasoning  an example

traditional proofs of intractability  e g   levesque   brachman         have occasionally
left users of dls puzzled over the intuitive aspects of a language which make reasoning
dicult  for this reason we present an example that illustrates the complexity of reasoning
with the set description 
suppose that we have the concept of jaded person as being one who wants only to
visit the arctic and or the antarctic  wherever there are penguins 
   

fisubsumption in classic

jaded person     wantstovisit  farctic antarcticg u  haspenguins   fyesg 

suppose we do not remember which is the arctic and which the antarctic  but we do know
that the south pole is located in one of these two places  and that there are penguins there 
while the north pole is located in one of these two places  and there are no penguins there 
assuming that islocatedin  and haspenguins  are attributes roles with exactly one filler 
we can record
southpole    islocatedin   farctic antarcticg u  haspenguins   fyesg 
northpole    islocatedin   farctic antarcticg u  haspenguins   fnog 

we are thus unable to distinguish the exact location of the southpole and northpole  however 
since haspenguins  has a single filler  exactly one of arctic and antarctic can  and in fact
must  have yes as filler for haspenguins   and therefore exactly one of them is the location
of southpole  
as a result of these facts  we know that the extension of jaded person must be a
subset of the extension of   wantstovisit in any database containing the above facts about
southpole and northpole 
observe that we have here not just an occasional worse case behavior  but a generalized
diculty in reasoning with set descriptions  because subsumption ignores assertions about
individuals  this does not  yet  show that subsumption per se must perform these inferences 
a simple transformation  given in the appendix  establishes this fact  by converting the
recognition of individuals into a question about the subsumption of two descriptions by
making all the individuals involved attribute fillers for new dummy attributes  and their
descriptions as restrictions on these attributes  as a result  if the description is non empty
then these attribute values must satisfy the corresponding restrictions 

    a modified semantics for individuals

we have seen two problems with individuals appearing in descriptions      the effect of
 mutable facts  on extensional relationships between  immutable  descriptions  and    
the computational intractability of subsumption caused by the appearance of individuals in
descriptions 
to deal with the first problem  it is reasonable to restrict the computation of subsumption so that it cannot access  database facts  about individuals  such as their role fillers  so
that all individuals are treated like host identifiers  this is a procedural description of some
aspect of reasoning  in the same sense as negation by failure is in prolog  as with prolog 
it would be desirable to find a semantic account of this phenomenon 
a semantics that ignores mutable facts when determining subsumption is not hard to
devise all that is required is to have two different sets of possible worlds corresponding
to a kb containing both concepts and individuals  one set consists of all possible worlds
that model all the information in the kb  the second consists of all possible worlds that
model only the information about concepts  and roles and attributes   when asking questions about individuals  the first set of possible worlds must be considered  when asking
subsumption questions  the second  larger  set must be considered  thus ignoring any effects
of the mutable facts 
   

fiborgida   patel schneider

however  this semantics does not solve the computational problem with individuals
in descriptions  to deal with this problem  the semantics of individuals are modified as
follows  instead of mapping individuals into separate elements of the domain  as is done in
a standard semantics  individuals are mapped into disjoint subsets of the domain  intuitively
representing different possible realizations of that  platonic  individual 
therefore  the semantics of the set constructor is now stated as follows  domain value
d belongs to the extension of fb        bn g iff d belongs to the extension of one of the bi  
an associated change in the notion of cardinality is required two elements of the domain
are considered congruent if they belong to the extension of the same individual or if they
are identical  the cardinality of a set of elements of the domain is then the size of the set
modulo this congruence relationship  this means that occurrences of different identifiers in
description s  are guaranteed to be unequal  but distinct occurrences of the same individual
identifier are not guaranteed to denote the same individual 
here are two consequences of this stance 
   looking at the descriptions of southpole and northpole in section      the distinct
occurrences of arctic might be satisfied by distinct domain elements  with different role
fillers   in greater detail  the extension of arctic might include domain elements d  and
d   with d  satisfying condition haspenguins    yes  while d  satisfies haspenguins    no 
if southpole is then located in d   while northpole is located in d    then we still have
both satisfying islocatedin    arctic  similarly for domain elements d  and d  in the
extension of antarctic  therefore one could have two places to visit where there are
penguins  d  and d   
   even though an individual may have a description that includes
islocatedin    arctic u originatesin    arctic 
it need not satisfy the condition islocatedin    originatesin   since the equality restriction requires identity of domain values 

   adding individuals to classic

individuals can occur in both classic and host descriptions  the following constructs create
classic descriptions 
r i
a i
fi        ing
where a is an attribute  r is a role  i is the name of a classic individual or a host value 
collectively called individuals  and ij are names of classic individuals  new host descriptions
can be constructed using fi        in g  where the ij are host values 
the interpretation function  i is extended to individual identifiers  by requiring that ii
be a non empty subset of c   if i is syntactically not recognized to be a host individual  and
making ii   fig for host values i  as stated earlier  the interpretations of distinct identifiers
must be non overlapping 
the interpretation ci of non atomic descriptions is modified as follows 
   

fisubsumption in classic

 p   ii   fd   c j  x  d  x    pi   x   ii g
 fi        ingi   sk iik if the ik are all classic individuals  fi        ingi   fi        in g if ik
are all host individuals  empty otherwise 

  n p i  resp   n p i   is those objects in c with at least  resp  at most  n noncongruent fillers for role p

the development of the subsumption algorithm in section   is then modified to take
into account the added constructs with the modified semantics introduced earlier 
first description graphs are extended  a node of a description graph is given a third
field  which is either a finite set of individuals or a special marker denoting the  universal 
set  this field is often called the dom of the node  both a edges and r edges are given an
extra field  called the fillers of the edge  this field is a finite set of individuals  where
unspecified  as in constructions in previous sections  the dom of a node is the universal set
and the fillers of an a edge or an r edge is the empty set 
the semantics of description graphs in definition   are extended to the following 

definition   let g   hn  e  ri be a description graph and let i be a possible world 

an element  d  of  is in gi   iff there is some function    from n into  such that

   d    r  
   for all n   n  n    ni  
   for all hn    n   a  f i   e we have h n      n  i   ai   and for all f   f    n      f i  
an element  d  of  is in ni   where n   hc  h  s i  iff
   for all c   c   we have d   ci  
   for all hr  m  m  g  f i   h  
 a 
 b 
 c 

there are between m and m elements  d   of the domain such that hd  d i   ri  
d    gi for all d  such that hd  d i   ri   and
for all f   f there is a domain element  d    such that hd  d i   ri and d    f i

   if the s is not the universal set then  f   s such that d   f i  

when merging nodes  the dom sets are intersected  merging description graphs is unchanged  when merging a edges and r edges  the sets of fillers are unioned 
the translation of descriptions into description graphs is extended by the following rules 
   a description of the form r   i is turned into a description graph with one node and
no a edges  the node has as its atoms classic thing and a single r edge with role
r  min    max    and fillers fig  the description graph restricting this r edge is
gclassic thing if i is a classic individual  and ghost thing otherwise 
   

fiborgida   patel schneider

   a description of the form a   i is turned into a description graph with two nodes with
a single a edge between them  the distinguished node of the graph is the source of
the a edge  it has no r edges and has as atoms classic thing  the other node
also has no r edges  it has as atoms classic thing if i is a classic individual  and
host thing otherwise  the a edge has as its single filler i 
    a description of the form fi        in g is turned into a description graph with one node 
the node has as dom the set containing i  through in   and no r edges  the atoms of
the node is host thing if all of the individuals are host values  and classic thing
if all of the individuals are classic individual names   note that the parser ensures
that individuals either must all be host values or must all be classic individual names  
a short examination shows that theorem   is true for these graphs  i e   the extension of
description graphs formed using these rules is the same as the extension of the description
from which they were formed 
the following transformations are added to the canonicalization algorithm 
   if the dom of a node is empty  mark the node incoherent 
    if a host value in the dom of a node is not in all the atoms of the node  remove it from
the dom 
    if an a edge has more than one filler  then mark the description graph as incoherent 
    if an a edge has a filler and the node at its end has the universal dom  make the dom
be the filler 
    if the filler of an a edge is not included in the dom of the node at its end  mark the
description graph as incoherent 
    if a node has only one element in its dom  make this element be the filler for all the
a edges pointing to it 
    if the fillers of some r edge are not a subset of the dom of the distinguished node of
the restriction graph of the edge  mark the node of the r edge incoherent 
    if the min on an r edge is less than the cardinality of fillers on it  let the min be this
cardinality 
    if the max on an r edge is greater than the cardinality of the dom on the distinguished node of the description graph of the r edge  make the max of this edge be the
cardinality of the dom 
    if the min on an r edge is greater than or equal to the cardinality of the dom on the
distinguished node of the restriction graph of the r edge  let the fillers of the edge be
the union of its fillers and the dom above   if min is greater than the cardinality  then
steps   and    detect the inconsistency  
   

fisubsumption in classic

    if the max on an edge is equal to the cardinality of fillers on the edge  let the dom
on the distinguished node of the description graph of the r edge be the intersection of
the dom and the fillers   if max is less than the cardinality  steps    and   detect the
inconsistency  
note that in the new canonical form all a edges pointing to a single node have the same
value for their fillers  and that if this is not the empty set  then the node has this set as the
value for its dom 
the proofs of lemmas   and   also work for this extension of description graphs  the
proof of theorem   can then be extended for these graphs 
the subsumption algorithm from page     is extended as follows 
    d is r   i and some r edge of r has role r and fillers including i 
    d is a   i and some a edge from r has attribute a and fillers including i 
    d is fi        in g and the dom of r is a subset of fi        in g 
again  the soundness of the extended algorithm is fairly obvious  the completeness
proof has the following additions to the construction of graphical worlds 

 the extension of classic individual names starts out empty 
 when constructing graphical worlds for a node that includes host thing in its
atoms and has a non universal dom  pick only those domain elements corresponding
to the elements of its dom 

 when constructing graphical worlds for a node that includes classic thing in its
atoms and has a non universal dom  add the distinguished domain element to the
extension of one of its dom elements 

 when constructing graphical worlds for the r edges of a node  ensure that each element

of the fillers of the r edge has the distinguished element of at least one of the graphical
worlds in its extension by either adding them to the extension or using appropriate
host domain elements   this can be done because the fillers must be a subset of the
dom of the distinguished node of the graphical world and any host values must belong
to its atoms  

the fillers for a edges need not be considered here because they are  pushed  onto the nodes
in the canonicalization process 
the proof of theorem   is then extended with the following cases 

 if d is of the form fi        ing then the dom of r is not a subset of fi          ing  thus
there are graphical worlds for g in which the distinguished domain element is not in
the extension of any of the ij 

 if d if of the form a   i then either the a edge from r labelled with a does not have
filler i or there is no such a edge 

   

fiborgida   patel schneider

in the former case the node pointed to by the a edge cannot have as its domain the
singleton consisting of i  therefore there are graphical worlds for g that have their
distinguished node a filler not in the extension of i  as required 
in the latter case  pick graphical worlds for g that have their distinguished node afiller in the wrong realm  in these graphical worlds for g the distinguished element is
not in the extension of d 

 if d is of the form r   i then either the r edge from r labelled with r does not have
filler i or there is no such r edge 
in the former case either the cardinality of the dom of the distinguished node of the
description graph of this r edge is greater than the min  m  of the r edge  or the dom
does not include i  if the dom does not include i  then all graphical worlds for the
node have their distinguished element not in the extension of i  as required  if the
dom does include i  then there are at least m elements of the dom besides i  and the
fillers of the r edge are a subset of the set of these elements  there are thus graphical
worlds for g that use only these elements  as required 
in the latter case  pick graphical worlds for g that have some distinguished node rfiller in the wrong realm  in these graphical worlds for g the distinguished element is
not in the extension of d 

this shows that the subsumption algorithm given here is sound and complete for the
modified semantics presented here 

   complete classic

we now make a final pass to deal with some less problematic aspects of classic descriptions
that have not been appropriately covered so far 
classic allows primitive descriptions of the form  primitive d t   where d is a
description  and t is a symbol  the extension of this is some arbitrary subset of the
extension of d  but is the same as the extension of  primitive e t   provided that d
and e subsume each other  in this way one can express employee  a kind of a person
who must have an employee number  as
 primitive  person u   employeenr  employee 
this construct can be removed by creating for every such primitive an atomic concept  e g  
employeehood  and then replacing the definition of the concept by the conjunction
of the necessary conditions and this atom  in this case employeehood u  person u
  employeenr   care has to be taken to use the same atomic concept for equivalent primitives 
classic permits the declaration of disjoint primitives  essentially allowing one to state
that the extensions of various atomic concepts must be disjoint in all possible worlds  to
deal with such declarations  we need only modify the algorithm for creating canonical graphs
by adding a step that marks a node as incoherent whenever its atoms contains two identifiers
that have been declared to be disjoint 
   

fisubsumption in classic

to allow an approximate representation for ideas that cannot be encoded using the
constructors expressly provided  classic allows the use of test defined concepts  using the
following syntax 
 test  host language boolean function  
e g    test prime number testing function    for the purposes of subsumption  these are
treated as  black boxes   with semantics assigned as for atomic concepts   test concepts
have a real effect on reasoning at the level of individuals  where they can perform constraint
checking  
with these simple additions  the above algorithm is a sound and complete subsumption
algorithm for descriptions in classic    under the modified semantics introduced in this
paper 

   summary  related work  and conclusions
we believe this paper makes two kinds of contributions  first  the paper presents an abstracted form of the subsumption algorithm for the classic description logic  and shows
that it is ecient and correct under the modified semantics  this is significant because
previous claims of correct and ecient subsumption algorithms in implemented dls such
as kandor  patel schneider        and candide  beck et al         have turned out to be
unfounded  nebel        
a tractability proof for a language like basic classic is claimed to exist  but is not
proven  in  donini et al          and an alternate proof technique may be found by considering a restriction of the  corrected  subsumption algorithm in  hollunder   nutt        
description graphs have also turned out to be of interest because they support further
theoretical results about dls  concerning their learnability  cohen   hirsh        pitt  
frazier        results which would seem harder to obtain using the standard notation for
dls 
second  this paper investigates the effect of allowing individuals to appear in descriptions of dls  as independently demonstrated in  lenzerini   schaerf         adding a
set description introduces yet another source of intractability  and we have provided an
intuitive example illustrating the source of diculties  the implementers of the classic
system  like others who do not use refutation tableaux theorem proving techniques  chose
not to perform all inferences validated by a standard semantics  not just because of the
formal intractability result but because no obvious algorithm was apparent  short of enumerating all possible ways of filling roles  the subset of inferences actually performed was
initially described procedurally   facts  about individuals were not taken into account in
the subsumption algorithm  this paper provides a denotational semantic account for this
incomplete set of inferences  the formal proof of this being a correct account is a corollary
of the completeness proof for the subsumption algorithm in section    and the observation
that the graph construction and subsumption algorithms in that section do indeed ignore
   in order to deal with the two realms  classic in fact provides two constructors  h test and ctest  for host and classic descriptions  but this does not cause any added complications besides
keeping track of the correct realm 

   

fiborgida   patel schneider

the properties of the individuals involved  the one difference between the original implementation of classic and the current semantics is that attribute paths ending with the
same filler were used to imply an equality condition  as noted in section      the modified
semantics does not support this inference  and it was taken out of the implementation of
classic  it is significant that the change to the standard semantics is small  easy to explain
to users  either procedurally or semantically   and only affects the desired aspects of the
language  i e   all reasoning with basic classic remains exactly as before  

acknowledgments

we wish to thank ronald brachman and our other colleagues in the classic project for
their collaboration  and the jair referees for their excellent suggestions for improving the
paper  in particular  one of the referees deserves a medal for the thoroughness and care
taken in locating weaknesses in our arguments  and we are most thankful  any remaining
errors are of course our own responsibility 

references

at kaci  h          a lattice theoretic approach to computation based on a calculus of
partially ordered type structures  ph d  thesis  university of pennsylvania 
at kaci  h     nasr  r          login  a logic programming language with built in
inheritance  journal of logic programming             
american association for artificial intelligence         issues in description logics  users
meet developers  working notes of the aaai      fall symposium 
baader  f   burckert  h  j   heinsohn  j   hollunder  b   muller  j   nebel  b   nutt  w  
  profitlich  h  j          terminological knowledge representation  a proposal for a
terminological logic  german research center for artificial intelligence  dfki  
baader  f     hanschke  p          a scheme for integrating concrete domains into concept
languages  in proceedings of the twelfth international joint conference on artificial
intelligence  pp           international joint committee on artificial intelligence  a
long version appears as research report rr       from the german research center
for artificial intelligence  dfki   april      
baader  f     hollunder  b          kris  knowledge representation and inference system 
sigart bulletin              
beck  h  w   gala  s  k     navathe  s  b          classification as a query processing
technique in the candide semantic data model  in proceedings of the fifth international data engineering conference  pp           institute of electric and electronic
engineers 
borgida  a   brachman  r  j   mcguinness  d  l     resnick  l  a          classic  a
structural data model for objects  in proceedings of the      acm sigmod international conference on mangement of data  pp         association for computing
machinery 
   

fisubsumption in classic

borgida  a          from type systems to knowledge representation  natural semantics
specifications for description logics  international journal of intelligent and cooperative information systems                
brachman  r  j   fikes  r  e     levesque  h  j          krypton  a functional approach
to knowledge representation  ieee computer                 
cohen  w  w     hirsh  h   forthcoming   learnability of description logics with equality
constraints  machine learning  a preliminary version appears in the proceedings of
the fourth annual workshop on computational learning theory 
devanbu  p   brachman  r  j   ballard  b     selfridge  p  g          lassie  a knowledgebased software information system  communications of the acm                
donini  f  m   lenzerini  m   nardi  d     nutt  w          tractable concept languages 
in proceedings of the twelfth international joint conference on artificial intelligence 
pp           international joint committee on artificial intelligence 
doyle  j     patil  r          two theses of knowledge representation  language restrictions  taxonomic classification  and the utility of representation services  artificial
intelligence                  
pitt  l     frazier  m          classic learning  in proceedings of the seventh annual acm
conference on computational learning theory new brunswick  nj  acm press 
heinsohn  j   kudenko  d   nebel  b     profitlich  h  j          an empirical analysis of terminological representation systems  in proceedings of the tenth national
conference on artificial intelligence  pp           american association for artificial
intelligence 
hollunder  b     nutt  w          subsumption algorithms for concept languages  research
report rr        german research center for artificial intelligence  dfki  
lenzerini  m     schaerf  a          concept languages and query languages  in proceedings
of the ninth national conference on artificial intelligence  pp           american
association for artificial intelligence 
levesque  h  j     brachman  r  j          expressiveness and tractability in knowledge
representation and reasoning  computational intelligence               
macgregor  r  m     bates  r          the loom knowledge representation language  tech 
rep  isi rs         information sciences institute  university of southern california 
mays  e   apte  c   griesmer  j     kastner  j          organizing knowledge in a complex
financial domain  ieee expert           
nebel  b          computational complexity of terminological reasoning in back  artificial
intelligence                  
nebel  b          terminological reasoning is inherently intractable  artificial intelligence 
                
   

fiborgida   patel schneider

nebel  b   peltason  c     von luck  k   eds            international workshop on terminological logics  document d        german research center for artificial intelligence
 dfki  
owsnicki klewe  b          configuration as a consistency maintenance task  in hoeppner  w   ed    proceedings of gwai    the   th german workshop on artificial
intelligence  pp         springer verlag 
patel schneider  p  f          small can be beautiful in knowledge representation  in
proceedings of the ieee workshop on principles of knowledge based systems  pp 
       ieee computer society 
patel schneider  p  f          decidable  logic based knowledge representation  ph d 
thesis  department of computer science  university of toronto 
patel schneider  p  f       a   a four valued semantics for terminological logics  artificial
intelligence                  
patel schneider  p  f       b   undecidability of subsumption in nikl  artificial intelligence                  
peltason  c   von luck  k     kindermann  c   eds            terminological logic users
workshop  fachbereich informatik  technische universitat berlin 
peltason  c   von luck  k   nebel  b     schmiedel  a          the user s guide to the
back system  kit report     fachbereich informatik  technische universitat berlin 
resnick  l  a   borgida  a   brachman  r  j   mcguinness  d  l     patel schneider 
p  f          classic description and reference manual for the common lisp
implementation  ai principles research department  at t bell laboratories 
schmidt schauss  m          subsumption in kl one is undecidable  in proceedings of
the first international conference on principles of knowledge representation and
reasoning  pp           morgan kaufmann 
wright  j  r   weixelbaum  e  s   brown  k   vesonder  g  t   palmer  s  r   berman 
j  i     moore  h  h          a knowledge based configurator that supports sales 
engineering  and manufacturing at at t network systems  in proceedings of the
innovative applications of artificial intelligence conference  pp           american
association for artificial intelligence 

a  intractability of reasoning with one of

we present here a formal proof that subsumption with set descriptions is in fact np hard   
we will show that if a term language allows a set description then it will need to
do  case analysis  in order to check whether the extension of an individual belongs to a
description or not  this is because this constructor behaves like disjunction if its elements can
    our original result was submitted for publication in       a different  independent  proof of the same
result has since been outlined in  lenzerini   schaerf        

   

fisubsumption in classic

be extensions of individuals whose membership in all terms is not known a priori  i e   nonhost individuals  in particular  we will show how to encode the testing of unsatisfiability of a
formula in  cnf as the question of recognizing an individual as an instance of a description 
since this problem is known to be np hard  we have strong indication of its intractability 
start with a formula f   in  cnf  using demorgan s laws  construct formula g  which is
the negation of f   and which is in  dnf  testing the validity of g is equivalent to checking
the unsatisfiability of f  
construct for every propositional symbol p used in f   two individual names p and p   
 here p  will represent the negation of p   each individual will have attribute truthvalue 
with possible fillers true and false
p  p     truthvalue  ftrue falseg 
to make sure that p and p  have exactly one  and opposite  truth values  we create two more
individual names  yesp and nop  with additional attributes approve and deny respectively 
whose fillers need to have truth value true and false respectively 
yesp    approve  fp p  g u  truthvalue  ftrueg 
nop    deny  fp p  g u  truthvalue  ffalseg 
now  given the formula g   c     c             cn  create individual names c   c  
        cn  each with role conjuncts containing the propositions that are its conjuncts  for
example  if c     p    q    r then
c     conjuncts  fp q  r  g u   conjuncts 
finally  construct individual g to have c   c           cn as possible fillers for a new role

disjunctsholding  

g    disjunctsholding  fc  c        cng 

the formula g will then be valid iff there is always at least one disjunct that holds 
this is equivalent to membership in the concept valid formulae defined as

  disjunctsholding u  disjunctsholding   conjuncts   truthvalue ftrueg   
the above shows that recognizing whether individuals are instances of descriptions is
intractable in the presence of set descriptions  minimum number restrictions  and value
restrictions 
we can convert this into a question concerning the subsumption of two descriptions by
essentially making all the individuals involved attribute fillers for new dummy attributes 
and their descriptions as restrictions on these attributes  then if the description is nonempty then these attribute values must satisfy the corresponding restrictions 
so  define concept upper to be

 formula valid formulae
and define concept lower to be
   

fiborgida   patel schneider

 dummy  p  fpg u  p  s concept descriptor    u
 dummy  p  fp g u  p   s concept descriptor    u
 dummy  p  fyespg u        u
 dummy  p  fnopg u        u
   
 dummy  ci  fcig u        u
   
 formula  fgg u       
then in any database state either concept lower has no instances  in which case it is
a subset of the extension of upper  or it has at least one instance  in which case the
individual names filling the various dummy attributes must have the properties ascribed to
them  whence c will be in valid formulae  and hence upper will subsume lower  iff
c is valid  which completes the proof 

   

fi