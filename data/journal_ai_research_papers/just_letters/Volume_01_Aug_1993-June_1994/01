journal artificial intelligence research               

submitted       published     

dynamic backtracking
matthew l  ginsberg

ginsberg cs uoregon edu

cirl  university oregon 
eugene             usa

abstract

occasional need return shallow points search tree  existing
backtracking methods sometimes erase meaningful progress toward solving search
problem  paper  present method backtrack points moved
deeper search space  thereby avoiding diculty  technique developed
variant dependency directed backtracking uses polynomial space still
providing useful control information retaining completeness guarantees provided
earlier approaches 

   introduction
imagine trying solve constraint satisfaction problem  csp 
interests definiteness  suppose csp question involves coloring map
united states subject restriction adjacent states colored differently 
imagine begin coloring states along mississippi  thereby splitting
remaining problem two  begin color states western half
country  coloring perhaps half dozen deciding likely able
color rest  suppose last state colored arizona 
point  change focus eastern half country  all  can t
color eastern half coloring choices states along mississippi 
point wasting time completing coloring western states 
successfully color eastern states return west  unfortunately 
color new mexico utah get stuck  unable color  say  nevada  what s more 
backtracking doesn t help  least sense changing colors new mexico
utah alone allow us proceed farther  depth first search would
us backtrack eastern states  trying new color  say  new york vain hope
would solve problems west 
obviously pointless  blockade along mississippi makes impossible
new york impact attempt color nevada western states 
what s more  likely examine every possible coloring eastern states
addressing problem actually source diculties 
solutions proposed involve finding ways backtrack directly
state might actually allow us make progress  case arizona earlier 
dependency directed backtracking  stallman   sussman        involves direct backtrack
source diculty  backjumping  gaschnig        avoids computational overhead technique using syntactic methods estimate point backtrack
necessary 

c      ai access foundation morgan kaufmann publishers  rights reserved 

figinsberg

cases  however  note although backtrack source problem 
backtrack successful solution half original problem  discarding
solution problem coloring states east  again  problem
worse   recolor arizona  danger solving east yet
realizing new choice arizona needs changed all  won t
examine every possible coloring eastern states  danger rediscovering
successful coloring exponential number times 
hardly seems sensible  human problem solver working problem would
simply ignore east possible  returning directly arizona proceeding 
states along mississippi needed new colors would east reconsidered   even
new coloring could found mississippi consistent
eastern solution 
paper formalize technique  presenting modification conventional
search techniques capable backtracking recently expanded
node  directly node elsewhere search tree  dynamic way
search structured  refer technique dynamic backtracking 
specific outline follows  begin next section introducing
variety notational conventions allow us cast existing work new
ideas uniform computational setting  section   discusses backjumping  intermediate
simple chronological backtracking ideas  presented
section    example dynamic backtracking algorithm use appears section
  experimental analysis technique section    summary results
suggestions future work section    proofs deferred appendix
interests continuity exposition 

   preliminaries
definition     constraint satisfaction problem  i  v    mean set vari 

ables      set vi possible values variable i  set
constraints  pair  j  p   j    j           jk   ordered subset p
subset vj  vjk  
solution csp set vi values variables vi   vi
every constraint  j  p   form    vj            vjk     p  

example introduction  set states vi set possible
colors state i  constraint  first part constraint pair adjacent
states second part set allowable color combinations states 
basic plan paper present formal versions search algorithms
described introduction  beginning simple depth first search proceeding
backjumping dynamic backtracking  start  make following definition
partial solution csp 

definition     let  i  v    csp  partial solution csp mean ordered
subset j assignment value variable j  
  

fidynamic backtracking

denote partial solution tuple ordered pairs  ordered pair

 i  v   assigns value v variable i  partial solution p   denote p
set variables assigned values p  

constraint satisfaction problems solved practice taking partial solutions
extending assigning values new variables  general  course  value
assigned variable inconsistent constraints  therefore
make following definition 

definition     given partial solution p

csp  eliminating explanation
variable pair  v    v   vi p   intended meaning
cannot take value v values already assigned p variables  
elimination mechanism csp function accepts arguments partial
solution p   variable    p   function returns  possibly empty  set  p  i 
eliminating explanations i 

set e eliminating explanations  denote eb values
identified eliminated  ignoring reasons given  therefore denote b p  i  set
values eliminated elements  p  i  
note definition somewhat exible regard amount work
done elimination mechanism   values violate completed constraints might
eliminated  amount lookahead might done  will  however  make
following assumptions elimination mechanisms 
   correct  partial solution p   value vi    b p  i   every
constraint  s    p  fig satisfied values partial solution
value vi i  constraints complete value vi
assigned i 
   complete  suppose p partial solution csp 
solution extends p assigning value v i  p   extension p
 v  e      p     i  
e    p     p     
   
words  whenever p successfully extended assigning v
p   cannot be  least one element p     p identified possible reason
problem 
   concise  partial solution p   variable eliminated value v  
single element form  v  e      p  i   one reason given
variable cannot value v  

lemma     let complete elimination mechanism csp  let p partial solution csp let    p   p successfully extended complete solution
assigning value v   v    b p  i  
apologize swarm definitions  allow us give clean description
depth first search 
  

figinsberg

algorithm      depth first search  given inputs constraint satisfaction problem

elimination mechanism  
   set p     p partial solution csp  set ei       ei
set values eliminated variable i 
   p     p assigns value every element   solution
original problem  return it  otherwise  select variable     p   set ei   b p  i  
values eliminated possible choices i 
   set   vi   ei  set remaining possibilities i  nonempty  choose
element v     add  i  v   p   thereby setting i s value v   return step   
   empty  let  j  vj   last entry p   entry  return failure 
remove  j  vj   p   add vj ej   set   j return step   

written algorithm returns single answer csp  modification accumulate answers straightforward 
problem algorithm     looks little conventional depth first
search  since instead recording unexpanded children particular node 
keeping track failed siblings node  following 

lemma     point execution algorithm      last element partial
solution p assigns value variable i  unexplored siblings current node
assign values vi   ei  
proposition     algorithm     equivalent depth first search therefore complete 

remarked  basic difference algorithm     conventional description depth first search inclusion elimination sets ei 
conventional description expects nodes include pointers back parents  siblings given node found examining children node s parent  since
reorganizing space search  impractical framework 
might seem natural solution diculty would record
values eliminated variable i  remain considered 
technical reason done much easier maintain
elimination information search progresses  understand intuitive level 
note search backtracks  conclusion implicitly drawn
particular node fails expand solution  opposed conclusion
currently unexplored portion search space  little surprise
ecient way manipulate information recording approximately form 

   backjumping

describe dependency directed backtracking backjumping setting 
cases  partial solution forced backtrack 
sophisticated backtracking mechanisms use information reason failure
identify backtrack points might allow problem addressed  start  need
modify algorithm     maintain explanations eliminated values 
  

fidynamic backtracking

algorithm     given inputs constraint satisfaction problem elimination mechanism  
   set p   ei       ei set eliminating explanations i 
   p     return p   otherwise  select variable     p   set ei    p  i  
   set   vi   ebi  nonempty  choose element v     add  i  v   p
return step   
   empty  let  j  vj   last entry p   entry  return failure 
remove  j  vj   p   must ebi   vi  every value
eliminated  let e set variables appearing explanations
eliminated value  add  vj   e   fj g  ej   set   j return step   

lemma     let p partial solution obtained execution algorithm     

let   p variable assigned value p   p   p successfully
extended complete solution assigning value v  v  e     ei   must

e    p   p      

words  assignment value variable p   p   correctly identified
source problem 
note step   algorithm  could added  vj   e   p   instead  vj   e  
fj g  ej   either way  idea remove e variables longer assigned
values p  
backjumping  simply change backtrack method  instead removing
single entry p returning variable assigned value prior problematic
variable i  return variable actually impact i  words 
return variable set e  

algorithm      backjumping  given inputs constraint satisfaction problem
elimination mechanism  
   set p   ei      

   p     return p   otherwise  select variable     p   set ei    p  i  
   set   vi   ebi  nonempty  choose element v     add  i  v   p
return step   
   empty  must ebi   vi   let e set variables appearing
explanations eliminated value 
   e     return failure  otherwise  let  j  vj   last entry p j   e  
remove p entry entry following it  add  vj   e   p   ej   set   j
return step   
  

figinsberg

step    add  vj   e   p   ej   removing e variables longer
assigned values p  

proposition     backjumping complete always expands fewer nodes depthfirst search 

let us look map coloring example  partial coloring
p looking specific state i  suppose denote c set colors
obviously illegal con ict color already assigned one i s
neighbors 
one possible elimination mechanism returns  p  i  list  c  p   color
c   c used color neighbor i  reproduces depth first search  since
gradually try possible colors idea went wrong need
backtrack since every colored state included p   far sensible choice would take
 p  i  list  c  fng  n neighbor already colored c  would
ensure backjump neighbor coloring found 
causes us backjump another state j   add i s neighbors eliminating explanation j  s original color  need backtrack still further 
consider neighbors either j   be  since changing color one
i s neighbors might allow us solve coloring problem reverting original
choice color state j  
have 

proposition     amount space needed backjumping o i v     ji j

number variables problem v number values variable
largest value set vi  

result contrasts sharply approach csps relies truth maintenance
techniques maintain list nogoods  de kleer         there  number nogoods
found grow linearly time taken analysis  typically
exponential size problem  backjumping avoids problem resetting
set ei eliminating explanations step   algorithm     
description given quite similar developed  bruynooghe 
       explanations somewhat coarser ours  listing variables
involved eliminating explanation particular variable csp 
idea essentially same  bruynooghe s eliminating explanations stored
o i   space  instead o i v     associated loss information makes technique
less effective practice  earlier work description backjumping only  since
intermediate information erased search proceeds 

   dynamic backtracking

finally turn new results  basic problem algorithm     backjumps wrong place  needlessly erases great deal work
done thus far  least  retain values selected variables
backjumped over  sense moving backjump variable end partial
  

fidynamic backtracking

solution order replace value without modifying values variables
followed it 
additional modification probably clearest return
example introduction  suppose example  color eastern
states returning western half country  reorder variables order
backtrack arizona eventually succeed coloring west without disturbing
colors used east 
unfortunately  return east backtracking required find
needing change coloring eastern states dealt earlier 
ideas presented allow us avoid erasing solution problems
west  search eastern states ecient  need
retain information portion east s search space
eliminated  all  determined new york cannot colored yellow 
changes west reverse conclusion   mississippi really isolate one
section country other 
machinery needed capture sort reasoning already place 
backjump variable k  retain choice value k  k s
elimination set  do  however  need remove elimination set entry
involves eventual backtrack variable j   since entries longer valid  
depend assumption j takes old value  assumption false 

algorithm      dynamic backtracking i  given inputs constraint satisfaction problem elimination mechanism  
   set p   ei      
   p     return p   otherwise  select variable     p   set ei   ei    p  i  
   set   vi   ebi  nonempty  choose element v     add  i  v   p
return step   
   empty  must ebi   vi   let e set variables appearing
explanations eliminated value 
   e     return failure  otherwise  let  j  vj   last entry p j   e  
remove  j  vj   p and  variable k assigned value j   remove
ek eliminating explanation involves j   set

ej   ej    p  j     f vj   e   p  g
   
vj eliminated value j values taken variables
e   p   inclusion term  p  j   incorporates new information variables
assigned values since original assignment vj j   set   j
return step   

theorem     dynamic backtracking always terminates complete  continues

satisfy proposition     expected expand fewer nodes backjumping provided
goal nodes distributed randomly search space 
  

figinsberg

essential difference dynamic dependency directed backtracking
structure eliminating explanations means save nogood information
based current values assigned variables  nogood depends outdated information  drop it  this  avoid need retain exponential amount
nogood information  makes technique valuable  as stated theorem 
termination still guaranteed 
one trivial modification make algorithm     quite useful
practice  removing current value backtrack variable j   algorithm    
immediately replaces another  real reason this  could
instead pick value entirely different variable 

algorithm      dynamic backtracking  given inputs constraint satisfaction problem elimination mechanism  
   set p   ei      
   p     return p   otherwise  select variable     p   set ei   ei    p  i  
   set   vi   ebi  nonempty  choose element v     add  i  v   p
return step   
   empty  must ebi   vi   let e set variables appearing
explanations eliminated value 
   e     return failure  otherwise  let  j  vj   last entry p binds
variable appearing e   remove  j  vj   p and  variable k assigned
value j   remove ek eliminating explanation involves j   add
 vj   e   p   ej return step   

   example
order make algorithm     bit clearer  suppose consider small mapcoloring problem detail  map shown figure   consists five countries 
albania  bulgaria  czechoslovakia  denmark england  assume  wrongly  
countries border shown figure  countries denoted nodes
border one another arc connecting them 
coloring map  use three colors red  yellow blue  typically
abbreviate country names single letters obvious way 
begin search albania  deciding  say  color red  look
bulgaria  colors eliminated albania bulgaria share border 
decide color bulgaria yellow   this mistake  
go consider czechoslovakia  since borders albania  color red
eliminated  decide color czechoslovakia blue situation this 
  

fidynamic backtracking

denmark




czechoslovakia

    
 
  
 
 
 
 
  
 
albanias 
  sbulgaria
  
 
 
  
 
 
 
 
    
  s
england

figure    small map coloring problem
country
color red yellow blue
albania
red
bulgaria
yellow
czechoslovakia blue
denmark
england
country  indicate current color eliminating explanations mean
cannot colored three colors  when explanations exist   look
denmark 
denmark cannot colored red border albania cannot colored
yellow border bulgaria  must therefore colored blue 
england cannot colored color borders albania  bulgaria
denmark  therefore need backtrack one three countries 
point  elimination lists follows 
country
color red yellow blue
albania
red
bulgaria
yellow
czechoslovakia blue
denmark
blue
b
england

b

backtrack denmark recent three possibilities 
begin removing eliminating explanation involving denmark table
get 
  

figinsberg

color red yellow blue
country
albania
red
bulgaria
yellow
czechoslovakia blue
denmark

b
england

b
next  add denmark s elimination list pair
 blue  fa  b g 
indicates correctly current colors albania bulgaria  denmark cannot colored blue  because subsequent dead end england   since every
color eliminated  must backtrack country set fa  b g  changing
czechoslovakia s color won t help must deal bulgaria instead  elimination
lists now 
country
color red yellow blue
albania
red
bulgaria
czechoslovakia blue
denmark

b a b
england

b
remove eliminating explanations involving bulgaria add bulgaria s elimination list pair
 yellow  a 
indicating correctly bulgaria cannot colored yellow current choice
color albania  red  
situation now 
color red yellow blue
country
albania
red
czechoslovakia blue
bulgaria

denmark

england

moved bulgaria past czechoslovakia ect search reordering algorithm  complete problem coloring bulgaria red  denmark either yellow
blue  england color used denmark 
example almost trivially simple  course  thing note
changed color bulgaria  retained blue color czechoslovakia
information indicating none czechoslovakia  denmark england could red 
complex examples  information may hard won retaining may
save us great deal subsequent search effort 
another feature specific example  and example introduction
well  computational benefits dynamic backtracking consequence
  

fidynamic backtracking

automatic realization problem splits disjoint subproblems  authors
discussed idea applying divide and conquer techniques csps  seidel       
zabih         methods suffer disadvantage constrain order
unassigned variables assigned values  perhaps odds common heuristic
assigning values first variables tightly constrained  dynamic
backtracking expected use situations problem question
split two disjoint subproblems  

   experimentation

dynamic backtracking incorporated crossword puzzle generation program
described  ginsberg  frank  halpin    torrance         leads significant performance improvements restricted domain  specifically  method tested
problem generating    puzzles sizes ranging            puzzle
attempted     times using dynamic backtracking simple backjumping 
dictionary shued solution attempts maximum      backtracks
permitted program deemed failed 
cases  algorithms extended include iterative broadening  ginsberg
  harvey         cheapest first heuristic forward checking  cheapest first
called  most constrained first  selects instantiation variable
fewest number remaining possibilities  i e   variable cheapest
enumerate possible values  smith   genesereth          forward checking prunes
set possibilities crossing words whenever new word entered constitutes
experimental choice elimination mechanism  point  words legal
crossing word eliminated  ensures word entered crossword
word potential crossing words point  cheapest first heuristic
would identify problem next step search  forward checking reduces
number backtracks substantially   least constraining  heuristic  ginsberg et al  
      used  heuristic suggests word slot filled word
minimally constrains subsequent search  heuristic used would
invalidate technique shuing dictionary solution attempts order
gather useful statistics 
table figure   indicates number successful solution attempts  out     
two methods    crossword frames  dynamic backtracking
successful six cases less successful none 
regard number nodes expanded two methods  consider data
presented figure    graph average number backtracks needed
two methods   although initially comparable  dynamic backtracking provides increasing
computational savings problems become dicult  somewhat broader set
experiments described  jonsson   ginsberg        leads similar conclusions 
examples  jonsson   ginsberg        dynamic backtracking
leads performance degradation  however  typical case appears figure    
   indebted david mcallester observations 
      points shown point plotted backjumping unable solve problem 
   worst performance degradation observed factor approximately   

  

figinsberg

dynamic
dynamic
frame backtracking backjumping frame backtracking backjumping
 
   
   
  
   
  
   
   
  
   
   
 
 
   
   
  
   
   
   
   
  
   
   
 
 
   
   
  
  
  
   
   
  
   
  
 
 
   
   
  
   
  
   
   
  
  
 
 
 
   
   
  
  
 
  
   
   
figure    number problems solved successfully

   
r
r

dynamic    
backtracking

r
r

r rr
rrr
rr

r
r

rr

   

   
   
backjumping

figure    number backtracks needed

  

   

    

fidynamic backtracking

region
 


  
 
 
 
 
 
b
sa
s 
  
aaaa
aaa
aaa   
aaa  
aa a
 a s

region  

figure    dicult problem dynamic backtracking
figure  first color a  b   countries region    get stuck region
  
presumably backtrack directly b   leaving coloring region   alone 
may well mistake   colors region   restrict choices b   perhaps
making subproblem consisting a  b region   dicult might be 
region   easy color  would better erasing even though didn t
need to 
analysis suggests dependency directed backtracking fare worse
coloring problems dynamic backtracking trouble  currently
extending experiments  jonsson   ginsberg        confirm this  conjecture
borne out  variety solutions come mind  might  example  record
many backtracks made node b figure  use
determine exibility b important retaining choices made region
   diculty finding coloring region   determined number
backtracks involved search 

   summary
    works
two separate ideas exploited development algorithm    
others leading it  first  easily important  notion
possible modify variable order way allows us retain
results earlier work backtracking variable assigned value early
search 
  

figinsberg

reordering confused work authors suggested
dynamic choice among variables remain assigned values  dechter   meiri 
      ginsberg et al         p  purdom   robertson        zabih   mcallester        
instead reordering variables assigned values search thus far 
another way look idea found way  erase  value given
variable directly opposed backtracking it  idea explored
minton et al   minton  johnston  philips    laird        selman et al 
 selman  levesque    mitchell         authors directly replace values assigned
variables satisfiability problems  unfortunately  heuristic repair method used
incomplete dependency information retained one state problem
solver next 
third way view well  space examining really
graph  opposed tree  reach point coloring albania blue
bulgaria red color opposite order  decide backjump
particular node search space  know need back particular
property node ceases hold   key idea backtracking along
path one node generated  may able backtrack
slightly would otherwise need retreat great deal  observation
interesting may well apply problems csps  unfortunately 
clear guarantee completeness search discovers node using one path
backtracks using another 
idea less novel  already remarked  use eliminating
explanations quite similar use nogoods atms community  principal
difference attach explanations variables impact drop
cease relevant   they might become relevant later  course  
avoids prohibitive space requirements systems permanently cache results
nogood calculations  observation may extensible beyond domain
csps specifically  again  ways view   gashnig s notion backmarking
 gaschnig        records similar information reason particular portions
search space known contain solutions 

    future work
variety ways techniques presented extended 
section  sketch obvious ones 
      backtracking older culprits

one extension work involves lifting restriction algorithm     variable
erased always recently assigned member set e  
general  cannot retaining completeness search  consider
following example 
imagine csp involves three variables  x  z   take value  
   further  suppose csp solutions  pick two values
x   realize suitable choice z  
  

fidynamic backtracking

begin taking x        realize need backtrack  introduce
nogood
x         
   
replace value     
fails  too  suppose decide backtrack x  introducing
new nogood
    x     
   
change x s value   erase     
fails  decide problem change value    introducing
nogood
x         
erasing      fails  danger returning x       
eliminated beginning example  loop may cause modified version
dynamic backtracking algorithm fail terminate 
terms proof theorem      nogoods discovered already include information
assigned variables  difference          drop
    favor      longer position recover     
deal placing conditions variables choose
backtrack  conditions need defined proof theorem     continues
hold   experimentation indicates loops form described extremely
rare practice  may possible detect directly thereby retain
substantial freedom choice backtrack point 
freedom backtrack raises important question yet addressed
literature  backtracking avoid diculty sort  one
backtrack 
previous work constrained backtrack recent choice
might impact problem question  decision would incomplete
inecient  although extension algorithm     need operate restriction 
given indication backtrack point selected 
several easily identified factors expected bear choice 
first remains reason expect backtracking chronologically recent
choices effective   choices expected contributed
fewest eliminating explanations  obvious advantage retaining many
eliminating explanations possible one point search next  possible  however  simply identify backtrack point affects fewest number
eliminating explanations use that 
alternatively  might important backtrack choice point
many new choices possible  extreme example  variable
every value current one already eliminated
reasons  backtracking guaranteed generate another backtrack immediately
probably avoided possible 
   another solution appears  mcallester        

  

figinsberg

finally  measure  directness  variable bears
problem  unable find value particular variable i  probably sensible
backtrack second variable shares constraint itself  opposed
variable affects indirectly 
competing considerations weighed  idea  framework developed interesting allows us work question 
basic terms   debug  partial solutions csps directly  moving laterally
search space attempt remain close solution possible 
sort lateral movement seems central human solution dicult search problems 
encouraging begin understand formal way 
      dependency pruning

often case one value variable eliminated solving csp 
others eliminated well  example  solving scheduling problem particular
choice time  say       may eliminated task isn t enough
time subsequent task b   case  later times obviously
eliminated well 
formalizing subtle  all  later time isn t uniformly worse
earlier time may tasks need precede making later
makes part schedule easier  it s problem b alone forces
earlier  again  analysis depends ability maintain dependency information
search proceeds 
formalize follows  given csp  i  v     suppose value v
assigned     construct new csp  i    v        involving
remaining variables      fig  new set v   need mention possible values
vi i    generated modifying constraints indicate
assigned value v   make following definition 

definition     given csp  suppose variable two possible values u

v  say v stricter u every constraint csp induced assigning
u constraint csp induced assigning value v 
point  course  v stricter u is  point trying
solution involving v u eliminated  all  finding solution would
involve satisfying constraints v restriction  superset
u restriction  unable satisfy constraints u restriction originally 
example began section generalizes following 

proposition     suppose csp involves set variables 
partial solution assigns values variables subset p   suppose
extend partial solution assigning value u variable    p  
extension solution entire csp  consider csp involving
variables   p induced choices values variables p   v stricter
u choice value problem  original csp solution
assigns v extends given partial solution p  
  

fidynamic backtracking

proposition isn t quite enough  earlier example  choice     
stricter      task needs scheduled is 
need record fact b  which longer assigned value  source
diculty  this  need augment dependency information
working 
precisely  say set variables fxi g eliminates value v variable
x  mean search date allowed us conclude
 v    x        vk   xk   v    x
vi current choices xi   obviously rewrite
 v    x         vk   xk      v   x  f
   
f indicates csp question solution 
let s specific still  indicating     exactly csp solution 
 v    x         vk   xk      v   x  f  i  
   
set variables complete csp 
address example began section  csp
known fail expression     entire problem  subset it 
example  considering  subproblem involves two tasks b  
general  augment nogoods include information subproblems
fail  measure strictness respect restricted subproblems
only  example  indeed allow us eliminate      consideration
possible time a 
additional information stored nogoods doubles size  we store
second subset variables csp   variable sets involved manipulated
easily search proceeds  cost involved employing technique therefore
strictness computation  may substantial given data structures currently
used represent csps  which typically support need check constraint
violated little more   seems likely compile time modifications data
structures used make strictness question easier answer  scheduling
problems  preliminary experimental work shows idea important one  here 
too  much done 
basic lesson dynamic backtracking retaining nogoods
still relevant given partial solution working  storage diculties
encountered full dependency directed methods alleviated  makes
ideas proposed possible   erasing values  selecting alternate backtrack
points  dependency pruning  surely many effective uses practical
dependency maintenance system well 

acknowledgements
work supported air force oce scientific research grant
number         darpa rome labs grant number f         c      
  

figinsberg

would thank rina dechter  mark fox  geddis  harvey  vipin kumar 
scott roy narinder singh helpful comments ideas  ari jonsson
david mcallester provided invaluable assistance experimentation proofs
respectively 

a  proofs
lemma     let complete elimination mechanism csp  let p partial solution

csp let    p   p successfully extended complete solution
assigning value v   v    b p  i  

proof  suppose otherwise   v  e      p  i   follows directly completeness


e    p   p     

contradiction 

lemma     point execution algorithm      last element partial

solution p assigns value variable i  unexplored siblings current node
assign values vi   ei  

proof  first note decide assign value new variable step  

algorithm  take ei   b p  i  vi   ei set allowed values
variable  lemma therefore holds case  fact continues hold
repetition loop steps     simple induction  point 
add ei node failed possible value assigned i 

proposition     algorithm     equivalent depth first search therefore complete 
proof  easy consequence lemma  partial solutions correspond nodes

search space 
lemma     let p partial solution obtained execution algorithm     
let   p variable assigned value p   p   p successfully extended
complete solution assigning value v  v  e     ei   must

e    p   p      

proof  proof lemma      show step algorithm     cause
lemma     become false 
lemma holds step    search extended consider new
variable  immediate consequence assumption elimination mechanism
complete 
step    add  vj   e   fj g  set eliminating explanations j  
simply recording fact search solution j set vj failed
unable extend solution i  consequence inductive hypothesis
long variable e   fj g changes  conclusion remain valid 
proposition     backjumping complete always expands fewer nodes depthfirst search 

  

fidynamic backtracking

proof  fewer nodes examined clear  completeness  follows lemma
    backtrack element e step   always necessary solution
found 
proposition     amount space needed backjumping o i v     ji j
number variables problem v number values variable
largest value set vi  
proof  amount space needed dominated storage requirements elimination sets ej   these  one might refer possible values
particular variable j   space needed store reason value j eliminated
ji j  since reason simply list variables assigned values 
never two eliminating explanations variable  since concise
never rebind variable value eliminated 
theorem     dynamic backtracking always terminates complete  continues

satisfy proposition     expected expand fewer nodes backjumping provided
goal nodes distributed randomly search space 

proof  four things need show  dynamic backtracking needs o i v 

space  complete  expected expand fewer nodes backjumping 
terminates  prove things order 
space clear  amount space needed continues bounded structure
eliminating explanations 
completeness clear  since lemma      eliminating explanations
retained algorithm obviously still valid  new explanations added    
obviously correct  since indicate j cannot take value vj backjumping
j cannot take values eliminated variables backjumped
over 
eciency see expect expand fewer nodes  suppose subproblem
involving variables jumped solutions total  one given
existing variable assignments  assuming solutions distributed randomly
search space  least   s chance particular solution leads
solution entire csp  so  reordered search   considers solution earlier
  save expense either assigning new values variables
repeating search led existing choices  reordered search benefit
information nogoods retained variables jumped
over 
termination dicult part proof 
work algorithm  generating  and discarding  variety
eliminating explanations  suppose e explanation  saying j cannot
take value vj values currently taken variables set ev  
denote variables ev x            xk current values v           vk  
declarative terms  eliminating explanation telling us
 x    v        xk   vk   j    vj
  

   

figinsberg

dependency directed backtracking would us accumulate nogoods  dynamic
backtracking allows us drop particular instance     antecedent
longer valid 
reason dependency directed backtracking guaranteed terminate
set accumulated nogoods eliminates monotonically increasing amount search
space  nogood eliminates new section search space nature
search process node examined consistent nogoods
accumulated thus far  process monotonic nogoods retained throughout
search  arguments cannot applied dynamic backtracking  since nogoods
forgotten search proceeds  make analogous argument 
this  suppose discover nogood      record
variables precede variable j partial order  together values currently
assigned variables  thus eliminating explanation becomes essentially nogood
n form     together set variable value pairs 
define mapping  n    changes antecedent     include assumptions variables bound     fsi   vi g 

 n        s    v        sl   vl  j    vj  

   

point execution algorithm  denote n conjunction
modified nogoods form     
make following claims 
   eliminating explanation  n     n j   n     n    valid
problem hand 
   new eliminating explanation  n      n    consequence n  
   deductive consequences n grow monotonically dynamic backtracking
algorithm proceeds 
theorem follow three observations  since know n valid
set conclusions search problem making monotonic
progress toward eliminating entire search space concluding problem
unsolvable 
 n    consequence  n    clear  since modification used obtain
        involves strengthening antecedent      clear  n   
consequence nogoods already obtained  since added antecedent
conditions hold node search space currently examination 
 n    consequence nogoods obtained thus far  node would
considered 
last observation depends following lemma 

lemma a   suppose x variable assigned value partial solution

x appears antecedent nogood n pair  n       set
variables assigned values later x     
  

fidynamic backtracking

proof  consider      suppose   cannot   x  since

would mentioned nogood n therefore   suppose
actually assigned value earlier x is   n    added set
eliminating explanations  must case x assigned value  since
appears antecedent n  not  know
later time assigned value x not  since precedes x current
partial solution  means x must changed value point  n   
added set eliminating explanations    n    would deleted
happened  contradiction completes proof 
returning proof theorem      suppose eventually drop  n   
collection nogoods so  new nogood added  n      
follows lemma     since xi   vi clause antecedent  n    
follows  n       imply negation antecedent  n    therefore
imply  n    itself  although drop  n    drop nogood  n      n   
continues entailed modified set n   consequences seen
growing monotonically 

references

bruynooghe  m          solving combinatorial search problems intelligent backtracking 
information processing letters                
de kleer  j          assumption based truth maintenance system  artificial intelligence 
            
dechter  r     meiri  i          experimental evaluation preprocessing techniques
constraint satisfaction problems  proceedings eleventh international joint
conference artificial intelligence  pp          
gaschnig  j          performance measurement analysis certain search algorithms 
tech  rep  cmu cs         carnegie mellon university 
ginsberg  m  l   frank  m   halpin  m  p     torrance  m  c          search lessons learned
crossword puzzles  proceedings eighth national conference artificial
intelligence  pp          
ginsberg  m  l     harvey  w  d          iterative broadening  artificial intelligence     
        
jonsson  a  k     ginsberg  m  l          experimenting new systematic nonsystematic search techniques  proceedings aaai spring symposium ai
np hard problems stanford  california 
mcallester  d  a          partial order backtracking  journal artificial intelligence
research     submitted 
minton  s   johnston  m  d   philips  a  b     laird  p          solving large scale constraint satisfaction scheduling problems using heuristic repair method  proceedings eighth national conference artificial intelligence  pp        
  

figinsberg

p  purdom  c  b     robertson  e          backtracking multi level dynamic search
rearrangement  acta informatica             
seidel  r          new method solving constraint satisfaction problems  proceedings
seventh international joint conference artificial intelligence  pp          
selman  b   levesque  h     mitchell  d          new method solving hard satisfiability
problems  proceedings tenth national conference artificial intelligence 
smith  d  e     genesereth  m  r          ordering conjunctive queries  artificial intelligence                  
stallman  r  m     sussman  g  j          forward reasoning dependency directed
backtracking system computer aided circuit analysis  artificial intelligence 
               
zabih  r          applications graph bandwidth constraint satisfaction problems 
proceedings eighth national conference artificial intelligence  pp        
zabih  r     mcallester  d  a          rearrangement search strategy determining
propositional satisfiability  proceedings seventh national conference
artificial intelligence  pp          

  


