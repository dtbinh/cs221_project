journal of artificial intelligence research                

submitted        published      

solving  sat and maxsat by dynamic programming
sigve hortemo sther
jan arne telle
martin vatshelle

sigve sether ii uib no
telle ii uib no
martin vatshelle ii uib no

department of informatics  university of bergen
bergen  norway

abstract
we look at dynamic programming algorithms for propositional model counting  also
called  sat  and maxsat  tools from graph structure theory  in particular treewidth 
have been used to successfully identify tractable cases in many subfields of ai  including
sat  constraint satisfaction problems  csp   bayesian reasoning  and planning  in this
paper we attack  sat and maxsat using similar  but more modern  graph structure
tools  the tractable cases will include formulas whose class of incidence graphs have not only
unbounded treewidth but also unbounded clique width  we show that our algorithms extend
all previous results for maxsat and  sat achieved by dynamic programming along
structural decompositions of the incidence graph of the input formula  we present some
limited experimental results  comparing implementations of our algorithms to state of the art
 sat and maxsat solvers  as a proof of concept that warrants further research 

   introduction
the propositional satisfiability problem  sat  is a fundamental problem in computer science
and in ai  many real world applications such as planning  scheduling  and formal verification
can be encoded into sat and a sat solver can be used to decide if there exists a solution 
to decide how many solutions there are  the propositional model counting problem   sat  
which finds the number of satisfying assignments  could be useful  if there are no solutions 
it may be interesting to know how close we can get to a solution  when the propositional
formula is encoded in conjunctive normal form  cnf  this may be solved by the maximum
satisfiability problem  maxsat   which finds the maximum number of clauses that can
be satisfied by some assignment  in this paper we investigate classes of cnf formulas
where these two problems   sat and maxsat  can be solved in polynomial time  tools
from graph structure theory  in particular treewidth  have been used to successfully identify
tractable cases in many subfields of ai  including sat  constraint satisfaction problems
 csp   bayesian reasoning  and planning  bacchus  dalmao    pitassi        darwiche 
      fischer  makowsky    ravve        samer   szeider         in this paper we
attack  sat and maxsat using similar  but more modern  graph structure tools  the
tractable cases will include formulas whose class of incidence graphs have not only unbounded
treewidth but also unbounded clique width 
both  sat and maxsat are significantly harder than simply deciding if a satisfying
assignment exists   sat is  p hard  garey   johnson        even when restricted
to horn   cnf formulas  and to monotone   cnf formulas  roth         maxsat is
np hard even when restricted to horn   cnf formulas  jaumard   simeone         and to
c
    
ai access foundation  all rights reserved 

fisther  telle   vatshelle

  cnf formulas where each variable appears at most   times  raman  ravikumar    rao 
       both problems become tractable under certain structural restrictions obtained by
bounding width parameters of graphs associated with formulas  fischer  makowsky    ravve 
      ganian  hlineny    obdrzalek        samer   szeider        szeider         the
work we present here is inspired by recent results in the work of paulusma  slivovsky  and
szeider        and also in the work of slivovsky and szeider        showing that  sat
is solvable in polynomial time when the incidence graph  i f   of the input formula f has
bounded modular treewidth  and more strongly  bounded symmetric clique width 
these tractability results work by dynamic programming along a decomposition of i f   
there are two steps involved      find a good decomposition  and     perform dynamic
programming along the decomposition  the goal is to have a fast runtime  and this is usually
expressed as a function of some known graph width parameter of the incidence graph i f  
of the formula f   like its tree width  step     is solved by a known graph algorithm for
computing a decomposition of low  tree  width  while step     solves  sat or maxsat
by dynamic programming with runtime expressed in terms of the  tree  width k of the
decomposition 
the algorithms we give in this paper also work by dynamic programming along a
decomposition  but in a slightly different framework  since we are not solving a graph
theoretic problem  expressing runtime by a graph theoretic parameter may be a limitation 
therefore  our strategy will be to develop a framework based on the following strategy
 a  consider  for  sat or maxsat  the amount of information needed to combine
solutions to subproblems into global solutions  then
 b  define the notion of good decompositions based on a parameter that minimizes this
information  and then
 c  design a dynamic programming algorithm along such a decomposition with runtime
expressed by this parameter
both in the work of paulusma et al         and in that of slivovsky and szeider       
two assignments are considered to be equivalent if they satisfy the same set of clauses 
when carrying out  a  for  sat and maxsat this led us to the concept of ps value of a
cnf formula  let us define it and give an intuitive explanation  a subset c of the clauses
of a cnf formula f is called projection satisfiable if there is some complete assignment
satisfying every clause in c but not satisfying any clause not in c  the ps value of f is
the number of projection satisfiable subsets of clauses  let us consider its connection to
dynamic programming  which in general applies when an optimal solution can be found
by combining optimal solutions to certain subproblems  for  sat and maxsat these
subproblems  at least in the cases we consider  take the form of a subformula of f induced
by a subset s of clauses and variables  i e  first remove from f all variables not in s and
then remove all clauses not in s  consider for simplicity the two subproblems fs and fs
defined by s and its complement s  when combining the solutions to fs and fs   in order
   i f   is the bipartite incidence graph between the clauses of f on the one hand and the variables of f on
the other hand  information about positive or negative occurrences of variables is not encoded in i f   so
sometimes a signed or directed version is used that includes also this information 

  

fisolving  sat and maxsat by dynamic programming

to find solutions to f   it seems clear that we must consider a number of cases at least as
big as the ps values of the two disjoint subformulas crossing between s and s  i e  the
subformulas obtained by removing from clauses in s the variables of s  and by removing
from clauses in s the variables of s  see figure   for an example 
we did not find in the literature a study of the ps value of cnf formulas  so we start by
asking for a characterization of formulas having low ps value  we were led to the concept of
the mim value of i f    which is the size of a maximum induced matching of i f    where
an induced matching is a subset m of edges with the property that any edge of the graph
is incident to at most one edge in m   note that this value can be much lower than the
size of a maximum matching  e g  any complete bipartite graph has mim value    we show
that the ps value of f is upper bounded by the number of clauses of f raised to the power
of the mim value of i f    plus    for a cnf formula f where i f   has mim value   the
interpretation of this result is straightforward  its clauses can be totally ordered such that for
any two clauses c   c   the variables occurring in c are a subset of the variables occurring
in c     and this has the implication that the number of subsets of clauses for which some
complete assignment satisfies exactly this subset is at most the number of clauses plus   
families of cnf formulas having small ps value are themselves of algorithmic interest 
but in this paper we continue with part  b  of the above strategy  and focus on how to
decompose a cnf formula f based on the concept of ps value  a common way to decompose
a mathematical object is to recursively partition its ground set into two parts  giving a
binary tree whose root represents the ground set and whose leaves are bijectively mapped
to the elements of the ground set  taking the ground set of f to be the set containing its
clauses and its variables  this is how we will decompose f   in other words by a binary tree
whose leaves are in     correspondence with the variables and clauses  a node of the binary
tree represents the subset x of variables and clauses at the leaves of its subtree  which
decomposition trees are good for efficiently solving  sat and maxsat  in accordance
with the above discussion under part  a  the answer is that the good decomposition trees
are those where all subformulas crossing between x and x  for some x defined by a node
of the tree  have low ps value  see figure   for an example  to define this informal notion
precisely we use the concept of a branch decomposition over the ground set of a formula with
cut function being the ps value of the formulas crossing the cut  branch decompositions are
by now a standard notion in graph and matroid theory  originating in the work of robertson
and seymour on graph minors  robertson   seymour         this way we arrive at the
definition of the ps width of a cnf formula f   and of the decompositions of f that achieve
this ps width  it is important to note that a formula can have ps value exponential in
formula size while ps width is polynomial  and that in general the class of formulas of low
ps width is much larger than the class of formulas of low ps value 
to finish the above strategy  we must carry out part  c  and show how to solve  sat
and maxsat by dynamic programming along the branch decomposition of the formula 
and express its runtime as a function of the ps width  this is not complicated  as dynamic
programming when everything has been defined properly simply becomes an exercise in
brute force computation of the sufficient and necessary information  but it is technical and
quite tedious  it leads to the following theorem 
theorem    given a formula f over n variables and m clauses  and a decomposition of f
of ps width k  we solve  sat and weighted maxsat in time o k   m m   n   
  

fisther  telle   vatshelle

thus  given a decomposition having a ps width k that is polynomially bounded in the
number of variables n and clauses m of the formula  we get polynomial time algorithms 
let us compare our result to the strongest previous result in this direction  namely the
work of slivovsky and szeider        for  sat  their algorithm takes as input a branch
decomposition over the vertex set of i f    which is the same as the ground set of f   and
evaluates its runtime by the cut function they call index  they show that this cut function is
closely related to the symmetric clique width scw of the given decomposition  giving runtime
 n   m o scw    considering the clique width cw of the given decomposition the runtime of the
cw
work of slivovsky and szeider        becomes  n   m o     since symmetric clique width
and clique width is related by the essentially tight inequalities    cw  scw   cw  courcelle 
       their algorithm is thus a polynomial time algorithm if given a decomposition with
constantly bounded scw  the result of theorem   encompasses this  since our corollary  
ties ps width to mim width and the work of vatshelle        shows that mim width is upper
bounded by clique width  see also the work of rao        for symmetric clique width  so
that a decomposition of i f   having constantly bounded  symmetric  clique width also has
polynomially bounded ps width  in this way  given the decomposition assumed as input in
the work of slivovsky and szeider         the algorithm of theorem   will have runtime
o m cw s   for cw the clique width of the given decomposition 
in the work of brault baron  capelli  and mengel         appearing after a preliminary
presentation of our results  sther  telle    vatshelle         it is argued that the framework
behind theorem   gives a uniform explanation of all tractability results for  sat in the
literature  in particular those using dynamic programming based on structural decompositions
of the incidence graph  the work of brault baron et al         also goes beyond this  giving
a polynomial time algorithm  not by dynamic programming  to solve  sat on  acyclic
cnf formulas  being exactly those formulas whose incidence graphs are chordal bipartite 
they show that these formulas do not have bounded ps width and that their incidence
graphs do not have bounded mim width  see figure   which gives an overview of the results
in this paper and in other papers 
using the concept of mim width of graphs  introduced in the thesis of vatshelle         and
the connection between ps value and mim value alluded to earlier  we show that a rich class of
formulas  including classes of unbounded clique width  have polynomially bounded ps width
and are thus covered by theorem    firstly  this holds for classes of formulas having incidence
graphs that can be represented as intersection graphs of certain objects  like interval graphs
 belmonte   vatshelle         secondly  it holds also for the much larger class of bipartite
graphs achieved by taking bigraph bipartizations of these intersection graphs  obtained by
imposing a bipartition on the vertex set and keeping only edges between the partition classes 
some such bigraph bipartizations have been studied previously  in particular the interval
bigraphs  the interval bigraphs contain all bipartite permutation graphs  and these latter
graphs have been shown to have unbounded clique width  brandstadt   lozin         see
figure   
let us discuss step      finding a good decomposition  note that theorem   assumes
that the input formula is given along with a decomposition of some ps width k  the value k
need not be optimal  so any heuristic finding a reasonable branch decomposition could be
used in practice  computing decompositions of optimal ps width is probably not doable in
  

fisolving  sat and maxsat by dynamic programming

iden
the inc

f

h of f
ce grap

ps width mk

 sat poly  paper a 
 sat poly  paper b 

chordal
bipartite

 sat and maxsat poly 
this paper 

 acyclic

ps width m 
mim width k
clique width k
symmetric
clique width k  
modular
treewidth k  

ps width m
k trapezoid
bigraph

circular arc
bigraph
interval bigraph
bipartite
permutation

figure    we believe  as argued in the work of brault baron et al          that any dynamic
programming approach working along a structural decomposition to solve  sat
 or maxsat  in polynomial time cannot go beyond the green box  paper a is by
brault baron et al         and paper b is by slivovsky and szeider         on
the left of the two dashed lines are   classes of graphs with bound k   or k on
some structural graph width parameter  and   classes of bipartite graphs  on the
right are  acyclic cnf formulas and   classes of cnf formulas with ps width
varying from linear in the number of clauses m  to m  and mk   there is an arc
from p to q if any formula f or incidence graph i f   having property p also has
property q  this is a hasse diagram  so lack of an arc in the transitive closure
means this relation provably does not hold 
polynomial time  but the complexity of this question is not adressed in this paper  however 
we are able to efficiently decide if a cnf formula has a certain linear structure guaranteeing
low ps width  by combining an alternative definition of interval bigraphs  hell   huang 
      with a fast recognition algorithm  muller        rafiey        we arrive at the
following  say that a cnf formula f has an interval ordering if there exists a total ordering
of variables and clauses such that for any variable x occurring in clause c  if x appears
before c then any variable between them also occurs in c  and if c appears before x then x
occurs also in any clause between them 
theorem    given a formula f over n variables and m clauses each of at most t literals 
in time o  m   n mn  we can decide if f has an interval ordering  yes iff i f   is an
interval bigraph   and if yes we solve  sat and weighted maxsat with an additional
runtime of o min m     t   m   n m  
formulas with an interval ordering are precisely those whose incidence graphs are interval
bigraphs  so theorem   encompasses classes of formulas whose incidence graphs have
unbounded clique width 
could parts of our algorithms be of interest for practical applications  answering this
question is beyond the scope of the present paper  however  we have performed some limited
testing  in particular for formulas with a linear structure  as a simple proof of concept  all
our code can be found online  sther  telle    vatshelle         we have designed and
implemented a heuristic for step     finding a good decomposition  in this case a linear
  

fisther  telle   vatshelle

one where the binary tree describing the decomposition is a path with attached leaves  we
have also implemented step     dynamic programming solving  sat and maxsat along
such decompositions  we then run     followed by     and compare against one of the
best maxsat solvers from the max sat      event of the sat      conference and the
latest version of the  sat solver called sharpsat  thurley         these solvers beat our
implementation on most inputs  which is not suprising since our code does not include any
techniques beyond our algorithm  nevertheless  we were able to generate some classes of
cnf formulas having interval orderings where our implementation is by far the better  this
lends support to our belief that methods related to ps value warrants further research to
investigate if they could be useful in practice 
our paper is organized as follows  in section   we give formal definitions of ps value
and ps width of a cnf formula and show the central combinatorial lemma linking ps value
of a formula to the size of the maximum induced matching in the incidence graph of the
formula  in section   we present dynamic programming algorithms that given a formula and
a decomposition solves  sat and weighted maxsat  proving theorem    in section  
we investigate classes of formulas having decompositions of low ps width  basically proving
the correctness of the hierarchy presented in figure    in section   we consider formulas
having an interval ordering and prove theorem    in section   we present the results of the
implementations and testing  we end in section   with some open problems 

   framework
we consider propositional formulas in conjunctive normal form  cnf   a literal is a
propositional variable or a negated variable  x or x  a clause is a set of literals  and a
formula is a multiset of clauses  for a formula f   cla f   denotes the clauses in f   the
incidence graph of a formula f is the bipartite graph i f   having a vertex for each clause
and variable  with variable x adjacent to any clause c in which it occurs  we consider
only input formulas where i f   is connected  as otherwise we would solve our problems
on the separate components of i f    for a clause c  lit c  denotes the set of literals
in c and var c  denotes
the variables of the literals in lit c   for a formula f   var f  
s
denotes the union ccla f   var c   for a set x of variables  an assignment of x is a
function    x          for a literal    we define      to be      var     if   is a negated
variable      x for some variable x  and to be   var  otherwise      x for some variable
x   a clause c is said to be satisfied by an assignment  if there exists at least one literal
   lit c  so that           any clause which an assignment  does not satisfy is said to be
falsified by    we notice that this means an empty clause will be falsified by all assignments 
a formula is satisfied by an assignment  if  satisfies all clauses in cla f   
the problem  sat  given a formula f   asks how many distinct assignments of var f  
satisfy f   the optimization problem weighted maxsat  given a formula
p f and weight
function w   cla f    n  asks what assignment  of var f   maximizes c w c  for all
c  cla f   satisfied by    the problem maxsat asks for the maximum number of satisfied
clauses that can be achieved  equivalent to weighted maxsat where all clauses have weight
one  for weighted maxsat  we assume the sum of all the weights are at most  o cla f     
and thus we can do summation on the weights in time linear in cla f   
  

fisolving  sat and maxsat by dynamic programming

for a set a  with elements from a universe u we denote by a the elements in u   a  as
the universe is usually given by the context 
    cut of a formula
in this paper  we will solve maxsat and  sat by the use of dynamic programming 
we will be using a divide and conquer technique where we solve the problem on smaller
subformulas of the original formula f and then combine the solutions to each of these smaller
formulas to form a solution to the entire formula f   note however  that the solutions found
for a subformula will depend on the interaction between the subformula and the remainder
of the formula  we use the following notation for subformulas 
for a clause c and set x of variables  by c x we denote the clause     c   var     x  
we say c x is the clause c induced by x  unless otherwise specified  all clauses mentioned
in this paper are from the set cla f    e g   if we write c x  cla f      we still assume c 
cla f     for a formula f and subsets c  cla f   and x  var f    we say the subformula
fc x of f induced by c and x is the formula consisting of the clauses  ci  x   ci  c   that
is  fc x is the formula we get by removing all clauses not in c followed by removing each
literal of a variable not in x  for a set c of clauses  we denote by c x the set  c x   c  c  
as with a clause  for an assignment  over a set x of variables  we say the assignment 
induced by x    x is the assignment   x   where the domain is restricted to x    
for a formula f and sets c  cla f    x  var f    and s   c  x  we call s a cut of f
and note that it breaks f into four subformulas fc x   fc x   fc x   and fc x   see figure   
one important fact we may observe from this definition is that a clause c in f is satisfied
by an assignment  of var f    if and only if c  induced by x or x  is satisfied by  in at
least one of the formulas of any cut of f  
    projection satisfiable sets and ps value of a formula
for a formula f and assignment  of some of the variables in var f    we denote by sat f    
the inclusion maximal set c  cla f   so that each clause in c is satisfied by    if for a
set c  cla f   we have sat f       c for some  over all the variables in var f    then c
is known as a projection  kaski  koivisto    nederlof        slivovsky   szeider       
and we say c is projection satisfiable in f   we denote by ps f   the family of all projection
satisfiable sets in f   that is 
ps f      sat f        is an assignment of the entire set var f    
the cardinality of this set   ps f     is referred to as the ps value of f  
to get a grasp of the structure of formulas having low ps value we consider induced
matchings in the incidence graph of a formula  the incidence graph of a formula f is the
bipartite graph i f   having a vertex for each clause and variable  with variable x adjacent
to any clause c in which it occurs  an induced matching in a graph is a subset m of edges
with the property that any edge of the graph is incident to at most one edge in m   in other
words  for any   vertices a  b  c  if ab is an edge in m and bc is an edge then there does not
exist an edge cd in m   the number of edges in m is called the size of the induced matching 
the following result provides an upper bound on the ps value of a formula in terms of the
maximum size of an induced matching of its incidence graph 
  

fisther  telle   vatshelle

lemma    let f be a cnf formula with no clause containing more than t literals  and
let k be the maximum size of an induced matching in i f    we then have  ps f    
min  cla f   k       tk   
proof  we first argue that  ps f      cla f   k      let c  ps f   and cf   cla f     c 
thus  there exists a complete assignment  such that the clauses not satisfied by  are
cf   cla f     sat f      since every variable in var f   appears in some clause of f this
means that   var cf   is the unique assignment of the variables in var cf   which do not satisfy
 
 
any clause of cf   let cf  cf be an inclusion minimal set such that var cf     var cf   
hence   var cf   is also the unique assignment of the variables in var cf   which do not satisfy
 
 
any clause of cf   an upper bound on the number of different such minimal cf   over all
 
c  ps f    will give an upper bound on  ps f     for every c  cf there is a variable vc
 
 
appearing in c and no other clause of cf   otherwise cf would not be minimal  note that we
have an induced matching m of i f   containing all such edges vc   c  by assumption  the
 
induced matching m can have at most k edges and hence  cf    k  it is easy to show by
induction on k that there are at most  cla f   k     sets of at most k clauses and the lemma
follows 
we now argue that  ps f      tk   as the maximum induced matching has size k there
is some set c of k clauses so that var c    var f    as each clause c  c has  var c    t 
we have  var f       var c    tk  as there are no more than   var f    assignments for f  
the ps value of f is upper bounded by  tk  
    the ps width of a formula
we define a branch decomposition of a formula f to be a pair  t    where t is a rooted
binary tree and  is a bijective function from the leaves of t to the clauses and variables
of f   if all the non leaf nodes  also referred to as internal nodes  of t induce a path  we
say that  t    is a linear branch decomposition  for a non leaf node v of t   we denote
by  v  the set   l    l is a leaf in the subtree rooted in v   based on this  we say that the
decomposition  t    of formula f induces certain cuts of f   namely the cuts defined by  v 
for each node v in t  
for a formula f and branch decomposition  t     for each node v in t   by fv we denote
the formula induced by the clauses in cla f      v  and the variables in  v   and by fv
we denote the formula on the complement sets  i e  the clauses in  v  and the variables
in var f      v   in other words  if  v    c  x with c  cla f   and x  var f   then
fv   fc x and fv   fc x   to simplify the notation  we will for a node v in a branch
decomposition and a set c of clauses denote by c v the set c var fv     we define the ps value
of the cut  v  to be
ps  v     max  p s fv      p s fv    
we define the ps width of a branch decomposition to be
psw t      max ps  v     v is a node of t  
we define the ps width of a formula f to be
psw f     min psw t       t    is a branch decomposition of f  
  

fisolving  sat and maxsat by dynamic programming

v
x 
x  c  x  c 
x 

x 

c 

c
c     x    x   
c     x    x    x   

c 
fc x   fv

x

fc x

fc x

x  x 

x  x 
x 

fc x   fv

c     x    x    x   
c     x    x    x   

x

c

figure    on top is a branch decomposition of a formula f with var f      x    x    x    x    x   
and the   clauses cla f      c    c    c    c    as given in the boxes  the node
v of the tree defines the cut  v    c  x where c    c    c    and x  
 x    x     there are   subformulas defined by this cut  fc x   fc x   fc x   fc x  
for example  fc x     x    x      x     and fc x       x    x      we have
fv   fc x and fv   fc x with projection satisfiable sets of clauses ps fv    
  c   v     c   v     c   v   c   v    and ps fv         c   v    and the ps value of this cut
is ps  v     max  p s fv      p s fv         

note that the ps value of a cut is a symmetric function  that is  the ps value of cut s
equals the ps value of the cut s  see figure   for an example 

   dynamic programming for maxsat and  sat
given a branch decomposition  t    of a cnf formula f over n variables and m clauses
and of total size s  we will give algorithms that solve maxsat and  sat on f in time
o psw t     m m   n    our algorithms are strongly inspired by the work of slivovsky and
szeider         but in order to achieve a runtime polynomial in ps width  and also to solve
maxsat  we must make some crucial changes  in particular  we must index the dynamic
progranming tables by ps sets rather than the shapes used in the work of slivovsky and
szeider        
let us discuss some special terminology to be used in this section  in this dynamic
programming section  we will combine partial solutions to subformulas into solutions for
the input formula f   to improve readability we introduce notation p s   and sat  that
allows us to refer directly to the clauses of f   also when working on the subformulas 
  

fisther  telle   vatshelle

thus  for a formula f and branch decomposition  t     for each node v in t   and induced
subformula fv of f   by ps   fv   we denote the subsets of clauses c from cla f      v  so
that ps fv     c var fv     similarly  for an assignment  over var fv    by sat   fv      we
denote the set of clauses c from cla f      v  so that sat fv        c var fv     note that
 ps   fv       ps fv    and  sat   fv          sat fv        we take the liberty to call also these
sets projection satisfiable and refer to them as ps sets in the text  but it will be clear from
context that we mean clauses of cla f   and not cla fv   
let us discuss some implementation details  we regard ps sets as boolean vectors of
length  cla f     and assume we can identify clauses and variables by integer numbers  so 
checking if a clause is in a ps set can be done in constant time  and checking if two ps sets
are equal can be done in o  cla f     time  to manage our ps sets  we use a binary trie
datastructure  fredkin         we can add and retrieve a ps set to and from a trie in
o  cla f     time  trying to add a ps set to a trie already containing an equivalent ps set
will not alter the content of the trie  so our tries will only contain distinct ps sets  as
retrieval of an element in our trie takes o  cla f     time  by assigning a distinct integer
to each ps set at the time it is added to the trie  we have a o  cla f     time mapping
from ps sets to distinct integers  this will be used implicitly in our algorithms when we
say we index by ps sets  when implementing the algorithm we will instead index by the
corresponding integer the ps set is mapped to 
in a pre processing step we will need the following which  for each node v in t computes
the sets of projection satisfiable subsets of clauses ps   fv   and ps   fv   of the two crossing
subformulas fv and fv  
theorem    given a cnf formula f with a branch decomposition  t    of ps width k  we
can in time o k   m m   n   compute the sets ps   fv   and ps   fv   for each v in t  

proof  we notice that for a node v in t with children c  and c    we can express ps   fv   as


c   ps   fc     and
 
ps  fv      c   c     cla fv    
 
c   ps   fc   

similarly  for sibling s and parent p of v in t   the set ps   fv   can be expressed as


cp  ps   fp    and
 
ps  fv      cp  cs    cla fv    
 
cs  ps   fs  
by transforming these recursive expressions into a dynamic programming algorithm  as
done in procedure   and procedure   below  we are able to calculate all the desired sets as
long as we can compute the sets for the base cases ps   fl   when l is a leaf of t   and ps   fr  
for the root r of t   however  these formulas contain at most one variable  and thus we can
easily construct their set of projection satisfiable clauses in linear amount of time for each
of the formulas  for the rest of the formulas  we construct the formulas using procedure  
and procedure    as there are at most twice as many nodes in t as there are clauses and
variables in f   the procedures will run at most o  cla f       var f     times  in each run
of the algorithms  we iterate through at most k   pairs of projection satisfiable sets  and do a
constant number of set operations that might take o  cla f     time each  this results in a
total runtime of o k    cla f     cla f       var f        o k   m m   n   for all the nodes of
t combined 
  

fisolving  sat and maxsat by dynamic programming

procedure    generating ps   fv  
input  ps   fc    and ps   fc    for children c  and c  of v
in branch decomposition
output  ps   fv  
l  empty trie of projection satisfiable clause sets
for each  c    c     ps   fc     ps   fc    do
add  c   c     cla fv   to l
return l
procedure    generating ps   fv  
input  ps   fs   and ps   fp   for sibling s and parent p of v
in branch decomposition
output  ps   fv  
l  empty trie of projection satisfiable clause sets
for each  cs   cp    ps   fs    ps   fp   do
add  cs  cp    cla fv   to l
return l
we now move on to the dynamic programming proper  we first give the algorithm for
maxsat and then briefly describe the changes necessary for solving weighted maxsat
and  sat 
our algorithm uses the technique of expectation introduced in the work of bui xuan 
telle  and vatshelle               some partial solutions might be good when combined
with certain partial solutions  but bad when combined with others  in the technique of
expectation we categorize how partial solutions can interact  and then optimize our selection
of partial solutions based on the expectation that this interaction occurs  in our dynamic
programming algorithm for maxsat  we apply this technique by making expectations on
each cut regarding what set of clauses will be satisfied by variables of the opposide side of
the cut 
for a node v in the decomposition of f and ps sets c  ps   fv   and c    ps   fv    we
say that an assignment  of var f   meets the expectation c and c   if sat   fv     v     c
and sat   fv     v     c     for each node v of the branch decomposition  our algorithm uses a
table tabv that for each pair  c  c      ps   fv    ps   fv   stores in tabv  c  c     the maximum
number of clauses in  v  that are satisfied  over all assignments meeting the expectation
of c and c     as the variables in var f      v  satisfy exactly c     for any assignment that
meets this expectation  an equivalent formulation of the content of tabv  c  c     is that it
must satisfy the following constraint 
over all assignments  of var f     v  such that sat   fv        c  
fi 
fi

tabv  c  c       max fi sat   f         v   c   fi

   



by bottom up dynamic programming along the tree t we compute the tables of each
node of t   for a leaf l in t   generating tabl can be done easily in linear time since the
formula fv contains at most one variable  for an internal node v of t   with children c    c   
  

fisther  telle   vatshelle

we compute tabv by the algorithm described in procedure    there are   tables involved in
this update  one at each child and one at the parent  a pair of entries  one from each child
table  may lead to an update of an entry in the parent table  each table entry is indexed by
a pair  thus there are   indices involved in a single potential update  a trick first introduced
in the work of bui xuan et al         allows us to loop over triples of indices and for each
triple compute the remaining   indices forming the   tuple involved in the update  thereby
reducing the runtime 
procedure    computing tabv for inner node v with children c    c 
input  tabc    tabc 
output  tabv
   initialize tabv   ps   fv    ps   fv       
   for each  cc    cc    cv    in ps   fc     ps   fc     ps   fv   do
  
cc      cc   cv      c   
  
cc      cc   cv      c   
  
cv   cc   cc       v 
  
t  tabc   cc    cc        tabc   cc    cc     
  
if tabv  cv   cv      t then tabv  cv   cv     t
   return tabv
lemma    for a cnf formula f of m clauses and an inner node v  of a branch decomposition  t    of ps width k  procedure   computes tabv satisfying constraint     in time
o k   m  
proof  we assume tabc  and tabc  satisfy constraint      procedure   loops over all triples
in ps   fc     ps   fc     ps   fv    from the definition of ps width of  t    there are at most
k   such triples  each operation inside an iteration of the loop take o m  time and there is
a constant number of such operations  thus the runtime is o k   m  
before we show the correctness of the output  let us look a bit at the workings of
procedure    for any assignment  over var f    and cut  the assignment  will only meet
the expectation of a single pair of ps sets  let  x    x       x    x     and  xv   xv    be the pairs
an assignment  meets the expectation for with respect to the cuts induced by c    c    and v 
respectively  we notice that
xv   sat   fv     v  

  sat   fv     c      c   

  sat   fv     c     sat   fv     c   

   sat   fc      c       v     sat   fc      c       v  

   

   x     v     x     v  
   x   x       v  

this can also be seen from figure    by symmetry  we find similar values for x   and x    
namely x      x   xv      c    and x      x   xv      c     so  these latter three sets
will be implicit based on the three former sets with respect to the cuts induced by v  c 
and c    we will therefore  for convenience of this proof  say that an assignment  meets the
  

fisolving  sat and maxsat by dynamic programming

  x    sat  fc      c   

clauses in cla f      v 

  x    sat  fc      c   
  xv   sat  fv     v  

clauses in  c   

clauses in  c   

figure    as shown by the chain of equalities in     in the proof of lemma    the clauses in
sat   fv     v   are precisely the clauses in  sat   fc      c     sat   fc      c        v  
expectation of a triple  c    c    c     of ps sets  when  meets the expectation of the implicit
three pairs on each of their respective cuts  we notice that for each choice of triples of
ps sets  cc    cc    cv    procedure   computes the implicit three other sets and names them
cc      cc    and cv accordingly 
we will now show that for all pairs  c  c      ps   fv    ps   fv   the value of tabv  c  c    
is correct  let   be an assignment over var f   that satisfies the maximum number of
clauses  while meeting the expectation of c and c     thus  the value of tabv  c  c     is correct
if and only if it stores exactly the number of clauses from  v  that   satisfies 
let  c    c     and  c    c     be the pairs of ps sets that   meet the expectation of for the
cut   c      c     and   c      c      respectively  as   meets these expectations  the value
of tabc   c    c     and tabc   c    c     must be at least as large as the number of clauses  
satisfies in  c    and  c     respectively  thus  the number of clauses   satisfies in both
 c    and  c    is at most as large as the sum of these two entries  since procedure    in
the iteration where cv    c     cc    c  and cc    c    ensures that tabv  c  c     is at least
the sum of tabc   c    c     and tabc   c    c      we know tabv  c  c     is at least as large as the
correct value 
now assume for contradiction that the value of the cell tabv  c  c     is too large  that
means that at some iteration of procedure   it is being assigned the value tabc   cc    cc       
tabc   cc    cc      when this sum is too large  let   and   be the assignments of var f  
meeting the expectation of cc  and cc    and meeting the expectation of cc    cc      respectively 
where the number of clauses of  c    and  c     respectively  equals the according table
entries of tabc  and tabc    if we now take the assignment x      c       c       v   we have
an assignment that meets the expectation of c and c     and who satisfies more clauses in
 v  than     contradicting the choice of     so tabv  c  c     can be neither smaller nor larger
than the number of clauses in  v    satisfies  so it is exactly the same 
theorem    given a formula f over n variables and m clauses  and a branch decomposition
 t    of f of ps width k  we solve maxsat   sat  and weighted maxsat in time
o k   m m   n   
proof  to solve maxsat  we first compute tabr for the root node r of t   this requires
that we first compute ps   fv   and ps   fv   for all nodes v of t   and then  in a bottom up
manner  compute tabv for each of the o m   n  nodes in t   the former part we can do in
  

fisther  telle   vatshelle

o k   m m   n   time by theorem    and the latter part we do in o k   m m   n   time by
lemma   
at the root r of t we have  r    var f    cla f    thus fr    and fr does not have
any variables  so that p s fr    p s fr   contains only       as all assignments over var f  
meet the expectation of  and  on the cut   r    r    and cla f     r    cla f    by
constraint     the value of tabr      is the maximal number of clauses in f any assignment
of var f   satisfies  and hence  this number is the solution to maxsat 
for a weight function w   cla f    n  by redefining constraint     for tabv to maximize
w sat   f       v   instead of  sat   f      v    we are able to solve the more general
problem weighted maxsat in the same way 
for the problem  sat  we care only about assignments satisfying all the clauses of
f   and we want to decide the number of distinct assignments doing so  this requires a
few alterations  firstly  alter the definition of the contents of tabv  c  c     in constraint
    to be the number of assignments  over var f     v  where sat   fv        c and all
clauses in  v  is either in c   or satisfied by    secondly  when computing tabl for the
leaves l of t   we set each of the entries of tabl to either zero  one  or two  according to the
definition  thirdly  we alter the algorithm to compute tabv  procedure    for inner nodes 
we initialize tabv  c  c     to be zero at the start of the algorithm  and substitute lines   and
  of procedure   by the following line which increases the table value by the product of the
table values at the children
tabv  cv   cv    tabv  cv   cv     tabc   cc    cc     tabc   cc    cc   
this will satisfy our new constraint of tabv for internal nodes v of t   the value of tabr     
at the root r of t will be exactly the number of distinct assignments satisfying all clauses of
f 
the bottleneck giving the cubic factor k   in the runtime of theorem   is the number
triples in ps   fv    ps   fc     ps   fc    for any node v with children c  and c    when  t    is
a linear branch decomposition  it is always the case that either c  or c  is a leaf of t   in this
case either  ps   fc     or  ps   fc     is a constant  therefore  for linear branch decompositions
ps   fv    ps   fc     ps   fc    will contain no more than o k     triples  thus we can reduce
the runtime of the algorithm by a factor of k 
theorem    given a formula f over n variables and m clauses  and a linear branch
decomposition  t    of f of ps width k  we solve  sat  maxsat  and weighted maxsat
in time o k   m m   n   

   cnf formulas of polynomial ps width
in this section we investigate classes of cnf formulas having decompositions with ps width
polynomially bounded in the total size s of the formula  in particular  we show that this
holds whenever the incidence graph of the formula has constant mim width  maximum
induced matching width  introduced in vatshelle         we also show that a large class of
bipartite graphs  using what we call bigraph bipartizations  have constant mim width 
  

fisolving  sat and maxsat by dynamic programming

in order to lift the upper bound of lemma   on the ps value of f   i e  ps f     to the
ps width of f   we use mim width of the incidence graph i f    which is defined using branch
decompositions of graphs  a branch decomposition of the formula f   as defined in section
   can also be seen as a branch decomposition of the incidence graph i f    nevertheless  for
completeness  we formally define branch decompositions of graphs and mim width 
a branch decomposition of a graph g is a pair  t    where t is a rooted binary tree
and  a bijection between the leaf set of t and the vertex set of g  for a node w of t
let the subset of v  g  in bijection  with the leaves of the subtree of t rooted at w be
denoted by vw   we say the decomposition defines the cut  vw   vw    the mim value of a cut
 vw   vw   is the size of a maximum induced matching of g vw   vw    the mim width of  t   
is the maximum mim value over all cuts  vw   vw   defined by a node w of t   the mim width
of graph g  denoted mimw g   is the minimum mim width over all branch decompositions
 t    of g  as before a linear branch decomposition is a branch decomposition where inner
nodes of the underlying tree induces a path 
since a decomposition of i f   of can be seen also as a decomposition of f   we immediately
get from lemma   the following corollary 
corollary    for any cnf formula f over m clauses  with no clause containing more than
t literals  the ps width of f is at most min mk       tk   for k   mimw i f    
many classes of graphs have intersection models  meaning that they can be represented
as intersection graphs of certain objects  i e  each vertex is associated with an object and
two vertices are adjacent iff their objects intersect  the objects used to define intersection
graphs usually consist of geometrical objects such as lines  circles or polygons  many well
known classes of intersection graphs have constant mim width  as in the following which
lists only a subset of the classes proven to have such bounds  belmonte   vatshelle       
vatshelle        
theorem     belmonte   vatshelle        vatshelle        let g be a graph  if g is a 
interval graph then mimw g     
circular arc graph then mimw g     
k trapezoid graph then mimw g   k 
moreover there exist linear decompositions satisfying the bound  that can be found in polynomial time  for k trapezoid assume the intersection model is given  
let us briefly mention the definition of these graph classes  a graph is an interval graph
if it has an intersection model consisting of intervals of the real line  a graph is a circular arc
graph if it has an intersection model consisting of arcs of a circle  to build a k trapezoid we
start with k parallel line segments  s    e      s    e           sk   ek   and add two non intersecting
paths s and e by joining si to si   and ei to ei   respectively by straight lines for each
i           k      the polygon defined by s and e and the two line segments  s    e      sk   ek  
forms a k trapezoid  a graph is a k trapezoid graph if it has an intersection model consisting
of k trapezoids  see the work of brandstadt  le  and spinrad        for information about
graph classes and their containment relations 
combining corollary   and theorem   we get the following
corollary    let f be a cnf formula containing m clauses with maximum clause size t 
if i f   is a 
  

fisther  telle   vatshelle

interval graph then psw f    min m       t   
circular arc graph then psw f    min m        t   
k trapezoid graph then psw f    min mk       tk   
moreover there exist linear decompositions satisfying the bound  that can be found in polynomial time  for k trapezoid assume the intersection model is given  
the incidence graphs of formulas are bipartite graphs  which is not the case for the
majority of graphs in the above mentioned graph classes  in the following we show how to
extend the results of corollary   to large classes of bipartite graphs  for a graph g and
subset of vertices a  v  g  the bipartite graph g a  a  is the subgraph of g containing all
edges of g with exactly one endpoint in a  for any graph g and a  v  g  we call g a  a 
a bigraph bipartization of g  and note that g has a bigraph bipartization for each subset of
vertices  for a graph class x we define the class of x bigraphs as the bipartite graphs h for
which there exists g  x such that h is isomorphic to a bigraph bipartization of g  for
example  a bipartite graph h is an interval bigraph if there is some interval graph g and
some a  v  g  with h isomorphic to g a  a  
the following result will allow us to lift the results of corollary   from the given graphs
to the bigraph bipartizations of the same graphs 
theorem    assume that we are given a cnf formula f of m clauses and maximum
clause size t  a graph g  a subset a  v  g   and  t  g   a  linear  branch decomposition
of g of mim width k  if i f   is connected and isomorphic to g a  a   thus i f   a bigraph
bipartization of g  then we can in linear time produce a  linear  branch decomposition  t  f  
of f having ps width at most min mk       tk  
proof  since each variable and clause in f has a corresponding node in i f    and each node
in i f   has a corresponding node in g  by defining f to be the function mapping each leaf
l of t to the variable or clause in f corresponding to the node g  l   we get that  t  f   is
a branch decomposition of f   consider a cut  b  b  induced by a node of  t  f    note
that the mim value of g b  b  is at most k  i f   is connected which means that we have
either a or a corresponding to the set of variables of f   assume wlog the former  thus
c   a  b  cla f   are the clauses in b  with c   cla f     c and x   a  b  var f  
are the variables in b  with x   var f     x  the mim values of g c  x  and g c  x  are
at most k  since these are induced subgraphs of g b  b   and taking induced subgraphs
cannot increase the size of the maximum induced matching  hence by lemma    we have
 ps fc x      cla f   k      and likewise we have  ps fc x      cla f   k      with the
maximum of these two being the ps value of this cut  since the ps width of the decomposition
is the maximum ps value of each cut the theorem follows 
combining theorems   and   we immediately get the following 
corollary    let f be a cnf formula containing m clauses with maximum clause size t 
if i f   is a 
interval bigraph then psw f    min m       t   
circular arc bigraph then psw f    min m        t   
k trapezoid bigraph then psw f    min mk       tk   
moreover there exist linear decompositions satisfying the bound 
  

fisolving  sat and maxsat by dynamic programming

in the next section we address the question of finding such linear decompositions in
polynomial time  we succeed in the case of interval bigraphs  but for circular arc bigraphs
and k trapezoid bigraphs we must leave this as an open problem 

   interval bigraphs and formulas having interval orders
we will in this section show that for formulas whose incidence graph is an interval bigraph
we can in polynomial time find linear branch decompositions having small ps width  let
us recall the definition of interval ordering  a cnf formula f has an interval ordering if
there exists a linear ordering of variables and clauses such that for any variable x occurring
in clause c  if x appears before c then any variable between them also occurs in c  and
if c appears before x then x occurs also in any clause between them  see figure   for an
example 
order 
x  c   x  x  c   c   x  x 

clauses 

bipartized interval rep 

incidence graph

x 
c 
x 
x 
c 
c 
x 
x 

c     x    x   
c     x    x    x   
c     x    x    x   

c 

x 

c  c 

x  x 

x  x 

figure    a cnf formula having an interval ordering  its incidence graph is an interval
bigraph  since it is isomorphic to the bigraph bipartization  defined by the blue
intervals  of the interval graph with intersection model on the left 
from the work of hell and huang        it follows that a formula f has an interval ordering
if and only if i f   is a interval bigraph 
theorem    given a cnf formula f over n variables and m clauses each of at most t
literals  in time o  m   n mn  we can decide if f has an interval ordering  yes iff i f   is
an interval bigraph   and if yes we solve  sat and weighted maxsat with an additional
runtime of o min m     t   m   n m  
proof  using the characterization in the work of hell and huang        and the algorithm
of rafiey        we can in time o  m   n mn  decide if f has an interval ordering and if
yes  then we find it  from this interval ordering we build an interval graph g such that i f  
is a bigraph bipartization of g  and construct a linear branch decomposition of g having
mim width    belmonte   vatshelle         from such a linear branch decomposition we
  

fisther  telle   vatshelle

get from theorem   that we can construct another linear branch decomposition of f having
ps width o m   we then run the algorithm of theorem   

   experimental results
we present some simple experimental results  intended as proof of concept  it is our belief
that some of the ideas behind our algorithms  like the notion of ps value  are useful in
practice  but it will require a thorough investigation to confirm such a belief  our results
indicate that the worst case runtime bounds of the dynamic programming  theorems   and
   are probably higher than what would commonly be seen in practice 
in the past decade  sat solvers have become very powerful  and are currently able
to handle very large practical instances  techniques from these sat solvers have been
applied to develop relatively powerful maxsat and  sat solvers  biere  heule    van
maaren         in our experiments we compare implementations of our algorithms against
state of the art maxsat and  sat solvers  we do not enhance our implementations with
any other techniques  not even simple pre processing  and on the vast majority of instances
our implementations fall far behind in a comparison  however  when focusing on formulas
with a certain linear order our implementations compare favorably 
as explained in section    there are two steps involved      find a good decomposition
of the input cnf formula f   and     perform dp  dynamic programming  along the
decomposition  let us start by describing a very simple heuristic for step      it takes
as input the bipartite graph i f   with vertex set cla f    var f    and outputs a linear
order  on the vertex set  the below heuristic greedyorder is a greedy algorithm that
for increasing values of i chooses  i  to be a vertex having the highest number of already
chosen neighbors  and among these choosing one with fewest non chosen neighbors  this
defines a linear branch decomposition  t    of the cnf formula f   with non leaf nodes
of the binary tree t inducing a path  with t rooted at one end of this path  and with 
mapping the ith leaf encountered by a breadth first search starting at the root of t to the
clause or variable  i   for all    i   cla f    var f    

algorithm greedyorder
input  g    v  e   a  bipartite  graph
output    a linear ordering of v
l     r   v   i    
for all v  v set ldegree v     
while r is not empty do
choose v  from vertices in r with max ldegree take one of smallest degree
set  i    v  increment i  add v to l and remove v from r
for all w  r with vw  e increment ldegree w 

  

fisolving  sat and maxsat by dynamic programming

all our implementations can be found online  sther  telle    vatshelle         we
have implemented greedyorder in java  together with a straight forward implementation of
the dp algorithm of theorem   
given a cnf formula  this allows us to solve maxsat and  sat by first running
greedyorder and then the dp  we compare our implementation to the best solvers we could
find online  respectively ccls to akmaxsat  luo  cai  wu  jie    su        which was
among the best solvers of the ninth max sat evaluation         and the latest version of
the  sat solver called sharpsat  thurley  n d          these solvers handily beat our
implementation on most inputs  we have therefore generated some cnf formulas having
interval orderings  as in theorem    to check if at least on these instances we do better 
note that for step     we have not implemented the polynomial time algorithm recognizing
formulas having interval orders  relying instead on the greedyorder heuristic 
    generation of instances
before presenting our results  let us describe the generation of the set of instances  which
are of three types  we start with type    the generation of these formulas is based on the
definition of interval orderings given by the interval bigraph definition  see e g  the left side
of figure    to generate a formula of type   with n variables and m clauses  we generate
n   m intervals of the real line by iterating through points i from   to   n   m  as left and
right endpoints of the intervals 
 at step i  check which of the   cases below are legal  e g    is legal if there exists a
live variable  i e  with left endpoint   i and no right endpoint  and randomly make
one of those legal choices 
   start interval of new variable with left endpoint i
   start interval of new clause with left endpoint i
   end interval of randomly chosen live variable by right endpoint i
   end interval of randomly chosen live clause by right endpoint i
towards the end of the process boundary conditions are enforced to reach exactly m
clauses  with n expected to be slightly smaller than m  for each clause interval we randomly
choose each variable having overlapping interval as being either positive or negative in this
clause  the resulting cnf formula will have an interval ordering given by the rightmost
endpoints of intervals  to hide this ordering the clauses and variables are randomly permuted
to make the final cnf formula 
the formulas of type   are generated in a very similar fashion as type    except we
guarantee that all clauses have the same size t  which by lemma   could be of big help  the
only change is to case   above which instead of being a choice becomes enforced for a live
clause that at step i has accumulated exactly t overlapping variable intervals  we also let
each clause interval represent   clauses over the same variable set but on randomly chosen
literals  at the aim of increasing the probability of each instance not being satisfiable 
the formulas of type   are the cnf representation of a conjunction of xor functions
where each xor has a fixed number t of literals and the variables of the xor functions
  

fisther  telle   vatshelle

overlap in such a way that the incidence graph will be the bipartization of a circular arc
graph 
a formula of type   is generated from three input parameters n  t  s  it has n variables
represented by successive points   to n on the circle  the first xor function has interval
from   to t thus containing variables with points   to t  the second has interval s     to s   t 
and in general the ith has interval i  s     to i  s   t  with appropriate modulo addition
and some boundary condition at the end to ensure n s xor functions  variables are chosen
randomly to appear positive or negative in each xor  each xor is then transformed in
the standard way to a cnf formula with  t  clauses to give us a resulting cnf formula
with n s   t  clauses  again  variables and clauses are randomly permuted to hide the
ordering giving the circular arc bigraph representation 
note that all the resulting formulas have a quite simple structure  and that a state ofthe art sat solver  like lingeling  biere         handles all generated instances within a
few seconds 
    results
we are now ready to present our results  we ran all the solvers on a dell optiplex    
running ubuntu          bit  the machine has  gb of memory and an intel core   quad
q     processor with openjdk java    icedtea          
for instances of type   the greedyorder heuristic fails terribly and becomes a huge
bottleneck  the greedy choice based on degrees of vertices in i f   is too simple  however 
when given the correct interval order to our solver s  they performed better 
instances of type   are generated similar to those of type   but all clauses have small size 
which by lemma   could be of help  in this case the number of clauses is approximately

runtime in seconds

   

   

ccls
sharpsat
our maxsat
and  sat
 practically equal 

   

 
 

    
    
number of variables

    

figure    runtimes of instances of type    here our maxsat solver is clearly faster than
ccls to akmaxsat  the vertical axis represents time in seconds  runs taking
more than     seconds were stopped before completion and are drawn on the
dotted line 

  

fisolving  sat and maxsat by dynamic programming

four times the number of variables  and as a consequence a great number of the instances
were not satisfiable  making the work of the  sat solvers easier than that of the maxsat
solvers  all generated instances of type   were solved within seconds by sharpsat  see
figure    as the size of the instances grow  we see a clear tendency for the runtimes of
ccls to akmaxsat to increase much more rapidly than both our solvers  the runtimes of
our two solvers were almost identical  the greedyorder heuristic on these instances seems
to produce decompositions orders of low ps width 
the type   instances shown in figure   were generated with k     and s      all
instances are satisfiable  which may explain why ccls to akmaxsat is very fast  choosing
k     and s     there will be some not satisfiable instances and ccls to akmaxsat would
then often spend more than     seconds and time out  as the size of the instances grow  we
see a clear tendency for the runtimes of sharpsat to increase much more rapidly than our
solvers  the runtimes of our two solvers were almost identical 

runtime in seconds

   

   

ccls
sharpsat
our maxsat
and  sat
 practically equal 

   

 
  

  
   
   
number of variables

   

figure    runtimes of instances of type    here our  sat solver is clearly faster than
sharpsat  the vertical axis represents time in seconds  runs taking more than
    seconds were stopped before completion and are drawn on the dotted line 

   conclusion
in this paper we have proposed a structural parameter of cnf formulas  called ps width
or projection satisfiable width  we showed that weighted maxsat and  sat can be
solved in polynomial time if given a decomposition of the formula of polynomially bounded
ps width  using the concept of interval bigraphs we also showed a polynomial time algorithm
that actually finds such a decomposition  for formulas having an interval ordering  could
one devise such an algorithm also for the larger class of circular arc bigraphs  or maybe
even for the even larger class of k trapezoid bigraphs  in other words  is the problem of
recognizing if a bipartite input graph is a circular arc bigraph  or a k trapezoid bigraph 
polynomial time solvable 
  

fisther  telle   vatshelle

it could be of practical interest to design a heuristic algorithm which given a formula finds
a decomposition of relatively low ps width  as has been done for boolean width  hvidevold 
sharmin  telle    vatshelle         one could then check if benchmarks covering real world
sat instances have low ps width  and perform a study on the correlation between low
ps width and their practical hardness by maxsat and  sat solvers  as has been done
for treewidth and sat solvers  mateescu         we presented some simple experimental
results  but it will require a thorough investigation to check if ideas from our algorithms
could be useful in practice  finally  we hope the essential combinatorial result enabling the
improvements in this paper  lemma    may have other uses as well 

references
bacchus  f   dalmao  s     pitassi  t          algorithms and complexity results for sat
and bayesian inference  in foundations of computer science        proceedings    th
annual ieee symposium on  pp          
belmonte  r     vatshelle  m          graph classes with structured neighborhoods and
algorithmic applications  theor  comput  sci               
biere  a          yet another local search solver and lingeling and friends entering the sat
competition       sat competition           
biere  a   heule  m     van maaren  h          handbook of satisfiability  in  vol      
chap       ios press 
brandstadt  a   le  v  b     spinrad  j  p          graph classes  a survey  vol     
philadelphia  siam society for industrial and applied mathematics 
brandstadt  a     lozin  v  v          on the linear structure and clique width of bipartite
permutation graphs  ars comb       
brault baron  j   capelli  f     mengel  s          understanding model counting for
 acyclic cnf formulas  corr  abs             retrieved from http   arxiv org 
abs          
bui xuan  b  m   telle  j  a     vatshelle  m          h join decomposable graphs and
algorithms with runtime single exponential in rankwidth  discrete applied mathematics 
                 
bui xuan  b  m   telle  j  a     vatshelle  m          boolean width of graphs  theoretical
computer science                     
courcelle  b          clique width of countable graphs  a compactness property  discrete
mathematics                     retrieved from http   dx doi org         s    
    x            doi          s        x           
darwiche  a          recursive conditioning  artificial intelligence               
fischer  e   makowsky  j  a     ravve  e  v          counting truth assignments of
formulas of bounded tree width or clique width  discrete applied mathematics          
        
  

fisolving  sat and maxsat by dynamic programming

fredkin  e          trie memory  communications of the acm                 
ganian  r   hlineny  p     obdrzalek  j          better algorithms for satisfiability problems
for formulas of bounded rank width  fundam  inform                  
garey  m  r     johnson  d  s          computers and intractability  a guide to the theory
of np completeness  w  h  freeman 
hell  p     huang  j          interval bigraphs and circular arc graphs  journal of graph
theory                  
hvidevold  e  m   sharmin  s   telle  j  a     vatshelle  m          finding good
decompositions for dynamic programming on dense graphs  in d  marx   p  rossmanith
 eds    ipec  vol        p            springer 
jaumard  b     simeone  b          on the complexity of the maximum satisfiability
problem for horn formulas  inf  process  lett               
kaski  p   koivisto  m     nederlof  j          homomorphic hashing for sparse coefficient
extraction  in proceedings of the  th international conference on parameterized and
exact computation  pp          
luo  c   cai  s   wu  w   jie  z     su  k          ccls  an efficient local search
algorithm for weighted maximum satisfiability  ieee transactions on computers  doi 
        tc             
mateescu  r          treewidth in industrial sat benchmarks  tech  rep    tech  rep 
cambridge  uk  microsoft research  retrieved from http   research microsoft
 com pubs        msr tr         pdf
muller  h          recognizing interval digraphs and interval bigraphs in polynomial time 
discrete applied mathematics                    
ninth max sat evaluation          retrieved from http   www maxsat udl cat    
 accessed    january      
paulusma  d   slivovsky  f     szeider  s          model counting for cnf formulas of
bounded modular treewidth  in n  portier   t  wilke  eds    stacs  vol      p         
schloss dagstuhl   leibniz zentrum fuer informatik 
rafiey  a         
abs            

recognizing interval bigraphs by forbidden patterns 

corr 

raman  v   ravikumar  b     rao  s  s          a simplified np complete maxsat
problem  inf  process  lett               
rao  m          clique width of graphs defined by one vertex extensions  discrete
mathematics                     
robertson  n     seymour  p  d          graph minors x  obstructions to tree decomposition 
j  combin  theory ser  b                  
roth  d          a connectionist framework for reasoning  reasoning with examples  in

  

fisther  telle   vatshelle

w  j  clancey   d  s  weld  eds    aaai iaai  vol     p              aaai press  
the mit press 
sther  s  h   telle  j  a     vatshelle  m          solving maxsat and  sat on
structured cnf formulas  in c  sinz   u  egly  eds    sat       vol        pp    
     springer  retrieved from http   dx doi org                            
doi                             
sther  s  h   telle  j  a     vatshelle  m          online implementations  retrieved from
http   people uib no ssa    pswidth 
samer  m     szeider  s          algorithms for propositional model counting  j  discrete
algorithms               
slivovsky  f     szeider  s          model counting for formulas of bounded clique width  in
l  cai  s  w  cheng    t  w  lam  eds    isaac  vol        p            springer 
szeider  s          on fixed parameter tractable parameterizations of sat  in e  giunchiglia
  a  tacchella  eds    sat       vol        p            springer 
thurley  m   n d    sharpsat  retrieved from https   sites google com site 
marcthurley sharpsat  accessed    january      
thurley  m          sharpsatcounting models with advanced component caching and
implicit bcp  in theory and applications of satisfiability testing sat       pp          
springer 
vatshelle  m          new width parameters of graphs  unpublished doctoral dissertation 
the university of bergen 

  

fi