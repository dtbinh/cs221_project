journal artificial intelligence research                  

submitted        published      

pagoda  pay as you go ontology query answering
using datalog reasoner
yujiao zhou
bernardo cuenca grau
yavor nenov
mark kaminski
ian horrocks

yujiao zhou cs ox ac uk
bernardo cuenca grau cs ox ac uk
yavor nenov cs ox ac uk
mark kaminski cs ox ac uk
ian horrocks cs ox ac uk

department computer science  university oxford
parks road  oxford ox   qd  united kingdom

abstract
answering conjunctive queries ontology enriched datasets core reasoning task
many applications  query answering is  however  computationally expensive 
led development query answering procedures sacrifice either expressive
power ontology language  completeness query answers order improve
scalability  paper  describe hybrid approach query answering owl  
ontologies combines datalog reasoner fully fledged owl   reasoner order
provide scalable pay as you go performance  key feature approach
delegates bulk computation datalog reasoner resorts expensive
owl   reasoning necessary fully answer query  furthermore  although
main goal efficiently answer queries owl   ontologies data  technical
results general approach applicable first order knowledge representation languages captured rules allowing existential quantification
disjunction head  assumption availability datalog reasoner
fully fledged reasoner language interest  used black boxes 
implemented techniques pagoda system  combines datalog
reasoner rdfox owl   reasoner hermit  extensive evaluation shows
pagoda succeeds providing scalable pay as you go query answering wide range
owl   ontologies  datasets queries 

   introduction
ontologies increasingly used rich conceptual schemas wide range application
domains  staab   studer         one widely used ontology languages owl 
description logic based language standardised world wide web consortium
 w c       revised  as owl          baader  calvanese  mcguinness  nardi 
  patel schneider        horrocks  patel schneider    van harmelen        cuenca grau 
horrocks  motik  parsia  patel schneider    sattler         owl ontology consists
set axioms  correspond first order sentences containing unary binary
predicates  called classes properties owl   structure axioms sentences
restricted ensure decidability basic reasoning problems 
applications  main focus conceptual model itself  class subsumption key reasoning problem  increasing number applications  however 
main focus using conceptual model access data  often form rdf
c      ai access foundation  rights reserved 

fizhou  cuenca grau  nenov  kaminski    horrocks

graph  manola   miller         data centric applications key reasoning problem
answer conjunctive queries  cqs sentences constructed function free atoms using
conjunction existential quantification  abiteboul  hull    vianu       which
constitute core component standard query languages sql sparql
 w c sparql working group        
conjunctive query answering ontology enriched datasets is  however  high worstcase complexity  glimm  lutz  horrocks    sattler        eiter  ortiz    simkus        
even measured respect size data  so called data complexity  
although heavily optimised  existing systems query answering respect  rdf 
data unrestricted owl   ontology process small medium size datasets
 sirin  parsia  cuenca grau  kalyanpur    katz        moller  neuenstadt  ozcep   
wandelt        wandelt  moller    wessel        kollia   glimm         led
development query answering procedures sacrifice expressive power
ontology language completeness query answers order improve scalability 
former case  sacrificing expressive power   query answering procedures
developed various fragments owl   conjunctive query answering tractable
respect data complexity  three fragments standardised so called
profiles owl    motik  cuenca grau  horrocks  wu  fokoue    lutz         owl  
ql owl   el profiles based dl lite  calvanese  de giacomo  lembo 
lenzerini    rosati        el  baader  brandt    lutz        families description
logics  owl   rl profile corresponds fragment rule based language datalog
 grosof  horrocks  volz    decker        dantsin  eiter  gottlob    voronkov        
conjunctive query answering systems profiles shown highly scalable
practice  bishop  kiryakov  ognyano  peikov  tashev    velkov        wu  eadon  das 
chong  kolovski  annamalai    srinivasan        motik  nenov  piro  horrocks    olteanu 
      erling   mikhailov        rodriguez muro   calvanese        lutz  seylan  toman 
  wolter        stefanoni  motik    horrocks         favourable computational
properties fragments make natural choice data intensive applications 
come expense loss expressive power  many ontologies used
applications captured profiles 
latter case  sacrificing completeness   query answering procedures
developed exploit scalable reasoning techniques  expense computing
approximate query answers  thomas  pan    ren        tserendorj  rudolph  krotzsch 
  hitzler        wandelt et al         bishop et al          cases  computed
answers sound  only correct answer tuples identified  incomplete  some correct
answer tuples may identified   one way realise procedure weaken
ontology falls within one owl   profiles  use scalable
procedure relevant fragment  required weakening trivially achieved
simply discarding  parts of  out of profile axioms  sophisticated techniques may
try reduce even minimise information loss  console  mora  rosati  santarelli    savo 
       approach clearly sound  if answer tuple entailed weakened
ontology  entailed original ontology   incomplete general 
ontologies outside relevant profile  answer returned systems therefore
understood providing lower bound correct answer  however  procedures

   

fipagoda  pay as you go query answering using datalog reasoner

cannot general provide complementary upper bound even indication
complete computed answer  cuenca grau  motik  stoilos    horrocks        
paper  describe novel hybrid approach query answering combines
scalable datalog  or owl   rl  reasoner fully fledged owl   reasoner provide
scalable performance still guaranteeing sound complete answers cases 
procedure uses datalog reasoner efficiently compute lower bound  sound
possibly incomplete  upper bound  complete possibly unsound  answers input query  lower upper bound answers coincide  obviously provide sound
complete answer  otherwise  relevant subsets ontology data computed
guaranteed sufficient test correctness tuples gap
lower upper bounds  subsets computed using datalog reasoner 
typically much smaller input ontology data  finally  fully fledged
reasoner used check gap tuples w r t  relevant subset  still computationally expensive  load fully fledged reasoner reduced exploiting
summarisation techniques inspired sher system quickly identify spurious gap
tuples  dolby  fokoue  kalyanpur  kershenbaum  schonberg  srinivas    ma        dolby 
fokoue  kalyanpur  schonberg    srinivas         analysing dependencies
remaining gap tuples reduce number checks need performed 
key feature approach pay as you go behaviour  bulk computational workload delegated datalog reasoner  extent
fully fledged reasoner needed depend solely ontology  interactions
ontology  dataset query  thus  even using expressive
ontology  queries often fully answered using datalog reasoner  even
fully fledged reasoner required  relevant subset extraction  summarisation
dependency analysis greatly reduce number size reasoning problems  moreover 
approach additional advantage lower bound answer tuples quickly
returned  even cases completion answer requires time consuming computations  finally  although main goal efficiently answer queries owl  
ontologies datasets  technical results general approach
restricted ontology languages based description logics  precisely  given kr
language l captured first order rules allowing existential quantification
disjunction head  want answer conjunctive queries 
assumption availability fully fledged reasoner l datalog reasoner 
used black box 
implemented techniques pagoda system  using rdfox datalog
reasoner  motik et al         hermit fully fledged owl   reasoner  glimm 
horrocks  motik  stoilos    wang          conducted extensive evaluation using
wide range realistic benchmark datasets queries  evaluation suggests
techniques eective providing scalable pay as you go query answering  tests
      queries   ontologies  none contained within
owl profiles      queries fully answered without resorting fullyfledged reasoner  moreover  even fully fledged reasoner used  relevant subset
   http   www cs ox ac uk isg tools pagoda 
   although techniques proved correct general conjunctive queries  practice limited
current query capabilities owl   reasoners 

   

fizhou  cuenca grau  nenov  kaminski    horrocks

extraction  summarisation dependency analysis greatly reduced number size
reasoning problems  tests  size dataset typically reduced order
magnitude  often several orders magnitude  seldom required
single test resolve status gap tuples  taken together  experiments show
pagoda provide efficient conjunctive query answering service scenarios requiring
expressive ontologies datasets containing hundreds millions facts  something
far beyond capabilities pre existing state of the art ontology reasoners 
remainder paper organised follows  section   introduce key
concepts definitions  section   present high level overview approach 
section   describe lower bound answers computed prove
sound  section   describe upper bound answers computed prove
complete  section   present technique reducing size
ontology dataset processed fully fledged reasoner prove
preserves completeness  section   present summarisation dependency analysis
optimisations prove preserve completeness  section   describe
implementation techniques pagoda system discuss additional
optimisations  finally  positioning work within state of the art section   
present extensive evaluation section     draw conclusions section    

   preliminaries
section briefly introduce rule based first order languages description logics
 dls a family knowledge representation formalisms underpinning owl owl  
ontology languages  baader et al         
use standard notions first order logic constant  predicate  function 
term  substitution  atom  formula  sentence  adopt standard definitions
 herbrand  interpretation model  well  un satisfiability entailment  written
    sets first order sentences  denote   nullary predicate false
interpretations  formulas may contain special equality predicate   assume
first order knowledge base f function free signature uses axiomatises
semantics usual way  is  f must contain following first order sentences 
 eq    eq   instantiated n ary predicate p f   n 
 x            xn  p  x            xi           xn     xi xi  

 eq  

 x  y x   x 

 x  y  z x   z   x z 

 x            xn   y p  x            xi           xn     xi   p  x            xi

 eq  
 eq  
    y  xi             xn   

 eq  

finally  exploit following notion homomorphism applicable sets
atoms  formulas substitutions  given sets ground atoms   define
homomorphism mapping ground terms ground terms s t 
 c    c constant c s  p  t            tn     atom p  t            tn     s 
application homomorphism naturally extended ground atoms  ground
formulas ground substitutions  e g  atom   p  t            tn      p  t            tn  
ground substitution   substitution  x    x   x   dom     
   

fipagoda  pay as you go query answering using datalog reasoner

    rule based knowledge representation
rule languages well known knowledge representation formalisms strongly connected ontology languages  dantsin et al         cal  gottlob  lukasiewicz  marnette 
  pieris        bry  eisinger  eiter  furche  gottlob  ley  linse  pichler    wei        
define fact function free ground atom dataset finite set facts 
rule r function free first order sentence form
  x   y  


x   y  
  

x   y  
    

   

x   y  
n   

 


 

i  

  zi  i   x   zi   

   

atom dierent   free variables  x    y   either

         x   z        
     formula  i   x   zj   conjunction atoms dierent
  free variables  x    zj  
conjunction
atoms     x   y       n   x   y   body r  denoted body r  
w
formula
  
z
 
x   zi   head r  denoted head r   assume rules
  
i  
safe  is  every variable  x mentioned body r   brevity  universal quantifiers
omitted rules 
rules form general able capture first order rule languages
knowledge representation  including datalog  abiteboul et al          existential rules
datalog  cal et al          well datalog    alviano  faber  leone    manna 
    b  bourhis  morak    pieris        
say rule r
disjunctive datalog head r  contains existential quantifiers conjunction 
existential     
datalog disjunctive datalog     
knowledge base k   k   dk consists finite set rules k dataset dk
predicate dk assumed occur k  
order simplify presentation technical results  sometimes restrict
knowledge bases particular normal form  specify next  say
rule r normalised one following forms 
 
x   zi   single atom dierent   
  
x   y  
    
x   y  
    
x   y  
    

   

x   y  
n   

   

x   y  
n   

   

x   y  
n   

  

   

    z      x   z   
 

x 
    

   

   
x 
  

   

knowledge base k   dk normalised rules k normalised  restriction
normalised knowledge bases w l o g  since every set rules form    
transformed polynomial time set normalised rules norm   conservative
extension given next  rule r     m  let  xi tuple
   

fizhou  cuenca grau  nenov  kaminski    horrocks

free variables subformulas   zi  i   x   zi   head r    xi  x  furthermore 
let e i fresh predicates arity   xi   let c i fresh predicates arity   xi       zi  
uniquely associated r i  then  norm   consists following rules  

x   y  
    

   

x   y  
n   

 


 

e i   xi   

   

i  

e i   xi       zi c i   xi    zi     m 
c i   xi    zi    

  atom

 i   x   zi     e i   xi     m 

 i   x   zi     c i   xi    zi     m 

   
 i   x   zi   

   
   
   

frequently use skolemisation interpret rules herbrand interpretations 
rule r form     existentially quantified variable zij   let fijr function
symbol globally unique r zij arity  x  furthermore  let sk substitution
sk  zij     fijr   x  zij    zi   skolemisation sk r  r following
first order sentence  slight abuse notation refer skolemised rule 
x   y  
    

   

x   y  
n   

 


 

 i   x   zi  sk

i  

skolemisation sk   set rules obtained skolemising individual rule
  extend definitions head body rules skolemised rules naturally 
well known skolemisation entailment preserving transformation 
    description logics ontology languages
next present brief overview dls underpinning w c standard ontology
language owl    horrocks  kutz    sattler        cuenca grau et al          typically 
predicates dl signatures restricted unary binary  former called atomic
concepts  whereas latter typically referred atomic roles  dls typically provide
two special concepts    the bottom concept     the top concept   mapped
every interpretation empty set interpretation domain  respectively 
every owl   dl ontology normalised set axioms form given
left hand side table    motik  shearer    horrocks          thus  w l o g  
define owl   dl ontology finite set axioms form  o   o    table   
every owl   dl ontology must satisfy certain additional requirements order ensure
decidability reasoning  horrocks et al          restrictions  however  immaterial
technical results 
normalised axiom corresponds single rule  given right hand side
table    concept   translated special nullary predicate    whereas   translated
   although rules        sufficient express normal form  introduce rules        order
facilitate computation upper bound query answers  see sections          
   convenience  omit axioms form v n r b simulated v  r bi  
bi v b bi u bj v       j n bi fresh concept 

   

fipagoda  pay as you go query answering using datalog reasoner

axioms
dn
ai v f
 
di  
n


v
i  
j   bj
 r a v b
v self r 
self r  v
r vs
r vs
r vt
rus v 
v  r b
v r b
v  a 
  v  r a

rules
vn
ai  x    w
 
vi  
n


 x 
 
i  
j   bj  x 
r x  y    a y    b x 
a x    r x  x 
r x  x    a x 
r x  y    s x  y 
r x  y    s y  x 
r x  z    s z  y     x  y 
r x  y    s x  y     
a x     y r x  y    b y  
v
w
a x    m  
i    r x  yi     b yi     
 i jm   yi yj
a x    x
r x  y    a y 

 o  
 o  
 o  
 o  
 o  
 o  
 o  
 o  
 o  
 o   
 o   
 o   
 o   

table    normalised dl axioms translation rules n       b
atomic concepts    r  s  atomic roles 
ordinary unary predicate  meaning axiomatised  let function
maps owl   axiom corresponding rule table    let
ontology  then   o  smallest knowledge base containing 
     o 
rule a x      x  atomic concept o 
rules r x  y      x  r x  y      y  atomic role r o 
note since  o  knowledge base  must contain axioms equality
signature whenever required translate axiom o 
recent years  growing interest ontology languages favourable
computational properties  led standardisation rl  ql  el
profiles owl    motik et al          say ontology horn    
axioms  o    o     additionally  say horn ontology
rl contain axioms  o     o     o    
ql contain axioms  o     o     o     o     o      o     furthermore  axioms  o    o   satisfy n   axioms  o   satisfy     
el contain axioms  o     o    o     additionally  say
el ontology elhor  contain axioms  o     o    o   
    conjunctive queries
conjunctive query  cq  formula q  x  form   y    x   y       x   y  
conjunction function free atoms  query boolean   x       atomic    x   y  
   

fizhou  cuenca grau  nenov  kaminski    horrocks

consists single atom   y        simplicity  sometimes omit free variables
write q instead q  x  
let k knowledge base  tuple  a constants possible answer q  x  w r t  k
arity  x constant  a occurs k  furthermore  say
possible answer  a certain answer k    q  a   set certain answers denoted
cert q  k   note that     x   y   boolean  set certain answers either empty
consists tuple length zero  treat unsatisfiability boolean query
   x   y   nullary falsehood symbol    query holds w r t  k k unsatisfiable 
cqs alternatively represented using datalog rules  end  query q  x 
uniquely associated predicate pq arity   x   where take p       set
rq rules defined follows 

 
q  
rq  
    
    x   y     pq   x   otherwise
then   a   cert q  k  k   rq    pq   a   way  certain answers characterised
means entailment single facts 
answering cqs w r t  knowledge bases computationally hard  decidability knowledge bases stemming owl   dl ontologies remains open  decidability
obtained ensuring ontology stays within one standardised profiles
owl    restriction ensures tractability respect data complexity 
makes profiles natural choice ontology language data intensive applications 
standard language sparql      w c sparql working group        allows users
formulate cqs owl   ontologies  however  ensure decidability reduce
complexity query answering  cqs interpreted sparql     ground semantics 
say possible answer  a q  x      y    x   y   ground answer w r t  satisfiable
knowledge base k exists tuple  e constants k k       a   e   clearly 
every ground answer certain answer vice versa  denote ground q  k 
set ground answers q w r t  k 
many reasoning systems currently support sparql     hence compute ground q  k 
given cq q owl   dl ontology k input  additionally  systems
able compute certain answers q suitably restricted  precisely  say q
internalisable kq   k   rq corresponds owl   dl knowledge base  internalisation
amounts transforming query ontology axiom typically referred
rolling up dl literature  horrocks   tessaris        
paper  focus general problem computing certain answers cq
w r t  knowledge base k  theoretical results generally applicable regardless
rule based language k expressed 
    hyperresolution
reasoning knowledge bases realised means hyperresolution calculus
 robinson   voronkov         briefly discuss next  treatment hyperresolution consider standard basic notions theorem proving  ground  clause
general unifier  mgu   furthermore  treat disjunctions ground atoms
sets hence allow duplicated atoms disjunction  assume  
   

fipagoda  pay as you go query answering using datalog reasoner

occur clauses denote empty clause  skolemisation sk r 
normalised rule r logically equivalent clause containing atom dierent
  head sk r   negation atom body sk r    sometimes abuse
notation use sk r  refer skolemised rule corresponding clause 
let c         n         clause  j atoms
 possibly containing functional terms   furthermore   n  let    
positive ground clause  finally  let mgu pairs       n  then 
positive ground clause               n hyperresolvent c             n  
inference called hyperresolution step  clause c main premise 
let k   k   dk normalised knowledge base let c positive ground clause 
derivation c k pair    t    tree  labeling function
maps node ground clause  v  
   

 v    c v root 

   

 v    dk v leaf 

    v children w            wn    v  hyperresolvent sk r   w              wn  
rule r   k  
support   written support    set facts rules participating hyperresolution steps   write k   c denote hyperresolution derivation
c k  hyperresolution sound complete  k unsatisfiable k    
furthermore  k satisfiable k   k    ground atom  
    skolem chase
answering cqs knowledge base k   k   dk k consists existential
rules realised using chase technique  abiteboul et al         cal  gottlob   
kifer         paper  use skolem chase variant  marnette        cuenca grau 
horrocks  krotzsch  kupke  magka  motik    wang        
skolem chase sequence k sequence sets ground atoms  b  i    
 
b   dk   b i   inductively defined follows 
b i     b    head sk r     r   k  

substitution  b    body r    

skolem chase k  written chasek   defined   b  
key property skolem chase computes universal herbrand model
k  used database answering cqs  formally  k satisfiable
  
  chasek   furthermore  k satisfiable  chasek homomorphically embeddable
every herbrand model k  seen set atoms   follows k satisfiable
q boolean cq k    q chasek    q 
note chasek might contain infinitely many atoms  k datalog  however 
chasek guaranteed finite contains precisely facts logically entailed k 
case  often refer chasek materialisation k 

   

fizhou  cuenca grau  nenov  kaminski    horrocks

   overview
section provide high level overview approach conjunctive query answering  assume availability two reasoners 
datalog reasoner sound complete answering conjunctive queries
datalog knowledge bases 
fully fledged reasoner sound complete answering given class
conjunctive queries q  which includes unsatisfiability query  w r t  knowledge
bases given ontology language l 
describe approach general form  make assumptions
two reasoners  treating black box query answering procedures 
kind queries knowledge bases dealt using approach
ultimately depends capabilities fully fledged reasoner  instance  owl
  dl reasoners typically process arbitrary owl   dl knowledge bases  however 
query language limited internalisable queries  turn  scalability approach
ultimately depends much reasoning workload delegated datalog
reasoner  goal delegate bulk computation datalog reasoner
restrict  expensive  use fully fledged reasoner bare minimum 
here  rest paper  fix arbitrary normalised knowledge base
k   k   dk   given arbitrary query q  which may special unsatisfiability query 
containing symbols k  core approach relies exploiting datalog
reasoner accomplishing following tasks 
lower upper bound computation  exploit datalog reasoner
compute lower bound lq upper bound u q certain answers
q w r t  k  bounds match  i e  lq   u q    query fully
answered datalog reasoner  otherwise  dierence gq   u q   lq provides
set gap answers need verified using fully fledged reasoner 
relevant techniques computing bounds described sections     
knowledge base subset computation  exploit datalog reasoner
compute  hopefully small  subset kq k sufficient check answers gq
cert q  k   is   a   cert q  k   a   cert q  kq    a   gq   details
compute kq given section   
proceed according following steps given query q 
step    check satisfiability k 
 a  compute bounds l  u   unsatisfiability query    l       
terminate report k unsatisfiable  u        proceed step  
 k satisfiable  
 b  compute subset k  k 

 c  use fully fledged reasoner check satisfiability k    minimise
computational workload fully fledged reasoner  proceed follows 
   

fipagoda  pay as you go query answering using datalog reasoner

i  construct summary k   see section     use fully fledged reasoner check satisfiable  is  proceed step    k satisfiable  
ii  use fully fledged reasoner check satisfiability k    unsatisfiable  terminate report k unsatisfiable  otherwise 
proceed step    k satisfiable  
step    compute bounds lq u q   gq      terminate return lq   otherwise 
proceed step   
step    compute subset kq k 
step     a   gq   use fully fledged reasoner check whether kq    q  a  
minimise computational workload  step carried follows 
 a  construct summary kq kq  see section      a   gq   use
fully fledged reasoner check whether  a certain answer q w r t 
summary kq   remove  a gq case 
 b  compute dependency relation remaining answers gq s t   b
depends  a  a spurious answer   b   see section    
 c  remove remaining spurious answers gq   answer spurious
entailed kq depends spurious answer  use fullyfledged reasoner check relevant entailments  arranging checks heuristics
w r t  dependency relation 
step    return lq   gq  
following sections  describe steps formally  introduce
number improvements optimisations  rely additional assumption
datalog reasoner materialisation basedthat is  datalog knowledge base k 
query q     computes query answers cert q     k    first computing materialisation
chasek  evaluating q   resulting materialisation  reasonable
assumption practice since datalog reasoners semantic web applications  e g  
owlim  rdfox  oracles native inference engine  materialisation based  cases 
assume direct access materialisation  pagoda system
combines hermit materialisation based reasoner rdfox  hence able
exploit improvements optimisations described below  realisation
approach pagoda discussed detail section   
illustrate techniques using running example consisting knowledge
base kex   kex   dkex query qex  x  given table    note rules  r  
 r   kex normalised  however  easily brought normal form
introducing fresh binary predicates eatsh eatsl follows 
meateater x     y eatsh  x  y   r a 

eats x  y    herbivore y    eatsh  x  y 
eatsh  x  y    eats x  y 

eatsh  x  y    herbivore y 

 r b 
 r c 

 r d 

   

folivore x     y eatsl  x  y   r a 

eats x  y    leaf y    eatsl  x  y 
eatsl  x  y    eats x  y 
eatsl  x  y    leaf y 

 r b 

 r c 
 r d 

fizhou  cuenca grau  nenov  kaminski    horrocks

mammal tiger 

 d  

mammal wolf  

 d  

mammal howler 

 d   

mammal lion 

 d  

meateater wolf  

 d  

meateater python 
eats python  rabbit 

 d  
 d  

eats wolf   sheep 
herbivore sheep 

 d  
 d  

folivore howler 
mammal a hare 

 d   
 d   

folivore a hare 

 d   

herbivore rabbit 

 d  

eats sheep  grass 

 d   

eats a hare  willow 

 d   

carnivore x    mammal x 

herbivore x    mammal x 

folivore x    meateater x     

herbivore x    eats x  y    plant y 

 r  
 r  
 r  
 r  

mammal x    herbivore x    meateater x 

 r  

mammal x     y eats x  y 

 r  

meateater x     y eats x  y    herbivore y  
folivore x     y eats x  y    leaf y  
leaf x    plant x 

 r  
 r  
 r  

qex  x     y eats x  y    plant y  

table    running example knowledge base kex query qex  x   set kex consists
rules  r   r    dataset dkex consists facts  d   d    
core techniques described sections     applicable knowledge base
query  order simplify presentation definitions technical results
sections fix  addition knowledge base k   k   dk   arbitrary query
q  x      y    x   y    which may unsatisfiability query    

   lower bound computation
straightforward way compute lower bound answers using datalog reasoner
evaluate q w r t  datalog subset k consisting facts dk datalog rules
k   case owl   ontologies  amounts considering subset owl  
rl axioms ontology  monotonicity property first order logic certain
answers w r t  subset certain answers w r t  k  furthermore  subset
unsatisfiable  k 
example      datalog subset example kex consists rules  r   r  
 r    together facts  d   d     materialisation datalog subset
kex results following dataset  dex    mammal rabbit   mammal sheep   plant grass  
evaluating qex  x  materialisation obtain sheep answer 
 
basic lower bound rather imprecise practice since rules featuring disjunction existential quantification typically abound owl   dl ontologies  improve

   

fipagoda  pay as you go query answering using datalog reasoner

bound  exploit techniques allow us deterministically derive  also via datalog
reasoning  additional consequences k follow datalog subset 
    dealing disjunctive rules  program shifting
deal disjunctive rules  adopt variant shiftinga polynomial program transformation commonly used answer set programming  eiter  fink  tompits    woltran 
       next illustrate intuition behind transformation example 
example      let us consider information kex arctic hares  a hare  
 r    d     one deduce hare meateater  follows
rule  r   fact  d    hare herbivore  since hare eats willow 
deduce plant willow   r   hence hare answer qex   although  r  
disjunctive rule  reasoning process fully deterministic captured
datalog  end  introduce predicate meateater intuitively stands
complement meateater  extend datalog subset kex rules encoding
intended meaning fresh predicate  particular   r    r   two rules 
obtained  r    r    respectively 
folivore x    meateater x 

 r  

mammal x    meateater x    herbivore x 

 r  

exploit rules derive meateater a hare  herbivore a hare  

 

define shifting transformation formally 
definition      let r normalised disjunctive datalog rule  predicate p r
let p fresh predicate arity  furthermore  given atom   p   t  let
p   t   shifting r  written shift r   following set rules 
r form      shift r     r         

    i       n

 



    n  

r form      shift r  consists following rules   i  rule  s   
 ii  rules  s     j m   iii  rules  s     n s t 
variable occurs atom rule 
 
 
 

   
   
   

n
n

 
 

 

 
 

 

   
   
i  



  

j  

   

 
n

 s  
j  

 

 

   

   




 

 

j

 s  



 s  

let set normalised disjunctive datalog rules  then  shifting defined
following set datalog rules 
 
shift    
shift r 
 
r 

note shifting polynomial transformation  r disjunctive datalog rule
n atoms body atoms head  shift r  contains   n     datalog
rules  furthermore  shown following theorem  sound 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

theorem      let dd
subset disjunctive datalog rules k   furthermore  let
k
k    shift dd
 
 

 
then 
cert q  k    cert q  k  
k
k
 
proof  let chasek     b  l
i   l non negative integer  recall k datalog
knowledge base hence skolem chase finite   show induction
following properties hold   l   b  

 a       k unsatisfiable 
 b    p   a   k    p   a  
 c    p   a   k    p   a  
base case  clearly  b     dk properties trivially follow fact dk k 

inductive step  assume properties  a  c  hold every   b   show
hold every   b i     b   must exist rule r    k  substitution
b    body r      head r      since every atom body r    b  
properties  a   c  hold atoms induction hypothesis  furthermore 
must exist rule r   k form       n         r    shift r  
 a       distinguish two cases   i  head r       case r   r 
induction hypothesis  k                  n   hence k        ii  head r       
case r  form  s               n             b  
induction hypothesis  k entails             n               then  rule r
cannot satisfied model k since r   k  obtain k unsatisfiable 
 b    p   a   r  form  s     p   a   hence  b contains atoms
i               induction hypothesis  k entails
        n           
 
 
 
 
 
 

 
 
 
 
 

a 
 
n
 
    i               since r   k   p   
must case k    p   a  
 c    p   a   following cases   i  head r       case induction
k                      i             n    then  since       n    
rule k  obtain k      required   ii  head r        case
r  form  s     p   a   then  b contains atoms                
induction hypothesis k entails atoms
i             n              
 
 
 
 
 
 
 
 
 
 
 


a  
 
 
i  
n
              since r   k obtain k    p   
v
q      theorem follows property  a   otherwise  let q  x      y   ni     x   y   
let  a possible answer k     q  a   since k  datalog  exists tuple
 e constants k  non negative integer l   a   e    b l   n 
then   b  k      a   e   hence k    q  a  
shifting captures consequences disjunctive datalog rules k 
furthermore  note refinement shifting ensures preservation
consequences  indeed  well known disjunctive datalog express queries  e g  
non   colorabilility  cannot captured means datalog program  afrati  cosmadakis    yannakakis        
   

fipagoda  pay as you go query answering using datalog reasoner

example      consider disjunctive datalog knowledge base consisting fact
greenseaturtle turtle   rules  r     r  
greenseaturtle x    herbivore x    carnivore x  
clearly  mammal turtle  follows knowledge base  shifting consists fact
greenseaturtle turtle  following rules  predicates carnivore  greenseaturtle 
herbivore mammal abbreviated as  respectively  c  g  h m 
c x    m x     

c x    m x 

m x    c x 

g x    h x    c x     

g x    h x    c x 

g x    c x    h x 

h x    m x     

h x    m x 

h x    c x    g x 

m x    h x 

 

checked fact mammal turtle  follow shifting 
    dealing existential rules  combined approach owl   el

existentially quantified rules ubiquitous large scale complex ontologies  especially
life sciences applications  el profile owl   specifically designed
applications  many large ontologies used practice seen consisting large
el backbone extended small number axioms outside profile 
given prevalence el axioms realistic ontologies  natural consider
owl   el subset k computing lower bound answers  cq answering owl
  el is  however  pspace complete  stefanoni  motik  krotzsch    rudolph       
system currently supports cq answering whole owl   el  complexity 
however  drops np case elhor   stefanoni et al          setting 
restriction elhor  ontologies added practical benefit exploit socalled combined approach delegate computational work associated cq
answering datalog reasoner  stefanoni et al         lutz  toman    wolter       a
technique currently supported systems karma   although datalog based cq
answering techniques available richer languages  extension elhor 
inverse roles  i e   axioms  o   table     resulting datalog programs hard
compute exponential size worst case  perez urbina  motik    horrocks 
       contrast combined approach elhor    relevant datalog
programs straightforwardly constructed without need reasoning 
linear size  see related work section details  
thus  compute query answers depend existentially quantified rules consider
r
subset el
k elho   rules k  syntactically characterised follows 
definition      rule elhor  one following forms    x  either
   form a x   x c   yr x  y  
p
 

i  

ai  x   

q
 

j  

 rj  x  yj    

lj
 

k  

   http   www cs ox ac uk isg tools karma 

   

bjk  yj        x  

 el  

fizhou  cuenca grau  nenov  kaminski    horrocks

r   x  y    r   x  y  
r x  y    a y  

 el  
 el  

combined approach exploit cq answering conceptualised
three step process 
   first step compute materialisation datalog program obtained
el
k respect dk   contains    knowledge base unsatisfiable  otherwise model knowledge base  model  however 
universal cannot homomorphically embedded every model  thus 
evaluation cqs may lead unsound answers 
   second step evaluate query q   step intractable query
size  well known database techniques exploited 
   third step  unsound answers obtained second step discarded using
polynomial time filtration algorithm 
next specify transformation knowledge bases datalog used first
step  transformation exploited later section   computing upper
bound query answers  computation datalog program knowledge base
step   relies form skolemisation existentially quantified variables mapped
fresh constants  instead functional terms  
definition      rule r form     existentially quantified variable
zij   let crij constant globally unique r zij   let c sk substitution
c sk  zij     crij zij    zi   c skolemisation c sk r  r given follows 
x   y  
    

   

x   y  
n   

 


 

 i   x   zi  c sk  

i  

then  define c sk k     c sk r    r   k     dk  

 

note application c skolemisation elhor  rule always results
datalog rule  note that  contrast standard skolemisation  c skolemisation
satisfiability entailment preserving transformation  may query answers
w r t  c sk k  unsound w r t  k  shown  however  c skolemisation
satisfiability preserving elhor  knowledge bases  thus  c sk el
k     dk satisfiable
el
 


satisfiable
 stefanoni
et
al  
      

next
sketch

filtration step 
k
k
refer interested reader work stefanoni et al  details 
main source spurious answers evaluating query materialisation
obtained step   presence forksconfluent chains binary atoms involving
skolem constantsin image query materialisation  due
fact elhor  so called forest model property  forks cannot manifest
forest shaped models  say constant c el
k  dk auxiliary
dierent constant b exists c sk el
 
 

  
c

b 

is 
auxiliary constants
k
k
introduced c skolemisation entailed equal
   

fipagoda  pay as you go query answering using datalog reasoner

constant present original elhor  knowledge base  let substitution
mapping free variables  x q constants  a k    q   then  relation
q  a smallest reflexive transitive binary relation terms q satisfying
following fork rule
 fork 

  t 
st

r s  s    p  t  t    occur q 
 s    auxiliary constant 

clearly equivalence relation  computed polynomial time size
q  term q  let  t  equivalence class w r t    let mapping
term q arbitrary fixed representative  t   auxiliary graph
q  a directed graph g   hv  ei
v contains vertex  t  term q  t  auxiliary 
e contains directed edge h  s    t i atom form r s  t  q
   s    t   v  
now  ready define filtration  say  a spurious answer either
auxiliary graph q contains cycle  terms occurring q exist
c sk el

k     dk      s   t   clearly  filtration candidate answer  
done polynomial time size q 
assume availability procedure soundanswers solves steps     
is  given q model computed step    returns answers q w r t 
input elhor  knowledge base  consequently  given k q  obtain lower bound
query answers follows 
r
extract subset el
k elho   rules k 

compute materialisation c sk el
k     dk  
q     return unsatisfiable       otherwise  return soundanswers q    
example      consider running example  elhor  subset kex consists
facts  d   d    together rules except  r    r    fact  d   
rule  r   deduce howler eats leaf  must plant rule  r    hence
howler answer qex   answer identified using aforementioned steps 
c skolemisation  r a  leads datalog rule
folivore x    eatsl  x  c   

 r au 

materialisation datalog program consisting facts rule  r au  contains
fact plant c    hence tuple  howler  c    matches qex materialisation 
match deemed sound filtration procedure 
 
    aggregated lower bound
techniques section seamlessly combined obtain lower bound lq
hopefully close actual set certain answers  given k q  proceed follows 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

dd subset
   construct datalog knowledge base shift dd
k     dk   k
l
disjunctive datalog rules k   compute materialisation m   
l
l
   construct datalog program c sk el
k     m  compute materialisation m   

   q      lq   cert q  m l    otherwise  lq   soundanswers q  m l   
theorem     ensures k      m l signature k  hence m l
used initial dataset second step  properties c skolemisation
filtration discussed section     ensure every answer lq indeed certain
answer q w r t  k  furthermore      m l   k indeed unsatisfiable  finally  note
materialisation m l obtained first step pipelined second step 
result  lq  sometimes strict  superset answers would obtain simply
el
computing answers q w r t  shift dd
k     dk c sk k     dk independently
union results 
example      running example kex   aggregated lower bound lex consists
sheep  which follows datalog subset kex    hare  which follows shift kex    
howler  which follows elhor  fragment kex   
 

   upper bound computation
many practical cases lower bound lq described section     constitutes rather
precise approximation actual set certain answers  furthermore 
computed efficiently resorting datalog reasoner  lower bound
computation  however  gives indication accuracy answers  without
corresponding upper bound  every possible answer remains candidate answer 
needs either confirmed discarded 
section  describe approach efficiently computing upper bound
set certain answers  lower upper bounds coincide  fully answered
query  otherwise  gap lower upper bounds provides margin
error lower bound  narrows set candidate answers whose
verification may require powerful computational techniques 
    strengthening knowledge base
first step towards computing upper bound construct  polynomial size 
datalog knowledge base k  k unsatisfiable  k  entails nullary predicate
 s   cert q  k  cert q  k    otherwise  roughly speaking  k    refer
datalog strengthening k  obtained k
   replacing   fresh nullary predicate  s predefined meaning 
   splitting disjuncts occurring head position dierent datalog rules 
   skolemising existentially quantified variables constants definition     
convenient subsequent definitions proofs explicitly define splitting
k  written split k   intermediate knowledge base resulting steps     above 
   

fipagoda  pay as you go query answering using datalog reasoner

satisfiable disjunction free  datalog strengthening k defined
result applying step   replacing existentially quantified rule
split k  c skolemisation 
definition      splitting rule r form     following set rules 
head r       split r           
predicate predefined meaning 
otherwise  split r     

   s     s fresh nullary

    zj  j   x   zj       j   

splitting k   k   dk defined split k    r k split r    dk   finally 
datalog strengthening k defined str k    c sk split k   
 
 

   

n

n

example      consider example knowledge base kex   splitting kex obtained
replacing rule  r   rules  r ua   r ub   rule  r    r u  
mammal x    herbivore x 

mammal x    meateater x 

folivore x    meateater x     s

 r ua 
 r ub 
 r u 

finally  str k  obtained replacing existentially quantified rules  r a    r  
following rules  r au    r u 
meateater x    eatsh  x  c   
mammal x    eats x  c   

well rule  r a  rule  r au  given example     

 r au 
 r u 
 

note k contain rules   head  str k  logically entails
k  splitting amounts turning disjunctions head rules conjunctions 
c skolemisation restricts possible values existentially quantified variables fixed
constants  thus  cert q  str k   constitutes upper bound cert q  k   is  however 
longer case   replaced ordinary predicate  s without predefined
meaning  rationale behind replacement provide meaningful upper bound
even cases splitting disjunctions c skolemising existentially quantified variables
would make strengthened knowledge base unsatisfiable 
    str k   example knowledge base 
example      consider strengthening kex
ex
since howler mammal  rule  r ub  meateater  then 
since folivore howler  fact kex derive  s using rule  r u   note that 
replaced falsehood predicate    s   strengthening kex would
unsatisfiable  case meaningful upper bound could obtained query   

next show str k  exploited compute meaningful upper bound
input query  despite fact   stripped built in semantics first order
logic  following lemma establishes key property splitting transformation
definition      ground clause           n derivable k via hyperresolution 
skolem chase split k  contains every atom   n 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

lemma      let    t    hyperresolution derivation k let h   split k  
then  every node v   ground atom occurring  v     chaseh  
proof  prove claim structural induction  
base case  v leaf    v    dk   since dk h   chaseh  

inductive step  assume induction hypothesis holds children w            wn
node v     exists rule r   k substitution   sk r  form
      n   disjunction atoms   v   
        n
hyperresolvent sk r   wi         n  induction
hypothesis  disjuncts chaseh   need show claim
disjunct
  distinguish following cases depending form
normalised rule r
r form     

empty  claim holds vacuously 

r form          sk   induction hypothesis 
chaseh   since split r    r hence r   h  obtain   sk   chaseh  





r form                induction hypothesis 
chaseh     m  since rule       n   h  obtain
atom chaseh   required 
exploit completeness hyperresolution show split k  satisfies
required properties  furthermore  fact str k     split k  immediately implies
str k  satisfies properties well hence may exploited compute upper
bound query answers 
theorem      following properties hold h   split k  well h   str k  
 i  cert    k  cert  s   h   i e  k unsatisfiable  h     s    ii  k
satisfiable cert q  k  cert q  h  
proof  first show properties  i   ii  hold h   split k   k unsatisfiable 
hyperresolution derivation empty clause k  thus  must
exist rule r form     k substitution
atom
  n derivable k  then  lemma       chaseh  
since h contains rule       n    s  s   chaseh h     s   required 
assume k satisfiable  cert q  k       cert q  k  cert q  h  holds trivially 
otherwise let  a certain answer q w r t  k  k    q  a  hence k   rq    pq   a  
since cert    k       q       using completeness hyperresolution
lemma     obtain pq   a  chase k   rq   then  aforementioned
splitting entails pq   a  since split k   rq     h   rq  a   cert q  h  
required  finally  properties  i   ii  hold str k  direct consequence fact
str k     split k  
example      figure   depicts materialisation str kex    edges predicates
introduced normalisation ignored edges figure represent
binary predicate eats  explicit facts kex depicted black  implicit facts depicted
   

fipagoda  pay as you go query answering using datalog reasoner

c 

tiger
mammal
herbivore
meateater

meateater
mammal
herbivore
plant

lion
mammal
herbivore
meateater

c 

python
meateater

plant

grass plant

wolf

rabbit
herbivore
mammal
meateater

mammal
meateater
herbivore

c 

sheep
herbivore
mammal
meateater
plant

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore
meateater

mammal
folivore
herbivore
meateater

figure    materialisation datalog strengthening kex
using dierent colours facilitate subsequent illustration refinements
materialisation allow us tighten upper bound  obtain following
upper bound cert qex   kex   evaluating qex materialisation 
cert qex   str kex       tiger  lion  python  rabbit  wolf   sheep  howler  hare  c   
already mentioned  str kex       s   however  obtained upper bound still meaningful
since contain possible answers kex   grass willow  please note
c  certain answer qex w r t  str kex    however  constant c  signature
kex hence possible answer qex w r t  k 
 
    tightening upper bound  existential rules
upper bound obtained str k  rather coarse grained practice  discussed
example      python  tiger  lion wolf contained upper bound  none
certain answer qex   section  show refine upper bound
restricting application c skolemisation existential rules  instead computing
upper bound q constructing strengthened knowledge base str k 
evaluating q  the materialisation of  str k   proceed follows 
   apply k variant skolem chase  refer c chase first
splitting disjuncts occurring head position dierent rules applying
skolem chasing split k  following modifications   i  similarly
restricted chase  cal et al          existential rules applied rule
head already satisfied   ii  rather skolemising head atom  using
functional term  whenever existential rule applied  resort c skolemisation
instead  due latter modification  c chase compute least
herbrand model split k   rather model split k  
   evaluate q result aforementioned chase  thus obtaining upper bound
certain answers q w r t  split k   thus w r t  k 
following example motivates practical advantages approach 
example      consider materialisation str kex   figure    already
mentioned  python returned upper bound answer since qex matches facts
   

fizhou  cuenca grau  nenov  kaminski    horrocks

eats python  c    plant c    materialisation  fact eats python  c    obtained
eatsh  python  c     included materialisation satisfy c skolemised
rule  r au  str kex    existentially quantified rule  r a  kex   case
python  however  rule  r a  kex already satisfied fact eatsh  python  rabbit  
derived eats python  rabbit  herbivore rabbit  dataset  rule
 r b   please note rule  r b  form     normalisation  r   
rule  r b  ensures  r   satisfied substitution   r a  satisfied substitution  obtain upper bound suffices construct model
kex  rather model str kex     thus  prevent application rule  r au 
python chase  dispense eats python  c    materialisation   
ready define c chase formally 
definition      let h   split k   let dh subset datalog rules h  
eh   h   dh   c chase sequence k sequence sets ground atoms  b  i    
b     dh  i e  b     dk    b i   inductively defined given next  let sdi  
sei   defined follows 
sdi      head r    r   dh  

sei      head c sk r     r   eh  

substitution  b    body r  b     head r  
substitution  b    body r  b     head r  

then  b i     b   sdi   sdi  
     b i     b   sei   otherwise  finally  define
 
c chase k c chasek     b  
 

note c chase k finite set since terms occur
constants c sk split k   
example      c chase kex depicted figure    materialisation strict
subset figure    orange coloured binary facts longer derived 
consequently  python longer derived answer qex  
 
relevant properties c chase summarised following lemma 
theorem       following properties hold   i  cert    k  cert  s   c chasek    i e 
k unsatisfiable   s   c chasek    ii  k satisfiable  cert q  k  cert q  c chasek   
proof  first prove c chasek model split k   since dk c chasek clear
satisfies facts split k   let r   split k   distinguish two cases 
rule r datalog  c chasek    body r  substitution definition
c chase ensures head r    c chasek hence rule satisfied 
otherwise  r form      c chasek    body r  substitution
definition c chaseh ensures head c sk r     c chasek   thus  c chasek   
head r  hence rule satisfied 
show contrapositive first property  assume  s    c chasek  
c chasek model split k   split k       s hence k satisfiable
theorem      finally  assume k satisfiable  cert q  k       cert q  k  cert q  h 
holds trivially  otherwise let  a certain answer q w r t  k  theorem      obtain
 a   cert q  split k    c chasek    split k    a   cert q  c chasek   
   

fipagoda  pay as you go query answering using datalog reasoner

c 

tiger
mammal
herbivore
meateater

meateater
mammal
herbivore
plant

lion
mammal
herbivore
meateater

c 

python

plant

grass plant

wolf

rabbit

meateater

herbivore
mammal
meateater

mammal
meateater
herbivore

c 

sheep
herbivore
mammal
meateater
plant

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore
meateater

mammal
folivore
herbivore
meateater

figure    c chase kex
    tightening upper bound  disjunctive rules
although technique described previous section quite eective practice 
main limitation split k  disjunctions heads rules k eectively turned conjunctions  section  show refine upper bound
exploiting extension c chase uses similar approach deal disjunctive
rules well existential rules 
specifically  extend c chase deal disjunctive rules r form    
 i  r applied none disjuncts head rule already
satisfied   ii  r applied  one disjuncts included chase  rather
them   order avoid non determinism chase expansion reduce
computational cost  disjuncts selected deterministically means  efficiently
implementable  choice function 
example       consider running example  first observe wolf answer
qex w r t  c chase kex shown figure    indeed  herbivore wolf   derived
mammal wolf   rules split  r    thus  plant sheep  derived using
rule  r    note  however  wolf spurious answer  given meateater wolf  
explicit fact kex   rule  r   already satisfied wolf hence dispense
fact herbivore wolf   materialisation 
finally  since goal construct model kex reasonable pick disjuncts
whose predicate unrelated   kex   since   depends meateater folivore
 by rule  r     makes sense include fact herbivore b  materialisation whenever
disjunctive rule  r   applied constant b 
 
details refer reader section    specific choice function
implemented pagoda described 
define extended notion c chase  efficiently implementable
choice function given additional parameter 
definition       let h knowledge base obtained k replacing  
nullary predicate  s   let dh set datalog rules h   let nh   h   dh  
furthermore  let f polynomially computable choice function given ground clause
set ground atoms returns disjunct   c chase sequence k w r t  f
   

fizhou  cuenca grau  nenov  kaminski    horrocks

c 

tiger
mammal
herbivore

lion
mammal
herbivore

python
meateater

plant

grass plant

wolf

rabbit
herbivore
mammal

mammal
meateater

c 

sheep
herbivore
mammal

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore

mammal
folivore
herbivore

figure    c chasef kex
sequence sets ground atoms  b  i     b     dh  i e   b     dk    b i  
defined given next  let sdi   sni   follows 
sdi      head r    r   dh  

sni      f  head c sk r     b     r   nh  

substitution  b    body r  b     head r  

substitution   b    body r  b     head r  

then  b i     b   sdi   sdi         b i     b   sni   otherwise  finally  define

c chase k w r t  f c chasefk     b  
 
example       consider aforementioned choice function f picks herbivore b 
whenever rule  r   applied fact mammal b   figure   depicts facts c chasefkex  
observed c chasefkex strict subset materialisation figure   
brown colored facts longer derived  see wolf answer
qex w r t  c chasefkex hence identified spurious  furthermore  nullary
predicate  s derived hence determine kex satisfiable   
relevant properties variant c chase follows 
theorem       let f choice function definition        s    c chasefk  
c chasefk model k cert q  k  cert q  c chasefk   
proof  dataset dk contained c chasefk   suffices show c chasefk satisfies
rule r   k  distinguish following cases 
r form      since  s  
  c chasefk   cannot exist substitution
c chasefk    body r  hence c chasefk satisfies r vacuously 



r form      pick c chasefk    body r    definition c chasefk
ensures head c sk r     c chasefk hence c chasefk satisfies r 
r form      pick c chasefk    body r    definition
c chasefk   f  head c sk r    sni     c chasefk set atoms sni
chase sequence  c chasefk satisfies r 

q      cert q  k      cert q  k  cert q  c chasefk   holds trivially  otherwise 
cert q  k  cert q  c chasefk   follows fact c chasefk model k 
   

fipagoda  pay as you go query answering using datalog reasoner

    combined upper bound
introduced three dierent techniques computing upper bound cert q  k  
   compute materialisation m u str k   evaluate q w r t  m u obtain set
possible answers u q q w r t  k  c f  section      
   compute c chase k  denoted m u   evaluate q w r t  m u obtain set
possible answers u q q w r t  k  c f  section      
   fix choice function f   compute c chase k w r t  f   denoted m u   evaluate q w r t  m u obtain set possible answers u q q w r t  k  c f  section      

trivially seen u q u q precise u q   i e  u q u q u q u q  
shown following example  u q u q are  however  incomparable 

example       consider knowledge base h consisting facts a a     r a    b     b b    
a a     r a    b     b b    rules b x    c x    d x   r x  y    c y    s x  y 
a x     ys x  y   let c freshly introduced constant a x     ys x  y   let
f choice function picks disjunct d bi   every clause c bi     d bi    then 
c chaseh   dh    c b     d b     s a    b     c b     d b     s a    b     
c chasefh   dh    d b     s a    c   d b     s a    c   

q   x     y s x  y    c y    d y    upper bound computed using c chaseh
contains two additional answers a  a  compared computed using c chasefh  
q   x    x       y s x    y    s x    y    upper bound computed using c chasefh
additional answers  a    a     a    a    compared computed using c chaseh    

are  however  tradeos considered  clearly  upper bound u q
convenient ease implementation point view  str k  constructed 
bound directly computed using o the shelf datalog reasoner without modification  furthermore  upper bound u q important shortcoming  use
whenever  s derived  show following example 
example       consider choice function g picks meateater a  disjunction form herbivore a    meateater a   c chase kex w r t  g derive
meateater howler  fact mammal howler  disjunctive rule  r    using
fact folivore howler  rule  r u  derive  s   thus see that  although
howler cert qex   kex    herbivore howler  c chase kex w r t  g  hence
howler upper bound computed using it  contrast two
upper bounds  herbivore howler  materialisation str kex   c chase
kex   hence howler upper bound computed w r t  them 
 
therefore   s    c chasefk   combine u q u q compute hopefully
precise upper bound  otherwise  use u q   combined upper bound query answer
u q q k formally defined follows 
   s
 
  u    u  q     
q
q
q
u  
    
u   u 
q       s    c chasefk  
   q
u 
otherwise 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

example       combined upper bound qex kex gives 
uex    tiger  lion  rabbit  sheep  howler  hare  
compare upper bound aggregated lower bound lex given example    
identify gap gex    tiger  lion  rabbit  
 

   reducing size knowledge base
whenever non empty gap gq lower upper bound  e g   running
example  need verify whether answer gq spurious not  accomplishing
task using fully fledged reasoner computationally expensive  verifying
answer gq typically involves satisfiability test  infeasible practice
large scale knowledge bases 
section propose technique identifying  typically small  subset kq
knowledge base k sufficient verifying answers gq  i e   a   cert q  k 
 a   cert q  kq    a   gq    essential subsets be  one hand 
small possible and  hand  efficiently computable  requirements
conflict  computing minimal sized subsets hard answering query  whereas
subsets easily computed may almost large initial knowledge base 
main idea behind approach construct datalog knowledge base whose
materialisation identifies rules facts kq   knowledge base size polynomial
sizes k q include predicates arity higher k
q  way  subset computation fully delegated scalable datalog reasoner 
hence addressing efficiency requirement  key property kq   ensures
contains relevant information k  following  rule fact  
  kq
show occur hyperresolution proof  resp  gap answer
gq   k   rq q      resp  q        completeness hyperresolution
guarantees excluded facts rules indeed irrelevant 
    overview approach
let us motivate main ideas behind approach using running example  since  s
derived m u   m u   know cert    kex        hence kex
satisfiable  see example        however  still need determine whether answers
gex    tiger  lion  rabbit  combined upper bound cert qex   kex    i e  
certain answers qex  
sketch construction datalog knowledge base track kex   qex   gex  
subset kex relevant answers gex derived  key property
knowledge base materialisation tracks rules facts may
participate hyperresolution proof gap answer thus encodes contents
subset kqex   relevant information recorded using fresh predicates constants 
fresh predicate p r predicate p kex   extension
materialisation track kex   qex   gex   give us facts subset 

   

fipagoda  pay as you go query answering using datalog reasoner

fresh constant dr rule r kex special unary predicate rel 
extension materialisation track kex   qex   gex   give us rules
subset 
key step construction knowledge base invert rule r   kex
set datalog rules  r   i  moving head atoms r body
replacing predicates corresponding fresh ones  e g   replace p p r   
 ii  copying atoms originally body r  now empty  head
replacing predicates corresponding fresh ones adding special atom
rel dr   additional conjunct   iii  eliminating conjunction head r
splitting r multiple rules  one head conjunct 
consider first example datalog rule  r   kex   inverted
following rules 
plantr  y    herbivore x    eats x  y    herbivorer  x 
r

r

plant  y    herbivore x    eats x  y    eats  x  y 
r

plant  y    herbivore x    eats x  y    rel dr   

    
    
    

head plant y   r   moved body predicate plant replaced
plantr   body herbivore x    eats x  y  copied head conjunction
herbivorer  x    eatsr  x  y   conjoined special atom rel dr     finally
head conjunction eliminated splitting rule three separate rules 
rules reflect intuitive meaning freshly introduced predicates  fact
plantr  c  holds constant c  means fact plant c  may participate
hyperresolution proof kex answer gap  additionally  herbivore b 
eats b  c  hold b  facts rule  r   could participate
one proof since plant c  hyperresolvent facts herbivore b  eats b  c 
rule  r    recorded facts herbivorer  b   eatsr  b  c   rel dr     thus  rules
         faithfully invert hyperresolution steps involving rule  r   
similarly  disjunctive rule  r   inverted following two rules 
herbivorer  x    meateaterr  x    mammal x    mammalr  x 
r

r

herbivore  x    meateater  x    mammal x    rel dr   

    
    

case  disjunctive head herbivore x  meateater x   r   moved
body conjunction herbivorer  x    meateaterr  x  fresh predicates herbivorer
meateaterr   facts herbivorer  c  meateaterr  c  hold c  which means
facts herbivore c  meateater c  may participate relevant proof kex  
mammal c  holds  deem fact mammal c  rule  r   relevant 
situation dierent comes inverting existentially quantified rules 
case longer capture relevant hyperresolution steps kex faithfully  consider
rule  r    inverted follows 
eatsr  x  y    mammal x    mammalr  x 
r

eats  x  y    mammal x    rel dr   
   

    
    

fizhou  cuenca grau  nenov  kaminski    horrocks

case  existentially quantified head  y eats x  y  moved body atom
eatsr  x  y   eatsr  b  c  holds b c  and hence fact may participate
relevant proof   mammal b  holds  record  r   mammal b 
relevant  the latter means fact mammalr  b    hyperresolvent mammal b 
 r   atom eats b  t   functional term  may unrelated eats b  c 
hence irrelevant proving answer gap 
addition inverting rules kex   construction track kex   qex   gex  
needs take query gap answers account  this  encode query
eats x  y    plant y    pqex   x  rules
pqrex  x    eats x  y    plant y    eatsr  x  y 

   a 

pqrex  x    eats x  y    plant y    plantr  y 

   b 

add fact pqrex  c  c   gex   query dependent rules used initialise extension fresh predicates  subsequently makes rules
track kex   qex   gex   applicable 
query answers gap stem upper bound  consequently  order
rules    a     b  applicable data track kex   qex   gex   obtained
upper bound materialisation kex   following section show suffices
include facts c chase kex order ensure computed subset
contain necessary facts rules 
    subset definition properties
ready formally define datalog knowledge base used subset computation
well corresponding relevant subset 
definition      let g set possible answers q  let rel fresh unary predicate
let dr fresh constant unique r k   rq   furthermore  predicate
p k   rq   let p r fresh predicate arity p and  atom   p   t  
let r denote p r   t   normalised rule r   k   rq   let move r  following
conjunction atoms 
p r r form     


r x   
z   
    



r x 
    

then 

r form     

   

r x 
  

r form     

 r  following set rules 

 r     move r    body r    rel dr       move r    body r   

r
k

 

k

body r   

tracking knowledge base track k  q  g  smallest knowledge base containing
 i  facts c chase k 

 ii  rules r k rq  r  
   

fipagoda  pay as you go query answering using datalog reasoner

 iii  fact pqr   a   a   g 
 iv  fact p r q      
subset k relevant q g  denoted kq g   smallest knowledge base
containing
rule r   k track k  q  g     rel dr   
fact   dk track k  q  g     r  
brevity  write kq particular case g set gap answers uq   lq
defined sections         
 
note k  subset kq since track k     g    subset track k  q  gq   
definition      point  i  track k     g    track k  q  gq    furthermore 
set rules  ii  track k     g    subset track k  q  gq   since
k   r  k   rq   finally  fact p r   included track k     g    point  iii  
belongs track k  q  gq   point  iv  
example      consider running example  gex    tiger  lion  rabbit  
subset kex relevant qex gex consists rules r   r   r   r   r  facts
d   d   d   d   d   d   d   
 
key properties computed subsets established following theorem 
theorem      following properties hold 
    assume l       then  k unsatisfiable k  unsatisfiable 
    let q dierent   let g non empty set possible answers q w r t 
k  k satisfiable   a   cert q  k   a   cert q  kq g   every  a   g 
proof  direction         follows directly monotonicity firstorder logic  direction         follows completeness
hyperresolution following claim  establishes q non empty
g  kq g contains support hyperresolution derivations clause  q  g 
k   rq

  
q     
 q  g   
 pq   a     a   g  otherwise 
claim             derivation    q  g  k   rq   support   kq g  
show direction      assume k unsatisfiable  theorem      
theorem            u        thus g        exists hyperresolution
derivation   k  since     g          know support     k 
     k  unsatisfiable  show direction      assume  a   g
 a   cert q  k   exists hyperresolution   pq   a  k   rq   similarly 
     know support     kq g hence  a   cert q  kq g   
   

fizhou  cuenca grau  nenov  kaminski    horrocks

next show inductively statement     follow  let        
derivation clause  q  g  k   rq   let h   split k   already
established  see proof theorem       c chasek model h  since chaseh
universal model h exists homomorphism chaseh c chasek   show
following properties inductively every node v  
a  track k  q  g     r   atom  v  
b  track k  q  g     rel dr    sk r  main premise used obtain parent u v 
proceed induction distance v root  
base case  base case v root   property  b  follows vacuously
since v parent  
q      derivation empty clause  v  empty disjunction
and  property  a  follows vacuously 
otherwise   v    pq   a   a   g  definition track k  q  g   point
 iii      v  r   track k  q  g  hence property  a  holds 
inductive step  assuming properties  a   b  hold node u  show
hold children v            vn u  let r rule k sk r 
main premise relevant hyperresolution step mgu   i e    u         
        n hyperresolvent sk r          n        
 vi         n  using   easy observation composition
substitution homomorphism used later rest proof 
 

        arbitrary function free atom  

    

lemma     section       chaseh   n  since
homomorphism chaseh c chasek       c chasek
            c chasek   n  next show track k  q  g     move r   
     move r    p r   distinguish two cases 
q       p r   track k  q  g  point  iv  

q       s   c chasek hence pqr   track k  q  g  point  iii  
otherwise  induction hypothesis  track k  q  g      
      track k  q  g     jr       j m 

j

 r

therefore track k  q  g     move r    body rules  r  satisfied
substitution hence track k  q  g     rel dr    track k  q  g     ir    
  n        track k  q  g       ir     n  addition 
induction hypothesis  track k  q  g     r
    n  hence  shown
 a    b  hold child vi u 
remains shown  a   b  imply      indeed  take   support   
   

fipagoda  pay as you go query answering using datalog reasoner

fact k  leaf node   hence  property  a 
track k  q  g     r   then  since fact dk definition homomorphism ensures r   r   definition kq g implies   kq g  
rule k  property  b  track k  q  g     rel d    again 
definition kq g ensures   kq g  
completes proof theorem 
note claim     proof theorem establishes important property
computed subsets  namely proof preserving  is  support every
hyperresolution proof relevant gap answer original knowledge base k
contained computed subset  two key implications  first  every justification
 i e   minimal subset k entailing gap answer  contained subset 
way  subsets preserve formulas k relevant gap answers 
formulas disregarded seen irrelevant  second  fully fledged reasoner
whose underpinning calculus cast framework resolution able
compute subset derivations gap answers k  consequently 
practice reasonable expect fully fledged reasoner uniformly display
better performance computed subsets kan expectation borne
experiments 
conclude section example illustrating dataset track k  q  g 
 point   definition      obtained c chasek materialisation underpinning
upper bound section    rather c chasefk section     
example      consider query q x    e x  knowledge base k consisting
following rules facts 
a x    b x    d x 

d x    e x 

b x    e x 

a a 

let f function always choosing b a  d a   c chasefk    a a   b a   e a  
constant answer q x  gap lower upper bound  suppose
define track k  q  g  definition     replacing facts point  i 
c chasefk   since d a  hold c chasefk corresponding subset
contain rule d x    e x   essential derive e a  
 
    optimisations datalog encoding
conclude section  present two optimisations datalog encoding definition
    exploit system pagoda 
first optimisation aims reducing size computed subsets  recall
key step construction tracking knowledge base track k  q  g  invert
rules k capture hyperresolution proofs backwards fashion  consider
inversion      rule  r   running example  eect inversion capture applicability hyperresolution  facts mammal rabbit   herbivorer  rabbit 
meateaterr  rabbit  hold  include rule  r   subset since may proof
   

fizhou  cuenca grau  nenov  kaminski    horrocks

k involving step ground clause herbivore rabbit    meateater rabbit   
obtained resolving  r   mammal rabbit     
note  however  step redundant herbivore rabbit  already contained k  case  r   may needed relevant subset  capture
observation distinguishing tracking knowledge base facts c chase
k already present original dataset dk   encode implied
facts instantiating fresh predicates p predicate p k  running example 
fact meateateri  rabbit  tracking knowledge base establishes meateater rabbit 
present original data  use atoms predicates guards
inverted rules  e g  rule      would written follows 
herbivorei  x    meateateri  x    herbivorer  x 

  meateaterr  x    mammal x    mammalr  x 

formally  definition     optimised given next 
definition      let k  q  g predicates p r definition      predicate
p   let p fresh predicate arity p   redefine move r 
rule r following conjunction atoms 
p r r form     


x   
z   
    



x 
    

 

r x   
z   
    

   

x 
  

r form     

 

r x 
    

   

r x 
  

r form     

then   r  definition      track k  q  g  definition      extended
addition fact p   a  fact p   a  c chasek dk    
easy see optimisation aect correctness theorem     
disjunction atoms derived via hyperresolution  one atoms already
present data  disjunction subsumed dispensed with 
second optimisation used obtain succinct encoding datalog
reasoners support equality reasoning natively  such rdfox   already mentioned 
built in semantics equality predicate axiomatised within datalog  however 
axiomatisation lead performance issues  scalability improved native
treatment equality equal objects merged single representative
whole equivalence class 
axiomatisation equality significant eect tracking encoding 
example  replacement rules r form  eq   inverted following rules
 r  predicate p  
p r  x            xi

    y  xi             xn  

p r  x            xi

    y  xi             xn  

  p  x            xn     xi   p r  x            xn  
  p  x            xn     xi   r  xi   y 

    
    

     tautology dispensed with  rule      required 
datalog reasoner native support equality  need include
   

fipagoda  pay as you go query answering using datalog reasoner

tracking knowledge base inversion equality axioms  eq     eq    eq   
need include rules      order ensure computed subset required
properties  result succinct encoding materialised efficiently 
example      consider knowledge base k consists facts  r a    b   r a    b   a a    
following rules 
a x    b x    c x 

r x    y    r x    y    x  x 

    
    

b x    d x 
c x    d x 

    
    

let q   d x   gap g lower upper bounds q  a    a     easy
see rule      essential derive q a     ensure rule fragment
kq g   track a  a  using instance rule      
 
    comparison magic sets
idea inverting rules recording relevant information heavily exploited
logic programming  particular  magic set transformation  bancilhon  maier  sagiv 
  ullman        technique that  given program query  optimises materialisation process derive facts relevant query  similarly
tracking encoding  magic sets technique uses auxiliary predicates  called magic predicates  identify relevant facts  technique originally developed datalog 
subsequently extended handle negation failure  beeri  naqvi  ramakrishnan  shmueli    tsur        kemp  srivastava    stuckey        disjunctions  alviano 
faber  greco    leone      a  
contrast magic sets  goal transformation reduce size
materialisation  rather compute relevant fragment knowledge base potentially
given expressive  even undecidable  language  reduce computation
datalog reasoning  sense  technique orthogonal magic sets  indeed 
benefits technique relevant knowledge bases containing existentially
quantified and or disjunctive rules  if k datalog  query would fully
answered lower bound  
furthermore  worth noticing way invert  datalog  rules dierent
magic sets yields precise tracking  assumption
tracking starts already computed materialisation  see point  i  definition
      instance  given already adorned rule a x    b x    c x   magic sets would
produce following rules deriving magic predicates b b 
c  x     x 

c  x    a x    b  x 

rules used derive fact  a  c  a   even a a  cannot used
derive c a  aforementioned rule applicable  e g   b a  hold
c a  derived using rules   transformation  contrast  would yield
restrictive rules
c r  x    a x    b x    ar  x 

c r  x    a x    b x    b r  x 

applicable a a  b a  hold materialisation 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

   summarisation analysis answer dependencies
section  let q input query dierent unsatisfiability query   
k  kq computed  still need check  using fully fledged reasoner 
satisfiability k  well whether kq entails candidate answer gq  
computationally expensive subsets large complex  many
candidate answers verify  therefore exploit summarisation techniques  dolby et al  
      eort reduce number candidate answers 
idea behind summarisation shrink data knowledge base merging
constants instantiate unary predicates  since summarisation equivalent
extending knowledge base equality assertions constants  summary
knowledge base entails original one monotonicity first order logic  consequently  exploit summarisation follows 
   satisfiability k remains undetermined  construct summary k 
check satisfiability  satisfiable  k   and thus k  satisfiable 
   construct summary kq use fully fledged reasoner check whether
summary  a entailed certain answer q summary kq  
discarding answers entailed 
formally  summarisation defined follows 
definition      type set unary predicates  given constant c k  say
   a   a c    k  type c  type   let fresh constant
uniquely associated   summary function k substitution mapping
constant c k   type c  finally  summary k k    
following proposition shows summarisation exploited detect spurious
answers setting  since summarisation significantly reduce data size practice 
relevant subsets k  kq already significantly smaller k  checking
satisfiability k  gap answer kq becomes feasible many cases  even
though implies resorting fully fledged reasoner 
proposition      let summary function k  satisfiability k  implies
following   i  k satisfiable   ii  cert q  k  cert q   kq   every cq q 
example      case running example  constants tiger lion
type  mammal   therefore mapped fresh constant  say tmammal   uniquely
associated  mammal   since tmammal certain answer qex w r t  summary
kex   determine tiger lion spurious answers 
 
summarisation succeed pruning candidate answers g  try
last step reduce calls fully fledged reasoner exploiting dependencies
remaining candidate answers that  answer  a depends answer  c 
 a spurious   c 
consider two tuples  c d  constants gq   suppose find endomor  determine  by calling fully fledged
phism dataset dk  c   d 
 
reasoner  spurious answer  must  c  result  longer need
call fully fledged reasoner verify  c  endomorphisms defined next 
   

fipagoda  pay as you go query answering using datalog reasoner

definition      let  c    c            cn   d     d            dn   n tuples constants k 
endomorphism  c d  k mapping constants constants
 i  ci   di   n   ii  p  t            tm     dk fact p  t            tm     dk  
 iii  r   k r   k  
 
relevant property endomorphisms given following proposition 
proposition      let  c  d  possible answers q let endomorphism  c
d  k  then   c   cert q  k  implies d    cert q  k  
proof  since  c   cert q  k   know k    q  c   hyperresolution derivation
   t    pq   c  k   rq   easy check  t 
  hyperresolution
  k   rq   then  k    q d 
  hence d    cert q  k  
derivation pq  d 
exploit idea compute dependency graph candidate answer tuples
  whenever endomorphism dk exists mapping  c d 
  since
nodes edge   c  d 
computing endomorphisms hard resort practice sound greedy algorithm
approximate dependency graph  describe section   

   implementation  pagoda system
implemented approach system called pagoda  written java
available academic license  system integrates datalog reasoner
rdfox  motik et al         fully fledged owl   reasoner hermit  glimm et al  
      black boxes  exploit combined approach elhor   see section
     implemented karma  stefanoni et al         
pagoda accepts input arbitrary owl   dl ontologies  datasets turtle format
 prudhommeaux   carothers        cqs sparql  queries interpreted
ground certain answer semantics  former case  pagoda sound
complete  latter case  however  pagoda limited capabilities hermit 
check entailment ground dl concept queries  hence  pagoda
guarantee completeness lower upper bounds match  query
transformed dl concept query via internalisation  see section       otherwise 
pagoda returns sound  but possibly incomplete  set answers  along bound
incompleteness computed answer set 
architecture pagoda depicted figure    box figure   represents
component pagoda  indicates external systems exploited within
component  could  principle  use materialisation based datalog reasoner
supports cq evaluation incremental addition facts  fully fledged owl
  dl reasoner supports fact entailment 
pagoda uses four instances rdfox  one lower bound  c chase  cchasef subset extractor components  two instances hermit  one
summary filter dependency graph components  
process fully answering query divided several steps  here  distinguish query independent steps query dependent ones  see figure
   loading ontology materialisation steps query independent  therefore 

   

fizhou  cuenca grau  nenov  kaminski    horrocks

cert q    d 
heuristic planner

g  gq

hermit
q  gq

summary filter
hermit
q  gq

endomorphism
checker

full reasoning

kq

lq

subset extractor

tracking encoder

extracting subsets

rdfox
track   q  gq  

  q  gq

gq

lq
f



computing query bounds

soundanswers q    d 
certu   q    d 

m l
q
lower store
karma
rdfox

certu   q    d 

m u

m u
q

q
c chase

f

 

c chase
rdfox

rdfox



materialisation



shift

loading ontology   data

profile checker

normaliser
hermit clausifier


figure    architecture pagoda
counted pre processing steps  computing query bounds  extracting subset
full reasoning query dependent  called query processing steps 
next describe component  following process flow pagoda 
    loading ontology data
pagoda uses owl api parse input ontology o  dataset given
separately turtle format  normaliser computes set rules corresponding
axioms ontology  pagodas normaliser extension hermits clausification
component  glimm et al          transforms axioms so called dl clauses  motik
et al          dataset loaded directly  the four instances of  rdfox 
normalisation  ontology checked determine inside owl   rl
elhor    input ontology owl   rl  resp  elhor     rdfox  resp 
karma  already sound complete  cases pagoda simply processes
   

fipagoda  pay as you go query answering using datalog reasoner

ontology  dataset queries using relevant component  otherwise  pagoda uses
dedicated program shifting component enrich deterministic part ontology
additional information disjunctive rules  see section       resulting set rules  
    materialisation
three components involved step  namely lower bound  c chase cchasef   takes input d  computes materialisation  shown
figure   ellipses   lower bound component performs steps     section    
order compute aggregated lower bound m l   c chase c chasef components
compute m u m u upper bound materialisations described section     using
dedicated implementation c chase algorithm  chase sequence stored rdfox 
applicability existential disjunctive rules determined posing sparql
queries rdfox  applying disjunctive rule  while computing m u    pagoda
uses choice function select one disjuncts  discussed section      choice
function try select disjuncts  eventually  lead contradiction 
end  pagoda implements following heuristics 
construct standard dependency graph containing edge predicate p
q rule p occurs body q head  then  compute
preference ordering predicates occurring disjunction according
distance   dependency graph  preferring furthest   
exploit result materialising using shifting enriched rules  see
section       fact form p   a  obtained materialisation  p   a 
follows knowledge base  hence  obtained p   a   try
avoid choosing p   a  disjunct p   a    chase computation 
m l contains contradiction  input ontology dataset unsatisfiable 
pagoda reports terminates   s derived m u   computation
aborted m u longer used  m u contains  s   pagoda checks
satisfiability   d  eect  computes cert      d   answer query
non empty  input ontology dataset unsatisfiable  pagoda reports
terminates  otherwise input ontology dataset satisfiable  pagoda
able answer queries 
    computing query bounds
given query q  pagoda uses m l lower bound materialisation compute lower
bound answer lq   order exploits karmas implementation filtration
procedure  algorithm soundanswers section       clarity step shown separately  as circle f it  figure     s derived computing
m u materialisation  u q   cert q  m u     cert q  m u    otherwise u q   cert q  m u    either
case u q computed directly using rdfox answer q w r t  relevant materialisation 
extracting subsets tracking encoder component implements datalog encoding
based definition     optimisations described section      resulting
datalog knowledge base added rules data c chase component 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

rdfox used extend c chase materialisation accordingly  freshly derived facts
 over tracking predicates introduced tracking encoder  passed
subset extractor component  uses facts identify facts rules
relevant checking gap answers  computes intersection relevant facts
input dataset querying instance rdfox containing only 
    full reasoning
pagoda uses hermit verify gap answers gq   u q   lq   hermit accepts
queries given either facts dl concepts  implemented standard rolling up
technique transform internalisable cqs  summary filter component  pagoda uses
hermit filter gap answers entailed summary kq  see section    
remaining gap answers g  gq passed endomorphism checker 
exploits greedy algorithm compute incomplete dependency graph answers
g    graph used heuristic planner optimise order answers
g  checked using hermit  see section     verified answers g  combined
lower bound lq give cert q    d  
implementation summarisation straightforward  pagoda essentially merges
constants  explicit  types data 

 
 
 
 
 
 
 
 
 
  

 
 
 
 
 
 
 
 
 
  
  
  

input  knowledge base k   k   dk   two tuples  a                b            bn   
output  return true endomorphism  a               b            bn   k found 
otherwise  false 
    
foreach       n 
ai locally embeddable bi k return false 
else  ai     bi  
end
foreach       n 
check ai   bi   return false 
end
k    k return false 
else return true 
subroutine check a  b 
oa     c   p  ai   c    dk    ia     c   p  c  ai     dk   
ob     d   p  bi   d    dk    ib     d   p  d  bi     dk   
foreach    o  i  c   sa
    d   sb   c locally embedded d  
empty return false 
defined c
 c     similar constant c d 
check c  d  return false 
end
else  c     return false 
end

algorithm    greedy endomorphism checker 

   

fipagoda  pay as you go query answering using datalog reasoner

next describe greedy algorithm implemented pagoda checking answer
dependencies  see algorithm     given tuples  a               b            bn    algorithm
returns true able find endomorphism  false otherwise  algorithm
considers constant ai tries map bi locally  sense
immediate neighbourhoods ai bi considered stage  formally 
captured following notion local embedding 
definition      given k constant c let mc multiset containing occurrence
fact a c    dk   occurrence p binary fact p  c  c      dk  
occurrence p binary fact p  c    c    dk  
given constants c k  say c locally embeddable predicate
mc occurs  with cardinality  md  
 
check a  b  subroutine implements greedy search looking immediate neighbours b  specifically  subroutine considers neighbour c picks
neighbour b c locally embedded d  several choices
available  algorithm heuristically chooses one according jaccard similarity
multisets mc md    algorithm terminates success manages
compute mapping defined constants reachable  a             
k  immediate see computed endomorphism  a  b k  thus 
algorithm sound  algorithm works polynomial time choices made
construction never revisited local embeddability checked efficiently 

   related work
conjunctive query answering ontology enriched datasets received great deal
attention recent years  computational complexity thoroughly investigated
wide range kr languages number practicable algorithms proposed
literature implemented reasoning systems 
    computational complexity cq answering
decision problem associated cq answering conjunctive query entailment  cqe  
namely decide whether k    q  a  given input cq q  possible answer  a 
knowledge base k expressed  fixed  language l  problem well known
undecidable general  even q restricted atomic l language
existential rules  dantsin et al         
cqe knowledge bases stemming owl dl ontologies decidable
assumption query mention transitive relations  rudolph   glimm        
decidability cqe unrestricted owl dl owl   dl ontologies cqs remains
open problem  even cases cqe decidable  typically high
computational complexity  cqe   exptime complete expressive dls shiq
shoq  glimm et al         eiter  lutz  ortiz    simkus         hardness results
   jaccard similarity multisets   defined  m        m         m       counts
minimum number occurrences common element     whereas  m       counts
sum occurrences elements    

   

fizhou  cuenca grau  nenov  kaminski    horrocks

  exptime obtained already alci  lutz        well horn sroiq 
underpins horn fragment owl   dl  ortiz  rudolph    simkus         cqe
alc shq  involve inverse roles  exptime complete  lutz        
single exponential time results obtained horn dls disallowing complex role
inclusion axioms  cqe exptime complete horn shoiq  underpins horn
fragment owl dl  ortiz et al         
given high complexity cqe  recently increasing interest
lightweight dls cqe computationally easier  lightweight dls
incorporated owl   standard profiles  motik et al          cqe owl
  el profile pspace complete  stefanoni et al          furthermore  complexity
cqe drops np complex role inclusions  with exception transitivity
reflexivity  disallowed owl   el  stefanoni   motik         latter complexity
rather benign since cqe databases already np hard  finally  cqe owl
  ql profile np complete  calvanese et al          regarding data complexity 
cqe conp complete non horn dls  ale  schaerf         contrast 
data complexity ptime complete horn dls encode recursion  hornsroiq owl   el  ortiz et al         stefanoni et al          finally  data complexity
known ac  owl   ql profile  calvanese et al         
complexity cqe well understood rule based kr languages  plain
datalog  exptime complete combined complexity ptime complete w r t  data
complexity  disjunctive datalog  conexptime complete combined complexity
conp complete w r t  data complexity  datalog refers family decidable kr
languages based existential rules  cal  gottlob    lukasiewicz         includes
guarded  cal et al          sticky  cal  gottlob    pieris         acyclic  cuenca grau
et al         datalog   extension datalog languages disjunctive rules
recently studied  alviano et al       b  bourhis et al         
finally  refer ground query entailment  gcqe  problem checking whether
tuple  a ground answer q  x      y    x   y   w r t  k  kr languages allow
existentially quantified rules  restriction ground answers typically makes cqe easier 
definition ground answers means gcqe trivially reduced satisfiability
checking  consequently  gcqe decidable owl   dl 
    practical query answering approaches
o the shelf dl reasoners  pellet  sirin et al         hermit  glimm
et al         provide support query answering  pellet supports sparql conjunctive
queries implements rolling up technique  contrast  hermit provide
sparql api supports cqs form  complex  dl concepts  racer
among first dl reasoners implement optimise cq answering ground
semantics  haarslev  hidde  moller    wessel         finally  intensive
work optimising query answering dl systems  including filter and refine techniques
 wandelt et al          ordering strategies query atoms  kollia   glimm         data
summarisation  dolby et al          optimising cq answering dl reasoners complementary approach  use optimised dl reasoner could significantly
improve performance pagoda queries require full reasoning 

   

fipagoda  pay as you go query answering using datalog reasoner

rdf triple stores typically implement materialisation based  a k a  forward chaining 
reasoning algorithms  answer queries evaluating resulting materialisation  jena  mcbride        sesame  broekstra  kampman    van harmelen       
among first systems provide support rdf schema  modern triple stores
owlim  bishop et al          oracles native inference engine  wu et al         
provide extended suppport ontologies rl profile  additionally  rdfox  motik
et al         supports arbitrary datalog unary binary predicates  finally  asp
engines dlv  leone  pfeifer  faber  eiter  gottlob  perri    scarcello        implement sound complete reasoning  extensions of  disjunctive datalog  although triple
stores exhibit appealing scalability  support restricted ontology languages 
however  dl reasoners  improving scalability triple stores complementary
approach  advances area directly exploited pagoda 
technique cq answering lightweight dls receiving increasing attention
so called combined approach  lutz et al         stefanoni et al         kontchakov 
lutz  toman  wolter    zakharyaschev         combined approach dataset
first augmented new facts query independent way build  in polynomial time 
model ontology  model exploited query answering two equivalent
ways  approach lutz et al         kontchakov et al         query first
rewritten evaluated constructed model  alternatively  work
stefanoni et al         lutz et al         query first evaluated model
unsound answers eliminated means polynomial time filtration process 
combined approaches applied logics el family  lutz et al        
stefanoni et al         well dl lite  kontchakov et al          pagoda 
use implementation  stefanoni et al         compute aggregated lower bound 
cq answering horn ontologies often realised means query rewriting techniques  rewriting query q w r t  ontology another query q   captures
information necessary answer q arbitrary dataset  unions cqs
datalog common target languages query rewriting  query rewriting enables reuse
optimised data management system  ucqs answered using standard relational
databases  whereas datalog queries evaluated using triple store  query rewriting
successfully applied owl   ql ontologies  rewritability ucqs
guaranteed  example systems include quonto  acciarri  calvanese  de giacomo  lembo 
lenzerini  palmieri    rosati         mastro  calvanese  de giacomo  lembo  lenzerini 
poggi  rodriguez muro  rosati  ruzzi    savo         rapid  chortaras  trivela    stamou         prexto  rosati         ontop  bagosi  calvanese  hardi  komla ebri 
lanti  rezk  rodriguez muro  slusnys    xiao         systems
successful large scale applications  however  applicable owl   ql
size rewriting exponential size ontology  datalog based query
rewriting implemented systems requiem  perez urbina et al         
supports extension elhor  inverse roles  introduction inverse
roles  however  leads significant jump complexity  query answering elhor 
np complete  and tractable atomic queries   whereas becomes exptime complete
inverse roles introduced  furthermore  exptime hardness holds already unsatisfiability checking atomic queries   practice  restricting elhor 
allows us compute datalog program linear size straightforward way skolemis   

fizhou  cuenca grau  nenov  kaminski    horrocks

ing existentially quantified variables constants  furthermore  datalog materialisation
query independent queries without existentially quantified variables answered
directly materialisation  complex queries answered using filtration 
finally  similarly pagoda  system hydrowl  stoilos      a  combines owl
  rl reasoner query rewriting system fully fledged dl reasoner order
answer conjunctive queries owl   knowledge base  techniques hydrowl are 
however  rather dierent pagoda  hydrowl uses two dierent query answering
strategies  first one based repairing  stoilos      b  query rewriting 
applicable ontologies suitable repair exists  second strategy exploits
query base  set atomic queries hydrowl computes pre processing phase 
fully answered using triple store given ontology arbitrary
dataset  answering query q  hydrowl checks q covered query base  stoilos
  stamou         is  q completely evaluated using owl   rl reasoner 
otherwise  fully fledged reasoner used answer q  however  computation
query base appear correct general   believe accounts
apparent incompleteness hydrowl tests  see section         
    approximate reasoning
idea transforming ontology  data and or query obtain lower upper bound
answers already explored previous work  screech system  tserendorj et al  
      uses kaon   hustadt  motik    sattler        transform shiq ontology
 exponential size  disjunctive datalog program way ground answers
queries preserved  subsequently  screech exploit  unsound incomplete  techniques
transform disjunctive datalog plain datalog  way  screech computes
approximation answer  trowl  thomas et al         exploits approximation
techniques transform owl   ontology ontology ql profile  pan  
thomas         approximation first computes closure input ontology
entailment owl   ql axioms  disregards axioms outside owl   ql 
related approximations owl   ql proposed  e g   wandelt et al 
       console et al          efficient approximation strategies owl   ontologies
complementary approach  exploited pagoda order
refine lower upper bound query answers 

    evaluation
evaluated query answering system pagoda range realistic benchmark ontologies  datasets queries  compared performance stateof the art query answering systems  test data systems used comparison
introduced sections            respectively  results discussed section
      experiments conducted    core     ghz intel xeon e          gb
ram  running fedora     test ontologies  queries  results available online  
   stoilos      a  mentions limitation automatically extracting  the atomic queries  
   http   www cs ox ac uk isg tools pagoda      jair 

   

fipagoda  pay as you go query answering using datalog reasoner

lubm n 
uobm n 
fly
npd
dbpedia 
chembl
reactome
uniprot

 axioms
  
   
      
   
     
     
   
   

 rules
   
   
      
   
     
     
   
   

   rules
  
  
    
   
  
   
  
  

   rules
 
 
 
  
 
  
  
  

 facts
n    
   n    
     
       
       
       
       
       

table    statistics test datasets
     test ontologies queries
table   summarises test data  first two columns table indicate total
number dl axioms test ontology well total number rules
normalisation  interested ontologies captured owl   rl
hence cannot fully processed rdfox  thus  number rules containing existential
quantification disjunction especially relevant given third fourth
columns table  respectively  finally  rightmost column lists number data
facts dataset 
lubm uobm widely used reasoning benchmarks  guo  pan    heflin       
ma  yang  qiu  xie  pan    liu         ontology axioms benchmarks
manually created considered fixed  whereas data synthetically generated
according parameter n determines size  lubm uobm come      
standard queries  respectively  make tests lubm challenging  extended
benchmark    additional queries datalog lower bound answers
guaranteed complete  as case standard queries  
fly realistic ontology describes anatomy drosophila
currently integrated virtual fly brain tool   although data rather small
compared test cases  about        facts   ontology rich existentially
quantified rules  makes query answering especially challenging  tested   realistic
queries provided developers ontology 
npd factpages ontology describing petroleum activities norwegian
continental shelf  ontology comes realistic dataset containing     million facts 
unfortunately  npd realistic queries tested atomic queries
signature ontology 
dbpedia contains information wikipedia entries  although dataset rather
large  ontology axioms simple captured owl   rl  provide
challenging test  used ontology matching system logmap  jimenezruiz   cuenca grau        extend dbpedia tourism ontology containing
   http   www virtualflybrain org site vfb site overview htm

   

fizhou  cuenca grau  nenov  kaminski    horrocks

existential disjunctive rules  case npd example test queries 
focused evaluation atomic queries 
chembl  reactome  uniprot realistic ontologies made publicly available european bioinformatics institute  ebi  linked data platform   
ontologies especially interesting testing purposes  one hand 
ontology axioms data realistic used number applications 
hand  ontologies rich existentially quantified disjunctive rules 
datasets extremely large  furthermore  ebi website provides number
example queries ontologies  order test scalability datasets
well compare pagoda systems implemented data sampling algorithm
based random walks  leskovec   faloutsos        computed subsets data
increasing size  used evaluation example queries correspond cqs
well atomic queries relevant signature 
     comparison systems
compared pagoda four ontology reasoners  hermit  v         pellet  v        
trowl bgp  v       hydrowl  v       single exception trowl 
systems implement sound complete algorithms standard reasoning tasks owl
  dl ontologies  including ontology consistency checking concept instance retrieval 
additionally  hermit provide support sparql queries 
pointed section    many systems answer queries
ontologies  however  systems generally designed specific fragments
owl    incomplete ontologies outside fragments  although trowl
incomplete owl    included evaluation is 
one hand  widely used system semantic web applications and  hand 
similar pagoda exploits ontology approximation techniques  follows 
describe capabilities systems detail 
hermit fully fledged owl   reasoner based hypertableau calculus  motik
et al         glimm et al          hermit focuses standard reasoning tasks dls 
provide sparql conjunctive query answering api  capable
answering atomic queries unary predicates checking fact entailment 
pellet tableau based owl   dl reasoner support cq answering  sirin et al  
       pellet provides sparql api  hence compute set ground
answers arbitrary conjunctive queries expressed sparql  pellet capable
computing certain answers internalisable conjunctive queries using rolling up
technique  see section      
trowl system based approximated reasoning  accepts input arbitrary
owl   dl ontology cq sparql  aims computing ground answers
given query  thomas et al          trowl exploits technique approximates
input ontology owl   ql profile  provide completeness guarantees 
    http   www ebi ac uk rdf platform

   

fipagoda  pay as you go query answering using datalog reasoner

correct 

incomplete 

unsound 

error 

kmeout 

cannot handle 

     
    
    
    
    
    

tr

tr

pe hy

pe hy

tr

pe hy

tr

tr

pe hy

pe hy

tr

pe hy

tr

pe hy

tr

pe hy

tr

pe hy

tr

pe hy

    
    
    
    

  
 
 
pr
ot
un


em


ac


e 
  
 
 

bl
  
 
 

 
db
pe


ia
ch

np
d 

fa

ct
pa
ge
s 

le
du
p 
ro
l
y 
fl

  
ro
l

le
du
p 

  
uo
bm

uo
bm

le
du
p 
  
ro
l
lu
bm

lu
bm

  

   

figure    quality answers computed system  four bars ontology
represent trowl  pellet  hermit hydrowl respectively 
hydrowl  stoilos      a  hybrid reasoning system similar spirit pagoda
 see section     detailed comparison   hydrowl integrates triple store owlim
hermit  accepts input arbitrary owl   ontology conjunctive queries rules 
computes ground answers query 
     experiments results
performed three dierent experiments  first experiment  compared
pagoda mentioned systems  respect quality
answers  i e   number correctly answered queries  performance relative
pagoda  second experiment  evaluated scalability considering datasets
increasing size  finally  third experiment  evaluated eectiveness
dierent reasoning techniques implemented pagoda 
       comparison systems
compared pagoda systems test ontologies  used
lubm    uobm    since already rather hard systems  similarly  used relatively small samples ebi platform ontologies     data
chembl uniprot      reactome  processed majority
systems  test ontology computed ground answers corresponding
test queries  whenever possible used internalisation  see section      additionally
compute certain answers  case fly  test queries yield empty set
ground answers  case computed certain answers  all fly queries
internalised   set timeouts    minutes answering individual query   
hours answering queries given ontology 
figure   summarises quality answers computed reasoner  bar
figure represents performance particular reasoner w r t  given ontology
   

fipellet 

hermit 

hydrowl 

db
pe


trowl 

ct
pa
ge
s 

zhou  cuenca grau  nenov  kaminski    horrocks

     

    

   

  
 
 
pr
ot
un


em


ac


e 
  
 
 

bl
  
 
 

 
ia
ch

fa
np
d 

le
du
p 
ro
l
y 
fl

  
ro
l

le
du
p 

  
uo
bm

le
du
p 
  
ro
l

uo
bm

  

lu
bm

lu
bm

  

  

figure    performance comparison systems  bar depicts total time
answer test queries relevant ontology comparison pagoda 
set test queries  use green indicate percentage queries reasoner
computed correct answers  correctness determined majority voting 
blue  resp  purple  indicate percentage queries reasoner
incomplete  resp  unsound   red  orange grey indicate  respectively  percentage
queries reasoner reported exception execution  accept
input query  exceeded timeout  criterion correctness  pagoda
able correctly compute answers every query test ontology within given
timeouts  consequently  performance pagoda represented figure 
figure   summarises performance system relative pagoda 
case considered queries relevant system yields answer  even
computed answer unsound and or incomplete   ideal  chose
consider queries  rather queries relevant system
yields correct answer   i  resulting time measurement obviously closer
time would required correctly answer queries   ii  correctness
relative gold standard query answers  ontology
reasoner  corresponding bar shows t   t   on logarithmic scale   t   resp  t   
total time required pagoda  resp  compared system  compute answers
queries consideration  missing bar indicates comparison system failed
answer queries within given timeout  please note two dierent bars
ontology comparable may refer dierent sets queries  bar
needs considered isolation 
draw following conclusions results experiments 
trowl faster pagoda lubm rolling up  uobm rolling
fly rolling up  incomplete      lubm queries  
  uobm queries  chembl  trowl exceeds timeout performing
satisfiability check  remaining ontologies  pagoda efficient spite
fact trowl incomplete queries  even unsound several
uniprot queries 
   

fipagoda  pay as you go query answering using datalog reasoner

pellet one robust systems evaluation  although times
fly ontology  succeeds computing answers remaining cases 
observe  however  cases pellet significantly slower pagoda 
sometimes two orders magnitude 
hermit answer queries one distinguished variable  could
evaluate atomic binary queries  see hermit exceeds timeout many
cases  tests hermit succeeds  significantly slower pagoda 
although hydrowl based theoretically sound complete algorithm 
found incomplete tests  exceeded timeout queries
three ontologies  ran memory queries another two
ontologies  reported exception chembl     remaining cases 
significantly slower pagoda 
       scalability tests
tested scalability pagoda lubm  uobm ontologies ebi
linked data platform  lubm used datasets increasing size step n  
     uobm used increasingly large datasets step n      
considered smaller step n     hard queries  finally  case ebis datasets 
implemented data sampling algorithm based random walks computed subsets
data increasing sizes    original dataset      steps
     used test queries described section      ontologies 
section         computed ground answers and  whenever possible  used internalisation
additionally compute certain answers  test ontology measured following 
pre processing time  includes pre processing steps section   well
satisfiability checking  i e   query processing boolean unsatisfiability query  
query processing time  time perform query processing steps
query given ontology  organise test queries following three
groups depending techniques exploited pagoda compute answers 
g   queries lower upper bounds coincide 
g   queries non empty gap  summarisation able filter
remaining candidate answers 
g   queries fully fledged reasoner called ontology subset
least one test datasets 
scalability test  set timeout   hours answering queries     hours
individual query  lubm uobm  increased size dataset
pagoda exceeded timeout  ontologies  pagoda able answer
queries within timeout  even largest dataset 
pellet compared system found sound complete test
ontologies queries  conducted scalability tests it  scalability
pellet is  however  limited  already failed lubm       uobm     well chembl
   

fi    

g      

    

thousands seconds 

thousands seconds 

zhou  cuenca grau  nenov  kaminski    horrocks

    
    
    

q   

q   

  
  
  
  
  
  
  
  

    

  

    

  

  

    

    

    

    

    

    

    

    

  

    

    

    

    

    

    

    

 b  lubm query processing

   

g      

   

thousands seconds 

thousands seconds 

 a  lubm pre processing

    

   
  
  

g     

q   

    
  
    
  

  

    

  
  
  

    

    

    

    

  

    

  

 c  uobm pre processing

    

    

    

    

    

 d  uobm query processing

figure    scalability tests benchmarks
    uniprot      dataset pellet managed process least two data
samples reactome  succeeded samples smaller      case
reactome discussed detail later on 
results summarised figures      ontology  plot time
size input dataset  query processing distinguish dierent groups
queries discussed above  pagoda behaves relatively uniformly queries g 
g   plot average time per query groups  contrast  pagodas
behaviour queries g  quite variable  plot time individual query 
lubm n  shown figure  a  pre processing fast  times appear scale linearly increasing dataset size  lubm queries belong either g  g 
latter group containing two queries  figure  b illustrates average query processing
time queries g   never exceeds    seconds  well time
two queries g   q   q     reaches       seconds lubm      
accounted hermit 
uobm n  shown figure  c  pre processing times significantly higher
lubm  reflecting increased complexity ontology  still appear scale linearly
dataset size  lubm  test queries contained g  
processing times never exceeds   seconds uobm    uobm       found one
query g   processing times query somewhat longer g 
reached    s uobm       finally  found one query  q    that  due uobms
   

fi   

g        

   

seconds 

thousands  seconds 

pagoda  pay as you go query answering using datalog reasoner

  
  
  
  
  
   

                                                  

     
     
     
     
     
     
     
     
     
     
     
                                                      

 a  chembl pre processing
pellet 

g       

   

seconds 

hundreds seconds 

pagoda 

 b  chembl query processing

   

g     

q   

pellet q   

     
    

   
  

    

  

    

  
    

  
  

  
         

    

    

         

    

    

          

                                                  

 c  reactome pre processing
unsa sable 

g       

    

seconds 

thousands seconds 

satsiable 

 d  reactome query processing

    

g     

   
   
   

    
   

    

  

    

  

                                                      

   

 e  uniprot pre processing

    

    

    

    

 f  uniprot query processing

figure    scalability tests ebi linked data platform
randomised data generation  dierent groups dierent datasets  uobm    
uobm     uobm     g   hermit called relevant subsets
fully answer query  uobm     g   hermit called
summary relevant subset  remaining cases shown figure  d
g   lower upper bounds coincided  query timed uobm     
due time taken hermit reason relevant subset  shown
times remaining g  g  queries uobm      
chembl shown figure  a  pre processing times significant manageable 
appear scale linearly dataset size  test queries contained g  

   

fizhou  cuenca grau  nenov  kaminski    horrocks

total
l    u  
l    u  
l    u  
l    u   

lubm
     
  
  
  
  
  

uobm
   
  
 
 
  
  

fly

npd

dbpedia

 
 
 
 
 

   
   
   
   
   

    
    
    
    
    

chembl
  
    
    
    
    
    

reactome
   
   
  
  
  
   

uniprot
  
   
   
   
   
   

table     queries answered dierent bounds
figure  b illustrates average processing times queries  less    s
datasets increases smoothly dataset size 
reactome shown figure  c  pre processing times appear scale quite
smoothly  groups g  g  contained one query  remaining queries
belonging g   query processing times shown figure  d  average query processing time queries g  never exceeded    seconds  average processing times g 
queries appeared grow linearly size datasets  average time never exceeded
   seconds  finally  seen g  query  q    much challenging 
could still answered less     seconds  even largest dataset 
already mentioned  tested scalability pellet reactome  pellet
able process samples size               pre processing time pellet
datasets comparable pagoda shown figure  c  average queryprocessing times queries g  g  slightly higher pagoda 
contrast  times query q   significantly higher     s     s       s reactome
              respectively  see figure  d   processing times q   pagoda 
however  grow smoothly thanks eectiveness subset extraction technique 
able keep input fully fledged reasoner small  even largest datasets 
uniprot contrast cases  uniprot whole unsatisfiable  sampling
technique can  however  produce satisfiable subset  figure  e illustrates pre processing
times  seen  drop abruptly unsatisfiable samples      larger  
unsatisfiability efficiently detected lower bound  figure shows
time detect inconsistency      even less     
time dominated loading time  i o performance varies run run  query
processing times considered satisfiable samples  see figure  f  
queries g   four g   observe average times queries
appear scale linearly data size groups 
       effectiveness implemented techniques
evaluated eectiveness various reasoning techniques implemented
pagoda comparing numbers test queries fully answered using
relevant technique 
query bounds sections     described dierent techniques computing lower
upper bound query answers  table   illustrates eectiveness bounds
   

fipagoda  pay as you go query answering using datalog reasoner

facts
rules

lubm
    
    

uobm
     
     

fly
    
    

npd
     
     

dbpedia
        
    

reactome
    
    

uniprot
        
    

table    size largest subsets given percentage input rules facts 
terms number queries bounds coincided test ontologies 
table  refer lower bound described section     l  aggregated
lower bound described section     l    similarly  refer three upper bound
computation techniques discussed section     u    u    u  combined upper
bound u      observe following experiments 
basic lower upper bounds suffice answer queries many
test ontologies  particular  l  u  matched       queries
lubm               npd           dbpedia           
chembl          uniprot 
aggregated lower bound l  eective case fly  basic
bounds match query  useful lubm  yielding matching
bounds   queries 
refined treatment existential rules described section      yields
upper bound u    especially eective uobm    reactome  many
existentially quantified rules already satisfied lower bound materialisation 
finally  refined treatment disjunctive rules section      yields combined upper bound u      instrumental obtaining additional matching bounds
non horn ontologies  could answer additional   queries uobm       
npd    dbpedia     chembl     reactome     uniprot 
overall  obtained matching bounds queries test ontologies 
could answer queries chembl    fly dbpedia   
reactome lubm         uobm    uniprot    npd 
subset extraction table   shows  dataset  maximum percentage facts
rules included relevant subset test queries non matching
bounds  observe subset extraction eective cases terms facts
rules  uniprot dbpedia  reduction data size especially dramatic 
interesting observe large reduction number rules fly 
rather complex ontology  finally  subset extraction least eective npd
uobm  even cases reduction almost one order magnitude
size ontology dataset 
turn attention summarisation dependency analysis  eectiveness
techniques measured number hard calls hermit required
fully answer query  call hermit considered hard knowledge base
passed hermit summary  first row table   shows number gap
   

fizhou  cuenca grau  nenov  kaminski    horrocks

l    u   
  sum
  dep

lubm
     
     
 
 

   
   
 

uobm
        
      
 
 

   
   
 

fly
   
   
 

dbpedia
  
 
 

npd
   
 
 

reactome
  
  
 
  
 
  

uniprot
   
 
 

table    number hard calls hermit fully answer query
answers query l  u    bounds match  without optimisation 
would call hermit number times fully answer query  row  
 resp  row    shows number hard calls hermit applying summarisation  resp 
summarisation plus dependency analysis   mentioned above  respectively  
  queries non matching bounds npd uniprot  however 
groups  summarisation dependency analysis identical eects queries
group  present one representative query ontology 
summarisation already discussed  summarisation enables pagoda fully answer
number test queries non empty gaps  instrumental fully answering one
query uobm     dbpedia reactome  well   queries npd   
queries uniprot  even cases summarisation suffice fully answer
query  eective reducing size gap  instance  one queries
uobm    obtained       gap answers     ruled summarisation 
dependency analysis lubm      two queries gap    answers
   answers  respectively  cases  answers merged single group 
hence single call hermit sufficed complete computation  similarly  uobm   
single call hermit sufficient  even though three queries gap
involved large number candidate answers  fly      answers remaining
verified summarisation    hard calls hermit required  finally 
case reactome one query    gap answers  dependency analysis reduced
number calls hermit    

    conclusions
paper  investigated novel pay as you go approach conjunctive query
answering combines datalog reasoner fully fledged reasoner  key feature
approach delegates bulk computation datalog reasoner
resorts fully fledged reasoner necessary fully answer query 
reasoning techniques proposed general applicable
wide range knowledge representation languages  main goal practice  however 
realise approach highly scalable robust query answering system
owl   dl ontologies  called pagoda  extensive evaluation
confirmed feasibility approach practice  system pagoda
significantly ourperforms state of the art reasoning systems terms robustness
scalability  particular  experiments using ontologies ebi linked data
platform shown pagoda capable fully answering queries highly complex
expressive ontologies realistic datasets containing hundreds millions facts 
   

fipagoda  pay as you go query answering using datalog reasoner

acknowledgments
extended version conference publications  zhou  nenov  cuenca grau   
horrocks        zhou  nenov  grau    horrocks         work supported
royal society royal society research fellowship  epsrc projects
score   masi    dbonto  well eu fp  project optique 

references
abiteboul  s   hull  r     vianu  v   eds            foundations databases  logical
level  addison wesley longman publishing co   inc   boston  ma  usa 
acciarri  a   calvanese  d   de giacomo  g   lembo  d   lenzerini  m   palmieri  m    
rosati  r          quonto  querying ontologies  veloso  m  m     kambhampati 
s   eds    aaai       proceedings twentieth national conference artificial intelligence seventeenth innovative applications artificial intelligence
conference  july             pittsburgh  pennsylvania  usa  pp            aaai
press   mit press 
afrati  f  n   cosmadakis  s  s     yannakakis  m          datalog vs  polynomial time 
j  comput  syst  sci                  
alviano  m   faber  w   greco  g     leone  n       a   magic sets disjunctive datalog
programs  artificial intelligence                 
alviano  m   faber  w   leone  n     manna  m       b   disjunctive datalog existential quantifiers  semantics  decidability  complexity issues  theory practice
logic programming                   
baader  f   brandt  s     lutz  c          pushing el envelope  ijcai      
proceedings nineteenth international joint conference artificial intelligence 
edinburgh  scotland  uk  july    august          pp         
baader  f   calvanese  d   mcguinness  d  l   nardi  d     patel schneider  p  f         
description logic handbook  theory  implementation  applications  cambridge univ  press 
bagosi  t   calvanese  d   hardi  j   komla ebri  s   lanti  d   rezk  m   rodriguez muro 
m   slusnys  m     xiao  g          ontop framework ontology based data access  zhao  d   du  j   wang  h   wang  p   ji  d     pan  j  z   eds    csws      
proceedings semantic web web science    th chinese conference  wuhan 
china  august             revised selected papers  vol      communications
computer information science  pp        springer 
bancilhon  f   maier  d   sagiv  y     ullman  j  d          magic sets strange
ways implement logic programs  silberschatz  a   ed    proceedings fifth
acm sigact sigmod symposium principles database systems  march             cambridge  massachusetts  usa  pp       acm 
beeri  c   naqvi  s  a   ramakrishnan  r   shmueli  o     tsur  s          sets negation
logic database language  ldl    vardi  m  y   ed    proceedings sixth
   

fizhou  cuenca grau  nenov  kaminski    horrocks

acm sigact sigmod sigart symposium principles database systems 
march              san diego  california  usa  pp        acm 
bishop  b   kiryakov  a   ognyano  d   peikov  i   tashev  z     velkov  r         
owlim  family scalable semantic repositories  semantic web              
bourhis  p   morak  m     pieris  a          impact disjunction query answering guarded based existential rules  ijcai       proceedings   rd
international joint conference artificial intelligence  beijing  china  august     
      pp          aaai press 
broekstra  j   kampman  a     van harmelen  f          sesame  generic architecture
storing querying rdf rdf schema  horrocks  i     hendler  j  a 
 eds    iswc       proceedings semantic web   first international semantic
web conference  sardinia  italy  june             proceedings  vol       lecture
notes computer science  pp        springer 
bry  f   eisinger  n   eiter  t   furche  t   gottlob  g   ley  c   linse  b   pichler  r     wei 
f          foundations rule based query answering  antoniou  g   amann  u  
baroglio  c   decker  s   henze  n   patranjan  p     tolksdorf  r   eds    reasoning
web       vol       lecture notes computer science  pp        springer 
cal  a   gottlob  g     kifer  m          taming infinite chase  query answering
expressive relational constraints  journal artificial intelligence research     
       
cal  a   gottlob  g     lukasiewicz  t          general datalog based framework
tractable query answering ontologies  j  web sem            
cal  a   gottlob  g   lukasiewicz  t   marnette  b     pieris  a          datalog    
family logical knowledge representation query languages new applications 
lics       proceedings   th annual ieee symposium logic computer
science        july       edinburgh  united kingdom  pp          ieee computer
society 
cal  a   gottlob  g     pieris  a          new expressive languages ontological query
answering  burgard  w     roth  d   eds    aaai       proceedings twentyfifth aaai conference artificial intelligence  san francisco  california  usa 
august             vol     pp            aaai press 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rodriguez muro  m  
rosati  r   ruzzi  m     savo  d  f          mastro system ontology based
data access  semantic web              
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable
reasoning efficient query answering description logics  dl lite family 
journal automated reasoning                 
chortaras  a   trivela  d     stamou  g  b          optimized query rewriting owl
  ql  bjrner  n     sofronie stokkermans  v   eds    cade     proceedings
  rd international conference automated deduction  wroclaw  poland  july
     august          vol       lecture notes computer science  pp         
springer 
   

fipagoda  pay as you go query answering using datalog reasoner

console  m   mora  j   rosati  r   santarelli  v     savo  d  f          eective computation
maximal sound approximations description logic ontologies  iswc      
proceedings semantic web     th international semantic web conference 
riva del garda  italy  october              proceedings  part ii  pp         
cuenca grau  b   horrocks  i   krotzsch  m   kupke  c   magka  d   motik  b     wang  z 
        acyclicity notions existential rules application query answering
ontologies  journal artificial intelligence research             
cuenca grau  b   horrocks  i   motik  b   parsia  b   patel schneider  p  f     sattler  u 
        owl    next step owl  journal web semantics                
cuenca grau  b   motik  b   stoilos  g     horrocks  i          completeness guarantees
incomplete ontology reasoners  theory practice  journal artificial intelligence
research             
dantsin  e   eiter  t   gottlob  g     voronkov  a          complexity expressive
power logic programming  acm computing surveys                 
dolby  j   fokoue  a   kalyanpur  a   kershenbaum  a   schonberg  e   srinivas  k    
ma  l          scalable semantic retrieval summarization refinement 
aaai       proceedings twenty second aaai conference artificial intelligence  july              vancouver  british columbia  canada  pp          aaai
press 
dolby  j   fokoue  a   kalyanpur  a   schonberg  e     srinivas  k          scalable highly
expressive reasoner  sher   journal web semantics                
eiter  t   fink  m   tompits  h     woltran  s          simplifying logic programs
uniform strong equivalence  lpnmr       proceedings logic programming
nonmonotonic reasoning    th international conference  fort lauderdale  fl 
usa  january            proceedings  pp       
eiter  t   lutz  c   ortiz  m     simkus  m          query answering description logics
transitive roles  boutilier  c   ed    ijcai       proceedings   st
international joint conference artificial intelligence  pasadena  california  usa 
july              pp         
eiter  t   ortiz  m     simkus  m          conjunctive query answering description
logic sh using knots  journal computer system sciences               

erling  o     mikhailov  i          virtuoso  rdf support native rdbms  virgilio 
r  d   giunchiglia  f     tanca  l   eds    semantic web information management
  model based perspective  pp          springer 
glimm  b   horrocks  i   motik  b   stoilos  g     wang  z          hermit  owl  
reasoner  journal automated reasoning                 
glimm  b   lutz  c   horrocks  i     sattler  u          conjunctive query answering
description logic shiq  journal artificial intelligence research             

grosof  b  n   horrocks  i   volz  r     decker  s          description logic programs 
combining logic programs description logic  hencsey  g   white  b   chen 
y  r   kovacs  l     lawrence  s   eds    www       proceedings twelfth
   

fizhou  cuenca grau  nenov  kaminski    horrocks

international world wide web conference  budapest  hungary  may             
pp        acm 
guo  y   pan  z     heflin  j          lubm  benchmark owl knowledge base
systems  journal web semantics                  
haarslev  v   hidde  k   moller  r     wessel  m          racerpro knowledge representation reasoning system  semantic web                
horrocks  i   kutz  o     sattler  u          even irresistible sroiq  kr
      proceedings tenth international conference principles knowledge
representation reasoning  lake district united kingdom  june           
pp       
horrocks  i   patel schneider  p  f     van harmelen  f          shiq rdf
owl  making web ontology language  journal web semantics        
    
horrocks  i     tessaris  s          conjunctive query language description logic
aboxes  kautz  h  a     porter  b  w   eds    aaai iaai       proceedings
seventeenth national conference artificial intelligence twelfth conference
innovative applications artificial intelligence  july      august          austin 
texas  usa   pp          aaai press   mit press 
hustadt  u   motik  b     sattler  u          reasoning description logics reduction
disjunctive datalog  journal automated reasoning                 
jimenez ruiz  e     cuenca grau  b          logmap  logic based scalable ontology
matching  aroyo  l   welty  c   alani  h   taylor  j   bernstein  a   kagal  l   noy 
n  f     blomqvist  e   eds    iswc       semantic web     th international
semantic web conference  bonn  germany  october              proceedings  part
i  vol       lecture notes computer science  pp          springer 
kemp  d  b   srivastava  d     stuckey  p  j          bottom up evaluation query
optimization well founded models  theoretical computer science               
    
kollia  i     glimm  b          optimizing sparql query answering owl ontologies 
journal artificial intelligence research             
kontchakov  r   lutz  c   toman  d   wolter  f     zakharyaschev  m          combined approach ontology based data access  walsh  t   ed    ijcai      
proceedings   nd international joint conference artificial intelligence 
barcelona  catalonia  spain  july              pp            ijcai aaai 
leone  n   pfeifer  g   faber  w   eiter  t   gottlob  g   perri  s     scarcello  f         
dlv system knowledge representation reasoning  acm transactions
computational logic                
leskovec  j     faloutsos  c          sampling large graphs  kdd       proceedings
twelfth acm sigkdd international conference knowledge discovery
data mining  philadelphia  pa  usa  august              pp         

   

fipagoda  pay as you go query answering using datalog reasoner

lutz  c          complexity conjunctive query answering expressive description logics  armando  a   baumgartner  p     dowek  g   eds    ijcar      
proceedings  th international joint conference automated reasoning  sydney 
australia  august              vol       lecture notes computer science  pp 
        springer 
lutz  c   seylan  i   toman  d     wolter  f          combined approach obda 
taming role hierarchies using filters  alani  h   kagal  l   fokoue  a   groth  p  t  
biemann  c   parreira  j  x   aroyo  l   noy  n  f   welty  c     janowicz  k   eds   
iswc       proceedings semantic web     th international semantic web
conference  sydney  nsw  australia  october              proceedings  part i  vol 
     lecture notes computer science  pp          springer 
lutz  c   toman  d     wolter  f          conjunctive query answering description logic el using relational database system  boutilier  c   ed    ijcai
      proceedings   st international joint conference artificial intelligence 
pasadena  california  usa  july              pp           
ma  l   yang  y   qiu  z   xie  g  t   pan  y     liu  s          towards complete owl
ontology benchmark  sure  y     domingue  j   eds    eswc       semantic
web  research applications   rd european semantic web conference  budva 
montenegro  june              proceedings  vol       lecture notes computer
science  pp          springer 
manola  f     miller  e          rdf primer  w c recommendation  available
http   www w  org tr rdf primer  
marnette  b          generalized schema mappings  termination tractability 
pods       proceedings twenty eigth acm sigmod sigact sigart
symposium principles database systems  june      july          providence 
rhode island  usa  pp       
mcbride  b          jena  implementing rdf model syntax specification 
semweb       proceedings second international workshop semantic
web 
moller  r   neuenstadt  c   ozcep  o  l     wandelt  s          advances accessing
big data expressive ontologies  timm  i  j     thimm  m   eds    ki      
proceedings advances artificial intelligence     th annual german conference
ai  koblenz  germany  september              vol       lecture notes
computer science  pp          springer 
motik  b   cuenca grau  b   horrocks  i   wu  z   fokoue  a     lutz  c          owl  
web ontology language profiles  second edition   w c recommendation  available
http   www w  org tr owl  profiles  
motik  b   nenov  y   piro  r   horrocks  i     olteanu  d          parallel materialisation
datalog programs centralised  main memory rdf systems  brodley  c  e    
stone  p   eds    aaai       proceedings twenty eighth aaai conference
artificial intelligence  july               quebec city  quebec  canada   pp         
aaai press 
   

fizhou  cuenca grau  nenov  kaminski    horrocks

motik  b   shearer  r     horrocks  i          hypertableau reasoning description logics 
journal artificial intelligence research             
ortiz  m   rudolph  s     simkus  m          query answering horn fragments
description logics shoiq sroiq  ijcai       proceedings   nd
international joint conference artificial intelligence  barcelona  catalonia  spain 
july              pp           
pan  j  z     thomas  e          approximating owl dl ontologies  aaai      
proceedings twenty second aaai conference artificial intelligence  july
             vancouver  british columbia  canada  pp           
perez urbina  h   motik  b     horrocks  i          tractable query answering rewriting
description logic constraints  journal applied logic                
prudhommeaux  e     carothers  g          rdf     turtle  w c recommendation 
available http   www w  org tr turtle  
robinson  j  a     voronkov  a   eds            handbook automated reasoning  in  
volumes   elsevier mit press 
rodriguez muro  m     calvanese  d          high performance query answering
dl lite ontologies  brewka  g   eiter  t     mcilraith  s  a   eds    kr      
proceedings principles knowledge representation reasoning  thirteenth
international conference  rome  italy  june              pp          aaai press 
rosati  r          prexto  query rewriting extensional constraints dl   lite 
simperl  e   cimiano  p   polleres  a   corcho  o     presutti  v   eds    eswc
      proceedings semantic web  research applications    th extended
semantic web conference  heraklion  crete  greece  may              vol      
lecture notes computer science  pp          springer 
rudolph  s     glimm  b          nominals  inverses  counting  conjunctive queries or 
infinity friend   journal artificial intelligence research             
schaerf  a          complexity instance checking problem concept languages
existential quantification  komorowski  h  j     ras  z  w   eds    ismis
      proceedings methodologies intelligent systems   th international symposium  trondheim  norway  june              vol      lecture notes computer
science  pp          springer 
sirin  e   parsia  b   cuenca grau  b   kalyanpur  a     katz  y          pellet  practical
owl dl reasoner  journal web semantics              
staab  s     studer  r   eds            handbook ontologies  international handbooks
information systems  springer 
stefanoni  g     motik  b          answering conjunctive queries el knowledge bases
transitive reflexive roles  bonet  b     koenig  s   eds    aaai      
proceedings   th aaai conference artificial intelligence  austin  tx  usa 
aaai press  appear 
stefanoni  g   motik  b     horrocks  i          introducing nominals combined
query answering approaches el  aaai       proceedings twenty seventh
aaai conference artificial intelligence  pp           
   

fipagoda  pay as you go query answering using datalog reasoner

stefanoni  g   motik  b   krotzsch  m     rudolph  s          complexity answering
conjunctive navigational queries owl   el knowledge bases  journal
artificial intelligence research             
stoilos  g       a   hydrowl  hybrid query answering system owl   dl ontologies 
rr       proceedings web reasoning rule systems    th international
conference  athens  greece  september              pp         
stoilos  g       b   ontology based data access using rewriting  owl   rl systems
repairing  presutti  v   damato  c   gandon  f   daquin  m   staab  s     tordai 
a   eds    semantic web  trends challenges     th international conference 
eswc       anissaras  crete  greece  may              proceedings  vol      
lecture notes computer science  pp          springer 
stoilos  g     stamou  g  b          hybrid query answering owl ontologies 
schaub  t   friedrich  g     osullivan  b   eds    ecai          st european conference artificial intelligence        august       prague  czech republic   including prestigious applications intelligent systems  pais        vol      frontiers
artificial intelligence applications  pp          ios press 
thomas  e   pan  j  z     ren  y          trowl  tractable owl   reasoning infrastructure 
eswc       proceedings semantic web  research applications   th
extended semantic web conference  heraklion  crete  greece  may      june         
part ii  pp         
tserendorj  t   rudolph  s   krotzsch  m     hitzler  p          approximate owlreasoning screech  calvanese  d     lausen  g   eds    rr       proceedings
web reasoning rule systems  second international conference  karlsruhe 
germany  october    november          vol       lecture notes computer
science  pp          springer 
w c sparql working group         sparql     overview  w c recommendation 
available http   www w  org tr sparql   overview  
wandelt  s   moller  r     wessel  m          towards scalable instance retrieval
ontologies  international journal software informatics                
wu  z   eadon  g   das  s   chong  e  i   kolovski  v   annamalai  m     srinivasan  j 
        implementing inference engine rdfs owl constructs user defined
rules oracle  alonso  g   blakeley  j  a     chen  a  l  p   eds    icde      
proceedings   th international conference data engineering  april      
      cancun  mexico  pp            ieee 
zhou  y   nenov  y   cuenca grau  b     horrocks  i          pay as you go owl query
answering using triple store  proceedings twenty eighth aaai conference
artificial intelligence 
zhou  y   nenov  y   grau  b  c     horrocks  i          complete query answering
horn ontologies using triple store  semantic web   iswc          th
international semantic web conference  sydney  nsw  australia  october       
      proceedings  part i  pp         

   


