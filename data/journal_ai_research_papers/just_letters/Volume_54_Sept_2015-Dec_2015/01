journal artificial intelligence research                

submitted        published      

solving  sat maxsat dynamic programming
sigve hortemo sther
jan arne telle
martin vatshelle

sigve sether ii uib no
telle ii uib no
martin vatshelle ii uib no

department informatics  university bergen
bergen  norway

abstract
look dynamic programming algorithms propositional model counting 
called  sat  maxsat  tools graph structure theory  particular treewidth 
used successfully identify tractable cases many subfields ai  including
sat  constraint satisfaction problems  csp   bayesian reasoning  planning 
paper attack  sat maxsat using similar  modern  graph structure
tools  tractable cases include formulas whose class incidence graphs
unbounded treewidth unbounded clique width  show algorithms extend
previous results maxsat  sat achieved dynamic programming along
structural decompositions incidence graph input formula  present
limited experimental results  comparing implementations algorithms state of the art
 sat maxsat solvers  proof concept warrants research 

   introduction
propositional satisfiability problem  sat  fundamental problem computer science
ai  many real world applications planning  scheduling  formal verification
encoded sat sat solver used decide exists solution 
decide many solutions are  propositional model counting problem   sat  
finds number satisfying assignments  could useful  solutions 
may interesting know close get solution  propositional
formula encoded conjunctive normal form  cnf  may solved maximum
satisfiability problem  maxsat   finds maximum number clauses
satisfied assignment  paper investigate classes cnf formulas
two problems   sat maxsat  solved polynomial time  tools
graph structure theory  particular treewidth  used successfully identify
tractable cases many subfields ai  including sat  constraint satisfaction problems
 csp   bayesian reasoning  planning  bacchus  dalmao    pitassi        darwiche 
      fischer  makowsky    ravve        samer   szeider         paper
attack  sat maxsat using similar  modern  graph structure tools 
tractable cases include formulas whose class incidence graphs unbounded
treewidth unbounded clique width 
 sat maxsat significantly harder simply deciding satisfying
assignment exists   sat  p hard  garey   johnson        even restricted
horn   cnf formulas  monotone   cnf formulas  roth         maxsat
np hard even restricted horn   cnf formulas  jaumard   simeone        
c
    
ai access foundation  rights reserved 

fisther  telle   vatshelle

  cnf formulas variable appears   times  raman  ravikumar    rao 
       problems become tractable certain structural restrictions obtained
bounding width parameters graphs associated formulas  fischer  makowsky    ravve 
      ganian  hlineny    obdrzalek        samer   szeider        szeider        
work present inspired recent results work paulusma  slivovsky 
szeider        work slivovsky szeider        showing  sat
solvable polynomial time incidence graph  i f   input formula f
bounded modular treewidth  strongly  bounded symmetric clique width 
tractability results work dynamic programming along decomposition i f   
two steps involved      find good decomposition      perform dynamic
programming along decomposition  goal fast runtime  usually
expressed function known graph width parameter incidence graph i f  
formula f   tree width  step     solved known graph algorithm
computing decomposition low  tree  width  step     solves  sat maxsat
dynamic programming runtime expressed terms  tree  width k
decomposition 
algorithms give paper work dynamic programming along
decomposition  slightly different framework  since solving graph
theoretic problem  expressing runtime graph theoretic parameter may limitation 
therefore  strategy develop framework based following strategy
 a  consider   sat maxsat  amount information needed combine
solutions subproblems global solutions 
 b  define notion good decompositions based parameter minimizes
information 
 c  design dynamic programming algorithm along decomposition runtime
expressed parameter
work paulusma et al         slivovsky szeider       
two assignments considered equivalent satisfy set clauses 
carrying  a   sat maxsat led us concept ps value
cnf formula  let us define give intuitive explanation  subset c clauses
cnf formula f called projection satisfiable complete assignment
satisfying every clause c satisfying clause c  ps value f
number projection satisfiable subsets clauses  let us consider connection
dynamic programming  general applies optimal solution found
combining optimal solutions certain subproblems   sat maxsat
subproblems  least cases consider  take form subformula f induced
subset clauses variables  i e  first remove f variables
remove clauses s  consider simplicity two subproblems fs fs
defined complement s  combining solutions fs fs   order
   i f   bipartite incidence graph clauses f one hand variables f
hand  information positive negative occurrences variables encoded i f  
sometimes signed directed version used includes information 

  

fisolving  sat maxsat dynamic programming

find solutions f   seems clear must consider number cases least
big ps values two disjoint subformulas crossing s  i e 
subformulas obtained removing clauses variables s  removing
clauses variables s  see figure   example 
find literature study ps value cnf formulas  start
asking characterization formulas low ps value  led concept
mim value i f    size maximum induced matching i f   
induced matching subset edges property edge graph
incident one edge   note value much lower
size maximum matching  e g  complete bipartite graph mim value    show
ps value f upper bounded number clauses f raised power
mim value i f    plus    cnf formula f i f   mim value  
interpretation result straightforward  clauses totally ordered
two clauses c   c   variables occurring c subset variables occurring
c     implication number subsets clauses
complete assignment satisfies exactly subset number clauses plus   
families cnf formulas small ps value algorithmic interest 
paper continue part  b  strategy  focus
decompose cnf formula f based concept ps value  common way decompose
mathematical object recursively partition ground set two parts  giving
binary tree whose root represents ground set whose leaves bijectively mapped
elements ground set  taking ground set f set containing
clauses variables  decompose f   words binary tree
whose leaves     correspondence variables clauses  node binary
tree represents subset x variables clauses leaves subtree 
decomposition trees good efficiently solving  sat maxsat  accordance
discussion part  a  answer good decomposition trees
subformulas crossing x x  x defined node
tree  low ps value  see figure   example  define informal notion
precisely use concept branch decomposition ground set formula
cut function ps value formulas crossing cut  branch decompositions
standard notion graph matroid theory  originating work robertson
seymour graph minors  robertson   seymour         way arrive
definition ps width cnf formula f   decompositions f achieve
ps width  important note formula ps value exponential
formula size ps width polynomial  general class formulas low
ps width much larger class formulas low ps value 
finish strategy  must carry part  c  show solve  sat
maxsat dynamic programming along branch decomposition formula 
express runtime function ps width  complicated  dynamic
programming everything defined properly simply becomes exercise
brute force computation sufficient necessary information  technical
quite tedious  leads following theorem 
theorem    given formula f n variables clauses  decomposition f
ps width k  solve  sat weighted maxsat time o k   m m   n   
  

fisther  telle   vatshelle

thus  given decomposition ps width k polynomially bounded
number variables n clauses formula  get polynomial time algorithms 
let us compare result strongest previous result direction  namely
work slivovsky szeider         sat  algorithm takes input branch
decomposition vertex set i f    ground set f  
evaluates runtime cut function call index  show cut function
closely related symmetric clique width scw given decomposition  giving runtime
 n   m o scw    considering clique width cw given decomposition runtime
cw
work slivovsky szeider        becomes  n   m o     since symmetric clique width
clique width related essentially tight inequalities    cw scw  cw  courcelle 
       algorithm thus polynomial time algorithm given decomposition
constantly bounded scw  result theorem   encompasses this  since corollary  
ties ps width mim width work vatshelle        shows mim width upper
bounded clique width  see work rao        symmetric clique width 
decomposition i f   constantly bounded  symmetric  clique width
polynomially bounded ps width  way  given decomposition assumed input
work slivovsky szeider         algorithm theorem   runtime
o m cw s   cw clique width given decomposition 
work brault baron  capelli  mengel         appearing preliminary
presentation results  sther  telle    vatshelle         argued framework
behind theorem   gives uniform explanation tractability results  sat
literature  particular using dynamic programming based structural decompositions
incidence graph  work brault baron et al         goes beyond this  giving
polynomial time algorithm  dynamic programming  solve  sat  acyclic
cnf formulas  exactly formulas whose incidence graphs chordal bipartite 
show formulas bounded ps width incidence
graphs bounded mim width  see figure   gives overview results
paper papers 
using concept mim width graphs  introduced thesis vatshelle        
connection ps value mim value alluded earlier  show rich class
formulas  including classes unbounded clique width  polynomially bounded ps width
thus covered theorem    firstly  holds classes formulas incidence
graphs represented intersection graphs certain objects  interval graphs
 belmonte   vatshelle         secondly  holds much larger class bipartite
graphs achieved taking bigraph bipartizations intersection graphs  obtained
imposing bipartition vertex set keeping edges partition classes 
bigraph bipartizations studied previously  particular interval
bigraphs  interval bigraphs contain bipartite permutation graphs  latter
graphs shown unbounded clique width  brandstadt   lozin         see
figure   
let us discuss step      finding good decomposition  note theorem   assumes
input formula given along decomposition ps width k  value k
need optimal  heuristic finding reasonable branch decomposition could
used practice  computing decompositions optimal ps width probably doable
  

fisolving  sat maxsat dynamic programming

iden
inc

f

h f
ce grap

ps width mk

 sat poly  paper a 
 sat poly  paper b 

chordal
bipartite

 sat maxsat poly 
paper 

 acyclic

ps width m 
mim width k
clique width k
symmetric
clique width k  
modular
treewidth k  

ps width
k trapezoid
bigraph

circular arc
bigraph
interval bigraph
bipartite
permutation

figure    believe  argued work brault baron et al          dynamic
programming approach working along structural decomposition solve  sat
 or maxsat  polynomial time cannot go beyond green box  paper
brault baron et al         paper b slivovsky szeider        
left two dashed lines   classes graphs bound k   k
structural graph width parameter    classes bipartite graphs 
right  acyclic cnf formulas   classes cnf formulas ps width
varying linear number clauses m  m  mk   arc
p q formula f incidence graph i f   property p
property q  hasse diagram  lack arc transitive closure
means relation provably hold 
polynomial time  complexity question adressed paper  however 
able efficiently decide cnf formula certain linear structure guaranteeing
low ps width  combining alternative definition interval bigraphs  hell   huang 
      fast recognition algorithm  muller        rafiey        arrive
following  say cnf formula f interval ordering exists total ordering
variables clauses variable x occurring clause c  x appears
c variable occurs c  c appears x x
occurs clause them 
theorem    given formula f n variables clauses literals 
time o  m   n mn  decide f interval ordering  yes iff i f  
interval bigraph   yes solve  sat weighted maxsat additional
runtime o min m     t   m   n m  
formulas interval ordering precisely whose incidence graphs interval
bigraphs  theorem   encompasses classes formulas whose incidence graphs
unbounded clique width 
could parts algorithms interest practical applications  answering
question beyond scope present paper  however  performed limited
testing  particular formulas linear structure  simple proof concept 
code found online  sther  telle    vatshelle         designed
implemented heuristic step     finding good decomposition  case linear
  

fisther  telle   vatshelle

one binary tree describing decomposition path attached leaves 
implemented step     dynamic programming solving  sat maxsat along
decompositions  run     followed     compare one
best maxsat solvers max sat      event sat      conference
latest version  sat solver called sharpsat  thurley         solvers beat
implementation inputs  suprising since code include
techniques beyond algorithm  nevertheless  able generate classes
cnf formulas interval orderings implementation far better 
lends support belief methods related ps value warrants research
investigate could useful practice 
paper organized follows  section   give formal definitions ps value
ps width cnf formula show central combinatorial lemma linking ps value
formula size maximum induced matching incidence graph
formula  section   present dynamic programming algorithms given formula
decomposition solves  sat weighted maxsat  proving theorem    section  
investigate classes formulas decompositions low ps width  basically proving
correctness hierarchy presented figure    section   consider formulas
interval ordering prove theorem    section   present results
implementations testing  end section   open problems 

   framework
consider propositional formulas conjunctive normal form  cnf   literal
propositional variable negated variable  x x  clause set literals 
formula multiset clauses  formula f   cla f   denotes clauses f  
incidence graph formula f bipartite graph i f   vertex clause
variable  variable x adjacent clause c occurs  consider
input formulas i f   connected  otherwise would solve problems
separate components i f    clause c  lit c  denotes set literals
c var c  denotes
variables literals lit c   formula f   var f  

denotes union ccla f   var c   set x variables  assignment x
function   x         literal    define        var       negated
variable      x variable x   var  otherwise      x variable
x   clause c said satisfied assignment exists least one literal
  lit c           clause assignment satisfy said
falsified   notice means empty clause falsified assignments 
formula satisfied assignment satisfies clauses cla f   
problem  sat  given formula f   asks many distinct assignments var f  
satisfy f   optimization problem weighted maxsat  given formula
p f weight
function w   cla f   n  asks assignment var f   maximizes c w c 
c cla f   satisfied   problem maxsat asks maximum number satisfied
clauses achieved  equivalent weighted maxsat clauses weight
one  weighted maxsat  assume sum weights  o cla f     
thus summation weights time linear cla f   
  

fisolving  sat maxsat dynamic programming

set a  elements universe u denote elements u   a 
universe usually given context 
    cut formula
paper  solve maxsat  sat use dynamic programming 
using divide conquer technique solve problem smaller
subformulas original formula f combine solutions smaller
formulas form solution entire formula f   note however  solutions found
subformula depend interaction subformula remainder
formula  use following notation subformulas 
clause c set x variables  c x denote clause    c   var    x  
say c x clause c induced x  unless otherwise specified  clauses mentioned
paper set cla f    e g   write c x cla f      still assume c
cla f     formula f subsets c cla f   x var f    say subformula
fc x f induced c x formula consisting clauses  ci  x   ci c  
is  fc x formula get removing clauses c followed removing
literal variable x  set c clauses  denote c x set  c x   c c  
clause  assignment set x variables  say assignment
induced x   x assignment  x   domain restricted x    
formula f sets c cla f    x var f      c x  call cut f
note breaks f four subformulas fc x   fc x   fc x   fc x   see figure   
one important fact may observe definition clause c f satisfied
assignment var f    c  induced x x  satisfied
least one formulas cut f  
    projection satisfiable sets ps value formula
formula f assignment variables var f    denote sat f   
inclusion maximal set c cla f   clause c satisfied  
set c cla f   sat f      c variables var f    c
known projection  kaski  koivisto    nederlof        slivovsky   szeider       
say c projection satisfiable f   denote ps f   family projection
satisfiable sets f   is 
ps f      sat f      assignment entire set var f    
cardinality set   ps f     referred ps value f  
get grasp structure formulas low ps value consider induced
matchings incidence graph formula  incidence graph formula f
bipartite graph i f   vertex clause variable  variable x adjacent
clause c occurs  induced matching graph subset edges
property edge graph incident one edge  
words    vertices a  b  c  ab edge bc edge
exist edge cd   number edges called size induced matching 
following result provides upper bound ps value formula terms
maximum size induced matching incidence graph 
  

fisther  telle   vatshelle

lemma    let f cnf formula clause containing literals 
let k maximum size induced matching i f     ps f   
min  cla f   k       tk   
proof  first argue  ps f     cla f   k      let c ps f   cf   cla f     c 
thus  exists complete assignment clauses satisfied
cf   cla f     sat f     since every variable var f   appears clause f
means  var cf   unique assignment variables var cf   satisfy
 
 
clause cf   let cf cf inclusion minimal set var cf     var cf   
hence  var cf   unique assignment variables var cf   satisfy
 
 
clause cf   upper bound number different minimal cf  
 
c ps f    give upper bound  ps f     every c cf variable vc
 
 
appearing c clause cf   otherwise cf would minimal  note
induced matching i f   containing edges vc   c  assumption 
 
induced matching k edges hence  cf   k  easy show
induction k  cla f   k     sets k clauses lemma
follows 
argue  ps f     tk   maximum induced matching size k
set c k clauses var c    var f    clause c c  var c   t 
 var f       var c   tk    var f    assignments f  
ps value f upper bounded  tk  
    ps width formula
define branch decomposition formula f pair  t    rooted
binary tree bijective function leaves clauses variables
f   non leaf nodes  also referred internal nodes  induce path 
say  t    linear branch decomposition  non leaf node v   denote
 v  set   l    l leaf subtree rooted v   based this  say
decomposition  t    formula f induces certain cuts f   namely cuts defined  v 
node v  
formula f branch decomposition  t     node v   fv denote
formula induced clauses cla f      v  variables  v   fv
denote formula complement sets  i e  clauses  v  variables
var f      v   words   v    c x c cla f   x var f  
fv   fc x fv   fc x   simplify notation  node v branch
decomposition set c clauses denote c v set c var fv     define ps value
cut  v 
ps  v     max  p s fv      p s fv    
define ps width branch decomposition
psw t      max ps  v     v node  
define ps width formula f
psw f     min psw t       t    branch decomposition f  
  

fisolving  sat maxsat dynamic programming

v
x 
x  c  x  c 
x 

x 

c 

c
c     x    x   
c     x    x    x   

c 
fc x   fv

x

fc x

fc x

x  x 

x  x 
x 

fc x   fv

c     x    x    x   
c     x    x    x   

x

c

figure    top branch decomposition formula f var f      x    x    x    x    x   
  clauses cla f      c    c    c    c    given boxes  node
v tree defines cut  v    c x c    c    c    x  
 x    x       subformulas defined cut  fc x   fc x   fc x   fc x  
example  fc x     x    x      x     fc x       x    x     
fv   fc x fv   fc x projection satisfiable sets clauses ps fv    
  c   v     c   v     c   v   c   v    ps fv         c   v    ps value cut
ps  v     max  p s fv      p s fv         

note ps value cut symmetric function  is  ps value cut
equals ps value cut s  see figure   example 

   dynamic programming maxsat  sat
given branch decomposition  t    cnf formula f n variables clauses
total size s  give algorithms solve maxsat  sat f time
o psw t     m m   n    algorithms strongly inspired work slivovsky
szeider         order achieve runtime polynomial ps width  solve
maxsat  must make crucial changes  particular  must index dynamic
progranming tables ps sets rather shapes used work slivovsky
szeider        
let us discuss special terminology used section  dynamic
programming section  combine partial solutions subformulas solutions
input formula f   improve readability introduce notation p   sat 
allows us refer directly clauses f   working subformulas 
  

fisther  telle   vatshelle

thus  formula f branch decomposition  t     node v   induced
subformula fv f   ps   fv   denote subsets clauses c cla f      v 
ps fv     c var fv     similarly  assignment var fv    sat   fv    
denote set clauses c cla f      v  sat fv       c var fv     note
 ps   fv       ps fv     sat   fv         sat fv       take liberty call
sets projection satisfiable refer ps sets text  clear
context mean clauses cla f   cla fv   
let us discuss implementation details  regard ps sets boolean vectors
length  cla f     assume identify clauses variables integer numbers  so 
checking clause ps set done constant time  checking two ps sets
equal done o  cla f     time  manage ps sets  use binary trie
datastructure  fredkin         add retrieve ps set trie
o  cla f     time  trying add ps set trie already containing equivalent ps set
alter content trie  tries contain distinct ps sets 
retrieval element trie takes o  cla f     time  assigning distinct integer
ps set time added trie  o  cla f     time mapping
ps sets distinct integers  used implicitly algorithms
say index ps sets  implementing algorithm instead index
corresponding integer ps set mapped to 
pre processing step need following which  node v computes
sets projection satisfiable subsets clauses ps   fv   ps   fv   two crossing
subformulas fv fv  
theorem    given cnf formula f branch decomposition  t    ps width k 
time o k   m m   n   compute sets ps   fv   ps   fv   v  

proof  notice node v children c  c    express ps   fv  


c  ps   fc    
 
ps  fv      c  c    cla fv    
 
c  ps   fc   

similarly  sibling parent p v   set ps   fv   expressed


cp ps   fp   
 
ps  fv      cp cs   cla fv    
 
cs ps   fs  
transforming recursive expressions dynamic programming algorithm 
done procedure   procedure   below  able calculate desired sets
long compute sets base cases ps   fl   l leaf   ps   fr  
root r   however  formulas contain one variable  thus
easily construct set projection satisfiable clauses linear amount time
formulas  rest formulas  construct formulas using procedure  
procedure    twice many nodes clauses
variables f   procedures run o  cla f       var f     times  run
algorithms  iterate k   pairs projection satisfiable sets 
constant number set operations might take o  cla f     time each  results
total runtime o k    cla f     cla f       var f        o k   m m   n   nodes
combined 
  

fisolving  sat maxsat dynamic programming

procedure    generating ps   fv  
input  ps   fc    ps   fc    children c  c  v
branch decomposition
output  ps   fv  
l empty trie projection satisfiable clause sets
 c    c    ps   fc    ps   fc   
add  c  c    cla fv   l
return l
procedure    generating ps   fv  
input  ps   fs   ps   fp   sibling parent p v
branch decomposition
output  ps   fv  
l empty trie projection satisfiable clause sets
 cs   cp   ps   fs   ps   fp  
add  cs cp   cla fv   l
return l
move dynamic programming proper  first give algorithm
maxsat briefly describe changes necessary solving weighted maxsat
 sat 
algorithm uses technique expectation introduced work bui xuan 
telle  vatshelle               partial solutions might good combined
certain partial solutions  bad combined others  technique
expectation categorize partial solutions interact  optimize selection
partial solutions based expectation interaction occurs  dynamic
programming algorithm maxsat  apply technique making expectations
cut regarding set clauses satisfied variables opposide side
cut 
node v decomposition f ps sets c ps   fv   c   ps   fv   
say assignment var f   meets expectation c c   sat   fv    v     c
sat   fv    v     c     node v branch decomposition  algorithm uses
table tabv pair  c  c     ps   fv   ps   fv   stores tabv  c  c     maximum
number clauses  v  satisfied  assignments meeting expectation
c c     variables var f      v  satisfy exactly c     assignment
meets expectation  equivalent formulation content tabv  c  c    
must satisfy following constraint 
assignments var f    v  sat   fv       c  



tabv  c  c       max sat   f       v  c  

   



bottom up dynamic programming along tree compute tables
node   leaf l   generating tabl done easily linear time since
formula fv contains one variable  internal node v   children c    c   
  

fisther  telle   vatshelle

compute tabv algorithm described procedure      tables involved
update  one child one parent  pair entries  one child
table  may lead update entry parent table  table entry indexed
pair  thus   indices involved single potential update  trick first introduced
work bui xuan et al         allows us loop triples indices
triple compute remaining   indices forming   tuple involved update  thereby
reducing runtime 
procedure    computing tabv inner node v children c    c 
input  tabc    tabc 
output  tabv
   initialize tabv   ps   fv   ps   fv      
    cc    cc    cv    ps   fc    ps   fc    ps   fv  
  
cc     cc  cv     c   
  
cc     cc  cv     c   
  
cv  cc  cc       v 
  
tabc   cc    cc        tabc   cc    cc     
  
tabv  cv   cv      tabv  cv   cv   
   return tabv
lemma    cnf formula f clauses inner node v  branch decomposition  t    ps width k  procedure   computes tabv satisfying constraint     time
o k   m  
proof  assume tabc  tabc  satisfy constraint      procedure   loops triples
ps   fc    ps   fc    ps   fv    definition ps width  t   
k   triples  operation inside iteration loop take o m  time
constant number operations  thus runtime o k   m  
show correctness output  let us look bit workings
procedure    assignment var f    cut  assignment meet
expectation single pair ps sets  let  x    x       x    x      xv   xv    pairs
assignment meets expectation respect cuts induced c    c    v 
respectively  notice
xv   sat   fv    v  

  sat   fv    c     c   

  sat   fv    c    sat   fv    c   

   sat   fc     c       v    sat   fc     c       v  

   

   x     v    x     v  
   x  x       v  

seen figure    symmetry  find similar values x   x    
namely x      x  xv     c    x      x  xv     c     so  latter three sets
implicit based three former sets respect cuts induced v  c 
c    therefore  convenience proof  say assignment meets
  

fisolving  sat maxsat dynamic programming

  x    sat  fc     c   

clauses cla f      v 

  x    sat  fc     c   
  xv   sat  fv    v  

clauses  c   

clauses  c   

figure    shown chain equalities     proof lemma    clauses
sat   fv    v   precisely clauses  sat   fc     c    sat   fc     c        v  
expectation triple  c    c    c     ps sets  meets expectation implicit
three pairs respective cuts  notice choice triples
ps sets  cc    cc    cv    procedure   computes implicit three sets names
cc      cc    cv accordingly 
show pairs  c  c     ps   fv   ps   fv   value tabv  c  c    
correct  let   assignment var f   satisfies maximum number
clauses  meeting expectation c c     thus  value tabv  c  c     correct
stores exactly number clauses  v    satisfies 
let  c    c      c    c     pairs ps sets   meet expectation
cut   c      c       c      c      respectively    meets expectations  value
tabc   c    c     tabc   c    c     must least large number clauses  
satisfies  c     c     respectively  thus  number clauses   satisfies
 c     c    large sum two entries  since procedure   
iteration cv    c     cc    c  cc    c    ensures tabv  c  c     least
sum tabc   c    c     tabc   c    c      know tabv  c  c     least large
correct value 
assume contradiction value cell tabv  c  c     large 
means iteration procedure   assigned value tabc   cc    cc       
tabc   cc    cc      sum large  let     assignments var f  
meeting expectation cc  cc    meeting expectation cc    cc      respectively 
number clauses  c     c     respectively  equals according table
entries tabc  tabc    take assignment x      c       c       v  
assignment meets expectation c c     satisfies clauses
 v      contradicting choice     tabv  c  c     neither smaller larger
number clauses  v    satisfies  exactly same 
theorem    given formula f n variables clauses  branch decomposition
 t    f ps width k  solve maxsat   sat  weighted maxsat time
o k   m m   n   
proof  solve maxsat  first compute tabr root node r   requires
first compute ps   fv   ps   fv   nodes v   then  bottom
manner  compute tabv o m   n  nodes   former part
  

fisther  telle   vatshelle

o k   m m   n   time theorem    latter part o k   m m   n   time
lemma   
root r  r    var f   cla f    thus fr   fr
variables  p s fr   p s fr   contains       assignments var f  
meet expectation cut   r    r    cla f    r    cla f   
constraint     value tabr      maximal number clauses f assignment
var f   satisfies  hence  number solution maxsat 
weight function w   cla f   n  redefining constraint     tabv maximize
w sat   f     v   instead  sat   f     v    able solve general
problem weighted maxsat way 
problem  sat  care assignments satisfying clauses
f   want decide number distinct assignments so  requires
alterations  firstly  alter definition contents tabv  c  c     constraint
    number assignments var f    v  sat   fv       c
clauses  v  either c   satisfied   secondly  computing tabl
leaves l   set entries tabl either zero  one  two  according
definition  thirdly  alter algorithm compute tabv  procedure    inner nodes 
initialize tabv  c  c     zero start algorithm  substitute lines  
  procedure   following line increases table value product
table values children
tabv  cv   cv   tabv  cv   cv     tabc   cc    cc    tabc   cc    cc   
satisfy new constraint tabv internal nodes v   value tabr     
root r exactly number distinct assignments satisfying clauses
f 
bottleneck giving cubic factor k   runtime theorem   number
triples ps   fv   ps   fc    ps   fc    node v children c  c     t   
linear branch decomposition  always case either c  c  leaf  
case either  ps   fc      ps   fc     constant  therefore  linear branch decompositions
ps   fv   ps   fc    ps   fc    contain o k     triples  thus reduce
runtime algorithm factor k 
theorem    given formula f n variables clauses  linear branch
decomposition  t    f ps width k  solve  sat  maxsat  weighted maxsat
time o k   m m   n   

   cnf formulas polynomial ps width
section investigate classes cnf formulas decompositions ps width
polynomially bounded total size formula  particular  show
holds whenever incidence graph formula constant mim width  maximum
induced matching width  introduced vatshelle         show large class
bipartite graphs  using call bigraph bipartizations  constant mim width 
  

fisolving  sat maxsat dynamic programming

order lift upper bound lemma   ps value f   i e  ps f    
ps width f   use mim width incidence graph i f    defined using branch
decompositions graphs  branch decomposition formula f   defined section
   seen branch decomposition incidence graph i f    nevertheless 
completeness  formally define branch decompositions graphs mim width 
branch decomposition graph g pair  t    rooted binary tree
bijection leaf set vertex set g  node w
let subset v  g  bijection leaves subtree rooted w
denoted vw   say decomposition defines cut  vw   vw    mim value cut
 vw   vw   size maximum induced matching g vw   vw    mim width  t   
maximum mim value cuts  vw   vw   defined node w   mim width
graph g  denoted mimw g   minimum mim width branch decompositions
 t    g  linear branch decomposition branch decomposition inner
nodes underlying tree induces path 
since decomposition i f   seen decomposition f   immediately
get lemma   following corollary 
corollary    cnf formula f clauses  clause containing
literals  ps width f min mk       tk   k   mimw i f    
many classes graphs intersection models  meaning represented
intersection graphs certain objects  i e  vertex associated object
two vertices adjacent iff objects intersect  objects used define intersection
graphs usually consist geometrical objects lines  circles polygons  many well
known classes intersection graphs constant mim width  following
lists subset classes proven bounds  belmonte   vatshelle       
vatshelle        
theorem     belmonte   vatshelle        vatshelle        let g graph  g a 
interval graph mimw g    
circular arc graph mimw g    
k trapezoid graph mimw g  k 
moreover exist linear decompositions satisfying bound  found polynomial time  for k trapezoid assume intersection model given  
let us briefly mention definition graph classes  graph interval graph
intersection model consisting intervals real line  graph circular arc
graph intersection model consisting arcs circle  build k trapezoid
start k parallel line segments  s    e      s    e           sk   ek   add two non intersecting
paths e joining si si   ei ei   respectively straight lines
         k     polygon defined e two line segments  s    e      sk   ek  
forms k trapezoid  graph k trapezoid graph intersection model consisting
k trapezoids  see work brandstadt  le  spinrad        information
graph classes containment relations 
combining corollary   theorem   get following
corollary    let f cnf formula containing clauses maximum clause size t 
i f   a 
  

fisther  telle   vatshelle

interval graph psw f   min m       t   
circular arc graph psw f   min m        t   
k trapezoid graph psw f   min mk       tk   
moreover exist linear decompositions satisfying bound  found polynomial time  for k trapezoid assume intersection model given  
incidence graphs formulas bipartite graphs  case
majority graphs above mentioned graph classes  following show
extend results corollary   large classes bipartite graphs  graph g
subset vertices v  g  bipartite graph g a  a  subgraph g containing
edges g exactly one endpoint a  graph g v  g  call g a  a 
bigraph bipartization g  note g bigraph bipartization subset
vertices  graph class x define class x bigraphs bipartite graphs h
exists g x h isomorphic bigraph bipartization g 
example  bipartite graph h interval bigraph interval graph g
v  g  h isomorphic g a  a  
following result allow us lift results corollary   given graphs
bigraph bipartizations graphs 
theorem    assume given cnf formula f clauses maximum
clause size t  graph g  subset v  g    t  g    linear  branch decomposition
g mim width k  i f   connected isomorphic g a  a   thus i f   bigraph
bipartization g  linear time produce  linear  branch decomposition  t  f  
f ps width min mk       tk  
proof  since variable clause f corresponding node i f    node
i f   corresponding node g  defining f function mapping leaf
l variable clause f corresponding node g  l   get  t  f  
branch decomposition f   consider cut  b  b  induced node  t  f    note
mim value g b  b  k  i f   connected means
either corresponding set variables f   assume wlog former  thus
c   b cla f   clauses b  c   cla f     c x   b var f  
variables b  x   var f     x  mim values g c  x  g c  x 
k  since induced subgraphs g b  b   taking induced subgraphs
cannot increase size maximum induced matching  hence lemma   
 ps fc x     cla f   k      likewise  ps fc x     cla f   k     
maximum two ps value cut  since ps width decomposition
maximum ps value cut theorem follows 
combining theorems     immediately get following 
corollary    let f cnf formula containing clauses maximum clause size t 
i f   a 
interval bigraph psw f   min m       t   
circular arc bigraph psw f   min m        t   
k trapezoid bigraph psw f   min mk       tk   
moreover exist linear decompositions satisfying bound 
  

fisolving  sat maxsat dynamic programming

next section address question finding linear decompositions
polynomial time  succeed case interval bigraphs  circular arc bigraphs
k trapezoid bigraphs must leave open problem 

   interval bigraphs formulas interval orders
section show formulas whose incidence graph interval bigraph
polynomial time find linear branch decompositions small ps width  let
us recall definition interval ordering  cnf formula f interval ordering
exists linear ordering variables clauses variable x occurring
clause c  x appears c variable occurs c 
c appears x x occurs clause them  see figure  
example 
order 
x  c   x  x  c   c   x  x 

clauses 

bipartized interval rep 

incidence graph

x 
c 
x 
x 
c 
c 
x 
x 

c     x    x   
c     x    x    x   
c     x    x    x   

c 

x 

c  c 

x  x 

x  x 

figure    cnf formula interval ordering  incidence graph interval
bigraph  since isomorphic bigraph bipartization  defined blue
intervals  interval graph intersection model left 
work hell huang        follows formula f interval ordering
i f   interval bigraph 
theorem    given cnf formula f n variables clauses
literals  time o  m   n mn  decide f interval ordering  yes iff i f  
interval bigraph   yes solve  sat weighted maxsat additional
runtime o min m     t   m   n m  
proof  using characterization work hell huang        algorithm
rafiey        time o  m   n mn  decide f interval ordering
yes  find it  interval ordering build interval graph g i f  
bigraph bipartization g  construct linear branch decomposition g
mim width    belmonte   vatshelle         linear branch decomposition
  

fisther  telle   vatshelle

get theorem   construct another linear branch decomposition f
ps width o m   run algorithm theorem   

   experimental results
present simple experimental results  intended proof concept  belief
ideas behind algorithms  notion ps value  useful
practice  require thorough investigation confirm belief  results
indicate worst case runtime bounds dynamic programming  theorems  
   probably higher would commonly seen practice 
past decade  sat solvers become powerful  currently able
handle large practical instances  techniques sat solvers
applied develop relatively powerful maxsat  sat solvers  biere  heule    van
maaren         experiments compare implementations algorithms
state of the art maxsat  sat solvers  enhance implementations
techniques  even simple pre processing  vast majority instances
implementations fall far behind comparison  however  focusing formulas
certain linear order implementations compare favorably 
explained section    two steps involved      find good decomposition
input cnf formula f       perform dp  dynamic programming  along
decomposition  let us start describing simple heuristic step      takes
input bipartite graph i f   vertex set cla f   var f    outputs linear
order vertex set  heuristic greedyorder greedy algorithm
increasing values chooses  i  vertex highest number already
chosen neighbors  among choosing one fewest non chosen neighbors 
defines linear branch decomposition  t    cnf formula f   non leaf nodes
binary tree inducing path  rooted one end path 
mapping ith leaf encountered breadth first search starting root
clause variable  i      cla f   var f    

algorithm greedyorder
input  g    v  e    bipartite  graph
output    linear ordering v
l     r   v      
v v set ldegree v     
r empty
choose v  vertices r max ldegree take one smallest degree
set  i    v  increment i  add v l remove v r
w r vw e increment ldegree w 

  

fisolving  sat maxsat dynamic programming

implementations found online  sther  telle    vatshelle        
implemented greedyorder java  together straight forward implementation
dp algorithm theorem   
given cnf formula  allows us solve maxsat  sat first running
greedyorder dp  compare implementation best solvers could
find online  respectively ccls to akmaxsat  luo  cai  wu  jie    su       
among best solvers ninth max sat evaluation         latest version
 sat solver called sharpsat  thurley  n d          solvers handily beat
implementation inputs  therefore generated cnf formulas
interval orderings  theorem    check least instances better 
note step     implemented polynomial time algorithm recognizing
formulas interval orders  relying instead greedyorder heuristic 
    generation instances
presenting results  let us describe generation set instances 
three types  start type    generation formulas based
definition interval orderings given interval bigraph definition  see e g  left side
figure    generate formula type   n variables clauses  generate
n   intervals real line iterating points     n   m  left
right endpoints intervals 
step i  check   cases legal  e g    legal exists
live variable  i e  left endpoint   right endpoint  randomly make
one legal choices 
   start interval new variable left endpoint
   start interval new clause left endpoint
   end interval randomly chosen live variable right endpoint
   end interval randomly chosen live clause right endpoint
towards end process boundary conditions enforced reach exactly
clauses  n expected slightly smaller m  clause interval randomly
choose variable overlapping interval either positive negative
clause  resulting cnf formula interval ordering given rightmost
endpoints intervals  hide ordering clauses variables randomly permuted
make final cnf formula 
formulas type   generated similar fashion type    except
guarantee clauses size t  lemma   could big help 
change case   instead choice becomes enforced live
clause step accumulated exactly overlapping variable intervals  let
clause interval represent   clauses variable set randomly chosen
literals  aim increasing probability instance satisfiable 
formulas type   cnf representation conjunction xor functions
xor fixed number literals variables xor functions
  

fisther  telle   vatshelle

overlap way incidence graph bipartization circular arc
graph 
formula type   generated three input parameters n  t  s  n variables
represented successive points   n circle  first xor function interval
  thus containing variables points   t  second interval       t 
general ith interval       t  appropriate modulo addition
boundary condition end ensure n s xor functions  variables chosen
randomly appear positive negative xor  xor transformed
standard way cnf formula  t  clauses give us resulting cnf formula
n s  t  clauses  again  variables clauses randomly permuted hide
ordering giving circular arc bigraph representation 
note resulting formulas quite simple structure  state ofthe art sat solver  lingeling  biere         handles generated instances within
seconds 
    results
ready present results  ran solvers dell optiplex    
running ubuntu          bit  machine  gb memory intel core   quad
q     processor openjdk java    icedtea          
instances type   greedyorder heuristic fails terribly becomes huge
bottleneck  greedy choice based degrees vertices i f   simple  however 
given correct interval order solver s  performed better 
instances type   generated similar type   clauses small size 
lemma   could help  case number clauses approximately

runtime seconds

   

   

ccls
sharpsat
maxsat
 sat
 practically equal 

   

 
 

    
    
number variables

    

figure    runtimes instances type    maxsat solver clearly faster
ccls akmaxsat  vertical axis represents time seconds  runs taking
    seconds stopped completion drawn
dotted line 

  

fisolving  sat maxsat dynamic programming

four times number variables  consequence great number instances
satisfiable  making work  sat solvers easier maxsat
solvers  generated instances type   solved within seconds sharpsat  see
figure    size instances grow  see clear tendency runtimes
ccls akmaxsat increase much rapidly solvers  runtimes
two solvers almost identical  greedyorder heuristic instances seems
produce decompositions orders low ps width 
type   instances shown figure   generated k         
instances satisfiable  may explain ccls akmaxsat fast  choosing
k         satisfiable instances ccls akmaxsat would
often spend     seconds time out  size instances grow 
see clear tendency runtimes sharpsat increase much rapidly
solvers  runtimes two solvers almost identical 

runtime seconds

   

   

ccls
sharpsat
maxsat
 sat
 practically equal 

   

 
  

  
   
   
number variables

   

figure    runtimes instances type     sat solver clearly faster
sharpsat  vertical axis represents time seconds  runs taking
    seconds stopped completion drawn dotted line 

   conclusion
paper proposed structural parameter cnf formulas  called ps width
projection satisfiable width  showed weighted maxsat  sat
solved polynomial time given decomposition formula polynomially bounded
ps width  using concept interval bigraphs showed polynomial time algorithm
actually finds decomposition  formulas interval ordering  could
one devise algorithm larger class circular arc bigraphs  maybe
even even larger class k trapezoid bigraphs  words  problem
recognizing bipartite input graph circular arc bigraph  k trapezoid bigraph 
polynomial time solvable 
  

fisther  telle   vatshelle

could practical interest design heuristic algorithm given formula finds
decomposition relatively low ps width  done boolean width  hvidevold 
sharmin  telle    vatshelle         one could check benchmarks covering real world
sat instances low ps width  perform study correlation low
ps width practical hardness maxsat  sat solvers  done
treewidth sat solvers  mateescu         presented simple experimental
results  require thorough investigation check ideas algorithms
could useful practice  finally  hope essential combinatorial result enabling
improvements paper  lemma    may uses well 

references
bacchus  f   dalmao  s     pitassi  t          algorithms complexity results for sat
bayesian inference  foundations computer science        proceedings    th
annual ieee symposium  pp          
belmonte  r     vatshelle  m          graph classes structured neighborhoods
algorithmic applications  theor  comput  sci               
biere  a          yet another local search solver lingeling friends entering sat
competition       sat competition           
biere  a   heule  m     van maaren  h          handbook satisfiability   vol      
chap       ios press 
brandstadt  a   le  v  b     spinrad  j  p          graph classes  survey  vol     
philadelphia  siam society industrial applied mathematics 
brandstadt  a     lozin  v  v          linear structure clique width bipartite
permutation graphs  ars comb       
brault baron  j   capelli  f     mengel  s          understanding model counting
 acyclic cnf formulas  corr  abs             retrieved http   arxiv org 
abs          
bui xuan  b  m   telle  j  a     vatshelle  m          h join decomposable graphs
algorithms runtime single exponential rankwidth  discrete applied mathematics 
                 
bui xuan  b  m   telle  j  a     vatshelle  m          boolean width graphs  theoretical
computer science                     
courcelle  b          clique width countable graphs  compactness property  discrete
mathematics                     retrieved http   dx doi org         s    
    x            doi          s        x           
darwiche  a          recursive conditioning  artificial intelligence               
fischer  e   makowsky  j  a     ravve  e  v          counting truth assignments
formulas bounded tree width clique width  discrete applied mathematics          
        
  

fisolving  sat maxsat dynamic programming

fredkin  e          trie memory  communications acm                 
ganian  r   hlineny  p     obdrzalek  j          better algorithms satisfiability problems
formulas bounded rank width  fundam  inform                  
garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w  h  freeman 
hell  p     huang  j          interval bigraphs circular arc graphs  journal graph
theory                  
hvidevold  e  m   sharmin  s   telle  j  a     vatshelle  m          finding good
decompositions dynamic programming dense graphs  d  marx   p  rossmanith
 eds    ipec  vol        p            springer 
jaumard  b     simeone  b          complexity maximum satisfiability
problem horn formulas  inf  process  lett               
kaski  p   koivisto  m     nederlof  j          homomorphic hashing sparse coefficient
extraction  proceedings  th international conference parameterized
exact computation  pp          
luo  c   cai  s   wu  w   jie  z     su  k          ccls  efficient local search
algorithm weighted maximum satisfiability  ieee transactions computers  doi 
        tc             
mateescu  r          treewidth industrial sat benchmarks  tech  rep    tech  rep 
cambridge  uk  microsoft research  retrieved http   research microsoft
 com pubs        msr tr         pdf
muller  h          recognizing interval digraphs interval bigraphs polynomial time 
discrete applied mathematics                    
ninth max sat evaluation          retrieved http   www maxsat udl cat    
 accessed    january      
paulusma  d   slivovsky  f     szeider  s          model counting cnf formulas
bounded modular treewidth  n  portier   t  wilke  eds    stacs  vol      p         
schloss dagstuhl   leibniz zentrum fuer informatik 
rafiey  a         
abs            

recognizing interval bigraphs forbidden patterns 

corr 

raman  v   ravikumar  b     rao  s  s          simplified np complete maxsat
problem  inf  process  lett               
rao  m          clique width graphs defined one vertex extensions  discrete
mathematics                     
robertson  n     seymour  p  d          graph minors x  obstructions tree decomposition 
j  combin  theory ser  b                  
roth  d          connectionist framework reasoning  reasoning examples 

  

fisther  telle   vatshelle

w  j  clancey   d  s  weld  eds    aaai iaai  vol     p              aaai press  
mit press 
sther  s  h   telle  j  a     vatshelle  m          solving maxsat  sat
structured cnf formulas  c  sinz   u  egly  eds    sat       vol        pp    
     springer  retrieved http   dx doi org                            
doi                             
sther  s  h   telle  j  a     vatshelle  m          online implementations  retrieved
http   people uib no ssa    pswidth 
samer  m     szeider  s          algorithms propositional model counting  j  discrete
algorithms               
slivovsky  f     szeider  s          model counting formulas bounded clique width 
l  cai  s  w  cheng    t  w  lam  eds    isaac  vol        p            springer 
szeider  s          fixed parameter tractable parameterizations sat  e  giunchiglia
  a  tacchella  eds    sat       vol        p            springer 
thurley  m   n d    sharpsat  retrieved https   sites google com site 
marcthurley sharpsat  accessed    january      
thurley  m          sharpsatcounting models advanced component caching
implicit bcp  theory applications satisfiability testing sat       pp          
springer 
vatshelle  m          new width parameters graphs  unpublished doctoral dissertation 
university bergen 

  


