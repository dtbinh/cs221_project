journal artificial intelligence research                  

submitted        published      

compressing optimal paths run length encoding
ben strasser

strasser   kit  edu

karlsruhe institute technology
karlsruhe  germany

adi botea

adibotea   ie   ibm   com

ibm research
dublin  ireland

daniel harabor

daniel   harabor   nicta   com   au

nicta
sydney  australia

abstract
introduce novel approach compressed path databases  space efficient oracles used
quickly identify first edge shortest path  algorithm achieves query running times
    nanosecond scale  significantly faster state of the art first move oracles
literature  space consumption competitive  due compression approach rearranges
rows columns first move matrix performs run length encoding  rle 
contents matrix  one variant implemented system was  convincing margin 
fastest entry      grid based path planning competition 
give first tractability analysis compression scheme used algorithm 
study complexity computing database minimum size general directed undirected
graphs  find cases problem np complete  show that  graphs
decomposed along articulation points  problem decomposed independent
parts  corresponding reduction level difficulty  particular  leads simple
tractable algorithms linear running time yield optimal compression results trees 

   introduction
compressed path database  cpd  index based data structure graphs used
quickly answer first move queries  query takes input pair nodes  namely source node
target node t  asks first edge shortest st path  i e   path t   cpds
successfully applied number contexts important ai  instance  copa  botea 
       cpd based pathfinding algorithm  one joint winners      edition
grid based path planning competition  shorter gppc  sturtevant      b   related algorithm 
mtscopa  fast method moving target search known partially known terrain  botea 
baier  harabor    hernandez        baier  botea  harabor    hernandez        
given graph g    v  e   trivial cpd consists square matrix dimensions
 v    v    matrix m  constructed precomputation step  stores cell m s  t 
identity first edge shortest st path  call first move matrix  convention
say rows correspond fixed source nodes columns fixed target nodes 
optimal terms query time o  v      space consumption quickly becomes prohibitive
larger graphs  challenge design compact representation trades small increase
query times large decrease space consumption 
c
    
ai access foundation  rights reserved 

fis trasser   b otea     h arabor

number different techniques compress first move matrix suggested
purpose  sankaranarayanan  alborzi    samet        botea        botea   harabor      a  
case objective conserve space grouping together entries share
common source node store first edge information 
work present single row compression  src  multi row compression
 mrc  indexing algorithms compressing all pairs shortest paths      s gppc  src outperformed competitors terms query running time  contributions presented article
go three main directions  new approach compressing first move matrix  experiments
demonstrate advancing state of the art terms response time memory consumption 
thorough theoretical analysis  discussing np hardness results islands tractability 
introduce new matrix compression technique based run length encoding  rle  
main idea algorithm simple  compute order nodes input graph
assign numeric ids nodes  e g      v    order  purpose ordering
nodes located close proximity graph small id difference  ordering
used order rows columns first move matrix  computed
preprocessing  then  apply run length encoding  rle  row first move matrix 
study three types heuristic orderings  graph cut order  depth first order input graph order 
study two types run length encoding  first involves straightforward application
algorithm row  second type sophisticated multi row scheme eliminates
redundancies adjacent rle compressed rows  answer first move queries employ
binary search fragment compressed result 
undertake detailed empirical analysis including comparisons techniques stateof the art variants cpds  botea         hub labeling  delling  goldberg  pajor    werneck 
       copa recent fast cpd oracle among joint winners     
international grid based path planning competition  gppc   using variety benchmarks
competition show techniques improve copa  terms storage query
time  hub labeling technique initially developed speedup queries roads 
work graphs  gridmaps  hub labeling best knowledge fastest
technique known roads  experiments  show approach leads better query times
hub labeling graphs reasonably compute m 
technique relies all pairs shortest path pre computation  plays tradeoff
query response speed  preprocessing time memory required store compressed
path database  thus  algorithm faster  requires larger preprocessing time
memory techniques literature  words  memory
preprocessing time available  technique provide state of the art speed performance  hand  larger larger graphs create memory preprocessing time
bottleneck  techniques considered  see detailed comparison experiments
section 
theoretical analysis  formally define study optimal rle compression first move
matrices produced input graphs  consider case directed input graphs case
undirected weighted input graphs  show versions np complete  focusing
distinct types graphs  result brings something new compared other  related  kou 
      oswald   reinelt        weaker  less specific  mohapatra        results rle based
matrix compression available literature  however  known  np hardness class
problems necessarily imply np hardness subset class  thus  despite
   

fic ompressing ptimal paths run l ength e ncoding

previous related results  mohapatra         open question whether optimal rlecompression first move matrix computed input graph tractable 
show that  graphs decomposed along articulation points  problem
decomposed independent subproblems  optimal orderings available subproblems  global optimal ordering easily obtained  particular  depth first preorder
optimal trees  general ordering problem fixed parameter tractable size
largest   connected component 
approach part evaluation previously reported shorter conference
paper  strasser  harabor    botea         theoretical analysis topic another conference paper  botea  strasser    harabor         putting together current submission
provides unique source describes method  performance theoretical properties 
compared previous conference papers  provide complete proofs theoretical
results  included details examples presentation  better clarity 
report additional results  performance pathfinding competition gppc      
originally published paper competition  sturtevant  traish  tulip  uras 
koenig  strasser  botea  harabor    rabin        

   related work
many techniques literature employed order quickly answer first move queries 
standard examples include optimal graph search techniques dijkstras algorithm  dijkstra 
      a   hart  nilsson    raphael         significant improvements methods
achieved preprocessing input graph  done cpds  instance  shortest paths
numerous applications various fields  plethora different preprocessing based algorithms
proposed  overview  refer interested reader recent survey article  bast 
delling  goldberg  mullerhannemann  pajor  sanders  wagner    werneck         common
approach consists adding online pruning rules dijkstras algorithm  rely data computed preprocessing phase  significantly reducing explored graphs size  approach
significantly differs technique described paper  omit details refer
interested reader aforementioned survey article 
silc  sankaranarayanan et al         copa  botea   harabor      a  cpd based techniques fast first move computation  silc employs recursive quad tree mechanism compression copa uses simpler effective  botea        decomposition rectangles 
hub labels  hl  initially introduced   hop labels  cohen  halperin  kaplan    zwick 
       nearly decade much research topic  abraham  delling 
goldberg  werneck        showed technique practical huge road networks 
coined term hub labels  realization drastically increased interest hl thus
spawned numerous follow works   abraham  delling  goldberg    werneck       
delling  goldberg    werneck        abraham  delling  fiat  goldberg    werneck        akiba 
iwata    yoshida         context  relevant one probably rxl  delling et al  
       hl variant  authors show algorithm works well road
graphs variety graphs different sources including graphs derived maps used
gppc  compare algorithm rxl 
hl index consists forward backward label node  contains list hub
nodes exact distances them  st pair must exist meeting hub h
   

fis trasser   b otea     h arabor

forward hub backward hub shortest st path  shortest distance query
node node answered enumerating common hubs t  labeling
good labels contain hubs  computing labeling minimizing index size
np hard  babenko  goldberg  kaplan  savchenko    weller        
works consider hl general form  consider restrictive variant
called hierarchical hub labels  hhl   term introduced abraham et al        
labels used previous work  abraham et al         already hierarchical  labeling called
hierarchical ordering vertices exists  every hub h vertex v comes v
order  given fixed node order  optimal labeling computed efficiently  abraham
et al          difficult task hhl consists computing node order  computing node
order minimizing index size np hard task  babenko et al         
hhl deeply coupled different popular speedup technique shortest path computations called contraction hierarchies  ch   geisberger  sanders  schultes    delling         ch
achieve query speeds hhl significantly smaller index sizes  however 
applications even ch query times already faster necessary  makes ch
strong competitor  ch iteratively contracts nodes inserting shortcuts maintain shortest
path distances remaining graph  following inserted shortcuts small fraction
graph needs explored every node  node order good ch search
spaces every node small  again  computing optimal order np hard  bauer  columbus 
katz  krug    wagner         first hl paper road graphs  abraham et al         computed
label v explicitly storing nodes reachable v ch search space applying pruning rules  later papers refined rules  every hierarchical label
viewed explicitly stored pruned ch search space  consequence node orders
good ch good hhl vice versa  even though formal optimization
criteria differ therefore optimal order one respect criterion
slightly suboptimal other 
node orders used hhl original ch depend weights input graph 
substantial changes weights requires recomputing node ordering  recent work
 bauer  columbus  rutter    wagner        dibbelt  strasser    wagner        introduced
customizable contraction hierarchies  cch  shown node orders exist work well
depend structure input graph  node orders exploit input graph
small balanced node separators comparative small treewidth 
paper consider two types node orders  first depth first search preorder
second based small balanced edge cuts  thus independent input
graphs weights  however  confuse orders cch node orders 
interchangeable  using cch ordering result bad performance technique 
using one node orders cch work well  fact  using preorder cch
maximizes maximum search space terms vertices instead minimizing it  is 
order works well technique cch worst case node order  further  orders
interchanged weight dependent orders needed hhl ch 
described literature  hl answers distance queries  however  hinted abraham
et al          easy extend hub labels first move queries  achieve this  entries
forward backward labels extended third component  first move edge id  h
forward hub corresponding entry extended using first edge id shortest
sh path  h backward hub entry extended first edge shortest ht path 
   

fic ompressing ptimal paths run l ength e ncoding

st query first corresponding meeting hub h determined     h first move
edge id stored forward label otherwise first move contained backward
label t  slightly increases memory consumption negligible impact
performance  note distance values needed even one wishes compute first moves
need distances determine right hub several hubs common 
context program analysis sometimes desirable construct oracle determines particular section code ever reached  pwah  van schaik   de moor       
one example  similarly work  authors precompute quadratic matrix employ
compression scheme based run length encoding  main difference reachability
oracles return yes no answer every query rather identity first edge 
another speedup technique low average query times transit node routing  tnr   bast 
funke    matijevic        bast  funke  matijevic  sanders    schultes        antsfeld  harabor 
kilby    walsh         however  two independent studies  abraham et al         arz  luxen   
sanders        come conclusion  at least roads  tnr dominated hl
terms query time  further  tnr optimize short range queries  scenario often
arises unit chases another unit  situations units tend close 
results many short range queries  tnr rather ineffective scenario 
bulitko  bjornsson  lawrence        present subgoal based approach pathfinding  similarities work include preprocessing stage paths map precomputed 
results compressed stored database  database used speed
response time path query posed system  substantial differences
two approaches well  method precomputes all pairs shortest paths  eliminating graph
search entirely production mode  i e   stage system queried provide full
shortest paths fragments shortest paths   contrast  bulitko et al  restrict precomputed
database subset nodes  turn requires additional search production mode 
compression method different case  system provides optimal paths 
guaranteed case bulitko et al s method  besides bulitko et al         work  pathfinding
sub goals turned popular successful idea recent work  hernandez  
baier        bulitko  rayner    lawrence        lawrence   bulitko        uras  koenig   
hernandez        
pattern databases  pdbs   culberson   schaeffer        lookup tables provide heuristic
estimations true distance search node goal state  obtained abstracting
original search space smaller space  optimal distances abstracted space  every
state pre established goal  precomputed stored pattern database estimations
distances original space  such  techniques memory based enhancements
problems solution represented path graph  several key
distinctions pdbs cpds  pdbs lossy abstractions  specific goal
subset goals  cpds lossless compressions  encode shortest paths every starttarget
pair  given lossy nature  pdbs need used heuristic within search algorithm 
example a   opposed complete optimal method own  pdbs commonly
used large graphs  implicitly defined search spaces  exploring entire graph
preprocessing impractical  pdbs  coarseness abstraction impacts accurracy
heuristic estimations  finer abstraction better quality  result larger pdb 
work addressing bottleneck include compressing pattern databases  felner  korf  meshulam 
   

fis trasser   b otea     h arabor

  holte        samadi  siabani  felner    holte         contrast  cpds compress all pairs
shortest paths 

   preliminaries
denote g    v  e  graph node set v edge  set e v v   denote
deg u  number outgoing edges u   maximum out degree denoted   node
order   v      v    assigns every node v unique node id o v   out going edges every
node ordered arbitrary fixed order position  index ordering  referred
out edge id 
further  weight function w   e r       st path sequence edges a        ak
a  starts ak ends tp
every edge ai ends node ai  
starts  weight  or cost  path w ai    st path shortest st path exists
strictly smaller weight  distance two nodes weight shortest
st path  one exists  st path exists  distance   notice may multiple
shortest st paths weight 
without loss generality assume duplicate edges  multi edges  exist
graphs  were  could drop shortest edge  edges used
shortest path  further  using similar argument  assume without loss generality
reflexive loops exist 
   t  st first move first edge shortest st path  multiple shortest
st paths  may multiple st first moves  st path exists  st first move exists 
formal problem consider following  given pair nodes t  find st first move 
several valid first moves  algorithm freely choose return 
given oracle answers first move queries  easily extract shortest paths  compute
st first move a  words  first edge shortest path  next  set end a 
long    t  apply procedure iteratively  notice  works edge weights
guaranteed non zero  allowed zero weights  could run infinite loop problem 
following example illustrates  consider graph g two nodes x connected edges
xy yx weights zero  denote node g  valid xt first move using xy 
valid yt first move using yx  oracle always returned two first moves 
path extraction algorithm would oscillate x would terminate 
depth first search  dfs  way traversing graph constructing special sort
spanning tree using backtracking  depth first preorder node order orders nodes
way dfs first sees them  search parameterized root node order
neighbors node visited  work regularly refer depthfirst preorders without stating parameters  always implicitly assume root
arbitrary node neighbors visited arbitrary order 
   term arc used literature  sometimes  distinction made whether graph directed  in
case authors prefer say arcs  undirected  paper  stick term edge cases 
   directed graph  every ordered pair  u  v  e outgoing edge u  undirected graph  every edge
incident u outgoing edge u 
   assume function e r   able apply dijkstras algorithm preprocessing phase 
however  one could consider arbitrary weights without negative cycles replace every occurrence dijkstras
algorithm algorithm bellman ford  bellman        ford        

   

fic ompressing ptimal paths run l ength e ncoding

run length encoding  rle  compresses string symbols representing compactly
substrings  called runs  consisting repetitions symbol  instance  string aabbbaaa
three runs  namely aa  bbb  aaa  run replaced pair contains start
value run  start index first element substring  whereas value
symbol contained substring  example  first run aa start   value a 
run bbb start   value b  whereas last run start   value a  
first last run value  need encode both  first
run easily reconstructed constant time case  first  decide whether first run
removed not  done checking first run among preserved ones
start equal    secondly  needed  reconstruct first run  using   start position value
equal value last encoded run  another way looking that  first
last run value  allow merge  wrapped around string
form cycle  allow this  say using cyclic runs  otherwise  never consider
merging ends string   say use sequential runs  see example   below 
given ordered sequence elements  string   say two positions are  adjacent
next other  cyclic adjacent adjacent one first last
position ordering  separated otherwise 
let ordered sequence elements  symbols  dictionary  or alphabet    given
symbol   let  run rle run containing symbol   every string   denote
n    total number occurrences symbol   further  number sequential  runs
denoted rs    number cyclic rc     notice   rs   rc      
words  number sequential runs number cyclic runs never differ
   finally  denote rs    total number sequential runs rc    total number
cyclic runs  paper  assume first move compression uses cyclic runs  unless
explicitly say otherwise 
example    consider string   aabbbaaa  compressing yields    a     b     a 
means position   string consists as  similarily position   bs
finally position   elements string ends  na        nb        
three sequential runs  namely aa  bbb aaa  first third ones a runs 
whereas middle one b run  thus  ras         rbs         rs                
time  one cyclic a run  indeed  put next two ends
string  string cyclic  occurrences string become one solid block  i e  
one cyclic a run   thus  rac         rbc         rc                

   basic idea
mentioned introduction  algorithm starts building  v    v   all pairs first move
matrix m  entry position m i  j  ij first move  central idea algorithm
compress row using rle  compression performed gradually  matrix
rows computed  uncompressed matrix kept memory 
answer st first move query  run binary search row s  however  achieve
good compression ratio  first reorder columns decrease total number runs 
columns correspond nodes  regard problem reordering columns problem
   alternative encodings exist  value followed run length  e g   a     b     a    example 

   

fis trasser   b otea     h arabor

 
b  

a  
e  
 

c  
 

d  
 a  input

 
f   
 


     
 a
  ae f e
  e ed c
  f f dd
  c c c c
 b  first move matrix

 
 
 
 
 

  a
  a   e   f   e
  e   d   c
  f   d
  c

 c  compressed path database

figure    toy example algorithm
computing good node order  computing optimal node order minimizes number
runs np hard  show theoretical analysis  fortunately  simple depth first preorder
works well practice 
sometimes  formal analysis  technical details annoying sense
make presentation somewhat complicated  question symbol
use m i  i  example  practical implementation  say care
symbol  never query it  reduce number runs therefore assign either
value m i    i  m i      i   theoretical analysis  make similar assumption  i e  
dont care symbol  sections      state section    assumption
m i  i  symbol different edge symbol  every case  assumptions
purpose keeping analysis simple possible 
example    figure  a shows toy weighted undirected graph    nodes   edges 
edge  show weight  cost   number  unique label  letter  first move
matrix graph  corresponding node ordering                shown figure  b 
recall entry m r  c   r row c column  id first move
shortest path node r node c  example  m         e e first step ea 
optimal path node   node    another optimal path would single step path b 
ea b optimal weight  cost     thus  free choose m         e
m         b  prefer e leads better compression row   m  since
first two symbols third row  identical  part rle run  show
section   breaking ties optimal way feasible computationally easy 
compression given node ordering  or equivalently  matrix column ordering  shown
figure  c 
notice ordering nodes impacts size compressed matrix  example   
swapping nodes      illustrated figure    would reduce number rle runs
row    two e symbols become adjacent  total number runs decreases   
runs    runs  thus  challenge find optimal least good enough node ordering 
objective function size compressed first move matrix 
compression strategy rle illustrated example   key component approach  study theoretically next three sections  showing computing optimal
node ordering np hard general  identifying tractability islands  present number
effective heuristic node orderings section    variant implemented method  called src 
   

fic ompressing ptimal paths run l ength e ncoding

 
b  

a  
e  
 

c  
 

d  
 a  input

 
f   
 


     
 a
  af e e
  f f
  e e dc
  c c c c
 b  first move matrix

 
 
 
 
 

  a
  a   f   e
  f   d
  e   d   c
  c

 c  compressed path database

figure    toy example figure   different node ordering  i e   nodes  
  swapped  
performs compression illustrated example  another version program  called
mrc  goes beyond idea compressing row independently  implementing multi row
compression strategy  discussed section   evaluated empirically section    

   first move compression directed graphs
recall ordering columns first move matrix affects number rle runs
matrix  section show obtaining optimal ordering intractable general
input graph directed  construction works uniform edge weights  simplicitly
therefore omit weights section 
definition    fmcomp d  first move compressiondirected  problem 
input  directed graph g    v  e   matrix size  v    v   cell m i  j  encodes
first move optimal path node node j  integer k 
question  ordering columns that  apply rle row 
total number cyclic rle runs summed rows k 
theorem    fmcomp d problem np complete 
proof  easy see problem belongs np  solution guessed verified
polynomial time 
np hardness shown reduction hamiltonian path problem  hpp 
undirected graph  let gh    vh   eh   arbitrary undirected graph  define n    vh  
e    eh    starting gh   build instance fmcomp d problem  according
definition    instance includes directed graph  call gf   first move matrix
gf   number 
gf    vf   ef   defined follows  node u vh   define node vf   call
nodes vf type n nodes  indicate created original nodes vh  
edge  u  v  eh   define new node nuv vf  type e nodes   new node nuv   define
two edges ef   one nuv u one nuv v  edges ef   see
figure   example 
table   shows first move matrix running example  given type n node u 
nodes unreachable u graph gf   thus  matrix row corresponding u
   

fis trasser   b otea     h arabor

nxy



x

x



w

z

nxw
w

z

nwz
figure    left  sample graph gh   right  gf built gh   gf   x  y  w  z type n nodes 
nodes nij type e 

x

w
z
nxy
nxw
nwz

x
 
 
 
 
 
 


 
 
 
 
 
 

w
 
 
 
 
 
 

z
 
 
 
 
 
 

nxy
 
 
 
 
 
 

nxw
 
 
 
 
 
 

nwz
 
 
 
 
 
 
 

nr  cyclic runs
 
 
 
 
 
 
 

table    first move matrix running example  rows columns follow node
ordering x  y  w  z  nxy   nxw   nwz  
one non trivial symbol   chose symbol    denotes node
reachable  rows one rle run each  regardless node ordering 
matrix row corresponding type e node nuv three distinct  non trivial  symbols total 
one symbol edge node u  another symbol edge node v  non reachable
symbol   every node  without generality loss  use symbol   edge u 
symbol   edge v  easy see that  nodes u v cyclic adjacent given
ordering  nuv row   rle runs  u v separated  row   rle runs 
see table   sample orderings 
claim hpp solution iff fmcomp d solution  e     rle runs  let
vi    vi          vin solution hpp  i e   hamiltonian path gh    let p eh set
edges included solution  show node ordering vf starting vi            vin  
followed type e nodes arbitrary order  result  e       n     en    n
runs   n   runs total type e rows  corresponding edges p     e n      runs
total remaining type e rows  n runs total type n rows 
   trivial symbol mean dont care symbol   recall impact number runs 
simplicity  safely ignore symbol discussion 
   say row type n  or type e  iff associated node type 

   

fic ompressing ptimal paths run l ength e ncoding

indeed  edge  u  v  p   type e row corresponding node nuv vf
  rle runs  since u v adjacent ordering  n   edges hamiltonian
path  total number rle runs   n    rows 
edge  u  v 
  p   two nodes separated therefore corresponding matrix row
  runs  sums   e n      rle runs rows corresponding edges
included hamiltonian path 
conversely  consider node ordering creates  e         n        e n        n rle
runs total  show ordering type n nodes contiguous block  
ordering hamiltonian path gh   equivalent saying exist n   pairs
type n nodes u v u v cyclic adjacent ordering   u  v  eh  
proof contradiction  assume p   n   pairs type n nodes u v
u v cyclic adjacent ordering   u  v  edge eh  
p pairs  row corresponding type e node nuv   rle runs  remaining e p
type e rows   rle runs each  mentioned earlier  type n rows n runs total 
regardless ordering  thus  total number rle runs  p     e p    n    e p   n  
 e  n      n    e      contradiction 

   compression undirected weighted graphs
turn attention undirected weighted graphs  showing computing optimal ordering
np complete 
definition    fmcomp uw problem  first move compressionundirected  weighted  defined follows 
input  undirected weighted graph g    v  e   matrix size  v    v   cell m i  j 
stores first move optimal path node node j  integer k 
question  ordering ms columns that  apply run length encoding  rle 
row  total number cyclic rle runs matrix k 
stepping stone proving np hardness fmcomp uw  introduce problem
call simmini runs  definition     prove np completeness  simmini runs inspired
work oswald reinelt         studied complexity problem involving
so called k augmented simultaneous consecutive ones property  c sk       matrix  i e  
matrix two symbols        definition      matrix c sk property if 
replacing k  s  s  columns rows matrix ordered that 
row column   s row column come one contiguous block 
oswald reinelt        proven checking whether     matrix c sk property
np complete  proof simmini runs related  point later proof 
given     matrix o  ordering columns  ordering rows  let global
sequential   runs count gs   o  number sequential   runs summed rows
columns  is 
x
gs   o   
r s    


   here  notion contiguous block allows case part block end sequence 
part beginning  sequence cyclic 

   

fis trasser   b otea     h arabor

o 

r 
r 



c 

c 

c 

 
 

 
 

 
 



figure    running example     matrix o  rows labelled ri   whereas cj represent column
labels 
iterated os rows columns  instance  gs   o      matrix shown
figure   
definition    simultaneous mini   runs  simmini runs  problem defined follows 
input      matrix every row column contain least one value    integer k 
question  ordering columns  ordering rows  gs   o  k 
theorem    simmini runs np complete 
proof available appendix a 
lemma    let     string starts    ends    both 
r s      r c    
proof  case  i   starts   ends    two end symbols different  sequential
runs cyclic runs identical    runs   runs alternate  numbers identical  case
 ii   starts   ends    similar previous one 
case  iii     ends    runs   runs alternate    runs
ends  follows r s      r s        r c    
theorem    fmcomp uw np complete 
proof  np hardness shown reduction simmini runs  consider arbitrary
simmini runs instance rows n columns  figure   shows running example 
build undirected weighted graph g    v  e  follows  v   types nodes  total
  n     nodes  column generates one node v   call c nodes  row
generates one node well  r nodes   extra node p called hub node 
one r node ri one c node cj connected unit cost edge iff o ri   cj       
addition  edge weight      p every node  edges
exist graph g  see figure   example 
let first move matrix g  row p fixed number runs  namely   n  
regardless ordering ms columns  let v c node r node  apart vs adjacent
nodes  nodes reached shortest path cost     whose first move edge
 v  p   matrix running example shown figure   
let t  total number occurrences symbol   matrix o  claim
ordering os rows columns results k sequential   runs  summed rows
columns  iff ordering columns resulting k    t      n
   recall ignore dont care symbol m p  p      impact number rle runs 

   

fic ompressing ptimal paths run l ength e ncoding

p

c 

c 

c 

r 

r 

figure    graph running example  dashed edges weight      whereas solid lines
unit cost edges 

r 

m 

r 



r 









c 
c 
c 
p

r 

c 

c 

c 

p

         
         
         
         
         
         










figure    first move matrix running example  without generality loss    move
towards p  incident edges given node counted starting   
cyclic rle runs total  summed rows   thus rows m  except ps row 
k    t  runs total 
let ri          rim cj          cjn row column orderings result k
sequential rle runs rows columns  show ordering ri          rim   cj          cjn   p
ms columns generates k    t      n cyclic runs  clearly  every row column
o  corresponding row    see figures     example   according
steps explained earlier illustrated figures        obtained follows 
original  s preserved  original  s replaced distinct consecutive integers starting
   addition    padded  s one ends  since    s one
ends  follows r s      r c         follows rc         r c       n       r s    n     
summing rc       rows   m  except ps row  obtain
x
   m   p 

rc        

x

r s     

 o 

x
 o 

n     k    t   

denotes set rows matrix  set columns      follows
ms rows k    t      n cyclic rle runs total  that is  summed rows  
conversely  assume ordering ms columns k    t      n cyclic rle runs
total  for rows   means summing runs rows m  except node ps
row  results k    t  runs  exactly  t  distinct runs different   runs 
   r s      r c    lemma    r c      r c       construction 

   

fis trasser   b otea     h arabor

follows k   runs total 
x
   m   p 

r c       k 

let ri          rim   cj          cjn   p re arragement ms columns that  r nodes come
one contiguous block  relative ordering preserved  c nodes one contiguous block 
relative ordering preserved 
since g restricted c nodes r nodes bi partite  rearrangement cannot possibly increase number rle runs   if anything  could eliminate   runs   hard
prove  example  current matrix row corresponds r node source node 
m a  b      every r node b  since a  p  b optimal path b  also 
m a  p       rearrangement moves nodes b block cyclic adjacent p 
create new run  case c node source similar 
order os columns cj          cjn   os rows ri          rim   orderings 
relation row column corresponding row   follows 
non zero values   converted  s      s one ends cut
away   since   contains  s one ends  r s      r c        according lemma   
follows
x
x
r s     
r c       k 
 o  o 

   m   p 

   fighting complexity decomposition
far results negative  shown computing optimal order large
class graphs np hard  section identify tractability islands  show problem
decomposed along articulation points  which related cuts size     particular 
implies  as shown section  depth first preorder optimal node ordering trees 
able construct optimal orders efficiently broader class graphs trees 
show problem fixed parameter tractable size largest component
graph articulation points 
definition    say node x graph g articulation point removing x adjacent edges g would split graph two disjoint connected subgraphs g        gn  
figure   shows example  rest section focus graphs g articulation
points x  consider cyclic runs  previous sections  treated m s  s  dont care symbol 
impact number runs  section  make different assumption  every cell
m s  s  gets distinct symbol  called s singleton  always creates run 
merged adjacent symbols common run  makes proofs easier
clearly significant impact number runs 
definition    call x block ordering node ordering x comes first  nodes g 
come next contiguous block  way block gn  
   

fic ompressing ptimal paths run l ength e ncoding

figure    graph articulation point x  removing x would decompose graph four
disjoint components  depicted g  g   

example shown figure    ordering   x  a  b  c  d  e  f  g example
x block ordering 
use o g  denote projection node ordering subset nodes corresponding
subgraph g  g  use denote subgraph induced nodes gi  x    
say order rotation another order o  obtained o  taking block
o  elements beginning appending end  instance  d  e  f  g  x  a  b  c
rotation x  a  b  c  d  e  f  g  formally  rotation o  two sub orders
exist o           
lemma    let x articulation point graph g  every node order rearranged
x block ordering o  without increasing number runs row 
given graph g  node ordering row subset s  let n  o  g  s  number runs
restricted subset s  clearly  n  o  g  g  total number runs 
lemma    given x block ordering o  that 
   n  o  g  gi     n  o i     gi   
p
   n  o  g   x       n   n  o i      x   
p
   n  o  g  g      n   n  o i       
proofs lemmas     available appendix b 
theorem    given optimal order oi every subgraph induced   construct
optimal global ordering g following  obtain new orderings o i rotating oi x
comes first  removing x  then    x  o             o n optimal 
proof  show  contradiction  global ordering optimal  notice o i optimal
  assume strictly better ordering o    according lemma    exists x block
    subgraph induced subset nodes contains nodes edges whose ends belong s 

   

fis trasser   b otea     h arabor

ordering o   least good o   
n  o  g  g      n  

x

 n 

x

n  o i      





n  o    i      

  n  o     g  g  n  o    g  g 
contradiction o  strictly better  i e   n  o    g  g    n  o  g  g   
lemma    g tree depth first preorder g  with arbitrary root  rotated
x block order every node x 
proof  every preorder induces rooted tree  respect root every node x  except root 
parent p possibly empty sequence direct children c        cn ordered way
depth first search visited them  removing x  g decomposed subgraphs gp  
gc        gcn   x root gp empty graph  order following structure 
nodes gp   x  nodes gc        nodes gcn   remaining nodes gp   clearly
rotated x block ordering 
theorem    g    v  e  tree depth first preorder g n  o  g  g      v     
proof  direct consequence lemma   every node v many runs d v      
d v  degree node     comes v singleton  thus
n  o  g  g   

x
vv

 d v           e     v       v     

theorem    computing optimal order graph g fixed parameter tractable size
largest two connected component g  i e   largest component articulation points  
proof  recursively decompose g articulation points two connected parts left 
size parts depend size g enumerate orders pick
best one  given optimal orders every part use theorem   construct optimal global
order 
able decompose graphs along articulation points useful real world road networks 
graphs tend large two connected component many small trees attached  example europe graph made available  th dimacs challenge  demetrescu  goldberg 
  johnson          m nodes total     m within largest twoconnected component  result allows us position    m nodes order fast optimally
using local information 
   

fic ompressing ptimal paths run l ength e ncoding

   heuristic node orderings
sections     shown computing optimal order np hard theory  fortunately  np hardness rule existence good heuristic orderings
computed quickly  indeed  simple depth first preorder works well practice  observation partially explained fact that  shown section    depth first preorder
optimal trees  however  explain using informal intuitive terms 
ordering good neighboring nodes graph assigned neighboring ids 
consistent previous observation  sankaranarayanan et al         botea        that  two
target nodes close other  chances first move current node towards
targets same  depth first preorder achieves goal assigning close ids
neighboring nodes low degree graphs  node either interior node  root  leaf
dfs tree  nodes graph tend interior nodes  these  depth first preorder
assign two neighboring nodes adjacent ids  denote v internal node  p parent
c first child v  id p id v minus    whereas id c id
v plus one  guarantee nothing children  however  average node degree
low  case example road graphs  many children 
besides using depth first preorders  propose another heuristic based intuition assigning close ids close nodes  based cuts  formulated intuitive
optimization criterion formulated following  every edge  endpoints
close id  obviously fulfilled edges once  reason proposed ordering tries identify small set edges property may violated 
using balanced edge cuts  given graph n nodes want assign ids range     n 
using recursive bisection  first step algorithm bisects graph two parts nearly
equal node counts small edge cut size  divides id range middle assigns
lower ids one part upper ids part  continues recursively bisecting
parts dividing associated id ranges parts constant size left 
described far algorithm free decide part assigns lower
upper id ranges  reason augment tracking every node v two counters h v 
  v  representing number neighbors guaranteed higher lower ids  initially
counters zero  every bisection ranges assigned algorithm iterates
edge cut increasing counters border nodes  deciding two parts p q
gets ranges uses counters estimate id distance parts nodes around
them  evaluates
x
x
x
x
h v 
  v   
h v 
  v 
vq

vq

vp

vp

assigns higher ids p condition holds  algorithm encounters part
small bisected assigns ids ordered   v  h v  

   compression
let a        denote uncompressed row first move matrix  stated previously  src
compresses list runs ordered start  compressed rows vary size  need
additional index array maps source node onto memory offset first run
   

fis trasser   b otea     h arabor

row corresponding s  arrange rows consecutively memory therefore end ss
row start    s row  therefore need store row ends 
    memory consumption
required node ids encodable    bits out edge ids   bits  encode runs
start upper    bits    bit machine word value lower   bits  total memory
consumption therefore     v         r  bytes r total number runs rows
 v       number offsets index array  notice that  implementation  assume
  bytes per index entry sufficient  equivalent saying r         formula
easily adapted sizes  i e   number bits  node ids  edge ids  index entries 
instance  sum one node id one edge id k bytes  j bytes sufficient
encode index run  in words  number r fits j bytes   formula becomes
j   v          k r bytes 
    computing rows
rows computed individually running variant dijkstras one to all algorithm every
source node compressed described detail section      however  depending
graph possible shortest paths unique may differ first edge  therefore
possible multiple valid uncompressed rows exist tie break paths differently  rows
may differ number runs therefore different compressed sizes  minimize
compressed size row  instead using dijkstras algorithm compute one specific row
a        modify compute sets a        valid first move edges  require
shortest st path must exist uses first edge  algorithm maintains alongside
tentative distance array d t  node set valid first move edges   algorithm
relaxes edge  u  v  decreasing d v  performs av au   d u    w u  v    d v 
performs av av au   restricted out degree node    store
sets    bit bitfields  set union performed using bitwise or operation 
    compressing rows run length encoding
every target compression method given set valid first move edges may pick one
minimizes compressed size  formalize subproblem following  given sequence
sets a        find sequence a        ai ai minimizes number runs 
show subproblem solved optimally using greedy algorithm  algorithm begins
determining longest run
includes a   
done scanning a        ai ai  
intersection empty  j   i  aj    j   i    aj     algorithm chooses
value intersection  it matter which  assigns a        ai   continues
determining longest run starts contains ai   way  procedure
iterated rows end reached  approach optimal show
optimal solution longest first run exists  valid solution longer first run 
optimal solution shorter first run transformed increasing first runs length
decreasing second ones without modifying values  subsequences exchanged
without affecting surroundings conclude greedy strategy optimal 
   

fic ompressing ptimal paths run l ength e ncoding

 
b  

a  
e  
 

c  
 

d  

 
f   
 

 
 
 
 
 

  a
  a   f   e
  f   d
  e   d   c
  c

 a  input

 b  src

 
 
 
 
 

x
x   f   e
  f
  e   c
z

 c  mrc per row info 

x   a
  d
z   c

 d  mrc per group info 

figure    mrc applied toy graph figure    reproduced convenience  left 
part  b  illustrates src input full runs rs every row  part  c  show groups  x 
  z  row row specific runs r    finally  part  d  depicts runs r  g shared
rows group 

    merging rows using groups
compress individual rows exploited shortest paths t  t  often
first move t  t  close  similar observation made close source nodes
s  s    compressed rows tend resemble other  want compress
data exploiting redundancy  call technique multi row compression  mrc 
illustrate figure    partition nodes groups store group information
shared nodes group  row store information unique it  denote
g s  unique group node s  two runs different rows start value
   bit pattern  denote rs set runs row s  instead storing
row
whole set rs store group h intersection rows  is 
 
store r h   ih ri   row store r    rs   rg s    recall query target
consists finding max x rs   x   t     where t      t        notice formula
rewritten using basic set logic max max x r    x   t     max x r  g s    x   t    
implemented using two binary searches r  stored ordered arrays  note
need second index array lookup r  g groups g 
    computing row groups
design close source nodes close node ids thus neighbouring rows  motivates
restricting row run groupings  is  group h rows j
rows  i  j  belong group  optimal row run grouping computed using
dynamic programming  denote s n  maximum number runs saved compared using
group compression restricted first n rows  notice s         given s          s n 
want compute s n       obviously n    s row must part thet
last group  suppose
last group length   save total s n                  i n    n    ri   runs 
n different values   enumerate  brute force  possible values 
resulting algorithm running time  n     observe intersection large
groups often seems nearly empty therefore test values       resulting
 n  heuristic 
   

fis trasser   b otea     h arabor

    queries
given source node target node  with    t  algorithm determines first edge
shortest st path  first determining start end compressed row
using index array  runs binary search determine run containing
corresponding out edge id  precisely algorithm searches run largest start
still smaller equal t  recall encode run single    bit machine word
higher    bits runs start  reinterpret    bits unsigned integers 
algorithm consists binary search ordered    bit integer largest element
larger   t       i e   higher    bits   lower bits set  
extracting path using cpds extremely simple recursive procedure  beginning start
node extract first move toward target  follow resultant edge neighbouring
node repeat process target reached 

    experimental setup
evaluate work consider two types graphs  road graphs grid based graphs 
cases assume node ids encoded within    bit integers  assume
    use distinct value      indicate invalid edge  allows us encode
out edge ids within   bits  note concatenation node id out edge id fits
single    bit machine word 
experiments performed quad core i       cpu       ghz  mb combined cache   gb ram running ubuntu        algorithms compiled using g        
 o   reported query times use single core 
     grid graphs
chosen three benchmark problem sets drawn real computer games  first two sets
benchmark instances appeared      grid based path planning competition  third
benchmark set consists two worst case maps terms size  two maps available part
nathan sturtevants extended problem repository http   movingai com benchmarks 
part      competition set 
first benchmark set features    maps come game dragon age origins 
maps   k nodes    k edges  average 
second benchmark set features    maps come game starcraft 
maps    k nodes     m edges  average 
third benchmark set comprises two large grids evaluate separately 
largest maps available two games  extended dragon age origins
problem set choose map called ost   d     k nodes    m edges 
extended starcraft problem set choose map called thefrozensea 
   k nodes    m edges  note ost   d  largest dragon age
origins map  smaller average starcraft map 
grid maps evaluation undirected feature two types
edges  straight edges
weight     diagonal edges weight   
   

fic ompressing ptimal paths run l ength e ncoding

     road graphs
case road graphs chosen several smaller benchmarks made available
 th dimacs challenge  demetrescu et al         
new york city map  henceforth  ny     k nodes    k edges 
san francisco bay area  henceforth  bay     k nodes    k edges 
finally  state colorado  henceforth  col     k nodes  m edges 
three graphs travel time weights  denoted using  t suffix  geographic distance weights
 denoted using  d  available 
     comparisons
implemented algorithm two variants  single row compression  src  using row
merging optimization  multi row compression  mrc   using optimization  compare
approaches two recent state of the art methods  copa  botea   harabor      b 
rxl  delling et al          evaluate two variants copa  first variant 
denote copa g  appeared      gppc optimised grid graphs  use original
c   implementation available competition repository  sturtevant      a  
second variant  denote copa r  optimised road graphs  algorithm described
 botea   harabor      a   used original c   implementation program version
well 
rxl newest version hub labeling algorithm  asked original authors
run experiments us presented below  experiments carried xeon e             ghz  compensate lower clock speed  compared test machine 
scale query times rxl factor                  important note
implementation rxl computes path distances instead first moves  discussed section  
make significant difference query times  however unclear us whether
possible incorporate additional data needed first move computation compression
schemes presented delling et al          reported rxl database sizes therefore
regarded lower bounds 

    results
evaluate two algorithms  src mrc  terms preprocessing time  compression
performance query performance  study impact range heuristic node orderings
using metrics  three variants  distinguished suffix  suffix  cut
indicates node ordering based balanced edge separators graph cutting technique described
section    suffix  dfs indicates node ordering based depth first search traversal 
described section    suffix  input  or shorter  inp  indicates order nodes taken
associated input file  case grid graphs ordered nodes lexicographically  first
y  x coordinates  applicable compare work state of the art
first move algorithms copa r copa g  compare recent hub labeling
technique known rxl space efficient  but fast  variant called crxl 
   

fis trasser   b otea     h arabor

benchmark
dimacs
dragon age origins
starcraft
ost   d
thefrozensea

average preprocessing time  seconds 
compute order
single row compression
multi row compression
 cut
 dfs
 input
 cut
 dfs
 input
 cut
 dfs
 input
  
  
 
    
    
    
    
    
    
 
  
 
  
  
  
  
  
  
  
  
 
    
    
    
    
    
    
  
  
n m
   
   
n m
   
   
n m
   
  
n m
    
    
n m
    
    
n m

table    preprocessing time road grid graphs  give results  i  average time required
compute node ordering   ii  total time required compute entire database src
mrc  values given nearest second  ost   d thefrozensea preprocessing experiments
run amd opteron         cores       ghz accelerate apsp computation 
experiments smaller graphs clearly show input order fully dominated  therefore omit
numbers two larger test graphs  n m stands measured 
graph
 v  

 e 
 v  

copag

 cut

min    k
 
q 
 k    
med
 k    
avg   k    
q 
  k    
max    k    

  
  
 
  
  
  

  
  
  
 
 
  

min
q 
med
avg
q 
max

  
   
   
   
   
   

  
  
  
   
   
   

   k
   k
   k
   k
   k
   k

   
   
   
   
   
   

db size  mb 
query time  nano seconds 
mrc
src
mrc
src
um copag
 dfs  inp  cut  dfs  inp
 cut  dfs  inp  cut  dfs
dragon age  origins     maps 
              
  
  
        
     
              
 
  
        
     
 
 
    
 
    
  
        
     
 
  
 
 
  
     
   
        
     
  
  
 
  
  
    
   
               
                     
   
                
starcraft     maps 
  
  
                    
               
                      
   
                
                        
   
                
                         
   
                 
                          
   
                 
                                
                   

 inp
  
  
  
  
  
   
  
   
   
   
   
   

table    performance src mrc grid graphs  use two problem sets taken     
gppc compare copa g  one winners competition  measure  i  size
compressed database  in mb  and   ii  time needed extract first query  in nanos   values
rounded nearest whole number  either mb nano  respectively   baseline  column um shows
size naive  non compressed first move matrix 

     preprocessing time
table   gives average preprocessing time src mrc   road graphs two
competition sets  time case dominated need compute full apsp table 
previously commented  apsp compression central point work 
apsp computation  preprocessing approach involves executing dijkstras algorithm repeatedly
resulting total running time o n  log n  sparse graphs non negative weights  using
modern apsp techniques  e g   delling  goldberg  nowatzyk  werneck       succeeded
significantly reducing hidden constants behind big o able exploit specific
graphs structures  e g   road graphs  get running time down  however  techniques
give benefit repeatedly running dijkstras algorithm asymptotic worst case 
   

fic ompressing ptimal paths run l ength e ncoding

graph
name

 v  

 e 
 v  

bay d
bay t
col d
col t
ny d
ny t

   k
   k
   k
   k
   k
   k

   
   
   
   
   
   

db size  mb 
query time  nano seconds 
copa hub labels
mrc
src
copa hub labels
mrc
src
um
 r rxl crxl  cut  dfs  cut  dfs
 r rxl crxl  cut  dfs  cut  dfs
      
  
                                               
      
  
                                             
          
                                                
      
  
                                              
      
  
                                                
      
  
                                               

table    comparative performance src  mrc  copa r two recent hub labeling algorithms 
report size um uncompressed matrix  test one six graphs  th dimacs
challenge  measure  i  database sizes  in mb    ii  time needed extract first query  in nanos  
values rounded nearest whole number  graph sizes rounded nearest thousand nodes 

creating node order fast   dfs requires fractions second  even  cut order
requires    seconds average using metis  karypis   kumar         meanwhile 
difference running times src mrc indicate multi row compression
add small overhead total time  test instances
recorded preprocessing overhead order seconds 
     compression query performance
table   give overview compression query time performance copa g
range src mrc variants competition benchmark sets  measure query
performance run     random queries source target nodes picked uniformly random
average running times 
mrc outperforms src terms compression expense query time  node orders
significantly impact performance src mrc  cases  cut yields smaller database
faster queries  src mrc using  cut  dfs convincingly outperform copa g
majority test maps  terms space consumption query time 
naive  non compressed first move matrix impractical due large memory requirements  size uncompressed matrix would    v    bits  reflecting assumption
outgoing edge stored   bits  tables         specify column um memory consumption uncompressed matrix  example  ost   d game graph    k 
non compressed matrix requires bit  gb memory  two orders magnitude higher   mb  respectively   mb src cut respectively mrc cut
need  larger graphs  difference striking  example thefrozensea  largest
game graph     k nodes leads    mb mrc cut database compared    gb noncompressed matrix  hand  smaller graphs matrix would fit memory 
fetching moves would extremely fast  one table lookup per move  comparison 
fetch one move  method performs binary search compressed string whose length
larger  usually much smaller  v   
table   look performance   road graphs compare copa r  src  mrc 
rxl crxl  main observations road graphs  dfs leads smaller cpds
 cut  surprisingly  lower average row lengths yield faster query times  copa r dominated rxl  src  mrc  src cut outperforms competitors several factors terms
   

fis trasser   b otea     h arabor

graph
name
ost   d
frozensea

 v  

 e 
 v  

   k
   k

   
   

db size  mb 
mrc
src
um
rxl crxl  cut  dfs  cut  dfs
  
  
  
  
  
  
    
       
                      
hub labels

query time  nano seconds 
hub labels
mrc
src
rxl crxl  cut  dfs  cut  dfs
        
      
  
  
                        

table    performance src mrc large grid graphs nathan sturtevants extended repository 
compare hub labeling methods rxl  crxl  report size um uncompressed matrix  run tests thefrozensea  drawn game starcraft  ost   d  comes
game dragon age origins  measure  i  database sizes  in mb    ii  time needed extract
first query  in nanos   values rounded nearest whole number  rxl   crxl exploit graphs
undirected src   mrc not  directed graphs space consumption rxl would double 

graph
bay d
bay t
col d
col t
ny d
ny t
frozensea
ost   d

average row label
length
space  bytes 
src
sampg
src
sampg
 cut  dfs   plain  cut  dfs
  
       
   
       
  
  
  
   
       
  
       
   
       
  
   
  
   
       
  
       
    
       
  
       
   
       
  
       
    
         
  
  
   
    
       

table    report average number hubs per label  length   number runs per row  length  
average space usage per node sampg plain src 

speed  rxl wins terms database size  however factor gained space smaller
factor lost query time compared src  crxl clearly wins terms space two
orders magnitude slower competition  road graphs distance weights harder
travel time weights  already known algorithms exploit similar graph features
rxl  however  interesting seemingly unrelated first move compression based algorithms
incur penalties 
table   evaluate performance src  mrc  rxl crxl larger game
maps  dropped copa r experiments smaller graphs clear
fully dominated  road graphs  space consumption src mrc lower
 cut order  dfs  result  cut order clearly superior  dfs game maps 
ost   d src mrc beat rxl terms query time space consumption 
thefrozensea rxl needs less space src mrc  however  note game maps rxl
gains factor   exploiting graphs undirected src mrc not 
crxl employs powerful compression techniques specific shortest paths  rxl use
uncompressed uses basic encoding techniques delta encoding 
basic hl variant stores nodes distances explicitly needs memory  refer
basic variant sampg plain  sampg ordering algorithm used rxl   plain refers
    rxl paper describes several node orders  however  sampg order suggest using  rxl
crxl numbers paper use sampg 

   

fic ompressing ptimal paths run l ength e ncoding

 
b  

a  
e  

 
f   

 
c  
 

d  

 

 a  input graph

 b  computing rectangles

 c  list rectangles

figure    copas rectangle decomposition toy example figures     first
moves source node    similar decompositions needed every source node 

elementary hl encoding   bytes per hub id   bytes per distance value  want
comparse src sampg plain  therefore report table   average number hubs
per label average number runs per row using src  reported number hubs per
label  note directed graphs every node needs two labels  forward backward label 
undirected graphs two labels coincide one stored  contrasts
src cannot exploit input graph undirected  numbers table therefore
assume two hl labels needed per node better comparability  hl need store
   bit distance value     bit node id   bit out edge id times  
two labels per node  total space consumption thus   h bytes h average
number hubs per label  src need store    bit node id   bit out edge id per
run  results  r bytes r average number runs per row  table  
seen sampg plain consistently occupies space src  even though experiments
thus far suggest rxl compact  basic compression techniques rxl therefore
important enough make performance ordering algorithms tip respect
space consumption 
rxl advantages visible tables  example require computing
apsp preprocessing step significantly reducing preprocessing time  computes
besides first move shortest path distance 
     discussion
compared src mrc copa rxl  copa recent successful technique creating compressed path databases  one joint winners      grid based path planning
competition  gppc     regard copa current state of the art range pathfinding
problems including efficient storage extraction optimal first moves  rxl newest
version hub labeling algorithm knowledge state of the art terms minimizing query times road graphs 
   

fis trasser   b otea     h arabor

src mrc illustrated figures         figure   illustrates copa
works preprocessing  better understanding section  without intention fully
detailed description  copa assumes every node graph labelled x  coordinates 
toy example   rows   columns  shown figure    a   copa iterates
nodes graph  let n current node  source node  given iteration  copa splits
map rectangles  labels rectangle id outgoing edge n 
target belongs given rectangle  optimal move n towards precisely label
rectangle  figure    a  shows map decomposition source node    rectangles depicted
dashed line  three rectangles constructed figure  one bottom left 
size     label e  one top left  size     label a  one bottom right 
size     label f   part  b   rectangle represented   symbols each  upper
row  left column  width  height  label  show rectangles source node   
concatenated lists nodes  rectangles safely removed  list
trimming  skip example  then    columns figure    a  treated
separate string  compressed sliding window compression run length
encoding 
performed experiments large number realistic grid graphs used gppc    find
src mrc significantly improve query time compression power
copa  large number experiments broad range input maps able extract
first move tens hundreds nano seconds  a factor     faster copa  
two main reasons src mrc performant vs  copa  approach uses less memory
query running time logarithmic  cf  linear  label size 
approach requires less memory copa  part explanation stems differences sizes building blocks approach  src mrc  building
block rle run represented two numbers  start run  node id
thus requires log    v    bits  value run  out edge id requires log    
bits  copa  building block rectangle requires   log    v      log     bits  actual
implementations  src mrc store single    bit machine word per run  allows graphs     nodes  copa code used      grid based path planning
competition stores rectangle    bits  corresponding max node count      
clearly  size building blocks reason different compression
results  number rle runs src mrc differ total number rectangles
copa  one optimal out edge exists  src mrc select edge
improve compression  whereas copa sticks one arbitrary optimal out edge 
hand  besides rectangle decomposition  copa implements additional compression methods 
list trimming  run length encoding sliding window compression  performed top
original rectangle decomposition  botea   harabor      a  
approach asymptotic query time o log   k   k number compressed
labels must searched  comparison  given source node  copa stores corresponding
list rectangles decreasing order size  rectangles checked order  while 
worst case  total number rectangle checks linear size list  average number
much improved due ordering mentioned  botea        botea   harabor      a  
reason cpd faster rxl due basic query algorithm  algorithm
underlying rxl consists merge sort merge two integer arrays formed forward
label backward label t  fast cache friendly operation needs look
   

fic ompressing ptimal paths run l ength e ncoding

entry resulting inherently linear time operation  src hand builds upon
binary search slightly less cache friendly memory accesses sequential
logarithmic running time 
one regard compressed src rows one sided labels  st pair first move
determined using label s  hl hand needs forward label
backward label t  hl labels tend less entries src labels  however 
hl entry needs space need store distance values addition node ids 

    results      grid based path planning competition
recently submitted algorithms src cut src dfs      edition gridbased path planning competition gppc  sturtevant         section give brief overview
competition short summary results  full description methodology employed
organisers  well full account results  given  sturtevant et al         
     competition setup
grid based path planning competition features one hundred grid maps
three hundred thousand distinct problem instances drawn  individual maps differ size 
ranging several thousand several million nodes  topography maps varied
many maps originating computer games starcraft  dragon age  origins dragon
age    maps appearing part competition synthetically generated grids  mazes 
rooms randomly placed obstacles varying density       edition competition
total    different entries  submitted   different teams  several entries variants
algorithm submitted team 
  entries employ symmetry breaking speed search  entries bljps  bljps   jps 
jps bucket roughly described extensions jump point search  harabor  
grastien        jps   harabor   grastien         entry nsubgoal makes use
multi level subgoal graphs  uras   koenig         finally entry named bljps sub
hybrid algorithm makes use jump point search subgoal graphs 
  entry  ch  employs variation contraction hierarchies  dibbelt et al         
  entries directly improve performance a  algorithm  either use faster
priority queues  a  bucket  trading optimality speed  ra  ra  subgoal  
  entries use compressed path databases  two  src dfs i src cut i 
incremental algorithms return optimal path one segment time  is  must
called repeatedly target location returned  two algorithms  src dfs
src cut  non incremental queried return complete path 
unfortunately    entries contained bugs therefore finish instances 
src cut one them  therefore omit tables discussion 
     results
summary results competition given table    observe following 
   

fis trasser   b otea     h arabor

entry


ra 
bljps
jps 
bljps 

ra  subgoal
jps  bucket
bljps  sub
nsubgoal
ch
src dfs
src dfs i

averaged query time test paths  s 
slowest move
first    moves
full path
path
path
extraction
       
       
       
      
      
      
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
   
   
   
   
   
   
   
   
   
 
 
   

preprocessing requirements
db size
time
 mb 
 minutes 
 
   
  
   
   
   
  
   
   
   
   
   
   
   
   
   
     
     
      
       
      
       

table    results      grid based path planning competition  figures summarised
official competition results  appear  sturtevant et al          entries denoted
indicate approximate algorithms guaranteed always find shortest path 
measurments bold indicate entry performed best regard single criterion 
entries whose name bold fully pareto dominated respect every
criterion  preprocessing running times time needed process     test maps 
   cpd based entries fastest methods competition across query time metrics  includes fastest  average  time required extract complete optimal path 
fastest  average  time extract first    steps optimal path fastest  average 
time required extract single step optimal path 
   performing first move query algorithm faster resolution competitions microsecond timer  even iteratively extracting    edges path barely
measurable without finer timer resolution  testing observed significant
amount query running time spent within benchmarking code provided
competition  therefore opted submit two variants  src dfs extracts path
whole  benchmarking code thus run per path  hand src dfs i
extracts path one edge time  allows measuring time needed individual
first move query  unfortunately  requires executing benchmarking code per
edge  difference path extraction running times src dfs src dfs i  i e  
  s  time spent benchmarking code 
   algorithm competitor able answer first move queries faster
full path extraction 
   entries database driven require generous amounts preprocessing time
storage space  src dfs therefore largest total preprocessing time largest
total storage cost entries competition 

    conclusion future work
study problem creating efficient compressed path database  cpd   shortest path
oracle which  given two nodes weighted directed graph  always returns first move
   

fic ompressing ptimal paths run l ength e ncoding

optimal path connecting them  starting all pairs first move matrix  assume
given  create oracles compact answer arbitrary first move queries
optimally many orders faster otherwise possible using conventional online graph search
techniques  employ run length encoding  rle  compression scheme throughout analyse
problem theoretical perspective empirical one  main idea simple 
look re order nodes  i e   columns  input first move matrix good way
rle compressed size subsequently reduced 
theoretical side show problem finding optimal node ordering 
general case directed directed graphs  np complete  specific cases 
graphs decomposed along articulation points  problem efficiently tackled
solving series independent sub problems  particular show depth first traversal
tree provides optimal node ordering  results give first theoretical underpinning
problem creating space efficient cpds using rle  work extends theoretical results
areas information processing databases  oswald   reinelt        mohapatra        
empirical side study efficacy three heuristic node orderings   i  depth first
ordering   ii  graph cut ordering based balanced edge separators   iii  naive baseline given
ordering specified input graph  given ordering first move matrix  describe
two novel approaches creating cpds  first these  src  uses simple run length encoding
compress individual rows matrix  second approach  mrc  sophisticated
identifies commonalities sets labels compressed src 
range experiments show src mrc compress apsp matrix graphs
hundreds thousands nodes little      mb  associated query times regularly
require less     nanoseconds  compare approaches copa  botea       
botea   harabor      a   rxl  delling et al          range experiments grid
road graphs show src mrc competitive copa often several
factors better  terms compression query times  show src mrc
outperform rxl terms query time  summarise results      grid based
path planning competition  particular report src fastest method
competition across query time metrics src performed better resolution
competitions microsecond timer 
appear several promising directions current work could extended  one
immediate possibility harness available results efficient appproximate tsp algorithms
order compute better space efficient node orderings  another immediate possibility
improve current mrc compression scheme devising algorithm optimizes
assignment first move ids 
looking broadly  strength cpds have  addition fast move extraction 
compress kind path network distance optimal   
multi agent pathfinding example sometimes useful guarantee properties must
always local detour available  wang   botea         another example turn costs road
graphs  thus one possible possible direction future work create cpds store
paths satisfying constraints 
weakness approach preprocessing apsp computation required 
delling et al         shown apsp sometimes computed reasonably fast
    suboptimal paths  however  introduce additional challenge avoiding infinite loops extracting path
cpd 

   

fis trasser   b otea     h arabor

graphs many nodes  apsp remains inherently quadratic number nodes
graph class output size quadratic  approach would therefore hugely profit
algorithm directly compute compressed cpd without first computing first move
matrix intermediate step 

    acknowledgments
thank patrik haslum  akihiro kishimoto  jakub marecek  anika schumman jussi rintanen
feedback earlier versions parts work  would thank daniel delling  
thomas pajor running hub labeling experiments us 

appendix a  proof theorem  
theorem    simmini runs np complete 
proof  membership np straightforward  hardness proof uses reduction
hamiltonian path problem  hpp  undirected graph  let g    v  e  arbitrary undirected
graph  without duplicate edges  define n    v   e    e   figure    shows toy graph used
running example 
starting g  build simmini runs instance follows  define     matrix
e rows n columns  let r row corresponding edge  u  v   let cu cv
columns associated nodes u v  m r  cv     m r  cu       m r  c     
columns  notice least value   every row column  figure    shows
matrix running example 
x



w

z

figure     sample graph g 
let r matrix row corresponding edge  u  v   easy see that  given
ordering columns  nodes  makes two nodes u v adjacent  number sequential

 x  y 
 x  w 
 x  z 
 w  z 

x
 
 
 
 


 
 
 
 

w
 
 
 
 

z
 
 
 
 

figure     matrix built g 
   

fic ompressing ptimal paths run l ength e ncoding

 x  z 
 w  z 
 x  w 
 x  y 


 
 
 
 

x
 
 
 
 

w
 
 
 
 

z
 
 
 
 

figure     matrix after  i  converting  s  s  shown bold   ii  re ordering columns
hamiltonian path  iii  re ordering rows lexicographically 

 x  z 
 w  z 
 x  w 
 x  y 


 
 
 
 

x
 
 
 
 

w
 
 
 
 

z
 
 
 
 

figure     matrix restoring back previously replaced  s  shown bold  
rle   runs   row r    nodes adjacent  number sequential rle   runs
row r   
claim hpp solution iff simmini runs solution    e n     rle
  runs  let vi            vin solution hpp  i e   hamiltonian path   let p set
edges included solution  running example  let p contain  y  x    x  w   w  z  
every row corresponding edge contained p   switch one two   entries
   then  order columns respect sequence nodes hamiltonian path
rearrange rows lexicographical order  figure    illustrates changes 
construction matrix  trick converting  s  s  ordering
rows columns reused oswald reinelts proof hardness deciding
whether     matrix c sk property  oswald   reinelt         rest proof 
coming below  significantly different 
now  restore previously replaced  s  shown figure     e n      s
replaced restored adjacent  s matrix    such  counts two
  runs  one horizontal one vertical  sums total   e n        runs corresponding
 s replaced restored  addition  row column one   run  follows
matrix  e n       runs 
conversely  consider row column ordering creates  e n     rle   runs total 
show matrix least e     vertical   runs  regardless row ordering  consider
rows  order  starting top  first row introduces exactly   vertical   runs  one
column contains value    subsequent row introduces least one vertical
  run  otherwise  new row would identical previous one  contradicts fact
graph duplicate edges 
    runs used proof sequential 
    adjacent   column  would imply two identical rows  would mean
g duplicate edges  adjacent   row  would mean edge hand belongs
hamiltonian path  contradicts fact  s replaced restored complementary set edges 

   

fis trasser   b otea     h arabor

least e     vertical   runs  number horizontal   runs
  e n       e         e n      show column ordering hamiltonian path 
assuming contrary  p   n   edges nodes adjacent
ordering  follows number horizontal   runs p     e p     e p    e n     
contradiction 

appendix b  proofs lemma   lemma  
start pointing two simple important properties stemming notion articulation point 
remark    given graph g  let x articulation point  let g        gn corresponding
connected components obtained removing x 
   given source node gi   first optimal move towards anywhere outside gi
same   
   given two distinct components gi gj   first optimal move x towards anywhere
gi different first optimal move x towards anywhere gj  
remark   follows easily obvious observation way going one
subgraph gi another subgraph gj passing x  see figure   illustration 
lemma    let x articulation point graph g  every node order rearranged
x block ordering o  without increasing number runs row 
proof  construct desired ordering o  applying following steps 
   rotate x comes first 
   every          n  project resulting order onto gi   obtaining suborder o i  
   define o  as  o    x  o             o n  
clear construction nodes every subgraph gi consecutive o    remains
show number runs per row grow 
denote source node  distinguish two cases 
case gi i  rotation 
step   impact number

cyclic runs  steps     take nodes k  i gk put one two blocks
cyclic
adjacent x  know remark    point   m s  x    m s  n 
nodes n k  i gk   thus  re arrangement brings next x nodes n
first move symbol x  clearly  increase number runs 
case   x  previous case  rotation performed step   increase
number cyclic runs  step    cyclic runs sequential runs equivalent  since
first position contains distinct symbol  namely x singleton  steps     separate
    assuming split ties among optimal paths consistent manner  easy ensure 

   

fic ompressing ptimal paths run l ength e ncoding

gi contiguous block  increase number sequential runs since 
according remark    point    every two blocks corresponding gi gj      j 
common symbol  follows number cyclic runs increase either 

lemma    given x block ordering o  that 
   n  o  g  gi     n  o i     gi   
p
   n  o  g   x       n   n  o i      x   
p
   n  o  g  g      n   n  o i       
proof  prove point follows 
   x block ordering  nodes come order x  g          gi         gn   consider
node gi corresponding row first move matrix  pointed remark   
every path node outside gi pass x  therefore first move
anywhere outside gi same  follows nodes sequence x  g          gi   
together nodes sequence gi  s
        gn   form one cyclic run  effect  removing
consideration nodes contained k  i gk leaves number runs unchanged 
completes proof case 
   case focused x start node  according remark    gi    gj  
first move x towards anywhere gi different first move x towards
anywhere gj   follows two runs two adjacent subsets gi gi   never merge
one run  thus 
x
n  o  g   x        
 n  o i      x     


   n 

x


n  o i      x   

   case follows previous two  standard arithmetic manipulation 
x
n  o  g  g    n  o  g   x    
n  o  g  gi  


   n 

x

   n 

x
 n  o i      x     n  o i     gi   



n  o i      x    

x



x
   n 
 n  o i      x  gi  


   n 

x

n  o i       



   

n  o i     gi  



fis trasser   b otea     h arabor

references
abraham  i   delling  d   fiat  a   goldberg  a  v     werneck  r  f          hldb  locationbased services databases  proceedings   th acm sigspatial international
symposium advances geographic information systems  gis     pp          acm
press  best paper award 
abraham  i   delling  d   goldberg  a  v     werneck  r  f          hub based labeling algorithm
shortest paths road networks  proceedings   th international symposium
experimental algorithms  sea     vol       lecture notes computer science  pp 
        springer 
abraham  i   delling  d   goldberg  a  v     werneck  r  f          hierarchical hub labelings
shortest paths  proceedings   th annual european symposium algorithms
 esa     vol       lecture notes computer science  pp        springer 
akiba  t   iwata  y     yoshida  y          fast exact shortest path distance queries large networks pruned landmark labeling   proceedings      acm sigmod international
conference management data  sigmod     pp          acm press 
antsfeld  l   harabor  d   kilby  p     walsh  t          transit routing video game maps  
aiide 
arz  j   luxen  d     sanders  p          transit node routing reconsidered  proceedings
  th international symposium experimental algorithms  sea     vol       lecture
notes computer science  pp        springer 
babenko  m   goldberg  a  v   kaplan  h   savchenko  r     weller  m          complexity hub labeling  proceedings   th international symposium mathematical
foundations computer science  mfcs     lecture notes computer science  springer 
baier  j   botea  a   harabor  d     hernandez  c          fast algorithm catching prey
quickly known partially known game maps  computational intelligence ai
games  ieee transactions on  pp     
bast  h   delling  d   goldberg  a  v   mullerhannemann  m   pajor  t   sanders  p   wagner  d    
werneck  r  f          route planning transportation networks  tech  rep  abs            
arxiv e prints 
bast  h   funke  s     matijevic  d          ultrafast shortest path queries via transit nodes 
shortest path problem  ninth dimacs implementation challenge  vol     dimacs
book  pp          american mathematical society 
bast  h   funke  s   matijevic  d   sanders  p     schultes  d          transit constant shortestpath queries road networks  proceedings  th workshop algorithm engineering
experiments  alenex     pp        siam 
bauer  r   columbus  t   katz  b   krug  m     wagner  d          preprocessing speed up
techniques hard  proceedings  th conference algorithms complexity
 ciac     vol       lecture notes computer science  pp          springer 
bauer  r   columbus  t   rutter  i     wagner  d          search space size contraction hierarchies  proceedings   th international colloquium automata  languages 
   

fic ompressing ptimal paths run l ength e ncoding

programming  icalp     vol       lecture notes computer science  pp        
springer 
bellman  r          routing problem  quarterly applied mathematics           
botea  a          ultra fast optimal pathfinding without runtime search  proceedings seventh aaai conference artificial intelligence interactive digital entertainment  aiide     pp          aaai press 
botea  a          fast  optimal pathfinding compressed path databases  proceedings
symposium combinatorial search  socs    
botea  a   baier  j  a   harabor  d     hernandez  c          moving target search compressed
path databases  proceedings international conference automated planning
scheduling icaps 
botea  a     harabor  d       a   path planning compressed all pairs shortest paths data 
proceedings   rd international conference automated planning scheduling 
aaai press 
botea  a     harabor  d       b   path planning compressed all pairs shortest paths data 
proceedings international conference automated planning scheduling icaps 
botea  a   strasser  b     harabor  d          complexity results compressing optimal paths 
proceedings national conference ai  aaai    
bulitko  v   bjornsson  y     lawrence  r          case based subgoaling real time heuristic
search video game pathfinding  j  artif  intell  res   jair              
bulitko  v   rayner  d  c     lawrence  r          case base formation real time heuristic
search  proceedings eighth aaai conference artificial intelligence interactive digital entertainment  aiide     stanford  california  october            
cohen  e   halperin  e   kaplan  h     zwick  u          reachability distance queries via
  hop labels  proceedings thirteenth annual acm siam symposium discrete
algorithms  soda     pp          philadelphia  pa  usa  society industrial applied mathematics 
culberson  j  c     schaeffer  j          pattern databases  computational intelligence        
       
delling  d   goldberg  a  v   nowatzyk  a     werneck  r  f          phast  hardwareaccelerated shortest path trees  journal parallel distributed computing            
    
delling  d   goldberg  a  v   pajor  t     werneck  r  f          robust distance queries massive
networks  proceedings   nd annual european symposium algorithms  esa    
vol       lecture notes computer science  pp          springer 
delling  d   goldberg  a  v     werneck  r  f          hub label compression  proceedings
  th international symposium experimental algorithms  sea     vol      
lecture notes computer science  pp        springer 
demetrescu  c   goldberg  a  v     johnson  d  s   eds            shortest path problem  ninth
dimacs implementation challenge  vol     dimacs book  american mathematical
society 
   

fis trasser   b otea     h arabor

dibbelt  j   strasser  b     wagner  d          customizable contraction hierarchies  proceedings
  th international symposium experimental algorithms  sea     vol      
lecture notes computer science  pp          springer 
dijkstra  e  w          note two problems connexion graphs  numerische mathematik 
          
felner  a   korf  r  e   meshulam  r     holte  r  c          compressed pattern databases   j 
artif  intell  res   jair              
ford  jr   l  r          network flow theory  tech  rep  p      rand corporation  santa monica 
california 
geisberger  r   sanders  p   schultes  d     delling  d          contraction hierarchies  faster
simpler hierarchical routing road networks  proceedings  th international
conference experimental algorithms  wea     pp         
harabor  d  d     grastien  a          online graph pruning pathfinding grid maps  burgard  w     roth  d   eds    proceedings twenty fifth aaai conference artificial
intelligence  aaai       san francisco  california  usa  august             aaai press 
harabor  d  d     grastien  a          improving jump point search  chien  s   do  m  b  
fern  a     ruml  w   eds    proceedings twenty fourth international conference
automated planning scheduling  icaps       portsmouth  new hampshire  usa  june
             aaai 
hart  p  e   nilsson  n     raphael  b          formal basis heuristic determination
minimum cost paths  ieee transactions systems science cybernetics            
hernandez  c     baier  j  a          fast subgoaling pathfinding via real time search  
proceedings international conference automated planning scheduling icaps   
karypis  g     kumar  v          metis  software package partitioning unstructured graphs 
partitioning meshes  computing fill reducing orderings sparse matrices  version      
kou  l  t          polynomial complete consecutive information retrieval problems  siam journal
computing             
lawrence  r     bulitko  v          database driven real time heuristic search video game
pathfinding  computational intelligence ai games  ieee transactions on           
    
mohapatra  a          optimal sort ordering column stores np complete  tech  rep   stanford university 
oswald  m     reinelt  g          simultaneous consecutive ones problem  theoretical computer science                       
samadi  m   siabani  m   felner  a     holte  r          compressing pattern databases
learning  proceedings      conference ecai         th european conference
artificial intelligence  pp          amsterdam  netherlands  netherlands  ios
press 
   

fic ompressing ptimal paths run l ength e ncoding

sankaranarayanan  j   alborzi  h     samet  h          efficient query processing spatial networks  proceedings   th annual acm international workshop geographic information systems  gis     pp         
strasser  b   harabor  d     botea  a          fast first move queries run length encoding  proceedings symposium combinatorial search  socs    
sturtevant  n       a        grid based path planning competition  https   code google 
com p gppc       
sturtevant  n       b   website grid based path planning competition       http 
  movingai com gppc  
sturtevant  n          website grid based path planning competition       http 
  movingai com gppc  
sturtevant  n   traish  j   tulip  j   uras  t   koenig  s   strasser  b   botea  a   harabor  d    
rabin  s          grid based path planning competition       entries results 
proceedings  th international symposium combinatorial search  socs     aaai
press 
uras  t     koenig  s          identifying hierarchies fast optimal search  brodley  c  e    
stone  p   eds    proceedings twenty eighth aaai conference artificial intelligence 
july               quebec city  quebec  canada   pp          aaai press 
uras  t   koenig  s     hernandez  c          subgoal graphs optimal pathfinding eightneighbor grids   proceedings international conference automated planning
scheduling icaps    
van schaik  s  j     de moor  o          memory efficient reachability data structure bit
vector compression  proceedings      acm sigmod international conference
management data  sigmod     pp          new york  ny  usa  acm 
wang  k  h  c     botea  a          mapp  scalable multi agent path planning algorithm
tractability completeness guarantees  journal artificial intelligence research  jair  
         

   


