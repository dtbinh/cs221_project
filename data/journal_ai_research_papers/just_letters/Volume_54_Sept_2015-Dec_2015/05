journal artificial intelligence research                 

submitted       published      

expressiveness two valued semantics
abstract dialectical frameworks
hannes strass

strass informatik uni leipzig de

computer science institute  leipzig university
augustusplatz           leipzig  germany

abstract
analyse expressiveness brewka woltrans abstract dialectical frameworks
two valued semantics  expressiveness mean ability encode desired set
two valued interpretations given propositional vocabulary using atoms
a  compare adfs expressiveness  the two valued semantics of 
abstract argumentation frameworks  normal logic programs propositional logic 
computational complexity two valued model existence problem
languages  almost  same  show languages form neat hierarchy
respect expressiveness  demonstrate hierarchy collapses
allow introduce linear number new vocabulary elements  finally analyse
compare representational succinctness adfs  for two valued model semantics  
is  capability represent two valued interpretation sets space efficient manner 

   introduction
often not  different knowledge representation languages conceptually similar partially overlapping intended application areas  faced
application choice several possible knowledge representation languages
could used application  one first axes along compare different
formalisms comes mind computational complexity  language computationally expensive considering problem sizes typically encountered practice 
clear criterion exclusion  available language candidates
computational complexity  expressiveness computationalcomplexity sense kinds problems formalism solve  same 
need fine grained notion expressiveness  paper  use notion
study expressiveness abstract dialectical frameworks  adfs   brewka   woltran 
      brewka  ellmauthaler  strass  wallner    woltran         recent generalisation
abstract argumentation frameworks  afs   dung        
argumentation frameworks de facto standard formalism abstract argumentation  field studies  abstract  arguments relate terms directed
conflicts  attacks   conflicts resolved without looking
arguments  afs popular well studied  noted many times
literature expressive capabilities somewhat limited  recently
made technically precise dunne  dvorak  linsbichler  woltran              
basically showed introducing new  purely technical arguments sometimes inevitable using afs representation purposes  however  due nature 
dialectical meaning technical arguments might ironically debatable 
c
    
ai access foundation  rights reserved 

fistrass

surprisingly  quite number generalisations afs proposed  for
overview refer brewka  polberg    woltran         one general af
alternatives  aforementioned abstract dialectical frameworks  adfs  emerged 
formalism  arguments  called statements there  abstract  links
arguments  afs links necessarily attacks  adfs statement
associated acceptance condition boolean function parent statements
specifies exactly statement accepted  way  acceptance
conditions ultimately express meaning links adf  even restricted subclass
bipolar adfs intuitively links supporting attacking proper
generalisation afs  quite expressive one shall see paper 
adfs could called lovechild afs logic programs  since combine
intuitions semantics dung style abstract argumentation well logic programming  brewka et al         strass        alviano   faber         abstract
level  adfs intended function argumentation middleware sufficiently expressive target formalism translations concrete  application  formalisms 
part adf success story  mention reconstruction carneades model
argument  brewka   gordon         instantiation simple defeasible theories
adfs  strass      a   recent applications adfs legal reasoning reasoning
cases al abdulkarim  atkinson  bench capon              
paper  approach abstract dialectical frameworks knowledge representation
formalisms  since used represent knowledge arguments relationships
arguments  employ view analyse representational capabilities
adfs  due roots afs logic programs  compare representational capabilities formalisms setting  initial study restrict
looking two valued semantics  specifically adf  stable  model semantics  corresponds af stable extension semantics  supported stable
model semantics logic programs  add propositional logic well known reference point  analysing precise formalisms additionally makes sense us
computational complexity respective model existence problems  with
one exception  
afs  deciding stable extension existence np complete  dimopoulos  nebel   
toni        
normal logic programs  deciding existence supported stable models npcomplete  bidoit   froidevaux        marek   truszczynski        
adfs  deciding existence  supported  models np complete  brewka
et al          deciding existence stable models p   complete general
adfs  brewka et al         np complete subclass bipolar adfs  strass
  wallner        
propositional satisfiability problem np complete 
view almost identical complexities  use alternative measure
expressiveness knowledge representation formalism f  given set two valued
interpretations  knowledge base f exact model set  notion
   

fiexpressiveness two valued semantics adfs

lends straightforwardly compare different formalisms  gogic  kautz  papadimitriou 
  selman        
formalism f  least expressive formalism f  every
knowledge base f  equivalent knowledge base f   
expressiveness understood terms realisability  kinds model sets
formalism express   in model theory  known definability  
easy see propositional logic express set two valued interpretations 
universally expressive  easy  but less easy  see normal logic programs
supported model semantics  normal logic programs stable model semantics 
clear model sets expressed  since two different stable models
always incomparable respect subset relation   paper  study
expressiveness properties mentioned formalisms different semantics 
turns languages form less strict expressiveness hierarchy  afs
bottom  adfs lps stable semantics higher adfs lps
supported model semantics top together propositional logic 
show language f  least expressive language f  mainly
use two different techniques  best case  use syntactic compact faithful
translation knowledge bases f  f    compact means translation
change vocabulary  is  introduce new atoms  faithful means
translation exactly preserves models knowledge base respective semantics
two languages  second best case  assume knowledge base f 
given form set x desired models construct semantic realisation x
f    is  knowledge base f  model set precisely x  show language
f  strictly expressive f    additionally present knowledge base kb
f  prove f  cannot express model set kb 
analysing expressiveness argumentation formalisms quite recent strand
work  ascent attributed dunne et al                studied realisability
argumentation frameworks  allowing introduce new arguments long
never accepted   likewise  dyrkolbotn        analysed af realisability projection
 allowing introduce new arguments  three valued semantics  baumann  dvorak  linsbichler  strass  woltran        studied expressiveness subclass compact
afs  argument accepted least once  finally  recently  puhrer
       analysed realisability three valued semantics adfs  previous preliminary works include brewka  dunne  woltran         translated adfs
afs adf model af stable extension semantics  however translation
introduces additional arguments therefore compact   strass        
studied syntactic intertranslatability adfs lps  look
expressiveness realisability 
gain achieved analysis paper increased
clarity fundamental properties knowledge representation languages
formalisms express  actually  several applications  dunne
et al         remarked  major application constructing knowledge bases aim
   however  stable model semantics becomes universally expressive allow nested expressions
form p rule bodies  lifschitz  tang    turner        lifschitz   razborov        

   

fistrass

encoding certain model set  necessary prerequisite this  must known
intended model set realisable first place  example  recent approach
revising argumentation frameworks  coste marquis  konieczny  mailly    marquis        
authors avoid problem assuming produce collection afs whose model sets
union produce desired model set  work dunne et al         showed
indeed necessary case afs stable extension semantics  work shows
adfs model semantics  single knowledge base  adf  always enough
realise given model set  more  assume intended model set
given form propositional formula  size realising adf
linear size formula  one example several occasions
consider sizes realisations  uncommon logic based ai  darwiche  
marquis        lifschitz   razborov        french  van der hoek  iliev    kooi        shen
  zhao         indeed  representation size fundamental practical aspect knowledge
representation languages  universal expressiveness little use model sets express
require exponential size knowledge bases even best case 
course  fact languages study computational complexity
means principle exist polynomial intertranslations respective decision
problems  intertranslations may involve introduction polynomial number
new atoms  theory  increase n atoms nk atoms k    
consequence  practice  profound impact  number n atoms directly
influences search space implementation potentially cover  there  step
 n
k  n
k
k 
 n    n n    n
amounts exponential increase search space size  able realise model set
compactly  without new atoms  therefore attests formalism f certain basic
kind efficiency property  sense f realisation model set
unnecessarily enlarge search space algorithms operating it 
might seem restricting assumption view formalisms sets f knowledge bases kb f associated two valued semantics  however  language
representation model universal sense another way expressing languages sets words         using n element vocabulary    a               binary word w   x  x  xn length n encoded set mw    ai   xi       
example  using vocabulary a     a    a    a     binary word     length   corresponds set m       a    a     consequently  set ln words length n
represented set xln  an subsets   xln    mw   w ln   
example vocabulary  word set l                    represented model
set xl      a    a       a    a       a    a      conversely  sequence  xn  n  sets

xn  an uniquely determines language l   n  ln         n n 
ln    wm   xn   wm   x  x  xn             n   xi    
ai xi     ai
    paper use language refer object level
languages formalism refers meta level languages  propositional logic 
argumentation frameworks  abstract dialectical frameworks  logic programs 
formally  syntax adfs defined via boolean functions  however  interested representations adfs  fix representation adfs via fixing
   

fiexpressiveness two valued semantics adfs

representation boolean functions  choose use  unrestricted  propositional formulas  customary literature  brewka   woltran        brewka et al  
      polberg et al         polberg        gaggl   strass        linsbichler        strass  
wallner        puhrer        gaggl  rudolph    strass         exceptions custom
works brewka et al          use boolean circuits  one  strass 
      used characteristic models  that is  used representation equivalent
representing formulas disjunctive normal form   subclass bipolar adfs 
yet uniform representation exists  another question address paper 
propositional formulas vocabulary mean formulas boolean
basis         is  trees whose leaves  sinks  atoms logical constants
true   false   internal nodes either unary    binary      make
occasional use boolean circuits  trees replaced directed acyclic
graphs  particular  allow unbounded fan in  is  reusing sub circuits  usual 
depth formula  circuit  length longest path root leaf
 sink   figure   shows formula circuit examples depth   



p



















q

p

q

p

q

figure    representing  p q   q p  formula tree  left  circuit  right  

analysing expressive power representation size boolean circuits established sub field computational complexity  arora   barak         led
number language classes whose members recognised boolean circuits satisfying

certain restrictions  need class ac    contains languages l   n  ln
exist d  k n n n  exists boolean circuit cn
depth size nk models cn exactly express ln   
words  every language l ac  recognised family polynomial size boolean
circuits fixed maximal depth independent word length 
paper proceeds follows  first define notion expressiveness  and succinctness  formally introduce formalisms study  reviewing several
intertranslatability results languages  step wise obtain results lead
expressiveness hierarchy  times looking representational efficiency 
finally show allowing linearly expand vocabulary leads collapse
hierarchy  paper concludes discussion possible future work 

   precise  n n  models cn exactly xln   turn expresses ln  

   

fistrass

   background
presume finite set atoms  statements  arguments   vocabulary  knowledge
representation formalism interpreted set f   two valued  semantics

f mapping   f    assigns sets two valued models knowledge bases
kb f   so implicit    strictly speaking  two valued interpretation mapping
set atoms two truth values true false  technical ease
represent two valued interpretations sets containing atoms true  below 
write  f      kb    kb f   intuitively   f  set interpretation sets
formalism f express  knowledge base whatsoever  example  f   pl

propositional logic   mod usual model semantics   pl       since
obviously set models realisable propositional logic   leads us compare
different pairs languages semantics respect semantics range models 
concept formalism concentrates semantics decidedly remains abstract 
first define expressiveness relation among formalisms 
definition    let finite vocabulary  f    f  formalisms interpreted


    f         f     two valued semantics  define
f   e f  

iff

   f       f   

intuitively  formalism f  semantics   least expressive formalism f 
semantics     model sets f  express   contained
f  produce      if semantics clear context
omit them  holds particular argumentation frameworks propositional logic 
look single semantics   usual 
f   e f  iff f  e f  f   e f   
f 
 e f  iff f  e f  f  e f   
relation e reflexive transitive definition  necessarily antisymmetric 
is  might different formalisms f     f  equally expressive  f 
 e f   
next introduce succinctness relation defined gogic et al         
definition    let finite vocabulary  let f  f  formalisms interpreted a  size measures kk  kk    two valued semantics      
respectively  define f   f   k n kb  f 
   kb       f       f     kb  f     kb         kb    kkb  k  kkb  kk   
intuitively  f   f   means f    least succinct f     
put another way  f   f   hold  knowledge base f  equivalent
counterpart f  must equivalent counterpart polynomially larger 
note succinctness talks model sets express 
meaningful comparing languages equally expressive  is  whenever
   set x  a simply define x  
mod  x     x 

w

x

   

 

v





v

aa m

clearly

fiexpressiveness two valued semantics adfs

   f         f     usual  define f   s f  iff f  f  f   s f    f 
 s f 
iff f  f  f  f    relation reflexive  necessarily antisymmetric
transitive 
final general definition formalisms polynomially expressing languages 
here  already make use previously introduced bijection interpretations
binary words use term languages synonymously refer both 

definition    formalism f polynomially express language l   n  ln


semantics   f    k n positive n n
knowledge base kbn f formalism  kbn     ln kkbn k o nk   
next introduce specific object level languages use  first all 
language parity contains odd element subsets vocabulary  formally 
   a              n  
parityn    m   n    m      m     

explained before  parity   nn n  parityn   textbook result parity
expressible polynomial size propositional formulas  jukna         example 
define parity
 a      a  n   set
 
parity
 a                 parity
 a              parity
 an                
n
n
n
 parity
 a              parity
 an                
n
n


n   n  n   n     this construction yields formula logarithmic depth
therefore polynomial size   textbook result  although nearly easy
see  parity cannot expressed depth bounded polynomial size circuits  is 
parity
  ac   jukna        
another important class  threshold languages defined n  k n n  
k n 
thresholdn k    m   k  m   
is  thresholdn k contains
interpretations n atoms least k atoms
true  special case k   n  leads majority languages 
majorityn   thresholdn d n e
 

contain interpretations least half atoms vocabulary true 
next introduce particular knowledge representation languages study
paper  make use vocabulary a  results paper considered
parametric given vocabulary 
    logic programs
vocabulary define    not   a  accordingly set literals
  a  normal logic program rule form b
b   set b called body rule  abbreviate b     b
   

fistrass

b    a   b   logic program  lp  p set logic program rules
a  interpretation satisfies body b rule b p iff b  
b     supported model p iff    a   b p  satisfies b  
logic program p denote set supported models su p    intuition
behind semantics atoms true model
kind support 
however  support might cyclic self support  instance  logic program
 a  a   two supported models   a   latter undesired many
application domains  alternative  gelfond lifschitz        proposed stable
model semantics  allow self support  set stable model p iff
 least supported model p   p obtained p     eliminating
rule whose body contains literal       deleting literals
form bodies remaining rules  gelfond   lifschitz        
write st p   set stable models p   follows definition st p  
 antichain  m     m  st p
p  m    m    size measure define
ka bk    b      rules kp k   rp krk programs 
example  consider vocabulary    a  b  c  logic program
p    a  b    b  a    c  not a    find su p       c     a  b   st p       c   
    argumentation frameworks
dung        introduced argumentation frameworks pairs f    a  r  set
 abstract  arguments r relation attack arguments 
purpose semantics argumentation frameworks determine sets arguments  called
extensions  acceptable according various standards  given extension
a  arguments considered accepted  attacked
argument considered rejected  others neither  status
undecided  interested so called stable extensions  sets arguments
attack attack arguments set  stable extensions 
argument either accepted rejected definition  thus semantics two valued 
formally  set arguments conflict free iff a  b  a  b  r 
set stable extension  a  r  iff conflict free  
argument b  b  a  r  af f   denote set stable extensions
st f    again  follows definition stable extension set st f   always
 antichain  size argumentation framework f    a  r  kf k    a     r  
example  af f     a  b  c      a  b    b  a    b  c    visualised using
c set stable extensions st f       a  c     b   
b
directed graph
    abstract dialectical frameworks
abstract dialectical framework tuple    a  l  c  set statements
 representing positions one take take debate   l set links
 representing dependencies positions   c    ca  aa collection total
functions ca    par  a   t  f    one statement a  function ca called
acceptance condition expresses whether accepted  given acceptance
   

fiexpressiveness two valued semantics adfs

status parents par  a   paper  represent ca propositional formula
par  a   mentioned earlier  propositional formulas built using negation  
conjunction disjunction   connectives material implication   logical equivalence
exclusive disjunction   regarded abbreviations  specify acceptance
condition  then  take ca  m par  a     hold iff model       
brewka woltran        introduced useful subclass adfs  adf    a  l  c 
bipolar iff links l supporting attacking  or both   link  b  a  l supporting iff par  a   ca  m     implies ca  m  b     t 
symmetrically  link  b  a  l attacking iff par  a  
ca  m  b     implies ca  m     t  link  b  a  supporting attacking
b influence a  link redundant  but violate bipolarity  
sometimes use circumstance searching adfs  simply assume
l   a  links actually needed expressed acceptance conditions make redundant 
numerous semantics adfs  interested two them 
 supported  models stable models  set model iff
find iff ca  m     t  definition stable models inspired logic
programming slightly complicated  brewka et al          define operator by 
 x       ac x     re x     x  a 
ac x       a   z   x z   ca  z    t 
re x       a   z   x z   ca  z    f  
intuition behind operator follows  pair  x    represents partial interpretation set statements x accepted  true   rejected
 false      x   neither  operator checks statement
whether total interpretations possibly arise  x    agree truth
value acceptance condition a  is  accepted matter
statements    x   interpreted  acc x     set rej  x    defined
symmetrically  pair  acc x     rej  x     constitutes refinement  x    
a  reduced adf dm    m  lm   c   defined lm   l
setting
     is  replacing b
  false
   b    b
acceptance formula a  model stable model iff least fixpoint
operator dm given  m     usual  su d  st d  denote respective model
sets  adf models
p related  adf stable models cannot  size adf
given kdk   aa ka k  size kk formula number
nodes 
example adf d  consider vocabulary    a  b  c  acceptance formulas
  c  b   c  c   b  single supported model  su d      a  b  c   
find st d    since atoms model support circularly 
    translations formalisms
review known translations mentioned formalisms 
   operator closely related ultimate approximation operators denecker  marek 
truszczynski         observed earlier  strass        

   

fistrass

      afs badfs
brewka woltran        showed translate afs adfs  af fv   a  r  
define adf associated f df    a  r  c  c    a  aa    b a r b
a  clearly  resulting adf bipolar  parents always attacking  brewka
woltran proved translation faithful af stable extension adf
model semantics  proposition     brewka et al         later proved af
stable extension adf stable model semantics  theorem     easy see
translation computed polynomial time induces linear blowup 
      adfs pl
brewka woltran        showed adfs supported model semantics
faithfully translated propositional logic  acceptance conditions statements represented propositional formulas   supported models
adf given classical propositional models formula set
   a   a  
      afs pl
combination  previous two translations yield

n polynomial
v
fifaithfulotranslation

chain afs propositional logic   a r   
 b a r b  
      adfs lps
earlier work  strass         showed adfs faithfully translated normal
logic programs  adf    a  l  c   standard lp
pd    a  m  par  a         a  ca  m     t 
follows lemma      strass        translation preserves supported
model semantics  translation size preserving acceptance condition representation strass        via characteristic models  representing acceptance conditions
via propositional formulas  cannot guaranteed show later  
      afs lps
translation chain afs adfs lps compact  faithful af stable
semantics lp stable semantics  osorio  zepeda  nieves    cortes         af stable
semantics lp supported semantics  strass         size preserving since single
rule atom contains attackers once  p a r     a  not b    b  a  r    a  
   already complexity reasons  cannot expect translation faithful stable
semantics  indeed  adf     a      a  a      a   a   stable model  a 
standard logic program p  d     a  a     not a   stable model  however  holds
st p  d   st d   denecker et al         strass        

   

fiexpressiveness two valued semantics adfs

      lps pl
well known logic programs supported model semantics translated
propositional logic  clark         logic program p becomes propositional theory p  


 
 
 

p    a   a   
b
b a 
abp

bb  

bb

stable model semantics  additional formulas added  extended
translation works  lin   zhao        
      lps adfs
clark completion normal logic program directly yields equivalent adf
signature  brewka   woltran         clearly translation computable
polynomial time blowup  with respect original logic program 
linear  resulting translation faithful supported model semantics  follows
lemma      strass        
    representing bipolar boolean functions
bipolarity hitherto predominantly defined used context
adfs  brewka   woltran         easy define concept boolean functions
general  let set atoms f    a  t  f   boolean function  atom
supporting iff a  f  m     implies f  m  a     t  write sup f   
atom attacking iff a  f  m     f implies f  m  a     f  
write att f    boolean function f    a  t  f   semantically bipolar iff
supporting attacking both  throughout paper  sometimes take boolean
function given interpretation set say set bipolar 
define bipolar propositional formulas representing bipolar adfs 
important study  since  for three valued semantics   bipolarity
key badfs low complexity comparison general adfs  strass   wallner        
now  usually assumed specify bipolar adf  addition statements 
links acceptance conditions  user specifies link whether supporting
attacking  strass   wallner         introduce arguably simpler way 
support attack represented syntax propositional formula encoding
acceptance function 
formally  polarity atom formula determined number
negations path root formula tree atom  polarity positive
number even negative number odd 
definition    propositional formula syntactically bipolar
atom occurs positively negatively  
recall use formulas basis        thus hidden
negations  e g  material implication  formulas negation normal form  that is 
negation applied atomic formulas   polarities atoms read
formula directly 
   

fistrass

address question represent bipolar boolean functions  clearly
boolean functions represented propositional formulas  modify construction
later thus reproduce here  boolean function f    a  t  f    associated
formula
 
 
 

   
 

f  


a f  m   t

aa m

is  exactly one model   f enumerates models 
particular  bipolar boolean functions represented propositional formulas well  however  guarantees us existence representations
gives us way actually obtain them  first fundamental result shows
construct syntactically bipolar propositional formula given semantically bipolar
boolean function  converse straightforward  thus two notions bipolarity
closely related  formula   associated boolean function f returns
gets input model  
theorem    let set atoms 
   syntactically bipolar formula a  boolean function f semantically
bipolar 
   semantically bipolar boolean function f    a  t  f    syntactically bipolar
formula f   f given
f  

 



 

a 
f  m   t

 
am 
aatt f
 
 



 



   

aa m 
asup f
 
 

proof 
   obvious  every atom occurring positively supporting  every atom occurring negatively attacking 
   let f    a  t  f   semantically bipolar  note first     
     easy see f syntactically bipolar  since f
semantically bipolar  is      attacking supporting 
occurs negatively f       supporting attacking  occurs
positively f       supporting attacking  occur f  
remains show   f   show    f f  
   f f   let v    t  f   v f     t 
f  m     v m     t   clearly v   vm       get v m    
thus v f     t 
   f f   model v f   f  m    
v m     t  show model f model f   show
f  m     t  model v model f   let  a    n 
contains exactly n literals  corresponding
k n   k n contains exactly n k literals  two
   

fiexpressiveness two valued semantics adfs

interpretations v     t  f   v     t  f    define difference
 v    v       a   v   a     v   a     note  a    n always
  v    v     n   use induction k show following 
f  m     t  v    t  f   v m       v  vm      k
find v f     t  covers models v f  since   v  vm     a  
thus establishes claim 
k       v  vm     implies v   vm whence v f     vm  f     vm  m    
definition f  
k
k      let f  m     t  v    t  f   v m    
  v  vm      k      since k           v  vm    is 
v a     vm  a  
 a  supporting attacking  necessarily v a    t   if v a    f  
vm  a     v a  implies vm  a    t  is  whence  m     
v m     f   contradiction   define interpretation w    t  f  
w a    f w c    v c  c    a   clearly  v  w     a 
  w  vm      k  hence induction hypothesis applies w
w f     t  w a    f   v a    w f     t  since supporting  v f     t 
 b  attacking supporting  symmetric opposite case above 
 c  supporting attacking  define interpretation w    t  f  
w a    vm  a  w c    v c  c    a   follows
  w  vm      k  whence induction hypothesis applies w
w f     t  since supporting attacking  thus redundant  
get v f     w f     t 

result paves way analysing succinctness bipolar adfs  since
quite natural way representing them 

   relative expressiveness
analyse compare relative expressiveness argumentation frameworks
 afs    bipolar  abstract dialectical frameworks   b adfs   normal logic programs  lps 
propositional logic  pl   first look different families semantics supported
stable models isolation afterwards combine results two semantics 
formalisms f  adf  lp  supported stable semantics 
indicate semantics via superscript definition    afs consider
stable semantics   to date  semantics afs interpretations
guaranteed map arguments either true  accepted  false  rejected  i e  attacked
accepted argument   propositional logic pl consider usual model semantics 
syntactic translations reviewed previous section  currently
following expressiveness relationships  supported semantics 
af e badfsu e adfsu
 e lpsu e pl
stable semantics 
   

fistrass

af e lpst  e pl af e badfst e adfst  e pl
note lpst  e pl adfst  e pl hold since sets stable models antichain
property  contrast model sets propositional logic 
succinctness relation 
af badfsu adfsu pl lpsu adfsu
    supported semantics
depicted above  know expressiveness afs propositional logic
decrease  however  yet clear relationships strict  follows
show two strict  working way top down least
expressive 
      adf vs  pl
first show adfs realise set models showing given propositional
formula used construct equivalent adf linear size  
theorem    pl e adfsu pl adfsu  
proof  let propositional formula vocabulary a  define adf
setting  a 
     a    a  
thus ka k o kk   whence kd k o  a  kk   remains tovshow su d     mod    
recall adf a  su d    mod  d     aa  a    applying
definition yields
v
  aa  a  a   
a  formula  a  a   vis equivalent    the proof case
distinction a   thus equivalent aa   is    follows
su d     mod  d     mod    

example  consider vocabulary    a  b  propositional formula   b 
canonical construction yields adf acceptance formulas    a b 
b   b  a b   have 
   a b     a  a b     a b  a   a b  b
intuitively    b expresses cannot false  true b true 
symmetrical argument  acceptance formula b equivalent b a  readily
checked su d       a  b   desired  since know section      
converse translation possible  adfsu pl   get following 
corollary    pl
 s adfsu
   consider vocabulary part input  size increase quadratic 

   

fiexpressiveness two valued semantics adfs

acceptance conditions written propositional formulas  construction
realise x  a proof theorem   defines space efficient equivalent
 
 

 

x am

a m x a
 

 

acceptance formula a  footnote   
      adf vs  lp
since adfs supported semantics faithfully translated logic programs 
likewise translated propositional logic  following 
corollary    adfsu
 e lpsu
 e pl
however  extend succinctness relation  logic programs stipulate
particular syntactic form essentially fixed depth circuit  specifically 
easy see language polynomially expressible normal logic programs
supported semantics ac    stable semantics so called canonical logic
programs  recently shown shen zhao         proposition      
case interested  supported semantics  works similarly  still present
proof completeness  main technical result towards proving lemma showing
turn logic program equivalent boolean circuit fixed depth 
lemma    every normal logic program p   exists circuit cp basis
       that 
   cp accepts supported models p  
   size cp linear size p  
   cp depth   
proof  let    a              vocabulary p   clark completion p  
 ai   ai a 
v dnfs literals a  clearly circuit p
must compute cp   ai  ai   ai replaced  ai   ai  
cnf literals a  construction depicted follows 
inner layers shown one only  dotted lines represent potential edges 

ai

   




   



a 

a 

   







ai
   



ai

ai
   

   

   







fistrass

    follows since su p     mod  p   cp accepts models p  
     p contains    p   rules  kp k total number inner gates
bounded n  m      n   kp k           clear 

statement lemma   actually much stronger gives constant upper
bound resulting circuit depth arbitrarily sized logic programs  readily follows
set polynomially logic program expressible languages subset languages
expressible alternating boolean circuits unbounded fan in constant depth 
proposition    l polynomially expressible normal logic programs supported
semantics  l ac   
follows immediately normal logic programs cannot polynomially express
language parity   supported semantics counterpart theorem      shen
  zhao        
corollary    parity polynomial size normal logic program representation 
proof  proposition   parity
  ac   jukna        



follows propositional logic strictly succinct normal logic programs
supported semantics 
corollary    pl  s lpsu thus lpsu  s pl 
considerations since theorem    follows small conjunctive
normal form  a conjunction clauses  disjunctive normal form  disjunction monomials  representation  small normal logic program representation
mod    
      adf vs  badf
quite obvious canonical adf constructed theorem   bipolar  since
well every atom mentioned occurs positively negatively  
raises question whether construction adapted bipolar adfs 
turns subclass bipolar adfs strictly less expressive  towards
proof result start new concept  conjugate model set
respect atom  concept used characterise adf realisability
precisely captures if and only if part adfs supported model semantics 
translation adf propositional logic v
 cf  section        see result
basically conjunction equivalences    aa  a    conjunction part
captured set intersection  conjugate capture equivalence part 
definition    let vocabulary  x  a a  a conjugate x set
hai x     m   x     m  
  x 
  m 
   logic programs supported models universally expressive  express parity 
polynomial size 

   

fiexpressiveness two valued semantics adfs

alternatively  could write hai x     m   x    intuitively  hai x 
contains interpretations containment coincides exactly containment x  formulated terms propositional formulas  x model set
formula a  hai x  model set formula   note vocabulary
implicit conjugate function 
example    consider vocabulary a     a  b   functions hai   hbi   operate

set      interpretation sets a  shown table   


b
b
b
ab

b

b
a b
ab
ab
b
ab
ba
 

hai  

b
b
b
ab
 
ab

a b
b
b
ba
b
ab
ab


hbi  
b
b
b
b
ba
ab
 
a b



ab
b
ab
ab
b

table    conjugation functions a     a  b   interpretation sets represented using
formulas a    connective   denotes exclusive disjunction xor 
two valued adf semantics  conjugation function plays essential semantical
role  since provides bridge models acceptance functions models
adf  interesting itself  first show properties conjugation
function associated atom  since used proof later on  first
all  involution  is  inverse  and thus particular bijection   next 
compatible complement operation  logical negation formula level  
finally  preserves evenness cardinality input set 
proposition    let vocabulary  x  a a 
   hai hai x     x 

 involution 

    a   hai x    hai  a   x  


 compatible negation 

    x  even iff  hai x   even 

 preserves evenness 

proof  let  a    n  x  a a 
   

fistrass

   let a 
hai hai x   iff hai x 
iff  m x  
iff x  a  
iff x
   denote
s     m   x   
s      m   x 
  m 
s 
   m  
  x   
 
s 
  x 
  m 
 
     m  
observe
 a   s    s     s 
    s 
 
 
x   s    s  
hai x    s    s 
 
 
  denotes disjoint union 

 a   hai x     a   s    s 
 
 
  s     s 
 
   m   x 
       m  
  x   






  afim
      x 
     a   x 

  hai  a   x
   show  x     hai x   even  firstly 
s     s 
       a  a 
 
     m  



n    thus

whence fis     fis 
 
    





 x     hai x      s      fis      s      fis 
 
 




     s      fis     fis 
 
 
     s       n 
even 



current purpose characterising expressiveness bipolar adfs 
use concept conjugation make adf realisability model semantics slightly
accessible  show adf realisation model set x n element
vocabulary equivalently characterised n tuple  y            yn   supersets x
whose intersection exactly x  crux proof result acceptance
conditions realising adf yi related conjugation function 
   

fiexpressiveness two valued semantics adfs

proposition     let    a              vocabulary x  a set interpretations  denote adf sequence              n   acceptance formulas  for
            n   formula acceptance formula ai    define
cx     mod               mod  n      su             n     x 

 
 
 
n

 

yx    y            yn   y            yn  a  
yi   x

i  

sets cx yx one to one correspondence  particular  cx      yx   
proof  provide bijection cx yx   consider function
n
n
 b            bn      ha  i b              han i bn   
  
f     
involution proposition    using results section        get
 mod               mod  n    cx iff su             n     x


 
iff mod
 ai     x
 in

iff

 

mod  ai     x

 in

iff

 

hai i mod  i      x

 in

iff  ha  i mod                 han i mod  n     yx
iff f  mod               mod  n    yx
thus f  cx     yx whence f  yx     f  f  cx      cx f  cx   cx yx bijective 



one to one correspondence important since later analyse precise
number realisations given model sets  furthermore  result shows role
conjugation function characterising two valued model realisability general adfs 
adapt characterisation result case bipolar adfs  precisely 
give several necessary sufficient conditions given model set bipolarly realisable 
characterisation hand  later show specific interpretation set fails
necessary conditions thus cannot model set badf 
below  fiwe denote

set supersets set x interpretation sets x    a x  
proposition     let    a              vocabulary x  a set interpretations  following equivalent 
   x bipolarly realisable 
   exist y            yn x that 

 a    ni   yi     x 
   

fistrass

 b    n  set hai i yi   bipolar 
   exist y            yn x

 a    ni   yi     x 
 b    i  j n  least one  
a   m yi ai    m  aj   yi ai  aj    
n a   n yi   ai n    n  aj   yi   ai n  aj    
proof           x bipolarly realisable  exists bipolar adf    a  l  c 
su d    x  particular  exist bipolar boolean functions c            cn
x   n find ai iff ci  m     t 
  n define yt
  hai i ci    assumption  hai i yi     hai i hai i ci      ci bipolar  furthermore   ni   yi     x follows above 
         let             n  assume hai i yi   bipolar  means
aj a  find aj supporting attacking  or both  hai i yi    aj
supporting haj i yi   iff find 
hai i yi    aj   hai i yi     is 
 m yi ai    m  aj   yi ai  aj   
similarly  aj attacking hai i yi   iff n find 
n
  hai i yi   n  aj  
  hai i yi     is 
 n yi ai n    n  aj   yi ai n  aj   
thus aj a  find least one following 
a   m yi ai    m  aj   yi ai  aj    
n a   n yi   ai n    n  aj   yi   ai n  aj    
         construct adf    a  l  c  follows              n  define ci   hai i yi   finally set l   a  ci bipolar equivalences
established previous proof item  su d 
  x follows fact
hai i ci     hai i hai i yi      yi presumption   ni   yi     x 


apply characterisation result show interpretation set
three atoms cannot realised bipolar adfs model semantics 
smallest example terms number atoms  actually  one two smallest
examples  interpretation sets binary vocabulary bipolarly realisable 
proposition     vocabulary a               bipolar adf realises
x   even                                 
   

fiexpressiveness two valued semantics adfs

proof  assume contrary x bipolarly realisable  exist y    y    y  x

proposition           x                  candidates yi   is 
every yi must form x   z
z                                  a   x
eleven sixteen model set candidates yi   set hii yi  
bipolar  show model set hii yi   bipolar  provide statement j a 
neither supporting attacking  say statement dependent 
   y    x  get h i y                                     bipolar since
statement   dependent    supporting      h i y    would imply
       h i y       attacking 
  h i y    would imply    
  h i y    
remaining cases  justifications specific statement dependent
equally easy read model set  brevity indicate statements 
   y    x        get h i y                                          
bipolar since statement   dependent 
   y    x        get h i y                               bipolar since
statement   dependent 
   case y    x       symmetric previous one  get model set
h i y                               bipolar since statement   dependent 
   y    x              get h i y                                                
bipolar since statement   dependent 
   y    x              get h i y                                    
bipolar since statement   dependent 
   case y    x             symmetric previous one 
   y    x              get h i y                         bipolar since
statement   dependent 
   y    x                    get h i y                                                      
bipolar since statement   dependent 
    y    x                    get h i y                                          
bipolar since statement   dependent 
    y    x                   symmetric previous case 
remains set c five candidates  due symmetry i  
c    x                      
x                            
x                            
x                            
x                                 
   

fistrass

basically  candidates least three four interpretations
                                contained addition already x  clearly
assumption yi realise x
    y    y 
c 
t 
yi     thus
i   yi   x  however  x    
contradiction  thus yi exist x bipolarly realisable 

interpretation set a  bipolarly realisable  found
complement even  above  parity language three atoms 
proposition     vocabulary a               bipolar adf realises
parity                                  
together straightforward statement fact even  realised
non bipolar adf  proposition    leads next result 
theorem     badfsu  e adfsu
proof  model set even  proposition    realisable model semantics adf
deven  acceptance conditions
            

            

           

however  bipolar adf realising even    witnessed proposition    



another consequence characterisation two valued model realisability proposition    get precise number distinct realisations given model set 
significant illustrates rather intricate difficulty underlying bipolar non realisability  cannot necessarily use model set even  determine
single reason bipolar non realisability  is  single link  b  a  neither supporting attacking realisations  rather  culprit s  might different
realisation  show bipolar non realisability  prove realisations 
necessarily exists reason non bipolarity  number different adf
realisations given model set x considerable  

proposition

    let vocabulary  a    n  x   interpretation set
fi    x   m  number distinct adfs su d    x

r n  m      n   m
proof  according proposition
   t realisation
tufi
x characterised
n
n tuples 
ple  y            yn   x x   ni   yi   since fix    m     m  t
however ttowards r n  m   wrongly counts tuples  y            yn     ni   yi     x 
is     ni   yi     x       at least once   remains subtract
            n  
n them 
overestimate number tuples  y            yn   x    ni   yi     x 
expression

n

q n  m  i   
 mi
   

   counting adfs a  take account different link relations  take l  
count different acceptance functions  redundant links modelled 

   

fiexpressiveness two valued semantics adfs


seen follows  let  a   x fixed i element set   intuitively  interpretation set x contains
interpretations many  
mi sets 
exactly


n
i  fii    mi   thus  mi possible ways choose n
elements  the y            yn     matter yj chosen  intersection
contains thus least elements many  however  sets least
    elements many counted twice subtracted  subtract
q n  m        counted sets least     elements many
add q n  m       
inclusion exclusion principle  number
n etc  hence

tuples  y            yn   x ni   yi   x given
r n  m    q n  m     q n  m       q n  m           q n  m  m 

x
 
   i q n  m  i 
i  

x


n

 
   
 mi

i  



x
 
  n  mi    i



 by     above 
 reordering factors 

i  
n

       m

 binomial theorem 

main contributing factor number interpretations excluded
desired model set x  proposition     instance                     
adfs model set even    according theorem     none bipolar  obvin
ously  maximal number realisations achieved x   whence r n   n       n      
hand  model set x    a exactly one realisation  r n          note
number  syntactically distinct  realisations universally expressive
formalisms  logic programs propositional logic  unbounded general since
add arbitrary number tautologies 
finally show reduction problem bipolar realisability propositional
satisfiability  approaches problem another angle  a possible implementation
deciding bipolar realisability using sat solver   provides proof theorem  
strass      b   contained work 
given vocabulary set x  a set interpretations  aim
construct propositional formula x satisfiable x bipolarly
realisable  propositional signature use following  a 
propositional variable pm
expresses whether ca  m     t  allows
encode possible acceptance conditions statements a  enforce bipolarity 
use additional variables model supporting attacking links  a  b a 
a b
variable pa b
sup saying supports b  variable patt saying attacks b 
vocabulary x given

n

a b
a b
p   pm
 
p
 
p


a 


a 
b




sup att
guarantee desired set models  constrain acceptance conditions dictated
x  desired set statement a  containment must correspond
   

fistrass

exactly whether ca  m     t  encoded
x   conversely  undesired set
 
statement a  must correspondence 
x expresses 
enforce bipolarity  state link must supporting attacking  model
meaning support attack  encode ground instances definitions 
definition    let vocabulary x  a set interpretations  define
following propositional formulas 

 
badf
 
x
x x bipolar


 
 
 


pm

pm


x  
x



aa m




 

 

x  

 


a m x
 

bipolar  

 

 

pm





pm


aa m



a b
a b
a b
pa b
sup patt sup att



a ba

a b
sup

  pa b
sup

a b
att

pa b
att

 



 a  b a 



 a  b a 

 a 

pm
b pb



 



 

 a 

pb

pm
b



corresponding result shows reduction correct 
theorem     let vocabulary x  a set interpretations  x bipolarly
realisable badf
satisfiable 
x
proof  if  let p model x   a  define acceptance condition follows  a  set ca  m     iff pm
i  easy see bipolar
guarantees acceptance conditions bipolar  adf given
su    a  a  c   remains show model su
dx
x
x 
su   consider a 
if  let x  show model dx

     since model
x   pa thus definition
ca  m     t 
  thus definition
       since model
x   pa
ca  m     f  
 
if  let
  x  since model
x  
ca  m     f
  ca  m     t  case  model
su  
dx

if  let bipolar adf su d    x  use define model x  
first  a  set pm
iff ca  m     t  since bipolar  link
supporting attacking a  b find valuation pa b
sup
pa b
 

remains

show




model


 
x
att
   

fiexpressiveness two valued semantics adfs

   model
x   since realises x  x model thus
ca  m     iff  
 
   model
  x model
x   since realises x 
d  thus   witnessing model
d      ca  m     f      
  ca  m     t 

   model bipolar   straightforward since bipolar assumption 



remarkably  decision procedure give answer  case
positive answer read badf realisation satisfying evaluation
constructed formula  illustrate construction example seen earlier 
example    consider a              model set even                                 
construction theorem    yields formulas 
   





even    p  p  p 
     

p 

     

p 

p 
p 

     

     

p 

 

even     p 
     



 p 

     



 p 

p 

     

p 

     

p 

p 

     

   

p   

   

p 

   

   

p 

p   

   

p 

   

p   

       

 p 

   

   

       

p 

       

p 

 

remaining formulas bipolarity independent even    show
here  implemented translation proof theorem    used solver
clasp  gebser  kaminski  kaufmann  ostrowski  schaub    schneider        verify
even  unsatisfiable 
      badf vs  lp
earlier  used language parity show propositional logic  and thus
pl
 s adfsu general adfs are  exponentially succinct normal logic programs
 under supported models   however  bipolar adfs  proposition    badf
a              model set su d    parity                                   is 
badfs cannot even express parity  fortunately  majority language trick
case 
theorem     badfsu  s lpsu
proof  show language majority polynomially expressed badfsu  
lpsu   latter fact follows majority
  ac   jukna        proposition    show first part constructing series badfs dn    a             
 n n  n    su dn     majorityn   use results  friedman        boppana         show positive n n k n  language thresholdn k
negation free propositional formulas threshold
polynomial size s  use
n k


    
bound boppana  k n log n   define d  a       n   set k   n 
  n 
ai   ai threshold
 a            ai    ai              
n  k
   

fistrass

intuitively  formula ai checks whether remaining variables could achieve majority
without ai   so  ai set arbitrarily  otherwise  ai must set true  clearly
boolean function computed ai bipolar  since ai supporting parents
attacking  size dn   observe


kdn k n threshold
n  k

whence overall size polynomial  remains show su dn     majorityn  
  let majorityn   show su dn    is  iff   
    immediate      let aj
 
j           n   show     aj   since majorityn    m    
k   n  n   thresholdn  k   is 
   threshold
 a            aj    aj              
n  k
together     aj   follows     aj  

  let
  majorityn    m         n    k  particular 
aj       k implies n thresholdn  k
 a            aj    aj               whence follows
 n        m    thus     threshold
n  k
   aj   together     aj conclude
  su dn   

since every badf adf size  get 
corollary     adfsu  s lpsu
combination translation logic programs adfs  implying relation
lpsu adfsu    means adfs strictly succinct logic programs 
corollary     lpsu  s adfsu
      badf vs  af
comparably easy show badf models strictly expressive afs 
since sets supported models bipolar adfs antichain property 
proposition     af  e badfsu
proof  consider vocabulary    a  badf    a    a  a      a      a 
straightforward check model set su d        a    since model sets afs
stable extension semantics satisfy antichain property  equivalent af
a 

yields following overall relationships 
af  e badfsu  e adfsu
 e lpsu
 e pl
concise overview relative succinctness  present results open problems
glance table   below  
   remark three open problems table   really two  easy show adfs
propositional logic behave equivalently relation bipolar adfs  since equally expressive
equally succinct  is  holds adfsu badfsu pl badfsu  

   

fiexpressiveness two valued semantics adfs

su

badf
adfsu
lpsu
pl

badfsu
 
 
 
 

adfsu

 
 s

 s

lpsu
 s
 s
 
 s

pl


 s
 s
 

table    relative succinctness results  bipolar  adfs model semantics  normal
logic programs supported semantics  classical propositional logic  entry
row f  column f  means f  f   
    stable semantics
before  recall current state knowledge 
af e badfst e adfst  e pl af e lpst  e pl
first show badfs strictly expressive afs 
proposition     af  e badfst
proof  consider set x      a  b     a  c     b  c   desired models  dunne et al        
proved x  realisable stable af semantics  however  model set x 
realisable badf dx  stable semantics 
  b c 

b   c 

c   b

let us exemplarily show    a  b  stable model  the cases completely
symmetric   reduct dm characterised two acceptance formulas   b
b     easily find dm         m      dm  m    

intuitively  argument af non realisability x  follows  since b occur
extension together  attack them  holds
pairs a  c b  c  set  a  b  c  conflict free thus must stable
extension containing three arguments  allowed x    reason afs
restriction individual attack  set attack  also called joint collective attack  suffices
realise x  seen above 
construction used proof realize x  comes work
eiter  fink  puhrer  tompits  woltran        logic programming 
generalised realise non empty model set satisfying antichain property 
st    a  l  c  c
definition    let x  a   define following badf dx

given


 
 

 
b
x am

ba m

thus l     b  a    x  m  b     
   

fistrass

next result shows construction indeed works 
st     x 
theorem     let x  
  x  a  antichain  find st dx

proof  let a 
st   st d st    use case distinction 
  let
  x  show
  su dx
x

   n x   n   n     consider
acceptance
v formula   since n n x  formula disjunct
a n   ba n b  n implies   n   model
st   
a n   thus model although
    hence
  su dx
   n x    n   x    implies      let  

v n x n   acceptance formula contains disjunct
a n   ba n b  assumption  n x bn   n  
clearly bn   n bn evaluated true   hence n x
n   disjunct a n evaluated false   thus false
st   

  su dx
st    is  a  find
  let x  first show su dx
iff model  
st
   let  
v construction  dx contains disjunct
form a m   ba m b  according interpretation   b  
false thus a m true whence true 

   let   consider acceptance formula   assume contrary
model v
  n x n
model a n   ba n b  is    n     hence n   and 
since n     even   n   whence x  antichain  contradiction 
thus model  
st respect   there  contains
consider reduct dm dx


disjunct a m   a m  b    b
    b   replaced false 
        equivalent true  thus true
whence a m

st   
least fixpoint dm thus st dx


restriction non empty model sets immaterial relative expressiveness  since
use construction theorem   fact st d  su d  adf
realize empty model set  stable model semantics adfs logic programs
antichain property  get 
corollary     adfst e badfst lpst e badfst
leads following overall relationships 
af  e badfst
 e adfst
 e lpst  e pl
remark antichain property provides characterisation realisability
stable semantics  is  model set stable realisable iff  antichain 
   

fiexpressiveness two valued semantics adfs

    supported vs  stable semantics
put supported stable pictures together  proof theorem    
st antichain x  supported
read canonical realisation dx
st     st d st     x  observation 
stable semantics coincide  is  su dx
x
bipolar adfs supported semantics realize antichain  this 
proposition     badfst e badfsu
seen proposition     bipolar adfs supported model sets
antichains  get 
corollary     badfst  e badfsu
result allows us close last gap put together big picture relative
expressiveness figure   below 
adfsu
 e pl
 e lpsu
badfsu
badfst
 e lpst
 e adfst
af
figure    expressiveness hierarchy  expressiveness strictly increases bottom
top  f denotes formalism f semantics   su supported st
stable model semantics  formalisms among afs  argumentation frameworks   adfs
 abstract dialectical frameworks   badfs  bipolar adfs   lps  normal logic programs 
pl  propositional logic  

   allowing vocabulary expansion
here  considered compact realisations  introduce new vocabulary elements  section  allow introduction small number new
atoms arguments statements  precisely  small means number linear
size source knowledge base  representing model set wish realize
target language   purpose realisability  new vocabulary elements projected
resulting models 
turns out  adding additional arguments already makes afs universally expressive
 under projection   technically  show propositional formula
vocabulary a  exists af f expanded vocabulary
models stable extensions f correspond one to one  roughly 
possible since afs regarded syntactic variant classical propositional
logic connective logical  gabbay        brewka et al  
       using connective  negation expressed   disjunction
   

fistrass

                 equivalences used translate arbitrary propositional formulas  over       syntactical  fragment  guarantee
size increase linear  introduce names subformulas  tseitin 
       next definition combines ideas 
definition    let formula using     vocabulary a  define sets
r inductively follows 
a     a   

r   

   a  

r     a     

ap    p  ap   p

rp     p  ap     ap   p   p

   a  

r     a      r

   a       r     a       a      r r
   a    

r     a       a       a      r r

af associated given f    a   r   a      r   
argument a  unattacked thus part every stable extension  is true every
interpretation   argument attacks thus cannot part stable extension  is false every interpretation   mutually attacking arguments p ap
p serve guess valuation a  guarantee  and all 
valuations models lead stable extensions f   intuitively  must
attacked  candidate   arguments attacks boolean
connectives express usual truth theoretic semantics  first technical result
translation shows 
lemma     let formula vocabulary f associated af 
stable extension f     have 
iff
  m 
iff  
iff one  
iff neither  
proof 
definition  attacker argument form argument
  thus iff
  m 
attackers arguments   case above 
iff
    iff
    consequently  iff

 
  iff  
attacker argument   similarly previous cases 
show iff
 
    iff
   
combination  iff  
   

fiexpressiveness two valued semantics adfs

attackers arguments   directly follows
iff neither  

correspondences used show induction newly introduced
arguments capture semantics formulas encode  for subformulas   
lemma     let formula f associated af  stable extension
f   iff model  
proof  let stable extension f   use structural induction  
     trivial  a  since attackers 
    trivial 
  since set  a   conflict free 
  p a  trivial  p iff    p definition 
    iff iff
  iff     iff    iff     
    iff iff iff       iff   
iff     
    iff iff iff       iff   
iff     
    iff iff
 
  iff         iff   
iff     

lets us show main result section  namely af stable extension
semantics universally expressive projection 
theorem     let formula vocabulary f associated af 
   model   exists stable extension e f   e a 
   stable extension e f   set e model  
proof 

   let model   define set
e    a         

observe   e a  presumption  e  remains show e
stable extension  is  e conflict free attacks arguments b
  e 
e conflict free  assume contrary attack r    a  b  r
a  b e  definition  cases 
arbitrary b     definition e get     
contradiction 
r    p  ap   r    ap   p  p a  definition e get
   p    p  contradiction 
   

fistrass

r    a      definition e get        
contradiction 
r    a     r    a                  
contradiction 
r    a           whence             
contradiction 
r    a     r    a                  
     contradiction 
e attacks arguments e  let b  a  a      e argument 
definition  formula b         use structural
induction 
  e attacks definition 
       whence e attacks definition 
          whence e e 
case  e attacks definition 
       whence e attacks definition 
       whence e e 
case  e attacks definition 
   let e stable extension f   since e conflict free 
  e  since e stable 
e attacks   yields e  lemma     e model  

particular  f stable extension iff unsatisfiable  shows
construction definition   works intended  remains show number new
arguments linear formula size  even show total increase
size linear  thus number new arguments linear 
proposition     formula   find kf k o kk  
proof  first note
kf k   k a   r   a      r  k
   a      r   a      r  
   a          r      
   a      r      
use structural induction show formulas   find  a     kk
 r     kk  follows kf k         kk         kk     o kk  
    
 a        a               k k
 r                   k k
   

fiexpressiveness two valued semantics adfs

   
 a       a              kk
 r        a                 kk
  a 
 aa       a  aa              kak
 ra        a  aa     aa   a              kak
   
 a      a  a     a          kk         kk          kk
 r      r   a        r          kk         kk          kk
   
 a    a      a         a            a           
   kk           kk              kk     kk    
     kk   kk          k k
 r    r      r         r            r           
   kk           kk              kk     kk    
     kk   kk          kk
   
 a    a      a         kk     kk    
  kk     kk          kk   kk          kk
 r    r      r          kk       kk     
  kk     kk          kk   kk          kk



hence projection  af stable extension semantics realise much propositional logic can  results previous section  af e pl   means
allowing introduce linear number new vocabulary elements  that later projected
out   languages considered paper equally  universally  expressive 
however  must note equal expressiveness mean equal efficiency 
assume knowledge base size n leads search space size o  n   
linear increase knowledge base size  that is  n c n constant c  leads
polynomial increase search space size  that is  o  n   o  cn     o   n  c   
   

fistrass

   discussion
compared expressiveness abstract argumentation frameworks  abstract dialectical
frameworks  normal logic programs propositional logic  showed expressiveness
different semantics varies formalisms obtained neat expressiveness hierarchy  results inform us capabilities languages encode sets
two valued interpretations  help us decide languages use specific applications  furthermore  seen results sensitive vocabulary one
permitted use  hierarchy collapses allow introduce even linear
number new atoms 
concerning succinctness  shown adfs  under model semantics  exponentially succinct normal logic programs  under supported model semantics  
even bipolar adfs  under model semantics  although less expressive
succinctly express model sets equivalent normal logic programs  under supported model semantics  vocabulary must necessarily blow exponentially
size  open whether converse direction holds  is  whether badfs
exponentially succinct logic programs  if lpsu badfsu   two
mutually incomparable terms succinctness  if lpsu  s badfsu    stable semantics  relative succinctness logic programs badfs completely open  partly due
technical aspect two stable semantics conceptually different  adfs
fact employ ultimate stable models  denecker et al         brewka et al         strass
  wallner         furthermore  general adfs  computational complexity
model existence problem stable semantics higher normal logic programs   
succinctness comparison regard stable models would limited significance 
easy see afs somewhat special role representationally
succinct case  vocabulary   syntactically possibility specify knowledge base  an af  exponential size  since largest af size
k an    k   n   n  thus polynomially large  anything expressed af expressed reasonable space definition  however 
strength afs taken grain salt  since comparably inexpressive   in addition results presented  already seen simple
counting argument  even syntactically different afs semantically differ 
ent  which not   could express  n different model sets 
n
increasing n negligible relation    possible model sets  
original paper  gogic et al         used relaxed version succinctness 
allowed introduce linear number new variables  follows results
section   formalisms consider equally succinct relaxed
notion 
parts expressiveness results normal logic programs carry lp
classes  example  canonical logic programs provide limited form nesting allowing
literals form rule bodies  lifschitz et al          makes quite easy
see normal logic programs supported semantics translated equivalent
canonical logic programs  namely replacing positive body atom
    p
   hard adfs  strass   wallner        opposed np normal lps  bidoit   froidevaux 
      marek   truszczynski        

   

fiexpressiveness two valued semantics adfs

rule bodies  recently  shen zhao        showed canonical logic programs
propositional logic programs succinctly incomparable  under assumption     
provide interesting avenues succinctness studies  add succinctness
questions own  firstly comparing disjunctive logic programs stable
models general adfs stable models  since two equally complex
 p   complete  model existence problem  eiter   gottlob        brewka et al         
more  alternative proposals stable model semantics adfs 
 strass         definition      later called approximate stable models strass
  wallner         model existence np complete  strass   wallner       
thus potentially easier stable models brewka et al        
 called ultimate stable models strass   wallner        
grounded model semantics bogaerts  vennekens  denecker         definition       whose model existence problem p   complete  bogaerts et al  
      
f stable model semantics alviano faber         definition     
follows theorem     bogaerts et al         grounded models f stable
models coincide  still  demonstrably different approximate ultimate stable models adfs  alviano   faber           relative succinctness
comparison normal disjunctive logic programs unanalysed 
potential work  first all  nice characterisation bipolar
adf realisability still missing  unsure whether much improvement proposition    possible  incidentally  afs exact characterisation compact stable extension realisability constitutes major open problem  dunne et al         baumann et al  
       second  semantics abstract dialectical frameworks whose expressiveness could studied  dunne et al         dyrkolbotn        already analyse many
argumentation frameworks  work thus start
done remaining semantics  example admissible  complete preferred
semantics defined afs   b adfs lps  strass        brewka et al         
puhrer        already made huge step direction characterising realisability  third  formalisms abstract argumentation  brewka et al        
whose expressiveness large unexplored best knowledge  finally 
representational succinctness subclass bipolar adfs  using bipolar propositional
formulas represent them  supported model semantics mostly open  cf  table    
evidence pointing toward meaningful capabilities 

acknowledgements
paper combines  extends improves results previous work  strass       
    b      c   wish thank stefan woltran providing useful pointer related
 
    p   nc poly
  boolean circuit equivalent assumption np   p 
    terminology alviano faber         approximate stable models  strass        called
s stable models ultimate stable models  brewka et al         called b stable models 
shown different f stable models 

   

fistrass

work realisability logic programming  bart bogaerts pointing grounded
models f stable models same  jorg puhrer several suggestions improvement manuscript  frank loebe helpful discussions  research partially
supported deutsche forschungsgemeinschaft  dfg  project br           

references
al abdulkarim  l   atkinson  k     bench capon  t  j  m          abstract dialectical
frameworks legal reasoning  hoekstra  r   ed    proceedings twentyseventh annual conference legal knowledge information systems  jurix  
vol      frontiers artificial intelligence applications  pp        ios press 
al abdulkarim  l   atkinson  k     bench capon  t  j  m          evaluating approach
reasoning cases using abstract dialectical frameworks  proceedings
fifteenth international conference artificial intelligence law  icail  
alviano  m     faber  w          stable model semantics abstract dialectical frameworks revisited  logic programming perspective  yang  q     wooldridge  m 
 eds    proceedings twenty fourth international joint conference artificial
intelligence  ijcai   pp            buenos aires  argentina  ijcai aaai 
arora  s     barak  b          computational complexity  modern approach  cambridge
university press 
baumann  r   dvorak  w   linsbichler  t   strass  h     woltran  s          compact
argumentation frameworks  proceedings twenty first european conference
artificial intelligence  ecai   pp        prague  czech republic 
bidoit  n     froidevaux  c          negation default unstratifiable logic programs 
theoretical computer science                
bogaerts  b   vennekens  j     denecker  m          grounded fixpoints applications knowledge representation  artificial intelligence            
boppana  r  b          threshold functions bounded depth monotone circuits  journal
computer system sciences                 
brewka  g   dunne  p  e     woltran  s          relating semantics abstract dialectical frameworks standard afs  proceedings twenty second international
joint conference artificial intelligence  ijcai   pp          ijcai aaai 
brewka  g   ellmauthaler  s   strass  h   wallner  j  p     woltran  s          abstract
dialectical frameworks revisited  proceedings twenty third international
joint conference artificial intelligence  ijcai   pp          ijcai aaai 
brewka  g     gordon  t  f          carneades abstract dialectical frameworks  reconstruction  proceedings third international conference computational
models argument  comma   vol      faia  pp       ios press 
brewka  g   polberg  s     woltran  s          generalizations dung frameworks
role formal argumentation  ieee intelligent systems                special
issue representation reasoning 
   

fiexpressiveness two valued semantics adfs

brewka  g     woltran  s          abstract dialectical frameworks  proceedings
twelfth international conference principles knowledge representation
reasoning  kr   pp         
clark  k  l          negation failure  gallaire  h     minker  j   eds    logic
data bases  pp          plenum press 
coste marquis  s   konieczny  s   mailly  j  g     marquis  p          revision
argumentation systems  minimal change arguments statuses  proceedings
fourteenth international conference principles knowledge representation
reasoning  kr   pp       
darwiche  a     marquis  p          knowledge compilation map  journal artificial
intelligence research             
denecker  m   marek  v  w     truszczynski  m          ultimate approximation
application nonmonotonic knowledge representation systems  information
computation                 
dimopoulos  y   nebel  b     toni  f          computational complexity
assumption based argumentation default reasoning  artificial intelligence 
                
dung  p  m          acceptability arguments fundamental role
nonmonotonic reasoning  logic programming n person games  artificial intelligence             
dunne  p  e   dvorak  w   linsbichler  t     woltran  s          characteristics multiple
viewpoints abstract argumentation  proceedings fourteenth international
conference principles knowledge representation reasoning  kr   pp 
      vienna  austria 
dunne  p  e   dvorak  w   linsbichler  t     woltran  s          characteristics multiple
viewpoints abstract argumentation  artificial intelligence              
dyrkolbotn  s  k          argue anything  enforcing arbitrary sets labellings
using afs  proceedings fourteenth international conference principles
knowledge representation reasoning  kr   pp          vienna  austria 
eiter  t   fink  m   puhrer  j   tompits  h     woltran  s          model based recasting
answer set programming  journal applied non classical logics                 
eiter  t     gottlob  g          computational cost disjunctive logic programming 
propositional case  annals mathematics artificial intelligence              
    
french  t   van der hoek  w   iliev  p     kooi  b          succinctness
modal logics  artificial intelligence            
friedman  j          constructing o n log n  size monotone formulae k th elementary symmetric polynomial n boolean variables  siam journal computing     
       
gabbay  d  m          dungs argumentation essentially equivalent classical propositional logic peirce quine dagger  logica universalis                
   

fistrass

gaggl  s  a     strass  h          decomposing abstract dialectical frameworks  parsons  s   oren  n     reed  c   eds    proceedings fifth international conference
computational models argument  comma   vol      faia  pp         
ios press 
gaggl  s  a   rudolph  s     strass  h          computational complexity naivebased semantics abstract dialectical frameworks  yang  q     wooldridge  m 
 eds    proceedings twenty fourth international joint conference artificial
intelligence  ijcai   pp            buenos aires  argentina  ijcai aaai 
gebser  m   kaminski  r   kaufmann  b   ostrowski  m   schaub  t     schneider  m 
        potassco  potsdam answer set solving collection  ai communications 
                available http   potassco sourceforge net 
gelfond  m     lifschitz  v          stable model semantics logic programming 
proceedings international conference logic programming  iclp   pp 
          mit press 
gogic  g   kautz  h   papadimitriou  c     selman  b          comparative linguistics
knowledge representation  proceedings fourteenth international joint
conference artificial intelligence  ijcai   pp          morgan kaufmann 
jukna  s          boolean function complexity  advances frontiers  vol     algorithms combinatorics  springer 
lifschitz  v     razborov  a          many loop formulas   acm transactions computational logic                
lifschitz  v   tang  l  r     turner  h          nested expressions logic programs  annals
mathematics artificial intelligence                  
lin  f     zhao  y          assat  computing answer sets logic program sat
solvers  artificial intelligence                    
linsbichler  t          splitting abstract dialectical frameworks  parsons  s   oren  n    
reed  c   eds    proceedings fifth international conference computational
models argument  comma   vol      faia  pp          ios press 
marek  v  w     truszczynski  m          autoepistemic logic  journal acm         
       
osorio  m   zepeda  c   nieves  j  c     cortes  u          inferring acceptable arguments
answer set programming  proceedings sixth mexican international
conference computer science  enc   pp         
polberg  s          extension based semantics abstract dialectical frameworks  endriss 
u     leite  j   eds    proceedings seventh european starting ai researcher
symposium  stairs   vol      faia  pp          ios press 
polberg  s   wallner  j  p     woltran  s          admissibility abstract dialectical
framework  leite  j   son  t  c   torroni  p   van der torre  l     woltran  s 
 eds    proceedings fourteenth international workshop computational logic
multi agent systems  clima xiv   vol       lnai  pp          springer 
   

fiexpressiveness two valued semantics adfs

puhrer  j          realizability three valued semantics abstract dialectical frameworks  yang  q     wooldridge  m   eds    proceedings twenty fourth
international joint conference artificial intelligence  ijcai   pp            ijcai aaai  buenos aires  argentina 
shen  y     zhao  x          canonical logic programs succinctly incomparable
propositional formulas  proceedings fourteenth international conference
principles knowledge representation reasoning  kr   pp         
vienna  austria 
strass  h          approximating operators semantics abstract dialectical frameworks  artificial intelligence            
strass  h          relative expressiveness argumentation frameworks  normal
logic programs abstract dialectical frameworks  konieczny  s     tompits 
h   eds    proceedings fifteenth international workshop non monotonic
reasoning  nmr  
strass  h       a   instantiating rule based defeasible theories abstract dialectical frameworks beyond  journal logic computation  advance access published   
february       http   dx doi org         logcom exv    
strass  h       b   relative expressiveness abstract argumentation logic programming  proceedings twenty ninth aaai conference artificial intelligence
 aaai   pp            austin  tx  usa 
strass  h       c   representational succinctness abstract dialectical frameworks 
black  e   modgil  s     oren  n   eds    proceedings third international workshop theory applications formal argumentation  tafa  
strass  h     wallner  j  p          analyzing computational complexity abstract
dialectical frameworks via approximation fixpoint theory  artificial intelligence      
     
tseitin  g  s          complexity derivations propositional calculus  structures constructive mathematics mathematical logic  part ii  seminars
mathematics  translated russian          

   


