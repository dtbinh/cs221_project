journal artificial intelligence research                 

submitted       published      

continuing plan quality optimisation
fazlul hasan siddiqui
patrik haslum

fazlul siddiqui anu edu au
patrik haslum anu edu au

australian national university  
nicta optimisation research group
canberra  australia

abstract
finding high quality plans large planning problems hard  although current
anytime planners often able improve plans quickly  tend reach limit
plans produced still far best possible  planners fail
find improvement  even given several hours runtime 
present approach continuing plan quality optimisation larger time scales 
implementation system called bdpo   key approach decomposition
subproblems improving parts current best plan  decomposition based
block deordering  form plan deordering identifies hierarchical plan structure 
bdpo  seen application large neighbourhood search  lns  local search
strategy planning  neighbourhood plan defined replacing one
subplans improved subplans  on line learning used adapt strategy
selecting subplans subplanners course plan optimisation 
even starting best plans found means  bdpo  able continue
improving plan quality  often producing better plans anytime planners
given enough runtime  best results  however  achieved combination
different techniques working together 

   introduction
classical ai planning problem involves representing models world  initial
goal states  available actions formal modelling language  reasoning
preconditions effects actions  given planning problem  planning system
 or planner  short  generates sequence actions  whose application transforms
world initial state desired goal state  thus  planning makes intelligent
system autonomous construction plans action achieve goals 
key concern automated planning producing high quality plans  planners using
optimal bounded suboptimal  heuristic  search methods offer guarantees plan quality 
unable solve large problems  fast planners  using greedy heuristic search
techniques  hand  solve large problems often find poor quality plans 
gap capabilities two kinds planners means producing high
quality plans large problems still challenge  example gap shown
figure    seek address gap proposing new approach continuing plan
improvement  able tackle large problems works varying time scales 
anytime search tries strike balance optimal  or bounded suboptimal 
greedy heuristic search methods  anytime search algorithms finding initial
solution  possibly poor quality  quickly continuing search better solutions
c
    
ai access foundation  rights reserved 

fi  
 

  

plan cost

  

siddiqui   haslum

  
          
 
 
    
 

  

   

   

problem  sorted 

figure    illustration plan quality gap  dashed line represents best  lowestcost  plan     problems genome edit distance  ged  domain  haslum       
found different non optimal planners  including anytime planners  solid line represents corresponding highest known lower bound  difference two
optimality gap    points represent plans found optimal planners 
vertical bars show optimality gap obtained problem specific algorithm  grimm  

time given  anytime search algorithms as  example  rwa 
 richter  thayer    ruml        aees  thayer  benton    helmert      b 
successfully used anytime planners  however  planners often effective
making use increasing runtime beyond first minutes  xie  valenzano    muller
       define unproductive time planner amount time remaining
finds best plan  total time given  show four ipc      domains
 barman  elevators  parcprinter  woodworking   unproductive time lama
planner  which uses rwa    given    minutes per problem      
observed similar results  shown figure    figure shows average
ipc quality score function time several anytime planners plan optimisation
methods  including lama planner   a full description experiment setup 
results even anytime planners  presented section    page       lama
finds first solution quickly        problems solves  within maximum  
hours cpu time per problem   first plan found less    minutes  quality
lamas plans improve rapidly early on  later trend one flattening out  i e  
decreasing increase   the drop beginning due figure showing average
plan quality solved problems  initial  low quality  plans problems found
average drops  increasing better plans found      
hours cpu time  lama improves plans       solved problems  yet
      problems better plans exist  found methods  time
interval  lamas average plan quality score increases       increase
   

ficontinuing plan quality optimisation

    
    

average quality score  relative ipc quality score   coverage 

    
    
    
    




































































































   
    
    
    
    
    
    


    









































bdpo  pngs base plans
bdpo  base plans
pngs base plans
ibcs base plans
bss base plans
lama scratch
ibacop  scratch








    



 

   

 

   

 

   

 

   

 

   

 

   

 

   

 

    

time  hours 

figure    average ipc quality score function time per problem  set    
large scale planning problems  quality score plan cref c  c cost
plan cref reference cost  least cost plans problem   hence
higher score represents better plan quality  anytime planners  lama  ibacop   start
scratch  post processing  pngs  bdpo  bounded cost search  ibcs  beamstack search  methods start set base plans  curves delayed   hour
account maximum time given generating base plan  experiment setup
results additional planners described section      page      

   

fisiddiqui   haslum

figure    general framework bdpo 

least       possible  memory limited branch and bound algorithms  beam stack
search  zhou   hansen        may run indefinitely  find improvements slowly 
increase average plan quality made bss entire time depicted figure
       
plan optimisation approaches based post processing start valid plan seek
improve it  figure   shows results plan neighbourhood graph search  nakhost
  muller         pngs searches shortcuts subgraph state space
problem  constructed around current plan   the pngs implementation used
experiment applies nakhosts mullers action elimination technique   applying
pngs results substantial plan quality improvements quickly       improved plans
found less    minutes stops  runs memory 
summary  experiment shows current anytime plan optimisation methods
become unproductive runtime increases  suffer slow rate plan quality
improvement 
present post processing approach plan optimisation  implementation
system called bdpo    the source code bdpo  provided on line appendix
article   post processor  bdpo  work own  depends
methods providing initial plan  experiment  set input plans  referred
base plans  best plans found lama   hour  plan found ibacop 
     ipc  figure   shows switching approach time
overcome limitation current anytime planning techniques  continue improve
plan quality allotted time increases  best result  shown  obtained chaining
several techniques together  applying first pngs base plans  bdpo 
best result produced pngs  result could achieved previous anytime
planning approaches alone 
bdpo  uses large neighborhood search  lns   local search technique  local
search explores neighbourhood around current solution plan better quality valid
plan  lns  neighbourhood solution defined destroy repair methods 
together replace part current solution  keeping rest unchanged 
bdpo   destroy step selects subsequence linearisation deordering
current plan  we call window  repair step applies bounded cost
planner subproblem finding better replacement subplan  focus
solving smaller subproblems makes local search  lns particular  scale better
large problems  size structure neighborhood  however  plays crucial
   

ficontinuing plan quality optimisation

role performance local search  hoffmann         setting  neighbourhood determined strategies used select windows subplanners  destroy
methods used lns algorithms often contain element randomness  local
search may accept moves lower quality solutions  ropke   pisinger        schrimpf 
schneider  stamm wilbrandt    dueck         contrast  explore neighbourhood
systematically  examining candidate windows generated ordered several heuristics 
accept moves strictly better plans  introduce lns idea
delayed restarting  meaning search combine multiple local improvements
restarting next iteration new best plan  found delayed
restarts allow better exploration subplans different parts current plan 
helps avoid local minima otherwise occur system attempts re optimise
part plan successive iterations 
bdpo  framework  shown figure    broadly consists four components  plan
decomposition  lns  i e   repeated destroy repair steps   windowing  on line
adaptation  first step  decomposition  uses deordering produce partially ordered
plan  deordering enables windowing strategies find subplans easier
improve on  leading much better anytime performance  use block deordering  siddiqui
  haslum         simultaneously decomposes given plan coherent subplans 
called blocks  relaxes ordering constraints blocks  block deordering removes
inherent limitations existing  step wise deordering techniques  able
deorder sequential plans cases step wise deordering possible 
windowing component collection strategies extracting windows block
deordered plan  ranking policies order windows system attempts
optimise promising windows first 
bdpo  extends earlier system  bdpo  siddiqui   haslum      b   mainly using
variety alternatives task  bdpo used single windowing strategy  with
ranking  single subplanner  bdpo  uses portfolios window generation
ranking strategies several subplanners  improves capability robustness
system  since single alternative  windowing strategy  subplanner  etc   dominates
others across problems  furthermore  take advantage fact system
solves many subproblems course local search learn on line
best alternatives current problem  particular  use ucb  multi armed
bandit learning policy  auer  cesa bianchi    fischer        subplanner selection 
sequential portfolio window ranking policies 
remainder article structured follows  section   describes block deordering  theory block deordering presented slightly different earlier
account  siddiqui   haslum         allowing deordering cases better contrasting traditional partially ordered plan semantics  section   presents
overview bdpo  system main empirical results  sections     give
details windowing on line adaptation components  respectively  including
empirical analysis impact performance system whole  section  
reviews related work  section   presents conclusions outlines ideas future work 
   

fisiddiqui   haslum

   plan decomposition
approach continuing plan quality improvement based optimising plan
parts  one time  every subplan consider local optimisation subsequence
linearisation partially ordered plan  therefore  key step removing unnecessary ordering constraints the  typically sequential  input plan  process called
plan deordering  importance deordering demonstrated one experiments
 presented section      page       apply bdpo  input plans
already high quality  total plan quality improvement  measured increase
average ipc plan quality score  achieved bdpo  without deordering      
less achieved bdpo  using plan deordering technique 
standard notion valid partially ordered plan requires unordered steps
plan non interfering  i e   two subsequences plan unordered  every
interleaving steps two must form valid execution   limits amount
deordering done  cases extent deordering sequential
plan possible   an example situation shown figure   page      
remedy this  introduced block deordering  siddiqui   haslum         creates
hierarchical decomposition plan non interleaving blocks deorders
blocks  makes possible deorder plans further  including cases
conventional  step wise  deordering possible   again  example found
figure   page       section  present new  slightly different account
theory practice block deordering  first  relaxes restriction block deordered
plans  thereby allowing deordering plans  second  contrasts semantics
block decomposed partially ordered plans traditional partially ordered plan
semantics clearer way 
sections        describe necessary background  sections        introduce block
decomposed partially ordered plans block deordering algorithm 
    planning problem  sequential plan validity
consider standard strips representation classical planning problems action
costs  planning problem tuple   hm  a  c  i  gi  set atoms
 alternatively called fluents propositions   set actions  c   r   cost
function actions  assigns action non negative cost  initial
state  g goal 
action characterised triple hpre a   add a   del a i  pre a   add a  
del a  preconditions  add delete effects respectively  say
action consumer atom pre a   producer add a  
deleter del a   action applicable state pre a  s 
applied s  results state apply a  s     s   del a   add a   sequence
actions   hai   ai          aj applicable state si     pre ak   sk k j 
    si     apply ai   si    si     apply ai     si      on  resulting state
apply   si     si j    
valid sequential plan  also totally ordered plan  seq   ha         planning
problem sequence actions applicable g apply seq   i  
actions seq must executed specified order 
   

ficontinuing plan quality optimisation

    partially ordered plan validity
plans partially ordered  case actions unordered respect
other  partially ordered plan  p o  plan  tuple  pop   hs  i 
set steps  each labelled action a  represents strict  i e  
irreflexive  partial order s  unordered steps pop executed order 
  denotes transitive closure   element hsi   sj  also si sj   basic
ordering constraint iff transitively implied constraints   plan
step s  use pre s   add s  del s  denote preconditions  add delete effects
action associated s  use terms producer  consumer  deleter 
cost plan steps  referring associated actions  include two steps 
si sg   si ordered steps  consumes nothing produces initially
true atoms  sg ordered steps  consumes goal atoms produces
nothing 
linearisation pop total ordering steps respects   p o  plan
pop valid  for planning problem   iff every linearisation pop valid sequential
plan  for    words  p o  plan viewed compact representation
set totally ordered plans  namely linearisations 
every basic ordering constraint  si sj   pop set associated reasons  denoted
re si sj    reasons explain ordering necessary plan
valid  re si sj   non empty  step precondition may unsatisfied
execution linearisations pop violate si sj   reasons three
types 
pc m   producerconsumer atom m   first step  si   produces precondition second step  sj   thus  order changed  sj executed si  
precondition sj may established required 
cd m   consumerdeleter m   second step  sj deletes m  precondition
si   thus  order changed  may deleted required 
dp m   deleterproducer m   first step  si deletes m  produced
second step  sj   order changed  add effect producer step may
undone deleter  causing later step fail  is  however  necessary
order producer deleter step may occur producer plan
depends added atom 
note ordering constraint several associated reasons  including several
reasons type referring different atoms  producerconsumer relation
pc m  re si sj   usually called causal link si sj  mcallester  
rosenblitt         denoted triple hsi   m  sj i  causal link hsi   m  sj threatened
deleter may ordered last producer sj
sj   since implies possibility false required execution
sj   formal definition follows 
definition    let pop   hs  p o  plan  hsp   m  sc causal link pop  
hsp   m  sc threatened step sd deletes neither     sc   sd
    s p   add s p   sd   s p   sc true 
   

fisiddiqui   haslum

mentioned above  p o  plan  pop   hs  planning problem valid iff
every linearisation pop valid sequential plan   however  following theorem
gives alternative  equivalent  condition p o  plan validity 
theorem    e g   nebel   backstrom         p o  plan valid iff every step precondition
supported causal link threat causal link 
condition chapmans        modal truth criterion 
sc s  pre sc    
sp    pc m  re sp sc  
st   del st   sc   sd s p   add s p   sd   s p   sc



 

    deordering
process deordering converts sequential plan p o  plan removing ordering
constraints steps  steps plan successfully executed
order consistent partial order still achieve goal  backstrom        
refer step wise deordering  distinguish block decomposition
deordering introduce later section  since current state space search planners
produce sequential plans efficiently  deordering plays important role efficient
generation p o  plans 
let pop   hs  valid p o  plan   step wise  deordering pop valid plan
 
 
pop
  hs              is  pop
result removing basic
ordering constraints without invalidating plan  sequential plan seq   ha        
represented p o  plan one step si action ai seq ordering
si sj whenever   j  two steps unordered  thus  deordering
sequential plan different  further  deordering p o  plan 
computing  step wise  deordering minimum number ordering constraints
np hard  backstrom         several non optimal algorithms  e g   pednault 
      veloso  perez    carbonell        regnier   fade         used variant
explanation based generalisation algorithm kambhampati kedar        
algorithm works two phases  first phase constructs validation structure 
exactly one causal link hsp   m  sc precondition step sc   sp chosen
earliest producer preceding sc input plan  intervening threatening
step  i e   deletes m  sp sc    the algorithm veloso  perez carbonell
similar  selects latest producer instead   second phase  algorithm builds
partial ordering  keeping orderings original plan either correspond
causal links validation structure required prevent threatening step
becoming unordered w r t  steps causal link 
kambhampati kedars deordering algorithm  due greedy strategy 
guarantee optimality  example fails transform totally ordered plan
least constrained plan shown figure    however  recent study found
algorithm produce optimal step wise plan deorderings plans
tested  muise  mcilraith    beck        
however  motivation plan deordering find deordering adequate
generating useful candidate subplans local optimisation  important achieving
   

ficontinuing plan quality optimisation

figure    example kambhampati kedars        algorithm fails find
least constrained plan   derived figure    backstroms      article plan
deordering   figure  a  sequential input plan   b  plan produced algorithm
choosing earliest producer  for validation structure  preconditions p
q d   c  minimally ordered version  a   simplicity  goal atoms
produced steps a  b  c shown figure 

optimal step wise deordering overcoming inherent limitation step wise deordering  allows plan steps unordered non interfering  block
deordering  described next two sections  remove orderings input
plans forming blocks  helps generate decomposed plan suitable
extracting subplans local optimisation 
    block decomposition
conventional p o  plan  whenever two subplans unordered every interleaving steps
two forms valid execution  limits deordering cases individual steps
non interfering  remove restriction  proposed block decomposed partial
ordering  restricts interleaving steps dividing plan steps blocks 
steps block must interleaved steps block  however 
steps within block still partially ordered  illustrated example
figure    figure shows difference linearisations p o  plan block
decomposed p o  plan  b  a  c  valid linearisation standard partial ordering
block decomposed p o  plan  formal definition block follows 
definition    let pop   hs  p o  plan  block w r t    subset b steps
two steps s  s  b  exists step s    s  b    s     s   
decomposition plan blocks recursive  i e   block wholly
contained another  however  blocks cannot partially overlapping  two blocks
ordered bi bj exist steps si bi sj bj si sj neither block
contained  i e   bi   bj bj   bi   
definition    let pop   hs  p o  plan  set b subsets block
decomposition pop iff     b b block w r t      every bi   bj b 
either bi bj   bj bi   bi bj disjoint  block decomposed plan denoted
bdp   hs  b  i 
   

fisiddiqui   haslum

figure    normal p o  plan  left  represents set sequential plans linearisations plan steps  example ha  b  c  di  hb  a  c  di  hb  c  a  di  hb  c  d  ai 
block decomposed p o  plan  shown right dashed outlines blocks  allows
unordered blocks executed order  steps different blocks
interleaved  thus  ha  b  c  di  hb  c  a  di  hb  c  d  ai possible linearisations
plan 

semantics block decomposed plan defined restricting linearisations  for
must valid  respect block decomposition  i e  
interleave steps disjoint blocks  bi bj   steps bi must precede steps bj
linearisation block decomposed plan 
definition    let bdp   hs  b  block decomposed p o  plan planning problem
  linearisation bdp total order lin     lin     every
b b block w r t  lin   bdp valid iff every linearisation bdp plan  
blocks behave much  non sequential  macro steps  preconditions  add
delete effects subset union constituent steps 
enables blocks encapsulate plan effects preconditions  reducing interference
thus allowing deordering  following definition captures preconditions
effects visible outside block  i e   give rise dependencies
interference parts plan  need consider
deciding two blocks unordered   note responsible step step block
causes produce  consume threaten atom  
definition    let bdp   hs  b  block decomposed p o  plan  b b block 
block semantics defined as 
b adds iff b precondition m  responsible step b
add s   s  b  s  deletes s  s 
b precondition iff responsible step b pre s  
step s  b causal link hs    m  si without active threat 
b deletes iff responsible step b del s   step
s  b s  adds m 
note block consumes proposition  cannot produce proposition 
reason taking black box view block execution  proposition
simply persists  true execution block begins remains true
finished  steps within block totally ordered  preconditions effects
block according definition   nearly cumulative preconditions
   

ficontinuing plan quality optimisation

effects action sequence defined haslum jonsson         difference
consumer block cannot producer proposition 
conventional p o  plan  valid  must contain threat causal link 
contrast  block decomposed p o  plan allows threat causal link exist plan 
long causal link protected threat block structure  causal
link protected threat iff either  i  causal link contained block
contain threat   ii  threat contained block contain
causal link delete threatened atom  i e   encapsulates delete effect  
threat causal link active link protected it  otherwise inactive 
formal definition follows 
definition    let bdp   hs  b  block decomposed p o  plan  st threat
causal link hsp   m  sc bdp   hsp   m  sc protected st iff exist block
b b either following true      sp   sc b  st
  b      st b  sp   sc
  b 

  del b  
example block decomposition protects causal link seen figure
  i  page     
following theorem provides alternative criterion validity block decomposed p o  plan  analogy condition conventional p o  plan given
theorem cited above  difference block decomposed p o  plan allows
threats causal links  long threats inactive  let bdp   hs  b  block
decomposed p o  plan  analogously chapmans modal truth criterion  condition
stated follows 
sc s  pre sc  
sp    m add sp  
st    m del st   st    sp sc    st hsp   m  sc protected st    
theorem    block decomposed p o  plan valid iff every step precondition supported
causal link active threat 
proof  let bdp   hs  b  block decomposed p o  plan planning problem   let
us first prove part  i e   every step precondition supported causal
link active threat every linearisation bdp valid plan   let
seq   h        sc        i arbitrary linearisation bdp total order seq s 
pre sc    then  according validity criteria sequential plan  show
must satisfied execution sc seq   since every step precondition
supported causal link bdp active threat  must supported
causal link hsp   m  sc active threat  moreover  since seq sp seq sc  
let st threat hsp   m  sc bdp   clearly  sp seq st seq sc possibility
may cause unsatisfied execution sc   since hsp   m  sc active
threat  hsp   m  sc protected st   therefore  according definition    either    
sp   sc b st
  b      st b  sp   sc
  b 
  del b   must hold      true 
sp seq st seq sc occur valid linearisation bdp   since interleaves
steps sp   sc b st
  b  thus b block w r t  seq   second case  since
   

fisiddiqui   haslum


  del b  must producer m  s p b  st seq s p   moreover 
since sp   sc
  b  sp seq st seq sc true sp seq st seq s p seq sc  
makes true execution sc seq  
let us prove part  i e   bdp valid every step precondition
supported causal link active threat  let sc s  pre sc   
seq   h        sc        i linearisation bdp total order seq s  consider two
possible situations      producer s  causal link hs    m  sc bdp
constructed      least one producer construct causal
link sc atom causal link active threat bdp   show
none situations happen long bdp valid  according situation
     s  seq well s  seq sc   causes unsatisfied
execution sc seq   i e   seq become invalid  consequently  bdp become invalid
 since one linearisation invalid   contradicts assumption  therefore 
must exist least one producer s  construct causal link hs    m  sc bdp  
now  situation      assume sp last producer execution sc
seq   i e   s p   sp   add s p    s p seq sp sc seq s p    let sp producer
causal link hsp   m  sc bdp  which possible  since sp ordered sc
bdp    assume hsp   m  sc active threat st bdp   since hsp   m  sc active
threat st  i e   hsp   m  sc protected st    neither  i  sp   sc b  st
  b 
 ii  st b  sp   sc
  b 
  del b   true  therefore  sp seq st seq sc possible
linearisation bdp   moreover  since producer sp sc  
must unsatisfied execution sc   i e   seq becomes invalid  consequently 
bdp invalid since one linearisations invalid  therefore  hsp   m  sc must
active threat 
    block deordering
block deordering  siddiqui   haslum        process removing orderings
plan steps adding blocks block decomposed p o  plan  may add plan
new ordering constraints  transitively implied ordering
constraints  block deordering often remove ordering constraints step wise deordering not  no interleaving restriction among blocks affords
us simplified  black box  view blocks localises interactions 
preconditions effects executing block whole important  thus  allows deordering able ignore dependencies effects matter
internally within block  addition providing linearisations  improving
deordering  blocks formed block deordering often correspond coherent  selfcontained subplans  form basis windowing strategies  described detail
section    use generate candidate subplans local optimisation 
subsection presents conditions adding blocks block decomposition allows removal basic ordering constraints  complete block deordering
algorithm presented next subsection 
simple example block deordering  figure   i  shows sequential plan small
logistics problem  plan deordered conventional p o  plan 
plan step reason ordered previous  block deordering  however 
   

ficontinuing plan quality optimisation

figure    sequential plan block deordering plan two unordered blocks
b  b   ordering constraints labelled reasons  producerconsumer  pc  
i e   causal link  deleterproducer  dp   consumerdeleter  cd   note ordering
constraint sequential plan removed without invalidating it  thus  step wise
deordering plan possible 

able break ordering s  s  removing reason pc at p  a  based
formation two blocks b  b  shown figure   ii   neither two blocks
delete add atom p   although precondition both   removes
interference them  allows two blocks executed order
without interleaving  therefore  possible linearisations block decomposed
p o  plan hs   s   s   s i hs   s   s   s i  note b  ordered b  
b  optimised removing step s  
besides necessary orderings pair steps plan due reasons pc 
cd  dp  stated section       valid block decomposed p o  plan must maintain one
type necessary ordering  called threat protection ordering  removing ordering
sx   sy causes block containing steps delete effect 
ordering  delete effect causes causal link outside block become
unprotected  not satisfying either two conditions definition     sx   sy
threat protection ordering  may removed  threat protection ordering
introduced block deordering process  introduced removed 
demonstrated figure    removing kind ordering leads invalid
block decomposed p o  plan  threat protection ordering defined formally follows 
definition    let bdp   hs  b  block decomposed p o  plan  hsp   m  sc
causal link protected st bdp   let b b  st   s  b  sp   sc
  b  add s    

  del b   st   s    st   s  threat protection ordering breaking ordering
causes del b  causes hsp   m  sc become unprotected st  
   

fisiddiqui   haslum

figure    two block decompositions plan containing five steps  s   s   s   s   s  
decomposition  i   three  transitively reduced  necessary orderings  s  s  
s  s   s  s   re s  s      dp m   dp n    re s  s      pc m   
re s  s      pc n    decomposition valid since every step precondition
satisfied causal link without active threats  threat s  causal link hs   n 
s i inactive  since link protected block bx    s   s   s   contains s 
delete m  disjoint causal link  forming two blocks     s  
bz    s   s   would possible remove s  s   shown  ii   since hs   m  s i
protected s  bz   however  decomposition delete effect block bx
becomes del bx      m  n   block therefore longer protects hs   n  s i  therefore 
decomposition deordering invalid  ordering s  s  threat protection
ordering  must broken  note  i  s  consumers produced
atom n  yet acts white knight hs   n  s i protect n deleter s  

notion threat protection ordering missing earlier block deordering
procedure  siddiqui   haslum         relied  implicitly  stronger restriction
delete effects block change due subsequent deordering inside block 
explicitly checking necessary threat protection orderings allows deordering
inside created blocks take place 
remove basic ordering  si sj   block decomposed p o  plan bdp   hs  b  i 
create two blocks  bi bj   si bi   sj bj   bi bj     note one
two blocks consist single step  blocks must consistent existing
decomposition  i e   b  bi   bj   must still valid block decomposition  sense
definition    remainder subsection  define four rules state conditions
blocks bi bj allow different reasons ordering si sj eliminated 
since ordering si sj exist several reasons  including several reasons
type  referring different atoms   blocks bi bj found
allow us remove every reason re si sj   ordering steps
removed 
rule    let bdp   hs  b  valid block decomposed p o  plan  si sj basic
ordering whose removal cause threat protection ordering removed 
pc m  re si sj    let bi block  si bi   sj
  bi   s  bi   si s    pc m 
removed re si sj   pre bi   sp
  bi sp establish
causal link bi sj  
   

ficontinuing plan quality optimisation

figure    formation block  s p  addition causal link hr m qi  ii  order
remove reason pc m  behind basic ordering constraint p q  i   different
situations   iii iv   threat  t  may active hr m qi 

explanation rule    pc m  re si sj    bi must produce m  since
si produces followed deleter within bi  because si sj basic
ordering sj
  bi   way happen bi consumes m  since plan
valid  must producer  sp
  bi   necessarily precedes step  in bi  
 
consumes m  note sp sj   adding causal link pc m  re sp sj    i e  
adding hsp   sj already present  allows pc m  removed re si sj   
theorem    deordering according rule   preserves plan validity 
proof  let bdp   hs  b  valid block decomposed p o  plan  therefore  according
theorem    every step precondition bdp supported causal link active
threat  let p q basic ordering constraint  where p  q s   bp   bq b blocks
meet conditions removing pc m  re p q   bp   bq ordered
ordering constraints  show removing pc m  re p q  results
 
new plan  bdp
  hs  b       i  meets condition theorem    therefore
remains valid 
assume pc m  re p q  removed  precondition q supplied
step r based newly established causal link hr m qi deordering formulating
 
bp    s     p   bq    q  bdp
  shown figure    ii   show hr m qi
 
 
active threat bdp   therefore  bdp
valid  assume  active threat 
 
 
t  hr m qi bdp   then  course  r q   t  examine every
situation  active threat hr m qi 
situation      assume   t  shown figure    iii   since active threat
hr m si bdp   according theorem    either contained block
   

fisiddiqui   haslum

figure    formation blocks removing reason cd m  behind basic ordering
p q 

delete threatened atom contain hr m si  hr m si contained
 
block b     r  s       contain t  first case  holds true bdp
 
 
therefore  active threat hr m qi  second case  b partially
overlap bp    s     p   therefore  either bp b  b  bp   bp b    bp must contain r 
happen according pc removing criteria  i e   r
  bp must hold  stated
rule    b  bp   b  must contain least r  s  p  b  partially
overlap bp    s     p   since active threat hp m qi bdp   hp m qi
must contained block b      p  q       contain t  now  since b 
b   partially overlap  b  b    whichever bigger  must contain least r  s  p 
q  b  b    whichever bigger  protects hr m qi t 
situation      assume   p  shown figure    iii   since active
threat hp m qi bdp   before  show either contained block
encapsulates threatened atom  i e   delete m  contain hp m qi 
hp m qi contained block b     r  s  p  q       contain t  cases 
hr m qi protected t 
situation      assume     p shown figure    iv   possible bp  
since interleave steps bp
  bp   therefore  bp   causes
hr m qi protected t  bp contain hr m qi
delete  since add p    p  
therefore  conclude never active threat hr m qi
situation 
rule    let bdp   hs  b  valid block decomposed p o  plan  si sj basic ordering
whose removal cause threat protection ordering removed  cd m 
   

ficontinuing plan quality optimisation

re si sj    let bi bj two blocks  si bi   sj bj   bi bj    
cd m  removed re si sj   bi consume m 
theorem    deordering according rule   preserves plan validity 
proof  let bdp   hs  b  valid block decomposed p o  plan  p q basic
ordering constraint  p  q cd m  re p q   order meet
condition rule    let us assume bp block includes r p hr m pi
causal link every consumer bp  if exist  ordered r bdp  as
shown figure    i    therefore meets condition bp must consume m  also 
assume bq block contains  q  bp   bq ordered ordering
constraints  therefore  cd m  re p q  well p q removed  results
 
 
new plan bdp
  hs  b       i  show bdp
valid according theorem   
since bdp valid  active threat causal link bdp according
theorem    due deordering p q  deleter q becomes new threat
 
  however  hr m pi contained bp contain
causal link hr m pi bdp
q  therefore  according definition    hr m pi protected q  i e   q becomes
 
remains valid 
inactive threat  result  bdp
rule    let bdp   hs  b  valid block decomposed p o  plan  si sj basic ordering
whose removal cause threat protection ordering removed  cd m 
re si sj    let bi bj two blocks  si bi   sj bj   bi bj    
cd m  removed re si sj   bj delete m 
theorem    deordering according rule   preserves plan validity 
proof  let bdp   hs  b  valid block decomposed p o  plan  p q basic
ordering constraint  p  q cd m  re p q   order meet condition
rule    let us assume bq block includes q dp m  re q s 
every deleter bq  if exist  ordered bdp  as shown
figure    ii    therefore meets condition bq must delete m  also  assume bp
block contains  p   bp   bq ordered ordering constraints 
therefore  cd m  re p q  well p q removed  results new plan
 
 
valid according theorem   
  hs  b       i  show bdp
bdp
since bdp valid  active threat causal link bdp according
theorem    due deordering p q  deleter q becomes new threat
 
causal link hr m pi bdp
  however  q contained bq contain hr m pi 
delete m  therefore  according definition    hr m pi protected q  i e  
 
q becomes inactive threat  result  bdp
satisfies condition theorem  
therefore remains valid 
rule    let bdp   hs  b  valid block decomposed p o  plan  si sj basic ordering
whose removal cause threat protection ordering removed  dp m 
re si sj    let bj block  sj bj si
  bj   dp m  removed
re si sj   bj includes every step s  pc m  re sj s    
theorem    deordering according rule   preserves plan validity 
   

fisiddiqui   haslum

figure     formation blocks removing reason dp m  behind basic ordering
p q 

proof  let bdp   hs  b  valid block decomposed p o  plan  let p q basic
ordering constraint  where p  q s   let bq block includes steps r
hq m ri  hq m si causal links bdp  as shown figure    ii    hence 
meets condition rule    also  assume bp block contains  p  bp   bq
ordered ordering constraints  result  dp m  re p q  well
 
 
  hs  b       i  show bdp
p q removed  results new plan bdp
satisfies condition theorem   therefore remains valid 
since bdp valid  active threat causal link bdp according
theorem    due deordering p q  deleter p becomes new threat
 
  however  causal links contained
causal links hq m ri hq m si bdp
bq contain p  therefore  according definition    protected p 
 
i e   p becomes inactive threat  result  bdp
remains valid 

even when  applying four rules above  find blocks bi bj remove
reasons ordering si sj   thus permitting ordering removed 
guaranteed two blocks bi bj unordered  may ordered
bi contains step si ordered step bj  whether sj
another   even not  block b b contains bi  or bj both  
b still ordered bj  resp  bi   due constraint  
hsi   sj i  blocks bi bj still ordered  sense bi appear bj
linearisation consistent block decomposition 
   

ficontinuing plan quality optimisation

    block deordering algorithm
previous subsection described four conditions  rules     adding blocks
decomposition allows reasons ordering constraints  thus ultimately ordering
constraints themselves  removed preserving plan validity  next  describe
algorithm uses rules perform block deordering  i e   convert sequential
plan seq block decomposed p o  plan bdp  
algorithm divided two phases  first  apply step wise deordering procedure convert seq p o  plan pop    s       used kambhampati
kedars        algorithm this  simple shown produce
good results  muise et al          even though optimality guarantee 
step wise plan deordering  extend ordering blocks  two blocks ordered
bi bj exist steps si bi sj bj si sj neither block contained
 i e   bi   bj bj   bi    case  steps bi must precede steps bj
linearisation block decomposed plan  extend reasons ordering
 pc  cd dp  ordering constraints blocks  set propositions
produced  consumed deleted block given definition    recall responsible
step step block causes produce  consume delete proposition 
example  b produces p  must step b produces p  step
block ordered deletes p  say step responsible b producing p 
next phase block deordering  converts p o  plan pop    s   
block decomposed p o  plan bdp    s  b       done greedy procedure 
examines basic ordering constraint bi bj turn attempts create blocks
consistent decomposition built far allow ordering
removed  core algorithm resolve procedure  algorithm     takes
input two blocks  bi bj   ordered  one blocks may consist single step  
tries break ordering extending larger blocks  b i b j   procedure
examines reason ordering constraint extends one blocks remove
reason  following rules given previous subsection  this  sets
propositions produced  consumed deleted new blocks  b i b j   recomputed
 following definition    new reasons ordering constraint arisen
steps included added re b i b j    repeated
either reason ordering remains  case new blocks returned
procedure safely unordered  reason cannot removed  case
deordering possible  signalled returning null   function intermediate bi   bj  
returns set steps ordered bi bj   i e    s   bi     bj    algorithm
  refers nearest step s  preceding following another step s  means step
smallest number basic ordering constraints s  s 
applied resolve procedure basic ordering constraint would obtain
collection blocks break orderings  collection
necessarily valid decomposition  since blocks may partial overlap 
find valid decomposition  use greedy procedure  repeatedly examine basic
ordering constraint bi bj call resolve find two extended blocks b i bi b j bj
allow ordering removed  iteration  constraints checked order
beginning plan  block  added bdp   removed
   

fisiddiqui   haslum

algorithm   resolve ordering constraints pair blocks 
   procedure resolve bi   bj  
  
initialise b i   bi   b j   bj  
  
re b i b j     
  
r re b i b j  
  
r   pc p 
   try rule  
  
find responsible step b i nearest s    b i consumes
p s    s 
  
s  exists
  
set b i   b i  s    intermediate s    b i   
  
else return null
   
else r   dp p 
   try rule  
   
find responsible step b j s    b j
hs  p  s  causal link 
   
s  exists
   
set b j   b j  s    intermediate b j   s    
   
else return null
   
else r   cd p 
   try rule  
   
find responsible step b j nearest s    b j produces p 
  s   
   
s  exists
   
set b j   b j  s    intermediate b j   s    
   
else
   try rule  
   
find responsible step b i nearest s    b i produces
p  s    s 
   
s  exists
   
set b i   b i  s    intermediate s    b i   
   
else return null 
   
recompute re b i b j   
   

return  b i   b j   

accommodate another block partially overlaps existing block throughout
procedure  even later  rejected  block could produce deordering one
created earlier  since choice deordering apply greedy  result guaranteed
optimal  b i b j cannot added decomposition  because one
partially overlaps existing block   consider blocks ordered immediately
bi   check orderings broken simultaneously  using union
blocks returned resolve ordering constraint   symmetrically  check
set blocks immediately bj   though rarely useful   additional
   

ficontinuing plan quality optimisation

heuristic  discard two blocks basic ordering constraint step
internal one blocks  i e   preceding following steps within
block  step outside block 
ordering removed  inner loop exits ordering relation updated
new constraints b i blocks ordered bj b j blocks
ordered bi   done checking three reasons  pc  cd dp  based
sets propositions produced  consumed deleted b i b j   inner loop
restarted  ordering constraints previously could broken checked
again  done removing ordering constraints make possible resolution
constraints  since removal orderings change set steps intermediate
two steps 
main loop repeats deordering consistent current decomposition found  iteration runs polynomial time  know upper
bound number iterations  note  however  procedure anytime 
sense interrupted running completion  result end last completed iteration still block deordering plan  bdpo   use time limit  
minutes whole deordering procedure  however  almost every problem considered
experiments  described section       block deordering finishes seconds
 except problems visitall domain  takes couple minutes  
summary  deordering makes structure plan explicit  showing us parts
necessarily sequential  because dependency interference  independent non interfering  block deordering improves creating on the fly
hierarchical decomposition plan  encapsulating dependencies interferences
within block  considering blocks  instead primitive actions  units partial
ordering thus enables deordering plans greater extent  including cases deordering possible using standard  step wise  partial order plan notion  impact
block decomposition anytime performance plan quality optimisation system
discussed section     

   system overview
bdpo  post processing based plan quality optimisation system  starting initial
plan  seeks optimise parts plan  i e  subplans  replacing lower cost
subplans  refer subplans candidates replacement windows 
better plan found certain conditions met  starts new
plan  viewed local search  using large neighborhood search  lns 
strategy  neighborhood plan defined set plans
reached replacing window new subplan  local search plain hill climbing 
move strictly better neighbouring plan  lns algorithms  searching
better plan neighbourhood done formulating local optimisation problems 
solved using bounded cost subplanners 
block deordering  described previous section  helps identify candidate windows
providing large set possible plan linearisations  block decomposition used
windowing strategies  window subsequence linearisation
block deordered input plan  however  represent window slightly different
   

fisiddiqui   haslum

way  partitioning blocks part replaced  w   ordered
 p   q  part 
definition    let bdp    s  b    block decomposed p o  plan  window bdp
partitioning b sets p  w  q  bdp linearisation consistent
 bp bw bq   bp p  bw w  bq q  
window defines subproblem  problem finding plan
fill gap left removing steps w linearisation bdp consistent
window  problem formally defined follows 
definition    let bdp    s  b    block decomposed p o  plan planning problem
  hp  w  qi window bdp   s            s p    s p              s p   w    s p   w              sn linearisation bdp consistent window  subproblem corresponding hp  w  qi 
sub   atoms actions   initial state sub   isub   result
progressing initial state s            s p   i e   applying s            s p  i  
goal sub   gsub   result regressing goal sn           s p   w     
theorem    let bdp    s  b    block decomposed p o  plan planning problem   hp  w  qi window bdp   sub subproblem corresponding window 
s            s p    s p              s p   w    s p   w              sn linearisation sub constructed
 
 
    s            s  plan
from  let w
sub   s            s p    s            sk   s p   w              sn
 
k
valid sequential plan  
proof  proof straightforward  subsequence s            s p  applicable initial
state   i  and  construction sub   results initial state sub   isub   hence
s            s p    s             s k applicable i  and  construction sub   results state
sg satisfies goal sub   gsub   since gsub result regressing goal  
g  s p   w              sn reverse  follows subsequence applicable sg  
applying results state satisfying g   for relevant properties regression 
see  example  ghallab  nau    traverso        section        
subproblem corresponding window hp  w  qi always solution  form
linearisation steps w  improve plan quality  however  replacement
subplan must cost strictly lower cost w  c w   amounts
solving bounded cost subproblems  subplanners used bdpo 
described section      return question multiple windows
within plan simultaneously replaced section     
algorithm   describes bdpo  performs one step local search  exploring
neighbourhood current plan  first step block deorder current plan
 line     next  optimisation using bounded cost subplanner tried systematically
candidate windows  lines       restart condition met  line     
local improvements possible  time limit reached  point difference
lns algorithms used delayed restart  meaning exploration
neighbourhood continue better plan found  helps avoid
local minima  driving exploration different parts current plan  restart
conditions  impact local search  described section     
   

ficontinuing plan quality optimisation

algorithm   neighbourhood exploration procedure bpdo  
   procedure bdpo  in   tlimit   banditpolicy  rankpolicy  optsubprob 
  
initialize  telapsed      last     triallimit     n       windowdb  
  
bdp   blockdeorder in  
  
telapse   tlimit last locally optimal
  
windows needed
  
extractmorewindows bdp   windowdb  optsubprob 
  
  
  
   
   
   
   
   
   
   
   
   
   
   

p   selectplanner banditpolicy 
w   selectwindow p  rankpolicy  triallimit  windowdb 
w   null windows extract triallimit p      
w   null continue
wnew   searchresult   optimisewindow p  w 
updatewindowdb p  w  wnew   optsubprob  searchresult  windowdb 
c wnew     c w 
new   merge bdp   windowdb 
c new     c last   last   new
updatebanditpolicy p  w  wnew   searchresult  banditpolicy 
updaterankpolicy p  searchresult  rankpolicy 
c last     c in   restart condition true
return bdpo   last   tlimt telapsed   banditpolicy  rankpolicy  optsubprob 
return last

key design goal procedure avoid unproductive time  meaning spending
much time one step trying optimise one window options could
lead improvement left waiting  therefore  steps done incrementally 
time limit step could take unbounded time 
database  windowdb  stores unique window extracted block deordered
plan  records status  how many times optimisation window tried
subplanner result   structural summary information window  window database populated incrementally  lines      applying different
windowing strategies limit time spent number windows added 
limits used     seconds    windows  respectively  balances time
window extraction optimisation  prevent procedure spending unproductive time  windowing strategies described section    compute lower
bound cost replacement plan window  using admissible lm cut
heuristic  helmert   domshlak         window proven optimal current subplan cost equals bound  previous attempt optimise window exhausted
bounded cost search space  already optimal windows are  course  excluded
optimisation  windows added database number windows eligible selected optimisation one subplanner  defined next paragraph 
drops threshold  used     current window database size
threshold 
   

fisiddiqui   haslum

subplanner use selected using ucb  multi armed bandit policy  auer et al  
       learns repeated trials select often subplanner succeeds
often finding improvements  next window try chosen  among eligible
ones database  according ranking policy  windows eligible optimisation
chosen subplanner     already proven optimal     
tried chosen subplanner current trial limit      overlap
improved window already found  ranking policy heuristic aimed selecting
windows likely improved chosen subplanner  use several ranking
policies switch one next subplanner fails find improvement
number consecutive tries  since indicates current ranking policy may
recommending right windows current problem  threshold used
switching ranking policy      this     maximum number windows added
window database call extractmorewindows   ranking policies
described section      subplanner given time limit  increased time
retried window  used limit    seconds  increasing another
   seconds retry  limit number times retried
window kept subplanner  initially set    limit increased
subplanner tried every window database  excluding windows
already proven optimal overlap windows better replacement
found  strategy generate new windows  line     lower cost
replacement subplan window found  together improvements already
found current neighbourhood fed merge procedure  tries
combine several replacements achieve greater overall plan cost reduction  merge
procedure described section     
procedure restarts new best plan  learned bandit policy subplanner selection current ranking policy  for subplanner  carried
next iteration  keep database subproblems  defined initial
state goal  whose plan cost proven optimal  avoid trying fruitlessly optimise further  window database  contains information specific
current input plan  reset 
remainder section organised follows  next two sections describe
settings used experiments overview main results  respectively 
describe subplanners used bdpo   section       restart conditions
 section      merge procedure  section       section     discusses impact
block deordering performance system  windowing strategies ranking
policies described section    details on line adaptation methods
used presented section   
    experiment setup
presenting overview results  outline three different experimental
setups used  experiment setup     used     large scale instances
   ipc domains  selection domains instances described below 
experiment    included additional medium sized instances total     instances
   domains  used domains sequential satisficing track
   

ficontinuing plan quality optimisation

                 ipc  except cybersec  cavediving citycar domains 
 the cybersec domain slow system parse  two conditional
effects  implementation handle   used alarm processing
power networks  appn  domain  haslum   grastien         plans used input
bdpo  plan produced ibacop   cenamor  de la rosa    fernandez       
     ipc problems competition  best plan found lama
 richter   westphal        ipc      version    hour cpu time problems 
refer base plans  experiments      selected domain
   last instances base plan exists   in domains less    instances
solved lama ibacop   total     rather       domains
appeared one competition  used instances ipc      set 
experiments run   core     ghz amd cpus  m l  cache   
gb memory limit every system  comparing anytime performance bdpo 
systems require input plan  count time generate base plan
  hour cpu time  maximum time allocated generating base plan 
found much quickly 
first experiment  use bdpo  system  instead  ran two
subplanners  pngs ibcs     seconds every subproblem corresponding
window extracted  by six windowing strategies  base plans  excluding
subproblems window proven optimal lower bound obtained
admissible lm cut heuristic  helmert   domshlak         experiment provided
information inform design combined window extraction procedure  window
ranking policies  aspects system  present results here 
refer later discuss system components detail 
experiment    compare bdpo  eight anytime planners plan optimisation systems  lama  richter   westphal        ipc      version   aees  implemented
fast downward code base  cf  thayer et al       b   ibcs  as described section
      beam stack search  bss   zhou   hansen         pngs  including action elimination  nakhost   muller         ibacop   cenamor et al          lpg  gerevini  
serina         arvand  nakhost   muller         bdpo  uses pngs ibcs
subplanners  configured described above  aees uses lm cut  helmert   domshlak        admissible heuristic  heuristic  without action costs
inadmissible estimates  bss uses lm cut heuristic  implementation bss
use divide and conquer solution reconstruction  run beam width
     systems described section   
system run   hours cpu time per problem  bdpo  pngs
use base plans input  ibcs beam stack search use base
plan cost initial cost bound  mentioned above  allocated   hour cpu time
generating base plan  therefore  comparing systems planners
starting scratch  lama  aees  ibacop   lpg arvand   add   hour start
delay runtime  beam stack search much slower planners used
experiment  therefore  ran    hours cpu time  reporting
results divide runtime    words  results shown hypothetical
implementation beam stack search amount search  faster
constant factor   
   

fisiddiqui   haslum

experiment   uses setup experiment    except input bdpo 
best plan found running pngs   hour cpu time    gb memory
limit  base plans   as mentioned previously  vast majority cases pngs runs
memory much less time that  cases run   hour
limit   use setup primarily run different configurations bdpo  analyse
impact different designs  e g   planner selection window ranking policies 
immediate vs  delayed restart  on  setting input plans already good
quality  comparing anytime result bdpo  experiment
systems  add   hours runtime 
    overview results
figure    shows headline result  form average plan quality achieved
bdpo  systems time per problem increases  ipc quality score plan
calculated cref  c  c cost plan cref cost best plan
problem instance found runs systems used experiments  thus 
higher score reflects lower cost plan  results figure    experiment  
   described previous section  shown figure    on page      
including results compared anytime planning systems  none planners
starting scratch find solution     problems  lama solves     problems 
ibacop       arvand      aees    lpg     planners  average quality
score shown figure    average problems have 
time  found least one plan   as previously mentioned  reason
average quality sometimes falls  first plan  low quality  previously unsolved
problem found  average decrease   words  metric unaffected
differences coverage  likewise  none post processing bounded cost search
methods improve base plans  bdpo  finds plan lower cost base plan
    problems  pngs      ibcs    beam stack search    
systems  average quality shown figure    taken     problems  using
base plan quality score problems system improved on 
majority compared systems show trend similar lama  i e  
improving quickly early flattening ultimately stagnating  reasons
vary  memory limiting factor algorithms  notably pngs  exhausts
  gb available memory reaching   hour cpu time limit       problems 
lama      problems  aees runs memory
    problems  hand  planners use limited memory algorithms 
beam stack search  lpg arvand  both use local search   never run
memory thus could conceivably run indefinitely  however  rate
find plan quality improvements small      hours  average quality produced
lpg arvand increases                respectively   the latter excludes three
problems solved arvand first time     hours  including
brings average down  making increase less         increase average
quality achieved bdpo   starting high quality plans generated pngs
base plans  time interval        
   

ficontinuing plan quality optimisation

    
    
    


average quality score  relative ipc quality score   coverage 

   













































































































































    
    



    





    
   
    
    
    
    
   
    
    
    



    



bdpo  pngs base plans
bdpo  base plans
pngs base plans
ibcs base plans
bss base plans
lama scratch
aees scratch
ibacop  scratch
arvand scratch
lpg scratch

   
    



    
    










































































 

   

 

   

 

   

 

   

 

   

 

   



   



 

   



 

    





time  hours 

figure     average ipc quality score function time per problem  set    
large scale planning problems  quality score plan cref c  c cost
plan cref least cost plans problem  hence higher score represents
better plan quality  lama  aees  lpg  arvand ibacop  planners start
scratch  whereas post processing  pngs  bdpo   bounded cost search  ibcs 
beam stack search  methods start set base plans  curves delayed  
hour  maximum time allocated generating base plan  experimental
setup described detail section     

   

fisiddiqui   haslum

bdpo 
bdpo 
pngs
           
appn
  
     
  
barman
      
  
childsnack
      
  
elevators
     
     
floortile
  
     
ged
  
  
hiking
  
     
maintenance    
   
nomystery
   
       
   
openstacks
parcprinter
   
      
  
  
     
parking
scanalyzer
     
     
sokoban
   
   
tetris
     
     
thoughtful
     
     
tidybot
  
  
transport
     
     
visitall
     
     
woodworking      
     
overall
               
domains

lama

aees

arvand

lpg

ibcs

bss

pngs

ibacop 

                                             
  
  
  
           

 

  
  

  
  

     
     

     
     

  

  

  
  
  

  

     

  

  

  

  

     

  

     

  

  

     
     

     

  
     

  

  

  

  

     
  
  
  
     
  

     

  

  

  

     
     

 

 

 

 

 

 

 

             

     
   

 

table    plan improvement method  percentage instances found
plan cost matching best plan      found plan strictly better method
     found plan known optimal  i e   matched highest lower bound
     percentage instances domain shown figure      zeros
omitted improve readability   bdpo  pngs result bdpo  experiment
   results experiment    see section      

draw two main conclusions  first  bdpo  achieves aim continuing quality
improvement even time limit grows  fact  continues find better plans  though
decreasing rate  even beyond   hour time limit used experiment  second 
combination pngs bdpo  achieves better result either alone  partly
work well different sets problems figure showing
average  bdpo  sometimes produces better result started best plan
found pngs domains bdpo  already outperforms pngs start
base plans  e g   elevators transport   however  seen
opposite domains  e g   floortile hiking   starting bdpo  worse
input plan often yields better final plan  seen figure     provides
detailed view  shows problem cost best plan found
system   hour total time limit  scaled interval base plan cost
highest known lower bound  hlb  plan problem   lower bounds
obtained variety methods  including several optimal planners  cf  haslum 
              problems excluded figure       cases  base plan cost
already matches lower bound  improvement possible  another    problems 
method improves base plans within stipulated time   the pegsol domain
appear graph  base plans one optimal  method
improves cost last one  
   

ficontinuing plan quality optimisation

base plans









































best cost achieved  normalised 



































nomystery

maintenance

ged

floortile

barman

hiking



elevators



childsnack



appn

hlb







lama scratch
aees scratch
arvand scratch
lpg scratch
ibacop  scratch
pngs base plans
ibcs base plans
bss base plans
bdpo  base plans
bdpo  pngs base plans

base plans




































best cost achieved  normalised 

































hlb



lama scratch
aees scratch
arvand scratch
lpg scratch
ibacop  scratch
pngs base plans
ibcs base plans
bss base plans
bdpo  base plans
bdpo  pngs base plans
woodworking

visitall

transport

tidybot

thoughtful

tetris

sokoban

scanalyzer

parking

parcprinter

openstacks





figure     best plan cost  normalised interval cost base plan
corresponding highest known lower bound  achieved different anytime plan
optimisation methods experiment    bdpo  experiments        see section
     

   

fisiddiqui   haslum

table   provides different summary information figure     showing
domain system percentage instances found plan cost    
matching best plan instance      strictly better method 
    matching lower bound  i e   known optimal  aggregate  combination
bdpo  pngs base plans achieves best result three measures 
however    domains  ged  hiking  openstacks  parking  tidybot   lama finds
plans strictly better method  tried using lama
one subplanners bdpo   lead better results overall 
domains  openstacks ged  smallest improvable subplan often whole 
almost whole  plan  lama finds improvement plan searching
longer time  although bdpo  increases time limit given subplanners
retry  average time limit  across local optimisation attempts experiment 
      seconds  thus  strategy searching quick improvements plan parts
work well domains 
    subplanners used window optimisation
subplanners used bdpo  used find plan window subproblem 
stated definition    cost less cost current window  c w  
considered three subplanners 
    iterated bounded cost search  ibcs   using greedy search admissible heuristic pruning 
    plan neighbourhood graph search  pngs   including action elimination technique  nakhost   muller        
    restarting weighted a   richter et al          implemented lama planner 
however  experimental setups described previous section  bdpo  uses
two subplanners  ibcs pngs  two reasons choosing two  first 
show good complementarity across domains  example  ibcs significantly better pngs appn  barman  floortile  hiking  maintenance  parking  sokoban 
thoughtful woodworking domains  pngs better elevators  scanalyzer 
tetris  transport visitall domains  second  learning policy use subplanner selection learns faster smaller number options  therefore  adding third
subplanner improve overall performance bpdo   given limited time per
problem  subplanner complements two well  i e   performs well
significant fraction instances two not  set benchmark
problems used experiment  case   a different set benchmarks
could course yield different outcome   experiment comparing effectiveness
three subplanners  individually well combination ibcs pngs
learning policy  bdpo  presented section     page     
solve bounded cost problem  ibcs uses greedy best first search guided
unit cost heuristic  pruning states cannot lead plan within cost bound
using f value based admissible lm cut heuristic  helmert   domshlak        
implemented fast downward planner  search complete  plan
   

ficontinuing plan quality optimisation

within cost bound  prove exhausting search space  given sufficient
time memory  bounded cost search return plan within cost
bound  get best subplan possible within given time limit  iterate it  whenever
plan found  long time remains  search restarted bound set
strictly less cost new plan 
pngs  nakhost   muller        plan improvement technique  searches subgraph state space around input plan  limited bound number states 
lower cost plan  better plan found exploration limit increased  usually
doubled   continues time memory limit reached  ibcs 
iterate pngs get best subplan possible within given time limit  improves
current subplan  process repeated around new best plan 
lama  richter   westphal        finds first solution using greedy best first search 
switches rwa   richter et al         search better quality solutions 
    restart
restart condition determines trade off exploring neighbourhood
current solution continuing local search different parts solution space 
obvious choice  one used lns algorithms  restart
new best solution soon one found  call immediate restart  however 
found continuing explore neighbourhood current plan even better
plan found  merging together several subplan improvements  described
section     below  often produces better results  call delayed restart 
setting right conditions make delayed restart critical success
approach  used disjunction two conditions  first  union
improved windows found neighbourhood covers     steps input plan 
recall continue exploration loop  algorithm    improvement
found  windows overlap already improved window excluded
optimisation  drives procedure search improvements different
parts current plan  helps avoid certain myopic behaviour occur
immediate restarts  restarting new best plan  get new block
decomposition new set windows  lead attempting re optimise
part plan improved  even several restarts  may lead
local optimum time consuming escape  second condition    consecutive
subplanner calls failed find improvement  threshold    three
times threshold switching ranking policy  cf  description algorithm  
beginning section   means    attempts tried optimise
   promising windows  among remaining eligible ones  recommended
ranking policies  without success  suggests improvable windows
found  none ranking policies good current neighbourhood 
making restart point allows exploration return parts plan
intersect already improved windows  thus increasing set eligible windows 
average plan quality  function time per problem  achieved bdpo  using
immediate restart delayed restart based conditions shown top
two lines figure     page       experiment  configurations run using
   

fisiddiqui   haslum

algorithm   merge improved windows
   procedure merge bdp   windowdb 
  
initialise bdp   bdp
  
w   improved windows windowdb sorted cost reduction  c w  c wnew   
  
w   
  
 hp  w  qi  wnew     pop window highest c w  c wnew   w
  
bdp   replaceifpossible bdp   hp  w  qi  wnew  
  
w   removeconflictingwindows w  bdp  
  

return bdp

setup experiment    described section     page      seen 
delayed restart yields better results overall  compared bdpo  immediate restart 
achieves total improvement     higher  however  found immediate restart
work better instances  especially visitall woodworking domains 
bdpo  immediate restart found better final plan nearly     instances 
average number iterations  i e   steps lns  done bdpo  using
delayed restart condition      per problems across domains considered
experiment  highest average single domain      thoughtful solitaire 
immediate restart average domains increases       words 
configurations bdpo  spend significant time exploring neighbourhood plan 
anytime performance curve figure    shows additional time spent
neighbourhood using delayed restarts pays off 
    merging improved windows
delayed restarting would benefit without ability simultaneously replace
several improved windows current plan  improved windows always nonoverlapping  because better subplan window found  windows overlap
longer considered optimisation  corresponding subproblems may
generated different linearisations block deordered plan 
this  replacement subplans may additional preconditions delete effects
replaced windows not  lack add effects  thus  may
linearisation permits two windows simultaneously replaced 
merge procedure shown algorithm   greedy procedure  maintains
times valid block deordered plan  bdp    meaning precondition block
supported causal link active threat   recall block context
block consists single step   initially  input plan  bdp   
causal links  ordering constraints  computed block deordering 
procedure gets improved windows  w   window database  tries replace
current plan bdp order contribution decreasing plan cost  i e  
cost replaced window  c w   minus cost new subplan  c wnew    
first replacement always succeeds  since  construction subproblem 
linearisation input plan wnew valid  cf  theorem     subsequent
replacements may fail  case merge proceeds next improved window w  
   

ficontinuing plan quality optimisation

since replacing window different subplan may impose new ordering constraints 
remaining improved windows conflict partial order current plan
removed w  
replaceifpossible function takes current plan  bdp    returns updated plan  which becomes current plan   plan replacement
possible  replacement subplan  wnew   made single block whose steps totally ordered  preconditions effects block  replaced window
 w   computed according definition    page       atom pre wnew  
w  existing causal link kept  likewise  causal links effect add w 
add wnew   kept  links unthreatened consistent
order  since plan valid replacement  additional precondition
new subplan  pre wnew     pre wi    causal link hbp   m  bc bdp
producer replaced window  bp w   consumer  bc   w  
atom link produced replacement subplan  m   add wnew     new
causal link must found  given consumer  bc   atom requires  m pre bc    
procedure tries following two ways creating unthreatened causal link 
 c   block b    bc add b     every threatening block  i e  
b   del b       either b   b  bc b   added existing plan ordering
without contradiction  b  chosen  ordering constraints necessary resolve
threats  if any  added 
 c   otherwise  block b  add b    unordered w r t  bc  
every threatening block either b   b  bc b   enforced  b  chosen 
causal link  implying new ordering b  bc   threat resolution ordering constraints
 if any  added plan 
two tried order  c  first c  c  fails  neither rule find
required causal link  replacement fails  wnew may threaten existing causal
links bdp w not  threatened link  hbp   m  bc i  procedure tries
resolve threat three ways 
 t   consumer bc ordered w linearisation corresponding
subproblem  bc p   bc wnew consistent  threat removed adding
ordering 
 t   producer bp ordered w linearisation corresponding subproblem  bp q   wnew bp consistent  threat removed adding ordering 
 t   new  unthreatened causal link supplying bc found one two
rules c  c  above  threatened link replaced new causal link 
rules tried order  none resolve threat  replacement
fails 
non basic ordering constraints blocks w may disappear w
replaced wnew   likewise  ordering constraints w rest
plan may become unnecessary  wnew may delete every atom w deletes
may preconditions w  thus removed  may make pairs
blocks b  b  plan ordered replacement unordered  thus create
new threats  new threats checked replaceifpossible  found
resolved restoring ordering constraint lost 
   

fisiddiqui   haslum

lemma    current plan bdp valid  wnew solves subproblem corresponding
window hp  w  qi  plan returned replaceifpossible valid 
proof  procedure ensures every precondition every step supported causal
link active threat  link either existed plan replacement  and
new threats created replacement resolved ordering constraints  
added procedure  thus  replacement succeeds  resulting plan valid
according theorem    replacement fails  plan returned current plan 
bdp   unchanged  valid assumption 
theorem    input plan  bdp valid  plan returned merge 
proof  immediate lemma   induction sequence accepted replacements 

    impact plan decomposition
neighbourhood explored step lns bdpo  defined substituting
improved subplans current plan  subplan considered local optimisation
subsequence linearisation block deordering current plan  obviously 
restrict windows consecutive subsequences totally ordered input
plan  fact  similar approaches plan optimisation adopted restriction  ratner
  pohl        estrem   krebsbach        balyo  bartak    surynek         section 
address question much block deordering contributes performance
bdpo  
preliminary experiment  setup    described section     page     
observed     subproblems improved subplan found
correspond non consecutive part sequential input plan  however  prove optimising     subplans found without
deordering would lead equally good end result 
therefore  conducted another experiment  using setup experiment    described section       experiment  ran bdpo  separately different degrees
plan decomposition      block deordering  as default bdpo  configuration 
one used experiments     presented section     page           standard  i e   step wise  plan deordering only  configuration  used kambhampati
kedars        algorithm  described section      plan deordering      without
deordering  i e   passing totally ordered input plan directly lns process 
addition  configurations run immediate restarting
delayed restarting  described section     
figure    shows average ipc plan quality score function time per problem
achieved configurations bdpo   shows simple clear picture 
immediate restart  lns applied block deordered plans outperforms lns applied
step wise deordered plans  turn outperforms use totally ordered plans 
total improvement  measured increase average ipc plan quality score 
achieved bdpo  without deordering       less achieved best
configuration  see deordering enabler delayed restarting 
block step wise deordering  delayed restarting boosts performance lns
   

ficontinuing plan quality optimisation

     












     








     







    



     










     






















     









     



    

 

   

 

   

 

   

 

     

 



   



 



     

bdpo  delayed restart block deordered plans
bdpo  immediate restart block deordered plans
bdpo  delayed restart standard partially ordered plans
bdpo  immediate restart standard partially ordered plans
bdpo  delayed restart totally ordered plans
bdpo  immediate restart totally ordered plans
   



 




   

average quality score  relative ipc quality score   coverage 



time  hours 

figure     average ipc quality score function time per problem bdpo  applied
totally ordered input plan  standard  step wise  deordering plan 
block deordering plan  plan type  system run two configurations  delayed restarting immediate restarting  cf  section    
page       experiment run setup    described section     page     
time shown runtime bdpo   i e   without   hour delay
generating input plans  shown figure      note y axis truncated 
curves start average quality input plans        

   

fisiddiqui   haslum

plan optimisation            respectively  totally ordered plans
significant effect 
deordering increases number linearisations therefore enables many
distinct candidate windows created  however  recall bdpo s neighbourhood
exploration procedure  algorithm    interleaves incremental window generation optimisation attempts  many windows could generated current plan may
never generated restart occurs  thus  average number windows generated
iteration reflect difference performance   with block deordering 
average number windows generated                remain filtering 
totally ordered plans               filtering  using immediate
restart   deordering helps windowing strategies generate windows
easily optimised  recall neighbourhood exploration retry subplanner
window  with higher time limit  windows tried
subplanner  average number optimisation attempts  using either subplanner 
window selected optimisation least once  around     either block deordering
standard deordering used input plan  without deordering  however 
average number attempts higher  high domains  leaving
highest    neighbourhoods encountered  average slightly   
    plan neighbourhoods average number attempts   
cases     words  generating windows totally ordered plan
causes procedure spend  average  time window improving
plan found 
hand  noted section      domains subplanners need
runtime find better plans improvable windows  bdpo  configuration without
deordering find better plan default configuration        problems 
current bdpo  system  subplanner time limit increased window
retried  procedure either attempts candidate windows likely improved
 for example  indicated window ranking policies described section     
frequently  varies amount time given optimise window may perform better 
optimal amount deordering plan may well different problem problem  averaged across set benchmark problems  deordering
unarguably better none 

   windowing strategies ranking windows
window subplan linearisation block deordered plan  extracted order
attempt local optimisation  section describes strategies use generate
rank windows  experimental evaluation impact systems performance 
recall definition    page      window represented triple hp  w  qi 
w set blocks replaced  p q sets blocks ordered
w  respectively  linearisation  block decomposed p o  plan
many linearisations  producing many possible windows typically far many
attempt optimise all  windowing heuristic procedure extracts reduced
set windows  hopefully including promising ones  systematic way 
   

ficontinuing plan quality optimisation

figure     block deordered plan transformation extended blocks  blocks b 
b  merged single block  blocks b  b  

windowing heuristics
rule based
cyclic thread
causal followers

generated
basic
ext 
   
  
  
  
  
  

filtered
basic
ext 
  
  
  
  
  
  

improved
basic
ext 
  
 
    
  
    
 

impr  gen 
basic
ext 
    
    
    
    
    
    

table    total number  in thousands  windows generated  filtered out 
finally improved  using different windowing heuristics different block types  basic
extended   number possible windows sequential input plans 
even considering deordering       million  rightmost pair columns shows
rate success  meaning fraction improved windows generated windows 
numbers results experiment    described section     page      
present three windowing heuristics  called rule based  cyclic thread  causal followers
heuristics  described detail following subsections 
heuristic applied two types block basic extended one time 
basic blocks blocks generated block deordering   for purpose windowing 
step included block created block deordering considered
block own   extended blocks created merging basic blocks block
deordered plan form complete non branching subsequences  block bi
immediate predecessor block bj   bj immediate successor bi  
merged one extended block  algorithm   shows procedure extended block
formation   ip b  denotes set bs immediate predecessors  is b  bs immediate
successors  
algorithm   computing extended blocks 
   bext bbasic
   bi   bj bext   ip bj      bi    is bi      bj  
  
bext bext  bi bj      bi   bj  
process illustrated example figure     note blocks b 
b  merged one extended block  although b 
immediate successor b   b  immediate predecessor b   extended blocks
useful allow windowing heuristics capture larger windows 
experiment results show windows different sizes useful different domains 
   

fisiddiqui   haslum

algorithm   extract candidate windows
   global array strategy       stores state windowing strategy   
   procedure extractmorewindows bdp   windowdb  optsubprob 
  
w  
  
tlimit   initial time limit tincrement
  
telapsed   tlimit  w     nwindowslimit
  
  nextwindowingstrategy  
  
  null break    windowing strategies exhausted   
  
w   strategy i  getwindows bdp   windowdb  optsubprob 
nwindowslimit  w    tlimit telapsed  
  
telapsed tlimit w   tlimit    tincrement
  

windowdb insert w  

example  larger windows likely improved pegsol  openstacks
parcprinter domains  optimising smaller windows better elevators  transport 
scanalyzer woodworking domains 
windowing strategy windowing heuristic applied block type  thus  use
total six different strategies  strategies contributes improvable
windows generated strategies  cf  section     
particular table   page       thus  are  sense  useful 
hand  size set windows generates fraction improvable
windows set varies strategies  sense useful
others 
table   shows results first experiment  systematically tried two
subplanners  pngs ibcs  every window generated  and filtered out 
windowing strategy     input plans  table shows total number  in thousands 
windows generated  remain filtering  finally improved
least one two subplanners  experiment  windows filtered
window cost matched lower bound given admissible lm cut heuristic
 helmert   domshlak         experiment setup described section      on
page       first observation strategies selective  number
windows could potentially generated  even without considering deordering  i e  
taking subsequences totally ordered input plans       million  thus 
even prolific strategy generates less tenth possible windows  second 
used rate success  meaning fraction windows generated improved
subplanners used experiment  order strategies  order
follows 
   rule based heuristic extended blocks 
   cyclic thread heuristic basic blocks 
   cyclic thread heuristic extended blocks 
   causal followers heuristic basic blocks 
   rule based heuristic basic blocks 
   causal followers heuristic extended blocks 
   

ficontinuing plan quality optimisation

neighbourhood exploration procedure  algorithm   page      adds windows
database incrementally  calling extractmorewindows procedure shown
algorithm    procedure selects next strategy try  cycling
order above  asks strategy generate specified number windows 
limited time  strategy keeps state  what part heuristic
applied part plan   next time queried resume
generating new windows  windows possible given strategy
generated  say strategy exhausted  windowing strategies discard    
windows known optimal  either cost matches lower bound
given admissible lm cut heuristic  helmert   domshlak        
stored set optimally solved subproblems      windows overlap
already improved window  windows eligible optimisation  cf  section    
generating redundant  selected strategy finishes without generating enough
windows time remains  next not yet exhausted strategy order queried 
on  either  w     nwindowslimit time up  windows generated 
strategies still exhausted  time limit increased 
    rule based windowing heuristic
first version bdpo  siddiqui   haslum      b  used single windowing strategy 
based applying fixed set rules extended blocks  strategy complements new windowing heuristics well  kept bdpo  
rule applied block b block deordered plan bdp selects set
blocks go replaced part  w  based relation b  ensure
window consistent block deordering  i e   consistent linearisation 
stated definition   page       blocks constrained ordered
blocks window must included  call intermediate blocks  formally
defined follows 
definition     let bdp   hs  b  block decomposed p o  plan  intermediate
blocks b b ib b     b   b    b   b   b  b b     
let b block bdp   let un b  set blocks ordered w r t  b 
ip b  immediate predecessors b  is b  immediate successors  rules used
windowing heuristic are 
   w   b  
   w   b  ip b  
   w   b  is b  
   w   b  un b  
   w   b  un b  ip b  
   w   b  un b  is b  
   w   b  un b  ip b  is b  
   w   b  un b  ip  b  un b   
   w   b  un b  is  b  un b   
   

fisiddiqui   haslum

figure     window formation applying  st rule rule based windowing heuristic
block b   i e   w  b    p un b    unordered block b  placed
predecessor set  note window optimised removing s  step
causal link successors 

    w   b  un b  ip  b  un b   is  b  un b   
given blocks selected one rules above  partitioning blocks hp  w  qi
made setting w   w  ib  w    assigning p block ordered
unordered w  q block ordered w  figure    shows example
rule based windowing   st rule applied block b   applied blocks 
rules produce duplicates  course  unique windows kept 
first rules  include fewer blocks  generally produce smaller windows 
later rules tend produce larger window  though exact relation  since
number actions block varies   heuristic applies rules block
block deordered plan bdp turn  rules applied order                       i e  
starting first  last  second  second last  on  blocks
ordered size  descending   ties broken order input plan  in opposite
direction extended blocks  
recall extractmorewindows repeatedly asks windowing strategy generate limited number windows  ordering blocks rules described helps
ensure heuristic generates varied set windows  including small
large  covering different parts current plan  time queried 
    cyclic thread windowing heuristic
discover new windowing heuristics  noted key changes decomposed plan
structure frequently occur plan improved  one significant observation
multiple steps input plan add effects  steps together
steps necessarily ordered form subplan often im   

ficontinuing plan quality optimisation

proved  call cyclic behavior  one experiment  found cycles type
either removed plan replaced different cycles    
improvements across domains  definition cyclic behavior based
individual atom  intuitively  atom cyclic behavior multiple producers  as
defined below  
definition     let bdp   hs  b  block decomposed p o  plan  pm
set producers atom m  i e   spm add s   cyclic behavior iff  pm       
note pm contains init step si iff i  however  since window never contains
initial step si   candidate windows formed extended producers instead  step

   si   sg   extended producer atom iff produces m  consumes
s     si produces ordered block deordered plan 
formal definition follows 
definition     let bdp   hs  b  block decomposed p o  plan  step
extended producer atom iff
   si   sg   and 
   add s 
   pre s  ks si add k    k 
order form candidate windows respect atom cyclic behavior 
first extract blocks contain least one extended producer atom m 
cyclic thread  cf  definition     formed taking linearisation blocks 
consistent input plan 
definition     let bdp   hs  b  block deordering sequential plan seq  
bx   b two blocks bx     let hbx   linearisation  bx     
hbx   consistent seq least one step bx appears step seq  
way linearise blocks consistent input plan clarified
following example  assume bx    sa   sc      sb   sd   two blocks
linearise  orderings constituent steps input plan
sa sb sc sd   linearisation starts block contains first
element   i e   bx case  since contains sa    updated  bx  
linearisation continues fashion empty  resulting linearisation
example blocks hbx   i  multiple  nested  blocks contain first element
  innermost one picked  formal definitions thread cyclic thread
follows 
definition     let bdp   hs  b  block deordering sequential plan seq   epm
set extended producers atom m  bm b set blocks 
element bm contains least one element epm   thread m  tm  
linearisation blocks bm linearisation consistent seq   thread
called cyclic iff cyclic behavior 
example  plan shown figure    i   atom  at t  a  cyclic behaviour 
since holds initial state added step s   extended producers s   s 
s   cyclic thread t at t  a    hb   b i 
   

fisiddiqui   haslum

finally  candidate windows formed taking consecutive subsequence blocks
 and intermediate blocks  necessary  cyclic thread  rule based windowing 
blocks unordered respect window assigned set blocks
precede window 
definition     let tm   b         bk cyclic thread atom m  cyclic thread based
windows cyclic thread tm wl m    b ib b    b   bi        bi l consecutive
subsequence tm    unordered blocks always placed predecessor set 
rule based windowing heuristic  cyclic thread heuristic generates windows order aims ensure returns varied set windows time
called  first identifies cyclic threads block deordered plan generates
stream candidate windows one cyclic thread another  mentioned 
candidate window formed taking consecutive subsequence blocks  and intermediate blocks required form consistent window  cyclic thread  given
thread  tm   blocks  subsequences generated according following order sizes 
    tm        tm               tm      words  subsequence lengths ordered
smallest  biggest  second smallest  second biggest  on  size
order  windows generated moving beginning end thread 
    causal followers windowing heuristic
third strategy use obtain broader range potentially improvable
windows similar cyclic thread heuristic creates windows subsequences linearisation blocks connected particular atom  different
connections via causal links 
definition     let bdp   hs  b  block decomposed p o  plan  c set
causal links   causal followers atom producer p cfhm pi  
 p  sj        sk   hp  m  sj i       hp  m  sk i  c      si   sg    causal followers  for
producers   cfm   sequence hcfhm p         cfhm pn i  p         pn linearisation
producers m 
words  causal followers atom list sets steps 
set steps  one producer others consumers sj m 
causal link every sj m  i e   pc m  re s sj    example  atom  at t  b 
block deordered plan figure    i  appears two causal links 
producer  hs    at t  b   s i hs    at t  b   s i  thus  causal followers
cf at t  b    h s   s   s  i 
block deordered plan extract sequence sets blocks corresponding
causal follower steps  according definition below  example  sequence
causal follower blocks cf at t  b  plan figure    i  cfb at t  b    h b  i 
since steps cf at t  b  contained block b  
definition     let bdp   hs  b  block decomposed p o  plan  cfhm pi
causal followers atom respect producer p s  causal follower
blocks respect producer p atom m  cfbhm pi   set blocks 
block contains least one element cfhm pi   causal follower blocks
   

ficontinuing plan quality optimisation

exclusive


basic block
      
      

ext  block
     
      

rule based
      
      

cyclic thread
     
      

causal followers
      
      

table    percentage improvable windows found using two block types three
windowing heuristics  total number improvable windows found using blocks
types windowing heuristics  first row gives percentage improvable windows
found one block type  or one windowing heuristic
others   second row gives percentage improvable windows found one
block type  or windowing heuristic   results first experiment  described
section     
 for producers   cfbm   sequence hcfbhm p         cfbhm pn i  p         pn
linearisation producers bdp  
candidate windows formed taking consecutive subsequences sequence
causal follower blocks  with intermediate blocks  necessary   formal definition
given below  windowing heuristics  blocks unordered respect
window assigned set blocks precede window 
definition     let bdp   hs  b  block decomposed p o  plan  cfbm  
hcfbhm p         cfbhm pn causal follower blocks m  causal followers based
windows cfbm wl m    b ib b    b   cfbhm pi     cfbhm pi l
consecutive subsequence cfbm length l   unordered blocks always placed
predecessor list 
order windows generated causal followers heuristic based
principle cyclic thread heuristic  generates stream candidate
windows causal follower blocks cfbm associated atom turn 
windows consecutive subsequences sets blocks cfbm   lengths chosen
according pattern    l     l          l     l length cfbm  
    impact windowing heuristics
one single windowing heuristic block type  combination them  guaranteed
find improvable windows  first row table   shows percentage improvable
windows found using one block type  or one windowing heuristic
others   total number improvable windows found using blocks types
windowing heuristics   the results first experiment  described section
      shows every windowing heuristic block type contributes improvable
windows found strategies  example        improvable windows
found rule based windowing heuristic  using basic extended blocks  
hand         improvable windows found heuristic 
windowing heuristics strengths limitations  rule based heuristic 
example  generate windows contain sequences extended blocks
fixed length  cyclic thread causal followers heuristics make windows
blocks connected single atom 
   

fisiddiqui   haslum

     

     

     




     














































     




















     


































     



















     





     



 

   

 

   

 

   

 

 



     

   




 

     

bdpo   combined windowing heuristics 
bdpo   random windowing 
bdpo   rulebased windowing only 
bdpo   causal followers windowing only 
bdpo   cyclic thread windowing only 
   



 



   

average quality score  relative ipc quality score   coverage 

     

time  hours 

figure     average ipc quality score function time separate runs bdpo  using
three windowing heuristics alone  three heuristics combined  random
window generation  run done using setup experiment    described
section      on page       x axis shows runtime bdpo   i e   without
  hour delay generating input plans  shown figure      note
y axis truncated  average quality input plans       

   

ficontinuing plan quality optimisation

figure    shows impact different windowing heuristics anytime performance
bdpo   measured average ipc plan quality score achieved function timeper problem  experiment  ran bdpo  three windowing heuristics
alone  three combined sequential portfolio  described beginning
section   the combined portfolio windowing heuristic configuration
bdpo  presented experimental results section      page      
compare non heuristic  random windowing strategy  window
formed taking random subsequence blocks random linearisation
block deordered plan  subsequences chosen distribution window sizes
 measured number actions window  roughly produced
combined heuristics  experiment uses setup    described section     page
      i e   input plans bdpo  already high quality   their average ipc plan
quality score        
predicted data table    using three windowing heuristics
results much worse system performance  since fails find substantial
fraction improvable windows  fact  random window generation better
heuristics own  however  combined portfolio heuristics outperforms
random windowing good margin  total quality improvement achieved
random windowing strategy       less best bdpo  configuration 
demonstrates heuristics capture information useful guide selection
windows 
    possible extensions windowing strategies
since window formed partitioning plan steps three disjoint sets blocks 
number possible windows exponential  challenge good windowing heuristic
extract reduced set contains windows likely improved  every windowing
strategy limitations  hence  always scope developing new windowing
heuristics extending existing ones  one extension discussed section 
combination strategies use may miss improvable windows  example 
long sequence blocks form part cyclic thread causal followers sequence
respect single atom captured heuristics  example
shown figure     three candidate windows  w   w  w   found causal
followers windowing heuristic improvable separately  situation  forming
window union separate windows  found one several strategies  overcome
limitations strategies  example  union w  w  improvable 
type composite windows could formed later stages plan improvement
process  individual windowing heuristics exhausted  however 
number composite windows created large set candidate windows
combinatorial thus optimising take long time 
    window ranking
although windowing strategies generate fraction possible windows 
number candidate windows still often large  cf  table     order speed
   

fisiddiqui   haslum

figure     three candidate windows  w   w   w   found causal followers
windowing heuristic atoms  at t  b    in p  t     in p  t   respectively  none
improvable  however  composite window formed merging w  w 
improvable substituting delivery package p   from location b c  provided
truck t  truck t   atom  at t  c  required
successors  i e   goal example  

plan improvement process  helpful order windows likely
improved optimised first  role window ranking 
ranking windows made difficult fact properties improvable windows
vary one another  lot domain domain  example  mentioned
beginning section  larger windows likely improved pegsol 
openstacks parcprinter domains  smaller windows better elevators 
transport  scanalyzer  woodworking domains  sokoban domain 
hand  medium sized windows better  moreover  improvable window may
improved particular subplanner within given time bound  noted
domains  e g   pegsol scanalyzer  subplanners require  average  time
find lower cost plan 
developed set window ranking policies examining structural properties
generated candidate windows generated results first experiment  cf 
section      ran two subplanners  ibcs pngs  generated window
   second time limit  excluding windows whose cost already shown
optimal admissible lm cut heuristic  helmert   domshlak         investigating
properties improved unimproved windows  identified four metrics work
relatively well across domains 
   

ficontinuing plan quality optimisation

    
random ranking
outgoing causal links per length  min max 
incoming causal links per length  min max 
pairwise ordering disagreement  min max 
gap cost   admissible heuristic  max min 

fraction improvable windows selected windows



    

   

    

    

    

    






























   

   

   

   

   

   

   

   

   

   

   

   

   

  

  

  

   

number selected  top ranked  windows

figure     fraction improvable windows  across domains  selected top
windows ranked orders generated ranking policies  see text  

    total number causal links whose producers reside window whose consumers outside window  divided length window lower
value higher rank  call property outgoing causal links per length 
    total number causal links whose consumers reside window whose producers outside window  divided length window lower
value higher rank  call property incoming causal links per length 
    gap cost window lower bound cost plan
corresponding subproblem given admissible heuristic higher value
higher rank 
    number pairwise ordering  of steps  disagreements window hp  w  qi
sequential input plan lower value higher rank  calculate
first take linearisation hp  w  qi used generate corresponding
subproblem  then  every pair plan steps  ordering
linearisation input plan call pairwise ordering
disagreement  lower total number disagreements window 
higher rank  words  ordering steps window different
input plan less likely improved 

   

fisiddiqui   haslum

    
fraction improvable windows selected windows

random ranking
outgoing causal links per length  min max 
incoming causal links per length  min max 
pairwise ordering disagreement  min max 
gap cost   admissible heuristic  max min 



    
   
    
    
    
    
   
    
    
    
    












   

















    




    
    
    

   

   

   

   

   

   

   

   

   

   

   

   

   

  

  

  

   

number selected  top ranked  windows

figure     fraction improvable windows parking domain  selected top
windows ranked orders generated ranking policies  see text  

infer first two ranking policies disconnected window
blocks decomposed plan likely improved  figure   
compares ranking policies performance random ordering windows 
average across domains  four ranking policies good picking improvable
windows  example  take top    windows order generated
incoming causal links per length policy  nearly     windows improvable  by
least one subplanner   top    windows random order contain
    improvable windows  random ranking figure    best result three
separate random rankings values x axis  expected  exhibits
roughly ratio improvable windows ranges  from          nearly    
selected windows  across domains  improvable  however  performance
individual ranking policies varies domain  policy find domain
good  example  figure    shows ranking results instances
parking domain only  here  outgoing causal links per length policy work
well  considering top    windows ranked order  even worse random 
however  ranking policies quite beneficial domain 
bdpo  uses first three ranking policies sequential portfolio  as explained
section     subplanner  bdpo  uses current ranking policy select next
   

ficontinuing plan quality optimisation

     

average quality score  relative ipc quality score   coverage 

     
     
     



     



     












     





     








     





     





     




     





     




     





     


     




     

bdpo   rankbased 
bdpo   randomranked 
 

   

 

   

 

   

 

   

 

   

 

   

 



time  hours 

figure     average ipc plan quality score function time two separate runs 
without window ranking  second case  order candidate windows
randomised  run done using experimental setup    described section    
page      time shown runtime bdpo   excluding   hour delay
generating input plans  shown figure      also  y axis truncated 
curves start average quality score input plans        

window chosen subplanner  from eligible optimisation subplanner  
improvement found subplanner certain number attempts     
current configuration   system switches different ranking policy  produce different
ordering candidate windows subplanner 
use window ranking beneficial effect anytime performance
plan improvement process  shown figure     achieve higher quality scores 
particular  achieve faster  using window ranking compared random ranking 
experiment  ran bdpo  portfolio ranking policies  described
   

fisiddiqui   haslum

above  windows chosen optimisation random order  experiment
used setup experiment    described section     page      
tried many alternative methods combining ordered lists generated different
ranking policies  order achieve ranking stable performance across domains 
problem combining rankings  often called rank aggregation  studied many
disciplines  social choice theory  sports competitions  machine learning  information retrieval  database middleware  on  rank aggregation techniques range
quite simple  based rank average number pairwise wins  complex procedures
require solving optimisation problem  tried five simple popular rank aggregation techniques  namely bordas        method  kemenys        optimal
ordering  copelands        majority graph  mc   dwork  kumar  naor    sivakumar 
       multivariate spearmans rho  bedo   ong         result experiments  however  rank aggregation produce better  stable  window
rankings  especially cases one individual policy relatively bad  hence choice
using ranking policies cyclic portfolio instead 

   on line adaptation
lns approach optimisation repeatedly solving local subproblems gives us
opportunity adapting process on line current problem  noted
different subplanners  windowing strategies  ranking policies work better different
domains  example  figure    shows fraction local improvements found
three subplanners different domains  seen  ibcs subplanner
productive  compared pngs lama  appn  barman  maintenance  parking 
sokoban  woodworking domains  pngs  hand  better scanalyzer
visitall domains  lama elevators openstacks domains  therefore 
learn course local search relative success rate different subplanners
current problem  system perform better  similar fashion  window
generation strategies ranking policies may adapted current problem 
system likely select subplans optimisation improvable 
use on line machine learning technique multi armed bandit  mab  model 
specific select subplanner local optimisation attempt  technique  impact anytime performance bpo  described following
subsections 
window selection  on line adaptation limited switching alternative
ranking policies  window selected optimisation subplanner top one
order given current ranking policy subplanner  cf  section      
long improvements found among windows  consider current
policy useful  subplanner reaches certain number attempts
improvements found  switch using next policy subplanner  number
windows neighbourhood optimised typically small compared
number candidate windows generated  average across problems experiment  
 cf  section     page      optimisation least one subplanner tried      
generated windows  this  adapting ranking policy influence
   

ficontinuing plan quality optimisation

figure     percentage improved windows found subplanners  pngs 
ibcs  lama   total number improved windows found subplanners  experiment  bdpo  run three times  time one subplanner 
setup experiment    described section     page      

windows tried adapting windowing strategies  effect adaptive
window ranking anytime performance bdpo  shown figure     page      
    bandit learning
multi armed bandit  mab  model popular machine learning formulation dealing
exploration versus exploitation dilemma  mab problem  algorithm
presented sequence trials  round  algorithm chooses one set
alternatives  often called arms  based past history  receives reward
choice  goal maximise total reward time  bandit learning algorithm
balances exploiting arms highest observed average reward exploring poorly
understood arms discover yield better reward 
mab found numerous applications diverse fields  e g   control  economics  statistics  learning theory  influential paper robbins         many policies
proposed mab problem different assumptions  example  independent  auer et al         dependent arms  pandey  chakrabarti    agarwal        
exponentially infinitely many arms  wang  audibert    munos         finite infinite
time horizon  jones   gittins         without contextual information  slivkins 
       on 
cast problem selecting subplanner local optimisation attempt
multi armed bandit problem  goal maximise total number improved
windows time  use learning algorithm based optimistic exploration strategy  chooses arm favorable environments high probability
best  given observed far  strategy often called optimism
face uncertainty  trial t  arm k  strategy use past
observations probabilistic argument define high probability confidence intervals
expected reward k   favorable environment arm k thus upper
   

fisiddiqui   haslum

confidence bound  ucb  k   simple policy based strategy play arm
highest ucb 
number algorithms developed optimistic exploration bandit arms 
ucb   ucb  ucb  normal auer et al          ucb v audibert 
munos szepesvari         kl ucb garivier cappe         use
ucb  algorithm planner selection  ucb  algorithm
selects trial arm
q
  ln
highest upper confidence bound bk t  
bk t  
nk   sum exploitation term
exploration term  respectively 
bk t empirical mean rewards received
arm k

trial
t 

n


number
times arm k tried far 
k
q
  ln
second term 
nk   confidence interval average reward  within true
expected reward falls almost certain probability  hence  bk t upper confidence
bound  ucb  algorithm achieve logarithmic regret uniformly number
trials without preliminary knowledge reward distributions  auer et al  
      
applied subplanner selection bdpo   algorithm works follows  first 
select subplanner p once  initialise average reward
bp   optimisation
attempt  give reward   chosen subplanner found improvement
reward   otherwise  could use scheme assigning rewards rather
simply      example  making reward proportional amount improvement
 or time taken find it   however  observed assigning varying rewards
subplanners makes bandit learning system complicated  help
achieving better overall result  next  select
q attempt subplanner p
maximises upper confidence bound p  bp t  
bp    nlnp   explained above  here 
np number times p tried far  total number optimisation
attempts  by subplanners  done far  see bp t grows shrinks
np increase uniformly  ensures alternative tried infinitely often
still balances exploration exploitation  words  try p 
smaller size confidence interval closer gets mean value
bp  

p cannot tried becomes smaller p   p planner best
average reward 
    impact bandit learning
response bandit policy subplanner selection shown figure     figure
shows fraction total number optimisation attempts one subplanner  ibcs 
selected  fraction total number window improvements found
subplanner  since bdpo  experiment uses two subplanners  ibcs pngs 
corresponding fraction pngs   y  example  third problem  from
left  appn domain       window improvements found ibcs 
bandit policy selects subplanner     total number optimisation attempts 
pngs chosen      finds improvement  see bandit
policy selects promising subplanner often across problems  however 
bandit policy somewhat conservative  ensures rule
subplanners fare poorly early on  moreover  current plan improved
   

ficontinuing plan quality optimisation

 
improvement ratio
exploitation ratio



   
exploitation improvement ratio ibcs



   
   




   
   

























































   



   














   
   

woodworking

visitall

transport

thoughtful

tetris

sokoban

parking

scanalyzer

parcprinter

nomystery

maintenance

hiking

ged

floortile

elevators

childsnack

barman

appn

 

figure     response bandit policy subplanner success rates  exploitation
ratio fraction total number optimisation attempts ibcs
subplanner chosen  total number attempts subplanners 
improvement ratio fraction total number improved windows found ibcs 
total number improved windows found subplanners  since ibcs
pngs two subplanners used experiment  corresponding ratios
pngs opposite  i e     y   experiment run setup
experiment    described section     page     

becomes harder find improvements  within given time bound   average
reward subplanners decreases  forces bandit policy switch
subplanners often 
figure    shows impact combining subplanners using ucb  bandit policy 
compared simply alternating subplanners using subplanner alone 
anytime performance bdpo   experiment ran bdpo  ibcs 
pngs lama subplanner  combining two  ibcs pngs 
using simple alternation policy  selects two turn  combining
two using bandit policy  run done experiment setup    as described
section     page       i e   input plans high quality   the ipc plan quality
score plan calculated before  see page       average score input
plans         expected  combining ibcs pngs subplanners fashion
leads quality improvement across entire time scale achieved running
bdpo  individual subplanner  figure shows combining multiple
subplanners using bandit policy better strategy simply alternating
   

fisiddiqui   haslum

     

average quality score  relative ipc quality score   coverage 

     




















     






















     















     






     







     




     


     




     



















































     

bdpo   pngs ibcs  bandit 
bdpo   pngs ibcs  alternating 
bdpo   pngs only 
bdpo   ibcs only 
bdpo   lama only 









     


 

   

 

   

 

   

 

   

 

   

 

   

 

     

time  hours 

figure     average ipc quality score function time per problem five different
runs bdpo   using one three subplanners  using two  ibcs
pngs  combined ucb  bandit policy  without  using simple alternation
instead   experiment run setup   described section      on page      
note y axis truncated  curves start average quality input plans 
       time shown runtime bdpo  only  excluding   hour
delay generating input plans shown figure     

   

ficontinuing plan quality optimisation

them  total quality improvement achieved bdpo  using alternation policy
     less bdpo  using bandit policy 

   related work
survey four areas related work  anytime search algorithms post processing approaches  common approach aim continuing plan quality
improvement  uses local search planning  finally  uses algorithm portfolios
planning 
    anytime search
large state space search problems  kind frequently arise planning problems 
often cannot solved optimally optimal search algorithms exhaust memory
finding solution  anytime search algorithms try deal problems finding
first solution quickly  possibly using greedy suboptimal heuristic search  continue
 or restart  searching better quality solution  anytime algorithms attractive allow users stop computation time  i e   good enough solution
found  long wait  contrasts algorithms require
user decide advance deadline  suboptimality bound  parameter
fixes trade off time solution qualty 
bounded suboptimal search problem finding solution cost less
equal user specified factor w optimal  weighted a   wa   search  pohl       
explicit estimation search  ees   thayer   ruml        two algorithms
kind used planning  iteratively applying bounded suboptimal
search algorithm lower value w whenever new best solution found provides
anytime improvement plan quality  restarting wa   richter et al         this  using
schedule decreasing weights  rwa  used lama planner  richter   westphal 
      lama finds first plan using greedy best first search  bonet   geffner        
uses several search enhancements  preferred operators deferred evaluation
 richter   helmert         ees conducts bounded suboptimal best first search restricted
expanding nodes may lead solution cost given factor w
times optimal  among open nodes set  expands one estimated
fewest remaining actions goal  uses admissible heuristic plan
cost informative inadmissible estimates guide search  aees  thayer
et al       b  anytime version ees  achieve anytime behavior  aees lowers
value w whenever new best solution found 
bounded cost search  stern  puzis    felner        problem  subproblems solved approach example  requires finding solution cost less
equal user specified cost bound c  aim bounded cost search algorithm find solution quickly possible  iteratively applying bounded cost
search algorithm bound less cost best solution found far provides
anytime quality improvement  ibcs algorithm  used one subplanners bdpo   does  bees beeps algorithms  thayer  stern  felner   
ruml      a  adapt ees setting bounded cost search  algorithms expand
   

fisiddiqui   haslum

best open node among whose inadmissible cost estimate c  falling back
expanding node best admissible estimate set empty 
branch and bound algorithms explore search space systematic fashion  using
admissible heuristic  lower bound cost  prune nodes cannot lead solution
better best found far  branch and bound implemented linearmemory  depth first search strategy well top strategies  experiment
reported section      page      used beam stack search  bss   zhou   hansen 
      bounded cost search algorithm providing initial upper bound cost
base plan problem  bss combines backtracking branch and bound beam
search  behaves breadth first search limits size open list
layer user specified parameter  known beam width  forced backtrack 
bss reconstructs nodes pruned open list search complete  beam
width parameter used control memory consumption bss never
exceeds available memory  planning problems  however  whose state spaces often
dense transpositions accurate admissible heuristics expensive compute 
repeatedly reconstructing paths unexplored nodes becomes time consuming 
anytime search planners aim provide continuing improvement plan quality given
time  often succeed early stages search  however 
observed results experiments  algorithms often stagnate  reaching
point find better plans even several hours cpu time   cf 
figure    page     section     page       example  experiment lama
aees found better plans            respectively  total number
problems   hours   hours cpu time  bdpo  found better plans
      problems time interval  memory one limiting factor 
one  almost half problems  aees ran full   hours cpu time
without running memory  yet found improved plans  bss found plans
cost less initial upper bound  the cost base plans        
problems even    hours cpu time per problem 
    local search
local search explores space searching small neighbourhood current element
search space one is  way  better  moving neighbour
repeating process  compared systematic search algorithms  advantage local
search needs much less memory  therefore  local search algorithms widely
used solve hard optimisation problems  however  local search algorithms cannot offer
guarantees global optimality  bounded suboptimality  planning  local search
used mainly find plans quickly  rarely improve plan quality  though
post processing methods discussed next section viewed local searches 
 hoffmann   nebel        forward chaining heuristic state space search planner 
heuristic used estimates distance state nearest goal state 
uses local search strategy  called enforced hill climbing  state uses breadthfirst search find neighbour state  which may several steps away current
state  strictly better heuristic value  i e   believed closer goal 
commits state starts new search neighbour better yet
   

ficontinuing plan quality optimisation

heuristic value  local search fails  due getting trapped dead end  falls back
complete best first search algorithm  rw ls planning algorithm  xie  nakhost 
  muller        similar ffs hill climbing approach  uses combination greedy
best first search exploration random walks find better next state local
search step  nakhost muller        developed planning system  called arvand 
uses random walk based local exploration conjunction search heuristic 
showed arvand outperforms hard problems many domains  execution
arvand consists series search episodes  episode starts set random
walks initial state  endpoint random walk evaluated using
heuristic function choose next state  search episode continues set
random walks state  process repeats either goal reached 
enough transitions made without heuristic progress  case process
restarted  ipc           versions arvand apply post processing improve
quality generated plan  post processing techniques action elimination
plan neighborhood graph search  nakhost   muller         discussed next
subsection  arvands search randomised  system continue generating
alternative plans  optmised  indefinitely  storing times best plan
generated far  provides certain anytime capability  manner
used experiment reported section     page     
lpg planner  gerevini   serina        based local search space
action graphs  represent partial plans  neighbourhood defined operators
modify action graph  inserting removing actions  function
evaluates nodes neighbourhood combines terms estimate far action
graph becoming valid plan  termed search cost  expected quality
plan may become  choice neighbour move involves element
randomness  lpg performs continuing search better plans  this  similar
anytime search algorithms discussed last subsection  whenever finds plan 
local search restarts partial plan obtained removing randomly selected
actions current plan  numerical constraint forcing cost next plan
lower added  provides guidance towards better quality next plan 
close relationship local search approaches planning plan repair
adaptation methods  garrido  guzman    onaindia         lpg planner originated
method plan repair  gerevini   serina         iterative repair methods
used plan generation  chien  knight  stechert  sherwood    rabideau        
key difference use local search previous uses planning
carry local search space valid plans  permits neighbourhood
evaluation focus exclusively plan quality  searching space partial plans  represented states  done ff  incomplete  invalid  plans  done lpg  requires
neighbourhood evaluation consider close element becoming valid plan 
balancing quality 
large neighbourhood search  lns  strategy formulates problem finding
good neighbor optimisation problem  rather simply enumerating evaluating
neighbours  allows much larger neighbourhood considered  lns used
successfully solve hard combinatorial optimisation problems vehicle routing
time windows  shaw        scheduling  godard  laborie    nuijten         theoretical
   

fisiddiqui   haslum

experimental studies shown increased neighborhood size may improve
effectiveness  quality solutions  local search algorithms  ahuja  goodstein  mukherjee 
orlin    sharma         neighbourhood current solution small
difficult escape local minima  case  additional meta heuristic techniques 
simulated annealing tabu search  may needed escape local minimum 
lns  size neighborhood may sufficient allow search process
avoid escape local minima 
lns literature  neighborhood solution usually defined set
solutions reached applying destroy heuristic repair method 
destroy heuristic selects part current solution removed  unassigned  
repair method rebuilds destroyed part  keeping rest current solution
fixed  destroy heuristic often includes element randomness  enabling search
explore modifications different parts current solution  role destroy
heuristic system played windowing strategies  select candidate windows  subplans  re optimisation  explore windows systematically  lns
algorithms  e g   ropke   pisinger        schrimpf et al         allow local search
move neighbouring solution lower quality  e g   using simulated annealing  
consider strictly improving moves  however  difference previous lns algorithms 
immediately move better plan restart neighbourhood exploration
local improvement found  instead  use delayed restarting  allows better
solution found one local search step destroying repairing multiple parts
current plan  experimentally  found delayed restarting produces better quality
plans  produces faster  immediate restarts  cf  section     page      
    plan post processing
post processing method  mean one takes valid plan input attempts
improve it  making modifications  related plan repair adaptation
 chien et al         fox  gerevini  long    serina        garrido et al         
key difference plan repair adaptation starts plan valid
current situation focuses making work  discrepancy current
state goals plan originally built provide guidance repairs
needed  contrast  post processing plan optimisation may require modifications
anywhere current plan 
nakhost muller        proposed two post processing techniques action elimination  ae  plan neighborhood graph search  pngs   action elimination identifies
removes unnecessary actions given plan  pngs constructs plan neighborhood graph  subgraph state space problem  built around
path state space induced current plan expanding limited number
states state path  searches least cost plan subgraph 
finds plan better current  process repeated around new best
plan  otherwise  exploration limit increased  time memory limit exceeded 
furcys        iterative tunneling search a   itsa   similar pngs  itsa 
explores area  called tunnel  state space using a  search  restricted fixed
distance current plan  methods seen creating neighborhood
   

ficontinuing plan quality optimisation

includes small deviations current plan  anywhere along plan 
contrast  bdpo  focuses one section decomposed plan time  often grouping
together different parts input plan  puts restriction much section
changes  hence  creates different neighbourhood  experiments show best
results obtained exploring neighbourhoods  example  pngs often finds
plan improvements quickly  running additional   hours improves average
ipc plan quality score  best plans finds first hour        
running instead bdpo   using pngs subplanner taking best plans
found pngs   hour input  improves average plan quality score     
hours 
ratner pohl        used local optimisation shortening solutions sequential
search problems  select subpath optimise  used sliding window predefined size dmax consecutive segments current path  estrem krebsbach
       instead used form windowing heuristic  select local optimisation pairs
states current path maximise estimate redundancy  based ratio
estimated distances two states  given state space heuristic 
cost current path  balyo  bartak surynek        used sliding window
approach minimise parallel plan length  that is  makespan  assuming actions
unit duration   rather take segments single path state space  use block
deordering input plan create candidate windows local optimisation  shown
experimental results  important success bdpo   total
improvement average plan quality achieved without deordering       less
achieved bdpo  using block deordering input plans  cf  section     page      
planning by rewriting approach  ambite   knoblock        uses local modifications partially ordered plans improve quality  plan modifications defined
domain specific rewrite rules  provided domain designer learned
many examples good bad plans  hence  technique effective
solving many problem instances domain  using planner solve subproblems may time consuming applying pre defined rules  makes process
automatic  however  consider solving many problems domain may
possible reduce average planning time learning  generalised  rules subplan
improvements discover using applicable avoid invoking subplanner 
    portfolio planning automatic parameter tuning
portfolio planning system runs several subplanners sequence  or parallel  short
timeouts  hope least one component planners find solution
time allotted it  portfolio planning systems motivated observations
single planner dominates others domains  planner solve
planning task quickly  often solve all  therefore  many todays
successful planners run sequential portfolio planners  coles  coles  olaya  celorrio 
linares lopez  sanner    yoon        
gerevini  saetti vallati        introduced pbp planner  learns portfolio
given set planners specific domain  well domain specific macro actions 
fast downward stone soup  fdss  helmert  roger  seipp  karpas  hoffmann  keyder 
   

fisiddiqui   haslum

nissim  richter    westphal        uses fixed portfolio  computed optimise performance
large sample training domains  domains  ibacop   cenamor et al        
dynamically configures portfolio using predictive model planner success 
another recent trend use automatic algorithm configuration tools 
paramils framework  hutter  hoos  leyton brown    stutzle         enhance planner
performance specific domain  paramils local search space configurations  using suite training problems evaluate performance different parameter
settings  combinatorial explosion caused many parameters many different values managed varying one parameter time  paramils used configure
lpg planner  vallati  fawcett  gerevini  hoos    saetti        fast downward planner  fawcett  helmert  hoos  karpas  roger    seipp         pbp  portfolio
planner  gerevini  saetti    vallati         successor pbp  includes version lpg
customised domain paramils learned portfolio 
bdpo   course  uses portfolio subplanners  and  shown  selecting
right subplanner current problem important  cf  section     much important 
however  focus subproblems approach brings  comparing figures     page
         page       clear using even single subplanner within bdpo 
effective using subplanners own  multiple window ranking
policies used bdpo   cf  section      viewed simple sequential portfolio 
compared previous portfolio planners  iterated use subplanners  windowing strategies components approach offers possibility learn best portfolio
configuration on line  is  rather spend time configuring system using
training problems  learn experience solving several subproblems 
actually working optimising current plan 
finally  although explored great depth  results suggest combining different anytime search post processing methods  effectively kind
sequential portfolio  such running bdpo  result running pngs result
lama ibacop   results experiment    shown figure   page      
often achieves better quality final plans investing available time single
method 

   conclusions future work
plan quality optimisation  particularly large problems  central concern automated
planning  anytime planning  aims deliver continuing stream better plans
given time  attractive idea  offering flexibility stop process
point  best plan found good enough wait next plan
becomes long  presented approach anytime plan improvement 
realisation bdpo  system  approach based large neighbourhood local
search strategy  shaw         using windowing heuristics select candidate windows
block deordering current plan  local optimisation using off the shelf bounded cost
planning techniques 
experiments demonstrate bdpo  achieves continuing plan quality improvement
even large time scales  several hours cpu time   anytime planners stagnate 
key achieving focus optimising subproblems  corresponding windows 
   

ficontinuing plan quality optimisation

mentioned section      extending windowing heuristics improving on line
learning effective window rankings one way improve approach  also  complementing window ranking  estimates promising window is 
estimate difficult windows optimise  using inform time allocated subplanners  currently uniform windows  may contribute better
performance  best result  however  achieved chaining several techniques together
 for example  applying bdpo  best plan found pngs applied best plan
found lama ibacop    result cannot achieved previous anytime planning approaches alone  thus  another area future work examine greater
depth best way combine different plan improvement methods 
learned on line optimising plan  example  conducted study
optimal time switch base plan generation  using lama  post processing
using pngs bdpo  function total runtime  siddiqui   haslum      a  
demonstrated experimentally  block deordering step essential
good performance bdpo   cf  section     page       block deordering creates
decomposition plan non interleaving blocks removing ordering constraints
blocks  lifts limitation conventional  step wise  deordering 
requires unordered steps plan non interfering  shown  validity
condition block decomposed partially ordered plans stated almost
chapmans        modal truth criterion  allowing threats causal link
remain unordered long link protected block structure  theorem  
page       therefore  block deordering yield less order constrained plans  including
cases conventional deordering possible 
plan structure uncovered block decomposition uses  recently used planner independent macro generation system bloma  chrpa  
siddiqui        find longer macros capture compound activities order improve
planners coverage efficiency  domains  e g   barman  childsnack  scanalyzer 
parcprinter  gripper  woodworking  etc    block deordering often identifies structurally similar subplans  symmetric improvement patterns  could potentially
exploited learning plan rewrite rules  ambite  knoblock    minton         structure
block deordered plans  often comprises nested  hierarchical decomposition
meaningful subplans  reminiscent hierarchical task network  htn  representations 
hence  block deordering technique could potentially applied generating  or helping
generate  htn structures domain independent way  reducing knowledge engineering
effort  recent work scala torasso        extends deordering plans planning
domains numeric state variables  identifying numeric dependencies capture
additional reasons necessary orderings  defining conditions blocks sufficient
encapsulate dependencies would allow block deordering numeric plans 
may synergy block deordering numeric planning  since numeric dependencies often involve groups plan steps  rather single producerconsumer pair 
acknowledgment
work partially supported australian research council discovery project
dp          robust ai planning hybrid systems  nicta funded aus   

fisiddiqui   haslum

tralian government department communications australian research council ict centre excellence program 

references
ahuja  r  k   goodstein  j   mukherjee  a   orlin  j  b     sharma  d         
large scale neighborhood search algorithm combined through fleet assignment
model  informs journal computing                 
ambite  j  l     knoblock  c  a          planning rewriting  journal artificial
intelligence research  jair                  
ambite  j  l   knoblock  c  a     minton  s          learning plan rewriting rules 
proc   th international conference artificial intelligence planning systems 
aips       breckenridge  co  usa  april              pp       aaai press 
audibert  j  y   munos  r     szepesvari  c          explorationexploitation tradeoff using
variance estimates multi armed bandits  theoretical computer science           
         
auer  p   cesa bianchi  n     fischer  p          finite time analysis multiarmed
bandit problem  machine learning                   
backstrom  c          computational aspects reordering plans  journal artificial
intelligence research  jair            
balyo  t   bartak  r     surynek  p          improving plan quality via local enhancements  proc   th international symposium combinatorial search  socs
      niagara falls  canada  july              aaai press 
bedo  j     ong  c  s          multivariate spearmans rho aggregating ranks using
copulas  corr  abs           
bonet  b     geffner  h          planning heuristic search  artificial intelligence                
cenamor  i   de la rosa  t     fernandez  f          ibacop ibacop  planners 
proc   th international planning competition  ipc       deterministic part 
pp       
chapman  d          planning conjunctive goals  artificial intelligence                 
chien  s   knight  r   stechert  a   sherwood  r     rabideau  g          using iterative
repair improve responsiveness planning scheduling  proc 
 th international conference artificial intelligence planning systems  aips      
breckenridge  co  usa  april              pp          aaai press 
chrpa  l     siddiqui  f  h          exploiting block deordering improving planners efficiency  proc    th international joint conference artificial intelligence 
ijcai       buenos aires  argentina  july              pp            aaai press 
coles  a  j   coles  a   olaya  a  g   celorrio  s  j   linares lopez  c   sanner  s     yoon 
s          survey seventh international planning competition  ai magazine 
             
   

ficontinuing plan quality optimisation

copeland  a  h          reasonable social welfare function  university michigan
seminar applications mathematics social sciences 
de borda  j  c          memory election ballot  history royal academy
sciences  paris         
dwork  c   kumar  r   naor  m     sivakumar  d          rank aggregation methods
web  proc    th international conference world wide web  www
      hong kong  may            pp          new york  ny  usa  acm 
estrem  s  j     krebsbach  k  d          airs  anytime iterative refinement solution  proc    th international florida artificial intelligence research society
conference  marco island  florida  may             
fawcett  c   helmert  m   hoos  h   karpas  e   roger  g     seipp  j          fd autotune 
domain specific configuration using fast downward  proc       icaps
workshop planning learning  pal       freiburg  germany  june       
      pp        aaai press 
fox  m   gerevini  a   long  d     serina  i          plan stability  replanning versus plan
repair  proc    th international conference automated planning
scheduling  icaps       cumbria  uk  june              pp          aaai press 
furcy  d          itsa   iterative tunneling search a   proc       aaai
workshop heuristic search  memory based heuristics applications 
july             boston  massachusetts  pp        aaai press 
garivier  a     cappe  o          kl ucb algorithm bounded stochastic bandits
beyond  corr  abs           
garrido  a   guzman  c     onaindia  e          anytime plan adaptation continuous
planning  proc  joint   th workshop uk special interest group
planning scheduling  th italian workshop planning scheduling  pp 
     
gerevini  a   saetti  a     vallati  m          automatically configurable portfolio based
planner macro actions  pbp  proc    th international conference
automated planning scheduling  icaps       thessaloniki  greece  september
             pp          aaai press 
gerevini  a   saetti  a     vallati  m          pbp   automatic configuration portfoliobased multi planner   th international planning competition  ipc        learning
track  http   www plg inf uc m es ipc     learning 
gerevini  a     serina  i          lpg  planner based local search planning graphs
action costs  proc   th international conference artificial intelligence
planning scheduling  aips       april              toulouse  france  pp     
     aaai press 
gerevini  a  e     serina  i          fast plan adaptation planning graphs  local
systematic search techniques  proc   th international conference
artificial intelligence planning systems  aips       breckenridge  co  usa  april
             pp          aaai press 
   

fisiddiqui   haslum

ghallab  m   nau  d  s     traverso  p          automated planning  theory   practice 
morgan kaufmann publishers inc   san francisco  ca  usa 
godard  d   laborie  p     nuijten  w          randomized large neighborhood search
cumulative scheduling  proc    th international conference automated
planning scheduling  icaps       monterey  california  usa  june           
pp        aaai press 
haslum  p          computing genome edit distances using domain independent planning 
proc       icaps workshop scheduling planning applications 
spark       freiburg  germany  june              aaai press 
haslum  p          incremental lower bounds additive cost planning problems  proc 
  nd international conference automated planning scheduling  icaps
      atibaia  sao paulo  brazil  june              pp        aaai press 
haslum  p     grastien  a          diagnosis planning  two case studies  proc 
     icaps workshop scheduling planning applications  spark      
freiburg  germany  june              aaai press 
haslum  p     jonsson  p          planning reduced operator sets  proc 
 th international conference artificial intelligence planning systems  aips      
breckenridge  co  usa  april              pp          aaai press 
helmert  m   roger  g   seipp  j   karpas  e   hoffmann  j   keyder  e   nissim  r   richter 
s     westphal  m          fast downward stone soup  planner abstract  
proc   th international planning competition  ipc       deterministic part 
http   www plg inf uc m es ipc     deterministic 
helmert  m     domshlak  c          landmarks  critical paths abstractions  whats
difference anyway   proc    th international conference automated
planning scheduling  icaps       thessaloniki  greece  september             
pp          aaai press 
hoffmann  j          local search topology planning benchmarks  empirical analysis 
proc    th international joint conference artificial intelligence  ijcai
      seattle  washington  usa  august             pp          san francisco  ca 
usa  morgan kaufmann publishers inc 
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research  jair              
hutter  f   hoos  h  h   leyton brown  k     stutzle  t          paramils  automatic
algorithm configuration framework  journal artificial intelligence research  jair  
               
jones  d  m     gittins  j          dynamic allocation index sequential design
experiments  university cambridge  department engineering 
kambhampati  s     kedar  s          unified framework explanation based generalization partially ordered partially instantiated plans  artificial intelligence 
             
   

ficontinuing plan quality optimisation

mcallester  d     rosenblitt  d          systematic nonlinear planning  proc   th
national conference artificial intelligence  aaai       anaheim  ca  usa  july
             volume     pp          aaai press   mit press 
muise  c  j   mcilraith  s  a     beck  j  c          optimally relaxing partial order plans
maxsat  proc    nd international conference automated planning
scheduling  icaps       atibaia  sao paulo  brazil  june              pp     
     aaai press 
nakhost  h     muller  m          monte carlo exploration deterministic planning 
proc    st international joint conference artificial intelligence  ijcai
      pasadena  california  usa  july              vol     pp           
nakhost  h     muller  m          action elimination plan neighborhood graph search 
two algorithms plan improvement  proc    th international conference
automated planning scheduling  icaps       toronto  canada  may       
      pp          aaai press 
nebel  b     backstrom  c          computational complexity temporal projection  planning  plan validation  artificial intelligence                 
pandey  s   chakrabarti  d     agarwal  d          multi armed bandit problems
dependent arms  proc    th international conference machine learning 
icml       corvallis  oregon  usa  june              vol       pp          acm 
pednault  e  p  d          formulating multiagent  dynamic world problems classical
planning framework  reasoning actions plans       
pohl  i          heuristic search viewed path finding graph  artificial intelligence 
              
ratner  d     pohl  i          joint lpa   combination approximation search 
proc   th national conference artificial intelligence  aaai       philadelphia  pa  august              volume    science   pp          morgan kaufmann 
regnier  p     fade  b          complete determination parallel actions temporal
optimization linear plans action  proc  european workshop planning 
ewsp       sankt augustin  frg  march              vol      lecture notes
computer science  pp          springer 
richter  s     helmert  m          preferred operators deferred evaluation satisficing
planning  proc    th international conference automated planning
scheduling  icaps       thessaloniki  greece  september              pp         
aaai press 
richter  s   thayer  j  t     ruml  w          joy forgetting  faster anytime search
via restarting  proc    th international conference automated planning
scheduling  icaps       toronto  canada  may              pp          aaai
press 
richter  s     westphal  m          lama planner  guiding cost based anytime
planning landmarks  journal artificial intelligence research  jair          
    
   

fisiddiqui   haslum

robbins  h          aspects sequential design experiments  herbert
robbins selected papers  vol      pp          springer 
ropke  s     pisinger  d          adaptive large neighborhood search heuristic
pickup delivery problem time windows  transportation science         
       
scala  e     torasso  p          deordering numeric macro actions plan repair 
proc    th international joint conference artificial intelligence  ijcai
      buenos aires  argentina  july              pp            aaai press 
schrimpf  g   schneider  j   stamm wilbrandt  h     dueck  g          record breaking
optimization results using ruin recreate principle  journal computational
physics                  
shaw  p          using constraint programming local search methods solve vehicle
routing problems  proc   th international conference principles
practice constraint programming  cp         pisa  italy  october             
vol       lecture notes computer science  pp          springer 
siddiqui  f  h     haslum  p          block structured plan deordering  proc    th
australasian joint conference advances artificial intelligence  ai       sydney 
australia  december            vol       lecture notes computer science  pp 
        berlin  heidelberg  springer 
siddiqui  f  h     haslum  p       a   local search space valid plans  proc 
     icaps workshop evolutionary techniques planning scheduling  evops       rome  italy  june              pp        http   icaps   icapsconference org wp content uploads         evops   proceedings pdf 
siddiqui  f  h     haslum  p       b   plan quality optimisation via block decomposition 
proc    rd international joint conference artificial intelligence  ijcai
      beijing  china  august            pp            aaai press 
slivkins  a          contextual bandits similarity information  journal machine
learning research                   
stern  r  t   puzis  r     felner  a          potential search  bounded cost search
algorithm  proc    st international conference automated planning
scheduling  icaps       freiburg  germany june              pp          aaai
press 
thayer  j   stern  r   felner  a     ruml  w       a   faster bounded cost search using
inadmissible heuristics  proc    nd international conference automated
planning scheduling  icaps       atibaia  sao paulo  brazil  june             
pp          aaai press 
thayer  j  t   benton  j     helmert  m       b   better parameter free anytime search
minimizing time solutions  proc   th international symposium
combinatorial search  socs       niagara falls  canada  july              pp 
        aaai press 
   

ficontinuing plan quality optimisation

thayer  j  t     ruml  w          bounded suboptimal search  direct approach using
inadmissible estimates  proc    nd international joint conference artificial intelligence  ijcai       barcelona  catalonia  spain  july              pp 
        aaai press 
vallati  m   fawcett  c   gerevini  a   hoos  h     saetti  a          parlpg  generating domain specific planners automatic parameter configuration lpg 
proc   th international planning competition  ipc       deterministic part 
http   www plg inf uc m es ipc     deterministic 
veloso  m  m   perez  a     carbonell  j  g          nonlinear planning parallel
resource allocation  proc  darpa workshop innovative approaches
planning  scheduling control  san diego  california  november            pp 
        morgan kaufmann 
wang  y   audibert  j     munos  r          algorithms infinitely many armed bandits 
proc    nd annual conference neural information processing systems 
nips       vancouver  british columbia  canada  december             pp      
      curran associates  inc 
xie  f   nakhost  h     muller  m          planning via random walk driven local search 
proc    nd international conference automated planning scheduling 
icaps       atibaia  sao paulo  brazil  june              pp          aaai press 
xie  f   valenzano  r  a     muller  m          better time constrained search via randomization postprocessing  proc    rd international conference
automated planning scheduling  icaps       rome  italy  june             
pp          aaai press 
young  h  p     levenglick  a          consistent extension condorcets election principle  siam journal applied mathematics                 
zhou  r     hansen  e  a          beam stack search  integrating backtracking beam
search  proc    th international conference automated planning
scheduling  icaps       monterey  california  usa  june             pp       
aaai press 

   


