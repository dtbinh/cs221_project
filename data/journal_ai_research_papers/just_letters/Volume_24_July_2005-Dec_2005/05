journal artificial intelligence research                  

submitted        published      

binary encodings non binary constraint satisfaction
problems  algorithms experimental results
nikolaos samaras

samaras uom gr

department applied informatics
university macedonia  greece

kostas stergiou

konsterg aegean gr

department information communication systems engineering
university aegean  greece

abstract
non binary constraint satisfaction problem  csp  solved directly using extended versions binary techniques  alternatively  non binary problem translated equivalent binary one  case  generally accepted translated
problem solved applying well established techniques binary csps 
paper evaluate applicability latter approach  demonstrate use
standard techniques binary csps encodings non binary problems problematic
results models rarely competitive non binary representation 
overcome this  propose specialized arc consistency search algorithms binary encodings  evaluate theoretically empirically  consider three
binary representations  hidden variable encoding  dual encoding  double
encoding  theoretical empirical results show that  certain classes non binary
constraints  binary encodings competitive option  many cases  better one
non binary representation 

   introduction
constraint satisfaction problems  csps  appear many real life applications
scheduling  resource allocation  timetabling  vehicle routing  frequency allocation  etc 
csps naturally eciently modelled using non binary  or n ary  constraints
may involve arbitrary number variables  well known non binary csp
converted equivalent binary one  well known translations
dual encoding  dechter   pearl        hidden variable encoding  rossi  petrie   
dhar         ability translate non binary csp binary often used
past justication restricting attention binary csps  implicitly  assumption faced non binary csp simply convert
binary one  apply well known generic techniques solving binary equivalent 
paper show assumption awed generic techniques
binary csps suitable binary encodings non binary problems 
past years  theoretical empirical studies eciency
binary encodings comparisons binary encodings non binary representation  bacchus   van beek        stergiou   walsh        mamoulis   stergiou       
smith        bacchus  chen  van beek    walsh         theoretical results showed
c
    
ai access foundation  rights reserved 

fisamaras   stergiou

converting non binary csps binary equivalents potentially ecient way
solve certain classes non binary problems  however   limited  empirical studies
cases appears true  conways game life  smith 
      notable exception  various reasons this  many cases 
extensive space requirements binary encodings make infeasible  also 
many non binary problems utilize ecient specialized propagators certain constraints  algorithm developed regin        all dierent constraint 
converting constraints binary clearly impractical  another reason 
overlooked   if all  experimental studies use well known generic local
consistency search algorithms encodings  way fail exploit
structure constraints encodings  ending inecient algorithms 
make binary encodings realistic choice modelling solving non binary csps 
need algorithms utilize structural properties  finally  important point
use binary encoding necessarily mean convert
non binary constraints problem binary  commonly perceived 
selective constraints encode  based properties arity tightness 
get ecient hybrid models 
address issues  show use specialized arc consistency search
algorithms binary encodings non binary csps lead ecient models  consider three encodings  dual  hidden variable  double encoding  latter 
basically conjunction two encodings  received little attention
may well turn signicant practice  aim study
twofold  first  present ecient algorithms binary encodings analyze
theoretically experimentally  second  importantly  investigate
use algorithms help solve non binary problems eciently  towards
aims  make following contributions 
describe simple algorithm enforces arc consistency hidden variable
encoding arbitrary non binary csp o ekdk   time complexity  e
number constraints  k maximum arity constraints 
maximum domain size  gives o d  improvement compared asymptotic
complexity generic arc consistency algorithm  improved complexity
complexity optimal generalized arc consistency algorithm
non binary representation problem  identify property arc
consistency algorithm hidden variable encoding make run faster 
arc inconsistent problems  generalized arc consistency algorithm 
consider search algorithms maintain local consistencies search
hidden variable encoding  show that  maintaining arc consistency 
generalizations forward checking non binary csps emulated
corresponding forward checking algorithms run hidden variable encoding
instantiate original variables  i e  variables initial non binary
problem   show algorithm corresponding algorithm nonbinary constraints following relationships     visit number
search tree nodes     asymptotic cost within polynomial
bound other 
   

fibinary encodings non binary csps  algorithms   experimental results

describe specialized algorithm dual encoding achieves arc consistency
o e  dk   worst case time complexity  signicantly lower o e  d k  
complexity generic arc consistency algorithm  improvement complexity
bound stems observation constraints dual encoding specic
structure  namely piecewise functional  van hentenryck  deville    teng 
       apart applying arc consistency dual encoding non binary
csp  algorithm used specialized ltering algorithm certain
classes non binary constraints 
adapt various search algorithms run double encoding compare
theoretically similar algorithms hidden variable encoding non binary
representation  search algorithms operate double encoding exploit
advantages hidden variable dual encoding  example  show
that  certain conditions  asymptotic cost maintaining arc consistency
algorithm double encoding polynomially worse asymptotic
cost corresponding algorithm non binary representation  and hidden
variable encoding   exponentially better 
finally  make extensive empirical study various domains  consider
random problems well structured ones  crossword puzzle generation  conguration  frequency assignment  study consists two parts  rst
part  give experimental results demonstrate advantages specialized
algorithms binary encodings compared generic algorithms  example 
specialized arc consistency algorithm dual encoding orders magnitude faster generic arc consistency algorithm  second part show
use binary encodings oer signicant benets solving certain classes
non binary csps  example  solving dual encoding conguration
problems orders magnitudes ecient solving non binary
representation  also  empirical results frequency assignment   problems
demonstrate binary encoding benecial even non binary constraints
intentionally specied 

paper structured follows  section   give necessary denitions
background  section   describe specialized arc consistency algorithm hidden
variable encoding  demonstrate extensions forward checking
non binary csps emulated binary forward checking algorithms run
hidden variable encoding  section   explain complexity arc consistency
dual encoding improved describe specialized arc consistency algorithm 
section   discusses algorithms double encoding  section   present experimental
results random structured problems demonstrate usefulness proposed
algorithms  draw conclusions regarding applicability encodings 
based theoretical experimental results  section   discusses related work  finally 
section   conclude 
   

fisamaras   stergiou

   background
section give necessary denitions csps  describe hidden variable 
dual  double encodings non binary csps 
    basic definitions
constraint satisfaction problem  csp   p   dened tuple  x  d  c   where 
x    x            xn   nite set n variables 
   din  x             din  xn    set initial domains  variable xi x 
din  xi   initial nite domain possible values  csp algorithms remove
values domains variables value assignments propagation 
variable xi   denote d xi   current domain xi time consists
values removed din  xi    assume every xi x 
total ordering  d dened din  xi   
c    c            ce   set e constraints  constraint ci
pair  vars ci    rel ci        vars ci      xj            xjk  
x called constraint scheme     rel ci   subset
din  xj   x       xdin  xjk   species allowed combinations
ables vars ci   

c dened
ordered subset
cartesian product
values vari 

size vars ci   called arity constraint ci   constraints arity   called
binary  constraints arity greater   called non binary  or n ary   tuple
rel ci   ordered list values  a            ak   aj din  xj   j              k 
tuple    a            ak   valid aj   j            k  aj d xj    is  tuple valid
values tuple present domains corresponding variables 
process veries whether given tuple allowed constraint ci called
consistency check  constraint either dened extensionally set allowed  or
disallowed  tuples intensionally predicate arithmetic function  binary csp
represented graph  called constraint graph  nodes correspond variables
edges correspond constraints  non binary csp represented constraint
hyper graph constraints correspond hyper edges connecting two nodes 
assignment value variable xi denoted  xi   a   tuple  
 a            ak   viewed set value variable assignments   x    a              xk   ak    
set variables tuple dened denoted vars    
subset vars vars      vars   denotes sub tuple includes assignments
variables vars   two tuples rel ci   ordered lexicographic
ordering  lex   ordering   lex exists subset  x            xj   ci
 x            xj      x            xj    xj      lex  xj      assignment consistent 
constraints ci   vars ci   vars      vars ci    rel ci    solution csp
 x  d  c  consistent assignment variables x  exists solution
given csp  say csp soluble  otherwise  insoluble 
basic way solving csps using backtracking search  seen
traversal search tree comprises possible assignments values variables 
   

fibinary encodings non binary csps  algorithms   experimental results

level tree corresponds variable  node search tree corresponds
tuple  i e  assignment values variables   root tree corresponds
empty tuple  rst level nodes correspond   tuples  an assignment value
one variable   second level nodes correspond   tuples  assignment values two
variables generated extending rst level   tuples  etc  stage search
tree traversal  variables already assigned called past variables 
recently assigned variable called current variable  variables
assigned yet called future variables 
rest paper use notation n number variables
csp  e number constraints problem  maximum domain size
variables  k maximum arity constraints 
      arc consistency
important concept csps concept local consistency  local consistencies
properties applied csp  using  typically  polynomial algorithms  remove
inconsistent values either prior search  arc consistency commonly
used local consistency property existing constraint programming engines 
give denition arc consistency 
definition     value d xj   consistent constraint ci   xj vars ci  
rel ci    xj     valid  case say support
ci   constraint ci arc consistent  ac  variable xj vars ci    d xj   
exists support ci   csp  x  d  c  arc consistent empty
domain constraints c arc consistent 
arc consistency enforced csp removing unsupported values
domains variables  enforcing arc consistency  or local consistency property
general  csp p   mean applying algorithm yields new csp
arc consistent  or property a  set solutions p  
denition arc consistency applies constraints arity  distinguish
binary non binary cases  use term arc consistency  ac  refer
property arc consistency binary constraints only  non binary constraints
use term generalized arc consistency  gac  
usefulness ac processing recognized early  result  various ac
algorithms binary constraints proposed literature  e g  ac   mackworth        ac   mohr   henderson        ac   van hentenryck et al         ac  
bessiere et al         ac      bessiere   regin        ac    zhang   yap        
extended non binary case  e g  gac   mohr   masini 
      gac schema bessiere   regin      a  gac      bessiere   regin        
ac enforced binary csp o ed    optimal worst case time complexity 
worst case complexity enforcing gac non binary csp o ekdk    bessiere   regin 
    a  
paper use algorithms ac      gac      theoretical empirical
comparisons specialized algorithms encodings  restrictive 
sense generic ac  and gac  algorithm used instead 
   

fisamaras   stergiou

following debruyne   bessiere         call local consistency property stronger
b problem enforcing deletes least values b  strictly
stronger stronger least one problem deletes values
b  call equivalent b delete values problems  similarly 
call search algorithm stronger search algorithm b every problem visits
search tree nodes b  strictly stronger stronger
least one problem visits less nodes b  equivalent b visit
nodes problems 
following bacchus et al          asymptotic cost  or cost hereafter  search
algorithm determined worst case number nodes algorithm
visit solve csp  worst case time complexity algorithm node   
paper bacchus et al          use measure set asymptotic bounds
relative performance various algorithms  example  two algorithms
b always visit nodes enforces property node exponentially
higher complexity property enforced b  say algorithm
exponentially greater cost algorithm b 
      functional piecewise functional constraints
specialized ac algorithms hidden variable dual encoding
describe sections     exploit structural properties encodings 
explain detail later  binary constraints hidden variable encoding one way
functional  binary constraints dual encoding piecewise functional 
dene concepts 
definition     binary constraint c  vars c     xi   xj    functional respect
d xi   d xj   d xi    resp  b d xj    exists one value
b d xj    resp  d xi    b support c  resp  support b  
example functional constraint xi   xj   binary constraint one way functional
functionality property holds respect one variables involved
constraint 
informally  piecewise functional constraint variables xi   xj constraint
domains xi xj partitioned groups group d xi  
supported one group d xj    vice versa  give formal denition 
rst dene concept piecewise decomposition 
definition      van hentenryck et al         let c binary constraint vars c   
 xi   xj    partitions    s            sm   d xi      s            sm   d xj  
piecewise decomposition d xi   d xj   respect c sl s sl  
following property holds  either sl   b sl    a  b  rel c   sl   b sl  
 a  b 
  rel c  
   paper bacchus et al         cost applying variable ordering heuristic node
taken account  theoretically compare search algorithms paper assume
use variable ordering  take cost account 

   

fibinary encodings non binary csps  algorithms   experimental results

definition      van hentenryck et al         binary constraint c  vars c   
 xi   xj    piecewise functional respect d xi   d xj   exists piecewise
decomposition    s            sm   d xi      s            sm   d xj   respect
c sl  resp  sl    exists one sl  resp  sl s  
sl   b sl  a  b  rel c  
example piecewise functional constraints modulo  x  mod x    a  integer
division  x  div x    a  constraints 
    binary encodings
two well known methods transforming non binary csp binary one 
dual graph encoding hidden variable encoding  encode non binary
constraints variables domains valid tuples constraints  is 
building binary encoding non binary constraint store extensional representation
constraint  the set allowed tuples   third method double encoding
combines two 
      dual encoding
dual encoding  originally called dual graph encoding  inspired work relational
databases  dual encoding  de   dechter   pearl        variables swapped
constraints vice versa  constraint c original non binary csp represented variable call dual variable denote vc   refer variables
original non binary csp original variables  domain dual variable vc
consists set allowed tuples original constraint c  binary constraints
two dual variables vc vc exist vars c  vars c       is  constraints c
c share one original variables  common vars set original variables
common c c tuple d vc   supported constraint vc
vc exists tuple d vc    common vars     common vars  

v c 

v c 

               

               

       

       

               

               

       

               
v c 

v c 

figure    dual encoding non binary csp 
   

fisamaras   stergiou

consider following example six variables     domains  four constraints 
c    x    x    x       c    x  x    x       c    x    x  x     c    x    x 
x       de represents problem   dual variables  one constraint 
domains dual variables tuples satisfy respective constraint 
example  dual variable vc  associated third constraint domain
                                             tuples values  x    x    x   
satisfy x    x  x     second example  dual variable vc  associated
last constraint domain                                    vc  vc 
compatibility constraint ensure two original variables common  x  x   
values  constraint allows pairs tuples agree
second third elements  i e            vc            vc              vc 
          vc     de problem shown figure   
rest paper  sometimes denote cvi non binary constraint
encoded dual variable vi   original variable xj vars cvi    pos xj   cvi  
denote position xj cvi   instance  given constraint cvi variables x    x    x   
pos x    cvi       
      hidden variable encoding
hidden variable encoding  hve  inspired work philosopher peirce        
according rossi et al          peirce rst showed binary relations
expressive power non binary relations 
hve  rossi et al          set variables consists original variables
non binary csp plus set dual variables  dual encoding  dual
variable vc corresponds constraint c original problem  domain dual
variable consists tuples satisfy original constraint  every dual variable
vc   binary constraint vc original variables xi
xi vars c   tuple d vc   supported constraint vc xi
exists value d xi    xi     a 
consider previous example six variables     domains  four constraints 
c    x    x    x       c    x  x    x       c    x    x  x     c    x    x  x      
hve are  addition original six variables  four dual variables 
de  domains variables tuples satisfy respective constraint 
compatibility constraints dual variable vc original variables
contained constraint c  example  constraints vc  x   
vc  x  vc  x    variables involved constraint c   
compatibility constraint cv  x  relation true rst element
tuple assigned cv  equals value x    hve shown figure   
      double encoding
double encoding  stergiou   walsh        combines hidden variable dual
encoding  hve  set variables double encoding consists
variables original non binary csp plus dual variables  every dual variable
vc   binary constraint vc original variables xi involved
corresponding non binary constraint c  de  binary constraints
   

fibinary encodings non binary csps  algorithms   experimental results

v c 

v c 

               

               

       

       

x     

x     

x     

x     

               

x 

  

x 

  

               

       

               
v c 

v c 

figure    hidden variable encoding non binary csp 
two dual variables vc vc non binary constraints c c share one
original variables 

   algorithms hidden variable encoding
section discuss specialized algorithms hve  rst describe simple
ac algorithm hve worst case time complexity optimal
gac algorithm non binary representation  appendix a  show
arc consistent csp proposed ac algorithm performs exactly number
consistency checks corresponding gac algorithm  arc inconsistent problems
show ac algorithm hve detect inconsistency earlier thus
perform fewer consistency checks gac algorithm 
consider search algorithms hve maintain local consistencies
search  show that  maintaining arc consistency  generalizations forward
checking non binary csps emulated corresponding binary forward checking
algorithms hve instantiate original variables 
    arc consistency
proved ac hve equivalent gac non binary problem
 stergiou   walsh         since hve binary csp  one obvious way apply ac
using generic ac algorithm  however  results redundant processing
asymptotic time complexity worse o ekdk    precise  hve problem
kary constraints ek binary constraints dual original variables 
constraint  ac enforced o ddk   worst case time complexity 
whole problem complexity o ekdk     
instead  describe simple ac algorithm operates hve
achieves worst case time complexity optimal gac algorithm applied
non binary representation  achieve slightly modifying gac algorithm
   

fisamaras   stergiou

bessiere regin         gac        figure   sketch ac algorithm
hve  call hac  hidden ac  
function hac
  
q
  
dual variable vj
  
variable xi xi vars cvj  
  
revise xi   vj     ru e
  
d xi   empty return inconsistency
  
put q dual variable vl xi vars cvl  
  
return p ropagation
function p ropagation
  
q empty
  
pop dual variable vj q
   
unassigned variable xi xi vars cvj  
   
revise xi   vj     ru e
   
d xi   empty return inconsistency
   
put q dual variable vl xi vars cvl  
    return consistency
function revise xi   vj  
    deletion false
   
value d xi  
   
currentsupportxi a vj valid
   
  d vj     lex currentsupportxi a vj    xi     valid
   
currentsupportxi a vj
   
else
   
remove d xi  
   
vl xi vars cvl  
   
remove d vl   tuple  xi    
   
d vl   empty return inconsistency
   
deletion true
    return deletion
figure    hac  ac algorithm hidden variable encoding 
hac algorithm uses stack  or queue  dual variables propagate value deletions  works follows  initialization phase iterates dual variable
vj  line     every original variable xi constrained vj algorithm revises
constraint vj xi   done calling function revise  line    
revision  value d xi   look tuple domain vj supports
it  ac       store currentsupportxi a vj   recent tuple found
d vj   supports value variable xi     tuple deleted d vj  
   assume  without loss generality  algorithm looks supports checking tuples
lexicographic order 

   

fibinary encodings non binary csps  algorithms   experimental results

know supported  otherwise  look new supporting tuple starting
tuple immediately currentsupportxi  a vj   tuple found
removed d xi    line      case  tuples include value removed
domains dual variables constrained xi  lines       
dual variables already stack added it    then  dual variables
removed stack sequentially  dual variable vj removed
stack  algorithm revises constraint vj original variable xi constrained vj   algorithm terminates values domain deleted 
case problem arc consistent  stack becomes empty  case
problem arc consistent 
main dierence hac gac      gac      include
lines       is  even non binary constraints given extension  gac     remove tuples become invalid lists allowed tuples 
result  two algorithms check validity tuple  in lines        dierent
ways  later section explain detail  apart dierence 
important aects run times  two algorithms essentially
same  move hac gac      removing lines      substituting
references dual variables references corresponding constraints  example 
currentsupportxi a vj corresponds currentsupportxi a cvj gac       i e  last tuple
constraint cvj supports value variable xi   note implementation
gac       propagation constraint based  is  algorithm utilizes stack
constraints perform propagation value deletions 
      complexities
give upper bound number consistency checks performed hac
worst case  function revise xi   vj   called kd times dual variable
vj   every deletion value domain xi   xi one k original
variables constrained vj   call revise xi   vj   algorithm performs
checks  one value d xi    see currentsupportxi a vj valid  line     
currentsupportxi a vj valid  hac tries nd new supporting tuple d vj   
check tuple contains assignment  xi   a  supports need check
valid  tuple valid one values removed domain
corresponding variable  means tuple removed
domain dual variable  therefore  checking validity tuple done
constant time looking domain dual variable  algorithm needs
check support dk    maximum  tuples contain assignment  xi   a  
since hac stores currentsupportxi a vj   call revise xi   vj   value
d xi    checks tuples checked before  words 
check dk  tuples value xi   overall  worst
case  dk  checks plus checks test validity current support 
kd values upper bound checks performed hac make one dual variable ac
   note dual variables already stack never added it  sense  stack
implemented set 

   

fisamaras   stergiou

o kd d   dk     o kdk    e dual variables worst case complexity bound o ekdk   
complexity gac non binary representation 
asymptotic space complexity hac algorithm dominated o edk  
space needed store domains dual variables  algorithm requires o nde 
space store current supports  since space required grows exponentially
arity constraints  reasonable assume hve  and binary
encodings  cannot practical constraints large arity  unless constraints
tight 
mentioned  consistency check non binary representation done dierent
way hve  assume gac      looks support value ai d xi  
constraint c  vars c     x            xk   xi vars c   tuple    a            ak  
supports ai  xi     ai valid  check valid  gac      check
values a            ak  except ai   still domains variables x            xk   therefore 
worst case  consistency check gac      involves k   operations  contrast 
hac checks validity tuple constant time looking domain
corresponding dual variable see tuple still there  however  means
algorithm update  usually  large domains dual variables value
deletion original variable  aects run times algorithms dierent
problems settings 
appendix show hac complexity 
performs exactly number consistency checks gac      arc consistent
problems  show arc inconsistent problems dierence
number checks favor hve 
    search algorithms
search algorithms maintain local consistencies widely used csp solving 
extended non binary case  example  maintaining arc consistency
 mac  forward checking  fc   shown non binary version mac
 mgac  applied non binary csp equivalent mac applied hve
csp original variables instantiated variable orderings used
 stergiou   walsh         show that  mgac  non binary extensions fc
emulated equivalent algorithms run hve 
fc  haralick   elliot        rst generalized handle non binary constraints
van hentenryck         according denition van hentenryck         forward
checking performed k   variables k ary constraint assigned
remaining variable unassigned  algorithm called nfc  paper bessiere 
meseguer  freuder    larrosa        more  stronger  generalizations fc
non binary constraints introduced  generalizations dier
extent look ahead perform variable instantiation  algorithm nfc  applies
one pass gac constraint constraint projection involving current variable
exactly one future variable    algorithm nfc  applies gac set constraints
involving current variable least one future variable  one pass  algorithm nfc 
applies gac set constraints involving current variable least one future
   one pass means constraint processed once 

   

fibinary encodings non binary csps  algorithms   experimental results

variable  algorithm nfc  applies gac set constraints involving least one
past variable least one future variable  one pass  algorithm nfc  
strongest version  applies gac set constraints involving least one past variable
least one future variable  generalizations reduce simple fc applied
binary constraints 
show various versions nfc equivalent  terms visited nodes 
binary versions fc run hve problem  holds
assumption binary algorithms assign original variables use
variable value ordering heuristics  static dynamic  non binary counterparts 
note algorithm nds consistent assignment original variables 
assignments propagated dual variables  domains dual
variables reduced singletons  is  domain dual variable vc
contain single tuple consistent assignments original variables
constrained vc   therefore  algorithm proceed assign dual variables
backtrack free manner 
equivalence nfc  version fc hve  called fc   bacchus
  van beek         proved bessiere et al          fc  specialized forward
checking algorithm hve  operates standard binary fc except
domain dual variable pruned  fc  removes adjacent original variables
value longer supported 
algorithms nfc  nfc  equivalent algorithms operate hve 
call algorithms hfc hfc   example  hfc  enforce ac set dual
variables  original variables connected them  dual variable connected
least one past original variable least one future original variable  note
nfc  natural equivalent algorithm hve  emulate hve
get inecient awkward algorithm  following  hfc  refer standard
binary fc algorithm hfc  refer fc  

proposition     non binary csp  xed variable value ordering  algorithm nfci  i              equivalent algorithm hfci operates hidden variable
encoding problem 
proof  prove nfc   strongest among generalized fc algorithms 
proof versions similar  need prove node
search tree algorithms nfc  hfc  delete exactly values
domains original variables  assume node  instantiating current
variable  nfc  deletes value future variable xi   exists constraint
c including xi least one past variable  value xi supporting tuple c 
hve  hfc  tries make vc  the dual variable corresponding c  ac
remove tuples assign xi   hence  hfc  delete domain xi  
opposite case  hfc  deletes value original variable xi means
tuples including assignment removed domains dual variables
include xi least one past variable  non binary representation problem 
assignment xi supporting tuples constraints involve xi
least one past variable  therefore  nfc  delete domain xi    
   

fisamaras   stergiou

algorithms nfc nfc  equivalent node visits corresponding algorithms hfc hfc   asymptotic cost  holds
condition non binary algorithms use gac       or optimal algorithm 
enforce gac  hve versions use algorithm hac 
proposition     non binary csp  xed variable value ordering  algorithm nfci  i              asymptotic cost algorithm hfci operates
hidden variable encoding problem 
proof  section     showed enforce ac hve non binary
csp worst case complexity gac non binary representation
problem  since algorithm nfci enforces gac part problem
algorithm hfci enforces ac  visit nodes search tree  follows
two algorithm asymptotic cost   
paper bessiere et al          detailed discussion complexities algorithms nfc nfc  made  worst case complexity nfc  nfc  one node
o  cc f   k   dk      cc f   number constraints involving current variable least one future variable  complexity hfc  hfc  
worst case complexity nfc  nfc  one node o  cp f   k   dk      cp f  
number constraints involving least one past variable least one future
variable  complexity hfc  hfc  
assuming nodes algi   set search tree nodes visited search algorithm
algi following holds 
corollary     given hidden variable encoding csp xed variable value
ordering schemes  following relations hold 
   nodes hfc   nodes hfc  
   nodes hfc   nodes hfc  
   nodes hfc   nodes hfc   nodes hfc  
   nodes hfc   nodes hfc   nodes hfc  
   nodes mac  nodes hfc  
proof  proof   straightforward  see paper bacchus   van beek        
proof     straightforward consequence proposition     corollary  
paper bessiere et al         hierarchy algorithms nfc  nfc  node visits
given  easy see   holds since hfc  applies ac part csp 
mac applies whole problem  therefore  mac prune least many
values hfc  given node search tree  since variable value
ordering heuristics used  means mac visit number
nodes hfc    
note paper bacchus   van beek        experimental results show differences fc hve fc non binary representation  however 
   

fibinary encodings non binary csps  algorithms   experimental results

algorithms compared fc  nfc   equivalent  also 
proved hfc  exponentially greater cost nfc   vice versa
 bacchus et al          however  algorithms equivalent  proved proposition      result bacchus et al         hold comparing equivalent
algorithms 
far showed solving non binary csp directly many ways equivalent
solving using hve  assuming original variables instantiated 
natural question whether search techniques inapplicable
non binary case  applied encoding  answer ability search
algorithm operates encoding instantiate dual variables  equivalent
non binary representation would imply instantiating values one variables
simultaneously  implement algorithm would modify standard search
algorithms heuristics devise new ones  hand  hve algorithm
instantiates dual variables easily implemented 

   algorithms dual encoding
section turn attention de describe specialized ac algorithm
signicantly lower complexity generic algorithm 
    arc consistency
know ac de strictly stronger gac non binary representation
ac hve  stergiou   walsh         since de binary csp  one obvious
way apply ac using generic ac algorithm  domain size dual variable
corresponding kary constraint dk worst case  therefore  apply
optimal ac algorithm enforce ac one dual constraint o d k   worstcase complexity  de csp e constraints maximum arity k
e e      binary constraints  when pairs dual variables share one
original variables   therefore  enforce ac de csp o e  d k   worstcase complexity  signicantly expensive compared o ekdk   complexity
bound gac non binary representation ac hve 
high complexity bound  ac processing de considered impractical  except
perhaps tight constraints 
however  show ac applied de much eciently 
precise enforce ac de non binary csp o e  dk   worst case time
complexity  improvement asymptotic complexity achieved exploiting
structure de  namely  fact constraints de piecewise
functional 
consider binary constraint dual variables vi vj   create piecewise
decomposition tuples domain either dual variable groups
tuples group supported group tuples variable 
non binary constraints corresponding two dual variables share f original variables
x            xf domain size d  partition tuples vi vj df groups 
tuple group includes sub tuple form  a            af    a 
d x             af d xf    tuple supported tuples group
   

fisamaras   stergiou

variable  tuple includes sub tuple  a            af   the tuples
belonging supports tuple since tuple contain
sub tuple  a            af    words  group tuples variable vi
supported corresponding group variable vj tuples groups
values original variables common two encoded non binary
constraints  therefore  constraints de piecewise functional 
example     assume two dual variables v  v    v  encodes constraint
 x    x    x     v  encodes constraint  x    x    x     original variables
x            x  domain            partition tuples dual variable
  groups  rst group include tuples form          second include tuples form          third include tuples form         
star    means corresponding original variable take value  group
supported corresponding group variable  note tuples
variable vi partitioned dierent groups according constraint involves vi  
instance  another dual variable v  encoding constraint  x    x    x   
partition tuples d v    according constraint v  v  groups
form                           
van hentenryck  deville   teng        shown ac achieved
set binary piecewise functional constraints o ed  worst case time complexity 
improvement o d  compared o ed    complexity arbitrary binary constraints
 van hentenryck et al          since showed constraints de piecewise
functional  result van hentenryck et al         means improve
o e  d k   complexity ac de 
figure   sketch ac   ac algorithm specically designed de 
call pw ac  piecewise arc consistency   show  algorithm
worst case time complexity o e  dk    complexity bound achieved
ac   algorithm van hentenryck et al          specialization piecewise
functional constraints  necessary adaptations operate de 
ac algorithms  pw ac uses stack  or queue  propagate deletions domains
variables  stack processes groups piecewise decompositions  instead variables
constraints usual ac algorithms  use following notation 
s vi   vj      s   vi   vj            sm  vi   vj    denotes piecewise decomposition d vi  
respect constraint vi vj   sl  vi   vj    l              m 
group partition 
sup sl  vi   vj    denotes group s vj   vi   support group sl  vi   vj  
s vi   vj    discussed  group unique 
counter sl  vi   vj    holds number valid tuples belong group sl  vi   vj  
decomposition s vi   vj    is  time value counter sl  vi   vj    gives
current cardinality group 
groupof  s vi   vj      function returns group s vi   vj   tuple
belongs  implement function  constraint dual variables vi
   

fibinary encodings non binary csps  algorithms   experimental results

function p w ac
  
q
  
initialize group counters  
  
variable vi
  
variable vj constrained vi
  
tuple d vi  
  
counter groupof  s vi   vj       counter groupof  s vi   vj          
  
variable vi
  
variable vj constrained vi
  
group sl  vi   vj  
   
counter sl  vi   vj       
   
put sl  vi   vj   q
    return p ropagation
function p ropagation
    q empty
   
pop group sl  vi   vj   q
   

   
revise vi   vj   sl  vi   vj   
   
d vj   empty return inconsistency
   
group sl  vj   vk   put sl  vj   vk   q
    return consistency
function revise vi   vj   sl  vi   vj   
    tuple d vj   sup sl  vi   vj   
   
remove d vj  
   
group sl  vj   vk   includes
   
counter sl  vj   vk    counter sl  vj   vk     
   
counter sl  vj   vk       
   
add sl  vj   vk  
    return
figure    pw ac  ac algorithm dual encoding 

vj store original variables shared non binary constraints cvi
cvj   also  original variable xl store pos xl   cvi   pos xl   cvj   
way groupof function takes constant time 
set contains groups counter reduced   call
function revise  is  groups tuples belonging
deleted 
algorithm works follows  initialization phase  group count
number tuples contains  lines      then  variable vi iterate
   

fisamaras   stergiou

variables vj constrained vi   group sl  vi   vj   s vi   vj    check
sl  vi   vj   empty  line      empty  added stack propagation 
next phase  function p ropagation called delete unsupported tuples
propagate deletions  line      previous phase nished  stack
contain number groups   cardinality  group sl  vi   vj   must
remove tuples belonging group sup sl  vi   vj    since lost support 
done successively removing group sl  vi   vj   stack calling function
revise  since group sup sl  vi   vj    lost support  tuple d xj   belongs
sup sl  vi   vj    deleted  lines        apart sup sl  vi   vj     tuple may belong
groups d vj   partitioned respect constraints vj
variables  since deleted  counters groups must updated  i e  reduced
one   done lines       implementation use function groupof
access relevant groups  counter group becomes   group
added stack propagation  lines           process stops either
stack domain variable becomes empty  former case  de ac 
latter not 
following example illustrates advantage algorithm pw ac generic
ac algorithm employed de  ac hve  or gac non binary representation  
example     consider three constraints c    c    c  part csp  vars c     
 x    x    x     vars c       x    x    x     vars c       x    x    x     assume point
domains variables de problem shown figure    disregarding
original variables depicted dashed lines   assume try enforce ac

x  x  x  

x  x  x  

vc 

     
     
     
     
     

vc 

     
     
     
     
     
     
     

x 

x  x  x  

   
     
     

vc 

   
x 

figure    dual encoding non binary csp 
de using algorithm ac         algorithm discover rst tuple d vc   
support d vc     there tuple x      x       delete it 
deletion  rst two tuples d vc    lose support d vc   
ac      must therefore look new supports  two tuples d vc   
algorithm check   remaining tuples d vc    discovering
support  result two tuples deleted  algorithm pw ac 
hand  set counter group rst tuple d vc    belongs  according
partition s vc    vc       deletes tuple  result call function
   note construct similar examples generic ac algorithm 

   

fibinary encodings non binary csps  algorithms   experimental results

revise automatic deletion rst two tuples d vc     saving total    
checks 
consider hve problem  applying ac hve eect
values     x  x  supported d vc    d vc     therefore
propagation variables  result two tuples d vc   
deleted  similarly  propagation apply gac non binary
representation problem 
note theoretical results regarding de presented rest paper
hold ac   algorithm van hentenryck et al         adapted used de
instead pw ac  two algorithms similarities  e g  use function
access group decomposition certain tuple belongs to  though implemented
dierently   basic operation dierent  algorithm van hentenryck et al 
        instantiation ac    handles queue triples  vi   vj   a  implement
constraint propagation  vi vj two variables involved constraint
value removed d vj    pw ac utilizes queue piecewise
decompositions  data structures used algorithms dierent  pw ac
checks updates counters perform propagation which  explain below  requires
space exponential number common variables non binary constraints 
algorithm van hentenryck et al         utilizes complicated data structure
requires space exponential arity non binary constraints  noted 
however  pw ac specically designed de  is  operation  data
structures  way checks consistency based fact domains
dual variables consist tuples original constraints extensionally stored 
hand  algorithm van hentenryck et al         generic  sense
adapted operate piecewise functional constraint 
      complexities
pw ac algorithm consists two phases  initialization phase set group
counters  main phase delete unsupported tuples propagate deletions 
analyze time complexity pw ac  note complexity analysis
measure operations  incrementing decrementing counter  since pw ac
perform consistency checks usual sense 
proposition     worst case time complexity algorithm pw ac o e  dk   
proof  assume constraint dual encoding  non binary constraints corresponding two dual variables vi vj share f original variables
x            xf domain size d  means piecewise decomposition consists
df groups  obviously  f equal k    k maximum arity
constraints  initialization phase lines    iterate constraints 
constraint variables vi vj   iterate tuples d vi   
done o e  dk   asymptotic time complexity  then  empty groups inserted
q  lines       requires e  df operations worst case  initialization 
function p ropagation called  group inserted q  and later removed 
becomes empty  means loop p ropagation executed
   

fisamaras   stergiou

df times constraint  e  df times total  maximum
number times function revise called  once every iteration loop   cost
function revise computed follows  assuming revise called group sl  vi   vj   
iterate  at most  dkf tuples group sup sl  vi   vj     line      iteration
remove tuple  line     update counters groups belongs
 lines        e groups  in case vj constrained dual
variables   therefore  iteration costs o e   result  call revise costs
o edkf    since revise called e  df times  complexity pw ac  including
initialization step  o e  dk   e  df   e  df edkf   o e  dk     
note pw ac easily used incrementally search  case 
initialization phase executed once  asymptotic space complexity pwac  ac algorithm binary encoding  dominated o edk   space need
store allowed tuples non binary constraints  algorithm pw ac requires
o e  df   space store counters groups  o e  df   space stack 
o f e    space fast implementation function groupof  

   algorithms double encoding
double encoding rarely used experiments binary encodings  although
combines features hve de  therefore may exploit advantages
worlds  precise  double encoding oers following interesting potential 
search algorithms deploy dynamic variable ordering heuristics assign values
original variables  constraint propagation implemented constraints
dual variables achieve higher pruning  section rst briey discuss
ac applied double encoding  show various search algorithms
adapted operate double encoding 
    arc consistency
ac enforced double encoding using algorithm pw ac addition
time value original variable xi loses supports adjacent dual
variable  deleted d xi    alternatively  use generic ac algorithm 
ac       note ac algorithm applied double encoding enforce various
levels consistency depending constraints uses propagation dual
variables  is  propagation either done directly constraints
dual variables  indirectly constraints dual original variables 
example  use constraints dual original variables get
level consistency ac hve  propagation dual variables
performed using constraints de get level consistency ac
de  dual variables  prune domains original variables 
between  option use dierent constraints propagation dierent parts
problem  next example shows  ac double encoding achieve
high level consistency compared non binary representation  sections        
show profound eect practice 
   

fibinary encodings non binary csps  algorithms   experimental results

example     consider problem figure    applying ac constraint
two dual variables determine problem insoluble  however 
problem non binary representation gac  singleton  generalized 
arc consistent  sgac   high level consistency  csp sgac
applying gac problem induced instantiation single variable 
domain wipeout  debruyne   bessiere        prosser  stergiou    walsh        

x 
x  x  x  x  

 
x 

   

 
x 

x  x  x  x  

x 
vc 

          
          
          
          

   

          
          
          
          

vc 

   
x 

figure    double encoding problem ac double encoding sgac
non binary representation 

    search algorithms
various search algorithms double encoding dened  depending variables
instantiated constraints used propagation  restrict
algorithms instantiate original variables perform propagation
using constraints dual variables  intuitively interesting class
algorithms combine nice features non binary representation
hve  small domain sizes   de  strong propagation  
rst show fc versions hve discussed section     adapted
yield algorithms run double encoding  call algorithms dfc dfc  
algorithm dfci  i                 instantiates original variables enforces ac
exactly set variables double encoding corresponding algorithm hfci
hve  example  dfc  enforce ac set dual variables  original
variables connected them  dual variable connected least one past
original variable least one future original variable  dierence algorithm
dfci  i                 hfci former exploit constraints dual
variables enforce higher level consistency latter  surprisingly 
results stronger algorithms 
proposition     non binary csp  xed variable value ordering  algorithm dfci  i                strictly stronger respective algorithm hfci 
proof  easy see value pruned hfci hve
pruned dfci double encoding  straightforward consequence
fact    double encoding subsumes hve     algorithms dfci hfci
enforce ac set variables  algorithm dfci strictly stronger hfci
   

fisamaras   stergiou

because  exploiting constraints dual variables  prune values
hfci  consider  instance  problem two constraints c  c    vars c     
 x    x    x    x    vars c       x    x    x    x     variables xi                   domains
        allowed tuples constraints rel c                                                
rel c                                                  x  given value   hve
algorithms hfc hfc  prune tuples                           domains dual
variables vc  vc  respectively  pruning performed  double
encoding  variable assignment  algorithms dfc dfc   cause
domain wipe out two dual variables   
corollary     non binary csp  xed variable value ordering  algorithm
dfci  i             strictly stronger respective algorithm nfci  i            
proof  straightforward consequence propositions           
easy see algorithm hfc   i e  simple binary fc  equivalent dfc  
holds algorithms hfc  dfc   various versions fc  mac
algorithm adapted run double encoding original variables
instantiated  propagation implemented constraints dual
variables  easy see algorithm strictly stronger corresponding
algorithm hve  the proof similar proof proposition       interestingly  show mac algorithm double encoding can  most 
polynomially greater cost corresponding mac algorithm hve  while 
hand  exponentially better 
proposition     non binary csp  xed variable value ordering 
mac algorithm hidden variable encoding instantiates original variables
exponentially greater cost corresponding mac algorithm double
encoding 
proof  prove this  use example    paper bacchus et al         
example csp  n     variables  x            x n     domain
            n    n     constraints 
c     x    x  mod       x    x  mod   
c     x    x  mod       x    x  mod   
   
c n    x n    x n mod       x n     x n   mod   
c n      x n     x n   mod       x    x  mod   
assume variables assigned lexicographic order double encoding  x 
x  assigned values  x    x  mod        enforcing ac prune
tuples d vc     x    x  mod         turn prune d vc   
tuples  x    x  mod         continuing way  ac propagation prune
d vc n     values  x    x  mod         deletions propagated
vc    d vc    become empty  similar way  enforcing ac assignments
   

fibinary encodings non binary csps  algorithms   experimental results

x  x     x    x  mod         leaves d vc    empty  therefore  csp
insoluble  mac double encoding needs instantiate two variables discover this 
visit o n    nodes  hand  explained bacchus et al          mac
hve needs visit o nlog n    nodes conclude problem insoluble  finally 
note that  node  asymptotic costs mac double encoding  using pwac  mac hve polynomially related  therefore  mac hve
exponentially worse mac double encoding   
corollary proposition     mac double encoding exponentially smaller cost mgac non binary representation 
proposition     non binary csp  xed variable value ordering 
mac algorithm double encoding instantiates original variables
polynomially greater cost corresponding mac algorithm hidden
variable encoding 
proof  prove need show two things     number node visits made
mac double encoding polynomial factor greater number
node visits made mac hve     node  worst case cost mac
double encoding polynomial factor greater worst case cost ac
hve  former true since mac double encoding strictly stronger
mac hve  latter established considering worst case complexities
algorithms node  mac hve costs o ekdk   node  mac
double encoding use pw ac enforce ac  costs o e  dk    therefore 
polynomial dierence   
similar way  prove relationship proposition     holds
algorithm dfci  i             corresponding algorithm hfci  corollary proposition     mac double encoding polynomially greater cost
mgac non binary representation  important note proposition    
holds algorithm pw ac used enforce ac double encoding  use
generic algorithm  ac       get exponential dierences favor mac
hve  finally  regarding relationship node visits among algorithms
double encoding  following 
proposition     given double encoding csp xed variable value ordering schemes  following relations hold 
   nodes dfc   nodes dfc  
   nodes dfc   nodes dfc  
   nodes dfc   nodes dfc   nodes dfc  
   nodes dfc   nodes dfc   nodes dfc  
   nodes dmac  nodes dfc  
proof  proof simple based comparing size subsets
problem algorithm enforces ac   
   

fisamaras   stergiou

   experimental results
section make empirical study algorithms binary encodings  empirical
study organized two parts 
rst part  subsections          evaluate improvements oered
specialized algorithms compared generic ones  time compare
eciency algorithms run binary encodings non binary counterparts  comparison give us better understanding encoding
non binary problem binary one pays o  encoding preferable 
empirical investigation use randomly generated problems  random problems
added structure  benchmark crossword puzzle generation problems  random
problems allow us relate performance algorithms certain parameters 
tightness  constraint graph density  domain size  crossword puzzles
standard benchmarks comparing binary non binary constraint models  allow us evaluate performance algorithms problems include
constraints high arity 
second part  subsection        investigate usefulness binary encodings
realistic problem settings  study use problems domains
conguration frequency assignment compare performance mac
algorithms run encodings mgac algorithm non binary representation 
algorithms implemented c  experiments run pc     
ghz pentium   processor   gb ram  experiments  algorithms use
dom deg heuristic  bessiere   regin      b  dynamic variable ordering lexicographic value ordering 
      random problems
random instances generated using extended model b described bessiere
et al          summarize generation method  random non binary csp dened
following input parameters 
n   number variables
  uniform domain size
k   uniform arity constraints
p   density     percentage generated graph  i e  ratio existing constraints
number possible sets k variables
q   uniform looseness     percentage constraints  i e  ratio allowed
tuples dk total tuples constraint
constraints allowed tuples generated following uniform distribution 
made sure generated graphs connected  following  class non binary
   

fibinary encodings non binary csps  algorithms   experimental results

csps denoted tuple form   n  d  k  p  q    use star    case
one parameters varied  example  tuple                    stands
class problems    variables  domain size     arity    graph density     
varying constraint looseness 
      crossword puzzles
crossword puzzle generation problems used evaluation algorithms
heuristics csps  ginsberg  frank  halpin    torrance        beacham  chen  sillito   
van beek        binary encodings non binary problems  bacchus   van beek       
stergiou   walsh         crossword puzzle generation try construct puzzles
given number words given grid lled words  problem
represented either non binary binary csp straightforward way 
non binary representation variable letter lled nonbinary constraint set k variables form word puzzle  domain
variable consists low case letters english alphabet giving domain
size     allowed tuples constraint words k letters
dictionary used  compared   k possible combinations letters 
means constraints tight  de variable word
length k puzzle possible values variable words k
letters dictionary  gives variables large domains  up      values
unix dictionary used experiments   binary constraints
variables intersect  i e  common letter   hve
original variables well set dual variables  one non binary constraint 
    hidden variable encoding
rst empirical study investigated performance two mac algorithms
operate hve  compared mgac       counterpart nonbinary representation  two mac algorithms hve mhac      
stands mac hve instantiates original variables  mhac      f ull
mac algorithm may instantiate variable  dual original  according
heuristic choice  stated names  three algorithms use ac       gac      
enforce ac  although run experiments various versions fc 
include results since algorithms inecient hard problems  especially hard
crossword puzzles   however  qualitative comparison fc based algorithms
hve non binary representation similar comparison regarding macbased algorithms 
      random problems
table   shows performance  measured cpu time  algorithms classes
randomly generated csps  classes hard phase transition region  classes   
        sparse    dense  include results mhac      f ull
experiments showed algorithm similar behavior mhac      
reason that  nature constraints  dom deg heuristic almost
   

fisamaras   stergiou

always selects original variables instantiation  rare cases heuristic
selected dual variables  resulted large increase cpu time 
class
mgac      mhac     
                          
    
    
                          
    
    
                        
     
     
                            
     
     
                       
    
    
table    comparison algorithms mgac      mhac      random classes
problems  classes     taken paper bessiere et al          give
average run times  in seconds      instances class  winning
time instance given bold  follow rest paper 

table   see mhac      performs better mgac     
sparse problems  general    ary classes tried density less      
relative run time performance mhac      compared mgac      ranged
equal around     times faster  sparse class    includes
problems   ary constraints  mhac      considerably ecient mgac      due fact sparse problems relatively large domain sizes
hard region located low constraint looseness  i e  small domains dual variables 
operations required revision dual variables  another factor
contributing dominance binary algorithm class   larger arity
constraints  non binary algorithm requires operations check validity
tuples tuples large arity  explained section     
density graph increases  class     overhead revising domains
dual variables restoring failed instantiations slows mhac      
result outperformed mgac       denser classes ones reported 
phase transition region point half tuples allowed 
cases non binary algorithm performs even better 
      crossword puzzles
table   demonstrates performance search algorithms various crossword puzzles 
used benchmark puzzles papers ginsberg et al         beacham et al 
        four puzzles                              could solved algorithms
within   hours cpu time  also  two puzzles               arc inconsistent 
cases gac discovered inconsistency slower ac hve  around     time
dierence                   latter method discovered early domain
wipe out dual variable 
rest puzzles observe mhac      performs better mgac     hard instances  hard insoluble puzzles mhac        times
faster mgac       mainly due large arity constraints
   

fibinary encodings non binary csps  algorithms   experimental results

puzzle
     
      
     
     
     
  
   
   
     

n
  
  
  
   
   
  
  
  
  

e mgac      mhac      mhac      f ull
   
    
    

   
     
     
     
   
     
     
  m
   
     
     

   


    
  
    
    
    
  
  m
 m
  m
  
 m
 m
 m
   
     
     
     

table    comparison  in cpu time  algorithms hve algorithms
non binary representation crossword puzzles  n number words e
number blanks  times seconds except followed
 minutes   dash    placed wherever algorithm manage nd
solution within   hours cpu time  problems marked     insoluble 
include problems reasonably hard least one algorithm
time solvable within   hours least one algorithm 

classes    another interesting observation signicant dierences
performance methods may instantiate dual variables instantiate
original ones  many cases mac      f ull managed nd  dierent  solution
mhac      mgac      earlier  hand  mac      f ull subject
thrashing instances methods terminate  fact insoluble
puzzles mac      f ull better mhac      shows performance
largely dependent variable ordering scheme  many cases mac      f ull visited
less nodes mhac       however  reected similar time performance
dierence dual variable instantiated mac      f ull work
original one instantiated  instantiate automatically original
variable xi constrained dual variable propagate changes dual
variables containing xi  
    dual double encodings
empirical study investigated performance algorithms de double
encoding  tried answer following three questions     ecient specialized
algorithms compared generic algorithms     use specialized algorithm
make de eective option solving non binary csps     take advantage
theoretical properties double encoding practice  answer questions 
run experiments random structured problems evaluate benets oered
specialized algorithm pw ac maintaining ac search  compared
   puzzles         correspond square grids blank squares 

   

fisamaras   stergiou

performance two mac algorithms  one uses ac      enforce ac  mac       another uses pw ac enforce ac  mac pw ac   compared
algorithms algorithm maintains gac non binary representation
using gac       mgac        mac algorithms maintain ac double
encoding using pw ac  algorithm mac pw acd  ac       algorithm mac     d  
      random problems
rst give indicative results comparison various algorithms using
random problems  figure   compares time required enforce ac de
gac non binary representation  figures      compare algorithms
maintain consistencies 
figure   shows average cpu times  in msecs  pw ac ac      take
enforce ac de     random csps    variables domain size     ternary
constraints      graph density     constraints   include average time gac     takes enforce gac non binary representation generated instances 
looseness constraints varied starting point instances gac
gac ac de delete values  signicant dierence
performance pw ac compared ac      constantly rises looseness
constraints becomes higher  expected  since number allowed tuples
constraint grows  ac      takes time nd supports  gac      faster
pw ac  up one order magnitude  looseness low  dierence
becomes smaller looseness grows 
figure   shows cpu times relatively sparse class problems    variables
   ternary constraints  p       figure   shows cpu times node visits denser class
   variables     ternary constraints  p       along x axis vary domain
size variables  data points show average cpu times  in secs      instances
taken hard phase transition region 
make following observations     mac pw ac mac pw acd signicantly faster  one order magnitude  mac      mac     d  respectively 
classes problems     classes  non binary representation preferable de  mgac      two orders magnitude faster denser class  
sparser class  mac double encoding  i e  algorithm mac pw acd  competitive
mgac      small domain sizes  considerably faster larger domain sizes 
eect domain size relative performance algorithms mainly due
run time advantage pw ac compared gac       higher consistency
level achieved double encoding    run time advantage pw ac explained
considering that  domain size increases  gac      check increasing number
tuples supports  operation costly counter updates pw ac 
denser class mgac      constantly faster algorithms domain
sizes  surprising considering o e  dk   o ekdk   complexities pw ac
gac       i e  factor e becomes signicant  
figure    compare algorithms mgac      mac pw acd  the faster among
algorithms encodings  class problems    variables      ary
   verified looking node visits two algorithms 

   

fibinary encodings non binary csps  algorithms   experimental results

     

     
cpu time  secs 

    
cpu time  msecs 

      

ac     
pw ac
gac     

   

  

 

    
   
  
 

   

   
 

     

    

     
q

    

     

    

 

      

  

  

  

  

figure                    csps 
      

mac     
mac ac    d
mac pw ac
mac pw acd
mgac     

mgac     
mac pw acd

     
cpu time  secs 

     

 



figure                        csps 

cpu time  secs 

mac     
mac     d
mac pw ac
mgac     
mac pw acd

    
   
  

    

   

  

 
   

 
 

 

  


  

  

 

 

  

  

  

  



figure                    csps 

figure                     csps 

constraints  algorithms encodings competitive class
problems  see mgac      ecient small domain sizes 
larger domain sizes mac pw acd one order magnitude faster  however 
denser classes problems results reversed 
experiments random problems conjecture double encoding
preferred model sparse problems  provided ecient algorithm
pw ac used propagation  csps medium high density non binary
representation preferable encodings 
random problems added structure experiments ternary csps
detect advantage de compared non binary representation
 and consequently hve   mac de rarely better mgac       only
cases tight constraints large domain sizes   despite use pw ac
propagation  also  mac pw acd competitive often faster mgac     sparse random problems  result reversed density increases  basic
reason results randomly generated problems  especially ones ternary
constraints  get many pairs non binary constraints share one original
variable  known  see bacchus et al        example  pair
constraints  ltering achieved ac de ltering achieved
gac non binary representation  and ac hve   therefore  ac de
looses much ltering power 
   

fisamaras   stergiou

validate conjecture  experimented generation model structure
added purely random problems  precise  experimented problems
clique variables embedded randomly generated instance  ternary problems
two constraints clique may share one two variables  decided random 
  ary problems two constraints clique may share one  two  three variables 
again  decided random  table   compares performance various mac
algorithms                                     problems type  second
class include results mac pw acd  far best algorithm
problems  mgac      
arity clique size mgac      mac      mac pw ac mac     d mac pw acd
 
 
      
        
       
       
       
 
  
      
        
       
       
      
 
  
       
       
      
      
     
 
  
       
      
     
      
    
 
 
     
      
 
  
      
     
 
  
       
      
table    average cpu times mac algorithms de double encoding
mgac non binary representation random problems embedded
cliques  times seconds  number gives average    instances
around phase transition region 
see  comparative results algorithms vary according size
embedded clique  clique embedded  clique size    mgac     
faster algorithms binary encodings  clique size grows  binary
encodings  especially double  become ecient  double encoding
eective de clique sizes  large clique covers variables  mac
double encoding many orders magnitude faster mgac       huge
dierence caused presence many constraints share one variable
non binary representation  cases ltering constraints dual
variables strong  however  much advantage lost generic algorithms
used encodings  similar results occur denser problems generation
model used 
      crossword puzzles
table   compares cpu times two mac algorithms de mgac
non binary representation using various benchmark crossword puzzles  include
results mac double encoding since particular representation crossword
puzzle generation problems impractical  reason pair dual
variables involved constraint  two variables one original variable
common  i e  letter two words intersect   explained previously 
   

fibinary encodings non binary csps  algorithms   experimental results

degrades ltering achieved constraints dual variables  constraints
double encoding redundant since ltering achieved
constraints dual original variables 

puzzle
     
      
     
     
     
     
     
     
     
     
     
  
   
   
   
     

n
  
  
  
  
   
   
   
   
   
   
   
  
  
  
  
  

e mgac      mac      mac pw ac
   
    
      
     
   
     
      
      
   
     


   
    


   
    


   
     

       
   

     
    
   
    
     
     
   
      
      
     
   


    
   


    
  
    
     
    
  
  m

  m
  
 m

 m
  


      
   
     
      
     

table    comparison  in cpu time  mac algorithms de mgac
non binary representation crossword puzzles  times seconds except
followed  minutes   cpu limit   hours  problems marked
    insoluble  include problems reasonably hard either
mgac      mac pw ac time solvable within   hours
least one algorithm 

data table   clearly see mac pw ac signicantly faster
mac      instances  speedup oered use pw ac makes mac
de competitive mgac many cases using generic algorithm
de results clear advantage favor mgac  also  instances  e g  puzzles
                      use pw ac makes mac de considerably faster
mgac  however  still instances mgac  and consequently mhac 
nds solution  or proves insolubility  fast  mac de thrashes  vice versa 
note       hard      puzzles tried solved
algorithm within time limit two hours  mac pw ac managed solve  
instances relatively fast  two algorithms solved   within
cpu limit 
   

fisamaras   stergiou

    experiments realistic problems
next sections present experimental results conguration frequency assignment problems  aim experiments investigate usefulness binary
encodings realistic structured domains  focus dual double encodings
promising binary encodings strong propagation oer 
      configuration
conguration area csp technology particularly eective  conguration problem viewed trying specify product dened set attributes 
attribute values combined predened ways  problems
modelled csps  variables correspond attributes  domains variables
correspond possible values attributes  constraints specify predened
ways values combined  many conguration problems constraints
expressed extensionally lists allowed  or disallowed  combinations values  alternatively  constraints expressed rules easily transformed
extensional representation  consider following example adapted paper
subbarayan  jensen  hadzic  andersen  hulgaard   moller        
example     conguration t shirt requires specify size  small 
medium  large   print  men black   mib save whales   stw  
color  black  white  red   following constraints     small size chosen
stw print cannot selected     mib print chosen black color
chosen well  stw print chosen black color cannot selected 
conguration problem modelled csp three variables  x    x    x    representing size  print  color respectively  domains variables d x     
 small  medium  large   d x       m ib  st w    d x       black  white  red  
rst constraint binary constraint variables x  x  following allowed
tuples     small  ib      medium  ib      medium  st w      large  ib     
large  st w     second constraint binary constraint variables x  x 
following allowed tuples     ib  black      st w  white      st w  red    
practice  many solvers conguration problems able interact user
that  apart meeting given specications  users choices values certain
attributes satised  study use conguration instances compare
non binary representation binary encodings structured realistic problems  although
would interesting investigate applicability binary encodings interactive
congurator  work outside scope paper 
run experiments problems taken clib  library benchmark conguration problems  clib         rst thing noticed encoding problems
binary non binary csps trivially solvable algorithms without
backtracking  closer look structure clibss problems revealed reason 
constraint graphs consist various unconnected components  component consists
or  cases  single variable  result  problems split independent subproblems trivially solved algorithms  order obtain dicult
instances benchmarking  made graphs connected adding randomness 
   

fibinary encodings non binary csps  algorithms   experimental results

problems extended adding   variables      constraints
graph became connected    table   shows total number variables
constraints modied problems  added constraints arity          chosen
random  variables posted selected random  making
sure resulting graph connected  looseness added constraint
set random  nally  allowed tuples constraint chosen random
according looseness 

problem n

e arity dom

machine
fx
fs
esvs
bike

  
  
  
  
  

  
  
  
  
  

 
 
 
 
 

 
  
  
  
  

mgac     
mac pw ac mac pw acd
nodes   time
nodes   time
nodes   time
              
          
           
             
         
         
              
         
          
                
           
             
                                              

table    comparison algorithms conguration problems  arity dom
maximum constraint arity maximum domain size problem  run times
given seconds 

table   gives average run times node visits algorithms mgac     
non binary representation  mac pw ac de  mac pw acd double
encoding  benchmarks repeatedly generated instances using
model described above  generated instance solved three algorithms
stored instance hard least one algorithm  otherwise  discarded 
instance considered hard least one algorithm took one second
solve it  table   reports averages rst    hard instances generated
benchmark  is  run     hard instances total  note binary encodings
constraints original problem  even binary ones  encoded dual variables 
experimental results table   show signicant advantage favor
binary encodings compared non binary representation  node visits run
times  de clearly ecient model  mac pw ac de
three orders magnitude faster mgac      non binary representation 
single instance among     instances mgac      faster
mac pw ac  double encoding much ecient non binary
representation  main factor contributing performance encodings
strong propagation achieved constraints dual variables 
reected numbers node visits  number reasons  related
structure conguration problems  justify strong performance
encodings 
   experiments showed minimum additions need made order get hard
problems without altering structure problems much 

   

fisamaras   stergiou

constraint graphs sparse  typical conguration problems since 
usually  attribute product specication dependencies
attributes 
constraints high arity tight  moreover  value variables
large domain sizes  typically one  supporting tuple constraints
variables participate 
intersecting non binary constraints one original variable
common  explained  demonstrated empirically section     
signicant impact propagation power ac dual double encodings 
note prole conguration problems  analyzed above  agrees conjectures made based results random problems  is  dual double
encodings suitable sparse problems tight constraints  intersecting constraints may share one variable 
      frequency assignment
frequency assignment important problem radiocommunication industry 
problem radio communications network given region consisting
set transmitters  transmitter position region  frequency spectrum 
certain power  directional distribution  aim assign values
properties transmitters certain criteria satised  various
types frequency assignment problems  study consider version radio
link frequency assignment problem  rlfa   problem given set links
 l            ln    consisting transmitter receiver  link must assigned
frequency given set f   time total interference receivers must
reduced acceptable level using frequencies possible  problems
typically optimization problems purposes study treat
satisfaction problems 
rlfa problem modelled csp transmitter corresponds
variable  domain variable consists frequencies assigned
corresponding transmitter  interferences transmitters modelled
binary constraints form  xi xj     s  xi xj variables  
required frequency separation  constraint restricts frequencies two
transmitters simultaneously assigned  way interference
minimized  realistic assumption closer two frequencies
greater interference them  binary model used extensively
represent rlfa problems  numerous solution methods  csp based other 
proposed  also  rlfa widely used benchmark test new algorithms
binary constraints  mainly ac algorithms  
argued standard binary model frequency assignment problems
fails capture important aspects real problems  multiple interferences 
resulting non optimal frequency assignments  jeavons  dunkin    bater        watkins 
hurley    smith        bater        hodge  hurley    smith         consequence 
eorts introduce expressive methods utilize non binary
   

fibinary encodings non binary csps  algorithms   experimental results

constraints frequency assignment  e g  bater        hodge et al          many
types non binary constraints considered  following ones received
attention 
co channel constraints   e g   frequencies assigned n transmitters equal 
adjacent channel constraints   e g   frequencies assigned n transmitters
least one frequency apart 
separation constraints   e g   frequencies assigned n transmitters least
frequencies apart 
obviously  separation constraints generalize adjacent channel constraints  rst
two types constraints typically loose third tight  separation
constraints used densely constrained areas  representing conurbations region 
large number links closely situated  cases  large separations
frequencies transmitters must imposed  resulting tight constraints 
consider richer type separation constraints  frequencies assigned set n
transmitters least frequencies apart n transmitters among least
   s  frequencies apart others  note non binary constraints
equivalently decomposed clique binary constraints  without introducing
dual variables  resulting however weaker propagation  example adjacent channel
constraints  others cannot equivalently expressed set binary constraints unless
binary encoding used  example  co channel constraints  noted hodge et al 
        non binary constraints low arity utilized practice 
shown many cases constraints sucient achieve low interferences 
constraints higher arity may oer improvements quality solutions  tend
slow solution process extend solving large real problems becomes
infeasible 
empirical study presented interested comparing models rlfatype problems non binary constraints corresponding binary encodings
devising new ecient methods solving rlfa problems  since available rlfa
benchmarks follow standard binary approach  test algorithms generated nonbinary problems placing variables  corresponding links  grid following typical
rlfa structure  is  problems consist several groups closely situated variables
plus constraints connect groups  example  structures depicted
figure     corresponds constraint graph binary rlfa problem
typically consists set cliques  or near cliques  binary constraints small number
constraints connecting various cliques  e g  benchmarks cabon  de givry 
lobjois  schiex    warners         binary encodings considered
double since dual variables large domains  makes de inecient 
indicative results experiments run depicted table    experiments
posted low arity  i e    ary   ary  separation constraints  shown figure    
compared performance algorithm mgac      non binary model
problems performance mac pw acd double encoding problems 
tried two implementations mgac       one utilizes specialized propagators
   

fisamaras   stergiou

a  prob 

b  prob 

c  prob 

figure     examples rlfa problems non binary separation constraints 

separation constraints  written functions   another operates extensional
representation constraints  rst implementation generally faster 
results mgac      presented refer intentional implementation  double
encoding built translating separation constraints lists allowed tuples
preprocessing step 

problem
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 

 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 

n
  
  
  
  
  
  
  
  
  
  
  
  
   
   
   

e arity
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

mgac     
mac pw acd
nodes   time
nodes   time
          
         
                   
         


             
               
               
               
                                      
           
        
            
            
             
        
         
         

         


          
        
              
         

           

table    comparison algorithms rlfa problems separation constraints  arity
maximum constraint arity  run times given seconds  dash   
placed wherever algorithm nish run within    hours cpu time 

   

fibinary encodings non binary csps  algorithms   experimental results

table   reports results total    instances created using dierent constraint
graph topologies  variables domains       values  number allowed
tuples constraints varied around    tight constraints several thousands looser ones  according frequency separation imposed parameters
separation constraints  parameters set random constraint 
making sure loose constraints generated  example    ary basic
separation constraint variables domain size     least    giving      allowed
tuples     giving     allowed tuples  
prob   prob   prob  refer problems topologies shown figure    
prob  consists three groups variables  similar ones prob   arranged
chain like structure  finally  instances prob  consist randomly generated groups
variables  one      variables       ary   ary constraints  groups
interconnected according topological distance  i e  constraints posted
variables nearby groups   instances prob  prob  xed topology 
topology set instances created changing type constraints  example 
two instances topology prob  may dier type separation constraints
 basic richer  include  also  frequency separations imposed
constraint may dier  instances prob  may dier constraint graph topology 
report node visits run times easiest  median  hardest instance
topology  respect performance mgac    hardest instances
encoding non binary representation  except prob    easiest
median instances sometimes dierent 
table   see substantial dierences favor
double encoding  many instances solvable double encoding
little backtracking mgac      thrashed  mainly due large number
interleaved constraints sharing one variable  boosts propagation
double encoding  performance algorithms seems heavily dependent
topology problems  example  instances prob  non binary representation
much ecient double encoding  seems particular class
problems heuristic choices misled propagation achieved double encoding 
able come satisfactory explanation occurred
particular topology 
finally  investigate eect presence loose constraints higher arity
has  run experiments   ary adjacent channel constraints posted
variables apart graph  addition separation constraints 
case using double encoding model constraints problems infeasible
due spatial requirements  example  trying generate allowed tuples
single   ary adjacent channel constraint consumed memory system  therefore 
compared algorithm mgac      non binary model mac algorithm
runs hybrid model tight separation constraints modelled using
double encoding loose adjacent channel constraints kept intentional nonbinary representation  table   reports results total    instances created using
   create instances varied type constraints values parameters
non trivial problems generated  consider trivial problems arc inconsistent solvable
backtracking 

   

fisamaras   stergiou

problem
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 
prob 

 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 
 easiest 
 median 
 hardest 

n
  
  
  
  
  
  
   
   
   

e arity
  
  
  
  
  
  
  
  
  

 
 
 
 
 
 
 
 
 

mgac     
mac hybrid
nodes   time
nodes   time
           
          
              
           


            
             
                



          
         
               
          

               

table    comparison algorithms rlfa problems separation adjacentchannel constraints  mac hybrid corresponds mac algorithm runs
hybrid model 

graph topologies prob   prob  prob  addition four   ary adjacent channel
constraints instance  hybrid model ecient instances prob 
prob  strong propagation achieved binary encoding tight
constraints  non binary model better instances prob  seems
propagation binary encoding results bad heuristic choices 
    discussion
section summarize results experimental studies draw conclusions regarding applicability encodings  based theoretical experimental
analysis 
hidden variable encoding theoretical results suggested  empirical results conrmed  solving problems hve using algorithms instantiate original variables
essentially analogous solving non binary representation directly  commonly
used algorithms non binary problems applied  adjustments  hve 
vice versa  algorithms used  hve oers  moderate  computational
savings compared non binary representation  especially sparse problems 
savings due ability ac algorithm hve detect inconsistencies earlier corresponding gac algorithm non binary representation  therefore 
conjecture hve applicable sparse non binary problems constraints
extensionally specied  cases  hve either less ecient run times
non binary representation  e g  dense problems   building hve adds space
overheads justied marginal gains search eort  additionally 
enough empirical evidence suggest essential dierence search
algorithms hve non binary representation  i e  ability former
branch dual variables  make hve signicantly ecient class
   

fibinary encodings non binary csps  algorithms   experimental results

problems  this  coupled fact benets gained instantiating dual
variables maximized double encoding used instead hve  limits
applicability algorithms 
dual double encodings de double encoding advantage
strong ltering constraints dual variables  showed
advantage exploited low cost specialized algorithm  pw ac  make
de competitive often signicantly better non binary representation
several sparse csps  crossword puzzle generation conguration problems 
dense csps  de pay either spatial requirements make use
infeasible  case  advantages oered outweighed overhead
updating domains dual variables  holds csps containing constraints
large arity unless tight  as crossword puzzles  
algorithms double encoding demonstrate especially promising performance 
many non binary constraints share one variable present
problem mac double encoding exploit benets variable
ordering heuristic  borrowed non binary representation  stronger ltering 
borrowed de  outperform representations  demonstrated
problems structure  random frequency assignment   like  
case still life problem  explains success double encoding    
addition  double encoding oers interesting potential hybrid models certain
constraints encoded binary others kept non binary representation
based certain properties constraints  precise benet encoding
constraints either naturally specied extension  relatively low arity
tight  demonstrated various domains  notably  frequency assignment problems double encoding  or hybrid one  payed cases 
although constraints problems naturally dened intentionally 

   related work
although  de proposed       dechter   pearl        hve       rossi
et al          rst substantial eort towards evaluating eciency carried
      bacchus   van beek         work  bacchus van beek compared theoretically empirically fc algorithm two encodings fc non binary
csps  also  introduced fc   specialized algorithm hve  algorithms
compared bacchus van beek simplest versions fc  hfc  hfc   i e 
fc   hve  nfc  non binary representation  extend work
studying various recent advanced versions fc 
following bacchus van beek         stergiou walsh made theoretical
empirical study ac encodings  stergiou   walsh         proved ac
hve equivalent gac non binary representation  ac de
stronger  small experimental study included paper stergiou   walsh        
mac hve  de  double encoding compared mgac non binary
    although title smiths paper        refers de  model still life problem used
based double encoding 

   

fisamaras   stergiou

representation crossword puzzles golomb rulers problems  results showed
advantage non binary representation hve  important note
mac algorithms used generic inecient algorithms enforce ac 
smith  stergiou   walsh        performed extensive experimental comparison
mac hve double encoding  mgac non binary model
golomb rulers problem  however  mac algorithms encodings used generic
algorithm enforce ac  result outperformed mgac non binary
model 
beacham et al         compared performances dierent models  heuristics 
algorithms csps using crossword puzzle generation problems benchmarks  among
models compared hve  de non binary representation 
again  algorithms applied encodings generic algorithms 
example  two implemented algorithms de mac uses ac  
propagation mac uses ac    algorithms suer high complexity ac propagation  demonstrated  use algorithm pw ac propagation
signicantly enhance performance mac crossword puzzle problems 
bacchus et al         presented extensive theoretical study de hve 
among results  polynomial bounds placed relative performance fc
mac two encodings non binary representation  shown
polynomial bound exists  example  shown fc hve  i e  hfc 
terminology use  never polynomial factor worse fc de 
fc de exponentially worse fc hve  also  fc non binary
representation  i e  nfc  terminology use  exponentially worse fc
hve  vice versa  add results analyzing performance various
advanced algorithms hve double encoding 
smith modelled problem nding maximum density stable pattern still life
conways game life using mac double encoding remarkable success 
compared constraint programming integer programming approaches  smith 
       mac algorithm implemented using table constraint ilog solver 
constraint implements generic ac algorithm bessiere   regin      a  
expensive used de high time complexity  believe
results presented smith improved mac pw ac used instead 

   conclusion
paper studied three binary translations non binary csps  hidden variable
encoding  dual encoding  double encoding  showed common perception standard algorithms binary csps used encodings non binary
csps suers aws  namely  standard algorithms exploit structure encodings  end inecient  address problem  proposed specialized arc
consistency search algorithms encodings  evaluated theoretically
empirically  showed arc consistency enforced hidden variable
encoding non binary csp worst case time complexity generalized arc
consistency non binary representation  showed structure constraints
dual encoding exploited achieve much lower time complexity
   

fibinary encodings non binary csps  algorithms   experimental results

generic algorithm  empirical results demonstrated use specialized algorithm
makes dual encoding signicantly ecient  showed generalized search
algorithms non binary csps relatively easily adjusted operate hidden
variable encoding  showed various algorithms double encoding
designed  algorithms exploit properties double encoding  strong ltering branching original variables  achieve good results certain problems 
empirical results random structured problems showed that  certain classes
non binary constraints  using binary encodings competitive option  many cases 
better one solving non binary representation 

acknowledgements
would thank panagiotis karagiannis  nikos mamoulis  toby walsh
help various stages work  would thank anonymous reviewers
earlier version paper useful comments suggestions 

appendix
explained  main dierence ac algorithm hve corresponding gac algorithm fact ac algorithm update domains
dual variables well original ones  incurs time overhead 
show  deleting values dual variables help propagation discover domain wipe outs
arc inconsistent problems faster 
proposition     let p non binary csp  assume generalized arc consistency applied p   domain wipeout resulting problem  enforcing arc
consistency hidden variable encoding p using hac requires number
consistency checks enforcing generalized arc consistency p using gac       assuming two algorithms follow ordering variables values looking
supports propagating deletions 
proof  first  consider domain wipeout variable  original dual  occurs
two algorithms add constraints  dual variables  stack remove
revision exactly order  therefore  need show
value deleted variable revision constraint nds new support
constraint operations require number checks
representations  assume non binary version algorithm value deleted
domain variable xi support constraint c   t  
number allowed tuples c determining lack support require  t  
currentsupportxi a c checks  one tuples c checked yet 
value deleted nds new support     currentsupportxi a c  
currentsupportxi a c checks performed  hve  xi processed
order non binary version require  t   currentsupportxi a vc
currentsupportxi a vc checks depending case  obviously  currentsupportxi  a c
currentsupportxi  a vc since tuple c corresponds value vc  
therefore  number checks performed representations   
   

fisamaras   stergiou

proposition     let p non binary csp  assume application generalized
arc consistency p results domain wipeout  algorithm hac applied hidden
variable encoding p discovers domain wipeout number
consistency checks algorithm gac      non binary representation  assuming
two algorithms follow ordering variables values looking supports
propagating deletions 
proof  csp  arc inconsistency detected domain variable wiped
applying ac  hve non binary csp  arc inconsistency detected
domain original variable wiped  crucially  domain dual
variable wiped out  second possibility make ac algorithm operates
hve ecient corresponding gac algorithm  prove consider
arc inconsistent non binary problem  assume domain original variable xi
wiped processing constraint c encoded dual variable vc
hve  point function revise called xi c arguments 
inconsistency according proposition     gac algorithm
ac algorithm hve perform number consistency checks  assume
j values left d xi   call revise  function revise
unsuccessfully look support j values   t   number allowed
tuples c then  value d xi    require  t   currentsupportxi a c checks
gac algorithm  t   currentsupportxi  a vc checks ac algorithm  since
 t   currentsupportxi  a c    t   currentsupportxi a vc   two algorithms perform
number consistency checks detect domain wipeout 
following example demonstrates hac may discover inconsistency less
checks  consider problem variables x    x    x    x  domains                
                        respectively  two constraints  c  c    vars c     
 x    x    x    vars c       x    x    x    respectively  value   x  supported c 
tuples include assignment  x        value   x  supported c  tuples
include assignment  x        constraint c  allows tuples include assignment
 x        values              x  supported c  tuples include  x       tuples
include  x        assume variable x  instantiated    means
deletion   d x    must propagated  hve  rst delete
tuples include value  x       dual variables vc  vc    then  add dual
variables vc  vc  stack  remove them  revise original variables connected
them  assuming vc  removed rst  value   x  support vc 
deleted  result  delete tuples dual variable vc  include
pair  x        means domain vc  wiped out  non binary
representation  proceed similar way perform number checks
  deleted x    deletion algorithm look supports c 
value   x  values x    involve checks avoided hve 
inconsistency discovered later process constraint c  nd
value   x  support c  resulting domain wipeout x     

   

fibinary encodings non binary csps  algorithms   experimental results

references
bacchus  f   chen  x   van beek  p     walsh  t          binary vs  non binary csps 
artificial intelligence           
bacchus  f     van beek  p          conversion non binary binary
constraint satisfaction problems  proceedings aaai    pp         
bater  j          non binary  higher order  modelling solution techniques frequency assignment mobile communications networks  ph d  thesis  university
london 
beacham  a   chen  x   sillito  j     van beek  p          constraint programming lessons
learned crossword puzzles  proceedings   th canadian conference
ai 
bessiere  c   freuder  e     regin  j          using inference reduce arc consistency
computation  proceedings ijcai    pp         
bessiere  c   meseguer  p   freuder  e     larrosa  j          forward checking
non binary constraint satisfaction  artificial intelligence              
bessiere  c     regin  j       a   arc consistency general constraint networks  preliminary results  proceedings ijcai    pp         
bessiere  c     regin  j       b   mac combined heuristics  two reasons forsake
fc  and cbj   hard problems  proceedings cp    pp       
bessiere  c     regin  j          rening basic constraint propagation algorithm 
proceedings ijcai      pp         
cabon  b   de givry  s   lobjois  l   schiex  t     warners  j          radio link frequency
assignment  constraints          
clib         conguration benchmarks library  http   www itu dk doi vecos clib   
maintained vecos group  it university copenhagen 
debruyne  r     bessiere  c          domain filtering consistencies  journal artificial
intelligence research             
dechter  r     pearl  j          tree clustering constraint networks  artificial intelligence             
ginsberg  m   frank  m   halpin  m     torrance  m          search lessons learned
crossword puzzles  proceedings aaai     pp         
haralick  r     elliot  g          increasing tree search eciency constraint satisfaction problems  artificial intelligence             
hodge  l   hurley  s     smith  d          higher order constraint techniques
frequency assignment problem  tech  rep   university cardi 
jeavons  p   dunkin  n     bater  j          higher order constraints necessary
model frequency assignment problems  ecai   workshop non binary
constraints 
mackworth  a          consistency networks relations  artificial intelligence        
   

fisamaras   stergiou

mamoulis  n     stergiou  k          solving non binary csps using hidden variable
encoding  proceedings cp       pp         
mohr  r     henderson  t          arc path consistency revisited  artificial intelligence             
mohr  r     masini  g          good old discrete relaxation  proceedings ecai    
pp         
peirce  c         collected papers vol  iii  cited f  rossi  c  petrie  v  dhar      
prosser  p   stergiou  k     walsh  t          singleton consistencies  proceedings
cp       pp         
regin  j          filtering algorithm constraints dierence csps  proceedings
aaai     pp         
rossi  f   petrie  c     dhar  v          equivalence constraint satisfaction
problems  proceedings ecai     pp         
smith  b          dual graph translation problem life  proceedings
cp     pp         
smith  b   stergiou  k     walsh  t          using auxiliary variables implied constraints model non binary problems  proceedings aaai      pp         
stergiou  k     walsh  t          encodings non binary constraint satisfaction problems  proceedings aaai    pp         
subbarayan  s   jensen  r   hadzic  t   andersen  h   hulgaard  h     moller  j         
comparing two implementations complete backtrack free interactive congurator  proceedings cp    workshop csp techniques immediate
application  pp        
van hentenryck  p   ed            constraint satisfaction logic programming  mit
press 
van hentenryck  p   deville  y     teng  c          generic arc consistency algorithm
specializations  artificial intelligence             
watkins  w   hurley  s     smith  d          area coverage frequency assignment  evaluation models area coverage  tech  rep   university glamorgan  presented
informs    
zhang  y     yap  r          making ac   optimal algorithm  proceedings
ijcai      pp         

   


