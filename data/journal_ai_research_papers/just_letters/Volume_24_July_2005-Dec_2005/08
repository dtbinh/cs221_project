journal artificial intelligence research                  

submitted        published      

ignoring delete lists works 
local search topology planning benchmarks
jorg hoffmann

hoffmann mpi sb mpg de

max planck institute computer science 
stuhlsatzenhausweg    
      saarbrucken
germany

abstract
           planning community seen vast progress terms
sizes benchmark examples domain independent planners tackle successfully 
key technique behind progress use heuristic functions based relaxing
planning task hand  relaxation assume delete lists empty 
unprecedented success methods  many commonly used benchmark examples 
calls understanding classes domains methods well suited for 
investigation hand  derive formal background understanding  perform case study covering range    commonly used strips adl
benchmark domains  including examples used first four international planning
competitions  prove connections domain structure local search topology
heuristic cost surface properties idealized version heuristic functions
used modern planners  idealized heuristic function called h    differs
practically used functions returns length optimal relaxed plan 
np hard compute  identify several key characteristics topology h    concerning existence non existence unrecognized dead ends  well
existence non existence constant upper bounds difficulty escaping local minima
benches  distinctions divide  set all  planning domains taxonomy
classes varying h  topology  turns out  many    investigated domains lie
classes relatively easy topology  particularly     domains lie classes
ffs search algorithm  provided h    polynomial solving mechanism 
present results relating h  approximation implemented ff 
behavior regarding dead ends provably same  summarize results empirical investigation showing that  many domains  topological qualities h 
largely inherited approximation  overall investigation gives rare example
successful analysis connections typical case problem structure  search
performance  theoretical investigation gives hints topological phenomena might automatically recognizable domain analysis techniques  outline
preliminary steps made direction 

   introduction
           one strongest trends planning community
towards heuristic planners  specifically towards use heuristic distance  in
cases  goal distance  estimation functions  best runtime results  progressing far beyond
sizes benchmark examples previous domain independent planners could tackle
successfully  achieved based upon technique phrased ignoring delete lists 
c
    
ai access foundation  rights reserved 

fihoffmann

there  heuristic function derived considering relaxation planning task
hand  relaxation assume delete lists  i e  negative effects
available planning operators  empty  search  may forward backward 
state space plan space  heuristic value search state framework  an
estimate of  difficulty extending state solution using relaxed operators 
difficulty defined number  relaxed  actions needed 
number real actions needed extend search state solution least
high number relaxed actions needed  optimal  shortest  relaxed solutions
can  principle  used derive admissible heuristic functions  however  first
proved bylander         deciding bounded plan existence  i e   existence plan
given number actions  np hard even delete lists  
thus much hope find optimal relaxed plans  i e   optimal relaxed solutionextensions search states  fast  instead  one approximate length optimal
relaxed plan search state  techniques kind first  independently  proposed
mcdermott        bonet  loerincs  geffner         developed planners
unpop  mcdermott               hsp   bonet et al          planners
perform forward state space search guided approximation relaxed goal distance 
unpop approximates distance backchaining goals  hsp  approximates
distance forward value iteration technique 
 st international planning competition  ipc    mcdermott         hosted
aips       hsp  compared well four competitors  inspired development hsp r hsp   bonet   geffner            b      a   grt  refanidis  
vlahavas               altalt  nguyen   kambhampati        srivastava  nguyen  kambhampati  do  nambiar  nie  nigenda    zimmermann         well  hoffmann 
      hoffmann   nebel      a  hoffmann      a   hsp r avoids heuristic re computations
changing search direction  hsp  implements various hsp versions configurable hybrid system  grt avoids heuristic re computations changing heuristic
direction  the direction relaxed plans computed   altalt uses planning
graph extract heuristic values  uses modified technique approximating optimal
relaxed plan length  namely  computing necessarily optimal relaxed plan 
done polynomial time   well new pruning search techniques  inspired integration heuristic search engines mips  edelkamp   helmert       
stan   fox   long         using elaborated variations ffs relaxed plan length
estimation technique 
 nd international planning competition  ipc    bacchus         hosted aips      heuristic planners dramatically outperformed approaches runtime wise 
scaling benchmark examples far beyond reach previous  e g   graphplan based
 blum   furst               systems  caused trend towards heuristic planners
still increase  various researchers extended relaxed plan distance estimation techniques
temporal numeric settings  do   kambhampati        hoffmann            a 
edelkamp      b   others adapted use partial order plan space search  nguyen
   parallel planning  bound number parallel time steps needed  deciding bounded
plan existence easy without delete lists  however  heuristic functions based observation
generally found provide useful search guidance practice  see  example  haslum  
geffner        bonet   geffner      b  

   

fiwhere ignoring delete lists works

  kambhampati        younes   simmons         developed variations provide
new means heuristic guidance  onaindia  sapena  sebastia    marzal        sebastia 
onaindia    marzal         modified take exclusion relations planning graph
account  gerevini   serina        gerevini  serina  saetti    spinoni        
 rd international planning competition  ipc    long   fox         hosted
aips          domain independent competing systems    using relaxed plan
distance estimations one form   st prize winner lpg  gerevini   serina 
      gerevini  saetti    serina        uses  amongst heuristics  relaxed planning
technique estimate difficulty sub goal achievement planning graph 
 th international planning competition  ipc    hoffmann   edelkamp        edelkamp 
hoffmann  englert  liporace  thiebaux    trug         hosted icaps         
competing sub optimal systems     using relaxed plan based heuristics 
two  st prize winners category  fast downward  helmert        helmert   richter 
      sgplan  chen   wah        chen  hsu    wah         latter uses
numeric version sub process  one version former combines ffs heuristic
estimates new heuristic function based causal graph analysis  helmert        
investigation hand  derive formal background classes domains methods kind described well suited for  make two simplifying
assumptions  first  consider forward state space search only  used by  example 
unpop  hsp  mips  ff  fast downward  forward state space search  one starts
initial state explores space reachable states goal state found 
state transitions follow sequential planning framework  single action
applied time   assuming forward search makes investigation easier since
search natural simple framework  second simplifying assumption
idealize matters consider heuristic value given optimal relaxed plan
length  the length shortest sequential relaxed plan  search state s  denote
value h   s   assumption  see many provable
connections domain structure heuristic quality  course  simplifying assumptions restrict relevance results practical planners  said
section  section    another  benign  restriction make
consider solvable tasks only  common restriction ai planning  particularly
competitions  main focus good planners finding plans 
specifically  main focus investigation hand characterize kinds
domains  relaxed plan based  heuristic planners find plans fast 
common knowledge behavior heuristic search methods  may
global local  i e   without backtracking mechanisms  depends crucially
quality underlying heuristic function  has  example  studied
sat community  example frank  cheeseman  stutz         work 
authors empirically investigate properties local search topology  i e   topological
properties sizes local minima etc   sat instances standard heuristic
function  adapt frank et al s definitions ai planning  difference frank et
al   take analytical approach prove properties valid across
   principle  parallel forward search possible  too  best authors knowledge 
published work implementation this  time writing  main difficulty is 
presumably  high branching factor 

   

fihoffmann

certain ranges  namely domains  example problem instances  investigate range
   commonly used strips adl benchmark domains including examples used
first four international planning competitions  identify several key characteristics
topology respective search spaces h    characteristics following 
      benchmark domains  unrecognized dead ends  i e   states
goal unreachable relaxed plan 
         benchmark domains  maximal exit distance local
minima constantly bounded  i e   one always escape local minima  regions
neighbors higher heuristic value  within number steps
constant across instances domain  regardless size  in fact    
domains local minima all  
         benchmark domains  maximal exit distance benches
constantly bounded  i e   one always escape benches  regions states
heuristic value  within number steps constant across
instances domain  regardless size  in   domains bound    one
domain even    
beside positive results proving characteristic qualities h  function 
investigation provides  parameterized  counter examples negative cases 
results divide investigated domains  more generally  possible planning domains 
meaningful taxonomy classes differ terms topological behavior
respect h    many    investigated domains lie relatively easy classes  i e   classes
h  provably high quality heuristic  particularly     domains
properties lie classes ffs search algorithm polynomial solving
mechanism  idealizing assumption ffs approximative heuristic function
identifies real h  distances  ffs search algorithm  called enforced hill climbing  tries
escape local minima benches means breadth first search  breadth first search
exponential search depth  local minima benches always
escaped within constant number steps case    domains
effort spent search polynomially bounded  way  results provide
non trivial insights typical case problem structure  in benchmarks   possible
effects search performance  examples successful theoretical investigations kind
extremely rare ai literature 
give reader feeling looking at  figure   shows two visualized
state spaces  shown tasks instances two domains easiest classes
taxonomy  gripper logistics  graph nodes states  edges state
transitions  action applications   height given h  value   pictures 
initial state somewhere left top part  goal states are  course  states
minimal zero h  value  gripper picture speaks itself  logistics topology
less extreme  still state space forms one big valley bottom
goal states 
   h  values here  empirical investigation  hoffmann      b      b  preceding theoretical
analysis  computed iterative deepening forward search space relaxed action sequences 

   

fiwhere ignoring delete lists works

 a 

 b 

figure    visualized state space h   a  gripper  b  logistics instance 

course  ffs approximation h    refer hf f   always identify
real h  values  priori evident relevance theoretical results
h  ffs efficiency practice  additionally  forward searching planners
use enforced hill climbing  topological results striking
impact  finally  importantly  several competitive planners even
perform forward search  use additional new techniques heuristic function
explicitly aimed identifying better information relaxed plans  prominent systems
former kind hsp r lpg  prominent systems latter kind lpg
fast downward 
relevance results performance ff  practical performance
coincides quite well them  concretely  behavior h  respect dead
ends provably hf f   moreover  large scale empirical investigation
 contained hoffmann      b  shown that  many domains  topology h 
largely preserved hf f   include section containing brief summary results 
relevance topological results forward search algorithms enforced
hill climbing  performance planners using search paradigms enhanced
heuristics  discussed section   
remark topological investigation specifically intended identify
properties relevant enforced hill climbing  theoretical investigation preceded
empirical investigation  hoffmann      b      b  measured kinds
topological parameters  including  example  size diameter local minima  benches 
structures so called valley regions  turned topology
parameters showed interesting behavior across significant number domains
maximal exit distance parameters considered investigation hand  this  fact 
came surprise us invented enforced hill climbing became clear
   

fihoffmann

many planning benchmarks share topological properties favoring precisely
particular search algorithm 
observe proved results worst case nature  i e   heuristic search using
 
h show good behavior example suite domain even domain lies
difficult class taxonomy given particular example instances test
suite emphasize worst cases possible domain  relevant 
discuss issue regards example suites used competitions 
employed proof methods give hints topological phenomena might
automatically detectable using general domain analysis techniques  extra section 
report first  not yet successful  attempt made that 
proofs individual planning domains are  cases  overly difficult 
full details domains extremely space consuming  details  except
  ipc   domains   i e   pddl like definitions domains well fully detailed
proofs  looked long      pages  technical report  hoffmann      c 
forms online appendix article   article provides proof sketches 
much better suited get overall understanding investigation results 
since even proof sketches sometimes hard read  moved appendix 
another appendix provides brief descriptions domains  main body text
gives results outline main proof arguments used obtain them 
paper organized follows  section   provides necessary background  i e 
straightforward formal framework strips adl domains  overview
investigated domains  definitions local search topology  section   presents
core lemmas underlying many proofs single domains  illustrates lemmas
application small example  section   gives results brief proof outline 
shows resulting planning domain taxonomy  section   presents results relating
h  hf f   section   reports first attempt design domain analysis techniques
automatically detecting h  topological phenomena  section   concludes article
brief discussion contributions future work  appendix contains
proof sketches individual domains  appendix b contains domain descriptions 

   background
background necessary planning framework  investigated domains  local
search topology 
    planning framework
enable theoretical proofs properties planning domains rather single tasks 
defined formal framework strips adl domains  formalizing straightforward manner way domains usually dealt community  outline
rather lengthy definitions  refer reader tr  hoffmann      c  details 
follows  sets mean finite sets unless explicitly said otherwise 
   remark tr longer version paper hand  trs overall structure
presentation angle different  intended source details needed 

   

fiwhere ignoring delete lists works

planning domain defined terms set predicates  set operators 
possibly infinite set instances  logical constructs domain based
set predicates  fact predicate applied tuple objects  operators
 k ary  k number operator parameters  functions  infinite  set
objects  infinite  set strips adl actions  strips action
triple  pre a   add a   del a    precondition  conjunction facts  add list 
fact set  delete list  fact set  adl action pair  pre a   e a  
precondition pre a  first order logical formula without free variables  e a 
set effects e form  con e   add e   del e   con e   effect condition 
formula without free variables  add e   the effects add list  well del e   the
effects delete list  fact sets  add list action effect contains fact p 
say action effect achieves p 
instance domain defined terms set objects  initial state  goal
condition  initial state set facts  goal condition formula without free
variables  in strips case  conjunction facts   facts contained
initial state assumed true  facts contained assumed false 
i e   usual apply closed world assumption  instance domain constitutes 
together domains operators  planning task  a  i  g  action set
result applying operators instances objects  i e   object tuples
appropriate lengths   initial state goal condition g instance 
identify instances respective planning tasks 
state set facts  logical formula holds state state model
formula according standard definition first order logic  where logical atom 
fact  holds iff contained state   result result s  hai  applying action
sequence consisting single strips adl action state defined follows 
actions precondition hold s  result s  hai  undefined  otherwise 
result s  hai  obtained including add effects   thereafter  removing
delete effects adl action  add effects add e  included
 delete effects del e  removed  respective effect condition con e  holds
s  result applying sequence ha            consisting one action
state defined iterative application single actions obvious manner 
apply a  s  apply a  result s  ha  i   on 
plan  solution  task  a  i  g  sequence actions p that 
successively applied i  yields goal state  i e   state g holds   we use
standard notation   set  denote set sequences elements
   many proofs need notion optimality  plan p task  a  i  g 
optimal plan  a  i  g  contains fewer actions p  
note that  announced introduction  definition  particular definition
plan optimality  stays within forward state space search framework plans
simple sequences actions  note ignoring delete lists simplifies task
formulas negation free  fixed domain  tasks polynomially normalized
property  compute negation normal form formulas  negations
front facts   introduce negated fact b new fact not b make sure
true state iff b false  gazen   knoblock         pre process done in 
   

fihoffmann

example  ff  investigation hand  considered normalized versions
domains  
consider domains  ipc   collection  feature derived predicates  predicates affected effects operators  truth value
instead derived values other  basic  predicates  via set derivation
rules  derivation rule form  x  p  x  p derived predicate
 a formula  rules antecedent  using free variables x  obvious idea
that   x  holds  p  x  concluded  little detail  semantics
defined follows  initial state  whenever action applied  first
derived predicate instances  derived facts  assumed false  derivation rules
applied fixpoint occurs  derived facts could concluded
said false  this called negation failure   derived predicates used
predicate operator preconditions  effect conditions 
goal condition  however  ensure unique fixpoint rule application 
use derived predicates derivation rule antecedents restricted  in context
ipc    positive use sense predicates appear negated
negation normal form rule antecedent  hoffmann   edelkamp        
make ignoring delete lists simplification  one needs derived facts
used positively operator preconditions  effect conditions  goal condition
 otherwise derived predicates can  example  used model negated preconditions etc    due negation failure semantics derived predicates  isnt
simple compilation negations pure adl case  approach take here 
implemented in  example  version treats derived predicates
 thiebaux  hoffmann    nebel               simply ignore  replace true  negated
derived predicates  the negation normal form of  operators goal  see below 
section      
    domains overview
said before  case study covers total    commonly used strips adl benchmark domains  include examples first four international competitions 
plus   domains used literature  brief descriptions domains looked
appendix b  full formal definitions domains  except   ipc   domains 
tr  hoffmann      c   note that  defining domain  one must amongst
things decide exactly instances are  naturally  abstracted
known example suites  cases abstraction obvious  less obvious
cases respective subsection appendix b includes explanatory remarks 
here  provide brief overview    analyzed domains  domains categorized three groups according semantics  high level abstraction 
categorization not  way  related topological characterization derive
later  use give overview structure 
   ignoring delete lists normalized domains comes relaxation that  basically  allows  the
translated  facts take truth values time 

   

fiwhere ignoring delete lists works

   transportation domains  domains locations  objects
must transported  vehicles means transportation   operators mostly either move vehicle  load  unload  object onto  from  vehicle  domains differ terms various constraints  important one that 
many domains  vehicles move instantaneously two locations 
domains movable links locations form arbitrary road maps 
   transportation domains collection look at  logistics classical transportation domain  trucks airplanes transport objects within between
cities  gripper robot two gripper hands transports number balls  one
time hand  one room another  ferry single ferry transports
cars one time  driverlog trucks need drivers board order move 
location links form bi directional road maps  which different trucks
drivers   briefcaseworld briefcase moves  conditional effects  objects along
inside it  grid robot transports keys grid like road map
positions locked must opened keys matching shapes  miconicstrips elevator transports passengers  using explicit actions board deboard
passengers  miconic simple miconic strips  passengers board deboard
conditional effects action stops elevator floor 
miconic adl miconic simple  various constraints must obeyed  for
example  vips first   zenotravel airplanes use fuel items replenished
one one using refuel operator  mprime arbitrary road map  trucks use
non replenishable fuel items  fuel transferred locations  mystery
mprime  without possibility transfer fuel  airport inbound
outbound planes must moved safely across road map airport 
   construction domains  generally closely related transportation domains above  construction domains common  roughly 
complex object must built individual parts   
domains collection look at  blocksworld arm classical construction
domain  blocks picked up put stacked onto unstacked
means robot arm  blocksworld no arm above  blocks
moved around directly block block   table block  
block table  depots combination blocksworld arm logistics 
objects must transported locations stacked onto
other  freecell encoding solitaire card game comes microsoft
windows  the complex object constructed final position cards  
hanoi encoding classical towers hanoi problem  assembly complex
object must assembled together parts  might need
assembled beforehand 
   domains     domains collection whose semantics
quite fit either groups  simple tsp trivial strips version
   term transportation domains suggested  example  long fox        helmert
        transportation benchmarks generally closely related groups
domains overviewed below  sometimes discuss transportation domains rather generic
level 

   

fihoffmann

tsp problem  move operator applied two locations 
movie order watch movie  one must buy snacks  set counter video
zero  rewind tape  tireworld number flat tires must replaced 
involves various working steps  like removing flat tire putting new
one   fridge number fridges  broken compressors must replaced 
involves various working steps  like loosening fastening screws hold
compressor   schedule objects must processed  painted  example 
number machines  satellite satellites must take images  of phenomena space  
using appropriate instruments  rovers rovers must navigate along road map  take
soil rock samples well images  communicate resulting data lander 
pipesworld oil derivatives must propagated pipeline network  psr
lines must re supplied faulty electricity network  dining philosophers
deadlock situation dining philosophers problem  translated adl
automata based promela language  edelkamp      a   must found  opticaltelegraph similar dining philosophers  considering encoding telegraph
communication system 
    local search topology
remember consider solvable tasks  since main focus investigation
characterize kinds domains heuristic planners find plans fast 
discussion unsolvable tasks section   
given planning task  a  i  g   state space  s    graph states
reachable initial state  set state transitions  i e   set
pairs  s  s    states action leads s  executed
s  goal distance gd s  state length shortest path  s   
goal state  gd s    path  latter case  dead end 
discuss states directly below  heuristic function h     n      heuristic
return indicate state hand might dead end 
given strips action    pre a   add a   del a    relaxation a 
 pre a   add a      given adl action    pre a   e a    relaxation a 
 pre a   e a     e a   e a  except delete lists empty 
set actions  relaxation a  a      a    a   action sequence
 
 
ha            relaxed plan  a  i  g  ha 
            plan  a   i  g   that 
 

state s  h  s    min n   p   ha              p relaxed plan  a  s  g   
minimum empty set  
presence derived predicates  said additionally relax planning
task ignoring  replacing true  negated derived predicates negation normal
forms preconditions  effect conditions  goal condition  note that 
additional simplification  happen h   s    although goal state 
simplification might relax goal condition itself  indeed  happens
psr domain  domains consider here  derived predicates either used
used positively  h   s      iff goal state 
   article focuses mainly h  heuristic  keep topology definitions
depend specific heuristic used somewhat general 

   

fiwhere ignoring delete lists works

one phenomenon clearly relevant performance heuristic state space
search dead end states s  gd s      heuristic function h return h s     
taking indication dead end  obvious idea remove
search space  this done in  example  hsp ff   technique adequate
h completeness preserving sense h s    gd s    s 
completeness preserving heuristic  dead end state called recognized h s   
unrecognized otherwise  note h  completeness preserving  task solved
even ignoring delete lists  task unsolvable  assume
heuristic look completeness preserving  respect dead ends 
planning state space falls one following four classes  state space called 
   undirected  if   s  s       s    s   
   harmless  exists  s  s     s    s      and  s  gd s     
   recognized  exists gd s      and  s  gd s   
h s     
   unrecognized  exists gd s    h s     
first class  dead ends everything undone 
second class  things undone  single directed state transitions
harm  sense dead end states  third class 
dead end states  recognized heuristic function 
critical case heuristic search class four  search algorithm run dead
end without noticing it  particularly relevant if  potentially  large regions
state space consist unrecognized dead end states  capture this  define depth
unrecognized dead end number states s  s  unrecognized dead
end  s  reachable path moves unrecognized dead ends 
investigation determines     benchmark domains looked at  exactly
four dead end classes instances domain belong  domains
turns unrecognized dead ends  construct parameterized
examples showing unrecognized dead ends arbitrarily deep  several
domains  individual instances fall different classes  case associate
overall domain worst case class  i e   class highest index above 
example  miconic adl  additional constraints obeyed
transportation passengers state space harmless miconic simple 
constraints on  example  possible direction travel access floors
given  unrecognized dead ends arise  avoid clumsy language  henceforth 
say state space harmless recognized unrecognized  mean falls
respective class  class it 
get definitions general topological phenomena  i e   relevant properties search space surface  adapt definitions given sat frank et al 
        difference sat framework there  planning formalism here 
lies possibly single directed state transitions planning  search spaces considered frank et al   state transitions traversed directions  single directed
   

fihoffmann

state transitions important impact search space topology  enabling 
example  existence dead ends  
base entity state space topology frank et al  name plateaus 
regions equivalent reachability aspects  look point
view heuristic function  l n     plateau p level l maximal subset
induced subgraph  s    strongly connected  h s    l
p    plateaus differ terms possibilities leaving heuristic level  i e  
reaching exit  plateau p level l  exit state reachable p  
h s    l exists state s     s  s      h s      h s   based behavior
respect exits  distinguish five classes plateaus  need notion
flat paths  paths  s    value h remains constant 
   recognized dead end plateau p level l    
   local minimum plateau p level     l   exit reachable
flat path 
   bench plateau p level     l     least one exit reachable
p flat path  least one state p exit 
   contour plateau p level     l   consists entirely exits 
   global minimum plateau p level   
plateau belongs exactly one classes  intuitively  roles different
kinds plateaus play heuristic search following  recognized dead ends
ignored completeness preserving heuristic function  local minima difficult
neighbors look worse  clear direction move next  benches
potentially easier  one step without temporarily worsening
heuristic value  contours  one step immediately   
main difficulty heuristic search deal local minima
benches  cases  search algorithm must  eventually  find path exit
order get closer goal  as far heuristic function informed
closer goal not   difficult find exit assessed
variety different parameters  size  number states  diameter  maximum distance
two states  local minimum the bench  number nearby exit
states  name important ones  benchmarks considered  mentioned
introduction  empirically found  or few  interesting observations
made parameters  hoffmann      b      b  
   one can  course  introduce backtracking mechanisms search space  always giving
planner possibility retract last step  affect relevant topological differences
search spaces instead domains with without dead ends  one gets domains backtracking
necessary not necessary 
   difference undirected case require states plateau strongly connected
undirected state transitions trivially fulfilled set connected states 
    differences undirected case lie plateaus level   allow exits
lie plateaus themselves  latter minor technical device obtain compact
terminology 

   

fiwhere ignoring delete lists works

one frequently observe interesting properties distance nearest
exit state  distance dist s  s    two states s  s  usual graph
distance  i e   length shortest path s   s    
path  exit distance ed s  search state distance nearest exit  i e  
ed s    min d   length path  s    state s  s t  h s      h s  
exists state s   s t   s    s       h s       h s      
where  before  minimum empty set   note require
path definition flat  i e   may that  order reach s    temporarily
increase h  value  want definition capture possible
escape routes state state space  including states lie local minima 
maximal local minimum exit distance  mlmed s     state space  s   
maximum exit distances states local minima   
states  maximal bench exit distance  mbed s     state space  s    maximum
exit distances states benches    states  find
that  many considered domains  constant upper bounds mlmed s   
and or mbed s    h    i e   bounds valid irrespectively  size the 
instance chosen 
following implication relevant subsequent investigation 
proposition   given solvable task  a  i  g   state space  s    completenesspreserving heuristic h  h s      gd s      s  exists unrecognized
dead end s  mlmed s       
proof  let unrecognized dead end  let s  state reachable
h value s  minimal  s  unrecognized dead end   in particular 
considered reachable itself   since h s        gd s        h s        
have  since h value s  minimal among states reachable s 
h s     h s    states s   reachable s    thus plateau s  lies local
minimum exits reachable  particular flat paths  shows s 
infinite exit distance 
 
proposition   says that  every region unrecognized dead ends  local
minimum  given h s      gd s         definitions  unrecognized
dead end state yields infinite local minimum exit distance  makes sense define
things way  arbitrarily deep  unrecognized dead end worse local
minimum  escaped all 
    remember latter untrue h  domain features derived predicates
appear negated negation normal form goal condition  even then  argument
proposition  every region unrecognized dead ends would contain global minimum consisting
non solution states  could defined fake global minima local minima  decided
order overly complicate topological definitions  since detail
seem important  said before  one    domains h   s      gd s     
anyway 

   

fihoffmann

   core lemmas
many investigated domains  intuitively similar patterns problem structure cause
characteristic qualities h    common structure generalized
captured concise definitions lemmas  lemmas formulate sufficient criteria implying  the state space of  planning task certain topological properties  proofs
domains proceed  possible  applying lemmas arbitrary instances 
several domains lemmas applied immediately  due syntactic details
domain definitions   similar proof arguments suffice show desired topological
properties 
restrict strips tasks lemmas  appropriate extensions adl
and or derived predicates probably possible least certain cases 
investigated detail extensions likely rather complicated notationally 
simpler strips case suffices transport ideas 

initial state 
at v  l     at o    l     at o    l   
goal 
at o    l     at o    l   
actions 
name
precondition
move l  l   
at v  l 
load o  l 
at v  l   at o  l 
unload o  l  at v  l   in o  v  

add list
at v  l   
in o  v  
at o  l 

delete list
at v  l 
at o  l 
in o  v  

figure    simple strips transportation task 
throughout section  assume given strips task  a  i  g   illustrative example definitions lemmas  use simple transportation task
defined figure    follows  three separate sections  concerned dead
ends  local minima  benches  respectively 
definitions lemmas following syntactical  sense
make use informations computed efficiently  for example  inconsistencies
facts   discuss this  focus exclusively role definitions
lemmas tools proving h  topology  role definitions lemmas
tools automatically detecting h  topology discussed section   
    dead ends
first focus criteria sufficient non existence dead ends  starting point
reformulated version simple result mentioned by  example  koehler hoffmann
        need notion inconsistency  two facts inconsistent
reachable state contains them  set facts f inconsistent another set
   

fiwhere ignoring delete lists works

facts f   fact f inconsistent least one fact f       action
invertible if 
    add a  inconsistent pre a  
    del a  pre a  
    action
 a  pre a   pre a  add a     del a  
 b  add a    del a  
 c  del a    add a  
intentions behind requirements following          ensure
effects occur    a  ensures applicable    b    c  ensure
undoes effects  example  actions illustrative task figure  
invertible  example    move l  l    action inverted   move l    l   see that 
simply insert definitions  add a     at v  l     inconsistent pre a     at v  l   
del a     at v  l     pre a   pre a     at v  l       add a   add a     at v  l     del a  
del a     at v  l       add a   similarly easily  one sees load o  l  unload o  l 
invert other  examples benchmark domains invertible actions blocksworld
 in variants   logistics  gripper 
lemma    koehler   hoffmann        given strips planning task  a  i  g  
actions invertible  state space task undirected 
proof  state applicable action a  applicable result s  hai  due
condition   a  invertibility  conditions         make sure effects fact
appear  condition     requires fact add list inconsistent least one
fact precondition   conditions   b    c  make sure undoes exactly
effects 
 
remark that  contrast one may think first sight  task
undirected state space even actions invertible sense  imagine 
example  action del a     p  pre a     p     and  due domain
semantics  p  true p true  means delete effect always appears 
however  detected simple syntax check  del a  pre a   used
definition above 
next provide new criterion weaker broadly applicable
lemma    implies non existence dead ends  criterion based
weaker version invertibility  two alternative properties whose combination
make action safe 
make action lead dead end  already sufficient inverse action
re achieves least deleted  delete facts true
    may seem natural define inconsistency fact sets symmetrical fashion  demanding
every fact f inconsistent every fact f     context here  definition would
stronger need 

   

fihoffmann

before  is  given state applicable  applying result s  hai  leads
us back state s  satisfies s  s  formally  action least invertible
action that 
    pre a   pre a  add a     del a  
    add a  del a  
    del a  inconsistent pre a  
condition     ensures  before  applicable result s  hai   condition
    ensures re achieves every fact deleted a  condition     ensures
facts deleted true anyway  note invertible action
least invertible  conditions         obviously given  condition     
del a    add a   condition   c  invertibility   add a  inconsistent pre a 
 condition     invertibility   del a  inconsistent pre a   invertible
stronger least invertible  chose name least latter illustrate
that  definition invertibility  potentially re achieves facts
original state s 
example  consider happens modify move l  l    action figure  
include visited l    fact add list  resulting action longer invertible
move l    l  delete visited l     apply  state s  move l  l    move l    l 
sequence  gets us state s  identical except
includes visited l  visited l     may true before  move actions
kind form simple tsp domain  least invertible sense 
pre move l    l      at v  l       add move l  l      add move l    l      at v  l   visited l  
 at v  l     del move l  l      del move l  l        at v  l     inconsistent  at v  l    
pre move l  l     
another property implying action lead dead ends this 
action must applied  because add effects remain true   deletes
nothing preconditions  action needs inverted  formally 
action static add effects if 
 

add a 

del a       

a 

action relevant delete effects  if 
del a   g

 

pre a         

a  a 



del a   g a  a  pre a         say relevant delete effects 
property actually interested in  illustrative task figure   
imagine disallow unloading object initial location  loading object
goal location  remaining unload actions  unload o    l    unload o    l    
static add effects action delete goal position object relevant
delete effects action needs object vehicle respective
unload goal location  actions characteristics are  example 
   

fiwhere ignoring delete lists works

actions make passengers get lift miconic strips  a passenger get
lift his her origin floor  get lift his her destination
floor   another example contained tireworld domain  action
inflates flat wheel  de flating action add effects static 
action goal needs wheel flat relevant delete effects 
lemma   given solvable strips planning task  a  i  g   holds actions
either
   least invertible 
   static add effects relevant delete effects 
state space task harmless 
proof  short  reachable state   result i  ha            i  plan constructed
inverting ha             applying respective inverse actions inverse order  
executing arbitrary plan  a  i  g  thereafter  processes  actions
 at least  invertible skipped prerequisite static add effects
relevant delete effects 
detail  proof argument proceeds follows  reachable state  
result i  ha            i  s  identify solution p  a  s  g   let hp            pm
solution  a  i  g   which exists  a  i  g  solvable prerequisite   construct
p algorithm shown figure   
  
   n        
ai least invertible ai
ai   apply ai endif
else     ai  
endif
endfor
          
pi   apply pi endif
endfor
figure    constructing plans tasks actions either least invertible 
static add effects relevant delete effects 
algorithm  serves kind memory set actions could
inverted  need prove preconditions applied actions fulfilled
state applied  goals true upon termination  let us start
first loop  denote si    result i  ha            ai i  state executing
   

fihoffmann

ith action path s  s i state first loop starts value i 
prove 
 
 
s i  si  g
add a 
pre a   
ami

aa mi

mi denotes current state set  proceed backward induction i 
  n  got s i   si mi     equation trivially true  assume
equation true    prove equation holds    ai least
invertible  action applied  s i    s i   mi    mi  ai    concerning
left hand side expression right hand side equation  observe ai

prerequisite delete fact g aa mi  pre a   mi  contains ai   
relevant facts si  already true s i   concerning right hand side
expression right  observe facts add ai   never deleted

prerequisite  ami  add a  contained s i   assume ai least invertible
ai   got mi    mi   assume ai applied  i e   ai   mi   applicable
preconditions contained si   element mi   resulting state
s i    facts ai deleted si  added  facts deleted
true si  anyway  also  none add effects actions mi deleted 
equation fulfilled  finally  ai applied  ai mi   ai static add effects
applied before  add effects contained s i   ai delete effects empty 
inserting     equation proved  get
s   i  g

 

pre a   

aa m 

 

add a 

am 

second loop starts s    start solution plan  excluding actions
set m    state including initial facts contained goal
precondition action m    state additionally contains add effects
actions m    add effects deleted action  clear
simply skip actions m  achieve goal 
 
example illustrate proof  consider reachable state tireworld domain 
every action invertible  except action inflates wheel  say  proof 
state reached action sequence ha            i  algorithm figure  
is  undo everything done  applying respective ai actions  except
inflating actions ai   latter stored set   gets us state
identical initial state  except already inflated flat
wheels  those corresponding actions    state  algorithm executes
arbitrary solution  skipping previously applied inflating actions  in   
    local minima
define important kind relationship role action real task
role relaxed task  combining definition notions least
invertible actions   no  relevant delete effects  yields criterion sufficient
non existence local minima h   or  equivalently    upper bound
maximal local minimum exit distance   criterion directly applied  
   

fiwhere ignoring delete lists works

   investigated domains  applied slight modifications   domains 
many individual proofs make use similar  albeit somewhat complicated 
proof arguments 
key property behind lack local minima h  is  time 
every action good solving real task good solving relaxed task 
formally  action respected relaxation if 
reachable state starts optimal plan  a  s  g  
optimal relaxed plan  a  s  g  contains a 
note one assume relaxed plan start a  since relaxation
better apply action earlier 
actions illustrative task figure   respected relaxation  consider move l  l    actions  example  if  state s  optimal plan starts
move l  l     must good reason this  either a  l  object
yet transported  b  object truck must transported l   
cases  relaxed plan must transport object  chance
without moving l  point  similarly  optimal plan starts load o  l 
action  means must transported somewhere else  relaxed plan
get around loading it  finally  optimal plan starts unload o  l  action 
means l goal location o  relaxed plan include
action 
similar arguments applied many transportation domains 
argument regarding move actions becomes little complicated non trivial
road maps  unlike illustrative example two locations
reachable single step other  say road map  any  directed graph 
modify move action figure   add precondition fact
demanding existence edge l l    move actions still respected
relaxation  ignoring delete lists affect shape road map 
optimal real path location l location l  coincides optimal relaxed path
movements l l   even though result executing path different  
there  claim follows argument above  namely  optimal
plans moves l l  object provides reason so 
transportation domain features additional constraints on  side effects of  move
actions  may respected relaxation  give example below 
formulating main lemma regarding local minima h   
note exist local minima even actions respected relaxation 
consider following transportation task  featuring single directional edges road
map graph  argued above  actions respected relaxation  vehicle
two objects o    o  initially l  o  must go l  o  must go l    edge l
l  single directed edge l l  single directed  l  l   
path n bi directional  undirected  edges  optimal relaxed plan state
where  initial state  o  o  loaded  length    move l l  l   
unload o  o  l  l    respectively  however  one moved  s  either l 
l    optimal relaxed plan length goes n      since entire path l 
   

fihoffmann

l  must traversed  lies local minimum  given n      note that  setting
n arbitrarily high values  get local minimum arbitrarily large exit distance 
turns preventing example  precisely  making use notions
invertibility relevant delete effects  introduced above  suffices get rid local
minima h   
lemma   given solvable strips task  a  i  g   state space  s   
contain unrecognized dead ends  action
   respected relaxation 
   least invertible relevant delete effects 
local minima  s    evaluation h   
proof  states gd s    local minima prerequisite  h   s     
prove that  every reachable state     gd s       action starts
optimal plan  a  s  g   h   result s  hai   h   s   proves lemma 
iterating argument  obtain path goal state s    value h 
increase path  means exit reachable flat path
h s          h s  point path h  value becomes lower h s   thus
lie local minimum 
let reachable state     gd s       let action starts
optimal plan  a  s  g   denote s     result s  hai   action respected
relaxation  optimal relaxed plan p    s   a  s  g  starts a 
case  a   removing p    s  yields relaxed plan  a  s    g   h   s     
 
h  s  follows  finished  case  particular  relevant delete
effects  facts deletes needed action goal  p    s 
without achieves goal starting s   where already applied  
case  b   assume removing p    s  yield relaxed plan s    then 
said before  relevant delete effects  must thus least
invertible  is  action pre a   pre a  add a     del a 
add a  del a   action guaranteed applicable s    re achieves
delete effects  denote p    s    action sequence results replacing  p    s  
a  p    s    relaxed plan  a  s    g   seen follows  observe
that  definition  p    s  without relaxed plan result s  ha  i   we abbreviate
notation somewhat improve readability   desired property follows
result s    ha  i  superset result s  ha  i   result s  ha  i    add a  
s     s add a     del a   add a  del a   p    s    relaxed plan  a  s    g  
yielding h   s    h   s  
 
proof lemma   demonstrates along lines  typically  proof arguments
investigation proceed  given state s  consider action starts optimal
plan s  consider optimal relaxed plan p    that contains a  ideally   then 
determine p   modified obtain relaxed plan state results
execution  technique forms basis literally proofs except concerned
dead ends  note second prerequisite lemma   fulfilled planning
   

fiwhere ignoring delete lists works

tasks qualifying undirectedness harmlessness criteria given lemmas     
note that  said above  proved state space
illustrative example figure   undirected  contain local minima
h   
domains actions respected relaxation are  example  strips
transportation domains logistics  gripper  ferry  miconic strips  cases 
respective proof arguments similar said above  instructive
look examples action respected relaxation 
transportation domain  can  example  happen due fuel usage side effect
moving  concretely  mystery domain  applying move action deletes fuel unit
start location  the location move starts   fuel running low
locations   real  plan may move along fuel rich deviations road map 
relaxed plan need always move along shortest connections
map because  there  actions delete fuel units 
formulated somewhat generally  relaxed plans take short cuts dont
work reality  short cuts disjoint  in starting actions  real solution
paths  local minima may arise even actions  at least  invertible 
discussed transportation case  short cuts correspond intuitive manner
one tends think short cuts  on road map  namely   case
general  i e   kinds domains  consider blocksworld arm state depicted
figure   

c
b

c



b

figure    local minimum state blocksworld arm  goal b table 
c b 

depicted state  denoted s  b table  arm holds c 
goal b table  c b    optimal plan put c
table  unstack b put table  pickup c stack
onto b  optimal relaxed plan s  however  stack c onto b immediately 
unstack b a  put b table  short cut
relaxed plan put c table  stacking c onto b
delete fact declares bs surface unoccupied  result  lies local
    usually  blocksworld goals demanding block table  example 
done sake simplicity  one could introduce one block demand b
goal 

   

fihoffmann

minimum h      reason  intuitively  h  yield local minima
many domains  vicious short cuts example dont happen 
    benches
could find nice general sufficient criterion implying upper bounds maximal
exit distance local minima except special case local
minima thus   upper bound maximal local minimum exit distance 
did  however  find simple proof argument determining upper bound maximal
exit distance benches  tasks qualify application lemma    proof
argument works  sometimes slight modifications    domains lemma  
directly applied domains  maximal bench exit distance bounded
   bounded    one case  
proof argument based observing that  many domains  actions
delete effects irrelevant  for relaxed plan  least  action
applied optimal solution path  formally  action relaxed plan relevant
delete effects if 
reachable state starts optimal plan  a  s  g  

optimal relaxed plan ha  a             a  s  g  del a   g ni   pre ai       
if  reachable state starts optimal plan  a  s  g  

optimal relaxed plan ha  a             a  s  g  del a   g ni   pre ai       
say relaxed plan relevant delete effects  property
actually interested in  notation  relaxed plan relevant delete effects 
starts optimal plan s  relaxed plan result s  hai  constructed
sequence ha            i  i e   skipping relaxed plan s  thus h 
value decreases result s  hai   note n set   results goal
state s  note that  definition  action relaxed plan relevant delete
effects respected relaxation  action respected relaxation 
claim anything h  anyway  note finally that  assuming action
respected relaxation  relevant delete effects  i e   delete
goal precondition another action  relaxed plan relevant delete
effects sense definition 
consider illustrative example figure    say state
load o  l  starts optimal plan  means yet transported  location
l     l  particular  means at o  l  goal  follows action
whose delete effect at o  l  relevant delete effects  no action
at o  l  precondition   further  say unload o  l  starts optimal plan s 
means l goal location o  applying action  goal
achieved  action need refer again  particular action require
inside vehicle  delete effect unload o  l   action neither
    h   s       h  value after  s  putting c table    any relaxed plan
apply two actions two goals   h  value stacking  s  c onto b still    the
relaxed plan unstack c b  unstack b a  put b   successor state
unstack c b again  going back s 

   

fiwhere ignoring delete lists works

relaxed plan relevant delete effects  contrast  consider move l  l    action 
deletes at v  l   say state o  loaded v initial
state task  move l    l    starts optimal plan s  relaxed plan
result s  hmove l    l   i  include action move l    l     moving back l 
l  order able transport o    delete effect move l    l     namely
at v  l     relaxed plan relevant 
if  task satisfying prerequisites lemma    optimal starting action
relaxed plan relevant delete effects  one apply case  a  proof lemma   
obtain smaller h  value  bound maximal exit distance benches 
need identify maximum number steps happen 
lemma   given solvable strips task  a  i  g  satisfies prerequisites
lemma    let constant that  every non dead end state s 
optimal plan ha            d th action  ad   relaxed plan relevant delete effects  mbed s      
proof  let reachable state     gd s       let ha            optimal plan
 a  s  g   ad relaxed plan relevant delete effects  denote    n 
si    result s  ha            ai i   argumentation lemma    h   si   h   s 
i  consider state sd    prerequisite  optimal relaxed plan

 
 a  sd    g  form   a             a m i  del ad    g
i   pre ai       
 
 
 
 
then  obviously  ha            relaxed plan sd   h  sd   h  sd      
distance sd     lemma follows 
 
lemma   directly applied     domains qualify lemma   
proof argument can  somewhat general version  applied   domains
well namely  ferry gripper  loading object deletes space vehicle
one domain namely  miconic simple  uses simple adl constructs 
domains proved upper bound maximal exit distance
benches  and or upper bound maximal exit distance local minima  
proof arguments  a lot  sometimes  complicated  reconsidering illustrative
example  stated load unload actions relaxed plan relevant delete
effects  move actions do  now  obviously  since two locations accessible
single move  optimal plan applies one move action
row  i e   optimal plan first second action load unload 
lemma   tells us maximal exit distance benches bounded   
similar argument applied transportation domains every pair
locations connected via single move  as in  example  logistics   generally 
 the standard encoding of  transportation domain constraints  regarding 
example  fuel   undirected road map graph  exit distance bounded
diameter road map graph  i e   maximum distance two locations
 nodes  graph  worst thing solution plan might traverse
entire road map loading unloading object   
    directed road map graphs  explained above  local minima arise  technically  lemma  
applied  lemma   applied either 

   

fihoffmann

   planning domain taxonomy
list proved results  brief explanations obtained results 
summarize results form planning domain taxonomy 
group positive results prove non existence topological
phenomena problematic heuristic search together single theorems 
negative results shown separately sketching counter examples  consider dead
ends  local minima  benches order  remember that  respect dead ends 
problematic case heuristic search unrecognized dead ends  c f 
section     
theorem   state space solvable instance
   blocksworld arm  blocksworld no arm  briefcaseworld  depots  driverlog  ferry 
fridge  gripper  hanoi  logistics undirected 
   grid  miconic simple  miconic strips  movie  pipesworld  psr  satellite 
simple tsp  tireworld  zenotravel harmless 
   dining philosophers  optical telegraph  rovers  schedule recognized evaluation h   
blocksworld arm  blocksworld no arm  driverlog  ferry  gripper  hanoi  logistics  lemma   directly applied  briefcaseworld  depots  fridge  due
subtleties actions invertible syntactical sense  easy show
every action inverse counterpart  movie  miconic strips  simple tsp 
tireworld  lemma   directly applied  grid miconic simple similar proof
arguments used lemma   suffice  pipesworld  psr  satellite  zenotravel 
easy to see individual domain properties prove absence dead ends  domains dead ends recognized h    individual domain properties exploited
proofs somewhat involved  example  rovers plan state
if  soil rock samples images need taken  rover
job  communicate gathered data lander 
chance run dead end take soil rock sample rover reach
lander  the soil rock sample available once   then  relaxed plan
state either 
  domains mentioned theorem    airport  assembly  freecell  miconicadl  mprime  mystery   easy construct arbitrarily deep unrecognized dead ends
 arbitrarily long paths unrecognized dead ends   example  mystery mprime
relaxed plan still achieve goal situations much fuel consumed
already  airport  two planes block others paths may move across
relaxed plan 
positive results regarding local minima these 
theorem   h    maximal local minimum exit distance state space
solvable instance
   

fiwhere ignoring delete lists works

   blocksworld no arm  briefcaseworld  ferry  fridge  grid  gripper  hanoi  logistics 
miconic simple  miconic strips  movie  simple tsp  tireworld   
   zenotravel    satellite    schedule    diningphilosophers    
ferry  gripper  logistics  miconic strips  movie  simple tsp  tireworld 
lemma   applied  fridge miconic simple  actions adhere syntactically definitions invertibility  no  relevant delete effects  similar
semantics  lemma   directly applied  similar arguments suffice  easy
see actions respected relaxation  proof lemma   individually adapted take account particular properties regarding invertibility
relevant delete effects   for example  passenger gets lift miconic simple 
delete effect passenger longer inside lift  matter
since passenger reached destination   blocksworld no arm  briefcaseworld 
grid  rather individual  and sometimes quite involved  arguments prove absence
local minima h    proof method is  cases  consider state
identify flat path state better h  value  example  grid done
moving along path locations contained relaxed plan s  key
picked up put down  lock opened  this simplified description 
actual procedure quite complicated   hanoi  one prove optimal relaxed
solution length state equal number discs yet final
goal position  suffices optimal plan moves disc away final position  note that  thus  hanoi state spaces h  sequence benches decreasing
exponentially diameter size 
zenotravel  satellite  schedule  proofs proceed identifying constant
number steps suffices execute one action optimal relaxed plan state
s  and  without deleting relevant add effects  re achieve relevant facts
deleted a  dining philosophers  as well optical telegraph   due subtleties
pddl encoding was  said  obtained automatic compilation
automata based promela language  edelkamp      a  h  loosely connected
goal distance  relaxation  automaton  for example  philosopher  always
block   actions  bound dining philosophers follows
rather constant restrictive domain structure  constant number process
transitions  namely    always suffices block one philosopher  proved bound
derived this  considering   planning actions needed process
transition  certain additional actions may needed due subtleties
pddl encoding  where process two internal states   remark
bound valid even trivial heuristic function returning number yet
un blocked philosophers  fact  proof h  viewed corollary proof
heuristic function  get back end section  finally remark
highest exit distance h  could actually construct dining philosophers
    conjecture  tight  upper bound 
satellite  schedule  zenotravel  proved upper bounds tight 
dining philosophers  satellite  schedule  zenotravel  bounds valid nondead end state s  so  beside bound local minimum exit distance  results
   

fihoffmann

provide bound bench exit distance  re used
section 
airport  assembly  freecell  miconic adl  mprime  mystery  stated
unrecognized dead ends  proposition   local minimum exit distance
domains unbounded  domains mentioned theorem    i e  
blocksworld arm  depots  driverlog  optical telegraph  pipesworld  psr  rovers  one
construct local minima arbitrarily large exit distances  complicated
example optical telegraph  where  difference dining philosophers  one construct
situations number process state transitions needed block one process
arbitrarily high  optical telegraph basically version dining philosophers
complicated philosophers  freedom next  freedom enables
situations whole row philosophers table must perform two transitions
order block one philosopher  details appendix a    simpler example
blocksworld arm  as well depots  blocksworld arm situations embedded  
consider following situation  n blocks b            bn initially form stack
bi bi   bn table  goal build stack top
another block bn     i e   goal stack b            bn   bn     reaching  initial state 
state better h  value involves disassembling entire stack b            bn  
disassembling process  h  increases  note basically extended version
illustrative example figure   
interesting side remark  note proved topological difference
blocksworld arm blocksworld no arm  latter  local minima
h    former  exit distance arbitrarily large 
intriguing  quite clear general message learn it  one might
interpret telling us  formal way  encoding details significant impact
topology  search performance  ff  example  much efficient
blocksworld no arm blocksworld arm  noted  however  two
domains differ semantically  namely plans blocksworld no arm half
long plans blocksworld arm  practical point view  would interesting
explore blocksworld observation generalized encoding methods trying
model domain way making best suited h    said
section   
positive results regarding benches these 
theorem   h    maximal bench exit distance state space solvable
instance simple tsp    ferry    gripper    logistics
   miconic simple    miconic strips    movie   
zenotravel    satellite    schedule    tireworld
   dining philosophers    
simple tsp  ferry  gripper  logistics  miconic strips  movie  tireworld 
lemma   directly applied  determining actions  no  relaxed plan relevant delete effects easy domains  tireworld somewhat complicated
see when  latest  action applied optimal plan  miconicsimple  similar arguments lemma   suffice  zenotravel  satellite  schedule 
dining philosophers  respective bounds shown already 
   

fiwhere ignoring delete lists works

note that  simple tsp  proved local minima exit
distance    implies h  is  fact  identical real goal distance  entire
state space consists contours global minima 
topological distinctions divide planning domains taxonomy classes
differ terms behavior state spaces respect h    visualization
taxonomy  results    investigated domains  given figure   

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed    c

mlmed    c

hanoi    
blocksworldnoarm    
fridge    
grid    
briefcaseworld    

logistics      
ferry      
gripper      
undirected

tireworld      
satellite      
zenotravel      
miconicsimple      
miconicstrips      
movie      
simpletsp      
harmless

diningphil         
schedule      

recognized

unrecognized

figure    planning domain taxonomy  overviewing results 
taxonomy  shown figure    two dimensions  x axis corresponds
four dead end classes  y axis corresponds existence non existence constant
upper bounds local minimum exit distance  bench exit distance  note
visualization makes simplifying assumption domains bounded
bench exit distance subset ones bounded local minimum exit distance 
assumption justified general  holds true specific collection domains 
also  question whether bound difficulty escaping benches
seem relevant when  anyway  arbitrarily difficult escape local minima   
specific bounds proved individual domains given parentheses  local minimum
exit distance bound preceding bench exit distance bound cases both 
bottom right corner taxonomy crossed domain belong
respective classes   
    similarly  benches arbitrarily large relevant local minima
small non existent  sense respective results briefcaseworld  fridge  grid  blocksworldno arm  hanoi moderately important  still constitute interesting properties
domains 
    proposition    existence unrecognized dead ends implies non existence constant upper
bounds local minimum exit distance  given states gd s       h   s      
states exist  domain features derived predicates appear negated negation

   

fihoffmann

figure   suggests h   approximating heuristic planners fast
many common benchmark domains lie easy regions taxonomy 
concretely  described introduction  provided h  function  ffs
search algorithm enforced hill climbing polynomial domains located lowermost classes taxonomy  i e   domains constant bounds maximal
exit distances   empirical perspective  distinction lines taxonomy
coincide quite well practical performance ff  excels       domains
belong lowermost classes taxonomy  the difficult domain diningphilosophers  whose upper bound exceptionally high     middle domains  no
local minima potentially large benches  performs well  scale
comfortably easier domains  complex domains  blocksworld arm 
depots  driverlog  optical telegraph  pipesworld  psr amongst challenging domains ff  mprime mystery  performs bad
planners  freecell miconic adl  among top performing planners  often
runs unrecognized dead ends larger instances  for example  larger freecell
instances used aips        airport  assembly rovers  performs pretty well
respective competition example suites  however  domains competition suites
hardly explore worst cases domain topology  details appendix a  
discuss detail relation taxonomy empirical performance heuristic planners make use h  approximation one
way  one observation definitely made planners
trouble solving instances domains extreme h  properties 
simple tsp  ferry  gripper  logistics  miconic simple  miconic strips  movie 
extent zenotravel  planners scale comfortably  particular 
scale much comfortably domains typically
domains  least without additional  for example  goal ordering  techniques 
next section  treat connection taxonomy ffs performance
analytical way  relating properties h  properties ffs approximation
h    called hf f   so  remarks relation taxonomy
complexity theory order  question whether provable relation  i e  
relation distinction lines taxonomy  complexity deciding
plan existence respective domains  able construct np hard domain
 a domain deciding plan existence np hard  h  yield local
minima  maximal bench exit distance domain is  however  unbounded  tried 
able come np hard domain constant bounds
maximal exit distances  remains open question whether domain exists
not  answer yes  lowermost classes taxonomy form group
domains worst case hard  typically easy solve  at least far

normal form goal condition  even then  presence unrecognized dead ends
would fake global minima  i e   global minima consisting non solution states  fact consisting
unrecognized dead ends 

   

fiwhere ignoring delete lists works

reflected hitherto benchmarks   answer no  identified
large polynomial sub class planning   
talking polynomial sub classes  intriguing observation made
trivial heuristic function returning  state s  number goals true
s  lets call function hg   little thinking  one realizes that  fact 
   domains proved constant bounds maximal exit distances h 
constant bounds hg   hand  remaining      
domains  except miconic adl  easy see constant bounds hg  
logistics  example  clearly maximum number steps needed achieve one
goal       steps  move  load  move  unload  within packages origin city 
origin city destination city  within destination city  diningphilosophers  example  upper bound h  was  said  proved corollary
upper bound hg   blocksworld  example  clearly take arbitrarily many
steps achieve one goal  namely block must moved buried beneath n
blocks need moved 
observation appears rather significant first sight  probably
important  neither theory practice  one thing  coincidence that 
here  set domains constant bounds h  set
domains constant bounds hg   simple counter example general
case graph search domain  task find path two nodes
directed graph  using obvious at predicate connected predicate based encoding 
there  h  equal real goal distance  since one never needs move back  
hg can  clearly  arbitrarily bad  another thing  domains logistics
constant exit distance bounds hg   bounds large practically useful 
example  h    needs look   steps forward breadth first
search iteration enforced hill climbing  logistics instance  hg   breadth first
searches depth    would needed  so  most  observation regarding hg
noteworthy statement current planning benchmarks  remains open question
whether  coincidental  correspondence bounds h    hg  
investigated    domains  exploited for  e g   detecting bounds automatically 

   relating h  hf f
discussion relating h  hf f structured two separate sections  first one
briefly discusses provable relations h  hf f   second section summarizes
results large scale empirical investigation aimed identifying extent
topological properties h    benchmarks  get preserved hf f  
    provable relations h  hf f
one thing easy observe behavior h  hf f provably
respect dead ends  i e   heuristics return cases 
simply heuristics return state iff relaxed plan s 
    presumably  prove latter  one would need characterize class purely syntactic manner
level pddl definitions  since h  derived directly pddl syntax  authors wild
guess going work  answer yes 

   

fihoffmann

h  follows definition  hf f follows completeness  relative
relaxation  algorithm computes relaxed plans  hoffmann   nebel      a  
algorithm relaxed version graphplan  blum   furst               state s 
runs graphplan task initial state  delete lists actions
empty  without delete lists  graphplan guaranteed terminate polynomial time 
graphplan terminates unsuccessfully  hf f  s  set   otherwise  number
actions returned plan taken heuristic value hf f  s  state    graphplan
complete algorithm terminates successfully plan
hf f set iff relaxed plan s  follows dead end classes
benchmarks h  hf f  
relaxed plans found graphplan  just general strips  property
optimal terms number parallel time steps  terms
number actions  so  general  hf f h   even p np  
uses following heuristic techniques action choice relaxed graphplan  aiming
minimizing number selected actions  hoffmann   nebel      a   first  fact
achieved noop  a dummy action propagating fact time step time
step     graphplans planning graph   noop selected  guarantees
every non noop action selected  of course  selected noop actions
counted relaxed plan   second  noop available action
minimal precondition weight chosen  weight defined summedup indices first layers appearance  in planning graph  precondition
facts  third  actions selected parallel time step assumed linearized
order selection  action selected a  assumed achieve fact
p add a  pre a    even a  selected parallel time step 
two restrictive sub classes strips hf f provably
h    first demands every fact one achiever 
proposition   let  a  i  g  strips planning task that  facts p 
one action p add a   then  states task  h   s    hf f  s  
proof  proposition follows observation that  running relaxed graphplan  choice points action selection  choice points always
empty unary case  implies actions selected graphplan
contained relaxed plan  detail  latter proved induction
regression steps relaxed graphplan  let state relaxed
plan  top level regression  actions selected support goals
contained s  goals need supported relaxed plan 
actions so  holds true preconditions selected
actions  p pre a  s  supporter must present relaxed plan 
supporter selected relaxed graphplan  iterating argument  get
desired property  claim follows because  proved hoffmann nebel
     a   relaxed graphplan selects every action once 
 
    note estimate sequential relaxed plan length  length planning graph built
graphplan corresponds optimal length parallel relaxed plan  admissible heuristic estimate 
however  indicated before  heuristic functions generally found provide useful
search guidance practice  see  example  haslum   geffner        bonet   geffner      b  

   

fiwhere ignoring delete lists works

second sub class strips demands one goal 
one precondition per action 
proposition   let  a  i  g  strips planning task  g    and  a 
 pre a      then  states task  h   s    hf f  s  
proof  given restrictions  relaxed planning comes finding paths
graph nodes facts  edge p p  iff action
pre a    p add a    p   empty preconditions modelled special fact
node assumed always true   state relaxed plan iff makes fact node
true path goal node  relaxed graphplan identifies shortest
path 
 
prerequisites propositions     maximally generous  i e   relaxing one
requirements  one loses h   s    hf f  s  property  obtain sub optimal relaxed
plans graphplan  i e   construct cases h   s     hf f  s   suffices one
fact two achievers  either two goal facts one action two preconditions 
following example  facts g    g    p  p    goal  g    g    
current state empty  actions shown figure   
name
opg 
opg   p
opg   p 
opp
opp 

 
 
 
 
 

 pre 

add 

del 

  p  
  p  
  p    
  
  

 g    
 g    
 g    
 p  
 p    

 
 
 
 
 

figure    actions example task hf f    h   
optimal relaxed plan hopp  opg    opg   pi  however  graphplan might choose
achieve g  opg   p    ending  parallel  relaxed plan h opp  opp      opg   
opg   p   i  note action single precondition  single fact
one achiever  two goals  similar example constructed
case one goal one action two preconditions 
obviously  syntax allowed either propositions     far restrictive
adequate formulating practical domains    investigate whether
interesting situations h  hf f same  intuition
case 
different question whether provable relations h  hf f  some
of     benchmark domains considered h  investigation  investigate
question detail note investigation would involve constructing detailed
    remark syntax identified proposition   sub class tractable class strips
planning identified bylander         bylanders class  constant number g goal facts allowed 
g greater    preconditions may positive negative 

   

fihoffmann

arguments individual domains  clearly beyond scope paper 
none domains captured either propositions      results
easy obtain following  simple tsp  movie  miconic strips  h  hf f
same  follows extremely simple structure domains 
finding step optimal relaxed plans graphplan always results relaxed plans
optimal number actions  however  even slightly complicated domains
ferry  gripper  logistics  miconic simple  zenotravel  one easily construct states
graphplans relaxed plans may unnecessarily long  miconic strips
happen single vehicle  the lift   capacity restrictions
 on number loaded objects  i e   passengers   several vehicles transportable
objects  occur logistics zenotravel  as well driverlog  depots  mprime 
mystery  rovers   difference h  hf f become arbitrarily large 
imagine n objects must transported l l    n vehicles available
l  parallel relaxed planning  makes difference single vehicle transports
objects  one different vehicle selected per individual object  particular  even
ffs action choice heuristics relaxed graphplan  hf f may  n     well  n   
ferry gripper  single vehicle  with capacity restrictions  
may upper bound difference h  hf f  
check detail 
spite above  authors personal experience developing that 
least relatively simply structured domains many different operators different
ways achieve facts  relaxed plans found relaxed graphplan typically pretty
close optimal  are  presumably  following two reasons this  first 
employed action choice heuristics  example  grid domain  relaxed plan may
choose pick key k sole purpose dropping picking
another key k  pickup and lose action  c f  appendix b      happen
selecting actions minimal precondition weight  the pickup and lose action
higher weight pickup action unless one already holds k considered state  
second  many published benchmark instance suites quite restricted  logistics 
example  situation outlined above  n objects n vehicles waiting location l 
happen trucks single truck city  airplanes 
published benchmark instances usually these  n
small 
    empirical relations h  hf f
large scale empirical investigation  hoffmann      b   turned hf f typically
preserves quality h    investigation aimed verifying  domains
h  positive topological property  for example  yielding local minima  
extent property inherited hf f   considered    benchmark domains 
namely domains paper hand  except    ipc   ipc   domains 
    one could circumvent particular phenomenon by  selecting action relaxed graphplan 
employing minimization summed weight preconditions actions selected far 
topic future work explore effect ffs performance 

   

fiwhere ignoring delete lists works

note that  latter    domains  three  namely dining philosophers  satellite 
zenotravel  positive topological properties 
experimental approach take samples state spaces  a technique adapted
work frank et al          precisely  method following 
domain  random generator used produce large set example instances 
instances grouped together according values domain parameters  i e  
input parameters generator  for example  number floors number passengers
miconic simple   then  single instance      states sampled  i e      
random sequences actions executed initial state  sequence length
chosen randomly interval     times ffs plan length   
resulting state s  exit distance ed s  computed breadth first search  another
search determined whether located valley  i e   whether path
goal state hf f value decreased monotonically    maximal exit
distance instance approximated maximum exit distances
sample states  every group instances  mean number states valleys 
mean maximal exit distance  computed  results visualized plotting
values scaling domain parameters  give examples directly below 
summarizing overall results 
results experiment strongly suggested hf f typically preserves quality
h    considered benchmark domains     domains h  provably yields
local minima  almost sample states located valleys except   domains 
namely grid hanoi  precisely     domains experiment considered
total     groups random instances  one groups       sample states
lay valleys  another group       another eight groups      
remaining     groups single valley state found  maximal
exit distance benches  tested instances domains bound
h    single sample state exit distance larger bound  namely
exit distance   instead   logistics domain   
blocksworld no arm
gripper
hanoi
tireworld

   
   
   
   

   
   
   
   

   
   
    
   

   
   
     
   

   
   
     
   

figure    percentage sample states valleys  mean values linear increase
respective domain parameter 
figure   provides results regarding sample states valleys  considered
domains local minima  and thus valleys  h    in    tried sampling strategies found make much difference terms
obtained results 
    intuitively  local minimum lies bottom valley  used valleys experiment since
may hard find local minimum state sampling 
    authors guess results similar empirical investigation dining philosophers  satellite 
zenotravel would similar  i e   sampled maximal exit distances would hardly increase
upper bounds proved h   

   

fihoffmann

stances characterized single domain parameter  movie simple tsp left
since hf f provably h     blocksworld no arm  parameter
number blocks  plus randomization initial goal states   gripper
number balls transported  hanoi number discs  tireworld
number flat tires  domain  left right table entries correspond
linear increase domain parameter             blocks              balls             discs 
          tires  respectively   obviously  domain behave hanoi
h  isnt useful heuristic anyway  yielding large benches  c f  section   
blocksworld no arm
gripper
hanoi
tireworld

   
   
   
   

   
   
    
   

   
   
    
   

   
   
   
   

   
   
   
   

figure    sampled maximal exit distance  mean values linear increase respective
domain parameter 
figure   shows results regarding sampled maximal exit distance domains
characterized single domain parameter  gripper tireworld  sampled values
respect bound valid h   in largest tireworld example  sampling
find maximum state rather large state space   comparison  sampled values
blocksworld no arm  bound h    show clear increase  again 
behavior hanoi odd 
figure   shows  part of  results domain characterized one
domain parameter  namely logistics  domains least two domain parameters 
experimental method run one experiment pair them  experiment 
parameters except respective pair set fixed value  data could
visualized   dimensional plots ones figure    figure  parameters
scaled number cities number objects  packages  transported 
parameter range           cases  city size number airplanes
fixed    parameter value combination     random instances generated  and
    states sampled per instance   valley states found  except   cities
  objects         sample states located valley    cities
  objects  single instance one sample state exit distance    rather bound
  valid h  single bound violation found entire experiment   
indicated before  grid domain was  hanoi  domain
experiment suggested major difference topologies h  hf f   large
fractions sample states         located valleys  clear
tendency increase percentage  increasing grid size increasing
number keys transported 
all  experiment confirmed that  blocksworld no arm  briefcaseworld  ferry  fridge  gripper  logistics  miconic simple  tireworld domains  hf f
    decrease mean sampled maximal exit distance large parameter values suggests
becomes harder  sampling  find maximum states rather large state spaces 

   

fiwhere ignoring delete lists works

z

z

 

 

   

 

 

 
 

 

 
 

 
 

 

 
x

 

 


 


 

 
 

x

   

 a 

 
 

   

 b 

figure    mean sampled valley percentage  a  maximal exit distance  b  logistics 
scaling cities  x axis  objects  y axis  
largely preserves quality h   no local minima and or constant bound maximal exit distance benches   remember miconic strips  movie  simple tsp
three domains this  provably  applies 

   towards automatically detecting h  phenomena
lemmas presented section   provide natural starting point investigations
domain analysis techniques trying detect topological phenomena automatically 
domain analysis techniques would useful configuring hybrid systems  i e  
automatic selection heuristic functions likely well suited solving given
planning task  further  techniques would useful avoiding need re do
h  investigation every single new planning domain  finally  basis
analysis techniques one may able compute good lower bounds h   
informative admissible heuristic function  discussion points contained
section   
question addressed if  extent  how  application
lemmas section   automated  i e   one automatically check
whether prerequisites satisfied given strips task  section hand 
present preliminary attempt made that  attempt
successful  believe investigation value showing one achieve
simple analysis techniques  weak points would needed improved
upon order obtain better results 
invertible  or least invertible  actions  actions irrelevant delete static add
effects  syntactically defined section   thus easy detect  difficulty
find inconsistencies facts  hard planning itself 
several approximation techniques literature  for example  blum   furst             
fox   long        gerevini   schubert              rintanen         tend work
well  least current benchmarks  challenge find syntactical
characterizations actions respected relaxation  actions
   

fihoffmann

relaxed plan relevant delete effects  now  many domains phenomena
occur  example ferry  gripper  logistics  miconic strips  movie  simple tsp 
tireworld  intuitively one looks domains causes phenomena
seem similar  getting actual syntax domain descriptions 
individual details different becomes difficult get hold
common ground  seem simple syntactical definition captures
behavior actions domains  least find syntactical
definition  instead  tried reason additive structure domains 
possible interactions delete effects   the intuition that  domains
simple h  topology  interactions arent harmful   captured
additive structure domain of instance data structure called fact generation
trees  next subsection describes data structure basic properties 
subsection gives results extreme case h  topology  subsection outlines
somewhat advanced analysis technique developed 
    fact generation trees
fact generation tree  short fgt  planning instance basically and or tree
results regression search starting goals  ignoring delete effects
actions  tree nodes labelled facts actions alternatingly  fact nodes
nodes represent choice achieving actions action nodes nodes
preconditions represent sets facts must achieved together  assume goal
achievement action  known from  example  description ucpop  penberthy  
weld         action root  and  node fgt  top level goals form
sons  obviously  sons fact node actions achieve fact 
sons action node precondition facts action   for sake
simplicity  stayed pure strips framework investigation   tree structures
kind were  example  described used nebel  dimopoulos  koehler       
work automatically detecting irrelevant facts operators  note fgt
take account interactions may arise trying achieve facts
node together  effect ignoring delete lists  fgt treats
facts completely separately 
terminate fgt applying following two rules 
   say inserted action node n  a  labeled action a  fact
p pre a  fact node labeled p occurs path root node
n  a   n  a  pruned 
   say inserted  son action node n  a   fact node n  p  labeled
fact p  action a  p pre a     action node labeled
a  occurs path root node n  a   n  p  pruned 
intuitively  rules disallow generation branches fgt would redundant relaxed plan  formally  call relaxed plan non redundant strict subsequence still relaxed plan  i e   action omitted   every non redundant
relaxed plan  every  not necessarily reachable  state  embedded connected 
rooted  non redundant sub tree fgt built way described above 
   

fiwhere ignoring delete lists works

precise introducing illustrative example figure     use
throughout section 

e

e

     eur

mv e


     eur

b

c


  eur


mv b

mv c

b

c

mv c

mv b



figure     sketch fgt illustrative example 
example  task reach location e  available actions moves along
 bi directional  graph edges obvious encoding using predicate  except
move e  requires additional precondition possession
  eur  acquire   eur add effect action moves
c  main part figure    shows fgt example  picture top left
corner illustrates example showing road map graph indication role
  eur constructs  root node  i e   artificial goal achievement action 
included figure  simplicity  due termination rule     for example  moving
e included son fact node labeled  the precondition e
root node   due termination rule    son action node labeled
mv c  at already occurs precondition mv e above  
every action non redundant relaxed plan  to arbitrary state  achieves
unique needed fact achieved preceding action  needed
goal precondition subsequent action    overly difficult prove
one thus embed relaxed plan fgt processing relaxed plan
back front  associating action corresponding node needed
fact added action  starting goal facts  resulting sub tree connected
rooted sense actions associated consecutive nodes  starting
root node  sub tree non redundant sense that  every node 
    observation made by  example  hoffmann nebel      b   used detect
actions participate non redundant relaxed plan  thus need
considered heuristic computations done planners hsp 

   

fihoffmann

one son gets associated action  termination rule   valid since fact needed
end relaxed plan needed start  termination rule   valid
since every needed fact least one representative node corresponding subtree  illustration  consider different locations graph underlying example
figure     one located  example    eur 
entire fgt except mv c node corresponds sub tree non redundant
relaxed plan  sub tree obtained follows  relaxed plan mv b  mv b
d  mv c  mv e  needed facts added actions b  d   
eur  e  respectively  starting goal fact e  first mv e gets
associated respective action node  fact nodes   eur
preconditions action dealt become open  mv b well
mv c get associated respective node respective needed fact 
consequence mv b action  fact node b becomes open  mv b gets
associated action node it  process stops  if  current state 
one is  example  located c   eur  process selects sub tree
consists mv c mv e nodes only 
every non redundant relaxed plan instance  particular every optimal relaxed
plan instance  corresponds sub tree fgt  fgt summary
possible relaxed plans sense  idea examine fgt harmful interactions
conflicts potential appear relaxed plan  hope able draw
conclusions non existence restricted form conflicts topological properties
h    next outline extreme case analysis kind  namely one postulates
absence conflicts fgt  note that  difference situation
illustrative example  general fgt contain action fact labels multiple nodes 
worst case size fgt exponential size instance description  so 
design practically usable domain analysis techniques  one would need approximate
fgt  instead building completely  aspect treated follows 
objective  only  find implications fgt structure h  topology
first place 
    interaction free planning tasks
think conflict situation one part  non redundant  relaxed plan
hinder execution success another part relaxed plan 
conflicts  every  non redundant  relaxed plan executable reality  implying
h  equal real goal distance  which course implies local minima
etc   investigated    benchmark domains  case  only  simple tsp 
use motivating example 
define three kinds conflicts fgt  call two action nodes  labeled
actions a    allied participate together non redundant sub tree  i e  
occur together embedding relaxed plan  descendants
other   this case iff paths root node a  separate
node   first kind conflicts given pair allied action nodes labeled a   
deletes precondition a    second kind conflicts  pair action nodes labeled
a    descendant a    deletes precondition a  added
   

fiwhere ignoring delete lists works

action path a    third kind  action node labeled a 
deletes goal fact added action path respective root
node 
conflicts fgt  call task interaction free  relatively
easy see that  without conflicts  every non redundant relaxed plan  for every nonredundant sub tree fgt  execution order works reality  h 
equals goal distance interaction free tasks 
illustrative example figure     conflict fgt
nodes mv c mv e nodes allied  mv c deletes
precondition mv e  note conflict indeed capture reason
h  equal goal distance example  order able move
e  one first move c get   eur  latter deletes
precondition former  relaxation  move c  one
located c time  relaxed plan needs one step less
achieve goal  from states move c yet done  
example domain interaction free tasks graph search domain mentioned earlier  tasks demand find path two nodes directed
graph  using obvious at predicate connected predicate based encoding   our
illustrative example becomes instance domain one removes   eur
constructs   even come purely syntactic criterion captures
example domain 
proposition   let  a  i  g  strips planning task
    g    
   a   pre a     
   a  del a  pre a  
 a  i  g  interaction free 
proof  due prerequisites      nodes fgt one son 
implies allied action nodes  together prerequisite  
termination rule    implies action node delete goal fact  precondition
fact ancestor node 
 
instances graph search domain fulfill prerequisites proposition  
static connected facts removed prior planning  note syntax identified
proposition   subset syntax identified proposition    thus tasks
hf f identical h    and  since h  identical real goal distance  plan existence
decided polynomial time  intuitively  captured syntax
express graph search domain  plans task qualifying proposition  
correspond exactly paths graph nodes facts  edges go
preconditions add effects  true relaxed plans 
instances simple tsp domain interaction free  conflicts
fgt pairs actions achieving different visited goals  example  say
   

fihoffmann

three locations visit  l    l    l    action nodes mv l  l  mv l 
l  allied since achieve goals visited l  visited l  participate
root node  actions mutually delete precondition  l   
constitute conflict fgt  appear together relaxed plan 
relaxed plan executable reality  unless relaxed plan happens move back
l  between   observe  however  execution of  example  mv l  l    one
replace mv l  l  mv l  l  repair conflict relaxed plan 
conflicts simple tsp fgts behave way 
general  say conflict allied action nodes a  repaired
action a   pre a      pre a  add a     del a   thus a   executed
a   add a     add a     thus a   achieves a  achieved   similar
repairable cases identified two kinds conflicts  conflicts
fgt repaired  non redundant relaxed plan relaxed plan
length executable reality  h  equals goal distance 
case simple tsp domain 
made preliminary implementation fgt analysis techniques 
implementation correctly detects simple tsp instances  as well graph search
instances   h  equals goal distance  simple tsp  less    locations analysis
takes split seconds     locations  runtime taken explodes fairly
quickly 
    advanced analysis
results encouraging  techniques applicability h  topology
detect clearly far severely restricted  turns extremely difficult find
less restrictive implications fgt structure h  topology  i e   sufficient criteria
weaker topological properties  best could come criterion implies
non existence local minima h    holds true movie domain
extremely simple logistics instances 
idea behind criterion following  imply non existence local
minima h    suffices know that  every state s  starting action
optimal solution h   result s  hai   h   s   say considering planning
task actions  at least  invertible  let state starting action
optimal solution s  optimal relaxed plan contains a 
done argument used lemma    else  let p   optimal relaxed plan
contain a  p   embedded sub tree fgt 
delete leaf nodes sub tree facts p   assumes true state
execution p   relaxed plan result s  hai  done  too  case left
open delete leaf node sub tree occupied p     observe
matter  or repairable  conflicts sub tree 
then  p   executable reality  p   optimal plan s  starting action
p   falls first case done again  get following sufficient
criterion 
   

fiwhere ignoring delete lists works

local minima h  actions holds least
invertible  non redundant sub trees fgt contain a  either
delete leaf sub tree  sub tree contain conflicts 
test criterion  one needs consider  redundant  sub tree fgt
branches left start nodes labeled a  sub tree
contains conflict  deletes fact occurring sub tree  criterion
apply  otherwise  test succeeds actions  proved local
minima h   
reconsider illustrative example figure     said conflict
fgt nodes mv c mv e  sub tree
contain one nodes conflict free  mv c mv e violate
criterion  neither mv b d  mv c d  mv b violate criterion  since
none actions deletes fact occurring anywhere else precondition 
however  mv b mv b sub tree looked entire fgt including
conflict  actions delete fact occurs fgt  criterion
apply illustrative example  note mv b mv b never start
optimal plan really could left considerations  unclear
detect automatically  general way 
remark side order here  action appear fgt  then 
difference one may think first sight  imply appear
optimal plan  fgt termination rules  adequate relaxed planning 
restrictive real planning  following example  facts g    g   
p  goal  g    g     current state  g     actions shown figure    
name
opp
opg 
opg 

 
 
 

 pre 

add 

del 

  g    
  
  p  

 p  
 g    
 g    

 
 g    
 

figure     actions example task fgt contain action  opp 
namely  needed reality 
optimal plan hopp  opg    opg  i  order able re achieve g 
applying opg    must achieve p first  however  opp appear fgt 
location fgt node n labeled opp could inserted
son precondition node p opg    inserted son g    n pruned
termination rule    opp g  precondition  g  appears path
root node n   note that  indeed  opp never part relaxed plan
achieving p good re achieving g  deleted actions necessary
reach goals 
implementation criterion given easily within split seconds proves
non existence local minima movie instances  regardless size instance 
   

fihoffmann

technique not  however  work domain tried  except logistics
instances single city  two locations it  single truck 
single package transported  note even simpler small
illustrative example used section    two objects need transported 
open question better results achieved  i e   state spaces
recognized feature local minima h    feeling backward
chaining approach domain analysis promising  but  successful  analysis
technique probably invest much effort analyzing way
goals achieved  many steps  rather crude
fgt approximation  information available goals achieved 
maybe would possible discover non trivial cases actions respected
relaxation    detecting actions relaxed plan relevant delete effects 
yet completely unclear us could accomplished 

   discussion
derived formal background understanding classes domains relaxed plan based heuristic methods  wide spread methods modern planning
landscape time writing  well suited for  formal approach taken
identify characteristics local search topology heuristic cost surface
idealized heuristic function h    forward searching framework     commonly used
benchmark domains including competition examples  i e   basically strips
adl benchmark domains used field time writing  proved
relevant topological properties are  results coincide well runtime behavior
ff  indeed  empirical results suggest quality h  often preserved ffs
approximation it 
results interesting give rare example successful theoretical
analysis connections typical case problem structure  search performance 
practical point view  results provide clear picture strengths
weaknesses h  lie  form good basis embarking improving heuristic
weak cases  approaches kind already appeared literature  fox  
long        gerevini et al          particularly  fast downwards heuristic function
 helmert        motivated observations regarding unrecognized dead ends h 
mystery domain  large benches transportation domains non trivial road
maps 
regarding relevance topological results forward search algorithms
enforced hill climbing  note things non existence unrecognized dead
ends non existence local minima certainly useful heuristic search
algorithm  albeit form provable polynomiality result    generally 
relevance topological results performance planners using search
    remark easy find even trivial syntactical restrictions actions are 
general  respected relaxation  example  even every fact added single action 
one construct cases non respected actions  one case example figure    
opp respected relaxation 
    except case heuristic function identifies precise goal distances  case
h       domains  namely  simple tsp domain 

   

fiwhere ignoring delete lists works

paradigms  enhanced heuristics  lpg fast downward  matter needing investigation  one thing certainly clear that  easiest classes
taxonomy  particularly domains state space local minima h    benches escaped single step  planner using approximation
h  likely work quite well  indeed thats one observes practice  intuition
author topology h  plays large role efficiency planners
generally  i e   domains  proving disproving beyond scope
paper  case  investigation provides nice theoretical background
proved results idealized setting  results used starting point
investigations tailored individual systems ff 
investigation considers solvable planning tasks only  well justified
focus set international planning competitions  turning focus unsolvable tasks 
one realizes much techniques results become useless  search space
solution  difference heuristic function make lies states
infinite heuristic value  i e   states recognized dead ends  means
interesting question remaining kinds dead end states
relaxed plan  results herein tell us this  domains
identified unrecognized dead ends  results tell us relaxed plans generous
approximation    domains  things look hopeful  still  results
relative solvable instances  whether h  detect many dead end states
unsolvable tasks depend reasons states  dead
ends unsolvable tasks may caused reasons solvable tasks 
since assumptions making tasks solvable given  note many
benchmarks  for example  blocksworld logistics  unsolvable instances
standard definition  extent  makes existence non existence
unrecognized dead ends choice domain designer extending domain definition 
exploring issues detail topic future work 
talking future work  biggest drawback research current form is 
obviously  needs re done every single new planning domain  would
desirable  turns hard  come generic ideally  automatic
methods determine topological properties domain  outlined
attempt made develop automatic methods  based analyzing properties fact
generation trees  presented first promising results  regarding applicability
domains complexity one would able handle  methods yet far
weak  left future research answer question approaches
topic work better practice  said  intuition better
approaches  based intelligent backchaining style reasoning goals
achieved domain  but  time writing  pure speculation 
beside easening burden proofs hand  benefits automatic domain analysis techniques would twofold  first  ambitious long term vision domainindependent planning arsenal complementary heuristics  combine
hybrid system automatically configured best suit given arbitrary
planning task  contribution made towards vision results hand
    unsurprisingly  seeing deciding plan existence np hard in  example  mystery  mprime  miconicadl  freecell  helmert        

   

fihoffmann

clear picture strengths h  lie  able automatically configure hybrid system  one would need multiple heuristics different strengths weaknesses
 i e   heuristics high quality different classes domains   well ability
determine automatically heuristic likely work best   at least approach could cost effective  beside much insightful  trying
possible combinations techniques  
another benefit enhanced domain analysis techniques might lie ability
generate high quality admissible heuristic function sequential planning  many domains  optimal relaxed plans mostly consist actions easy human
see  or one set similar actions  must contained optimal
relaxed plan  for example  loading unloading actions cant avoided
transportation task   number actions state could provide good lower
bound value h    note phenomenon actions must contained
every relaxed plan stronger version notion actions respected
relaxation  promising approach seems try detect former sufficient
approximation latter 
since observed arbitrarily deep local minima h  blocksworldarm  none blocksworld no arm  one might try come encoding methods
trying model domain way making best suited h    since blocksworld no arm
basically version blocksworld arm possible pairs consecutive actions
 pickup stack  unstack stack  unstack putdown  replaced macro actions  good
 but somewhat obvious  heuristic modeling probably choose domain granularity
high level abstraction possible  insightful heuristics may obtained
considering h  topology planning benchmarks enriched automatically
detected macro actions  botea  muller    schaeffer              
apart above  important future direction adaption formal
framework  theoretical analysis methods  temporal numeric settings
dealt modern planning benchmarks modern planning systems  needed
adaptations straightforward numeric framework used metric ff  hoffmann 
    a   temporal planning  objective function estimated heuristic
number actions needed complete partial plan  adaptation framework
probably straightforward well  if  however  makespan estimated heuristic 
said article apply  most  setting
analysis techniques could relevant search uses estimation remaining action
steps secondary heuristic 

acknowledgments
would thank drew mcdermott  fahiem bacchus  maria fox  derek long
responses various questions concerning definitions of intentions behind
competition domains  thank anonymous reviewers  whose comments helped
improve paper 

   

fiwhere ignoring delete lists works

appendix a  proof sketches
list proof sketches sections concerning dead ends  local minima  benches 
order 
a   dead ends
theorem   state space solvable instance
   blocksworld arm  blocksworld no arm  briefcaseworld  depots  driverlog  ferry 
fridge  gripper  hanoi  logistics undirected 
   grid  miconic simple  miconic strips  movie  pipesworld  psr  satellite 
simple tsp  tireworld  zenotravel harmless 
   dining philosophers  optical telegraph  rovers  schedule recognized evaluation h   
proofs simple applications lemma      said  descriptions
domains looked appendix b 
proof sketch   theorem   
actions blocksworld arm  blocksworld no arm  driverlog  ferry  gripper  hanoi 
logistics instances invertible  apply lemma   finished 
inverse actions obvious ones cases  stacking unstacking block onto from
block  loading unloading object onto from vehicle  moving l
l   moving l  l  in case driverlog  latter always done
underlying road map bi directional  c f  appendix b     briefcaseworld  depots 
fridge domains  actions strictly obey definition invertible
 neither least invertible   still invert obvious way 
i e   every state applicable action action result s  ha  ai    s 
movie  actions getting snacks irrelevant delete effects static add effects 
rewinding movie resetting counter least invertible  simple tsp action
moving l l  least invertible moving back  tireworld  working steps
inverse one  except inflating wheel  irrelevant delete effects
static add effects  miconic strips  moving lift invertible  boarding passenger
least invertible  departing passenger irrelevant delete effects static add
effects  four domains  lemma   thus applied  miconic simple
grid domains  actions strictly adhere relevant definitions  similar
arguments lemma   prove non existence dead ends  miconic simple  moving
lift invertible  letting passengers lift inverted 
actions need applied  similar static add effects  
interfere anything else  similar irrelevant deletes   grid  actions
inverse action  except opening lock  latter action excludes actions opening
lock  similar irrelevant deletes   lock needs opened once 
locks closed  static add effects   zenotravel satellite  facts
re achieved sometimes one apply several actions so  zenotravel 
   

fihoffmann

flying airplane l l    get back l  one might refuel airplane
top flying back  satellite  switching instrument on  one might recalibrate it  always done involve several actions  turning satellite
right direction applying actual calibration action   pipesworld 
push action inverted respective pop action  vice versa  state space
undirected since pushs pops non unitary pipeline segments split two parts 
psr  dead end states since one always reach goal state waiting 
necessary  opening breakers  bringing  non breaker  devices goal
position  closing needed breakers 
dining philosophers  dead ends arise process  a philosopher  initiated impossible reading writing command  from to empty a full queue 
queue contents updated  actions applicable   the derived
predicate rules determine process blocked apply case  since
require read write command initiated yet   obviously  applicable
actions relaxed plan either  states  goal reached
traversing individual process state transitions philosophers one fork  try
take other 
optical telegraph  dead ends arise two kinds situations  first  process
initiated impossible reading writing command  similarly dining philosophers 
applicable actions thus relaxed plan  second possibility
two processes pair may take different decisions go next communication sequence  one may decide stop data exchange  may decide
send receive data  situation  least one processes state
two transitions available  already activated one transitions 
might already initiated respective write read command  write read command
impossible  since process took different decision   actions
applicable process  derived predicate blocking rules apply
process  never apply process states one available transition 
neither real relaxed plan exist state  reachable states 
goal reached traversing individual process state transitions pairs
communicating processes occupy one control channel  try write other 
rovers  plan state if  soil rock samples images
need taken  rover job  communicate
gathered data lander  chance run dead end take soil rock
sample rover reach lander  the soil rock sample available once  
then  relaxed plan state either 
schedule  state gd s    solved applying  object
turn  certain sequence working steps  sequence applied object
follows preconditions needed action fulfilled  must
case cold  a do roll action applied previously 
making hot   operator make cold again  i e   operator adds respective
fact  thus relaxed plan either 
 
note worst cases theorem   occur  i e   domains whose instances
harmless  directed state transitions  domains whose instances
   

fiwhere ignoring delete lists works

recognized  dead ends  remark dead ends dining philosophers
optical telegraph due seem bugs encoding queues
 whose contents arent always updated correctly  blocked situations  whose rules
detection seem incomplete   modifying operators straightforward way
fix  apparent  bugs  one gets dead end free  harmless  state spaces 
domains mentioned theorem   airport  assembly  freecell  miconicadl  mprime  mystery  domains  one construct arbitrarily deep
unrecognized dead ends  airport  unrecognized dead ends arise two planes move
towards line segments  possibility changing direction 
deadlock situations arent recognized relaxed planning since  relaxation 
free space left two planes remains free  used navigate planes
across other  dead end becomes arbitrarily deep when  independently
deadlock situation  planes still moved  remark that  reality
ipc   example instances deadlock situations rarely occur  airplanes
movable along standard paths serve avoid deadlocks main connecting
routes airport  places airport deadlocks occur 
reality ipc   example instances  near parking areas  space
dense  airplanes need move directions airport segment 
deadlocks occur all  i e   planes move target positions one
without hindering other  h  delivers exact goal distance 
presumably reason heuristic planners performed well ipc   airport
test suites  performance would probably become worse one use  unrealistic 
instances excessively many potential deadlock situations 
assembly  unrecognized dead ends arise several objects stuck due
complex ordering constraints  imply solution plan would need go
cyclic assembly pattern  details rather complicated  interested reader
referred tr  hoffmann      c   proved that  unless ordering constraints
assembly instance potential yield cyclic situation  dead
ends all  one ipc   competition instances  ordering constraints
potential  helps explain efficient test suite
 it solves even largest task within half second search time  finding plan    
steps  
freecell  unrecognized dead ends arise  example  one cautious
enough moving cards free cells  relaxed plan still achieve goal
single free cell  using cell intermediate store cards  reality 
however  moving card free cell occupies space  by deleting availability
free cell   thus exclude possibilities reaching goal  thus moving card
free cell lead unrecognized dead end state  unrecognized dead end
arbitrarily deep cards still moved around independently deadlock
situation 
miconic adl  unrecognized dead ends arise problem constraint violated 
violation goes unrecognized relaxed plan  example two passengers
p  p  lift  p  transported downwards  p  access
p  destination floor  p  destination floor p  s  state dead end
one let p  get first p  access respective floor
   

fihoffmann

neither one let p  get first afterwards  lift would need drive upwards 
cant p  board  relaxation  one stop destination floors
simultaneously at facts deleted  unrecognized dead end becomes
arbitrarily deep several passengers moved around reaching p 
destination floor 
mystery  unrecognized dead ends arise fuel scarce  vehicle makes suboptimal moves  relaxed plan achieve goal long relevant locations
still accessible least once  may suffice reality  dead end becomes arbitrarily deep additional objects transported independently problematic
situation  mprime behaves similarly  difference mystery example that 
avoid possibility transferring fuel items problematic locations  one must make
sure enough fuel enable transportation additional objects 
a   local minima
theorem   h    maximal local minimum exit distance state space
solvable instance
   blocksworld no arm  briefcaseworld  ferry  fridge  grid  gripper  hanoi  logistics 
miconic simple  miconic strips  movie  simple tsp  tireworld   
   zenotravel    satellite    schedule    diningphilosophers    
present proof sketch theorem   terms three groups domains
similar proofs  note domains maximal local minimum exit distance  
domains local minima all  first focus domains
lemma    slight extensions it  applied 
proof sketch   theorem    ferry  fridge  gripper  logistics  miconic simple  miconicstrips  movie  simple tsp  tireworld 
theorem    none listed domains contains dead ends  said proof
sketch theorem  actions ferry  gripper  logistics  miconic strips  movie 
simple tsp  tireworld domains either least invertible  irrelevant delete
effects  lemma   suffices show actions respected relaxation 
cases  except driving flying actions logistics  easy see
optimal starting action something avoided relaxed plan   for
example  relaxed plan avoid load unload objects onto from vehicles 
avoid missing working steps tireworld   optimal starting action
logistics drives truck flies airplane location l  object must either
loaded unloaded l  relaxed plan choice apply action
moves transportation vehicle  of kind  there  vehicles equally good  except
clever choice  i e   vehicle already carries objects unloaded
l  then  move one vehicles optimal relaxed plan will 
vehicles equally good relaxation   in ferry  gripper  miconic strips 
   

fiwhere ignoring delete lists works

single vehicle  makes moving actions domains easier
reason about  
fridge miconic simple domains  actions adhere strictly
definitions invertibility irrelevant delete effects  proof theorem  
shown similar semantics  i e   either inverted  delete
facts longer needed applied  furthermore  actions
domains respected relaxation  fridge  missing working steps must
done relaxed plan  miconic simple  lift moves trivially respected  lift
stops respected since clever choices reality coincide clever choices relaxed
plan 
 
next four domains  local minima either  proofs
sophisticated make use rather individual properties respective domains 
cases proved path goal h  increase 
proof sketch   theorem    blocksworld no arm  briefcaseworld  grid  hanoi 
theorem    none domains contains dead ends  blocksworld no arm 
optimal starting action stacks block goal position  starts
optimal relaxed plan  because better thing achieve goal
immediately   relaxed plan  replaced inverse counterpart form
relaxed plan successor state  action state s  one
optimal plan starts putting block b must moved order access block
block c onto table  yielding state s    relaxed plan
s  constructed relaxed plan p   by  taking account various case
distinctions  replacing move actions regarding b p   number
move actions  case distinctions kind action p   uses move b
away c one action a  must contained p     a  moves b table
replace a  p   action moves b back onto c  finished  else 
must distinguish cases b required c goal 
block  cases  make successful use fact b moved
position position within single action  enabling us exchange actions
p   quite flexibly 
briefcaseworld  actions inverted  actions put objects briefcase
trivially respected relaxation  state optimal plan starts
take out action  optimal relaxed plan used successor state  since
taking object delete important facts  state optimal plan
starts move action l l    p   relaxed plan s  relaxed plan
successor state constructed replacing moves l l     l      l    p    
moves l  l    
grid  rather complex procedure applied identify flat path state
better h  value  state s  let p   optimal relaxed plan s  let
first unlock action p     putdown unlock action  identifying flat
path state s  applied suffices  unlocking deletes facts
irrelevant lock open  deletes putting key irrelevant
locks must opened  selected action uses key k
   

fihoffmann

position p  p   contains sequence actions moving p  moving along path defined
actions increase h  since actions contained relaxed plan 
inverted  k already held s  apply a  hand
empty s  key held  one use p   identify flat path state
one hold appropriate key k  hand empty  p   must contain
sequence actions moving location k picked up  key
held  p   must contain sequences actions moving locations series
keys picked put down  key series ends picking k 
hanoi  proved optimal relaxed solution length state equal
number discs yet final goal position proceeding
smallest largest disc  respective goal achieved single action 
optimal plan moves disc away final position  h  increase optimal
solution paths 
 
finally consider four domains local minima  one always
escape within constant number steps  cases  prove upper bound
distance non dead end state state s  h   s      h   s   immediately
implies   upper bound maximal local minimum exit distance  it
implies   upper bound maximal bench exit distance  results
re used appendix a    
dining philosophers  h  loosely connected goal distance  bound 
holds even trivial heuristic function returning number yet un blocked
philosophers  follows rather constant restrictive domain structure 
three domains  proofs proceed follows  reachable state s  identify constant
number steps suffices execute one action optimal relaxed plan s  and 
without deleting relevant add effects  re achieve relevant facts deleted
a  then  state s  h   s      h   s  reached 
proof sketch   theorem    dining philosophers  satellite  schedule  zenotravel 
theorem    dead ends dining philosophers recognized  non
dead end state s  shortest relaxed plan blocks processes  philosophers 
yet blocked  individual process    steps needed relaxation 
block process always suffices activate state transition  initiate read write
command  queue update  update  queue empty full 
read write impossible sense blocking rules apply   with this 
process block relaxation  h  value fairly loosely correlated
true goal distance   thus  reach state lower h  value  obviously always
suffices block one process  prove upper bound determining constant
bound number steps needed that  bound exists because  beside
fact philosopher processes constant interfere respective
two neighbors table  philosophers fixed order try pick
forks  always first try pick fork right  fork left 
restricts possible combinations internal states neighbored philosophers 
detail  philosopher blocked iff tries pick fork
table  philosopher p  refer pl ps neighbor philosopher left side 
   

fiwhere ignoring delete lists works

description   different states philosopher process appendix b    let
non dead end state  let p philosopher blocked  if p exists 
goal state nothing prove   prove desired upper bound
exhaustive case distinction states p pl  state               
p  consider state il                pl  combination il
possible  nothing  else  determine number k process state transitions
leads state either  p blocked pl still blocked blocked
s  pl blocked blocked s  cases 
make distinctions internal state pls left neighbor pll  worst case  k     
occurs      i e   p holds adjacent forks  then  pl either
state il     il      which means  pl cant hold fork pl p since
held p   il      pl blocked s  pl put left fork  getting
state   pl blocked since waits pick right fork  held p  il    
distinguish two cases state pll       p holds
adjacent forks   il      pl waits pick fork p pl   pl
blocked  case a  state pll          pll holds fork pll
pl  go p                go pl     
then  p pl blocked since wait pick fork left  case b 
state pll      fork pll pl table  pll
blocked  go pll      if          that  pll holds
fork pll pl  case apply sequence  getting us
state pll possibly blocked  p pl definitely blocked 
always need   process state transitions block one philosopher 
process state transitions take   planning actions each  makes    planning
steps  planning steps needed due subtleties pddl encoding 
subtlety a  process may already decided go state  yet arrived
i e   respective transition activated read write command initiated 
communication channel queue occupied transition yet complete 
  steps needed reach next internal state  update queue wrap
transition   subtlety b  blocked state process must activate outgoing
transition  worst case described above  p  pl  pll may require  
steps induced subtlety a  p pl require step induced subtlety b 
get  at most     planning actions  effect last action  one process
becomes blocked  upper bound exit distance    
theorem    dead ends satellite  let reachable state 
determine upper bound distance state s  h   s      h   s  
one look optimal relaxed plan p   s  distinguish four cases regarding
existence applicable actions different types p     action type  constant
number steps suffices re achieve deleted facts application action 
worst case       arises switch on action applied  switching instrument
deletes instruments calibration  re achieve this  one must turn satellite
calibrate it  another turn taking image  state lower h  value reached 
theorem    dead ends schedule recognized  let non dead
end state  determine upper bound distance state s 
h   s      h   s   one look optimal relaxed plan p   distinguish seven
   

fihoffmann

cases regarding kinds applicable actions p   contains  worst case      
arises do roll action available  and applicable  p     one needs
apply time step  do lathe action achieve desired effects do roll  another time
step  do polish do grind action re achieve previous surface condition  another
time step  do immersion paint action re achieve previous color 
theorem    dead ends zenotravel  reachable state s  determine
desired constant d  distinguishing two cases job  relaxed plan p  
contains applicable boarding  departing  refueling action  applying action
leads state lower h  value  else  p   starts flying action  better
state reached executing flight  refueling once  boarding departing
person  get     
 
note proved bound dining philosophers holds even take heuristic
function trivial one returns number yet un blocked philosophers 
extremely cumbersome figure exactly worst case exit distance diningphilosophers h  so  one consider combinations possible states
neighbored processes  possible developments lot action steps  rather
un intuitive pddl encoding made automated translation machinery  highest
exit distance could actually construct dining philosophers     conjecture
 tight  upper bound 
satellite  schedule  zenotravel  proved upper bounds tight 
dining philosophers  satellite  schedule  zenotravel  bounds valid nondead end state s  so  beside bound local minimum exit distance  results
provide bound bench exit distance  re use appendix a   
blocksworld arm  depots  driverlog  optical telegraph  pipesworld  psr  rovers 
one construct local minima arbitrarily large exit distances  blocksworld arm 
example situation n blocks b            bn initially form stack bi
bi   bn table  goal build stack top
another block bn     i e   goal stack b            bn   bn     reaching  initial state 
state better h  value  involves disassembling entire stack b            bn  
disassembling process  h  increases  example used depots 
driverlog  local minima arise due different road maps trucks drivers 
example  takes one step drive location l another location l    n
steps walk  relaxed plan  driver drive truck goal
staying is  reality  driver walk way back 
optical telegraph  treated easily reconsidering diningphilosophers domain  proved constant upper bound above  reason
optical telegraph basically permissive version dining philosophers 
philosophers choose fork pick first  and  hold forks 
fork want put first  consider configuration depicted figure    
configuration reachable given automata underlying dining philosophers 
reachable given automata underlying optical telegraph 
figure     nietzsche holds adjacent forks  kant holds none tries
get access fork right  nietzsche kant  arbitrarily
many philosophers hold one fork each  trying access other 
   

fiwhere ignoring delete lists works

kant

nietzsche

figure     unreachable situation dining philosophers  unbounded local
minimum h  would arise  arrows indicate pickup requests 

non blocked philosopher nietzsche  put forks again 
pddl encoding this  world state nietzsche activated transition
putting right  or left  fork  h  value    relaxation  suffices
initiate write command  update queue contents  write command
initiated  however  h  goes   transition become non activated 
relaxed plan update queue contents  wrap transition  activate
 same  transition again  reaching state h  value   involves propagating
forks entire sequence philosophers nietzsche kant  either
right hand side  left hand side  example  say nietzsche puts forks
picks right fork  philosopher left nietzsche pick
requested fork  or nietzsche pick gets us back started  
resulting state  situation before  except philosopher
nietzsche role sits one position left  iterating procedure
around left side table  kant pick requested fork  request get
other  giving us goal state philosophers blocked  state h  value  
one kant yet activated transition request fork 
configuration figure    reachable dining philosophers domain
used ipc    because  there  philosopher pick fork left hand
side first done figure    philosophers nietzsche kant
nietzsches left hand side  said  optical telegraph philosophers
freedom choice  situation reachable  detail  described
appendix b     optical telegraph n pairs communicating processes 
pairs arranged cycle  pair control channel  internally 
two processes within pair go fairly long  heavily interactive  sequence
operations  implementing possibility exchange data two stations 
   

fihoffmann

operations begin  processes occupy  write into  one
control channel  is  one processes occupies channel  waits signal
process  indicating second control channel occupied well 
data exchange terminated  control channels get released  read 
arbitrary order  overall system blocked iff process pairs state
occupied one control channel  waiting occupy other  thus 
process pairs correspond exactly philosophers choose fork pick  put
down  first  figure    provides example arbitrarily high exit distance
local minimum state  precisely  local minimum state one nietzsche
process pair occupied channels  process blocked second
channel activated transition sending occupied the other one signal 
state  h  value    all processes except active one blocked  
pipesworld  consider situation several areas form circle unitary
connections  local minimum state s  single goal batch g go area a 
g currently segment adjacent a  contains batch b  areas empty 
shortest plan push b segment  not s  adjacent a  propagate
batches around circle g pushed a  shortest relaxed plan
is  however  push b push g side i e   g used
push goal area  reaching nearest state h  value   requires n  
steps n areas circle  path h  value increases  note
example uses neither tankage restrictions  interface restrictions  non unitary
pipeline segments 
psr  deep local minimum given n breakers feed individual goal line 
way breaker feed breakers goal line without breaker
closed  breakers connected faulty line  one
breakers closed  h  value state    close single open breaker  since
unsatisfied goal condition  beside supplying line fed open breaker 
one postulating breaker affected  condition negated derived predicate 
thus ignored relaxation  applicable action state wait 
that  breakers open  shortest relaxed plan close all  yielding
h  value n  obviously  nearest state h  value   least n steps away   
rovers  local minima arise taking image deletes calibration
camera  example this  n waypoints w            wn connected line
 i e   wi  connected wi    lander w    one rover camera c must used
take two images w    c calibrated  only  wn   rover w   
c calibrated  relaxed plan take two images communicate two
data pieces  taking one image  one navigate way wn   calibrate
c  get back  note example makes use road map arbitrarily large
diameter  diameter rovers instance longest way rover must travel
order get one waypoint another  general  distance state better
h  value bounded  d     diameter instance  see details
tr   road map diameter ipc   rovers instances varies around     
    remark counter example remains valid ipc   simple adl strips formulations
psr  use different encoding derived predicates  using negation formulate
goal breaker affected 

   

fiwhere ignoring delete lists works

airport  assembly  freecell  miconic adl  mprime  mystery domains 
seen appendix a   contain unrecognized dead ends  so  proposition   
local minimum exit distance domains unbounded  assembly 
tr describes detail  initial state instance path goal
h  decreases monotonically  unless complex interactions ordering
constraints present instance  none ipc   instances features complex
interactions  assuming ffs search algorithm sticks monotonically decreasing
paths  gives another indication system efficient example
suite 
a   benches
theorem   h    maximal bench exit distance state space solvable
instance simple tsp    ferry    gripper    logistics
   miconic simple    miconic strips    movie   
zenotravel    satellite    schedule    tireworld
   dining philosophers    
before  subdivide proof sketch theorem   groups domains
similar proofs  first consider transportation type domains  them  lemma   
similar proof arguments  applied 
proof sketch   theorem    ferry  gripper  logistics  miconic simple  miconic strips 
proofs theorems     shown that  domains  actions
respected relaxation  and  domains except miconic simple 
actions either invertible  relevant delete effects  determine upper bound
exit distance benches  thus apply lemma    requires us show
that  state s  optimal plan    th action relaxedplan relevant delete effects  miconic simple  seen actions 
adhering syntactic conditions invertibility  no  relevant delete effects 
similar semantics  proof technique applied there 
 transportation type  domains consideration  argument is  roughly 
load type unload type actions relaxed plan relevant delete effects 
move type actions need applied row locations
immediately accessible other  implies upper bound   maximal
exit distance  concretely  say reachable state logistics instance  starts
optimal plan s  p   optimal relaxed plan starts a  applying
yields state s    loading  unloading  action  delete at in   fact transported object  object loaded respective location
 unloaded respective vehicle  optimal relaxed plan p    
relaxed plan relevant delete effects  exit  otherwise  drives flies vehicle
v l l    s  exit optimal plan s  starts loading  unloading 
package  from  v  miconic strips miconic simple  arguments
apply  ferry  arguments remain valid except that  optimal start action
state boards car  action deletes available free space
   

fihoffmann

ferry  then  relaxed plan p   contains actions move ferry
location l  debark car l  otherwise would point boarding
car   placing actions front p     removing a  yields relaxed plan
state results applying s  similar argument applied prove
claim gripper  gripper hands hold one ball time   note
argument ferry gripper uses somewhat weaker notion relaxed plan relevant
delete effects  effects  undone actions contained
relaxed plan  
 
next come non transportation domains lemma   applied 
proof sketch   theorem    movie  simple tsp  tireworld 
proofs theorems     shown domains actions
respected relaxation  either least invertible  irrelevant delete effects 
apply lemma   cases 
movie  actions no  therefore relaxed plan relevant  delete effects 
single exception rewinding movie  which deletes counter zero  
obviously  optimal plan rewinds movie twice row  thus      desired
upper bound 
simple tsp      suffices  say reachable state one location
l  optimal plan starts action visiting yet unvisited location l    optimal
relaxed plan start a  visit remaining unvisited location l  
move l  l     latter actions require preconditions deleted a 
every action relaxed plan relevant delete effects 
tireworld  lowest constant upper bound      non final working steps
 like jacking hub flat wheel on  need undone later on  i e  
relaxed plan relevant delete effects  final working steps  like jacking hub 
need undone  i e   relaxed plan relevant delete effects  longest
sequence non final working steps optimal plan row following
  step one  open boot  it must closed again   fetch wrench jack  they
must put away again   loose nuts hub thats got flat wheel  the nuts must
tightened again   jack respective hub  it must jacked again   undo
nuts  they must done again   resulting state  one remove flat
wheel  needs undone 
 
remaining domains theorem   claims constant upper bound
maximal bench exit distance  seen appendix a   upper bounds
distance reachable state state s  h   s      h   s   upper
bounds trivially imply upper bounds maximal bench exit distance 
proof sketch   theorem    dining philosophers  satellite  schedule  zenotravel 
follows directly proof theorem   

 

domains  except last four  one easily construct examples
bench exit distance equal proved upper bound  satellite  schedule 
   

fiwhere ignoring delete lists works

zenotravel  open question whether tighter bounds bench exit
distance local minimum exit distance  seem particularly relevant 
though   for dining philosophers  said may even bound
local minimum exit distance tight  
blocksworld no arm  briefcaseworld  fridge  grid  hanoi domains  theorem   proves local minima  important know whether
arbitrarily difficult escape benches  answer yes cases  blocksworldno arm  example one already used blocksworld arm depots
 to show bounds local minimum exit distances   n blocks
b            bn initially form stack bi bi   bn table  goal
build stack top another block bn     i e   goal stack b            bn   bn    
shortest relaxed plan initial state n steps long  remove stack top
bn   move bn onto bn      nearest state h  value n   one bn
already stacked onto bn     state n steps away initial state 
briefcaseworld  bench exit distance becomes large many objects must
taken briefcase relaxation  point taking objects out  since
moving briefcase delete at facts  consider state n objects
o            inside briefcase location l  goal o            l
briefcase another location l    h   s       moving briefcase l  suffices
relaxation  nearest goal state  h       n     steps away  one must take
objects moving l   
fridge  single fridge compressor held n screws  exit distance
initial state n      reach better state  one must  stop fridge  which must
turned back relaxed plan   unfasten n screws  which must fastened
relaxed plan   remove broken compressor  which needs undone
deletes fact broken compressor attached fridge    
grid  consider instances robot located n  grid  a line  without
locked locations  robot starts leftmost location  shall transport key
rightmost location left end  initial value h  n      walk
key  pick up  put at facts deleted   value get
better robot actually picked key 
hanoi  seen h  always equal number discs yet
goal position  thus maximal bench exit distance grows exponentially
number discs  initial state instance n discs  takes  n  steps
move first  i e   largest  disc goal position 
  domains local minimum exit distance arbitrarily large 
relevant whether bench exit distance bounded not  escaping bench
might planner better ending huge local minimum  remark that 
example  driverlog  rovers  mprime  mystery  one easily construct examples
large bench exit distances  defining road maps large diameters i e   using
basically example used grid domain 
    fact  one easily prove n     upper bound bench exit distance  fridge
instances compressors held n screws  details tr  

   

fihoffmann

appendix b  domain descriptions
following list brief descriptions    investigated domains  explain
overall idea behind domain  available operators  initial states
goals are  cases set instances obvious  restrictions  any  explained 
remark that  points  domain semantics seem bit odd  for example 
zenotravel  difference flying zooming plane zooming consumes
fuel   odd points are  presumably  domain bugs overlooked
respective domain designers  corrected bugs as  all  investigation
meant determine properties benchmarks used community 
domains listed alphabetical order 
b   airport
airport domain  planner safely navigate ingoing outgoing traffic 
given point time  across airport  main problem constraint planes
must endanger other  come close others running
engines  constraint modeled letting plane block segments
engines currently endanger  planes enter blocked areas  five operators 
plane moved one airport segment another  plane facing right
direction  planes get endangered action  similarly  plane pushed
back cause trouble  one start engines plane  let plane
take off  let plane settle parking position  initial state specifies current
positions orientations planes  goal specifies planes outbound  have
take off   inbound parking positions 
b   assembly
assembly domain  complex object must constructed assembling parts
together  obeying certain ordering constraints  parts might need
assembled way beforehand  parts transient  means
must integrated temporarily  collection machines  resources 
might needed working steps  four operators  available resource
committed object  deleting resources availability  releasing resource
object inverse action  available object x assembled object y 
x either part transient part y  resources requires committed
y  objects assemble order x already incorporated
y  effect  x incorporated longer available  becomes available
parts except x already incorporated  transient part incorporated 
incorporated object x removed y  resources requires committed
y  and  given x transient part  a part y   objects remove order
 an assemble order  x incorporated  not incorporated   effect  x available
longer incorporated  becomes available parts incorporated 
transient parts except x incorporated  instances  part of relation
forms tree goal make root object tree available  also 
   

fiwhere ignoring delete lists works

assemble remove order constraints consistent  cycle free   restrictions hold
true aips      competition examples 
b   briefcaseworld
briefcaseworld  number portables must transported  transportation
done via conditional effects move actions  three operators  putting
portable location done portable briefcase respective
location  portable yet inside  taking portable done inside 
move applied two locations  achieves  beside is at fact
briefcase  respective at facts portables inside  i e   portables inside
moved along conditional effects   goal briefcase  subset
portables  goal locations 
b   blocksworld no arm
blocksworld no arm variant widely known blocksworld domain  three
operators  one move block table onto another block  one move block
another block table  one move block another block onto third
block  initial state instance specifies initial positions blocks  goal
state specifies  consistent  i e   cycle free  set facts 
b   blocksworld arm
instances blocksworld arm blocksworld no arm  difference blocks moved via single robot arm hold one block time 
four operators  one pickup block table  one put block 
arm holding  onto table  one unstack block
block  finally  one stack block  arm holding  onto block 
b   depots
depots domain kind mixture logistics blocksworld arm 
set locations  set trucks  set pallets  set hoists  set crates 
trucks transport crates locations  hoists used stack crates onto
crates  onto pallets  six operators  move truck  different 
locations  load crate held hoist onto truck location  unload
crate hoist truck location  lift crate hoist surface  a
pallet crate  location  drop crate held hoist onto surface
location  hoist hold one crate time  crates initially arranged
arbitrary stacks  bottom crate stack standing pallet  goal
arrange crates arbitrary stacks  possibly  pallets 
involve transporting crates locations  as pallets moved  
   

fihoffmann

b   dining philosophers
dining philosophers encoding well known dining philosophers problem 
task planner find deadlock situation arises every philosopher
taken single fork  pddl domain created automatic translation
automata based promela language  automata referred processes 
promela  philosopher finite automaton process works follows 
start state  state    transition puts right fork onto table  this initialization
step   getting state    loop four states  state   state
   philosopher takes right fork       takes left fork     
puts right fork  state   puts left fork gets back state
   process communicates neighbors communication
channel  queue  either contains fork  empty  if one adjacent philosophers
currently holding fork  
pddl encoding  process state transition broken four actions 
first action activates chosen transition  second action initiates write read
command needed queue  deleting activation transition setting flags
queue update  third action updates  possible  queue contents  update
possible write command shall done full queue  a queue already contains
fork   read command shall done empty queue  fourth action wraps
process state transition up  re setting flags 
derived predicates used model conditions process blocked 
rules require outgoing transitions current state process blocked 
transition blocked activated  would need perform impossible queue
write read operation sense impossible write read operation yet
initiated    applying planning action initiating impossible write read
command  blocking rules dont apply anymore resulting state dead end
planning tasks state space  but blocking situation process network 
according derived predicate rules modeling blocking  
remark that  ipc    version dining philosophers modeled
process blocking via additional planning operators  derived predicates  chose
consider other  above  domain version since constitutes natural concise
formulation  since planners ipc   scaled version without
derived predicates 
b   driverlog
driverlog variation logistics  drivers needed trucks 
drivers trucks move along arbitrary  bi directional  road maps  road maps
drivers trucks different  operators load unload object onto from
truck location  board disembark driver onto from truck location  walk
    one outgoing transition activated time  process never become blocked
state one outgoing state transition  appears bug translation
promela pddl intuitive requirement would activated transition needs
blocked  outgoing transition need activated order blocked  note
that  dining philosophers  every automaton state one outgoing transition 

   

fiwhere ignoring delete lists works

driver location another one  drive truck driver location
another one  preconditions effects loading unloading objects obvious
ones  driver board truck truck empty  effect  truck longer
empty  as well driven driver   disembarking driver inverse action 
order walk driver l l    must path l l    order drive
truck l l    link l l   and must driver
truck   paths links form arbitrary  in particular  potentially different  graphs
locations  restriction undirected  i e   truck driver
move l l  move back  restriction imposed driverlog
instances generated ipc   generator 
b   ferry
ferry  single ferry used transport cars locations  one time 
three operators  one sail ferry two locations  one board car onto
ferry location  deletes empty ferry fact  plus adding car
ferry deleting car location   one debark car ferry
location  achieves empty ferry  plus adding car location
deleting car ferry   goal subset cars goal
locations 
b    freecell
freecell domain strips formulation widely known solitaire card game
comes microsoft windows  number cards different suits initially
arranged random stacks number columns  cards must put home 
suit cards  separate home column  cards suit must
stacked increasing order card value  number free cells  cards
moved around according certain rules  card clear card top
it  clear card put free cell  if already there   free cell holds
one card time  clear card moved onto empty column  clear card
c put home last card put home suit one preceding c  c
c  clear cards differently colored suits  one stack c top c  c 
free cell  cs card value one less card value c   so stacks
built columns  decreasing order card value  alternating colors   goal
reached topmost cards suits put home 
b    fridge
fridge  one must replace broken compressor fridge  this  one must remove
compressor  involves unfastening screws hold compressor 
turn involves first switching fridge off  goal new compressor attached
fridge  screws fastened  fridge switched back on  origin domain
strips formulation  consider adaptation allows arbitrary number
fridges screws  compressor fastened  arbitrary  least one 
number screws  adaptation involves adl precondition  compressor
   

fihoffmann

removed screws unfastened  six operators  one stop start fridge 
one unfasten fasten screw from to compressor attached fridge  so 
fridge needs turned off  compressor needs attached  screw must fit
compressor  finally  one remove attach compressor from to fridge  removing
compressor requires fridge turned off  none screws fit
compressor fastened  effect  compressor longer attached fridge 
fridge compressor free  attaching compressor requires fridge
turned off  compressor fits fridge  effect  compressor attached 
compressor fridge longer free 
b    grid
grid  robot must move along positions arranged grid like reachability
relation  positions locked  keys different shapes open them 
goal keys goal positions  five operators  one
move position p position p    requires  apart obvious preconditions 
p p  connected  p  open  not locked   one pick key
position  requires arm empty  one hold one key time  
effects one holds key  arm longer empty  key
longer position  putting key position inverse action  one
abbreviate two previous actions pickup and lose keys k k 
position  this  one must hold k  directly exchanged k    i e   effects
one holds k k  position  finally  one unlock position p  one
position p connected p    holds key shape locked
position p    add effect p  open  delete effect position longer
locked  instances specify initial locations keys  locked positions 
robot  well shapes keys locked positions  goal specifies
positions subset keys  robot always starts open position 
make significant difference  robot allowed start locked position 
local minima h      otherwise none  c f  theorem    intuitively  makes
sense let robot located open positions only  restriction holds true
published benchmark examples 
b    gripper
gripper  task transport number balls one location another 
three operators  one move locations  one pick ball location
hand  apart obvious preconditions requires hand empty 
effects obvious ones  the ball hand longer room  plus
hand longer empty  one drop ball location hand  inverts
effects picking action  always exactly two locations  two gripper
hands  instances thus differ terms number balls  severe restrictions
hold true aips      instances  remark adding locations and or hands
    moving away locked initial position lead need applying several steps re open
position  relaxed plan initial state realize this  since ignores delete
initial at fact 

   

fiwhere ignoring delete lists works

affect topological properties h    fact proof arguments given
theorems         remain valid case 
b    hanoi
hanoi domain strips encoding classical towers hanoi problem 
n discs d            dn   three pegs p    p    p    single operator moves
object x object onto object z  the operator parameters grounded
discs well pegs   preconditions move x y  x clear  z
clear  x smaller z  effects x z clear  x
longer z longer clear  semantics towers hanoi encoded via
smaller relation  relation holds obvious way discs  discs
smaller pegs  the pegs smaller anything moved  
instances differ terms number n discs must transferred p 
p   
b    logistics
logistics classical transportation domain  objects must transported within
cities using trucks  different cities using airplanes  six operators 
drive truck two locations within city  fly airplane two airports 
load  unload  object onto  from  truck location  load  unload  object
onto  from  airplane airport  operators obvious preconditions
effects  the complicated operator moving truck  whose precondition
requires locations within city   always least one city 
city non zero number locations one airport  arbitrary
number objects  airplanes  which located airports   goal
subset objects goal locations 
b    miconic adl
miconic adl adl formulation complex elevator control problem occurring
real world application planning  koehler   schuster         number passengers
waiting number floors transported lift  obeying variety constraints 
always least one floor  arbitrary number passengers 
given origin destination floor  three operators  lift move
floor f floor f f  transitively  f  vice versa moving downwards 
lift stop floor  floor f  conditional effects
stopping action passengers waiting f boarded  passengers wanting get
f depart  goal serve passengers  i e   bring destination
floor  constraints must obeyed following 
cases  passenger p access floor f  lift stop f
p boarded 
passengers vips  long served  lift stop
floors vip getting off 
   

fihoffmann

passengers must transported non stop  i e   boarded  lift
make intermediate stops stopping destination floor 
passengers travel alone  others attend them  one former
kind boarded  must least one latter kind 
groups b passengers allowed people
groups boarded simultaneously 
passengers transported direction travel  i e  
need go  down   then  boarded  lift move
downwards  upwards  
constraints formulated means complex first order preconditions
operators 
b    miconic simple
miconic simple domain miconic adl described above  except
constraints all 
b    miconic strips
miconic strips domain almost miconic simple domain  see above 
difference boarding departing passengers done conditional
effects stopping operator  explicitly separate strips operators  one board
passenger floor  precondition  current  floor passengers origin 
effect passenger boarded  one let passenger depart
floor  preconditions  current  floor passengers destination
passenger boarded  effects passenger served longer
boarded 
b    movie
movie  task prepare watching movie  seven different operators 
one rewind tape  adds tape rewound  deletes counter
zero  one reset counter  effect counter zero  one
get five different kinds snacks   add  effect one respective
snack  instances differ terms number items sort
snacks  goal always one snack sort  tape rewound 
counter zero 
b    mprime
mprime transportation kind domain  objects must transported
locations means vehicles  vehicles use non replenishable fuel  instance 
set l locations  set objects  set v vehicles 
sets f fuel numbers space numbers  location initially certain fuel
   

fiwhere ignoring delete lists works

number number fuel items available location vehicle certain
space number number objects vehicle carry time  operators
move vehicles locations  load  unload  objects onto  from  vehicles 
transfer fuel units locations  move location l location l 
made l l  connected  where connection relation arbitrary graph  
least one fuel unit available l  l fuel number lower neighbor  
effect move  respective vehicle located l    amount fuel l
decreased one unit  i e   l assigned next lower fuel number  similar fashion 
object loaded onto vehicle space that  effect available
space decreases  unloading object frees space again  transfer operator
transfer one fuel unit location l location l    l l  connected  l
least two fuel units left  result applying operator  ls fuel number decreases
one  l  fuel number increases one  note way re gain fuel items
 one transfer around one obtain new ones   goal transport
subset objects goal locations 
b    mystery
mystery exactly mprime domain described above  except
operator transfer fuel items 
b    optical telegraph
dining philosophers domain described appendix b    optical telegraph
pddl compilation problem originally formulated automata based promela
language  mechanics pddl compilation dining philosophers 
using derived predicates detect blocked situations  problem involves n pairs communicating processes  pair featuring process  pair go
fairly long  heavily interactive  sequence operations  implementing possibility exchange data two stations  data exchanged  various initializing
steps must taken  ensure processes working synchronously  importantly 
process writes token control channel  queue  beginning
sequence  reads token end  causes deadlock situation
n control channels  accessed two processes 
precisely  process pairs arranged cycle  pair control channel  overall system blocked iff process pairs state
occupied  written into  one control channel  waiting occupy other 
sense  optical telegraph viewed version dining philosophers
internal states philosophers complicated  particular  philosophers
 process pairs  choose order pick forks  occupy control
channels   turns out  see appendix a    latter important impact
topology h   
remark that  ipc    version optical telegraph modeled
process blocking via additional planning operators  derived predicates  chose
consider other  above  domain version since constitutes natural concise
   

fihoffmann

formulation  since planners ipc   scaled version without
derived predicates 
b    pipesworld
pipesworld  units oil derivatives  called batches  must propagated
pipeline network  network consists areas connected pipe segments different
length  pipes completely filled batches times  one pushes batch
one end pipe  last batch currently pipe comes end 
interface restrictions concerning types oil derivatives allowed
adjacent inside pipe  tankage restrictions concerning
number batches  of derivative type  stored point time
individual areas 
available planning operator push batch pipe  ipc  encoding domain  look here  non unitary pipe segments  pipes
containing one batch  operator split two parts  start finish
action  in order reduce number operator parameters needed correctly update
pipe contents   also  pipe segments encoded directed fashion  making necessary
distinguish  symmetrical  push pop actions  initial state specifies
current batch positions etc   goal specifies batches brought
areas 
b    psr
psr domain  used ipc    task re supply given set lines faulty
electricity network  nodes network breakers  feed electricity
network  devices  switches used change network
configuration  edges network lines  connecting two three nodes 
breakers devices open closed  open  disconnect
lines adjacent them  breakers closed  feed electricity adjacent
lines  lines faulty  goal ensure none breakers
affected  i e   feeds electricity faulty line  transitive connections
network  also  goal requires given set lines  transitively  fed
electricity breaker 
transitive network semantics  determining breaker feeds electricity
line  breaker affected  modeled means various derived predicates  with
recursive rule antecedents enable computation transitive closure   three
planning operators  one open device breaker currently closed  one
inverse closing action  actions require precondition breaker
currently affected  latter untrue  i e   breaker currently affected 
available action wait  effect open breakers affected 
remark that  ipc    different version psr  formulated
pure strips without derived predicates  version constitutes  however  relatively
superficial pre compiled form domain  hoffmann   edelkamp        edelkamp et al  
       included ipc   order provide pure strips planners
   

fiwhere ignoring delete lists works

domain formulation could tackle  the pre compilation necessary order enable
formulation pure strips  
b    rovers
rovers  number rovers must navigate road map waypoints  take rock
soil samples well images  communicate data number landers 
nine available operators following  one navigate rover one waypoint
another this  waypoints must connected rover  one sample
soil rock rover waypoint using store so  rover must
 empty  store equipped soil rock analysis  must soil rock sample
waypoint  effect one soil rock analysis  store full  soil rock
sample longer waypoint  one empty full store dropping store  one
calibrate camera waypoint using objective  one take image
objective mode camera waypoint  operators  object must
visible waypoint  camera must board rover equipped
imaging  calibrate camera  object must calibration target it 
effect operator calibration camera  take image  camera must
calibrated  support required mode  effects one image data 
camera longer calibrated  finally  three operators
rover communicate soil rock image data lander  so  landers waypoint
must visible rover  effect data communicated 
instances restricted visibility connectivity waypoints
bi directional waypoint w visible waypoint w  holds true vice
versa  rover move w w  move back  another restriction
camera initially calibrated  this serves make sure that  reachable state 
calibrated camera least one calibration target   restrictions imposed
rovers instances generated ipc   generator 
b    satellite
satellite  satellites need take images different directions  certain modes  using
appropriate instruments  number satellites  number directions  number
instruments  number modes  following five operators  one
turn satellite direction another one  preconditions effects obvious
ones  action applied pair directions  no connectivity constraints  
one switch instrument board satellite  satellite power available 
effect  instrument power longer calibrated  satellite
power available  one switch instrument board satellite  instrument
power  effect  satellite power available  instrument anymore 
one calibrate instrument board satellite direction  satellite points
direction  instrument power  direction calibration target
instrument  effect calibration camera  finally  one take
image instrument board satellite direction mode  so 
satellite must point direction  camera must support mode  power 
calibrated  effect one image direction mode 
   

fihoffmann

goal images number direction mode pairs  also  satellites
goal requirement point specified direction  initial states
satellite  but instrument  power available  instrument calibrated 
former restriction makes sure satellite power run one instrument
time  latter restriction makes sure that  reachable state  calibrated instrument
least one calibration target  restrictions imposed satellite instances
generated ipc   generator 

b    schedule
schedule  collection objects must processed number machines  applying
working steps change objects shape  surface condition  color  one drill
holes varying widths varying orientations  nine operators  eight
describe working steps object machine  amongst things  operators
preconditions require scheduled elsewhere machine busy 
operators effect scheduled  machine busy  ninth
operator time step  whose effect object scheduled  machine
busy  longer  one apply do roll action object o  makes cylindrical
hot  no longer cold  see below   deleting surface conditions  colors 
holes might have  one apply do lathe o  making cylindrical rough
surface  deleting colors might painted before  one apply
do polish cold  giving polished surface  one apply do grind o 
giving smooth surface colors  one apply do punch o  width w
orientation o  cold  resulting hole w o  rough surface  one
apply do drill press o  cold  making hole width w orientation
 changing none os properties except making hole   cold  one
apply do spray paint color c  deleting surface conditions might have 
finally  one apply do immersion paint o  changing none os properties except
color  note operator change os temperature  except do roll
makes hot  that  made cold  this reason dead
ends arise  c f  theorem     initially  objects cold  shape
surface condition specified  objects painted initially  object
none several holes  goal condition  objects required
cylindrical shape  the shape produced machines  
need surface condition  must painted  object required
arbitrary number holes 

b    simple tsp
simple tsp trivial version tsp problem  single operator move
locations  applied two  different  locations  effect
 besides obvious ones  destination location visited  instances specify
number locations must visited  starting one them 
   

fiwhere ignoring delete lists works

b    tireworld
tireworld  one must replace number flat tires  involves collection objects
must used appropriate working steps  briefly summarized  situation
follows  thirteen operators  boot either opened closed 
initially closed shall end  pump  wrench  jack
fetched put away  from into boot   initially boot
shall put back end  spare wheels initially inflated  inflated
using pump  the add effect wheel inflated  delete effect
longer not inflated   hub fastened nuts  loosened tightened 
using wrench  respective hub ground  jack used either
jack jack hub  hub jacked up  one undo  loose  nuts 
up  nuts undone  one remove respective wheel  put one 
optimal solution plan this  open boot  fetch tools  inflate spare wheels  loosen
nuts  turn jack hub  undo nuts  remove flat wheel  put spare
wheel  nuts  jack hub again  tighten nuts  put away tools 
close boot 
b    zenotravel
zenotravel transportation domain variant vehicles  called aircrafts  use fuel
units replenished using refueling operator  number cities 
number aircrafts  number persons  number different possible fuel levels 
fuel levels encode natural numbers next predicate next f f    true iff f 
next higher fuel level f  task transport subset persons
initial locations goal locations  following five operators  one
board debark person onto from aircraft city  obvious preconditions effects  one fly aircraft city different city  decreasing
aircrafts fuel level f f    f must aircrafts current fuel level  f  must
next lower level  one zoom aircraft  exactly flying it  except
zooming uses fuel aircrafts fuel level decreased two units  finally 
one refuel aircraft city fuel level f fuel level f    conditions
f aircrafts current fuel level  f  next higher level  thus aircrafts
refueled city  steps one unit 

references
bacchus  f          aips   planning competition  ai magazine               
biundo  s     fox  m   eds            recent advances ai planning   th european
conference planning  ecp     lecture notes artificial intelligence  durham 
uk  springer verlag 
blum  a  l     furst  m  l          fast planning planning graph analysis 
mellish  s   ed    proceedings   th international joint conference artificial
intelligence  ijcai      pp            montreal  canada  morgan kaufmann 
   

fihoffmann

blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                   
bonet  b     geffner  h          planning heuristic search  new results   biundo   
fox  biundo   fox         pp       
bonet  b     geffner  h       a   heuristic search planner      ai magazine         
     
bonet  b     geffner  h       b   planning heuristic search  artificial intelligence 
              
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  kuipers  b  j     webber  b   eds    proceedings   th national
conference american association artificial intelligence  aaai      pp 
        portland  or  mit press 
botea  a   muller  m     schaeffer  j          using component abstraction automatic
generation macro actions   koenig et al   koenig  zilberstein    koehler        
pp         
botea  a   muller  m     schaeffer  j          learning partial order macros solutions 
biundo  s   myers  k     rajan  k   eds    proceedings   th international
conference automated planning scheduling  icaps      pp          monterey  ca  usa  morgan kaufmann 
brazdil  p     jorge  a   eds     epia            proceedings   th portuguese conference artificial intelligence  epia      porto  portugal  springer verlag 
bylander  t          computational complexity propositional strips planning 
artificial intelligence                  
cesta  a     borrajo  d   eds            recent advances ai planning   th european
conference planning  ecp     lecture notes artificial intelligence  toledo 
spain  springer verlag 
chen  y   hsu  c     wah  b          sgplan  subgoal partitioning resolution
planning   edelkamp et al   edelkamp  hoffmann  littman    younes        
chen  y     wah  b          automated planning scheduling using calculus variations
discrete space   giunchiglia et al   giunchiglia  muscettola    nau         pp 
    
chien  s   kambhampati  r     knoblock  c   eds     aips            proceedings
 th international conference artificial intelligence planning systems  aips     
breckenridge  co  aaai press  menlo park 
do  m  b     kambhampati  s          sapa  domain independent heuristic metric
temporal planner   cesta    borrajo  cesta   borrajo         pp         
edelkamp  s       a   promela planning  ball  t     rajamani  s   eds    proceedings
  th international spin workshop model checking software  spin     
pp          portland  or  springer verlag 
edelkamp  s       b   taming numbers durations model checking integrated
planning system  journal artificial intelligence research             
   

fiwhere ignoring delete lists works

edelkamp  s     helmert  m          mips  model checking integrated planning system 
ai magazine               
edelkamp  s   hoffmann  j   englert  r   liporace  f   thiebaux  s     trug  s         
engineering benchmarks planning  domains used deterministic part
ipc    journal artificial intelligence research  submitted 
edelkamp  s   hoffmann  j   littman  m     younes  h   eds     ipc            proceedings
 th international planning competition  whistler  bc  canada  jpl 
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research            
fox  m     long  d          stan   hybrid planning strategy based subproblem
abstraction  ai magazine               
frank  j   cheeseman  p     stutz  j          gravity fails  local search topology 
journal artificial intelligence research            
gazen  b  c     knoblock  c          combining expressiveness ucpop
efficiency graphplan   steel    alami  steel   alami         pp         
gerevini  a     schubert  l          inferring state constraints discoplan  new
results   kautz    porter  kautz   porter         pp         
gerevini  a     schubert  l          discoplan  efficient on line system computing
planning domain invariants   cesta    borrajo  cesta   borrajo         pp     
    
gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs  journal artificial intelligence research             
gerevini  a     serina  i          lpg  planner based local search planning graphs
action costs   ghallab et al   ghallab  hertzberg    traverso         pp 
     
gerevini  a   serina  i   saetti  a     spinoni  s          local search techniques temporal
planning lpg   giunchiglia et al   giunchiglia et al          accepted
publication 
ghallab  m   hertzberg  j     traverso  p   eds     aips            proceedings  th
international conference artificial intelligence planning scheduling  aips     toulouse  france  morgan kaufmann 
giunchiglia  e   muscettola  n     nau  d   eds     icaps            proceedings
  th international conference automated planning scheduling  icaps     
trento  italy  morgan kaufmann 
haslum  p     geffner  h          admissible heuristics optimal planning   chien
et al   chien  kambhampati    knoblock         pp         
helmert  m          complexity results standard benchmark domains planning 
artificial intelligence              
helmert  m          planning heuristic based causal graph analysis   koenig et al 
 koenig et al          pp         
   

fihoffmann

helmert  m     richter  s          fast downward making use causal dependencies
problem representation   edelkamp et al   edelkamp et al         
hoffmann  j          heuristic domain independent planning use enforced
hill climbing algorithm  ras  z  w     ohsuga  s   eds    proceedings   th
international symposium methodologies intelligent systems  ismis      pp 
        charlotte  nc  springer verlag 
hoffmann  j       a   ff  fast forward planning system  ai magazine         
     
hoffmann  j       b   local search topology planning benchmarks  empirical analysis   nebel  nebel         pp         
hoffmann  j          extending numerical state variables  harmelen  f  v   ed   
proceedings   th european conference artificial intelligence  ecai      pp 
        lyon  france  wiley 
hoffmann  j       a   metric ff planning system  translating ignoring delete lists
numeric state variables  journal artificial intelligence research             
hoffmann  j       b   utilizing problem structure planning  local search approach 
vol       lecture notes artificial intelligence  springer verlag 
hoffmann  j       c  
ignoring delete lists works  local search topology planning benchmarks 
tech  rep       albert ludwigs universitat 
institut fur informatik  freiburg  germany 
available http   www mpiinf mpg de hoffmann papers jair  report ps gz 
hoffmann  j     edelkamp  s          deterministic part ipc    overview  journal
artificial intelligence research  appear 
hoffmann  j     nebel  b       a   planning system  fast plan generation
heuristic search  journal artificial intelligence research             
hoffmann  j     nebel  b       b   rifo revisited  detecting relaxed irrelevance   cesta 
  borrajo  cesta   borrajo         pp         
kautz  h  a     porter  b   eds     aaai            proceedings   th national
conference american association artificial intelligence  aaai      austin 
tx  mit press 
koehler  j     hoffmann  j          reasonable forced goal orderings use
agenda driven planning algorithm  journal artificial intelligence research 
           
koehler  j     schuster  k          elevator control planning problem   chien et al 
 chien et al          pp         
koenig  s   zilberstein  s     koehler  j   eds     icaps            proceedings
  th international conference automated planning scheduling  icaps     
whistler  canada  morgan kaufmann 
long  d     fox  m          automatic synthesis use generic types planning  
chien et al   chien et al          pp         
   

fiwhere ignoring delete lists works

long  d     fox  m           rd international planning competition  results
analysis  journal artificial intelligence research          
mcdermott  d          heuristic estimator means ends analysis planning  drabble  b   ed    proceedings  rd international conference artificial intelligence
planning systems  aips      pp          aaai press  menlo park 
mcdermott  d               ai planning systems competition  ai magazine 
             
mcdermott  d  v          using regression match graphs control search planning 
artificial intelligence                    
nebel  b   ed     ijcai            proceedings   th international joint conference
artificial intelligence  ijcai      seattle  washington  usa  morgan kaufmann 
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts operators
plan generation   steel    alami  steel   alami         pp         
nguyen  x     kambhampati  s          extracting effective admissible heuristics
planning graph   kautz    porter  kautz   porter         pp         
nguyen  x     kambhampati  s          reviving partial order planning   nebel  nebel 
       pp         
onaindia  e   sapena  o   sebastia  l     marzal  e          simplanner  executionmonitoring system replanning dynamic worlds   brazdil    jorge  brazdil  
jorge         pp         
penberthy  j  s     weld  d  s          ucpop  sound  complete  partial order planner
adl  nebel  b   swartout  w     rich  c   eds    principles knowledge
representation reasoning  proceedings  rd international conference  kr     pp          cambridge  ma  morgan kaufmann 
refanidis  i     vlahavas  i          grt  domain independent heuristic strips
worlds based greedy regression tables   biundo    fox  biundo   fox        
pp       
refanidis  i     vlahavas  i          grt planning system  backward heuristic construction forward state space planning  journal artificial intelligence research 
           
rintanen  j          iterative algorithm synthesizing invariants   kautz    porter
 kautz   porter         pp         
sebastia  l   onaindia  e     marzal  e          stella  optimal sequential parallel
planner   brazdil    jorge  brazdil   jorge         pp         
srivastava  b   nguyen  x   kambhampati  s   do  m  b   nambiar  u   nie  z   nigenda  r  
  zimmermann  t          altalt  combining graphplan heuristic state search 
ai magazine               
steel  s     alami  r   eds            recent advances ai planning   th european conference planning  ecp     vol       lecture notes artificial intelligence 
toulouse  france  springer verlag 
   

fihoffmann

thiebaux  s   hoffmann  j     nebel  b          defence pddl axioms  gottlob  g 
 ed    proceedings   th international joint conference artificial intelligence
 ijcai      pp          acapulco  mexico  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          defence pddl axioms  artificial
intelligence  appear 
younes  h     simmons  r          role ground actions refinement planning  
ghallab et al   ghallab et al          pp       

   


