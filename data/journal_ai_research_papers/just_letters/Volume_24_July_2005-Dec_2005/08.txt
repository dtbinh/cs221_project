journal of artificial intelligence research                  

submitted        published      

where ignoring delete lists works 
local search topology in planning benchmarks
jorg hoffmann

hoffmann mpi sb mpg de

max planck institute for computer science 
stuhlsatzenhausweg    
      saarbrucken
germany

abstract
between      and       the planning community has seen vast progress in terms of
the sizes of benchmark examples that domain independent planners can tackle successfully 
the key technique behind this progress is the use of heuristic functions based on relaxing
the planning task at hand  where the relaxation is to assume that all delete lists are empty 
the unprecedented success of such methods  in many commonly used benchmark examples 
calls for an understanding of what classes of domains these methods are well suited for 
in the investigation at hand  we derive a formal background to such an understanding  we perform a case study covering a range of    commonly used strips and adl
benchmark domains  including all examples used in the first four international planning
competitions  we prove connections between domain structure and local search topology
 heuristic cost surface properties  under an idealized version of the heuristic functions
used in modern planners  the idealized heuristic function is called h    and differs from
the practically used functions in that it returns the length of an optimal relaxed plan 
which is np hard to compute  we identify several key characteristics of the topology under h    concerning the existence non existence of unrecognized dead ends  as well as the
existence non existence of constant upper bounds on the difficulty of escaping local minima
and benches  these distinctions divide the  set of all  planning domains into a taxonomy
of classes of varying h  topology  as it turns out  many of the    investigated domains lie
in classes with a relatively easy topology  most particularly     of the domains lie in classes
where ffs search algorithm  provided with h    is a polynomial solving mechanism 
we also present results relating h  to its approximation as implemented in ff  the
behavior regarding dead ends is provably the same  we summarize the results of an empirical investigation showing that  in many domains  the topological qualities of h  are
largely inherited by the approximation  the overall investigation gives a rare example of a
successful analysis of the connections between typical case problem structure  and search
performance  the theoretical investigation also gives hints on how the topological phenomena might be automatically recognizable by domain analysis techniques  we outline some
preliminary steps we made into that direction 

   introduction
between      and       one of the strongest trends in the planning community has been that
towards heuristic planners  more specifically towards the use of heuristic distance  in most
cases  goal distance  estimation functions  the best runtime results  progressing far beyond
the sizes of benchmark examples that previous domain independent planners could tackle
successfully  have been achieved based upon a technique phrased ignoring delete lists 
c
    
ai access foundation  all rights reserved 

fihoffmann

there  the heuristic function is derived by considering a relaxation of the planning task at
hand  where the relaxation is to assume that all delete lists  i e  the negative effects of the
available planning operators  are empty  during search  may it be forward or backward 
state space or plan space  the heuristic value of a search state in this framework is  an
estimate of  the difficulty of extending the state to a solution using the relaxed operators 
where difficulty is defined as the number of  relaxed  actions needed 
the number of real actions needed to extend a search state to a solution is at least
as high as the number of relaxed actions needed  so optimal  shortest  relaxed solutions
can  in principle  be used to derive admissible heuristic functions  however  as was first
proved by bylander         deciding bounded plan existence  i e   the existence of a plan
with at most some given number of actions  is np hard even when there are no delete lists  
thus there is not much hope to find optimal relaxed plans  i e   optimal relaxed solutionextensions of search states  fast  instead  one can approximate the length of an optimal
relaxed plan to a search state  techniques of this kind were first  independently  proposed by
mcdermott        and by bonet  loerincs  and geffner         who developed the planners
unpop  mcdermott               and hsp   bonet et al          both these planners
perform forward state space search guided by an approximation of relaxed goal distance 
unpop approximates that distance by backchaining from the goals  hsp  approximates
that distance by a forward value iteration technique 
in the  st international planning competition  ipc    mcdermott         hosted at
aips       hsp  compared well with the four other competitors  this inspired the development of hsp r and hsp   bonet   geffner            b      a   grt  refanidis  
vlahavas               altalt  nguyen   kambhampati        srivastava  nguyen  kambhampati  do  nambiar  nie  nigenda    zimmermann         as well as ff  hoffmann 
      hoffmann   nebel      a  hoffmann      a   hsp r avoids heuristic re computations
by changing the search direction  hsp  implements the various hsp versions in a configurable hybrid system  grt avoids heuristic re computations by changing the heuristic
direction  the direction in which relaxed plans are computed   altalt uses a planning
graph to extract heuristic values  ff uses a modified technique for approximating optimal
relaxed plan length  namely  by computing a not necessarily optimal relaxed plan  which
can be done in polynomial time   as well as new pruning and search techniques  ff inspired the integration of heuristic search engines into mips  edelkamp   helmert       
and stan   fox   long         using elaborated variations of ffs relaxed plan length
estimation technique 
in the  nd international planning competition  ipc    bacchus         hosted at aips      the heuristic planners dramatically outperformed the other approaches runtime wise 
scaling up to benchmark examples far beyond reach of previous  e g   graphplan based
 blum   furst               systems  this caused the trend towards heuristic planners
to still increase  various researchers extended relaxed plan distance estimation techniques
to temporal and numeric settings  do   kambhampati        hoffmann            a 
edelkamp      b   others adapted them for use in partial order plan space search  nguyen
   for parallel planning  where the bound is on the number of parallel time steps needed  deciding bounded
plan existence is easy without delete lists  however  heuristic functions based on this observation have
generally not been found to provide useful search guidance in practice  see  for example  haslum  
geffner        bonet   geffner      b  

   

fiwhere ignoring delete lists works

  kambhampati        younes   simmons         developed variations of them to provide
new means of heuristic guidance  onaindia  sapena  sebastia    marzal        sebastia 
onaindia    marzal         or modified them to take exclusion relations in a planning graph
into account  gerevini   serina        gerevini  serina  saetti    spinoni        
in the  rd international planning competition  ipc    long   fox         hosted at
aips       out of    domain independent competing systems    were using relaxed plan
distance estimations in one or the other form  the  st prize winner lpg  gerevini   serina 
      gerevini  saetti    serina        uses  amongst other heuristics  a relaxed planning
technique to estimate the difficulty of sub goal achievement in a planning graph  in the
 th international planning competition  ipc    hoffmann   edelkamp        edelkamp 
hoffmann  englert  liporace  thiebaux    trug         hosted at icaps       out of   
competing sub optimal systems     were using relaxed plan based heuristics  there were
two  st prize winners in that category  fast downward  helmert        helmert   richter 
      and sgplan  chen   wah        chen  hsu    wah         the latter uses the
numeric version of ff as a sub process  one version of the former combines ffs heuristic
estimates with a new heuristic function based on causal graph analysis  helmert        
in the investigation at hand  we derive a formal background as to what classes of domains methods of the kind described above are well suited for  we make two simplifying
assumptions  first  we consider forward state space search only  as used by  for example 
unpop  hsp  mips  ff  and fast downward  in a forward state space search  one starts
at the initial state and explores the space of reachable states until a goal state is found 
the state transitions follow a sequential planning framework  where only a single action is
applied at a time   assuming forward search makes the investigation easier since such a
search is a very natural and simple framework  our second simplifying assumption is to
idealize matters in that we consider the heuristic value given by the optimal relaxed plan
length  the length of a shortest sequential relaxed plan  to each search state s  we denote
that value with h   s   under this assumption  as we will see there are many provable
connections between domain structure and heuristic quality  of course  the simplifying assumptions restrict the relevance of the results for practical planners  more on this is said
below in this section  and in section    another  more benign  restriction we make is to
consider solvable tasks only  this is a very common restriction in ai planning  particularly
in the competitions  where the main focus is on how good planners are at finding plans 
more specifically  the main focus of the investigation at hand is to characterize the kinds of
domains in which  relaxed plan based  heuristic planners can find plans fast 
it is common knowledge that the behavior of heuristic search methods  may they be
global or local  i e   with or without backtracking mechanisms  depends crucially on the
quality of the underlying heuristic function  this has  for example  been studied in the
sat community  for example by frank  cheeseman  and stutz         in their work  these
authors empirically investigate properties of the local search topology  i e   of topological
properties like the sizes of local minima etc   in sat instances under a standard heuristic
function  we adapt frank et al s definitions to ai planning  in difference to frank et
al   we take a more analytical approach where we prove properties that are valid across
   in principle  a parallel forward search is possible  too  to the best of the authors knowledge  there
is no published work about an implementation of this  at the time of writing  the main difficulty is 
presumably  the high branching factor 

   

fihoffmann

certain ranges  namely domains  of example problem instances  we investigate a range of
   commonly used strips and adl benchmark domains including all examples used in
the first four international planning competitions  we identify several key characteristics of
the topology of the respective search spaces under h    the characteristics are the following 
   in    of the benchmark domains  there are no unrecognized dead ends  i e   no states
from which the goal is unreachable but for which there is a relaxed plan 
   in    of the above    benchmark domains  the maximal exit distance from local
minima is constantly bounded  i e   one can always escape local minima  regions
where all neighbors have a higher heuristic value  within a number of steps that is
constant across all instances of the domain  regardless of their size  in fact  in    of
these domains there are no local minima at all  
   in    of the above    benchmark domains  the maximal exit distance from benches
is constantly bounded  i e   one can always escape benches  regions where all states
have the same heuristic value  within a number of steps that is constant across all
instances of the domain  regardless of their size  in   domains the bound is    in one
domain it is even    
beside the positive results proving characteristic qualities of the h  function  the
investigation also provides  parameterized  counter examples in the negative cases  the
results divide the investigated domains  more generally  all possible planning domains  into
a meaningful taxonomy of classes which differ in terms of their topological behavior with
respect to h    many of the    investigated domains lie in relatively easy classes  i e   classes
where h  is a  provably  high quality heuristic  most particularly  the    domains with
all the above properties lie in classes where ffs search algorithm is a polynomial solving
mechanism  under the idealizing assumption that ffs approximative heuristic function
identifies the real h  distances  ffs search algorithm  called enforced hill climbing  tries
to escape local minima or benches by means of a breadth first search  breadth first search
is exponential only in the search depth  so if local minima and benches can always be
escaped from within a constant number of steps  as is the case in these    domains  then
the effort spent in the search is polynomially bounded  in this way  our results provide
non trivial insights into typical case problem structure  in benchmarks   and its possible
effects on search performance  examples of successful theoretical investigations of this kind
are extremely rare in the ai literature 
to give the reader a feeling for what we are looking at  figure   shows two visualized
state spaces  the shown tasks are instances of two domains from the easiest classes of the
taxonomy  gripper and logistics  the graph nodes are the states  the edges are the state
transitions  action applications   the height is given by the h  value   in both pictures  the
initial state is somewhere in the left top part  the goal states are  of course  the states with
minimal  zero  h  value  the gripper picture speaks for itself  the logistics topology
is less extreme  but still the state space forms one big valley at the bottom of which there
are the goal states 
   the h  values here  and in an empirical investigation  hoffmann      b      b  preceding our theoretical
analysis  were computed by an iterative deepening forward search in the space of relaxed action sequences 

   

fiwhere ignoring delete lists works

 a 

 b 

figure    visualized state space under h  of  a  a gripper and  b  a logistics instance 

of course  ffs approximation of h    which we refer to as hf f   does not always identify
the real h  values  and so it is a priori not evident what relevance the theoretical results
about h  have for ffs efficiency in practice  additionally  most forward searching planners
do not use enforced hill climbing  for which the topological results have the most striking
impact  finally  and most importantly  several competitive other planners do not even
perform a forward search  or use additional new techniques in the heuristic function that
are explicitly aimed at identifying better information than relaxed plans  prominent systems
of the former kind are hsp r and lpg  prominent systems of the latter kind are lpg and
fast downward 
as for the relevance of the results for the performance of ff  the practical performance of
ff coincides quite well with them  more concretely  the behavior of h  with respect to dead
ends is provably the same as that of hf f   moreover  a large scale empirical investigation
 contained in hoffmann      b  has shown that  in many domains  the topology of h  is
largely preserved by hf f   we include a section containing a brief summary of these results 
the relevance of the topological results for forward search algorithms other than enforced
hill climbing  and the performance of planners using other search paradigms or enhanced
heuristics  is discussed in section   
we remark that our topological investigation was not specifically intended to identify
properties relevant to enforced hill climbing  the theoretical investigation was preceded
by an empirical investigation  hoffmann      b      b  where we measured all kinds of
topological parameters  including  for example  size and diameter of local minima  benches 
and other structures such as so called valley regions  it turned out that the only topology
parameters that showed interesting behavior across a significant number of domains were
the maximal exit distance parameters considered in the investigation at hand  this  in fact 
came as a surprise to us  we invented enforced hill climbing in ff before it became clear
   

fihoffmann

that many of the planning benchmarks share topological properties favoring precisely this
particular search algorithm 
observe that the proved results are of a worst case nature  i e   a heuristic search using
 
h can show good behavior in an example suite of a domain even if that domain lies in
a very difficult class of the taxonomy  given the particular example instances in the test
suite do not emphasize on the worst cases possible in the domain  where relevant  we will
discuss this issue with regards to the example suites used in the competitions 
the employed proof methods give hints as to how the topological phenomena might be
automatically detectable using general domain analysis techniques  in an extra section  we
report on a first  not yet very successful  attempt we made to do that 
the proofs for the individual planning domains are  in most cases  not overly difficult 
but the full details for all domains are extremely space consuming  the details  except for
the   ipc   domains   i e   pddl like definitions of the domains as well as fully detailed
proofs  can be looked up in a long      pages  technical report  hoffmann      c  that also
forms an online appendix to the article   the article itself provides proof sketches  which
are much better suited to get an overall understanding of the investigation and its results 
since even the proof sketches are sometimes hard to read  they are moved into an appendix 
another appendix provides brief descriptions of all domains  the main body of text only
gives the results and an outline of the main proof arguments used to obtain them 
the paper is organized as follows  section   provides the necessary background  i e 
a straightforward formal framework for strips and adl domains  an overview of the
investigated domains  and the definitions of local search topology  section   presents some
core lemmas underlying many of the proofs in the single domains  and illustrates the lemmas
application in a small example  section   gives all the results with a brief proof outline 
and shows the resulting planning domain taxonomy  section   presents the results relating
h  to hf f   and section   reports on our first attempt to design domain analysis techniques
for automatically detecting the h  topological phenomena  section   concludes the article
with a brief discussion of our contributions and of future work  appendix a contains the
proof sketches for the individual domains  appendix b contains the domain descriptions 

   background
background is necessary on the planning framework  the investigated domains  and local
search topology 
    planning framework
to enable theoretical proofs to properties of planning domains rather than single tasks  we
have defined a formal framework for strips and adl domains  formalizing in a straightforward manner the way domains are usually dealt with in the community  we only outline
the rather lengthy definitions  and refer the reader to the tr  hoffmann      c  for details 
in what follows  by sets we mean finite sets unless explicitly said otherwise 
   we remark that the tr is not a longer version of the paper at hand  the trs overall structure and
presentation angle are very different  and it is only intended as a source of details if needed 

   

fiwhere ignoring delete lists works

a planning domain is defined in terms of a set of predicates  a set of operators  and
a possibly infinite set of instances  all logical constructs in the domain are based on the
set of predicates  a fact is a predicate applied to a tuple of objects  the operators are
 k ary  where k is the number of operator parameters  functions from the  infinite  set of
all objects into the  infinite  set of all strips or adl actions  a strips action a is a
triple  pre a   add a   del a    as precondition  which is a conjunction of facts  as add list 
a fact set  and as delete list  also a fact set  an adl action a is a pair  pre a   e a   where
the precondition pre a  is a first order logical formula without free variables  and e a  is
a set of effects e of the form  con e   add e   del e   where con e   the effect condition  is
a formula without free variables  and add e   the effects add list  as well as del e   the
effects delete list  are fact sets  if the add list of an action effect contains a fact p  we also
say that the action effect achieves p 
an instance of a domain is defined in terms of a set of objects  an initial state  and a goal
condition  the initial state is a set of facts  and the goal condition is a formula without free
variables  in the strips case  a conjunction of facts   the facts that are contained in the
initial state are assumed to be true  and all facts not contained in it are assumed to be false 
i e   as usual we apply the closed world assumption  an instance of a domain constitutes 
together with the domains operators  a planning task  a  i  g  where the action set a is
the result of applying the operators to the instances objects  i e   to all object tuples of the
appropriate lengths   and the initial state i and goal condition g are those of the instance 
we identify instances with the respective planning tasks 
a state s is a set of facts  a logical formula holds in a state if the state is a model of
the formula according to the standard definition for first order logic  where a logical atom 
a fact  holds iff it is contained in the state   the result result s  hai  of applying an action
sequence consisting of a single strips or adl action a to a state s is defined as follows 
if the actions precondition does not hold in s  then result s  hai  is undefined  otherwise 
result s  hai  is obtained from s by including all of as add effects  and  thereafter  removing
all of as delete effects  if a is an adl action  only those add effects add e  are included
 delete effects del e  are removed  for which the respective effect condition con e  holds in
s  the result of applying a sequence ha            an i consisting of more than one action to a
state s is defined as the iterative application of the single actions in the obvious manner 
apply a  to s  then apply a  to result s  ha  i   and so on 
a plan  or solution  for a task  a  i  g  is a sequence of actions p  a that  when
successively applied to i  yields a goal state  i e   a state in which g holds   we use the
standard notation m    where m is a set  to denote the set of all sequences of elements of
m    for many proofs we need the notion of optimality  a plan p for a task  a  i  g  is
optimal if there is no plan for  a  i  g  that contains fewer actions than p  
note that  as announced in the introduction  the definition  in particular the definition
of plan optimality  stays within the forward state space search framework where plans are
simple sequences of actions  note also that ignoring the delete lists simplifies a task only if
all formulas are negation free  for a fixed domain  tasks can be polynomially normalized to
have that property  compute the negation normal form to all formulas  negations only in
front of facts   then introduce for each negated fact b a new fact not b and make sure it
is true in a state iff b is false  gazen   knoblock         this is the pre process done in 
   

fihoffmann

for example  ff  in the investigation at hand  we have considered the normalized versions
of the domains  
we also consider a few domains  from the ipc   collection  that feature derived predicates  such predicates are not affected by the effects of the operators  and their truth value
is instead derived from the values of the other  basic  predicates  via a set of derivation
rules  a derivation rule has the form  x   p  x  where p is the derived predicate and
  a formula  is the rules antecedent  both using the free variables x  the obvious idea
is that  if  x  holds  then p  x  can be concluded  in a little more detail  the semantics
are defined as follows  in the initial state  and whenever an action was applied  first all
derived predicate instances  derived facts  are assumed to be false  then all derivation rules
are applied until a fixpoint occurs  the derived facts that could not be concluded until
then are said to be false  this is called negation as failure   derived predicates can be used
just like any other predicate in the operator preconditions  in the effect conditions  and in
the goal condition  however  to ensure that there is a unique fixpoint of rule application 
the use of derived predicates in derivation rule antecedents is restricted  in the context of
ipc    to a positive use in the sense that these predicates do not appear negated in the
negation normal form of any rule antecedent  hoffmann   edelkamp        
to make ignoring delete lists a simplification  one also needs that the derived facts are
used only positively in the operator preconditions  effect conditions  and goal condition
 otherwise the derived predicates can  for example  be used to model negated preconditions etc    due to the negation as failure semantics of derived predicates  there isnt a
simple compilation of negations as in the pure adl case  the approach we take here 
and that is implemented in  for example  the version of ff that treats derived predicates
 thiebaux  hoffmann    nebel               is to simply ignore  replace with true  negated
derived predicates in  the negation normal form of  operators and the goal  see also below 
section      
    domains overview
as said before  our case study covers a total of    commonly used strips and adl benchmark domains  these include all the examples from the first four international competitions 
plus   more domains used in the literature  brief descriptions of all domains can be looked
up in appendix b  full formal definitions of the domains  except the   ipc   domains  are
in the tr  hoffmann      c   note that  for defining a domain  one must amongst other
things decide what exactly the instances are  naturally  to do so we have abstracted from
the known example suites  in most cases the abstraction is obvious  in the less obvious
cases the respective subsection of appendix b includes some explanatory remarks 
here  we provide a brief overview of the    analyzed domains  the domains are categorized into three groups according to their semantics  at a high level of abstraction  the
categorization is not  in any way  related to the topological characterization we will derive
later  we use it only to give the overview some structure 
   ignoring delete lists in the normalized domains comes down to a relaxation that  basically  allows  the
translated  facts to take on both truth values at the same time 

   

fiwhere ignoring delete lists works

   transportation domains  these are domains where there are locations  objects
that must be transported  and vehicles that are the means of transportation   operators mostly either move a vehicle  or load  unload  an object onto  from  a vehicle  the domains differ in terms of various constraints  an important one is that  in
many domains  vehicles can move instantaneously between any two locations  while in
other domains the movable links between locations form arbitrary road maps  there
are    transportation domains in the collection we look at  logistics  the classical transportation domain  where trucks airplanes transport objects within between
cities  gripper  a robot with two gripper hands transports a number of balls  one
at a time in each hand  from one room to another  ferry  a single ferry transports
cars one at a time  driverlog  trucks need drivers on board in order to move  the
location links form bi directional road maps  which can be different for trucks and
drivers   briefcaseworld  a briefcase moves  by conditional effects  all objects along
that are inside it  grid  a robot transports keys on a grid like road map where
positions can be locked and must be opened with keys of matching shapes  miconicstrips  an elevator transports passengers  using explicit actions to board deboard
passengers  miconic simple  like miconic strips  but passengers board deboard
themselves by conditional effects of the action that stops the elevator at a floor 
miconic adl  like miconic simple  but various constraints must be obeyed  for
example  vips first   zenotravel  airplanes use fuel items that can be replenished
one by one using a refuel operator  mprime  on an arbitrary road map  trucks use
non replenishable fuel items  and fuel can be transferred between locations  mystery
 like mprime  but without the possibility to transfer fuel  airport  inbound and
outbound planes must be moved safely across the road map of an airport 
   construction domains  these are generally not as closely related as the transportation domains above  what the construction domains have in common  roughly 
is that a complex object must be built out of its individual parts  there are   such
domains in the collection we look at  blocksworld arm  the classical construction
domain  where blocks are picked up put down or stacked onto unstacked from each
other by means of a robot arm  blocksworld no arm  like above  but blocks are
moved around directly from a block to a block   from the table to a block   from a
block to the table  depots  a combination of blocksworld arm and logistics  where
objects must be transported between locations before they can be stacked onto each
other  freecell  an encoding of the solitaire card game that comes with microsoft
windows  the complex object to be constructed is the final position of the cards  
hanoi  an encoding of the classical towers of hanoi problem  assembly  a complex
object must be assembled together out of its parts  which themselves might need to
be assembled beforehand 
   other domains  there are    domains in the collection whose semantics do not
quite fit into either of the above groups  simple tsp  a trivial strips version of the
   the term transportation domains was suggested  for example  by long and fox        and helmert
        the transportation benchmarks are generally more closely related than the other groups of
domains overviewed below  and we will sometimes discuss transportation domains on a rather generic
level 

   

fihoffmann

tsp problem  where the move operator can be applied between any two locations 
movie  in order to watch a movie  one must buy snacks  set the counter on the video
to zero  and rewind the tape  tireworld  a number of flat tires must be replaced 
which involves various working steps  like removing a flat tire and putting on a new
one   fridge  for a number of fridges  the broken compressors must be replaced 
which involves various working steps  like loosening fastening the screws that hold
a compressor   schedule  objects must be processed  painted  for example  on a
number of machines  satellite  satellites must take images  of phenomena in space  
using appropriate instruments  rovers  rovers must navigate along a road map  take
soil rock samples as well as images  and communicate the resulting data to a lander 
pipesworld  oil derivatives must be propagated through a pipeline network  psr 
some lines must be re supplied in a faulty electricity network  dining philosophers 
the deadlock situation in the dining philosophers problem  translated to adl from
the automata based promela language  edelkamp      a   must be found  opticaltelegraph  similar to dining philosophers  but considering an encoding of a telegraph
communication system 
    local search topology
remember that we only consider solvable tasks  since the main focus of the investigation is
to characterize the kinds of domains in which heuristic planners can find plans fast  some
discussion of unsolvable tasks is in section   
given a planning task  a  i  g   the state space  s  t   is a graph where s are all states
that are reachable from the initial state  and t is the set of state transitions  i e   the set of
all pairs  s  s     s  s of states where there is an action that leads to s  when executed in
s  the goal distance gd s  for a state s  s is the length of a shortest path in  s  t   from s
to a goal state  or gd s     if there is no such path  in the latter case  s is a dead end  we
discuss such states directly below  a heuristic is a function h   s   n       a heuristic
can return  to indicate that the state at hand might be a dead end 
given a strips action a    pre a   add a   del a    the relaxation a  of a is
 pre a   add a      given an adl action a    pre a   e a    the relaxation a  of a is
 pre a   e a     where e a   is the same as e a  except that all delete lists are empty  for
a set a of actions  the relaxation a  of a is a      a    a  a   an action sequence
 
 
ha            an i is a relaxed plan for  a  i  g  if ha 
            an i is a plan for  a   i  g   with that 
 

for any state s  h  s    min n   p   ha            an i  a   p is relaxed plan for  a  s  g   
where the minimum over an empty set is  
in the presence of derived predicates  as said above we additionally relax the planning
task by ignoring  replacing with true  all negated derived predicates in the negation normal
forms of preconditions  effect conditions  and the goal condition  note that  with this
additional simplification  it can happen that h   s  is   although s is not a goal state 
because the simplification might relax the goal condition itself  indeed  this happens in the
psr domain  in all other domains we consider here  derived predicates are either not used
at all or used only positively  so there h   s      iff s is a goal state 
   while the article focuses mainly on the h  heuristic  we keep the topology definitions  which do not
depend on the specific heuristic used  somewhat more general 

   

fiwhere ignoring delete lists works

one phenomenon that is clearly relevant for the performance of heuristic state space
search is that of dead end states s  gd s      a heuristic function h can return h s     
taking this as an indication that s is a dead end  the obvious idea is to remove s from the
search space  this is done in  for example  hsp and ff   this technique is only adequate if
h is completeness preserving in the sense that h s      gd s     for all s  s  with
a completeness preserving heuristic  a dead end state s is called recognized if h s     and
unrecognized otherwise  note that h  is completeness preserving  if a task can not be solved
even when ignoring the delete lists  then the task is unsolvable  from now on we assume
that the heuristic we look at is completeness preserving  with respect to dead ends  any
planning state space falls into one of the following four classes  the state space is called 
   undirected  if  for all  s  s     t    s    s   t  
   harmless  if there exists  s  s     t such that  s    s    t   and  for all s  s  gd s     
   recognized  if there exists s  s such that gd s      and  for all s  s  if gd s    
then h s     
   unrecognized  if there exists s  s such that gd s     and h s     
in the first class  there can be no dead ends because everything can be undone  in the
second class  some things can not be undone  but those single directed state transitions do
not do any harm  in the sense that there are no dead end states  in the third class  there
are dead end states  but all of them are recognized by the heuristic function  the only
critical case for heuristic search is class four  where a search algorithm can run into a dead
end without noticing it  this is particularly relevant if  potentially  large regions of the
state space consist of unrecognized dead end states  to capture this  we define the depth of
an unrecognized dead end s as the number of states s  such that s  is an unrecognized dead
end  and s  is reachable from s by a path that moves only through unrecognized dead ends 
our investigation determines  for each of the    benchmark domains looked at  exactly in
which of the above four dead end classes the instances of the domain belong  for the domains
where it turns out that there can be unrecognized dead ends  we construct parameterized
examples showing that the unrecognized dead ends can be arbitrarily deep  in several
domains  individual instances can fall into different classes  in this case we associate the
overall domain with the worst case class  i e   the class with highest index in the above 
for example  in miconic adl  if there are no additional constraints to be obeyed on the
transportation of passengers then the state space is harmless as in miconic simple  but
if constraints on  for example  the possible direction of travel and the access to floors are
given  then unrecognized dead ends can arise  to avoid clumsy language  henceforth  if we
say that a state space is harmless recognized unrecognized  then we mean that it falls into
the respective class  or into a class below it 
we now get into the definitions of general topological phenomena  i e   of relevant properties of the search space surface  we adapt the definitions given for sat by frank et al 
        the difference between the sat framework there  and the planning formalism here 
lies in the possibly single directed state transitions in planning  in the search spaces considered by frank et al   all state transitions can be traversed in both directions  single directed
   

fihoffmann

state transitions can have an important impact on the search space topology  enabling  for
example  the existence of dead ends  
the base entity in the state space topology are what frank et al  name plateaus  these
are regions that are equivalent under reachability aspects  and look the same from the point
of view of the heuristic function  for l  n      a plateau p of level l is a maximal subset
of s for which the induced subgraph in  s  t   is strongly connected  and h s    l for each
s  p    plateaus differ in terms of the possibilities of leaving their heuristic level  i e   of
reaching an exit  for a plateau p of level l  an exit is a state s reachable from p   such that
h s    l and there exists a state s     s  s     t   with h s      h s   based on the behavior
with respect to exits  we distinguish between five classes of plateaus  we need the notion
of flat paths  these are paths in  s  t   on that the value of h remains constant 
   a recognized dead end is a plateau p of level l    
   a local minimum is a plateau p of level     l    from that no exit is reachable on
a flat path 
   a bench is a plateau p of level     l     such that at least one exit is reachable
from p on a flat path  and at least one state on p is not an exit 
   a contour is a plateau p of level     l    that consists entirely of exits 
   a global minimum is a plateau p of level   
each plateau belongs to exactly one of these classes  intuitively  the roles that the different
kinds of plateaus play for heuristic search are the following  recognized dead ends can
be ignored with a completeness preserving heuristic function  local minima are difficult
because all neighbors look worse  so it is not clear in which direction to move next  benches
are potentially easier  because one can step off them without temporarily worsening the
heuristic value  from contours  one can step off immediately   
the main difficulty for a heuristic search is how to deal with the local minima and the
benches  in both cases  the search algorithm must  eventually  find a path to an exit in
order to get closer to the goal  as far as the heuristic function is informed about what is
closer to the goal and what is not   how difficult it is to find an exit can be assessed by a
variety of different parameters  the size  number of states  or diameter  maximum distance
between any two states  of the local minimum the bench  and the number of nearby exit
states  to name some important ones  in the benchmarks considered  as mentioned in the
introduction  we empirically found that there are no  or very few  interesting observations
to be made about these parameters  hoffmann      b      b  
   one can  of course  introduce backtracking mechanisms into a search space  such as always giving the
planner the possibility to retract the last step  but that does not affect the relevant topological differences
between search spaces  instead of domains with without dead ends  one gets domains where backtracking
is necessary not necessary 
   the difference to the undirected case is that we require the states on the plateau to be strongly connected
 with undirected state transitions this is trivially fulfilled by any set of connected states 
    the differences to the undirected case lie in that there can be plateaus of level   and that we allow exits
to not lie on the plateaus themselves  the latter is just a minor technical device to obtain a compact
terminology 

   

fiwhere ignoring delete lists works

what one can frequently observe are interesting properties of the distance to the nearest
exit state  the distance dist s  s    between any two states s  s   s is the usual graph
distance  i e   the length of a shortest path from s to s  in  s  t    or  if there is no such
path  the exit distance ed s  of a search state s is the distance to the nearest exit  i e  
ed s    min d   d is the length of a path in  s  t   from s to a state s  s t  h s      h s  
and there exists a state s   s t   s    s      t   and h s       h s      
where  as before  the minimum over an empty set is   note that we do not require the
path in the definition to be flat  i e   it may be that  in order to reach s    we temporarily
have to increase the h  value  this is because we want the definition to capture possible
escape routes from any state in the state space  including states that lie on local minima 
the maximal local minimum exit distance  mlmed s  t    of a state space  s  t   is the
maximum over the exit distances of all states on local minima  or   if there are no such
states  the maximal bench exit distance  mbed s  t    of a state space  s  t   is the maximum
over the exit distances of all states on benches  or   if there are no such states  we will find
that  in many of the considered domains  there are constant upper bounds on mlmed s  t  
and or mbed s  t   under h    i e   bounds that are valid irrespectively of the  size of the 
instance chosen 
the following is an implication that is relevant for the subsequent investigation 
proposition   given a solvable task  a  i  g   with state space  s  t   and a completenesspreserving heuristic h  where h s       gd s      for s  s  if there exists an unrecognized
dead end s  s  then mlmed s  t      
proof  let s be an unrecognized dead end  and let s  be a state reachable from s so that
the h value of s  is minimal  then s  is an unrecognized dead end  too  in particular  s is
considered reachable from itself   and since h s         gd s        we have h s         we
further have  since the h value of s  is minimal among the states reachable from s  that
h s      h s    for all states s   reachable from s    thus the plateau on which s  lies is a local
minimum  no exits are reachable  in particular not on flat paths  this also shows that s 
has infinite exit distance 
 
proposition   says that  in every region of unrecognized dead ends  there is a local
minimum  given h s       gd s         with the above definitions  that unrecognized
dead end state yields an infinite local minimum exit distance  it makes sense to define
things this way because an  arbitrarily deep  unrecognized dead end is worse than any local
minimum  it can not be escaped from at all 
    remember that the latter can be untrue for h  only if the domain features derived predicates that
appear negated in the negation normal form of the goal condition  and even then  by the argument in
the proposition  every region of unrecognized dead ends would contain a global minimum consisting of
non solution states  we could have defined such fake global minima to be local minima  but decided
against it in order to not overly complicate the topological definitions  and since that detail does not
seem very important  as said before  in all but one of our    domains we have h   s       gd s     
anyway 

   

fihoffmann

   some core lemmas
in many of the investigated domains  intuitively similar patterns of problem structure cause
the characteristic qualities of h    some of this common structure can be generalized and
captured in concise definitions and lemmas  the lemmas formulate sufficient criteria implying that  the state space of  a planning task has certain topological properties  proofs
for domains proceed  where possible  by applying the lemmas to arbitrary instances  in
several domains where the lemmas can not be applied immediately  due to syntactic details
of the domain definitions   similar proof arguments suffice to show the desired topological
properties 
we restrict ourselves to strips tasks in the lemmas  appropriate extensions to adl
and or to derived predicates are probably possible at least in certain cases  but we have not
investigated this in detail  such extensions are likely to be rather complicated notationally 
and the simpler strips case suffices to transport the ideas 

initial state 
at v  l     at o    l     at o    l   
goal 
at o    l     at o    l   
actions 
name
precondition
move l  l   
at v  l 
load o  l 
at v  l   at o  l 
unload o  l  at v  l   in o  v  

add list
at v  l   
in o  v  
at o  l 

delete list
at v  l 
at o  l 
in o  v  

figure    a simple strips transportation task 
throughout the section  we assume we are given a strips task  a  i  g   as an illustrative example for the definitions and lemmas  we will use the simple transportation task
defined in figure    in what follows  there are three separate sections  concerned with dead
ends  local minima  and benches  respectively 
the definitions and lemmas in the following are not syntactical  in the sense that they
make use of informations that can not be computed efficiently  for example  inconsistencies
between facts   we do not discuss this  and focus exclusively on the role of the definitions
and lemmas as tools for proving h  topology  the role of the definitions and lemmas as
tools for automatically detecting h  topology will be discussed in section   
    dead ends
we first focus on criteria sufficient for the non existence of dead ends  our starting point is
a reformulated version of a simple result mentioned by  for example  koehler and hoffmann
        we need the notion of inconsistency  two facts are inconsistent if there is no
reachable state that contains both of them  a set of facts f is inconsistent with another set
   

fiwhere ignoring delete lists works

of facts f   if each fact in f is inconsistent with at least one fact in f       an action a  a
is invertible if 
    add a  is inconsistent with pre a  
    del a   pre a  
    there is an action a  a such that
 a  pre a    pre a   add a     del a  
 b  add a    del a   and
 c  del a    add a  
the intentions behind these requirements are the following      and     ensure that
as effects all occur    a  ensures that a is applicable  and   b  and   c  ensure that a
undoes as effects  as an example  all actions in the illustrative task from figure   are
invertible  for example  an a   move l  l    action is inverted by a   move l    l   to see that 
simply insert the definitions  add a     at v  l     is inconsistent with pre a     at v  l   
del a     at v  l     pre a   pre a     at v  l       add a   add a     at v  l     del a  
del a     at v  l       add a   similarly easily  one sees that load o  l  and unload o  l 
invert each other  examples of benchmark domains with invertible actions are blocksworld
 in both variants   logistics  and gripper 
lemma    koehler   hoffmann        given a strips planning task  a  i  g   if all
actions a  a are invertible  then the state space of the task is undirected 
proof  for any state s and applicable action a  a is applicable in result s  hai  due to
condition   a  of invertibility  conditions     and     make sure that as effects do in fact
appear  condition     requires that each fact in the add list is inconsistent with at least one
fact in the precondition   and conditions   b  and   c  make sure that a undoes exactly
those effects 
 
we remark that  in contrast to what one may think at first sight  a task can have an
undirected state space even if some actions are not invertible in the above sense  imagine 
for example  an action a where del a     p  and pre a     p     and  due to the domain
semantics  if p  is true then p is also true  this means that as delete effect always appears 
however  this can not be detected with the simple syntax check  del a   pre a   used in
the definition above 
we next provide a new criterion that is weaker  more broadly applicable  than
lemma    and that only implies the non existence of dead ends  the criterion is based
on a weaker version of invertibility  and on two alternative properties whose combination
can make an action safe 
to make an action a not lead into a dead end  it is already sufficient if the inverse action
re achieves at least what has been deleted  and does not delete any facts that have been true
    it may seem more natural to define inconsistency between fact sets in a symmetrical fashion  demanding
that every fact in f be inconsistent with every fact in f     in our context here  that definition would be
stronger than what we need 

   

fihoffmann

before  that is  given a state s in which a is applicable  applying a in result s  hai  leads
us back to a state s  that satisfies s   s  formally  an action a  a is at least invertible if
there is an action a  a such that 
    pre a    pre a   add a     del a  
    add a   del a   and
    del a  is inconsistent with pre a  
condition     here ensures  as before  that a is applicable in result s  hai   condition
    ensures that a re achieves every fact that was deleted by a  condition     ensures
that the facts deleted by a were not true in s anyway  note that any invertible action is
also at least invertible  conditions     and     are obviously given  as for condition     
if del a    add a   condition   c  of invertibility   and add a  is inconsistent with pre a 
 condition     of invertibility   then del a  is inconsistent with pre a   so invertible is
stronger than at least invertible  we chose the name at least for the latter to illustrate
that  with this definition of invertibility  a potentially re achieves more facts than we had
in the original state s 
as an example  consider what happens if we modify the move l  l    action in figure   to
include a visited l    fact in its add list  the resulting action is no longer invertible because
move l    l  does not delete visited l     if we apply  in state s  move l  l    and move l    l 
in sequence  then now that gets us to a state s  that is identical to s except that it also
includes visited l  and visited l     which may not have been true before  move actions of
this kind form the simple tsp domain  they are at least invertible in the above sense 
pre move l    l      at v  l       add move l  l      add move l    l      at v  l   visited l   
 at v  l     del move l  l      del move l  l        at v  l     is inconsistent with  at v  l    
pre move l  l     
another property implying that an action can not lead into dead ends is this  if the
action must be applied at most once  because its add effects will remain true   and it deletes
nothing but its own preconditions  then that action needs not be inverted  formally  an
action a  a has static add effects if 
 

add a  

del a       

a  a

an action a  a has relevant delete effects  if 
del a    g 

 

pre a         

a  a  a

s

if del a   g a  a  a pre a         then we say that a has no relevant delete effects  which
is the property we will actually be interested in  in the illustrative task from figure   
imagine we disallow unloading an object at its initial location  and loading an object at
its goal location  then the remaining unload actions  unload o    l    and unload o    l    
have static add effects  no action can delete the goal position of an object  and no relevant
delete effects  the only action that needs an object to be in the vehicle is the respective
unload at the goal location  actions that have such characteristics are  for example  the
   

fiwhere ignoring delete lists works

actions that make passengers get out of the lift in miconic strips  a passenger can get
into the lift only at his her origin floor  and get out of the lift only at his her destination
floor   another example is contained in the tireworld domain  where there is an action
that inflates a flat wheel  there is no de flating action and so the add effects are static 
no action nor the goal needs a wheel to be flat so there are no relevant delete effects 
lemma   given a solvable strips planning task  a  i  g   if it holds for all actions
a  a that either
   a is at least invertible  or
   a has static add effects and no relevant delete effects 
then the state space of the task is harmless 
proof  in short  to any reachable state s   result i  ha            an i  a plan can be constructed
by inverting ha            an i  applying the respective inverse actions in the inverse order   and
executing an arbitrary plan for  a  i  g  thereafter  in these processes  actions that are not
 at least  invertible can be skipped because by prerequisite they have static add effects and
no relevant delete effects 
in more detail  the proof argument proceeds as follows  to any reachable state s  
result i  ha            an i   s  we identify a solution p for  a  s  g   let hp            pm i  a be
a solution for  a  i  g   which exists as  a  i  g  is solvable by prerequisite   we construct
p with the algorithm shown in figure   
m    
for i    n         do
if ai is at least invertible by ai then
if ai   m apply ai endif
else m    m   ai  
endif
endfor
for i            m do
if pi   m then apply pi endif
endfor
figure    constructing plans in tasks where all actions are either at least invertible  or have
static add effects and no relevant delete effects 
in the algorithm  m serves as a kind of memory set for the actions that could not be
inverted  we need to prove that the preconditions of all applied actions are fulfilled in the
state where they are applied  and that the goals are true upon termination  let us start
with the first loop  we denote by si    result i  ha            ai i  the state after executing the
   

fihoffmann

ith action on the path to s  and by s i the state before the first loop starts with value i  we
prove 
 
 
s i   si   g 
add a 
pre a    
ami

aa mi

mi here denotes the current state of the set  we proceed by backward induction over i 
if i   n  we got s i   si and mi     so the equation is trivially true  now assume the
equation is true for i     we prove that the equation holds for i     if ai is not at least
invertible  then no action is applied  s i    s i   and mi    mi   ai    concerning the
left hand side of the expression on the right hand side of the equation  we observe that ai
s
does by prerequisite not delete any fact from g  aa mi  pre a   mi  contains ai    so
all relevant facts from si  have already been true in s i   concerning the right hand side
of the expression on the right  we observe that the facts in add ai   are never deleted by
s
prerequisite  so ami  add a  is contained in s i   now assume that ai is at least invertible
by ai   we got mi    mi   assume ai is applied  i e   ai   mi   it is applicable because its
preconditions are contained in si   and it is not an element of mi   for the resulting state
s i    all facts that ai has deleted from si  are added  and only facts are deleted that have
not been true in si  anyway  also  none of the add effects of actions in mi is deleted  so the
equation is fulfilled  finally  if ai is not applied  ai  mi   then ai has static add effects and
was applied before  so its add effects are contained in s i   and ai s delete effects are empty 
inserting i     in the equation we have just proved  we get
s    i   g 

 

pre a    

aa m 

 

add a 

am 

the second loop starts from s    so we start a solution plan  excluding the actions in a
set m    from a state including all initial facts that are contained in the goal or in the
precondition of any action not in m    as the state additionally contains all add effects of
all actions in m    and those add effects are not deleted by any action  it is clear that we
can simply skip the actions in m  and achieve the goal 
 
as an example to illustrate the proof  consider a reachable state in the tireworld domain 
every action is invertible  except the action that inflates a wheel  say  as in the proof  we
are in a state s reached by the action sequence ha            an i  what the algorithm in figure  
will do is  undo everything we have done  by applying the respective ai actions  except for
the inflating actions ai   the latter will be stored in the set m   this gets us to a state
that is identical to the initial state  except that we have already inflated some of the flat
wheels  those corresponding to the actions in m    from that state  the algorithm executes
an arbitrary solution  skipping the previously applied inflating actions  in m   
    local minima
we define an important kind of relationship between the role of an action in the real task
and its role in the relaxed task  combining this definition with the notions of at least
invertible actions  and  no  relevant delete effects  yields a criterion that is sufficient for the
non existence of local minima under h   or  equivalently  for   being an upper bound on
the maximal local minimum exit distance   the criterion can be directly applied in   of the
   

fiwhere ignoring delete lists works

   investigated domains  and can be applied with slight modifications in   more domains 
many of the more individual proofs make use of similar  albeit somewhat more complicated 
proof arguments 
the key property behind the lack of local minima under h  is  most of the time  that
every action that is good for solving the real task is also good for solving the relaxed task 
formally  an action a  a is respected by the relaxation if 
for any reachable state s  s such that a starts an optimal plan for  a  s  g   there is an
optimal relaxed plan for  a  s  g  that contains a 
note that one can assume the relaxed plan to start with a  since in the relaxation it can
only be better to apply an action earlier 
all actions in the illustrative task from figure   are respected by the relaxation  consider the move l  l    actions  for example  if  in a state s  an optimal plan starts with
move l  l     then there must be a good reason for this  either a  at l  there is an object that
has yet to be transported  or b  an object is in the truck that must be transported to l    in
both cases  any relaxed plan must also transport the object  and there is no chance of doing
so without moving to l  at some point  similarly  if an optimal plan starts with a load o  l 
action  then this means that o must be transported somewhere else  and the relaxed plan
does not get around loading it  finally  if an optimal plan starts with an unload o  l  action 
then this means that l is the goal location of o  and any relaxed plan will have to include
that action 
similar arguments as the above can be applied in many transportation domains  the
argument regarding move actions becomes a little more complicated if there are non trivial
road maps  unlike in the illustrative example where there are only two locations that are
reachable in a single step from each other  say the road map is a  any  directed graph 
and we modify the move action from figure   only in that we add a precondition fact
demanding the existence of an edge from l to l    then all move actions are still respected by
the relaxation  because ignoring delete lists does not affect the shape of the road map  any
optimal real path from a location l to a location l  coincides with an optimal relaxed path
of movements from l to l   even though the result of executing the path will be different  
from there  the claim follows with the same argument as above  namely  that an optimal
plans moves from l to l  only if some object provides a reason for doing so 
if a transportation domain features additional constraints on  or side effects of  the move
actions  then they may not be respected by the relaxation  we give an example below  after
formulating our main lemma regarding local minima under h   
note that there can exist local minima even if all actions are respected by the relaxation 
consider the following transportation task  featuring single directional edges in the road
map graph  as argued above  all actions are respected by the relaxation  a vehicle and
two objects o    o  are initially at l  o  must go to l  and o  must go to l    the edge from l
to l  is single directed and the edge from l to l  is single directed  between l  and l    there
is a path of n bi directional  undirected  edges  the optimal relaxed plan for the state s
where  from the initial state  o  and o  were loaded  has length    move from l to l  and l   
and unload o  and o  at l  and l    respectively  however  once one moved  in s  to either l 
or l    the optimal relaxed plan length goes up to n      since the entire path between l  an
   

fihoffmann

l  must be traversed  so s lies on a local minimum  given that n      note that  by setting
n to arbitrarily high values  we get a local minimum with arbitrarily large exit distance 
it turns out that preventing the above example  precisely  making use of the notions of
invertibility and of relevant delete effects  as introduced above  suffices to get rid of local
minima under h   
lemma   given a solvable strips task  a  i  g   such that the state space  s  t   does
not contain unrecognized dead ends  if each action a  a
   is respected by the relaxation  and
   is at least invertible or has no relevant delete effects 
then there are no local minima in  s  t   under evaluation with h   
proof  the states with gd s     are not on local minima by prerequisite  with h   s     
we will prove that  in every reachable state s with     gd s       if an action a starts
an optimal plan for  a  s  g   then h   result s  hai    h   s   this proves the lemma 
iterating the argument  we obtain a path from s to a goal state s    where the value of h 
does not increase on the path  this means that from s an exit is reachable on a flat path 
h s          h s  so at some point on the path the h  value becomes lower than h s   thus
s can not lie on a local minimum 
let s be a reachable state with     gd s       let a be an action that starts an
optimal plan for  a  s  g   we denote s     result s  hai   the action is respected by the
relaxation  so there is an optimal relaxed plan p    s  for  a  s  g  that starts with a 
case  a   removing a from p    s  yields a relaxed plan for  a  s    g   then h   s     
 
h  s  follows  and we are finished  this is the case  in particular  if a has no relevant delete
effects  the facts that a deletes are not needed by any other action nor by the goal  so p    s 
without a achieves the goal starting from s   where a has already been applied  
case  b   assume removing a from p    s  does not yield a relaxed plan for s    then 
with what was said before  a does have relevant delete effects  and must thus be at least
invertible  that is  there is an action a  a with pre a    pre a   add a     del a  and
add a   del a   the action a is guaranteed to be applicable in s    and it re achieves as
delete effects  denote by p    s    the action sequence that results from replacing  in p    s  
a with a  then p    s    is a relaxed plan for  a  s    g   this can be seen as follows  observe
that  by definition  p    s  without a is a relaxed plan for result s  ha  i   we abbreviate
the notation somewhat to improve readability   the desired property now follows because
result s    ha  i  is a superset of result s  ha  i   we have result s  ha  i    s  add a  
s     s  add a     del a   and add a   del a   so p    s    is a relaxed plan for  a  s    g  
yielding h   s     h   s  
 
the proof to lemma   demonstrates along which lines  typically  the proof arguments
in this investigation proceed  given a state s  consider an action a that starts an optimal
plan for s  and consider an optimal relaxed plan p   for s  that contains a  ideally   then 
determine how p   can be modified to obtain a relaxed plan for the state that results from
as execution  this technique forms the basis of literally all proofs except those concerned
with dead ends  note that the second prerequisite of lemma   is fulfilled by planning
   

fiwhere ignoring delete lists works

tasks qualifying for the undirectedness or harmlessness criteria given by lemmas   and   
note also that  with what was said above  we have now proved that the state space of the
illustrative example in figure   is undirected  and does not contain any local minima under
h   
domains where all actions are respected by the relaxation are  for example  the strips
transportation domains logistics  gripper  ferry  and miconic strips  in all these cases 
the respective proof arguments are very similar to what we said above  it is instructive
to have a look at some examples where an action is not respected by the relaxation  in a
transportation domain  this can  for example  happen due to fuel usage as a side effect
of moving  concretely  in the mystery domain  applying a move action deletes a fuel unit
at the start location  the location in that the move starts   if fuel is running low at some
locations  a  real  plan may have to move along fuel rich deviations in the road map  a
relaxed plan does not need to do that  it can always move along the shortest connections
on the map  because  there  the actions do not delete the fuel units 
formulated somewhat more generally  relaxed plans can take short cuts that dont
work in reality  if these short cuts are disjoint  in the starting actions  with the real solution
paths  then local minima may arise even if all actions are  at least  invertible  in the above
discussed transportation case  the short cuts correspond in a very intuitive manner to what
one tends to think about as short cuts  on a road map  namely   this is not the case in
general  i e   in other kinds of domains  consider the blocksworld arm state depicted in
figure   

c
b

c

a

b

figure    a local minimum state in blocksworld arm  the goal is to have b on the table 
and c on b 

in the depicted state  denoted s  b is on a is on the table  and the arm holds c  the
goal is to have b on the table  and c on b    the only optimal plan for s is to put c down
on the table  then unstack b from a and put it down on the table  then pickup c and stack
it onto b  the only optimal relaxed plan for s  however  is to stack c onto b immediately 
then unstack b from a  then put b down to the table  the short cut here is that the
relaxed plan does not have to put c down on the table  because stacking c onto b does
not delete the fact that declares bs surface as unoccupied  as a result  s lies on a local
    usually  in blocksworld there are no goals demanding a block to be on the table  in the example  this is
done only for the sake of simplicity  one could just introduce one more block d and demand that b be
on d for the goal 

   

fihoffmann

minimum under h      the reason  intuitively  why h  does not yield any local minima in
many domains  is that vicious short cuts like in this example just dont happen 
    benches
we could not find a nice general sufficient criterion implying upper bounds on the maximal
exit distance from local minima  except the special case above where there are no local
minima at all and thus   is an upper bound on the maximal local minimum exit distance 
we did  however  find a simple proof argument determining an upper bound on the maximal
exit distance from benches  in tasks that qualify for the application of lemma    the proof
argument works  sometimes with slight modifications  in all the   domains where lemma  
can be directly applied  in all these domains  the maximal bench exit distance is bounded
by    bounded by    in one case  
the proof argument is based on observing that  in many domains  some of the actions
have only delete effects that are irrelevant  for the relaxed plan  at least  once the action was
applied on an optimal solution path  formally  an action a  a has relaxed plan relevant
delete effects if 
for any reachable state s  s such that a starts an optimal plan for  a  s  g   there is no
s
optimal relaxed plan ha  a            an i for  a  s  g  such that del a    g  ni   pre ai       
if  for any reachable state s  s such that a starts an optimal plan for  a  s  g   there is an
s
optimal relaxed plan ha  a            an i for  a  s  g  such that del a    g  ni   pre ai       
then we say that a has no relaxed plan relevant delete effects  which is the property we will
actually be interested in  with this notation  if a has no relaxed plan relevant delete effects 
and it starts an optimal plan for s  then a relaxed plan for result s  hai  can be constructed
as the sequence ha            an i  i e   by skipping a from the relaxed plan for s  thus the h 
value decreases from s to result s  hai   note that n can be set to   if a results in a goal
state from s  note also that  by definition  any action with no relaxed plan relevant delete
effects is respected by the relaxation  if an action is not respected by the relaxation  then
we can not claim anything about h  anyway  note finally that  assuming an action a that
is respected by the relaxation  if a has no relevant delete effects  i e   if a does not delete a
goal or any precondition of another action  then a also has no relaxed plan relevant delete
effects in the sense of our definition 
consider again our illustrative example from figure    say we have a state s in which
load o  l  starts an optimal plan  this means that o has yet to be transported  to a location
l     l  in particular  it means that at o  l  is not a goal  and it follows that the action
 whose only delete effect is at o  l   has no relevant delete effects  no other action has
at o  l  in its precondition   further  say unload o  l  starts an optimal plan in s  this
means that l is the goal location of o  after applying the action  the goal for o will be
achieved  and no action will need to refer to o again  in particular no action will require o to
be inside the vehicle  which is the only delete effect of unload o  l   so that action neither
    we have h   s       the h  value after  in s  putting c down to the table is    any relaxed plan has to
apply two actions for each of the two goals   the h  value after stacking  in s  c onto b is still    the
relaxed plan is unstack c b  unstack b a  put down b   but from there the only successor state is to
unstack c from b again  going back to s 

   

fiwhere ignoring delete lists works

has relaxed plan relevant delete effects  in contrast  consider the move l  l    action  that
deletes at v  l   say we are in the state s where o  has been loaded into v from the initial
state of the task  then move l    l    starts an optimal plan for s  and any relaxed plan
for result s  hmove l    l   i  has to include the action move l    l     moving back from l 
to l  in order to be able to transport o    so the delete effect of move l    l     namely
at v  l     is relaxed plan relevant 
if  in a task satisfying the prerequisites of lemma    an optimal starting action has no
relaxed plan relevant delete effects  then one can apply case  a  in the proof of lemma   
and obtain a smaller h  value  to bound the maximal exit distance from benches  all we
need to do is to identify a maximum number of steps after which that will happen 
lemma   given a solvable strips task  a  i  g  that satisfies the prerequisites of
lemma    let d be a constant so that  for every non dead end state s  s  there is an
optimal plan ha            an i where the d th action  ad   has no relaxed plan relevant delete effects  then mbed s  t    d    
proof  let s be a reachable state with     gd s       let ha            an i be an optimal plan
for  a  s  g   where ad has no relaxed plan relevant delete effects  denote  for    i  n 
si    result s  ha            ai i   with the argumentation in lemma    we have h   si    h   s 
for all i  consider the state sd    by prerequisite  there is an optimal relaxed plan for
s
 
 a  sd    g  that has the form had   a             a m i  where del ad     g  m
i   pre ai        but
 
 
 
 
then  obviously  ha            am i is a relaxed plan for sd   and so h  sd    h  sd        the
distance from s to sd  is d     and so the lemma follows 
 
lemma   can be directly applied in   of the   domains that qualify for lemma    its
proof argument can  in a somewhat more general version  be applied in the   other domains
as well  namely  in ferry and gripper  where loading an object deletes space in the vehicle 
and in one more domain  namely  miconic simple  that uses some simple adl constructs 
in the other domains where we proved an upper bound on the maximal exit distance from
benches  and or an upper bound on the maximal exit distance from local minima   the
proof arguments are  a lot  sometimes  more complicated  reconsidering the illustrative
example  as stated above the load and unload actions have no relaxed plan relevant delete
effects  while the move actions do  now  obviously  since the two locations are accessible
from each other with a single move  no optimal plan applies more than one move action
in a row  i e   in any optimal plan the first or second action will be a load unload  with
lemma   this tells us that the maximal exit distance from benches is bounded by    a very
similar argument can be applied in all other transportation domains where every pair of
locations is connected via a single move  as in  for example  logistics   more generally  in
 the standard encoding of  a transportation domain with no other constraints  regarding 
for example  fuel   and with an undirected road map graph  the exit distance is bounded
by the diameter of the road map graph  i e   by the maximum distance of any two locations
 nodes  in the graph  the worst thing a solution plan might have to do is to traverse the
entire road map before loading unloading an object   
    with directed road map graphs  as explained above  local minima can arise  more technically  lemma  
can not be applied  and so lemma   can not be applied either 

   

fihoffmann

   a planning domain taxonomy
we now list our proved results  with brief explanations of how we obtained these results 
we then summarize the results in the form of a planning domain taxonomy 
we group the positive results  those which prove the non existence of topological
phenomena that are problematic for heuristic search  together in single theorems  the
negative results are shown separately by sketching counter examples  we consider dead
ends  local minima  and benches in that order  remember that  with respect to dead ends 
the only problematic case for heuristic search is when there are unrecognized dead ends  c f 
section     
theorem   the state space of any solvable instance of
   blocksworld arm  blocksworld no arm  briefcaseworld  depots  driverlog  ferry 
fridge  gripper  hanoi  or logistics is undirected 
   grid  miconic simple  miconic strips  movie  pipesworld  psr  satellite 
simple tsp  tireworld  or zenotravel is harmless 
   dining philosophers  optical telegraph  rovers  or schedule is recognized under evaluation with h   
in blocksworld arm  blocksworld no arm  driverlog  ferry  gripper  hanoi  and logistics  lemma   can be directly applied  in briefcaseworld  depots  and fridge  due to some
subtleties the actions are not invertible in the syntactical sense  but it is easy to show
that every action has an inverse counterpart  in movie  miconic strips  simple tsp  and
tireworld  lemma   can be directly applied  in grid and miconic simple similar proof
arguments as used in lemma   suffice  in pipesworld  psr  satellite  and zenotravel  some
easy to see more individual domain properties prove the absence of dead ends  in the domains where all dead ends are recognized by h    the individual domain properties exploited
in the proofs are somewhat more involved  for example  in rovers there is a plan to a state
if and only if  for all soil rock samples and images that need to be taken  there is a rover
that can do the job  and that can communicate the gathered data to a lander  the only
chance to run into a dead end is to take a soil rock sample with a rover that can not reach
a lander  the soil rock sample is available only once   but then  there is no relaxed plan to
the state either 
in the   domains not mentioned in theorem    airport  assembly  freecell  miconicadl  mprime  mystery   it is easy to construct arbitrarily deep unrecognized dead ends
 arbitrarily long paths of unrecognized dead ends   for example  in mystery and mprime
the relaxed plan can still achieve the goal in situations where too much fuel was consumed
already  in airport  two planes that block each others paths may move across each other
in the relaxed plan 
the positive results regarding local minima are these 
theorem   under h    the maximal local minimum exit distance in the state space of any
solvable instance of
   

fiwhere ignoring delete lists works

   blocksworld no arm  briefcaseworld  ferry  fridge  grid  gripper  hanoi  logistics 
miconic simple  miconic strips  movie  simple tsp  or tireworld is   
   zenotravel is at most    satellite is at most    schedule is at most    diningphilosophers is at most    
in ferry  gripper  logistics  miconic strips  movie  simple tsp  and tireworld 
lemma   can be applied  in fridge and miconic simple  the actions do not adhere syntactically to the definitions of invertibility and  no  relevant delete effects  but have similar
semantics  so lemma   can not be directly applied  but similar arguments suffice  it is easy
to see that all actions are respected by the relaxation  and the proof of lemma   can be individually adapted to take into account the particular properties regarding invertibility and
relevant delete effects   for example  if a passenger gets out of the lift in miconic simple 
then the delete effect is that the passenger is no longer inside the lift  which does not matter
since the passenger has reached her destination   in blocksworld no arm  briefcaseworld 
and grid  rather individual  and sometimes quite involved  arguments prove the absence
of local minima under h    the proof method is  in all cases  to consider some state s and
identify a flat path from s to a state with better h  value  for example  in grid this is done
by moving along a path of locations contained in the relaxed plan for s  until a key can
be picked up put down  or a lock can be opened  this is a very simplified description  the
actual procedure is quite complicated   in hanoi  one can prove that the optimal relaxed
solution length for any state is equal to the number of discs that are not yet in their final
goal position  this suffices because no optimal plan moves a disc away from its final position  note that  thus  the hanoi state spaces under h  are a sequence of benches decreasing
exponentially in diameter and size 
in zenotravel  satellite  and schedule  the proofs proceed by identifying a constant
number of steps that suffices to execute one action a in the optimal relaxed plan for a state
s  and  without deleting as relevant add effects  to re achieve all relevant facts that were
deleted by a  in dining philosophers  as well as optical telegraph   due to the subtleties of
the pddl encoding  which was  as said  obtained by an automatic compilation from the
automata based promela language  edelkamp      a   h  is only very loosely connected
to goal distance  in the relaxation  an automaton  for example  a philosopher  can always
block itself with at most   actions  the bound for dining philosophers follows from
the rather constant and restrictive domain structure  where a constant number of process
transitions  namely    always suffices to block one more philosopher  the proved bound
is derived from this  by considering that   planning actions are needed for each process
transition  and that certain additional actions may be needed due to the subtleties of the
pddl encoding  where a process can be in between two of its internal states   we remark
that the bound is valid even for the trivial heuristic function returning the number of yet
un blocked philosophers  in fact  the proof for h  can be viewed as a corollary of a proof for
this heuristic function  we get back to this at the end of this section  we finally remark that
the highest exit distance under h  that we could actually construct in dining philosophers
was     we conjecture that this is a  tight  upper bound 
in satellite  schedule  and zenotravel  the proved upper bounds are tight  in all of
dining philosophers  satellite  schedule  and zenotravel  the bounds are valid for any nondead end state s  so  beside a bound on the local minimum exit distance  these results
   

fihoffmann

also provide a bound on the bench exit distance  and will be re used for that below in this
section 
in airport  assembly  freecell  miconic adl  mprime  and mystery  as stated above
there can be unrecognized dead ends  so by proposition   the local minimum exit distance
in these domains is unbounded  in all other domains not mentioned in theorem    i e   in
blocksworld arm  depots  driverlog  optical telegraph  pipesworld  psr  and rovers  one
can construct local minima with arbitrarily large exit distances  the most complicated
example is optical telegraph  where  in difference to dining philosophers  one can construct
situations where the number of process state transitions needed to block one more process is
arbitrarily high  optical telegraph is basically a version of dining philosophers with more
complicated philosophers  that have more freedom of what to do next  this freedom enables
situations where a whole row of philosophers at the table must perform two transitions each
in order to block one more philosopher  details are in appendix a    a simpler example is
blocksworld arm  as well as depots  in which blocksworld arm situations can be embedded  
consider the following situation  there are n blocks b            bn that initially form a stack
where bi is on bi   and bn is on the table  the goal is to build the same stack on top of
another block bn     i e   the goal is a stack b            bn   bn     reaching  from the initial state 
a state with better h  value involves disassembling the entire stack b            bn   during the
disassembling process  h  increases  note that this is basically an extended version of the
illustrative example from figure   
as an interesting side remark  note that we have now proved a topological difference
between blocksworld arm and blocksworld no arm  in the latter  there are no local minima
at all under h    in the former  the exit distance from them can be arbitrarily large  while
this is intriguing  it is not quite clear if there is a general message to learn from it  one might
interpret it as telling us  in a formal way  that encoding details can have a significant impact
on topology  and with that on search performance  ff  for example  is much more efficient
in blocksworld no arm than in blocksworld arm  it should be noted  however  that the two
domains differ also semantically  namely in that plans in blocksworld no arm are half as
long as plans in blocksworld arm  from a practical point of view  it would be interesting
to explore if this blocksworld observation can be generalized into encoding methods trying
to model a domain in a way making it best suited for h    some more on this is said in
section   
the positive results regarding benches are these 
theorem   under h    the maximal bench exit distance in the state space of any solvable
instance of simple tsp is    ferry is at most    gripper is at most    logistics is at most
   miconic simple is at most    miconic strips is at most    movie is at most   
zenotravel is at most    satellite is at most    schedule is at most    tireworld is at most
   and dining philosophers is at most    
in simple tsp  ferry  gripper  logistics  miconic strips  movie  and tireworld 
lemma   can be directly applied  determining what actions have  no  relaxed plan relevant delete effects is easy in all the domains  in tireworld it is somewhat complicated to
see when  at the latest  such an action can be applied in an optimal plan  for miconicsimple  similar arguments as in lemma   suffice  for zenotravel  satellite  schedule  and
dining philosophers  the respective bounds were shown above already 
   

fiwhere ignoring delete lists works

note that  in simple tsp  we proved that there are no local minima and that the exit
distance is    this implies that h  is  in fact  identical to the real goal distance  the entire
state space consists of contours and global minima 
our topological distinctions divide planning domains into a taxonomy of classes which
differ in terms of the behavior of their state spaces with respect to h    a visualization of
the taxonomy  with the results for the    investigated domains  is given in figure   

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed    c

mlmed    c

hanoi    
blocksworldnoarm    
fridge    
grid    
briefcaseworld    

logistics      
ferry      
gripper      
undirected

tireworld      
satellite      
zenotravel      
miconicsimple      
miconicstrips      
movie      
simpletsp      
harmless

diningphil         
schedule      

recognized

unrecognized

figure    a planning domain taxonomy  overviewing our results 
the taxonomy  as shown in figure    has two dimensions  the x axis corresponds to the
four dead end classes  the y axis corresponds to the existence or non existence of constant
upper bounds on the local minimum exit distance  and on the bench exit distance  note
that this visualization makes the simplifying assumption that the domains with bounded
bench exit distance are a subset of the ones with bounded local minimum exit distance  this
assumption is not justified in general  but holds true in our specific collection of domains 
also  the question whether there is a bound on the difficulty of escaping benches does not
seem as relevant when  anyway  it can be arbitrarily difficult to escape local minima    the
specific bounds proved for the individual domains are given in parentheses  local minimum
exit distance bound preceding bench exit distance bound in the cases where there are both 
the bottom right corner of the taxonomy is crossed out because no domain can belong to
the respective classes   
    similarly  when benches can be arbitrarily large it is not as relevant if or if not the local minima are
small or non existent  in that sense the respective results for briefcaseworld  fridge  grid  blocksworldno arm  and hanoi are only moderately important  still they constitute interesting properties of these
domains 
    by proposition    the existence of unrecognized dead ends implies the non existence of constant upper
bounds on the local minimum exit distance  given there are no states with gd s       but h   s       such
states can exist  but only if the domain features derived predicates that appear negated in the negation

   

fihoffmann

what figure   suggests is that h   approximating heuristic planners are fast because
many of the common benchmark domains lie in the easy regions of the taxonomy  more
concretely  as described in the introduction  when provided with the h  function  ffs
search algorithm enforced hill climbing is polynomial in the domains located in the lowermost classes of the taxonomy  i e   in domains with constant bounds on both maximal
exit distances   from a more empirical perspective  the distinction lines in the taxonomy
coincide quite well with the practical performance of ff  ff excels in    of the    domains
that belong to the lowermost classes of the taxonomy  the more difficult domain is diningphilosophers  whose upper bound is exceptionally high   in the   middle domains  no
local minima but potentially large benches  ff performs well  but does not scale up as
comfortably as in the easier domains  as for the more complex domains  blocksworld arm 
depots  driverlog  optical telegraph  pipesworld  and psr are amongst the most challenging domains for ff  in mprime and mystery  ff performs just as bad as most other
planners  in freecell and miconic adl  ff is among the top performing planners  but often
runs into unrecognized dead ends in the larger instances  for example  the larger freecell
instances used at aips        in airport  assembly and rovers  ff performs pretty well in
the respective competition example suites  however  in these domains the competition suites
hardly explore the worst cases of the domain topology  details on this are in appendix a  
we do not discuss in detail the relation between the taxonomy and the empirical performance of all the other heuristic planners that make use of an h  approximation in one
or the other way  one observation that can definitely be made is that all these planners
have no trouble in solving instances from the domains with the most extreme h  properties 
in simple tsp  ferry  gripper  logistics  miconic simple  miconic strips  and movie 
to some extent also zenotravel  all such planners scale up very comfortably  in particular 
they scale up much more comfortably in these domains than they typically do in the other
domains  at least without additional  for example  goal ordering  techniques 
in the next section  we treat the connection between the taxonomy and ffs performance
in a more analytical way  by relating the properties of h  to properties of ffs approximation
of h    called hf f   before we do so  some remarks on the relation of the taxonomy to
complexity theory are in order  the question is whether there is a provable relation  i e   a
relation between the distinction lines in the taxonomy  and the complexity of deciding
plan existence in the respective domains  we were able to construct an np hard domain
 a domain where deciding plan existence is np hard  where h  does not yield any local
minima  the maximal bench exit distance in that domain is  however  unbounded  we tried 
but we were not able to come up with an np hard domain that has constant bounds on
both maximal exit distances  it remains an open question whether such a domain exists
or not  if the answer is yes  then the lowermost classes of the taxonomy form a group
of domains that are worst case hard  but typically very easy to solve  at least as far as

normal form of the goal condition  but even then  in the presence of unrecognized dead ends there
would be fake global minima  i e   global minima consisting of non solution states  in fact consisting
of unrecognized dead ends 

   

fiwhere ignoring delete lists works

reflected by the hitherto benchmarks   if the answer is no  then we have identified a very
large polynomial sub class of planning   
talking about polynomial sub classes  an intriguing observation can be made here about
the trivial heuristic function returning  for a state s  the number of goals that are not true
in s  lets call this function hg   with a little thinking  one realizes that  in fact  all the
   domains where we proved constant bounds on both maximal exit distances under h  also
have such constant bounds under hg   on the other hand  for the remaining    of the   
domains  except miconic adl  it is easy to see that there are no constant bounds for hg  
in logistics  for example  clearly the maximum number of steps needed to achieve one
more goal is       steps each  move  load  move  unload  within a packages origin city 
between the origin city and the destination city  and within the destination city  in diningphilosophers  for example  the upper bound for h  was  as said  proved as a corollary of
an upper bound for hg   in blocksworld  for example  clearly it can take arbitrarily many
steps to achieve one more goal  namely if a block that must be moved is buried beneath n
other blocks that do not need to be moved 
while the above observation appears rather significant at first sight  it is probably not
very important  neither in theory nor in practice  for one thing  it is a coincidence that 
here  the set of domains with both constant bounds under h  is the same as the set of
domains with both constant bounds under hg   a simple counter example for the general
case is a graph search domain  where the task is to find a path between two nodes in a
directed graph  using the obvious at predicate and connected predicate based encoding 
there  h  is equal to the real goal distance  since one never needs to move back   while
hg can  clearly  be arbitrarily bad  for another thing  while domains like logistics have
constant exit distance bounds under hg   these bounds are too large to be practically useful 
for example  with h    ff needs to look at most   steps forward in each breadth first
search iteration of enforced hill climbing  in any logistics instance  with hg   breadth first
searches up to depth    would be needed  so  at most  the observation regarding hg is a
noteworthy statement about the current planning benchmarks  it remains an open question
whether the  coincidental  correspondence between the bounds for h    and for hg   in the
investigated    domains  can be exploited for  e g   detecting such bounds automatically 

   relating h  to hf f
our discussion relating h  to hf f is structured in two separate sections  the first one
briefly discusses provable relations between h  and hf f   the second section summarizes
the results of a large scale empirical investigation aimed at identifying to what extent the
topological properties of h    in the benchmarks  get preserved by hf f  
    provable relations between h  and hf f
one thing that is very easy to observe is that the behavior of h  and hf f is provably the
same with respect to dead ends  i e   both heuristics return  in the same cases  this
is simply because both heuristics return  in a state s iff there is no relaxed plan for s 
    presumably  to prove the latter  one would need to characterize that class in a purely syntactic manner
on the level of pddl definitions  since h  is derived directly from the pddl syntax  the authors wild
guess it that this is not going to work  and that the answer is yes 

   

fihoffmann

for h  this follows by definition  for hf f it follows from the completeness  relative to the
relaxation  of the algorithm that computes relaxed plans  hoffmann   nebel      a   that
algorithm is a relaxed version of graphplan  blum   furst               in each state s 
ff runs graphplan on the task where s is the initial state  and the delete lists of all actions
are empty  without delete lists  graphplan is guaranteed to terminate in polynomial time 
if graphplan terminates unsuccessfully  then hf f  s  is set to   otherwise  the number of
actions in the returned plan is taken as the heuristic value hf f  s  of the state    graphplan
is a complete algorithm  it terminates successfully if and only if there is a plan  and so
hf f is set to  iff there is no relaxed plan for s  it follows that the dead end classes of the
benchmarks are the same under h  and hf f  
the relaxed plans found by graphplan have  just as in general strips  the property
that they are optimal in terms of the number of parallel time steps  but not in terms of the
number of actions  so  in general  hf f is not the same as h   even if p is the same as np  
ff uses the following heuristic techniques for action choice in relaxed graphplan  aiming
at minimizing the number of selected actions  hoffmann   nebel      a   first  if a fact
can be achieved by a noop  a dummy action propagating a fact from time step t to time
step t     in graphplans planning graph   then that noop is selected  this guarantees
that every non noop action is selected at most once  of course  selected noop actions are
not counted into the relaxed plan   second  if there is no noop available then an action
with minimal precondition weight is chosen  where weight is defined as the summedup indices of the first layers of appearance  in the planning graph  of the precondition
facts  third  actions selected at the same parallel time step are assumed to be linearized
by order of selection  so an action a selected after a  will be assumed to achieve a fact
p  add a   pre a    even if a and a  are selected at the same parallel time step 
there are two very restrictive sub classes of strips in which hf f is provably the same
as h    the first demands that every fact has at most one achiever 
proposition   let  a  i  g  be a strips planning task so that  for all facts p  there is at
most one action a  a with p  add a   then  for all states s in the task  h   s    hf f  s  
proof  the proposition follows from the observation that  when running relaxed graphplan  the only choice points are those for action selection  these choice points will always
be empty or unary in our case  this implies that all actions selected by graphplan are
contained in any relaxed plan  in more detail  the latter can be proved by an induction
over the regression steps in relaxed graphplan  let s be a state for which there is a relaxed
plan  at the top level of the regression  actions a are selected to support all goals that are
not contained in s  these goals need to be supported in any relaxed plan  and there are
no other actions for doing so  the same holds true for the preconditions of the selected
actions  if p  pre a  is not in s  then a supporter must be present in any relaxed plan 
and that supporter will be selected by relaxed graphplan  iterating the argument  we get
the desired property  the claim then follows because  as proved by hoffmann and nebel
     a   relaxed graphplan selects every action at most once 
 
    note that this is an estimate of sequential relaxed plan length  the length of the planning graph built by
graphplan corresponds to the optimal length of a parallel relaxed plan  an admissible heuristic estimate 
however  as indicated before  such heuristic functions have generally not been found to provide useful
search guidance in practice  see  for example  haslum   geffner        bonet   geffner      b  

   

fiwhere ignoring delete lists works

our second sub class of strips demands that there is at most one goal  and at most
one precondition per action 
proposition   let  a  i  g  be a strips planning task so that  g     and  for all a  a 
 pre a       then  for all states s in the task  h   s    hf f  s  
proof  under the given restrictions  relaxed planning comes down to finding paths in the
graph where the nodes are the facts  and an edge is between p and p  iff there is an action
with pre a    p and add a    p   empty preconditions can be modelled by a special fact
node that is assumed to be always true   a state has a relaxed plan iff it makes a fact node
true from which there is a path to the goal node  relaxed graphplan identifies a shortest
such path 
 
the prerequisites of propositions   and   are maximally generous  i e   when relaxing one
of the requirements  one loses the h   s    hf f  s  property  to obtain sub optimal relaxed
plans with graphplan  i e   to construct cases where h   s     hf f  s   it suffices to have one
fact with two achievers  and either two goal facts or one action with two preconditions  the
following is such an example  there are the facts g    g    p  and p    the goal is  g    g     the
current state is empty  the actions are shown in figure   
name
opg 
opg   p
opg   p 
opp
opp 

 
 
 
 
 

 pre 

add 

del 

  p  
  p  
  p    
  
  

 g    
 g    
 g    
 p  
 p    

 
 
 
 
 

figure    actions in an example task where hf f    h   
the optimal relaxed plan here is hopp  opg    opg   pi  however  graphplan might choose
to achieve g  with opg   p    ending up with the  parallel  relaxed plan h opp  opp      opg   
opg   p   i  note that each action has only a single precondition  only a single fact has more
than one achiever  and there are only two goals  a similar example can be constructed for
the case where there is only one goal but one action with two preconditions 
obviously  the syntax allowed by either of propositions   or   is far too restrictive to
be adequate for formulating practical domains    we did not investigate whether there are
any more interesting situations where h  and hf f are the same  our intuition is that this
is not the case 
a different question is whether there are provable relations between h  and hf f in  some
of  the    benchmark domains considered in the h  investigation  we did not investigate
this question in detail  note that such an investigation would involve constructing detailed
    we remark that the syntax identified by proposition   is a sub class of a tractable class of strips
planning identified by bylander         in bylanders class  a constant number g of goal facts is allowed 
where g can be greater than    the preconditions may be positive or negative 

   

fihoffmann

arguments about all the individual domains  which is clearly beyond the scope of this paper 
none of the domains is captured by either of propositions   or    a few results that are
easy to obtain are the following  in simple tsp  movie  and miconic strips  h  and hf f
are the same  this follows from the extremely simple structure of these domains  where
finding step optimal relaxed plans with graphplan always results in relaxed plans with an
optimal number of actions  however  even in the only slightly more complicated domains
ferry  gripper  logistics  miconic simple  and zenotravel  one can easily construct states
where graphplans relaxed plans may be unnecessarily long  in miconic strips this does
not happen because there is only a single vehicle  the lift   with no capacity restrictions
 on the number of loaded objects  i e   passengers   with several vehicles and transportable
objects  as can occur in logistics and zenotravel  as well as driverlog  depots  mprime 
mystery  and rovers   the difference between h  and hf f can become arbitrarily large 
just imagine that n objects must be transported from l to l    and n vehicles are available
at l  for parallel relaxed planning  it makes no difference if a single vehicle transports all
objects  or if one different vehicle is selected per individual object  in particular  even with
ffs action choice heuristics in relaxed graphplan  hf f may be  n     just as well as  n   
in ferry and gripper  where there is only a single vehicle  with capacity restrictions   it
may be that there is an upper bound on the difference between h  and hf f   we did not
check that in detail 
in spite of the above  the authors personal experience from developing ff is that  at
least in relatively simply structured domains with not many different operators different
ways to achieve facts  the relaxed plans found by relaxed graphplan are typically pretty
close to optimal  there are  presumably  the following two reasons for this  first  the
employed action choice heuristics  for example  in the grid domain  a relaxed plan may
choose to pick up a key k with the sole purpose of dropping it again when picking up
another key k  with a pickup and lose action  c f  appendix b      this does not happen
when selecting actions with minimal precondition weight  the pickup and lose action has a
higher weight than the pickup action unless one already holds k in the considered state  
second  many of the published benchmark instance suites are quite restricted  in logistics 
for example  the situation outlined above  n objects and n vehicles waiting at a location l 
can not happen for trucks because there is only a single truck in each city  as for airplanes 
in the published benchmark instances there usually are only few of these  and so n will be
small 
    empirical relations between h  and hf f
in a large scale empirical investigation  hoffmann      b   it turned out that hf f typically
preserves the quality of h    the investigation was aimed at verifying  in those domains
where h  has some positive topological property  for example  yielding no local minima  
to what extent that property is inherited by hf f   we considered    benchmark domains 
namely the same domains as in the paper at hand  except the    ipc   and ipc   domains 
    one could circumvent this particular phenomenon by  when selecting an action in relaxed graphplan 
employing a minimization of the summed up weight of the preconditions of all actions selected so far  it
is a topic for future work to explore if this has any effect on ffs performance 

   

fiwhere ignoring delete lists works

note that  of the latter    domains  only three  namely dining philosophers  satellite  and
zenotravel  have positive topological properties 
the experimental approach was to take samples from state spaces  a technique adapted
from work by frank et al          more precisely  the method was the following  of each
domain  a random generator was used to produce a large set of example instances  the
instances were grouped together according to the values of the domain parameters  i e   the
input parameters to the generator  for example  number of floors and number of passengers
in miconic simple   then  for each single instance      states were sampled  i e      
random sequences of actions were executed in the initial state  where the sequence length
was chosen randomly in the interval between   and   times ffs plan length    of each
resulting state s  the exit distance ed s  was computed by a breadth first search  and another
search determined whether s was located on a valley  i e   whether there was no path from
s to a goal state on which the hf f value decreased monotonically    the maximal exit
distance of an instance was approximated as the maximum over the exit distances of the
sample states  for every group of instances  the mean number of states on valleys  and the
mean maximal exit distance  were computed  the results were visualized by plotting these
values over the scaling domain parameters  we give some examples for this directly below 
after summarizing the overall results 
the results of the experiment strongly suggested that hf f typically preserves the quality
of h    in the considered benchmark domains  of the    domains in which h  provably yields
no local minima  almost no sample states were located on valleys except in   domains 
namely grid and hanoi  more precisely  in the    other domains the experiment considered
a total of     groups of random instances  in one of these groups       of the sample states
lay on valleys  in another group it were       in another eight groups it were below      
and in the remaining     groups not a single valley state was found  as for the maximal
exit distance from benches  of all the tested instances of domains in which there is a bound
under h    only a single sample state had an exit distance larger than that bound  namely
an exit distance of   instead of   in the logistics domain   
blocksworld no arm
gripper
hanoi
tireworld

   
   
   
   

   
   
   
   

   
   
    
   

   
   
     
   

   
   
     
   

figure    percentage of sample states on valleys  mean values for a linear increase of the
respective domain parameter 
figure   provides the results regarding sample states on valleys  in those considered
domains where there are no local minima  and thus no valleys  under h    and where in    we tried a few other sampling strategies and found that they did not make much difference in terms of
the obtained results 
    intuitively  each local minimum lies at the bottom of a valley  we used valleys in the experiment since
it may be hard to find a local minimum state by sampling 
    the authors guess is that the results of a similar empirical investigation in dining philosophers  satellite 
and zenotravel would be similar  i e   that the sampled maximal exit distances would hardly increase
above the upper bounds proved for h   

   

fihoffmann

stances are characterized by a single domain parameter  movie and simple tsp are left out
since there hf f is provably the same as h     in blocksworld no arm  that parameter is
the number of blocks  plus randomization of initial and goal states   in gripper it is the
number of balls to be transported  in hanoi it is the number of discs  in tireworld it is the
number of flat tires  in each domain  from left to right the table entries correspond to a
linear increase in the domain parameter             blocks              balls             discs  and
          tires  respectively   obviously  the only domain that does not behave is hanoi 
where h  isnt a very useful heuristic anyway  yielding very large benches  c f  section   
blocksworld no arm
gripper
hanoi
tireworld

   
   
   
   

   
   
    
   

   
   
    
   

   
   
   
   

   
   
   
   

figure    sampled maximal exit distance  mean values for a linear increase of the respective
domain parameter 
figure   shows the results regarding the sampled maximal exit distance in domains
characterized by a single domain parameter  in gripper and tireworld  the sampled values
respect the bound that is valid for h   in the largest tireworld example  sampling did not
find a maximum state in the rather large state space   by comparison  the sampled values
in blocksworld no arm  where there is no bound for h    show a clear increase  again  the
behavior of hanoi is odd 
figure   shows  part of  the results for a domain that is characterized by more than one
domain parameter  namely logistics  in domains with at least two domain parameters  the
experimental method was to run one experiment for each pair of them  in each experiment 
all parameters except the respective pair was set to some fixed value  the data could then
be visualized in   dimensional plots like the ones in figure    in the figure  the parameters
scaled are the number of cities and the number of objects  packages  to be transported 
the parameter range is           in both cases  city size and number of airplanes are both
fixed to    of each parameter value combination     random instances were generated  and
    states were sampled per instance   no valley states were found  except with   cities
and   objects  where   of the      sample states were located on a valley  with   cities and
  objects  in a single instance one sample state had exit distance    rather than the bound
  valid for h   the single such bound violation found in the entire experiment   
as indicated before  the grid domain was  with hanoi  the only domain for that the
experiment suggested a major difference between the topologies of h  and hf f   large
fractions of the sample states  up to        were located on valleys  there was a clear
tendency of increase of the percentage  both with increasing grid size and with increasing
number of keys to be transported 
all in all  the experiment confirmed that  in all of the blocksworld no arm  briefcaseworld  ferry  fridge  gripper  logistics  miconic simple  and tireworld domains  hf f
    the decrease in the mean sampled maximal exit distance for very large parameter values suggests that
it becomes harder  for sampling  to find the maximum states in the rather large state spaces 

   

fiwhere ignoring delete lists works

z

z

 

 

   

 

 

 
 

 

 
 

 
 

 

 
x

 

 

y
 

y
 

 
 

x

   

 a 

 
 

   

 b 

figure    mean sampled valley percentage  a  and maximal exit distance  b  in logistics 
when scaling cities  x axis  against objects  y axis  
largely preserves the quality of h   no local minima and or a constant bound on the maximal exit distance from benches   remember that miconic strips  movie  and simple tsp
are three more domains where this  provably  applies 

   towards automatically detecting h  phenomena
the lemmas presented in section   provide a natural starting point for investigations into
domain analysis techniques trying to detect the topological phenomena automatically  such
domain analysis techniques would be useful for configuring hybrid systems  i e   for the
automatic selection of heuristic functions that are likely to be well suited for solving a given
planning task  further  such techniques would be useful for avoiding the need to re do
the h  investigation for every single new planning domain  finally  on the basis of such
analysis techniques one may be able to compute good lower bounds on h    and with that an
informative admissible heuristic function  some more discussion of these points is contained
in section   
the question to be addressed is if  to what extent  and how  the application of the
lemmas from section   can be automated  i e   if and how one can automatically check
whether their prerequisites are satisfied in a given strips task  in the section at hand 
we present a preliminary attempt we made to do that  while the attempt was not very
successful  we believe that the investigation has value in showing up what one can achieve
with some simple analysis techniques  and what weak points would be needed to be improved
upon in order to obtain better results 
invertible  or at least invertible  actions  and actions with irrelevant delete static add
effects  are syntactically defined in section   and thus easy to detect  the only difficulty
is to find inconsistencies between facts  while this is as hard as planning itself  there are
several approximation techniques in the literature  for example  blum   furst             
fox   long        gerevini   schubert              rintanen         which tend to work
very well  at least in the current benchmarks  the challenge is to find more syntactical
characterizations of actions that are respected by the relaxation  and of actions that have
   

fihoffmann

no relaxed plan relevant delete effects  now  in many domains where these phenomena
occur  such as for example ferry  gripper  logistics  miconic strips  movie  simple tsp 
and tireworld  intuitively when one looks at the domains the causes of the phenomena
seem similar  but when getting down to the actual syntax of these domain descriptions 
the individual details are very different and it becomes very difficult to get a hold on the
common ground  there does not seem to be a simple syntactical definition that captures
the behavior of the actions in all these domains  at least we did not find such a syntactical
definition  instead  we tried to reason about the additive structure of the domains  and
its possible interactions with the delete effects   the intuition being that  in the domains
with very simple h  topology  the interactions arent very harmful   we captured the
additive structure of a domain of an instance in a data structure called fact generation
trees  the next subsection describes this data structure and its basic properties  then a
subsection gives our results in an extreme case of h  topology  then a subsection outlines a
somewhat more advanced analysis technique we developed 
    fact generation trees
the fact generation tree  short fgt  to a planning instance is basically the and or tree
that results from a regression search starting at the goals  when ignoring the delete effects of
the actions  tree nodes are labelled with facts and actions alternatingly  fact nodes are or
nodes  they represent a choice of achieving actions  and action nodes are and nodes 
their preconditions represent sets of facts that must be achieved together  we assume a goal
achievement action  as known from  for example  the description of ucpop  penberthy  
weld         that action is the root  and  node of the fgt  and the top level goals form
its sons  obviously  the sons of a fact node are all the actions that achieve the fact  and
the sons of each action node are all the precondition facts of the action   for the sake of
simplicity  we stayed in a pure strips framework in this investigation   tree structures of
this kind were  for example  described and used by nebel  dimopoulos  and koehler       
in their work on automatically detecting irrelevant facts and operators  note that the fgt
does not take account of the interactions that may arise when trying to achieve the facts
below an and node together  as an effect of ignoring the delete lists  the fgt treats all
these facts completely separately 
we terminate the fgt by applying the following two rules 
   say we just inserted an action node n  a  labeled with action a  if there is a fact
p  pre a  so that a fact node labeled with p occurs on the path from the root node
to n  a   then n  a  is pruned 
   say we just inserted  as a son of an action node n  a   a fact node n  p  labeled with
fact p  if there is an action a  with p  pre a     so that an action node labeled with
a  occurs on the path from the root node to n  a   then n  p  is pruned 
intuitively  the rules disallow the generation of branches in the fgt that would be redundant for a relaxed plan  formally  we call a relaxed plan non redundant if no strict subsequence of it is still a relaxed plan  i e   no action can be omitted   every non redundant
relaxed plan  for every  not necessarily reachable  state  can be embedded into a connected 
rooted  and non redundant sub tree of the fgt built in the way described above  we will
   

fiwhere ignoring delete lists works

be more precise after introducing the illustrative example in figure     that we will use
throughout this section 

e

at e

     eur

mv d e

d
     eur

b

c
at d

  eur

a
mv b d

mv c d

at b

at c

mv d c

mv a b

at a

figure     sketch and fgt of the illustrative example 
in the example  the task is to reach location e  the available actions are moves along
 bi directional  graph edges in the obvious encoding using an at predicate  except the
move from d to e  which requires as an additional precondition that we be in possession
of   eur  we can acquire the   eur as an add effect of the action that moves from d to
c  the main part of figure    shows the fgt to the example  the picture in the top left
corner illustrates the example by showing its road map graph and an indication of the role
of the   eur constructs  the root node  i e   the artificial goal achievement action  is not
included in the figure  for simplicity  due to termination rule     for example  moving from
e to d is not included as a son of the fact node labeled at d  the precondition at e is
the root node   due to termination rule    at d is not a son of the action node labeled
mv d c  at d already occurs as a precondition of mv d e above  
every action in a non redundant relaxed plan  to some arbitrary state  achieves some
unique needed fact that is not achieved by any preceding action  and that is needed for
the goal or for the precondition of a subsequent action    it is not overly difficult to prove
that one can thus embed such a relaxed plan into the fgt by processing the relaxed plan
from back to front  associating each action with the corresponding node below a needed
fact added by the action  starting at the goal facts  the resulting sub tree is connected and
rooted in the sense that actions are only associated with consecutive and nodes  starting at
the root node  the sub tree is non redundant in the sense that  of every or node  at most
    this observation was made by  for example  hoffmann and nebel      b   where it is used to detect
actions that do not participate in any non redundant relaxed plan  and that thus do not need to be
considered in the heuristic computations done by planners such as ff or hsp 

   

fihoffmann

one son gets associated with an action  termination rule   is valid since a fact that is needed
at the end of a relaxed plan can not also be needed at its start  termination rule   is valid
since for every needed fact there is at least one representative node in the corresponding subtree  for illustration  consider the different locations in the graph underlying the example
in figure     if one is located  for example  at a and does not have the   eur  then the
entire fgt except the mv c d node corresponds to the sub tree for a non redundant
relaxed plan  this sub tree is obtained as follows  the relaxed plan is mv a b  mv b
d  mv d c  mv d e  the needed facts added by these actions are at b  at d   
eur  and at e  respectively  starting from the goal fact at e  first mv d e gets
associated with the respective action node  then the fact nodes at d and   eur 
the preconditions of the action just dealt with  become open  and mv b d as well as
mv d c get associated with the respective node below their respective needed fact  as a
consequence of the mv b d action  fact node at b becomes open  and mv a b gets
associated with the action node below it  then the process stops  if  in the current state 
one is  for example  located at c with the   eur  then the process selects the sub tree that
consists of the mv c d and mv d e nodes only 
every non redundant relaxed plan in the instance  in particular every optimal relaxed
plan in the instance  corresponds to a sub tree of the fgt  the fgt being a summary of all
possible relaxed plans in that sense  our idea is to examine the fgt for harmful interactions
 conflicts  with the potential to appear in a relaxed plan  the hope is to be able to draw
conclusions from the non existence restricted form of conflicts to topological properties of
h    we next outline an extreme case analysis of this kind  namely one that postulates the
absence of any conflicts in the fgt  note here that  in difference to the situation in the
illustrative example  in general the fgt can contain action fact labels in multiple nodes 
the worst case size of the fgt is exponential in the size of the instance description  so  to
design practically usable domain analysis techniques  one would need to approximate the
fgt  instead of building it completely  this aspect is not treated at all in what follows 
where our objective is  only  to find implications between fgt structure and h  topology
in the first place 
    interaction free planning tasks
think of a conflict as a situation where one part of a  non redundant  relaxed plan can
hinder the execution success of another part of the relaxed plan  if there are no such
conflicts  then every  non redundant  relaxed plan is executable in reality  implying that
h  is equal to the real goal distance  which of course implies that there are no local minima
etc   in the investigated    benchmark domains  this is the case  only  in simple tsp  which
we use as a motivating example 
we define three kinds of conflicts in the fgt  we call two action nodes  labeled by
actions a and a    allied if they participate together in a non redundant sub tree  i e   they
can occur together in the embedding of a relaxed plan  but are not descendants of each
other   this is the case iff the paths from the root node to a and a  separate in an and
node   our first kind of conflicts is given by a pair of allied action nodes labeled a and a   
where a deletes a precondition of a    second kind of conflicts  a pair of action nodes labeled
a and a    where a is a descendant of a    and a deletes a precondition of a  that is not added
   

fiwhere ignoring delete lists works

by any action on the path from a to a    third kind  an action node labeled a  where a
deletes a goal fact that is not added by any action on the path from a to the respective root
node 
if there are no conflicts in the fgt  then we call the task interaction free  it is relatively
easy to see that  without conflicts  for every non redundant relaxed plan  for every nonredundant sub tree of the fgt  there is an execution order that works in reality  so h 
equals goal distance in interaction free tasks 
in the illustrative example from figure     the only conflict in the fgt is that between
the nodes mv d c and mv d e  these nodes are allied  and mv d c deletes the
precondition at d of mv d e  note that this conflict does indeed capture the reason
why h  is not equal to goal distance in the example  in order to be able to move from d to
e  one has to first move from d to c and get the   eur  doing the latter deletes the at
d precondition of the former  but in the relaxation  after the move from d to c  one is
located in both d and c at the same time  and so the relaxed plan needs one step less to
achieve the goal  from all states where the move to c has yet to be done  
an example of a domain with interaction free tasks is the graph search domain mentioned earlier  where the tasks demand to find a path between two nodes in a directed
graph  using the obvious at predicate and connected predicate based encoding   our
illustrative example above becomes an instance of this domain if one removes the   eur
constructs   we can even come up with a purely syntactic criterion that captures this
example domain 
proposition   let  a  i  g  be a strips planning task so that
    g     
   for all a  a   pre a       and
   for all a  a  del a   pre a  
then  a  i  g  is interaction free 
proof  due to prerequisites   and    the and nodes in the fgt all have at most one son 
this implies that there are no allied action nodes  together with prerequisite   and our
termination rule    it implies that no action node can delete the goal fact  or the precondition
fact of an ancestor node 
 
instances of the graph search domain fulfill the prerequisites of proposition   if the
static connected facts are removed prior to planning  note that the syntax identified by
proposition   is a subset of the syntax identified by proposition    and thus in such tasks
hf f is identical to h    and  since h  is identical to the real goal distance  plan existence
can be decided in polynomial time  intuitively  this is because the captured syntax can not
express more than the graph search domain  plans in a task qualifying for proposition  
correspond exactly to paths in the graph where the nodes are the facts  and the edges go
from preconditions to add effects  the same is true for relaxed plans 
the instances of the simple tsp domain are not interaction free  there are conflicts
in the fgt between pairs of actions achieving different visited goals  for example  say
   

fihoffmann

there are three locations to visit  l    l    and l    the action nodes mv l  l   and mv l 
l   are allied since they achieve the goals visited l   and visited l   that both participate
in the root and node  but these actions mutually delete their precondition  at l    so
they constitute a conflict in the fgt  if they appear together in a relaxed plan  then that
relaxed plan is not executable in reality  unless the relaxed plan happens to move back to
l  in between   observe  however  that after the execution of  for example  mv l  l    one
can replace mv l  l   with mv l  l   and so repair the conflict in the relaxed plan  all
conflicts in simple tsp fgts behave this way 
in general  we say that a conflict between allied action nodes a and a  can be repaired if
there is an action a   such that pre a       pre a   add a     del a   thus a   can be executed
after a   and add a      add a     thus a   achieves what a  should have achieved   similar
repairable cases can be identified for the two other kinds of conflicts  if all conflicts in the
fgt can be repaired  then to any non redundant relaxed plan there is a relaxed plan of the
same length that is executable in reality  and so again h  equals goal distance  this is the
case in the simple tsp domain 
we made a preliminary implementation of the above fgt analysis techniques  the
implementation correctly detects that in simple tsp instances  as well as in graph search
instances   h  equals goal distance  in simple tsp  with less than    locations the analysis
takes only split seconds  with more than    locations  the runtime taken explodes fairly
quickly 
    a more advanced analysis
while the above results are encouraging  the techniques applicability  the h  topology it
can detect  is clearly far too severely restricted  it turns out extremely difficult to find
less restrictive implications from fgt structure to h  topology  i e   sufficient criteria for
weaker topological properties  the best we could come up with is a criterion that implies
the non existence of local minima under h    and that holds true in the movie domain and
in some extremely simple logistics instances 
the idea behind the criterion is the following  to imply the non existence of local
minima under h    it suffices to know that  in every state s  there is a starting action a of
an optimal solution so that h   result s  hai    h   s   say we are considering a planning
task where all actions are  at least  invertible  let s be a state and a be the starting action
of an optimal solution from s  if there is an optimal relaxed plan for s that contains a  then
we are done with the argument used in lemma    else  let p   be an optimal relaxed plan
for s that does not contain a  p   can be embedded in a sub tree of the fgt  if a does not
delete any leaf nodes of that sub tree  any facts that p   assumes to be true in the state of
execution  then p   is a relaxed plan for result s  hai  and we are done  too  the case left
open is when a does delete a leaf node of the sub tree occupied by p     observe that this
does not matter if we have that there are no  or only repairable  conflicts in the sub tree 
then  p   is executable in reality  so p   is an optimal plan for s  so the starting action of
p   falls into the first case above and we are done again  we get the following sufficient
criterion 
   

fiwhere ignoring delete lists works

there are no local minima under h  if for all actions a it holds that a is at least
invertible  and for all non redundant sub trees of the fgt that do not contain a  either a
does not delete a leaf of the sub tree  or the sub tree does not contain any conflicts 
to test this criterion  all one needs to do is to consider the  redundant  sub tree of the fgt
where the only branches left out are those that start in nodes labeled with a  if this sub tree
contains a conflict  and a deletes some fact occurring in the sub tree  then the criterion does
not apply  otherwise  if the test succeeds for all actions  it is proved that there are no local
minima under h   
reconsider the illustrative example from figure     where as said above the only conflict
in the fgt is that between the nodes mv d c and mv d e  any sub tree that does not
contain one of these nodes is conflict free  so mv d c and mv d e do not violate the
above criterion  neither do mv b d  mv c d  and mv a b violate the criterion  since
none of these actions deletes a fact occurring anywhere else but in its own precondition 
however  for mv b a and mv d b the sub tree looked at is the entire fgt including
the conflict  and both these actions delete a fact that occurs in the fgt  so the criterion
does not apply to our illustrative example  note that mv b a and mv d b never start
an optimal plan so really they could be left out of the considerations  but it is unclear how
to detect this automatically  in a general way 
a remark on the side is in order here  if an action a does not appear in the fgt  then 
in difference to what one may think at first sight  this does not imply that a does not appear
in an optimal plan  our fgt termination rules  while adequate for relaxed planning  are
too restrictive for real planning  the following is an example  there are the facts g    g   
and p  the goal is  g    g     the current state is  g     the actions are shown in figure    
name
opp
opg 
opg 

 
 
 

 pre 

add 

del 

  g    
  
  p  

 p  
 g    
 g    

 
 g    
 

figure     actions in an example task where the fgt does not contain an action  opp 
namely  needed in reality 
the only optimal plan here is hopp  opg    opg  i  in order to be able to re achieve g 
after applying opg    we must achieve p first  however  opp does not appear in the fgt 
the only location in the fgt where a node n labeled with opp could be inserted is as a
son of the precondition node p of opg    which is inserted as a son of g    but n is pruned
by termination rule    because opp has g  in its precondition  and g  appears on the path
from the root node to n   note that  indeed  opp is never part of a relaxed plan because
achieving p is only good for re achieving g  if that is deleted by other actions necessary to
reach the goals 
our implementation of the criterion given above easily  within split seconds  proves
the non existence of local minima in movie instances  regardless of the size of the instance 
   

fihoffmann

the technique does not  however  work in any other domain we tried  except logistics
instances where there is only a single city  with only two locations in it  only a single truck 
and only a single package to be transported  note that this is even simpler than the small
illustrative example used in section    where two objects need to be transported 
it is an open question how better results can be achieved  i e   how more state spaces can
be recognized to not feature any local minima under h    our feeling is that the backward
chaining approach to domain analysis is promising  but  to be successful  the analysis
technique should probably invest much more effort into analyzing the way in which the
goals can be achieved  and with how many steps  rather than doing just the very crude
fgt approximation  with more information available about how goals can be achieved 
maybe it would be possible to discover non trivial cases in which actions are respected by
the relaxation    as for detecting actions that have no relaxed plan relevant delete effects 
it is yet completely unclear to us how this could be accomplished 

   discussion
we have derived a formal background to an understanding of what classes of domains relaxed plan based heuristic methods  the most wide spread methods in the modern planning
landscape at the time of writing  are well suited for  the formal approach taken is to
identify characteristics of the local search topology  the heuristic cost surface  under the
idealized heuristic function h    in a forward searching framework  for    commonly used
benchmark domains including all competition examples  i e   for basically all strips and
adl benchmark domains that are used in the field at the time of writing  we proved what
the relevant topological properties are  the results coincide well with the runtime behavior
of ff  indeed  empirical results suggest that the quality of h  is often preserved in ffs
approximation of it 
the results are interesting in that they give a rare example of a successful theoretical
analysis of the connections between typical case problem structure  and search performance 
from a more practical point of view  the results provide a clear picture of where the strengths
and weaknesses of h  lie  and so form a good basis for embarking on improving the heuristic
in the weak cases  approaches of this kind have already appeared in the literature  fox  
long        gerevini et al          most particularly  fast downwards heuristic function
 helmert        is motivated by observations regarding unrecognized dead ends under h 
in the mystery domain  and large benches in transportation domains with non trivial road
maps 
regarding the relevance of our topological results for forward search algorithms other
than enforced hill climbing  note that things like the non existence of unrecognized dead
ends or the non existence of local minima are certainly useful for any heuristic search
algorithm  albeit not in the form of a provable polynomiality result    more generally 
the relevance of the topological results for the performance of planners using other search
    we remark that it is not easy to find even trivial syntactical restrictions under which actions are  in
general  respected by the relaxation  for example  even when every fact is added by only a single action 
one can construct cases of non respected actions  one such case is the example from figure     where
opp is not respected by the relaxation 
    except in the case where the heuristic function identifies the precise goal distances  which is the case for
h  in   of the    domains  namely  the simple tsp domain 

   

fiwhere ignoring delete lists works

paradigms  or enhanced heuristics  like lpg and fast downward  is a matter needing further investigation  one thing that is certainly clear is that  in the easiest classes of the
taxonomy  particularly in domains where in the state space there are no local minima under h    and benches can be escaped in a single step  any planner using an approximation of
h  is likely to work quite well  indeed thats what one observes in practice  the intuition
of the author is that the topology of h  plays a large role for the efficiency of these planners
more generally  i e   also in other domains  proving or disproving this is beyond the scope
of this paper  in any case  our investigation provides a nice theoretical background with
proved results in an idealized setting  and these results can be used as a starting point into
investigations tailored to individual systems other than ff 
our investigation considers solvable planning tasks only  which is well justified by the
focus set in the international planning competitions  turning the focus on unsolvable tasks 
one realizes that much of our techniques and results become useless  in a search space
with no solution  the only difference a heuristic function can make lies in the states with
infinite heuristic value  i e   in the states recognized as dead ends  which means that
the only interesting question remaining is for what kinds of dead end states there is no
relaxed plan  what do the results herein tell us about this  in those domains where we
identified unrecognized dead ends  the results tell us that relaxed plans are a too generous
approximation    in the other domains  things look more hopeful  still  these results are
relative to solvable instances  whether or not h  will detect many of the dead end states
in unsolvable tasks will depend on what reasons there can be for such states  the dead
ends in unsolvable tasks may be caused by other reasons than those in solvable tasks 
since the assumptions making the tasks solvable are not given  note that many of the
benchmarks  for example  blocksworld and logistics  do not have any unsolvable instances
in their standard definition  to some extent  this makes the existence or non existence of
unrecognized dead ends a choice of the domain designer extending the domain definition 
exploring these issues in detail is a topic for future work 
talking about future work  the biggest drawback of this research in its current form is 
obviously  that it needs to be re done for every single new planning domain  it would be very
desirable  but turns out to be very hard  to come up with more generic  ideally  automatic
 methods to determine the topological properties of a domain  we have outlined an
attempt we made to develop such automatic methods  based on analyzing properties of fact
generation trees  we presented some first promising results  but regarding the applicability
to domains of the complexity one would like to be able to handle  our methods are yet far
too weak  it is left for future research to answer the question if there are approaches to
the topic that work better in practice  as said  our intuition is that there are such better
approaches  based on more intelligent backchaining style reasoning about how the goals can
be achieved in a domain  but  at the time of writing  this is pure speculation 
beside easening the burden of doing all the proofs by hand  the benefits of automatic domain analysis techniques would be twofold  first  an ambitious long term vision in domainindependent planning is to have an arsenal of complementary heuristics  and combine these
into a hybrid system that can automatically be configured to best suit a given arbitrary
planning task  the contribution made towards this vision by the results at hand is a very
    unsurprisingly  seeing as deciding plan existence is np hard in  for example  mystery  mprime  miconicadl  and freecell  helmert        

   

fihoffmann

clear picture of where the strengths of h  lie  to be able to automatically configure a hybrid system  one would need multiple heuristics with different strengths and weaknesses
 i e   heuristics that are of high quality in different classes of domains   as well as the ability
to determine automatically what heuristic is likely to work best   at least such an approach could be more cost effective  beside being much more insightful  than just trying out
all possible combinations of techniques  
another benefit from enhanced domain analysis techniques might lie in the ability to
generate a high quality admissible heuristic function for sequential planning  in many domains  optimal relaxed plans mostly consist of actions of which it is easy  for a human
 to see that they  or one of a set of similar actions  must be contained in any optimal
relaxed plan  for example  all the loading and unloading actions that cant be avoided in a
transportation task   so the number of such actions in a state could provide a good lower
bound on the value of h    note that this phenomenon  actions that must be contained in
every relaxed plan  is a stronger version of the notion of actions that are respected by the
relaxation  a promising approach seems to be to try to detect the former as a sufficient
approximation of the latter 
since we observed that there are arbitrarily deep local minima under h  in blocksworldarm  but none in blocksworld no arm  one might try to come up with encoding methods
trying to model a domain in a way making it best suited for h    since blocksworld no arm
is basically a version of blocksworld arm where all possible pairs of consecutive actions
 pickup stack  unstack stack  unstack putdown  were replaced with macro actions  a good
 but somewhat obvious  heuristic for modeling is probably to choose the domain granularity
on as high a level of abstraction as possible  more insightful heuristics may be obtained
when considering the h  topology in planning benchmarks enriched with automatically
detected macro actions  botea  muller    schaeffer              
apart from the above  the most important future direction is the adaption of the formal
framework  and of the theoretical analysis methods  to the temporal and numeric settings
dealt with in modern planning benchmarks and in modern planning systems  the needed
adaptations are straightforward for the numeric framework used in metric ff  hoffmann 
    a   as for temporal planning  if the objective function estimated by the heuristic is the
number of actions needed to complete the partial plan  then the adaptation of the framework
is probably straightforward as well  if  however  makespan is estimated by the heuristic 
then most of what is said in this article does not apply  at most  in such a setting our
analysis techniques could be relevant if the search uses an estimation of remaining action
steps as a secondary heuristic 

acknowledgments
i would like to thank drew mcdermott  fahiem bacchus  maria fox  and derek long
for their responses to various questions concerning the definitions of intentions behind the
competition domains  i also thank the anonymous reviewers  whose comments helped to
improve the paper 

   

fiwhere ignoring delete lists works

appendix a  proof sketches
we list the proof sketches in sections concerning dead ends  local minima  and benches  in
that order 
a   dead ends
theorem   the state space of any solvable instance of
   blocksworld arm  blocksworld no arm  briefcaseworld  depots  driverlog  ferry 
fridge  gripper  hanoi  or logistics is undirected 
   grid  miconic simple  miconic strips  movie  pipesworld  psr  satellite 
simple tsp  tireworld  or zenotravel is harmless 
   dining philosophers  optical telegraph  rovers  or schedule is recognized under evaluation with h   
most of the proofs are simple applications of lemma   or    as said  descriptions of the
domains can be looked up in appendix b 
proof sketch   theorem   
all actions in blocksworld arm  blocksworld no arm  driverlog  ferry  gripper  hanoi 
and logistics instances are invertible  so we can apply lemma   and are finished  the
inverse actions are the obvious ones in all cases  like stacking unstacking a block onto from
some other block  loading unloading an object onto from a vehicle  or moving from l to
l   moving from l  to l  in the case of driverlog  the latter can always be done as the
underlying road map is bi directional  c f  appendix b     in the briefcaseworld  depots 
and fridge domains  while the actions do not strictly obey the definition of being invertible
 neither that of being at least invertible   they still invert each other in an obvious way 
i e   for every state s and applicable action a there is an action a so that result s  ha  ai    s 
in movie  actions getting snacks have irrelevant delete effects and static add effects  while
rewinding the movie and resetting the counter are at least invertible  a simple tsp action
moving from l to l  is at least invertible by moving back  in tireworld  to all working steps
there is an inverse one  except to inflating a wheel  but that has irrelevant delete effects
and static add effects  in miconic strips  moving a lift is invertible  boarding a passenger
is at least invertible  and departing a passenger has irrelevant delete effects and static add
effects  in all the four domains  lemma   can thus be applied  in the miconic simple and
grid domains  while the actions do not strictly adhere to the relevant definitions  similar
arguments like lemma   prove the non existence of dead ends  in miconic simple  moving
the lift is invertible  letting passengers in or out of the lift can not be inverted  but those
actions need to be applied at most once  similar to static add effects   and they do not
interfere with anything else  similar to irrelevant deletes   in grid  to all actions there is an
inverse action  except opening a lock  the latter action excludes only other actions opening
the same lock  similar to irrelevant deletes   and each lock needs to be opened at most once 
as locks can not be closed  static add effects   in zenotravel and satellite  all facts can be
re achieved but sometimes one has to apply several actions to do so  in zenotravel  after
   

fihoffmann

flying an airplane from l to l    to get back to l  one might have to refuel the airplane on
top of flying it back  in satellite  after switching an instrument on  one might have to recalibrate it  which can always be done but can involve several actions  turning the satellite
into the right direction before applying the actual calibration action   in pipesworld  any
push action is inverted by the respective pop action  and vice versa  the state space is not
undirected since the pushs pops for non unitary pipeline segments are split into two parts 
in psr  there are no dead end states since one can always reach a goal state by waiting 
if necessary  then opening all breakers  then bringing the  non breaker  devices into a goal
position  then closing the needed breakers 
in dining philosophers  dead ends arise only when a process  a philosopher  has initiated an impossible reading or writing command  from to an empty a full queue   the
queue contents can then not be updated  and no more actions are applicable   the derived
predicate rules that determine if a process is blocked do not apply in this case  since they
require that no read write command has been initiated yet   obviously  with no applicable
actions there is no relaxed plan either  in all other states  the goal can be reached by
traversing individual process state transitions until all philosophers have one fork  and try
to take up the other 
in optical telegraph  dead ends arise in two kinds of situations  first  when a process
has initiated an impossible reading or writing command  similarly as in dining philosophers 
there are no applicable actions and thus no relaxed plan  the second possibility is that the
two processes in a pair may take different decisions of where to go next in their communication sequence  one may decide to stop data exchange  while the other may decide to
send or receive more data  in such a situation  at least one of the processes is in a state
where it has two transitions available  has already activated one of these transitions  and
might have already initiated the respective write read command  the write read command
is impossible  since the other process took a different decision   and no more actions are
applicable for that process  the derived predicate blocking rules do not apply to the
process  because they never apply in process states with more than one available transition 
so neither a real nor a relaxed plan exist for the state  from all other reachable states 
the goal can be reached by traversing individual process state transitions until all pairs of
communicating processes occupy one control channel  and try to write into the other 
in rovers  there is a plan to a state if and only if  for all soil rock samples and images
that need to be taken  there is a rover that can do the job  and that can communicate the
gathered data to a lander  the only chance to run into a dead end is to take a soil rock
sample with a rover that can not reach a lander  the soil rock sample is available only once  
but then  there is no relaxed plan to the state either 
in schedule  any state s with gd s     can be solved by applying  to each object o in
turn  a certain sequence of working steps  if the sequence can not be applied for some object
o then it follows that the preconditions of a needed action are not fulfilled  which must be
the case because o is not cold in s  a do roll action has been applied to o previously 
making o hot   no operator can make o cold again  i e   no operator adds the respective
fact  thus there is no relaxed plan for s either 
 
note that the worst cases in theorem   can occur  i e   in the domains whose instances
are harmless  there can be directed state transitions  and in the domains whose instances are
   

fiwhere ignoring delete lists works

recognized  there can be dead ends  we remark that the dead ends in dining philosophers
and optical telegraph are due to what seem to be bugs in the encoding of the queues
 whose contents arent always updated correctly  and of the blocked situations  whose rules
for detection seem to be incomplete   modifying the operators in a straightforward way to
fix these  apparent  bugs  one gets dead end free  harmless  state spaces 
the domains not mentioned in theorem   are airport  assembly  freecell  miconicadl  mprime  and mystery  in all these domains  one can construct arbitrarily deep
unrecognized dead ends  in airport  unrecognized dead ends arise when two planes move
towards each other on a line of segments  with no possibility of changing the direction 
such deadlock situations arent recognized by relaxed planning since  in the relaxation  the
free space left between the two planes remains free  and can be used to navigate the planes
across each other  the dead end becomes arbitrarily deep when  independently of the
deadlock situation  other planes can still be moved  we remark that  in reality  and in
the ipc   example instances  deadlock situations like this rarely occur  airplanes are only
movable along standard paths that serve to avoid such deadlocks on the main connecting
routes of the airport  the only places on the airport where deadlocks can occur  both in
reality and in the ipc   example instances  are near the parking areas  where space can
be dense  and airplanes need to move in both directions on the same airport segment  if
no deadlocks can occur at all  i e   if all planes can move to their target positions one after
the other without hindering each other  then h  delivers the exact goal distance  this is
presumably the reason why the heuristic planners performed very well in the ipc   airport
test suites  the performance would probably become worse if one were to use  unrealistic 
instances with excessively many potential deadlock situations 
in assembly  unrecognized dead ends can arise when several objects are stuck due to
complex ordering constraints  which imply that any solution plan would need to go through
a cyclic assembly pattern  the details are rather complicated  and the interested reader is
referred to the tr  hoffmann      c   it can be proved that  unless the ordering constraints
in an assembly instance have the potential to yield a cyclic situation  there are no dead
ends at all  in all but one of the ipc   competition instances  the ordering constraints do
not have this potential  this helps to explain how ff can be so efficient in that test suite
 it solves even the largest task within half a second search time  finding a plan with    
steps  
in freecell  unrecognized dead ends can arise  for example  when one is not cautious
enough about moving cards into the free cells  a relaxed plan can still achieve the goal
with a single free cell  using that cell as an intermediate store for all cards  in reality 
however  moving a card into a free cell occupies space  by deleting the availability of the
free cell   and can thus exclude possibilities of reaching the goal  thus moving a card into
a free cell can lead into an unrecognized dead end state  the unrecognized dead end can be
arbitrarily deep when other cards can still be moved around independently of the deadlock
situation 
in miconic adl  unrecognized dead ends arise when a problem constraint is violated 
but this violation goes unrecognized by the relaxed plan  an example is when two passengers
p  and p  are in the lift  such that p  can only be transported downwards  p  has no access
to p  s destination floor  and p  s destination floor is below p  s  the state is a dead end
because one can not let p  get out first  p  has no access to the respective floor  but
   

fihoffmann

neither can one let p  get out first  afterwards  the lift would need to drive upwards 
which it cant with p  on board  in the relaxation  one can stop at both destination floors
simultaneously because the at facts are not deleted  the unrecognized dead end becomes
arbitrarily deep when several other passengers can be moved around before reaching p  s
destination floor 
in mystery  unrecognized dead ends arise when fuel is scarce  and a vehicle makes suboptimal moves  the relaxed plan can achieve the goal as long as all relevant locations are
still accessible at least once  but that may not suffice in reality  the dead end becomes arbitrarily deep when additional objects can be transported independently of the problematic
situation  mprime behaves similarly  the only difference to the mystery example is that  to
avoid the possibility of transferring fuel items to the problematic locations  one must make
sure that there is just enough fuel to enable the transportation of the additional objects 
a   local minima
theorem   under h    the maximal local minimum exit distance in the state space of any
solvable instance of
   blocksworld no arm  briefcaseworld  ferry  fridge  grid  gripper  hanoi  logistics 
miconic simple  miconic strips  movie  simple tsp  or tireworld is   
   zenotravel is at most    satellite is at most    schedule is at most    diningphilosophers is at most    
we present the proof sketch to theorem   in terms of three groups of domains with
similar proofs  note that the domains where the maximal local minimum exit distance is  
are domains where there are no local minima at all  we first focus on the domains where
lemma    or slight extensions of it  can be applied 
proof sketch   theorem    ferry  fridge  gripper  logistics  miconic simple  miconicstrips  movie  simple tsp  tireworld 
with theorem    none of the listed domains contains dead ends  as said in the proof
sketch to the theorem  all actions in the ferry  gripper  logistics  miconic strips  movie 
simple tsp  and tireworld domains are either at least invertible  or have irrelevant delete
effects  with lemma   it suffices to show that all actions are respected by the relaxation 
in all cases  except the driving flying actions in logistics  it is very easy to see that any
optimal starting action does something that can not be avoided in the relaxed plan   for
example  the relaxed plan can not avoid to load unload objects onto from vehicles  and
it can not avoid missing working steps in tireworld   if an optimal starting action a in
logistics drives a truck flies an airplane to some location l  then some object must either
be loaded or unloaded at l  so a relaxed plan from s has no choice but to apply some action
that moves a transportation vehicle  of as kind  there  all vehicles are equally good  except
when there is a clever choice  i e   a vehicle that already carries objects to be unloaded at
l  but then  a will move one of those vehicles just like an optimal relaxed plan will  and all
such vehicles are equally good in the relaxation   in ferry  gripper  and miconic strips 
   

fiwhere ignoring delete lists works

there is only a single vehicle  which makes the moving actions in these domains easier to
reason about  
in the fridge and miconic simple domains  the actions do not adhere strictly to the
definitions of invertibility and irrelevant delete effects  but the proof to theorem   has
shown that they have similar semantics  i e   they can either be inverted  or delete only
facts that are no longer needed once they are applied  furthermore  all actions in these
domains are respected by the relaxation  in fridge  missing working steps must also be
done in the relaxed plan  in miconic simple  lift moves are trivially respected  and lift
stops are respected since clever choices in reality coincide with clever choices in the relaxed
plan 
 
in the next four domains  there are no local minima either  but the proofs are more
sophisticated and make use of rather individual properties of the respective domains  in all
cases it is proved that there is a path to the goal on which h  does not increase 
proof sketch   theorem    blocksworld no arm  briefcaseworld  grid  hanoi 
with theorem    none of these domains contains dead ends  in blocksworld no arm 
if an optimal starting action a stacks a block into its goal position  then a also starts
an optimal relaxed plan  because there is no better thing to do than to achieve this goal
immediately   in that relaxed plan  a can be replaced with its inverse counterpart to form
a relaxed plan for the successor state  if there is no such action a in a state s  then one
optimal plan starts by putting some block b  that must be moved in order to access a block
below it  from some other block c onto the table  yielding the state s    a relaxed plan
for s  can be constructed from a relaxed plan p   for s by  taking account of various case
distinctions  replacing the move actions regarding b in p   with the same number of other
such move actions  the case distinctions are about what kind of action p   uses to move b
away from c  one such action a  must be contained in p     if a  moves b to the table then
we can replace a  in p   with the action that moves b back onto c  and are finished  else  we
must distinguish between the cases where b is required to be on c for the goal  or on some
other block  in both cases  we can make successful use of the fact that b can be moved from
any position to any other position within a single action  enabling us to exchange actions
in p   quite flexibly 
in briefcaseworld  all actions can be inverted  actions that put objects into the briefcase
are trivially respected by the relaxation  in a state s where an optimal plan starts with a
take out action  an optimal relaxed plan for s can also be used for the successor state  since
taking out an object does not delete important facts  in a state s where an optimal plan
starts with a move action from l to l    and p   is a relaxed plan for s  a relaxed plan for
the successor state can be constructed by replacing moves from l to l     l      l    in p     with
moves from l  to l    
in grid  a rather complex procedure can be applied to identify a flat path to a state
with better h  value  in a state s  let p   be an optimal relaxed plan for s  and let a be the
first unlock action in p     or a putdown if there is no such unlock action  identifying a flat
path to a state s  where a can be applied suffices  because unlocking deletes only facts that
are irrelevant once the lock is open  and the deletes of putting down a key are irrelevant if
there are no more locks that must be opened  the selected action a uses some key k at a
   

fihoffmann

position p  p   contains a sequence of actions moving to p  moving along the path defined
by those actions does not increase h  since those actions are contained in the relaxed plan 
and they can be inverted  if k is already held in s  then we can now apply a  if the hand is
empty in s  or some other key is held  then one can use p   to identify a flat path to a state
where one does hold the appropriate key k  if the hand is empty  then p   must contain a
sequence of actions moving to a location where k can be picked up  if some other key is
held  then p   must contain sequences of actions moving between locations where a series
of keys are picked up and put down  where the key series ends with picking up k 
in hanoi  it can be proved that the optimal relaxed solution length for any state is equal
to the number of discs that are not yet in their final goal position  proceeding from the
smallest to the largest disc  each respective goal can be achieved with a single action  no
optimal plan moves a disc away from its final position  so h  does not increase on optimal
solution paths 
 
we finally consider those four domains where there are local minima  but one can always
escape them within a constant number of steps  in all cases  we prove an upper bound d on
the distance of any non dead end state s to a state s  with h   s      h   s   this immediately
implies that d    is an upper bound on the maximal local minimum exit distance  it also
implies that d    is an upper bound on the maximal bench exit distance  the results will
be re used in appendix a    
in dining philosophers  h  is only loosely connected to goal distance  and the bound 
which holds even for the trivial heuristic function returning the number of yet un blocked
philosophers  follows from the rather constant and restrictive domain structure  in the other
three domains  the proofs proceed as follows  for a reachable state s  we identify a constant
number of steps that suffices to execute one action a in the optimal relaxed plan for s  and 
without deleting as relevant add effects  to re achieve all relevant facts that were deleted
by a  then  a state s  with h   s      h   s  is reached 
proof sketch   theorem    dining philosophers  satellite  schedule  zenotravel 
by theorem    the dead ends in dining philosophers are all recognized  in any non
dead end state s  the shortest relaxed plan blocks all processes  philosophers  that are not
yet blocked  for each individual process  at most   steps are needed  in the relaxation 
to block a process it always suffices to activate a state transition  to initiate a read write
command  and to do the queue update  after the update  the queue is both empty and full 
and the read write is impossible in the sense that the blocking rules apply   with this  a
process can block itself in the relaxation  and the h  value is only fairly loosely correlated
with the true goal distance   thus  to reach a state with lower h  value  obviously it always
suffices to block one more process  we prove our upper bound by determining a constant
bound on the number of steps needed to do that  such a bound exists because  beside the
fact that the philosopher processes are constant and can interfere only with their respective
two neighbors at the table  the philosophers have a fixed order in which they try to pick up
the forks  they always first try to pick up the fork to their right  then the fork to their left 
this restricts the possible combinations of internal states of neighbored philosophers 
in more detail  a philosopher is blocked iff he tries to pick up a fork that is not on the
table  for a philosopher p  we refer by pl to ps neighbor philosopher on the left side  a
   

fiwhere ignoring delete lists works

description of the   different states of each philosopher process is in appendix b    let s
be a non dead end state  let p be a philosopher that is not blocked in s  if no such p exists 
then s is a goal state and there is nothing to prove   we can prove the desired upper bound
by an exhaustive case distinction over the states of p and pl  for each state i                
of p  we consider each state il                 of pl  if the combination of i and il is not
possible  then we do nothing  else  we determine a number k of process state transitions
that leads to a state where either  p is blocked and pl is still blocked if it was blocked
in s  or pl is blocked and was not blocked in s  in a few cases  to do so we also have to
make distinctions over the internal state of pls left neighbor pll  the worst case  k     
occurs when i      i e   when p holds both adjacent forks  then  pl has to be in either
state il     or il      which means  pl cant hold the fork between pl and p since that
is held by p   if il      then pl is not blocked in s  pl can put down its left fork  getting
to state   where pl is blocked since it waits to pick up its right fork  held by p  if il    
then we have to distinguish two cases about the state of pll  we have that i      p holds
both adjacent forks   and il      pl waits to pick up the fork between p and pl   pl is
blocked  case a  if the state of pll is       or    then pll holds the fork between pll and
pl  we go with p from   to    from   to    and from   to    and we go with pl from   to   
then  both p and pl are blocked since they wait to pick up the fork to their left  case b 
if the state of pll is   or    then the fork between pll and pl is on the table  and pll is
not blocked  we go with pll from   to    if in     and from   to    after that  pll holds
the fork between pll and pl  we are in case a and can apply that sequence  getting us to
a state where pll is possibly blocked  and both p and pl are definitely blocked 
we always need at most   process state transitions to block one more philosopher 
the process state transitions take   planning actions each  and so this makes    planning
steps  some more planning steps are needed due to the subtleties of the pddl encoding 
subtlety a  a process may have already decided to go to a state  but not yet arrived there
 i e   the respective transition is activated and the read write command is initiated  so
that communication channel queue is occupied but the transition is not yet complete  at
most   steps are needed to reach the next internal state  update the queue and wrap up
the transition   subtlety b  to be blocked in a state a process must activate its outgoing
transition  in the worst case described above  each of p  pl  and pll may require the  
steps induced by subtlety a  both p and pl require the step induced by subtlety b  so all
in all we get to  at most     planning actions  in effect of the last action  one more process
becomes blocked  so an upper bound on the exit distance is    
by theorem    there are no dead ends in satellite  let s be a reachable state  to
determine an upper bound d on the distance from s to a state s  with h   s      h   s  
one can look at an optimal relaxed plan p   for s  and distinguish four cases regarding the
existence of applicable actions of different types in p     for each action type  a constant
number of steps suffices to re achieve the deleted facts after application of the action  the
worst case  d      arises when a switch on action is applied  switching on an instrument
deletes the instruments calibration  to re achieve this  one must turn the satellite and
calibrate it  after another turn and taking an image  a state with lower h  value is reached 
by theorem    the dead ends in schedule are all recognized  let s be a non dead
end state  to determine an upper bound d on the distance from s to a state s  with
h   s      h   s   one can look at an optimal relaxed plan p   for s and distinguish seven
   

fihoffmann

cases regarding the kinds of applicable actions that p   contains  the worst case  d     
arises when only a do roll action is available  and applicable  in p     one then needs to
apply a time step  a do lathe action to achieve the desired effects of do roll  another time
step  a do polish or a do grind action to re achieve the previous surface condition  another
time step  and a do immersion paint action to re achieve the previous color 
by theorem    there are no dead ends in zenotravel  in a reachable state s  to determine
the desired constant d  distinguishing two cases does the job  if the relaxed plan p   for s
contains an applicable boarding  departing  or refueling action  then applying that action
leads into a state with lower h  value  else  p   starts with a flying action  and a better
state can be reached by executing the flight  refueling once  and boarding or departing a
person  we get d     
 
note that the proved bound for dining philosophers holds even if we take the heuristic
function to be the trivial one that returns the number of yet un blocked philosophers  it is
extremely cumbersome to figure out what exactly the worst case exit distance is in diningphilosophers under h   to do so  one has to consider all combinations of possible states of
neighbored processes  and their possible developments over a lot of action steps  in a rather
un intuitive pddl encoding made by an automated translation machinery  the highest
exit distance we could actually construct in dining philosophers was     we conjecture
that this is a  tight  upper bound 
in satellite  schedule  and zenotravel  the proved upper bounds are tight  in all of
dining philosophers  satellite  schedule  and zenotravel  the bounds are valid for any nondead end state s  so  beside a bound on the local minimum exit distance  these results also
provide a bound on the bench exit distance  we will re use them below in appendix a   
in blocksworld arm  depots  driverlog  optical telegraph  pipesworld  psr  and rovers 
one can construct local minima with arbitrarily large exit distances  in blocksworld arm 
an example situation is that where n blocks b            bn initially form a stack where bi is
on bi   and bn is on the table  and where the goal is to build the same stack on top of
another block bn     i e   the goal is a stack b            bn   bn     reaching  from the initial state 
a state with better h  value  involves disassembling the entire stack b            bn   during the
disassembling process  h  increases  the same example can be used in depots 
in driverlog  local minima can arise due to the different road maps for trucks and drivers 
for example  when it takes one step to drive from a location l to another location l    but n
steps to walk  in the relaxed plan  the driver can drive the truck to its goal while himself
staying where he is  but in reality  the driver will have to walk all the way back 
as for optical telegraph  this is treated most easily by reconsidering the diningphilosophers domain  for which we proved a constant upper bound above  the reason is
that optical telegraph is basically a more permissive version of dining philosophers  where
the philosophers can choose which fork to pick up first  and  if they hold both forks  which
fork they want to put down again first  consider the configuration depicted in figure    
that configuration is not reachable given the automata underlying dining philosophers 
but is reachable given the automata underlying optical telegraph 
in figure     nietzsche holds both adjacent forks  while kant holds none and tries to
get access to the fork to his right  in between nietzsche and kant  there are arbitrarily
many other philosophers that all hold one fork each  and are trying to access the other 
   

fiwhere ignoring delete lists works

kant

nietzsche

figure     an unreachable situation in dining philosophers  in which an unbounded local
minimum under h  would arise  arrows indicate pickup requests 

the only non blocked philosopher is nietzsche  who can put down the forks again  in the
pddl encoding of this  in the world state where nietzsche has just activated the transition
putting down the right  or left  fork  the h  value is    in the relaxation  it suffices to
initiate the write command  and to update the queue contents  after the write command
was initiated  however  h  goes up to   because the transition has become non activated 
so the relaxed plan has to update the queue contents  wrap up the transition  then activate
the  same  transition again  reaching a state where the h  value is   involves propagating
forks through the entire sequence of philosophers between nietzsche and kant  either on the
right hand side  or on the left hand side  for example  say nietzsche puts down both forks
and then picks up the right fork  then the philosopher to the left of nietzsche can pick up
his requested fork  or nietzsche can pick it up which gets us back to where we started   in
the resulting state  we are in the same situation as before  except that now the philosopher
with the nietzsche role sits one more position to the left  after iterating the procedure
around the left side of the table  kant can pick up the requested fork  and request to get the
other  giving us a goal state where all philosophers are blocked  the state with h  value  
is the one where kant has not yet activated the transition to request the other fork 
the configuration in figure    is not reachable in the dining philosophers domain as
used in ipc    because  there  a philosopher can not pick up the fork on his left hand
side first  as is done in figure    by all the philosophers between nietzsche and kant
on nietzsches left hand side  as said  in optical telegraph the philosophers do have
this freedom of choice  and so the situation is reachable  in more detail  as described in
appendix b     in optical telegraph there are n pairs of communicating processes  the
pairs are arranged in a cycle  where between each pair there is a control channel  internally 
the two processes within each pair can go through a fairly long  heavily interactive  sequence
of operations  implementing the possibility to exchange data between the two stations 
   

fihoffmann

before these operations can begin  each of the processes has to occupy  write into  one
control channel  that is  one of the processes occupies a channel  then it waits for a signal
from the other process  indicating that the second control channel was occupied as well 
after the data exchange was terminated  the control channels get released  read  in an
arbitrary order  the overall system is blocked iff all process pairs are in the state where
they have occupied one control channel  and are waiting to occupy the other  thus  the
process pairs correspond exactly to philosophers that can choose which fork to pick up  put
down  first  and figure    provides an example with arbitrarily high exit distance from a
local minimum state  precisely  the local minimum state is the one where the nietzsche
process pair has just occupied both channels  and the process that blocked the second
channel has just activated the transition sending the occupied the other one signal  in
that state  h  has value    all processes except the active one are blocked  
in pipesworld  consider the situation where several areas form a circle with unitary
connections  in the local minimum state s  a single goal batch g has to go into an area a 
g is currently in a segment s adjacent to a  a contains a batch b  all other areas are empty 
the shortest plan is to push b into the other segment  not s  adjacent to a  and propagate
the batches around in the circle until g can be pushed into a  the shortest relaxed plan for
s is  however  to push b into s and then push g into s from the other side  i e   g is used
to push itself into the goal area  reaching the nearest state with h  value   requires n   
steps when there are n areas in the circle  and on the path the h  value increases  note that
this example uses neither tankage restrictions  nor interface restrictions  nor non unitary
pipeline segments 
in psr  a deep local minimum is given when n breakers each feed an individual goal line 
in a way so that no breaker can feed any other breakers goal line without that other breaker
being also closed  and the breakers are all connected to some faulty line  all but one of the
breakers are closed  the h  value of such a state is    close the single open breaker  since
the only unsatisfied goal condition  beside supplying the line fed by the open breaker  is the
one postulating that no breaker is affected  that condition is a negated derived predicate 
and thus ignored in the relaxation  the only applicable action in the state is to wait  after
that  all breakers are open  and the shortest relaxed plan is to close them all  yielding the
h  value n  obviously  the nearest state with h  value   is at least n steps away   
in rovers  local minima can arise because taking an image deletes the calibration of
the camera  an example is this  there are n waypoints w            wn connected in a line
 i e   wi  is connected to wi    a lander at w    one rover has a camera c that must be used
to take two images at w    and c can be calibrated  only  at wn   when the rover is at w   
and c is calibrated  the relaxed plan is to take the two images and communicate the two
data pieces  but after taking one image  one has to navigate all the way to wn   calibrate
c  and get back  note that this example makes use of a road map with arbitrarily large
diameter  where the diameter of a rovers instance is the longest way any rover must travel
in order to get from one waypoint to another  in general  the distance to a state with better
h  value is bounded by  d     where d is the diameter of the instance  see the details in
the tr   the road map diameter in the ipc   rovers instances varies around   to   
    we remark that this counter example remains valid in the ipc   simple adl and strips formulations
of psr  which use a different encoding of the derived predicates  not using a negation to formulate the
goal that no breaker is affected 

   

fiwhere ignoring delete lists works

as for the airport  assembly  freecell  miconic adl  mprime  and mystery domains  we
have seen in appendix a   that these contain unrecognized dead ends  so  by proposition   
the local minimum exit distance in these domains is unbounded  for assembly  as the
tr describes in detail  the initial state of an instance has a path to the goal on which
h  decreases monotonically  unless there are complex interactions between the ordering
constraints present in the instance  none of the ipc   instances features such complex
interactions  assuming that ffs search algorithm sticks to the monotonically decreasing
paths  this gives another indication as to how the system can be so efficient in that example
suite 
a   benches
theorem   under h    the maximal bench exit distance in the state space of any solvable
instance of simple tsp is    ferry is at most    gripper is at most    logistics is at most
   miconic simple is at most    miconic strips is at most    movie is at most   
zenotravel is at most    satellite is at most    schedule is at most    tireworld is at most
   and dining philosophers is at most    
as before  we subdivide the proof sketch to theorem   into groups of domains with
similar proofs  we first consider the transportation type domains  in all of them  lemma   
or very similar proof arguments  can be applied 
proof sketch   theorem    ferry  gripper  logistics  miconic simple  miconic strips 
the proofs to theorems   and   have shown that  in all these domains  the actions
are respected by the relaxation  and  in all these domains except in miconic simple  the
actions are either invertible  or have no relevant delete effects  to determine an upper bound
d on the exit distance from benches  we can thus apply lemma    this requires us to show
that  for any state s  there is an optimal plan in that the d    th action has no relaxedplan relevant delete effects  in miconic simple  we have seen that the actions  while not
adhering to the syntactic conditions of invertibility and  no  relevant delete effects  have
similar semantics  so the same proof technique can be applied there 
in all the  transportation type  domains under consideration  the argument is  roughly 
that load type and unload type actions have no relaxed plan relevant delete effects  while
move type actions need not be applied more than once in a row because all locations are
immediately accessible from each other  this implies an upper bound of   on the maximal
exit distance  concretely  say s is a reachable state in a logistics instance  a starts an
optimal plan from s  p   is an optimal relaxed plan for s that starts with a  and applying
a to s yields the state s    if a is a loading  unloading  action  its only delete is the at in   fact of the transported object  as the object is loaded from the respective location
 unloaded from the respective vehicle  only once in the optimal relaxed plan p     a has no
relaxed plan relevant delete effects  so s is an exit  otherwise  if a drives or flies some vehicle
v from l to l    then s  is an exit because an optimal plan for s  starts by loading  unloading 
some package to  from  v  for miconic strips and miconic simple  the same arguments
apply  in ferry  the arguments also remain valid except that  if the optimal start action
a in the state s boards a car  then this action also deletes the available free space on the
   

fihoffmann

ferry  but then  the relaxed plan p   for s also contains actions that move the ferry to a
location l  and that debark the car at l  otherwise there would be no point in boarding the
car   placing these actions up front in p     and removing a  yields a relaxed plan for the
state that results from applying a in s  a similar argument can be applied to prove the
claim for gripper  where gripper hands can hold only one ball at a time   note that the
argument for ferry and gripper uses a somewhat weaker notion than relaxed plan relevant
delete effects  where there are such effects  but they are undone by actions contained in the
relaxed plan  
 
next come some non transportation domains where also lemma   can be applied 
proof sketch   theorem    movie  simple tsp  tireworld 
the proofs to theorems   and   have shown that in these domains all actions are
respected by the relaxation  and either at least invertible  or have irrelevant delete effects 
we apply lemma   in all cases 
in movie  all actions have no  and therefore no relaxed plan relevant  delete effects 
with the single exception of rewinding the movie  which deletes the counter being at zero  
obviously  no optimal plan rewinds the movie twice in a row  thus  d     is the desired
upper bound 
in simple tsp  d     suffices  say we are in a reachable state s where one is at location
l  an optimal plan starts with an action a visiting a yet unvisited location l    an optimal
relaxed plan for s is to start with a  then visit each remaining unvisited location l   by a
move from l  to l     the latter actions do not require preconditions deleted by a  and so a
 every action  has no relaxed plan relevant delete effects 
in tireworld  the lowest constant upper bound is d      some non final working steps
 like jacking up a hub with a flat wheel on  need to be undone later on  i e   they have
relaxed plan relevant delete effects  other final working steps  like jacking down the hub 
need not be undone  i e   they have no relaxed plan relevant delete effects  the longest
sequence of non final working steps that any optimal plan does in a row is the following
  step one  open the boot  it must be closed again   fetch the wrench and the jack  they
must be put away again   loose the nuts on a hub thats got a flat wheel on  the nuts must
be tightened again   jack up the respective hub  it must be jacked down again   and undo
the nuts  they must be done up again   in the resulting state  one can remove the flat
wheel  which needs not be undone 
 
for the remaining domains where theorem   claims a constant upper bound on the
maximal bench exit distance  we have seen in appendix a   that there are upper bounds
on the distance from any reachable state s to a state s  with h   s      h   s   these upper
bounds trivially also imply upper bounds on the maximal bench exit distance 
proof sketch   theorem    dining philosophers  satellite  schedule  zenotravel 
follows directly from the proof to theorem   

 

for all of the above domains  except the last four  one can easily construct examples
where the bench exit distance is equal to the proved upper bound  for satellite  schedule 
   

fiwhere ignoring delete lists works

and zenotravel  it is an open question whether there are tighter bounds on the bench exit
distance than on the local minimum exit distance  this does not seem particularly relevant 
though   for dining philosophers  as said above it may be that not even the bound on the
local minimum exit distance is tight  
for the blocksworld no arm  briefcaseworld  fridge  grid  and hanoi domains  theorem   proves that there are no local minima  so there it is important to know whether it can
be arbitrarily difficult to escape benches  the answer is yes in all cases  in blocksworldno arm  the example is the same one that we already used in blocksworld arm and depots
 to show that there are no bounds on the local minimum exit distances   there are n blocks
b            bn that initially form a stack where bi is on bi   and bn is on the table  and the goal is
to build the same stack on top of another block bn     i e   the goal is a stack b            bn   bn    
the shortest relaxed plan for the initial state is n steps long  remove the stack on top of
bn   then move bn onto bn      the nearest state with h  value n    is the one where bn has
already been stacked onto bn     that state is n steps away from the initial state 
in briefcaseworld  the bench exit distance becomes large when many objects must be
taken out of the briefcase  in the relaxation  there is no point in taking objects out  since
moving the briefcase does not delete any at facts  consider the state s where n objects
o            on are inside the briefcase at a location l  and the goal is to have o            on at l and
the briefcase at another location l    we have h   s       moving the briefcase to l  suffices
in the relaxation  but the nearest goal state  h       is n     steps away  one must take
all the objects out before moving to l   
in fridge  if in a single fridge the compressor is held by n screws  then the exit distance
of the initial state is n      to reach a better state  one must  stop the fridge  which must
be turned back on in the relaxed plan   unfasten the n screws  which must be fastened
again in the relaxed plan   and remove the broken compressor  which needs not be undone
as it only deletes the fact that the broken compressor is attached to the fridge    
in grid  consider the instances where the robot is located on a n  grid  a line  without
locked locations  the robot starts at the leftmost location  and shall transport a key from
the rightmost location to the left end  the initial value of h  is n      walk over to the
key  pick it up  and put it down  the at facts are not deleted   and the value does not get
better until the robot has actually picked up the key 
in hanoi  we have seen that h  is always equal to the number of discs that are not yet
in their goal position  thus the maximal bench exit distance grows exponentially with the
number of discs  from the initial state in an instance with n discs  it takes  n  steps to
move the first  i e   the largest  disc into its goal position 
for the   domains where the local minimum exit distance can be arbitrarily large  it
is not as relevant whether the bench exit distance is bounded or not  escaping a bench
might do the planner no better than ending up in a huge local minimum  we remark that 
for example  in driverlog  rovers  mprime  and mystery  one can easily construct examples
with large bench exit distances  by defining road maps with large diameters  i e   by using
basically the same example as used above in the grid domain 
    in fact  one can easily prove that n     is also an upper bound on the bench exit distance  in fridge
instances where compressors are held by n screws  details are in the tr  

   

fihoffmann

appendix b  domain descriptions
the following is a list of brief descriptions of the    investigated domains  we explain the
overall idea behind each domain  the available operators  and what the initial states and
goals are  in most cases the set of instances is obvious  restrictions  if any  are explained 
we remark that  at some points  the domain semantics seem a bit odd  for example  in
zenotravel  the only difference between flying and zooming a plane is that zooming consumes
more fuel   the odd points are  presumably  domain bugs that have been overlooked by the
respective domain designers  we have not corrected these bugs as  after all  the investigation
is meant to determine the properties of the benchmarks as they are used by the community 
the domains are listed in alphabetical order 
b   airport
in the airport domain  the planner has to safely navigate the ingoing and outgoing traffic 
at a given point in time  across an airport  the main problem constraint is that planes
must not endanger each other  which they do if they come too close to each others running
engines  the constraint is modeled by letting each plane block the segments that its
engines currently endanger  planes can not enter blocked areas  there are five operators 
a plane can be moved from one airport segment to another  if the plane is facing the right
direction  and no planes get endangered by the action  similarly  a plane can be pushed
back if that does not cause trouble  one can start up the engines of a plane  let the plane
take off  or let the plane settle at a parking position  the initial state specifies the current
positions and orientations of the planes  the goal specifies which planes are outbound  have
to take off   and which are inbound and to what parking positions 
b   assembly
in the assembly domain  a complex object must be constructed by assembling its parts
together  obeying certain ordering constraints  the parts themselves might need to be
assembled in the same way beforehand  some parts are transient  which means that they
must be integrated only temporarily  there is a collection of machines  resources  which
might be needed by the working steps  there are four operators  an available resource can
be committed to an object  deleting the resources availability  releasing a resource from
an object is the inverse action  an available object x can be assembled into an object y 
if x is either a part or a transient part of y  if all resources that y requires are committed
to y  and if all objects that have an assemble order before x are already incorporated into
y  in effect  x is incorporated into y but no longer available  and y becomes available if all
parts of y except x are already incorporated  and no transient part of y is incorporated  an
incorporated object x can be removed from y  if all resources that y requires are committed
to y  and  given x is a transient part of y  a part of y   if all objects with a remove order
 an assemble order  before x are incorporated  not incorporated   in effect  x is available
but no longer incorporated  and y becomes available if all parts of y are incorporated  and
all transient parts of y except x are not incorporated  in the instances  the part of relation
forms a tree where the goal is to make the root object of the tree available  also  the
   

fiwhere ignoring delete lists works

assemble and remove order constraints are consistent  cycle free   these restrictions hold
true in the aips      competition examples 
b   briefcaseworld
in briefcaseworld  a number of portables must be transported  where the transportation is
done via conditional effects of the move actions  there are three operators  putting in a
portable at a location can be done if the portable and the briefcase are at the respective
location  and the portable is not yet inside  taking a portable out can be done if it is inside 
a move can be applied between two locations  and achieves  beside the is at fact for the
briefcase  the respective at facts for all portables that are inside  i e   the portables inside
are moved along by conditional effects   the goal is to have the briefcase  and a subset of
the portables  at their goal locations 
b   blocksworld no arm
blocksworld no arm is a variant of the widely known blocksworld domain  there are three
operators  one can move a block from the table onto another block  one can move a block
from another block to the table  one can move a block from another block onto a third
block  the initial state of an instance specifies the initial positions of the blocks  the goal
state specifies a  consistent  i e   cycle free  set of on facts 
b   blocksworld arm
the instances of blocksworld arm are the same as those of blocksworld no arm  the difference is that blocks are moved via a single robot arm that can hold one block at a time 
there are four operators  one can pickup a block that is on the table  one can put a block 
that the arm is holding  down onto the table  one can unstack a block from some other
block  finally  one can stack a block  that the arm is holding  onto some other block 
b   depots
the depots domain is a kind of mixture between logistics and blocksworld arm  there is
a set of locations  a set of trucks  a set of pallets  a set of hoists  and a set of crates  the
trucks can transport crates between locations  the hoists can be used to stack crates onto
other crates  or onto pallets  there are six operators  to move a truck between  different 
locations  to load a crate that is held by a hoist onto a truck at a location  to unload a
crate with a hoist from a truck at a location  to lift a crate with a hoist from a surface  a
pallet or a crate  at a location  and to drop a crate that is held by a hoist onto a surface at
a location  a hoist can hold only one crate at a time  the crates are initially arranged in
arbitrary stacks  where the bottom crate in each stack is standing on a pallet  the goal is
to arrange the crates in some other arbitrary stacks on  possibly  other pallets  which can
involve transporting crates to other locations  as pallets can not be moved  
   

fihoffmann

b   dining philosophers
dining philosophers is an encoding of the well known dining philosophers problem  where
the task for the planner is to find the deadlock situation that arises when every philosopher
has taken up a single fork  the pddl domain was created by an automatic translation
from the automata based promela language  the automata are also referred to as processes 
in promela  each philosopher is a finite automaton process that works as follows  from the
start state  state    a transition puts the right fork onto the table  this is just an initialization
step   getting him to state    then there is a loop of four states  from state   to state
   the philosopher takes up the right fork  from   to    he takes up the left fork    to  
he puts down the right fork  in state   he puts down the left fork and gets back to state
   each such process communicates with each of its neighbors through a communication
channel  a queue  that either contains a fork  or is empty  if one of the adjacent philosophers
is currently holding that fork  
in the pddl encoding  each process state transition is broken down into four actions 
the first action activates the chosen transition  the second action initiates a write or read
command to the needed queue  deleting the activation of the transition and setting flags for
queue update  the third action updates  if possible  the queue contents  an update is not
possible if a write command shall be done to a full queue  a queue that already contains a
fork   or if a read command shall be done to an empty queue  the fourth action wraps the
process state transition up  re setting all flags 
derived predicates are used to model the conditions under which a process is blocked 
the rules require that all outgoing transitions of the current state of the process are blocked 
a transition is blocked if it is activated  and would need to perform an impossible queue
write read operation  in the sense that this impossible write read operation has not yet
been initiated    after applying the planning action initiating the impossible write read
command  the blocking rules dont apply anymore and so the resulting state is a dead end
in the planning tasks state space  but not a blocking situation in the process network 
according to the derived predicate rules modeling the blocking  
we remark that  in ipc    there was also a version of dining philosophers that modeled
process blocking via additional planning operators  not derived predicates  we chose to
consider the other  above  domain version since it constitutes the more natural and concise
formulation  and since planners at ipc   scaled further up in it than in the version without
derived predicates 
b   driverlog
driverlog is a variation of logistics  where drivers are needed for the trucks  and where
drivers and trucks can move along arbitrary  bi directional  road maps  the road maps for
drivers and trucks can be different  there are operators to load unload an object onto from
a truck at a location  to board disembark a driver onto from a truck at a location  to walk
    only one outgoing transition can be activated at any time  so a process can never become blocked in a
state with more than one outgoing state transition  this appears to be a bug in the translation from
promela to pddl  the more intuitive requirement would be that only the activated transition needs
to be blocked  or that an outgoing transition does not need to be activated in order to be blocked  note
that  in dining philosophers  every automaton state has just one outgoing transition 

   

fiwhere ignoring delete lists works

a driver from a location to another one  and to drive a truck with a driver from a location
to another one  the preconditions and effects of loading unloading objects are the obvious
ones  a driver can board a truck only if the truck is empty  in effect  the truck is no longer
empty  as well as driven by the driver   disembarking a driver is the inverse action  in
order to walk a driver from l to l    there must be a path between l and l    in order to drive
a truck from l to l    there has to be a link from l to l   and there must be a driver on the
truck   paths and links form arbitrary  in particular  potentially different  graphs over the
locations  the only restriction being that they are undirected  i e   if a truck or driver can
move from l to l  then it can also move back  this restriction is imposed on the driverlog
instances as can be generated with the ipc   generator 
b   ferry
in ferry  a single ferry is used to transport cars between locations  one at a time  there are
three operators  one can sail the ferry between two locations  one can board a car onto
the ferry at a location  which deletes an empty ferry fact  plus adding that the car is on
the ferry and deleting that the car is at the location   one can debark a car from the ferry
at a location  which achieves empty ferry  plus adding that the car is at the location and
deleting that the car is on the ferry   the goal is to have a subset of the cars at their goal
locations 
b    freecell
the freecell domain is a strips formulation of the widely known solitaire card game
that comes with microsoft windows  a number of cards from different suits are initially
arranged in random stacks on a number of columns  the cards must be put home  for each
suit of cards  there is a separate home column  on which the cards from that suit must be
stacked in increasing order of card value  there is a number of free cells  the cards can be
moved around according to certain rules  a card is clear if it has no other card on top of
it  any clear card can be put into a free cell  if its not already there   each free cell holds
only one card at a time  any clear card can be moved onto an empty column  a clear card
c can be put home if the last card put home in the same suit was the one preceding c  if c
and c  are clear cards from differently colored suits  then one can stack c on top of c  if c  is
not in a free cell  and cs card value is one less than the card value of c   so stacks can only
be built on columns  in decreasing order of card value  and in alternating colors   the goal
is reached when the topmost cards of all suits have been put home 
b    fridge
in fridge  one must replace the broken compressor in a fridge  to do this  one must remove
the compressor  this involves unfastening the screws that hold the compressor  which in
turn involves first switching the fridge off  the goal is to have the new compressor attached
to the fridge  all screws fastened  and the fridge switched back on  the origin of this domain
is a strips formulation  we consider an adaptation that allows for an arbitrary number of
fridges and screws  where each compressor is fastened by the same  arbitrary  at least one 
number of screws  the adaptation involves an adl precondition  a compressor can only be
   

fihoffmann

removed if all screws are unfastened  there are six operators  one can stop start a fridge 
one can unfasten fasten a screw from to a compressor attached to a fridge  to do so  the
fridge needs to be turned off  the compressor needs to be attached  and the screw must fit
the compressor  finally  one can remove attach a compressor from to a fridge  removing
a compressor requires that the fridge is turned off  and that none of the screws that fit the
compressor are fastened  in effect  the compressor is no longer attached to the fridge  and
both the fridge and the compressor are free  attaching a compressor requires that the fridge
is turned off  and that the compressor fits the fridge  in effect  the compressor is attached 
and the compressor and fridge are no longer free 
b    grid
in grid  a robot must move along positions that are arranged in a grid like reachability
relation  the positions can be locked  and there are keys of different shapes to open them 
the goal is to have some keys at their goal positions  there are five operators  one can
move from position p to position p    which requires  apart from the obvious preconditions 
that p and p  are connected  and that p  is open  not locked   one can pick up a key at a
position  which requires that the arm is empty  one can only hold one key at a time   and
has as effects that one holds the key  that the arm is no longer empty  and that the key
is no longer at the position  putting a key down at a position is the inverse action  one
can abbreviate the two previous actions by doing a pickup and lose of keys k and k  at a
position  to do this  one must hold k  which is directly exchanged for k    i e   the effects are
that one holds k and that k  is at the position  finally  one can unlock a position p  if one is
at a position p that is connected to p    and holds a key that has the same shape as the locked
position p    the add effect is that p  is open  the delete effect is that the position is no longer
locked  the instances specify the initial locations of all keys  of all locked positions  and
of the robot  as well as the shapes of the keys and the locked positions  the goal specifies
positions for a subset of the keys  the robot always starts at an open position  this does
make a significant difference  if the robot is allowed to start at a locked position  there can
be local minima under h      otherwise there are none  c f  theorem    intuitively  it makes
more sense to let the robot be located in open positions only  the restriction also holds true
in the published benchmark examples 
b    gripper
in gripper  the task is to transport a number of balls from one location to another  there
are three operators  one can move between locations  one can pick up a ball at a location
with a hand  apart from the obvious preconditions this requires that the hand is empty  the
effects are the obvious ones  the ball is in the hand and no longer in the room  plus that
the hand is no longer empty  one can drop a ball at a location from a hand  which inverts
the effects of the picking action  there are always exactly two locations  and two gripper
hands  instances thus differ only in terms of the number of balls  these severe restrictions
hold true in the aips      instances  we remark that adding more locations and or hands
    moving away from a locked initial position can lead to the need of applying several steps to re open that
position  the relaxed plan to the initial state does not realize this  since it ignores the delete on the
initial at fact 

   

fiwhere ignoring delete lists works

does not affect the topological properties under h    in fact the proof arguments given in
theorems       and   remain valid in this case 
b    hanoi
the hanoi domain is a strips encoding of the classical towers of hanoi problem  there
are n discs d            dn   and three pegs p    p    and p    there is a single operator that moves
an object x from an object y onto an object z  the operator parameters can be grounded
with discs as well as pegs   the preconditions of the move are that x is on y  x is clear  z
is clear  and x is smaller than z  the effects are that x is on z and y is clear  while x is no
longer on y and z is no longer clear  the semantics of towers of hanoi are encoded via the
smaller relation  this relation holds in the obvious way between the discs  and all discs are
smaller than the pegs  the pegs are not smaller than anything so they can not be moved  
the instances differ in terms of the number n of discs that must be transferred from p  to
p   
b    logistics
logistics is the classical transportation domain  where objects must be transported within
cities using trucks  and between different cities using airplanes  there are six operators  to
drive a truck between two locations within a city  to fly an airplane between two airports 
to load  unload  an object onto  from  a truck at a location  and to load  unload  an object
onto  from  an airplane at an airport  the operators all have the obvious preconditions
and effects  the most complicated operator is that moving a truck  whose precondition
requires that both locations are within the city   there is always at least one city  and each
city has a non zero number of locations one of which is an airport  there is an arbitrary
number of objects  and of airplanes  which are located at airports   the goal is to have a
subset of the objects at their goal locations 
b    miconic adl
miconic adl is an adl formulation of a complex elevator control problem occurring in a
real world application of planning  koehler   schuster         a number of passengers are
waiting at a number of floors to be transported with a lift  obeying a variety of constraints 
there is always at least one floor  and an arbitrary number of passengers  each of which is
given an origin and a destination floor  there are three operators  the lift can move up
from floor f to floor f if f is  transitively  above f  and vice versa for moving downwards 
the lift can also stop at a floor  when it does so at floor f  by conditional effects of the
stopping action all passengers waiting at f are boarded  and all passengers wanting to get
out at f depart  the goal is to serve all passengers  i e   to bring them to their destination
floor  the constraints that must be obeyed are the following 
 in some cases  a passenger p has no access to a floor f  the lift can then not stop at f
while p is boarded 
 some passengers are vips  as long as these are not all served  the lift can only stop
at floors where a vip is getting on or off 
   

fihoffmann

 some passengers must be transported non stop  i e   if they are boarded  the lift can
make no intermediate stops before stopping at their destination floor 
 some passengers can not travel alone  others can attend them  if one of the former
kind is boarded  then so must be at least one of the latter kind 
 there are groups a and b of passengers such that it is not allowed to have people
from both groups boarded simultaneously 
 some passengers can only be transported in the direction of their own travel  i e   if
they need to go up  down   then  while they are boarded  the lift can not move
downwards  upwards  
all of these constraints are formulated by means of complex first order preconditions of
the operators 
b    miconic simple
the miconic simple domain is the same as miconic adl described above  except that
there are no constraints at all 
b    miconic strips
the miconic strips domain is almost the same as the miconic simple domain  see above 
the only difference is that boarding and departing passengers is not done by conditional
effects of a stopping operator  but explicitly by separate strips operators  one can board
a passenger at a floor  the precondition is that the  current  floor is the passengers origin 
and the only effect is that the passenger is boarded  one can let a passenger depart at a
floor  the preconditions are that the  current  floor is the passengers destination and that
the passenger is boarded  and the effects are that the passenger is served but no longer
boarded 
b    movie
in movie  the task is to prepare for watching a movie  there are seven different operators 
one can rewind the tape  which adds that the tape is rewound  and deletes that the counter
is at zero  one can reset the counter  the only effect being that the counter is at zero  one
can get five different kinds of snacks  the only  add  effect being that one has the respective
snack  instances differ only in terms of the number of items that there are of each sort of
snacks  the goal is always to have one snack of each sort  to have the tape rewound  and
to have the counter at zero 
b    mprime
mprime is a transportation kind of domain  where objects must be transported between
locations by means of vehicles  and vehicles use non replenishable fuel  in an instance 
there are a set l of locations  a set o of objects  and a set v of vehicles  there also are
sets f and s of fuel numbers and space numbers  each location initially has a certain fuel
   

fiwhere ignoring delete lists works

number  the number of fuel items available at the location  and each vehicle has a certain
space number  the number of objects the vehicle can carry at a time  there are operators
to move vehicles between locations  to load  unload  objects onto  from  vehicles  and to
transfer fuel units between locations  a move from location l to location l  can only be
made if l and l  are connected  where the connection relation is an arbitrary graph   and if
there is at least one fuel unit available at l  l has a fuel number that has a lower neighbor  
in effect of the move  the respective vehicle is located at l    and the amount of fuel at l is
decreased by one unit  i e   l is assigned the next lower fuel number  in a similar fashion  an
object can only be loaded onto a vehicle if there is space for that  and in effect the available
space decreases  unloading the object frees the space again  the transfer operator can
transfer one fuel unit from location l to location l    if l and l  are connected  and l has at
least two fuel units left  as the result of applying the operator  ls fuel number decreases by
one  while l  s fuel number increases by one  note that there is no way to re gain fuel items
 one can transfer them around but one can not obtain new ones   the goal is to transport
a subset of the objects to their goal locations 
b    mystery
mystery is exactly the same as the mprime domain described above  except that there is
no operator to transfer fuel items 
b    optical telegraph
like the dining philosophers domain described above in appendix b    optical telegraph
is a pddl compilation of a problem originally formulated in the automata based promela
language  the mechanics of the pddl compilation are the same as in dining philosophers 
using derived predicates to detect blocked situations  the problem involves n pairs of communicating processes  each pair featuring an up and a down process  such a pair can go
through a fairly long  heavily interactive  sequence of operations  implementing the possibility to exchange data between the two stations  before data is exchanged  various initializing
steps must be taken  to ensure the processes are working synchronously  most importantly 
each of the process writes a token into a control channel  queue  at the beginning of
the sequence  and reads the token out again at the end  this causes a deadlock situation
because there are only n control channels  each of which is accessed by two processes  more
precisely  the process pairs are arranged in a cycle  where between each pair there is a control channel  the overall system is blocked iff all process pairs are in a state where they
have occupied  written into  one control channel  and are waiting to occupy the other  in
that sense  optical telegraph can be viewed as a version of dining philosophers where the
internal states of the philosophers are more complicated  in particular  the philosophers
 process pairs  here can choose in which order to pick up the forks  occupy the control
channels   as it turns out  see appendix a    the latter has an important impact on the
topology under h   
we remark that  in ipc    there was also a version of optical telegraph that modeled
process blocking via additional planning operators  not derived predicates  we chose to
consider the other  above  domain version since it constitutes the more natural and concise
   

fihoffmann

formulation  and since planners at ipc   scaled further up in it than in the version without
derived predicates 
b    pipesworld
in pipesworld  units of oil derivatives  called batches  must be propagated through a
pipeline network  the network consists of areas connected with pipe segments of different
length  the pipes are completely filled with batches at all times  and if one pushes a batch
in at the one end of a pipe  the last batch currently in that pipe comes out at the other end 
there can be interface restrictions concerning the types of oil derivatives that are allowed
to be adjacent to each other inside a pipe  and there can be tankage restrictions concerning
the number of batches  of each derivative type  that can be stored at any point in time in
the individual areas 
the only available planning operator is to push a batch into a pipe  in the ipc  encoding of the domain  which we look at here  for non unitary pipe segments  pipes
containing more than one batch  this operator is split into two parts  a start and a finish
action  in order to reduce the number of operator parameters needed to correctly update the
pipe contents   also  pipe segments are encoded in a directed fashion  making it necessary
to distinguish between  symmetrical  push and pop actions  the initial state specifies the
current batch positions etc   the goal specifies what batches have to be brought to what
areas 
b    psr
in the psr domain  as used in ipc    the task is to re supply a given set of lines in a faulty
electricity network  the nodes of the network are breakers  which feed electricity into
the network  and devices  which are just switches that can be used to change the network
configuration  the edges in the network are the lines  each connecting two or three nodes 
the breakers and devices can be open or closed  if they are open  then they disconnect the
lines adjacent to them  if breakers are closed  then they feed electricity into the adjacent
lines  some of the lines are faulty  the goal is to ensure that none of the breakers is
affected  i e   feeds electricity into a faulty line  through the transitive connections in the
network  also  the goal requires that each of the given set of lines is  transitively  fed with
electricity from some breaker 
the transitive network semantics  determining if a breaker feeds electricity into some
line  and if a breaker is affected  are modeled by means of various derived predicates  with
recursive rule antecedents to enable the computation of transitive closure   there are three
planning operators  one can open a device or breaker that is currently closed  and one
can do the inverse closing action  both actions require as a precondition that no breaker
is currently affected  if the latter is untrue  i e   if a breaker is currently affected  then the
only available action is to wait  its effect is to open all breakers that are affected 
we remark that  in ipc    there was also a different version of psr  formulated in
pure strips without derived predicates  that version constitutes  however  a relatively
superficial pre compiled form of the domain  hoffmann   edelkamp        edelkamp et al  
       it was included in ipc   only in order to provide the pure strips planners with a
   

fiwhere ignoring delete lists works

domain formulation they could tackle  the pre compilation was necessary in order to enable
the formulation in pure strips  
b    rovers
in rovers  a number of rovers must navigate through a road map of waypoints  take rock
and soil samples as well as images  and communicate the data to a number of landers  the
nine available operators are the following  one can navigate a rover from one waypoint
to another  to do this  the waypoints must be connected for the rover  one can sample
soil rock with a rover at a waypoint using a store  to do so  the rover must have the
 empty  store and be equipped for soil rock analysis  and there must be soil rock to sample
at the waypoint  in effect one has the soil rock analysis  the store is full  and the soil rock
sample is no longer at the waypoint  one can empty a full store by dropping the store  one
can calibrate a camera at a waypoint using an objective  and one can take an image of an
objective in a mode with a camera at a waypoint  for both operators  the object must be
visible from the waypoint  and the camera must be on board a rover that is equipped for
imaging  to calibrate the camera  the object must be a calibration target for it  the only
effect of the operator is the calibration of the camera  to take an image  the camera must
be calibrated  and support the required mode  the effects are that one has the image data 
and that the camera is no longer calibrated  finally  there are three operators with which
a rover can communicate soil rock image data to a lander  to do so  the landers waypoint
must be visible from that of the rover  the only effect is that the data is communicated 
the instances are restricted in that the visibility and connectivity between waypoints are
bi directional  if waypoint w is visible from waypoint w  then the same holds true vice
versa  if a rover can move from w to w  then it can also move back  another restriction is
that no camera is initially calibrated  this serves to make sure that  in a reachable state 
each calibrated camera has at least one calibration target   both restrictions are imposed
on the rovers instances as can be generated with the ipc   generator 
b    satellite
in satellite  satellites need to take images in different directions  in certain modes  using
appropriate instruments  there is a number of satellites  a number of directions  a number
of instruments  and a number of modes  there are the following five operators  one can
turn a satellite from a direction to another one  the preconditions and effects are the obvious
ones  the action can be applied between any pair of directions  no connectivity constraints  
one can switch on an instrument on board a satellite  if the satellite has power available  in
effect  the instrument has power but is no longer calibrated  and the satellite has no more
power available  one can switch off an instrument on board a satellite  if the instrument
has power  in effect  the satellite has power available  but the instrument not anymore 
one can calibrate an instrument on board a satellite in a direction  if the satellite points
into the direction  the instrument has power  and the direction is a calibration target for
the instrument  the only effect is the calibration of the camera  finally  one can take an
image with an instrument on board a satellite in a direction and a mode  to do so  the
satellite must point into the direction  and the camera must support the mode  have power 
and be calibrated  the only effect is that one has an image of the direction in the mode 
   

fihoffmann

the goal is to have images of a number of direction mode pairs  also  satellites can have a
goal requirement to point into a specified direction  the initial states are such that each
satellite  but no instrument  has power available  and no instrument is calibrated  the
former restriction makes sure that each satellite has the power to run one instrument at a
time  the latter restriction makes sure that  in a reachable state  each calibrated instrument
has at least one calibration target  both restrictions are imposed on the satellite instances
as can be generated with the ipc   generator 

b    schedule
in schedule  a collection of objects must be processed on a number of machines  applying
working steps that change an objects shape  surface condition  or color  one can also drill
holes of varying widths in varying orientations  there are nine operators  eight of these
describe working steps for an object o on a machine  amongst other things  these operators
preconditions require that o is not scheduled elsewhere and that the machine is not busy 
and these operators effect is that o is scheduled  and that the machine is busy  the ninth
operator does a time step  whose effect is that no object is scheduled  and no machine is
busy  any longer  one can apply a do roll action to an object o  which makes o cylindrical
and hot  no longer cold  see also below   while deleting any surface conditions  colors  and
holes that o might have  one can apply a do lathe to o  making it cylindrical with a rough
surface  and deleting any colors that o might have been painted in before  one can apply
a do polish to o if it is cold  giving it a polished surface  one can apply a do grind to o 
giving it a smooth surface with no colors  one can apply a do punch to o  with width w in
orientation o  if o is cold  resulting in o having a hole in w and o  and a rough surface  one
can also apply a do drill press to o  if o is cold  making a hole of width w and orientation
o into o  changing none of os properties except making the hole   if o is cold  then one
can also apply a do spray paint in color c  deleting all surface conditions that o might have 
finally  one can apply a do immersion paint to o  changing none of os properties except
the color  note that there is no operator that can change os temperature  except do roll
which makes o hot  after that  o can not be made cold again  this is the reason why dead
ends can arise  c f  theorem     initially  all objects are cold  and have a shape and a
surface condition specified  some of the objects are also painted initially  and an object
can have none or several holes  in the goal condition  some of the objects can be required
to have cylindrical shape  the only shape that can be produced by the machines   some
need a surface condition  some must be painted  and each object can be required to have
an arbitrary number of holes 

b    simple tsp
simple tsp is a trivial version of the tsp problem  there is a single operator to move
between locations  this can be applied between any two  different  locations  and the effect
 besides the obvious ones  is that the destination location is visited  the instances specify
a number of locations that must all be visited  starting in one of them 
   

fiwhere ignoring delete lists works

b    tireworld
in tireworld  one must replace a number of flat tires  this involves a collection of objects
that must be used in the appropriate working steps  briefly summarized  the situation is as
follows  there are thirteen operators  there is a boot that can be either opened or closed 
it is initially closed and shall be so in the end  there are a pump  a wrench  and a jack
which can be fetched or put away  from into the boot   they are initially in the boot and
shall be put back in the end  the spare wheels are initially not inflated  and can be inflated
using the pump  the add effect is that the wheel is inflated  the delete effect is that it is no
longer not inflated   each hub is fastened with nuts  these can be loosened or tightened 
using the wrench  while the respective hub is on ground  the jack can be used to either
jack up or jack down a hub  once a hub is jacked up  one can undo the  loose  nuts  or do
them up  if the nuts are undone  one can remove the respective wheel  or put on one  an
optimal solution plan is this  open the boot  fetch the tools  inflate all spare wheels  loosen
all nuts  in turn jack up each hub  undo the nuts  remove the flat wheel  put on the spare
wheel  do up the nuts  and jack the hub down again  tighten all nuts  put away the tools 
and close the boot 
b    zenotravel
zenotravel is a transportation domain variant where the vehicles  called aircrafts  use fuel
units that can be replenished using a refueling operator  there are a number of cities  a
number of aircrafts  a number of persons  and a number of different possible fuel levels 
the fuel levels encode natural numbers by a next predicate  next f f    is true iff f  is the
next higher fuel level than f  the task is to transport a subset of the persons from their
initial locations to their goal locations  there are the following five operators  one can
board debark a person onto from an aircraft at a city  this has just the obvious preconditions and effects  one can fly an aircraft from a city to a different city  decreasing the
aircrafts fuel level from f to f    f must be the aircrafts current fuel level  and f  must be the
next lower level  one can also zoom the aircraft  this is exactly the same as flying it  except
that zooming uses more fuel  the aircrafts fuel level is decreased by two units  finally 
one can refuel an aircraft at a city from fuel level f to fuel level f    the conditions are that
f is the aircrafts current fuel level  and that f  is the next higher level  thus aircrafts can
be refueled at any city  and in steps of one unit 

references
bacchus  f          the aips   planning competition  the ai magazine               
biundo  s     fox  m   eds            recent advances in ai planning   th european
conference on planning  ecp     lecture notes in artificial intelligence  durham 
uk  springer verlag 
blum  a  l     furst  m  l          fast planning through planning graph analysis  in
mellish  s   ed    proceedings of the   th international joint conference on artificial
intelligence  ijcai      pp            montreal  canada  morgan kaufmann 
   

fihoffmann

blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence                   
bonet  b     geffner  h          planning as heuristic search  new results   in biundo   
fox  biundo   fox         pp       
bonet  b     geffner  h       a   heuristic search planner      the ai magazine         
     
bonet  b     geffner  h       b   planning as heuristic search  artificial intelligence 
              
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism
for planning  in kuipers  b  j     webber  b   eds    proceedings of the   th national
conference of the american association for artificial intelligence  aaai      pp 
        portland  or  mit press 
botea  a   muller  m     schaeffer  j          using component abstraction for automatic
generation of macro actions   in koenig et al   koenig  zilberstein    koehler        
pp         
botea  a   muller  m     schaeffer  j          learning partial order macros from solutions 
in biundo  s   myers  k     rajan  k   eds    proceedings of the   th international
conference on automated planning and scheduling  icaps      pp          monterey  ca  usa  morgan kaufmann 
brazdil  p     jorge  a   eds     epia            proceedings of the   th portuguese conference on artificial intelligence  epia      porto  portugal  springer verlag 
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence                  
cesta  a     borrajo  d   eds            recent advances in ai planning   th european
conference on planning  ecp     lecture notes in artificial intelligence  toledo 
spain  springer verlag 
chen  y   hsu  c     wah  b          sgplan  subgoal partitioning and resolution in
planning   in edelkamp et al   edelkamp  hoffmann  littman    younes        
chen  y     wah  b          automated planning and scheduling using calculus of variations
in discrete space   in giunchiglia et al   giunchiglia  muscettola    nau         pp 
    
chien  s   kambhampati  r     knoblock  c   eds     aips            proceedings of the
 th international conference on artificial intelligence planning systems  aips     
breckenridge  co  aaai press  menlo park 
do  m  b     kambhampati  s          sapa  a domain independent heuristic metric
temporal planner   in cesta    borrajo  cesta   borrajo         pp         
edelkamp  s       a   promela planning  in ball  t     rajamani  s   eds    proceedings
of the   th international spin workshop on model checking of software  spin     
pp          portland  or  springer verlag 
edelkamp  s       b   taming numbers and durations in the model checking integrated
planning system  journal of artificial intelligence research             
   

fiwhere ignoring delete lists works

edelkamp  s     helmert  m          mips  the model checking integrated planning system 
ai magazine               
edelkamp  s   hoffmann  j   englert  r   liporace  f   thiebaux  s     trug  s         
engineering benchmarks for planning  the domains used in the deterministic part of
ipc    journal of artificial intelligence research  submitted 
edelkamp  s   hoffmann  j   littman  m     younes  h   eds     ipc            proceedings
of the  th international planning competition  whistler  bc  canada  jpl 
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificial intelligence research            
fox  m     long  d          stan   a hybrid planning strategy based on subproblem
abstraction  the ai magazine               
frank  j   cheeseman  p     stutz  j          when gravity fails  local search topology 
journal of artificial intelligence research            
gazen  b  c     knoblock  c          combining the expressiveness of ucpop with the
efficiency of graphplan   in steel    alami  steel   alami         pp         
gerevini  a     schubert  l          inferring state constraints in discoplan  some new
results   in kautz    porter  kautz   porter         pp         
gerevini  a     schubert  l          discoplan  an efficient on line system for computing
planning domain invariants   in cesta    borrajo  cesta   borrajo         pp     
    
gerevini  a   saetti  a     serina  i          planning through stochastic local search and
temporal action graphs  journal of artificial intelligence research             
gerevini  a     serina  i          lpg  a planner based on local search for planning graphs
with action costs   in ghallab et al   ghallab  hertzberg    traverso         pp 
     
gerevini  a   serina  i   saetti  a     spinoni  s          local search techniques for temporal
planning in lpg   in giunchiglia et al   giunchiglia et al          accepted for
publication 
ghallab  m   hertzberg  j     traverso  p   eds     aips            proceedings of the  th
international conference on artificial intelligence planning and scheduling  aips     toulouse  france  morgan kaufmann 
giunchiglia  e   muscettola  n     nau  d   eds     icaps            proceedings of the
  th international conference on automated planning and scheduling  icaps     
trento  italy  morgan kaufmann 
haslum  p     geffner  h          admissible heuristics for optimal planning   in chien
et al   chien  kambhampati    knoblock         pp         
helmert  m          complexity results for standard benchmark domains in planning 
artificial intelligence              
helmert  m          a planning heuristic based on causal graph analysis   in koenig et al 
 koenig et al          pp         
   

fihoffmann

helmert  m     richter  s          fast downward  making use of causal dependencies in
the problem representation   in edelkamp et al   edelkamp et al         
hoffmann  j          a heuristic for domain independent planning and its use in an enforced
hill climbing algorithm  in ras  z  w     ohsuga  s   eds    proceedings of the   th
international symposium on methodologies for intelligent systems  ismis      pp 
        charlotte  nc  springer verlag 
hoffmann  j       a   ff  the fast forward planning system  the ai magazine         
     
hoffmann  j       b   local search topology in planning benchmarks  an empirical analysis   in nebel  nebel         pp         
hoffmann  j          extending ff to numerical state variables  in harmelen  f  v   ed   
proceedings of the   th european conference on artificial intelligence  ecai      pp 
        lyon  france  wiley 
hoffmann  j       a   the metric ff planning system  translating ignoring delete lists
to numeric state variables  journal of artificial intelligence research             
hoffmann  j       b   utilizing problem structure in planning  a local search approach 
vol       of lecture notes in artificial intelligence  springer verlag 
hoffmann  j       c  
where ignoring delete lists works  local search topology in planning benchmarks 
tech  rep       albert ludwigs universitat 
institut fur informatik  freiburg  germany 
available at http   www mpiinf mpg de hoffmann papers jair  report ps gz 
hoffmann  j     edelkamp  s          the deterministic part of ipc    an overview  journal
of artificial intelligence research  to appear 
hoffmann  j     nebel  b       a   the ff planning system  fast plan generation through
heuristic search  journal of artificial intelligence research             
hoffmann  j     nebel  b       b   rifo revisited  detecting relaxed irrelevance   in cesta 
  borrajo  cesta   borrajo         pp         
kautz  h  a     porter  b   eds     aaai            proceedings of the   th national
conference of the american association for artificial intelligence  aaai      austin 
tx  mit press 
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
koehler  j     schuster  k          elevator control as a planning problem   in chien et al 
 chien et al          pp         
koenig  s   zilberstein  s     koehler  j   eds     icaps            proceedings of the
  th international conference on automated planning and scheduling  icaps     
whistler  canada  morgan kaufmann 
long  d     fox  m          automatic synthesis and use of generic types in planning   in
chien et al   chien et al          pp         
   

fiwhere ignoring delete lists works

long  d     fox  m          the  rd international planning competition  results and
analysis  journal of artificial intelligence research          
mcdermott  d          a heuristic estimator for means ends analysis in planning  in drabble  b   ed    proceedings of the  rd international conference on artificial intelligence
planning systems  aips      pp          aaai press  menlo park 
mcdermott  d          the      ai planning systems competition  the ai magazine 
             
mcdermott  d  v          using regression match graphs to control search in planning 
artificial intelligence                    
nebel  b   ed     ijcai            proceedings of the   th international joint conference
on artificial intelligence  ijcai      seattle  washington  usa  morgan kaufmann 
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts and operators in
plan generation   in steel    alami  steel   alami         pp         
nguyen  x     kambhampati  s          extracting effective and admissible heuristics from
the planning graph   in kautz    porter  kautz   porter         pp         
nguyen  x     kambhampati  s          reviving partial order planning   in nebel  nebel 
       pp         
onaindia  e   sapena  o   sebastia  l     marzal  e          simplanner  an executionmonitoring system for replanning in dynamic worlds   in brazdil    jorge  brazdil  
jorge         pp         
penberthy  j  s     weld  d  s          ucpop  a sound  complete  partial order planner
for adl  in nebel  b   swartout  w     rich  c   eds    principles of knowledge
representation and reasoning  proceedings of the  rd international conference  kr     pp          cambridge  ma  morgan kaufmann 
refanidis  i     vlahavas  i          grt  a domain independent heuristic for strips
worlds based on greedy regression tables   in biundo    fox  biundo   fox        
pp       
refanidis  i     vlahavas  i          the grt planning system  backward heuristic construction in forward state space planning  journal of artificial intelligence research 
           
rintanen  j          an iterative algorithm for synthesizing invariants   in kautz    porter
 kautz   porter         pp         
sebastia  l   onaindia  e     marzal  e          stella  an optimal sequential and parallel
planner   in brazdil    jorge  brazdil   jorge         pp         
srivastava  b   nguyen  x   kambhampati  s   do  m  b   nambiar  u   nie  z   nigenda  r  
  zimmermann  t          altalt  combining graphplan and heuristic state search 
the ai magazine               
steel  s     alami  r   eds            recent advances in ai planning   th european conference on planning  ecp     vol       of lecture notes in artificial intelligence 
toulouse  france  springer verlag 
   

fihoffmann

thiebaux  s   hoffmann  j     nebel  b          in defence of pddl axioms  in gottlob  g 
 ed    proceedings of the   th international joint conference on artificial intelligence
 ijcai      pp          acapulco  mexico  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          in defence of pddl axioms  artificial
intelligence  to appear 
younes  h     simmons  r          on the role of ground actions in refinement planning  
in ghallab et al   ghallab et al          pp       

   

fi