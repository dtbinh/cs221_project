journal artificial intelligence research                 

submitted        published      

engineering note
mgpt  probabilistic planner based heuristic search
blai bonet

bonet ldc usb ve

departamento de computacion
universidad simon bolvar  venezuela

hector geffner

hector geffner upf edu

icrea   universitat pompeu fabra
paseo de circunvalacion    barcelona        spain

abstract
describe version gpt planner used probabilistic track  th
international planning competition  ipc     version  called mgpt  solves markov
decision processes specified ppddl language extracting using different classes
lower bounds along various heuristic search algorithms  lower bounds
extracted deterministic relaxations alternative probabilistic effects
action mapped different  independent  deterministic actions  heuristic search
algorithms use lower bounds focusing updates delivering consistent
value function states reachable initial state greedy policy 

   introduction
mgpt planner based heuristic search solving markov decision processes  mdps 
specified high level planning language ppddl  mgpt captures fragment
functionality gpt system handles non determinism incomplete information 
qualitative probabilistic forms  including pomdps conformant planning
 bonet   geffner        
mgpt supports several algorithms admissible heuristic functions  lower bounds 
combined generate wide range solvers  main algorithms lrtdp
hdp  heuristic search algorithms solving mdps make use lower bounds
computing consistent value function v   function bellman residuals bounded
user provided parameter states reachable given initial state s 
greedy policy based v  bonet   geffner      b      a  
lower bounds derived solving relaxations input problem  since algorithms solving relaxations based heuristic search  implemented
stackable software components created sequence computing complex heuristic functions simpler ones 

   algorithms
divide algorithms two groups  deliver consistent value functions
respect user provided parameter   select actions real time  first

c
    
ai access foundation  rights reserved 

fibonet   geffner

class algorithms compute  consistent value function v states reachable
initial state s    greedy policy v based v  
following subsection  give definitions admissible consistent value functions  greedy  partial proper policies  then  present algorithms implemented
mgpt 
    consistent value functions  greedy  partial proper policies
value function v admissible non overestimating  i e  value v  s 
state lower bound optimal expected cost starting s  v  consistent
state bellman residual s 



x


def
 
 

r s    fiv  s  min c s  a   
p r s  s  a v  s    
   
aa s 

s 

less equal   here  a s  denotes actions applicable s  c s  a 
cost applying action s  p r   probabilistic transition function  v
  consistent s  say v consistent s 
state reachable initial state s  policy exists trajectory
s    s            sn sn   p  sk    sk    sk          k   n  words 
state reached positive probability s  zero steps using
policy  
known greedy policy v based value function v   defined


x
def
 
 
v  s    argmin c s  a   
p r s  s  a v  s    
   
aa s 

s 

optimal v  consistent states sufficiently small   yet  since goal
find optimal policy respect initial state s  states reachable
it  sufficient v admissible  consistent states reachable
s  v  
partial policy policy doesnt need defined states  closed
respect state defined states reachable  
proper respect goal state reached every state reachable
  finally proper proper respect states 
    algorithms compute  consistent value functions
first group algorithms  mgpt implements value iteration  vi   labeled realtime dynamic programming  lrtdp   heuristic dynamic programming  hdp  
value iteration  bertsekas        applied states reached
given initial state available operators  yields  consistent value function
them   mgpts vi serves bottom line reference comparison
algorithms 
   undiscounted problems probabilistic planning  conditions neeeded order
vi finish  consistent value function  bertsekas        

   

fimgpt  probabilistic planner based heuristic search

labeled real time dynamic programming  bonet   geffner      b  heuristicsearch algorithm implements labeling scheme top rtdp algorithm  barto 
bradtke    singh        improve convergence  lrtdp works performing simulated
trials start initial state end solved states  selecting actions according
greedy policy v successor states according corresponding transition
probabilities  initially  v input heuristic function  solved states
goal states  then  time action picked state s  value updated
making consistent value successors  end trial  labeling
procedure called checks whether new states labeled solved  state solved
value value descendents  consistent  algorithm ends
initial state labeled solved  point states reachable initial state
s  greedy policy v  consistent  labeling mechanism guarantees
v proper partial policy respect s   
heuristic dynamic programming  bonet   geffner      a  second heuristic search
algorithm supported mgpt solving mdps  hdp performs systematic depth first
searches set states reachable initial state s  greedy policy
v looking  inconsistent states updating values  top search 
labeling scheme based tarjans strongly connected components procedure  tarjan 
       identifies states solved need revisited  initial
value function given heuristic function  algorithm ends initial state
solved  lrtdp  labeling mechanism guarantees v proper respect
s   
    algorithms real time action selection
second class algorithms attempt solve given mdp  rather select
actions real time limited amount processing without offering guarantees
quality resulting policies  algorithms group include extension
action selection planning algorithm  asp   bonet  loerincs    geffner       
probabilistic domains  basically rtdp algorithm lookahead  asp  rtdp 
performs value function updates states cannot get trapped loop  thus 
although policy delivered asp suboptimal  proper policy  i e  policy
guaranteed reach goal state 

   heuristics
algorithms assume initial value function given heuristic function
provides good cost estimates  particular  lrtdp hdp expect heuristic
admissible  described pearl         informative admissible heuristics
obtained solving suitable relaxations input problem  two relaxations
supported mgpt  min min relaxation  strips relaxation  first defines
 deterministic  shortest path problem original state space  second used define
 deterministic  shortest path problems atom space   thus  first solved
   atoms refer propositional symbols used representation language  ppddl case 
define problem  number atoms polynomial size input  size
state space is  general  exponential number atoms 

   

fibonet   geffner

time polynomial number states  shortest path problems defined second
solved time polynomial number atoms  methods yield lower bounds
expected cost goal given state  yet bounds produced min min
relaxation stronger produced strips relaxation 
    min min state relaxation
idea behind min min relaxation transform input probabilistic problem 
described bellman equations


x
def

 
 
v  s    min c s  a   
p r s  s  a v  s    
   
aa s 

s 

deterministic shortest path problem bellman equations form 

vmin
 s   

def


min c s  a    min  vmin
 s      p  s   s  a        

   

aa s 

level representation language  min min relaxation built transforming probabilistic operator form 
  h     p                pn   n    

   

precondition ith probabilistic effect  with probability
pi    set independent deterministic operators form 
oi   h    

  n 

   

thus  min min relaxation one actually choose convenient non deterministic effect operator  hence  cost relaxation lower bound
expected cost original probabilistic problem 
min min relaxation deterministic problem solved means
standard path finding algorithms  example  solved dijkstras algorithm 
a   ida   deterministic version lrtdp  i e  labeled lrta algorithm  korf         
mgpt provides two methods computing min min heuristic relaxation 
min min ida   uses ida   min min lrtdp  uses lrtdp  versions
lazy sense heuristic values states computed needed
planner requires them 
    strips relaxation
strips relaxation turn converts deterministic problem obtained min min
relaxation strips problem  obtains lower bounds original mdp
computing lower bounds resulting strips problem using methods developed
classical planning  e g   bonet   geffner        haslum   geffner        hoffmann   nebel 
      edelkamp        nguyen   kambhampati         methods run polynomial
time number atoms yet  unlike min min relaxation  require casting minmin relaxation strips format  conversion that  conversion adl strips
 gazen   knoblock         may require exponential time space  see below  
   

fimgpt  probabilistic planner based heuristic search

mgpt  strips relaxation obtained directly original problem  first
transforming probabilistic operator form 
  h prec    p     add    del             pn    addn   deln      

   

prec  addi   deli conjunctions literals represents precondition  ith
add list  ith delete list operator respectively  pi probabilities sum
   order take operators form      disjunctive preconditions  conditional
effects  quantifiers removed described gazen knoblock        
operators form      strips relaxation generated splitting
operators n independent strips operators form 
oi   h prec  addi   deli  

  n 

   

following heuristics implemented mgpt upon strips relaxation 
first two lower bounds optimal cost strips relaxation hence
optimal  expected  cost original mdp  third one necessarily lower bound
either cost 
hm heuristics  h m   haslum   geffner        heuristics recursively
approximate cost achieving set atoms c initial state cost
achieving costly subset size c  computed shortestpath algorithm graph nodes standing sets atoms 
result values hm  s  estimate cost reaching goal state s  use
option h m k mgpt refer hm heuristic   k 
pattern database heuristics  patterndb   edelkamp        compute optimal costs
relaxations strips problem defined multi valued variables
implicit problem  e g  location block blocksworld domain
implicit multi valued variable whose possible values either table top
block   heuristic precomputed once  beginning 
provides lower bound cost arbitrary state goal  pattern
database computed projecting strips problem respect set atoms
 those define multi valued variables  solving resulting problem
optimally dijkstras algorithm  multiple pattern databases combined
either taking max sum  latter case  pattern database referred
additive   use additive pattern databases defined haslum  bonet 
geffner        constraints original problem preserved
projection  something often results stronger heuristics  patterndb k refers
pattern database heuristic defined k multi valued variables 
 ff  heuristic implements heuristic function used planner  hoffmann   nebel         computed building so called relaxed planning graph
finding plan it  heuristic number operators plan 
   conditions required adding two pattern databases result remains admissible 
sufficient condition b   sets b used build projections
respectively 

   

fibonet   geffner

relaxed planning graph version graph constructed graphplan
 blum   furst        delete lists ignored  shown computing
heuristic done polynomial time size input problem
 hoffmann   nebel         heuristic however informative non admissible 
shown below  heuristics plugged directly planning algorithm
used compute informative heuristics  example  patterndb
heuristic used within ida  solve min min relaxation  gives stronger
heuristic patterndb heuristic  thus  mgpt implements algorithms heuristics
stackable software components element stack used solve elements
it 

   implementation
section gives details implementation mgpt together examples
use  mgpt system implemented c   upon preliminary parser offered
organizers ipc   
    hash tables
perhaps important component modern search based planners internal
representation states hash tables  since mgpt uses different search algorithms
hash tables solve given instance  e g  informative heuristics computed
less informative ones   good internal representations hash table implementation
critical good performance 
grounding atoms operators  state represented ordered list
atoms hold true state  state appear associated different
data multiple hash tables simultaneously  thus  instead multiples copies
s  mgpt implements system wide state hash table stores representation
states referenced hash tables entries tables simply contain reference
state hash table  way  planner saves time space 
another issue large impact performance average number collisions
hash table  two points relevant keeping number collisions low 
hashing function size hash table  former  seen
cryptographic hashing functions md  behave well even though slower
traditional choices  latter  mgpt uses hash tables whose size equal
large prime number  cormen  leiserson    rivest        
    algorithms heuristics
algorithm mgpt implemented subclass abstract algorithm class
whose members reference problem and  cases  reference hash table
parameter   similarly  heuristic mgpt implemented subclass
abstract heuristic class whose members reference problem function
maps states non negative values  simple heuristics constant zero function
straightforward  others min min lrtdp implemented class whose members are 
addition above  references hash table lrtdp algorithm 
   

fimgpt  probabilistic planner based heuristic search

    examples
main parameters call mgpt  a  algorithm  specifies algorithm
use   h  heuristic  specifies heuristic function   e  epsilon 
specifies threshold consistency check  typical call looks like 
mgpt  a lrtdp  h h m    e       domain   problem 
instructs mgpt use lrtdp algorithm h m   heuristic        
domain problem files specified 
h m   heuristic admissible weak  following example shows
compute min min lrtdp heuristic using h m   base heuristic 
mgpt  a lrtdp  h  h m   min min lrtdp   e       domain   problem 
pipe symbol used instruct planner heuristics computed using
heuristics 
another possibility use mgpt reactive planner decisions taken
on line respect heuristic function improved time  example 
mgpt  a asp  h  domain   problem 
uses asp algorithm heuristic 
mgpt  a asp  h  zero min min ida    domain   problem 
uses asp algorithm min min ida  heuristic computed constant zero
heuristic  combinations algorithms heuristics possible  mgpt accepts
parameters control initial hash size  weight heuristic function  values dead end
states  verbosity level  lookahead settings asp  etc 

   competition
competition suite consisted   probabilistic domains named blocksworld  explodingblocksworld  boxworld  fileworld  tireworld  towers of hanoise  zeno  blocksworld
exploding blocksworld variations standard blocksworld domain classical planning  boxworld logistics like transportation domain  fileworld file folder domain
uncertainty present initial situation destination
file set  tireworld towers of hanoise variations classical tireworld domain
towers of hanoi  zeno traveling domain fuel resource 
domains come two variations  goal oriented version goal
achieved certainty minimizing expected costs  reward oriented version
involves rewards  mgpt planner handles first type tasks only 
competition used lrtdp algorithm patterndb   heuristic 
parameter          weight w     heuristic function  cases 
patterndb   heuristic poor  planner switched automatically asp
algorithm heuristic 

   

fibonet   geffner

problem name
blocksworld  
blocksworld  
blocksworld   
blocksworld   
blocksworld   
blocksworld   
exploding bw
boxworld c  b  
boxworld c   b  
boxworld c   b  
fileworld     
towers of hanoise
tireworld g
tireworld r
zeno

runs
  
  
  
  



  


  

  
  
  

failed
 
 
 
 



 


 

  
 
 

successful
  
  
  
  



  


  

  
  
  

time
  
  
   
     



     


     

  
  
   

reward
     
     
     
     



     


    

     
 
   

table    results mgpt planner competition problems  table shows
problem name  number runs  number failed successful runs  see text  
time reward averages  dash means mgpt able solve
problem  times milliseconds 

    results
competition held client server model  planner evaluated
problem number runs supervision server  planner initiated
session connecting server interacted exchanging messages 
run consisted actions sent planner whose effects transmitted back
server planner  thus  current state problem maintained
planner server 
table   shows results mgpt competition problems  problem 
   runs executed  table shows number runs  number failed runs
 i e  finished without reaching goal state   number successful runs  i e 
finished goal states   time reward averages per run  
blocksworld  problem blocksworld xx means problem xx blocks  boxworld 
problem boxworld cxx byy means problem xx cities yy boxes 
seen table  mgpt solve exploding bw  larger instances
blocksworld boxworld  failed approximately half instances
tireworld g  difficulties encountered mgpt solving problems often
much probabilities involved  domains  particular 
encodings  basic algorithms used mgpt try solve problems
   competition format reward based presentation cost based  straightforward
go one format other 

   

fimgpt  probabilistic planner based heuristic search

computing value function  residuals relevant states  those reachable
initial state optimal policy   this  mgpt computes admissible heuristic
function solving either min min relaxation  strips relaxation  both  problem
faced approach many instances neither relaxations could
solved  here  give detailed explanation problems encountered mgpt
different domains  worth noting many difficulties would surface
strips planner well  even probabilities ignored 
blocksworld exploding blocksworld  operator encodings preconditions
containing universally quantified negative literals  result using clear
predicate  example 
  action pick up block from
 parameters   top   block  bottom 
 precondition  and  not     top  bottom  
 forall   b   block   not  holding  b   
 on top of  top  bottom 
 forall   b   block   not  on top of  b  top    
 effect  and  decrease  reward    
 probabilistic
      and  holding  top   not  on top of  top  bottom   
      when  not     bottom table  
 and  not  on top of  top  bottom  
 on top of  top table     
 

complex encoding standard planning makes atom based heuristics almost useless  mgpt could solve instances             blocks
      blocks  exploding blocksworld  mgpt unable
solve parser incomplete parse complex constructs 
boxworld  encoding contains drive truck operator moves truck
intended destination probability     one three wrong destinations
probability       each  encoding specifies unintended effects means
nested conditional effects form
  action drive truck
 parameters   t   truck  src   city  dst   city 
 precondition  and  truck at city  t  src   can drive  src  dst  
 effect  and  not  truck at city  t  src  
 probabilistic
     forall   c    city 
 when  wrong drive   src  c  
 forall   c    city 
 when  wrong drive   src  c  
 forall   c    city 
 when  wrong drive   src  c  
 probabilistic
     truck at city  t  c  
     truck at city  t  c  
     truck at city  t  c         
     truck at city  t  dst   
 
   

fibonet   geffner

strips relaxation  planner converts adl style operators strips 
suffers exponential blow domain     cities 
thousand operators grounded adl operator  set included problems
         cities 
fileworld  domain     files need filed one   different
folders  exact destination determined probabilistically  optimal policy
problem  proper policy  must prescribe action     states 
relevant  consequence problem millions relevant states
need stored hash table task compute proper policy 
patterndb   heuristic problem informative  revealed analysis
values stored pattern database  thus mgpt switched automatically
asp algorithm heuristic 
towers of hanoise  blocksworld domain  encoding complex operators disjunctions universally quantified negative literals preconditions  complex conditional effects  yet problem prevented mgpt
solving problem domain bug code implements conditional
effects surface domains 
tireworld  two versions  goal based version called tireworld g
reward based version called tireworld r  domain contains multiple dead ends
locations car gets flat tire spare tire available 
dead ends unavoidable  i e  proper policy problem  trials
reward based version end successfully since requirement reach goal
position  rather objective maximize accumulated reward  mgpt treated
versions goal based problems deal directly reward based
problems 

   conclusions
mgpt planner entered probabilistic planning competition combines heuristicsearch algorithms methods obtaining lower bounds deterministic relaxations 
results obtained competition mixed difficulties
selection domains encodings match capabilities mgpt 
mgpt tries compute proper solutions using heuristics derived strips relaxations 
described  domains could solved due number relevant
states  others due complexity strips relaxations themselves 
definition good benchmarks mdp solvers  crucial define
constitutes solution bottom line assessing performance  classical
planning  example  solutions plans bottom line given blind search
algorithms  progress field measured distance bottom line 
probabilistic setting  difficult always clear means
solve problem  this  however  needs defined way  otherwise performance
comparisons meaningful  indeed  classical setting  one longer compares
optimal non optimal planners since types planners different  one
provides guarantees apply solutions  provides guarantees

   

fimgpt  probabilistic planner based heuristic search

apply one solution only  probabilistic setting even subtle
different types guarantees  example  restrict class mdps
constitute simplest generalization classical setting task reaching
goal certainty minimizing expected number steps given initial
state s  methods yield solutions  policies  ensure goal
reached certainty finite number steps  not necessarily optimal   methods
guarantees  types methods necessary practice  yet crucial
make distinction among identify useful benchmarks class 
methods yield optimal policies  least policies finite expected costs  standard
dynamic programming methods value iteration provide useful bottom line reference
assessing performance  case  believe useful benchmarks need defined
taking account types tasks various algorithms aim solve 
types guarantees  any  provide solutions 
gpt mgpt available download http   www ldc usb ve bonet 
acknowledgements
mgpt built upon parser developed john asmuth rutgers university
hakan younes carnegie mellon university  thank david e  smith comments helped us improve note 

references
barto  a   bradtke  s     singh  s          learning act using real time dynamic programming  artificial intelligence            
bertsekas  d          dynamic programming optimal control     vols   athena scientific 
blum  a     furst  m          fast planning planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning incomplete information heuristic search
belief space  chien  s   kambhampati  s     knoblock  c   eds    proc   th
international conf  artificial intelligence planning scheduling  pp       
breckenridge  co  aaai press 
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
bonet  b     geffner  h       a   faster heuristic search algorithms planning
uncertainty full feedback  gottlob  g   ed    proc    th international joint
conf  artificial intelligence  pp            acapulco  mexico  morgan kaufmann 
bonet  b     geffner  h       b   labeled rtdp  improving convergence real time
dynamic programming  giunchiglia  e   muscettola  n     nau  d   eds    proc 
  th international conf  automated planning scheduling  pp        trento 
italy  aaai press 

   

fibonet   geffner

bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  kuipers  b     webber  b   eds    proc    th national conf 
artificial intelligence  pp          providence  ri  aaai press   mit press 
cormen  t   leiserson  c     rivest  r          introduction algorithms  mit press 
edelkamp  s          planning pattern databases  cesta  a   ed    proc   th
european conf  planning  pp        toledo  spain  springer  lncs 
gazen  b     knoblock  c          combining expressiveness ucpop
efficiency graphplan  steel  s     alami  r   eds    proc   th european conf 
planning  pp          toulouse  france  springer  lncs 
haslum  p   bonet  b     geffner  h          new admissible heuristics domainindependent planning  veloso  m     kambhampati  s   eds    proc     national
conf  artificial intelligence  pp            pittsburgh  pa  aaai press   mit
press 
haslum  p     geffner  h          admissible heuristic optimal planning  chien  s  
kambhampati  s     knoblock  c   eds    proc   th international conf  artificial
intelligence planning scheduling  pp          breckenridge  co  aaai press 
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research             
korf  r          real time heuristic search  artificial intelligence                  
nguyen  x     kambhampati  s          extracting effective admissible state space
heuristics planning graph  kautz  h     porter  b   eds    proc    th
national conf  artificial intelligence  pp          austin  tx  aaai press  
mit press 
pearl  j          heuristics  morgan kaufmann 
tarjan  r  e          depth first search linear graph algorithms  siam journal
computing                

   


