journal of artificial intelligence research                  

submitted        published      

the first probabilistic track of the
international planning competition
hakan l  s  younes

lorens cs cmu edu

computer science department
carnegie mellon university
pittsburgh  pa       usa

michael l  littman
david weissman
john asmuth

mlittman cs rutgers edu
dweisman cs rutgers edu
jasmuth cs rutgers edu

department of computer science
rutgers university
piscataway  nj       usa

abstract
the      international planning competition  ipc    included a probabilistic planning
track for the first time  we describe the new domain specification language we created for
the track  our evaluation methodology  the competition domains we developed  and the
results of the participating teams 

   background
the fourth international planning competition  ipc    was held as part of the international conference on planning and scheduling  icaps    in vancouver  british columbia
in june       by request of the icaps   organizers  sven koenig and shlomo zilberstein 
we were asked to create the first probabilistic planning track as part of ipc   
the overriding goal of the first probabilistic planning track was to bring together two
communities converging on a similar set of research issues and aid them in creating comparable tools and evaluation metrics  one community consists of markov decision process
 mdp  researchers interested in developing algorithms that apply to powerfully expressive
representations of environments  the other consists of planning researchers incorporating
probabilistic and decision theoretic concepts into their planning algorithms  cross fertilization has begun  but the intent of the probabilistic planning track was to create a set of
shared benchmarks and metrics that could crystallize efforts in this area of study 
we created a new domain description language called ppddl     described in section    ppddl stands for probabilistic planning domain definition language  in analogy to pddl  mcdermott         which was introduced in ipc    ppddl is modeled on
pddl     fox   long         the domain description language for deterministic domains
used in ipc    syntactically  this language has a strips adl like flavor  but includes
probabilistic constructs  to focus the energy of participants on issues of dealing with uncertainty  we chose not to include constructs for durative actions in ppddl    
by basing the domain description language on pddl  we sought to remain in the spirit
of the existing planning competition  which we hope will further bring the communities
c
    
ai access foundation  all rights reserved 

fiyounes  littman  weissman   asmuth

together  the ppddl representation itself is relational  although representations with
explicit objects are not a traditional feature of mdp based domain description languages 
algorithms that exploit these features have begun to appear  we expected participants to
propositionalize the domains before running their planning algorithms and  for the most
part  they did so 
a fully functional parser for ppddl was provided to participants in c   in the form of
a plan validator and very simple planner  some basic tools to convert ppddl to a decisiondiagram representation were also provided  in many ways  handling the rich constructs
of ppddl was the main hurdle for many participants and we tried to provide as much
assistance as we could on this dimension 
although ppddl supports numerical fluents  this feature was not used to its fullest
extent in the competition  numerical quantities were used only for representing reward
values  and reward effects were required to be additive 
since the classical track is well established at this point  it is helpful to contrast how
the probabilistic track differs  the defining difference  of course  is that actions can have
uncertain effects  that is  a pickup action in a blocksworld might behave differently
on different occasions  even from the same state  this single difference has a number of
significant consequences  first  the optimal action choices for reaching a goal may be a
function of the probabilistic outcomes along the waya single sequence of actions may
not be sufficient  as a result  it can be difficult to output a plan  for this reason  we
decided not to separate plan synthesis and execution into two phases  but instead evaluated
planners online  second  because of the unpredictability of effects  even an optimal plan
for reaching a goal may get unlucky and fail with some probability  for this reason 
we evaluated each planner multiple times on each problem and did not include a separate
optimal planner track  in addition  since some planners may fail to reach the goal state
for some executions  we needed a way of trading off between goal attainment and action
cost  we decided to score an execution as goal reward minus action cost and chose a goal
reward for each problem  section   describes the evaluation methodology in further detail 
in total  we designed eight domains for the competition  section     some domains
were simply noisy versions of classical planning domains  while other domains were designed
specifically to thwart greedy replanning approaches that ignore uncertainty 
ten planners from seven different groups entered the competition  the results of the
competition are presented in section    a deterministic replanner performed best overall 
primarily due to a disproportionate number of noisy classical planning problems in the
evaluation suite  some domains proved challenging for all participating planners  these
latter domains could serve as a basis for future probabilistic planning competitions 

   probabilistic pddl
this section describes the input language  ppddl     that was used for the probabilistic
track  ppddl    is essentially a syntactic extension of levels   and   of pddl     fox
  long         the complete syntax for ppddl    is given in appendix a  we assume
that the reader is familiar with pddl     so we focus on the new language features  which
include probabilistic effects and rewards  a more detailed account of ppddl    is provided
   

fithe first probabilistic track of ipc

name
bomb in package package 
bomb in package package 
toilet clogged
bomb defused

type
boolean
boolean
boolean
boolean

init  
true
false
false
false

init  
false
true
false
false

table    state variables and their initial values for the bomb and toilet problem 
by younes and littman         the semantics of a ppddl    planning problem is given
in terms of a discrete time markov decision process  howard              puterman        
    probabilistic effects
to define probabilistic and decision theoretic planning problems  we need to add support
for probabilistic effects  the syntax for probabilistic effects is
 probabilistic p  e        pk ek  
meaning
pk that effect ei occurs with probability pi   we require that the constraints pi   
and i   pi     are fulfilled  a probabilistic effect declares an exhaustive set of probabilityweighted outcomes  we do  however  allow a probability effect pair to be left out if the
effect is empty  in other words 
 probabilistic p  e        pl el  
with

pl

i   pi

    is syntactic sugar for
 probabilistic p  e        pl el q  and  
pl

with q      i   pi and  and  representing an empty effect  that is  no state changes  
for example  the effect  probabilistic      clogged   means that with probability    
the state variable clogged becomes true in the next state  while with probability     the
state remains unchanged 
figure   shows an encoding in ppddl of the bomb and toilet example described
by kushmerick  hanks  and weld         the requirements flag  probabilistic effects
signals that probabilistic effects are used in the domain definition  in this problem  there
are two packages  one of which contains a bomb  the bomb can be defused by dunking the
package containing the bomb in the toilet  there is a      probability of the toilet becoming
clogged when a package is placed in it  thus rendering the goal state unreachable 
the problem definition in figure   also shows that initial conditions in ppddl can be
probabilistic  in this particular example  we define two possible initial states with equal
probability       of being the true initial state for any given execution  table   lists the
state variables for the bomb and toilet problem and their values in the two possible initial
states  intuitively  we can think of the initial conditions of a ppddl planning problem as
being the effects of an action forced to be scheduled right before time    also  note that
the goal of the problem involves negation  which is why the problem definition declares the
 negative preconditions requirements flag 
   

fiyounes  littman  weissman   asmuth

 define  domain bomb and toilet 
  requirements  conditional effects  probabilistic effects 
  predicates  bomb in package  pkg   toilet clogged 
 bomb defused  
  action dunk package
 parameters   pkg 
 effect  and  when  bomb in package  pkg 
 bomb defused  
 probabilistic       toilet clogged     
 define  problem bomb and toilet 
  domain bomb and toilet 
  requirements  negative preconditions 
  objects package  package  
  init  probabilistic      bomb in package package  
     bomb in package package    
  goal  and  bomb defused   not  toilet clogged     
figure    ppddl encoding of bomb and toilet example 

ppddl allows arbitrary nesting of conditional and probabilistic effects  see example in
figure     this feature is in contrast to popular encodings  such as probabilistic strips
operators  psos  kushmerick et al         and factored psos  dearden   boutilier        
which do not allow conditional effects nested inside probabilistic effects  while arbitrary
nesting does not add to the expressiveness of the language  it can allow for exponentially
more compact representations of certain effects given the same set of state variables and
actions  rintanen         any ppddl action can  however  be translated into a set of psos
with at most a polynomial increase in the size of the representation  consequently  it follows
from the results of littman        that ppddl  after grounding  that is  full instantiation
of action schemata   is representationally equivalent to dynamic bayesian networks  dean
  kanazawa         which is another popular representation for mdp planning problems 
still  it is worth noting that a single ppddl action schema can represent a large number
of actions and a single predicate can represent a large number of state variables  meaning
that ppddl often can represent planning problems more succinctly than other representations  for example  the number of actions that can be represented using m objects and n
action schemata with arity c is m  nc   which is not bounded by any polynomial in the size
of the original representation  m   n   grounding is by no means a prerequisite for ppddl
planning  so planners could conceivably take advantage of the more compact representation
by working directly with action schemata 
    rewards
markovian rewards  associated with state transitions  can be encoded using fluents  numeric
state variables   ppddl reserves the fluent reward   accessed as  reward  or reward  to
represent the total accumulated reward since the start of execution  rewards are associated
   

fithe first probabilistic track of ipc

 define  domain coffee delivery 
  requirements  negative preconditions
 disjunctive preconditions
 conditional effects  mdp 
  predicates  in office   raining   has umbrella   is wet 
 has coffee   user has coffee  
  action deliver coffee
 effect  and  when  and  in office   has coffee  
 probabilistic
     and  user has coffee 
 not  has coffee  
 increase  reward       
     and  probabilistic      not  has coffee   
 when  user has coffee 
 increase  reward          
 when  and  not  in office    has coffee  
 and  probabilistic      not  has coffee   
 when  user has coffee 
 increase  reward         
 when  and  not  has coffee    user has coffee  
 increase  reward       
 when  not  is wet  
 increase  reward         
     

figure    part of ppddl encoding of coffee delivery domain 

with state transitions through update rules in action effects  the use of the reward fluent
is restricted to action effects of the form  hadditive opi hreward fluenti hf expi   where
hadditive opi is either increase or decrease  and hf expi is a numeric expression not involving reward   action preconditions and effect conditions are not allowed to refer to the
reward fluent  which means that the accumulated reward does not have to be considered
part of the state space  the initial value of reward is zero  these restrictions on the use
of the reward fluent allow a planner to handle domains with rewards without having to
implement full support for fluents 
a new requirements flag   rewards  is introduced to signal that support for rewards is
required  domains that require both probabilistic effects and rewards can declare the  mdp
requirements flag  which implies  probabilistic effects and  rewards 
figure   shows part of the ppddl encoding of a coffee delivery domain described by
dearden and boutilier         a reward of     is awarded if the user has coffee after the
deliver coffee action has been executed  and a reward of     is awarded if is wet is false
after execution of deliver coffee  note that a total reward of     can be awarded as a
result of executing the deliver coffee action if execution of the action leads to a state
where both user  has coffee and is wet hold 
   

fiyounes  littman  weissman   asmuth

    plan objectives
regular pddl goals are used to express goal type performance objectives  a goal statement
  goal   for a probabilistic planning problem encodes the objective that the probability
of achieving  should be maximized  unless an explicit optimization metric is specified for
the planning problem  for planning problems instantiated from a domain declaring the
 rewards requirement  the default plan objective is to maximize the expected reward  a
goal statement in the specification of a reward oriented planning problem identifies a set of
absorbing states  in addition to transition rewards specified in action effects  it is possible to
associate a one time reward for entering a goal state  this is done using the   goal reward
f   construct  where f is a numeric expression 
in general  a statement   metric maximize f   in a problem definition means that the
expected value of f should be maximized  reward oriented problems  for example a problem instance of the coffee delivery domain in figure    would declare   metric maximize
 reward   as the optimization criterion  this declaration is the default if the  rewards
requirement has been specified   ppddl defines goal achieved as a special optimization
metric  which can be used to explicitly specify that the plan objective is to maximize  or
minimize  the probability of goal achievement  the value of the goal achieved fluent is  
if execution ends in a goal state  the expected value of goal achieved is therefore equal to
the probability of goal achievement  a declaration   metric maximize  goal achieved  
takes precedence over any reward specifications in a domain or problem definition  and it
is the default if the  rewards requirement has not been specified  for example  the bomb
and toilet problem in figure    
    ppddl semantics
for completeness  we present a formal semantics for ppddl planning problems in terms of
a mapping to a probabilistic transition system with rewards  a planning problem defines
a set of state variables v   possibly containing both boolean and numeric state variables 
although we only consider planning problems without any numeric state variables in this
section  an assignment of values to state variables defines a state  and the state space s
of the planning problem is the set of states representing all possible assignments of values
to variables  in addition
to v   a planning problem defines an initial state distribution
p
p    s         with ss p   s       that is  p  is a probability distribution over states   a
formula g over v characterizing a set of goal states g    s   s    g    a one time reward
rg associated with entering a goal state  and a set of actions a instantiated from ppddl
action schemata  for goal directed planning problems  without explicit rewards  we use
rg     
      probability and reward structure
an action a  a consists of a precondition a and an effect ea   action a is applicable
in a state s if and only if s    g  a   it is an error to apply a to a state such that
s     g  a   goal states are absorbing  so no action may be applied to a state satisfying
g   the requirement that a must hold in order for a to be applicable is consistent with
the semantics of pddl     fox   long        and permits the modeling of forced chains
of actions  effects are recursively defined as follows  see also  rintanen        
   

fithe first probabilistic track of ipc

     is the null effect  represented in ppddl by  and  
   b and b are effects if b  v is a boolean state variable 
   r  v  for v  r  is an effect 
   c  e is an effect if c is a formula over v and e is an effect 
   e       en is an effect if e            en are effects 
   p
  e           pn en is an effect if e            en are effects  pi    for all i              n   and
p
n
i   pi     
the effect b sets the boolean state variable b to true in the next state  while b sets b to false
in the next state  effects of the form r  v are used to associate rewards with transitions
as described below 
an action a   ha   ea i defines a transition probability matrix pa and a state reward
vector ra   with pa  i  j  being the probability of transitioning to state j when applying a
in state i  and ra  i  being the expected reward for executing action a in state i  we can
readily compute the entries of the reward vector from the action effect formula ea   let c
be the characteristic function for the boolean formula c  that is  c  s  is   if s    c and  
otherwise  the expected reward for an effect e applied to a state s  denoted r e  s   can be
computed using the following inductive definition 
 
r    s     
 
r b  s     
 
r b  s     
 
r r  v  s    v
 
r c  e  s    c  s   r e  s 
n
  x
r e       en   s   
r ei   s 
i  
n
  x
r p  e           pn en   s   
pi  r ei   s  
i  

a factored representation of the probability matrix pa can be obtained by generating
a dynamic bayesian network  dbn  representation of the action effect formula ea   we
can use bayesian inference on the dbn to obtain a monolithic representation of pa   but
the structure of the factored representation can be exploited by algorithms for decision
theoretic planning  see  for example  work by boutilier  dearden    goldszmidt       
hoey  st aubin  hu    boutilier        boutilier  dean    hanks        guestrin  koller 
parr    venkataraman        
a bayesian network is a directed graph  each node of the graph represents a state
variable  and a directed edge from one node to another represents a causal dependence  with
each node is associated a conditional probability table  cpt   the cpt for state variable
xs node represents the probability distribution over possible values for x conditioned on
the values of state variables whose nodes are parents of xs node  a bayesian network is a
   

fiyounes  littman  weissman   asmuth

factored representation of the joint probability distribution over the variables represented
in the network 
a dbn is a bayesian network with a specific structure aimed at capturing temporal
dependence  for each state variable x  we create a duplicate state variable x     with x
representing the situation at the present time and x   representing the situation one time
step into the future  a directed edge from a present time state variable x to a future time
state variable y   encodes a temporal dependence  there are no edges between two presenttime state variables  or from a future time to a present time state variable  the present does
not depend on the future   we can  however  have an edge between two future time state
variables  such edges  called synchronic edges  are used to represent correlated effects  a
dbn is a factored representation of the joint probability distribution over present time and
future time state variables  which is also the transition probability matrix for a discrete time
markov process 
we now show how to generate a dbn representing the transition probability matrix for
a ppddl action  to avoid representational blowup  we introduce a multi valued auxiliary
variable for each probabilistic effect of an action effect  these auxiliary variables are introduced to indicate which of the possible outcomes of a probabilistic effect occurs  allowing
the representation to correlate all the effects of a specific outcome  the auxiliary variable
associated with a probabilistic effect with n outcomes can take on n different values  a
ppddl effect e of size  e  can consist of at most o  e   distinct probabilistic effects  hence 
the number of auxiliary variables required to encode the transition probability matrix for
an action with effect e will be at most o  e    only future time versions of the auxiliary
variables are necessary  for a ppddl problem with m boolean state variables  we need
on the order of  m   maxaa  ea   nodes in the dbns representing transition probability
matrices for actions 
we provide a compositional approach for generating a dbn that represents the transition probability matrix for a ppddl action with precondition a and effect ea   we assume
that the effect is consistent  that is  that b and b do not occur in the same outcome with
overlapping conditions  the dbn for an empty effect   simply consists of  m nodes  with
each present time node x connected to its future time counterpart x     the cpt for x  
has the non zero entries pr x         x          and pr x        x          the same
holds for a reward effect r  v  which does not change the value of state variables 
next  consider the simple effects b and b  let xb be the state variable associated with
the ppddl atom b  for these effects  we eliminate the edge from xb to xb    the cpt for
xb  has the entry pr xb           for effect b and pr xb          for effect b 
for conditional effects  c  e  we take the dbn for e and add edges between the presenttime state variables mentioned in the formula c and the future time state variables in the
dbn for e   entries in the cpt for a state variable x   that correspond to settings of the
present time state variables that satisfy c remain unchanged  the other entries are set to
  if x is true and   otherwise  the value of x does not change if the effect condition is not
satisfied  
the dbn for an effect conjunction e       en is constructed from the dbns for the
n effect conjuncts  the value for pr x         x  in the dbn for the conjunction is set to
   this transformation can increase the size of the dbns exponentially unless context specific dbns are
used  boutilier  friedman  goldszmidt    koller        

   

fithe first probabilistic track of ipc

r

r

r 
hu 
iw  
uhc 
hc 
io 

raining
has umbrella
is wet
user has coffee
has coffee
in office

hu

hu

iw

iw

uhc

uhc

aux 

hc

hc

aux 

io

io

aux 

aux   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

io
 
 
 
 




 
 
 
 





hc
 
 


 
 


 
 


 
 



uhc
 

 

 

 

 

 

 

 


uhc  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

figure    dbn structure  left  for the deliver coffee action of the coffee delivery domain  with the cpt for uhc    the future time version of the state variable
user  has coffee  shown to the right 

the maximum of pr x         x  over the dbns for the conjuncts  the maximum is used
because a state variable is set to true  false  by the conjunctive effect if it is set to true
 false  by one of the effect conjuncts  effects are assumed to be consistent  so that the result
of taking the maximum over the separate probability tables is still a probability table  
finally  to construct a dbn for a probabilistic effect p  e           pn en   we introduce an
auxiliary variable y   that is used to indicate which one of the n outcomes occurred  the
node for y   does not have any parents  and the entries of the cpt are pr y     i    pi  
given a dbn for ei   we add a synchronic edge from y   to all state variables x  the
value of pr x         x  y     j  is set to pr x         x  if j   i and   otherwise 
this transformation is repeated for all n outcomes  which results in n dbns  these dbns
can trivially be combined into a single dbn for the probabilistic effect because they have
mutually exclusive preconditions  the value of y  
as an example  figure   shows the dbn encoding of the transition probability matrix
for the deliver coffee action  whose ppddl encoding was given in figure    there are
three auxiliary variables because the action effect contains three probabilistic effects  the
node labeled uhc    the future time version of the state variable user  has coffee  has four
parents  including one auxiliary variable  consequently  the cpt for this node will have
        rows  shown to the right in figure    
      optimality criteria
we have shown how to construct an mdp from the ppddl encoding of a planning problem 
the plan objective is to maximize the expected reward for the mdp  this objective can be
interpreted in different ways  for example as expected discounted reward or expected total
   

fiyounes  littman  weissman   asmuth

reward  the suitable interpretation depends on the problem  for process oriented planning problems  for example  the coffee delivery problem   discounted reward is typically
desirable  while total reward often is the interpretation chosen for goal oriented problems
 for example  the bomb and toilet problem   ppddl does not include any facility for
enforcing a given interpretation or specifying a discount factor 
for the competition  we used expected total reward as the optimality criterion  without
discounting  some care is required in the design of planning problems to ensure that the
expected total reward is bounded for the optimal policy  the following restrictions were
made for problems used in the planning competition 
   each problem had a goal statement  identifying a set of absorbing goal states 
   a positive reward was associated with transitioning into a goal state 
   a negative reward  cost  was associated with each action 
   a done action was available in all states  which could be used to end further accumulation of reward 
these conditions ensure that an mdp model of a planning problem is a positive bounded
model  puterman         the only positive reward is for transitioning into a goal state 
since goal states are absorbing  that is  they have no outgoing transitions   the maximum
value for any state is bounded by the goal reward  furthermore  the done action ensures
that there is an action available in each state that guarantees a non negative future reward 

   evaluation methodology
in classical planning  a plan is a series of operators  a successful plan is one that  when
applied to the initial state  achieves the goal  in probabilistic planning  there are many
proposals for plan representations  straight line plans  plan trees  policy graphs  and triangle
tables  for example   but none is considered a widely accepted standard  in addition  even
simple plans are challenging to evaluate exactly in a non deterministic environment  as
all possible outcomes need to be checked and results combined  littman  goldsmith   
mundhenk        
for these reasons  we chose to evaluate planners by simulation  that is  our plan validator was a server  and individual planning algorithms acted as clients  planners connected
to the validator  received an initial state  and returned an operator action  this dialog
continued until a terminating condition was reached at which point the validator evaluated
the performance of the planner during that trajectory from initial state to terminating condition  this entire process was repeated several times and results averaged over the multiple
runs 
because this evaluation scheme blurs the distinction between a planner and an executor 
it means that computation is no longer a one time preprocessing cost  but something integrated with action selection itself  planner quality  therefore  needs to be a combination of
expected utility and running time  for simplicity  we set a time threshold and only allowed
reward to be gathered until time ran out  this time threshold was known to competitors 
whose planners could take it into consideration when deciding how to balance computation
   

fithe first probabilistic track of ipc

and action  since we did not know whether participants would reuse results from one trajectory to speed planning in the next  we set an overall time limit that applied to the total
of all repetitions of the evaluator for a given domain 
concretely  in our evaluations  participants were presented with twenty previously unseen problems in ppddl format  to evaluate each problem  participants connected to one
of our evaluation servers  at cmu or rutgers   the server provided the planner with an
initial state and the planner selected and returned an action  this dialogue was iterated
until a goal was reached  time ran out  or the planner sent a done action  the value
obtained for the problem was the goal reward  if the goal was reached  minus the sum of the
action costs  if any   for each problem  this procedure was repeated    times in a maximum
of    minutes and the results averaged 
there were two types of problems in the evaluation set  reward problems and goal
problems  for goal problems  the success percentage determined a participants score for
the problem  no action costs   in reward problems  every action had a fixed cost  the times
to completion were recorded  but not explicitly used for ranking  planners that completed
less than    runs in    minutes were given a score of   for the unfinished runs 
in the design of the server  we believed that the time needed for computation in the
planner would far outweigh any possible communication delay  however  in preliminary
evaluations  participantsespecially those halfway across the worldexperienced disruptive levels of latency when evaluating their planners by connecting remotely to the server 
before the formal evaluation  we offered participants local accounts at cmu and nearly all
availed themselves of this option 
    communication between client and server
the communication between a participants client program and our server took place in
xml  we made this decision for two reasons  the first is that parsing the messages into an
easily managed format was trivial for all parties involvedmany solid xml parsers exist in
the public domain  the second is that bandwidth was not a great concernas mentioned
in the previous section  most participants ran their clients on the machine that hosted the
server  while it is true that excessively large messages can take up valuable processing
time  in our specific case those large messages corresponded to large state spaces  which
took somewhat longer to process altogether  and the xml parsing was not the limiting
factor 
when a client connected to a server  it would request a certain problem to run  the
server would then lead the client through running that problem    times  sending the state
of the problem  receiving the clients action  and then creating a new state from the old
state and the action  and sending it back again  figure   gives a schematic illustration of
the conversation between the client and server  the specific format of each xml element
is described in appendix b 
prior to the competition  an example client was written in c   and distributed to
the participants to minimize difficulties in dealing with the nuts and bolts of the protocol 
allowing them to instead focus on the design of their algorithms 
   

fiyounes  littman  weissman   asmuth

client  hsession requesti
server  hsession initi
loop through    rounds
client  hround requesti
server  hround initi
loop until termination conditions
server  hstatei
client  hacti   hnoopi   hdonei
server  hend round i
 server  hend sessioni

figure    the interaction between client  planners  and server  environment  in our evaluation system 

    generator based domains
several example domains were provided to participants in advance to serve as testbeds
for parser and planner development  in addition  parameterized problem generators were
provided for two domain classesblocksworld and boxworld  described in more detail in
section    the availability of these domains served to allow participants to learn  either manually or automatically  about the domains and to create domain specific solutions  these
approaches were evaluated independently in a separate category 

   competition domains
this section describes the domains used in the competition  machine readable versions of
the domains themselves can be found online at the competition web site 
http   www cs rutgers edu mlittman topics ipc   pt 
    blocksworld  traditional 
our traditional blocksworld domain does not stray far from the original blocksworld domain  the domain consists of two types of objects  blocks and tables  the domain has
exactly one table and each problem instance has some number of blocks  the number of
blocks is problem specific   the actions of the domain are pick up block from and putdown block on  for each problem instance  an initial configuration and a goal configuration
of the blocks is given  the goal of the problem is to move the blocks from the initial configuration into the goal configuration  this domain comes in two flavors  a goal version and a
reward version  within the reward version  there is a cost of one unit every time the action
pick up block from is executed  and the reward is     for reaching the goal configuration 
as with all of the other domains used in the competition  the blocksworld domain
incorporates probabilistic effects and does so by adding a slip probability  that is  each
time a block is picked up or put down  the block will slip and fall onto the table with
   

fithe first probabilistic track of ipc

probability        of course  if the intended action is to put the block down onto the table 
then this effect will always be achieved   the blocksworld domain is an extremely simple
domain  yet it offers a lot of insight into the planning process  two important features of
the domain are 
   a basic policy to solve the domain is 
 a  from the initial configuration  place all of the blocks onto the table with no block
on top of another block 
 b  starting from the bottom up  place each block into its place in the final configuration 
note that without noise  if there are n blocks  this policy takes  n steps    steps for
each block on part  a  and   steps for each block on part  b  and hence costs  n
units  so  there is a very basic  very inexpensive way to solve this domain 
   the state space of this domain increases exponentially with the number of blocks 
thus  this domain aims at testing if planners could find the easy  maybe slightly more
expensive  policy when the state space was too large to find a good policy  as far as the
complexity of this domain is concerned  it is one of the easier domains to plan for and our
hope was that many planners would do quite well in this domain 
a generation program for random traditional blocksworld domains was provided to
participants and the competition problems were generated from this same program  the
availability of the generator allowed participants to test their planners on as many problems
as they liked in advance of the evaluation 
    blocksworld  color 
the colored blocksworld domain is a variant of the traditional blocksworld presented above 
as in the traditional blocksworld  colored blocksworld consists of two types of objects 
tables and blocks  again  the domain has exactly one table and each problem instance
has some number of blocks  the actions of the domain are still pick up block from and
put down block on  and this domain also comes in two flavors  goal and reward  the
major difference from the traditional blocksworld domain is that each block in the colored
blocksworld domain is assigned a color  and the goal configuration is specified in terms of
block colors rather than specific blocks  thus  in general  there are many different valid goal
configurations  goal conditions are expressed with existential quantification  for example 
the ppddl fragment
  goal  and  exists   b    is green  b   
 exists   b    and  is blue  b    on top of  b   b      
states that the goal is to have any green block on top of any blue block 
the noise in the colored blocksworld domain is the same as in the traditional blocksworld domain  that is  the colored blocksworld domain incorporates probabilistic effects
by adding a slip probability  each time a block is picked up or put down  the block will
slip and fall onto the table with probability      
   

fiyounes  littman  weissman   asmuth

notice that although the goal configuration is existentially quantified and hence not precisely specified  the same basic policy that can be used to solve the traditional blocksworld
can be used to solve the colored blocksworld  to solve a colored blocksworld problem 
unstack all of the blocks and then  in a bottom up fashion  choose a block that satisfies a
color constraint and place it in the appropriate position 
the colored blocksworld domain aims to add complexity to the traditional blocksworld domain by incorporating existential quantification into the goal configuration  the
indeterminacy of the goal in the colored blocksworld domain can make the planning problem
considerably harder than its traditional counterpart  thus  a colored blocksworld problem
may be impossible for a given planner to solve in a reasonable amount of time  whereas
that same planner would have no problem on a traditional blocksworld problem of the same
size  
a generation program for random colored blocksworld domains was provided to participants and the competition problems were generated from this same program 
    boxworld
the boxworld domain is modeled after the traditional logistics domain  the domain consists
of four types of objects  cities  boxes  trucks and planes  for each problem  there is a graph
superimposed on the cities with two different types of edges  one denoting the ability to
drive from one city to another and the other denoting the ability to fly from one city
to the other  the actions of the domain are load box on truck in city  unload boxfrom truck in city  load box on plane in city  unload box from plane in city  drivetruck and fly plane  both goal and reward versions of this domain were included in
the evaluation  within the reward version  there was a cost of   unit every time either
load box on truck in city or load box on plane in city was executed  a cost of   units
every time drive truck was executed and a cost of    units every time fly plane was
executed  for each problem instance  the initial configuration determines the graph that
is superimposed on the cities  identifies the locations of the boxes  trucks and planes and
determines the final destination where each box should arrive  the goal configuration
specifies a destination for every box  the goal of the problem is to move from the initial
configuration to a state where each box is in its destined location 
noise enters this domain in the action drive truck  when this action is executed  the
desired effect is achieved with probability      that is  with probability     the truck will
end up in its expected destination   however  with probability      the truck will get lost
and end up in the wrong destination  for each city  there are three cities that the truck
may get lost to when trying to execute the drive truck action  if the truck actually gets
lost it will end up in each of these cities with equal probability  that is  with probability
     
as with the blocksworld domains  a generation program for random boxworld domains
was provided to participants and the competition problems were generated from this same
program 
   it is important to note that the existentially quantified goal formula for colored blocksworld  when
grounded  can be excessively long  this fact is a serious bottleneck for larger instances of this domain 
planners that avoid grounding should have a benefit here  but did not in the competition because our
plan validator grounded the goal formula 

   

fithe first probabilistic track of ipc

    exploding blocksworld
the exploding blocksworld domain is a dead end version of the traditional blocksworld
domain described earlier  as in the traditional blocksworld domain  there are two types
of objects  tables and blocks  and two actions  pick up block from and put down blockon   an initial configuration and a goal configuration of the blocks are given and the goal
of the domain is to move the blocks from the initial configuration to the goal configuration 
the key difference between this domain and the traditional blocksworld domain is that
every block in the exploding blocksworld domain is initially set to detonate  every time
a put down block action is executed  if the block that is being put down has not yet
detonated it will detonate with probability      this is the only noise in the domain  if a
block detonates when executing a put down block action  the object beneath the block
 whether it is the table or another block  is destroyed and is no longer accessible within the
domain  once a block detonates  it is safe and can no longer detonate 
the exploding blocksworld domain aims at testing a planners ability to think ahead 
more formally  as actions are executed it is possible to reach a state from which the goal
cannot be reached  consider  for example  executing the standard blocksworld approach
in which all blocks are unstacked to the table before the goal configuration is constructed 
after seven blocks have been unstacked  there is a                     probability that the
table is destroyed  rendering the problem unsolvable 
one strategy for solving an exploding blocksworld problem is to never place an unsafe
block on top of something valuable  the table or a block needed in the final stack   instead 
a block should first be disarmed  by placing it on top of some block that is not needed
for the final configuration  if such a block exists 
we illustrate this strategy on the problem instance that was used in the planning competition  shown in figure    four blocks are not needed for the goal configuration          
and     we start by repeatedly picking up block   and placing it on block   until block  
detonates  next  we detonate block   in the same way using block     with both block  
and block   safe  we place block   on the table and block   on top of block    this completes the left most tower  at this stage  there are no safe moves because blocks   and   are
not clear  we pick up block   and put it on block    the last action leads to failure with
probability      if successful  the right most tower is completed  block   is now clear and
we use it to detonate block    block   is then safely placed on top of block    finally  the
center tower is completed by placing block   on top of block    which can result in failure
with probability      in total  the success probability of the given plan is                  
which  in fact  is optimal for the given problem  there are no action costs  
along with several other test domains  exploding blocksworld was specifically designed
so that a replanning strategy performs suboptimally  gets stuck with high probability   a
replanning strategy would be to ignore the     probability of detonation and try to replan
if something unexpected happens  however  there is a high probability that this approach
will render the goal state unreachable 
    fileworld
fileworld is a fairly basic domain  it consists of k files and n folders for the files to be
filed into  the actions of the domain are get type  reports which folder the given file
   

fiyounes  littman  weissman   asmuth

initial state
 
 
 
 

 
 

 

 
 

 

goal

  

 
 

 
 
 

 
 

figure    exploding blocksworld problem used in the planning competition  note that the
goal condition does not require block   to be on the table 

belongs in   get folder fi  one for each i              n      retrieves folder i from the filing
cabinet   file fi  one for each i              n      inserts the given file into folder i  and
return fi  one for each i             n      returns folder i to the filing cabinet   this
domain comes only in a reward version  there is a cost of     for executing the action
get folder fi and a cost of   for executing the action file fi  the other actions have
no explicit costs since they must be used in conjunction with get folder fi and file fi  the
initial configuration of the problem specifies how many folders there are  the competition
problem used    files and   folders  and the goal configuration specifies that all of the files
must be filed  note that the initial configuration does not specify which folder a file is to go
into  but files cannot be filed into just any folder  this constraint is where the noise comes
into the domain 
before a file can be filed  its destination folder must be determined  the destination
folder of a file is obtained by executing the action get type with the file in question as a
parameter  when this action is executed  the file passed as a parameter is assigned a folder 
with each folder being the files destination with equal probability  that is  probability   n  
once a file has a destination folder  it can be filed into this  and only this  folder 
the fileworld domain tests a planners ability to consider all of its strategies and choose
the one that minimizes the cost  in particular  a straightforward plan to achieve the goal
is to carry out the following series of actions on each file in turn 
   get its type with get type
   get its destination folder by executing get folder fi
   place the file in the appropriate folder by executing the file fi action
   return the folder by executing the return fi action
although this plan works  it is very costly  its cost would be    k where k is the number of
files  because get folder fi  expensive  and file fi  cheap  are executed for every file  a
less costly  in fact  the optimal  plan can be described  it first executes get type on every
file  then  for each folder i              n     that at least one file has as its destination  it
runs get folder fi  next  it files every file that belongs in folder i using file fi  it then
uses return fi in preparation for getting the next folder 
   

fithe first probabilistic track of ipc

the expected reward for the optimal plan is          n   k   where n is the number of
folders and k is the number of files  this analysis gives    as the optimal expected reward
for the competition problem   the domain is designed to reward planners that are able to
reason about the initial destination uncertainty of the files and recognize that the second
plan is much less costly and should be preferred to the straightforward brute force plan 
    tireworld
tireworld is another domain that tests the planners ability to plan ahead under uncertainty 
the domain consists of one type of object  namely locations  this domain comes in two
flavors  a goal version and a reward version  the actions common to both versions are
move car  load tire and change tire  in the reward version  there is the additional
action call aaa 
within the reward version  there is a cost of   every time one of the actions move car 
load tire or change tire is executed and a cost of     every time the action callaaa is executed  the initial configuration of the problem defines a set of locations  a
superimposed graph on these locations  roads   a subset of all locations representing the
locations with spare tires  and the starting location on the graph  the goal configuration
defines a destination location on the graph  the goal of the problem is to move from the
starting location to the goal location 
the noise in tireworld comes from the action move car  each time this action is
executed  the car drives from one city to another and will get a flat tire with probability
      once a car has a flat tire  it cannot execute the action move car again until the
tire is fixed  the car has the ability to store at most one spare tire  which it can pick up
by executing the action load tire when it is in a location with a spare tire  if the car is
holding a spare tire  the change tire action can be invoked to fix the flat  however  if
the car does not currently have a spare then this action is disabled  in the goal version 
a flat tire may result in a dead end if a car gets a flat and carries no spare tire  in the
reward version  the planner has the choice of executing one of the actions change tire  if
the car has a spare  or call aaa  at a high cost  to repair the flat  thus  in the reward
version  there are no dead ends and the goal is always reachable  notice that since the cost
of call aaa is large compared to the costs of change tire and load tire  fixing a flat
is always less expensive if the car has a spare tire 
figure   illustrates the tireworld problem used in the competition  we next compare
the probability of reaching a goal state for two different plans for this problem to illustrate
what an ideal plan looks like in this domain 
an optimal plan would look ahead and attempt to keep spare tires as accessible as
possible to avoid dead ends  from the start state  the car must make three steps without a
flat tire to reach the first spare at cc  which will occur with probability              now 
the car needs to go four steps without getting two flats to make it to the next spare at d   it
gets zero flats with probability             and one flat with probability                
      so a four step segment can be traversed with probability                    with one
spare tire  there are three four step segments that must be traversed successfully to reach
ck  finally  with a spare  the last two steps can be traveled with certainty  thus  the total
success probability of this event sequence is                    note that this estimate is a
   

fiyounes  littman  weissman   asmuth

spare tire
 all boxed locations 
start

goal
d 

d 

ca
c 

cn

cd

cc

c 

cm

cb
c 

ce

cf

cg

ch

ci
c 

c 

c 

cj

ck

c  c 

c 

cl
c 
d 

d 
d 

d 

d 

figure    the tireworld domain used in the competition 
lower bound on the success probability of the optimal strategy  because it does not factor in
the probability of getting a flat tire upon arrival to a state with a spare tire  furthermore 
if the car is in location cf or ch with a spare and no flat  it is unnecessary to traverse the
loop to pick up the spare tire in location d  or cm  by accounting for these factors we get
a success probability of just over      
in contrast  a greedy replanning algorithm would not gather spares  since their utility
comes from the realization that something might go wrong  for such a planner  the best
plan is to go directly from c  to c  on the shortest    step  route  its success probability
is              which is just    percent of the best success probability computed above 
in the reward version of the planning problem  the optimal success probability is one
because the call aaa action is always available  however  the cost of this action equals
the reward for reaching the goal  so it is always better to end execution with the done
action than to repair a flat tire with the call aaa action  hence  the best strategy for
the goal version is optimal for the reward version as well and gives a reward of just under
    the greedy strategy outlined above would result in an expected reward of just over    
if the call aaa action is used to fix flat tires  then the expected reward drops to    
    towers of hanoise
as the name suggests  this domain is a noisy version of the famous towers of hanoi
problem  the domain has two types of objects  disks and pegs  the problem that was
used in the competition had five disks and three pegs  the actions of the domain are
single move big not moved  single move big moved  double move big not moved and
double move big moved  as the action names suggest  one can move either one or two
   

fithe first probabilistic track of ipc

disks at a time  single move double move  and the outcome of the move is dependent on
whether or not the biggest disk has been moved yet  big not moved big moved   the objective of the domain is to maximize the probability of reaching a goal configuration  no
rewards  
the initial configuration defines the starting positions of the disks  as in towers of
hanoi  the five disks are stacked on the first peg in bottom to top  largest to smallest
order   the goal configuration defines the destination positions of the disks  again  the
destination positions are the same as that of towers of hanoi  namely all five disks are
stacked in the same order as the initial configuration but on the last peg   the goal of the
problem is to move the disks from the starting configuration to the goal configuration  all
actions in towers of hanoise have noisy outcomes  in particular  when executing an action
it is possible to drop a disk and have it be lost forever  thus bringing execution to a dead
end  the success probabilities are 

action
single move big not moved
single move big moved
double move big not moved
double move big moved

success probability
    
    
    
    

notice that the probability of succeeding with a move is dependent on the number of disks
moved and whether or not the big disk has been moved yet 
every sequence of actions has some success probability less than one in this problem  so
it is not possible to reach the goal with certainty  to maximize the probability of reaching
the goal  a careful comparison must be made  to move the big disk from the first to last
peg  it is necessary to move the four smaller disks to the middle peg  this subgoal can
be achieved by executing single move big not moved fifteen times on the smaller disks 
resulting in a success probability of               it can also be accomplished by moving
the four smaller disks as two units of two using double move big not moved three times 
resulting in a low success probability of approximately      
next  the big disk can be moved from the first to last peg with a success probability of
      single move big not moved   then  the four smaller disks again need to be moved 
this time from the middle peg to the last peg  now that the big disk has been moved  the
success probabilities change and the two strategies yield success probabilities of about     
for single move big moved and      for double move big moved 
a planner that chooses optimally at each step would switch from single moves to double
moves after the big disk is in place resulting in a total success probability of        
                  one that ignores probabilities and always uses single moves has a lower
success probability of                             a planner that ignores probabilities and
minimizes the number of steps by always using double moves has a lower success probability
still of                      thus  for optimum performance  a planner must realize that
its policy should consider the success probabilities of actions and how they are influenced
by the status of the big disk 
   

fiyounes  littman  weissman   asmuth

    zeno travel
our last domain is zeno travel  based on a domain used in ipc    problem instances
of this domain involve using airplanes to move people between cities  an airplane requires fuel to fly  it can be flown at two different speedsthe higher speed requiring
more fuel  our problem instance used one aircraft  two people  three cities and seven
fuel levels  the actions of the domain are start boarding  complete boarding  startdebarking  complete debarking  start refueling  complete refueling  start flying 
complete flying  start zooming  and complete zooming  the initial configuration
specifies the location of the plane  the initial fuel level of the plane and the location of
all people  as well as some initializations to allow for arithmetic type operations on the
fuel level objects   the goal configuration specifies a destination for the plane and destinations for all people  the noise in this domain comes from the family of complete x
actions  each time a complete x action is executed it will have the desired effect with
probability   k for some positive integer k  note that k is a function of the action executed  specifically k      for complete boarding and k      for complete debarking  
if the desired effect is not achieved then there is no effect  and this occurs with probability
      k   this structure is meant to represent actions with random duration  each durative action x is represented by two primitive actions start x and complete x  giving
x a duration that is geometrically distributed 
ultimately  this problem presented no real challenge because we neglected to include
action costs  since actions have either standard desired effect or none at all  a planner can
simple continue to execute an action until its effect is achieved  without incurring any cost 

   competition results
based on the initial announcement of the competition  we put together a mailing list of
   researchers expressing interest  as development of ppddl  the server  the evaluation
criteria  and the practice domains progressed  we kept the community informed by releasing
a series of faqs  may       faq      september       faq      november      faq       
by early       a core group of participants became evident and the competition logistics
were finalized  leading up to june       participants ran their planners on the previously
unseen test problems  we tabulated the scores in each of a set of evaluation categories and
presented them at icaps   in vancouver  canada 
the following subsections describe the competitions participants  evaluation tracks  and
results 
    participants
although twenty teams registered for the competition initially  seven teams from four continents ultimately competed  they produced ten different planners  which were evaluated
on various subsets of the problem domains  the groups and their planners were 
 group c  umass
participants  zhengzhu feng  university of massachusetts  and eric hansen  mississippi state university  
   

fithe first probabilistic track of ipc

description  symbolic heuristic search 
 group e  dresden  flucap  formerly fcplanner 
participants  eldar karabaev and olga skvortsova  both of dresden university of
technology  
description  first order heuristic search 
 group g  anu  nmrdpp 
participants  charles gretton  david price and sylvie thiebaux  all of the australian
national university  
descriptions  g   planner primarily designed for domains with non markovian rewards  and g   nmrdpp augmented with control knowledge 
 group j  purdue
participants  sungwook yoon  alan fern and robert givan  all of purdue university  
descriptions  j   human written policy in classys policy language  purdue humans   j   offline policy iteration by reduction to classification  automatically acquiring a domain specific policy  classy   and j   deterministic replanner using
ff  ff replan  
 group p  simon bolvar  mgpt 
participants  blai bonet  universidad simon bolvar  and hector geffner  universitat
pompeu fabra  
description  labeled rtdp with lower bounds extracted from the problem description 
 group q  michigan tech  probapop 
participants  nilufer onder  garrett c  whelan and li li  all of michigan technological university  
description  pop style planner  no sensing  
 group r  cert
participants  florent teichteil konigsbuch and patrick fabiani  both of cert  
description  probabilistic reachability heuristic and dbns 
    evaluation tracks
it was clear from the discussions leading up to the competition that different groups were
prioritizing their efforts differently  we wanted to ensure that a diverse set of powerful
approaches were recognized and decided to tabulate results in several different ways to
acknowledge the value of these different approaches  the six tracks were 
   

fiyounes  littman  weissman   asmuth

 overall  this track used a reward based evaluation criterion for all domains  goal
achievement counted as     for goal based domains   domains  blocksworld    problems   colored blocksworld      boxworld      exploding blocksworld      fileworld
     tireworld      towers of hanoise      zeno travel     
 goal based  for this track  we ignored action costs and counted goal achievement
as a unit reward  thus emphasizing approaches that maximized the probability of
reaching a goal state   the domains and problems used were the same as in the
overall track  blocksworld      colored blocksworld      boxworld      exploding
blocksworld      fileworld      tireworld      towers of hanoise      zeno travel     
 overall  non blocks box  blocksworld and boxworld dominated the full set
and we wanted to see how subtler problems were handled  domains  exploding
blocksworld      fileworld      tireworld      towers of hanoise      zeno travel     
 domain specific  domain specific allowed human tuned rules  domain specific 
no tuning did not  only automatically generated rules specific to the domain were
allowed   they were evaluated using the generated domains  blocksworld      colored
blocksworld      boxworld     
 conformant  planners in this category had to produce straight line plans  blind to
intermediate states encountered  we prepared unobservable versions of the domains
to evaluate planners in this category  domains  blocksworld      colored blocksworld
     boxworld      exploding blocksworld      fileworld      tireworld      towers of
hanoise      zeno travel     
    results
to display the results for each evaluation track  we plotted the cumulative reward achieved
by each participant over the set of evaluation problems  reward is accumulated left to right  
in the reward based tracks  goal achievement was counted as     for problems without an
explicitly specified goal reward  these plots highlight where one planner has an advantage
over another  greater slope  as well as the total difference in score  height difference between
the lines  
figure   displays the results in the overall category  two planners  j  and p  produced
significantly more positive results than the others  with the replanning algorithm j  clearly
dominating the others  j  was crowned overall winner  with p as runner up  the figure
also displays the results for the conformant category  which consisted solely of q  the
uncontested winner of the category 
similar results are visible in the goal based track  displayed in figure    in which j 
again comes out ahead with p achieving runner up status  comparing figures   and  
reveals that the margin of victory between j  and p  r and g  is diminished in the goalbased category  this suggests that j  is more sensitive to the rewards themselveschoosing
cheaper paths among the multiple paths available to the goal  in the set of problems used in
the competition  this distinction was not very significant and the graphs look very similar 
however  a different set of test problems might have revealed the fundamental tradeoff
   

fi   
zeno travel

tower of hanoise

tireworld  reward 

tireworld  goal 

fileworld

exploding blocksworld

boxworld          goal 

boxworld         goal 

boxworld         

boxworld         

boxworld        

colored blocksworld     goal 

colored blocksworld    

blocksworld     goal 

blocksworld     

blocksworld     

blocksworld     

    

blocksworld     

blocksworld    

blocksworld    

cumulative reward

the first probabilistic track of ipc

j 
p
c
g 
r
q

    

    

    

    

 

figure    competition results in the overall category  the result for the conformant category is the line marked q  the numbers in parentheses indicate problem size 
number of blocks for blocksworld domains  number of cities and boxes  respectively  for boxworld domains 

fiyounes  littman  weissman   asmuth

j 
p
c
g 
r
q

  

cumulative goal probability

  

  

 

 

 

 

zeno travel

tower of hanoise

tireworld  reward 

tireworld  goal 

fileworld

exploding blocksworld

boxworld          goal 

boxworld         goal 

boxworld         

boxworld         

boxworld        

colored blocksworld     goal 

colored blocksworld    

blocksworld     goal 

blocksworld     

blocksworld     

blocksworld     

blocksworld     

blocksworld    

blocksworld    

 

figure    competition results in the goal based category 
between seeking to maximize reward and seeking to reach the goal with high probability 
future competitions could attempt to highlight this important issue 
it is very interesting to note that j s outstanding performance stems primarily from
the early problems  which are the blocksworld and boxworld problems that are amenable
to replanning  the later problems in the set were not handled as well by j  as by most
other planners 
figure   displays the results for the non block box category  indeed  j  performed
much more poorly on the problems is this category  with planner c taking the top spot 
the runner up spot was closely contested between planners r and g   but g  pulled ahead
on the last problem to claim the honors  planner p also performed nearly as well on this
set 
figure    gives a more detailed view of the results in the non blocks box category 
the optimal score for each problem is indicated in the graphs   note that planner cs
performance in the tireworld domain is well above optimal  the result of a now fixed bug in
the competition server that allowed disabled actions to be executed  planner p displayed
outstanding performance on the fileworld and goal based tireworld problems  but did not
attempt to solve tower of hanoise and therefore fell behind g  and r overall  planner r
used more time per round than planner g  in the zeno travel domain  which ultimately
cost r the second place because it could only complete    of the    runs in this domain 
note that some planners received a negative score on the reward oriented problems  we
   the optimal scores do not necessarily apply to planner q  which is a conformant planner 

   

fithe first probabilistic track of ipc

c
g 
r
p
j 
q

    

cumulative reward

   

   

   

   

zeno travel

tower of hanoise

tireworld  reward 

tireworld  goal 

fileworld

exploding blocksworld

 

figure    summary of competition results in the overall  non blocks box category 
counted negative scores on individual problems as zero in the overall evaluation so as not to
give an advantage to planners that did not even attempt to solve some problems  planner q
was the only entrant  except  possibly  for c  to receive a positive score on the reward based
tireworld problem  the planners with negative score for this problem used the expensive
call aaa action to ensure that the goal was always reached 
the results for the domain specific planners are shown in figure     the highest scoring
planners were j  and g   with the difference between them primarily due to the two largest
blocksworld problems  which j  solved more effectively than g   the performance of the
five domain specific planners on the colored blocksworld problems is virtually indistinguishable  as mentioned earlier  grounding of the goal condition in the validator prevented us
from using larger problem instances  which might otherwise have separated the planners in
this domain 
the two planners that won the domain specific category were ineligible for the no
tuning subcategory because they were hand tuned for these domains  thus  j  and j 
took the top spots in the subcategory  it is interesting to note that j  won in spite of being
a general purpose plannerit was not  in fact  created to be domain specific  it overtook
j  due to two small boxworld problems that j  solved but j  missed 
figure    summarizes the competition results in the six evaluation categories 

   conclusion
we are happy with the outcomes of the first probabilistic track of the international planning
competition  in addition to bringing attention to this important set of planning challenges 
   

fiyounes  littman  weissman   asmuth

exploding blocksworld

tireworld  goal 

 

 

  
max prob 

   

goal probability

   
   
   
 

   
   
   
   

 
c

g 

 
p

j 

 
q

 
r

 
c

 

   
 

 

 

 
    

prob 
max prob 
reward
max reward
g 

j 

q

r

p

q

prob 
max prob 
reward
max reward

   

   

c

p

  

   
goal probability

 
   
   
   
   
 

j 

tireworld  reward 

reward

goal probability

fileworld

g 

   

  
  

   

  

   

  

 

    

reward

goal probability

max prob 

 

    

   

    
r

c

g 

tower of hanoise

j 

p

q

r

zeno travel
max prob 

 

 

   

goal probability

goal probability

max prob 

   
   
   
 

   
   
   
   

 
c

g 

j 

 
p

 
q

 
r

c

g 

j 

p

q

r

figure     competition results for non blocks box problems    indicates that a planner
did not attempt to solve a problem     indicates anomalous results due to a bug
in the server that allowed the execution of disabled actions   note that the two
graphs in the center have reward scales to the right 

   

fithe first probabilistic track of ipc

j  
g  
j 
j 
e 

    
    

cumulative reward

    
    
    
    
    
    

boxworld          goal 

boxworld         goal 

boxworld         

boxworld         

boxworld        

colored blocksworld      goal 

colored blocksworld     goal 

colored blocksworld     goal 

colored blocksworld     

colored blocksworld    

colored blocksworld    

blocksworld     goal 

blocksworld     

blocksworld     

blocksworld     

blocksworld     

blocksworld    

blocksworld    

 

figure     competition results in the domain specific categories  for the no tuning
category results  ignore the j   g   and e lines on the graph  marked with
asterisks  

category
overall
goal based domains
overall  non blocks box
domain specific  no tuning
domain specific
conformant

 st
j 
j 
c
j 
j 
q

 nd
p
p
g 
j 
g 

figure     summary of competition results by category 

   

fiyounes  littman  weissman   asmuth

it appears to have helped spur the community to use uniform comparison problems by
providing a domain language and a set of benchmarks  yoon  fern    givan        
in spite of the success  we feel there are changes that could be made in future competitions that would increase their value to the community  first  on the competition logistics
side  our server logged outcomes of the interactions between planners and domains  but did
not keep an exhaustive record of the actions taken and timing information  in retrospect 
such information would have been helpful in identifying how the planners addressed the
domains and whether they took suboptimal actions or just got unlucky  in addition  our
server had no provisions for security  a simple password and or reservation system would
have helped the evaluations go much more smoothly as it would have prevented inadvertent
access to the server by one group when another was assigned an evaluation slot 
on the domain side  we hope future competitions are able to focus on more interesting
domains  we found that simply adding noisy action failures to a deterministic domain was
not enough to produce interesting probabilistic problemsfor such domains  straightforward replanning can be very effective  the non blocksworld domains we created were not
mastered by any of the planners and we hope that they are retained in some form in future
evaluations 
like the progression of competitions in the classical track  we hope future competitions
in the probabilistic track move toward domains grounded in real life data and real world
problems including the handling of partially observability and time  a second competition
is slated to be held in conjunction with ipc in      and we urge interested members of the
planning community to participate to help keep the competition moving in a productive
direction for the benefit of the field 

acknowledgments
we appreciate the support of the national science foundation and the royal swedish
academy of engineering sciences  as well as the feedback of sven koenig  shlomo zilberstein  paul batchis  bob givan  hector geffner and other participants who contributed to
the design of the competition  jair editor david smith and his anonymous reviewers provided invaluable insights on the document that we tried to reflect in this final manuscript 
this material is based upon work supported by the national science foundation under
grant no          and the royal swedish academy of engineering sciences  iva  with
grants from the hans werthen fund  any opinions  findings  and conclusions or recommendations expressed in this material are those of the author s  and do not necessarily reflect
the views of the national science foundation or iva 

   

fithe first probabilistic track of ipc

appendix a  bnf grammar for ppddl   
we provide the full syntax for ppddl    using an extended bnf notation with the following conventions 
 each rule is of the form hnon terminal i     expansion 
 alternative expansions are separated by a vertical bar     
 a syntactic element surrounded by square brackets    and    is optional 
 expansions and optional syntactic elements with a superscripted requirements flag are
only available if the requirements flag is specified for the domain or problem currently
being defined  for example   htypes def i  typing in the syntax for domain definitions
means that htypes def i may only occur in domain definitions that include the  typing
flag in the requirements declaration 
 an asterisk     following a syntactic element x means zero or more occurrences of
x   a plus      following x means at least one occurrence of x 
 parameterized non terminals  for example htyped list  x  i  represent separate rules for
each instantiation of the parameter 
 terminals are written using typewriter font 
 the syntax is lisp like  in particular  case is not significant  for example   x and  x
are equivalent   parenthesis are an essential part of the syntax and have no semantic
meaning in the extended bnf notation  and any number of whitespace characters
 space  newline  tab  etc   may occur between tokens 
a   domains
the syntax for domain definitions is the same as for pddl     except that durative actions
are not allowed  declarations of constants  predicates  and functions are allowed in any
order with respect to one another  but they must all come after any type declarations and
precede any action declarations 
hdomaini

hrequire def i
hrequire keyi
htypes def i
hconstants def i
hpredicates def i

      define   domain hnamei  
 hrequire def i 
 htypes def i  typing
 hconstants def i 
 hpredicates def i 
 hfunctions def i  fluents
hstructure def i   
       requirements hrequire keyi   
    see section a  
       types htyped list  name i  
       constants htyped list  name i  
       predicates hatomic formula skeletoni   
   

fiyounes  littman  weissman   asmuth

hatomic formula skeletoni
hpredicatei
hfunctions def i
hfunction skeletoni
hfunction symbol i
hstructure def i
haction def i
htyped list  x  i
htypei
hprimitive typei
hfunction typed list  x  i
hfunction typei

      hpredicatei htyped list  variable i  
    hnamei
       functions hfunction typed list  function skeleton i  
      hfunction symbol i htyped list  variable i  
    hnamei
    haction def i
    see section a  
    hx i    typing hx i    htypei htyped list  x  i
      either hprimitive typei      hprimitive typei
    hnamei
    hx i 
  typing hx i    hfunction typei hfunction typed list  x  i
    number

a hnamei is a string of characters starting with an alphabetic character followed by a
possibly empty sequence of alphanumeric characters  hyphens      and underscore characters      a hvariablei is a hnamei immediately preceded by a question mark      for
example  in office and ball   are names  and  gripper is a variable 
a   actions
action definitions and goal descriptions have the same syntax as in pddl    
haction def i

       action haction symbol i
  parameters   htyped list  variable i   
haction def bodyi  
haction symbol i
    hnamei
haction def bodyi
      precondition hgdi 
  effect heffecti 
hgdi
    hatomic formula  term i     and hgdi   
  equality     htermi htermi  
  equality   not     htermi htermi    
  negative preconditions   not hatomic formula  term i  
  disjunctive preconditions   not hgdi  
  disjunctive preconditions   or hgdi   
  disjunctive preconditions   imply hgdi hgdi  
  existential preconditions   exists   htyped list  variable i  
hgdi  
  universal preconditions   forall   htyped list  variable i  
hgdi  
  fluents hf compi
hatomic formula  x  i       hpredicatei hx i      hpredicatei
htermi
    hnamei   hvariablei
hf compi
      hbinary compi hf expi hf expi  
hbinary compi
                       
hf expi
    hnumber i   hf head  term i
   

fithe first probabilistic track of ipc

hf head  x  i
hbinary opi

    hbinary opi hf expi hf expi         hf expi  
      hfunction symbol i hx i      hfunction symbol i
                 

a hnumber i is a sequence of numeric characters  possibly with a single decimal point    
at any position in the sequence  negative numbers are written as    hnumber i  
the syntax for effects has been extended to allow for probabilistic effects  which can be
arbitrarily interleaved with conditional effects and universal quantification 
heffecti

    hp effecti     and heffecti   
  conditional effects   forall   htyped list  variable i   heffecti  
  conditional effects   when hgdi heffecti  
  probabilistic effects   probabilistic hprob effecti   
hp effecti
    hatomic formula  term i     not hatomic formula  term i  
  fluents   hassign opi hf head  term i hf expi  
  rewards   hadditive opi hreward fluenti hf expi  
hprob effecti
    hprobabilityi heffecti
hassign opi
    assign   scale up   scale down   hadditive opi
hadditive opi     increase   decrease
hreward fluenti       reward     reward

a hprobabilityi is a hnumber i with a value in the interval        
a   problems
the syntax for problem definitions has been extended to allow for the specification of a
probability distribution over initial states  and also to permit the association of a one time
reward with entering a goal state  it is otherwise identical to the syntax for pddl   
problem definitions 
hproblemi

hobjects def i
hiniti
hinit el i
hp init el i
hprob init el i
ha init el i
hgoal i
hgoal speci
hmetric speci

      define   problem hnamei  
   domain hnamei  
 hrequire def i 
 hobjects def i 
 hiniti 
hgoal i  
       objects htyped list  name i  
       init hinit el i   
    hp init el i
  probabilistic effects   probabilistic hprob init el i   
    hatomic formula  name i   fluents     hf head  name i hnumber i  
    hprobabilityi ha init el i
    hp init el i     and hp init el i   
    hgoal speci  hmetric speci    hmetric speci
       goal hgdi       goal reward hground f expi    rewards
       metric hoptimizationi hground f expi  
   

fiyounes  littman  weissman   asmuth

hoptimizationi     minimize   maximize
hground f expi     hnumber i   hf head  name i
    hbinary opi hground f expi hground f expi  
      hground f expi  
    total time     total time
    goal achieved     goal achieved
  rewards hreward fluenti
a   requirements
below is a table of all requirements in ppddl     some requirements imply others  some
are abbreviations for common sets of requirements  if a domain stipulates no requirements 
it is assumed to declare a requirement for  strips 
requirement
 strips
 typing
 equality
 negative preconditions
 disjunctive preconditions
 existential preconditions
 universal preconditions
 quantified preconditions
 conditional effects
 probabilistic effects
 rewards
 fluents
 adl

 mdp

description
basic strips style adds and deletes
allow type names in declarations of variables
support   as built in predicate
allow negated atoms in goal descriptions
allow disjunctive goal descriptions
allow exists in goal descriptions
allow forall in goal descriptions
   existential preconditions
   universal preconditions
allow when and forall in action effects
allow probabilistic in action effects
allow reward fluent in action effects and
optimization metric
allow numeric state variables
   strips    typing    equality
   negative preconditions
   disjunctive preconditions
   quantified preconditions
   conditional effects
   probabilistic effects    rewards

   

fithe first probabilistic track of ipc

client

server

  session request  
 
 
  session init  
 
 

  round request  
 
 
  round init  
 
 

  state  
 
 
  action
 

spec   

  
 
  state  
 
 
  action
 

spec   

  end round  
 
 










 repeat










  end session  
 
 

figure     successful communication session 

appendix b  communication protocol
we adopt an xml like syntax for the client server communication protocol  we use the
same extended bnf notation as in appendix a to describe the syntax of protocol messages 
the hnamei and hnumber i terminals are defined in exactly the same way as for ppddl  an
hinteger i is a nonempty string of numeric characters  a hmessagei is an arbitrary character
string  possibly empty 
figure    shows the expected sequence of messages  a session starts by the client
sending a hsession requesti message to the server  the server replies with a hsession initi
message  which tells the client the number of evaluation rounds that will be run  to start
an evaluation round  the client sends a hround requesti message  to which the server replies
with a hround initi message  at this point the evaluation round starts  the server sends
a hturn responsei message to the client  which can be a hstatei message or an hend round i
message  for every hstatei message that the client receives  it sends an haction speci message
in return  once the client receives an hend round i message  it ends the current evaluation
round  the client then starts a new evaluation round with a hround requesti message to
the server  or waits for an hend sessioni message from the server in case all rounds have
already been run  the server sends an herror i message to the client if an error occurs  for
example if the server receives an unexpected message from the client 
   

fiyounes  littman  weissman   asmuth

b   client messages
client messages have the following form 
hsession requesti      session request 
 name  hnamei   name 
 problem  hnamei   problem 
  session request 
hround requesti

     round request  

haction speci
hactioni
htermi

     act  hactioni   act     done  
     action   name  hnamei   name  htermi    action 
     term  hnamei   term 

b   server messages
server messages have the following form 
hsession initi

     session init 
 sessionid  hinteger i   sessionid 
 setting 
 rounds  hinteger i   rounds 
 allowed time  hinteger i   allowed time 
 allowed turns  hinteger i   allowed turns 
  setting 
  session init 

hround initi

     round init 
 round  hinteger i   round 
 sessionid  hinteger i   sessionid 
 time left  hinteger i   time left 
 rounds left  hinteger i   rounds left 
  round init 

hturn responsei     hstatei   hend round i
hend round i
     end round 
hstatei   goal reached   
 time spent  hinteger i   time spent 
 turns used  hinteger i   turns used 
  end round 
hstatei
     state    is goal    hatomi  hfluenti    state 
hatomi
     atom  hpredicatei htermi    atom 
hfluenti
     fluent  hfunctioni htermi  hvaluei   fluent 
hpredicatei
     predicate  hnamei   predicate 
hfunctioni
     function  hnamei   function 
htermi
     term  hnamei   term 
   

fithe first probabilistic track of ipc

hvaluei

     value  hnumber i   value 

hend sessioni

     end session 
 sessionid  hinteger i   sessionid 
 problem  hnamei   problem 
 rounds  hinteger i   rounds 
 goals 
 failed  hinteger i   failed 
 reached 
 successes  hinteger i   successes 
  time average  hnumber i   time average  
  reached 
  goals 
  metric average  hnumber i   metric average  
  end session 

herror i

     error  hmessagei   error 

   

fiyounes  littman  weissman   asmuth

references
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions and computational leverage  journal of artificial intelligence research 
        
boutilier  c   dearden  r     goldszmidt  m          exploiting structure in policy construction  in mellish  c  s   ed    proceedings of the fourteenth international joint
conference on artificial intelligence  pp            montreal  canada  morgan kaufmann publishers 
boutilier  c   friedman  n   goldszmidt  m     koller  d          context specific independence in bayesian networks  in proceedings of the twelfth annual conference on
uncertainty in artificial intelligence  uai      pp          portland  or 
dean  t     kanazawa  k          a model for reasoning about persistence and causation 
computational intelligence                
dearden  r     boutilier  c          abstraction and approximate decision theoretic planning  artificial intelligence                  
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research            
guestrin  c   koller  d   parr  r     venkataraman  s          efficient solution algorithms
for factored mdps  journal of artificial intelligence research             
hoey  j   st aubin  r   hu  a     boutilier  c          spudd  stochastic planning using
decision diagrams  in laskey  k  b     prade  h   eds    proceedings of the fifteenth
conference on uncertainty in artificial intelligence  pp          stockholm  sweden 
morgan kaufmann publishers 
howard  r  a          dynamic programming and markov processes  john wiley   sons 
new york  ny 
howard  r  a          dynamic probabilistic systems  vol  i  markov models  john wiley
  sons  new york  ny 
kushmerick  n   hanks  s     weld  d  s          an algorithm for probabilistic planning 
artificial intelligence                  
littman  m  l          probabilistic propositional planning  representations and complexity  in proceedings of the fourteenth national conference on artificial intelligence 
pp          providence  ri  american association for artificial intelligence  aaai
press 
littman  m  l   goldsmith  j     mundhenk  m          the computational complexity of
probabilistic planning  journal of artificial intelligence research         
mcdermott  d          the      ai planning systems competition  ai magazine         
     
puterman  m  l          markov decision processes  discrete stochastic dynamic programming  john wiley   sons  new york  ny 
   

fithe first probabilistic track of ipc

rintanen  j          expressive equivalence of formalisms for planning with sensing  in
giunchiglia  e   muscettola  n     nau  d  s   eds    proceedings of the thirteenth international conference on automated planning and scheduling  pp          trento 
italy  aaai press 
yoon  s   fern  a     givan  r          learning measures of progress for planning domains 
in proceedings of the twentieth national conference on artificial intelligence  pp 
         
younes  h  l  s     littman  m  l          ppddl     an extension to pddl for expressing
planning domains with probabilistic effects  tech  rep  cmu cs         carnegie
mellon university  pittsburgh  pa 

   

fi