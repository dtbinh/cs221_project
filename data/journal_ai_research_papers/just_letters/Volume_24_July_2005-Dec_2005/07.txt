journal of artificial intelligence research                  

submitted        published      

engineering note
optiplan  unifying ip based and graph based planning
menkes h l  van den briel

menkes asu edu

department of industrial engineering
arizona state university  tempe  az       usa

subbarao kambhampati

rao asu edu

department of computer science and engineering
arizona state university  tempe  az       usa

abstract
the optiplan planning system is the first integer programming based planner that
successfully participated in the international planning competition  this engineering note
describes the architecture of optiplan and provides the integer programming formulation
that enabled it to perform reasonably well in the competition  we also touch upon some
recent developments that make integer programming encodings significantly more competitive 

   introduction
optiplan is a planning system that uses integer linear programming  ip  to solve strips
planning problems  it is the first such system to take part in the international planning
competition  ipc  and was judged the second best performer in four competition domains
of the optimal track for propositional domains  optiplans underlying integer programming
formulation extends the state change model by vossen and his colleagues         its architecture is very similar to that of blackbox  kautz   selman        and gp csp  do  
kambhampati         but instead of unifying satisfiability  sat  or constraint satisfaction
 csp  with graph based planning  optiplan uses integer programming  like blackbox and
gp csp  optiplan works in two phases  in the first phase a planning graph is built and
transformed into an ip formulation  then in the second phase the ip formulation is solved
using the commercial solver ilog cplex  ilog inc         
a practical difference between the original state change model and optiplan is that the
former takes as input all ground actions and fluents over all initialized plan steps  while
the latter takes as input just those actions and fluents that are instantiated by graphplan
 blum   furst         it is well known that the use of planning graphs has a significant
effect on the size of the final encoding no matter what combinatorial transformation method
 ip  sat  or csp  is used  for instance  kautz and selman        as well as kambhampati
       pointed out that blackboxs success over satplan  kautz   selman        was mainly
explained by graphplans ability to produce better  more refined  propositional structures
than satplan  in addition  optiplan allows propositions to be deleted without being required
as preconditions  such state changes are not modeled in the original state change model  and
therefore optiplan can be considered to be a more general encoding  one more  although
c
    
ai access foundation  all rights reserved 

fivan den briel    kambhampati

minor  implementation detail between optiplan and the state change model is that optiplan
reads in pddl files 
this engineering note is organized as follows  section   provides a brief background on
integer programming and section   discusses previous ip approaches to planning  section
  describes the optiplan planning system and its underlying ip formulation  in section  
we give some experimental results and look at optiplans performance in the international
planning competition of       ipc    conclusions and a brief discussion on some recent
developments is given in section   

   background
a linear program is represented by a linear objective function and a set of inequalities  such
as min cx   ax  b  x     where x an n dimensional column vector of variables  a is an
m by n matrix  c an n dimensional row vector  and b an m dimensional column vector  if
all variables are constrained to be integers then we have an integer  linear  program  and if
all variables are restricted to     values then we have a binary integer program 
the most widely used method for solving general integer programs is by using branch
and bound on the linear programming relaxation  branch and bound is a general search
method in which subproblems are created that restrict the range of the integer variables 
and the linear programming relaxation is a linear program obtained from the original integer
program by omitting the integrality constraints  an ideal formulation of an integer program
is one for which the solution of the linear programming relaxation is integral  even though
every integer program has an ideal formulation  wolsey         in practice it is very hard to
characterize the ideal formulation as it may require an exponential number of inequalities 
in problems where the ideal formulation cannot be determined  it is often desirable to find
a strong formulation of the integer program  suppose that p    min cx   a  x  b    x    
and p    min cx   a  x  b    x     are the linear programming relaxations of two ip
formulations of a problem  then we say that formulation p  is stronger than formulation p 
if p   p    that is  the set of solutions of p  is subsumed by the set of solutions of p   

   integer programming approaches to planning
despite the vast amount of research that has been conducted in the field of ai planning  the
use of linear programming  lp  and integer linear programming have only been explored at
a marginal level  this is quite surprising since  mixed  integer linear programming provide
feasible environments for using numeric constraints and arbitrary linear objective functions 
two important aspects in real world planning problems 
only a handful of works have explored the use of lp and ip techniques in ai planning 
bylander        developed an ip formulation for classical planning and used the lp relaxation as a heuristic for partial order planning  the results  however  do not seem to scale
well compared to planning graph and satisfiability based planners 
the difficulty in developing strong ip formulations is that the performance often depends on the way the ip formulation is constructed  vossen et al         compared two
formulations for classical planning  first  they consider a straightforward ip formulation
based on converting the propositional representation given by satplan  kautz   selman 
   

fioptiplan  unifying ip based and graph based planning

      to an ip formulation with variables that take the value   if a certain proposition
is true  and   otherwise  in this formulation  the assertions expressed by ip constraints
directly correspond to the logical conditions of the propositional representation  second 
they consider an ip formulation in which the original propositional variables are replaced
by state change variables  state change variables take the value   if a certain proposition is
added  deleted  or persisted  and   otherwise  vossen et al  show that the formulation based
on state change variables outperforms the straightforward formulation based on converting
the propositional representation 
dimopoulos        improves the ip formulation based on state change variables by identifying valid inequalities that tighten the formulation  yet  even stronger ip formulations
are given by bockmayr and dimopoulos               but their ip formulations contain
domain dependent knowledge and are  therefore  limited to solving problems of specific
problem domains only 
lp and ip techniques have also been explored for non classical planning  dimopoulos
and gerevini        describe a mixed integer programming formulation for temporal planning and wolfman and weld        use an lp formulation in combination with a sat
formulation to solve resource planning problems  kautz and walser        also use ip
formulations for resource planning problems but  in addition  incorporate action costs and
complex objectives 
so far  none of these ip approaches to ai planning ever participated in the ipc  making
it harder to assess the relative effectiveness of this line of work  optiplan  a planner based
on the state change formulation  is the first ip based planner to do so 

   optiplan
optiplan is a planning graph based planner and works as follows  first we build the
planning graph to the level where all the goal fluents appear non mutex  then we compile
the planning graph into an integer program and solve it  if no plan is found  the planning
graph is extended by one level and the new graph is again compiled into an integer program
and solved again  this process is repeated until a plan is found 
in the remainder of this section we give the ip formulation that is used by optiplan  in
order to present the ip formulation we will use the following notation  f is the set of fluents
and a is the set of actions  operators   the fluents that are true in the initial state and
the fluents that must be true in the goal are given by i and g respectively  furthermore 
we will use the sets 
 pref  a  f  f  set of actions that have fluent f as precondition 
 addf  a  f  f  set of actions that have fluent f as add effect 
 delf  a  f  f  set of actions that have fluent f as delete effect 
variables are defined for each layer    t  t in the planning graph  there are
variables for the actions and there are variables for the possible state changes a fluent can
make  but only those variables that are reachable and relevant by planning graph analysis
are instantiated  for all a  a  t          t we have the action variables
   

fivan den briel    kambhampati

ya t  



  if action a is executed in period t 
  otherwise 

the no op actions are not included in the ya t variables but are represented separately
by the state change variable xmaintain
 
f t
optiplan is based on the state change formulation  vossen et al          in this formulation fluents are not represented explicitly  instead state change variables are used to model
transitions in the world state  that is  a fluent is true if and only if it is added to the state by
preadd
xadd
  or if it is persisted from the previous state by xmaintain
  optiplan extends
f t or xf t
f t
the state change formulation  vossen et al         by introducing an extra state change
variable  xdel
f t   that allows actions to delete fluents without requiring them as preconditions 
the original state change formulation did not allow for these actions  so therefore we added
these new state change variables to keep track of such state changes and altered the model
to take these new variables into account  in the ipc  domains of airport and psr there are
many actions that delete fluents without requiring them as preconditions  therefore making
the original state change formulation ineffective  also  optiplan instantiates only those
variables and constraints that are reachable and relevant through planning graph analysis 
and therefore creates a smaller encoding than the original one  for all f  f  t          t
we have the following state change variables 

  if fluent f is propagated in period t 
maintain
 
xf t
  otherwise 

  if action a is executed in period t such that a  pref  a 
  delf  
preadd
xf t
 
  otherwise 

  if action a is executed in period t such that a  pref  a  delf  
predel
xf t
 
  otherwise 

  if action a is executed in period t such that a 
  pref  a  addf  
 
xadd
f t
  otherwise 

  if action a is executed in period tsuch that a 
  pref  a  delf  
xdel
 
f t
  otherwise 
in summary  xmaintain
    if the truth value of a fluent is propagated  xpreadd
    if an
f t
f t
action is executed that requires a fluent and does not delete it  xpredel
    if an action is
f t
add
executed that requires a fluent and deletes it  xf t     if an action is executed that does
not require a fluent and adds it  and xdel
f t     if an action is executed that does not require
a fluent and deletes it  the complete ip formulation of optiplan is given by the following
objective function and constraints 

    objective
for classical ai planning problems  no minimization or maximization is required  instead
we want to find a feasible solution  the search for a solution  however  may be guided by
   

fioptiplan  unifying ip based and graph based planning

an objective function such as the minimization of the number of actions  which is currently
implemented in optiplan  the objective function is given by 
min

xx

ya t

   

aa it

since the constraints guarantee feasibility we could have used any linear objective function  for example  we could easily set up an objective to deal with cost sensitive plans
 in the context of non uniform action cost   utility sensitive plans  in the context of oversubscription and goal utilities   or any other metric that can be transformed to a linear
expression  indeed this flexibility to handle any linear objective function is one of the advantages of ip formulations 

    constraints
the requirements on the initial and goal transition are given by 
xadd
f      
maintain preadd
xadd
  xf  
f     xf  
maintain
xadd
  xpreadd
f t   xf t
f t

f  i

   

  

f 
 i

   

 

f  g

   

where constraints      and     add the initial fluents in step   so that they can be used
by the actions that appear in the first layer  step    of the planning graph  constraints
    represent the goal state requirements  that is  fluents that appear in the goal must be
added or propagated in step t  
the state change variables are linked to the actions by the following effect implication
constraints  for each f  f and    t  t we have 
x
ya t  xadd
   
f t
aaddf  pref

ya t  xadd
f t
x

ya t 

a  addf   pref

xdel
f t

   
   

adelf  pref

ya t  xdel
f t
x

a  delf   pref

ya t  xpreadd
f t

   
   

apref  delf

ya t  xpreadd
f t
x

ya t   xpredel
f t

a  pref   delf

    
    

apref delf

where constraints     to      represent the logical relations between the action and
state change variables  the equality sign in      is because all actions that have f as a
   

fivan den briel    kambhampati

precondition and as a delete effect are mutually exclusive  this also means that we can
substitute out the xpredel
variables  which is what we have done in the implementation of
f t
optiplan  we will  however  use the variables here for clarity  mutexes also appear between
different state change variables and these are expressed by constraints as follows 

predel
maintain
 
  xdel
xadd
f t   xf t
f t   xf t

    

predel
xpreadd
  xmaintain
  xdel
 
f t
f t   xf t
f t

    

where constraints      and      restrict certain state changes from occurring in parallel 
del
for example  xmaintain
 propagating fluent f at step t  is mutually exclusive with xadd
f t
f t   xf t  
and xpredel
 adding or deleting f at t  
f t
finally  the backward chaining requirements and binary constraints are represented by 

add
maintain
xpreadd
  xmaintain
  xpredel
 xpreadd
f t
f t
f t
f t    xf t    xf t 

f  f  t          t

    

del maintain
xpreadd
  xpredel
  xadd
      
f t   xf t   xf t
f t
f t

    

ya t       

    

where constraints      describe the backward chaining requirements  that is  if a fluent
f is added or maintained in step t  then the state of f can be changed by an action in step
t through xpreadd
  or xpredel
  or it can be propagated through xmaintain
  constraints     
f t
f t
f t
and      are the binary constraints for the state change and action variables respectively 

loc 

truck 

loc 

truck 

figure    a simple logistics example

    example
in this example  we show how some of the constraints are initialized and we comment on
the interaction between the state change variables and the action variables 
consider a simple logistics example in which there are two locations  two trucks  and
one package  the package can only be transported from one location to another by one of
the trucks  we built a formulation for three plan steps  the initial state is that the package
   

fioptiplan  unifying ip based and graph based planning

and the trucks are all at location   as given in figure    the initial state constraints are 
xadd
pack 

at loc   

xadd
truck 

at loc   
add
xtruck  at loc   
add maintain preadd
xf     xf  
  xf  

  
  
  
  

f    i

the goal is to get the package at location   in three plan steps  which is expressed as
follows 
xadd
pack 

at loc   

  xmaintain
pack  at

loc   

  xpreadd
pack  at

loc   

 

we will not write out all effect implication constraints  but we will comment on a few
of them  if xadd
f t     for a certain fluent f   then we have to execute at least one action a
that has f as an add effect and not as a precondition  for example 
yunload

truck  at loc  t

  yunload

truck  at loc  t

 xadd
pack 

at loc  t

preadd
the state changes for xdel
have a similar requirement  that is if we change
f t and xf t
the state through del or preadd then we must execute at least one action a with the corresponding effects  on the other hand  if we execute an action a then we must change all
fluent states according to the effects of a  for example 

yunload

truck  at loc  t

 xadd
pack 

yunload

truck  at loc  t



yunload

truck  at loc  t

 

at loc  t
preadd
xtruck at loc  t
xpredel
pack  in truck  t

there is a one to one correspondence  note the equality sign  between the execution of
actions and the xpredel
state change variables  this is because  actions that have the same
f t
predel effect must be mutex  mutexes are also present between state changes  for example 
a fluent f that is maintained  propagated  cannot be added or deleted  the only two state
changes that are not mutex are the add and the preadd  this is because the add state
change behaves like the preadd state change if the corresponding fluent is already present
in the state of the world  this is why we introduce two separate mutex constraints  one
that includes the add state change and one that includes the preadd  an example for the
constraints on the mutex state changes are as follows 
xadd
pack 

in truck  t

xpreadd
pack  in

truck  t

  xmaintain
pack  in

truck  t

  xdel
pack 

in truck  t

  xpredel
pack 

in truck  t

  

  xmaintain
pack  in

truck  t

  xdel
pack 

in truck  t

  xpredel
pack 

in truck  t

  

the state of a fluent can change into another state only if correct state changes have
occurred previously  hence  a fluent can be deleted  propagated  or used as preconditions
in step t if and only if it was added or propagated in step t     for example 
xpreadd
pack  in

predel
maintain
truck  t   xpack  in truck  t   xpack  in truck  t
add
maintain
xpreadd
pack  in truck  t    xpack  in truck  t    xpack  in truck  t 

   



fivan den briel    kambhampati

t  
xadd
pack 
xadd
truck 
xadd
truck 

at loc   

t  
yload truck  at loc   
xadd
pack  in truck   
xpredel
pack  at loc   
xpreadd
truck  at loc   

at loc   

xmaintain
truck  at

at loc   

t  
ydrive truck  loc  loc   
xmaintain
pack  in truck   
xadd
truck 
xpredel
truck 

at loc   

t  
yunload truck  at loc   
xadd
pack  at loc   
xpredel
pack  in truck   
xpreadd
truck  at loc   

at loc   

loc   

table    solution to the simple logistics example  all displayed variables have value   and
all other variables have value   

this simple problem has a total of     variables     action and    state change  and
   constraints  however  planning graph analysis fixes    variables     action and    state
change  to zero  after substituting these values and applying presolve techniques that are
built in the ilog cplex solver  this problem has only    variables and    constraints 
the solution for this example is given in table    note that  when there are no actions
that actively delete f   there is nothing that ensures xmaintain
to be true whenever f was
f t
true in the preceding state  for example  see the fluent truck  at loc    since negative
preconditions are not allowed  having the option of letting xmaintain
be false when it should
f t
have been true cannot cause actions to become executable when they should not be  we
will not miss any solutions because constraints     ensure that the goal fluents are satisfied 
therefore forcing xmaintain
to be true whenever this helps us generate a plan 
f t

   experimental results
first we compare optiplan with the original state change model  and then we check how
optiplan performed in the ipc of      
optiplan and the original state change formulation are implemented in two different
languages  optiplan is implemented in c   using concert technology  which is a set of
libraries that allow you to embed ilog cplex optimizers  ilog inc          and the
original state change model is implemented in ampl  fourer  gay    kernighan        
which is a modeling language for mathematical programming  in order to compare the
formulations that are produced by these two implementations  they are written to an output
file using the mps format  mps is a standard data format that is often used for transferring
linear and integer linear programming problems between different applications  once the
mps file  which contains the ip formulation for the planning problem  is written  it is read
and solved by ilog cplex     on a pentium      ghz with      gb of ram 
table   shows the encoding size of the two implementations  where the encoding size is
characterized by the number of variables and the number of constraints in the formulation 
both the encoding size before and after applying ilog cplex presolve is given  presolve is
a problem reduction technique  brearley  mitra    williams        that helps most linear
programming problems by simplifying  reducing and eliminating redundancies  in short 
   

fioptiplan  unifying ip based and graph based planning

problem
bw sussman
bw   step
bw large a
att log 
log easy
log a

state change model
before presolve
after presolve
 var   cons   var   cons 
   
   
   
   
    
    
    
    
    
     
    
    
    
    
  
  
     
     
    
    
     
     
    
    

optiplan
before presolve
after presolve
 var   cons   var   cons 
   
   
   
   
    
    
   
    
    
    
    
    
   
   
 
 
    
    
   
   
    
    
    
    

table    encoding size of the original state change formulation and optiplan before and
after ilog cplex presolve   var  and  cons  give the number of variables
and constraints respectively 

problem
bw sussman
bw   step
bw large a
bw large b
att log 
att log 
att log 
att log 
att log 
att loga
rocket a
rocket b
log easy
log a
log b
log c

 var 
   
    
    
    
  
   
   
    
    
    
    
    
    
    
    
    

state change model
 cons   nodes
   
 
    
  
    
 
     
  
  
 
   
 
   
  
    
  
    
  
    
   
    
   
    
   
    
  
    
   
    
   
    
   

time
    
    
    
      
    
    
    
    
    
      
     
    
    
      
     
      

 var 
   
   
    
    
 
  
  
   
   
    
   
    
   
    
    
    

optiplan
 cons   nodes
   
 
    
  
    
 
    
  
 
 
  
 
  
 
   
 
   
 
    
  
    
  
    
  
   
 
    
  
    
   
    
  

time
    
    
    
     
    
    
    
    
    
    
    
    
    
    
     
     

table    performance and encoding size of the original state change formulation and optiplan   var  and  cons  give the number of variables and constraints after
ilog cplex presolve  and  nodes give the number of nodes explored during
branch and bound before finding the first feasible solution 

   

fivan den briel    kambhampati

presolve tries to remove redundant constraints and fixed variables from the formulation 
and aggregate  substitute out  variables if possible 
from the encoding size before presolve  which is the actual encoding size of the problem 
we can see how significant the use of planning graphs is  optiplan  which instantiates
only those fluents and actions that are reachable and relevant through planning graph
analysis  produces encodings that in some cases are over one order of magnitude smaller than
the encodings produced by the original state change model  which instantiates all ground
fluents and actions  although the difference in the encoding size reduces substantially
after applying presolve  planning graph analysis still finds redundancies that presolve fails
to detect  consequently  the encodings produced by optiplan are still smaller than the
encodings that are produced by the original state change model 
the performance  and the encoding size after presolve  of optiplan and the original
state change model are given in table    performance is measured by the time to find the
first feasible solution  the results show the overall effectiveness of using planning graph
analysis  for all problems optiplan not only generates smaller encodings it also performs
better than the encodings generated by the state change model 
    ipc results
optiplan participated in the propositional domains of the optimal track in the ipc       in
this track  planners could either minimize the number of actions  like bfhsp and semsyn 
minimize makespan  like cpt  hsp a  optiplan  satplan    and tp    or minimize some
other metric 
the ipc results of the makespan optimal planners are given in figure    all results were
evaluated by the competition organizers by looking at the runtime and plan quality graphs 
also  all planners were compared to each other by estimating their asymptotic runtime and
by analyzing their solution quality performance  out of the seven competition domains 
optiplan was judged second best in four of them  this is quite remarkable because integer
programming has hitherto not been considered competitive in planning 
optiplan reached second place in the optical telegraph and the philosopher domains 
in these domains optiplan is about one order of magnitude slower than satplan    but it
clearly outperforms all other participating planners  in the pipesworld tankage domain 
optiplan was awarded second place together with satplan    and in the satellite domain
optiplan  cpt  and semsyn all tied for second place  in the other domains optiplan did
not perform too well  in the airport domain  optiplan solves the first    problems and
problem     but it takes the most time to do so  for the pipesworld notankage and the
psr domains  optiplan not only is the slowest it also solves the fewest number of problems
among the participating planners 
in looking at the domains and problems where optiplan has difficulty scaling  we notice
that these are problems that lead to very large ip encodings  since the size of the encoding is
a function of plan length  optiplan often fails to solve problems that have long solution plans 
one way to resolve this issue is to de link the encoding size from solution length  which is
what we have done in some of our recent work  van den briel  vossen    kambhampati 
       in fact  in the year following the ipc  we developed novel ip encodings that    
   

fioptiplan  unifying ip based and graph based planning

model transitions in the individual fluents as separate but loosely coupled network flow
problems  and that     control the encoding length by generalizing the notion of parallelism 

   conclusions
the optiplan planning system performs significantly better than the original state change
model by vossen and his colleagues         it performed respectably at the ipc   but still
lags behind sat  and csp based planners  like blackbox chaff   satplan   siege   and
gp csp  we believe  however  that this performance gap is not because ip techniques are
inferior to sat and csp  but rather a reflection of the types of ip formulations that have
been tried so far  specifically  the encodings that have been tried until now have not been
tailored to the strengths of the ip solvers  chandru   hooker        
our experience with optiplan has encouraged us to continue working on improved ip
formulations for ai planning  in our recent work  van den briel  vossen    kambhampati 
      we model fluents as loosely coupled network flow problems and control the encoding
length by generalizing the notion of parallelism  the resulting ip encodings are solved
within a branch and cut algorithm and yield impressive results  also  this new approach
has been shown to be highly competitive with the state of the art sat based planners 

references
blum  a     furst  m          fast planning through planning graph analysis  in proceedings
of the   th international joint conference on artificial intelligence  ijcai      pp 
         
bockmayr  a     dimopoulos  y          mixed integer programming models for planning problems  in working notes of the cp    constraint problem reformulation
workshop 
bockmayr  a     dimopoulos  y          integer programs and valid inequalities for planning problems  in proceedings of the european conference on planning  ecp     
pp          springer verlag 
brearley  a   mitra  g     williams  h          analysis of mathematical programming
problems prior to applying the simplex algorithm  mathematical programming    
     
bylander  t          a linear programming heuristic for optimal planning  in aaai   iaai    proceedings  pp         
chandru  v     hooker  j          optimization methods for logical inference  john wiley
  sons  new york 
dimopoulos  y          improved integer programming models and heuristic search for
ai planning  in proceedings of the european conference on planning  ecp      pp 
        springer verlag 
   

fivan den briel    kambhampati

     

     

    

    

   
time in sec 

time in sec 

   
  
optiplan

 

  
 
optiplan

satplan  
   

   

cpt

    

    
 

 

  

  

  

  

  

  

  

  

satplan  
cpt

tp 

 

  

 

  

     

     

    

    

   

   

time in sec 

time in sec 

  

  

  

  

  

satellite problem nr 

airport problem nr 

  
optiplan

 

  
 

satplan  
   

optiplan
   

cpt

satplan  

tp 

cpt

    

    
 

 

  

  

  

  

  

  

  

  

  

 

 

  

  

  

  

    

    

   

   

  

time in sec 

     

optiplan
satplan  

 

hsps a
 

 

 

 

 

 

 

  

  

     

 

  

 

satplan  

cpt

tp 

  

  

  

philosophers problem nr 

optical telegraph problem nr 

     
optiplan

    

satplan  
hsps a

   

tp 
cpt

  
 
   
    
 

  

optiplan
hsps a

    

    
 

  

 
   

tp 

 

  

  

cpt
   

 

  

pipesworld tankge problem nr 

     

time in sec 

time in sec 

pipesworld notankage problem nr 

  

 

  

  

  

  

  

  

  

  

  

psr problem nr 

figure    ipc      results for the makespan optimal planners 

   

  

fioptiplan  unifying ip based and graph based planning

dimopoulos  y     gerevini  a          temporal planning through mixed integer programming  in proceeding of the aips workshop on planning for temporal domains 
pp     
do  m     kambhampati  s          planning as constraint satisfaction  solving the planning graph by compiling it into csp  artificial intelligence                  
fourer  r   gay  d     kernighan  b          ampl  a modeling language for mathematical programming  duxbury press  belmont  ca 
ilog inc   mountain view  ca         ilog cplex     users manual 
kambhampati  s          challenges in bridging plan synthesis paradigms  in proceedings
of the   th international joint conference on artificial intelligence  ijcai      pp 
     
kautz  h     selman  b          planning as satisfiability  in proceedings of the european
conference on artificial intelligence  ecai  
kautz  h     selman  b          blackbox  unifying sat based and graph based planning 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai      pp         
kautz  h     walser  j          state space planning by integer optimization  in aaai   iaai    proceedings  pp         
van den briel  m   vossen  t     kambhampati  s          reviving integer programming approaches for ai planning  a branch and cut framework  in proceedings of the
international conference on automated planning and scheduling  icaps      pp 
       
vossen  t   ball  m   lotem  a     nau  d          on the use of integer programming
models in ai planning  in proceedings of the   th international joint conference on
artificial intelligence  ijcai      pp         
wolfman  s     weld  d          the lpsat engine and its application to resource planning  in proceedings of the   th international joint conference on artificial intelligence  ijcai      pp         
wolsey  l          integer programming  wiley interscience series in discrete mathematics
and optimization  john wiley   sons  new york 

   

fi