journal of artificial intelligence research                

submitted       published     

synthesizing customized planners from specifications
biplav srivastava
subbarao kambhampati

department of computer science and engineering
arizona state university  tempe  az       

biplav asu edu
rao asu edu

abstract

existing plan synthesis approaches in artificial intelligence fall into two categories  
domain independent and domain dependent  the domain independent approaches are applicable across a variety of domains  but may not be very ecient in any one given domain 
the domain dependent approaches need to be  re designed for each domain separately  but
can be very ecient in the domain for which they are designed  one enticing alternative
to these approaches is to automatically synthesize domain independent planners given the
knowledge about the domain and the theory of planning  in this paper  we investigate
the feasibility of using existing automated software synthesis tools to support such synthesis  specifically  we describe an architecture called clay in which the kestrel interactive
development system  kids  is used to derive a domain customized planner through a
semi automatic combination of a declarative theory of planning  and the declarative control knowledge specific to a given domain  to semi automatically combine them to derive
domain customized planners  we discuss what it means to write a declarative theory of
planning and control knowledge for kids  and illustrate our approach by generating a class
of domain specific planners using state space refinements  our experiments show that the
synthesized planners can outperform classical refinement planners  implemented as instantiations of ucp  kambhampati   srivastava         using the same control knowledge  we
will contrast the costs and benefits of the synthesis approach with conventional methods
for customizing domain independent planners 

   introduction

given the current state of the world  a set of desired goals  and a set of action templates 
 planning  involves synthesizing a sequence of actions which when executed from the initial
state will lead to a state of the world that satisfies all the goals  fikes   nilsson       
mcallester   rosenblitt        kambhampati      b   planning is known to be a combinatorially hard problem  and a variety of approaches for plan synthesis have been developed
over the past twenty years  these approaches can be classified into two broad categories
  domain independent and domain dependent  domain independent planners do not make
any assumptions about the planning domains  and can thus accept and solve planning problems from any domain  in contrast  domain specific planners are specifically designed for a
single domain and thus have the dynamics and control knowledge of the domain hard coded 
the advantage of domain independent planning is that once a planning algorithm is
designed  it can be used in any domain by simply changing the action template that is
input to the algorithm  in contrast  domain specific planners would have to be  modified 
or  re designed  for each domain  on the ip side  domain specific planners tend to be more

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fisrivastava   kambhampati

theory of refinement

domain knowledge

planning
control knowledge
 eg  planes dont touchdown
without delivering packages 

  fss
  bss
kids

  pss
  htn
dynamical model
 action operator description 

problem

customized
planner

plan

figure    architectural overview of planner synthesis with kids in the clay approach 
the theories of refinement planning and domain knowledge are declaratively specified to kids which in turn combines them to produce a customized planner for
the domain  the resulting planner  like conventional planners  can handle any
planning problem from the domain  for a detailed description  see section   
ecient in their designated domains than domain independent planners since the latter may
not be able to effectively exploit the control knowledge of every domain 
not surprisingly  a significant amount of work in ai planning has been aimed at improving the performance of domain independent planners by dynamically customizing them to
a given domain  this customization is done by providing the domain writer the ability to
control the search of the planner  as is the case in task reduction planning  kambhampati
  srivastava        kambhamapti         or by using learning techniques  kambhampati 
katukam    qu        minton         although several approaches have been developed
for learning to improve planning performance  at present they are not an effective match
for the eciency of domain dependent planners 
one intriguing alternative is to automatically synthesize domain dependent planners
given the knowledge about the domain and the theory of planning  in this paper  we investigate the feasibility of using existing automated software synthesis tools to support such
a synthesis  we introduce the clay architecture which supports the synthesis of domain
dependent planners using kids  a semi automated software synthesis system  specifically 
as shown in figure    a declarative theory of plan synthesis  theory of planning  is combined
with the control knowledge specific to a given domain in a semi automated software synthesis system called kestrel interactive development system   kids  smith            a 
  

fisynthesizing customized planners from specifications

    b  to derive a customized planner for the domain  we will draw the declarative theory
of plan synthesis from domain independent planning techniques  domain specific control
knowledge will be expressed in terms of the types of plans that are preferred in the given
domain 
such an approach strikes a promising middle ground between domain independent and
domain dependent planners  the theories of planning are encoded independent of domains 
and the domain control knowledge can be encoded independent of the specific planning
theory being used  the customization step compiles the domain control knowledge into the
planning algorithm and ensures that the resulting planners are able to exploit the structure
of the domain 

    overview of the synthesis approach

as briey mentioned above  the practicality of our approach is predicated on the availability
of a software synthesis system capable of deriving code from formal specifications  kids is
a powerful semi automated system for development of correct and ecient programs from
formal specifications  given a domain theory and the input output specification of a task 
kids system helps in synthesizing a program capable of solving the task  here  the term
theory refers to any useful body of knowledge  task refers to any assignment that is given
to kids for solving and the solution is a program for that task  the input to kids is a task
theory comprised of the task specification and a declarative description of useful concepts
and rules to reason in the task space  in this research  we give planning as a task to kids
and expect it to synthesize and return a planner as the solution  the planner can then take
planning problems as input and return results  plans  
in order to support planner synthesis  we have to develop and input a theory of planning
to kids  as discussed in  kambhampati      b   the traditional plan synthesis techniques
can be described in terms of a common plan representation  with different planners corresponding to different ways of refining the partial plans such as progression  regression and
plan space refinements  see section       consequently  our planning theory will consist of
a specification of the planning task  in terms of input and output data types  and one or
more refinement theories  since we are also interested in domain customized planners  we
have to provide the necessary domain knowledge to kids 
given these inputs  kids semi automatically synthesizes a program  in this case  a domain dependent refinement planner  using generic algorithm design tactics  such as branch
and bound  global search   the resulting planner  like conventional planners  can handle
any planning problem from the domain  see section   for more details 

    outcomes

to understand the ecacy of plan synthesis in clay  in this paper  we concentrate on the
synthesis of planners using state space refinement theories   empirical evaluation shows
that these synthesized planners can be very ecient  for example  in the blocks world
domain where the goal was stack inversion  a kids synthesized planner solved a    blocks
problem in under a minute  in the logistics domain  a problem with    packages    planes
   in future  we plan to extend our approach to plan space and task reduction refinements 

  

fisrivastava   kambhampati

and   places was solved in under a minute  similarly  in the tyre domain  russell   norvig 
       the  fixit  problem was solved in under a minute  to put these performance results
in perspective  we compared kids  synthesized planners to a set of classical planners implemented as the instantiations the ucp planning system  kambhampati   srivastava 
       as described later  instantiations of ucp can emulate a spectrum of classical planners  including the popular snlp planner  mcallester   rosenblitt         by selecting
the appropriate refinement  in our experiments  the best of the kids  synthesized planners
outperformed the best of the ucp instantiations when given the same domain specific information  we hypothesize that this is because kids can profitably fold in the domain specific
control knowledge  i e   the domain theory  into the planning code 

    organization

the rest of this paper describes the details of our approach  called the clay architecture
for planner synthesis  the paper is organized as follows  after a brief review of traditional
plan synthesis approaches and software synthesis on kids in section    we walk through
the clay framework in section    section   presents a discussion on the nature of planners
synthesized by our approach  section   empirically evaluates the synthesized planners and
compares them to classical planners  section   discusses related work  section   describes
our conclusions and discusses the costs and benefits of the synthesis approach 

   background

in this section  we briey discuss relevant background on software synthesis with kids 
and plan generation that will be needed to follow the rest of the paper 

    kestrel interactive development system

before discussing kids  we start with some preliminaries on automated software synthesis 
the holy grail of software synthesis is to  
 produce highly reliable  adaptable software in a greatly reduced development time 
 automate detail intensive tasks in software production that are largely non creative
in nature 
a program  or program segment  p   is correct with respect to an initial condition  assertion  i and a final condition  assertion  f if and only if whenever i is true prior to the execution of p   and p terminates  f will be true after the execution of p is complete  using a
formal specification of the task  a knowledge base and an inference system  knowledge based
software synthesis proceeds with an iterative specification refinement process to specialize
the general knowledge of program development  in the form of algorithm theories  to solve
specific tasks on hand  the refinements are sound in that if the specification is correct  the
synthesized program  code  will be correct 
kids is a program transformation framework for the development of programs from
formal specifications of a task  kids runs on sun workstations and is built over refine 
a commercial knowledge based programming environment and a high level language  the
  

fisynthesizing customized planners from specifications

software specification
 input  output specification of a planner 

background knowledge
 domain dynamics  control

algorithm design tactics

knowledge  distributive laws etc  

 global search refinement search
for planning 

un optimized algorithm
 a planning algorithm 

optimization
 simplification  finite differencing etc 

optimized algorithm
 optimized planner 

compilation

compiled code in base language

figure    overview of software synthesis process in kids
refine language supports first order logic  set theory  pattern matching and transformation rules  refine provides a compiler that generates common lisp or c code for programs
written in its logical specification language 
in the following  we describe the general steps involved in synthesizing software on kids 
figure   provides an overview of this process  the process is illustrated in more detail in
section   in the context of synthesis of customized planner code 
   develop a task theory to state and reason about the task  the user defines appropriate
functions and types that describe the task and also gives laws that allow high level
reasoning about the defined functions  for planning  many planning theories  e g  
progression and regression  were written and relevant laws were specified  we also provided domain theories so that kids could perform specialized reasoning on planners
it returned as solutions 
   select and apply a design tactic to select an algorithmic framework that should be
used to implement the task specification  kids currently supports a variety of design tactics including problem reduction  divide and conquer  global search and local
search  for planning  we use the global search design tactic because our formalization
  

fisrivastava   kambhampati

of classical planning is driven by refinement search which can be seen as a special case
of global search  see below  
   apply optimizations to make the generated algorithm ecient  at first  the generated
algorithm is well structured and correct in that it can return all valid solutions  but
it can be very inecient  the algorithm is optimized through specification reduction
techniques such as simplification  partial evaluation and finite differencing 
   compile the algorithm to produce a program in the base language 
the domain theories and specifications are written in refine  and kids synthesizes
and optimizes the algorithms in the same language  to transform specifications into programs as well as to optimize the programs  kids uses a form of deductive reasoning called
 directed inference  to reason about the task specification and domain theory 
the kids system has been used to derive a variety of programs in the past  of particular
interest to us is the work on deriving ecient scheduling software  smith   parra       
burstein   smith         as the success of these programs provided initial impetus for our
own research 

    theories of plan synthesis

as mentioned earlier  using kids to derive planning software in clay involves figuring
out  a  how declarative theories for different types of classical planning are specified and
 b  what algorithmic design templates are best suited to planner synthesis   kambhampati 
    b  provides an overview of traditional plan synthesis approaches  as discussed there 
plan synthesis approaches come in many varieties with very little superficial commonality
between them  in the last few years  we have developed a unifying framework that subsumes
most of these approaches  kambhampati   srivastava        kambhampati  knoblock   
yang        kambhampati      b   in this framework  plan synthesis is modeled as a
process of searching in a space of sets of action sequences  these sets are represented
compactly as collections of constraints called  partial plans   the search process first
attempts to extract a result  an action sequence capable of solving the problem  from the
partial plan  and when that fails   refines   or splits  the partial plan into a set of new partial
plans  each corresponding to sets of action sequences that are subsets of the action sequence
set corresponding to the original partial plan   and considers the new plans in turn  the
existing domain independent plan synthesis algorithms correspond to four different ways of
refining partial plans  these are known  respectively  as forward state space or progression
refinement  fss   backward state space refinement or regression refinement  bss   plan
space refinement  pss  and task reduction refinement  strips  fikes   nilsson       
is an example of a planner using the fss refinement  topi  barrett   weld        uses
the bss refinement  snlp  mcallester   rosenblitt        uses the plan space refinement
and nonlin  tate        uses the task reduction refinement  given this background  the
declarative theory of plan generation in clay corresponds to theories of the refinements 
the algorithm tactic underlying plan generation corresponds to  refinement search   the
kids system supports an algorithm tactic called  global search   smith      a  which can
be seen as a generalization of this refinement search 
  

fisynthesizing customized planners from specifications

specification  what is a planning problem  
encoding of
domain knowledge
theory import
direction

planner

level  

refinement theory  what refinements are available  
progression fss 

regression bss 

plan space  ps 

level  

domain theory  how is the particular planning domain unique  

blocks world
domain
knowlegde

blocks world
progression

logistics domain
knowlegde

level  

blocks world
regression
logistics progression

logistics
regression

figure    the clay architecture for writing planning theory  each level answers a question
relevant to that level of planning detail  clay uses kids  feature of theory
import to modularize the domain specific planning theory

   developing a planner from declarative specification  the clay
architecture

figure   summarizes how kids is used to synthesize a domain specific refinement planner  the domain knowledge consists of a dynamical model and control knowledge  the
dynamical model is specified in the form of actions  also called operators  that define legal transformations from one state of the world to another  control knowledge is a set of
domain specific criteria that helps the planner decide if a plan p  is better than p  and is
intended to make search more ecient  an example of control knowledge is that in a logistics domain where some packages have to be moved to their destinations using airplanes 
planes should not touchdown at a location if they have no packages to pickup or deliver 
refinement planning and domain control knowledge are brought together in the clay
architecture for writing declarative domain specific planning theory as summarized in figure    to specify a planning task  a plan representation is selected and the constraints
that should be satisfied by a solution plan are enumerated in the planner specification 
the planner specification is dependent on the plan representation but is independent of
the refinement needed for search  a refinement strategy uses the planner specification and
defines how children nodes are generated from a given partial plan  what the goal test will
be  and also explicates any refinement specific search pruning tests  the refinement and the
  

fisrivastava   kambhampati

specification together form the planning theory  to obtain a domain dependent planner  all
one needs to do is import any planning theory and provide some relevant domain specific
planning control knowledge that provides a preference structure among partial plans and
competing solutions  an interesting special case is when one specifies a generic domain
knowledge to the effect that all the plans are equally good in the domain  in such a case 
based on the refinement used  one gets a fss  bss  pss or hybrid  if multiple refinements
are used   general purpose planner 
each level in the directed tree in figure   represents an abstraction of the planning
task  at the root of the tree  level     only a description of a planning task is required
without specifying what refinements strategies should be used  at level    the refinements
are specified but no assumption is made about the domain  next  characteristics of the
domain are provided at level    a progression  fss  blocks world planner is different from
a progression logistics domain planner only in terms of the domain knowledge  on the other
hand  a progression blocks world planner is different from a regression  bss  blocks world
planner only in terms of the refinement used 
as stated above  to ensure exibility  the control knowledge should not change when
different refinements are used and thereby represent substantial exibility  but in practice 
since control knowledge helps prune children nodes produced by a refinement  pruning may
be more effective if the control knowledge is encoded depending on the refinement  there
can also be a middle ground that we have not implemented  domain control knowledge
may be represented in an intermediate form depending on the partial plan representation 
each refinement can provide  in addition to a termination test  a conversion function to
transform the control knowledge into the refinement specific form 

    representing domain operators

we now discuss how the world state is represented and how the domain operators define
state transformations  in classical planning  the world is modeled in terms of a set of  state
variables   each state of the world corresponds to a particular assignments of values to these
variables  the actions are described in terms of the specific variable value combinations that
are needed for them to be applicable  and the variable value combinations they will enforce
after execution  two variants of this general modeling approach have become popular in the
planning community  the first  called the strips representation  fikes   nilsson       
represents the world in terms of ground atoms in a first order logic  the action applicability
conditions and effects are also described in terms of conjunctions of ground atoms  the
second variant  backstrom   nebel        models the world and actions directly in terms
of multi valued state variables and their values  since strips representation can be seen
as a state variable model with boolean state variables  and since any multi valued statevariable system can be converted into an equivalent boolean state variable system  the two
representations are equivalent in expressive power 
we chose the state variable representation for our implementation since this can be
directly mapped on to the primitive data structures supported by kids  figure   shows
the action of moving block a from block b to the top of block c in strips and statevariable representation  a blocks world domain is an environment in which some blocks
are placed on a table or on top of other blocks and the problems involve stacking them in
   

fisynthesizing customized planners from specifications

strips representation

action  move a  b  c  
prec  clear a    clear c      on a  b  
post  on a  c     clear b      clear c  
  on a  b  

muti valued state variable representation

action  move a  b  c  
pre  hb  true     false     truei
post  hc  true     true     falsei

 where a state is a   tuple
h pos a  clr a  pos b  clr b  pos c  clr c i 
and the zeroes represent  don t care  values 

figure    different representations of  move a from b to c 
some desired configuration  for the purpose of exposition  we are showing values of state
variables corresponding to block positions  e g   pos a  by symbols  b    c   etc  and clear
conditions  e g   clr a  by true or false  in practice  we map all the valid values of state
variables to integers 

    specification of a planner

kids uses a functional specification and programming language augmented with set theoretic
data types  a specification of the task  smith      a  is represented by a quadruple
f   hd  r  i  oi where d is the input type satisfying the input condition  i   d   boolean 
the output type is r and the output condition  o   d  r   boolean  defines a feasible solution  if o x z  holds  then z is a feasible solution with respect to input x  the specification
of a program follows the template 
function f  x  d    set r 
where i x 
returns f z j o  x z  g
  body x 
a specification for program f is consistent if for all possible inputs satisfying the input
condition  the body produces a feasible solution  i e     x   d   z   r  i  x     o x  z    
within this view  a planner takes as inputs an initial state  a goal state and an operator
list  the operators are assumed to define state transitions from valid states to valid states 
a specification for the planning task is  given the initial state  the goal state and the
operator list  return a sequence of operators  plan  such that 



termination test  the goals must hold in the final state resulting from the execu 

tion of the plan   we are only considering planning problems in which the goal is to
make all state variables achieve specified values  i e   goals of achievement  
 domain independent pruning test  the plan passes the domain independent
pruning tests  each planning refinemen can specify conditions under which a partialplan cannot lead to a desirable solution  and any partial plan satisfying such a pruning
   

fisrivastava   kambhampati

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test visited states
 plan  init  goal  opers  
init  goal 
  no moves back visited states
 plan  init  goal  opers  
init  goal 
  goal test visited states
 plan  init  goal  opers  
init  goal  

figure    a declarative specification for planning
test can be eliminated from further consideration  for example  the state loop pruning heuristic in forward state space refinement says that if we have a partial plan such
that the plan state after executing operator o  is a subset of the state following an
earlier operator o    then such a partial plan can be pruned 
 domain dependent pruning test  the plan passes the additional domain specific
pruning tests 
the last one is the hook through which domain specific control knowledge is introduced 
in the current implementation of clay  we use domain knowledge for rejecting undesirable
partial plans  in section      we discuss ways in which our implementation can be extended
to support other uses of domain control knowledge 
the specification of the planning task above is declarative in that it states what constraints must be satisfied in the resulting plan produced by a planner when given a planning
problem  it does not suggest any algorithm that should be used to obtain the results  algorithmic decisions will be made in the program development phase of kids 
an example of top level specification of planning task  in refine  is shown in figure   
in this specification  the input condition  i   is true  the input data type  d includes init 
goal and opers  the output data type r is plan and the output condition o consists of
goodness test  goal test  no moves back  no moves back is a domain independent
pruning tests whereas goodness test is a domain dependent pruning test 
delving deeper into representation detail  we represent a plan as a sequence of indices
in the operator list  i e   sequence of operator identifiers   for state space planning  the
state sequence corresponding to the partial plan is produced by function visited states
and the goal test  domain independent pruning tests and domain dependent pruning tests
are done on the state sequence by functions goal test  no moves back and goodnesstest respectively  the state variables take integer values  consequently  our initial and
goal states are a sequence of integers 
in words  the specification in figure   says that a partial plan is a sequence of integral
indices  of operators  and so the indices must not be more than the size of operator list  valid
   

fisynthesizing customized planners from specifications

plan is one whose corresponding state sequence  produced by visited states  satisfies the
goal test  no moves back and goodness test  
in the context of forward state space refinement  fss   visited states returns the
states obtained by the successive application of the operators in the partial plan to the
initial state and the resulting states thereafter  goal test signals that the goal has been
achieved  for fss refinement it involves checking that the last state in the state sequence
is the goal state  the no moves back function tests state looping  forward state space
looping checks if the state after executing operator oj  state sj   is a subset of the state
following an earlier operator oi  i   j    state si    this partial plan can be pruned  
the function goodness test checks for possible redundancy in the state sequence
corresponding to the current partial plan based on domain characteristics  let us explain
it in the context of the blocks world domain  we can specify any reasonable checks for the
blocks world as long as they do not make the planner lose a desired solution  below  we
present two goodness tests 

  heuristic h   limit useless moves  if a block moves between states i and  i     it

must not change position between states  i    and  i     the motivation behind this
check is to prevent blocks from being moved around randomly in successive moves 
  heuristic h   move via table  a block can only move from its initial state to the
table and from table only to its goal position  this is motivated by the fact that
a polynomial time approximate algorithm for solving blocks world planning problems involves putting all blocks on table first  and then constructing each of the goal
configuration stacks bottom up  

    implementing the specification using global search

as discussed in section    we need to select an algorithm design tactic to implement the task
specification in kids  one of the design tactics provided by kids is global search  the basic
idea of global search is to represent and manipulate sets of candidate solutions  the principal
operations are to extract candidate solutions from a set and to split a set into subsets 
derived operations include various filters which are used to eliminate sets containing no
feasible or optimal solutions  global search algorithms work as follows  starting from an
initial set of potential solutions  that contains all desired solutions to the given problem
instance  the algorithm repeatedly extracts solutions  splits sets and eliminates sets via
filters until a candidate solution can be drawn from one of the sets  sets of solutions are
represented implicitly by data structures called descriptors  and splitting is done by adding
   refine code of all the referenced functions is shown in appendix a 
   actually  we test a slightly more general condition that if the state after executing operator oj  state
sj   is weaker than a state following an earlier operator oi  state si    then this partial plan can be
pruned  sj is weaker than si if every state variable with assigned value in state si has that same assigned
value in state sj   by specifying weakness rather than subset as the relationship between states to decide
domain independent pruning in state space planning  we allow the synthesized planner to deal with a
partially specified initial state  the planner will work correctly as long as all the state variables that are
required for reasoning are specified in the initial state 
   our pruning test alone doesn t guarantee polynomial algorithm since the order in which the blocks are
to be put on the table or later at the goal positions is not specified in the pruning heuristic 

   

fisrivastava   kambhampati

mutually exclusive and exhaustive sets of constraints to the descriptors  the process can
be described as a tree search in which a node represents a set of candidates and an arc
represents the split relationship between a set and its subset  for complete details  readers
are referred to  smith      a  
the kids  global search paradigm is a general form of the refinement search model
used to unify classical planners in ucp  kambhampati   srivastava         specifically 
the partial plans correspond to descriptors and the refinements correspond to splitting
strategies  to use global search to implement the planner specification  we need to select
a suitable representation for sets of potential solutions  which  in the refinement view of
planning  are essentially the partial plans   the global search tactic would then set up a
search algorithm that can split a solution set and extract solutions that meet the problem
specification  kids provides global search tactics for primitive data types such as sequences 
sets and maps  if a complex data type is needed to represent the potential solution set of
a task  the user must implement a global search tactic for it 
since we are interested in state space planners initially  we chose to represent the partial
plan as a sequence of operators  actually sequence of operator indices   this allowed us to
use kids global search theory for finite sequences 

    specifying distributive and monotonic laws

one aspect of kids specification that is slightly unintuitive to new users is the need to
specify distributive and monotonic laws on all the operations used in the input output
specification  e g   no moves back in the specification of the progression planner shown in
figure     distributive laws state how a specific operation distributes over other operations
 e g    a   b    c   a  c      b  c     while monotonic laws provide a set of boundary
conditions  e g   a      a   such laws should be explicitly stated for all operations involved
in the specification to support instantiation of design tactics  as well as optimization of
generated code  specifically  kids has a directed inference engine called rainbow which
uses the task specification and the distributed laws specified by the user to simplify and
reformulate the expressions in the synthesized code  deductive inference is the primary
means by which kids reasons about the task specification in order to apply design tactics 
and optimize the code  and derive necessary pruning conditions  distributive and monotonic
laws indirectly provide kids with information on alternative ways of defining predicates 
a useful heuristic in writing laws is that they should be simple  normally expressed in
terms of the main function and perhaps another function to handle boundary cases  called
cross functions  see below   as an example  consider figure   where function no movesback is a domain independent pruning test used in the specification of progression planners 
recall that no moves back is called on a state sequence and checks that a later state is
not a subset of  or weaker than  an earlier state  calling no moves back on a sequence s
which is a concatenation of state sequences s  and s  is equivalent to calling it on s  and
s  and testing that no state in s  is weaker than a state in s   notice that the first two
tests can be handled by no moves back itself but the last test needs a new function  we
call this new function a cross function for no moves back  cross no moves back   the
monotonic laws for no moves back include 



no moves back over a singleton state sequence is true 

   

fisynthesizing customized planners from specifications



no moves back over an empty state sequence is false  useful when the selected action

is not applicable  

similarly  the distributive laws for no moves back include 



no moves back over sequence concatenation is equal to no moves back on s    nomoves back on s  and cross no moves back on s  and s   

 when a state a is prepended to a state sequence s   applying no moves back over

such a combined state sequence is equivalent to applying cross no moves back on
the singleton sequence  a  and s   and no moves back on s  
 when a state a is appended to a state sequence s   no moves back over such a
combined state sequence is the same as no moves back on s and cross no movesback on s and the singleton sequence  a  

all these rules  while reasonably obvious to us  are nonetheless very crucial for the
effectiveness of kids as they help it in reformulating and optimizing the generated code 
an example of their use  as we will see in section        occurs in figure   where an  if
 condition     then     else   statement gets simplified to just the   then   part because all
the conditions in the   condition   can be proved to be true in the context of the input
specification  given the distributive laws 
using the task specification  the selected design tactic   global search  and distributive
laws  kids produces a correct but naive code  as shown in figure    the code is naive
because the same checks  for example cross no moves back in figure    are computed
repeatedly even if they are true from their context  we discuss some methods to optimize
the code in the next section 

    program optimization

this section explains how the initial planner code  generated by kids  is optimized  readers
not familiar with automated software synthesis literature might want to skip this section
on first read  and revisit it later for more details 
the first code produced by kids  shown in figure    is well structured but very inecient  there are several opportunities for optimization and kids provides tools for program
optimization  the code can be compiled and executed at any stage of optimization  now 
we briey summarize the program optimizations used to achieve eciency 
      context independent simplifier

this method simplifies an expression independent of its surrounding context  there are
two possibilities for context independent simplification 
 in the first case  a set of equations are treated as left to right rewrite rules that are
fired exhaustively until none apply  distributive laws are also treated as rewrite rules 
an example application of a rewrite rule is 
 if true then p else q     p
   

fisrivastava   kambhampati

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goal test
 visited states plan  init  goal  opers  
init  goal  
  if no moves back
 visited states     init  goal  opers  
init  goal 
  goodness test
 visited states     init  goal  opers  
init  goal 
then planner aux init  goal  opers     
else undefined

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
  goodness test
 visited states v  init  goal  opers  
init  goal 
  no moves back
 visited states v  init  goal  opers  
init  goal  
  seq integer 
  if ex  plan  seq integer  
 goal test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  range plan  subset       size opers  
  plan   v 
then some  plan    seq integer  
 goal test
 visited states plan    init  goal  opers  
init  goal 
  no moves back
 visited states plan    init  goal  opers  
init  goal 
  goodness test
 visited states plan    init  goal  opers  
init  goal 
  range plan    subset       size opers  
  plan     v 
else some  plan    seq integer  
ex  new v  seq integer  
 plan    
planner aux init  goal  opers  new v 
  defined  plan   
  goodness test
 visited states new v  init  goal  opers  
init  goal 
  no moves back
 visited states new v  init  goal  opers  
init  goal 
  ex  i  integer 
 new v   append v  i 
  i in       size opers    

figure    first progression blocks world planner code synthesized by kids  notice that the
code is inecient because the same checks  for example  cross no moves back 
are computed repeatedly  even if they are true from their context 

   

fisynthesizing customized planners from specifications

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer   
range plan  subset       size opers  
and     
  if no moves back
 visited states     init  goal  opers  
init  goal 
and goodness test
 visited states     init  goal  opers  
init  goal 
then planner aux
 init  goal  opers       init   init 
size opers  
else undefined

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer   
range plan  subset       size opers  
and     
  planner aux
 init  goal  opers       init   init 
size opers  

figure    example of context independent simplification in kids  the code on the right
size is the simplified version of that on the left 
function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
and goodness test visited states
 v  init  goal  opers  
init  goal 
and no moves back visited states
 v  init  goal  opers  
init  goal  
  seq integer 
  if goal test 
visited states v  init  goal  opers  
init  goal 
and no moves back visited states
 v  init  goal  opers  
init  goal 
and goodness test visited states
 v  init  goal  opers  
init  goal 
and range v  subset       size opers  
then  if         

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
and goodness test visited states
 v  init  goal  opers  
init  goal 
and no moves back visited states
 v  init  goal  opers  
init  goal  
  seq integer 
  if goal test 
visited states v  init  goal  opers  
init  goal 
then  if         

figure    example of context dependent simplification in kids  the code on the right size
is the simplified version of that on the left 

 in the second case  all occurrences of a local variable which is defined by an equality

is replaced by the equivalent value 
fc  x  j x   e   p  x g    fc  e  j p  e g
figure   shows an example of context independent simplification where all the conditions
of the if condition are true from their respective distributive laws  hence  the if then else
statement is replaced by the then part 
   

fisrivastava   kambhampati

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
l vs  seq integer   
seqequal l vs  last vs  
and range v  subset       size opers  
and     
  if goal test vs  init  goal  then v
else some  plan    seq integer  
exists i  integer 
 i in       size opers  
and    

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
l vs  seq integer   num ops  integer
 
num ops   size opers 
and     
  if goal test vs  init  goal  then v
else some  plan    seq integer  
exists i  integer 
 i in       num ops 
and    

figure    example of finite differencing  on size opers    the code on the right size is
the result of finite differencing on that on the left 
   focus initialize planner
   tactic global search on planner
   simplify  context independent fast  if    then   
else some  plan         
   simplify  context dependent  forward    backward   
                 
   simplify  context dependent  forward    backward   
if    else und   
   fd  general purpose  vs  
visited states v  init  goal  opers 
   fd  general purpose  l vs   last vs 
   fd  general purpose  num ops   size opers 
   abstract next state l vs  i  opers  into ns in
ex  i  integer      in        
   simplify  context independent fast 
if         then planner aux           
    refine compile into lisp  planner aux  planner

figure     derivation steps to generate a progression planner for blocks world domain 
      context dependent simplifier

this method is designed to simplify a given expression with respect to its surrounding context and is  thus  more powerful than context independent simplification  all the predicates
that hold in the context of the expression are gathered by walking up the abstract syntax
tree  the expression is then simplified with respect to the set of assumptions that hold in
the context  in figure    the function calls for no moves back  goodness test and the
range test in the  if  expression are redundant because their results follow from the input
invariant  conditions listed after  j  and before      of the planner aux function  so
they are removed by this simplification 

   

fisynthesizing customized planners from specifications

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goal test
 visited states plan  init  goal  opers  
init  goal  
  planner aux
 init  goal  opers       init  
size opers   init 

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
num ops  integer  l vs  seq integer 
  seqequal l vs  last vs  
  seqequal vs 
visited states v  init  goal  opers  
  no moves back
 visited states v  init  goal  opers  
init  goal 
  goodness test
 visited states v  init  goal  opers  
init  goal 
  range v  subset       size opers  
  num ops   size opers  
  seq integer 
  if goal test vs  init  goal  then v
else some  plan    seq integer  
ex  ns  seq integer   i  integer 
 ns   next state l vs  i  opers 
  cross no moves back vs   ns   init  goal 
  cross goodness test vs   ns   init  goal 
  defined  plan   
  plan  
  planner aux
 init  goal  opers  append v  i  
append vs  ns   num ops  ns 
  i in       num ops  

figure     final progression blocks world planner code synthesized by kids
      finite differencing

the idea behind finite differencing is to perform computations incrementally rather than
repeat them from scratch every time  let us assume that inside a function f  x  there is
an expression g x  and that x changes in a regular way  in this case  it might be useful to
create a new variable  equal to g x   whose value is maintained across iterations and which
allows for incremental computation of g x  with the next x value  finite differencing can be
decomposed into two more basic operations  abstraction and simplification  smith      a 

 first  the function f is abstracted with respect to expression g x  adding a new
parameter c to parameter list of f  now f  x  c   and adding c   g x  as a new input
invariant to f   all calls to f   whether recursive calls within f or external calls  must
now be changed to match the definition of f i e  f  x  is changed to f  x  g x    in this
process  all occurrences of g x  are replaced by c 
 if distributive laws apply to g h x   yielding an expression of the form h  g x   and
so h   c   the new value of g h x   can be computed in terms of the old value of g x 
and this the real benefit in optimization 

let us illustrate this process with an example  suppose that some function f  x  has a
call for function g x  which returns the square of numbers and that variable x varies linearly 
now  suppose that we are given a distributive law such as g x        g x       x      so 
after finite differencing  f becomes f  x  c  and the g x  call is replaced by c      x     
   

fisrivastava   kambhampati

an additional invariant c   x  x will also be maintained for f   this new expression is
computationally much cheaper than the original expression 
in figure    finite differencing is performed on size opers    the argument of function
planner is expanded with the inclusion of num ops  the name entered by the user for
the value of size opers    only abstraction is done here as the number of operators
available to the planner does not change during planning  note that num ops represents
the number of operators in a planning problem and this is a meaningful concept for planning 
all instances of size opers   are replaced by num ops 
      program derivation

figure    shows a summary of the sequence of derivation steps carried out to obtain a
blocks world domain specific forward state space planner  the final version of the planner
code is shown in figure    
in step    the top level planner specification is selected and in step    selected design
tactic is applied  step   involves a context independent simplification  and steps   and
  involve context dependent simplifications  steps   through   cover finite differencing 
finally  an ecient planner code is compiled in step    

   discussion on synthesized planners

section     used the synthesis of a progression planner for blocks world domain as a case
study to walk through the planner synthesis process leading to the final planner given
in figure     in our research  we have also considered regression  backward state space 
planners  all the planners we have synthesized to date are summarized in table    although
each of these planners differ in terms of the refinements they use  and the domains to which
they are customized  figure    attempts a pseudo code description of a generic template to
facilitate discussion of the synthesized planners as a group 
the main function planner takes initial state  goal state and operator set as
inputs and in turn calls the recursive function planner aux with all the inputs and an
initial plan  all the pruning tests comprising the output conditions are maintained as
 invariants   in that they must hold not only of the final plan  but also of the every partial
plan leading to the final plan   the goal test  of course  need only hold for the final plan 
and is thus not maintained as an invariant  finite differencing leads to more invariants 
inside planner aux  if a partial plan satisfies the goal test  it is returned  otherwise 
the partial plan is refined  invariants are incrementally tested in the new partial plan and
planner aux is called recursively 
first thing we note is that the pseudo code template describes a planner for any planning
domain employing any state space refinement  even the requirement that the synthesized
planner be state space is dictated by how the new partial plan  partial plan   is obtained
 in this case by appending an operator to an operator sequence   it can be generalized to
support other refinements  by modifying the operation  in the current case  append   that
is used to build the new partial plan from the old one  with corresponding changes to the
distributive laws to account for the new operation  
second  we observe that all invariants are incrementally evaluated  see planner aux  
for example  to see if the the plan in ith iteration satisfies the no moves back test  we only
   

fisynthesizing customized planners from specifications

check if the latest state is duplicated by any of the previous states  we hypothesize that such
incremental evaluation is the primary reason for the synthesized planner s eciency  once
refinement and planning domain knowledge is available  context dependent simplification
may show that many of the tests made in the separate theories are in fact redundant 
moreover  incremental evaluations may be cheaper than complete evaluations of invariants
if they are amenable to the operations of distribution and monotonicity over the abstract
data types 
although domain independent planners can be given the same control knowledge that
we give to kids during planner synthesis  our approach is expected to be superior in two
ways 
   our approach separates the control knowledge acquisition from the specifics of the
planner to some extent and this makes the acquisition process easier  in contrast 
controlling the search of a domain independent planner requires the user to think in
terms of specific  choice points  in the planner s search strategy 
   more importantly  search control in domain independent planners typically involves
generating unpromising partial plans first and then pruning them  in contrast  our approach improves eciency by  folding in  the control knowledge into the synthesized
planner code  through incremental evaluation of pruning test  specifically  to a first
approximation  conventional domain independent planners will add the goodnesstest either to control their search at the choice points or to post process the generated partial plans  we specify distributive laws on how the goodness test can be
incrementally evaluated  in terms of cross goodness test and goodness test 
and perform context dependent analysis on all the pieces of available knowledge to
optimize the code  this is what we mean by  folding in  the control knowledge 
in figure     we can see an instance of control knowledge being folded into the synthesized progression planner for the blocks world domain  contrast it to the first synthesized
planner shown in figure    we notice that redundant invocation of various checks  such
as goodness test  visited states  etc  in the earlier planner have been simplified away 
moreover  individual checks  such as no moves back and goodness test  have been
further simplified based on the distributive laws  like cross no moves back and crossgoodness test  to consider just the newly added parts of the partial plan  all these
considerations lead to a very small and ecient final planner 

   empirical evaluation of synthesized planners

table   lists several domain dependent state space planners that we have synthesized to
date  the planners are characterized by the domain for which they are developed   bw  for
blocks world   log  for logistics  and  tyr  for tyre world   all of which are benchmark
domains in ai planning   the type of  state space  refinement used   p  for progression
and  r  for regression   and the type of domain specific control knowledge used  h  that
limits useless moves  h  which moves blocks via table  etc    we will now report results of
an empirical study conducted over these synthesized planners  the study had two aims 
 to ascertain whether the synthesized planners are able to eciently exploit domain
knowledge 
   

fisrivastava   kambhampati

   the main function planner calls the auxiliary function
function planner  initial state  goal state  operator set 
returns plan
such that output conditions are satisfied
 
planner aux initial state  goal state  operator set 
initial plan      
   note  other parameters are added during finite differencing
   the function planner aux is called by planner or by planner aux
   note  from the set of output conditions given as part of
  
the problem specification  kids selects all but one
  
to be maintained as invariants  finite differencing
  
gives more invariants 
function planner aux initial state  goal state  operator set 
current plan      
such that invariants are satisfied for the state sequence
corresponding to the current plan
return type of plan
 
if state sequence ensures the satisfaction of goal state
when current plan is executed from the initial state
return current plan
else consider some partial plan    append current plan  i 
where i is index of a valid operator in operator set  and
a  incremental test of invariants is true for
state sequence corresponding to partial plan 
b  partial plan   
planner aux initial state  goal state  operator set 
partial plan       

figure     pseudo code for the state space planners synthesized by kids

 to ascertain if the synthesized planners are better than traditional domain indepen 

dent planners in utilizing domain control knowledge 
our discussion is organized as follows  in section      we describe the domains and
problems we have considered in our empirical work  in section      we evaluate the absolute
performance of the synthesized planners in the various domains  in section     we compare
the performance of synthesized planners and traditional planners 

    domains and problems
      blocks world domain

a blocks world domain is an environment in which each block is placed either on a table or on
top of other blocks  and the problems involve stacking them in some desired configuration 
let us focus on two states in particular  a on top and n on top  when there are a
   n blocks  a on top stands for the state where block a is on top of block b  block b
   

fisynthesizing customized planners from specifications

name
bw p h 
bw p h 
bw r h 
bw r h 
log p l
log r l
tyr p m
indep p
indep r

customized for
the domain
blocks world
blocks world
blocks world
blocks world
logistics
logistics
tyre world
 none none 

refinement

domain dependent pruning test

progression  fss 
progression  fss 
regression  bss 
regression  bss 
progression  fss 
regression  bss 
progression  fss 
progression  fss 
regression  bss 

limit useless moves  h  
move via table  h  
limit useless moves  h  
move via table  h  
limit ineciency
limit ineciency
multiple control rules
true  every state is ok 
true  every state is ok 

table    table showing the variety of planners synthesized on kids  the names of the
planners follow the format  domain   refinement   heuristic  
is on top of block c       block n   is on top of block n and block n is on table  similarly 
n on top stands for the state in which block a is on table  block b is on top of block a 
     block n is on top of block n    problems for the reported experiments are one of three
types 
   stack inversion  invert from a on top to n on top 
   stack building  initial state is a collection of random stacks of up to two blocks height
in which the last n   blocks are either put on the first n   blocks or on the table 
goal state is a on top or n on top 
   random blocks world problems  a subset of random blocks world problems generated using minton s algorithm  minton         in a problem with n blocks  the goal
state can have up to n   goal conditions 
some domain dependent pruning tests for blocks world were covered in section    specifically  we covered pruning test h  that prevents any block from being moved in consecutive
steps  and test h  which requires that all blocks have to be moved via the table 
      logistics domain

the logistics domain consists of a several planes and packages at different places  the goals
involve transporting the planes and packages to the specified locations  we considered a
type of logistics domain where there are k planes   k places and  k packages  there can be
either   packages or   package and   plane at each place  the goal is to get all planes and
packages to a distinguished place 
the domain dependent pruning test for the logistics transportation domain   which we
call  limit ineciency  heuristic  consists of the following pieces of advice 
   

fisrivastava   kambhampati

   planes should not make consecutive ights without loading or unloading a package
   packages should either be at the goal position to begin with  or may be loaded inside
a plane and then own to their goal position 
   once a package reaches its goal position  it should not be moved 
      tyre world domain

the tyre world  russell   norvig        is a benchmark domain with complex causal
structure  blum   furst         in the  fixit  problem from this domain  a car s tyre is
at and must be replaced by a spare at tyre  which must first be inated   the original
tyre has to be placed in the boot and all tools must be returned to the boot  the domain
dependent pruning test that we devised enforces the following constraints 
   if only one state variable changes between one state s    and the next state s     it
should not change in the subsequent state s     this is because a state variable describes an attribute about an object in the domain  if the attribute has a value in
state s  that will be  overwritten  in state s    this might indicate a non minimal
plan  
   work on the status of boot last 
   fixing up a free hub is invalid   a wheel must be on it first 
   if we have jacked up the car that needs a tyre  we can not jack it down without putting
the tyre on it 
   work on the position of the pump and wrench after all the wheels and the hub are in
their final configuration 
   once the wheels are in their goal positions  they should not be moved 

    absolute performance of the synthesized planners

in this section  we discuss the absolute performance of the synthesized planners in different
domains  as we shall see  the synthesized planners were able to solve the benchmark
problems that are known to be hard for the traditional planners  a special note is in order
regarding the plots that follow  in all the plots that follow  if a curve stops mid way in a
graph  it means that the corresponding planner could not solve the given problem or all
problems in the problem class  as applicable  in the stipulated time 
      planners in blocks world

in traditional planners  domain specific information helps the planner return a result faster
and we obtained similar results with the synthesized planners  as can be seen from the left
   this is not true in all domains  since in some domains  the only way a state variable can shift its value
from v  to v  is to transition through v    the heuristic however does preserve completeness in the tyre
world 

   

fisynthesizing customized planners from specifications

synthesized progression planners for block world

synthesized progression planner for logistics

effectiveness of domain based pruning tests

effectiveness of domain base pruning tests

        

       

bw p h 
indep p

log p l
indep p
      

      

log  time  in secs  

log  time  in secs  

     

    

    

   
   
   

   
   

    

   
   

    
  blocks

   
   
   
   
  planes  x places   x packages 

   

figure     plots show that domain dependent goodness tests lead to ecient planners  the
problem domains are blocks world  left  and logistics transportation domain
 right   planners with domain guidance perform better than those without it 
plot in figure     the domain specific blocks world heuristic h    limit useless moves  
helped the progression planner  bw p h   solve the stack inversion problem  invert aon top to n on top  for    blocks in under a minute  and for    blocks in under   
minutes  without such a heuristic  the progression planner  indep p  could not solve even
a   block stack inversion problem in the same time 
      planners in the logistics domain

in the logistics domain  the progression planner with the limit ineciency heuristic  logp l  could solve   plane problems in under a minute and   plane problems in    minutes
 figure     right   without such a heuristic  the progression planner  indep p  could not
solve even the   plane problem in the same time 
      planners in the tyre world

there are    operators     state variables and   control rules in our manually encoded tyre
world  russell   norvig        description  the fixit problem was solved in under a minute
and a    step plan was returned 

    comparing traditional and synthesized planners in blocks world

since our synthesized planners used domain specific control knowledge that is not normally
used by domain independent planners  our next step involved comparing synthesized planners to domain independent planners using the same control knowledge  our aim is to see
if the synthesized planners are better able to exploit the domain knowledge than the traditional planners  we restricted this detailed comparison to the blocks world domain  since
   

fisrivastava   kambhampati

there are a variety of traditional classical planners each of which have varying tradeoffs
 c f   barrett   weld        kambhampati et al           we used a  league tournament 
approach in our comparison  specifically  since most popular classical planners correspond
to different instantiations of ucp  kambhampati   srivastava         we first ran them all
on our blocks world problem distribution to isolate the best traditional planners  similar
study was done to isolate the best synthesized planners for our problem distribution  at
this point  the best synthesized planner is compared to the best traditional planner  in
this second round of comparison  the winning traditional planner is given the same control
knowledge as the synthesized planner 
we have used two of the three blocks world test suites   the random blocks world
problems and the stack building problems   in the comparisons  each problem class is
defined in terms of the number of blocks and an average of    runs is shown in each plot 
the total time allowed for a class of problems was      seconds after which the planner was
deemed to have failed on that problem class  all planners were run on the same problems
from the problem suite 
      picking the best synthesized planner

in this section  we want to empirically determine the the most effective refinement and
control knowledge  heuristics  for the blocks world problem suites  we ran six synthesized
planners  bw p h   bw p h   indep p  bw r h   bw r h  and indep r  on the
above test suite  figure    shows the relative performance  we notice that planners with
the pruning test h  perform the best when compared with other planners using the same
refinement  
      picking the best traditional planner

in this section  we empirically search for the best ucp strategy in the blocks world  figure    shows the performance of ucp instantiations with no domain dependent heuristic
information  instantiations of ucp which do only fss  bss or ps refinements can emulate
classical forward state space  backward state space or plan space planners  respectively  we
call these instantiations ucp fss  ucp bss and ucp ps  ucp lcfr is a hybrid strategy
which interleaves fss  bss and ps refinements depending on the lower branching factor
 kambhampati   srivastava         in both the random blocks world problems  left  and
the stacking building problems  right   the left and right plots  ucp fss solves all of the
   we also notice that progression planners perform better in the left plot and regression planners perform
better in the right plot  this trend can be explained easily in terms of the way the refinements operate
 kambhampati      b   in the left figure  based on the nature of the goals  the branching factor for
the regression planners may become enormous because it cannot detect all the conicts among the
steps that give conditions at the goal  or at steps which eventually support the goal condition   many
more operators seem to potentially give a condition than is actually the case  on the other hand  the
completely specified initial state helps the progression planner decide all applicable operators from the
beginning itself  consequently  progression planner bw p h  is a clear win  in the right plot  as the
initial and goal states are completely specified  both regression and progression planners can detect all
conicts  as is true in realistic domains  many more operators are applicable from the initial state than
are relevant to achieving the goal conditions  so  the regression planner bw r h  performs better than
the progression planner bw p h  

   

fisynthesizing customized planners from specifications

performance of synthesized planners

performance of synthesized planners

random blocks world problems

build stack to achieve a on top

     

     

bw p h 
bw p h 
indep p
bw r h 
bw r h 
indep r

    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

bw p h 
bw p h 
indep p
bw r h 
bw r h 
indep r

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     performance of the synthesized progression and regression planners with h  
h  or no domain dependent control knowledge  bw p h  perform best in the
left plot and bw r h  performs best in the right plot  as the points are close
together  it is not clear but bw r h  and indep r solve problems of upto  
blocks in the left plot 
performance of ucp instantiations

performance of ucp instantiations

mintons random blocks world problems

go from random stacks of upto two blocks height to a on top

     

     

ucp ps
ucp fss
ucp bss
ucp lcfr

ucp ps
ucp fss
ucp bss
ucp lcfr
    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

   

   

   
  blocks

   

   

figure     performance of ucp instantiations with no domain dependent heuristic  in the
left and right plots  ucp fss solves all of the problems in the least time  based
on the results  we see that ucp fss is a good strategy for blocks world  note
from the figure that ucp bss solves only   blocks problems in the given time
in all the plots 
   

fisrivastava   kambhampati

comparison of ucp fss and synthesized planners

comparison of ucp fss and synthsized planners

random blocks world problems

build stack to achieve a on top

     

     
bw p h 
ucp fss h 

bw r h 
ucp fss h 

    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     how the best ucp strategy for blocks world  namely ucp fss  performs against
the best of kids  synthesized planners  in the left plot  ucp fss does better
than indep p i e   without any heuristic information  but when h  heuristic is
given to both the planners  bw p h  is a winner  in the right plot  bw r h 
outperforms ucp fss with h  
problems in the least time  based on the results  we see that ucp fss is a good strategy
for the blocks world problem distributions we used  
      comparing the best synthesized planner and best traditional
planner

finally  we pit the best ucp strategy for the blocks world  namely ucp fss  against
the best of kids  synthesized planners  we chose bw p h  for the random blocks world
problem suite and bw r h  for the stack building problem suite  comparison is done when
all planners are either given the same heuristic information  h   or no domain dependent
guidance  figure    plots the results  in the left plot  bw p h  is a clear winner when
both planners are given the domain specific heuristic h   in the right plot  bw r h 
outperforms ucp fss with h   so  we see that given the same heuristic information  the
best of the planners synthesized by kids can outperform the best instantiation of ucp for
the blocks world 
it is interesting to note that while all synthesized planners improve drastically with
domain specific knowledge  domain independent planners do not always improve in the
same way  we illustrate this in figure     where we compare ucp instantiations and the
synthesized planers with and without control heuristics  while the synthesized planners
   note that in the case of synthesized planners  a planner based on regression outperformed one based on
progression in the stack building problems  in contrast  ucp fss out performs ucp bss for the same
problem suite  the reason for this had to do with the particular implementation of ucp bss  which
involves a costly unification step 

   

fisynthesizing customized planners from specifications

comparison of ucp fss and synthesized planners comparison of ucp fss and synthesized planners
random blocks world problems

build stack to achieve a on top

     

     
bw p h 
ucp fss h 
indep p
ucp fss dom indep

bw r h 
ucp fss h 
indep r
ucp fss dom indep
    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     effect of control knowledge on ucp planners vs  kids synthesized planners 
always improve with the addition of control knowledge  the same is not true of the ucp
instantiations  specifically  in the right plot  we see that ucp fss h   which uses control
knowledge h  does worse than ucp fss dom indep  which does not use any control
knowledge  we speculate that this is because ucp fss explicitly calls a function to do
domain specific reasoning in each recursive invocation while the synthesized planners have
domain control knowledge folded into the planner code  see section    

    summary of results

in summary  we have demonstrated that 

 the clay approach to writing domain specific planning theory is exible  it sup 

ports mix and match of refinements and control knowledge in generating a variety of
customized planners  as examples  we presented planners for blocks world  logistics
domain and tyre domain  using forward and backward state space refinements and
different types of domain specific control knowledge 
 the synthesized planners can exploit domain dependent control knowledge to improve performance  we showed that  in fact  they are better able to exploit domain
knowledge than the traditional planners can 

   related work

the research reported here straddles the two fields of automated software synthesis and
ai planning  although our research is the first to address the issue of planner synthesis 
synthesis of other types of search engines has been addressed by smith and his co workers 
of particular interest to us is the work they did in developing automated scheduling software
for transportation logistics problems using kids system  smith   parra        burstein  
smith         the scheduling systems they have generated have been shown to significantly
   

fisrivastava   kambhampati

outperform general purpose schedulers working on the same problem  their results provided
the initial impetus for our research  although their original work used a design tactic
based on global search to model scheduling  they have also since then developed design
tactics based on other local search regimes  another interesting issue brought up by their
work is the importance of  constraint propagation  techniques in deriving ecient code 
this has made us explore the role  or lack thereof  of constraint propagation in planning 
kambhampati and yang        describe ways in which the refinement planning framework
can be extended to exploit constraint satisfaction techniques  in future  we hope to be able
to synthesize planners using this more general theory of refinement planning 
although there has not been much work on automated planner synthesis  a notable exception is the work of gomes         gomes had synthesized a state space problem solver
for the  missionaries and cannibals  problem on kids  and has shown that the synthesized
code outperforms general purpose problem solvers in that domain  our framework can be
seen as a generalization of the work done by gomes  in particular  we separate planning
theories from the dynamics and the control knowledge  which in principle supports generation of planning code based on a variety of refinements  we have demonstrated this by
deriving both progression and regression planners for three different domains  blocks world 
logistics and tyre world  and with two different bodies of control knowledge in each case 
methodologically  our work adds to gomes  results in that we have shown that given the
same control knowledge  planners generated by kids can outperform traditional planners
using the control knowledge at their choice points  this makes for a fairer comparison
between synthesized and general purpose planners 
in some existing planners such as ucpop  penberthy   weld        and prodigy
 fink   veloso         customization is supported by allowing the user to specify search
control rules that are checked at every choice point during search  such control rules can
be used to rank the search nodes based on some heuristic  or prune unpromising nodes 
the main difference between these approaches and the synthesis approach described here
is that ours supports a higher degree of integration of domain knowledge into the planner
by folding it into the synthesized code for the planner  planners using search control rules
cannot do context dependent analysis or incremental application of control knowledge  in
contrast  in our approach  the control information is encoded declaratively and the planning
algorithm can be optimized based on all the knowledge that is available  including the
control knowledge 
our work on utilizing explicit control knowledge in addition to domain dynamics in
deriving planning code has some parallels with the recent work by bacchus and kabanza
        they concentrate on providing a rich language in which control knowledge can be
specified for a progression planner  they describe a language based on temporal logic to
specify domain control rules  rather than using this knowledge to prune bad plans after
they are generated  bacchus and kabanza explore ways of incrementally tracking the level
of satisfaction of the control axioms as the planning progresses  our approach facilitates
the same  in a refinement independent setting  by  folding in  the control knowledge into
the developed planning code  with the help of kids framework 
there is some work in constraint satisfaction community that is directed towards producing specialized  customized  programs that is relevant to the research described here 
coastool  yoshikawa  kaneko  nomura    watanabe        and alice systems  lau   

fisynthesizing customized planners from specifications

riere        take declarative description of csps and compile specialized algorithms for solving them  and multi tac  minton        supports automatic configuration of constraint
satisfaction programs  the multi tac system  in particular  provides an interesting contrast to our approach  multi tac starts with an algorithm schema  a list of high level
heuristic rules for various decision points  e g    most constrained variable first  heuristic
for variable selection and  least constraining value first  for value selection in csp search  
and a list of ags indicating whether certain procedures  e g   forward checking in csp  will
or will not be used  multi tac uses the domain specification to specialize the high level
heuristics given to it  for example  in the context of a minimum maximal matching problem
in graph theory  a most constrained variable first heuristic may become  choose the edge
with the most neighbors that have been assigned values    a configuration is a particular
subset of specialized heuristics to be used  and a particular assignment of ags  multitac first searches through a space of  configurations  to see which configuration best fits
a given problem population  once the best configuration is found  it is then automatically
compiled into ecient code by using specification refinement techniques similar to those
that we described in section     
multi tac thus presents an interesting middle ground between search control rule
specification approach used in ucpop and prodigy planners  and the full integration of
domain knowledge into the synthesized code  promised by the clay approach  in contrast
to the ucpop and prodigy search control rule approach  the multi tac compilation
phase can support folding in of search control rules into the compiled code  in contrast
to clay which advocates semi automatic synthesis of a piece of software by manually
guided optimization  through the help of user specified distributive and monotonicity laws  
multi tac supports fully automating the customization of a configurable template  for
the clay approach to be effective  we need to provide a declarative specification of the
task and the domain control knowledge  as well as high level algorithm tactics  kids
deals with instantiating the tactics into the specific problem  but the simplification needs to
be guided by careful specification of distributive monotonicity laws  in contrast  multitac s configuration approach needs an algorithm template that is already semi customized
to the specific task  with built in hooks for using heuristics  the heuristics themselves are
specified in the form of meta heuristic knowledge 
in multi tac  domain knowledge is used only in specializing the meta heuristics  in
theory  the clay approach may support a deeper integration of the domain knowledge into
the synthesized code  but at the expense of a significant amount of user intervention  an
interesting application of the multi tac approach in the context of planning might involve
starting with a ucp planning shell  which can be configured to emulate many varieties of
planners   a list of high level heuristics for guiding the decision points in the ucp shell
 e g   refinement selection  aw selection etc   and searching among the configurations to
pick a planner for the given problem distribution 

   conclusion

in this research  we investigated the feasibility of using automated software synthesis tools
to synthesize customized domain specific planners  we described the clay architecture
for exibly synthesizing ecient domain dependent classical planners from a declarative
   

fisrivastava   kambhampati

theory of planning and domain theory using a software synthesis system  kids   using
this framework  any classical planner can be synthesized enriched with domain control
knowledge  as a proof of concept  forward state space and backward state space planners
were synthesized for the blocks world  the logistics and the tyre world domains  we have
shown that the synthesized planners can outperform general purpose planners when both
are using the same amount of domain specific control knowledge and argueed that this is
due to their ability to fold in domain specific control knowledge into the planner code  in
contrast  the domain independent planners test the control knowledge for each plan being
refined  and thus suffer a significant application overhead 

    features and limitations

our synthesis approach provides several interesting contrasts to main stream ai planning
work  to begin with  most ai planning work attempts to improve the eciency of planning
by concentrating on the way plans are generated  our work differs radically in that we
concentrate on how  ecient planners  are synthesized  the use of software synthesis techniques lends modularity to the planner synthesis activity  the planning theory is specified
declaratively rather than in the form of an implemented program  this supports changes
and extensions to the planning theory  while a planning theory is described independent
of domains  control knowledge and dynamical knowledge of the domain can be specified
once for each domain  by selecting different combinations of planning theory and control
knowledge  we can synthesize a variety of domain customized refinement planners 
despite these promises  our approach does entail several overheads  some of these
overheads are related to the current state of the art in automated software synthesis while
others are related to our current implementation of clay architecture  in what follows 
we try to tease these apart 
the holy grail of automated software synthesis approaches is to free the users from lowlevel coding  and allow them to concentrate on declarative specification  while the kids
system comes closest to this promise  it is still far from perfect  to start with  the user must
be reasonably familiar with the software synthesis process in order to do anything substantial
with kids  we had to go through a steep learning curve before we could understand how to
structure our theories to make good use of the optimizations provided by kids  writing the
monotonic and distributive laws for operations such that they can help kids do effective
code simplification is still somewhat of an art  many times  we had to go back and rewrite
the domain knowledge after kids was unsuccessful in using the knowledge provided to it 
advances in software synthesis technology may provide support for automatic translation
for high level control knowledge into forms suitable for consumption by kids  but such
support is not available right now 
the current cost benefit ratios are such that we would not recommend using clay kids
approach for customizing a planner if one is interested in customizing a single planner for
a single domain  the refine code the user writes to specify the synthesis task is typically larger than any one single synthesized planner generated by kids  thus  manually
customizing the planner for the domain may still be more appropriate  however  the synthesized approaches may be competitive if we are interested in being able to customize a
variety of planners to a variety of domains 
   

fisynthesizing customized planners from specifications

in addition to the overheads entailed by kids  our specific implementation of planning
theories  domain knowledge  etc  also lead to some ineciencies  these latter can be
eliminated by a better design of the clay architecture  for example  to make our work
simple  we decided to go with one of the pre existing canned design tactics provided by
kids  and chose the global search theory over finite sequences as the candidate tactic 
because of this choice  we found state variable representation of domains to be more suitable
from an implementation point of view  although getting state variable representations of
actions is not very hard  we wrote a couple of utility routines for converting actions in
strips representation into state variable representation   specifying control knowledge in
terms of this representation turned out to be less than natural  especially in larger domains
like russel s tyre world 
our choice of in built design tactics also limited the types of domain knowledge we could
specify  most of the control knowledge had to be in the form of node rejection rules  general
global search also allows node preference knowledge as well as knowledge regarding effective
ways of shrinking the set of potential solutions  without splitting the set  by eliminating
non solutions  
we could eliminate the awkwardness of state variable representations as well as exploit more types of domain knowledge by designing global search tactics specially suited
to planning specific data structures  although eventually the kids system may support a
larger variety of design tactics  customizing design tactics to task classes is very much in
line with the current practice in automated software synthesis  gomes  smith    westfold 
      

    future directions

the work presented here can be seen as the beginning of a fairly open ended research program that complements  rather than competes with  the research into ecient planning
algorithms  ideally  we would like to support the synthesis of customized planners based
on the full gamut of planning technologies including partial order and task reduction planning  these latter are already subsumed by the refinement planning framework developed
in  kambhampati   srivastava        and supporting their synthesis is mainly a matter
of supporting a more exible partial plan representation in kids  representing plans as
sequences over actions has suced until now  as we were only addressing the synthesis of
state space planners   we are currently in the process of doing this  srivastava  kambhampati    mali        
more generally  any time we get insights into the internal workings of a family of planning algorithms  we would like to translate those insights into declarative specifications for
kids and support synthesis of more ecient customized domain code  an example of this
is the recent research on plan synthesis approaches based on constraint satisfaction  in fact 
domain independent planners such as graphplan  blum   furst        can solve our test
suites in equal or better time compared to the synthesized planners  we have taken some
preliminary steps towards integrating these approaches into the refinement planning framework by using the notion of disjunctive refinement planning  see kambhampati   yang 
      kambhampati      b  kambhampati  parker    lambrecht        kambhampati 
   

fisrivastava   kambhampati

    a   in future  as this work matures  we intend to explore synthesis of planners using
the theories of disjunctive plan refinement 

acknowledgements

we are grateful to doug smith for his help with kids and numerous discussions on tactics 
global search and distributive laws  we would also like to thank carla gomes for discussing
her work with us and making useful suggestions on how to write theories  and nort fowler
for his encouragement on this line of research  thanks are also due to steve minton and
the anonymous referees of jair for their many helpful comments toward improving the
presentation of this paper  this research is supported by a darpa planning initiative
phase   grant f         c       through a subcontract from kestrel to arizona state
university  

appendix a  sample code referred in the text
   get state sequence from partial plan
function visited states
 plan  seq integer   is  seq integer  
gs  seq integer  
opers  seq tuple seq integer   seq integer    
  seq seq integer  
  if empty plan  then  is 
else
if  empty next state is  first plan   opers   then
prepend visited states rest plan  
next state is  first plan   opers  
gs  opers   is 
   used by visited states to get next state
   after applying an operator
function next state
 state  seq integer   oper  integer 
operators  seq tuple seq integer   seq integer    
  seq integer 
  if fa  i  integer  i in       size state  
   operators oper    i      or
operators oper    i    state i   then
image lambda x 
if operators oper    x      then state x 
else operators oper    x  
      size state   

   domain independent pruning test for fss refinement
function no moves back  vis states  seq seq integer   
is  seq integer   gs  seq integer  
  boolean
  fa  i  integer  j  integer 
 i in       size vis states  
  j in       size vis states  
  i   j
   not  fa  index  integer 
 index in       size first vis states   
   vis states j  index   
vis states i  index 
or vis states i  index        

   

fisynthesizing customized planners from specifications

function cross no moves back
 r  seq seq integer    s  seq seq integer    is  seq integer  
gs  seq integer    boolean
  fa  i  integer  j  integer 
 i in       size r     j in       size s  
   not  fa  index  integer 
 index in       size first r   
   s j  index    r i  index 
or r i  index        
   domain independent goal test for fss refinement
function goal test
 vis states  seq seq integer    init  seq integer  
goal  seq integer    boolean
  fa  i  integer 
 i in       size goal  
   goal i      or
last vis states  i    goal i  

   domain dependent pruning test
   heuristic h   limit useless move for blocks world
function no redundancy  s  seq seq integer   
  boolean
  fa  i  integer  index  integer 
 i in       size s      
  index in       size first s   
  index mod      
and s i  index     s i      index 
   s i      index    s i      index  
   domain dependent pruning test
   heuristic h   move via table for blocks world
function no redundancy  s  seq seq integer   
init  seq integer  
goal  seq integer  
  boolean
  fa  i  integer  index  integer 
 i in       size s      
  index in       size first s   
  index mod      
  s i  index     s i      index 
       position in state i is same as
   initial state
s i  index    init index 
and
s i      index   
   position in state i   is on table
     real to nearest integer
 size first s         
or
 s i  index   
   position in state i is on table
     real to nearest integer
 size first s      
and
   position in state i   is same as
   goal state
s i      index    goal index    

   

fisrivastava   kambhampati

references

bacchus  f     kabanza  f          using temporal logic to control search in a forward
chaining planner  new directions in ai planning  ewsp     ios press          
backstrom  c     nebel  b          complexity results in sas  planning  research report 
dept comp and info sc   linkoping univ   sweden 
barrett  a     weld  d          partial order planning  evaluating possible eciency gains 
artificial intelligence         
blum  a     furst  m          fast planning through planning graph analysis  proc ijcai              
burstein  m     smith  d          itas  a portable  interactive transportation scheduling
tool using a search engine generated from formal specifications  in proceedings of  rd
ai planning systems conference  pp        
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  readings in planning  morgan kaufmann publ   san
mateo  ca 
fink  e     veloso  m          formalizing the prodigy planning algorithm  cmu cs tech
report cmu cs        
gomes  c   smith  d     westfold  s          synthesis of schedulers for planned shutdowns of power plants  proc  of   th knowledge based software engg  conf   ieee
computer society press  los alamitos ca        
gomes  c  p          planning in kids  technical report rl tr         rome laboratory 
kambhamapti  s          comparative analysis of partial order planning and htn planning 
acm sigart bulletin    
kambhampati  s       a   challenges in bridging plan sythesis paradigms  in proc  intl 
joint conference on artificial intelligence  ijcai      morgan kaufmann 
kambhampati  s       b   refinement planning as a unifying framework for plan synthesis 
ai magazine                
kambhampati  s   katukam  s     qu  y          failure driven dynamic search control
for partial order planners  an explanation based approach  artificial intelligence     
        
kambhampati  s   knoblock  c     yang  q          planning as refinement search  a
unified framework for evaluating design tradeoffs in partial order planning  artificial
intelligence               special issue on planning and scheduling 
kambhampati  s   parker  e     lambrecht  e          understanding and extending
graphplan  in proc   th european conference on planning  springer verlag 
   

fisynthesizing customized planners from specifications

kambhampati  s     srivastava  b          universal classical planning  an algorithm
for unifying state space and plan space planning approaches  new directions in ai
planning  ewsp     ios press        
kambhampati  s     srivastava  b          unifying classical planning approaches 
tech  rep  asu cse tr         arizona state university  available at
http   rakaposhi eas asu edu yochan html 
kambhampati  s     yang  x          on the role and utility of disjunctive representation
in refinement planning  in proc  fifth conf  principles of knowledge representation
and reasoning  kr      pp          
lauriere  j  l          a language and a program for stating and solving combinatorial
problems  artificial intelligence             
mcallester  d     rosenblitt  d          systematic nonlinear planning  proc   th ncai    
        
minton  s          learning effective search control knowledge  an explanation based
approach  phd thesis  carnegie  mellon university  pittsburgh  pa 
minton  s          automatically configuring constraint satisfaction problems  a case study 
constraints        
minton  s          quantitative results concerning the utility of explanation based learning 
in artificial intelligence  vol      pp          
penberthy  j     weld  d          ucpop  a sound  complete  partial order planner for
adl  proc  aaai             
russell  s     norvig  p          artificial intelligence   a modern approach  chap     
prentice hall  englewood cliffs  nj 
smith  d  r          kids  a semi automatic program development system  ieee trans 
on software engineering   special issue on formal methods      no    sep      
smith  d  r       a   structure and design of global search algorithms  kestrel tech  rep 
kes u       
smith  d  r       b   transformational approach to scheduling  kestrel institute tech 
rep  kes u         pp 
smith  d     parra  e          transformational approach to transportation scheduling  in
proceedings of the  th knowledge based software engineering conference  pp        
chicago  il  sept      
srivastava  b   kambhampati  s     mali  a          a structured approach for synthesizing
planners from specifications  proc  of   th ieee intl  conf  on automated software
engg   lake tahoe  nv 
tate  a          generating project networks  proc   th ijcai          
   

fisrivastava   kambhampati

yoshikawa  m   kaneko  k   nomura  y     watanabe  m          a constraint based
approach to high school timetabling problems  a case study  proc  ncai          
     

   

fi