journal artificial intelligence research                

submitted       published     

synthesizing customized planners specifications
biplav srivastava
subbarao kambhampati

department computer science engineering
arizona state university  tempe  az       

biplav asu edu
rao asu edu

abstract

existing plan synthesis approaches artificial intelligence fall two categories  
domain independent domain dependent  domain independent approaches applicable across variety domains  may ecient one given domain 
domain dependent approaches need  re designed domain separately 
ecient domain designed  one enticing alternative
approaches automatically synthesize domain independent planners given
knowledge domain theory planning  paper  investigate
feasibility using existing automated software synthesis tools support synthesis  specifically  describe architecture called clay kestrel interactive
development system  kids  used derive domain customized planner
semi automatic combination declarative theory planning  declarative control knowledge specific given domain  semi automatically combine derive
domain customized planners  discuss means write declarative theory
planning control knowledge kids  illustrate approach generating class
domain specific planners using state space refinements  experiments show
synthesized planners outperform classical refinement planners  implemented instantiations ucp  kambhampati   srivastava         using control knowledge 
contrast costs benefits synthesis approach conventional methods
customizing domain independent planners 

   introduction

given current state world  set desired goals  set action templates 
 planning  involves synthesizing sequence actions executed initial
state lead state world satisfies goals  fikes   nilsson       
mcallester   rosenblitt        kambhampati      b   planning known combinatorially hard problem  variety approaches plan synthesis developed
past twenty years  approaches classified two broad categories
  domain independent domain dependent  domain independent planners make
assumptions planning domains  thus accept solve planning problems domain  contrast  domain specific planners specifically designed
single domain thus dynamics control knowledge domain hard coded 
advantage domain independent planning planning algorithm
designed  used domain simply changing action template
input algorithm  contrast  domain specific planners would  modified 
 re designed  domain  ip side  domain specific planners tend

c      ai access foundation morgan kaufmann publishers  rights reserved 

fisrivastava   kambhampati

theory refinement

domain knowledge

planning
control knowledge
 eg  planes dont touchdown
without delivering packages 

  fss
  bss
kids

  pss
  htn
dynamical model
 action operator description 

problem

customized
planner

plan

figure    architectural overview planner synthesis kids clay approach 
theories refinement planning domain knowledge declaratively specified kids turn combines produce customized planner
domain  resulting planner  conventional planners  handle
planning problem domain  detailed description  see section   
ecient designated domains domain independent planners since latter may
able effectively exploit control knowledge every domain 
surprisingly  significant amount work ai planning aimed improving performance domain independent planners dynamically customizing
given domain  customization done providing domain writer ability
control search planner  case task reduction planning  kambhampati
  srivastava        kambhamapti         using learning techniques  kambhampati 
katukam    qu        minton         although several approaches developed
learning improve planning performance  present effective match
eciency domain dependent planners 
one intriguing alternative automatically synthesize domain dependent planners
given knowledge domain theory planning  paper  investigate feasibility using existing automated software synthesis tools support
synthesis  introduce clay architecture supports synthesis domain
dependent planners using kids  semi automated software synthesis system  specifically 
shown figure    declarative theory plan synthesis  theory planning  combined
control knowledge specific given domain semi automated software synthesis system called kestrel interactive development system   kids  smith            a 
  

fisynthesizing customized planners specifications

    b  derive customized planner domain  draw declarative theory
plan synthesis domain independent planning techniques  domain specific control
knowledge expressed terms types plans preferred given
domain 
approach strikes promising middle ground domain independent
domain dependent planners  theories planning encoded independent domains 
domain control knowledge encoded independent specific planning
theory used  customization step compiles domain control knowledge
planning algorithm ensures resulting planners able exploit structure
domain 

    overview synthesis approach

brie mentioned above  practicality approach predicated availability
software synthesis system capable deriving code formal specifications  kids
powerful semi automated system development correct ecient programs
formal specifications  given domain theory input output specification task 
kids system helps synthesizing program capable solving task  here  term
theory refers useful body knowledge  task refers assignment given
kids solving solution program task  input kids task
theory comprised task specification declarative description useful concepts
rules reason task space  research  give planning task kids
expect synthesize return planner solution  planner take
planning problems input return results  plans  
order support planner synthesis  develop input theory planning
kids  discussed  kambhampati      b   traditional plan synthesis techniques
described terms common plan representation  different planners corresponding different ways refining partial plans progression  regression
plan space refinements  see section       consequently  planning theory consist
specification planning task  in terms input output data types  one
refinement theories  since interested domain customized planners 
provide necessary domain knowledge kids 
given inputs  kids semi automatically synthesizes program  in case  domain dependent refinement planner  using generic algorithm design tactics  such branch
bound  global search   resulting planner  conventional planners  handle
planning problem domain  see section   details 

    outcomes

understand ecacy plan synthesis clay  paper  concentrate
synthesis planners using state space refinement theories   empirical evaluation shows
synthesized planners ecient  example  blocks world
domain goal stack inversion  kids synthesized planner solved    blocks
problem minute  logistics domain  problem    packages    planes
   future  plan extend approach plan space task reduction refinements 

  

fisrivastava   kambhampati

  places solved minute  similarly  tyre domain  russell   norvig 
        fixit  problem solved minute  put performance results
perspective  compared kids  synthesized planners set classical planners implemented instantiations ucp planning system  kambhampati   srivastava 
       described later  instantiations ucp emulate spectrum classical planners  including popular snlp planner  mcallester   rosenblitt         selecting
appropriate refinement  experiments  best kids  synthesized planners
outperformed best ucp instantiations given domain specific information  hypothesize kids profitably fold in domain specific
control knowledge  i e   domain theory  planning code 

    organization

rest paper describes details approach  called clay architecture
planner synthesis  paper organized follows  brief review traditional
plan synthesis approaches software synthesis kids section    walk
clay framework section    section   presents discussion nature planners
synthesized approach  section   empirically evaluates synthesized planners
compares classical planners  section   discusses related work  section   describes
conclusions discusses costs benefits synthesis approach 

   background

section  brie discuss relevant background software synthesis kids 
plan generation needed follow rest paper 

    kestrel interactive development system

discussing kids  start preliminaries automated software synthesis 
holy grail software synthesis  
produce highly reliable  adaptable software greatly reduced development time 
automate detail intensive tasks software production largely non creative
nature 
program  program segment  p   correct respect initial condition  assertion  final condition  assertion  f whenever true prior execution p   p terminates  f true execution p complete  using
formal specification task  knowledge base inference system  knowledge based
software synthesis proceeds iterative specification refinement process specialize
general knowledge program development  in form algorithm theories  solve
specific tasks hand  refinements sound specification correct 
synthesized program  code  correct 
kids program transformation framework development programs
formal specifications task  kids runs sun workstations built refine 
commercial knowledge based programming environment high level language 
  

fisynthesizing customized planners specifications

software specification
 input  output specification planner 

background knowledge
 domain dynamics  control

algorithm design tactics

knowledge  distributive laws etc  

 global search refinement search
planning 

un optimized algorithm
 a planning algorithm 

optimization
 simplification  finite differencing etc 

optimized algorithm
 optimized planner 

compilation

compiled code base language

figure    overview software synthesis process kids
refine language supports first order logic  set theory  pattern matching transformation rules  refine provides compiler generates common lisp c code programs
written logical specification language 
following  describe general steps involved synthesizing software kids 
figure   provides overview process  process illustrated detail
section   context synthesis customized planner code 
   develop task theory state reason task  user defines appropriate
functions types describe task gives laws allow high level
reasoning defined functions  planning  many planning theories  e g  
progression regression  written relevant laws specified  provided domain theories kids could perform specialized reasoning planners
returned solutions 
   select apply design tactic select algorithmic framework
used implement task specification  kids currently supports variety design tactics including problem reduction  divide conquer  global search local
search  planning  use global search design tactic formalization
  

fisrivastava   kambhampati

classical planning driven refinement search seen special case
global search  see below  
   apply optimizations make generated algorithm ecient  first  generated
algorithm well structured correct return valid solutions 
inecient  algorithm optimized specification reduction
techniques simplification  partial evaluation finite differencing 
   compile algorithm produce program base language 
domain theories specifications written refine  kids synthesizes
optimizes algorithms language  transform specifications programs well optimize programs  kids uses form deductive reasoning called
 directed inference  reason task specification domain theory 
kids system used derive variety programs past  particular
interest us work deriving ecient scheduling software  smith   parra       
burstein   smith         success programs provided initial impetus
research 

    theories plan synthesis

mentioned earlier  using kids derive planning software clay involves figuring
 a  declarative theories different types classical planning specified
 b  algorithmic design templates best suited planner synthesis   kambhampati 
    b  provides overview traditional plan synthesis approaches  discussed there 
plan synthesis approaches come many varieties little superficial commonality
them  last years  developed unifying framework subsumes
approaches  kambhampati   srivastava        kambhampati  knoblock   
yang        kambhampati      b   framework  plan synthesis modeled
process searching space sets action sequences  sets represented
compactly collections constraints called  partial plans   search process first
attempts extract result  an action sequence capable solving problem 
partial plan  fails   refines   or splits  partial plan set new partial
plans  each corresponding sets action sequences subsets action sequence
set corresponding original partial plan   considers new plans turn 
existing domain independent plan synthesis algorithms correspond four different ways
refining partial plans  known  respectively  forward state space progression
refinement  fss   backward state space refinement regression refinement  bss   plan
space refinement  pss  task reduction refinement  strips  fikes   nilsson       
example planner using fss refinement  topi  barrett   weld        uses
bss refinement  snlp  mcallester   rosenblitt        uses plan space refinement
nonlin  tate        uses task reduction refinement  given background 
declarative theory plan generation clay corresponds theories refinements 
algorithm tactic underlying plan generation corresponds  refinement search  
kids system supports algorithm tactic called  global search   smith      a 
seen generalization refinement search 
  

fisynthesizing customized planners specifications

specification  planning problem  
encoding
domain knowledge
theory import
direction

planner

level  

refinement theory  refinements available  
progression fss 

regression bss 

plan space  ps 

level  

domain theory  particular planning domain unique  

blocks world
domain
knowlegde

blocks world
progression

logistics domain
knowlegde

level  

blocks world
regression
logistics progression

logistics
regression

figure    clay architecture writing planning theory  level answers question
relevant level planning detail  clay uses kids  feature theory
import modularize domain specific planning theory

   developing planner declarative specification  clay
architecture

figure   summarizes kids used synthesize domain specific refinement planner  domain knowledge consists dynamical model control knowledge 
dynamical model specified form actions  also called operators  define legal transformations one state world another  control knowledge set
domain specific criteria helps planner decide plan p  better p 
intended make search ecient  example control knowledge logistics domain packages moved destinations using airplanes 
planes touchdown location packages pickup deliver 
refinement planning domain control knowledge brought together clay
architecture writing declarative domain specific planning theory summarized figure    specify planning task  plan representation selected constraints
satisfied solution plan enumerated planner specification 
planner specification dependent plan representation independent
refinement needed search  refinement strategy uses planner specification
defines children nodes generated given partial plan  goal test
be  explicates refinement specific search pruning tests  refinement
  

fisrivastava   kambhampati

specification together form planning theory  obtain domain dependent planner 
one needs import planning theory provide relevant domain specific
planning control knowledge provides preference structure among partial plans
competing solutions  interesting special case one specifies generic domain
knowledge effect plans equally good domain  case 
based refinement used  one gets fss  bss  pss hybrid  if multiple refinements
used   general purpose planner 
level directed tree figure   represents abstraction planning
task  root tree  level     description planning task required
without specifying refinements strategies used  level    refinements
specified assumption made domain  next  characteristics
domain provided level    progression  fss  blocks world planner different
progression logistics domain planner terms domain knowledge 
hand  progression blocks world planner different regression  bss  blocks world
planner terms refinement used 
stated above  ensure exibility  control knowledge change
different refinements used thereby represent substantial exibility  practice 
since control knowledge helps prune children nodes produced refinement  pruning may
effective control knowledge encoded depending refinement 
middle ground implemented  domain control knowledge
may represented intermediate form depending partial plan representation 
refinement provide  addition termination test  conversion function
transform control knowledge refinement specific form 

    representing domain operators

discuss world state represented domain operators define
state transformations  classical planning  world modeled terms set  state
variables   state world corresponds particular assignments values
variables  actions described terms specific variable value combinations
needed applicable  variable value combinations enforce
execution  two variants general modeling approach become popular
planning community  first  called strips representation  fikes   nilsson       
represents world terms ground atoms first order logic  action applicability
conditions effects described terms conjunctions ground atoms 
second variant  backstrom   nebel        models world actions directly terms
multi valued state variables values  since strips representation seen
state variable model boolean state variables  since multi valued statevariable system converted equivalent boolean state variable system  two
representations equivalent expressive power 
chose state variable representation implementation since
directly mapped primitive data structures supported kids  figure   shows
action moving block block b top block c strips statevariable representation  blocks world domain environment blocks
placed table top blocks problems involve stacking
   

fisynthesizing customized planners specifications

strips representation

action  move a  b  c  
prec  clear a    clear c      on a  b  
post  on a  c     clear b      clear c  
  on a  b  

muti valued state variable representation

action  move a  b  c  
pre  hb  true     false     truei
post  hc  true     true     falsei

 where state   tuple
h pos a  clr a  pos b  clr b  pos c  clr c i 
zeroes represent  don t care  values 

figure    different representations  move b c 
desired configuration  purpose exposition  showing values state
variables corresponding block positions  e g   pos a  symbols  b    c   etc  clear
conditions  e g   clr a  true false  practice  map valid values state
variables integers 

    specification planner

kids uses functional specification programming language augmented set theoretic
data types  specification task  smith      a  represented quadruple
f   hd  r  i  oi input type satisfying input condition      boolean 
output type r output condition    r   boolean  defines feasible solution  o x z  holds  z feasible solution respect input x  specification
program follows template 
function f  x  d    set r 
i x 
returns f z j  x z  g
  body x 
specification program f consistent possible inputs satisfying input
condition  body produces feasible solution  i e     x   d   z   r  i  x     o x  z    
within view  planner takes inputs initial state  goal state operator
list  operators assumed define state transitions valid states valid states 
specification planning task is  given initial state  goal state
operator list  return sequence operators  plan  that 



termination test  goals must hold final state resulting execu 

tion plan   we considering planning problems goal
make state variables achieve specified values  i e   goals achievement  
domain independent pruning test  plan passes domain independent
pruning tests  planning refinemen specify conditions partialplan cannot lead desirable solution  partial plan satisfying pruning
   

fisrivastava   kambhampati

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test visited states
 plan  init  goal  opers  
init  goal 
  no moves back visited states
 plan  init  goal  opers  
init  goal 
  goal test visited states
 plan  init  goal  opers  
init  goal  

figure    declarative specification planning
test eliminated consideration  example  state loop pruning heuristic forward state space refinement says partial plan
plan state executing operator o  subset state following
earlier operator o    partial plan pruned 
domain dependent pruning test  plan passes additional domain specific
pruning tests 
last one hook domain specific control knowledge introduced 
current implementation clay  use domain knowledge rejecting undesirable
partial plans  section      discuss ways implementation extended
support uses domain control knowledge 
specification planning task declarative states constraints must satisfied resulting plan produced planner given planning
problem  suggest algorithm used obtain results  algorithmic decisions made program development phase kids 
example top level specification planning task  in refine  shown figure   
specification  input condition    true  input data type  includes init 
goal opers  output data type r plan output condition consists
goodness test  goal test  no moves back  no moves back domain independent
pruning tests whereas goodness test domain dependent pruning test 
delving deeper representation detail  represent plan sequence indices
operator list  i e   sequence operator identifiers   state space planning 
state sequence corresponding partial plan produced function visited states
goal test  domain independent pruning tests domain dependent pruning tests
done state sequence functions goal test  no moves back goodnesstest respectively  state variables take integer values  consequently  initial
goal states sequence integers 
words  specification figure   says partial plan sequence integral
indices  of operators  indices must size operator list  valid
   

fisynthesizing customized planners specifications

plan one whose corresponding state sequence  produced visited states  satisfies
goal test  no moves back goodness test  
context forward state space refinement  fss   visited states returns
states obtained successive application operators partial plan
initial state resulting states thereafter  goal test signals goal
achieved  fss refinement involves checking last state state sequence
goal state  no moves back function tests state looping  forward state space
looping checks state executing operator oj  state sj   subset state
following earlier operator oi  i   j    state si    partial plan pruned  
function goodness test checks possible redundancy state sequence
corresponding current partial plan based domain characteristics  let us explain
context blocks world domain  specify reasonable checks
blocks world long make planner lose desired solution  below 
present two goodness tests 

 heuristic h   limit useless moves  block moves states  i    

must change position states  i     i     motivation behind
check prevent blocks moved around randomly successive moves 
 heuristic h   move via table  block move initial state
table table goal position  motivated fact
polynomial time approximate algorithm solving blocks world planning problems involves putting blocks table first  constructing goal
configuration stacks bottom up  

    implementing specification using global search

discussed section    need select algorithm design tactic implement task
specification kids  one design tactics provided kids global search  basic
idea global search represent manipulate sets candidate solutions  principal
operations extract candidate solutions set split set subsets 
derived operations include various filters used eliminate sets containing
feasible optimal solutions  global search algorithms work follows  starting
initial set potential solutions  contains desired solutions given problem
instance  algorithm repeatedly extracts solutions  splits sets eliminates sets via
filters candidate solution drawn one sets  sets solutions
represented implicitly data structures called descriptors  splitting done adding
   refine code referenced functions shown appendix a 
   actually  test slightly general condition state executing operator oj  state
sj   weaker state following earlier operator oi  state si    partial plan
pruned  sj weaker si every state variable assigned value state si assigned
value state sj   specifying weakness rather subset relationship states decide
domain independent pruning state space planning  allow synthesized planner deal
partially specified initial state  planner work correctly long state variables
required reasoning specified initial state 
   pruning test alone doesn t guarantee polynomial algorithm since order blocks
put table later goal positions specified pruning heuristic 

   

fisrivastava   kambhampati

mutually exclusive exhaustive sets constraints descriptors  process
described tree search node represents set candidates arc
represents split relationship set subset  complete details  readers
referred  smith      a  
kids  global search paradigm general form refinement search model
used unify classical planners ucp  kambhampati   srivastava         specifically 
partial plans correspond descriptors refinements correspond splitting
strategies  use global search implement planner specification  need select
suitable representation sets potential solutions  which  refinement view
planning  essentially partial plans   global search tactic would set
search algorithm split solution set extract solutions meet problem
specification  kids provides global search tactics primitive data types sequences 
sets maps  complex data type needed represent potential solution set
task  user must implement global search tactic it 
since interested state space planners initially  chose represent partial
plan sequence operators  actually sequence operator indices   allowed us
use kids global search theory finite sequences 

    specifying distributive monotonic laws

one aspect kids specification slightly unintuitive new users need
specify distributive monotonic laws operations used input output
specification  e g   no moves back specification progression planner shown
figure     distributive laws state specific operation distributes operations
 e g    a   b   c  a c      b c     monotonic laws provide set boundary
conditions  e g        a   laws explicitly stated operations involved
specification support instantiation design tactics  well optimization
generated code  specifically  kids directed inference engine called rainbow
uses task specification distributed laws specified user simplify
reformulate expressions synthesized code  deductive inference primary
means kids reasons task specification order apply design tactics 
optimize code  derive necessary pruning conditions  distributive monotonic
laws indirectly provide kids information alternative ways defining predicates 
useful heuristic writing laws simple  normally expressed
terms main function perhaps another function handle boundary cases  called
cross functions  see below   example  consider figure   function no movesback domain independent pruning test used specification progression planners 
recall no moves back called state sequence checks later state
subset  or weaker than  earlier state  calling no moves back sequence
concatenation state sequences s  s  equivalent calling s 
s  testing state s  weaker state s   notice first two
tests handled no moves back last test needs new function 
call new function cross function no moves back  cross no moves back  
monotonic laws no moves back include 



no moves back singleton state sequence true 

   

fisynthesizing customized planners specifications



no moves back empty state sequence false  useful selected action

applicable  

similarly  distributive laws no moves back include 



no moves back sequence concatenation equal no moves back s    nomoves back s  cross no moves back s  s   

state prepended state sequence   applying no moves back

combined state sequence equivalent applying cross no moves back
singleton sequence  a    no moves back  
state appended state sequence   no moves back
combined state sequence no moves back cross no movesback singleton sequence  a  

rules  reasonably obvious us  nonetheless crucial
effectiveness kids help reformulating optimizing generated code 
example use  see section        occurs figure    if
 condition     then     else   statement gets simplified   then   part
conditions   condition   proved true context input
specification  given distributive laws 
using task specification  selected design tactic   global search  distributive
laws  kids produces correct naive code  shown figure    code naive
checks  for example cross no moves back figure    computed
repeatedly even true context  discuss methods optimize
code next section 

    program optimization

section explains initial planner code  generated kids  optimized  readers
familiar automated software synthesis literature might want skip section
first read  revisit later details 
first code produced kids  shown figure    well structured inecient  several opportunities optimization kids provides tools program
optimization  code compiled executed stage optimization  now 
brie summarize program optimizations used achieve eciency 
      context independent simplifier

method simplifies expression independent surrounding context 
two possibilities context independent simplification 
first case  set equations treated left to right rewrite rules
fired exhaustively none apply  distributive laws treated rewrite rules 
example application rewrite rule is 
 if true p else q     p
   

fisrivastava   kambhampati

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goal test
 visited states plan  init  goal  opers  
init  goal  
  no moves back
 visited states     init  goal  opers  
init  goal 
  goodness test
 visited states     init  goal  opers  
init  goal 
planner aux init  goal  opers     
else undefined

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
  goodness test
 visited states v  init  goal  opers  
init  goal 
  no moves back
 visited states v  init  goal  opers  
init  goal  
  seq integer 
  ex  plan  seq integer  
 goal test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  range plan  subset       size opers  
  plan   v 
 plan    seq integer  
 goal test
 visited states plan    init  goal  opers  
init  goal 
  no moves back
 visited states plan    init  goal  opers  
init  goal 
  goodness test
 visited states plan    init  goal  opers  
init  goal 
  range plan    subset       size opers  
  plan     v 
else  plan    seq integer  
ex  new v  seq integer  
 plan    
planner aux init  goal  opers  new v 
  defined  plan   
  goodness test
 visited states new v  init  goal  opers  
init  goal 
  no moves back
 visited states new v  init  goal  opers  
init  goal 
  ex  i  integer 
 new v   append v  i 
        size opers    

figure    first progression blocks world planner code synthesized kids  notice
code inecient checks  for example  cross no moves back 
computed repeatedly  even true context 

   

fisynthesizing customized planners specifications

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer   
range plan  subset       size opers  
    
  no moves back
 visited states     init  goal  opers  
init  goal 
goodness test
 visited states     init  goal  opers  
init  goal 
planner aux
 init  goal  opers       init   init 
size opers  
else undefined

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer   
range plan  subset       size opers  
    
  planner aux
 init  goal  opers       init   init 
size opers  

figure    example context independent simplification kids  code right
size simplified version left 
function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
goodness test visited states
 v  init  goal  opers  
init  goal 
no moves back visited states
 v  init  goal  opers  
init  goal  
  seq integer 
  goal test 
visited states v  init  goal  opers  
init  goal 
no moves back visited states
 v  init  goal  opers  
init  goal 
goodness test visited states
 v  init  goal  opers  
init  goal 
range v  subset       size opers  
 if         

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer 
  range v  subset       size opers  
goodness test visited states
 v  init  goal  opers  
init  goal 
no moves back visited states
 v  init  goal  opers  
init  goal  
  seq integer 
  goal test 
visited states v  init  goal  opers  
init  goal 
 if         

figure    example context dependent simplification kids  code right size
simplified version left 

second case  occurrences local variable defined equality

replaced equivalent value 
fc  x  j x   e   p  x g    fc  e  j p  e g
figure   shows example context independent simplification conditions
if condition true respective distributive laws  hence  if then else
statement replaced then part 
   

fisrivastava   kambhampati

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
l vs  seq integer   
seqequal l vs  last vs  
range v  subset       size opers  
    
  goal test vs  init  goal  v
else  plan    seq integer  
exists i  integer 
 i       size opers  
   

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
l vs  seq integer   num ops  integer
 
num ops   size opers 
    
  goal test vs  init  goal  v
else  plan    seq integer  
exists i  integer 
 i       num ops 
   

figure    example finite differencing  on size opers    code right size
result finite differencing left 
   focus initialize planner
   tactic global search planner
   simplify  context independent fast       
else  plan         
   simplify  context dependent  forward    backward   
                 
   simplify  context dependent  forward    backward   
   else und   
   fd  general purpose  vs  
visited states v  init  goal  opers 
   fd  general purpose  l vs   last vs 
   fd  general purpose  num ops   size opers 
   abstract next state l vs  i  opers  ns
ex  i  integer             
   simplify  context independent fast 
        planner aux           
    refine compile lisp  planner aux  planner

figure     derivation steps generate progression planner blocks world domain 
      context dependent simplifier

method designed simplify given expression respect surrounding context is  thus  powerful context independent simplification  predicates
hold context expression gathered walking abstract syntax
tree  expression simplified respect set assumptions hold
context  figure    function calls no moves back  goodness test
range test  if  expression redundant results follow input
invariant  conditions listed  j       planner aux function 
removed simplification 

   

fisynthesizing customized planners specifications

function planner
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
returns
 plan  seq integer 
  range plan  subset       size opers  
  goodness test
 visited states plan  init  goal  opers  
init  goal 
  no moves back
 visited states plan  init  goal  opers  
init  goal 
  goal test
 visited states plan  init  goal  opers  
init  goal  
  planner aux
 init  goal  opers       init  
size opers   init 

function planner aux
 init  seq integer   goal  seq integer  
opers  seq tuple seq integer   seq integer    
v  seq integer   vs  seq seq integer   
num ops  integer  l vs  seq integer 
  seqequal l vs  last vs  
  seqequal vs 
visited states v  init  goal  opers  
  no moves back
 visited states v  init  goal  opers  
init  goal 
  goodness test
 visited states v  init  goal  opers  
init  goal 
  range v  subset       size opers  
  num ops   size opers  
  seq integer 
  goal test vs  init  goal  v
else  plan    seq integer  
ex  ns  seq integer   i  integer 
 ns   next state l vs  i  opers 
  cross no moves back vs   ns   init  goal 
  cross goodness test vs   ns   init  goal 
  defined  plan   
  plan  
  planner aux
 init  goal  opers  append v  i  
append vs  ns   num ops  ns 
        num ops  

figure     final progression blocks world planner code synthesized kids
      finite differencing

idea behind finite differencing perform computations incrementally rather
repeat scratch every time  let us assume inside function f  x 
expression g x  x changes regular way  case  might useful
create new variable  equal g x   whose value maintained across iterations
allows incremental computation g x  next x value  finite differencing
decomposed two basic operations  abstraction simplification  smith      a 

first  function f abstracted respect expression g x  adding new
parameter c parameter list f  now f  x  c   adding c   g x  new input
invariant f   calls f   whether recursive calls within f external calls  must
changed match definition f i e  f  x  changed f  x  g x   
process  occurrences g x  replaced c 
distributive laws apply g h x   yielding expression form h  g x  
h   c   new value g h x   computed terms old value g x 
real benefit optimization 

let us illustrate process example  suppose function f  x 
call function g x  returns square numbers variable x varies linearly 
now  suppose given distributive law g x        g x      x      so 
finite differencing  f becomes f  x  c  g x  call replaced c     x     
   

fisrivastava   kambhampati

additional invariant c   x x maintained f   new expression
computationally much cheaper original expression 
figure    finite differencing performed size opers    argument function
planner expanded inclusion num ops  name entered user
value size opers    abstraction done number operators
available planner change planning  note num ops represents
number operators planning problem meaningful concept planning 
instances size opers   replaced num ops 
      program derivation

figure    shows summary sequence derivation steps carried obtain
blocks world domain specific forward state space planner  final version planner
code shown figure    
step    top level planner specification selected step    selected design
tactic applied  step   involves context independent simplification  steps  
  involve context dependent simplifications  steps     cover finite differencing 
finally  ecient planner code compiled step    

   discussion synthesized planners

section     used synthesis progression planner blocks world domain case
study walk through planner synthesis process leading final planner given
figure     research  considered regression  backward state space 
planners  planners synthesized date summarized table    although
planners differ terms refinements use  domains
customized  figure    attempts pseudo code description generic template
facilitate discussion synthesized planners group 
main function planner takes initial state  goal state operator set
inputs turn calls recursive function planner aux inputs
initial plan  pruning tests comprising output conditions maintained
 invariants   in must hold final plan  every partial
plan leading final plan   goal test  course  need hold final plan 
thus maintained invariant  finite differencing leads invariants 
inside planner aux  partial plan satisfies goal test  returned  otherwise 
partial plan refined  invariants incrementally tested new partial plan
planner aux called recursively 
first thing note pseudo code template describes planner planning
domain employing state space refinement  even requirement synthesized
planner state space dictated new partial plan  partial plan   obtained
 in case appending operator operator sequence   generalized
support refinements  modifying operation  in current case  append  
used build new partial plan old one  with corresponding changes
distributive laws account new operation  
second  observe invariants incrementally evaluated  see planner aux  
example  see plan ith iteration satisfies no moves back test 
   

fisynthesizing customized planners specifications

check latest state duplicated previous states  hypothesize
incremental evaluation primary reason synthesized planner s eciency 
refinement planning domain knowledge available  context dependent simplification
may show many tests made separate theories fact redundant 
moreover  incremental evaluations may cheaper complete evaluations invariants
amenable operations distribution monotonicity abstract
data types 
although domain independent planners given control knowledge
give kids planner synthesis  approach expected superior two
ways 
   approach separates control knowledge acquisition specifics
planner extent makes acquisition process easier  contrast 
controlling search domain independent planner requires user think
terms specific  choice points  planner s search strategy 
   importantly  search control domain independent planners typically involves
generating unpromising partial plans first pruning them  contrast  approach improves eciency  folding in  control knowledge synthesized
planner code  incremental evaluation pruning test  specifically  first
approximation  conventional domain independent planners add goodnesstest either control search choice points post process generated partial plans  specify distributive laws goodness test
incrementally evaluated  in terms cross goodness test goodness test 
perform context dependent analysis pieces available knowledge
optimize code  mean  folding in  control knowledge 
figure     see instance control knowledge folded synthesized progression planner blocks world domain  contrast first synthesized
planner shown figure    notice redundant invocation various checks  such
goodness test  visited states  etc  earlier planner simplified away 
moreover  individual checks  such no moves back goodness test 
simplified based distributive laws  like cross no moves back crossgoodness test  consider newly added parts partial plan 
considerations lead small ecient final planner 

   empirical evaluation synthesized planners

table   lists several domain dependent state space planners synthesized
date  planners characterized domain developed   bw 
blocks world   log  logistics   tyr  tyre world   benchmark
domains ai planning   type  state space  refinement used   p  progression
 r  regression   type domain specific control knowledge used  h 
limits useless moves  h  moves blocks via table  etc    report results
empirical study conducted synthesized planners  study two aims 
ascertain whether synthesized planners able eciently exploit domain
knowledge 
   

fisrivastava   kambhampati

   main function planner calls auxiliary function
function planner  initial state  goal state  operator set 
returns plan
output conditions satisfied
 
planner aux initial state  goal state  operator set 
initial plan      
   note  parameters added finite differencing
   function planner aux called planner planner aux
   note  set output conditions given part
  
problem specification  kids selects one
  
maintained invariants  finite differencing
  
gives invariants 
function planner aux initial state  goal state  operator set 
current plan      
invariants satisfied state sequence
corresponding current plan
return type plan
 
state sequence ensures satisfaction goal state
current plan executed initial state
return current plan
else consider partial plan    append current plan  i 
index valid operator operator set 
a  incremental test invariants true
state sequence corresponding partial plan 
b  partial plan   
planner aux initial state  goal state  operator set 
partial plan       

figure     pseudo code state space planners synthesized kids

ascertain synthesized planners better traditional domain indepen 

dent planners utilizing domain control knowledge 
discussion organized follows  section      describe domains
problems considered empirical work  section      evaluate absolute
performance synthesized planners various domains  section     compare
performance synthesized planners traditional planners 

    domains problems
      blocks world domain

blocks world domain environment block placed either table
top blocks  problems involve stacking desired configuration 
let us focus two states particular  a on top n on top 
   n blocks  a on top stands state block top block b  block b
   

fisynthesizing customized planners specifications

name
bw p h 
bw p h 
bw r h 
bw r h 
log p l
log r l
tyr p m
indep p
indep r

customized
domain
blocks world
blocks world
blocks world
blocks world
logistics
logistics
tyre world
 none none 

refinement

domain dependent pruning test

progression  fss 
progression  fss 
regression  bss 
regression  bss 
progression  fss 
regression  bss 
progression  fss 
progression  fss 
regression  bss 

limit useless moves  h  
move via table  h  
limit useless moves  h  
move via table  h  
limit ineciency
limit ineciency
multiple control rules
true  every state ok 
true  every state ok 

table    table showing variety planners synthesized kids  names
planners follow format  domain   refinement   heuristic  
top block c       block n   top block n block n table  similarly 
n on top stands state block table  block b top block a 
     block n top block n    problems reported experiments one three
types 
   stack inversion  invert a on top n on top 
   stack building  initial state collection random stacks two blocks height
last n   blocks either put first n   blocks table 
goal state a on top n on top 
   random blocks world problems  subset random blocks world problems generated using minton s algorithm  minton         problem n blocks  goal
state n   goal conditions 
domain dependent pruning tests blocks world covered section    specifically  covered pruning test h  prevents block moved consecutive
steps  test h  requires blocks moved via table 
      logistics domain

logistics domain consists several planes packages different places  goals
involve transporting planes packages specified locations  considered
type logistics domain k planes   k places  k packages 
either   packages   package   plane place  goal get planes
packages distinguished place 
domain dependent pruning test logistics transportation domain   which
call  limit ineciency  heuristic  consists following pieces advice 
   

fisrivastava   kambhampati

   planes make consecutive ights without loading unloading package
   packages either goal position begin with  may loaded inside
plane goal position 
   package reaches goal position  moved 
      tyre world domain

tyre world  russell   norvig        benchmark domain complex causal
structure  blum   furst          fixit  problem domain  car s tyre
must replaced spare tyre  which must first ated   original
tyre placed boot tools must returned boot  domain
dependent pruning test devised enforces following constraints 
   one state variable changes one state s    next state s    
change subsequent state s     state variable describes attribute object domain  attribute value
state s   overwritten  state s    might indicate non minimal
plan  
   work status boot last 
   fixing free hub invalid   wheel must first 
   jacked up car needs tyre  jack without putting
tyre it 
   work position pump wrench wheels hub
final configuration 
   wheels goal positions  moved 

    absolute performance synthesized planners

section  discuss absolute performance synthesized planners different
domains  shall see  synthesized planners able solve benchmark
problems known hard traditional planners  special note order
regarding plots follow  plots follow  curve stops mid way
graph  means corresponding planner could solve given problem
problems problem class  as applicable  stipulated time 
      planners blocks world

traditional planners  domain specific information helps planner return result faster
obtained similar results synthesized planners  seen left
   true domains  since domains  way state variable shift value
v  v  transition v    heuristic however preserve completeness tyre
world 

   

fisynthesizing customized planners specifications

synthesized progression planners block world

synthesized progression planner logistics

effectiveness domain based pruning tests

effectiveness domain base pruning tests

        

       

bw p h 
indep p

log p l
indep p
      

      

log  time  in secs  

log  time  in secs  

     

    

    

   
   
   

   
   

    

   
   

    
  blocks

   
   
   
   
  planes  x places   x packages 

   

figure     plots show domain dependent goodness tests lead ecient planners 
problem domains blocks world  left  logistics transportation domain
 right   planners domain guidance perform better without it 
plot figure     domain specific blocks world heuristic h    limit useless moves  
helped progression planner  bw p h   solve stack inversion problem  invert aon top n on top     blocks minute     blocks   
minutes  without heuristic  progression planner  indep p  could solve even
  block stack inversion problem time 
      planners logistics domain

logistics domain  progression planner limit ineciency heuristic  logp l  could solve   plane problems minute   plane problems    minutes
 figure     right   without heuristic  progression planner  indep p  could
solve even   plane problem time 
      planners tyre world

   operators     state variables   control rules manually encoded tyre
world  russell   norvig        description  fixit problem solved minute
   step plan returned 

    comparing traditional synthesized planners blocks world

since synthesized planners used domain specific control knowledge normally
used domain independent planners  next step involved comparing synthesized planners domain independent planners using control knowledge  aim see
synthesized planners better able exploit domain knowledge traditional planners  restricted detailed comparison blocks world domain  since
   

fisrivastava   kambhampati

variety traditional classical planners varying tradeoffs
 c f   barrett   weld        kambhampati et al           used  league tournament 
approach comparison  specifically  since popular classical planners correspond
different instantiations ucp  kambhampati   srivastava         first ran
blocks world problem distribution isolate best traditional planners  similar
study done isolate best synthesized planners problem distribution 
point  best synthesized planner compared best traditional planner 
second round comparison  winning traditional planner given control
knowledge synthesized planner 
used two three blocks world test suites   random blocks world
problems stack building problems   comparisons  problem class
defined terms number blocks average    runs shown plot 
total time allowed class problems      seconds planner
deemed failed problem class  planners run problems
problem suite 
      picking best synthesized planner

section  want empirically determine effective refinement
control knowledge  heuristics  blocks world problem suites  ran six synthesized
planners  bw p h   bw p h   indep p  bw r h   bw r h  indep r 
test suite  figure    shows relative performance  notice planners
pruning test h  perform best compared planners using
refinement  
      picking best traditional planner

section  empirically search best ucp strategy blocks world  figure    shows performance ucp instantiations domain dependent heuristic
information  instantiations ucp fss  bss ps refinements emulate
classical forward state space  backward state space plan space planners  respectively 
call instantiations ucp fss  ucp bss ucp ps  ucp lcfr hybrid strategy
interleaves fss  bss ps refinements depending lower branching factor
 kambhampati   srivastava         random blocks world problems  left 
stacking building problems  right   left right plots  ucp fss solves
   notice progression planners perform better left plot regression planners perform
better right plot  trend explained easily terms way refinements operate
 kambhampati      b   left figure  based nature goals  branching factor
regression planners may become enormous cannot detect con icts among
steps give conditions goal  or steps eventually support goal condition   many
operators seem potentially give condition actually case  hand 
completely specified initial state helps progression planner decide applicable operators
beginning itself  consequently  progression planner bw p h  clear win  right plot 
initial goal states completely specified  regression progression planners detect
con icts  true realistic domains  many operators applicable initial state
relevant achieving goal conditions  so  regression planner bw r h  performs better
progression planner bw p h  

   

fisynthesizing customized planners specifications

performance synthesized planners

performance synthesized planners

random blocks world problems

build stack achieve a on top

     

     

bw p h 
bw p h 
indep p
bw r h 
bw r h 
indep r

    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

bw p h 
bw p h 
indep p
bw r h 
bw r h 
indep r

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     performance synthesized progression regression planners h  
h  domain dependent control knowledge  bw p h  perform best
left plot bw r h  performs best right plot  points close
together  clear bw r h  indep r solve problems upto  
blocks left plot 
performance ucp instantiations

performance ucp instantiations

mintons random blocks world problems

go random stacks upto two blocks height a on top

     

     

ucp ps
ucp fss
ucp bss
ucp lcfr

ucp ps
ucp fss
ucp bss
ucp lcfr
    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

   

   

   
  blocks

   

   

figure     performance ucp instantiations domain dependent heuristic 
left right plots  ucp fss solves problems least time  based
results  see ucp fss good strategy blocks world  note
figure ucp bss solves   blocks problems given time
plots 
   

fisrivastava   kambhampati

comparison ucp fss synthesized planners

comparison ucp fss synthsized planners

random blocks world problems

build stack achieve a on top

     

     
bw p h 
ucp fss h 

bw r h 
ucp fss h 

    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     best ucp strategy blocks world  namely ucp fss  performs
best kids  synthesized planners  left plot  ucp fss better
indep p i e   without heuristic information  h  heuristic
given planners  bw p h  winner  right plot  bw r h 
outperforms ucp fss h  
problems least time  based results  see ucp fss good strategy
blocks world problem distributions used  
      comparing best synthesized planner best traditional
planner

finally  pit best ucp strategy blocks world  namely ucp fss 
best kids  synthesized planners  chose bw p h  random blocks world
problem suite bw r h  stack building problem suite  comparison done
planners either given heuristic information  h   domain dependent
guidance  figure    plots results  left plot  bw p h  clear winner
planners given domain specific heuristic h   right plot  bw r h 
outperforms ucp fss h   so  see given heuristic information 
best planners synthesized kids outperform best instantiation ucp
blocks world 
interesting note synthesized planners improve drastically
domain specific knowledge  domain independent planners always improve
way  illustrate figure     compare ucp instantiations
synthesized planers without control heuristics  synthesized planners
   note case synthesized planners  planner based regression outperformed one based
progression stack building problems  contrast  ucp fss performs ucp bss
problem suite  reason particular implementation ucp bss 
involves costly unification step 

   

fisynthesizing customized planners specifications

comparison ucp fss synthesized planners comparison ucp fss synthesized planners
random blocks world problems

build stack achieve a on top

     

     
bw p h 
ucp fss h 
indep p
ucp fss dom indep

bw r h 
ucp fss h 
indep r
ucp fss dom indep
    

log  time  in secs  

log  time  in secs  

    

   

   

   
   

   

   

   

   
  blocks

   

   
   

    

   

   
  blocks

   

    

figure     effect control knowledge ucp planners vs  kids synthesized planners 
always improve addition control knowledge  true ucp
instantiations  specifically  right plot  see ucp fss h   uses control
knowledge h  worse ucp fss dom indep  use control
knowledge  speculate ucp fss explicitly calls function
domain specific reasoning recursive invocation synthesized planners
domain control knowledge folded planner code  see section    

    summary results

summary  demonstrated that 

clay approach writing domain specific planning theory exible  sup 

ports mix and match refinements control knowledge generating variety
customized planners  examples  presented planners blocks world  logistics
domain tyre domain  using forward backward state space refinements
different types domain specific control knowledge 
synthesized planners exploit domain dependent control knowledge improve performance  showed that  fact  better able exploit domain
knowledge traditional planners can 

   related work

research reported straddles two fields automated software synthesis
ai planning  although research first address issue planner synthesis 
synthesis types search engines addressed smith co workers 
particular interest us work developing automated scheduling software
transportation logistics problems using kids system  smith   parra        burstein  
smith         scheduling systems generated shown significantly
   

fisrivastava   kambhampati

outperform general purpose schedulers working problem  results provided
initial impetus research  although original work used design tactic
based global search model scheduling  since developed design
tactics based local search regimes  another interesting issue brought
work importance  constraint propagation  techniques deriving ecient code 
made us explore role  or lack thereof  constraint propagation planning 
kambhampati yang        describe ways refinement planning framework
extended exploit constraint satisfaction techniques  future  hope able
synthesize planners using general theory refinement planning 
although much work automated planner synthesis  notable exception work gomes         gomes synthesized state space problem solver
 missionaries cannibals  problem kids  shown synthesized
code outperforms general purpose problem solvers domain  framework
seen generalization work done gomes  particular  separate planning
theories dynamics control knowledge  principle supports generation planning code based variety refinements  demonstrated
deriving progression regression planners three different domains  blocks world 
logistics tyre world  two different bodies control knowledge case 
methodologically  work adds gomes  results shown given
control knowledge  planners generated kids outperform traditional planners
using control knowledge choice points  makes fairer comparison
synthesized general purpose planners 
existing planners ucpop  penberthy   weld        prodigy
 fink   veloso         customization supported allowing user specify search
control rules checked every choice point search  control rules
used rank search nodes based heuristic  prune unpromising nodes 
main difference approaches synthesis approach described
supports higher degree integration domain knowledge planner
folding synthesized code planner  planners using search control rules
cannot context dependent analysis incremental application control knowledge 
contrast  approach  control information encoded declaratively planning
algorithm optimized based knowledge available  including
control knowledge 
work utilizing explicit control knowledge addition domain dynamics
deriving planning code parallels recent work bacchus kabanza
        concentrate providing rich language control knowledge
specified progression planner  describe language based temporal logic
specify domain control rules  rather using knowledge prune bad plans
generated  bacchus kabanza explore ways incrementally tracking level
satisfaction control axioms planning progresses  approach facilitates
same  refinement independent setting   folding in  control knowledge
developed planning code  help kids framework 
work constraint satisfaction community directed towards producing specialized  customized  programs relevant research described here 
coastool  yoshikawa  kaneko  nomura    watanabe        alice systems  lau   

fisynthesizing customized planners specifications

riere        take declarative description csps compile specialized algorithms solving them  multi tac  minton        supports automatic configuration constraint
satisfaction programs  multi tac system  particular  provides interesting contrast approach  multi tac starts algorithm schema  list high level
heuristic rules various decision points  e g    most constrained variable first  heuristic
variable selection  least constraining value first  value selection csp search  
list ags indicating whether certain procedures  e g   forward checking csp 
used  multi tac uses domain specification specialize high level
heuristics given it  example  context minimum maximal matching problem
graph theory  most constrained variable first heuristic may become  choose edge
neighbors assigned values    configuration particular
subset specialized heuristics used  particular assignment ags  multitac first searches space  configurations  see configuration best fits
given problem population  best configuration found  automatically
compiled ecient code using specification refinement techniques similar
described section     
multi tac thus presents interesting middle ground search control rule
specification approach used ucpop prodigy planners  full integration
domain knowledge synthesized code  promised clay approach  contrast
ucpop prodigy search control rule approach  multi tac compilation
phase support folding in search control rules compiled code  contrast
clay advocates semi automatic synthesis piece software manually
guided optimization  through help user specified distributive monotonicity laws  
multi tac supports fully automating customization configurable template 
clay approach effective  need provide declarative specification
task domain control knowledge  well high level algorithm tactics  kids
deals instantiating tactics specific problem  simplification needs
guided careful specification distributive monotonicity laws  contrast  multitac s configuration approach needs algorithm template already semi customized
specific task  built in hooks using heuristics  heuristics
specified form meta heuristic knowledge 
multi tac  domain knowledge used specializing meta heuristics 
theory  clay approach may support deeper integration domain knowledge
synthesized code  expense significant amount user intervention 
interesting application multi tac approach context planning might involve
starting ucp planning shell  which configured emulate many varieties
planners   list high level heuristics guiding decision points ucp shell
 e g   refinement selection  aw selection etc   searching among configurations
pick planner given problem distribution 

   conclusion

research  investigated feasibility using automated software synthesis tools
synthesize customized domain specific planners  described clay architecture
exibly synthesizing ecient domain dependent classical planners declarative
   

fisrivastava   kambhampati

theory planning domain theory using software synthesis system  kids   using
framework  classical planner synthesized enriched domain control
knowledge  proof concept  forward state space backward state space planners
synthesized blocks world  logistics tyre world domains 
shown synthesized planners outperform general purpose planners
using amount domain specific control knowledge argueed
due ability fold in domain specific control knowledge planner code 
contrast  domain independent planners test control knowledge plan
refined  thus suffer significant application overhead 

    features limitations

synthesis approach provides several interesting contrasts main stream ai planning
work  begin with  ai planning work attempts improve eciency planning
concentrating way plans generated  work differs radically
concentrate  ecient planners  synthesized  use software synthesis techniques lends modularity planner synthesis activity  planning theory specified
declaratively rather form implemented program  supports changes
extensions planning theory  planning theory described independent
domains  control knowledge dynamical knowledge domain specified
domain  selecting different combinations planning theory control
knowledge  synthesize variety domain customized refinement planners 
despite promises  approach entail several overheads 
overheads related current state art automated software synthesis
others related current implementation clay architecture  follows 
try tease apart 
holy grail automated software synthesis approaches free users lowlevel coding  allow concentrate declarative specification  kids
system comes closest promise  still far perfect  start with  user must
reasonably familiar software synthesis process order anything substantial
kids  go steep learning curve could understand
structure theories make good use optimizations provided kids  writing
monotonic distributive laws operations help kids effective
code simplification still somewhat art  many times  go back rewrite
domain knowledge kids unsuccessful using knowledge provided it 
advances software synthesis technology may provide support automatic translation
high level control knowledge forms suitable consumption kids 
support available right now 
current cost benefit ratios would recommend using clay kids
approach customizing planner one interested customizing single planner
single domain  refine code user writes specify synthesis task typically larger one single synthesized planner generated kids  thus  manually
customizing planner domain may still appropriate  however  synthesized approaches may competitive interested able customize
variety planners variety domains 
   

fisynthesizing customized planners specifications

addition overheads entailed kids  specific implementation planning
theories  domain knowledge  etc  lead ineciencies  latter
eliminated better design clay architecture  example  make work
simple  decided go one pre existing canned design tactics provided
kids  chose global search theory finite sequences candidate tactic 
choice  found state variable representation domains suitable
implementation point view  although getting state variable representations
actions hard  we wrote couple utility routines converting actions
strips representation state variable representation   specifying control knowledge
terms representation turned less natural  especially larger domains
russel s tyre world 
choice in built design tactics limited types domain knowledge could
specify  control knowledge form node rejection rules  general
global search allows node preference knowledge well knowledge regarding effective
ways shrinking set potential solutions  without splitting set  by eliminating
non solutions  
could eliminate awkwardness state variable representations well exploit types domain knowledge designing global search tactics specially suited
planning specific data structures  although eventually kids system may support
larger variety design tactics  customizing design tactics task classes much
line current practice automated software synthesis  gomes  smith    westfold 
      

    future directions

work presented seen beginning fairly open ended research program complements  rather competes with  research ecient planning
algorithms  ideally  would support synthesis customized planners based
full gamut planning technologies including partial order task reduction planning  latter already subsumed refinement planning framework developed
 kambhampati   srivastava        supporting synthesis mainly matter
supporting exible partial plan representation kids  representing plans
sequences actions suced now  addressing synthesis
state space planners   currently process  srivastava  kambhampati    mali        
generally  time get insights internal workings family planning algorithms  would translate insights declarative specifications
kids support synthesis ecient customized domain code  example
recent research plan synthesis approaches based constraint satisfaction  fact 
domain independent planners graphplan  blum   furst        solve test
suites equal better time compared synthesized planners  taken
preliminary steps towards integrating approaches refinement planning framework using notion disjunctive refinement planning  see kambhampati   yang 
      kambhampati      b  kambhampati  parker    lambrecht        kambhampati 
   

fisrivastava   kambhampati

    a   future  work matures  intend explore synthesis planners using
theories disjunctive plan refinement 

acknowledgements

grateful doug smith help kids numerous discussions tactics 
global search distributive laws  would thank carla gomes discussing
work us making useful suggestions write theories  nort fowler
encouragement line research  thanks due steve minton
anonymous referees jair many helpful comments toward improving
presentation paper  research supported darpa planning initiative
phase   grant f         c       through subcontract kestrel arizona state
university  

appendix a  sample code referred text
   get state sequence partial plan
function visited states
 plan  seq integer   is  seq integer  
gs  seq integer  
opers  seq tuple seq integer   seq integer    
  seq seq integer  
  empty plan   is 
else
 empty next state is  first plan   opers  
prepend visited states rest plan  
next state is  first plan   opers  
gs  opers   is 
   used visited states get next state
   applying operator
function next state
 state  seq integer   oper  integer 
operators  seq tuple seq integer   seq integer    
  seq integer 
  fa  i  integer  i       size state  
   operators oper    i     
operators oper    i    state i  
image lambda x 
operators oper    x      state x 
else operators oper    x  
      size state   

   domain independent pruning test fss refinement
function no moves back  vis states  seq seq integer   
is  seq integer   gs  seq integer  
  boolean
  fa  i  integer  j  integer 
 i       size vis states  
  j       size vis states  
    j
    fa  index  integer 
 index       size first vis states   
   vis states j  index   
vis states i  index 
vis states i  index        

   

fisynthesizing customized planners specifications

function cross no moves back
 r  seq seq integer    s  seq seq integer    is  seq integer  
gs  seq integer    boolean
  fa  i  integer  j  integer 
 i       size r     j       size s  
    fa  index  integer 
 index       size first r   
   s j  index    r i  index 
r i  index        
   domain independent goal test fss refinement
function goal test
 vis states  seq seq integer    init  seq integer  
goal  seq integer    boolean
  fa  i  integer 
 i       size goal  
   goal i     
last vis states  i    goal i  

   domain dependent pruning test
   heuristic h   limit useless move blocks world
function no redundancy  s  seq seq integer   
  boolean
  fa  i  integer  index  integer 
 i       size s      
  index       size first s   
  index mod      
s i  index     s i      index 
   s i      index    s i      index  
   domain dependent pruning test
   heuristic h   move via table blocks world
function no redundancy  s  seq seq integer   
init  seq integer  
goal  seq integer  
  boolean
  fa  i  integer  index  integer 
 i       size s      
  index       size first s   
  index mod      
  s i  index     s i      index 
       position state
   initial state
s i  index    init index 

s i      index   
   position state i   table
     real to nearest integer
 size first s         

 s i  index   
   position state table
     real to nearest integer
 size first s      

   position state i  
   goal state
s i      index    goal index    

   

fisrivastava   kambhampati

references

bacchus  f     kabanza  f          using temporal logic control search forward
chaining planner  new directions ai planning  ewsp     ios press          
backstrom  c     nebel  b          complexity results sas  planning  research report 
dept comp and info sc   linkoping univ   sweden 
barrett  a     weld  d          partial order planning  evaluating possible eciency gains 
artificial intelligence         
blum  a     furst  m          fast planning planning graph analysis  proc ijcai              
burstein  m     smith  d          itas  portable  interactive transportation scheduling
tool using search engine generated formal specifications  proceedings  rd
ai planning systems conference  pp        
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  readings planning  morgan kaufmann publ   san
mateo  ca 
fink  e     veloso  m          formalizing prodigy planning algorithm  cmu cs tech
report cmu cs        
gomes  c   smith  d     westfold  s          synthesis schedulers planned shutdowns power plants  proc    th knowledge based software engg  conf   ieee
computer society press  los alamitos ca        
gomes  c  p          planning kids  technical report rl tr         rome laboratory 
kambhamapti  s          comparative analysis partial order planning htn planning 
acm sigart bulletin    
kambhampati  s       a   challenges bridging plan sythesis paradigms  proc  intl 
joint conference artificial intelligence  ijcai      morgan kaufmann 
kambhampati  s       b   refinement planning unifying framework plan synthesis 
ai magazine                
kambhampati  s   katukam  s     qu  y          failure driven dynamic search control
partial order planners  explanation based approach  artificial intelligence     
        
kambhampati  s   knoblock  c     yang  q          planning refinement search 
unified framework evaluating design tradeoffs partial order planning  artificial
intelligence               special issue planning scheduling 
kambhampati  s   parker  e     lambrecht  e          understanding extending
graphplan  proc   th european conference planning  springer verlag 
   

fisynthesizing customized planners specifications

kambhampati  s     srivastava  b          universal classical planning  algorithm
unifying state space plan space planning approaches  new directions ai
planning  ewsp     ios press        
kambhampati  s     srivastava  b          unifying classical planning approaches 
tech  rep  asu cse tr         arizona state university  available
http   rakaposhi eas asu edu yochan html 
kambhampati  s     yang  x          role utility disjunctive representation
refinement planning  proc  fifth conf  principles knowledge representation
reasoning  kr      pp          
lauriere  j  l          language program stating solving combinatorial
problems  artificial intelligence             
mcallester  d     rosenblitt  d          systematic nonlinear planning  proc   th ncai    
        
minton  s          learning effective search control knowledge  explanation based
approach  phd thesis  carnegie  mellon university  pittsburgh  pa 
minton  s          automatically configuring constraint satisfaction problems  case study 
constraints        
minton  s          quantitative results concerning utility explanation based learning 
artificial intelligence  vol      pp          
penberthy  j     weld  d          ucpop  sound  complete  partial order planner
adl  proc  aaai             
russell  s     norvig  p          artificial intelligence   modern approach  chap     
prentice hall  englewood cliffs  nj 
smith  d  r          kids  semi automatic program development system  ieee trans 
software engineering   special issue formal methods      no    sep      
smith  d  r       a   structure design global search algorithms  kestrel tech  rep 
kes u       
smith  d  r       b   transformational approach scheduling  kestrel institute tech 
rep  kes u         pp 
smith  d     parra  e          transformational approach transportation scheduling 
proceedings  th knowledge based software engineering conference  pp        
chicago  il  sept      
srivastava  b   kambhampati  s     mali  a          structured approach synthesizing
planners specifications  proc    th ieee intl  conf  automated software
engg   lake tahoe  nv 
tate  a          generating project networks  proc   th ijcai          
   

fisrivastava   kambhampati

yoshikawa  m   kaneko  k   nomura  y     watanabe  m          constraint based
approach high school timetabling problems  case study  proc  ncai          
     

   


