journal artificial intelligence research                  

submitted       published     

searching best solutions graphical models
natalia flerova

nflerova   uci   edu

university california  irvine
irvine  ca        usa

radu marinescu

radu   marinescu   ie   ibm   com

ibm research ireland

rina dechter

dechter   uci   edu

university california  irvine
irvine  ca        usa

abstract
paper focuses finding best solutions combinatorial optimization problems
using best first depth first branch bound search  specifically  present new algorithm ma   extending well known a  m best task  first time prove desirable
properties  including soundness  completeness optimal efficiency  maintained  since bestfirst algorithms require extensive memory  extend memory efficient depth first branch
bound m best task 
adapt algorithms optimization tasks graphical models  e g   weighted csp
mpe bayesian networks   provide complexity analysis empirical evaluation  experiments confirm theory best first approach largely superior memory available 
depth first branch bound robust  show algorithms competitive
related schemes recently developed m best task 

   introduction
usual aim combinatorial optimization find optimal solution  minimum maximum 
objective function  however  many applications desirable obtain single
optimal solution  set first best solutions integer m  motivated
many real life domains  task arises  instance  problem finding likely
haplotype pedigree presented finding probable assignment bayesian
network encodes genetic information  fishelson  dovgolevsky    geiger         practice data often corrupted missing  makes single optimal solution unreliable 
possible increase confidence answer finding set best solutions
choosing final solution expert help obtaining additional genetic data 
examples m best tasks arise procurement auction problems probabilistic expert systems  certain constraints often cannot directly incorporated model  either
make problem infeasibly complex vague formalize  e g  idiosyncratic
preferences human user   thus domains may practical first find several
good solutions relaxed problem pick one satisfies additional constraints
post processing manner  additionally  sometimes set diverse assignments approximately
cost required  reliable communication network design  finally  context
summation problem graphical models  probability evidence partition function 
approximation derived summing likely tuples 
c
    
ai access foundation  rights reserved 

fif lerova   arinescu     echter

problem finding best solutions well studied  one earliest
influential works belongs lawler         provided general scheme extends
optimization algorithm m best task  idea compute next best solution successively
finding single optimal solution slightly different reformulation original problem
excludes solutions generated far  approach extended improved
years still one primary strategies finding best solutions  approaches
direct  trying avoid repeated computation inherent lawlers scheme  two earlier
works relevant provide highest challenge work nilsson       
aljazzar leue        
nilsson proposed junction tree based message passing scheme iteratively finds
best solutions  claimed best runtime complexity among m best schemes
graphical models  analysis  section    shows indeed nilssons scheme second
best worst case time complexity algorithm be m bf  section       however 
practice scheme feasible problems large induced width 
recent work aljazzar leue proposed algorithm called k   a  search style
scheme finding k shortest paths interleaved breadth first search  used
specialized data structure unclear approach straightforwardly extended
graphical models  point leave future work 
one popular approximate approaches solving optimization problems based
lp relaxation problem  wainwright   jordan         m best extension approach
 fromer   globerson        guarantee exact solutions  quite efficient practice 
discuss previous works section   
main focus lies optimization context graphical models  bayesian networks  markov networks constraint networks  however  algorithms developed
used general purpose tasks  finding shortest paths graph  various
graph exploiting algorithms solving optimization tasks graphical models developed
past decades  algorithms often characterized either inference type
 e g   message passing schemes  variable elimination  search type  e g   and or search
recursive conditioning   earlier works   e g   flerova  dechter    rollon         extended
inference schemes represented bucket elimination algorithm  be   dechter             
task finding best solutions  however  due large memory requirements  variable
elimination algorithms  including bucket elimination  cannot used practice finding exact
solutions combinatorial optimization tasks problems graph dense  depth first branch
bound  dfbnb  best first search  bfs  flexible trade space time 
work explores question solving best solutions task using heuristic search schemes 
contribution lies extending heuristic algorithms best solutions task  describe general purpose m best variants depth first branch bound best first search 
specifically a   yielding algorithms m bb m a  respectively  analyze properties  show m a  inherits a s desirable properties  dechter   pearl        
significantly optimally efficient compared alternative exact search based scheme 
discuss size search space explored m bb  extend new m best algorithms graphical models exploring and or search space 
evaluate resulting algorithms   benchmarks     instances total 
examine impact number solutions algorithms behaviour  particular 
   

fis earching b est olutions g raphical odels

observe runtime schemes  except depth first branch bound
exploring and or tree  scales much better worst case theoretical analysis
suggests 
show m a  search using exact bucket elimination heuristic  a scheme
call be m bf  highly efficient easier problems suffers severely memory issues
denser graphs  far a  based schemes using approximate mini bucket heuristics  finally  compare schemes efficient algorithms based
lp relaxation  fromer   globerson        batra         showing competitiveness even superiority large values  m      providing optimality guarantees 
paper organized follows  section   provide relevant background  section  
presents extension best first search m best task  particular  define m a  
extension a  algorithm finding best solutions        prove main properties       
section   describes algorithm m bb  extension depth first branch bound algorithm
solving m best task  section   discuss adaptation two newly proposed m best
search algorithms and or search spaces graphical models  including hybrid method
be m bf incorporates variable elimination heuristic search  section   elaborates
related work contrasts methods  section   presents empirical evaluation
m best schemes section   concludes 

   background
begin formally defining graphical models framework providing background
heuristic search 
    graphical models
denote variables upper case letters  e g   x  y  z  values variables lower case
letters  e g   x  y  z   sets variables denoted upper case letters bold  e g  x  y  z  
assignment  x    x            xn   xn   abbreviated x    x            xn   
denote functions letters f  g  h etc   set functions bypf  function f
scope s     x            xr   denoted fs    p
summation
p operator xx defines sum
possible values variables x  namely x  x            xn xn   minimization minxx
maximization maxxx operators defined similar manner  note use terms elimination
p
marginalization interchangeably 
convenience sometimes use minx  maxx   x  
p
denote minxx  maxxx   xx   
graphical model collection local functions subsets variables conveys probabilistic  deterministic  preferential information  whose structure described graph 
graph captures independencies irrelevance information inherent model  useful
interpreting modeled data and  significantly  exploited reasoning algorithms 
set local functions combined variety ways generate global function  whose
scope set variables 
n
efinition    graphical model   graphical model   tuple   hx  d  f  i 
   x    x            xn   finite set variables 

      d            dn   set respective finite domains values 
   

fif lerova   arinescu     echter

   f    f            fr   set non negative real valued discrete functions  defined scopes
variables si x  called local functions 
n
n
q p
  
combination operator  e g  
       product  sum 
graphical model represents
global function  whose scope x combination
n
local functions  rj   fj  
n
p
n
  qand   dsi n weighted constraint satisfaction problems  wcsps  
 
  pi  xi   pai   bayesian network  probabilities p
defined relative directed acyclic graph g x  set xi            xik parents
pai xi   i e  xij edge pointing xij xi   illustration  consider
bayesian network   variables whose directed acyclic graph  dag  given figure   a  
common optimization task bayesian network probable explanation
 mpe  known maximum posteriori hypothesis  map    goal compute
optimal value
r


c   max
fj  xsj  
x

j  

optimizing configuration


x   argmax
x

r


fj  xsj  

j  

related task  typical wcsp 
min sum  namely computing minimal cost
p
p assignment  min sum   c   minx j fj  x  optimizing configuration x   argminx j fj  x  
historically task sometimes referred energy q
minimization  equivalent

mpe map task following sense  cmax
  maxx j fj  x  solution mpe




problem 
p cmax   exp  cmin    cmin solution min sum problem cmin  
minx j gj  x  j  gj  x    log  fj  x   
graphical model defines primal graph captures dependencies problems
variables  variables vertices  edge connects two vertices whose variables appear
scope function  important property graphical model  characterizing
complexity reasoning tasks induced width  ordered graph pair  g  o 
g undirected graph     x            xn   ordering nodes  width node
number nodes neighbors precede ordering  width graph along
ordering maximum width nodes  induced ordered graph obtained
ordered graph follows  nodes processed last first based o  node xj
processed  preceding neighbors connected  width ordered induced graph along
ordering called induced width along denoted w  o   induced width
graph  denoted w   minimal induced width orderings  abusing notation
sometimes use w denote induced width along particular ordering  meaning
clear context 
figure   b  depicts primal graph bayesian network figure   a   figures   c 
  d  show induced graphs primal graph figure   a  respectively along orderings
   communities map refers task optimizing partial assignment variables  however 
paper use map mpe interchangeable  referring optimal full variable assignment 

   

fis earching b est olutions g raphical odels

p  a 





b

e

c





c

e

b





 c 

 d 

p  b a 

b

c

b

c

p  c a 

e

e

p  e b  c 





p  d a  b 

 a 

 b 

figure     a  dag bayesian network   b  primal graph  also called moral graph  
 c  induced graph along    a  e  d  c  b    d  induced graph along
   a  b  c  d  e   example gogate        

   a  e  d  c  b  o     a  b  c  d  e   dashed lines figure   c  represent
induced edges  namely edges absent moral graph  introduced
induced graph  see induced width along ordering w  o      induced
width along ordering o  w  o         respectively 
    heuristic search
analysis focuses best first search  bfs   whose behaviour task finding single
optimal solution well understood  assuming minimization task  best first search always expands
node best  i e   smallest  value heuristic evaluation function  maintains graph
explored paths  list closed expanded nodes frontier open nodes  bfs chooses
open node n smallest value heuristic evaluation function f  n   expands
generating successors succ n   places closed  places succ n  open 
popular variant best first search  a   uses heuristic evaluation function f  n    g n    h n  
g n  cost path root n  h n  heuristic function estimates
optimal cost go h  n  n goal node  heuristic function called admissible
never overestimates  for minimization  true minimal cost reach goal h  n   namely 
n h n  h  n   heuristic called consistent monotonic  every node n every
successor n  n following inequality holds  h n  c n  n      h n     h n  consistent 
values evaluation function f  n  along path non decreasing  known
regardless tie breaking rule a  expands node n reachable strictly c  bounded path
root  node referred surely expanded a   dechter   pearl        
path c  bounded relative f   n   f  n    c   c cost optimal
solution 
a  search number attractive properties  nillson        pearl        dechter   pearl 
      
   

fif lerova   arinescu     echter

soundness completeness  a  terminates optimal solution 
h consistent  a  explores set nodes    n f  n  c   surely
expands nodes    n f  n    c   
optimal efficiency consistent heuristic  h consistent  node surely expanded a  must expanded sound complete search algorithm using
heuristic information 
optimal efficiency node expansions  heuristic function consistent  a  
searching graph  expands node once  time nodes expansion
a  found shortest path it 
dominance  given two heuristic functions h  h    s t  n h   n    h   n   a  expand
every node surely expanded a    ai uses heuristic hi  
although best first search known best algorithm terms number nodes expanded  dechter   pearl         requires exponential memory worst case 
popular alternative depth first branch bound  dfbnb   whose attractive feature  compared best first search  executed linear memory  yet 
search space graph  exploit memory improve performance flexibly trading space
time  depth first branch bound expands nodes depth first manner  maintaining cost
best solution found far upper bound u b cost optimal solution 
heuristic evaluation function current node n greater equal upper bound 
node pruned subtree never explored  worst case depth first branch
bound explores entire search space  best case first solution found optimal 
case performance good bfs  however  solution depth unbound  depth first
search might follow infinite branch never terminate  also  search space graph 
dfbnb may expand nodes numerous time  unless uses caching checks duplicates 
    search graphical models
search algorithms provide way systematically enumerate possible assignments given
graphical model  optimization problems graphical models naturally presented
task finding optimal cost path appropriate search space 
simplest variant search space so called search tree  level corresponds
variable original problem  nodes correspond partial variable assignments
arc weights derived problems input functions  size search tree bounded
o k n    n number variables k maximum domain size 
throughout section going illustrate concepts using example problem
six variables  a  b  c  d  e  f   six pairwise functions  primal graph shown figure
  a   figure   b  displays search tree corresponding lexicographical ordering 
      and or earch paces
search trees blind problem decomposition encoded graphical models therefore inefficient  exploit independencies model  and or search spaces
   

fis earching b est olutions g raphical odels

 a  primal
graph

 b  search tree along ordering a  b  c  d  e  f

figure    example problem   variables  a  b  c  d  e  f     pairwise functions 
graphical models introduced better capture problem structure  dechter   mateescu         and or search space defined relative pseudo tree primal graph
captures problem decomposition  figure   a  shows pseudo tree example problem 
efinition    pseudo tree undirected graph g    v  e  directed rooted tree  
 v  e      every arc g included e   back arc   namely connects node
ancestor   arcs e   may included e 
given graphical model   hx  d  primal graph g pseudo tree g 
and or search tree st contains alternating levels nodes  structure based
underlying pseudo tree   root node st node labelled variable
root   children node xi nodes labelled value assignments hxi   xi
 or simply hxi i   children node hxi   xi nodes labelled children
xi   representing conditionally independent subproblems  and or tree corresponding
pseudo tree figure   a  shown figure   b   arcs nodes xi hxi   xi
and or search tree annotated weights derived cost functions f 
efinition    arc weight   weight w xi   xi   arc  xi   hxi   xi i  combination  i e 
sum wcsp product mpe  functions  whose scope includes xi fully
assigned along path root node corresponding hxi   xi i  evaluated values
along path 
identical subproblems identified context  namely  partial instantiation
ancestors separates subproblem rest problem graph   merged 
yielding and or search graph  dechter   mateescu         merging context mergeable
nodes yields context minimal and or search graph  denoted ct   example seen
figure   c   size context minimal and or search graph shown exponential
induced width g along pseudo tree  dechter   mateescu        
solution tree ct subtree that      contains root node ct      
internal node n   children       internal node n  
exactly one children       every tip node  i e   nodes children 
terminal node  cost solution tree product  mpe sum wcsp  weights
associated arcs 
node n ct associated value v n  capturing optimal solution cost
conditioned subproblem rooted n  assuming mpe map problem  shown v n 
   

fif lerova   arinescu     echter






 

 



b

b



 

 

 

 



c



b
c

e



f



 



c

e
 

 

 



f

f

 

               

e

c

 

 

 



f

f

 

               

 a  pseudo tree

 

 

 



f

f

 

e
 

 

 



f

f

               

               

 b  and or search tree






 

 



b

b



 

 

c

c




c

e

 

 

 

 

c

c
 

 

 

 

 

e
 

 

e
 

 

e

e
 

 

 

 

 











f

f

f

f



   

   

   

   

   

   

   

   

 c  context minimal and or search graph

figure    and or search spaces graphical models 

computed recursively based values ns successors  nodes maximization 
nodes multiplication  wcsps  v n  nodes updated minimization
summation  respectively  dechter   mateescu        
next provide overview depth first branch bound best first search algorithms 
explore and or search spaces  marinescu   dechter      b      a  otten   dechter        
schemes use heuristics generated either mini bucket elimination scheme        
soft arc consistency schemes  marinescu   dechter      a      b  schiex        darwiche  dechter  choi  gogate    otten        composite  ihler  flerova  dechter    otten 
       customary heuristic search literature  defining search algorithms
assume without loss generality minimization task  i e   min sum optimization problem  
   

fis earching b est olutions g raphical odels

algorithm    aobf exploring and or search tree  marinescu   dechter      b 

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  

input  graphical model   hx  d  fi  pseudo tree rooted x    heuristic function h  
output  optimal solution
create root node labelled x  let g  explored search space     s  
initialize v s    h s  best partial solution tree g 
solved
select non terminal tip node n   node break 
n node labeled xi
forall xi d xi  
create child n    hxi   xi i 
n terminal
mark n  solved 
succ n  succ n  n   
else n node labeled hxi   xi
forall successor xj xi
create child n    xj  
succ n  succ n  n   
initialize v n      h n    new nodes 
add new nodes explores search space g g  succ n   
let  n  
  
let p node descendants g still s 
 p  
p node
v p    minksucc p   w p  k    v k   
mark best successor k ancestors p  k   arg minksucc p   w p  k    v k  
 maintaining previously marked successor still best  
mark p solved best marked successor solved 
else p
p node
v p    ksucc p  v k  
mark arcs successors 
mark p solved children solved 
p changes value p marked solved
add parents p p one successors marked arc 
recompute following marked arcs root s 
return hv s   i 

      b est f irst and or earch
state of the art version best first search and or search spaces graphical models
best first and or search algorithm  aobf   marinescu   dechter      b   aobf
variant ao   nillson        explores context minimal and or search graph 
aobf described algorithm    simplicity  present algorithm traversing
and or search tree  aobf maintains explicated part search space g keeps
track current best partial solution tree   interleaves iteratively top down node expansion
step  lines        selects non terminal tip node generates children g 
bottom up cost revision step  lines         updates values internal nodes based
childrens values  newly generated child node terminal marked solved  line    
   

fif lerova   arinescu     echter

bottom up phase  nodes least one solved child nodes
children solved marked solved  algorithm marks arc best
child node minimum achieved  line      following backward
step  new best partial solution tree recomputed  line      aobf terminates root
node marked solved  heuristic used admissible  point termination
optimal solution cost v s   root node search space 
extending algorithm explore context minimal and or search graph straightforward done follows  expanding non terminal node lines        aobf
generate corresponding children already present explicated search
space g rather links them  identical nodes g easily recognized based
contexts  marinescu   dechter      b  
heorem    complexity  marinescu   dechter      b   algorithm aobf traversing context
minimal and or graph time space complexity o n k w    n number
variable problem  w induced width pseudo tree k bounds domain size 
      epth  f irst and or b ranch b ound
depth first and or branch bound  aobb   marinescu   dechter      a  algorithm
traverses and or search space depth first rather best first manner  keeping
track current upper bound minimal solution cost 
simplicity  present variant algorithm explores and or
search tree  aobb described algorithm   interleaves forward node expansion  lines      
backward cost revision  or propagation  step  lines        updates node values  capturing
current best solution subproblem rooted node   search terminates
optimal solution found  node n pruned  lines        current upper bound
higher nodes heuristic lower bound  computed recursively using procedure described
algorithm   

worst case  aobb explores entire search space  namely o n k w   nodes  assuming
context minimal and or search graph   practice  however  aobb likely expand
nodes aobf using heuristic  empirical performance aobb depends heavily
order solutions encountered  namely quickly algorithm finds
close optimal solution use upper bound pruning 
      ini  b ucket h euristics
and or search algorithms presented  aobf aobb  often use mini bucket
 also known mbe  heuristic h n   mini bucket elimination mbe  dechter   rish       
approximate version exact variable elimination algorithm called bucket elimination  be 
 dechter         mbe  algorithm    bounds space time complexity full bucket elimination  which exponential induced width w    given variable ordering  algorithm
associates variable xi bucket contains functions defined variable 
higher index variables  large buckets partitioned smaller subsets  called minibuckets  containing distinct variables  parameter called i bound 
algorithm processes buckets last first  lines      algorithm     mini buckets
variable processed separately  assuming min sum problem  mbe calculates sum
   

fis earching b est olutions g raphical odels

algorithm    aobb exploring and or search tree  marinescu   dechter      b 

 
 
 
 
 
 
 
 
 
  
  

  
  

input  graphical model   hx  d  fi  pseudo tree rooted x    heuristic function h   
output  optimal solution
create root node labelled x  let stack created expanded nodes op en  s  
initialize v s  best partial solution tree rooted  s    u b  
op en   
select top node n open 
n node labeled xi
foreach xi d xi  
add child n  labeled hxi   xi list successors n 
initialize v n         best partial solution tree rooted n  n       
n node labelled hxi   xi
foreach ancestor k n
recursively evaluate cost partial solution tree rooted k  based heuristic function
h    assign cost f  k      see algorithm  
evaluated partial solution better current upper bound k  e g  f  k  v k 
prune subtree current tip node n 
else

  

foreach successor xj xi
add child n  labeled xj list successors n 
initialize v n      best partial solution tree rooted n   n     

  
  
  

  
  
  
  
  
  
  
  
  
  

  
  

add successors n top open 
list successors node n empty
node n root node
return solution  v n    n   
else
p node
v p  v p    v n    p   p   n  
else p node
new value better old one  e g  v p     c p  n    v n   minimization
v p  w p  n    v n    p   p  hxi   xi i 
remove n list successors p 
move one level up  n p 

functions mini bucket eliminates variable using min operator  line    
new function placed appropriate lower bucket  line      mbe generates bound  lower
minimization upper maximization  optimal value  higher values take computational resources  yield accurate bounds  large enough  i e   w    mbe
coincides full bucket elimination 
heorem    complexity  dechter   rish         given graphical model variable ordering
induced width w  o  i bound parameter i  time mini bucket algorithm


mbe i  o nk min i w  o       space complexity o nk min i w  o      n number
problem variables k maximum domains size 
mini bucket elimination viewed message passing leaves root along minibucket tree  mini bucket tree graphical model mini buckets nodes  bucketx
   

fif lerova   arinescu     echter

algorithm    recursive computation heuristic evaluation function
 

 
 
 

function evalpartialsolutiontree t  n   h n  
input  partial solution subtree  n  rooted node n  heuristic function h n  
output  heuristic evaluation function f  t  n   
succ n    
n node
return   
else

 

return h n  

 
 
 
 
  
  
  
  

else
n node
let k            kl children n 
p
return li   evalpartialsolutiontree t  ki    h ki    
else n node
let k child n 
return w n  k    evalpartialsolutiontree t  k   h k   

algorithm    mini bucket elimination

 

 
 
 
 
 
 
 
 
  

  

  

input  model   hx  d  fi  ordering o  parameter
output  approximate solution m  ordered augmented buckets
initialize  partition functions f bucket            bucketn   bucketi contains functions
whose highest variable xi  
   backward pass
p n downto  
let h            hj functions  original intermediate  bucketp   let s            sj scopes 
xp instantiated  xp   xp  
assign xp   xp hi put resulting function appropriate bucket 
else
generate i partitioning 
foreach qk q 
p
generate message function hkb   hkb   minxp xp ji   hi  
add hkb bucket xb   largest index variable scope hkb   
   forward pass
assign value variable ordering combination functions bucket
minimal 
return function computed bucket first variable corresponding assignment 

child buckety function hxy generated bucketx variable x eliminated 
placed buckety   therefore  every vertex root one parent possibly
several child vertices  note mini bucket tree corresponds pseudo tree  minibuckets variables combined form call augmented buckets  corresponding
variable nodes  dechter   mateescu        
mini bucket elimination often used generate heuristics search algorithms graphical
models  formulated search spaces kask dechter      a      b  extended
and or search marinescu dechter        
   

fis earching b est olutions g raphical odels

efinition    mbe heuristic and or search space  marinescu   dechter         given
ordered set augmented buckets  b x             b xn    generated mini bucket algorithm
be i  along bucket tree   given node n and or search tree  static minibucket heuristic function h n  computed follows 
   n node  labeled hxp   xp i  then 
x
h n   
hkj
hkj  b xp  b xp     xpq   

namely  sum intermediate functions hkj satisfy following two properties 
generated buckets b xk    xk descendant xp bucket tree
reside bucket b xp   bucket b xp        xpq      b xp             b xpq    correspond ancestors  xp             xpq   xp
   n node  labeled xp   then 
h n   

min

msucc p 

 w n  m    h m  

children n labeled values xp xp  
established necessary background  turn main part paper 
presenting contributions  beginning extension best first search m best task 
customary heuristic search literature without loss generality  assume
remaining paper min sum optimization problem 

   best first search finding best solutions
extending best first search  section      particular popular version  a   mbest task fairly straightforward suggested  example  charniak shimony        
instead stopping finding optimal solution  algorithm continues exploring search
space  reporting next discovered solutions obtained  show
solutions indeed best found decreasing order optimality 
particular  second solution reported second best solution and  general  ith solution
discovered ith best 
    m a   definition
m best tree search variant a  denoted m a   algorithm    assumes consistent heuristic 
solves m best optimization problem general search graph  show later
extended general admissible heuristics 
scheme expands nodes order increasing value f usual a  manner 
keeps lists created nodes open expanded nodes closed  usual  maintaining
search tree  denoted r  beginning start node s  m a  picks node smallest
evaluation function f  n  open puts closed  line     node goal  new
solution reported  lines        otherwise  node expanded children created  lines
        algorithm may encounter node multiple times maintain
   

fif lerova   arinescu     echter

algorithm    m a  exploring graph  assuming consistent heuristic

 
 
 
 
 
 
 

 
 

  
  

input  implicit directed search graph g    n  e   start node set goal nodes goals 
consistent heuristic evaluation function h n   parameter
output  best solutions
initialize  open   closed   tree r          i counts current solution searched for 
open  s   f  s    h s  
make root r 

open empty
return solutions found far 
remove node  denoted n  open minimum f  break ties arbitrarily  favour goal nodes
deeper nodes  put closed 
n goal node
output current solution obtained tracing back pointers n  pointers assigned step
     denote solution soli  
 
return 
else

  

    

  
  
  
  
  
  
  
  
  
  
  

  

else
expand node n  generating children ch  
foreach n  ch
n  already appears open closed times
discard node n   
else
compute current path cost g n      g n    c n  n    
compute evaluation function f  n      g n      h n     
attach pointer n  back n r 
insert n  right place open based f  n    
return set best solutions found

copies open closed lists combined  line      separate paths copy
explored search tree  lines         nodes encountered beyond times discarded  line     
denote ci ith best solution cost   n  cost ith best solution going node
n   n  heuristic evaluation function estimating  n  gi  n  hi  n  estimates
ith best costs n n goal  respectively 
heuristic consistent  whenever algorithm reaches node seen  if
search space graph tree   exists possibility new path improving
previously discovered ones  therefore  lines       revised following way
account possibility better path n  discovered 
  
n  appears already times union open closed
  
g n    strictly smaller gm  n     current m best path n 
  
keep n  pointer n put n back open
  
discard earlier subtree rooted n
figure   shows example m a  finding     shortest paths toy problem 
left hand side figure   shows problem graph   variables   edges  together
   

fis earching b est olutions g raphical odels


 

h a     

 

h b     



order
nodes expanded

  

h c     

b

  

c

b f   

h d     

c 
c 

 

 

  



d 

 

  

m  
c     

c f   

    
    

  
d  f    

f   

 
h f      

h e     

e

f
 

    f       
e 
f  f    

 
g

h g     

g 
f     

   
g 

   f       
f 

f     e 

   
g 

f     

f     

  
g 
f   

nodes closed

 a  problem graph

 b  trace m a 

figure    example problem  left  problem graph heuristic values h n  node 
right  trace m a  finding     best solutions evaluation function f  n 
node  white nodes closed  grey one created  discarded 

admissible heuristic functions node  note heuristic consistent  example 
h a    h c    c a  c   start node  g goal node  right side figure
present trace m a   evaluation function copy nodes created
time  rd solution found  white nodes closed  grey one  node g   
created  never put open  algorithm expands nodes open increasing order
evaluation functions  assume ties broken favour deeper nodes  first  m a 
discovers solution c f g cost c       next solution c e g
cost c       found  third solutions b f g cost c        note
two copies node d  e f four copies g created  goal node g 
discarded  bound total number copies particular node     
n
heorem    given graphical model   hx  d  f  n variables whose domain size
bounded k  worst case time space complexity m a  exploring search tree
o k n   
proof  worst case m a  would explore entire search tree  whose size o k n    section       since underlying search space tree  algorithm never encounter
nodes once  thus nodes duplicated 
   

fif lerova   arinescu     echter

    properties m a 
section extend desirable properties a   listed section      m best case 
simplicity without loss generality  assume throughout search graph accommodates
least distinct solutions 
heorem    given optimization task  implicit directed search graph g integer
parameter    m a  guided admissible heuristic following properties 
   soundness completeness  m a  terminates best solutions generated order
costs 
   optimal efficiency consistent heuristic  node surely expanded  m a 
must expanded search algorithm traversing g guaranteed find
best solutions heuristic information 
   optimal efficiency node expansions  m a  expands node times
heuristic consistent  ith path found node ith best path 
   dominance  given two heuristic functions h  h    every n h   n    h   n  
m a   expand every node surely expanded m a     m a i using heuristic hi  
prove properties m a  sections             
      oundness c ompleteness
algorithm m a  maintains copies node discards rest  next show
restriction compromise completeness 
p roposition    node discarded m a  lead m best solutions 
proof  consider consistent heuristic first  as described algorithm     moment
m a  discovered node n  m     th time  copies n reside open closed
algorithm maintains distinct paths each  let  m     th path 
prove theorem     node n discovered  m     th time  cost cnew newly
discovered path new  m     th best  namely better costs already discovered 
cnew cm   therefore  eliminated  m     th path node n guaranteed worse
remaining ones thus part potential m best optimal solutions
might passing node n 
heuristic consistent  m a  modified replace worst previously
discovered paths newly found new   cost latter better place new
copy open  thus  again  safe bound number copies m 
clear along particular solution path evaluation function nodes
bounded paths cost c    heuristic admissible 
p roposition    following true regarding m a  
   solution path   forall n   f  n  c   
   precisely defined section      

   

fis earching b est olutions g raphical odels

   unless already discovered m a   always node n resides
open 
   therefore  long m a  discover must node open f  n 
c   
proof     f  n    g  n    h n  since h n  c  n  t  due admissibility  c  n  t 
actual cost n goal node along   conclude f  n  g  n    h n    c   
   reachable path root always leaf open unless nodes along path
expanded closed 
   follows easily     
follows immediately proposition    stated similarly nilsson        that 
p roposition     necessary condition node expansion  node n expanded m a 
searching ith best solution    m  satisfies f  n  ci  
clear
p roposition     sufficient condition node expansion  every node n open 
f  n    ci   must expanded m a  ith best solution found 
soundness completeness m a  follows quite immediately 
heorem    soundness completeness   algorithm m a  generates m best solutions
order  namely  ith solution generated ith best solution 
proof  let us assume contradiction case  let ith generated solution path
first one generated according best first order  namely ith solution
generated cost c c   ci   however  algorithm selected goal ti along
  evaluation function f  ti     gi  ti     c  while  based proposition   
node n  open whose evaluation function ci   thus n  selected
expansion instead ti   contradiction therefore result follows 
      mpact h euristic trength
a   performance m a  improves accurate heuristic 
p roposition    consider two heuristic functions h  h    let us denote m a   algorithm uses heuristic h  m a   one using heuristic h    heuristic h 
informed h    namely every node n  h   n    h   n   algorithm m a   expand
every node expanded algorithm m a   finding j th solution
j                m   assuming tie breaking rule 
proof  since h  informed h    h   n    h   n  every non goal node n  let us
assume m a   expands non terminal node n finding j th best solution
cost cj   node n expanded  means  a  point open  b  evaluation
function satisfies f   n    g n    h   n  cj  proposition     consider current path
start node n  node n  path selected point expansion thus
   

fif lerova   arinescu     echter

m a search space

search space
c  cm
algorithm
ci


 cm
c   

search space
explored m a
compared

figure    schematic representation search spaces explored m a  algorithm  de
pending cost cm

evaluation functions nodes bounded cost j th best solution 
f   n    cj   since h   n      h   n    every node n  along path   evaluation functions
according heuristic h   n  obey 
f   n      g n      h   n      g n      h   n      cj

   

thus node n  must expanded m a    
consider case exact heuristic  easy show that 
heorem    h   h exact heuristic  m a  generates solutions j optimal
paths   j m 
proof  since h exact  f values open expanded sequence values c  c 
  generated nodes evaluation function f   c definition
      ci       cm
 
optimal paths  since h   h    f   c  must paths second
best on  notice solutions costs 
h   h   m a s complexity clearly linear number nodes evaluation
  however  cost function small range values  may
function f cm
  avoid exponential frontier
exponential number solution paths cost cm
chose tie breaking rule expanding deeper nodes first  yielding number node expansions
bounded n  n bounds solution length  clearly 

heorem    m a  access
favour deeper
p h   h   then  using tie breaking rule
th
nodes  expands  n    ni nodes   ni length optimal solution
path  clearly   n n 

   

fis earching b est olutions g raphical odels

figure    graph g  represents new problem instance constructed appending branch leading new goal node node n 

       a  c onsistent h euristic
m a  uses consistent heuristic  several useful properties 
optimal efficiency consistent heuristic  algorithm a  known optimally efficient
consistent heuristic  dechter   pearl         namely  algorithm extends search
paths root uses heuristic information a  expand every node
surely expanded a   i e   expand every n  f  n    c   extend notion
nodes surely expanded a  m best case 
 bounded
p roposition    algorithm m a  expand node n reachable strictly cm
path root  regardless tie breaking rule  set nodes referred surely
expanded m a  
 bounded path    s  n   n         n   start node
proof  let us consider strictly cm
   
clearly expanded beginning search children  including node n    placed
  node n must expanded m a  finding mth best
open  since f  n      cm
 
solution  proposition     children  including n    turn placed open  true
nodes   including n 

heorem    m optimal efficiency   search algorithm  guaranteed find m best
solutions explores search space m a  consistent heuristic 
expand node surely expanded m a   namely expand every node
  i e  f  n      c   n   
lies path dominated cm

proof idea similar work dechter pearl         namely show
algorithm expand node n  surely expanded m a   miss one m best
solutions  applied slightly modified problem 
proof  let us consider problem search graph g consistent heuristic h  assume
node n surely expanded m a  finding j th best solution  let b algorithm
uses heuristic h guaranteed find best solutions  let assume
node n expanded b  consistency heuristic allows us better characterize
nodes expanded m a  
create new problem graph g   see figure    adding new goal node
h t       connecting n edge cost c   h n            cj d 
   

fif lerova   arinescu     echter

  maxn  sj f  n     sj set nodes surely expanded m a  finding
j th solution  possible show heuristic h admissible graph g   dechter  
pearl         since       cj d   c      construction  evaluation function
new goal node is 

f  t    g t    h t    g n    c   g n    h n      f  n        cj   cj

   

means reachable path whose cost strictly bounded cj  
guarantees m a  expand  proposition     discovering solution cost cj  
hand  algorithm b  expand node n original problem  still expand
thus reach node discover solution cost cj   returning true
set best solutions modified problem  contradiction theorem follows 
p roposition    heuristic function employed m a  consistent  values evaluation function f sequence expanded nodes non decreasing 
proof straightforward extension result nilsson        
proof  let node n  expanded immediately n    n  already open time
n  expanded  node selection rule follows f  n    f  n     n 
open  must added result expansion n    i e   child n   
case cost getting n  start node g n      g n      c n    n   
evaluation function node n  f  n      g n      h n      g n      c n    n      h n     since h n 
consistent  h n    c n    n    h n    f  n    g n    h n     namely  f  n    f  n    
heuristic function consistent  stronger condition proposition   
heorem    algorithm m a  using consistent heuristic function 
 
   expands nodes n f  n    cm
 
   never expands nodes evaluation function f  n    cm

   expands nodes f  n    cm   subject tie breaking rule 
node n never expanded
proof     assume exists node n f  n    cm
m a   situation arise node n never open list  otherwise would
expanded  according proposition    implies parent node n search
space  let us denote node p  never expanded  however  similarly done
  thus
proof proposition    easy show f  p  f  n  and  consequently f  p    cm
node p must never open  otherwise would expanded  clearly  true
ancestors n  start node s  since node clearly open beginning
search  initial assumption incorrect property follows 
      follow directly proposition   

figure   provides schematic summary search space explored m a  consistent heuristic 
   

fis earching b est olutions g raphical odels


 n f n    cm
 

search space
explored m a

 

 

 n f  n    cm
 


 n f  n    cm
 

figure    nodes explored m a  algorithm consistent heuristic 
optimal efficiency node expansions  whenever node n selected expansion
first time m a   algorithm already found shortest path node  extend
property follows 
heorem     given consistent heuristic h  m a  selects node n expansion
ith time  g n    gi  n   namely found ith best path start node n 
proof  induction       basic step  theorem holds  nillson         assume
holds  i   th expansion node n  let us consider ith case       inductive step  
already expanded node n  i    times due inductive hypothesis already
found  i    distinct best paths node n  let us assume cost newly found
solution path greater ith optimal one  i e  gi  n    gi  n   then  exists different 
undiscovered path n cost g  n    gi  n    gi  n   proposition   exists
open node n    obviously  node n  must located start node node
n  denoting c  n    n    c n    n        c nk   n   heuristic consistency easily
follows h n      c  n    n    h n  evaluation function node n  along path
f  n      g  n      h n      g  n      c  n    n    h n   seeing cost path
n g  n    g  n      c   conclude f  n      f  n   however  contradicts
assumption node n expanded ith time node n    theorem follows 
      mpact r equired b est olutions
sequence sizes search spaces explored m a  function obviously monotonically increasing m  denoting j a  i a  versions m a  algorithm
search respectively j best solutions  make following straightforward characterization 
p roposition    given search graph consistent heuristic 
   node expanded i a  expanded j a    j use tie breaking
rule 
   

fif lerova   arinescu     echter

   set s i  j  nodes defined s i  j     n ci   f  n    cj   surely expanded
j a  surely expanded i a  
   cj   ci   difference number nodes expanded i a  j a  determined
tie breaking rule 
proof follows trivially theorem    result  larger discrepancy respective costs cj ci yields larger difference search spaces explored j a  i a  
difference  however  depends granularity values sequence
observed evaluation functions increase  related arc costs  or weights  search
graph  ci   cj   c  search space explored i a  j a  differ
frontier nodes satisfying f  n    c  figure   represents schematically search spaces explored
i a  algorithm 

   depth first branch bound finding best solutions
along valuable properties  m a  inherits disadvantages a   exponential space
complexity  makes algorithm infeasible many applications  alternative approach
searching using depth first branch bound  dfbnb   implemented linear
space necessary therefore often practical  dfbnb finds optimal solution
exploring search space depth first manner  algorithm maintains cost u best
solution encountered far prunes search nodes whose lower bounding evaluation function
f  n    g n    h n  larger u   extending dfbnb m best task straightforward 
describe next 
    m bb algorithm
algorithm m bb  depth first branch bound extension m best task  explores
search tree presented algorithm    usual  algorithm maintains lists open
closed nodes  maintains sorted list candidate nodes contains best
solutions found far  nodes open organized last   first manner order
facilitate depth first exploration search space  i e   open stack   step  m bb
expands next node n open  line     goal node  new complete solution found
 line    stored candidate list  line       re sorted  line     
best solutions maintained  lines        
main modification depth first branch bound  extended m best task 
pruning condition  let u  u        um denote costs best solutions
encountered thus far  um upper bound used pruning  solutions discovered  pruning takes place  algorithm m bb expands current node n  generates children
 lines        computes evaluation function  line         prunes subproblem n
iff f  n  um  lines         easy see algorithm terminates  outputs
m best solutions problem 
heorem     algorithm m bb sound complete m best solutions task 
proof  algorithm m bb explores search space systematically  solutions
  c
skipped ones satisfying f  n  um  see step      since um cm

   

fis earching b est olutions g raphical odels

algorithm    m bb exploring graph  assuming consistent heuristic

 

 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  

input  implicit directed search graph g    n  e  start node n  set goal nodes goals 
heuristic function h n   parameter  the number desired solutions  
output  best solutions
initialize  open   closed   tree r     sorted list candidate     upperbound          i
counts current solution searched for  
put start node n  open  g n         f  n      h n    
assign n  root r 
open empty
remove top node open  denoted n  put closed 
n goal node
soli solution obtained tracing back pointers n n   pointers assigned step     
ci cost soli  
place solution soli candidate 
sort candidate increasing order solution costs 
size candidate list
um cost mth element candidate 
keep first elements candidate  discard rest 
else
expand node n  generating children succ n  
forall n  succ n 
attach pointer n  back n r 
g n      g n    c n  n    
f  n      g n      h n    
f  n      um
place n  open 
else
discard n   
return solutions candidate list

therefore path cannot lead newly discovered
best solution cost  implies f  n  cm
m best cost 

n
heorem     given graphical model   hx  d  f  i  worst case time complexity
m bb explores search tree o k n   log m   n number variables 
k domain size number required solutions  space complexity o n  
proof  worst case m bb would explore entire search tree size o k n    maintaining
candidate list introduces additional time overhead o log m   since search tree
yields caching  m bb uses space linear number variables 
    characterization search space explored m bb
already shown m a  superior exact search algorithm finding mbest solutions heuristic consistent  theorem     particular  m bb must expand
  
nodes surely expanded m a   namely set nodes  n f  n    cm
theorem   pruning condition clear that 
   

fif lerova   arinescu     echter

p roposition    given consistent heuristic m bb must expand node set  n f  n   
   also  instances m bb expands nodes satisfying f  n    c  
cm

several sources overhead m bb discussed next 
       bb vs   bb
pruning m bb occur upper bound current mth best solution assigned
valid value  i e   solutions found  absence determinism  solutions
consistent  time takes find arbitrary solutions depth first manner o m n  
n length solution  for graphical models n coincides number variables  
problem contains determinism may difficult find even single solution  means
m bb search may exhaustive quite time 
      mpact olution rder
difference number nodes expanded bb m bb depends greatly variance
solution costs  solutions cost  u    um   however 
situation unlikely therefore conditions m bbs node expansions impacted
            u j   non increasing sequence
order solutions discovered  let  um

th
upper bounds best solution  point m bb uncovered j th solution 
j
initially um
    j                
p roposition     discovery  j   th j th solutions set nodes
j 
u j u j   
expanded m bb included sj    n   f  n  um
   cm


proof  discovering  j   th j th solutions m bb expands nodes satisfying
j 
j 
 n   f  n  um
   hence j   cj um
  j th solution found  either replaces
j
th
previous bound solution um   cj k th upper bound  k                 yielding
j 
j
u j u j   
  either way  cm
  um 
um


      rdering overhead
need keep list sorted solutions  the candidate list  implies o log m  overhead
new solution discovered  total number solutions encountered termination
hard characterize 
      c aching overhead
overhead related caching arises m bb explores search graph uses caching 
version algorithm  not explicitly presented  stores best partial solutions
fully explored subproblems  and subset partial set discovered  re uses
results whenever subproblem encountered again  order implement caching  mbb requires store list length node cached  moreover  cached partial
solutions need sorted  yields o m log m  time overhead per cached node 
   

fis earching b est olutions g raphical odels

   adapting m a  m bb graphical models
main task find best solutions optimization tasks graphical models  therefore 
adapt m best search algorithms m a  m bb explore and or search space
graphical models  yielding algorithms m aobf m aobb  respectively  describe
hybrid algorithm be m bf  combining bucket elimination m a  
    m aobf  best first and or search best solutions graphical models
extension algorithm aobf  section        m best task seems fairly straightforward 
principle  m aobf aobf continues searching discovering first solution 
required number best solutions obtained  actual implementation requires several
modifications discuss next 
easy extend aobfs bottom up node values updates corresponding arc marking
mechanism m best task  therefore  order keep track current best partial solution
tree searching ith best solution adopt naive approach maintains explicitly
list open containing entire partial solution trees  not nodes   sorted ascending order
heuristic evaluation costs  algorithm   presents pseudo code simple scheme explores
and or search tree generates solutions one one order costs  step 
algorithm removes next partial solution tree   open  line       complete
solution  added list solutions along cost  lines       otherwise algorithm
expands tip node n     generating successors  line         newly generated node
n  added   separately  yielding new partial solution tree     lines         whose cost
recursively evaluated using algorithm    aobb  line      new partial trees
placed open  line      search stops solutions found 
note maintenance open list containing explicit partial solution subtrees
source significant additional overhead become apparent empirical evaluation
section    thus  question whether performance m aobf improved open
therefore rich topic future work 
m a  properties  section      extended m aobf  particular  algorithm maobf admissible heuristic sound complete  terminating best solutions
generated order costs  m aobf optimal terms number nodes expanded
compared algorithm explores and or search space
consistent heuristic function 
heorem     m aobf complexity   complexity algorithm m aobf traversing either
h 
and or search tree context minimal and or search graph time space o k deg   
h depth underlying pseudo tree  k maximum domain size  deg bounds
degree nodes pseudo tree  pseudo tree balanced  each internal node
exactly deg child nodes   time space complexity o k n    n number
variables 
real complexity bound m aobf comes cost function  appears however
maintaining open list brute force manner lend easily effective way
enumerating partial solution subtrees therefore search space partial solution
subtrees actually exponential n  detailed proof theorem    given appendix 
   

fif lerova   arinescu     echter

algorithm    m aobf exploring and or search tree

 
 
 
 
 
 
 
 
 

  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  

  
  

input  graphical model   hx  d  fi  pseudo tree rooted x    heuristic function h    parameter m 
output  best solutions
create root node labelled x    let g    s   explored search space     s   partial solution tree  
initialize   op en  t          i counts current solution searched for  
op en   
select top partial solution tree   remove open 
  complete solution
 hf  t        i  
    
continue 
select non terminal tip node n    
   expand node n
n node labeled xi
forall xi d xi  
create child n  labeled hxi   xi i 
succ n  succ n   n    
else n node labeled hxi   xi
forall successor xj xi
create child n  labeled xj  
succ n  succ n   n    
g g  succ n   
   generate new partial solution trees
l  
forall n  succ n  initialize v n      h n    
n node
forall n  succ n 
create new partial solution tree       n    
l l  t      
else n node
create new partial solution tree       succ n   
forall    l
recursively evaluate assign f  t      cost partial solution tree      based heuristic
function h       see algorithm  
place    open  keeping sorted ascending order costs f  t      
return best solutions found s 

    m aobb  and or branch bound best solutions graphical models
algorithm m aobb extends and or branch bound search  aobb  section       
m best task  main difference aobb m aobb value function computed
node  m aobb tracks costs best partial solutions solved subproblem  thus extends node value v n  solution tree  n  rooted n aobb ordered
sets length m  denoted v n   n   respectively  v n     v   n           vm  n  
ordered set costs best solutions subproblem rooted n   n   
 n   set corresponding solution trees  extension arises due
 t   n           tm
depth first manner search space exploration m aobb conjunction and or decomposition  therefore  due and or decomposition m aobb needs completely solve
   

fis earching b est olutions g raphical odels

algorithm    m aobb exploring and or search tree

 
 

 
 
 
 
 
 
 
  
  
  
  
  

input  graphical model   hx  d  fi  pseudo tree rooted x    heuristic function h    parameter m 
output  best solutions
   initialize
create root node labeled x  let stack created expanded nodes op en    s  
initialize v s     a set bounds best solutions s  set best partial solution trees rooted
 s      u b     sorted list didat e    
op en   
select top node n open 
   expand
n node labeled xi
foreach xi d xi  
add child n  labeled hxi   xi list succ n  containing successors n 
initialize v n         set best partial solution trees rooted n  n       
n node labeled hxi   xi
let p ancestor n 
recursively evaluate assign f  p  cost partial solution tree rooted p  based heuristic h      
see algorithm  
vm  p    f  p  vm  p 
prune subtree current tip node n 
else
foreach successor xj xi
add child n  labeled xj list succ n  containing successors n 
initialize v n        set best partial solution trees rooted n  n       

  
  
  

  
  
  
  
  
  
  
  

  

  
  
  

  

  
  
  
  

remove n open add succ n  top open 
   propagate
list successors node n empty
n root node
return set solutions rooted n costs   n   v n   
else
update ancestors n  nodes p  bottom up 
p node
combine set partial solution trees subproblem rooted p  p  set partial
solution trees rooted n  n  costs v p  v n      see algorithm  
assign resulting set costs set best partial solution trees respectively v p 
 p  
else p node
foreach solution cost vi  n  set v n 
update cost weight arc  creating new set costs v    n  
vi   n    c p  n    vi  n  
merge sets partial solutions v n  v p  sets partial solution trees rooted p n 
 p   n   keeping best elements    algorithm   
assign results merging respectively v p   p  
remove n list successors p 
move one level up  n p 
return v s   s 

subproblems rooted children n  node n  even single solution
subproblem n acquired  unlike m bb case   consequently  bottom up phase
sets costs propagated updated  m aobf hand  maintains
set partial solution trees 
   

fif lerova   arinescu     echter

algorithm    combining sets costs partial solution trees
 

 
 
 

 
 
 
 
 
  
  

function combine v n   v p    n  t  n  
input  input sorted sets costs v n   v p   corresponding partial solution trees  n    p   number
required solutions
output  set costs best combined solutions v    p   corresponding partial solution trees    p 
   initialize
sorted list open  initially empty    contains potential cost combinations
v    p       p   
k        number partial solutions already assembled  total
   search possible combinations
open v   n    v   p  
k   op en empty
remove top node v open  v   svi  n    vj  p  
vk   p  v  
 
 p  ti  n  tj  p  
vi    n    vj  p  op en
put vi    n    vj  p  op en  

  

vi  n    vj    p  op en
put vi  n    vj    p  op en  

  

k k     

  

return v    p    p  

  

unlike m aobf discovers solutions one one order costs  m aobb  pseudocode algorithm    reports entire set solutions once  termination  m aobb interleaves forward node expansion  lines       backward propagation  or cost revision  step
 lines        updates node values search terminates  node n pruned  lines       
current upper bound mth solution n  vm  n   lower nodes evaluation
functions f  n   computed recursively aobb  algorithm     bottom up
propagation phase node partial solutions subproblems rooted nodes
children combined  line        algorithm     parent node p v p   p 
updated incorporate new possibly better partial solutions rooted child node n  lines
       algorithm     
      c haracterizing n ode p rocessing overhead
addition increase explored search space m bb experiences compared bb
due reduced pruning  section       and or search introduces additional overhead maobb  propagation set costs partial solution trees leads increase
memory factor per node  processing partial solutions nodes
introduces additional overhead 
heorem     algorithm m aobb exploring and or search tree time overhead
o m deg log m  per node o m k  per node  deg bounds degree
pseudo tree k largest domain size  assuming k   deg log m   total worst case time
complexity o n k h deg log m   space complexity o mn   time complexity

m aobb exploring and or search graph o n k w deg log m    space complexity

o mn k w   
   

fis earching b est olutions g raphical odels

algorithm     merging sets costs partial solution trees
 

 
 
 
 

 
 
 
 
  
  
  
  
  
  
  

  

function merge v n  v p  t  n  t  p  
input  input sorted cost sets v n  v p   sets corresponding partial solution trees  n   p  
number required solutions
output  v    p   merged set best solution costs     p  set corresponding partial solution trees
   initialize
v    p   
   p   
i  j      indices cost sets
k      index resulting array
   merge two sorted sets
k
vi  p  vj  n 
vk   p  vi  p  
 
tk  p  ti  p  
    
k k     
else
vk   p  vj  n  
 
tk  p  tj  n  
j j     
k k     
return v    p     p  

proof  combining sets current m best partial solutions  algorithm    introduces overheard
o m log m    resulting time overhead per node o deg log m    merging two
sorted sets costs  algorithm     done o m  steps  node o k  children 
resulting overhead o m k   assuming k   deg log m   complexity dominated
processing nodes  worst case  tree version m aobb  called m aobb tree 
would explore complete search space size o n k h    h bounds depth pseudo

tree  graph version  called m aobb graph  would visit space size o n k w   
w induced width pseudo tree  space complexity m aobb tree follows
need propagate sets o m  partial solutions length o n   time overhead
m aobb and or trees and or graphs  space complexity m aobbgraph explained need store partial solutions cached node 

    algorithm be m bf
known exact heuristics graphical models generated bucket elimination
 be  algorithm described section        therefore first compile exact heuristics along
ordering using apply m a   or m aobf  work point  
using exact heuristics  resulting algorithm called be m bf  worst case analysis
algorithm show yields best worst case complexity compared known
m best algorithm graphical models 
   

fif lerova   arinescu     echter

heorem     time complexity be m bf o nk w     nm  n number
variables  k largest domain size  w induced width problem desired
number solutions  space complexity o nk w   nm  
proof  bes time complexity o nk w     space complexity o nk w    dechter        
since compiles exact heuristic function  m a  exact heuristic expands nodes
f  n    cj searching ith solution  algorithm breaks ties favour
deeper nodes  expand nodes solution paths  path length n  yielding total
time space complexity step algorithm equal o n m  

   related work
distinguish several primary approaches employed earlier m best exact algorithms 
mentioned already introduction  note original works include space
complexity analysis bounds provided often own 
first influential approach introduced lawler         aimed use of theshelf optimization schemes best solutions  lawler showed extend given optimization
algorithm m best task  step  algorithm seeks best solution re formulation
original problem excludes solutions already discovered  scheme improved years still one primary strategies finding m best solutions 
time space complexity lawlers scheme o nmt  n   o s n   respectively 
 n  s n  time space complexity finding single best solution  example 
use aobf underlying optimization algorithm  use lawlers method yields time


complexity o n  mk w log n   space complexity o nk w log n   
hamacher queyranne        built upon lawlers work used building blocks algorithms find first second best solutions  two best solutions generated 
new problem formulated second best solution best solution new problem 
then  second best solution new problem becomes overall third best solution
procedure repeated  algorithm time complexity o m t   n   space complexity
o s   n    t   n  s   n  respectively time space finding second best
solution  complexity method always bounded lawler  seeing
lawlers scheme used algorithm finding second best task  using m aobf

find two best solutions  obtain time complexity o  mnk w log n   space complexity

o  nk w log n   
nilsson        applied lawlers method using join tree algorithm  top algorithm reuses computations previous iterations  scheme  called max flow algorithm  uses
message passing junction tree calculate initial max marginal functions cluster
 e g  probability values probable assignments task  yielding best solution  note
step equivalent running bucket elimination algorithm  subsequent solutions recovered conditioning search consult generated function  time complexity analysis
nilsson        o  p c     mp r    pm log  pm    p number cliques joint
tree   c  size largest clique  r  size largest residual  i e  number
variables cluster neighbouring clusters   space complexity bounded
o p c    p  s      s  size separator clusters  applied buckettree  nilssons scheme time space complexity o  nk w     mn  k   log mn  


o nk w      nk w   respectively  since bucket tree p   n cliques  whose size bounded
   

fis earching b est olutions g raphical odels



 c    k w    residual cluster  r    k  the domain single variable  
thus algorithm better time complexity schemes mentioned far  except
be m bf 
two works de campos et al  build upon nilssons approach  extending solving mbest map task using genetic algorithms  de campos  gamez    moral        probability trees
 de campos  gamez    moral         respectively  schemes approximate authors
provide theoretical analysis complexity 
fairly recently  yanover weiss        developed iterative scheme based belief propagation  called bmmf  iteration bmmf uses loopy belief propagation solve two new
problems obtained restricting values certain variables  applied junction tree

induced width w  whose largest cluster size bounded k w      exact algorithm
time complexity o  mnk w     space complexity o nk w   mnk   applied
loopy graph  bmmf guaranteed find exact solutions 
another approach based lawlers idea uses optimization via lp relaxation  wainwright
  jordan         formulated fromer globerson         method  called spanning tree
inequalities partitioning enumerating solutions  stripes  partitions search
space  systematically excluding previously determined assignments  step new
constraints added lp optimization problem  solved via off the shelf lp solver 
general  algorithm approximate  however  trees junction trees exact
underlying lp solver reports solutions within time limit  pesteelars extension
scheme batra        solves lp relaxation using message passing approach that 
unlike conventional lp solvers  exploits structure problems graph  complexity
lp based algorithm hard characterize using usual graph parameters 
another approach extends variable elimination  or dynamic programming  schemes directly
obtain best solutions  recent paper  flerova et al         extended bucket elimination mini bucket elimination m best solutions task  yielding exact scheme called
elim m opt approximate version called mbe m opt  respectively  work embeds
m best optimization task within semi ring framework  time space complexities


algorithm elim m opt bounded o m log mnk w      o mnk w    respectively 
two related dynamic programming based ideas seroussi golmard        elliot
        seroussi golmard extract solutions directly  propagating best partial
solutions along junction tree  given junction tree p cliques  largest cluster size  c   separator
size bounded  s  branching degree deg  time complexity algorithm o m  p
 c  deg  space complexity o m p  s    adapted bucket tree  algorithm


time complexity o m  nk w    deg  space complexity o mnk w    elliot propagates
best partial solutions along representation called valued and or acyclic graph  known
smooth deterministic decomposable negation normal form  sd dnnf   darwiche        

time complexity elliots algorithm o nk w    log  m deg   space complexity

o mnk w      
several methods focus search schemes obtaining multiple optimal solution k shortest
paths task  ksp   survey see paper eppstein         majority algorithms
assume entire search graph available memory thus directly applicable 
recent exception aljazzar leue         whose k algorithm finds k shortest paths
search on the fly thus potentially useful graphical models  algorithm
interleaves a  search problems implicit graph g dijkstras algorithm        spe   

fif lerova   arinescu     echter

be m bf


o nk w

m aobf


o nk w

log n

  

  mn 

o  nk w

 



nilsson     

  

  mn   log mn     k  

elim m opt


gosh et al      

elliot
    


yanover weiss     

m aobb


hamacher queyranne

o mnk w

o mnk w

  

  



o mnk w  

log m 

log  m deg  

o mnk w

o mnk w deg log m 



o  mnk w

  

log n

aljazzar leue     


o nk w w log  nk    m 

 

 

seroussi golmard     
o m  nk w   deg 

lawler     

o n  mk w  

m a  tree
o k n  

m bb tree

o k n   log m 

figure    time complexity comparison exact m best algorithms specified bucket tree 
parent node graph better complexity children  problem parameters 
n   number variables  k   largest domain size  w   induced width  deg   degree
join  bucket  tree  algorithms highlighted 

cific path graph structure denoted p  g   p  g  directed graph  vertices correspond
edges problem graph g  given consistent heuristic  k   applied and or

search graph time space o nk w w log n k    m  
recently  gosh  et al          introduced best first search algorithm generating ordered solutions explicit and or trees graphs  time complexity algorithm
bounded o mnk w    applied context minimal and or search graph  space
complexity bounded o s nk w      number candidate solutions generated
stored algorithm  hard quantify using usual graph parameters  however  approach 
explores space complete solutions  seem practical graphical models
requires entire and or search space fully explicated memory attempting generate even second best solution  contrast  algorithms generate best
solutions traversing space partial solutions 
   

fis earching b est olutions g raphical odels

figure   provides visual comparison worst case time complexity bounds
discussed schemes form directed graph  node corresponds algorithm
parent graph better complexity child  assume analysis
n      k     
see best emerging scheme  far worst case performance goes be m bf 
however  since requires compiling exact heuristics  often infeasible  see
algorithm elim m opt appears relatively good time complexity superior  example  maobb search  however  showed previous work  flerova et al          quite limited
empirically  note worst case analysis often fails capture practical performance  either algorithms good worst case performance require much memory 
ignores power cost function bounding performance 

   experimental evaluation
experiments consist two parts  evaluation m best search algorithms benchmarks
recent uai pascal  competitions comparison schemes previously developed algorithms randomly generated networks  whose parameters structure
restricted due limitations available implementations competing schemes 
defer discussion second part experiments section      concentrating
evaluation m best search schemes only 
    overview methodology
used   benchmarks  all  except binary grids  came real world domains 
   pedigrees
   binary grids
   wcsp
   promedas
   proteins
   segmentation
pedigrees benchmark  pedigree   used uai      competition   arise
domain genetic linkage analysis associated task haplotyping 
haplotype sequence alleles different loci inherited individual one parent 
two haplotypes  maternal paternal  individual constitute individuals genotype 
genotypes measured standard procedures  result list unordered pairs
alleles  one pair locus  maximum likelihood haplotype problem consists finding
joint haplotype configuration members pedigree maximizes probability
data  shown that  given pedigree data  haplotyping problem equivalent
computing probable explanation bayesian network represents pedigree  see
paper fishelson geiger        details  
   http   graphmod ics uci edu group repository

   

fif lerova   arinescu     echter

benchmark
pedigrees
grids
wcsp
promedas
proteins
segmentation

  inst
  
  
  
  
  
  

n
        
        
       
        
      
       

k
   
 
     
 
     
    

w
     
     
     
     
    
     

ht
      
      
      
      
    
     

table    benchmark parameters    inst   number instances  n   number variables  k   domain
size  w   induced width  ht   pseudo tree height 

binary grid networks                    nodes corresponding
binary variables arranged n n square functions defined pairs
variables generated uniformly randomly 
wcsp    wcsp  benchmark includes random binary wcsps  scheduling problems
spot  benchmark  radio link frequency assignment problems  providing large variety
problem parameters 
protein side chain prediction  pdb   networks correspond side chain conformation prediction tasks protein folding problem  yanover  schueler furman    weiss        
resulting instances relatively nodes  large variable domains  generally rendering
instances complex 
promedas  or chain    segmentation    s binary  probabilistic networks
come set problems used      probabilistic inference challenge   promedas instances based bayesian network model developed expert systems medical diagnosis
 wemmenhove  mooij  wiegerinck  leisink  kappen    neijt         segmentation common
benchmark used computer vision  modeling task image segmentation mpe problem 
namely assigning label every pixel image  pixels label share
certain characteristics 
table   describes benchmark parameters    inst   number instances  n   number variables  k   maximum domain size  w   induced width ordering used  ht   pseudo tree height 
induced width one crucial parameters indicating difficulty problem 
difference induced width mini bucket i bound signifies strength
heuristic  i bound considerably smaller induced width  heuristic
weak  i bound equal greater induced width yields exact heuristic 
turn yields much faster search  clearly  large number variables  high domain size large
pseudo tree height suggest harder problems 
      lgorithms
distinguish   algorithms  be m bf  m a  tree m bb tree exploring regular
search tree modifications explore and or search tree  denoted m aobf tree
m aobb tree  consider variant m aobf explores and or search graph
m aobf graph  implement m aobb and or search graph 
   http   graphmod ics uci edu repos mpe grids 
   http   www cs huji ac il project pascal archive mpe tgz

   

fis earching b est olutions g raphical odels

overhead due book keeping looked prohibitive  used m aobf representative and or
graph search  see proved indeed cost effective  algorithms
guided pre compiled mini bucket heuristics  described section        used    i bounds 
ranging       however  hard problems computing mini bucket heuristic
larger i bounds proved infeasible  actual range i bounds varies among benchmarks
among instances within benchmark  algorithms restricted static variable ordering
computed using min fill heuristic  kjrulff         and or schemes used pseudo
tree  implementation algorithms m bb  m bf m aobf break ties lexicographically 
algorithm m aobb solves independent subproblems rooted node increasing
order lower bound heuristic estimates 
algorithms implemented c       bit  experiments run    ghz
quad core processor  memory limit set   gb per problem  time limit   hours 
report cpu time  in seconds  number nodes expanded search  uniformity
consider task throughout maximization product problem  known
probable explanation task  mpe map   focus complete exact solutions thus
report results algorithm found less solutions  for best first schemes 
optimality solutions proved  for branch bound schemes  
      g oals e mpirical e valuation
address following aspects 
   comparing best first depth first branch bound approaches
   impact and or decomposition search performance
   scalability algorithms number required solutions
   comparison earlier proposed algorithms
    main trends behavior algorithms
tables                    present algorithms raw results form runtime
seconds number expanded nodes select instances benchmark  selected
best illustrate prevailing trends  benchmark show results two values
i bound  corresponding  cases  relatively weak strong heuristics  note ibound impact be m bf  since always calculates exact heuristic  show three
values number solutions m  equal    ordinary optimization problem          
order see bigger picture  figures      show bar charts representing
benchmark median runtime number instances solved algorithm particular
strength heuristic  i bound                      y axis logarithmic scale 
numbers bars indicate actual values median time seconds number
solved instances  respectively  important note figures account harder
instances  i bound yield exact heuristic  acknowledge median
times strictly comparable since calculated varied number instances solved
algorithm  however  metric robust outliers gives us intuition
algorithms relative success  addition  tables                   show benchmark
number instances  given algorithm best terms runtime terms
number expanded nodes  several algorithms show best result  counts towards
score them 
   

fif lerova   arinescu     echter

instance
 n k w  h 

i bound

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
timeout
    
    
oom
oom
oom
      
         
     
       
    
    

number solutions
m   
nodes
oom
oom
oom
timeout
timeout
    
    
oom
oom
oom
       
         
      
        
    
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
oot
       
        
oom
oom
oom
oom
      
        
      
       
oom

oom
oom
oom
oot
       
        
oom
oom
oom
oom
      
        
      
       
oom

oom
oom
oom
oot
       
        
oom
oom
oom
oom
      
        
      
       
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
       
        
oom
oom
oom
      
       
timeout
      
       
oom

oom
oom
oom
timeout
oot
oom
oom
oom
oom
timeout
      
       
oom

oom
oom
oom
timeout
oot
oom
oom
oom
oom
timeout
      
       
oom

     

     

algorithm

m  
time

    wcsp

 

               

 

myciel g   wcsp

 

              

 

satellite  ac wcsp

 

               

 

   wcsp

 

               

 

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

     
     
     
    
   
    
    
    
    
    
   

nodes

      
oom
      
       
     
   
    
    
    
     
    
   

time

     
     
    
   
    
    
    
    
    
   

      
oom
      
       
      
   
    
    
    
     
     
   

m    
time

nodes
oom
oom
oom
timeout
timeout
    
    
oom
oom
oom
       
         
       
         
    
    

     
     
     
    
    
    
    
    
     
    

      
oom
      
       
       
   
    
    
    
     
       
   

table    wcsp  cpu time  in seconds  number nodes expanded  timeout stands
exceeding time limit   hours  oom indicates  gb memory  bold
highlight best time number nodes m  parameters  n   number
variables  k   domain size  w   induced width  h   pseudo tree height 

next provide elaboration interpretation results 
      wcsp
table   shows results two values i bound select instances chosen best illustrate
common trends seen across wcsp benchmark  figure   presents median time
number solved instances algorithm i     table   shows i bound  i    
number instances schemes best runtime best number
expanded nodes  many problem instances benchmark mini bucket elimination
large i bounds infeasible  thus present results small medium i bounds 
   

fis earching b est olutions g raphical odels

be m bf
m aobf tree

m aobf graph
m a  tree

    
    
    
    
    

    

  

   

 
 
 
 

 
 
 

 
 
 

 
 
 

 

solved instances

wcsps  i   

 
 

 

 

 

 

m bb tree
m aobb tree

 
 

 
 

 

 

m aobf graph
m a  tree

 

be m bf
m aobf tree
 

   
    
    
    

   
   
    
    
    

 


 

 
 

 

    

   

    

    
    
   
    
    
    

    
   

   
    
    
    

median time
wcsps  i   

   

m bb tree
m aobb tree
    

   

   

 

 

 



  

   

figure    median time number solved instances  out     select values wcsps 
i bound     numbers bars   actual values time  sec    instances  total
instances benchmark      discarded instances due exact heuristic     

be m bf  suggested theory  whenever be m bf run memory 
efficient scheme  see example table        wcsp    wcsp  however  calculation
exact heuristic feasible easier instances and  figure   shows  solve
   

fif lerova   arinescu     echter

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

wcsps    inst     n        
k        w         ht         i bound   
m  
m  
m  
m   
m    
 bt    bn  bt    bn  bt    bn  bt    bn  bt    bn
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    number instances  algorithm best runtime   bt  best number
expanded nodes   bn   wcsps     instances    exact heuristics  table
accounts remaining     i bound      

  wcsp instances  seen table    two instances be m bf demonstrated best
runtime among schemes 
m aobb tree  number problems small values m  m aobb tree superior mbb tree terms runtime number expanded nodes  example     wcsp 
i    m    m aobb tree requires      seconds solve problem expands        nodes
runtime m bb tree       seconds expands         nodes  however 
majority instances m aobb tree slower schemes  seen figure    moreover 
m aobb tree scales poorly number solutions        often
worst runtime largest explored search space among schemes  e g  i        wcsp 
striking decrease performance grows consistent across various benchmarks
explained need combine sets partial solutions nodes described
earlier  overhead connected and or decomposition accounts larger time per
node ratio m aobb tree  compared schemes  example  table   instance
myciel g   wcsp  i    m    m     m aobb tree expands less nodes m bb tree 
runtime larger  nevertheless  m aobb tree benefits  since space efficient
algorithms  often scheme able find solutions harder instances 
especially heuristic weak  see myciel g   wcsp i   satellite  ac wcsp
i   i    respectively 
m bb tree  figure   see m bb tree solves almost number problems
m aobb tree considerably better median time 
m aobf tree m aobf graph  unsurprisingly  best first search algorithms often run
space problems feasible branch bound      wcsp myciel g   wcsp i   
m aobf based schemes overall inferior algorithms  solving  figure   shows 
least number problems  schemes run memory much often m a  tree 
believe due overhead maintaining open list partial solution trees  opposed
open list individual nodes m a  tree does  whenever m aobf schemes manage
find solutions  example instance    wcsp  i    m aobf graph explores smallest
   

fis earching b est olutions g raphical odels

search space among schemes  except be m bf  time m aobf tree sometimes
expands nodes compared m aobf graph  m a  tree 
would normally expect  since m a  tree traverses search space  inherently larger
and or one  however  important remember though better space efficiency
and or schemes often observed  guaranteed  many factors  tie breaking
nodes value evaluation function  impact performance maobf tree  m aobf tree m aobf graph almost median time number
solved problems  seen figure   
m a  tree  three best first algorithms m a  tree overall best  figure   see
solves instances schemes values median runtime
close be m bf  table   proves i bound    scheme fastest among
schemes largest number instances  showing best runtime     instances  depending
m  explained part relatively reduced overhead maintaining search space
open list memory  compared example m aobf schemes 
      p edigrees
table   displays results select instances pedigree benchmark two i bounds each 
overall  difference results algorithms greatly diminishes heuristic
strength increases  figure    shows median time number solved instances select
values i     number instances schemes best runtime
best number expanded nodes i bound presented table   
be m bf  be m bf often superior algorithms  especially
schemes use lower values i bound  e g  pedigree    i     ms  large i bounds thus
accurate heuristics difference much smaller  moreover  sometimes be m bf
slower schemes  due time required calculate exact heuristic  e g  pedigree   
i     table   shows be m bf overall fastest  see pedigree benchmark
algorithm quite successful  evident many instances solved  see figure     
m aobb tree  low values m aobb tree slightly superior algorithms 
solving number instances   see figure      hand  median time
largest  fails solve instances m      table   see m aobb tree
slowest   e g   pedigree    i     ms   yet  instance pedigree    i     m    scheme
one find solution 
m bb tree  expected  m bb tree inferior best first search schemes unless latter
run memory  case wcsp  scheme often faster m aobb tree 
example  pedigree    i     values m  bar charts show m bb tree second
worst median time values m  solves number problems m     
m aobf schemes  m aobf algorithms unsuccessful pedigree benchmark 
often run memory even      e g  pedigree    i      instances
report solution m aobf tree faster m aobf graph  though difference usually
large 
m a  tree  saw wcsps  pedigree instances m a  tree faster two
m aobf schemes  seen figure     values m  moreover  superior harder instances
   

fif lerova   arinescu     echter

instance
 n k w  h 

i bound

pedigree  

  

algorithm

m  
time

                 
  

pedigree  

  

                  

  

pedigree  

  

                

  

pedigree  

  

                
  

nodes

number solutions
m   
time
nodes
oom
oom
oom
timeout
timeout
oom
oom
oom
    
     
    
      
timeout
oom

m    
nodes
oom
oom
oom
timeout
timeout
oom
oom
oom
    
      
     
      
timeout
oom
time

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
       
         
oom
oom
oom
    
     
    
      
    
     
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
       
        
    
    
oom
oom
     
       
     
        
      
       
    
    

oom
oom
oom
timeout
oot
    
    
oom
oom
     
       
     
        
timeout
    
    

oom
oom
oom
timeout
oot
    
     
oom
oom
     
       
      
        
timeout
    
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
    
      
    
       
     
      
    
   
oom
oom
    
     
   
      
     
      
    
   

oom
oom
      
       
        
    
oom
oom
     
      
        
    

oom
oom
     
      
     
       
timeout
    
     
oom
oom
    
     
     
       
oom
    
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

    
     
     
     

     
     
     
     

oom
oom
       
       
       
   
oom
oom
       
       
       
   

    
     
      
    

    
    
      
    

     
     
       
     

     
     
      
     

oom
oom
       
       
        
    
oom
oom
       
       
        
    

oom
oom
       
       
timeout
     
     
oom
oom
     
       
    
       
timeout
     
     
     
     

table    pedigrees  cpu time  in seconds  number nodes expanded  timeout stands
exceeding time limit   hours  oom indicates  gb memory  bold
highlight best time number nodes m parameters  n   number
variables  k   domain size  w   induced width  h   pseudo tree height 

infeasible m aobf schemes be m bf  e g  pedigree    i     shown figure    
solves   instances i     ms  best second best results  depending
number solutions  however  median time m a  tree considerably larger
be m bf  i bound latter solves single instance less 
      b inary g rids
table   shows results select instances grid networks domain  figure    shows
median runtime number solved instances i     table   presents number
instances  algorithm best  i bound  trends algorithms
   

fis earching b est olutions g raphical odels

m aobf graph
m a  tree

m bb tree
m aobb tree

      

be m bf
m aobf tree

    

    

    

     

     

    

     

m bb tree
m aobb tree
 
 
 

 
 
 

 

 
 
 

 
 

 
 

 

   

   
   

   

m aobf graph
m a  tree

 
 
 

  



be m bf
m aobf tree

  

   

   

 



   
   

 

   
   

 

   
   

    

   
   

   

   
   

solved instances
pedigrees  i   

    
   
   

 

 

 

 

    
   
   

    
   
   

   

    
   
   

    

   

   

    

     

   

     

     

median time
pedigrees  i   

      

   

figure     median time number solved instances  out     select values pedigrees  i bound     numbers bars   actual values time  sec    instances 
total instances benchmark       discarded instances due exact heuristic    

behavior observed wcsp pedigree benchmarks noticed grid benchmark
well  particular  m aobb tree successful small  even solving
instances  seen figure     shows worse results m     number
solutions largest median time  m bb tree smaller median time ms  still
   

fif lerova   arinescu     echter

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

pedigrees    inst     n         
k      w         ht          i bound   
m  
m  
m  
m   
m    
 bt    bn  bt    bn  bt    bn  bt    bn  bt    bn
 
 
 
 
 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    number instances  algorithm best runtime   bt  best number
expanded nodes   bn   pedigrees     instances   exact heuristics  table
accounts remaining     i bound      

considerably slower best first schemes  m a  tree presents best compromise
small medium running time relatively large number solved instances  table  
shows majority grid instances fastest algorithm  two m aobf schemes
results quite similar other  solving almost number instances ms little
difference median runtimes  shown figure     consistently inferior
schemes except be m bf  often runs memory  main difference
grid benchmark compared previously discussed domains lies behaviour be mbf i bound high  even though expands less nodes  many problems be m bf
slower schemes due large time required compute exact heuristic 
example  grid          i     m    runtime be m bf        seconds  even
m aobb tree  known slow  terminates      seconds  time  instance
be m bf explores smallest search space values m 
      p romedas
table   shows results promedas benchmark  figure    presents median time number solved instances benchmark i     table   shows i bound number
instances schemes best runtime best number expanded nodes 
significant fraction instances solved algorithms  especially low
medium i bounds  unlike benchmarks  m aobb tree solves instances
small ms  quite successful m      solving one instance less best
scheme value m  m bb tree  moreover  sometimes m aobb tree scheme
report solutions  especially weak heuristic  e g  chain    fg chain     fg  i    
be m bf runs memory instances  seen table    overall  variance
algorithms performance significant promedas previously discussed benchmarks  example  see figure     i    m a  tree  m bb tree m aobb tree solve
      instances          be m bf m aobf based schemes
solve     instances  table   demonstrates m a  tree often fastest
algorithms 
   

fis earching b est olutions g raphical odels

instance
 n k w  h 

       

i bound

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
    
      
    
       
    
      
oom
oom
oom
oom
oom
timeout
      
        
oom
oom

number solutions
m   
time
nodes
oom
oom
     
       
     
       
     
       
oom
oom
oom
oom
oom
timeout
      
        
oom
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
       
   
oom
oom
     
      
     
   

oom
oom
oom
timeout
      
        
     
    
oom
oom
    
     
    
      
      
       
     
    

oom
oom
oom
timeout
timeout
     
    
oom
oom
    
      
    
      
timeout
     
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
      
        
oom
oom
oom
oom
   
      
     
        
     
       
oom
oom

oom
oom
oom
timeout
      
        
oom
oom
oom
oom
    
      
     
        
      
       
oom
oom

oom
oom
oom
timeout
       
        
oom
oom
oom
oom
    
      
     
        
      
        
oom
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
      
         
      
   
oom
oom
    
       
     
       
     
       
      
   

oom
oom
oom
timeout
timeout
      
    
oom
oom
     
       
     
       
    
       
      
    

oom
oom
oom
timeout
timeout
      
     
oom
oom
     
       
     
       
timeout
      
     

algorithm

m  
time

  

                
  

       
  

                
  

       

  

                

  

       

  

                
  

     
     

    
    
    
     

nodes

m    
time

nodes
oom
oom
     
       
     
       
timeout
oom
oom
oom
oom
oom
timeout
       
        
oom
oom

table    grids  cpu time  in seconds  number nodes expanded  timeout stands
exceeding time limit   hours  oom indicates  gb memory  bold
highlight best time number nodes m  parameters  n   number
variables  k   domain size  w   induced width  h   pseudo tree height 

      p rotein
table    shows select protein instances i   i    respectively  figure    table    show
summary results i    benchmark fairly difficult due large domain size
 up      heuristic calculation feasible higher i bounds  particular  be m bf
considerable problems calculating exact heuristic  even low i bounds relatively easy
instances solved  note instances pdb ctk pdb dlw i bound   yields exact heuristic 
m aobf tree m aobf graph fail find solutions within memory limit
majority instances  e g   pdb b v pdb cxy  i    much difference
runtimes algorithms  exception m aobb tree  example  pdb b v  i   
   

fif lerova   arinescu     echter

m aobf graph
m a  tree

m bb tree
m aobb tree
      

be m bf
m aobf tree

     
    

  



   

m bb tree
m aobb tree
  
  

  
  
  

  
  

  
  

  

m aobf graph
m a  tree

  

be m bf
m aobf tree

    

    
    
    

    

   
   
    

 

 

    
    
   

     

     
     

     
     
    

 

  
  
  

    

   

    

    

   

    
    

   

    
    

     
     

median time
grids  i   

   

     

   

 
 
 
 

 

 
 

 
 
 

 

 
 

 

 

solved instances

grids  i   

 

   

   

 

 

 



  

   

figure     median time number solved instances  out     select values
grids  i bound     numbers bars   actual values time  sec    instances 
total instances benchmark      discarded instances due exact heuristic    

m aobb tree requires      seconds find m    solutions  runtimes algorithms
range           seconds  except be m bf runs memory   however 
slow performance m aobb tree easier problems feasible algorithms
compensated fact many instances scheme report solution  solving
   

fis earching b est olutions g raphical odels

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

grids    inst     n         
k      w         ht          i bound   
m  
m  
m  
m   
m    
 bt    bn  bt    bn  bt    bn  bt    bn  bt    bn
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
      
      
   
   
   
   
   
   
   
   

table    number instances  algorithm best runtime   bt  best number
expanded nodes   bn   grids     instances   exact heuristics  table
accounts remaining     i bound      

instances considerable amount          figure      table    shows m aobbtree best terms time space overwhelming majority problems
values except       
      egmentation
table    shows results select instances segmentation benchmark two i bounds 
namely i   i     figure    table    present summary results i    
unlike wcsp  benchmark chose display relatively low i bounds calculating heuristic larger infeasible  problems low induced width
wished avoid displaying results obtained exact heuristics  main peculiarity
benchmark striking success be m bf  overall solves many instances usually
superior m a  tree m bb tree  seen figure     moreover  runtime superior
schemes  true instances table    illustrated results
table     heuristic weak  m aobb tree fairly successful  example  finding
solutions values      s binary  i    infeasible scheme except
be m bf  however  usual  m aobb tree overall slowest schemes 
    best first vs depth first branch bound best solutions
let us consider data presented tables      figures      order summarize
observations contrast performance best first depth first branch bound schemes 
among best first search schemes m a  tree successful  often effective 
armed good heuristic  requires less space best first schemes 
already noted  be m bf shows good results segmentation benchmark  best
algorithm terms median runtime  solving least number problems
schemes  however  benchmarks calculation exact heuristic often
infeasible 
   

fif lerova   arinescu     echter

instance
 n k w  h 

i bound

  

                

  

                

chain     fg

  

  

  

                
  

chain    fg

m  
time

chain     fg

chain     fg

algorithm

  

               
  

nodes

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
    
      
     
       
     
       
oom
oom
oom
   
       
    
       
      
       
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
       
          
     
       
oom
oom
oom
     
       
      
        
     
       
oom

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

number solutions
m   
time
nodes
oom
oom
     
       
     
       
      
       
oom
oom
oom
     
       
     
       
      
        
oom

m    
time

     
     
      

     
      
      

nodes
oom
oom
       
        
        
oom
oom
oom
       
        
        
oom

oom
oom
oom
oot
        
oom
oom
oom
       
        
        
oom

oom
oom
oom
oot
       
        
oom
oom
oom
oom
      
         
      
        
oom

oom
oom
oom
timeout
        
oom
oom
oom
       
        
        
oom

oom
oom
oom
timeout
       
         
oom
oom
oom
     
       
      
        
       
        
oom

oom
oom
oom
timeout
timeout
oom
oom
oom
     
       
      
        
       
        
oom

oom
oom
oom
timeout
       
        
oom
oom
oom
     
       
     
        
timeout
oom

oom
oom
oom
timeout
       
        
oom
oom
oom
oom
      
        
timeout
oom

oom
oom
oom
timeout
       
         
oom
oom
oom
oom
      
        
timeout
oom

      

    
     
      

      

     
      
     

table    promedas  cpu time  in seconds  number nodes expanded  timeout stands
exceeding time limit   hours  oom indicates  gb memory  bold
highlight best time number nodes m  parameters  n   number
variables  k   domain size  w   induced width  h   pseudo tree height 

two m aobf based schemes overall inferior due prohibitively large memory  solving
fewer instances algorithms  believe non trivial extension aobf
single solution m best task straightforward  hard represent multiple
partial solution trees efficient manner  order efficient m aobf implementation 
one needs quickly identify partial solution subtree select extend next  searching  k     th solution finding k th best solution  aobf  for   solution  uses
arc marking mechanism efficiently represent current best partial solution subtree
search  easy extend case searching best solutions  therefore 
shown section      m aobf implements naive mechanism par   

fis earching b est olutions g raphical odels

be m bf
m aobf tree

   

m aobf graph
m a  tree

m bb tree
m aobb tree

  



   

m aobf graph
m a  tree

m bb tree
m aobb tree
  
  
 

 

 

 

 

 

 
 

 

 

 

 

 
 

solved instances

promedas  i   

   

 

  

  
  
  

  
  
  

  
  
  

be m bf
m aobf tree

    
    
    
    

    
    
    
    
   

    
    
    
    

 

 

      

      

      
     

      
    

 

  
  
  

    

    
    

    
    
    
    

   

   

    

     

   

     

      

median time
promedas  i   

   

       

   

   

 

 

 



  

   

figure     median time number solved instances  out     summary select values
promedas  i bound     numbers bars   actual values time  sec   
instances  total instances benchmark      discarded instances due exact heuristic 
   

tial solution trees represented explicitly memory  simple representation  however  incurs
considerable computational overhead searching best solutions  indeed
revealed experiments  efficient implementation m aobf left future work 
   

fif lerova   arinescu     echter

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

promedas    inst     n         
k      w         ht          i bound   
m  
m  
m  
m   
m    
 bt    bn  bt    bn  bt    bn  bt    bn  bt    bn
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
       
       
       
       
   
   
   
   
   
      
   
   
   
   
   
   
   
   
   
   

table    number instances  algorithm best runtime   bt  best number
expanded nodes   bn   promedas     instances    exact heuristics 
table accounts remaining     i bound      

unsurprisingly  branch bound algorithms robust terms memory
dominate m a  tree best first schemes many benchmarks terms number
instances solved  however  tend considerably larger median time expand
nodes  particular  m aobb tree scale well number solutions large
values runtime increases drastically  unlike m aobf  whose inferior performance
attributed specifics implementation  depth first m aobb suffers issues inherent
solving m best problem depth first manner  algorithm    describes  m aobb needs
merge best partial solution internal node  hurts performance significantly 
cannot avoided  unless algorithmic approach fundamentally changed 
see way overcome limitation 
overall  whenever calculation exact heuristic feasible  be m bf
algorithm choice  otherwise  m a  tree superior relatively easy problems  maobb tree best scheme hard memory intensive instances  superiority best first
approach  whenever memory available  expected  based  one hand  intuition derived
knowledge task finding single solution  hand  theoretical
results section     
    scalability algorithms number required solutions
figures       present plots showing runtime seconds number expanded nodes
function number solutions  on log scale  two instances benchmark 
figure    displays results wcsp pedigree benchmarks  figure      grids promedas 
figure      proteins segmentation  lower values  on y axis  preferable  row
contains two instances benchmarks specific value i bound  runtime plots
shown ones containing expanded nodes  examples chosen best
illustrate prevailing tendencies 
note theoretical analysis suggests runtime be m bf  best among

algorithms  scale since worst case complexity o nk w   mn   theoretical
complexity best first search schemes m aobf tree m a  tree linear number
   

fis earching b est olutions g raphical odels

instance
 n k w  h 

pdb b v

                 

pdb cxy

               

i bound

m  
time

 

 

 

 

pdb ctj

 

               

 

pdb dlw

 

               

algorithm

 

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

nodes
oom
oom

    
     
    
    
    
   
    
    

    
      
      
oom
  
  
   
    
    
oom

number solutions
m   
nodes
oom
oom
    
    
     
       
     
      
oom
    
   
    
   
    
   
    
    
    
      
oom
time

oom
oom
    
   

    
     
oom
oom
oom
    
   
    
    
    
    
oom

     
      
    
    
   
    
    
    
    
    

     
     
      
    

    
    
     
    

oom
oom
     
        
     
  
  
  
  
    
    
  
oom
oom
      
       
       
   
oom
oom
    
      
      
   

m    
time

nodes
oom
oom

    
    
      
    
    
    
   

    
       
         
oom
    
   
    
     
timeout
oom

oom
oom
    
   

oom
oom
    
     

oom

     
      
oom
oom
oom
   
    
    
     
     
       
oom

oom
oom

oom
oom

oom
oom
oom
    
    
    

     
       
     
    
    
    
    
    
    
    

     
     
      
    

    
    
      
    

   
     
     

     
        
      
   
   
  
   
    
     
   
oom
oom
      
       
        
   
oom
oom
    
      
       
   

    
    

     
       
      
    
    
    
    
    
     
    

     
     
    

    
    
    

     
         
       
    
    
  
    
     
       
    
oom
oom
      
       
oot
    
oom
oom
     
      
oot
    

table     protein  cpu time  in seconds  number nodes expanded  timeout stands
exceeding time limit   hours  oom indicates  gb memory  bold
highlight best time number nodes m  parameters  n   number
variables  k   domain size  w   induced width  h   pseudo tree height 

solutions  m bb tree overhead due m best task factor  m log m 
m aobb tree  m log deg   deg degree pseudo tree  observed
compared schemes runtime be m bf indeed rises quite slowly number
solutions increases  even reaches      runtime m a  tree scales well m 
behaviour m bb tree depends lot benchmarks  pedigrees protein runtime
changes little instances number solutions grows  benchmarks 
runtime m     tends significantly larger m    m aobf tree m aobfgraph often provide solutions even m   or  alternatively  run memory
slightly increases  m           algorithms clearly successful practice 
   

fif lerova   arinescu     echter

be m bf
m aobf tree

   

m aobf graph
m a  tree

m bb tree
m aobb tree

       

     

     

      
     

     
     

   

      

   

     

      

median time
protein  i  

   

 

 

  



   

  
  

  
  

  
  

  
  

  
  

solved instances
protein  i  

  

  

  

  
  
  

  

  

m bb tree
m aobb tree

  

  
  

  

  

  

m aobf graph
m a  tree

  

be m bf
m aobf tree

    
    
    

    

    

    
    
    

 

    
    
    

    
    
    
    

    
    
    
    

   

    

   

   

 

 

 



 

 

 

 

 

   

  

   

figure     median time number solved instances  out     select values
protein  i bound    numbers bars   actual values time  sec    instances 
total instances benchmark      discarded instances due exact heuristic    

discussed before  runtime number expanded nodes m aobb tree increase
drastically gets larger 
   

fis earching b est olutions g raphical odels

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

m  
 bt    bn
  
   
      
      
   
       
   

protein    inst     n       
k        w        ht        i bound  
m  
m  
m   
 bt    bn  bt    bn  bt    bn
  
  
  
   
   
   
      
      
      
   
      
       
   
   
   
       
       
       
   
   
   

m    
 bt    bn
  
   
      
       
       
   
   

table     number instances  algorithm best runtime   bt  best
number expanded nodes   bn   protein     instances   exact heuristics 
table accounts remaining     i bound     

    comparison competing algorithms
compare methods number previously developed schemes described details
section    stripes  pesteelars nilssons algorithm  implementations
schemes provided dhruv batra  first two approaches based ideas lp relaxations approximate  known often find exact solutions  though provide
guarantees optimality  nilssons algorithm exact message passing scheme operating
junction tree  first set experiments  on tree benchmark  show results
stilars algorithm  older version pesteelars algorithm  however  scheme
consistently inferior two lp based schemes considered two
benchmarks  following  collectively refer   algorithms competing schemes 
      r andomly g enerated b enchmarks
available us code lp based nilssons approaches developed run restricted inputs only  could applied benchmarks used bulk evaluation described above  concluded re implementing competing codes work general
input would time consuming would provide additional insights  thus chose
compare algorithms competitors using benchmarks acceptable
competing schemes 
specifically  comparison performed following three benchmarks  random trees 
random binary grids random graphs submodular potentials  call submodular
graphs remainder section  table    shows parameters benchmarks 
instances generated following manner  first  vector    logarithmically spaced integers          generated  serving number variables instances 
binary grids benchmarks value used generate two problems number
variables  edges variables generated uniformly randomly  making
sure end graph tree  grid loopy graph  depending benchmark  edge
define binary potential vertex unary potential exponential form  f   e  
   

fif lerova   arinescu     echter

instance
 n k w  h 

i bound

 

                

  

                

    s binary

                

oom
oom
oom
timeout
      
       
   
   
    
      
     
    
    
    
    
    
    
    
   
   

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
     
       
    
   
    
    
    
   
    
   
    
     
    
     
    
   

oom
oom
oom
timeout
      
        
    
    
    
     
    
    
    
    
    
     
     
       
    
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
      
       
    
   
    
      
oom
    
    
    
    
    
    
    
   

oom
oom
oom
timeout
      
        
    
    
oom
oom
    
    
    
     
     
      
    
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

oom
oom
oom
timeout
      
       
    
   
oom
oom
    
      
    
      
    
     
    
   

oom
oom
oom
timeout
     
        
    
    
oom
oom
    
      
   
      
     
      
    
    

m  
time

     s binary

      s binary

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

number solutions
m   
nodes
oom
oom
oom
timeout
      
        
    
    
     
      
oom
    
    
    
     
    
      
    
    

algorithm

 

  

 

  

     s binary

 

                

  

nodes

time

m    
time

nodes
oom
oom
oom
timeout
       
         
    
     
oom
oom
   
     
    
      
      
        
    
     

    

    
   
    

    

    
    
    

oom
oom
oom
timeout
oot
     
oom
oom
     
      
oot
     
oom
oom
oom
timeout
oot
     
oom
oom
     
     
oot
     

oom
oom
oom
timeout
oot
    
     
oom
oom
    
      
   
       
       
         
    
     

table     segmentation  cpu time  in seconds  number nodes expanded  timeout
stands exceeding time limit   hours  oom indicates  gb memory 
bold highlight best time number nodes m  parameters  n   number
variables  k   domain size  w   induced width  h pseudo tree height 

real number sampled uniform distribution  third benchmark potentials modified submodular  random trees m best optimization lp
problem guaranteed tight  graphs submodular potentials lp optimization
problem tight  m best extension not  arbitrary loopy graphs  including grids 
algorithms provide guarantees 
      c ompeting lgorithms p erformance
table    shows runtimes select instances random tree benchmark   mbest search schemes competing lp schemes stilars  pesteelars stripes 
   

fis earching b est olutions g raphical odels

be m bf
m aobf tree

m aobf graph
m a  tree

m bb tree
m aobb tree

   

      

   

 

   

  

  
  

  

  

  

  

  
  
  

m bb tree
m aobb tree

  

  
  
  

  
  

  

  
  
  

m aobf graph
m a  tree

  
  

  
  

solved instances
segmentation  i   

  

  
  
  

be m bf
m aobf tree

   

  



  
  

 

    
    
   
    
    

 

    

    
    
    
    
    
   

    
    
   
    
    
    

   

    

   

    
   
    
    
    

   

   
    
   
    
    
    

median time
segmentation  i   

   

 

 

 



  

   

figure     median time number solved instances  out     select values
segmentation  i bound     numbers bars   actual values time  sec   
instances  total instances benchmark      discarded due exact heuristic    

observed benchmarks stilars always inferior two schemes
therefore excluded remainder evaluation  instead  tables       
show results random binary grids submodular graphs benchmarks  added
comparison nilssons max flow algorithm  table       time limit set   hour 
memory limit   gb  schemes behavior quite consistent across instances 
   

fif lerova   arinescu     echter

time vs m  wcsps  bwt ac wcsp

time vs m  wcsps  queen      wcsp

                  i  

                 i   

 

  

 

time  sec

time  sec

 
  

 

 
 
 
 

 

 

   

    

number solutions

m aobf tree
m aobf graph

   

 e 

m a  tree
m bb tree

     

   

m aobb tree
be m bf

    

m aobf tree
m aobf graph

nodes vs m  wcsps  bwt ac wcsp
                  i  
   

 e 

     

number solutions
m a  tree
m bb tree

m aobb tree
be m bf

nodes vs m  wcsps  queen      wcsp
                 i   

   
   

   

nodes

nodes

   

   

   

   

   

   

   

   

   

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

   

m aobb tree
be m bf

m aobf tree
m aobf graph

m a  tree
m bb tree

     

m aobb tree
be m bf

time vs m  pedigrees  pedigree 

time vs m  pedigrees  pedigree  

                    i   

                    i   

    

    

    

    

time  sec

    

time  sec

    

number solutions

   

    

   
   
   
 

   
 

   

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

   

m aobb tree
be m bf

m aobf tree
m aobf graph

nodes vs m  pedigrees  pedigree  
 e 

    

number solutions
m a  tree
m bb tree

     

m aobb tree
be m bf

nodes vs m  pedigrees  pedigree 

                    i   

 

 

                    i   

nodes

 

   

nodes

   

 e 

   

 

   

 

   

 
   

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

   

m aobb tree
be m bf

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

m aobb tree
be m bf

figure     cpu time seconds number expanded nodes function number solutions  wcsp pedigrees    gb    hours 

   

fis earching b est olutions g raphical odels

time vs m  grids         

time vs m  grids         

                  i   

                  i   

  

    
    
    
    
    
    
   
 

time  sec

time  sec

  
  
  
 
   

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

   

m aobb tree
be m bf

m aobf tree
m aobf graph

nodes vs m  grids         
 

 
 
 
 
 
 
 
 

m a  tree
m bb tree

m aobb tree
be m bf

                  i   

 e 

 

nodes

nodes

 
 
 
 
 

   

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

   

m aobb tree
be m bf

    

     

number solutions

m aobf tree
m aobf graph

time vs m  promedas  or chain    fg

m a  tree
m bb tree

m aobb tree
be m bf

time vs m  promedas  or chain     fg
                  i   

                  i   

    

  

    

 

time  sec

time  sec

     

nodes vs m  grids         

                  i   

   e 

    

number solutions

    

 

    

 

    

 
 

 
   

    

m aobf tree
m aobf graph

 e 

     

number solutions
m a  tree
m bb tree

   

m aobb tree
be m bf

    

m aobf tree
m aobf graph

nodes vs m  promedas  or chain    fg
                  i   

 e 

   

m a  tree
m bb tree

m aobb tree
be m bf

nodes vs m  promedas  or chain     fg
                  i   

nodes

   

 

nodes

 

     

number solutions

   

 
 

   

 

   
   

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

   

m aobb tree
be m bf

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

m aobb tree
be m bf

figure     cpu time seconds number expanded nodes function number solutions  grids promedas    gb    hours 

   

fif lerova   arinescu     echter

time vs m  protein  pdb at 

time vs m  protein  pdb b v

                  i  

                   i  

   
   
   
   
   
   
   
   
 

 
 

time  sec

time  sec

 
 
 
 
 
 
   

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

   

m aobb tree
be m bf

m aobf tree
m aobf graph

nodes vs m  protein  pdb at 

m aobb tree
be m bf

   
   

   

nodes

nodes

   

   

   

   

   

   

   
   

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

   

m aobb tree
be m bf

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

m aobb tree
be m bf

time vs m  segmentation        s binary

time vs m  segmentation       s binary

                  i  

                  i   

     

 

    

 

time  sec

time  sec

m a  tree
m bb tree

                   i  

 e 

   

    

 

    

 

    

 

 

   

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

   

m aobb tree
be m bf

    

     

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

m aobb tree
be m bf

time vs m  segmentation        s binary

time vs m  segmentation       s binary

                  i  

                  i   

     

 

    

 

time  sec

time  sec

     

nodes vs m  protein  pdb b v

                  i  

 e 

    

number solutions

    

 

    
    

 

 

 
   

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

   

m aobb tree
be m bf

    

number solutions

m aobf tree
m aobf graph

m a  tree
m bb tree

     

m aobb tree
be m bf

figure     cpu time seconds number expanded nodes function number solutions  protein segmentation    gb    hours 

   

fis earching b est olutions g raphical odels

algorithm

solved
m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
be m bf

segmentation    inst     n        
k       w         ht         i bound   
m  
m  
m  
m   
m    
 bt    bn  bt    bn  bt    bn  bt    bn  bt    bn
  
  
  
  
  
   
   
   
   
   
   
   
      
      
      
      
      
      
      
   
   
   
   
   
   
   
   
   
   
   
       
       
       
      
       

table     number instances  algorithm best runtime   bt  best number expanded nodes   bn   segmentation     instances   exact heuristics 
table accounts remaining     i bound      

benchmark
random trees
random binary grids
random submodular graphs

  inst
  
  
  

n
       
       
       

k
   
 
 

w
 
    
    

ht
     
     
     

table     benchmark parameters    inst   number instances  n   number variables  k   domain
size  w   induced width  ht   pseudo tree height 

stilars nilssons schemes always dominated two competing schemes
terms runtime  stripes pesteelars sometimes faster schemes
m    e g  tree nnodes    ps  k   however  three benchmark scale rather poorly
m    almost always inferior algorithms  provided latter report
results  occasional exception m aobb tree  tends slow large m 
problems pesteelars stripes superior search schemes
largest networks      variables  grid nnodes     ps  k  
infeasible algorithms  overall  five m best algorithms proved superiority
considered competing schemes majority instances  often better runtime  especially
     guaranteeing solution optimality 

   conclusion
work finding best solutions graphical models focused either iterative
schemes based lawlers idea dynamic programming  e g   variable elimination treeclustering   showed first time combinatorial optimization defined graphical
models traditional heuristic search paradigms directly applicable  often superior 
specifically  extended best first depth first branch bound search algorithms solve
m best optimization task  presenting m a  m bb  respectively  showed properties a  extend m a  algorithm and  particular  proved m a  superior
   

fif lerova   arinescu     echter

instance

tree nnodes    ps  k 

               

tree nnodes    ps  k 

               

tree nnodes     ps  k 

                 

algorithm

i bound    k  
m  
m   
time
time
    
    
    
    
    
    
    
    
    
     
    
    
   
    
    
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
stilars
stripes
pesteelars

m  
time
    
    
   
   
    
   
    
   

m  
time
    
    
   
   
    
    
    
    

m    
time
    
    
    
    
       
       
     
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
stilars
stripes
pesteelars

   
    
    
   
    
   
    
   

    
    
    
   
    
    
     
    

    
   
    
    
     
     
     
    

   
    
    
    
      
     
     
    

oom
oom
    
     
timeout
       
      
    

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
stilars
stripes
pesteelars

oom
oom
    
    
      
    
      
    

oom
oom
     
     
      
    
      
     

oom
oom
     
     
timeout
     
       
     

oom
oom
     
     
timeout
      
       
      

oom
oom
      
      
timeout
      
timeout
timeout

table     random trees  i bound    timeout   time  oom   memory    gb    hour 
search scheme m best task  analyzed overhead algorithms caused
need find multiple solutions  introduced be m bf  hybrid variable elimination
best first search scheme showed best worst case time complexity among
m best algorithms graphical models known us 
evaluated schemes empirically  observed and or decomposition
search space  significantly boosts performance traditional heuristic search schemes 
cost effective m best search algorithms  least current implementation 
expected  best first schemes dominate branch bound algorithms whenever sufficient
space available  fail memory intensive problems  compared schemes  
previously developed algorithms  three approximate schemes based lp relaxation problem algorithm performing message passing junction tree  showed schemes
often dominate competing schemes  known efficient  terms runtime  especially
required number solutions large  moreover  scheme guarantee solution optimality 

acknowledgement
work sponsored part nsf grants iis         iis          united
states air force contract no  fa        c      darpa ppaml program 

   

fis earching b est olutions g raphical odels

instance

grid nnodes    ps  k 

                 

grid nnodes    ps  k 

                

grid nnodes     ps  k 

                  

algorithm

m  
time
random binary grid

i bound   
m  
m   
time
time

m   
time

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

oom
oom
    
    
     
     
    
    

oom
oom
    
    
      
      
     
    

oom
oom
    
    
      
       
      
     

oom
oom
    
    
       
       
      
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

oom
oom
   
    
    
     
    
    

oom
oom
    
    
     
      
     
    

oom
oom
    
    
     
       
     
     

oom
oom
    
    
       
      
timeout
timeout

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

oom
oom
oom
timeout
timeout
oom
      
     

oom
oom
oom
timeout
timeout
oom
      
     

oom
oom
oom
timeout
timeout
oom
       
      

oom
oom
oom
timeout
timeout
oom
timeout
timeout

table     random binary grids  i bound     timeout   time  oom   memory    gb 
  hour 

   

fif lerova   arinescu     echter

instance

gen nnodes    ps  k 

                

gen nnodes    ps  k 

                

gen nnodes     ps  k 

                  

algorithm

i bound   
m  
m   
time
time
    
    
    
    
    
    
   
    
    
    
     
      
    
    
    
     

m   
time
    
    
    
    
      
      
     
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

m  
time
    
    
   
   
    
    
   
   

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

oom
oom
    
    
     
      
    
    

oom
oom
    
    
      
     
   
     

oom
oom
    
    
      
       
     
     

oom
oom
    
    
       
       
    
     

m aobf tree
m aobf graph
m a  tree
m bb tree
m aobb tree
nilsson
stripes
pesteelars

oom
oom
oom
timeout
timeout
oom
     
    

oom
oom
oom
timeout
timeout
oom
     
     

oom
oom
oom
timeout
timeout
oom
      
     

oom
oom
oom
timeout
timeout
oom
     
     

table     random loopy graphs submodular potentials  i bound     timeout   time 
oom   memory    gb    hour 

   

fis earching b est olutions g raphical odels

figure     example and or search tree   layers nodes 

appendix a  proof theorem   
let st and or search tree relative pseudo tree depth h  n number
variables  k maximum domain size  deg maximum degree nodes  
define partial solution subtree   subtree st that        contains root
st       non terminal node n       contains exactly one child node n 
n      non terminal node n     contains child nodes n             n j n 
    leaf tip node   doesnt successors    
nodes st grouped layers  h layers ith layer  denoted
li     h  contains nodes whose variables depth   together
children  assume root depth    illustration  figure    depicts
and or search tree   layers  example l     a  ha   i  ha   i  
denote tior set partial solution subtrees whose leaf nodes nodes li  
similarly  tian set partial solution subtrees whose leaf nodes nodes li  
partial solution subtree   t or whose leaf nodes nodes belonging  nd layer
highlighted figure     namely      a  ha   i  b  c  
l emma    given   tior    tian    extension         
number leaf nodes 
proof  let number leaf nodes     definition  nodes
extended exactly one child node      follows    leaf nodes 
l emma    given   tior   number leaf nodes     denoted mi   deg i   
proof  show induction mi   deg i        m       assume   p   
  first extend        lemma        
mp    deg p    let   tp 
p 
number leaf nodes  namely mp    next  extend        tpor   since
mp  leaf nodes    deg child nodes       follows mp  
number leaf nodes     mp   mp  deg   deg p  deg   deg p   
proof theorem    consider number partial solution subtrees n contained st  
   

fif lerova   arinescu     echter

n 

h
x

 nior   nian  

   

i  

nior


   tior   nian    tian    respectively 
 
  easy see   extended single partial solution subtree
given ti 
  

ti leaf nodes   deg child nodes      therefore 

nior   ni 

   

given   tior     extended k partial solution subtrees    tian
leaf nodes   exactly one child node    k
bounds domain size  lemmas      that 
nian   nior k deg

i 

   

using equations      well n or      rewrite equation   follows 
n        k 
   k   k deg    
   k deg     k deg

   deg  

 
   

     
   k deg
o k

h   deg h        

deg h  
deg 

  k deg

h   deg h        

 

 

thus  worst case number partial solution subtrees need stored open
h 
h 
n o k deg    therefore  time space complexity m aobf follows o k deg   
pseudo tree balanced  namely internal node exactly deg child nodes 
time space complexity bound o k n    since n o deg h    

references
aljazzar  h     leue  s          k   heuristic search algorithm finding k shortest paths 
artificial intelligence                    
batra  d          efficient message passing algorithm m best map problem  uncertainty
artificial intelligence 
charniak  e     shimony  s          cost based abduction map explanation  artificial intelligence                
darwiche  a          decomposable negation normal form  journal acm  jacm         
       
darwiche  a   dechter  r   choi  a   gogate  v     otten  l         
results probablistic inference evaluation uai    web report
http   graphmod ics uci edu uai   evaluation report 
in  uncertainty artificial intelligence applications workshop 
   

fis earching b est olutions g raphical odels

de campos  l  m   gamez  j  a     moral  s          partial abductive inference bayesian belief
networks using genetic algorithm  pattern recognition letters                   
de campos  l  m   gamez  j  a     moral  s          partial abductive inference bayesian networks using probability trees  enterprise information systems v  pp          springer 
dechter  r          bucket elimination  unifying framework reasoning  artificial intelligence 
             
dechter  r     mateescu  r          and or search spaces graphical models  artificial intelligence                  
dechter  r     rish  i          mini buckets  general scheme bounded inference  journal
acm                
dechter  r          reasoning probabilistic deterministic graphical models  exact algorithms  synthesis lectures artificial intelligence machine learning             
dechter  r     pearl  j          generalized best first search strategies optimality a  
journal acm  jacm                 
dijkstra  e  w          note two problems connexion graphs  numerische mathematik 
             
elliott  p          extracting k best solutions valued and or acyclic graph  masters
thesis  massachusetts institute technology 
eppstein  d          finding k shortest paths  proceedings   th symposium foundations computer science  pp          ieee comput  soc  press 
fishelson  m     geiger  d          exact genetic linkage computations general pedigrees 
international conference intelligent systems molecular biology  ismb   pp         
fishelson  m  a   dovgolevsky  n     geiger  d          maximum likelihood haplotyping
general pedigrees  human heredity              
flerova  n   dechter  r     rollon  e          bucket mini bucket schemes best solutions
graphical models  graph structures knowledge representation reasoning
workshop 
fromer  m     globerson  a          lp view m best map problem  advances neural
information processing systems             
ghosh  p   sharma  a   chakrabarti  p     dasgupta  p          algorithms generating ordered
solutions explicit and or structures  journal artificial intelligence  jair         
       
gogate  v  g          sampling algorithms probabilistic graphical models determinism
dissertation  ph d  thesis  university california  irvine 
hamacher  h     queyranne  m          k best solutions combinatorial optimization problems 
annals operations research               
ihler  a  t   flerova  n   dechter  r     otten  l          join graph based cost shifting schemes 
arxiv preprint arxiv           
kask  k     dechter  r       a   branch bound mini bucket heuristics  ijcai  vol     
pp         
   

fif lerova   arinescu     echter

kask  k     dechter  r       b   mini bucket heuristics improved search  proceedings
fifteenth conference uncertainty artificial intelligence  pp          morgan
kaufmann publishers inc 
kjrulff  u          triangulation graphsalgorithms giving small total state space  tech  report
r       
lawler  e          procedure computing k best solutions discrete optimization problems
application shortest path problem  management science                
marinescu  r     dechter  r       a   and or branch and bound search combinatorial optimization graphical models  artificial intelligence                       
marinescu  r     dechter  r       b   memory intensive and or search combinatorial optimization graphical models  artificial intelligence                       
marinescu  r     dechter  r          and or branch and bound graphical models  international joint conference artificial intelligence  vol      p       lawrence erlbaum
associates ltd 
nillson  n  j          principles artificial intelligence  tioga  palo alto  ca 
nilsson  d          efficient algorithm finding probable configurations probabilistic expert systems  statistics computing               
nilsson  n          principles artificial intelligence  springer verlag 
otten  l     dechter  r          anytime and or depth first search combinatorial optimization  socs 
pearl  j          heuristics  intelligent search strategies  addison wesley 
schiex  t          arc consistency soft constraints  international conference principles
practice constraint programming  cp          
seroussi  b     golmard  j          algorithm directly finding k probable configurations bayesian networks  international journal approximate reasoning            
    
wainwright  m  j     jordan  m  i          variational inference graphical models  view
marginal polytope  proceedings annual allerton congerence communication
control computing  vol      pp          citeseer 
wemmenhove  b   mooij  j  m   wiegerinck  w   leisink  m   kappen  h  j     neijt  j  p         
inference promedas medical expert system  artificial intelligence medicine  pp 
        springer 
yanover  c     weiss  y          finding probable configurations using loopy belief
propagation  advances neural information processing systems     mit press 
yanover  c   schueler furman  o     weiss  y          minimizing learning energy functions
side chain prediction  journal computational biology                

   


