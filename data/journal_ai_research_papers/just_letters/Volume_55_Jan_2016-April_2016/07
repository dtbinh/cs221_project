journal artificial intelligence research                  

submitted          published        

parallel model based diagnosis multi core computers
dietmar jannach
thomas schmitz

dietmar jannach tu dortmund de
thomas schmitz tu dortmund de

tu dortmund  germany

kostyantyn shchekotykhin

kostyantyn shchekotykhin aau at

alpen adria university klagenfurt  austria

abstract
model based diagnosis  mbd  principled domain independent way analyzing system examination behaving expected  given abstract
description  model  systems components behavior functioning normally  mbd techniques rely observations actual system behavior reason
possible causes discrepancies expected observed behavior  due generality  mbd successfully applied variety application
domains last decades 
many application domains mbd  testing different hypotheses reasons
failure computationally costly  e g   complex simulations system behavior performed  work  therefore propose different schemes
parallelizing diagnostic reasoning process order better exploit capabilities
modern multi core computers  propose systematically evaluate parallelization
schemes reiters hitting set algorithm finding leading minimal diagnoses using two different conflict detection techniques  furthermore  perform initial
experiments basic depth first search strategy assess potential parallelization
searching one single diagnosis  finally  test effects parallelizing direct
encodings diagnosis problem constraint solver 

   introduction
model based diagnosis  mbd  subfield artificial intelligence concerned
automated determination possible causes system behaving expected 
early days mbd  diagnosed systems typically hardware artifacts
electronic circuits  contrast earlier heuristic diagnosis approaches connected
symptoms possible causes  e g   expert rules  buchanan   shortliffe        
mbd techniques rely abstract explicit representation  model  examined
system  models contain information systems structure  i e   list
components connected  well information behavior
components functioning correctly  model available  expected behavior  outputs  system given inputs thus calculated  diagnosis problem
arises whenever expected behavior conflicts observed system behavior  mbd
techniques core construct test hypotheses faultiness individual
components system  finally  diagnosis considered subset components
that  assumed faulty  explain observed behavior system 
reiter        suggests formal logical characterization diagnosis problem
first principles proposed breadth first tree construction algorithm determine
c
    
ai access foundation  rights reserved 

fijannach  schmitz    shchekotykhin

diagnoses given problem  due generality used knowledge representation
language suggested algorithms computation diagnoses  mbd
later applied variety application problems hardware  application
fields mbd  example  include diagnosis knowledge bases ontologies  process
specifications  feature models  user interface specifications user preference statements 
various types software artifacts including functional logic programs well
vhdl  java spreadsheet programs  felfernig  friedrich  jannach    stumptner       
mateis  stumptner  wieland    wotawa        jannach   schmitz        wotawa      b 
felfernig  friedrich  isak  shchekotykhin  teppan    jannach        console  friedrich 
  dupre        friedrich   shchekotykhin        stumptner   wotawa        friedrich 
stumptner    wotawa        white  benavides  schmidt  trinidad  dougherty    cortes 
      friedrich  fugini  mussi  pernici    tagni        
several application fields  search diagnoses requires repeated computations based modified versions original model test different hypotheses
faultiness individual components  several works original problem
converted constraint satisfaction problem  csp  number relaxed versions
original csp solved construct new node search tree  felfernig
et al         jannach   schmitz        white et al          depending application domain  computation csp solutions check consistency can  however 
computationally intensive actually represents costly operation
construction search tree  similar problems arise underlying reasoning
techniques  e g   ontology debugging  friedrich   shchekotykhin         used 
current mbd algorithms sequential nature generate one node time 
therefore  exploit capabilities todays multi core computer processors 
nowadays found even mobile devices  paper  propose new schemes
parallelize diagnostic reasoning process better exploit available computing
resources modern computer hardware  particular  work comprises following
algorithmic contributions insights based experimental evaluations 
propose two parallel versions reiters        sound complete hitting set
 hs  algorithm speed process finding diagnoses  common
problem setting above described mbd applications  approaches
considered window based parallelization schemes  means limited number search nodes processed parallel point time 
evaluate two different conflict detection techniques multi core setting 
goal find leading diagnoses  set experiments  multiple conflicts computed construction tree node using novel
mergexplain method  mxp   shchekotykhin  jannach    schmitz       
processing time therefore implicitly allocated conflict generation 
demonstrate speedups achieved parallelization scenarios search one single diagnosis  e g   using basic parallel
depth first strategy 
measure improvements achieved parallel constraint solving
using direct csp based encoding diagnosis problem  experiment
   

fiparallel model based diagnosis multi core computers

illustrates parallelization underlying solvers  particular using
direct encoding  advantageous 
evaluate proposed parallelization schemes extensive set experiments  following problem settings analyzed 
 i  standard benchmark problems diagnosis research community 
 ii  mutated csps constraint programming competition domain
csp based spreadsheet debugging  jannach   schmitz        
 iii  faulty owl ontologies used evaluation mbd based debugging techniques
expressive ontologies  shchekotykhin  friedrich  fleiss    rodler        
 iv  synthetically generated problems allow us vary characteristics
underlying diagnosis problem 
results show using parallelization techniques help achieve substantial
speedups diagnosis process  a  across variety application scenarios   b  without
exploiting specific knowledge structure underlying diagnosis problem 
 c  across different problem encodings   d  application problems ontology
debugging cannot efficiently encoded sat problems 
outline paper follows  next section  define main concepts
mbd introduce algorithm used compute diagnoses  section    present
systematically evaluate parallelization schemes reiters hs tree method
goal find minimal diagnoses  section    report results evaluations
implicitly allocate processing time conflict generation using mxp
conflict detection  section   assess potential gains comparably simple
randomized depth first strategy hybrid technique problem finding one
single diagnosis  results experiments direct csp encoding reported
section    section   discuss previous works  paper ends summary
outlook section   

   reiters diagnosis framework
section summarizes reiters        diagnosis framework use basis
work 
    definitions
reiter        formally characterized model based diagnosis using first order logic 
main definitions summarized follows 
definition       diagnosable system  diagnosable system described pair  sd 
comps  sd system description  a set logical sentences  comps represents
systems components  a finite set constants  
connections components normal behavior components
described terms logical sentences  normal behavior system components
   

fijannach  schmitz    shchekotykhin

usually described sd help distinguished negated unary predicate ab    
meaning abnormal 
diagnosis problem arises observation p obs systems input output
behavior  again expressed first order sentences  deviates expected system behavior  diagnosis corresponds subset systems components
assume behave abnormally  be faulty  assumptions must consistent
observations  words  malfunctioning components
possible reason observations 
definition       diagnosis  given diagnosis problem  sd  comps  obs   diagnosis
subset minimal set comps sd obs tab c  c p u abpcq c p
compszu consistent 
according definition      interested minimal diagnoses  i e   diagnoses
contain superfluous elements thus supersets diagnoses  whenever use term diagnosis remainder paper  therefore mean minimal
diagnosis  whenever refer non minimal diagnoses  explicitly mention fact 
finding diagnoses theory done simply trying possible subsets
comps checking consistency observations  reiter         however 
proposes efficient procedure based concept conflicts 
definition       conflict  conflict  sd  comps  obs  set tc         ck u comps
sd obs abpc  q       abpck qu inconsistent 
conflict corresponds subset components which  assumed behave normally 
consistent observations  conflict c considered minimal 
proper subset c exists conflict 
    hitting set algorithm
reiter        discusses relationship conflicts diagnoses claims
theorem     set diagnoses collection  minimal  conflicts f
equivalent set h minimal hitting sets   f  
determine minimal hitting sets therefore diagnoses  reiter proposes
breadth first search procedure construction hitting set tree  hs tree   whose
construction guided conflicts  logic based definition mbd problem
 reiter         conflicts computed calls theorem prover  tp   tp
component considered black box assumptions made
conflicts determined  depending application scenario problem encoding 
one can  however  use specific algorithms quickxplain  junker         progression  marques silva  janota    belov        mergexplain  shchekotykhin et al         
guarantee computed conflict sets minimal 
main principle hs tree algorithm create search tree node
either labeled conflict represents diagnosis  latter case node
expanded  otherwise  child node generated element nodes
   given collection c subsets finite set s  hitting set c subset contains
least one element subset c  corresponds set cover problem 

   

fiparallel model based diagnosis multi core computers

conflict outgoing edge labeled one component nodes conflict 
subsequent expansions node components used label edges
path root tree current node assumed faulty  newly
generated child node either diagnosis labeled conflict
contain component already assumed faulty stage  conflict
found node  path labels represent diagnosis sense definition     
      example
following example show hs tree algorithm quickxplain
 qxp  conflict detection technique combined locate fault specification
csp  csp instance defined tuple pv  d  cq  v tv            vn u
set variables  td            dn u set domains variables v  
c tc            ck u set constraints  assignment subset x v set
pairs txv    d  y          xvk   dm yu vi p x variable dj p di value
domain variable  assignment comprises exactly one variable value pair
variable x  constraint ci p c defined list variables s  called scope 
forbids allows certain simultaneous assignments variables scope 
assignment satisfies constraint ci comprises assignment allowed ci  
assignment solution satisfies constraints c 
consider csp instance variables v ta  b  cu variable
domain t       u following set constraints defined 
c    b 

c    b c 

c    c a 

c    b c

obviously  solution exists diagnosis problem consists finding subsets
constraints whose definition faulty  engineer modeled csp could 
example  made mistake writing c   b c 
eventually  c  added later correct problem  engineer forgot remove
c   given faulty definition i  two minimal conflicts exist  namely ttc   c   c u 
tc   c uu  determined help qxp  given two conflicts 
hs tree algorithm finally determine three minimal hitting sets ttc u  tc   c u 
tc   c uu  diagnoses problem instance  set diagnoses contains
true cause error  definition c  
let us review detail hs tree qxp combination works example problem  illustrate tree construction figure    logic based definition
reiter  hs tree algorithm starts check observations obs consistent
system description sd components comps  application setting
corresponds check exists solution csp instance   since
case  qxp call made  returns conflict tc   c   c u  used
label root node       tree  element conflict  child node
created conflict element used path label  tree node  consistency sd  obs  comps tested  time  however  elements appear
   comps constraints tc    c u sd corresponds semantics logic constraints
working correctly  e g   abpc q   pa bq  obs empty example could partial value
assignment  test case  another scenario 

   

fijannach  schmitz    shchekotykhin

 
 c  c   c  
c 

 

c 

c 

 

 c  c  
 

c 

 c  c  

c 

c 

c 
 

figure    example hs tree construction 
labels path root node current node considered abnormal 
csp diagnosis setting  means check solution modified
version original csp remove constraints appear labels
path root current node 
node     c  correspondingly considered abnormal  removing c 
csp is  however  sufficient solution exists relaxed problem  another call
qxp made  returns conflict tc   c u  tc u therefore diagnosis
new conflict used label node     algorithm proceeds breadth first
style tests assuming tc u tc u individually faulty consistent
observations  case means solution relaxed csp exists  since tc u
diagnosis least one solution exists c  removed csp definition
node marked   expanded  node     correspond
diagnosis  already known conflict tc   c u reused overlap
nodes path label call p  qxp  required  last tree level 
nodes     expanded  closed marked    tc u
already identified diagnosis previous level resulting diagnoses would
supersets tc u  finally  sets tc   c u tc   c u identified additional
diagnoses 
      discussion
soundness completeness according reiter         breadth first construction scheme node closing rule ensure minimal diagnoses computed 
end hs tree construction process  set edge labels path
root tree node marked   corresponds diagnosis  
greiner  smith  wilkerson         later on  identified potential problem reiters
algorithm cases conflicts returned p guaranteed minimal 
extension algorithm based hs dag  directed acyclic graph  structure
proposed solve problem 
context work  use methods return conflicts guaranteed minimal  example  according theorem   work junker        
given set formulas sound complete consistency checker  qxp always returns
   reiter        states theorem     given set conflict sets f   hs tree algorithm outputs
pruned tree set thpnq n node labeled  u corresponds set h
minimal hitting sets f hpnq set arc labels path node n root 

   

fiparallel model based diagnosis multi core computers

either minimal conflict conflict  minimality guarantee turn means
combination hs tree algorithm qxp sound complete  i e   returned
solutions actually  minimal  diagnoses diagnosis given set conflicts
missed  holds computing multiple conflicts time mxp
 shchekotykhin et al         
simplify presentation parallelization approaches  therefore rely
reiters original hs tree formulation  extension deal hs dag structure
 greiner et al         possible 
on demand conflict generation complexity many above mentioned
applications mbd practical problems  conflicts computed on demand 
i e   tree construction  cannot generally assume set minimal
conflicts given advance  depending problem setting  finding conflicts
therefore computationally intensive part diagnosis process 
generally  finding hitting sets collection sets known np hard problem
 garey   johnson         moreover  deciding additional diagnosis exists conflicts
computed demand np complete even propositional horn theories  eiter  
gottlob         therefore  number heuristics based  approximate thus incomplete 
well problem specific diagnosis algorithms proposed years 
discuss approaches later sections  next section  we  however  focus
 worst case  application scenarios goal find minimal diagnoses given
problem  i e   focus complete algorithms 
consider  example  problem debugging program specifications  e g   constraint
programs  knowledge bases  ontologies  spreadsheets  mbd techniques mentioned
above  application domains  typically sufficient find one minimal diagnosis  work jannach schmitz         example  spreadsheet developer
presented ranked list sets formulas  diagnoses  represent possible
reasons certain test case failed  developer either inspect
individually provide additional information  e g   test cases  narrow set
candidates  one diagnosis computed presented  developer would
guarantee true cause problem  lead limited acceptance
diagnosis tool 

   parallel hs tree construction
section present two sound complete parallelization strategies reiters
hs tree method determine minimal diagnoses 
    non recursive hs tree algorithm
use non recursive version reiters sequential hs tree algorithm basis
implementation two parallelization strategies  algorithm   shows main loop
breadth first procedure  uses list open nodes expanded central data
structure 
algorithm takes diagnosis problem  dp  instance input returns set
diagnoses  dp given tuple  sd  comps  obs   sd system
   

fijannach  schmitz    shchekotykhin

algorithm    diagnose  main algorithm loop 
input  diagnosis problem  sd  comps  obs 
result  set diagnoses
 
 
 
 
 
 
 
 
 

h  paths h  conflicts h 
nodestoexpand   xgeneraterootnode sd  comps  obs y 
nodestoexpand x
newnodes   x y 
node   head nodestoexpand   
foreach c p node conflict
generatenode node  c    paths  conflicts  newnodes  
nodestoexpand   tail nodestoexpand  newnodes 
return  

algorithm    generatenode  node generation logic 
input  existingnode expand  conflict element c p comps 
sets   paths  conflicts  newnodes
 
 
 
 
 
 
 
 
 
  
  
  
  

newpathlabel   existingnode pathlabel  c  
pe l p   l newpathlabelq   checkandaddpathppaths  newpathlabelq
node   new node newpathlabel  
p conflicts   x newpathlabel h
node conflict   s 
else
newconflicts   checkconsistency sd  comps  obs  node pathlabel  
node conflict   head newconflicts  
node conflict h
newnodes   newnodes xnodey 
conflicts   conflicts newconflicts 
else
 node pathlabel  

description  comps set components potentially faulty obs set
observations  method generaterootnode creates initial node  labeled
conflict empty path label  within loop  first element firstin first out  fifo  list open nodes nodestoexpand taken current element 
function generatenode  algorithm    called element nodes conflict
adds new leaf nodes  still explored  global list  new
nodes appended    remaining list open nodes main loop 
   

fiparallel model based diagnosis multi core computers

continues elements remain expansion   algorithm    generatenode 
implements node generation logic  includes reiters proposals conflict re use 
tree pruning  management lists known conflicts  paths diagnoses 
method determines path label new node checks new path label
superset already found diagnosis 
algorithm    checkandaddpath  adding new path label redundancy
check 
input  previously explored paths  newpathlabel explored
result  boolean stating newpathlabel added paths

 

e l p paths   l newpathlabel
paths   paths newpathlabel 
return true 

 

return false 

 
 

function checkandaddpath  algorithm    used check node
already explored elsewhere tree  function returns true new path label
successfully inserted list known paths  otherwise  list known paths
remains unchanged node closed 
new nodes  either existing conflict reused new one created call
consistency checker  theorem prover   tests new node diagnosis
returns set minimal conflicts otherwise  depending outcome  new node
added list nodestoexpand diagnosis stored  note algorithm  
return value instead modifies sets   paths  conflicts  newnodes 
passed parameters 
    level wise parallelization
first parallelization scheme examines nodes one tree level parallel proceeds
next level elements level processed  example shown
figure    would mean computations  consistency checks theorem prover
calls  required three first level nodes labeled tc u  tc u  tc u done
three parallel threads  nodes next level explored threads
previous level finished 
using level wise parallelization  lwp  scheme  breadth first character maintained  parallelization computations generally feasible consistency
checks node done independently done nodes
level  synchronization required make sure thread starts exploring
path already examination another thread 
algorithm   shows sequential algorithm   adapted support
parallelization approach  again  maintain list open nodes expanded 
difference run expansion nodes parallel collect
   limitation regarding search depth number diagnoses find easily integrated
scheme 

   

fijannach  schmitz    shchekotykhin

algorithm    diagnoselw  level wise parallelization 
input  diagnosis problem  sd  comps  obs 
result  set diagnoses
 
 
 
 
 
 
 
 
 
  

h  conf licts h  paths   h 
nodestoexpand   xgeneraterootnode sd  comps  obs y 
nodestoexpand x
newnodes   x y 
foreach node p nodestoexpand
foreach c p node conflict
   computations parallel
threads execute generatenode node  c    paths  conflicts  newnodes   
threads await   
nodestoexpand   newnodes 

   wait current level complete
   prepare next level

return  

nodes next level variable newnodes  current level finished 
overwrite list nodestoexpand list containing nodes next level 
java like api calls used pseudo code algorithm   interpreted
follows  statement threads execute   takes function parameter schedules
execution pool threads given size  thread pool of  e g   size   
generation first two nodes would done parallel next ones would
queued one threads finished  mechanism  ensure
number threads executed parallel less equal number hardware
threads cpus 
statement threads await   used synchronization blocks execution
subsequent code scheduled threads finished  guarantee
path explored twice  make sure two threads parallel add node
path label list known paths  achieved declaring
function checkandaddpath critical section  dijkstra         means
two threads execute function parallel  furthermore  make access
global data structures  e g   already known conflicts diagnoses  thread safe 
i e   ensure two threads simultanuously manipulate them  
    full parallelization
lwp  situations computation conflict specific node
takes particularly long  this  however  means even nodes current
level finished many threads idle  expansion hs tree cannot proceed
level completed  algorithm   shows proposed full parallelization  fp 
algorithm variant  immediately schedules every expandable node execution
thereby avoids potential cpu idle times end level 
   controlling concurrency aspects comparably simple modern programming languages java 
e g   using synchronized keyword 

   

fiparallel model based diagnosis multi core computers

algorithm    diagnosefp  full parallelization 
input  diagnosis problem  sd  comps  obs 
result  set diagnoses
 
 
 
 
 
 
 
 

 
  
  
  

h  paths h  conflicts h 
nodestoexpand   xgeneraterootnode sd  comps  obs y 
size      lastsize     
psizelastsizeq   pthreads activethreads  q
  size lastsize
node   nodestoexpand get lastsize   i  
foreach c p node conflict
threads execute generatenodefp node  c    paths  conflicts 
nodestoexpand   
lastsize   size 
wait   
size   nodestoexpand length   
return  

main loop algorithm slightly different basically monitors list
nodes expand  whenever new entries list observed  i e   last observed
list size different current one  retrieves recently added elements adds
thread queue execution  algorithm returns diagnoses new
elements added since last check threads active  
fp  search necessarily follow breadth first strategy anymore
non minimal diagnoses found process  therefore  whenever find new
diagnosis d  check set known diagnoses contains supersets
remove  
updated generatenode method listed algorithm    updating shared
data structures  nodestoexpand  conflicts     make sure threads
interfere other  mutual exclusive section marked synchronized
keyword 
compared lwp  fp wait end level specific
node takes particularly long generate  hand  fp needs synchronization
threads  cases last nodes level finished
time  lwp could advantageous  evaluate aspect section     
    properties algorithms
algorithm   together algorithms     corresponds implementation
hs tree algorithm  reiter         algorithm   implements breadth first search strategy
point     reiters hs tree algorithm since nodes stored list nodestoexpand
   functions wait   notify   implement semantics pausing thread awaking paused
thread java programming language used avoid active waiting loops 

   

fijannach  schmitz    shchekotykhin

algorithm    generatenodefp  extended node generation logic 
input  existingnode expand  c p comps 
sets   paths  conflicts  nodestoexpand
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  

  

newpathlabel   existingnode pathlabel  c  
pe l p   l newpathlabelq   checkandaddpathppaths  newpathlabelq
node   new node newpathlabel  
p conflicts   x newpathlabel h
node conflict   s 
else
newconflicts   checkconsistency sd  comps  obs  node pathlabel  
node conflict   head newconflicts  
synchronized
node conflict h
nodestoexpand   nodestoexpand xnodey 
conflicts   conflicts newconflicts 
else e p   newpathlabel
 node pathlabel  
p   newpathlabel
z d 
notify   

processed iteratively first in first out order  see lines       algorithm   first
checks pruning rules  i   ii  reiter applied line    rules state
node pruned  i  exists diagnosis  ii  set labels
corresponding path tree subset set labels
path node  pruning rule  ii  implemented algorithm    pruning rule  iii 
reiters algorithm necessary since settings tp  call guarantees return
minimal conflicts 
finally  point     reiters hs tree algorithm description implemented lines
    algorithm    here  algorithm checks conflict reused
node label  case reuse possible  algorithm calls theorem prover tp find
another minimal conflict  conflict found  node added list open nodes
nodestoexpand   otherwise  set node path labels added set diagnoses 
corresponds situation reiters algorithm would mark node
hs tree   symbol  note label nodes   done reiters
algorithms since simply store nodes expansion list 
overall  conclude hs tree algorithm implementation  algorithm  
   properties reiters original hs tree algorithm  namely  hitting set
returned algorithm minimal  soundness  existing minimal hitting sets
found  completeness  
   

fiparallel model based diagnosis multi core computers

      level wise parallelization  lwp 
theorem      level wise parallelization sound complete 
proof  proof based fact lwp uses expansion pruning
techniques sequential algorithm  algorithms       main loop line   applies
procedure original algorithm difference executions
algorithm   done parallel level tree  therefore  difference
sequential algorithm lwp lies order nodes one level
labeled generated 
let us assume two nodes n  n  tree sequential
hs tree algorithm process n  n    assuming neither n  n  correspond
diagnoses  sequential algorithm   would correspondingly first add child nodes
n  queue open nodes later append child nodes n   
parallelize computations needed generation n  n  lwp 
happen computations n  need longer n    case
child nodes n  placed queue first  order nodes
subsequently processed is  however  irrelevant computation minimal hitting
sets  since neither labeling pruning rules influenced it  fact 
labeling node n depends whether minimal conflict set f exists
hpnq x f h  nodes level  pruning rules
state node n pruned exists node n  labeled  
hpn  q hpnq  i e   supersets already found diagnoses pruned  n n 
level   hpnq   hpn  q   consequently  pruning rule applied
hpnq hpn  q  therefore  order nodes  i e   nodes pruned  irrelevant
minimal hitting set lost  consequently  lwp complete 
soundness algorithm follows fact lwp constructs hitting sets
always order increasing cardinality  therefore  lwp always return minimal hitting sets even scenarios stop k diagnoses found 
  k n predefined constant n total number diagnoses
problem 
      full parallelization  fp 
minimality hitting sets encountered search guaranteed fp 
since algorithm schedules node processing immediately generation  line  
algorithm     special treatment generatenodefp function ensures
supersets already found hitting sets added supersets newly found
hitting set removed thread safe manner  lines       algorithm     due
change generatenodefp  analysis soundness completeness
done two distinct cases 
theorem      full parallelization sound complete  applied find diagnoses
cardinality 
proof  fp stops either  i  hitting set exists  i e   leaf nodes tree
labeled either       ii  predefined cardinality  tree depth  reached 
latter case  every leaf node tree labeled either       minimal conflict
   

fijannach  schmitz    shchekotykhin

set  case  ii  reduced  i  removing branches tree labeled
minimal conflict  branches irrelevant since contribute
minimal hitting sets higher cardinality  therefore  without loss generality  limit
discussion case  i  
according definition generatenodefp  tree built using pruning
rule done sequential hs tree algorithm  consequence  tree generated
fp must comprise least nodes tree generated sequential hstree procedure  therefore  according theorem     work reiter       
tree generated fp must comprise set leaf nodes labeled  
set thpnq n node labeled  u corresponds set h minimal hitting
sets  moreover  result returned fp comprises minimal hitting sets 
generatenodefp removes hitting sets h supersets hitting sets 
consequently  fp sound complete  applied find diagnoses 
theorem      full parallelization cannot guarantee completeness soundness
applied find first k diagnoses  i e    k n   n total number
diagnoses problem 
proof  proof done constructing example fp returns least
one non minimal hitting set set   thus violating definition      instance 
situation might occur fp applied find one single diagnosis example problem
presented section        let us assume generation node corresponding
path c  delayed  e g   operating system scheduled another thread
execution first  node   correspondingly generated first  case  algorithm
would return non minimal hitting set tc   c u diagnosis 
note elements set returned fp case turned
diagnoses applying minimization algorithm inv quickxplain  shchekotykhin 
friedrich  rodler    fleiss         algorithm adopts principles quickxplain
applies divide and conquer strategy find one minimal diagnosis given set
inconsistent constraints 
given hitting set h diagnosis problem  algorithm capable computing
minimal hitting set h   h requiring op h      h     logp h   h    qqq calls theorem
prover tp  first part   h      reflects computational costs determining whether
h   minimal  second part represents number subproblems must
considered divide and conquer algorithm order find minimal hitting set h    
    evaluation
determine performance improvements achieved various forms
parallelization proposed paper  conducted series experiments diagnosis
problems number different application domains  specifically  used electronic
circuit benchmarks dx competition      synthetic track  faulty descriptions
constraint satisfaction problems  csps   well problems domain ontology
debugging  addition  ran experiments synthetically created diagnosis problems
analyze impact varying different problem characteristics  diagnosis algorithms
   

fiparallel model based diagnosis multi core computers

evaluated paper implemented java unless noted otherwise  generally 
use wall clock times performance measure 
main part paper  focus results dx competition
problems widely used benchmark  results problem
setups presented discussed appendix paper  cases 
results dx competition problems follow similar trend achieved
experiments 
section compare hs tree parallelization schemes lwp fp
sequential version algorithm  goal find diagnoses 
      dataset procedure
set experiments  selected first five systems dx competition     
synthetic track  see table     kurtoglu   feldman         system  competition specifies    scenarios injected faults resulting different faulty output values 
used system description given input output values diagnosis
process  additional information injected faults course ignored 
problems converted constraint satisfaction problems  experiments used
choco  prudhomme  fages    lorca        constraint solver qxp conflict
detection  returns one minimal conflict called node construction 
computation times required conflict identification strongly depend
order possibly faulty constraints  shuffled constraints test repeated
tests     times  report wall clock times actual diagnosis task  times
required input output independent hs tree construction scheme
relevant benchmarks  parallel approaches  used thread pool size
four  
table   shows characteristics systems terms number constraints
  c  problem variables   v    numbers injected faults   f 
numbers calculated diagnoses   d  vary strongly different scenarios
system  columns show ranges values scenarios 
columns  d  d  indicate average number diagnoses average cardinality 
seen  search tree diagnosis become extremely broad
      diagnoses average diagnosis size      system c    
      results
table   shows averaged results searching minimal diagnoses  first list
running times milliseconds sequential version  seq   improvements
lwp fp terms speedup efficiency respect sequential version 
speedup sp computed sp t   tp   t  wall time using   thread  the
sequential algorithm  tp wall time p parallel threads used  speedup
   four hardware threads reasonable assumption standard desktop computers mobile
devices  hardware used evaluation chapter laptop intel i      qm
cpu    gb ram  running windows   four cores hyperthreading  results
evaluation server hardware    cores reported later section 
   systems marked    search depth limited actual number faults ensure
sequential algorithm terminates within reasonable time frame 

   

fijannach  schmitz    shchekotykhin

system
     
  l  
      
      
c    

 c
  
  
  
  
   

 v
  
  
  
  
   

 f
   
   
   
   
   

 d
        
       
           
          
         

 d
     
    
       
     
       

 d 
    
    
    
    
    

table    characteristics selected dxc benchmarks 
  would therefore mean needed computation times halved  speedup   
theoretical optimum using   threads  means time reduced
one quarter  efficiency ep defined sp  p compares speedup
theoretical optimum  fastest algorithm system highlighted bold 
system
     
  l  
      
      
c    

seq  qxp 
 ms 
  
   
   
      
      

lwp qxp 
s 
e 
    
    
    
    
    
    
    
    
    
    

fp qxp 
s 
e 
         
         
         
         
         

table    observed performance gains dxc benchmarks searching diagnoses 

tests  parallelization approaches outperform sequential algorithm  furthermore  differences sequential algorithm one parallel approaches statistically significant  p              tested scenarios 
systems  fp efficient lwp speedups range          
 i e   reduction running times              scenarios
differences lwp fp statistically significant  trend
observed efficiency fp higher complex problems  reason
problems time needed node generation much larger absolute
numbers additional overhead times required thread synchronization 
      adding threads
use cases diagnosis process done powerful server architectures
often even cpu cores modern desktop computers  order assess
extent   threads help speed diagnosis process  tested
different benchmarks server machine    cpu cores  test compared
fp              threads sequential algorithm 
results dxc benchmark problems shown table    tested systems
diagnosis process faster using   instead   threads substantial speedups
     could achieved compared sequential diagnosis  corresponds
   

fiparallel model based diagnosis multi core computers

runtime reduction      one system  utilization    threads led
additional speedups  using    threads fastest     tested systems 
efficiency  however  degrades threads used  time needed
synchronization threads  using threads hardware actually cores
result additional speedups tested systems  reason
time threads busy conflict detection  e g   finding solutions csps 
use almost      processing power assigned them 
system
     
  l  
     
      
c    

seq  qxp 
 ms 
  
   
      
      
      

s 
    
    
    
    
    

e 
    
    
    
    
    

s 
    
    
    
    
    

fp qxp 
e 
s  
e  
              
              
              
              
              

s  
    
    
    
    
    

e  
    
    
    
    
    

table    observed performance gains dxc benchmarks server    hardware
threads 

      additional experiments
details additional experiments conducted compare proposed parallelization schemes sequential hs tree algorithm presented section a  
appendix  results show significant speedups achieved constraint satisfaction problems  section a      ontologies  section a       appendix
furthermore contains analysis effects adding threads benchmarks
csps ontologies  section a      presents results simulation experiment
systematically varied different problem characteristics  section a      
      discussion
overall  results evaluations show parallelization approaches help improve performance diagnosis process  tested scenarios approaches
achieved speedups  cases fp faster lwp  however  depending
specifics given problem setting  using lwp advantageous situations 
e g   time needed generate node small conflict generation time vary strongly  cases synchronization overhead needed
fp higher cost waiting threads finish  tested ontologies
section a      case four tested scenarios 
although fp average faster lwp significantly better sequential
hs tree construction approach  tested scenarios efficiency still far
optimum    explained different effects  example  effect
false sharing happen memory two threads allocated block
 bolosky   scott         every access memory block synchronized although
two threads really share memory  another possible effect called cache
   

fijannach  schmitz    shchekotykhin

contention  chandra  guo  kim    solihin         threads work different computing
cores share memory  cache misses occur often depending
problem characteristics thus theoretical optimum cannot reached cases 

   parallel hs tree construction multiple conflicts per node
sequential parallel version hs tree algorithm  theorem
prover tp call corresponds invocation qxp  whenever new node hs tree
created  qxp searches exactly one new conflict case none already known
conflicts reused  strategy advantage call tp immediately
returns one conflict determined  turn means parallel
execution threads immediately see new conflict shared data structures
can  best case  reuse constructing new nodes 
disadvantage computing one conflict time qxp search
conflicts restarted invocation  recently proposed new conflict detection
technique called mergexplain  mxp   shchekotykhin et al          capable
computing multiple conflicts one call  general idea mxp continue search
identification first conflict look additional conflicts remaining
constraints  or logical sentences  divide and conquer approach 
combined sequential hs tree algorithm  effect tree construction time initially spent conflict detection construction continues
next node  exchange  chances conflict available reuse increase
next nodes  time  identification conflicts less timeintensive smaller sets constraints investigated due divide and conquer
approach mxp  experimental evaluation various benchmark problems shows
substantial performance improvements possible sequential hs tree scenario
goal find leading diagnoses  shchekotykhin et al         
section  explore benefits using mxp parallel hs tree construction schemes proposed previous section  using mxp combination
multiple threads  implicit effect cpu processing power devoted conflict generation individual threads need time complete construction
new node  contrast sequential version  threads continue
work parallel 
next section  briefly review mxp algorithm report
results empirical evaluation benchmark datasets  section      
    background quickxplain mergexplain
algorithm   shows qxp conflict detection technique junker        applied
problem finding conflict diagnosis problem hs tree construction 
qxp operates two sets constraints  modified recursive calls 
background theory b comprises constraints considered anymore
part conflict current stage  beginning  set contains sd  obs 
   use term constraints original formulation  qxp independent
underlying reasoning technique  elements sets could general logical sentences well 

   

fiparallel model based diagnosis multi core computers

algorithm    quickxplain  qxp 
input  diagnosis problem  sd  comps  obs   set visitednodes elements
output  set containing one minimal conflict cs c
  b sd obs  ab c  c p visitednodes   c abpcq c p compszvisitednodesu 
  isconsistent b c  return conflict 
  else c h return h 
  return tc  abpcq p getconflictpb  b  cqu 
 
 
 
 
 
  

function getconflict  b  d  c 
h   isconsistent b  return h 
 c    return c 
split c disjoint  non empty sets c  c 
d  getconflict  b c    c    c   
d  getconflict  b d    d    c   
return d  d   

set nodes path current node hs tree  visited nodes  
set c represents set constraints search conflict 
conflict c empty  algorithm immediately returns  otherwise getconflict called  corresponds junkers qxp method minor difference
getconflict require strict partial order set constraints c 
introduce variant qxp since cannot always assume prior fault information
available would allow us generate order 
rough idea qxp relax input set faulty constraints c partitioning
two sets c  c    c  conflict  algorithm continues partitioning c 
next recursive call  otherwise  i e   last partitioning split conflicts c
conflicts left c    algorithm extracts conflict sets c 
c    way  qxp finally identifies individual constraints inconsistent
remaining consistent set constraints background theory 
mxp builds ideas qxp computes multiple conflicts one call  if
exist   general procedure shown algorithm    initial consistency checks 
method findconflicts called  returns tuple xc     y  c   set
remaining consistent constraints set found conflicts  function recursively
splits set c constraints two halves  parts individually checked
consistency  allows us exclude larger consistent subsets c search process 
besides potentially identified conflicts  calls findconflicts return two sets
constraints consistent  c   c   q  union two sets consistent 
look conflict within c   c    and background theory  style qxp 
details found earlier work  results in depth
experimental analysis reported  shchekotykhin et al         
   

fijannach  schmitz    shchekotykhin

algorithm    mergexplain  mxp 
input  diagnosis problem  sd  comps  obs   set visitednodes elements
output    set minimal conflicts
  b sd obs  ab c  c p visitednodes   c abpcq c p compszu 
 
isconsistentpbq return solution 
  isconsistentpb cq return h 
  x   findconflictspb  cq
  return tc  abpcq p   
 
 
 
 
  
  
  
  
  
  
  
  

function findconflicts  b  c  returns tuple xc    
isconsistent b c  return xc  hy 
 c    return xh  tcuy 
split c disjoint  non empty sets c  c 
xc       findconflictspb  c  q
xc       findconflictspb  c  q
     
isconsistentpc   c   bq
x getconflictpb c     c     c   q
cs x getconflictpb x  x  c   q
c   c   z tu p x
tcs u
return xc   c     y 

    evaluation
section evaluate effects parallelizing diagnosis process use
mxp instead qxp calculate conflicts   shchekotykhin et al        
focus finding limited set  five  minimal diagnoses 
      implementation variants
using mxp parallel tree construction implicitly means time allocated
conflict generation using qxp proceeding next node 
analyze extent use mxp beneficial tested three different strategies
using mxp within full parallelization method fp 
strategy      configuration simply called mxp instead qxp node
generation  whenever mxp finds conflict  added global list known conflicts
 re  used parallel threads  thread executes mxp node
generation continues next node mxp returns 
strategy      strategy implements variant mxp slightly complex 
mxp finds first conflict  method immediately returns conflict
calling thread continue exploring additional nodes  time  new background thread started continues search additional conflicts  i e   completes
work mxp call  addition  whenever mxp finds new conflict checks
already running node generation thread could reused conflict
   

fiparallel model based diagnosis multi core computers

available beforehand  case  search conflicts thread
stopped new conflict needed anymore  strategy     could theory result
better cpu utilization  wait mxp call finish
continue building hs tree  however  strategy leads higher synchronization
costs threads  e g   notify working threads newly identified conflicts 
strategy      finally  parallelized conflict detection procedure itself  whenever
set c constraints split two parts  first recursive call findconflicts
queued execution thread pool second call executed current thread 
calls finished  algorithm continues 
experimentally evaluated three configurations benchmark datasets 
results showed strategy     lead measurable performance improvements
compared strategy      additional communication costs seem higher
saved executing conflict detection process background
thread  strategy     applied combination strategies  similar
experiments reported sequential hs tree construction  shchekotykhin et al  
       additional performance gains could observed due higher synchronization
costs  limited effectiveness strategies         principle caused
nature benchmark problems strategies might advantageous
different problem settings  following  therefore report results
applying strategy     
      results dxc benchmark problems
results dxc benchmarks shown table    left side table shows
results using qxp right hand side shows results mxp 
speedups shown fp columns refer respective sequential algorithms using
conflict detection technique 
using mxp instead qxp favorable using sequential hs tree algorithm
reported work mxp  shchekotykhin et al          reduction
running times ranges          speedups obtained fp using
mxp comparable fp using qxp range            i e   lead
reduction running times      speedups achieved addition
speedups sequential algorithm using mxp could already achieve qxp 
best results printed bold face table   using mxp combination
fp consistently performs best  overall  using fp combination mxp
        faster sequential algorithm using qxp  tests indicate
parallelization method works well conflict detection techniques
complex qxp and  case  return one conflict call 
addition  investing time conflict detection situations goal find
leading diagnoses proves promising strategy 
      additional experiments discussion
ran additional experiments constraint problems ontology debugging problems  detailed results provided section a   
   

fijannach  schmitz    shchekotykhin

system
     
  l  
     
     
c   

seq  qxp 
 ms 
  
  
  
   
     

fp qxp 
s 
e 
         
         
         
         
         

seq  mxp 
 ms 
  
  
  
   
     

fp mxp 
s 
e 
         
         
         
         
         

table    observed performance gains dxc benchmarks  qxp vs mxp  

overall  results obtained embedding mxp sequential algorithm confirm
results shchekotykhin et al         using mxp favorable qxp
small problem instances  however  observe allocating
time conflict detection mxp parallel processing setup help
speedup diagnosis process search number leading diagnoses  bestperforming configuration across experiments using full parallelization method
combination mxp setup led shortest computation times   
   tested scenarios  dx benchmarks  csps  ontologies  

   parallelized depth first hybrid search
application domains mbd  finding minimal diagnoses either required
simply possible computational complexity application specific constraints allowed response times  settings  number algorithms
proposed years  example try find one minimal diagnoses
quickly find diagnoses certain cardinality  metodi  stern  kalech    codish       
feldman  provan    van gemund      b  de kleer         cases  algorithms
principle extended used find diagnoses  are  however  optimized
task 
instead analyzing various heuristic  stochastic approximative algorithms proposed literature individually respect potential parallelization 
analyze next section parallelization helpful already simple class
depth first algorithms  context  investigate measurable improvements
achieved without using  domain specific  heuristic  finally  propose
hybrid strategy combines depth first full parallel hs tree construction
conduct additional experiments assess strategy advantageous task
quickly finding one minimal diagnosis 
    parallel random depth first search
section introduces parallelized depth first search algorithm quickly find one single
diagnosis  different threads explore tree partially randomized form  call
scheme parallel random depth first search  prdfs  
   

fiparallel model based diagnosis multi core computers

      algorithm description
algorithm   shows main program recursive implementation prdfs  similar
hs tree algorithm  search diagnoses guided conflicts  time  however 
algorithm greedily searches depth first manner  diagnosis found 
checked minimality diagnosis contain redundant elements 
minimization non minimal diagnosis achieved calling method
inv quickxplain  shchekotykhin et al         simply trying remove one element
diagnosis checking resulting set still diagnosis 
algorithm    diagnoseprdfs  parallelized random depth first search 
input  diagnosis problem  sd  comps  obs  
number mindiags diagnoses find
result  set diagnoses
 
 
 
 
 
 
 
 

h  conflicts h 
rootnode   getrootnode sd  comps  obs  
  nbthreads
threads execute expandprdfs rootnode  mindiags    conflicts   
   mindiags
wait   
threads shutdownnow   
return  

idea parallelization approach algorithm start multiple threads
root node  threads perform depth first search parallel  pick
next conflict element explore randomized manner 
logic expanding node shown algorithm     first  conflict
given node copied  changes set constraints affect
threads  then  long enough diagnoses found  randomly chosen constraint
current nodes conflict used generate new node  expansion function
immediately called recursively new node  thereby implementing depth first
strategy  identified diagnosis minimized added list known
diagnoses  similar previous parallelization schemes  access global lists
known conflicts made thread safe  specified number diagnoses
found threads finished  statement threads shutdownnow   immediately stops
execution threads still running results returned  semantics
threads execute    wait    notify   section   
      example
let us apply depth first method example section        remember
two conflicts problem ttc   c   c u  tc   c uu  partially expanded tree
problem seen figure   
   

fijannach  schmitz    shchekotykhin

algorithm     expandprdfs  parallel random depth first node expansion 
input  existingnode expand  number mindiags diagnoses find 
sets conflicts
 
 
 
 
 
 
 
 
 
  
  
  

  
  
  
  
  
  

c   existingnode conflict clone   
   copy existingnodes conflict
   mindiags   c   
randomly pick constraint c c
c cztcu 
newpathlabel   existingnode pathlabel  c  
node   new node newpathlabel  
p conflicts   x newpathlabel h
node conflict   s 
else
node conflict   checkconsistency sd  comps  obs  node pathlabel  
node conflict h
   new conflict found
conflicts   conflicts node conflict 
   recursive call implements depth first search strategy
expandprdfs node  mindiags    conflicts  
else
   diagnosis found
diagnosis   minimize node pathlabel  
 diagnosis  
   mindiags
notify   

example  first root node   created conflict tc   c   c u
found  next  random expansion would  example  pick conflict element c 
generate node     node  conflict tc   c u computed tc u
alone diagnosis  since algorithm continues depth first manner 
pick one label elements node     e g   c  generate node    
node  consistency check succeeds  conflict computed algorithm
found diagnosis  found diagnosis tc   c u is  however  minimal contains
redundant element c   function minimize  called end algorithm
    therefore remove redundant element obtain correct diagnosis tc u 
used one thread example  one parallel threads would
probably started expanding root node using conflict element c   node     
case  single element diagnosis tc u would identified already first
level  adding parallel threads therefore help increase chances find one
hitting set faster different parts hs tree explored parallel 
instead random selection strategy  elaborate schemes pick next nodes
possible  e g   based application specific heuristics fault probabilities  one could
better synchronize search efforts different threads avoid duplicate calculations  conducted experiments algorithm variant used shared
   

fiparallel model based diagnosis multi core computers

 
 c  c   c  
c 

 

 

c 

c 

 c  c  
 

c 

 c  c  

c 

c 

c 

figure    example hs tree construction prdfs 
synchronized list open nodes avoid two threads generate identical sub tree
parallel  did  however  observe significantly better results method
shown algorithm   probably due synchronization overhead 
      discussion soundness completeness
every single thread depth first algorithm systematically explores full search space
based conflicts returned theorem prover  therefore  existing diagnoses
found parameter mindiags equal higher number actually
existing diagnoses 
whenever  potentially non minimal  diagnosis encountered  minimization process ensures minimal diagnoses stored list diagnoses  duplicate
addition diagnosis one threads last lines algorithm
prevented consider diagnoses equal contain set elements
set definition cannot contain element twice 
overall  algorithm designed find one diagnoses quickly  computation minimal diagnoses possible algorithm highly inefficient  e g   due
computational costs minimizing diagnoses 
    hybrid strategy
let us consider problem finding one minimal diagnosis  one easily imagine
choice best parallelization strategy  i e   breadth first depth first 
depend specifics given problem setting actual size existing
diagnoses  single element diagnosis exists  exploring first level hs tree
breadth first approach might best choice  see figure   a    depth first strategy
might eventually include element non minimal diagnosis  would
number additional calculations ensure minimality diagnosis 
if  contrast  smallest actually existing diagnosis cardinality of  e g   five 
breadth first scheme would fully explore first four hs tree levels
finding five element diagnosis  depth first scheme  contrast  might quickly find
   

fidiagnosis detected

jannach  schmitz    shchekotykhin

superset five element diagnosis  e g   six elements  needs six
additional consistency checks remove redundant element diagnosis  figure
  b   
diagnosis detected

diagnosis detected

 a  breadth first strategy advantageous 

 b  depth first strategy advantageous 

figure    two problem configurations different search strategies favorable 
since cannot know cardinality diagnoses advance  propose hybrid
strategy  half threads adopt depth first strategy half uses
fully parallelized breadth first regime  implement strategy  algorithms  
 fp     prdfs  started parallel algorithm allowed use one
half defined share available threads  coordination
two algorithms done help shared data structures contain known
conflicts diagnoses  enough diagnoses  e g  one  found  running threads
terminated
results returned 
diagnosis detected
    evaluation
evaluated different strategies efficiently finding one minimal diagnosis
set benchmark problems used previous sections  experiment
setup identical except goal find one arbitrary diagnosis
included additional depth first algorithms  order measure potential benefits
parallelizing depth first search  ran benchmarks prdfs   threads
  thread  latter setup corresponds random depth first search
 rdfs  without parallelization 
      results dxc benchmark problems
results dxc benchmark problems shown table    overall  tested
systems  approaches proposed paper help speed process
finding one single diagnosis         evaluated scenarios least one
tested approaches statistically significantly faster sequential algorithm 
   scenarios  finding one single diagnosis simple modest
significant speedups compared sequential algorithm obtained 
comparing individual parallel algorithms  following observations
made 
   

fiparallel model based diagnosis multi core computers

examples  prdfs method faster breadth first search
implemented fp technique  one benchmark system  prdfs approach
even achieve speedup    compared sequential algorithm  corresponds runtime reduction     
compared non parallel rdfs  prdfs could achieve higher speedups
tested systems except simple one  took    ms even
sequential algorithm  overall  parallelization therefore advantageous
depth first strategies 
performance hybrid strategy lies performances components prdfs fp     tested systems  systems  closer
faster one two  adopting hybrid strategy therefore represent good
choice structure problem known advance  combines
ideas breadth first depth first search able quickly find diagnosis
problem settings unknown characteristics 

system
     
  l  
     
     
c   

seq 
 ms 
  
  
  
   
     

fp
s 
e 
         
         
         
         
         

rdfs
 ms 
 
  
  
  
     

prdfs
s 
e 
         
         
         
         
         

hybrid
s 
e 
         
         
         
         
         

table    observed performance gains dxc benchmarks finding one diagnosis 

      additional experiments
detailed results obtained additional experiments provided
appendix  measurements include results csps  section a      ontologies
 section a       well results obtained systematically varying characteristics synthetic diagnosis problems  section a       results indicate applying
depth first parallelization strategy many cases advantageous csp problems 
tests ontology problems simulation results however reveal depending problem structure cases breadth first strategy
beneficial 
      discussion
experiments show parallelization depth first search strategy  prdfs 
help reduce computation times search one single diagnosis 
evaluated cases  prdfs faster sequential counterpart 
cases  however  obtained improvements quite small virtually non existent 
explained follows 
   

fijannach  schmitz    shchekotykhin

small scenarios  parallel depth first search cannot significantly
faster non parallel variant creation first node parallelized  therefore major fraction tree construction process parallelized
all 
problem settings existing diagnoses size 
parallel depth first searching threads therefore explore tree certain
depth none threads immediately return diagnosis much smaller
one determined another thread  e g   given diagnosis problem 
diagnoses size    threads explore tree least level   find
diagnosis likely find diagnosis level  therefore 
setting thread much faster others 
finally  suspect problems cache contention correspondingly increased number cache misses  leads general performance deterioration
overhead caused multiple threads 
overall  obtained speedups depend problem structure  hybrid
technique represents good compromise cases faster sequential
breadth first search approach tested scenarios  including csps  ontologies  synthetically created diagnosis problems presented section a     also 
efficient prdfs cases breadth first search better
depth first search 

   parallel direct csp encodings
alternative conflict guided diagnosis approaches reiters hitting set technique 
so called direct encodings become popular research community recent
years  feldman  provan  de kleer  robert    van gemund      a  stern  kalech  feldman 
  provan        metodi et al         mencia   marques silva        menca  previti   
marques silva        marques silva  janota  ignatiev    morgado          
general idea direct encodings generate specific representation diagnosis
problem instance knowledge representation language use theorem
prover  e g   sat solver constraint engine  compute diagnoses directly 
methods support generation one multiple diagnoses calling theorem prover
once  nica  pill  quaritsch  wotawa        made number experiments
compared conflict directed search direct encodings showed
several problem settings  using direct encoding advantageous 
part paper  goal evaluate whether parallelization search
process case inside constraint engine help improve efficiency
diagnostic reasoning process  goal chapter therefore rather quantify
extent internal parallelization solver useful present new
algorithmic contribution 
    direct encodings may always possible mbd settings discussed above 

   

fiparallel model based diagnosis multi core computers

    using gecode solver direct encodings
evaluation use gecode constraint solver  schulte  lagerkvist    tack        
particular  use parallelization option gecode test effects diagnosis
running times    chosen problem encoding similar one used nica
wotawa         allows us make results comparable obtained
previous works  addition  provided encoding represented language
supported multiple solvers 
      example
let us first show general idea small example  consider following csp  
consisting integer variables a   a   b   b   c  constraints x    x    x 
defined as 
x    b  a     x    b  a     x    c  b  b  
let us assume programmer made mistake x  actually c 
b    b   given set expected observations  a test case  a     a     d      mbd
applied considering constraints possibly faulty components 
direct encoding given csp extended definition array ab
rab    ab    ab  boolean       variables encode whether corresponding constraint
considered faulty not  constraints rewritten follows 
x     ab    pb  a   q 

x     ab    pb  a   q 

x     ab    pc  b  b q 

observations encoded equality constraints bind values
observed variables  example  constraints would be 
o    a    

o    a    

o    d    

order find diagnosis cardinality    additionally add constraint
ab    ab    ab   
let solver search solution  case  x  would identified
possible diagnosis  i e   ab  would set   solver 
      parallelization approach gecode
using direct encoding  parallelization diagnosis process  shown
reiters approach  cannot done embedded underlying search
procedure  however  modern constraint solvers  gecode  or tools many
solvers participated minizinc challenge  stuckey  feydy  schutt  tack 
  fischer         internally implement parallelization strategies better utilize todays
multi core computer architectures  michel  see    van hentenryck        chu  schulte   
    state of the art sat solver capable parallelization could used analysis well 
    adapted earlier work  jannach   schmitz        

   

fijannach  schmitz    shchekotykhin

stuckey         following  therefore evaluate set experiments 
solver internal parallelization techniques help speed diagnosis process
direct encoding used   
gecode implements adaptive work stealing strategy  chu et al         parallelization  general idea summarized follows  soon thread finishes
processing nodes search tree  steals nodes non idle threads 
order decide thread work stolen  adaptive strategy uses
balancing heuristics estimate density solutions particular part
search tree  higher likelihood containing solution given branch 
work stolen branch 
    problem encoding
evaluation use minizinc constraint modeling language  language
processed different solvers allows us model diagnosis problems csps
shown above 
      finding one diagnosis
find single diagnosis given diagnosis problem  sd  comps  obs   generate
direct encoding minizinc follows 
    set components comps generate array ab    ab            abn  
boolean variables 
    formula sdi p sd add constraint form
constraint abris   psdi q 
observation oj p obs model extended constraint
constraint oj  
    finally  add search goal output statement 
solve minimize sumpi    nqpbool intpabrisqq 
output show ab   
first statement last part  solve minimize   instructs solver search
 single  solution minimal number abnormal components  i e   diagnosis
minimum cardinality  second statement  output  projects assignments set
abnormal variables  interested knowing components
faulty  assignments problem variables irrelevant 
      finding diagnoses
problem encoding shown used quickly find one all diagnoses minimum cardinality  is  however  sufficient scenarios goal find
diagnoses problem  therefore propose following sound complete algorithm
repeatedly modifies constraint problem systematically identify diagnoses 
    contrast parallelization approaches presented previous sections  propose
new parallelization schemes rather rely existing ones implemented solver 

   

fiparallel model based diagnosis multi core computers

technically  algorithm first searches diagnoses size   increases
desired cardinality diagnoses step step 

algorithm     directdiag  computation diagnoses using direct encoding 
input  diagnosis problem  sd  comps  obs   maximum cardinality k
result  set diagnoses
 
 
 
 
 
 
 
 
 
  

h  c h  card   
k  comps  k  comps  
  generatemodel  sd  comps  obs  
card k
  updatemodel  m  card   c  
  computediagnosespmq 
c c generateconstraintsp  q 
   
card card     
return  

procedure algorithm    shows main components direct diagnosis method used
connection parallel constraint solver find diagnoses  algorithm starts
generation minizinc model  generatemodel  described above 
difference search solutions given cardinality 
details encoding search goals given below 
iteration  algorithm modifies model updating cardinality
searched diagnoses furthermore adds new constraints corresponding already
found diagnoses  updatemodel   updated model provided minizinc
interpreter  constraint solver   returns set solutions     element p  
corresponds diagnosis cardinality card  
order exclude supersets already found diagnoses   future iterations 
generate constraint p   formulas j l  generateconstraints  
constraint abrjs false     abrls false 
constraints ensure already found diagnosis supersets cannot found
again  added model next iteration main loop  algorithm
continues diagnoses cardinalities k computed 
changes encoding calculate diagnoses given size  first instruct
solver search possible solutions provided constraint problem   
addition  keeping steps         section       replace lines step    
    achieved calling minizinc   all solutions flag 

   

fijannach  schmitz    shchekotykhin

following statements 
constraint sumpi    nqpbool intpabrisqq card  
solve satisfy 
output show ab   
first statement constrains number abnormal variables true
certain value  i e   given cardinality card  second statement tells solver find
variable assignments satisfy constraints  last statement guarantees
solver considers solutions different different
respect assignments abnormal variables 
soundness completeness algorithm    implements iterative deepening approach guarantees minimality diagnoses   specifically  algorithm
constructs diagnoses order increasing cardinality limiting number ab
variables set true model  computation starts card   
means one ab variable true  therefore  diagnoses cardinality   
i e   comprising one abnormal variable  returned solver  found
diagnosis add constraint requires least one abnormal variables
diagnosis false  therefore  neither diagnosis supersets found
subsequent iterations  constraints implement pruning rule hs tree
algorithm  finally  algorithm    repeatedly increases cardinality parameter card
one continues next iteration  algorithm continues increment cardinality card becomes greater number components  corresponds
largest possible cardinality diagnosis  consequently  given diagnosis problem
well sound complete constraint solver  algorithm    returns diagnoses
problem 
    evaluation
evaluate speedups achieved parallelization direct encoding 
used first five systems dxc synthetic track tested scenarios
using gecode solver without parallelization     parallel threads 
      results
evaluated two different configurations  setup  a   task find one single
diagnosis minimum cardinality  setup  b   iterative deepening procedure
section       used find diagnoses size actual error 
results setup  a  shown table    observe using parallel
constraint solver pays except tiny problems overall search time
less     ms  furthermore  adding worker threads beneficial larger
problem sizes speedup      achieved complex test case
took     seconds solve 
pattern observed setup  b   detailed results listed table
   tiny problems  internal parallelization gecode solver lead
performance improvements slightly slows whole process  soon
   

fiparallel model based diagnosis multi core computers

problems become complex  parallelization pays observe speedup
     complex tested cases  corresponds runtime reduction
    
system
     
  l  
     
     
c   

direct encoding
abs   ms 
s 
e 
s 
                 
                 
                 
                  
                    

e 
    
    
    
    
    

table    observed performance gains dxc benchmarks finding one diagnosis
direct encoding using one  column abs    two  four threads 

system
     
  l  
     
     
c   

direct encoding
abs   ms 
s 
e 
s 
                  
                 
                  
                    
                      

e 
    
    
    
    
    

table    observed performance gains dxc benchmarks finding diagnoses
direct encoding using one  column abs    two  four threads 

      summary remarks
overall  experiments show parallelization beneficial direct encoding
diagnosis problem employed  particular problems non trivial 
comparing absolute running times java implementation using open source
solver choco optimized c   implementation gecode generally appropriate benchmark problems  gecode works faster absolute scale 
note  however  true cases  particular searching diagnoses size actual error complex system c     even reiters
non parallelized hitting set algorithm much faster     seconds  using direct
encoding based iterative deepening      seconds   line observation
nica et al         direct encodings always best choice searching
diagnoses 
first analysis run time behavior gecode shows larger problem is 
time spent solver iteration reconstruct internal structures 
lead measurable performance degradation  note work relied
minizinc encoding diagnosis problem independent specifics
   

fijannach  schmitz    shchekotykhin

underlying constraint engine  implementation relies direct use api
specific csp solver might help address certain performance issues  nevertheless 
implementation must solver specific allow us switch solvers easily
possible minizinc  

   relation previous works
section explore works related approach  first examine different
approaches computation diagnoses  focus general methods
parallelizing search algorithms 
    computation diagnoses
computing minimal hitting sets given set conflicts computationally hard problem
already discussed section       several approaches proposed years
deal issue  approaches divided exhaustive approximate ones 
former perform sound complete search minimal diagnoses  whereas
latter improve computational efficiency exchange completeness  e g   search
one small set diagnoses 
approximate approaches example based stochastic search techniques
genetic algorithms  li   yunfei        greedy stochastic search  feldman et al       b  
greedy method proposed feldman et al       b   example  uses two step
approach  first phase  random possibly non minimal diagnosis determined
modified dpll   algorithm  algorithm always finds one random diagnosis
invocation due random selection propositional variables assignments 
second step  algorithm minimizes diagnosis returned dpll technique
repeatedly applying random modifications  randomly chooses negative literal
denotes corresponding component faulty flips value positive 
obtained candidate well diagnosis problem provided dpll algorithm
check whether candidate diagnosis not  case success obtained
diagnosis kept another random flip done  otherwise  negative literal labeled
failure another negative literal randomly selected  algorithm stops
number failures greater predefined constant returns best diagnosis
found far 
approach li yunfei        genetic algorithm takes number conflict
sets input generates set bit vectors  chromosomes   every bit encodes
truth value atom ab    predicate  iteration algorithm applies
genetic operations  mutation  crossover  etc   obtain new chromosomes  subsequently  obtained bit vectors evaluated hitting set fitting function
eliminates bad candidates  algorithm stops predefined number iterations
returns best diagnosis 
general  approximate approaches directly comparable lwp
fp techniques  since incomplete guarantee minimality returned
    davis putnam logemann loveland 

   

fiparallel model based diagnosis multi core computers

hitting sets  goal contrast improve performance time
maintaining completeness soundness property 
another way finding approximate solutions use heuristic search approaches 
example  abreu van gemund        proposed staccato algorithm applies
number heuristics pruning search space  aggressive pruning techniques
result better performance search algorithms  however  increase probability diagnoses found  approach aggressiveness
heuristics varied input parameters depending application goals 
recently  cardoso abreu        suggested distributed version staccato algorithm  based map reduce scheme  dean   ghemawat       
therefore executed cluster servers  recent algorithms focus
efficient computation one minimum cardinality  minc  diagnoses  de kleer 
       distributed approach minimum cardinality scenario  assumption  possibly incomplete  set conflicts already available input
beginning hitting set construction process  application scenarios
address work  finding conflicts considered computationally
expensive part assume know minimal conflicts advance
compute on demand done works  felfernig  friedrich  jannach 
stumptner  et al         friedrich   shchekotykhin        williams   ragno         see
work pill  quaritsch  wotawa        comparison conflict computation
approaches 
exhaustive approaches often based hs trees work wotawa      a 
tree construction algorithm reduces number pruning steps presence nonminimal conflicts  alternatively  one use methods compute diagnoses without
explicit computation conflict sets  i e   solving problem dual minimal hitting sets
 satoh   uno         stern et al          example  suggest method explores
duality conflicts diagnoses uses symmetry guide search 
approaches exploit structure underlying problem  hierarchical  autio
  reiter         tree structured  stumptner   wotawa         distributed  wotawa  
pill         algorithms similar hs tree algorithm and  consequently 
parallelized similar way  example  consider set enumeration tree
 se tree  algorithm  rymon         algorithm  similarly reiters hs tree approach 
uses breadth first search specific expansion procedure implements pruning
node selection strategies  lwp fp parallelization variant
used se tree algorithm comparable speedups expected 
    parallelization search algorithms
historically  parallelization search algorithms approached three different ways
 burns  lemons  ruml    zhou        
 i  parallelization node processing  applying type parallelization  tree
expanded one single process  computation labels evaluation
heuristics done parallel 
   

fijannach  schmitz    shchekotykhin

 ii  window based processing  approach  sets nodes  called windows  processed different threads parallel  windows formed search algorithm
according predefined criteria 
 iii  tree decomposition approaches  here  different sub trees search tree assigned different processes  ferguson   korf        brungger  marzetta  fukuda   
nievergelt        
principle  three types parallelization applied form hs tree
generation problem 
applying strategy  i  mbd problem setting would mean parallelize process
conflict computation  e g   parallel variant qxp mxp  tested
partially parallelized version mxp  however lead performance
improvements compared single threaded approach evaluated benchmark
problems  shchekotykhin et al          experiments section   however show
using mxp combination lwp fp thereby implicitly allocating cpu time
computation multiple conflicts construction single node advantageous  well known conflict prime implicate computation algorithms  junker 
      marques silva et al         previti  ignatiev  morgado    marques silva       
contrast designed parallel execution computation multiple conflicts 
strategy  ii  computing sets nodes  windows  parallel example applied
powley korf         work windows determined different thresholds
heuristic function iterative deepening a   applying strategy hs tree
construction problem would mean categorize nodes expanded according
criterion  e g   probability finding diagnosis  allocate different
groups individual threads  absence window criteria  lwp fp could
seen extreme cases window size one  open node allocated one thread
processor  experiments done throughout paper suggest independent
parallelization strategy  lwp fp  number parallel threads  windows 
exceed number physically available computing threads obtain best performance 
finally  iii   strategy exploring different sub trees search different
processes can  example  applied context mbd techniques using binary
hs tree  bhs  algorithms  pill   quaritsch         given set conflict sets  bhs
method generates root node labels input set conflicts  then  selects
one components occurring conflicts generates two child nodes 
left node labeled conflicts comprising selected component right
node remaining ones  consequently  diagnosis tree decomposed two subtrees processed parallel  main problem kind parallelization
conflicts often known advance computed search 
anglano portinale        suggested another approach ultimately
parallelized diagnosis problem based structural problem characteristics 
work  first map given diagnosis problem behavioral petri net  bpn   then 
obtained bpn manually partitioned subnets every subnet provided
different parallel virtual machine  pvm  parallel processing  relationship
work lwp fp parallelization schemes limited approaches
require manual problem decomposition step 
   

fiparallel model based diagnosis multi core computers

general  parallelized versions domain independent search algorithms
applied mbd settings  however  mbd problem specifics make
application algorithms difficult  instance  pra method
variant hda discussed work burns et al         use mechanism minimize
memory requirements retracting parts search tree  forgotten parts
later re generated required  mbd setting  generation nodes however
costly part  applicability hda seems limited  similarly 
duplicate detection algorithms pbnf  burns et al         require existence
abstraction function partitions original search space blocks  general mbd
settings  however cannot assume function given 
order improve performance therefore avoid parallel generation
duplicate nodes different threads  plan investigate future work 
promising starting point research could work phillips  likhachev 
koenig         authors suggest variant a  algorithm generates
independent nodes order reduce costs node generation  two nodes considered
independent generation one node lead change heuristic
function node  generation independent nodes done parallel
without risk repeated generation already known state  main difficulty
adopting algorithm mbd formulation admissible heuristic required
evaluate independence nodes arbitrary diagnosis problems  however 
specific problems encoded csps  williams ragno        present
heuristic depends number unassigned variables particular search node 
finally  parallelization used literature speed processing
large search trees fit memory  korf schultze         instance  suggest
extension hash based delayed duplicate detection algorithm allows search
algorithm continue search parts search tree written read
hard drive  methods theory used combination lwp fp
parallelization schemes case complex diagnosis problems  plan explore use
 externally  saved search states context mbd part future works 

   summary
work  propose systematically evaluate various parallelization strategies
model based diagnosis better exploit capabilities multi core computers  show
parallelization advantageous various problem settings diagnosis approaches  approaches include conflict driven search minimal
diagnoses different conflict detection techniques  heuristic  depth first search
order quickly determine single diagnosis  main benefits parallelization
approaches applied independent underlying reasoning engine
variety diagnostic problems cannot efficiently represented sat csp
problems  addition hs tree based parallelization approaches  show
parallelization beneficial settings direct problem encoding possible
modern parallel solver engines available 
evaluations furthermore shown speedups proposed parallelization methods vary according characteristics underlying diagnosis problem 
   

fijannach  schmitz    shchekotykhin

future work  plan explore techniques analyze characteristics order
predict advance parallelization method best suited find one single
diagnoses given problem 
regarding algorithmic enhancements  furthermore plan investigate information underlying problem structure exploited achieve better distribution work parallel threads thereby avoid duplicate computations 
furthermore  plan explore usage parallel solving schemes dual algorithms  i e   algorithms compute diagnoses directly without computation minimal conflicts  satoh   uno        felfernig  schubert    zehentner        stern et al  
      shchekotykhin et al         
presented algorithms designed use modern multi core computers
today usually less dozen cores  results show additional performance improvements obtain proposed techniques become smaller
adding cpus  part future works therefore plan develop
algorithms utilize specialized environments support massive parallelization 
context  future topic research could adaption parallel hs tree
construction gpu architectures  gpus  thousands computing cores 
proved superior tasks parallelized suitable way  campeotto 
palu  dovier  fioretto  pontelli        example used gpu parallelize constraint solver  however  yet fully clear whether tree construction techniques
efficiently parallelized gpu  many data structures shared across
nodes access synchronized 

acknowledgements
paper significantly extends combines previous work  jannach  schmitz   
shchekotykhin        shchekotykhin et al         
would thank hakan kjellerstrand gecode team support 
thankful various helpful comments suggestions made anonymous
reviewers jair  dx    dx    aaai    ijcai   
work supported carinthian science fund  kwf  contract kwf                  austrian science fund  fwf  german research foundation  dfg  contract numbers      n    ja           project debugging
spreadsheet programs  

appendix a 
appendix report results additional experiments made different
benchmark problems well results simulation experiments artificially created
problem instances 
section a   contains results lwp fp parallelization schemes proposed
section   
section a   reports additional measurements regarding use mergexplain
within parallel diagnosis process  see section   
   

fiparallel model based diagnosis multi core computers

section a   finally provides additional results parallelization depth first
strategies discussed section   
a   additional experiments lwp fp parallelization strategies
addition experiments dxc benchmark systems reported section     
made additional experiments constraint satisfaction problems  ontologies 
artificial hitting set construction problems  furthermore  examined effects
increasing number available threads benchmarks csps ontologies 
a     diagnosing constraint satisfaction problems
data sets procedure set experiments used number csp instances
     cp solver competition  lecoutre  roussel    van dongen       
injected faults    diagnosis problems created follows  first generated
random solution using original csp formulations  solution  randomly
picked     variables stored value assignments  served
test cases  stored variable assignments correspond expected outcomes
constraints formulated correctly  next  manually inserted errors  mutations 
constraint problem formulations     e g   changing less operator
operator  corresponds mutation based approach software testing 
diagnosis task consists identifying possibly faulty constraints using partial
test cases  addition benchmark csps converted number spreadsheet
diagnosis problems  jannach   schmitz        csps test performance gains
realistic application settings 
table   shows problem characteristics including number injected faults   f  
number diagnoses   d   average diagnosis size   d    general  selected
csps quite diverse respect size 
results measurement results using   threads searching diagnoses given
table    improvements could achieved problem instances  exception
smallest problem mknap     speedups achieved lwp fp statistically
significant  problems  improvements strong  with running time
reduction       whereas others improvements modest  average  fp
faster lwp  however  fp consistently better lwp often
differences small 
observed results indicate performance gains depend number factors
including size conflicts  computation times conflict detection 
problem structure itself  average fp faster lwp  characteristics
problem settings seem considerable impact speedups obtained
different parallelization strategies 
    able sufficient number repetitions  picked instances comparably small running
times 
    mutated csps downloaded http   ls   www cs tu dortmund de homepage hp 
downloads jair csps zip 

   

fijannach  schmitz    shchekotykhin

scenario
c 
costasarray   
domino        
gracefulk  p 
mknap    
queens  
hospital payment
profit calculation
course planning
preservation model
revenue calculation

 c
   
  
   
  
 
  
  
  
   
   
  

 v
   
  
   
  
  
 
  
   
   
   
   

 f
 
 
 
 
 
  
 
 
 
 
 

 d
 
 
  
   
 
 
   
  
    
  
    

 d 
    
   
 
    
 
    
   
    
 
 
 

table    characteristics selected problem settings 
scenario
c 
costasarray   
domino        
gracefulk  p 
mknap    
queens  
hospital payment
profit calculation
course planning
preservation model
revenue calculation

seq  qxp 
 ms 
   
     
     
     
   
   
      
   
      
   
   

lwp qxp 
s 
e 
         
    
    
         
    
    
         
    
    
    
    
    
    
    
    
    
    
         

fp qxp 
s 
e 
         
         
         
         
         
         
         
         
         
         
         

table    results csp benchmarks spreadsheets searching diagnoses 
a     diagnosing ontologies
data sets procedure recent works  mbd techniques used locate faults
description logic ontologies  friedrich   shchekotykhin        shchekotykhin et al        
shchekotykhin   friedrich         represented web ontology language
 owl   grau  horrocks  motik  parsia  patel schneider    sattler         testing
ontology  developer similarly earlier approach  felfernig  friedrich 
jannach  stumptner    zanker        specify set positive negative test cases 
test cases sets logical sentences must entailed ontology  positive 
entailed ontology  negative   addition  ontology itself  set
logical sentences  consistent coherent  baader  calvanese  mcguinness 
nardi    patel schneider         diagnosis  debugging  problem context arises 
one requirements fulfilled 
work shchekotykhin et al          two interactive debugging approaches
tested set faulty real world ontologies  kalyanpur  parsia  horridge    sirin       
   

fiparallel model based diagnosis multi core computers

two randomly modified large real world ontologies  use dataset evaluate
performance gains applying parallelization schemes ontology debugging problem  details different tested ontologies given table    
characteristics problems described terms description logic  dl  used
formulate ontology  number axioms   a   concepts   c   properties   p  
individuals   i   terms first order logic  concepts properties correspond
unary binary predicates  whereas individuals correspond constants  every letter
dl name  alchf pdq   corresponds syntactic feature language  e g  
alchf pdq attributive concept language complement  properties hierarchy 
functional properties datatypes  underlying description logic reasoner  used
pellet  sirin  parsia  grau  kalyanpur    katz         manipulation knowledge bases diagnosis process accomplished owl api  horridge  
bechhofer        
note considered ontology debugging problem different diagnosis settings discussed far cannot efficiently encoded csp sat problem 
reason decision problems  checking consistency concept
satisfiability  ontologies given table    exptime complete  baader et al  
       set experiments therefore helps us explore benefits parallelization
problem settings computation conflict sets hard  furthermore 
application parallelization approaches ontology debugging problem demonstrates generality methods  i e   show methods applicable
wide range diagnosis problems require existence sound complete
consistency checking procedure 
due generality reiters general approach and  correspondingly  implementation diagnosis procedures  technical integration owl dl reasoner
software framework relatively simple  difference csp based problems
instead calling chocos solve   method inside theorem prover  make call
pellet reasoner via owl api check consistency ontology 
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen no propchains

dl
alchf pdq
alcon pdq
alchof pdq
alcn
soin pdq
alchpdq
alchpdq
shf
alchif pdq

 a
   
  
     
   
  
     
     
      
     

 c  p  i
       
      
            
        
       
          
          
           
           

 d
 
  
  
  
  
   
     
  
   

 d 
    
   
 
 
    
    
 
 
    

table     characteristics tested ontologies 
results obtained results using thread pool size four shown table
    again  every case parallelization advantageous compared sequential
version cases obtained speedups substantial  regarding comparison
   

fijannach  schmitz    shchekotykhin

lwp fp variants  clear winner across test cases  lwp seems
advantageous problems complex respect
computation times  problems easily solved  fp sometimes slightly
better  clear correlation problem characteristics complexity
knowledge base terms size could identified within set benchmark
problems 
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen no propchains

seq  qxp 
 ms 
   
  
 
   
  
   
     
   
      

lwp qxp 
s 
e 
         
         
    
    
    
    
    
    
         
         
         
    
    

fp qxp 
s 
e 
         
         
         
         
         
         
         
         
         

table     results ontologies searching diagnoses 

a     adding threads
constraint satisfaction problems table    shows results csp benchmarks
spreadsheets using    threads  test utilizing   threads
advantageous one small scenario  however       tested scenarios
computations   threads pay off  indicates
choosing right degree parallelization depend characteristics diagnosis
problem  diagnosis mknap     problem  example  cannot sped
parallelization contains one single conflict found root node 
contrast  graceful k  p  problem benefits use    threads
could achieve speedup      scenario  corresponds runtime reduction
    
ontologies results diagnosing ontologies    threads shown
table     tested ontologies  comparably simple debugging cases  using
  threads payed     cases  best results diagnosing
  ontologies obtained   threads used  one ontology using
  threads even slower sequential algorithm  indicates
effectiveness parallelization depends characteristics diagnosis problem
adding threads even slightly counterproductive 
a     systematic variation problem characteristics
procedure better understand way problem characteristics influence
performance gains  used suite artificially created hitting set construction problems
   

fiparallel model based diagnosis multi core computers

scenario

seq  qxp 
 ms  s 
e 
c 
             
costasarray   
               
domino        
             
gracefulk  p 
               
mknap    
               
queens  
            
hospital payment
                
profit calculation
            
course planning
                
preservation model
             
revenue calculation
             

s 
    
    
    
    
    
    
    
    
    
    
    

fp qxp 
e 
s  
e  
s  
e  
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        

table     observed performance gains csp benchmarks spreadsheets
server    hardware threads 
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation

seq  qxp 
 ms 
   
  
 
   
  
   
     

s 
    
    
    
    
    
    
    

e 
    
    
    
    
    
    
    

s 
    
    
    
    
    
    
    

fp qxp 
e 
s  
         
         
         
         
         
         
         

e  
    
    
    
    
    
    
    

s  
    
    
    
    
    
    
    

e  
    
    
    
    
    
    
    

table     observed performance gains ontologies server    hardware
threads 

following varying parameters  number components   cp   number conflicts
  cf   average size conflicts   cf    given parameters  used problem generator
produces set minimal conflicts desired characteristics  generator
first creates given number components uses components generate
requested number conflicts 
obtain realistic settings  generated conflicts equal size rather
varied according gaussian distribution desired size mean  similarly 
components equally likely part conflict used gaussian
distribution assign component failure probabilities  probability distributions could
used generation process well  e g   reflect specifics certain application
domain 
since experiment conflicts known advance  conflict detection algorithm within consistency check return one suitable conflict upon request 
zero computation times unrealistic assumption conflict
   

fijannach  schmitz    shchekotykhin

detection actually costly part diagnosis process  varied assumed
conflict computation times analyze effect relative performance gains 
computation times simulated adding artificial active waiting times  wt  inside
consistency check  shown ms table      note consistency check called
conflict reused current node  artificial waiting time applies
cases new conflict determined 
experiment repeated     times different variations problem setting
factor random effects  number diagnoses  d thus average well 
algorithms had  however  solve identical sets problems thus returned identical
sets diagnoses  limited search depth   experiments speed
benchmark process  average running times reported table    
results varying computation times first  varied assumed conflict computation times quite small diagnosis problem using   parallel threads  table     
first row assumed zero computation times shows long hs tree construction
alone needs  improvements parallelization smaller case
overhead thread creation synchronization  however  soon add average
running time   ms consistency check  parallelization approaches result
speedup    corresponds runtime reduction      increasing
assumed computation time lead better relative improvements using pool
  threads 
results varying conflict sizes average conflict size impacts breadth
hs tree  next  therefore varied average conflict size  hypothesis larger
conflicts correspondingly broader hs trees better suited parallel processing 
results shown table    confirm assumption  fp always slightly efficient
lwp  average conflict sizes larger   did  however  lead strong additional
improvements using   threads 
results adding threads larger conflicts  adding additional threads leads
improvements  using   threads results improvements       corresponding running time reduction      larger conflict sizes
cases even higher levels parallelization achieved 
results adding components finally  varied problem complexity
adding components potentially faulty  since left number
size conflicts unchanged  adding components led diagnoses included
different components  limited search depth   experiment  fewer
diagnoses found level search trees narrower  result 
relative performance gains lower fewer components  constraints  
discussion simulation experiments demonstrate advantages parallelization 
tests  speedups lwp fp statistically significant  results
confirm performance gains depend different characteristics underlying
problem  additional gains waiting end search level worker
threads finished typically led small improvements 
redundant calculations can  however  still occur  particular conflicts
new nodes determined parallel two worker threads return conflict 
   

fiparallel model based diagnosis multi core computers

 cp   cf   d wt seq 
lwp
 cf 
 ms   ms 
s 
e 
varying computation times wt
        
  
 
  
         
        
  
  
   
         
        
                      
varying conflict sizes
        
  
                  
        
   
                  
         
   
                  
varying numbers components
         
   
                  
         
   
                  
          
  
                  
 cp   cf   d wt seq 
lwp
i cf 
 ms   ms 
s 
e 
adding threads    instead   
        
  
                  
        
   
                  
         
   
                  

fp
s 

e 

    
    
    

    
    
    

    
    
    

    
    
    

         
         
         
fp
s 
e 
    
    
    

    
    
    

table     simulation results 
although without parallelization computing resources would left unused
anyway  redundant calculations lead overall longer computation times small
problems thread synchronization overheads 
a   additional experiments using mxp conflict detection
section report additional results obtained using mergexplain
instead quickxplain conflict detection strategy described section     
different experiments made using set csps ontology debugging problems  remember set experiments goal identify set leading
diagnoses 
a     diagnosing constraint satisfaction problems
table    shows results searching five diagnoses using csp spreadsheet
benchmarks  mxp could help reduce running times tested
scenarios except smaller ones  tiny scenario mknap      simple
sequential algorithm using qxp fastest alternative  scenarios 
however  parallelization pays faster sequentially expanding search
tree  best result could achieved scenario costasarray     fp using
mxp reduced running times     compared sequential algorithm using qxp 
   

fijannach  schmitz    shchekotykhin

corresponds speedup    results indicate fp works well
qxp mxp 
scenario
c 
costasarray   
domino        
gracefulk  p 
mknap    
queens  
hospital payment
profit calculation
course planning
preservation model
revenue calculation

seq  qxp 
 ms 
   
     
  
   
  
  
     
  
     
   
  

fp qxp 
s 
e 
         
         
         
         
         
         
         
         
         
         
         

seq  mxp 
 ms 
   
     
  
   
  
  
     
  
     
   
  

fp mxp 
s 
e 
         
         
         
         
         
         
         
         
         
         
         

table     results csp benchmarks spreadsheets  qxp vs mxp  
note one case  costasarray     see efficiency value larger one 
means obtained speedup super linear  happen special situations
search limited number diagnoses use fp method  see
section a       assume generating one specific node takes particularly long  i e  
computation conflict set requires considerable amount time  case 
sequential algorithm stuck node time  fp method
continue generating nodes  nodes sufficient find  limited 
required number diagnoses  lead efficiency value greater
theoretical optimum 
a     diagnosing ontologies
results shown table     similar previous experiment  using mxp
combination fp pays cases except simple benchmark problems 
a   additional experiments parallel depth first search
section  report results additional experiments made assess
effects parallelizing depth first search strategy described section      set
experiments goal find one single minimal diagnosis  report results
obtained constraint problems ontology debugging problems discuss
findings simulation experiment systematically varied problem
characteristics 
a     diagnosing constraint satisfaction problems
results searching single diagnosis csps spreadsheets shown
table     again  parallelization generally shows good strategy speed
   

fiparallel model based diagnosis multi core computers

ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen no propchains

seq  qxp 
 ms 
   
  
 
  
  
  
  
   
     

fp qxp 
s 
e 
         
         
         
         
         
         
         
         
         

seq  mxp 
 ms 
   
  
 
  
  
  
  
   
     

fp mxp 
s 
e 
         
         
         
         
         
         
         
         
         

table     results ontologies  qxp vs mxp  
diagnosis process  measured speedups except speedup rdfs first scenario
c  statistically significant  specific problem setting  fp strategy
measurable effect strategies even modest performance deterioration
observed compared reiters sequential algorithm  reason lies resulting
structure hs tree narrow conflicts size one 
following detailed observations made comparing algorithms 
tested csps  fp advantageous compared rdfs prdfs 
spreadsheets  contrast  rdfs prdfs better breadth first
approach fp three five cases 
comparing rdfs prdfs  observe parallelization
advantageous depth first strategies 
again  however  improvements seem depend underlying problem structure  case hospital payment scenario  speedup prdfs high
    compared sequential algorithm  corresponds runtime reduction
     parallel strategy is  however  consistently better
test cases 
performance hybrid method lies performances
two components many  all  tested scenarios 

a     diagnosing ontologies
next  evaluated search one diagnosis real world ontologies  table     
tested scenarios  applying depth first strategy often pay compared
breadth first methods  reason tested examples ontology debugging domain many cases single element diagnoses exist  quickly
detected breadth first strategy  furthermore absolute running times often comparably small  parallelizing depth first strategy leads significant speedups
cases 
   

fijannach  schmitz    shchekotykhin

scenario
c 
costasarray   
domino        
gracefulk  p 
mknap    
queens  
hospital payment
profit calculation
course planning
preservation model
revenue calculation

seq 
 ms 
   
     
  
   
   
  
   
  
     
   
   

fp
s 
e 
         
         
         
         
         
         
         
         
         
         
         

rdfs
 ms 
   
     
  
   
   
  
   
  
     
   
   

prdfs
s 
e 
         
         
         
         
         
         
         
         
         
         
         

hybrid
s 
e 
         
         
         
         
         
         
         
         
         
         
         

table     results csp benchmarks spreadsheets finding one diagnosis 
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation

seq 
 ms 
  
  
 
  
  
  
  

fp
s 
e 
         
         
         
         
         
         
         

rdfs
 ms 
  
 
 
  
  
  
  

prdfs
s 
e 
         
         
         
         
         
         
         

hybrid
s 
e 
         
         
         
         
         
         
         

table     observed performance gains ontologies finding one diagnosis 
a     systematic variation problem characteristics
table    finally shows simulation results searching one single diagnosis 
experiment used uniform probability distribution selecting components
conflicts obtain complex diagnosis problems  results summarized
follows 
fp expected better sequential version hs tree algorithm
tested configurations 
small problems contain comparably small conflicts 
depth first strategy work well  parallel sequential versions
even slower reiters original proposal  except cases zero conflict
computation times assumed  indicates costs hitting set minimization high 
larger problem instances  relying depth first strategy find one single
diagnosis advantageous better fp  additional test even
   

fiparallel model based diagnosis multi core computers

 cp   cf  i d  wt
seq 
i cf 
 ms 
 ms 
varying computation times wt
        
    
 
  
        
    
  
  
        
        
   
varying conflict sizes
        
    
  
  
        
    
  
  
         
    
  
  
varying numbers components
         
    
  
   
         
    
  
   
               
  
     
conflicts
          
    
         

fp

rdfs
 ms 

prdfs
s 
e 

hybrid
s 
e 

s 

e 

    
    
    

    
    
    

 
   
     

    
    
    

    
    
    

    
    
    

    
    
    

    
    
    

    
    
    

   
   
   

    
    
    

    
    
    

    
    
    

    
    
    

    
    
    

    
    
    

   
   
   

    
    
    

    
    
    

    
    
    

    
    
    

    

    

   

    

    

    

    

table     simulation results finding one diagnosis 
larger problem shown last line table    reveals potential depth first
search approach 
problems larger  prdfs help obtain runtime
improvements compared rdfs 
hybrid method works well single case zero computation times 
again  represents good choice problem structure known 
overall  simulation experiments show speedups achieved
different methods depend underlying problem structure search
one single diagnosis 

references
abreu  r     van gemund  a  j  c          low cost approximate minimal hitting set
algorithm application model based diagnosis  sara    pp     
anglano  c     portinale  l          parallel model based diagnosis using pvm  europvm    pp         
autio  k     reiter  r          structural abstraction model based diagnosis 
ecai    pp         
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p         
description logic handbook  theory  implementation applications  vol     
bolosky  w  j     scott  m  l          false sharing effect shared memory
performance  sedms    pp       
   

fijannach  schmitz    shchekotykhin

brungger  a   marzetta  a   fukuda  k     nievergelt  j          parallel search bench
zram applications  annals operations research               
buchanan  b     shortliffe  e   eds            rule based expert systems  mycin experiments stanford heuristic programming project  addison wesley  reading 
ma 
burns  e   lemons  s   ruml  w     zhou  r          best first heuristic search
multicore machines  journal artificial intelligence research             
campeotto  f   palu  a  d   dovier  a   fioretto  f     pontelli  e          exploring
use gpus constraint solving  padl    pp         
cardoso  n     abreu  r          distributed approach diagnosis candidate generation  epia    pp         
chandra  d   guo  f   kim  s     solihin  y          predicting inter thread cache contention chip multi processor architecture  hpca    pp         
chu  g   schulte  c     stuckey  p  j          confidence based work stealing parallel
constraint programming  cp    pp         
console  l   friedrich  g     dupre  d  t          model based diagnosis meets error
diagnosis logic programs  ijcai    pp           
de kleer  j          hitting set algorithms model based diagnosis  dx    pp         
dean  j     ghemawat  s          mapreduce  simplified data processing large clusters  communications acm                 
dijkstra  e  w          structure the multiprogramming system  communications acm                 
eiter  t     gottlob  g          complexity logic based abduction  journal
acm              
feldman  a   provan  g   de kleer  j   robert  s     van gemund  a       a   solving
model based diagnosis problems max sat solvers vice versa  dx    pp 
       
feldman  a   provan  g     van gemund  a       b   approximate model based diagnosis
using greedy stochastic search  journal artifcial intelligence research         
    
felfernig  a   friedrich  g   isak  k   shchekotykhin  k  m   teppan  e     jannach  d 
        automated debugging recommender user interface descriptions  applied
intelligence              
felfernig  a   friedrich  g   jannach  d     stumptner  m          consistency based diagnosis configuration knowledge bases  artificial intelligence                  
felfernig  a   friedrich  g   jannach  d   stumptner  m     zanker  m          hierarchical
diagnosis large configurator knowledge bases  ki    pp         
felfernig  a   schubert  m     zehentner  c          efficient diagnosis algorithm
inconsistent constraint sets  artificial intelligence engineering design  analysis
manufacturing               
   

fiparallel model based diagnosis multi core computers

felfernig  a   friedrich  g   jannach  d   stumptner  m   et al          consistency based
diagnosis configuration knowledge bases  ecai    pp         
ferguson  c     korf  r  e          distributed tree search application alpha beta
pruning  aaai    pp         
friedrich  g     shchekotykhin  k  m          general diagnosis method ontologies 
iswc    pp         
friedrich  g   stumptner  m     wotawa  f          model based diagnosis hardware
designs  artificial intelligence                 
friedrich  g   fugini  m   mussi  e   pernici  b     tagni  g          exception handling
repair service based processes  ieee transactions software engineering         
       
friedrich  g     shchekotykhin  k          general diagnosis method ontologies 
iswc    pp         
garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w  h  freeman   co 
grau  b  c   horrocks  i   motik  b   parsia  b   patel schneider  p     sattler  u         
owl    next step owl  web semantics  science  services agents
world wide web                
greiner  r   smith  b  a     wilkerson  r  w          correction algorithm
reiters theory diagnosis  artificial intelligence               
horridge  m     bechhofer  s          owl api  java api owl ontologies 
semantic web journal              
jannach  d     schmitz  t          model based diagnosis spreadsheet programs 
constraint based debugging approach  automated software engineering  february
      published online  
jannach  d   schmitz  t     shchekotykhin  k          parallelized hitting set computation
model based diagnosis  aaai    pp           
junker  u          quickxplain  preferred explanations relaxations overconstrained problems  aaai    pp         
kalyanpur  a   parsia  b   horridge  m     sirin  e          finding justifications
owl dl entailments  semantic web  vol       lecture notes computer
science  pp         
korf  r  e     schultze  p          large scale parallel breadth first search  aaai   
pp           
kurtoglu  t     feldman  a          third international diagnostic competition  dxc
     https   sites google com site dxcompetition      accessed             
lecoutre  c   roussel  o     van dongen  m  r  c          cpai   competition  http 
  www cril univ artois fr cpai     accessed             
li  l     yunfei  j          computing minimal hitting sets genetic algorithm 
dx    pp     
   

fijannach  schmitz    shchekotykhin

marques silva  j   janota  m   ignatiev  a     morgado  a          efficient model based
diagnosis maximum satisfiability  ijcai    pp           
marques silva  j   janota  m     belov  a          minimal sets monotone predicates
boolean formulae  computer aided verification  pp         
mateis  c   stumptner  m   wieland  d     wotawa  f          model based debugging
java programs  aadebug   
mencia  c     marques silva  j          efficient relaxations over constrained csps 
ictai    pp         
menca  c   previti  a     marques silva  j          literal based mcs extraction 
ijcai    pp           
metodi  a   stern  r   kalech  m     codish  m          novel sat based approach
model based diagnosis  journal artificial intelligence research             
michel  l   see  a     van hentenryck  p          parallelizing constraint programs transparently  cp    pp         
nica  i   pill  i   quaritsch  t     wotawa  f          route success  performance
comparison diagnosis algorithms  ijcai    pp           
nica  i     wotawa  f          condiag   computing minimal diagnoses using constraint
solver  dx    pp         
phillips  m   likhachev  m     koenig  s          pa se  parallel a  slow expansions 
icaps   
pill  i   quaritsch  t     wotawa  f          conflicts diagnoses  empirical
evaluation minimal hitting set algorithms  dx    pp         
pill  i     quaritsch  t          optimizations boolean approach computing
minimal hitting sets  ecai    pp         
powley  c     korf  r  e          single agent parallel window search  ieee transactions
pattern analysis machine intelligence                 
previti  a   ignatiev  a   morgado  a     marques silva  j          prime compilation
non clausal formulae  ijcai    pp           
prudhomme  c   fages  j  g     lorca  x          choco documentation  tasc  inria
rennes  lina cnrs umr       cosling s a s  http   www choco solver org 
reiter  r          theory diagnosis first principles  artificial intelligence         
     
rymon  r          se tree based prime implicant generation algorithm  annals
mathematics artificial intelligence                   
satoh  k     uno  t          enumerating minimally revised specifications using dualization  jsai    pp         
schulte  c   lagerkvist  m     tack  g          gecode   open  free  efficient constraint
solving toolkit  http   www gecode org  accessed             
   

fiparallel model based diagnosis multi core computers

shchekotykhin  k   friedrich  g   fleiss  p     rodler  p          interactive ontology debugging  two query strategies efficient fault localization  journal web semantics 
            
shchekotykhin  k  m     friedrich  g          query strategy sequential ontology
debugging  iswc    pp         
shchekotykhin  k   jannach  d     schmitz  t          mergexplain  fast computation
multiple conflicts diagnosis  ijcai    pp           
shchekotykhin  k  m   friedrich  g   rodler  p     fleiss  p          sequential diagnosis
high cardinality faults knowledge bases direct diagnosis generation  ecai   
pp         
sirin  e   parsia  b   grau  b  c   kalyanpur  a     katz  y          pellet  practical
owl dl reasoner  web semantics  science  services agents world wide
web               
stern  r   kalech  m   feldman  a     provan  g          exploring duality conflictdirected model based diagnosis  aaai    pp         
stuckey  p  j   feydy  t   schutt  a   tack  g     fischer  j          minizinc challenge
           ai magazine               
stumptner  m     wotawa  f          debugging functional programs  ijcai    pp 
         
stumptner  m     wotawa  f          diagnosing tree structured systems  artificial
intelligence               
white  j   benavides  d   schmidt  d  c   trinidad  p   dougherty  b     cortes  a  r 
        automated diagnosis feature model configurations  journal systems
software                   
williams  b  c     ragno  r  j          conflict directed a  role model based
embedded systems  discrete applied mathematics                     
wotawa  f       a   variant reiters hitting set algorithm  information processing
letters               
wotawa  f       b   debugging hardware designs using value based model  applied
intelligence               
wotawa  f     pill  i          classification modeling issues distributed modelbased diagnosis  ai communications                 

   


