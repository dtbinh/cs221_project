journal artificial intelligence research                 

submitted        published      

belief tracking planning sensing  width 
complexity approximations
blai bonet

bonet ldc usb ve

departamento de computacion
universidad simon bolvar
caracas  venezuela

hector geffner

hector geffner upf edu

icrea   universitat pompeu fabra
roc boronat    
      barcelona  spain

abstract
consider problem belief tracking planning setting states valuations set variables partially observable  beliefs stand sets
states possible  problem intractable worst case 
recently shown deterministic conformant contingent problems  belief tracking exponential width parameter often bounded small  work 
extend results two ways  first  introduce width notion applies
non deterministic problems well  develop factored belief tracking algorithm exponential problem width  show applies existing benchmarks  second 
introduce meaningful  powerful  sound approximation scheme  beam tracking 
exponential smaller parameter  problem causal width  much broader applicability  illustrate value algorithm large instances problems
battleship  minesweeper  wumpus  yields state of the art performance
real time 

   introduction
planning incomplete information formulated search problem belief space
two issues need addressed  keeping track beliefs  searching goal
belief  bonet   geffner         two tasks intractable worst case
compact representations  approach adopted recent conformant
contingent planners beliefs handled using sat  regression techniques  logical
normal forms cnf  dnf  obdds  search goal beliefs guided
domain independent heuristics  bertoli  cimatti  roveri    traverso        hoffmann  
brafman        bryce  kambhampati    smith        to  pontelli    son        shani  
brafman        brafman   shani        
recently  complexity belief tracking deterministic conformant contingent
planning shown exponential problem width parameter often
bounded small  palacios   geffner        albore  palacios    geffner        
bound follows family translations developed compiling planning problems
beliefs planning problems states  translations exponential problem
c
    
ai access foundation  rights reserved 

fibonet   geffner

width  deterministic conformant problems result problems solved
classical planners 
difficulty extending results palacios  albore  geffner nondeterministic setting consequence special role played initial situation
deterministic problems  case  uncertainty  particular  uncertainty
observations  action preconditions  goals  one matters
complete planner  result uncertainty initial situation  nondeterministic setting  hand  uncertainty produced dynamically result
application non deterministic actions  moreover  uncertain initial situation
always modeled fully known initial situation dummy non deterministic
action  opposite transformation simple  indeed  non deterministic effects
compiled deterministic effects conditional value hidden variables 
number hidden variables required must grow planning horizon
 weld  anderson    smith        albore  ramirez    geffner        
aim work study computational complexity belief tracking
terms novel width parameters apply deterministic non deterministic
planning problems  formulation practical approximate belief tracking algorithms
efficient effective even problems large width  achieve
considering two decomposition schemes belief tracking  three algorithms based
decompositions  precisely  introduce 
   width notion planning close correspondence notion introduced
palacios  albore  geffner applies non deterministic problems
well 
   first belief tracking algorithm  factored belief tracking  sound complete
deterministic non deterministic problems p   runs time space
exponential problem width w p    algorithm based decomposition
problem p projected subproblems px   one every goal precondition
variable x  one including variables relevant x 
   second belief tracking algorithm  causal belief tracking  based alternative
decomposition scheme  subproblems px defined every goal  precondition 
observable variable x  one including variables causally relevant
x  algorithm sound complete large meaningful class problems 
still time exponential problem width  space exponential
causal width problem often much smaller 
   final belief tracking algorithm  beam tracking sound incomplete approximation causal belief tracking  often practical enough  even problems
large widths  runs time space exponential problem causal
width 
power last algorithm  beam tracking  shown empirically large
instances problems minesweeper  battleship  wumpus  state of the   

fibelief tracking planning sensing

art performance obtained real time combining belief tracking algorithm
simple heuristics action selection  
organization paper follows structure  preceded overview
relevant notation background  followed description experiments 
discussion related work  summary  paper integrates results two conference
papers  bonet   geffner      b         providing proofs additional details  work
related proposals tractable forms belief tracking logical probabilistic
frameworks  doucet  freitas  murphy    russell        amir   russell         yet
two key differences  one start exact account used determine
certainty whether goal achieved action applicable  second
belief tracking accounts planning complete formulas  order
sound complete planner  beliefs observations  action preconditions 
goals required  important observations  action preconditions 
goals given  structure actions  sensors  goals exploited
track beliefs efficiently  observation implicit lazy belief tracking
schemes planning incomplete information appeal sat solvers  hoffmann  
brafman        regression  shani   brafman         well say related work
section    

   model
model planning sensing simple extension model conformant
planning goal achieved certainty spite uncertainty initial
situation action effects  goldman   boddy        smith   weld         model
conformant planning characterized tuple   hs  s    sg   a  f
finite state space 
s  non empty set possible initial states  s  s 
sg non empty set goal states  sg s 
set actions a s  denoting sets actions applicable s 
f non deterministic state transition function f  a  s  denotes nonempty set possible successor states follow action s  a s  
solution conformant model action sequence maps possible initial state
goal state  precisely    ha            an  conformant plan possible
sequence states s    s            sn s  s  si   f  ai   si                 n   
action ai applicable si sn goal state 
conformant planning cast path finding problem beliefs  defined
sets states deemed possible time point  bonet   geffner        
initial belief b  s    belief ba results action belief state b is 
ba    s    b s  f  a  s    

   

   real time animation algorithm several instances minesweeper seen https 
  www youtube com watch v u  ow n  ra  source code graphical interfaces
obtained http   code google com p belief tracking 

   

fibonet   geffner

action applicable b applicable state b  formulation 
conformant plan action sequence maps initial belief b  goal belief bg  
i e   set goal states 
contingent planning planning sensing planning uncertainty
feedback  model contingent planning model conformant planning extended
sensor model  sensor model function o s  a  mapping state action pairs
observations tokens o  expression o s  a  means token possible
observation true state system last action done 
observed token provides partial information true possibly hidden system
state token may possible different states  two different tokens o 
o  belong o s  a   means either one observed
last action  sensing deterministic noiseless o s  a  contains one token  else
non deterministic noisy  contingent model similar pomdps  kaelbling 
littman    cassandra        uncertainty encoded sets states rather
probability distributions 
executions contingent setting sequences ha    o    a    o         i pairs actions
ai observations oi   b   bi belief state action ai applied oi
token observed  belief ba action   ai given     
belief bi     boa follows observing token is 
boa    s   ba o s  a    

   

execution ha    o    a    o         i possible starting initial belief b    action
ai applicable belief bi  i e   ai a s  bi       belief bi
empty 
off line contingent planning  action selection strategy sought ensures
possible executions end goal belief  on line contingent planning  action
selection strategy sought ensures single execution results
interaction real system simulator  ends goal belief  cases 
action selection strategy expressed partial function beliefs  called policy 
 b  action belief b  function partial
defined initial belief b  non goal beliefs b  namely 
reached b  off line planning  reached
b  on line planning 

   language
syntactically  conformant problems expressed compact form set
state variables  convenience assume multi valued   precisely 
conformant planning problem tuple p   hv  i  a  gi v stands problem
variables x  one finite discrete domain dx   set clauses
v  literals defining initial situation  set actions  g set v  literals
defining goal  every action precondition p re a  given set v  literals 
   multi valued variables compiled boolean variables compilation affects syntactic
structure problem  principle  structure could recovered boolean encodings
would result complex formulation 

   

fibelief tracking planning sensing

set conditional effects c e           en c ei sets  conjunctions 
v  literals  conditional effect non deterministic n      else n     effect
deterministic 
problem p   hv  i  a  gi defines conformant model s p     hs  s    sg   a  f i 
set possible valuations variables v   s  sg sets valuations
satisfy g respectively  a s  set operators whose preconditions true
s  f  a  s  non deterministic transition function results collecting
successor states may follow selecting one head ei conditional
effect c e           en whose body c true s  
contingent problems described extending syntactic description conformant problems compact encoding sensor model  this  assume set
v   observable multi valued variables   necessarily disjoint state variables
v  i e   state variables may observable   formulas wa  y   y  state
variables  action possible value observable variable  
formula wa  y   y  implicitly encodes states observation literal  
possible last action executed  formulas wa  y   y  different
values dy must logically exhaustive  every state action pair must give rise
observation   y  addition  formulas wa  y   y  different values
logically exclusive  every state action pair gives rise single observation  
sensing deterministic  state variable x observable  wa  x   x 
formula x   x 
contingent problem p tuple p   hv  i  a  g  v     w defines contingent
model made conformant model hs  s    sg   a  f determined first four
components p   sensor model o a  s  determined last two components 
o a  s  iff valuation observable variables v    
true formula wa  y   y  w true dy  
standard language representing contingent problems compact form featuring incomplete information  non deterministic actions sensors  two
distinctive features relation similar languages use multi valued variables 
distinction state observable variables 
illustration  x encodes position agent  encodes position
object seen agent x     observable variable
z  y es  n o  encoding whether
object seen agent
w
w not  defined
formulas wa  z   es    ld  x   ly   l   wa  z   n o    ld  x   ly   l  
set possible locations action  deterministic
sensor  non deterministic sensor could used if  example  agent cannot detect
 
presence
w object certain locations l   this  suffices push
disjunct ld   x   l  formulas characterizing wa  z   es  wa  z   n o  
two observations z   es z   n would possible agent
position l d   
since conformant problem hv  i  a  gi expressed contingent problem
hv  i  a  g  v     w one  dummy  observable variable z  z
  v domain
   conditional effects must consistent sense explained below 

   

fibonet   geffner

dz        observation model wa  z        true every action a  focus
general contingent problem 
likewise  convenience  variable boolean  often represent literals
  true   f alse   similarly  variable observable  unless stated
otherwise  assume observation model deterministic formula
wa  y   f alse  becomes complement formula wa  y   true  

   belief tracking problem flat belief tracking algorithm
execution problem p   hv  i  a  g  v     w sequence ha    o    a    o         i
actions ai observations oi ai observation oi full
valuation observation variables v     execution ha    o              possible
problem p non empty belief state b    generates sequence beliefs b            bn
preconditions action ai true belief bi   belief states
bi empty  problem belief tracking contingent planning problem
determining execution possible final belief state achieves goal 
definition    belief tracking planning  btp  problem determining whether
execution ha    o    a    o         i planning problem p   hv  i  a  g  v     w possible 
so  whether resulting belief state makes goal g true 
complete planner needs solve problem determining actions applicable given execution  observations may result  whether goal
achieved  machinery develop aimed slightly general
belief tracking problem generalized executions  executions ha    o    a    o         i
observations oi partial rather full valuations observable variables  moreover  suffices consider generalized executions observations
valuations single observable variable  observations oi represented
observation literals  i  
definition    generalized belief tracking planning  gbtp  problem determining whether generalized execution ha         a              i planning problem p  
hv  i  a  g  v     w possible  so  whether achieves given goal  precondition 
observation literal 
given procedure deciding gbtp  simple decide btp execution
calling procedure deciding gbtp generalized execution   replaces
observation oi sequence observation literals true oi separated
no op actions  actions effects  
proposition    btp polynomial time reducible gbtp 
interest belief tracking planning  find convenient focus
generalized problem  none belief update equations algorithms sensitive
distinction  simplicity  however  talk belief tracking  make
explicit distinctions btp gbtp  normal generalized
executions  needed 
   

fibelief tracking planning sensing

plain solution belief tracking problem given updates expressed
eqs       belief states explicitly represented sets states  states full
valuations state variables  actions  transition function  observations
obtained syntactic representation problem 
definition    flat belief tracking algorithm execution ha    o    a    o         i
problem p   starts belief b  contains states satisfy initial situation 
setting next belief state bi   boa using         b   bi     ai     oi  
complexity flat belief tracking exponential number state variables  yet 
often state variables add complexity tracking beliefs  syntactically 
happens state variable x initially known  variables causally
relevant x  see below  initially known well  neither x variable
causally relevant x appears head non deterministic effect  say
variables determined value every reachable belief known  fully
predicted preceding actions preceding values  example  variable
encodes position agent wumpus game determined  initial
value known effect actions variable deterministic depends
previous value 
formally  define set variables determined problem
largest set state variables x problem initially known every
state variable x   causally relevant x belongs set  set variables
easily identifiable low polynomial time  complexity flat belief tracking
expressed follows 
theorem    flat belief tracking exponential  vu    vu   v   vk vk
set state variables determined problem 
given result  first question arises bad naive approach flat belief
tracking  interestingly  following result decision problem shows flat belief
tracking bad worst case 
theorem    btp gbtp turing complete class pnp  
is  btp gbtp decided polynomial time using oracle np  sat 
example   every decision problem decided polynomial time
oracle  decided polynomial time oracle btp gbtp 
complexity class pnp includes classes np conp  contained pspace
 sipser        

   structure width
possible improve complexity flat belief tracking specific problem
exploiting structure problem  introducing graph captures
structure  convenient make explicit assumptions restrict
generality approach make definitions simpler  first  assume
formula encoding initial situation contains positive negative literals  i e   unit
clauses only  restrictive assumption since set clauses encoded
   

fibonet   geffner

help dummy observations  second  assume non deterministic effects
involve one variable heads  again  always achieved adding extra
variables effects  example  non deterministic effect x z   z
action replaced deterministic effects x w z x w z 
along non deterministic effect true w   w   w new random boolean
variable initially unknown changes randomly  third  assume problem
consistent  meaning initial situation logically consistent initial
belief state b  empty  effects action consistent
heads deterministic conditional effects applicable reachable state s  along
choice heads non deterministic conditional effects applicable
s  jointly consistent   last  assume every observable variable relevant
variable appearing precondition goal  notion relevance spelled
below  observable variables dont comply condition eliminated
problem relevant information loss 
    relevance width
variable x  whether state variable  observable variable  both  immediate
causes x defined follows 
definition    variable x immediate cause variable problem p   written
x ca y    iff x      either x occurs body c conditional effect c
e     en occurs head ei     n  observable variable x
occurs formula wa  y   y  dy action a 
basically  x immediate cause uncertainty x may affect
uncertainty directly  variables  x necessarily immediate
cause x appears precondition action affects   preconditions
must known certainty  hence  propagate uncertainty  notion
causal relevance given transitive closure immediate cause relation 
definition    x causally relevant p x     x ca y    x causally
relevant variable z causally relevant  
order test whether given literal z   z known certain execution
ha    a            ai actions conformant setting  possible show one
progress state variables x causally relevant z 
proposition    belief tracking deterministic non deterministic conformant setting exponential maximum number non determined variables causally
relevant variable appearing action precondition goal 
bound closely related bound obtained palacios geffner
deterministic setting  indeed  refer number non determined state variables
   semantic point view  means state s  possible successor state
action applicable s  i e  s  f  a  s   iff every literal x   x true s    x   x head
deterministic non deterministic conditional effect action whose body true s  x   x
true s  effect action x   x  head  x     x  whose body
true s 

   

fibelief tracking planning sensing

causally relevant x  conformant width x  set width p
maximum conformant width variables x appear action preconditions
goals  proposition   simply says belief tracking non deterministic conformant
problem exponential problem width  width notion  however  exactly
equivalent notion palacios geffner used deterministic setting
defined variables rather literals  say distinction
below  general  however  two accounts yield similar widths deterministic
benchmarks 
contingent setting  variables whose uncertainty may affect variable
z causally relevant z  situation similar one arising
bayesian networks  pearl         relevance flows causally  direction
arrows  evidentially  observations direction arrows 
definition     x evidentially relevant p x observable variable
causally relevant x 
notion relevance captures transitive closure  directional  causal evidential relations 
definition     x relevant x causally evidentially relevant   x
relevant variable z relevant  
thus  variable x   w  relevant variable   wn iff chain variables
wi     n    variable wi causally evidentially relevant next
variable wi   chain  example  x causally relevant z 
observable variable  relevant z evidentially relevant x x
causally relevant z 
bayesian networks  relevance relations understood graph theoretically 
thus  directed edge z stands z immediate cause   x
causally relevant x   directed path x x     x evidentially
relevant x   x observable variable  directed path x  
x  terms bayesian networks  relevance relation takes transitive closure
causal evidential relationships  encodes potential dependency given
may observed  using information certain variables observed  are
observable   unlike bayesian networks  means however relevance relation
symmetric  namely  cause x relevant   automatically
relevant x causally relevant observable variable z  may
itself  context variable set variables problem relevant
x 
definition     context variable x  ctx x   denotes set state variables
problem relevant x 
width variable defined number state variables context
determined 
definition     width variable x  w x    ctx x  vu    vu   v   vk
vk set state variables determined 
   

fibonet   geffner

width problem then 
definition     width w p   conformant contingent problem p   whether deterministic not  maxx w x  x ranges variables appear goal
action precondition p  
relation width complexity expressed as 
theorem     belief tracking p exponential w p   
proof theorem follows results algorithm
achieves complexity bound presented  significance theorem belief
tracking planning domains width bounded constant becomes polynomial
number problem variables  see examples below  complexity bound
similar ones obtained deterministic conformant contingent problems  palacios
  geffner        albore et al          main difference new account applies
non deterministic problems well  new account simpler general 
see  slightly less tight deterministic domains 

   examples
illustrate definitions benchmark domains  starting det ring
 cimatti  roveri    bertoli         domain  ring n rooms
agent move forward backward along ring  room window
opened  closed  locked closed  initially  status windows
known agent know initial location  domain agent
means obtaining information status windows position 
goal windows locked  plan deterministic conformant problem
repeat n times actions  close  lock  f wd   skipping last f wd action  alternatively 
action f wd replaced action bwd throughout plan  state variables
problem encode agent location loc             n   status window 
w  i   open  closed  locked                n  location variable loc  causally  relevant
window variable w  i   window variable w  i  relevant loc w  k 
k    i  w  i  causally relevant observable variable  none variables
determined largest contexts window variables w  i  include two
variables  w  i  loc  result width domain    independent
number state variables w  i  grows number rooms n  causal
graph problem  directed edge x means x immediate cause
shown figure  a 
non det ring variation domain actions f wd bwd
agent non deterministic effect status windows locked 
capturing possibility external events open close unlocked windows 
non determinism effect causal graph variables  result 
change effect contexts domain width remains bounded equal
  number rooms n 
last version domain considered cimatti et al  non det ring key 
key required lock windows  initial position key known 
   

fibelief tracking planning sensing

loc

loc

w    

w    



w  n 

w    

 a  det ring

w    

kloc



w  n 

h

 b  cont non det ring key

figure    causal graphs problems det ring  left  cont non det ring key
 right   latter  variable h observable tells us whether key held
not  arc x denotes x immediate cause   graphs  variables
preconditions goals underlined yellow colored  observable variables
enclosed blue circle 
yet agent tries collect key room key there  agent
key  conformant plan problem repeat actions pick f wd  n
times  skipping last f wd action  following plan det ring  non detring key  additional state variable  kloc             n  hand   represents
key location  agent location loc relevant kloc relevant window
variable w  i   result  size contexts ctx w  i   problem width
increase    width however remains bounded value   independently
number rooms n  
presence partial observability  analysis similar necessary
consider relevance relationships arise due presence observable variables 
example  one express agent always observe whether holding
key not  boolean observable variable h  deterministic  observation
model wa  h   true  given kloc   hand  actions a  new relevance
relation among state variables arises adding observable variable
loc kloc  causally relevant h  before  loc relevant kloc
way around  yet affect domain width remains  
n  causal graph resulting domain shown figure  b 

   factored belief tracking
belief tracking problem p exponential width w p   p   algorithm
achieves bound exploits relevance relations encoded variable contexts
decomposing beliefs  particular  variable relevant variable 
problem width    beliefs variable maintained separately 
belief decomposition obtained projecting problem p smaller problems ps
set state variables p   semantically  projected problems ps capture
dynamics problem p expressed subset state variables  syntactically 
projected problems ps defined means logical notion projection 
   problem encoded making holding key precondition rather condition
locking windows  encoding  variable kloc longer relevant window
variables w  i  according definitions  kloc   hand must known certainty 
hence uncertainty windows variables w  i  affected uncertainty kloc 
result encoding  domain width reduces   

   

fibonet   geffner

logical projection formula f subset variables refers formula f  
defined variables s  valuations satisfy f   exactly
extended valuations satisfy f  darwiche   marquis         likewise 
projection conditional effect c e      e n conditional effect cs es     esn
body c effects e replaced logical projections cs esi
respectively 
definition     projection problem p   hv  i  a  g  v     w set variables
v problem ps   hvs       gs   vs    ws vs s  gs
initial goal formulas g logically projected variables s 
preconditions conditional effects projected s  vs  v     ws set
formulas wa  y   y  w logically projected variables s 
notion projected planning problem used setting
classical planning introducing class admissible heuristics known pattern databases
 edelkamp         use richer contingent setting decomposing belief
tracking problem p belief tracking problem smaller problems ps obtained
p projecting away state variables p  
defining target subproblems ps decomposition  notice variables
state observable variables p s  belong vs 
vs   meaning observable variables projected problem ps  
moreover  formulas variables ws become wa  y   y    true
dy   meaning problem ps   observations   possible
y  regardless state last action done  observations thus completely
irrelevant ps effect  case  p ps share set actions
set observations even actions observations ps may
defined smaller set state variables 
target subproblems ps defined terms set state variables
relevant precondition goal variables  recall assume observable
variable problem relevant action precondition goal  else variable
could safely removed 
definition     projection problem p variable x  denoted px  
projection ps p set variables   ctx x   ctx x  context
x p   i e   set state variables p relevant x 
two basic properties projected problems px are 
proposition     variable x appears goal precondition  number state
variables px determined bounded w p   
proposition     execution ha    o    a    o         i possible p   possible
px state variable x p  
b belief results execution p   call bx belief
results execution projected problem px   completeness
decomposition global belief b p expressed terms local beliefs bx
subproblems px   treat beliefs b bx relations database
   

fibelief tracking planning sensing

state variables beliefs columns possible combination values
 states local states  rows  projection b  set variables thus
represents combination values variables possible b 
join bx
nby represents combination values x sets variables
two beliefs bx x coincide variables x
  example  b contains valuations  states  x          x          
projection  x  b contain valuations x     x      likewise  b  contains
     z          z      join b
n b  contain x           z    
x           z     
theorem     state variable x  let b bx beliefs result execution
possible p px   then 
x bx   x b  

   

equation   states literal x   x possible true global belief b iff
possible belief bx results execution projected problem
px   exactly type completeness needed planning variable
x involved action precondition goal  stronger form completeness
formulas  expressed


nx bx   b  

   


n stands join operation x ranges precondition goal variables
problem  needed  actually necessarily true  even state
variables appear context ctx x   example  value boolean variable
z initially unknown  variables x initially false  action conditional
effects z x z z results belief b two states  corresponding
terms z x z x   x precondition goal variables
relevant other  projected problem px contain variables
x z  projected problem py contain variables z  belief
bx resulting execution action px include local states
corresponding terms z x z x  belief py include
local states corresponding terms z z   clearly  projection b
bx  by   variable x  y   coincide dictated      join two local
beliefs bx yield global belief b would correspond      indeed 
formula x false latter former       prove
inductively size execution that 
theorem        execution possible p iff possible subproblems
px x precondition goal variable p      execution precondition
goal variable x  x   x  resp  x    x  true b iff x   x  resp  x    x  true
bx   b bx beliefs result executing p px respectively 
since plain belief tracking projected problem px exponential size
px   bounded w p   determined variables excluded  follows that 
   

fibonet   geffner

theorem     flat belief tracking projected problems px x
precondition goal variable p   provides sound complete factored algorithm
belief tracking p time space exponential width p  
call algorithm  factored belief tracking  order check whether precondition
goal literal x   x true execution  factored belief tracking checks whether
x   x true belief bx results execution subproblem px  
execution possible action precondition x   x true bx results
empty belief subproblem  theorem    thus says factored belief tracking
sound complete algorithm btp time space complexity exponential
problem width  indeed  since every observable variable relevant precondition
goal variable x assumption  every direct cause z relevant x
evidentially relevant x  thus  formula wa  y   y  evaluated bx
determine whether observation   necessary  possible impossible applying
action a  thus  factored belief tracking solves generalized btp problem 
illustration theorem     let us go back det ring problems p whose
structure analyzed before  theorem implies order check whether given
possible execution achieves goal p   sufficient check whether goal literal
w  i    locked    n  achieved execution subproblem pw  i    thus 
factored belief tracking p done o n    time since n subproblems
pw  i    one involving   variables  w  i  constant size domain loc
domain size n 
exact situation arises non deterministic conformant problem non det
ring whose causal graph one det ring  hand  nondet ring key  subproblems must keep track kloc variable encoding key
location  thus belief update operation requires o n    time  still much better
flat belief tracking p requires time exponential n  complexity
results applies problem longer conformant agent observe whether
holding key not 
experimental figures domains shown table    factored belief
tracking used combination simple heuristics  experiments run
xeon woodcrest      cpu running      ghz   gb ram  planner
kacmbp cimatti et al  uses obdd based belief representation cardinality
heuristics  solve problems n      rooms  producing plans    
steps slightly       seconds non det ring key  conformant planners
t   palacios   geffner        cannot used problem non deterministic 
tables  a  b show scalability factored belief tracking algorithm context
greedy best first search p
heuristic h b   similar one used albore  ramirez 
geffner         h b    ni   h bi    bi belief factor projected
problem goal variable w  i  representing status ith window  h bi  
representing fraction states bi goal w  i    locked false  displayed
tables  resulting planner scales polynomially  non det ring key
    rooms  produces plan        actions       seconds  contingent
version problem agent detects key room  cont detring key  policy greedy cardinality heuristic h b    maxni    bi   used instead 
   

fibelief tracking planning sensing

n

steps

exp 

time

n

steps

exp 

time

n

avg  steps

avg  time

  
  
  
  
  
  
  
  
  
   

  
   
   
   
   
   
   
   
   
   

   
   
     
     
     
     
     
     
     
     

     
   
   
   
   
    
    
    
     
     

  
  
  
  
  
  
  
  
  
   

   
   
   
   
   
   
   
   
   
     

   
     
     
     
     
     
     
     
     
     

     
   
   
    
    
    
     
     
     
     

  
  
  
  
  
  
  
  
  
   

         
             
             
             
             
              
              
               
               
               

   
   
   
   
   
   
    
    
    
    

 a  det ring key

 b  non det ring key

 c  cont det ring key

table    results conformant contingent ring problems obtained combining factored belief tracking simple heuristics  data point panel  c  contingent
problem average  and sample standard deviation        random instances  times
seconds  column exp  contains number expansions 

ties broken randomly  bi belief factor goal variable w  i  
seen table  c  resulting planner runs polynomial time solve problems
    rooms  thus  heuristic policy weak  long executions result 
belief tracking problem efficient scales well 

   causal belief tracking
factored belief tracking exponential problem width  many problems  however 
width may high method usable practice  illustration 
consider problem p state variables x            xn     observable variables o           
oi true iff xi   xi     sensors thus wa  oi   true     xi   xi    
wa  oi   f alse     xi    xi     actions   n  let us assume
actions problem may affect xi variables introduce
causal relations among them  state variables appear preconditions
goals  causal graph problem shown figure    width n    
state variables interact  indeed  variable xi relevant variable xk  
relevance flowing xi xi     vice versa  variables causally relevant
observable variable oi evidentially relevant both  result
problem p projected problems pxi coincide denote problem 
contexts state variables include state variables 
focus different decomposition belief tracking maps problem p
smaller subproblems pxc whose size bounded number state variables
causally relevant given precondition  goal  observation variable  new width
measure called causal width problem  problem shown figure  
width n     causal width    explore belief tracking algorithms
exponential problem causal width analyze conditions
   

fibonet   geffner

x 

x 

x 



xn

o 

o 

o 





xn  

figure    causal graph   layer network example state variables x            xn  
observable variables o            on     immediate causes observable oi
variables xi xi     precondition goal variables appear underlined
yellow box  observable variables appear within blue circle  since xi variables
relevant other  width problem n      hand  since
two variables causally relevant precondition  goal  observable variable 
causal width problem   
complete  this  first generalize make explicit decomposition underlying
factored belief tracking algorithm 
definition     decomposition problem p pair   ht  bi  set
variables x appearing p   called target variables decomposition  b
collection beams b x  associated target variable made
state variables p  
decomposition   ht  bi maps p set subproblems pxd   one variable
x   corresponds projections p state variables beam b x  
decomposition underlies factored belief tracking is 
definition     factored decomposition f   htf   bf p decomposition
target variables tf given state variables x appearing action preconditions goals 
beams bf  x  given state variables relevant x 
factored belief tracking flat belief tracking applied subproblems determined
factored decomposition  algorithms introduce next based different
decomposition 
definition     causal decomposition c   htc   bc p decomposition
target variables tc given observable variables state variables appearing
action precondition goals  beams bc  x  given state variables
causally relevant x 
causal decomposition determines larger number subproblems  subproblems
generated observable variables  subproblems smaller beams
bc  x   contain state variables causally relevant x opposed
variables relevant x  causal width problem given size
largest beam causal decomposition  discounting variables determined
problem 
definition     causal width variable x problem p   wc  x   number
state variables causally relevant x determined  causal width
   

fibelief tracking planning sensing

p maxx wc  x   x ranges target variables causal decomposition
p  
first simplest belief tracking algorithm defined causal decomposition
call decoupled causal belief tracking  runs time space
exponential problem causal width 
definition     decoupled causal belief tracking  decoupled cbt  flat belief tracking
applied independently problems pxc determined causal decomposition
c   htc   bc p   subproblem pxc problem p projected variables
bc  x  x tc   i e   pxc   pbc  x   
since causal width never greater width often much smaller  decoupled
cbt runs much faster factored belief tracking general  this  however  comes
price express using expression b denoting projection  the states
the  belief b variables s 
theorem     decoupled cbt runs time space exponential wc  p   
sound complete  is  target variable x causal decomposition 
b bx beliefs resulting execution p pxc respectively 
bx bc  x  b necessarily true  bx bc  x  b not 
one reason incompleteness beliefs bx associated different target
variables x assumed independent decoupled cbt may
true  indeed  causal decomposition problem may give rise beam bc  y  
involving variable x  second beam bc  z  involving variable x another
variable x     variable observed  x   x may become false 
observation z may lead x     x  becoming false well  yet  decoupled cbt 
inference cannot captured information flow across beams  factored
decomposition situation cannot happen variable x   relevant variable
x hence beams contain x necessarily contain x    x   relevant x
causally relevant z evidentially relevant x  
causal decomposition  beams kept small closing relevance
relation  result  beliefs beams longer independent  however 
regarding beliefs tables relations  consistency relation among local beliefs
causal decomposition enforced means join operation  resulting
algorithm coupled causal belief tracking  abbreviated simply causal belief tracking 
definition     causal belief tracking  cbt  belief tracking algorithm operates
causal decomposition c   htc   bc setting beliefs b x time   beam
bc  x  projection bc  x  initial belief  x tc   successive beliefs
bi  
x as 
bi  
n  biy  oa   tc relevant x 
   
x   bc  x 
  ai   oi action observation time execution 
 biy  oa boa eqs      b   biy  
cbt  beliefs tracked independently subproblems pxc
causal decomposition  rather  beliefs first progressed filtered independently 
   

fibonet   geffner

merged projected back onto beams  making consistent
other  progression filtering local beliefs causal decomposition performed time space exponential problem causal width  full consistency
operation captured join project operation     requires time worst case
exponential problem width 
theorem     cbt space exponential causal width problem  time
exponential width 
cbt sound incomplete  however  range problem cbt complete 
unlike decoupled cbt  large meaningful enough  includes example three
domains considered experiments below  battleship  minesweeper
wumpus  express completeness conditions cbt introducing notion
memory variables 
definition     state variable x memory variable problem p value x k
variable x time point k execution determined uniquely observation
value x x time point i  k  actions execution  initial
belief state problem 
example  static variables memory variables change thus
knowing value time point determines value point  determined
variables  section    memory variables since value x k variables
determined initial belief actions done time k  likewise  variables
permutation domains actions permute values variables  amir   russell 
       memory variables  three sufficient conditions state variable
memory variable easy check  problem said causally
decomposable following condition holds 
definition     problem p causally decomposable every pair beams bc  x 
bc  x     causal decomposition p non empty intersection  x  
observation variable  either    variables intersection memory variables 
   variable w causal decomposition relevant x x  
whose causal beam bc  w   contains bc  x  bc  x     
problem causally decomposable  filtering implemented updates
cbt using equation   suffices completeness 
theorem     causal belief tracking always sound complete causally decomposable problems 
importance result many meaningful domains whose problem
instances causally decomposable  particular  domains variables appear
two different beams static  this include minesweeper   domains variables
appear two different beams either static determined  this includes wumpus 
non static variable agent location determined   domains
hidden non static state variables appear one beam  this includes battleship
hidden non static variables appear intersection beams   cases
well  sect        present variation wumpus monster moves
non deterministically grid instance causally decomposable
problem 
   

fibelief tracking planning sensing

   approximation  beam tracking
causal belief tracking algorithm shows possible track beliefs planning
sound complete manner large meaningful class problems  considering
beliefs subproblems smaller factored decomposition 
algorithm  however  space exponential causal width problem 
time exponential problem width  global consistency operation
enforced      beam tracking final belief tracking algorithm consider 
replaces global consistency operation local consistency operation
performed polynomial time  beam tracking thus approximation causal belief
tracking aimed efficient effective rather complete 
definition     beam tracking belief tracking algorithm operates causal
decomposition c   htc   bc i  setting beliefs b x time   projection initial
belief beam x tc   setting successive beliefs bi  
x two steps  first 


set progressed filtered belief ba b   bx     ai   oi  
ai oi action observation time execution  then  local form
consistency enforced upon beliefs means following updates fixed
point reached 
i  
   
bi  
nbi  
 
x   bc  x   bx
refers target variable causal decomposition bc  y  
bc  x  non empty 
filtering represented iterative update eq    defines form relational
arc consistency  dechter   beek        equality constraints among beams sharing
common variables enforced polynomial time space size beams  beam
tracking remains sound complete  causally decomposable problems  however 
incompleteness sole result replacing global local consistency 

    extensions  modeling  width
testing beam tracking algorithm empirically  present two simple extensions
language contingent planning useful modeling  briefly discuss
modeling choices affect causal width problem  first extension allows
use defined variables preconditions goals  second extension allows use
state constraints restricting possible value combination subsets variables 
     defined variables
variable z domain dz defined function subset state variables
problem  function belief variables  example  boolean variable
z defined true two variables x equal  third variable w
known true  defined variables z function set sz state variables
function belief variables  handled action preconditions
goals introducing beam decomposition includes variables sz
along variables relevant causally relevant them  according whether
decomposition factored causal  width causal width problem follow
   

fibonet   geffner

then  before  size largest beam factored causal decompositions
determined variables excluded 
     state constraints
state constraints used restrict value combinations given subsets state variables  game battleship  example  modeled state variables associated
cells grid representing whether cell part ship  size
ship cell belongs  if any   relative position cell within ship
cell belongs  if any   whether ship placed vertically horizontally  state variables  however  independent  indeed  ship size   
horizontally placed cell         cells     i                     must belong  the
same  ship 
formally  state constraint represented formula c state variables
encoded means dummy observable variable always observed
true  observed true states c holds  i e   model
wa  y   true    c every action a  implementation  however  pays treat
constraints c relations  the set valuations satisfy c   include
joins beliefs include variables c  causal belief tracking
effect completeness complexity algorithm  beam tracking 
changing update    
i  
n c 
n
n cn  
n bi  
bi  

x   bc  x   bx

   

c            cn state constraints whose variables included bc  x  bc  y   
makes local consistency stronger effect complexity algorithm  moreover  one pair beams state constraint  state constraints
increase causal width problem constant factor   most  yet
effective causal width problem change  beams associated
dummy observables introduced constraints redundant ignored 
later case  using beam tracking  constraints ci need stored
extensional form relations handled intentionally boolean functions
test whether assignment join two beams satisfies constraint 
     modeling width
complexity belief tracking algorithms function width causal width
problem  turns depends way problem encoded  often small
changes encoding drastic effect resulting widths  example 
wumpus problem  russell   norvig         natural define conditions
stench signal received setting observation model to 

w
w
wa  stench   true    c  pos   c  c  wumpc 
pos encodes agent position  c ranges possible cells  c  ranges cells
adjacent c  wumpc  denotes presence wumpus c    encoding 
however  results beam observable variable stench includes wumpc
   

fibelief tracking planning sensing

szx y

hitx y

waterx y

nhitsx y

ancx y

hzx y

figure    causal graph fragment battleship  circled variables observable
others state variables  problem one type variable cell  x  y 
grid  causal width problem   
variables  hence whose size grows grid size  better alternative results
beams bounded causal width exploit fact position agent pos
determined  taking advantage this  observable variable stench replaced
observable variables stenchc   one cell grid  sensors characterized
model 
wa  stenchc   true     pos   c 

w

c 

wumpc   

beams stenchc variables contain four wumpc  variables  one cell
c  adjacent c  way  causal width wumpus problem becomes bounded
independent grid size  number wumpus pits  see below  
idea
w generalized automated  observation model form wa  z  
z    x  x   x    x  formula constructed determined variables 
replaced observation models wa  zx   z     x   x  expanding
number observable variables  likewise  multiple observation models wai  z   z   
one observable variable z different actions  ai  ir conveniently replaced
observation models wai  zi   z      r different observable variables zi  
different formulas involve different variables  alternatives domain encoding
difference bounded unbounded causal width  hence  whether
complexity beam tracking grow polynomially exponentially 

    experiments
tested beam tracking large instances battleship  minesweeper  wumpus  combination simple heuristics action selection make use computed beliefs  width problems bounded  hence  neither factored
causal belief tracking used except small instances  hand 
domains small bounded causal widths encodings provided  hence
beam tracking runs efficiently time space  exact belief tracking
domains difficult  kaye        scott  stege    rooij         sizes
instances considered much larger used contingent planning  moreover 
domains full contingent solutions  thus compare on line
planner relies handcrafted heuristics two reported solvers rely belief
tracking algorithms tailored domains  consider non deterministic version
wumpus domain  results obtained xeon woodcrest      cpu
running      ghz  gb ram 
   

fibonet   geffner

     battleship
battleship popular two player guessing game  standard version consists four
ships length           units secretly placed    by    grid  ship
adjacent diagonally adjacent another  task sink ships firing torpedos
specific cells  fired torpedo  told whether torpedo hits water ship 
ship sunk cells hit  problem encoded   state variables
per cell  x  y    hitx y tells torpedo fired cell  szx y tells size
ship occupying cell    ship   hzx y tells ship placed horizontally
vertically  true ship   nhitsx y tells number hits ship   
ship   ancx y tells relative position ship cell    ship  
single observable boolean variable water deterministic sensor model given
wf ire x y   waterx y   true     szx y       action model complex firing
torpedo  x  y  may cause change variables associated cells  x        
indeed  denotes maximum size ship    standard game   f ire x  y 
includes conditional effects variables referring cells  x        vertical
horizontal distance units  goal problem achieve equality
nhitsx y   szx y cells may contain ship  state constraints used
constraining sets state variables described above  encoding  causal beams
never contain   variables  even though problem width bounded
grows grid size  figure   shows fragment causal graph battleship 
table   shows results two policies  random policy fires non fired cell
random  greedy policy fires non fired cell likely contain ship 
approximations probabilities obtained beliefs maintained beam
tracking   difference performance two policies shows beliefs
informative  moreover        game  agent fires          torpedos
average  matching quite closely average results silver veness       
obtained combination uct  kocsis   szepesvari        action selection 
particle filter  doucet et al         hand tuned domain belief tracking 
approach  however  involves        simulation per action result order   seconds
per game       instances  greedy approach takes        seconds per game 
     minesweeper
objective minesweeper clear rectangular minefield without detonating mine 
play either opens flags cell  first case  cell contains mine  game
terminated  otherwise integer counting number mines surrounding cell
revealed  initial configuration minesweeper consists n minefield k
randomly placed mines  three standard difficulty levels game
made                  boards           mines respectively 
   rich encoding allows accommodate observation ship fully sunk 
experiments  however  observation used order compare results reported
silver veness        
   probabilities events defined variables beam obtained ratio number states
beam satisfy event total number states beam 

   

fibelief tracking planning sensing

avg  time per
dim

policy

 ships

 torpedos

decision

game

     
     
     
     

greedy
greedy
greedy
greedy

 
 
  
  

        
          
          
           

   e  
   e  
   e  
   e  

   e  
   e  
   e  
   

     
     
     
     

random
random
random
random

 
 
  
  

        
          
          
            

   e  
   e  
   e  
   e  

   e  
   e  
   e  
   e  

table    results battleship  table contains results greedy random
policies described text        board    ships sizes           
size board increased n  number ships size gets multiplied
n  average sample standard deviation number torpedos required sunk
ships  calculated        random instances board  shown  average times
seconds 

problem encoded  mn boolean state variables minex y   openedx y
f laggedx y denote presence absence mine cell  x  y  whether cell
opened flagged  mn observable variables obsx y domain                  
two type actions open x  y  f lag x  y  first precondition effect f laggedx y openedx y   second precondition minex y
effect f laggedx y   sensor model given formulas specify integer
agent receives opening cell terms status minex   y  variables
surrounding cells  formulas are 
wopen x y   obsx y        minex y  
wopen x y   obsx y   k    minex y

w

tn  x y k   

  k      

wopen x y   obsx   y    k    true  

 x            x  y    k    

wf lag x y   obsx   y    k    true  

 x          k    

n  x  y  k  terms   cell variables minex   y  surrounding cell  x  y 
make exactly k literals true  initial situation  variables openedx y
f laggedx y false minex y unknown  goal problem get disjunction f laggedx y openedx y cell  x  y  without triggering explosion 
beams result factored decomposition contain  mn state variables  making beams identical resulting unbounded width  mn  causal
width  hand    causal beams openedx y f laggedx y identical
contain   variables  beams obsx y contain   minex   y  variables
cells  x        surround cell  x  y  along variable minex y   figure  
contains fragment causal graph minesweeper 
   

fibonet   geffner

minex   y 

minex y

f laggedx y

openedx y

obsx y
figure    sketch causal graph minesweeper  observable variables obsx y
state variables minex y   f laggedx y openedx y cell  x  y   cell  x       
represents one adjacent cells  x  y   since   cells  causal width
problem   
avg  time per
dim

 mines

density

 win

 guess

decision

game

  
     
     
     

  
  
  
   

     
     
     
     

    
    
    
    

   
   
     
   

   e  
   e  
   e  
   e  

    
    
    
    

table    results minesweeper  table contains results three standard levels
game plus larger instance  average results       runs shown  average
times seconds 

table   shows results three standard levels game much larger
instance  battleship  greedy policy used action selection makes use beliefs
computed beam tracking  flagging opening cell certain content  else
selecting cell lowest probability containing mine opening it 
probabilities approximated beliefs beams indicated before  despite
complexity game  np complete checking consistency  kaye        conpcomplete inference  scott et al          beam tracking scales well solves difficult
games quickly  moreover  results shown table competitive recently
reported lin  buffet  lee  teytaud         obtained combination
uct action selection  domain specific csp solver tracking beliefs  success
ratios report are                 instances    mines           
      instances    mines                  instances   
mines  authors report times 
     wumpus
wumpus game  russell   norvig        consists maze agent
moves around looking gold avoiding hidden pits wumpus monsters 
initially  agent know positions gold  pits wumpuses  senses
glitter cell gold  senses stench breeze adjacent
cell wumpus pit respectively  n instance described known state
variables position orientation agent  hidden boolean variables
cell tell whether pit  wumpus  nothing cell  one
   

fibelief tracking planning sensing

heading
gold pos

pos

pitx   y 

wumpx   y 

glitter

deadx   y 

breezex y

stenchx y

figure    fragment causal graph wumpus  observable variables
breezex y   stenchx y deadx y   state variables heading  pos  pitx y wumpx y  
 x  y  ranging grid cells  cells  x        stand cells adjacent  x  y  
causal width problem     cells  state variables heading
pos determined 
hidden state variable stores position gold  observable variables boolean 
glitter  breezex y   stenchx y deadx y    x  y  ranging different cells 
actions move forward  rotate right left  grab gold  causal width
encoding   problem width grows n  figure   shows fragment
causal graph wumpus  size causal beams breeze stench
variables bounded   cell   neighbors heading
position variables agent determined 
table   shows results different grid sizes number pits wumpus 
agent selects actions greedy policy based heuristic returns length
minimum length safe path nearest cell may contain gold  beliefs
computed beam tracking used determine cells safe  known contain
wumpus pit  may contain gold  aware tested
scalable solver wumpus making comparison  exception recent
lw  planner built work  bonet   geffner         figures table
show clearly beam tracking computes beliefs effectively efficiently domain 
instance        instances    pits    wumpus solved successfully    
time  less     seconds average  moreover  unsolved instances
actually shown unsolvable sense agent could reach unvisited
cell safe manner  proved unsolved instance calling sat solver
propositional theory encodes game literals learned agent
execution 
     non deterministic moving wumpus
order evaluate beam tracking complex non deterministic domain  the nondet ring key domain section   small width   designed non deterministic
variant wumpus domain  moving wumpus one wumpus grid
wumpus moves around non deterministically everytime agent moves 
grid still contains hidden pits hidden gold  order make game safer
agent  wumpus sensor enhanced detect position wumpus
 euclidean  distance less   agent  else safe strategy escaping
death general  
   

fibonet   geffner

avg  time per
dim

 pits  wumpus

 density

 decisions

 win

decision

game

  
     
     
     
     
     
     
     
     
     

   
   
   
   
       
       
       
         
         
         

   
   
   
   
   
   
    
    
    
    

      
      
       
       
       
       
         
         
         
         

    
    
    
    
    
    
    
   
   
   

   e  
   e  
   e  
   e  
   e  
   e  
   e  
   e  
   e  
   e  

   e  
   e  
   e  
   e  
   
   
   
    
    
     

table    results wumpus  size  performed       runs  table shows
total number density pits wumpus grid  total number decisions
across runs  percentage runs agent found gold  average
time seconds per decision game 

moving wumpus causally decomposable thus incompleteness beam tracking
domain due replacement full consistency among beams done
cbt weaker efficient  relational  arc consistency done beam tracking 
see this  observe variable memory variable position
wumpus wloc  however  two beams causal decomposition
contain variable  beam wloc beam observable variable
tells position wumpus  former beam contained latter beam  
experimental results beam tracking domain presented table  
policy obtained using aot lookahead algorithm based ao   bonet   geffner      a 
builds lookahead tree depth    using    expansions  heuristic function
measures distance agent position closest unvisited cell 
algorithm evaluated different instances grids nn n                       
number pits equal  n       grid size  performed      
evaluations different initial configurations wumpus  pits gold randomly
placed  instance game may turn unsolvable gold isolated
agent pits  agent finds position safe movement 
agent exceeded maximum number actions  set   times number
cells grid  

   indeed  general version problem involves wumpuses move non deterministically
grid  version causally decomposable beams positions wumpuses
 one wumpus  contained beam observable variable  general case 
problem would causal width equal m 

   

fibelief tracking planning sensing

avg  time per
dim

 pits

 density

 decisions

 win

decision

game

  
  
  
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 

   
   
   
   
   
   
   
   
   

      
      
      
      
       
       
       
       
       

    
    
    
    
    
    
    
    
    

   e  
   e  
   e  
   e  
   
   
   
   
   

   e  
   
    
    
     
     
     
       
       

table    results non deterministic moving wumpus domain  grid size 
averages       runs shown  table shows total number density pits
grid  total number decisions across runs  percentage runs
agent found gold  average time seconds per decision game 

    related work
formulation paper closely related recent translation based approaches
conformant contingent planning compile beliefs away  palacios   geffner       
albore et al          translations  however  assume problems deterministic 
account yields similar widths deterministic benchmarks 
simpler  defined multi valued variables  general 
handles non deterministic actions  yet account less tight deterministic problems  illustration     x  xn   actions ai  
conditional effect xi g               n  conformant problem goal g width
  palacios geffners account  width n ours  relevance account based
literals indeed finer one based variables difficult
generalize non deterministic settings  difference seem practical
effects benchmarks disjunctions initial situation exclusive
implicitly encode possible values set multi valued variables  another important
difference approaches complete translations always exponential
problem width  complexity bound worst case  i e   variables contexts
highly correlated  actual complexity factored belief tracking much lower 
notion width appears bayesian networks inference exponential
width network  pearl         three differences pointed
relation notion width    exploit knowledge certain variables
observable     determine use knowledge certain variables
determined     make use distinction action conditions preconditions planning  example  problem agent go n doors
whose status  open closed  observed agent near door 
width smaller n modeled dynamic bayesian network  door
variables affect agent location variable  setting  however  problem width
   

fibonet   geffner

  status door need known agent open  close
walk door 
causal decomposition resulting causal belief tracking algorithms similarly related ideas variable splitting renaming graphical models 
variable x appearing different factors replaced different variables xi   one per
factor  choi   darwiche        ramirez   geffner         problem width
reduced  then  equality constraints relating xi variables must enforced 
approximate belief tracking algorithms dynamic bayesian networks pomdps
appealed idea decomposing global beliefs variables local beliefs subsets variables  boyen   koller        shani  poupart  brafman    shimony 
       key difference causal belief tracking algorithm provide
conditions type decomposition remains sound complete 
hand  deal uncertainty represented sets states  probability
distributions 
number logical schemes representing tracking beliefs used
developed contingent planning  appealing obdds  cnf  dnf representations
 bertoli et al         bryce et al         et al          relevance considerations  tran 
nguyen  son    pontelli         lazy sat regression techniques  hoffmann   brafman        rintanen        shani   brafman         none approaches  however 
tried domains considered paper instances similar size 
indeed  causal width domains bounds complexity beam tracking  similar bound known schemes unlike beam tracking complete 
moreover  principle schemes handle non determinism naturally 
methods based sat not  k replanner  bonet   geffner       
based efficient effective belief tracking method polynomial
fully general cannot deal non deterministic actions  follow lw  planner
 bonet   geffner        shares features k replanner complete width  
problems 
experimental perspective  several comments questions order
relation beam tracking algorithms used belief tracking contingent
planners existing benchmarks  first all  practically benchmarks used
far contingent planning easy belief tracking point view  indeed 
quadratic linear time representation beliefs clg lw  respectively 
shown adequate problems  including wumpus problems above 
exception minesweeper  belief tracking provably np hard
linear approximation lw  turns much weaker beam tracking  failing
solve without guessing instances beam tracking solve
way  bonet   geffner         means that  whether width problems
low high  effective width    cases  beam tracking cannot help
computationally  actually  may degrade performance  except minesweeper   beam
tracking exponential problem causal width  lower width general
usually higher    effective width problem p minimum non negative
integer value contingent translation xi  p    palacios   geffner        albore
et al         solution  effective width problem never greater width
much smaller width causal width  example 
   

fibelief tracking planning sensing

avg  time per
dim

 mines

 density

 succ

 failure

 aborted

decision

game

  
     
     

  
  
  

    
    
    

    
    
    

   
   
   

   
   
    

   
   
    

    
       
       

table    comparison sdr on line planner minesweeper instances  sdr fed
random hidden states solutions  action sequences  computed beam tracking
guessing  planner task check applicability actions given
solution whether goal holds  instance size  sdr tested     different
random problems  column failure indicates number times sdr able
verify correct solution  column aborted indicates number times
sdr terminated early due bug  times seconds  beam tracking takes
seconds solving instances  see table    

problem actions ai conditional effects map valuations vi set variables
x            xn goal literal   y  width causal width smaller
n variables xi causally relevant   yet effective width
problem may   values xi variables observed directly
inferred observations  also  goal achieved without using
actions all  sense  notion effective width provides lower bound
number state variables whose uncertainty must tracked jointly order make
problem solvable  notions width  characterized syntactically  provides upper
bound number state variables whose uncertainty must tracked jointly
solution would missed  gap two bounds large indeed 
obtaining syntactic characterizations former open problem 
related question various belief tracking algorithms used contingent planning regression  obdds  cnf  dnf  scale domains 
general comparison complete exponential algorithms incomplete polynomial algorithms beam tracking  over domains bounded causal width  would
fair  would still interesting find easy cases algorithms scale polynomially exponentially  performing tests  however 
simple  requires getting code planners would
follow fixed common policy instance  thus leaving planning component aside 
moreover  even fixing policy instance  enough  planners
off line hence track beliefs many possible executions one 
case on line planners 
purpose illustration performed test one difficult
domains  minesweeper  supplying on line planner sdr  shani   brafman       
execution computed beam tracking along hidden initial state
execution  setting  on line planner sdr planning  rather
tracking beliefs problem verify goal achievement preconditions
given applicable action time point  minesweeper instances solved
   

fibonet   geffner

beam tracking without guessing  i e   pure inference first fixed choice  table  
shows results sdr tracks beliefs using form regression  rintanen       
shani   brafman         two observations made comparing results
table table   beam tracking  first  sdr takes              
        seconds average verifying solutions                  instances
respectively  beam tracking takes                 seconds finding solutions
following greedy policy  since finding solutions expensive verifying
one must least identify applicable actions time point difference
performance turns several orders magnitude  growing grid size 
addition  regression mechanism sdr fails verify correct solutions several cases
aborts failure large number cases large instances  case 
performance gap surprising  belief tracking minesweeper np hard  thus
complete algorithms regression run exponential time worst case 
beam tracking remains polynomial causal width domain bounded 
challenging problems  gap performance beam tracking complete belief
tracking algorithms similar  beam tracking useful causal width
problem bounded large  trading principled way completeness
tractability 

    summary
effective belief tracking crucial planning incomplete information sensing 
problem intractable general  shown elsewhere belief tracking deterministic problems exponential width parameter often bounded
small  work  introduced related formulation applies nondeterministic problems well  factored belief tracking algorithm results set
projected problems whose size bounded problem width  beliefs goals
preconditions obtained directly beliefs projected problems
maintained independently  developed different decomposition
scheme belief tracking algorithm maintains beliefs smaller projections 
provided conditions algorithm complete  causal belief tracking
space exponential problem causal width remains time exponential problem width  global consistency beliefs smaller projections need
enforced  finally  beam tracking sound incomplete approximation causal belief
tracking global consistency replaced local powerful form consistency 
beam tracking runs time space exponential problem causal width
often much smaller problem width  tested beam tracking large
instances battleship  minesweeper  wumpus  combination simple heuristics
action selection  performance compares well state of the art solvers
using orders of magnitude less time  future  would explore extensions
proposed framework belief tracking pomdps  belief states sets
states probability distributions  particle based algorithms provide common
approximation  doucet et al         
   

fibelief tracking planning sensing

acknowledgments
thank gabriel detoni java tewnta framework  http   code google com p 
tewnta  implementing client server games graphical interface developed graphical interfaces battleship  minesweeper wumpus  thanks
james biagioni wumpuslite java simulator  http   www cs uic edu  jbiagion 
wumpuslite html  adapted run experiments wumpus  guy shani
help running sdr  hector geffner partially supported eu fp  grant        
 spacebook  micinn csd            simulpast  

appendix a  proofs
formal results needed stated propositions theorems
main text article appear form lemmas 
a   complexity flat belief tracking
let us first formally define decision problems btp gbtp  btp language
btp    hp    p contingent problem  possible execution  b    g 
p   hv  i  a  g  v     w i    ha    o              execution  b belief
results execution initial belief state  gbtp btp except
consists triplets hp     i p contingent problem  possible generalized
execution    goal  precondition observation literal  b      
observe btp gbtp respectively include tuples hp  hp     i
problem empty initial belief state  due two complementary literals appearing unit clauses i  since case every execution trivially possible b
trivially entails literal   
proposition    btp polynomial time reducible gbtp 
proof  idea map normal execution generalized execution results
replacing pair ha  oi sequence ha       noopa                noopa     v    
               v     observation literals made true o  one observable variable
v     noopa action requires nothing nothing whose sensor
model wnoopa       wa     observation literal   
formally  given instance hp  btp  reduction must generate polynomial
time instance hp          i gbtp hp  btp iff hp          i gbtp 
problem p   problem p extended actions noopa   new boolean
variable xgoal denotes achievement goal g p   new action agoal
precondition g effect xgoal   new dummy observable variable domain
    models wa  y        true actions a  hand  generalized
execution   hm   agoal      i     xgoal   clearly  reduction works polynomial
time hp  btp iff hp          i gbtp 
theorem    flat belief tracking exponential  vu    vu   v   vk vk
set state variables v determined 
   

fibonet   geffner

proof  described definition    flat belief tracking consists explicit representation
beliefs set states  savings space time obtained noting
variables vk determined 
explicit representation beliefs  belief tracking problem gets trivially solved
checking whether execution   ha    o              possible literal  
true reduces computing belief bn   results checking whether
bn   empty whether every state satisfies    time complexity algorithm
time needed compute initial belief b  plus  n      multiplied time needed
compute bi   bi plus time needed check validity    among times 
last easiest calculate linear size bn     thus need bound
first two times  begin proof showing flat belief tracking done
time exponential  v   reduce exponential dependency  v    vu   
computing b  enough generate possible states  valuations variables 
filter satisfy clauses i  total time thus spent
 v    i   o  v    since  o  v    valuations   i  clauses  clause
 v   literals  
time compute bi   bi consists time check preconditions
hold b  times compute ba b boa ba b   bi     ai
  oi   preconditions easily verified iterating states b  time
bounded  v    o  v    since contains  v   preconditions b contains
 o  v    states  precondition satisfied state b  execution
possible 
belief ba computed b iterating state b 
possible state s  ba   checking whether s  f  a  s   two nested
iterations require time  o  v     o  v       o  v      test s  f  a  s  performed
time exponential  v   follows  let ci e i    eni     m 
collection conditional effects action trigger state s  s  f  a  s  
s  result applying one head conditional effect s  since
problem  v   variables  among heads  v   heads map
s  rest  if any  subsumed first  subsets heads size
 v   enumerated  o  v    time  subset checking whether gets
mapped s  requires o  v    time  therefore  checking s  f  a  s  requires  o  v    time
well computing ba b 
ba obtained  boa calculated removing  filtering  ba states
comply observation o  state ba observation literal
  compatible o  state belongs boa iff    wa      latter test
performed time linear  wa       size formula wa      hence  since
 v     observation literals compatible o  boa computed ba time o  ba  
 v      wa     wa     max   wa      max ranges observation literals   
boa empty ba non empty  execution possible 
   calculation  implicitly assume variable domains constant size  otherwise 
domains size n linear input size  number valuations bounded  o  v   log n 
instead  o  v      either case  number valuations still exponential number variables
well resulting complexity flat belief tracking 

   

fibelief tracking planning sensing

times weighed in  see flat belief tracking done time
exponential  v   
reduce exponent  v    vu    direct since determined
variable valuation across states reachable belief  hence  variables
contribute increase number states reachable beliefs  likewise 
subsets heads size  vu   need considered computing belief ba b 
hence  computations done time space exponential  vu   
theorem    btp gbtp turing complete class pnp  
proof  proposition    btp polynomial time reducible gbtp  thus enough
show hardness btp inclusion gbtp 
class pnp set decisions problems decided  deterministic 
polynomial time using oracle sat  show btp hard class 
enough show unsat reduced polynomial time btp since every
call np oracle replaced call btp oracle  hand 
show gbtp belongs pnp   enough show algorithm
complement gbtp  since pnp closed complementation  runs polynomial
time makes calls oracle sat 
hardness  let    c            cm   cnf theory boolean variables x            xn  
need construct polynomial time contingent problem p   hv  i  a  g  v     w
execution hp  btp iff unsatisfiable  variables
problem p boolean given v    x            xn   q  v      z            zm   
empty set clauses g    q   true   actions a              empty
preconditions conditional effects  sensor model wai  zi   true    ci q
wai  zj   true    f alse j    i  finally  execution   ha    o              om
oi v    valuation makes zi true zj false j    i 
note initial belief contains  n   v  valuations  half satisfying
q half q  first observation o  received  valuations
satisfy clause c  q preserved  thus  inductively  observation oi
received  valuations satisfy clauses  c    c            ci   q preserved 
therefore  b set valuations satisfy q hence non empty  i e  
possible execution   thus  b    g iff valuations q gone iff unsatisfiable 
inclusion  complement gbtp consists tuples hp     i b  non empty
either non executable b        since consists unit clauses  b     iff
contains pair complementary literals  assume   ha         a                    n i 
literals  i observation literals  let bi belief action ai
applied  i e   bi   boa b   bi      ai     i    then  possible iff
bi non empty action ai applicable bi   assume established
prefix   ha                 ai     i  possible  checking whether i   possible
involves two operations     checking precondition literal ai holds bi 
   checking whether least one state bai complies  i   b   bi   
first check done calling sat oracle cnf theory i   
time indexed propositions state variable literals actions  encodes possible
state trajectories fixed valuation actions  time horizon theory
   

fibonet   geffner

                theory built way satisfiable iff state
time  i e   bi    satisfy least one precondition ai   theory
polynomial size built polynomial time  likewise  second check
performed calling sat oracle cnf theory i  property
satisfiable iff state bi  complies observation  i  
hence  algorithm decides complement gbtp works building theories
             n  stage t  accepts input satisfiable
unsatisfiable  if  end  algorithm accepted yet  builds another theory
n     instead checking whether precondition action ai doesnt
hold  checks whether input literal   doesnt hold  n   satisfiable  accepts
since belief b satisfy    else rejects hp     i gbtp 
a   factored belief tracking
following  state  valuation variables  subset variables  write
s s denote valuation restricted variables s  called projection
s  general  use symbols s  primed versions denote states 
symbols u  v primed versions denote projected states  restrictions
partial valuations  
proposition    belief tracking deterministic non deterministic conformant setting exponential maximum number non determined variables causally
relevant variable appearing action precondition goal 
proof  proposition special case theorem     and theorem     
theorem     belief tracking p exponential w p   
proof  conformant setting  observable variables hence evidential
relevance relation empty relevant relation equals causally relevant relation 
therefore  context variable x equals set variables causally relevant
x  theorem establish proposition   conformant setting 
general setting  theorem shown constructing algorithm belief
tracking whose time complexity exponential w p    definition analysis
algorithm done series claims terminate theorem    below 
proposition     variable x appears goal precondition  number state
variables px determined bounded w p   
proof  number state variables px  ctx x   number state variables
determined px  ctx x  vu    definition width  quantity
less equal w p   x goal precondition variable 
establish two fundamental lemmas progression actions projection observable models  following  say subset variable causally
closed variable x variable causally relevant x  s 
likewise  causal closure variable z minimum  with respect set inclusion 
subset variables causally closed includes z 
   

fibelief tracking planning sensing

lemma    factored progression   consider consistent problem p   let state 
action applicable s  then  causally closed subset variables 
   every u    u  fs  a  s s   s  f  a  s  u    s   s  
   every s    s  f  a  s  s   s fs  a  s s  
fs transition function projected problem ps   therefore  f  a  s   
fs  a  s s   every state applicable  f  a  u     fs  a  u   every
set u valuations applicable 
proof  part    let u  element fs  a  s s   let hs    esi  m
i   collection
heads conditional effects csi esi trigger s s result u   
fixed             m   know s s    csi   esi    then  definition causally
relevant relation  v ars c   thus csi   c   therefore     c effect
triggers applied s  show effect affects variable
triggers applied s  indeed  conditional effect c f affects
variable triggers     c thus s s    cs fs hs   finally  effects
trigger affect variables problems p ps   since p
consistent  set effects  e  m
i   contained set h heads effects
trigger applied s  therefore  u  projection state s 
results applying effects h s  i e   u    s   s  
part    let s  element f  a  s  let h    e  m
i   collection heads
conditional effects c e trigger result s    fixed             m  
know    c thus s s    c  s   therefore  effects csi esi trigger
applied s s ps   show effect affects variable
triggers applied s s ps   indeed  let us suppose projected conditional
effect cs fs affects variable triggers s s   then  v ars f   thus
v ars c  s  since causally closed  cs   c  therefore     c effect
triggers applied s  finally  since effects trigger affect
variables problems p ps   s   s result applying
 
projected effects  esi  m
i   s s   i e    s fs  a  s s   
lemma    observational closure   every variable x  action a  observation literal
    z   z  wa    s either wa     true    ctx x  
proof  let  x            xn   variables wa      definition relevant relation 
z relevant xi vice versa  hence  z xi belongs s  z
xi belongs well  therefore  wa    s either wa     true 
following results obtained induction length executions 
noted before  loss generality consider generalized executions instead
executions  however  easier consider even general executions correspond
finite sequences alphabet  ha   i   a    lits v     
set actions lits v     set observation literals  type executions
general require interleaving actions observations  i e  
execution may contain multiple actions observations sequence  example 
   

fibonet   geffner

execution ha    a    ha       i  ha       i       i indicates initial belief needs
progressed actions a  a    filtered formula wa         filtered
formula wa         on  case normal generalized executions 
direct mapping generalized executions new type executions 
one execution  b denotes belief results applying initial
belief  b   b   ba ba   denote beliefs result executions
    h  ai     h  ha   ii respectively  therefore  making induction
length executions prove claim  need show claim initial belief
corresponds empty execution  beliefs form ba ba   b   b  
next definition lemma make precise notion decomposable belief
plays fundamental role results  intuitively  belief b decomposable
every pair states s  b  state w b agrees variables
subset agrees variables subset  where certain
subsets variables   symbols  w b w s   s s w t   t t  
definition lemma    decomposability   belief state b decomposable iff
every variable x  observation literal     z   z  action a  subset v ars wa     
causally closed ctx x      holds 


s  s  b   w w b w ctx x    s ctx x  w t   t t  
turns every reachable belief decomposable 
proof  let b reachable belief  then  execution b   b  
proof induction length   empty  claim holds since contains
unit clauses ctx x     
assume beliefs reachable executions length less equal
n decomposable  consider execution   length n     augments
execution length n  following  b denotes belief b   res a  s  denotes
state results applying deterministic action state s 
case      h  a  i  let x     statement lemma    ctx x  
let s    t  two states ba    therefore  two determinizations a  a 
a  s    res a    s  t    res a    t  s  b  apply inductive hypothesis
obtain w b w s   s s w t   t t   since disjoint
causally closed  determinization   a  a  res a    s  s   res a    w  s
res a    t  t   res a    w  t   sought w  ba  thus w    res a    w  
case      h  ha       ii  before  let x     statement lemma 
   
let      z     z     let s    t  two states ba      consider two subcases whether
v ars wa         not    ctx x  
subcase  v ars wa         s  since  s    t  b  apply inductive hypothesis get w  b
   
w   s   s   s w   t   t   t   then  w  ba    w   s   s   s    wa       s  
wa        
    existence determinization granted second assumption planning problem
fact sets variables disjoint 

   

fibelief tracking planning sensing

subcase  v ars wa           s  lemma    v ars wa             let   minimal
causally closed subset variables includes v ars wa          observe    
since belongs intersection  z   relevant   relevant x  thus
z   relevant x contradicting v ars wa             apply inductive hypothesis
using   get w  b w   s   s   s w   t     t   t     w 
   
looking   thus w   t   t   t   w  ba    since
w   t     t   t      wa       t     wa        
last technical lemma  giving proofs theorems        establish
existence partial valuations projection filtered beliefs following 
lemma    factored filtering   let x variable    ctx x   b reachable belief 
action      z z observation literal  ba   non empty u
u b u    wa    s   u ba    
proof  assume ba   non empty let u s valuation satisfies antecedent lemma  wa    s   wa      u    wa     u ba    
wa    s    wa     lemma    v ars wa          let minimal
causally closed subset variables includes v ars wa       note
z evidentially relevant relevant x  thus z relevant x
v ars wa      s  therefore      let ba   b apply lemma   get
w b w s   u w t   t t   hence  w t    wa    t   wa      w ba  
u ba    
theorem     state variable x  let b bx beliefs result execution
possible p px   then  x bx   x b 
proof  let execution possible p px   prove
general result bx   b   ctx x   general x
x bx   x b   x b  proof induction length   empty
execution  result follows readily since contains unit clauses  assume
claim holds executions length n  let   execution length n    
augments execution length n possible p px   further  let b
bx beliefs result p px respectively  then  inductive
hypothesis bx   b 
case      h  ai  need show bx a   ba   following  fs denotes
transition function px   forward inclusion given


 
u  bx a   u u bx u  fs  a  u 


 
  us u bx u  fs  a  u  b s s   u


 
  uss  u bx u  fs  a  u  b s s   u s  f  a  s  s   s   u 


 
  ss  b s  f  a  s  s   s   u 

 
 
  s  s  ba s   s   u    u  ba
   

fibonet   geffner

  definition bx a     inductive hypothesis    lemma     
  definitions ba ba respectively  backward inclusion

 


 
s   s ba   b s  f  a  s    b s  f  a  s  s   s fs  a  s s  

 
 
  s s bx s   s fs  a  s s     s   s bx a
  definition ba     lemma      inductive hypothesis   
definition bx a   therefore  bx a   ba  
a  
case      h  ha   ii  need show ba  
x   b   forward inclusion
 

 

 

a  
u ba  
x   u bx u    wa    s   u b u    wa    s   u b

  definition ba  
x     inductive hypothesis    lemma   
backward inclusion
 

 

 

s s ba     b    wa       s s bx s s    wa    s   s s ba  
x  
  definition ba       inductive hypothesis    definition
a  
a  
ba  
x   therefore  bx   b  
theorem        execution possible p iff possible subproblems
px x precondition goal variable p      execution precondition
goal variable x  x   x  resp  x    x  true b iff x   x  resp  x    x  true
bx   b bx beliefs result executing p px respectively 
proof  part    proof induction length executions  base case
induction empty execution possible p px   assume
claim holds executions length n  let b bx beliefs result
p subproblem px respectively  let   execution length
n     augments   following  f denotes collection precondition goal
variables p     ctx x  x f 
case      h  ai  first  assume   possible p   need show   possible
px x f  assumption  literal   p re a  b       
let   literal p re a s u bx x f  then  v ars    and  inductive
hypothesis theorem     since applicable p px   applied   u   s s
b  therefore  u      applicable bx  
now  assume   possible px x f  need show  
possible p       x   x precondition a    p re a s   holds
state u bx   b then  inductive hypothesis theorem    applied  
u bx s s   u  thus       applicable b 
case      h  ha   ii  first  assume   possible p   i e   ba   non empty  need
show ba  
x non empty well x f 
 

 

 

ba     b    wa       s s bx s s    wa    s   s s ba  
x
   

fibelief tracking planning sensing

  definition ba       inductive hypothesis theorem      
a  
definition ba  
x   hence  bx non empty 
finally  assume   possible px   i e   ba  
x non empty x f 
a  
need show b non empty  let x f wa    s   wa    
  ctx x   exists fourth assumption problem p lemma   



 
 
u ba  
x   u bx u    wa    s   u bx u    wa    s b u   s s


 
  u bx    wa     b u   s s

 


 
     wa     b   ba  
  definition ba  
x     inductive hypothesis theorem      
wa    s   wa        definition ba     hence  ba   non empty 
part    let possible execution p   hence  part    possible px  
let b bx beliefs result p px respectively  theorem    
x bx   x b  therefore  x   x  or x    x  holds bx iff holds b 
theorem     flat belief tracking projected problems px x
precondition goal variable p   provides sound complete factored algorithm
belief tracking p time space exponential width p  
proof  direct theorem     let execution b bx 
beliefs result executing p px respectively  then  possible p iff
possible px   therefore  flat belief tracking subproblems px tells whether
possible p   furthermore  precondition goal variable x  x   x holds
b iff holds bx    thus  flat belief tracking subproblems px sufficient
determine action applicable goal belief reached 
theorem    flat belief tracking subproblem px exponential  ctx x  vu   
therefore  flat belief tracking subproblems px  simultaneously  exponential
maxx  ctx x  vu   max ranges precondition goal variables x 
latter expression one defines w p   
proposition     execution ha    o    a    o         i possible p   possible
px state variable x p  
proof  x precondition goal variable  claim follows theorem     so 
assume x state variable appear precondition goal  show
using induction length  generalized  execution possible p
possible px   base case empty executions direct  consider
execution   length n     extends execution length n  let b bx
result applying execution p px respectively  let   ctx x  
case      h  ai  let       precondition p re a s   ctx y    then 
ctx y   ctx x  relevant x  lemma    below   bx  
   

fibonet   geffner

hand  theorem          every   therefore    holds state
bx   applicable bx     possible px  
case      h  ha   ii  wa    s   true  ba  
x   bx non empty inductive
hypothesis thus   possible px   wa    s    true     z   z  z
relevant x  since assumption precondition goal variable z
relevant   difficult show x relevant   thus  ctx x  ctx y  
bx lemma    since   possible p ba  
non empty theorem    
  possible p  
ba  

non empty


x
x
a   causal belief tracking
lemma    soundness causally closed decompositions   let   ht  bi decomposition whose beams causally closed  let pxd subproblem corresponding
projection p variables b x  x   target variable x   b
bx beliefs resulting execution p pxd respectively  bx b x  b 
proof  proof induction length executions  empty execution 
claims holds since contains unit clauses  let   execution length  
augments   following  b bx denote beliefs p pxd resulting
execution   denotes b x  
case      h  ai  let u  ba   then  b u  f  a  s  
lemma    u  fs  a  s s    thus  since s s bx inductive hypothesis  u  bx a  
case      h  ha   ii  let s s ba     b    wa      inductive
hypothesis  s s    wa    s s s bx   thus  s s ba  
x  
theorem     decoupled cbt runs time space exponential wc  p   
sound complete  is  target variable x causal decomposition 
b bx beliefs resulting execution p pxc respectively 
bx bc  x  b necessarily true  bx bc  x  b not 
proof  soundness follows directly lemma    bounds time space
direct size beam bc  x  bounded causal width wc  p   
theorem     cbt space exponential causal width problem  time
exponential width 
proof  cbt maintains beliefs beams causal decomposition whose size
bounded causal width problem  join project operation cbt
performed across time  considering one valuation time  without need first
compute store full joint  done recursively iterating beliefs
 by  oa participate join      combining partial valuations belief 
storing projection resulting belief bi  
x   number valuations join
o w p
  
    bounded  
variable z bc  y    relevant x  relevant
x thus z ctx x  
   

fibelief tracking planning sensing

remains show theorem     stated below   proof straightforward
split two parts  first part reformulates cbt algorithm called wide
 causal  belief tracking  wbt   cbt performs join operation
beliefs variables problem variables relevant
x  shows soundness completeness wbt  second part  show
cbt simply wbt applied subproblem pctx x  associated variable x
factored decomposition f   use soundness completeness factored
decomposition finish proof  first part proof consists lemmas    
second part consists lemma   theorem    
wbt works causal decomposition c   htc   bc cbt  beliefs time
  wbt cbt  initial belief projected causal
beams bc  x  x tc   beliefs later times associated executions  
augment executions   denote belief variable x tc execution
bx    update equations wbt are 
bx h ai   bc  x 
n ft  a  by      tc    
bx h ha  ii   bc  x 
n f ilter wa   t   by      tc  

   
   

  bc  y   beam   ft  a  u   set uu ft  a  u   f ilter   u  
set  u u   u       equations essentially equation     cbt 
progression filtering separated  except join performed
target variables instead joining target variables relevant x 
following basic facts joins  projections filtering easily shown
used proofs   we include proofs here   statements  sets
u ui refer sets valuations  refers collection subset variables  refers
subset variables si   v ars ui    refers logical formula  facts are 
bf   u
n s u   s  
bf   collection  ui  ii  


n si
n ui   i    i   
n ui   i  

bf   f ilter   u   f ilter s   u   
definition lemma    decomposition   ht  bi factors set u v  valuations
iff u  
n b x  u   x   
decomposition   ht  bi preserves transitions set u v  valuations iff
pair variables x    z b x  b y    either i  z known u  i e  
u z    u   z  u  u  u    ii  b x  b y   b w   variable w  
iii  every action a  transition function fs  a        variable z u  
causal closure z 
let   ht  bi decomposition v   xt b x  b x  causally
closed x   u set v  valuations  v  formula  following
claims hold 
   factors u  
f  a  u  
n b x f  a  u     x    
n fb x  a  b x u     x    
   

fibonet   geffner

   factors preserves transitions u  
f  a  u    
n b x f  a  u     x    
n fb x  a  b x u     x    
   factors u x b x     
f ilter   u    
n b x f ilter   u     x    
n f ilter b x   b x u     x    
proof  part    containment direct bf   equality follows directly
b x  f  a  u     fb x   a  b x  u   lemma   
part    second equality forward inclusion first equality
part    thus need show f  a  u  
n b x  f  a  u     x    let
u  element right hand side expression x   then  u   b x 
b x  f  a  u    by lemma    ux b x  u u   b x  fb x   a  ux   
claim  ux  xt consistent collection valuations  indeed  not 
valuations ux   uy variable z ux  z     uy  z   clearly  z known
u   b x  b y   b w   w   exchange ux uy
uw  b x  uw  b y   respectively  otherwise  see function fs  a    
causal closure z      z  contradicting assumptions  therefore 
valuation u u b x    ux x  i e   u
n b x  u   x    thus 
assumption  u u   finally  since b x  f  a  u    fb x   a  u b x      fb x   a  ux  
lemma    u   b x  b x  f  a  u  u  f  a  u   
part    first  observe bf  bf  imply chain containments
f ilter   u  
n b x f ilter   u     x  
n f ilter b x   b x u     x    
finish showing equality holds proving last subset contained
first  let u  element last subset  u  belongs
n b x  u   x  
u since factors u   thus need show u       direct
since assumption x b x      thus u   b x     b x     
lemma    soundness wbt   wbt sound  is  c   htc   bc causal
decomposition problem p    bx  xtc local beliefs time i  b global
belief time i  b
n bx   x tc   bc  x  b bx x tc  
proof  really need proof first claim b
n bx   x tc   second
follows directly observing bx belief variables bc  x  
proof first claim induction length executions  base
case empty execution easily verified  assume claims hold executions
length n let   execution length n     augments execution
length n  observe c factors u  
n by    tc   bf   b u inductive
hypothesis 
case      h  ai 


n bx 

 

 

  x tc    
n bc  x 
n fbc  y   a  by      tc     x tc  
   

fibelief tracking planning sensing

 


n bc  x 
n fbc  y   a  bc  y  u     tc     x tc  
 

 

f  a  u   f  a  b     b  
  eq       by  bc  y   u     part   lemma     
inductive hypothesis 
case      h  ha   ii 


n bx 

 

 

  x tc    
n bc  x 
n f ilter wa   bc  y    by      tc     x tc  
  




n b

c  x 


n f ilter wa   b

c  y

    bc  y   u  

  tc     x tc  

  

  

  f ilter wa      u   f ilter wa      b     b  
  eq    
inductive hypothesis 

  

by  bc  y   u  

  

part   lemma   

  



lemma    completeness wbt   let c   htc   bc causal decomposition
problem p   c preserves transitions every reachable belief state  wbt complete 
is   bx  xtc local beliefs time i  b global belief time i 
b o
n bx   x tc   bc  x  b   bx x tc  
proof  proof induction length executions  base case
empty execution easily verified since contains unit clauses  assume claims
hold executions length n let   execution length n     augments
execution length n  observe c factors u  
n by    tc   bf  
inductive hypothesis implies b   u by    bc  y   u   proof first claim
b o
n bx   x tc   exactly proof lemma   except containments
replaced equalities  either using part   lemma   inductive hypothesis 
second claim  make similar induction  in tandem first induction  
again  base case induction easily verified  inductive step 
case      h  ai 
 

 

bx      bc  x 
n fbc  y   a  by      tc     bc  x 
n fbc  y   a  bc  y  u     tc  
 

 

  bc  x  f  a  u     bc  x  f  a  b     bc  x  b  
  eq         inductive hypothesis    part   lemma   
case      h  ha   ii 
 

bx      bc  x 
n f ilter wa   bc  y    by      tc  
 

  bc  x 
n f ilter wa   bc  y    bc  y  u     tc  
 

 

  bc  x  f ilter wa      u     bc  x  f ilter wa      b     bc  x  b  
  eq         inductive hypothesis    part   lemma   
   

fibonet   geffner

following lemma shows tracking cbt variable x equivalent
tracking wbt subproblem px factored decomposition  i e  
px   pbf  x  factored decomposition f   htf   bf i  
lemma    let f   htf   bf c   htc   bc factored causal decompositions
w
problem p   execution x tc state variable  bc
x   bx
c
bx denotes local belief variable x computed cbt problem
p   bw
x denotes local belief variable x computed wbt
subproblem pbf  x   
proof sketch  simple tedious proof  provide sketch  let cx  
htx   bx causal decomposition subproblem pbf  x  x tf  i e  
causal decomposition subproblem associated variable x tf factored
decomposition   beams participate join cbt beams
variables tc relevant x  variables appear tx well  tx
variables however  observable variables relevant x  yet  since
state variables pbf  x  relevant x  projected formulas wa  y   y bf  x 
variables equal true  hence  beams variables
empty set variables contain empty valuation  therefore  beams
removed join defines wbt problem pbf  x  without altering value 
resulting join wbt pbf  x  contain beams variables tc
relevant x 
fact observed  proof consists simple induction length
executions  induction left exercise 
theorem     causal belief tracking always sound  complete causally decomposable problems 
proof  let f   htf   bf c   htc   bc factored causal decompositions
problem p   cx   htx   bx causal decomposition subproblem pbf  x 
x tf  notice x state variable tf comprised such   further  let
w
execution  let bc
x bx local beliefs variable x computed
cbt problem p wbt problem pbf  x  respectively  let bfx local belief
variable x computed factored belief tracking problem p   let b
 global  belief problem p  
observable variable relevant x  bc  x    bf  x  cbt x equal
factored belief tracking x sound complete theorem    
observable variables relevant x  first notice
w
f
bc
x   bx bc  x  bx   bc  x  b

    

lemma    soundness wbt  cf  lemma     soundness completeness fbt  cf  theorem      therefore  cbt sound 
causal decomposition cx preserves transitions every reachable belief state
problem pbf  x    containment      equality cbt complete well 
thus finish proof showing decomposition cx causally decomposable
problems decomposition preserves transitions reachable belief pbf  x   
   

fibelief tracking planning sensing

let x tc variable  let bx reachable belief problem pbf  x    let x  
two variables tx  the target variables causal decomposition problem
pbf  x     let z variable bc  x     bc  x       show either    z
known bx      bc  x     bc  x      bc  w   variable w tx      every
action a  transition function fs  a        variable z bx causal
closure z  case  causal decomposition cx preserves transitions every
reachable belief problem pbf  x   
x   

consider two cases 
case  x   x    observable  first  apply causal decomposability p conclude
either variable w tc relevant x   x    bc  w   bc  x    
bc  x       z memory variable  former case  w relevant x thus
belongs tx   latter case  show either z known bx transition
function fs  a        z bx   causal closure z action
applicable bx  
indeed  proof contradiction let us suppose z known bx
transition function      then  two valuations s    s  bx two
progressions s   fx  a  s    s   fx  a  s    s   z     s   z  s    z    s    z  
therefore  observing value z state s   knowing initial belief
actions execution h  ai  where execution leads bx    one cannot infer
value z bx two different values compatible
observation  namely s   z  s   z   hence  z memory variable contradicting
assumed causal decomposability p  
case  x   x    observables  divide case two subcases
whether variables x   x    causal ancestors x not  affirmative
subcase  bc  x     bc  x      bc  x   negative subcase  assume without loss
generality x   causal ancestor x  then  observable variable
x   causal ancestor relevant x  hence  bc  y   bc  x    
implies z bc  y   bc  x      case reduced previous case 

references
albore  a   palacios  h     geffner  h          translation based approach contingent
planning  proc    st int  joint conf  artificial intelligence  pp           
pasadena  california 
albore  a   ramirez  m     geffner  h          compiling uncertainty away nondeterministic conformant planning  proc    th european conf  artificial intelligence  pp          lisbon  portugal 
albore  a   ramirez  m     geffner  h          effective heuristics belief tracking
planning incomplete information  proc    st int  conf  automated
planning scheduling  pp      freiburg  germany 
amir  e     russell  s          logical filtering  proc    th int  joint conf  artificial
intelligence  pp        acapulco  mexico 
   

fibonet   geffner

bertoli  p   cimatti  a   roveri  m     traverso  p          planning nondeterministic domains partial observability via symbolic model checking  nebel  b 
 ed    proc    th int  joint conf  artificial intelligence  pp          seattle  wa 
morgan kaufmann 
bonet  b     geffner  h          planning incomplete information heuristic search
belief space  chien  s   kambhampati  s     knoblock  c   eds    proc   th
int  conf  artificial intelligence planning systems  pp        breckenridge  co 
aaai press 
bonet  b     geffner  h          planning partial observability classical replanning 
theory experiments  proc    nd int  joint conf  artificial intelligence  pp 
          barcelona  spain 
bonet  b     geffner  h       a   action selection mdps  anytime ao  vs  uct 
proc    th aaai conf  artificial intelligence  pp            toronto  canada 
bonet  b     geffner  h       b   width complexity belief tracking nondeterministic conformant contingent planning  proc    th aaai conf 
artificial intelligence  pp            toronto  canada 
bonet  b     geffner  h          causal belief decomposition planning sensing 
completeness results practical approximation  proc    rd int  joint conf 
artificial intelligence  pp            beijing  china 
bonet  b     geffner  h          flexible scalable partially observable planning
linear translations  proc    th aaai conf  artificial intelligence  pp           
quebec city  canada 
boyen  x     koller  d          tractable inference complex stochastic processes 
cooper  g     moral  s   eds    proc    th conf  uncertainty artificial intelligence  pp        madison  wi  morgan kaufmann 
brafman  r  i     shani  g          replanning domains partial information
sensing actions  journal artificial intelligence research                 
bryce  d   kambhampati  s     smith  d  e          planning graph heuristics belief
space search  journal artificial intelligence research           
choi  a     darwiche  a          edge deletion semantics belief propagation
practical impact approximation quality  proc    st nat  conf  artificial
intelligence  pp           
cimatti  a   roveri  m     bertoli  p          conformant planning via symbolic model
checking heuristic search  artificial intelligence              
darwiche  a     marquis  p          knowledge compilation map  journal artificial
intelligence research             
dechter  r     beek  p  v          local global relational consistency  theoretical
computer science                  
doucet  a   freitas  n  d   murphy  k     russell  s          rao blackwellised particle filtering dynamic bayesian networks  proc    th conf  uncertainty artificial
intelligence  pp         
   

fibelief tracking planning sensing

edelkamp  s          planning pattern databases  cesta  a   ed    proc   th
european conf  planning  pp        toledo  spain  springer  lncs 
goldman  r  p     boddy  m  s          expressive planning explicit knowledge 
drabble  b   ed    proc   rd int  conf  artificial intelligence planning systems 
pp          edinburgh  scotland  aaai press 
hoffmann  j     brafman  r  i          contingent planning via heuristic forward search
implicit belief states  biundo  s   myers  k     rajan  k   eds    proc    th
int  conf  automated planning scheduling  pp        monterey  ca  morgan
kaufmann 
hoffmann  j     brafman  r  i          conformant planning via heuristic forward search 
new approach  artificial intelligence              
kaelbling  l  p   littman  m     cassandra  a  r          planning acting partially
observable stochastic domains  artificial intelligence             
kaye  r          minesweeper np complete  mathematical intelligencer              
kocsis  l     szepesvari  c          bandit based monte carlo planning  proc    th
european conf  machine learning  pp          springer 
lin  w   buffet  o   lee  c     teytaud  o          optimistic heuristics minesweeper 
proc  int  computer symposium  ics      http   hal inria fr docs 
            pdf mines  pdf 
palacios  h     geffner  h          compiling uncertainty away conformant planning
problems bounded width  journal artificial intelligence research         
    
pearl  j          probabilistic reasoning intelligent systems  morgan kaufmann 
ramirez  m     geffner  h          structural relaxations variable renaming
compilation solving mincostsat  proc    th int  conf  principles
practice constraint programming  pp          springer 
rintanen  j          regression classical nondeterministic planning  ghallab 
m   spyropoulos  c  d   fakotakis  n     avouris  n  m   eds    proc    th european
conf  artificial intelligence  pp          patras  greece 
russell  s     norvig  p          artificial intelligence  modern approach   rd edition  
prentice hall 
scott  a   stege  u     rooij  i  v          minesweeper may np complete
hard nonetheless  science business media  llc              
shani  g     brafman  r  i          replanning domains partial information
sensing actions  proc    nd int  joint conf  artificial intelligence  pp      
      barcelona  spain 
shani  g   poupart  p   brafman  r  i     shimony  s          efficient add operations
point based algorithms  rintanen  j   nebel  b     j  c  beck  e  a  h   eds   
proc    th int  conf  automated planning scheduling  pp          sydney 
australia 
   

fibonet   geffner

silver  d     veness  j          monte carlo planning large pomdps  proc    th
annual conf  advances neural information processing systems  pp           
sipser  m          introduction theory computation   nd edition   thomson course
technology  boston  ma 
smith  d     weld  d          conformant graphplan  mostow  j     rich  c   eds   
proc    th nat  conf  artificial intelligence  pp          madison  wi  aaai
press   mit press 
to  s  t   pontelli  e     son  t  c          effectiveness cnf dnf representations contingent planning  proc    nd int  joint conf  artificial intelligence 
pp            barcelona  spain 
tran  v   nguyen  k   son  t  c     pontelli  e          conformant planner based
approximation  cpa h   acm trans  intelligent systems technology        
   
weld  d   anderson  c     smith  d          extending graphplan handle uncertainty
sensing actions  proc    th nat  conf  artificial intelligence  pp         
aaai press 

   


