journal artificial intelligence research                  

submitted        published      

improving delete relaxation heuristics explicitly
represented conjunctions
emil keyder

emilkeyder gmail com

jorg hoffmann

hoffmann cs uni saarland de

saarland university
      saarbrucken  germany

patrik haslum

patrik haslum anu edu au

australian national university   nicta
canberra act       australia

abstract
heuristic functions based delete relaxation compute upper lower bounds
optimal delete relaxation heuristic h    paramount importance
optimal satisficing planning  introduce principled flexible technique
improving h    augmenting delete relaxed planning tasks limited amount
delete information  done introducing special fluents explicitly represent
conjunctions fluents original planning task  rendering h  perfect heuristic h
limit  previous work introduced method growth task
potentially exponential number conjunctions introduced  formulate alternative technique relying conditional effects  limiting growth task linear
number  show method still renders h  perfect heuristic h
limit  propose techniques find informative set conjunctions introduced
different settings  analyze extend existing methods lower bounding upperbounding h  presence conditional effects  evaluate resulting heuristic
functions empirically set ipc benchmarks  show sometimes much
informative standard delete relaxation heuristics 

   introduction
planning heuristic search one successful approaches planning 
informative heuristic functions domain independent planning obtained
estimated cost delete relaxation original planning task  delete
relaxation simplifies planning tasks assuming every variable value  achieved 
persists execution rest plan  cost optimal plan
resulting relaxed planning task  denoted h    np complete compute  however whether
plan delete relaxed task exists checked polynomial time  bylander 
       satisficing planning  heuristic admissible 
latter fact exploited upper bound h    generating necessarily optimal
plan delete relaxed task  hoffmann   nebel         optimal planning  lowerbounding methods devised based analysis landmarks  logical formulas
set actions state necessary properties delete relaxed plans  karpas  
c
    
ai access foundation  rights reserved 

fikeyder  hoffmann    haslum

domshlak        helmert   domshlak         cost estimates delete relaxed
task used guide heuristic search state space original task 
since delete relaxation heuristics first proposed  bonet   geffner         much
work done improve them  one approach focuses better approximation
schemes h    obtaining tighter upper bounds thus better non admissible estimates
 hoffmann   nebel        keyder   geffner               tighter lower bounds
correspond informative admissible heuristics  helmert   domshlak        bonet
  helmert         many domains  however  important heuristic able
take account delete information  hoffmann         indeed long tradition
works proposing heuristics so  several extend delete relaxation
capture strictly information  fox   long        helmert        helmert   geffner 
      cai  hoffmann    helmert        katz  hoffmann    domshlak        
consider delete relaxation attempt find low conflict relaxed plans  baier  
botea         generate modified heuristic values based taking conflicts account
extent  do   kambhampati        gerevini  saetti    serina         here 
approach problem taking inspiration admissible hm family heuristics
 haslum   geffner         important property heuristics introduce  shared
recent work direction  technique renders h  perfect
heuristic h limit  words  technique offers trade off amount
delete information considered computational overhead so  one end
continuum  delete relaxed plans become plans original task 
hm heuristic function considers cost making true simultaneously sets fluents
size m  cost planning task estimated recursively taking cost
set fluents  goal set action preconditions  cost
costly subset size m  ignoring cost achieving remaining fluents
set  possible subset size fluents task must considered 
size representation required compute hm exponential m  hm heuristics
provide guarantee exists hm   h  trivially satisfied
total number fluents task   however  value required achieve
usually large make computing h method infeasible practice 
hm heuristic recently recast hmax   h  cost planning task
deletes  haslum         achieved representing conjunctions fluents c
size original task new fluents c   called  fluents  modifying
initial state  goal  operators planning task capture reasoning
performed hm sets within computation hmax   however  h   m  
admissible  since separate copy action may needed establish
 fluent   thus compilation useful obtaining admissible estimates
informative h    recent c construction  haslum        fixes
issue  introducing action copy every subset  fluents may established  
cost growing task representation exponentially number  fluents rather
linearly representation  hand  c offers possibility
fine grained tradeoff representation size heuristic accuracy  allowing
choice arbitrary set conjunctions c corresponding  fluents  which need
size   stands contrast hm heuristic compilation 
sets conjunctions size represented 
   

fiimproving delete relaxation heuristics explicit conjunctions

haslum        proposed repeatedly solve c optimally  within iterative procedure
adds new conjunctions set c iteration  relaxed plans
computed therefore gradually become closer  sense  plans original
task  instead explore idea using kind construction obtaining heuristic
functions guiding search 
c
introduce related construction c
ce similar   makes use
conditional effects limit growth task worst case linear  rather
exponential   c   gain size comes price information loss relative
c   however  show  information loss affect fundamental property
tending towards perfect heuristic h enough conjunctions introduced 
c   c
ce perfect limit  i  e  always exists set conjunctions c

h   c
ce     h   furthermore  information may lost  always case 
indeed  possible construct families planning tasks c
ce represent
 
c
heuristic function c set conjunctions c  i  e   h   c
ce     h     
c
representation ce occupies exponentially less space 
said that  theoretical advantage c
ce tend materialize practice
 or least commonly used benchmarks   without optimizations c
indeed grows quickly practical  turns mutex pruning techniques  eliminating compiled actions conflicting preconditions  extremely effective keeping
c
size c bay  therefore consider c
ce   evaluating usefulness
devising improved heuristic functions  focus two main questions 
 a  obtain upper lower bounds h  compiled tasks 
 b  choose set conjunctions c maximize information gained
addition planning task 
response question  a   analyze extend three state of the art methods
estimating h    satisficing setting  upper bounding h     consider problem
finding low cost relaxed plans scheduled minimize cost
sequence actions required trigger given set conditional effects  avoiding unnecessary
repeated applications action  problem scantily addressed
previous work  show problem optimal action scheduling given
set effects np complete  generalize approximation technique used
planner  hoffmann   nebel        
optimal setting  lower bounding h     consider lm cut heuristic  helmert
  domshlak        well admissible heuristics based fluent landmarks  karpas
  domshlak         former  findings mostly negative  first  show
even though introduction  fluents cannot decrease hmax h    lowerand upper bound lm cut  respectively  lm cut heuristic value decrease  second 
show neither two straightforward adaptations lm cut algorithm
problems conditional effects maintains admissibility domination hmax   
latter  show c
ce used generate informative fluent landmarks 
recent work  keyder  richter    helmert        extracts landmarks task 
   sophisticated adaptation lm cut  based idea context splitting  recently
proposed        maintains properties 

   

fikeyder  hoffmann    haslum

allows discovery  fluent landmarks corresponding conjunctive landmarks
original task  suffers due large number  fluents must considered 
c
ce compilation offers possibility discovering interesting conjunctive landmarks
unbounded size  avoiding growing size compilation unnecessarily 
response question  b   devise range strategies depending purpose
c
c
ce compilation used  parameterized terms
allowed growth compiled task relative original task  thus allow
trade off informativeness heuristic computational overhead 
evaluate resulting heuristics wide range benchmarks international planning competition  varying relevant algorithm parameters determine individual
effect performance  results show  several domains heuristics much
informative previous ones  leading significantly improved performance 
next define basic concepts  section     moving formal definition

c
c
ce compilation previously introduced compilations  section    
c

c
section    analyze ce relation theoretical perspective 
section   discusses practical issues arise using compilations purpose
satisficing planning  describes obtained experimental results  section  
case optimal planning  finally  section   summarizes main points
paper indicates possible future research directions 

   preliminaries
planning model based propositional strips formalization  add
action costs conditional effects  states operators defined terms set f
propositional variables  fluents  state f given set fluents
true state  planning task described   tuple   hf  a  i  gi  f
set variables  set actions  f initial state  g f
describes set goal states  given  s   g s   action consists
  tuple hpre a   add a   del a   ce a i  pre a   add a   del a  subsets f  
action cost cost a  r 
    ce a     ce a             ce a n    denote set
conditional effects action a  triple hc a i   add a i   del a i subsets
f   simplify notations  require add a  del a      need
impose restrictions deletes del a i conditional effects  conditional
effects used within delete relaxation  ce a    a 
conditional effects  say strips planning task 
action applicable pre a  s  result applying given
 
 
s a     s    del a 
del a i     add a 
add a i  
 i c a i s 

 i c a i s 

plan sequence
pn actions   a            whose application results goal
state  cost i   cost ai    optimal cost minimal among plans
s  often denote optimal plans   plan called plan  
simply plan 
heuristic function h mapping states r 
    perfect heuristic

h maps state cost optimal plan s  heuristic h admissible
   

fiimproving delete relaxation heuristics explicit conjunctions

h s  h  s  s  h      denote heuristic function whose value
given estimating cost corresponding state s  modified task     specify
  terms transformation   hf  a  i  gi     hf     a        g  i  s  obtained
applying transformation used obtain   i  sometimes useful
make explicit h heuristic computed itself  denote h   
note modified task   used computation heuristic function 
particular  actual search plan performed state space original
planning task  
delete relaxation   planning task obtained discarding delete
effects  formally      hf  a    i  gi  a     hpre a   add a     ce   a i   a  
ce   a     hc a i   add a i     ce a i ce a    cost action a  a 
cost corresponding action cost a   optimal delete relaxation heuristic h 
defined cost h      optimal plan    
denote power set f p f      c   c f    context hm  
c
  c
ce   refer fluent subsets c p f   sets conjunctions interchangeably 
throughout paper  assume conjunctions non unit  i  e    c      
landmark planning task logical formula set fluents f
every valid plan makes true state  hoffmann  porteous    sebastia        
orderings landmarks statements order states occur 
natural ordering   n   means state sj satisfies     state si
occurring sj   satisfied  necessary ordering   nec   means  
always true state immediately state   becomes true 
greedy necessary ordering   gn   means relationship holds first time
  made true  note necessary ordering   nec   implies greedy necessary
ordering   gn     vice versa  landmark graph g directed graph whose
nodes landmarks  whose labelled edges correspond known orderings
landmarks 

     c c
ce compilations
compilation  haslum        first technique proposed made use
idea  fluents explicitly represent conjunctions original task  given
conjunction c f   c new fluent c   f unique c  i  e   c    c  c    c   
defining compilations discuss  use shorthand x c  
x  c   c c c x   x f set fluents  c p f   set
conjunctions  words  x c consists set fluents x itself  together new
fluents c whose intention represent conjunctions c c contained x 
c x 
definition    the compilation  given strips planning task   hf  a  i  gi
parameter z    planning task hf c   ac   c   gc i  c    c   c
f      c  m   ac contains well action ac pair a  c c
del a  c   add a  c      ac given del ac       ce ac      
pre ac      pre a   c   add a   c
add ac     add a   c    c  c c   add a  c  
   

fikeyder  hoffmann    haslum

parameter indicates maximum size conjunctions represented
explicitly resulting compiled task   fluent inserted  by definition f c   cf 
above  c f      c  m  c added fluent sets
task  such initial state  action preconditions  goals  containing associated
set c  furthermore  linear  in  c   number representatives action added
task model situation elements c made true
already true applied  adds remaining fluents c deleting
none them  thereby making every fluent c  therefore c   true  compilation
allows admissible hm cost original task computed hmax cost
compiled task 
non admissibility h  m     h   m   due construction action representatives ac   sets fluents simultaneously made true single application
action may require several representatives explicitly achieve
effect   consider example action adding fluent p state q
r already true  makes fluents p  q  r true simultaneously  whereas
    two different representatives required  one c    p  q  adding  p q   
one c    p  r  adding  p r   
c compilation solves problem instead creating number representatives exponential number  fluents may made true a 
representatives corresponds application makes set  fluents
true  haslum         following example  separate representatives would
introduced  fluent sets     p q       p r       p q     p r    
representative resulting last could applied make two  fluents
true simultaneously  c differs allows choice set c p f   
introduces fluents c c c  rather subsets size
m  
definition    the c compilation  given strips planning task   hf  a  i  gi
set non unit conjunctions c p f    c planning task hf c   ac   c   gc i 
 
ac contains action ac pair a  c   c c  c    
    del a  c    add a  c      
    c c  c c  add a  c        c c     
 

 

 

ac given del ac       ce ac      
 
 
pre ac      pre a 
 c    add a   c
c  c  
c 

add a      add a   pre a    del a   c  c    c  c    
   three differences definition haslums        definition actions
c   first  haslums definition features delete effects  ensuring real  non relaxed  plans correspond
plans original task  since consider delete relaxations compiled task  safely
omit these  second  allow sets c   used construction actions contain conjunctions c
 
c add a   pre a    del a    third  add ac   contains  fluents c c pre a    del a  
latter two differences keep definitions simpler  redundant action representatives
redundant add effects cause easily pruned practice 

   

fiimproving delete relaxation heuristics explicit conjunctions

 

representatives ac enforce  every c  c     part c  deleted 
 
non added part c  true already ac executed  constraint    
 
ensures form non redundancy  ac adds  fluent c    adds  fluents
c c c    fluents c necessarily become true application
action  note that  differently   add effects c include  fluents representing
conjunctions fluents added action prevail fluents  non deleted preconditions  
necessary admissibility h   the primary purpose c    needed
computation h   the primary purpose   
c enumerates possible subsets c constructing representatives
action therefore grows exponentially  c   exponentiality reminiscent
canonical conditional effects compilation used convert planning tasks conditional
effects classical strips planning tasks exponentially actions  gazen  
knoblock         c
ce compilation introduce result applying
roughly reverse transformation c   resulting closely related planning task
linear  in  c   number conditional effects 
definition    the c
ce compilation  given strips planning task   hf  a  i  gi
c
c
c
c
set non unit conjunctions c p f    c
ce planning task hf   ace     g

c
c
c
c
ac
ce    hpre a    add a    del a    ce a  i   a  

ac given
pre ac     pre a c
add ac      add a   pre a    del a   c
del ac    
ce ac      h pre a   c   add a   c    c   
  c c c del a    c add a      
rather enumerating sets  fluents may made true action  c
ce
uses conditional effects implicitly describe conditions made true 
information lost information encoded cross context  fluents
preconditions  appear action representatives c   preconditions
c  
effect conditions corresponding actions c
ce   action representatives
 
c    fluents pre ac   exists c c   s t   c   add a  
pre a   situation discussed above  example   q r  precondition action
representative adds  p q   p r  c   appear condition
conditional effects corresponding action c
ce   since effect conditions
determined individually c   conditions never included  return
discussing theoretical relationship c c
ce  
example   consider strips planning task  adapted helmert   geffner       
variables  x            xn   y   initial state    x    y   goal g    xn    unit cost actions
  h   y    

bi   h xi   y    xi       y  
   

fikeyder  hoffmann    haslum

             n   
optimal solution planning task takes form b    a  b    a          bn   
cost  n   delete relaxation task  fact deleted application
bi ignored  optimal plan cost n 
 fluent xi  y introduced c
ce compilation  added precondition
action bi   new conditional effects ce a i form h xi      xi  y     created
action a  conditional effects added b actions  deletes
therefore cannot achiever  fluent  increases optimal delete relaxation
cost task    new instance must added relaxed plan achieve
newly introduced precondition bi    fluents form  xi  y  introduced 
delete relaxation cost c
ce becomes  n    optimal cost 
set conjunctions renders delete relaxation cost c perfect  i  e  
 n     however  size c given conjunction set exponential n  action
may principle achieve subset conjunctions  every subset c   induces
 
separate representative ac ac  
regarding compilation  h    hmax      gives optimal cost task 
however  computation requires consideration  n    fluent pairs  rather
linear number  fluents need introduced c
ce   shall see  theorem     example easily extended must scale n hm become
c

perfect  thus showing exponential separation c
ce  
important practical optimization c c
ce mutex pruning  mutex
information original planning task available  specifically given  some 
m tuples fluents reachable conjunction  discard
compiled task action representatives conditional effects require
m tuple  without losing admissibility compilation  namely  value h   c  
 respectively h   c
ce    mutex pruning bounded value
 
 
 
h   c    respectively h   c
ce    larger set c c conjunctions  include

 fluents size m  h mutexes found  i  e   none respective fluents reachable compiled task  exploiting available mutex information allows us
make compilation informed without add additional  fluents 
helping keep compilation small 
another optimization use eliminate dominated preconditions  whenever add
fluent c precondition action  condition conditional effect 
remove condition fluents p c  fluents  c    c  c  
achieving c implies achieving fluents well  methods count cost
separately  such as  example  hadd related heuristics  would incur overestimation 
note  however  eliminate duplication caused  fluents representing different fluent sets non empty intersection  consider  example 
action pre a     p  q  r   c     p  q    q  r    pre a      p q     q r    
cost achieving q implicitly counted twice hadd estimate cost
applying a  possible solution  considered replacing overlapping  fluents c   c 
cc    this  however  consistently improve heuristics compute
compiled tasks 
   

fiimproving delete relaxation heuristics explicit conjunctions

   theoretical properties c
ce
 
c
discuss theoretical properties c
ce   considering cost h  ce  
optimal solutions instead practical approximations  note c
ce version
c considered here  h    h delete effects present   proof sketches
shown  full proofs found appendix a  first show fundamental
expected property 

theorem    consistency admissibility  h   c
ce   consistent admissible 
proof  regarding consistency  given s  s a    s    need show
 
c
 
 c
 c c  
h   c
ce   s  cost a    h  ce   s    let  s   optimal plan
ce
 c sc  ac   c task
ac  s c   necessarily plan sc c
ce  
ce
deletes  admissibility follows consistency together fact h   c
ce   s     
goal states s 
furthermore   ideal  delete relaxation lower bound improve add  fluents 
theorem    h   c
ce   grows monotonically c  given planning task sets
 
 
c 
c c non unit conjunctions  h   c
ce   h  ce   
c
c
 
proof  follows fact given plan   ac
            an  for  ce      
 
 
 
c
c
c
c
c
c
a            constitutes plan ce   show induction  a           ai  
c
 
c 
c   
c  ac
           ai      c   c c   c    shows result since goal ce g
gc    c   c c   c      gc sc    valid plan 
 
     induction hypothesis holds since c   c    c   c c   c     definition 
 
 
 
 
c
c
c
c 
c
 
     ac
applicable  a           ai    since pre ai     pre ai      c   c c   c   
 
 
 
c
 
c
c c
c  ac
           ai     a           ai      c   c c   c   induction hypothesis 
c
c
c
c
c
c
 c   c  i  a           ai      a           ai     c c      either c add ai  c  
 
c 
implies c add ac
  due definition ce   exists conditional effect
c
 
cej  ac
    h pre a   c    add a       c    i  since c c   must exist  corresponding
 
c
c 
conditional effect ce definition  condition must true c  ac
           ai   
induction hypothesis 

special case c       theorem   gives us 
 
corollary    h   c
ce   dominates h     given planning task set non unit
 
c
 
conjunctions c  h  ce   h    

domination strict  follows trivially convergence h  theorem   below  
consider relationship c c
ce compilations  mentioned
above  information encoded cross context preconditions lost moving
c
exponential c linear c
ce   estimates obtained ce may therefore inferior
obtained c  
theorem    h   c   dominates h   c
ce    given planning task set nonunit conjunctions c  h   c   h   c
  
cases inequality strict 
ce
   

fikeyder  hoffmann    haslum

proof sketch  standard conditional effects compilation strips  gazen   knoblock 
c
       applied c
ce   equivalent except presence cross context preconditions c   given this  plan c plan c
ce   yet inverse
c c
c
 
n
 
 
      ac
case  show first part  show induction c  ac
n    a             ce  
 
i        ce denotes result applying sequence actions initial state c
c
c
ce   since goal tasks defined g   shows desired result 
strictness result follows fact possible construct tasks
cross context preconditions discussed play role  leading situations
c
exist plans c
ce shorter minimum length plans  
proof strictness  appendix a   show planning task h   c  
value strictly larger h   c
ce   value c chosen conjunctions
size    implies exist tasks necessary consider strictly
larger conjunctions c
ce obtain equally good heuristic estimates obtained
c
c   necessarily problematic however  differently hm   c
ce
introduce conjunctions given size  therefore exponential maximum
size conjunctions considered 
c
advantage c
ce potentially exponentially smaller  c  
domination therefore must qualified reduction size  furthermore 
c
ce preserves ability compute perfect heuristic given sufficiently large set c
conjunctions  first consider equivalent result c   already proved haslum
        provide alternative proof conveniently adapted show
c
property c
ce   key proof following equivalence
h   m   h   c   
lemma   given planning task   c    c p f          c  m   h   m     h   c   
proof sketch  c identical except action sets  h  values computed
considering single add effect time  inequality h   m   h   c  
 
easy see verifying that  every add effect c action ac c  unless
 
c pre ac   thus redundant   action ac dominates it  i  e   c add ac  
 
pre ac   pre ac    proof similar inequality h   c   h   m    observing
action ac non redundant add effect  exists dominating action
 
ac c  
theorem    h   c   perfect limit  given planning task   exists c
h   c     h    
proof  known h      hm    sufficiently high values  haslum  
geffner         shown haslum         hm      h   m    lemma   
c    c p f          c  m   h   m     h   c    choosing appropriate
corresponding c  thus h      hm      h   m     h   c   
together fact h   c   h   c    since h   c   h    admissibility
h   c    claim follows 
 
c
 
c
show claim c
ce   remains relate h     h  ce   

   

fiimproving delete relaxation heuristics explicit conjunctions

lemma   given planning task set non unit conjunctions c  h   c  
h   c
ce   
c
proof sketch  consider planning task c
no cc identical except drops cross 
context  fluents preconditions  show  a  h  c   h   c
no cc     b 
 
c
 
c
h  no cc   h  ce   
similarly proof lemma     a  easy see showing every add effect
 
c    c   simply set c   
c action ac c
no cc dominated action
minimal subset c   contains c satisfies condition     definition    in
words  reduce c   get rid cross context  fluents  
 
c
 b   suffices show h   c
no cc   h  ce    holds because  action
c
 
relaxed plan ce   c set conjunctions added conditional
 
effects applied plan  action representative ac c
no cc
preconditions a  used achieve set fluents 

theorem    h   c
ce   perfect limit  given planning task   exists c
h   c
 
 
h    
ce
proof  choosing appropriate c  h      hm      h   m    and 
lemma    h   m     h   c    lemma    get h   c   h   c
ce    since 
    shows claim 
theorem    h   c
 

h
ce
note that  theorem    theorem   actually corollary theorem    presentation chosen make relation two results  role two lemmas 
clearer 
proofs theorems     rely obtaining perfect hm   clearly unfeasible
general since involves enumerating subsets fluents  and hence possible states 
worst case  however  c c
ce offer flexibility allowing us choose set
c  selecting subsets guarantees perfect heuristic  may achieved
much less effort  especially beneficial using c
ce whose growth  c  linear 

indeed  task families obtaining h takes exponential effort hm  
requires exponentially sized c   yet c
ce remains small 
c   exist parameterized task
theorem    expressive power c
ce vs  h
families k

   hm  k     h  k   k 

c
   h   c
k     h  k   implies number action representatives k exponential k 

   k exists ck  ck    and therefore number conditional effects
 
c

 k  c
ce   polynomial k   b  h   k  ce     h  k   
proof  members one family given combination k planning tasks
type shown example    size k  share among action
fluent needs made true step  k k goals  hm   h iff
k 
   

fikeyder  hoffmann    haslum

c
c
k  k  ce perfect  k  fluents  xi    y            xik   y  must introduced individual subtasks i  leading total k    fluents  one
 fluents present  precondition action bij  k  c
ce   similarly
representative c        c
 



individual
fluent
preconditions
y  xij  
k
consequence one actions reestablishing left plan 
number conditional effects created  k  c
ce linear number  fluents added 
however  number action representatives  k  c exponential k  action
adds fluent y  belongs  fluents  hence one representative
subset  fluents 

using h   c
ce   practice  typically able choose c results
perfect heuristic  instead  try pick set c yields informative heuristic
without making size representation impractical work with 

   heuristics satisficing planning
consider practical issues involved using c
ce satisficing planning  section     deals extraction relaxed plans  section     deals strategies
choosing set conjunctions c  section     presents experiments resulting
setup 
    relaxed planning conditional effects
techniques extracting relaxed plans presence conditional effects long
known  hoffmann   nebel         here  refine extend techniques 
particularly important context as  unlike ipc benchmarks  structure
conditional effects c
ce rather complex  involving multiple dependencies
different actions  even different executions action  
non admissible delete relaxation heuristics typically obtained relaxed plan
extraction algorithm  keyder   geffner         different variants algorithm
characterized best supporter function bs   f   use  cases  bs p 
action adding p minimizes estimate cost making p true 
conditional effects present  algorithms compute set actions
scheduled form relaxed plan planning task  formally  algorithms construct
relaxed plan according following equations  keyder   geffner        
 
  
p
 p   
bs p   pre bs p    otherwise
 
 p    
 p 
pp

existing methods choosing best supporters  hadd hmax   easily
extended conditional effects treating conditional effect task separate
   remark similar issues arise approaches compiling uncertainty classical planning
conditional effects  palacios   geffner        bonet  palacios    geffner         techniques may
turn useful well 

   

fiimproving delete relaxation heuristics explicit conjunctions

action  particular  method employed  using hmax   compute heuristic
function  hoffmann   nebel         precisely  relaxed conditional effect
ce a  
condition c a i add add a i   action ai add effect add ai    
add a  add a i precondition pre ai     pre a  c a i created  set effects  g 
defined rules forms relaxed plan  presence conditional effects 
however  implies problem schedule relaxed plan  different
schedules may require different numbers action applications  multiple applications
single action avoided making conditions multiple desired effects true
given application a 
illustration  consider planning task action move briefcase n conditional effects  conditionally transports object location location
b inside briefcase  using representation above  distinct moving action
generated conditional effect  one possible schedule relaxed plan repeatedly
puts object briefcase  applies move briefcase  proceeds next object 
plan n   steps longer optimal relaxed plan  first places
objects briefcase applies move briefcase once 
words  single action execution may trigger several conditional effects
once  may exist relaxed plan length less   g    question arises
optimally schedule relaxed plan  minimizing number action applications
required  uses simple approximate solution problem  outline
improve upon below  first note problem scheduling conditional relaxed
plans  scrp  actually np complete 
theorem    scheduling conditional relaxed plans  let   relaxed planning task
conditional effects  g  set effects that  viewed set independent actions 
constitutes plan     deciding whether exists sequence actions length k
conditional effects  g  triggered np complete 
proof  membership follows fact given sequence k actions  easily
checked polynomial time whether conditional effects  g  triggered  hardness
follows reduction shortest common supersequence problem  scs   garey  
johnson         supersequence string x   d        dm alphabet string
alphabet belongs language l   d        dm   given
instance scs problem strings x            xn alphabet        asks
whether exists supersequence strings length k  construct
planning task conditional effects   hf  a  i  gi 

f   ni    yij     j  xi   
   a    a     az          ce az     ce az   given set conditional
effects
n  x 
  
 
 hyij   yij       xij   z 
i   j  

   y             yn   
g    y  x              yn xn    
   

fikeyder  hoffmann    haslum

two actions a  a  correspond addition symbols     respectively
supersequence implicitly constructed  fluent yij encodes fact
current string constitutes supersequence prefix xi            xij   
seen valid plan planning task must trigger conditional effects
task  yet sequence actions length k exists iff common
supersequence x            xn length k  transformation scs problem
planning task conditional effects polynomial  shows claim 
note theorem   relate  known  hardness optimal relaxed planning 
wish schedule effects already selected know form
relaxed plan  source complexity has  yet  overlooked literature 
given hardness result  employ greedy minimization technique call
conditional effect merging  starting trivial schedule containing one action execution
effect  g   consider pairs effects e  e   g  conditional effects
action a  two effects merged single execution conditions
achieved without use either add effects  ffs approximation method
applies similar reasoning  captures special case condition holds 
e e  appear layer relaxed planning graph  trivially
implies conditions effects independently achievable  however 
may case effects different layers relaxed planning graph 
devise strictly general technique  capturing form independence
effects using call best supporter graph  bsg  representation relaxed plan
 for simplicity  assume task single goal fluent g    needed
achieved introducing new action end whose preconditions original goals 
adds g    
definition    best supporter graph  given relaxed planning task   best supporter function bs  best supporter graph directed acyclic graph   hv  ei 
v    g    g  above  e    hv  v     p pre v     v   bs p    vertex
labeled action whose conditional effect represents  edge labelled
set preconditions  p   p pre v     v   bs p   
nodes graph represent conditional effects appear relaxed plan 
exists edge hv  v   two nodes effect represented v best
supporter  pre condition effect represented v      bs valid best supporter
function  i  e   relaxed plan  g  generated bs sound  sufficient condition
acyclic  easily shown topological sort sound
relaxed plan  implies that  path two conditional effects
action  occur result action application  therefore
merged single occurrence action  nodes removed
bsg  new node added represents effects  combining incoming
outgoing edges  process repeated node merges possible 
algorithm runs polynomial time sound results bsg
topological sort constitutes relaxed plan   not  however  guarantee
optimal scheduling original plan 
   edge labels used procedure choosing conjunction set c  described section     

   

fiimproving delete relaxation heuristics explicit conjunctions

example  consider task move briefcase n conditional effects
transporting object location location b inside briefcase  nodes
bsg n put into briefcase oi   actions  one object oi    well n copies
move briefcase a  b   one conditional effect regarding object oi   
one edge put into briefcase oi   respective copy move briefcase a  b   labeled
in briefcase oi    therefore path graph move briefcase a  b 
node another  merged single node conditional effect merging
algorithm  topological sorts merged bsg correspond optimal relaxed plans 
    choosing c relaxed planning
algorithm   shows main procedure computing set conjunctions c used form
c
ce task  algorithm applied once  start search  initial
c
state planning task  resulting c
ce  or   task used subsequent
heuristic evaluations  conditional effect merging used conflict extraction
phase configuration discussed below  i  e   use original non merged bsg
stated definition   
algorithm    choosing c relaxed plan heuristics 
c 
  relaxedplan c
ce  
plan size c
ce     bound
c   c findconflicts  
  relaxedplan c
ce  
algorithm   is  high level  similar procedure previously introduced
computing incremental cost lower bounds based c construction  haslum        
algorithm repeatedly generates relaxed plans initial state current compiled
task  adds new conjunctions c based conflicts found current
plan  i  e   based current relaxed plan fails executed original planning
task   process stops either conflicts found  implying
current relaxed plan c
ce plan original planning task  user specified
c
bound size ce reached  express bound terms size c
ce
compared  see below   sometimes impose bound runtime
algorithm 
bound specified  findconflicts   returns least one new conjunction
long plan   algorithm   complete planning algorithm right 
report results usage algorithm experiments below  relaxed
plan generated iteration optimal  algorithm   used compute sequence
admissible cost estimates converges optimal plan cost  haslum        
focus  however  use c
ce generating inadmissible heuristic functions 
therefore use tractable  non optimal  relaxed planning procedure  impose bound
typically stops algorithm   plan original task found 
remains specify findconflicts procedure  given relaxed plan fails
execute original planning task   select set new conjunctions c  one
   

fikeyder  hoffmann    haslum

answer question provided previous use algorithm   compute
plan cost lower bounds  haslum         aim different computing heuristics
satisficing search based planning make number changes previously
proposed version findconflicts  section       summarizes original procedure 
section       describes changes make it 
      conflict extraction incremental plan cost lower bounds
given optimal relaxed plan plan original planning task  haslums
       version findconflicts returns set conjunctions c prevents relaxed
plan solution next iteration  ensures progress  sense
cost relaxed plan eventually increase  prove real plan cost 
describe conflict extraction procedure  need two definitions 
definition    relaxed plan dependency graph  let non redundant plan
relaxed planning task     construct directed graph g    one node va
action   plus node vg representing goal  let pre v  denote precondition
node v  pre a  node va g node vg   g  s  directed edge
va v   iff pre v     relaxed reachable using set actions minus  a  
edge labelled subset pre v     relaxed unreachable actions 
relaxed plan dependency graph  rpdg    transitive reduction g    
rpdg similar bsg  definition     encodes necessary dependencies actions relaxed plan  path node va node vb
rpdg implies precedes b every valid sequencing   case  vb said
ordered va   contrast  bsg encodes intentions relaxed plan
heuristic  form chosen best supporters  may impose orderings need
respected every valid sequencing plan  e  g  fluent p added another
action relaxed plan best supporter p   relaxed plan
non redundant  meaning action removed without invalidating it 
path every action node rpdg goal node 
definition    dependency closure  let non redundant plan relaxed planning task     let v v   nodes rpdg    v   ordered v  simple
q 
q 
qm
dependency path path v v        v   v v   rpdg    edge
labelled one fluent  chosen arbitrarily  edge label rpdg     whenever
v   ordered v  simple dependency path v v   exists   dependency closure
v v   minimal  w r t  subset  union paths      contains simple
dependency path v v         q fluent labels edge node v   
closure  action q add a   action associated
v      closure contains simple dependency path v node corresponding
a   such path guaranteed exist  
recall input findconflicts plan    valid delete relaxation  
original planning task delete effects considered 
valid     preconditions actions   well goals  must made true
   

fiimproving delete relaxation heuristics explicit conjunctions

   
vd
p 
r
   
vf
q 

p
vd

q 

   

qn

vf

pn
vj
qm

 b 

 a 

figure    relaxed plan failure scenarios  wavy edges show deletions precondition 
point  thus  fails solve original task must case action
d  call deleter  deletes precondition action f   called
failed action  note failed action goal  let p pre f  
deleted fluent  procedure distinguishes two cases  based relation
nodes vd vf rpdg 
first case  illustrated figure    a   vf ordered vd   choose dependency
closure vd vf   let l set fluents labelling edges closure 
set conflicts generated   p  q    q l    note p   l  thus conflict
proper conjunction  
first case hold  vd vf unordered  must nearest
common descendant node  vj   rpdg  situation illustrated figure  
 b   choose dependency closure vd vj   let l  set fluents labelling
edges closure  likewise  choose dependency closure vf vj   let l 
set fluents labelling edges closure  set conflicts generated
  q  q       q l    q   l   p   
theorem    haslum        theorem    let   a            non redundant plan
delete relaxed task   valid original task   let c set
conjunctions extracted procedure described above  action sequence     a             a n
a i representative ai valid plan c  
      changes conflict extraction satisficing planning
number differences setting haslum        
particular  although  fluents collected initial state  resulting c
ce task
used heuristic evaluations states encountered search  growth
size c
ce task incur overhead heuristic evaluation  thus 
objective find set c make heuristic accurate across states 
keeping size c limited  hand  computing non optimal relaxed
plans computationally far cheaper optimal relaxed planning  afford
iterations algorithm   
therefore  make following modifications strategy  first  use bsg
instead rpdg  necessity orderings latter extend beyond
current  initial  state  therefore useful purpose  bsg
representative relaxed plans found non optimal relaxed planning procedure 
second  introduce single  fluent iteration algorithm   
time  cause new relaxed plan found  allows algorithm focus
finding small number conflicts useful wide range states  chosen
conflict  p  qn   case depicted figure    a    pn   qm   figure    b  
   

fikeyder  hoffmann    haslum

intuitively  works better setting set conflicts generated
plan failure tends redundant  thus needlessly grows size task
leading slow evaluation times without much gain informativeness 
changes affect fundamental property algorithm    converges
real plan  show convergence  property findconflicts must
returns least one new conjunction whenever fails solve original task 
variant still gives guarantee 
lemma   assume eliminate dominated preconditions   c   let   a           
non redundant plan c valid original task   let c
conjunction extracted procedure described above  c   c 
proof  simply because  possible relaxed plan failure scenarios  figure    
chosen conjunction c    x  y    x  y     p  qn   respectively  x  y     pn   qm    contained
precondition failed action f   assuming c    x  y  c  eliminate
dominated preconditions  action precondition c contains x y  hence 
case  c cannot chosen conjunction 
theorem    convergence conflict extraction  assume eliminate dominated preconditions c   algorithm   run without size bound  eventually
plan  
proof  follows lemma   set possible conjunctions finite 
contrasting theorem   haslums variant  theorem     latter gives stronger
convergence guarantee  only  sense guarantees certain minimum progress
made iteration 
lemma    and thus theorem    holds way c
ce   i  e   sequence
c
conditional effects ce   that  viewed set independent actions  constitutes nonredundant plan c
ce   rely eliminating dominated preconditions
makes proof simple  use technique practice anyway 
verify whether convergence holds dominated preconditions eliminated 
conjecture does 
since multiple conflicts bsg relaxed plan  experiments
choose  arbitrarily  one minimizes number conditional effects  or strips
actions  case c   created  place bound factor x c
ce exceeds
size original planning task   precisely  x       fluents conditional
 
effects added  c
ce     resulting standard relaxed plan heuristic  growth
bounds x       fluents added number conditional effects task reaches
 x     a   c   x limits total number actions task multiple  a  

   recall eliminating dominated preconditions means that  whenever add fluent c precondition action  condition conditional effect  remove condition fluents
p c  fluents  c    c  c  

   

fiimproving delete relaxation heuristics explicit conjunctions

example   consider strips planning task example    variables
 x            xn   y   initial state    x    y   goal g    xn    unit cost actions
  h   y    

bi   h xi   y    xi       y  

             n   
previously discussed  setting c    x   y           xn   y   renders delete relaxation
perfect  i  e   results relaxed plan re establish every two bactions  exactly set c iteratively selected procedure 
assuming best supporter function based either hadd hmax   first iteration
algorithm   bsg be 

b 

x 

b 

x 

   

b 

bn 

xn 

bn 

relaxed plan fails execute trying apply second action  b    corresponding failure scenario matches figure    a  


b 

b 

x 

chosen conflict thus  y  x     non empty set conjunctions c containing single conjunction  precondition b  contains  x   y  must
established using action a  bsg takes form  note dominated
preconditions xi b  eliminated  

b 

x 



 x   y 

b 

b 

x 

   

bn 

xn 

bn 

relaxed plan fails execute trying apply fourth action  b   
corresponding failure scenario is 


b 

x 

b 

chosen conflict  y  x     iterating procedure will  manner  select
exactly set c one by one  end relaxed plan solve original
planning task 
    experiments
evaluate impact using c
ce compilation relaxed plan heuristic context greedy search  expected impact using heuristic based improved
relaxation two fold  one hand  make heuristic informative 
   

fikeyder  hoffmann    haslum

enabling search find plans fewer node evaluations  hand 
computational overhead associated growth problem  slowing heuristic
evaluations  examine effects individually  well combined influence coverage  set problems planner able solve within given time
memory bounds  take main measure performance 
study  consider objective producing plans high quality  as
measured plan length cost   plan quality unimportant  rather 
rationale decision methodological  seeking high quality plan
problem seeking find plan minimum search effort particularly
quality measured non unit action costs requirements heuristics
two problems quite different  here  chosen focus one  viz  search efficiency 
measured coverage node evaluations  rather conflate two  choice
plain greedy search algorithm motivated decision  consequence 
treat actions unit cost    previous experiments shown
context greedy search  distinguishing action costs heuristic calculation tends result
lower coverage  richter   westphal         however  least assess impact
heuristics plan quality  report data regarding plan length 
next describe experiment setup baseline  discuss heuristic informativeness  computational overhead  impact conditional effect merging  impact
plan length using c
ce heuristics  comparison state of the art heuristics
problem  difference using c c
ce compilations  finding
plans search 
      experiment setup baseline
compilation associated heuristics implemented fast downward planner
 helmert         used greedy best first search  lazy evaluation second
open list  with boosting  states resulting preferred operators  planners
tested strips domains          editions international
planning competition  ipc   domains last two ipcs  recent
sets instances used  experiments run opteron      processors
settings used competition  memory limit  gb time limit    minutes 
baseline planner configuration uses relaxed plan heuristic  best supporters
identified hadd   unmodified planning task  i  e   growth bound x      
known fact greedy search  particular greedy search lazy evaluation
strong bias towards preferred operators  highly sensitive small changes
relaxed plan  even changes alter heuristic value rather
operators preferred  unfortunately  fact rarely taken account
heuristics compared context greedy search  since introduction  fluents
alters structure relaxed plan  believe particularly important determine
whether resulting differences planner performance really due relaxed plan
 or less  informative 
therefore  first step towards accounting brittleness experiments
greedy heuristic search  introduce simple variance measure use decide
results experiments considered significant  variance performance
   

fiimproving delete relaxation heuristics explicit conjunctions

baseline planner measured randomizing choice supporters equal
hadd values construction relaxed plan measuring maximum deviation
results baseline planner five repeated runs  results shown
columns labeled mad  tables       domain problem set
whole  deviation defined differences coverage median number
heuristic evaluations  note interested whether randomization helps
hurts search  rather magnitude variation causes 
c
comparing results planner using heuristics based c
ce different
growth bounds results baseline planner  consider difference
significant greater magnitude maximum deviation observed
randomization baseline  interpreted significance
statistical sense  although  assumed randomization affects heuristics equally 
could estimate probability hypothesis difference   simply setting
reasonable threshold counts substantial difference search performance 

      heuristic informativeness
comparison heuristic informativeness summarized right half table   
shows ratio median  per domain  tasks solved planners 
number heuristic evaluations baseline planner planners using
c
ce  based heuristics  half domains  difference informativeness
c
ce  based heuristics compared baseline exceed threshold significance
set sensitivity study  shown mad column   among domains
significant difference  majority using c
ce  based heuristics reduces
number node evaluations  indicating augmented heuristics informative 
cases  ratio grows  fluents added  i e   growth bound
x increased  drastic example seen floortile domain 
c
ce  based heuristics evaluate four orders magnitude fewer nodes  compared
standard delete relaxation heuristic  allows easily solve instances
domain  comparison  planner ipc      able solve  
   instances domain  woodworking domain  c
ce heuristics
two orders magnitude informative  associated increase coverage
tasks solved configurations 
roughly third domains consistent  or nearly consistent  loss
informativeness  though significant  note loss informativeness always correlate loss coverage  attributed different
factors  including small magnitudes loss  well fact ratio node
evaluations taken tasks solved planners compared  another issue
dramatic coverage losses often due computational overhead incurred
c
ce compilation  particular  openstacks satellite domains  decrease
number tasks solved c
ce  based heuristics matches almost exactly number
tasks conflict selection compilation process fails complete within
     seconds allocated per task  get back next subsection 
   

fikeyder  hoffmann    haslum

worth noting quality c
ce  based heuristics highly sensitive
precise choice  fluents used compilation   hence  may exist better policies
making choice relatively simple one used here 
ho po colums table    coverage only  examine effect new
heuristic function  respectively new preferred operators returned function 
separation  po corresponds configuration uses relaxed plan c
ce task
 built x       timeout     s  discussed section        identify
preferred operators  together heuristic value baseline  x      heuristic 
ho  hand  uses heuristic values obtained x       preferred
operators x      interestingly  either heuristic values preferred operators alone
sufficient greatly improve coverage floortile  domain techniques
greatest impact  ho po configurations able solve every instance
domain   effect domains mixed  configurations solving
sometimes more  sometimes fewer instances 
      computational overhead
computational overhead c
ce  based heuristics  compared standard relaxed
plan heuristic  stems two sources      time spent computing set  fluents
add problem      greater overhead heuristic evaluation c
ce task 
table   shows three measures impact 
first four columns  under timeouts  show number instances
construction c
ce task finish within      seconds  second set
four columns  under      sec  shows number instances construction
time exceeds    seconds  inclusive instances first set columns   note
behavior spending large amount time c
ce construction without reaching
growth bound partly due strategy selecting  fluents  since purposely
choose  fluents increase size compiled task least 
several domains construction time frequently exceeds    seconds 
happen domains c
ce  based heuristic informative 
floortile woodworking  suggests imposing time limit construction
c
ce task incur small loss informativeness  present coverage results
strategy  using    second time limit  table   below  significantly better
baseline planner  compares favourably state art heuristics 
expected  domains evaluating heuristics c
ce task slower
standard delete relaxation  tends slow growth bound x increases 
due larger number fluents actions compiled planning task  median
slowdown per domain typically order x itself  exceeds one order
   indeed  results reported earlier paper  keyder  hoffmann    haslum        show increase
informativeness barman parcprinter domains 
   plausible explanation behavior respect dead end states  intuitively 
robot painted corner  unrecognized standard delete relaxation
heuristic  i  e   relaxed plan exists  appears c
ce highly effective fixing
issue  x     search encounters millions states hff        ho encounters

states hff  c
 c
ce      suggesting h
ce   prunes dead ends early on   po encounters
states  suggesting hff  c
 
preferred
operators prevent search entering
ce
dead end regions first place  

   

fiimproving delete relaxation heuristics explicit conjunctions

domain
x   mad
airport     
  
barman     
  
blocksworld     
  
depots     
  
driverlog     
  
elevators     
  
floortile     
 
freecell     
  
grid    
 
gripper     
  
logistics       
  
logistics       
  
miconic      
   
mprime     
  
mystery     
  
nomystery     
 
openstacks     
  
parcprinter     
  
parking     
  
pathways     
  
pegsol     
  
pipes notk     
  
pipes tank     
  
psr     
  
rovers     
  
satellite     
  
scanalyzer     
  
sokoban     
  
tidybot     
  
tpp     
  
transport     
  
trucks     
  
visitall     
  
woodwork     
  
zenotravel     
  
total       
    

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

   


coverage
x  
po ho
                   
  
              
               
  
  
  
  
  
  

    
           
  
  
  
  
  
  

                 
                       
     
        
  
  
  
  
  
  

  
  
  
  
  
  

  
  
  
  
  
  

    
        
  
  
  
  
  
  
  

  
  
  
  
  
  

                 
           
           
             
    
       
  
         
  
  
  
  
  
  

    
  
    
  

          
     
  
  
  
  
  
  

  
  
    
  
 
  
          
                
    
       
  
      
  
 
  
  
  
  
  
  

              
     
           
             
  
  
  
  
  
  

  
  
  
  
  
  

               

median node evaluations ratio
x  
   
 
   
 
    
        
        
        
        
    
        
        
        
      
 
        
        
        
        
     
        
        
        
        
             
        
        
        
    
        
        
        
        
              
         
         
         
    
        
        
        
        
             
        
        
        
 
        
        
                 
    
        
        
        
        
             
        
        
        
          
        
        
        
             
        
        
        
             
        
        
        
     
        
        
        
         
             
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
   
        
        
    
        
        
        
        
     
        
        
        
        
    
   
   
   
        
 
   
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
                
         
          
          
    
        
        
        
        
mad

table    planner coverage heuristic informativeness using c
ce varying growth bounds 
without conditional effect merging  coverage shows number problems solved baseline
configuration  x       difference  increase decrease  relative baseline
configurations  po uses preferred operators obtained c
ce compilation
x           s  returning x     heuristic value  ho uses heuristic values
obtained x           s  preferred operators x      heuristic informativeness
measured ratio per domain median number node evaluations  comparing
baseline configurations  across instances solved configurations   normalized
smaller value    is  entry     means baseline planner requires times
many heuristic evaluations planner  columns labeled mad show magnitude
maximum deviation  in coverage ratio  baseline sensitivity study  values
bold exceed threshold  therefore consider significant 

magnitude floortile domain x        somewhat surprisingly 
domains heuristic evaluations become faster  fluents added  possible
explanation eliminate dominated preconditions  cf  section    
number action preconditions decreases delete relaxation hypergraph
c
ce becomes graph like result 
   

fikeyder  hoffmann    haslum

domain
airport     
barman     
blocksworld     
depots     
driverlog     
elevators     
floortile     
freecell     
grid    
gripper     
logistics       
logistics       
miconic      
mprime     
mystery     
nomystery     
openstacks     
parcprinter     
parking     
pathways     
pegsol     
pipes notank     
pipes tank     
psr     
rovers     
satellite     
scanalyzer     
sokoban     
tidybot     
tpp     
transport     
trucks     
visitall     
woodwork     
zenotravel     
total       

timeouts
x  
           
 
 
 
 

   
  

     sec
x  
 
   
  
  

 
  

 

 

 

 

 

  

  

  

  

 

 

 

 

 

  

 

 

  

  

  

  

  

  
 

  
 

  
 

 
 
 

 
  
 

 
  
 

 
  
 

 

 
 
  
 
 

 
 
  
 
 

 
 
  
 
  

  

   

   

   

 

 

  

  

  

 

 

  

 
  

ratio median evaluations sec
x  
   
 
   
 
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
   
   
        
        
        
        
        
        
        
        
                 
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
                 
        
        
   
        
        

table    computational overhead c
ce   first set columns  timeouts  shows number

tasks c
ce construction finish within      second time limit 
second set       sec  shows number tasks construction time exceeds    seconds
 inclusive first set columns   improve readability  non zero entries
shown  i e   blank cells columns zeroes   last set columns shows median
 per domain  commonly solved tasks  ratio heuristic evaluations per second baseline
planner  x      planner  x       entry     means baseline planner
performs times many heuristic evaluations per second planner 

      conditional effect merging
majority domains  conditional effect merging slightly increases change
informativeness c
ce  based heuristics  exceptions logistics  
gripper domains  merging results heuristic twice informative
 using ratio median number evaluations metric presented table    
nomystery domain order magnitude informative  for problems
solved heuristics   barman domain four times less
informative  general  higher informativeness occurs domains tasks
   

fiimproving delete relaxation heuristics explicit conjunctions

solved planners  result increased coverage  indeed  shown
table   below  conditional effect merging proves detrimental overall coverage
c
planner using c
ce  based heuristic  best ce configuration conditional
effect merging solves  total    tasks standard relaxed plan heuristic 
configuration without conditional effect merging solves    tasks 
runtime overhead merging procedure quite small  transitive closure
operation required check whether path two nodes bsg
implemented efficiently graph known directed acyclic  case
here  x        comparing c
ce  based heuristic conditional effect merging
without  ratio median number heuristic evaluations per second  the
metric used right hand side table    shows maximal per domain slow down
      across domain average       coverage decreases domains
barman therefore appear due sensitivity search small changes
heuristic function  rather due time taken compute function  
      plan length c
ce
determine effect using c
ce heuristics plan quality  compare length
plans found c
heuristics

found x      standard delete relaxation
ce
heuristic  plan length measure equivalent plan quality unit cost setting 
consider median ratio plan length found standard delete relaxation
heuristic found c
ce heuristic  set instances solved
configurations  table     general  observe large differences 
median ratio staying close    one notable exception blocksworld domain 
heuristics based c
ce compilation consistently find significantly shorter plans 
c
results ce heuristics ability deduce implicit ordering constraints domain 
avoiding actions lead temporary improvements greedy search later
need reversed  adding plan length  c
ce leads shorter plans gripper 
mprime  woodworking domains  tends result longer plans barman
grid domains 
      comparison state art
table   shows coverage variety heuristics planners  best configurations
two compilations x     achieve better overall coverage results
standard relaxed plan heuristic  best performing heuristics obtained c
ce
compilation without conditional effect merging  c compilation  give coverages
          respectively  difference coverage baseline
planner greater significance threshold  numbers far exceed coverage obtained hcea heuristic  fall short      instances solved
dual heuristic approach used lama  however  combining lama best c
ce  nm
configuration portfolio planner runs lama      seconds search
c
ce  nm heuristic     seconds results coverage           solvable problems 
almost difference results c
ce  based heuristics superior performance
floortile  lesser extent  airport domains 
   

fikeyder  hoffmann    haslum

domain
airport
barman
blocksworld
depots
driverlog
elevators
floortile
freecell
grid
gripper
logistics  
logistics  
miconic
mprime
mystery
nomystery
openstacks
parcprinter
parking
pathways
pegsol
pipesworld
pipesworld
psr
rovers
satellite
scanalyzer
sokoban
tidybot
tpp
transport
trucks
visitall
woodwork
zenotravel

x      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

x
 
 
    
    
 
 
 
 
 
    
 
    
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
    
    
 
 
    
    
    
    
    
 
    
 
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    

x      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

x
 
 
    
    
 
 
 
 
 
    
 
    
    
    
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
    
    
 
 
    
    
    
    
    
 
    
 
 
 
    
    
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    

table    median ratio length plans found x      length plans found c
ce
different values x  instances solved planners  entry     means
baselines plans times longer planner  conditional effect merging
used 

      c vs  c
ce
given fixed number  fluents  difference size c c
ce
compilations exponential worst case  mutex pruning  however  mitigate much
growth c   consider  example  action c
ce compilation n
different conditional effects  mutexes considered  one would expect number
action representatives generated set  fluents c  n   if  however 
n  fluents generating conditional effects shown mutex
one another  number action representatives generated c n 
found experiments effect leads much slower growth c
might expected  consider figure    point graph represents
   

fiimproving delete relaxation heuristics explicit conjunctions

domain
airport     
barman     
blocksworld     
depots     
driverlog     
elevators     
floortile     
freecell     
grid    
gripper     
logistics       
logistics       
miconic      
mprime     
mystery     
nomystery     
openstacks     
parcprinter     
parking     
pathways     
pegsol     
pipes notank     
pipes tank     
psr     
rovers     
satellite     
scanalyzer     
sokoban     
tidybot     
tpp     
transport     
trucks     
visitall     
woodwork     
zenotravel     
total       

x  
  
  
  
  
  
  
 
  
 
  
  
  
   
  
  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    

mad
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

 
  

c
ce
  
  
  
  
  
  
  
  
 
  
  
  
   
  
  
 
  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    

coverage
c
 nm
c
ce
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
 
 
  
  
  
  
  
  
   
   
  
  
  
  
 
  
  
  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    
    

hff
  
  
  
  
  
  
 
  
 
  
  
  
   
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
 
  
  
    

hcea
  
 
  
  
  
  
 
  
 
  
  
  
   
  
  
 
  
  
  
  
  
  
  
  
  
  
  
 
  
  
  
  
 
 
  
   

lama
  
  
  
  
  
  
 
  
 
  
  
  
   
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    

pf
  
  
  
  
  
  
  
  
 
  
  
  
   
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    

table    comparison state of the art heuristics satisficing planning  columns x    
mad table    column c
ce shows coverage best configuration  in terms overall
coverage  compilation using conditional effect merging  namely x              
c
c
ce  nm best ce configuration without conditional effect merging  which happens use
c
x t   best c configuration x      which happens use
x t   entries bold columns difference baseline planner
exceeds threshold significance  given mad column   column pf shows coverage
portfolio planner runs lama      seconds c
ce     seconds 
single problem instance  from instance set before   paired value x 
c
c
ce  x axis   y axis   measure ratio growth  a  growth
 f    i  e   factor compilation increased size action set encoding
 measured number actions c number conditional effects c
ce   
divided factor compilation increased number fluents 
   

fikeyder  hoffmann    haslum

 e   
action set growth uent set growth  c

action set growth uent set growth  c

   
 
   
 
   
 
   
 
   
 

 

   

 

   

 

   

 

   

 

   

action set growth uent set growth  cce

 e   
 e   
      
     
    
   
  
 

 

  

   

   

   

   

   

   

action set growth uent set growth  cce

 a 

 b 

figure    growth problem size ratio growth  a  growth  f     a  without
 b  mutex pruning  point corresponds single instance value x  f  x    x
shown reference 

words  assess growth encoding number conjunctions  c  
theory worst case exponential c linear c
ce  
mutex pruning used  figure    b    growth c rapid
ratio quickly increases millions  mutex pruning  figure    a    growth c
still faster c
ce   difference much smaller 
      finding plans search
growth time limit imposed construction c c
ce tasks 
algorithm   used complete planning algorithm  competitive
heuristic search methods  nevertheless interesting observe performance details
algorithm various domains  coverage obtained algorithm using
c c
ce compilations  well statistics growth compiled
c
tasks  shown table    difference c
ce much visible here 
since number  fluents added is  general  much larger growth bounded
constructions used heuristic computation  c
ce able rapidly add much
larger number  fluents  therefore find relaxed plans solutions
c
original planning task well  overall  c
ce solves     tasks compared      
solves equal greater number tasks except   domains 
considering individual domains  seen c c
ce able solve
almost tasks certain domains logistics    mprime  mystery  parcprinter 
psr  woodworking  domains  even addition small amount
information sufficient obtain relaxed plans plans original task 
maximum x values required solve tasks quite low  case mprime 
mystery  woodworking domains  maximum required x values            
      respectively  others elevators  openstacks  transport  visitall 
even smallest tasks quite large many different plans possible 
possible introduce enough  fluents disqualify possible relaxed plans
constitute real plans  tasks solved 
   

fiimproving delete relaxation heuristics explicit conjunctions

domain
airport     
barman sat     
blocksworld     
depots     
driverlog     
elevators sat       
floortile sat       
freecell     
grid    
gripper     
logistics       
logistics       
miconic      
mprime     
mystery     
nomystery sat       
openstacks sat       
parcprinter sat       
parking sat       
pathways noneg     
pegsol sat       
pipes notank     
pipes tank     
psr     
rovers     
satellite     
scanalyzer sat       
sokoban sat       
tidybot sat       
tpp     
transport sat       
trucks     
visitall sat       
woodwork sat       
zenotravel     
total       

cov 
  
 
  
  
  
 
 
 
 
  
  
  
   
  
  
 
 
  
 
 
  
  
 
  
  
  
 
 
 
  
 
  
 
  
  
   

min
    
    
    
    
     
     
    
    
    
    
    
    
    
     
    
    
     
    
    
    
    
    
    
     
    
    
    
    

c
ce
max
     
      
     
     
      
     
     
      
     
     
      
    
    
     
     
     
      
      
     
     
      
     
     
     
     
     
    
     

c
med
    
     
    
    
      
     
    
     
    
     
     
    
    
     
    
    
      
     
     
    
    
     
     
     
     
     
    
    

cov 
  
 
  
  
  
 
 
 
 
 
  
  
  
  
  
 
 
 
 
 
 
 
 
  
  
 
  
 
 
 
 
 
 
  
  
   

min
    
    
    
    
     
      
    
    
    
    
    
    
    
     
    
    
     
    
    
    
    
    
    
    
    
    
    

max
      
      
      
     
      
      
     
      
      
      
       
     
    
     
      
      
      
      
       
      
      
      
    
      
      
    
      

med
    
     
     
    
      
      
    
     
     
    
     
    
    
     
     
     
      
     
     
     
     
     
    
     
     
    
     

table    solving planning tasks search  table shows coverage c c
ce compilations  minimum  maximum  median values x solved tasks 

   heuristics optimal planning
consider admissible heuristics  optimal planning  section     considers
lm cut heuristic  showing certain complications make difficult
obtain improved heuristic estimates c c
ce   section      consider
alternative method lower bound h    namely admissible cost partitioning heuristics based
conjunctive landmarks obtained c
ce   detail choose c
setting  present experimental results section     
   

fikeyder  hoffmann    haslum

a 


a 
a 

g 

ac
 

g 

g 


a 
a 
a 

g 

ac
 

 

g 

g 
 a 

 

 g   g   g   
ac
 

 

 b 

figure    lm cut   c compilation  example   
    lm cut
state of the art admissible approximation h  computed lm cut algorithm
 helmert   domshlak         logical approach obtaining admissible heuristics
c c
ce therefore apply lm cut compilations  unfortunately  turns
several serious obstacles this  discussing issues  first give
brief description lm cut algorithm  present simpler case c
compilation  additional complication conditional effects present 
lm cut computed planning task deletes  simple transformation first applied replaces goal set g single goal achieved
goal achievement action whose precondition set g  adds dummy precondition actions whose precondition set empty  lm cut initializes hlm cut     
and  repeats following steps hmax  g  becomes        compute hmax       apply
precondition choice function  pcf  action precondition pre a  removes
pre a  one fluents p pre a  hmax  p  maximal      construct
justification graph whose vertices fluents whose arcs precondition effect
pairs according pcf      find cut l initial state goal
justification graph  given set actions enters goal zone  i  e   set
fluents goal reached   cost      add costmin    minal cost a 
heuristic value hlm cut   reduce cost l costmin   proved
helmert domshlak         algorithm two fundamental properties  namely  i 
admissibility  hlm cut h     ii  domination hmax   hmax hlm cut  
would expected heuristic obtained manner c would
strictly informative obtained original planning task  
turns case  indeed  heuristic become strictly less informative 
example   let   hf  a  i  gi given f    g    g    g        a    a    a    
ai   h   gi      i      g    g    g    g     figure     words  three goals 
achievable single action  valid plans apply action
order  make goals true  cuts found lm cut algorithm task
 a      a      a     regardless pcfs chosen  lm cut algorithm therefore
always computes optimal cost    consider c compilation results
set c     g    g    g      f c contains single  fluent  g   g   g      representative
 
 
action ac
constructed sole non empty subset c     g    g    g     c 
first cut found lm cut contains three representatives  adds
expensive goal  g   g   g      possible pcfs  next cut last 
final heuristic estimate   two cuts found  if  example 
   

fiimproving delete relaxation heuristics explicit conjunctions

 

 

c
precondition choice function chooses g  hmax justifier ac
  a    g 
 
max
c
h
justifier a    cut  a    a     cut  goal reached   cost
  g  g  g   
via a    a    a          hmax   lm cut stops 

 
c
note  similarly h   c
ce    cf  theorem    possible either h    
hmax  c   decrease addition  fluents  example hmax
cost task actually increases  from      addition  fluent  g   g   g     
however  type interactions introduced difficult lm cut algorithm
reason about  resulting worse admissible bounds practice  lm cut course continues dominate hmax   proving sufficient number  fluents added  lm cut
eventually tend towards optimal cost task 

weakness pointed example   inherited application lm cut
algorithm c
ce compilation  furthermore  application involves additional complication proves formidable  lm cut defined conditional effects  therefore
cannot directly applied c
ce task  turns two straightforward
adaptations algorithm problems conditional effects  neither preserves
properties  i  admissibility  ii  domination hmax  
see  ii  stake  consider planning task single action
two conditional effects ce a     h p    q   ce a     h q    r   i  initial state
 p   goal  r   h       hmax        due critical path ha  ai 
justification graph considered lm cut consists sequence  first cut found
 a   cost reduced  remaining task hmax cost    resulting
cost estimate hlm cut     
issue different conditional effects action may part
critical path  natural approach therefore reduce costs per individual conditional
effect  rather effects action once  unfortunately  turns
preserve admissibility  i   indeed  detail example    appendix a  
exist strips tasks whose c
ce compilations following property 
exists action reducing cost globally first encountered cut
leads heuristic estimate less hmax  c
ce    treating effects
 
c
separately leads estimate greater h  ce     h    
therefore simple strategy dealing conditional effects preserves
 i   ii  planning tasks  since admissibility cannot sacrificed  must
reduce costs globally give dominating hmax   particular implication
 
c

so  despite theorem   shows hmax  c
ce     h  ce   converges h    
convergence guaranteed hlm cut  c
ce    could course fixed using
max hmax   hlm cut   heuristic value  yet hmax typically informative 
strategy useful practice 
detail section     below  ipc benchmarks  using lm cut computed either c c
ce often results larger search spaces  fluents introduced  cases  overall performance worse hlm cut  c   hlm cut  c
ce  
hlm cut     remains open question whether improved 
   

fikeyder  hoffmann    haslum

    c
ce landmarks
landmarks planning tasks formulas set fluents f property made true state execution valid plan 
problem checking whether even single fluent landmark planning task
pspace complete  approaches finding landmarks past focused
delete relaxation  setting whether fluent landmark checked
polynomial time  recently shown maximum fixpoint solution
set simple recursive equations defines complete set single fact delete relaxation
landmarks  words landmark formulas consist single literal
  p  keyder et al          solution computed algorithm repeatedly updates set landmarks fluent action planning task 
convergence  method naturally handle conditional effects treating
independent actions  described section     
shown equations applied and or graph
structure  necessarily corresponding delete relaxation planning task 
insight used obtain landmarks task  single  fluent landmarks
correspond conjunctive landmarks necessarily landmarks
delete relaxation     approach suffers  however  large number  fluents
considered   rendering landmark generation impractical compilations larger tasks  aim take advantage flexibility c
ce compilation
obtain non delete relaxation landmarks original task  considering
focused set  fluents given size m  before  allow us
consider larger conjunctions keeping size delete relaxation task low 
using c
ce landmark finding  focus technique keep overhead
bay  choose set conjunctions c guarantee every  fluent landmark
c
ce  and therefore original planning task   accomplished extracting
landmark graph sets landmarks simultaneously achieved  
definition    simultaneously achieved landmarks  set landmarks ls       
        n   simultaneously achieved lc         n landmark  
maximal sets simultanously achieved landmarks easily extracted set
landmarks orderings  given initial set landmarks l set orderings 
following sets sets simultaneously achieved landmarks 
lg        g      
lnec        nec     l 
lgn        gn     l 
lg contains single set made landmarks l entailed g  since
valid plan must make goals true final state  necessarily simultaneously
achieved  given landmark   lnec contains set elements landmarks ordered necessarily   due definition necessary orderings 
must simultaneously true every state immediately precedes state
becomes true  lgn similar set  yet since greedy necessary orderings
   

fiimproving delete relaxation heuristics explicit conjunctions

weaker necessary orderings  sometimes contain sets appear lnec  
therefore result larger overall set conjunctive landmarks  note necessary orderings greedy necessary orderings  conjunctive landmark
results set necessary orderings therefore subset conjunctive landmark
results greedy necessary orderings  include conjunctive landmarks result
necessary orderings result stronger necessary orderings added
conjunctive landmark   landmark heuristics sometimes infer
conjunctive landmarks must reachieved landmark ordered necessarily
reachieved  case conjunctive landmarks derived
greedy necessary orderings  need achieved make landmarks
ordered true first time 
algorithm    choosing c landmark generation 
c 
l   findlandmarks c
ce  
repeat
c   c simultaneouslyachieved l 
l   findlandmarks c
ce  
simultaneouslyachieved l  c

strategy choosing c landmark generation shown algorithm   
new conjunctive landmarks l   p  pn discovered  corresponding fluents
 p       pn   added c
ce landmark computation step repeated  note
process may go several iterations  run fixpoint reached 
addition new  fluents c
ce task result discovery new landmarks 
process terminates new conjunctive landmarks discovered already
exist  fluents c
ce   note method choosing c desired
c
property mentioned above   fluents introduced c
ce represent fact landmarks ce
conjunctive landmarks original task  
strategy works especially well domains many landmarks several landmarks necessarily greedy necessarily ordered them  one domain
occurs blocksworld  see illustration figure     method
able find extremely informative conjunctive landmarks allow optimally solve
tasks heuristic tested 
    experiments
consider performance lm cut heuristic hlm cut c c
ce compilations  admissible landmark cost partitioning heuristic hlm introduced
karpas domshlak        different landmark generation schemes  including
lm cut used search algorithm  hlm
landmarks obtained c
ce   h

use lm a   variant effective known fluent landmarks
 karpas   domshlak         benchmarks  computers  time memory limits
used section     
   

fikeyder  hoffmann    haslum

informativeness
coverage
domain
c      
c
 
   
orig 
x
 
 
c       c
ce
ce      
airport
         
         
  
  
  
  
barman opt
        
        
 
 
 
 
blocksworld
        
        
  
  
  
  
depots
        
        
 
 
 
 
driverlog
        
         
  
  
  
  
elevators opt  
        
        
  
  
  
  
floortile opt  
         
         
 
 
  
  
freecell
        
        
  
  
  
 
grid
        
        
 
 
 
 
gripper
   
   
 
 
 
 
logistics  
        
         
  
  
  
  
logistics  
        
         
 
 
 
 
miconic
          
                  
  
  
mprime
         
        
  
  
  
  
mystery
        
        
  
  
  
  
nomystery opt  
          
          
  
  
 
 
openstacks opt  
   
   
  
  
  
  
parcprinter opt  
        
        
  
  
  
  
parking opt  
 
 
 
 
pathways noneg
         
         
 
 
 
 
pegsol opt  
        
        
  
  
  
  
pipes notank
        
        
  
  
  
  
pipes tank
        
        
  
  
 
 
psr
        
        
  
  
  
  
rovers
        
        
 
 
 
 
satellite
        
         
 
 
 
 
scanalyzer opt  
        
        
  
  
 
 
sokoban opt  
        
        
  
  
  
  
tidybot opt  
        
         
  
  
 
 
tpp
        
        
 
 
 
 
transport opt  
        
        
 
 
 
 
trucks
        
         
  
  
 
 
visitall opt  
        
        
  
  
  
  
woodwork opt  
        
        
  
  
 
 
zenotravel
         
          
  
  
 
 
total
       
   
   
c
table    lm cut c
ce   two columns left show ratio summed

number heuristic evaluations tasks solved configurations  comparing standard
lm cut results x     lm cut computed c c
ce x        example 
first entry table             shows lm cut computed c growth bound
x       evaluates  sum commonly solved tasks  nearly    times many states lm cut
computed standard delete relaxation  last   columns show coverage  column original
shows results obtained fast downwards implementation lm cut  which applies
standard delete relaxation   column x     shows results implementation lmcut unmodified delete relaxation  with differences two purely due
implementation details   entries bold indicate highest coverage domain  total 

   

fiimproving delete relaxation heuristics explicit conjunctions

clear a 
gn
clear b 
handempty
ontable b 

clear a 
holding b 

nat

nat

clear b 
handempty
on b  a 
clear c 
handempty
ontable c 

clear b 
clear d 
gn
on b  a 
holding c 
nat ontable d 
gn

on b  a 
on c  b 
on d  c 

nec

clear c 
clear c 
clear d 
on b  a  gn handempty
on c  b 
on b  a 
holding d 
on c  b 
ontable d 

figure    landmarks graph found c
ce compilation small blocksworld task 
blocks initially table g    on b  a   on c  b   on d  c    smaller conjunctive
landmarks single fluent landmarks omitted 

      lm cut c c
ce
evaluate impact using c c
ce compilations lm cut  constructed
c
c
ce tasks following procedure described section      repeatedly
selecting conflicts increase size compiled task reached fixed growth
bound x  conflict selection based hmax supporters rather hadd supporters 
hmax plays key role computation lm cut  resulted better performance 
that  procedure used generate c c
ce tasks same 
c
tested value x set                  c
ce   observed
x       dominated larger values x domain by domain overall basis 
therefore report results two configurations  exception
mystery domain  c x       x     solved    tasks compared   
x       
overall  heuristic computed lm cut algorithm standard delete relaxation   dominates computed c c
ce   terms informativeness
terms coverage  first two columns table   show large majority
domains  search using lm cut computed c c
ce performs many heuristic
evaluations tasks solved configurations  airport domain 
instance  lm cut standard delete relaxation requires approximately    times fewer
heuristic evaluations solve set tasks either c c
ce   domains  situation less extreme  standard delete relaxation continues give
better heuristic estimates  exceptions blocksworld  elevators  floortile 
freecell  grid  mprime  mystery  pegsol  psr  transport woodworking domains 
 
least one c c
ce yields informative heuristic estimates  
impressively  c c
ce give estimates respectively       times informative estimates obtained   floortile domain  estimates using
c    times informative   mprime domain  terms
coverage  translates    tasks solved c c
ce floortile domain 
compared   standard version lm cut     tasks solved c
   

fikeyder  hoffmann    haslum

mprime domain  compared     mystery domain  coverage increased   
domains  coverage achieved c c
ce  based lm cut less equal
coverage achieved standard lm cut  overall  standard version lm cut
solves     planning tasks compared     c     c
ce   though large part
difference     tasks  comes miconic domain  difference remaining
domains still significant 
comparing c c
ce   seen additional loss information resulting
treatment conditional effects lm cut leads worse heuristic estimates
c
using c
ce   expected theoretical result ce grows linearly
number  fluents  number  fluents added task using
c
c
ce compilation almost always higher using   however treatment
conditional effects lm cut  described above  turns greatly degrade performance 
c
lm cut using c
ce informative lm cut using   domains 
      admissible landmark heuristics c
ce landmarks
admissible landmark heuristic  hlm   uses action cost partitioning derive heuristic
values collection  ordered  landmarks  distributing cost action
set landmarks achieves  karpas   domshlak         cost partitioning done
different ways  optimal cost partitioning tractable  yields best possible heuristic
value given set landmarks  practice slow coverage suffers  uniform
partitioning generally achieves better time informativeness trade off  therefore better
coverage 
evaluate potential informativeness landmarks obtained c
ce using
iterative technique described section      used landmarks optimal cost
partitioning setting  since setting makes best possible use information present
given landmarks  compared informativeness heuristic using
landmarks obtained compilation         sound
complete landmark generation algorithm  keyder et al          results shown
first two columns table    show ratio total number heuristic evaluations 
per domain  tasks solved configurations  hlm using landmarks  
heuristic using landmarks   c
ce   respectively  note landmarks
  compilations contain landmarks obtained  
generated c


ce
subset  hlm optimal partitioning   c
ce landmarks therefore
dominates hlm optimal partitioning   landmarks  hence ratio always
greater   
     domains considered  neither addition   landmarks c
ce landmarks leads informative heuristic  cases columns show value    
remaining    domains  schemes improve   landmarks equal degree
     improves   greater degree c
ce     one case  blocksworld 
c
landmarks

much

informative

landmarks
found methce
ods  improve informativeness baseline heuristic using   landmarks
factor     
uniform cost partitioning divides cost action evenly set landmarks
achieves  rather searching partitioning maximizes heuristic value
   

fiimproving delete relaxation heuristics explicit conjunctions

domain

airport
barman opt
blocksworld
depots
driverlog
elevators opt  
floortile opt  
freecell
grid
gripper
logistics  
logistics  
miconic
mprime
mystery
nomystery opt  
openstacks opt  
parcprinter opt  
parking opt  
pathways noneg
pegsol opt  
pipes notank
pipes tank
psr
rovers
satellite
scanalyzer opt  
sokoban opt  
tidybot opt  
tpp
transport opt  
trucks
visitall opt  
woodwork opt  
zenotravel
total

informativeness
coverage
 optimal partitioning   uniform partitioning 
 
c
 
 
c
ce
ce
    
    
  
  
  
 
 
 
     
      
  
  
  
    
    
 
 
 
    
    
  
 
 
    
    
  
  
  
    
    
 
 
 
    
    
  
  
  
    
    
 
 
 
 
 
 
 
 
     
     
  
  
  
    
    
 
 
 
    
    
   
   
   
    
 
  
  
  
    
 
  
  
  
    
    
  
  
  
 
 
  
 
  
    
 
  
 
  
    
 
 
 
 
 
 
 
 
 
    
 
  
  
  
    
    
  
  
  
    
    
  
  
  
    
    
  
  
  
 
 
 
 
 
    
    
 
 
 
    
    
 
 
 
    
 
  
  
  
    
    
  
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
    
    
 
 
 
 
 
 
 
 
   
   
   

table    hlm landmarks generated delete relaxation          keyder et al        
c
ce   two columns left show ratio summed number heuristic evaluations
tasks solved configurations  comparing   c
ce baseline using landmarks
    using optimal cost partitioning hlm   landmarks yield better lower bounds 
indeed ratios    which use     presentation  differently
previous tables   right most three columns show coverage  using uniform cost partitioning 
heuristic uniform partitioning solves tasks optimal cost partitioning
landmark generation schemes considered  entries bold indicate best results  per domain
total 

   

fikeyder  hoffmann    haslum

state  make hlm heuristic weaker  though typically much 
makes much faster compute  leading better coverage general  confirmed
uniform cost partitioning results higher coverage optimal cost partitioning
domains three landmark generation schemes considered 
three right most columns table   show coverage achieved hlm
three landmark generation schemes setting  seen using   landmarks results greater coverage combining either   c
ce landmarks 
 
c
compared heuristic using landmarks  using ce landmarks solve many
tasks every domain except nomystery rovers domains  c
ce landmarks outperform   landmarks two domains  blocksworld  using c
landmarks
planner
ce
finds optimal solutions       tasks  tested heuristic 
miconic    instance  domains  use c
ce landmarks either
 
effect worsens coverage compared   interestingly  informativeness
lm cut heuristic increases greatly c c
ce compilations floortile domain  corresponding increase compilations used find landmarks 
conjunctive landmarks  besides goal  found 

   conclusions open questions
long tradition works attempting devise heuristics taking account
delete effects  however  techniques rendering h  perfect limit thus allowing
smoothly interpolate h  h proposed quite recently 
haslum        katz et al         respectively  extended haslums approach
introducing new compilation method linear  vs  worst case exponential  growth 
demonstrated machinery needed using approach generate heuristics 
evaluation shows that  domains  informedness dramatically improved
small cost terms computational overhead 
main open issue lies use words domains here 
domains  gain informativeness small  domains overall performance
suffers dramatically  domain independent planning technique work well
every domain  simple portfolio approach  cf  column pf table    suffices
improve state art satisficing planning  extent per domain performance variation technique dramatic  obtain understanding
causes phenomena  ultimately exploit understanding devise reliable effective practical methods  unchanged worse performance many domains
due fundamental limitations technique  due particular instantiation
 especially selection  fluents  run experiments 
practical perspective  answering questions comes exploration
techniques predicting impact adding  fluents  making informed
decisions  fluents add  observed changes domain formulation  random reorderings  small changes heuristic criteria used  fluent
selection large impact heuristic informativeness coverage  research formulate new heuristic criteria improve existing ones therefore could 
potentially  provide better performance across wide range domains  might in   

fiimproving delete relaxation heuristics explicit conjunctions

teresting systematically explore impact random arbitrary changes  attempt
building complementary strength compilations combined effective portfolios 
theoretical perspective  currently approaching questions
terms analyzing conditions small  polynomial size  set  fluents
suffices render h  perfect  applied individual domains  analysis offers way
answering question whether lack performance improvement due
essential limitation due choosing wrong set  fluents  hope
eventually obtain syntactic criteria  e  g   based causal graph structure 
automatically applied arbitrary planning task descriptions  serving select  fluents
 or exclude subsets  fluents consideration  targeted manner  first
results direction already published hsdip    hoffmann  steinmetz 
  haslum        
observations optimal planning pose many questions future work  simple one
whether effective c
ce landmarks could extracted restricting techniques
adding  fluents guaranteed landmarks  daunting challenges regard
lm cut  observations suggest methods use suffer greatly suboptimal
choices precondition choice functions  pcfs   would therefore worthwhile investigate new methods obtaining better pcfs  another important direction develop
extensions lm cut conditional effects guarantee admissibility domination hmax   simple yet impractical method multiply conditional effects
 enumerating subsets thereof   sophisticated method based context splitting  distinctions different occurences action introduced
targeted manner necessary  recently proposed  roger  pommerening 
  helmert        
summary  explicitly represented conjunctions clearly exhibit potential dramatically improve delete relaxation heuristics  much remains done order
understand use effectively 

acknowledgments
part work leading publication carried emil keyder jorg
hoffmann working inria grand est  nancy  france  nicta funded
australian government department communications australian
research council ict centre excellence program  thank university
freiburg allowing us use computional resources 

appendix a  proofs
theorem    h   c   dominates h   c
ce    given planning task set con 
c
 
c
junctions c  h     h  ce    cases inequality strict 
proof  follows fact plan c plan c
ce   yet
cn plan c  
 
inverse case  show first part  let   hac
 
 
 
 
 

n
 
show sequence actions constitutes plan c
ce   showing
cn   c  ac           ac     i        
 
induction c  ac
 
 
 
 
 

denotes
result
ce
n
n ce
 
 
   

fikeyder  hoffmann    haslum

applying sequence actions initial state c c
ce   since goal tasks
defined gc   shows desired result  base case  initial state
c
c c
ce   subset relation holds  inductive case  assume
ci 
c 
c
c
c
c
c
 a            ai     ac
            ai   ce   since precondition ai ce subset
c
c
c c
c

precondition ac
ci   ai applied  a            ai   ce
c

induction hypothesis  need show fluents added ac

ci
c
c c
c
c
added ac
ce applied  a            ai   ce   add effect ai consists
c
union two sets   add a   pre a    del a      add effect ac

ci
c
 
c
 
ce therefore added   c   c ci    since ai applicable  

ci 
 
preconditions  pre a  c  ci  c   add a   c must true c  ac
            ai     therefore
c
 
c  ac
            ai   ce   induction hypothesis  c c  and therefore c ci   ci
c
c
c   ac
ce conditional effect effect c condition  pre a   c   add a     
ci
c
applies condition subset precondition ai   shows
desired property 
strictness  consider planning task fluent set f    p    p    r  g    g     initial
state    p     goal g    g    g     actions
ap    h p      p      r  p     ar   h   r    
ag    h p    r    g       ag    h p    r    g      
let c    c f    c        optimal plan c sequence
har   ag    ap    ar   ag  i  case c follows fact plan must include
ag  ag  actions achieving two goals  therefore must achieve
precondition  fluents  p   r   p   r    respectively   fluents
achieved ar   action achieves either p fluents without deleting
r  single representative ar achieves  p   r   p   r   
representative would precondition  p   p      unreachable  since
action achieving p  deletes p    plan c therefore must contain ag    ag    least two
instances ar   ap   
longer holds  however  considering c
ce   action sequence
hap    ar   ag    ag  plan contains   actions  c
ce   two possible  fluents
added ar    p   r   p   r    treated independently  separate conditional effect
created each  conditions p  p  respectively  p  p 
achieved separately  single application action ar sufficient achieve
two  fluents  without making true  unreachable  cross context  fluent  p   p     
similar cases  exist plans c
ce shorter minimum length plans
c  
given strips task   hf  a  i  g  costi  h  heuristic set p fluents 
defined follows  bonet   geffner        

 
p
 
h  p   
min a padd a   h   pre a     cost a  otherwise
h   p     max h   p 
pp

   

fiimproving delete relaxation heuristics explicit conjunctions

value heuristic given planning task taken h  cost goal
g  h       h   g  
lemma   given planning task c    c p f          c  m   h   c     h   m   
proof  let   hf  a  i  gi  c identical except action sets 
denote action set ac  m   c ac  c    deletes
conditional effects either ac  m   ac  c    ignore
follows 
first show h   c   h   m    h   m   h   c    direction
based following two observations  first  strips planning task 
split actions singleton add effects  without affecting h    precisely  given
action p add a    pre a   denote a p  action pre a p     pre a 
add a p      p   replacing split up actions a p   i  e  generating
split up action a p  every non redundant add effect a   h  remains same  second 
say every split up action a p  action set dominated action a  action set
a    i  e   pre a    pre a p   add a    add a p    h  using a  lower bound
h  using a 
prove h   c   h   m    every c f      c  m 
del a  c     add a  c      ac  m   contains action ac given pre ac    
 pre a   c   add a   c   add ac     add a   c    c  c c   add a  c    let
 
p add ac    p add a   ac c     dominates ac  p   say p   c 
c    pre ac    obtain dominating action ac  c    define 
c       c   c   del a  c       add a  c        c   c   
c   c  c   c   conditions     del a  c     add a  c     
    c c     c c   add a  c        c c     definition  
obviously satisfied 
 
 
thus ac  c   contains action ac given pre ac      pre a  c   c    c     add a   c
 
add ac      add a   pre a    del a   c  c     c   c      prove  a 
 
 
pre ac   pre ac    b  p   c  add ac   
regarding  a   every c   c  

c     add a  c    add a  c   add a   thus c   c    c     add a   c    add a  c   add a  
regarding  b   need prove c  c  del a c      add a c       c  c   
first last properties obvious  second one direct construction 
third one  add a  c       true otherwise would c 
c   add a  implying contradiction construction c  pre ac   
remains prove h   m   h   c    every c   c conditions
 
 
        stated above  ac  c   contains action ac   let p add ac    p
 fluent  either p add a  p pre a    del a   latter case irrelevant  and
 
split up action generated   former case  setting c    add a  get ac  p 
dominated ac ac  m    say p   c   least one following cases
must hold   a  c c    b  c  pre a    del a    c  c  add a   pre a    del a   
c add a       case  a   follows directly definition ac ac  m  
 
 
dominates ac  p   case  b   p   c pre ac   case irrelevant  case  c  
 
c add a     c del a    ac ac  m   dominates ac  p  
concludes proof 
   

fikeyder  hoffmann    haslum

lemma   given planning task set non unit conjunctions c  h   c  
h   c
ce   
c
proof  consider planning task c
no cc identical except
include cross context preconditions  is  precondition action representative
 
ac modified following 

 

pre ac     pre a c

 

 pre a   c    add a   c

c  c  

 
c
 
c
show  a  h   c   h   c
no cc     b  h  no cc   h  ce   

first prove  a   proof lemma    suffices prove that  every split 
c
action ac  p  c
no cc   exists dominating action   p  fluent 
  
 
ac c c      dominates ac  p   otherwise  say p   c    least one
following cases must hold   a  c  c    b  c   add a   pre a    del a     case  b  
  
 
ac c c      dominates ac  p   case  a   obtain dominating action
  
ac c   define
c        c   c   del a  c       add a  c        c   c   
c   c    satisfy conditions     del a  c     add a  c          c c  
  
  c c   add a  c        c c     definition    indeed ac action c  
  
  
obviously c  c    thus p add ac    remains prove pre ac  
 
pre ac  p    so  intuitively  c    corresponds single conjunction c   plus
subsumed conjunctions  hence cross context fluents arise s specifically  every
  
c   c    c    add a  c   add a   thus pre ac      pre a  c   c     c    add a   c  
 
 pre a   c    add a   c   latter obviously contained pre ac  p    concluding
proof  a  
 
c
 
c
remains prove  b   since h   c
no cc   h  no cc    suffices prove h  no cc  
 
c
 
c
h  ce    consider state s  relaxed plan ce ce   action ace
    representing action original task   let c   set conjunctions c whose
ce
  c   c   obviously qualifies
 fluents added ace execution ce
ce

constraint     definition    qualifies constraint     conditional effect
c property triggered ace conditional effect suitable c 
c   a  define action sequence  
triggered  thus c
no cc includes representative
c     adds fluents  
c 
c
ce
no cc sequence   obviously 
precondition union ace conditional effects fire  thus
 
c
 
c
  relaxed plan c
no cc   follows h  no cc   h  ce   desired 

example   consider strips planning task variables  i  p  q  r  z  g    g    g    
initial state    i   goal g    g    g    g     actions follows 
   



fiimproving delete relaxation heuristics explicit conjunctions

name
pre
add del ce cost
aqz
 i 
 q 
z 

 

ari
 i 
 r 

 
pz
 i  q 
 p   z 
 
aiq
apz
 r 
 p 
 z 

 
r
g 
 p  z   g   

 
apz
agiq 
 i  q   g   

 
g 
ar
 r   g   

 
set c     i  q    p  z    operator adding part  i  q  aqz
adds q 
qz
pz pz
operators adding part  p  z  ai adds z  aiq   ar add p 
pz
since aiq
apz
delete z  cannot used establish conjunction  p  z  
r
thus actions c
ce are 
name
pre
add del
ce cost
qz
qz
ai
 i   q  z 
ce ai  
 
ari
 i 
 r 


 
 i 
q 

 
 p 


 
apz
i q
iq
pz
ar
 r 
 p 


 
 p  z  p z    g   


 
agpz 
g 
aiq
 i  q  i q    g   


 
 r   g   


 
agr 
ce aqz
  contains two conditional effects 
name
c
add del
i q
ei
 i   i q  


ep p z
 p   p z  

pz
clearly  respect hmax    fluents preconditions aiq
  agpz    agiq  dominate respective preconditions actions  as pointed section     
implementation actually remove preconditions   thus lm cuts justification
graph c
ce would structure shown figure   
 
c
hmax  c
ce        due cost achieving g    h  ce    construct
qz pz
plan c
ce choice establish p  use ai   aiq  
use ari   apz
r   latter case  make single application conditionalg  g 
r pz qz g 
effects action aqz
  relaxed plan     hai   ar   ai   apz   aiq   ar i  whose cost    
qz
former case  must use ai twice first i q   p z yielding relaxed
pz qz g 
g  r g 
 
c
plan     haqz
  aiq   ai   apz   aiq   ai   ar i  whose cost     thus h  ce         since 
pz
execution     delete ar   true anyhow state
execution    solves original task get h      h   c
ce        
consider lm cut  say produced cut conditional effects action
p z
aqz
connects p p z via conditional effect ep   two options discussed
section      a  reduce cost aqz
globally  sticking original definition


lm cut   b  reduce cost ep p z   conditional effect ei i q
p z
part optimal cost path ep thus serves justify hmax value 
options violates one essential properties lm cut 

   

fikeyder  hoffmann    haslum



z

p



i q
aqz
  ei

aqz




q

aqz


 


ei i q

 

r

arg 

p z

apz
iq


ei i q

i q

apz
r

ari

p z
aqz
  ep

agiq 

agpz 

g 

g 

g 

figure    illustration lm cut justification graphs c
ce example    dashed
edges correspond preconditions critical  hmax  maximizing  start 
become critical point execution lm cut 


p z
 a  configuration  lm cut produces cuts  agpz     cost      aqz
  ep    cost    
pz pz
g 
 cost      ar   aiq    cost      aiq    cost      ari    cost     note that 
i q
p z
qz
qz
cut  aqz
  ep    cost ai reduced   globally  particular  cut  ai   ei  
produced  get heuristic value hlm cut       hmax  c
ce         lm cut
dominate hmax  
 b  configuration  lm cut produce following cuts  start  every
p z
possible precondition choice function  pcf    get cuts  agpz     cost     aqz
  ep  
 cost     hmax   g    g    say pcf selects g    get cut  agiq   
pz
max  
 cost     now  pcf select g    getting cut  apz
r   aiq    cost     then  h
g 
g    g    say pcf selects g    say pcf selects p z apz  another
choice would z   selects i q apz
 another choice would q   thus remaining
iq
i q pz
non dashed part figure    get cut  aqz
  ei   ar    cost   
g  reached   cost p i q  we would get cut pcf
selecting g    point   now  hmax   g    g    g    get cut
 agr     cost     point  hmax   goal facts  say lm cut selects g    thus
get cut  ari    cost    way achieve r  finally hmax
i q
  g  only  yielding cut  aqz
  ei    cost     overall  get heuristic value
hlm cut        h      h   c
ce         lm cut admissible 

 agr   

bibliography
baier  j  a     botea  a          improving planning performance using low conflict relaxed
plans  gerevini  a   howe  a   cesta  a     refanidis  i   eds    proceedings
   

fiimproving delete relaxation heuristics explicit conjunctions

  th international conference automated planning scheduling  icaps    
pp        thessaloniki  greece  aaai press 
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
bonet  b     helmert  m          strengthening landmark heuristics via hitting sets 
coelho  h   studer  r     wooldridge  m   eds    proceedings   th european
conference artificial intelligence  ecai     pp          lisbon  portugal  ios
press 
bonet  b   palacios  h     geffner  h          automatic derivation memoryless policies
finite state controllers using classical planners  gerevini  a   howe  a   cesta 
a     refanidis  i   eds    proceedings   th international conference automated planning scheduling  icaps     pp        thessaloniki  greece  aaai
press 
bylander  t          computational complexity propositional strips planning 
artificial intelligence                  
cai  d   hoffmann  j     helmert  m          enhancing context enhanced additive
heuristic precedence constraints  gerevini  a   howe  a   cesta  a     refanidis  i   eds    proceedings   th international conference automated planning
scheduling  icaps     pp        thessaloniki  greece  aaai press 
do  m  b     kambhampati  s          sapa  domain independent heuristic metric temporal planner  cesta  a     borrajo  d   eds    recent advances ai planning   th
european conference planning  ecp     lecture notes artificial intelligence 
pp          toledo  spain  springer verlag 
fox  m     long  d          stan   hybrid planning strategy based subproblem
abstraction  ai magazine               
garey  m  r     johnson  d  s          computers intractabilitya guide
theory np completeness  freeman  san francisco  ca 
gazen  b  c     knoblock  c          combining expressiveness ucpop
efficiency graphplan  steel  s     alami  r   eds    recent advances ai
planning   th european conference planning  ecp     lecture notes artificial
intelligence  pp          toulouse  france  springer verlag 
gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs  journal artificial intelligence research             
haslum  p     geffner  h          admissible heuristics optimal planning  chien  s  
kambhampati  r     knoblock  c   eds    proceedings  th international conference artificial intelligence planning systems  aips     pp          breckenridge  co  aaai press 
haslum  p          hm  p     h   p    alternative characterisations generalisation
hmax hm   gerevini  a   howe  a   cesta  a     refanidis  i   eds    proceedings   th international conference automated planning scheduling
 icaps     pp          thessaloniki  greece  aaai press 
   

fikeyder  hoffmann    haslum

haslum  p          incremental lower bounds additive cost planning problems 
bonet  b   mccluskey  l   silva  j  r     williams  b   eds    proceedings   nd
international conference automated planning scheduling  icaps     pp 
      sao paulo  brasil  aaai press 
helmert  m          fast downward planning system  journal artificial intelligence
research             
helmert  m     domshlak  c          landmarks  critical paths abstractions  whats
difference anyway   gerevini  a   howe  a   cesta  a     refanidis  i   eds   
proceedings   th international conference automated planning scheduling  icaps     pp          thessaloniki  greece  aaai press 
helmert  m     geffner  h          unifying causal graph additive heuristics 
rintanen  j   nebel  b   beck  j  c     hansen  e   eds    proceedings   th
international conference automated planning scheduling  icaps     pp 
        sydney  australia  aaai press 
hoffmann  j          ignoring delete lists works  local search topology planning
benchmarks  journal artificial intelligence research             
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research             
hoffmann  j   porteous  j     sebastia  l          ordered landmarks planning  journal
artificial intelligence research             
hoffmann  j   steinmetz  m     haslum  p          take render h    c  
perfect   proceedings  th workshop heuristics search domain
independent planning  icaps   
karpas  e     domshlak  c          cost optimal planning landmarks  boutilier  c 
 ed    proceedings   st international joint conference artificial intelligence
 ijcai     pp            pasadena  california  usa  morgan kaufmann 
katz  m   hoffmann  j     domshlak  c          said need relax variables  
borrajo  d   fratini  s   kambhampati  s     oddi  a   eds    proceedings
  rd international conference automated planning scheduling  icaps    
pp          rome  italy  aaai press 
keyder  e     geffner  h          heuristics planning action costs revisited 
ghallab  m   ed    proceedings   th european conference artificial intelligence  ecai     pp          patras  greece  wiley 
keyder  e     geffner  h          trees shortest paths vs  steiner trees  understanding
improving delete relaxation heuristics  boutilier  c   ed    proceedings
  st international joint conference artificial intelligence  ijcai     pp      
      pasadena  california  usa  morgan kaufmann 
keyder  e   hoffmann  j     haslum  p          semi relaxed plan heuristics  bonet  b  
mccluskey  l   silva  j  r     williams  b   eds    proceedings   nd international conference automated planning scheduling  icaps     pp         
sao paulo  brasil  aaai press 
   

fiimproving delete relaxation heuristics explicit conjunctions

keyder  e   richter  s     helmert  m          sound complete landmarks and or
graphs  coelho  h   studer  r     wooldridge  m   eds    proceedings   th
european conference artificial intelligence  ecai     pp          lisbon  portugal  ios press 
palacios  h     geffner  h          compiling uncertainty away conformant planning
problems bounded width  journal artificial intelligence research         
    
richter  s     westphal  m          lama planner  guiding cost based anytime
planning landmarks  journal artificial intelligence research             
roger  g   pommerening  f     helmert  m          optimal planning presence
conditional effects  extending lm cut context splitting  schaub  t   ed   
proceedings   st european conference artificial intelligence  ecai    
prague  czech republic  ios press  appear 

   


