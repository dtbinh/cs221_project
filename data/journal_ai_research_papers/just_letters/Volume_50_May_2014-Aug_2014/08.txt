journal of artificial intelligence research                  

submitted        published      

mdd propagation for sequence constraints
david bergman

david bergman business uconn edu

school of business  university of connecticut
     hillside road  unit       storrs  ct      

andre a  cire
willem jan van hoeve

acire andrew cmu edu
vanhoeve andrew cmu edu

tepper school of business  carnegie mellon university
     forbes avenue  pittsburgh  pa       usa

abstract
we study propagation for the sequence constraint in the context of constraint programming based on limited width mdds  our first contribution is proving that establishing
mdd consistency for sequence is np hard  yet  we also show that this task is fixed parameter tractable with respect to the length of the sub sequences  in addition  we propose
a partial filtering algorithm that relies on a specific decomposition of the constraint and a
novel extension of mdd filtering to node domains  we experimentally evaluate the performance of our proposed filtering algorithm  and demonstrate that the strength of the
mdd propagation increases as the maximum width is increased  in particular  mdd propagation can outperform conventional domain propagation for sequence by reducing the
search tree size and solving time by several orders of magnitude  similar improvements are
observed with respect to the current best mdd approach that applies the decomposition
of sequence into among constraints 

   introduction
the central inference process of constraint programming is constraint propagation  rossi 
van beek    walsh        dechter        apt         while traditional constraint processing
techniques were designed for explicitly defined relations of small arity  state of the art constraint programming solvers apply specialized constraint propagation algorithms for global
constraints of any arity  often based on efficient combinatorial methods such as network
flows  van hoeve   katriel        regin        
conventional constraint propagation algorithms  or domain filtering algorithms  operate on individual constraints of a given problem  their role is to identify and remove
values in the variable domains that are inconsistent with respect to the constraint under
consideration  whenever the domain of a variable is updated  i e   a value is removed  
the constraints in which this variable appears can be reconsidered for inspection  this
cascading process of propagating the changes in variable domains through the constraints
continues until a fixed point is reached  most constraint programming solvers assume that
the variable domains are finite  which ensures termination of the constraint propagation
process  note that constraint propagation in itself may not be sufficient to determine the
resolution of a given problem  therefore  constraint propagation is normally applied at each
search state in a systematic search process 
c
    
ai access foundation  all rights reserved 

fibergman  cire   van hoeve

a major benefit of propagating variable domains is that it can be implemented efficiently
in many cases  however  an inherent weakness of domain propagation is that it implicitly
represents the cartesian product of the variable domains as potential solution space  by
communicating only domain changes  this limits the amount of information shared between
constraints 
to address this shortcoming of domain propagation  andersen  hadzic  hooker  and
tiedemann        proposed the use of multi valued decision diagrams  mdds  as an alternative to variable domains in the context of constraint propagation  mdds are directed
acyclic layered graphs that can  in principle  compactly represent all solutions to a combinatorial problem  wegener         andersen et al         showed that mdds of limited
width can provide a much stronger relaxation of the solution space than the traditional
cartesian product of the variable domains  and as a consequence mdds allow to represent
and communicate more refined information between constraints  by propagating mdds
rather than variable domains  huge reductions in search tree size and computation time
can be realized  andersen et al         hadzic  hooker  osullivan    tiedemann      a 
hadzic  hooker    tiedemann      b  hadzic  omahony  osullivan    sellmann       
hoda  van hoeve    hooker        cire   van hoeve              
mdds can be used to represent individual  global  constraints  subsets of constraints 
or all constraints in a given problem  when representing individual constraints  as in the
work of hawkins  lagoon  and stuckey        and cheng and yap         the higher level
information carried by the mdd is lost when projecting this down to the variable domains
for the traditional domain propagation  the highest potential for mdd propagation instead
appears to be in representing specific subsets of constraints within the same mdd  that is 
for a given set of constraints  we create and maintain one single limited width mdd  which
is then propagated through this constraint set  since an mdd is defined with respect to a
fixed variable ordering  it is most useful to select a subset of constraints compatible with this
ordering  when applied in this way  mdd propagation can be implemented in parallel to the
existing domain propagation in constraint programming systems  thus complementing and
potentially strengthening the domain propagation process  for example  cire and van hoeve
       introduced mdd propagation for a subset of constraints representing disjunctive
scheduling problems  they embedded this as a custom global constraint in the ilog cp
optimizer constraint programming solver  which greatly improved the performance 
    methodology
constraint propagation based on limited width mdds amounts to mdd filtering and mdd
refinement  the role of an mdd filtering algorithm is to remove provably inconsistent arcs
from the mdd  hadzic et al       b  hoda et al          an mdd refinement algorithm on
the other hand  aims at splitting nodes in the mdd to more accurately reflect the solution
space  hadzic et al       a   in order to make this approach scalable and efficient  refinement
algorithms must ensure that the mdd remains within a given maximum size  typically by
restricting its maximum widththe number of nodes on any layer   by increasing this
maximum width  the mdd relaxation can be strengthened to any desired level  that
is  a maximum width of   would correspond to the traditional cartesian product of the
variable domains  while an infinite maximum width would correspond to an exact mdd
   

fimdd propagation for sequence constraints

representing all solutions  however  increasing the size of the mdd immediately impacts
the computation time  and one typically needs to balance the trade off between the strength
of the mdd and the associated computation time 
in order to characterize the outcome of an mdd filtering algorithm  the notion of mdd
consistency was introduced by andersen et al          similar to domain consistency in
finite domain constraint programming  given an mdd  a constraint is mdd consistent if
all arcs in the mdd belong to at least one solution to the constraint  as a consequence
of the richer data structure that an mdd represents  establishing mdd consistency may
be more difficult than establishing domain consistency  for example  andersen et al  show
that establishing mdd consistency on the alldifferent constraint is np hard  while
establishing traditional domain consistency can be done in polynomial time  regin        
    contributions
the main focus of this paper is the sequence constraint  that is defined as a specific conjunction of among constraints  where an among constraint restricts the occurrence of a
set of values for a sequence of variables to be within a lower and upper bound  beldiceanu
  contejean         the sequence constraint finds applications in  e g   car sequencing
and employee scheduling problems  regin   puget        van hoeve  pesant  rousseau   
sabharwal         it is known that classical domain consistency can be established for sequence in polynomial time  van hoeve  pesant  rousseau    sabharwal        van hoeve
et al         brand  narodytska  quimper  stuckey    walsh        maher  narodytska 
quimper    walsh        downing  feydy    stuckey         furthermore  hoda et al 
       present an mdd filtering algorithm for among constraints establishing mdd consistency in polynomial time  however  it remained an open question whether or not mdd
consistency for sequence can be established in polynomial time as well 
in this work  we answer that question negatively and our first contribution is showing
that establishing mdd consistency on the sequence constraint is np hard  this is an
important result from the perspective of mdd based constraint programming  namely  of
all global constraints  the sequence constraint has perhaps the most suitable combinatorial
structure for an mdd approach  it has a prescribed variable ordering  it combines subconstraints on contiguous variables  and existing approaches can handle this constraint
fully by using bounds reasoning only 
as our second contribution  we show that establishing mdd consistency on the sequence constraint is fixed parameter tractable with respect to the lengths of the subsequences  the among constraints   provided that the mdd follows the order of the sequence constraint  the proof is constructive  and follows from a generic algorithm to filter
one mdd with another 
the third contribution is a partial mdd propagation algorithm for sequence  that does
not necessarily establish mdd consistency  it relies on the decomposition of sequence
into cumulative sums  and a new extension of mdd filtering to the information that is
stored at its nodes 
our last contribution is an experimental evaluation of our proposed partial mdd propagation algorithm  we evaluate the strength of our algorithm for mdds of various maximum
widths  and compare the performance with existing domain propagators for sequence  we
   

fibergman  cire   van hoeve

also compare our algorithm with the currently best known mdd approach that uses the
natural decomposition of sequence into among constraints  hoda et al          our
experiments demonstrate that mdd propagation can outperform domain propagation for
sequence by reducing the search tree size  and solving time  by several orders of magnitude  similar results are observed with respect to mdd propagation of among constraints 
our results thus provide further evidence for the power of mdd propagation in the context
of constraint programming 
the remainder of this paper is structured as follows  in section    we provide the necessary definitions of mdd based constraint programming and the sequence constraint  in
section    we present the proof that establishing mdd consistency on sequence is nphard  section   describes that establishing mdd consistency is fixed parameter tractable 
in section    the partial mdd filtering algorithm is presented  section   shows the experimental results  we present final conclusions in section   

   definitions
we first recall some basic definitions of mdd based constraint programming  following the
work of andersen et al         and hoda et al          in this work  an ordered multivalued
decision diagram  mdd  is a directed acyclic graph whose nodes are partitioned into n    
 possibly empty  subsets or layers l            ln     where the layers l            ln correspond
respectively to variables x            xn   l  contains a single root node r  and ln   contains
a single terminal node t  for a node u in the mdd  we let l  u  denote the index of its
layer  for an mdd m   the width w m   is the maximum number of nodes in a layer  or
maxni     li     in mdd based cp  the mdds typically have a given fixed maximum width 
all arcs of the mdd are directed from an upper to a lower layer  that is  from a node
in some li to a node in some lj with i   j  for our purposes it is convenient to assume
 without loss of generality  that each arc connects two adjacent layers  each arc out of
layer li is labeled with an element of the domain d xi   of xi   for an arc a  we refer to
the label it represents as   a   for notational convenience  we also write   u  v  instead of
   u  v   for an arc  u  v   an element in d xi   appears at most once as a label on the
arcs out of a given node u  li   the set a u  v  of arcs from node u to node v may
contain multiple arcs  and we denote each with its label  let ain  u  denote the set of arcs
comingfi into node u  we define the size of anfi mdd m by the number of its arcs  i e  
 m     fi a   a  ain  u   u  li   i              n     fi 
an arc with label v leaving a node in layer i represents an assignment xi   v  each
path in the mdd from r to t can be denoted by the arc labels v            vn on the path and
is identified with the solution  x            xn      v            vn    a path v            vn is feasible for a
given constraint c if setting  x            xn      v            vn   satisfies c  constraint c is feasible
on an mdd if the mdd contains a feasible path for c 
a constraint c is called mdd consistent on a given mdd if every arc of the mdd
lies on some feasible path  thus mdd consistency is achieved when all redundant arcs
 i e   arcs on no feasible path  have been removed  we also say that such mdd is mdd
consistent with respect to c  domain consistency for c is equivalent to mdd consistency
on an mdd of width one that represents the variable domains  that is  it is equivalent
   

fimdd propagation for sequence constraints

to mdd consistency on an mdd in which each layer li contains a single node si   and
a si   si       d xi   for i              n 
lastly  we formally recall the definitions of among  beldiceanu   contejean        
sequence  beldiceanu   contejean         and gen sequence  van hoeve et al        
constraints  the among constraint counts the number of variables that are assigned to a
value in a given set s  and ensures that this number is between a given lower and upper
bound 
definition   let x be a set of variables  l  u integer numbers such that    l  u   x  
and s  xx d x  a subset of domain values  then we define among x  l  u  s  as
x
l
 x  s   u 
xx

note that the expression  x  s  is evaluated as a binary value  i e   resulting in   if x  s
and   if x 
  s  the sequence constraint is the conjunction of a given among constraint
applied to every sub sequence of length q over a sequence of n variables 
definition   let x be an ordered set of n variables  q  l  u integer numbers such that
   q  n     l  u  q  and s  xx d x  a subset of domain values  then
sequence x  q  l  u  s   

nq  
 

among si   l  u  s  

i  

where si represents the sub sequence xi           xi q   
finally  the generalized sequence constraint extends the sequence constraint by allowing
the among constraints to be specified with different lower and upper bounds  and subsequence length 
definition   let x be an ordered set of n variables  k a natural number   s   l   u vectors of
length k such that si is a sub sequence of x  li   ui  n     li  ui  n for i                 k 
and s  xx d x  a subset of domain values  then
gen sequence x   s   l   u  s   

k
 

among si   li   ui   s  

i  

   mdd consistency for sequence is np hard
as stated before  the only known non trivial np hardness result for a global constraint in
the context of mdd based constraint programming is that of andersen et al         for
the alldifferent constraint  a challenge in determining whether a global constraint
can be made mdd consistent in polynomial time is that this must be guaranteed for any
given mdd  that is  in addition to the combinatorics of the global constraint itself  the
shape of the mdd adds another layer of complexity to establishing mdd consistency  for
proving np hardness  a particular difficulty is making sure that in the reduction  the mdd
remains of polynomial size  for sequence constraints  so far it was unknown whether a
polynomial time mdd consistency algorithm exists  in this section we answer that question
negatively and prove the following result 
   

fibergman  cire   van hoeve

theorem   establishing mdd consistency for sequence on an arbitrary mdd is nphard even if the mdd follows the variable ordering of the sequence constraint 
proof  the proof is by reduction from   sat  a classical np complete problem  garey
  johnson         we will show that an instance of   sat is satisfied if and only if a
particular sequence constraint on a particular mdd m of polynomial size has a solution 
therefore  establishing mdd consistency for sequence on an arbitrary mdd is at least
as hard as   sat 
consider a   sat instance on n variables x            xn   consisting of m clauses c            cm  
we first construct an mdd that represents the basic structure of the   sat formula  see
example   after this proof for an illustration   we introduce binary variables yi j and y i j
representing the literals xj and xj per clause ci   for i              m and j              n  xj and xj
may or may not exist in ci    we order these variables as a sequence y   first by the index of
the clauses  then by the index of the variables  and then by yi j   y i j for clause ci and variable
xj   that is  we have y   y      y       y      y             y  n   y   n           ym     y m            ym n   y m n   we
construct an mdd m as a layered graph  where the k th layer corresponds to the k th
variable in the sequence y  
a clause ci is represented by  n consecutive layers corresponding to yi             y i n   in
such part of the mdd  we identify precisely those paths that lead to a solution satisfying
the clause  the basis for this is a diamond structure for each pair of literals  yi j   y i j   
that assigns either        or        to this pair  if a variable does not appear in a clause  we
represent it using such a diamond in the part of the mdd representing that clause  thus
ensuring that the variable can take any assignment with respect to this clause  for the
variables that do appear in the clause  we will explicitly list out all allowed combinations 
more precisely  for clause ci   we first define a local root node ri representing layer l  yi     
and we set tag ri     unsat  for each node u in layer l  yi j    for j              n   we do the
following  if variable xj does not appear in ci   or if tag u  is sat  we create two nodes v  v  
in l y i j   one single node w in l  yi j      and arcs  u  v  with label     u  v     with label   
 v  w  with label    and  v     w  with label    this corresponds to the diamond structure 
we set tag w    tag u   otherwise  i e   tag u  is unsat and yi j appears in ci    we create
two nodes v  v   in l y i j   two nodes w  w  in l  yi j      and arcs  u  v  with label     u  v    
with label     v  w  with label    and  v     w    with label    if ci contains as literal yi j   we set
tag w    sat and tag w      unsat  otherwise  ci contains y i j    we set tag w    unsat
and tag w      sat 
this procedure will be initialized by a single root node r representing l  y      we
iteratively append the mdds of two consecutive clauses ci and ci   by merging the nodes
in the last layer of ci that are marked sat into a single node  and let this node be the
local root for ci     we finalize the procedure by merging all nodes in the last layer that
are marked sat into the single terminal node t  by construction  we ensure that only one
of yij and y ij can be set to    furthermore  the variable assignment corresponding to each
path between layers l  yi     and l  yi       will satisfy clause ci   and exactly n literals are
chosen accordingly on each such path 
we next need to ensure that for a feasible path in the mdd  each variable xj will
correspond to the same literal yi j or y i j in each clause ci   to this end  we impose the
   

fimdd propagation for sequence constraints

r
c 

  
  

y   

y   
y   
y   
y   
y   
y   
y   
c 

y   

y   
y   
y   
y   
y   
y   
y   
t

figure    the mdd corresponding to example   
constraint
sequence y  q    n  l   n  u   n  s       

   

on the mdd m described above  if the sub sequence of length  n starts from a positive
literal yi j   by definition there are exactly n variables that take value    if the sub sequence
starts from a negative literal y i j instead  the last variable in the sequence corresponds to
the value xj in the next clause ci     i e   yi   j   observe that all variables except for the
first and the last in this sequence will take value   already n    times  therefore  of the
first and the last variable in the sequence  which represent xj and its complement xj in any
order   only one can take the value    that is  xj must take the same value in clause ci and
ci     since this holds for all sub sequences  all variables xj must take the same value in all
clauses 
the mdd m contains  mn     layers  while each layer contains at most six nodes 
therefore  it is of polynomial size  in the size of the   sat instance   and the overall construction needs polynomial time 

   

fibergman  cire   van hoeve

  
  

x 
 

 

x 
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

x 

x 

x 

x 

figure    the exact mdd for the sequence constraint of example   

example   consider the   sat instance on four boolean variables x    x    x    x  with clauses
c     x   x   x    and c     x   x   x     the corresponding mdd used in the reduction
is given in figure   

   mdd consistency for sequence is fixed parameter tractable
in this section we show that establishing mdd consistency for sequence on an arbitrary
mdd is fixed parameter tractable  with respect to the length of the sub sequences q  it
was already shown by van hoeve et al               that an exact mdd for the sequence
constraint exists with o n q   nodes  i e   the unfolded automaton of the regular constraint   as illustrated in the next example 
example   consider the constraint sequence x  q      l      u      s        where
x    x    x            x    is an ordered set of binary variables  the corresponding exact mdd 
following the order of x  is presented in figure    for convenience  each node in the mdd
is labeled with the last q    labels that represent the sub sequence up to that node  starting
q    layers up   for example  the second node in the third layer represents decisions x     
and x       corresponding to sub sequence     to construct the next layer  we either append
a   or a   to this sub sequence  and remove the first symbol   leading to nodes labeled    and
    respectively  note that from nodes labeled    we must take an arc with label    because
l      similarly for nodes labeled    we must take an arc with label    because u      after q
   

fimdd propagation for sequence constraints

layers  all possible sub sequences have been created  maximally o  q      which thus defines
the width of the subsequent layers 
however  since we are given an arbitrary mdd  and not necessarily an exact mdd  we need
some additional steps to exploit this connection  for this we apply a generic approach that
will not only show fixed parameter tractability for sequence  but in fact can be applied
to determine whether mdd consistency is tractable for any constraint 
our goal is to establish mdd consistency on a given mdd m with respect to another
mdd m   on the same set of variables  this is compatible with our earlier definitions since
m   can be interpreted to define a constraint  that is  m is mdd consistent with respect to
m   if every arc in m belongs to a path  solution  that also exists in m     for our purposes 
we assume that m and m   follow the same variable ordering 
we can establish mdd consistency by first taking the intersection of m and m     and
then removing all arcs from m that are not compatible with the intersection  computing the
intersection of two mdds is well studied  and we present a top down intersection algorithm
that follows our definitions in algorithm    this description is adapted from the melding
procedure presented by knuth        
the intersection mdd  denoted by i  represents all possible paths  solutions  that are
present both in m and m     each partial path in i from the root ri to a node u thus
will exist in m and m     with respective endpoints v  v     this information is captured by
associating with each node u in i a state s u     v  v     representing those nodes v  m
and v    m     the root of i is initialized as ri with s ri       r  r    where r and r  are the
respective roots of m and m    lines       the algorithm then  in a top down traversal 
considers a layer lii in i  and augments a node u  lii with s u     v  v     with an arc
only if both m and m   have an arc with the same label out of v and v   respectively  lines
      if the next layer already contains a node u with the same state we re use that node 
otherwise we add a new node u to lii   and add the arc  u  u  to i  note that the last layer
of i contains a single terminal ti with state s ti      t  t     provided that i is not empty  in
the last step  line     we clean up i by removing all arcs and nodes that do not belong to a
feasible path  this can be done in a bottom up traversal of i  observe that this algorithm
does not necessarily create a reduced mdd 
algorithm   presents an algorithm to establish mdd consistency on m with respect to
 
m   we first compute the intersection i of m and m    line     we then traverse m in a
top down traversal  and for each layer lm
i we identify and remove infeasible arcs  for this 
we define a boolean array support u  l   initialized to    that represents whether an arc out
of node u  m with label l has support in i  line     in line    we consider all arcs out
of layer lii in i  if an arc a    v  v  exists in lii with label l and s v     u  u     we mark
the associated arc out of u as supported by setting support u  l        lines       we then
remove all arcs out of lm
i that have no support  lines       lastly  we again clean up m
by removing all arcs and nodes that do not belong to a feasible path  line     
theorem   algorithm   establishes mdd consistency on m with respect to m   in o  m   
w m     time and space 
proof  the correctness of algorithm   follows by induction on the number of layers  to
prove that algorithm   establishes mdd consistency  consider an arc a    u  u  in m after
   

fibergman  cire   van hoeve

algorithm   intersection m  m    
input  mdd m with root r  mdd m   with root r    m and m   are defined on the same
ordered sequence of n variables 
output  mdd i with layers li            lin   and arc set ai   each node u in i has an
associated state s u  
   create node r i with state s r i       r  r    
   li      r i  
   for i     to n do
  
lii        
  
for all u  lii with s u     v  v     do
  
for all a    v  v   m and a     v     v      m   such that   a      a    do
  
create node u with state s u      v  v    
  
if  w  lij   with s w    s u  then u    w
  
else lii      u end if
   
add arc  u  u  with label   a  to arc set ai
   
end for
   
end for
    end for
    remove all arcs and nodes from i that are not on a path from r i to ti  lin  
    return i

algorithm   mdd consistency m  m    
input  mdd m with root r  mdd m   with root r    m and m   are defined on the same
ordered sequence of n variables 
output  m that is mdd consistent with respect to m  
   create i    intersection m  m    
   for i     to n do
  
create array support u  l       for all u  lm
i and arcs out of u with label l
  
for all arcs a    v  v  in ai with s v     u  u    such that v  lii do
  
support u    a       
  
end for
  
for all arcs a    u  u  in m such that u  lm
i do
  
if support u    a       then remove a from m end if
  
end for
    end for
    remove all arcs and nodes from m that are not on a path from r to t  lm
n  
    return m

   

fimdd propagation for sequence constraints

applying the algorithm  there exists a node v  i with s v     u  u    such that solutions
represented by the paths from r to u in m and from r  to u  in m   are equivalent  there
also exists an arc ai    v  v   ai with the same label as a  consider s v     w  w     since
m and i are decision diagrams  a label appears at most once on an arc out of a node 
therefore  w   u  since ai belongs to i  there exist paths from w  or u  to t in m and
from w  to t  in m   that are equivalent  hence  a belongs to a feasible path in m  from r
to u  then along a into u and terminating in t  for which an equivalent path exists in m  
 from r  to u    then into w  and terminating in t    
regarding the time complexity for computing the intersection  a coarse upper bound
multiplies n  line     w m    w m      line     and d max  line     where dmax represents the
maximum degree out of a node  or maxxx  d x    we can amortize these steps since the forloops in lines   and   consider each arc in m once for comparison with arcs in m     each arc
is compared with at most w m     arcs  line     here we assume that we can check in constant
time whether a node has an outgoing arc with a given label  using an arc label list   this
gives a total time complexity of o  m    w m       the memory requirements are bounded by
the size of the intersection  which is at most o n  w m    w m      dmax     o  m    w m      
this dominates the complexity of algorithm    since lines      can be performed in linear
time and space  in the size of m   

observe that algorithm   no longer ensures that each solution in m is represented by
some path in m     as is the case for the intersection  mdd consistency merely establishes
that each arc in m belongs to some solution that is also in m     although mdd intersections
are stronger than mdd consistency  their limitation is that the width of the intersection
mdd may be as large as the product of the widths of m and m     therefore intersecting m
with multiple mdds will  in general  increase the size of the resulting mdd exponentially 
we next apply theorem   to the sequence constraint 
corollary   let x be an ordered sequence of variables  c   sequence x  q  l  u  s  a
sequence constraint  and m an arbitrary mdd following the variable ordering of x  establishing mdd consistency for c on m is fixed parameter tractable with respect to parameter q 
proof  we know that there exists an exact mdd m   of size o n q    that represents c
 van hoeve et al                applying theorem   gives an mdd consistency algorithm
with time and space complexity o  m    q     and the result follows 

we note that theorem   can also be applied to obtain the tractability of establishing
mdd consistency on other constraints  consider for example the constraint among x    x   
        xn   l  u  s   for any variable ordering  we can construct an exact mdd in a top down
procedure by associating with each node v the number of variables taking a value in s along
the path from r to v  representing the length of that path  nodes with the same length are
equivalent and can be merged  because the largest layer has at most u     different path
lengths  the exact mdd has size o nu   and by theorem   establishing mdd consistency
is tractable for among  indeed  hoda et al         also showed that mdd consistency can
be established for this constraint  with quadratic time complexity 
   

fibergman  cire   van hoeve

the converse of theorem   does not hold  there exist constraints for which mdd
consistency can be established in polynomial time on any given mdd  while a minimal
reduced exact mdd hasp
exponential size  as a specific example  consider linear inequality
constraints of the form ni   ai xi  b where xi is an integer variable  ai is a constant  for
i              n  and b is a constant  mdd consistency can be established for such constraints in
linear time  for any given mdd  by computing for each arc the longest r t path  relative to
the coefficients ai   that uses that arc  andersen et al          however  hosaka  takenaga 
kaneda  and yajima       
provide the following explicit linear inequality  for k even
p
and n   k     consider  i jk aij xij  k   k        where xij is a binary variable  and
aij    i     k j    for    i  j  k  they show that  for any variable order 
the size of the

n  
reduced ordered bdd for this inequality is bounded from below by   
  

   partial mdd filtering for sequence
in many practical situations the value of q will lead to prohibitively large exact mdds for
establishing mdd consistency  which limits the applicability of corollary    therefore we
next explore a more practical partial filtering algorithm that is polynomial also in q 
one immediate approach is to propagate the sequence constraint in mdds through
its natural decomposition into among constraints  and apply the mdd filtering algorithms
for among proposed by hoda et al          however  it is well known that for classical
constraint propagation based on variable domains  the among decomposition can be substantially improved by a dedicated domain filtering algorithm for sequence  van hoeve
et al               brand et al         maher et al          therefore  our goal in this section is to provide mdd filtering for sequence that can be stronger in practice than mdd
filtering for the among decomposition  and stronger than domain filtering for sequence 
in what follows  we assume that the mdd at hand respects the ordering of the variables in
the sequence constraint 
    cumulative sums encoding
our proposed algorithm extends the original domain consistency filtering algorithm for
sequence by van hoeve et al         to mdds  following the cumulative sums encoding as proposed by brand et al          this representation takes the following form 
for a sequence of variables x   x    x            xn   and a constraint sequence x  q  l  u  s  
we first introduce variables y    y            yn   with respective initial domains d yi         i 
for
pi i              n  these variables represent the cumulative sums of x  i e   yi represents
j    xj  s  for i              n  we now rewrite the sequence constraint as the following
system of constraints 
i              n  

   

yi q  yi  l

i              n  q  

   

yi q  yi  u

i              n  q  

   

yi   yi    s  xi  

where s   x         is the indicator function for the set s  i e   s  x      if x  s and
s  x      if x 
  s  brand et al  show that establishing singleton bounds consistency on
this system suffices to establish domain consistency for the original sequence constraint 
   

fimdd propagation for sequence constraints

in order to apply similar reasoning in the context of mdds  the crucial observation is
that the domains of the variables y            yn can be naturally represented at the nodes of the
mdd  in other words  a node v in layer li represents the domain of yi    restricted to the
solution space formed by all r t paths containing v  let us denote this information for each
node v explicitly as the interval  lb v   ub v    and we will refer to it as the node domain of
v  following the approach of hoda et al          we can compute this information in linear
time by one top down pass  by using equation      as follows 
lb v    min u v ain  v   lb u    s    u  v     
ub v    max u v ain  v   ub u    s    u  v     

   

for all nodes v    r  while  lb r   ub r            
as the individual among constraints are now posted as yi q  yi  l and yi q  yi  u 
we also need to compute for a node v in layer li   all its ancestors from layer li   this can
be done by maintaining a vector av of length q     for each node v  where av  i  represents
the set of ancestor nodes of v at the i th layer above v  for i              q  we initialize
ar     r                and apply the recursion
av  i     u v ain  v  au  i    

for i                 q 

av        v  
the resulting top down pass itself takes linear time  in the size of the mdd   while a direct
implementation of the recursive step for each node takes o q   w m       operations for an
mdd m   now  the relevant ancestor nodes for a node v in layer li q are stored in av  q  
a subset of layer li   we similarly compute all descendant nodes of v in a vector dv of
length q      such that dv  i  contains all descendants of v in the i th layer below v  for
i                 q  we initialize dt     t               
however  for our purposes we only need to maintain the minimum and maximum value
of the union of the domains of av   resp   dv   because constraints     and     are inequalities 
see the application of av and dv in rules     below  this makes the recursive step more
efficient  now taking o qw m    operations per node 
alternatively  we can approximate this information by only maintaining a minimum
and maximum node domain value for each layer  instead of a list of ancestor layers  this
will compromise the filtering  but may be more efficient in practice  as it only requires to
maintain two integers per layer 
    processing the constraints
we next process each of the constraints           and     in turn to remove provably inconsistent arcs  while at the same time we filter the node information 
starting with the ternary constraints of type      we remove an arc  u  v  if lb u   
s    u  v     ub v   updating  lb v   ub v   for a node v is done similar to the rules    
above 

 
lb v    max lb v   min u v ain  v   lb u    s    u  v     
   

 
ub v    min ub v   min u v ain  v   ub u    s    u  v     
   

fibergman  cire   van hoeve

  
  

y 

    

     

x 

x 
     

     

     

y 

     

x 

x 
     

     

     

     

     

     

y 
x 

x 
     

     

     

     

     

     

y 
x 

x 
     

     

     

     

     

     

y 
x 

x 
     

     

a  initial mdd

b  node domains

y 

c  mdd after filtering

figure    mdd propagation for the constraint sequence x  q      l      u      s       
of example   

in fact  the resulting algorithm is a special case of the mdd consistency equality propagator of hadzic et al       a   and we thus inherit the mdd consistency for our ternary
constraints 
next  we process the constraints     and     for a node v in layer li    i              n  
recall that the relevant ancestors from li  q are av  q   while its relevant descendants
from li   q are dv  q   the variable corresponding to node v is yi   and it participates in
four constraints 
yi  l   yiq  
yi  u   yiq  
   
yi  yi q  l 
yi  yi q  u 
observe that we can apply these constraints to filter only the node domain  lb v   ub v  
corresponding to yi   namely  the node domains corresponding to the other variables yiq
and yi q may find support from nodes in layer li   other than v  we update lb v  and
ub v  according to equations     
lb v    max  lb v  

l   min lb u  
uav  q 

ub v    min  ub v   u   max ub u  
uav  q 

min lb w   u   
wdv  q 

max ub w   l   

   

wdv  q 

the resulting algorithm is a specific instance of the generic mdd consistent binary
constraint propagator presented by hoda et al          and again we inherit the mdd
consistency for these constraints  we can process the constraints in linear time  in the size
of the mdd  by a top down and bottom up pass through the mdd 
   

fimdd propagation for sequence constraints

example   consider the constraint sequence x  q      l      u      s        with the
ordered sequence of binary variables x    x    x    x    x    x     assume we are given the
mdd in figure   a  in figure   b  we show the node domains that result from processing
rules      figure   c  shows the resulting mdd after processing the constraints via the
rules     and      for example  consider the middle node in the fourth layer  corresponding
to variable y    let this node be v  it has initial domain         and av  q  only contains the
root node  which has domain         since l      we can reduce the domain of v to         we
can next consider the arcs into v  and conclude that value   in its domain is not supported 
this further reduces the domain of v to         and allows us to eliminate one incoming arc
 from the first node of the previous layer  
the resulting mdd in figure   c  reflects all possible deductions that can be made by
our partial algorithm  we have not established mdd consistency however  as witnessed by
the infeasible path                 
observe that our proposed algorithm can be applied immediately to the more general
gen sequence constraints in which each among constraint has its individual l  u and q 
the cumulative sums encoding can be adjusted in a straightforward manner to represent
these different values 
    formal analysis
we next formally compare the outcome of our partial mdd filtering algorithm with mdd
propagation for the among encoding and domain propagation for sequence  first  we
recall the following theorem 
theorem    brand et al         thm     bounds consistency on the cumulative sums
encoding is incomparable to bounds consistency on the among encoding of sequence 
note that since all variable domains in the among and cumulative sums encoding are
ranges  intervals of integer values   bounds consistency is equivalent to domain consistency 
corollary   mdd consistency on the cumulative sums encoding is incomparable to mdd
consistency on the among encoding of sequence 
proof  we apply the examples from the proof of theorem   in the work of brand et al  
consider the constraint sequence x  q      l      u      s        with the ordered
sequence of binary variables x    x    x    x    x    having domains d xi            for i  
         and d x           we apply the trivial mdd of width   representing the cartesian
product of the variable domains  establishing mdd consistency on the cumulative sums
encoding yields
y           y           y           y           y          
x           x           x        x          
establishing mdd consistency on the among encoding  however  yields
x           x        x        x       
   

fibergman  cire   van hoeve

consider the constraint sequence x  q      l      u      s        with the ordered
sequence of binary variables x    x    x    x    x    having domains d xi            for i  
         and d x           again  we apply the mdd of width   representing the cartesian
product of the variable domains  establishing mdd consistency on the cumulative sums
encoding yields
y           y           y           y           y          
x        x           x           x       
while establishing mdd consistency on the among encoding does not prune any value  
as an additional illustration of corollary    consider again example   and figure    mdd
propagation for the among encoding will eliminate the value x      from the infeasible
path                  whereas our example showed that mdd propagation for cumulative sums
does not detect this 
theorem   mdd consistency on the cumulative sums encoding of sequence is incomparable to domain consistency on sequence 
proof  the first example in the proof of corollary   also shows that domain consistency
on sequence can be stronger than mdd consistency on the cumulative sums encoding 
to show the opposite  consider a constraint sequence x  q  l  u  s        with a set
of binary variables of arbitrary size  arbitrary values q  l  and u    x      let m be the
mdd defined over x consisting of two disjoint paths from r to t  the arcs on one path
all have label    while the arcs on the other all have value    since the projection onto
the variable domains gives x         for all x  x  domain consistency will not deduce
infeasibility  however  establishing mdd consistency with respect to m on the cumulative
sums encoding will detect this 

even though formally our mdd propagation based on cumulative sums is incomparable to
domain propagation of sequence and mdd propagation of among constraints  in the
next section we will show that in practice our algorithm can reduce the search space by
orders of magnitude compared to these other methods 

   computational results
the purpose of our computational results is to evaluate empirically the strength of the partial mdd propagator described in section    we perform three main comparisons  first 
we want to assess the impact of increasing the maximum width of the mdd on the filtering 
second  we want to compare the mdd propagation with the classical domain propagation
for sequence  in particular  we wish to evaluate the computational overhead of mdd
propagation relative to domain propagation  and to what extent mdd propagation can
outperform domain propagation  third  we compare the filtering strength of our mdd
propagator for sequence to the filtering strength of the mdd propagators for the individual among constraints  being the best mdd approach for sequence so far  hoda et al  
      
   

fimdd propagation for sequence constraints

we have implemented our mdd propagator for sequence as a custom global constraint
in ibm ilog cplex cp optimizer       using the c   interface  recall from section  
that for applying rules     we can either maintain a minimum and maximum value for the q
previous ancestors and descendants of each node  or approximate this by maintaining these
values simply for each layer  we evaluated both strategies and found that the latter did
reduce the amount of filtering  but nonetheless resulted in much more efficient performance
 about twice as fast on average   hence  the reported results use that implementation 
for the mdd propagator for among  we apply the code of  hoda et al          for the
domain propagation  we applied three models  the first uses the domain consistent propagator for sequence by van hoeve et al          running in o n    time  the second uses
the domain consistent propagator for sequence based on a network flow representation
by maher et al          which runs in o n    time   as third model  we applied the decomposition into cumulative sums  which uses no explicit global constraint for sequence 
propagating this decomposition also takes o n    in the worst case  as it considers o n  variables and constraints while the variable domains contain up to n elements  we note that
for almost all test instances  the cumulative sums encoding established domain consistency
on sequence  as an additional advantage  the cumulative sums encoding permits a more
insightful comparison with our mdd propagator  since both are based on the cumulative
sums decomposition 
we note that brand et al         introduce the multiple sequence constraint that
represents the conjunction of multiple sequence constraints on the same set of ordered
variables  as in our experimental setup   narodytska        shows that establishing bounds
consistency on such system is already np hard  and presents a domain consistent propagator
that encodes the system as an automaton for the regular constraint  the algorithm runs
in o nmq   time  where n represents the number of variables  m the number of sequence
constraints  and q the length of the largest subsequence 
in order to compare our algorithms with the multiple sequence constraint  we conducted experiments to identify a suitable testbed  we found that instances for which the
multiple sequence constraint would not run out of memory could be solved instantly by
using any domain propagator for the individual sequence constraints  while creating the
data structures for the multiple sequence constraint took substantially more time on average  for instances that were more challenging  as described in the next sections   the
multiple sequence constraint could not be applied due to memory issues  we therefore
excluded this algorithm from the comparisons in the sections below 
because single sequence constraints can be solved in polynomial time  we consider
instances with multiple sequence constraints in our experiments  we assume that these
are defined on the same ordered set of variables  to measure the impact of the different
propagation methods correctly  all approaches apply the same fixed search strategy  i e  
following the given ordering of the variables  with a lexicographic value ordering heuristic 
for each method  we measure the number of backtracks from a failed search state as well
as the solving time  all experiments are performed using a     ghz intel xeon machine 
   we thank nina narodytska for sharing the implementation with us 

   

fibergman  cire   van hoeve

    systems of sequence constraints
we first consider systems of multiple sequence constraints that are defined on the same set
of variables  we generate instances with n      variables each having domain                    
and   sequence constraints  for each sequence constraint  we set the length of subsequence uniform randomly between     n    as
q    rand     n             
here  rand   refers to the standard c   random number generator  i e   rand   k selects
a number in the range     k      without the minimum length of    many of the instances
would be very easy to solve by either method  we next define the difference between l and
u as      rand   q   and set
l     rand    q     
u    l    
lastly  we define the set of values s by first defining its cardinality as  rand            and
then selecting that many values uniformly at random from                     we generated    
such instances in total  
we solve each instance using the domain consistency propagator for sequence  the
cumulative sums encoding  domain propagation   and the mdd propagator with maximum
widths                           each method is given a maximum time limit of       seconds
per instance 
we compare the performance of domain propagation and mdd propagation in figure    in this figure  we report for each given time point how many instances could be
solved within that time by a specific method  the three domain propagation methods are
represented by cumulative sums  the cumulative sums decomposition   sequence   hprs
 the sequence propagator in van hoeve et al                and sequence   flow  the
flow based propagator in maher et al          observe that the cumulative sums domain
propagation  although not guaranteed to establish domain consistency  outperforms both
domain consistent sequence propagators  also  mdd propagation with maximum width
  can already substantially outperform domain propagation  we can further observe that
larger maximum widths require more time for the mdds to be processed  but in the end
it does allow to solve more instances  maximum mdd width     permits to solve all    
instances within the given time limit  whereas domain propagation can respectively solve
     sequence   flow        sequence   hprs   and      cumulative sums  instances 
to illustrate the difference between domain and mdd propagation in more detail  figure   presents scatter plots comparing domain propagation  cumulative sums  with mdd
propagation  maximum width      this comparison is particularly meaningful because
both propagation methods rely on the cumulative sums representation  for each instance 
figure   a depicts the number of backtracks while figure   b depicts the solving time of
both methods  the instances that were not solved within the time limit are collected under
to  time out  for that method  figure   a demonstrates that mdd propagation can lead
to dramatic search tree reductions  by several orders of magnitude  naturally  the mdd
   all instances are available at http   www andrew cmu edu user vanhoeve mdd  

   

fi   
   
   

mdd width    
mdd width   
mdd width  
domain  cumulative sums 
domain  sequence  hprs 
domain  sequence  flow 

 

  

number of instances solved

   

mdd propagation for sequence constraints

   

   

   

   

   

   

time s 

figure    performance comparison of domain and mdd propagators for the sequence
constraint  each data point reflects the total number of instances that are solved
by a particular method within the corresponding time limit 

propagation comes with a computational cost  but figure   b shows that for almost all instances  especially the harder ones   the search tree reductions correspond to faster solving
times  again often several orders of magnitude 
we next evaluate the impact of increasing maximum widths of the mdd propagator 
in figure    we present for each method the survival function with respect to the number
of backtracks  a   and solving time  b    formally  when applied to combinatorial backtrack search algorithms  the survival function represents the probability of a run taking
more than x backtracks  gomes  fernandez  selman    bessiere         in our case  we
approximate this function by taking the proportion of instances that need at least x backtracks  figure   a   respectively seconds  figure   b   observe that these are log log plots 
with respect to the search tree size  figure   a clearly shows the strengthening of the mdd
propagation when the maximum width is increased  in particular  the domain propagation
reflects the linear behavior over several orders of magnitude that is typical for heavy tailed
runtime distributions  naturally  similar behavior is present for the mdd propagation  but
in a much weaker form for increasing maximum mdd widths  the associated solving times
are presented in figure   b  it reflects similar behavior  but also takes into account the
initial computational overhead of mdd propagation 
   

fi   
   
   
   

   

mdd propagator  width      time  s 

   
   
   
   

mdd propagator  width      backtracks

to

    to

bergman  cire   van hoeve

   

   

   

   

   

to

   

   

   

   

    to

domain propagator  cumulative sums   time  s 

domain propagator  cumulative sums   backtracks

b  solving time

a  number of backtracks

figure    comparing domain and mdd propagation for sequence constraints  each data
point reflects the number of backtracks  a   resp  solving time in seconds  b  
for a specific instance  when solved with the best domain propagator  cumulative
sums encoding  and the mdd propagator with maximum width     instances for
which either method needed   backtracks  a   or less than      seconds  b   are
excluded  here  to stands for timeout and represents that the specific instance
could not be solved within      s  fig  b    in figure a   these instances are
labeled separately by to  at tick mark        note that the reported number of
backtracks after       seconds may be much less than     for these instances  all
reported instances with fewer than     backtracks were solved within the time
limit 

    nurse rostering instances
we next consider a more structured problem class inspired by nurse rostering problems 
the problem is to design a work schedule for a nurse over a given horizon of n days  on
each day  a nurse can either work a day shift  d   evening shift  e   night shift  n   or
have a day off  o   we introduce a variable xi for each day i              n  with domain
d xi      o  d  e  n   representing the shift  we impose the eight sequence constraints
modeling the requirements listed in table   
by the combinatorial nature of this problem  the size of the cp search tree turns out to
be largely independent on the length of the time horizon  when a lexicographic search  by
increasing day i  is applied  we however do consider instances with various time horizons
 n                     to address potential scaling issues 
the results are presented in table    the columns for domain sequence show the total
number of backtracks  bt  and solving time in seconds  cpu  for the domain consistent
sequence propagator  similarly  the columns for domain cumul  sums show this infor   

fimdd propagation for sequence constraints

   
   
   
    

survival function

   

domain consistency
mdd width  
mdd width  
mdd width  
mdd width   
mdd width   
mdd width   
mdd width    

          

    
          

survival function

   

   

domain consistency
mdd width  
mdd width  
mdd width  
mdd width   
mdd width   
mdd width   
mdd width    

   

   

   

   

   

   

   

   

   

backtracks

   

   

   

   

   

time  s 

a  survival function with respect to backtracks

b  survival function with respect to solving time

figure    evaluating the impact of increased width for mdd propagation via survival function plots with respect to search backtracks  a   and solving time  b    both plots
are in log log scale  each data point reflects the percentage of instances that require at least that many backtracks  a   resp  seconds  b   to be solved by a
particular method 

requirement

sequence x  q  l  u  s 

at least    work shifts every    days 
at least   off days every    days 
between   and   night shifts every    days 
between   and   evening shifts every    days 
nights shifts cannot appear on consecutive days 
between   and   evening night shifts every   days 
at most   work shifts every   days 

sequence x               d  e  n   
sequence x              o  
sequence x             n   
sequence x             e  
sequence x            n   
sequence x            e  n   
sequence x            d  e  n   

table    nurse rostering problem specification  variable set x represents the shifts to be
assigned over a sequence of days  the possible shifts are day  d   evening  e  
night  n   and day off  o  

mation for the cumulative sums domain propagation  the subsequent columns show these
numbers for the mdd propagator  for mdds of maximum width          and    note that
propagating an mdd of width   corresponds to domain propagation  and indeed the associated number of backtracks is equivalent to the domain propagator of the cumulative sums 
as a first observation  a maximum width of   already reduces the number of backtracks
by a factor      for maximum width of   the mdd propagation even allows to solve the
   

fibergman  cire   van hoeve

n
  
  
  
   

domain
sequence
bt
cpu
             
             
              
              

domain
cumul  sums
bt
cpu
       
       
       
       

     
     
     
     

mdd
width  
bt
cpu
             
             
              
              

mdd
width  
bt
cpu
      
      
      
      

     
     
     
     

mdd
width  
bt cpu
   
   
   
   

    
    
    
    

mdd
width  
bt cpu
 
 
 
 

    
    
    
    

table    comparing domain propagation and the mdd propagation for sequence on nurse
rostering instances  here  n stands for the number of variables  bt for the number
of backtracks  and cpu for solving time in seconds 

problem without search  the computation times are correspondingly reduced  e g   from
   s  resp    s  for the domain propagators to     s for the mdd propagator  width    for
the instance with n        lastly  we can observe that in this case mdd propagation does
not suffer from scaling issues when compared to domain propagation 
as a final remark  we also attempted to solve these nurse rostering instances using the
sequence domain propagator of cp optimizer  ilosequence   it was able to solve the
instance with n      in       seconds  but none of the others instances were solved within
the time limit of       seconds 
    comparing mdd filtering for sequence and among
in our last experiment  we compare our sequence mdd propagator to the mdd propagator for among constraints by hoda et al          our main goal is to determine whether a
large mdd is by itself sufficient to solve these problem  irrespective of propagating among
or a cumulative sums decomposition   or whether the additional information obtained by
our sequence propagator makes the difference 
we apply both methods  mdd propagation for sequence and mdd propagation for
among  to the data set of section     containing     instances  the time limit is again
      seconds  and we run the propagators with maximum mdd widths           and     
we first compare the performance of the mdd propagators for among and sequence
in figure    the figure depicts the number of instances that can be solved within a given
time limit for the various methods  the plot indicates that the among propagators are
much weaker than the sequence propagator  and moreover that larger maximum widths
alone do not suffice  using the sequence propagator with maximum width   outperforms
the among propagators for all maximum widths up to     
the scatter plot in figure   compares the mdd propagators for among and sequence
in more detail  for widths           and      instances that take   backtracks  resp  less
than      seconds  for either method are discarded from figure   a  resp    b   for smaller
widths  there are several instances that the among propagator can solve faster  but the
relative strength of the sequence propagator increases with larger widths  for width
     the sequence propagator can achieve orders of magnitude smaller search trees and
   

fi   
   
   

sequence  width    
sequence  width   
sequence  width  
sequence  width  
among  width    
among  width   
among  width  
among  width  

 

  

number of instances solved

   

mdd propagation for sequence constraints

   

   

   

   

   

   

time s 

    to
   
   
   
   

sequence mdd propagator  time  s 

width  
width  
width   
width    

   

   

   

   

width  
width  
width   
width    

   

sequence mdd propagator  backtracks

to

figure    performance comparison of mdd propagation for sequence and among for
various maximum widths  each data point reflects the total number of instances
that are solved by a particular method within the corresponding time limit 

   

   

   

   

   

to

   

   

   

   

    to

among mdd propagator  time  s 

among mdd propagator  backtracks

b  solving time

a  number of backtracks

figure    evaluating mdd propagation for sequence and among for various maximum
widths via scatter plots with respect to search backtracks  a   and solving time
 b    both plots are in log log scale and follow the same format as figure   

   

fibergman  cire   van hoeve

solving time than the among propagators  which again demonstrates the advantage of
mdd propagation for sequence when compared to the among decomposition 

   conclusion
constraint propagation with limited width mdds has recently been shown to be a powerful
alternative to the conventional propagation of variable domains in constraint programming 
in this work  we have studied mdd propagation for the sequence constraint  which appears in  e g   rostering and scheduling applications  we have first proved that establishing
mdd consistency for sequence is np hard  however  we have also shown that this task
is fixed parameter tractable with respect to the length of the sub sequences defined by the
constraint  provided that the mdd follows the variable ordering specified by the constraint 
we then proposed a practical mdd propagation algorithm for sequence that is also polynomial in the length of the sub sequences  which is based on a cumulative decomposition 
we provided extensive experimental results comparing our mdd propagator for sequence
to domain propagators for sequence as well as an existing mdd propagator for among 
our computational experiments have shown that our mdd propagator for sequence can
outperform domain propagators by orders by magnitude in terms of search tree size and
solving time  similar results were obtained when compared to the existing mdd propagator for among  which demonstrates that in practice a large mdd alone is not sufficient to
solve these problems  specific mdd propagators for global constraints such as sequence
can lead to orders of magnitude speedups 

acknowledgments
this material is based upon work supported by the national science foundation under
grant no  cmmi          and a google research award  we also thank the reviewers
whose comments helped improve the paper 

references
andersen  h  r   hadzic  t   hooker  j  n     tiedemann  p          a constraint store
based on multivalued decision diagrams  in proceedings of cp  vol       of lncs 
pp          springer 
apt  k  r          principles of constraint programming  cambridge university press 
beldiceanu  n     contejean  e          introducing global constraints in chip  journal
of mathematical and computer modelling                 
brand  s   narodytska  n   quimper  c   stuckey  p     walsh  t          encodings of the
sequence constraint  in proceedings of cp  vol       of lncs  pp          springer 
cheng  k     yap  r          maintaining generalized arc consistency on ad hoc r ary
constraints  in proceedings of cp  vol       of lncs  pp          springer 
cire  a  a     van hoeve  w  j          mdd propagation for disjunctive scheduling  in
proceedings of icaps  pp        aaai press 
   

fimdd propagation for sequence constraints

cire  a  a     van hoeve  w  j          multivalued decision diagrams for sequencing
problems  operations research                   
dechter  r          constraint processing  morgan kaufmann 
downing  n   feydy  t     stuckey  p          explaining flow based propagation  in
proceedings of cpaior  vol       of lncs  pp          springer 
garey  m     johnson  d          computers and intractability   a guide to the theory of
np completeness  freeman 
gomes  c  p   fernandez  c   selman  b     bessiere  c          statistical regimes across
constrainedness regions  constraints                 
hadzic  t   hooker  j  n   osullivan  b     tiedemann  p       a   approximate compilation of constraints into multivalued decision diagrams  in proceedings of cp  vol 
     of lncs  pp          springer 
hadzic  t   hooker  j  n     tiedemann  p       b   propagating separable equalities in
an mdd store  in proceedings of cpaior  vol       of lncs  pp          springer 
hadzic  t   omahony  e   osullivan  b     sellmann  m          enhanced inference for
the market split problem  in proceedings of ictai  pp          ieee 
hawkins  p   lagoon  v     stuckey  p          solving set constraint satisfaction problems
using robdds  jair                 
hoda  s   van hoeve  w  j     hooker  j  n          a systematic approach to mdd based
constraint programming  in proceedings of cp  vol       of lncs  pp         
springer 
hosaka  k   takenaga  y   kaneda  t     yajima  s          size of ordered binary decision
diagrams representing threshold functions  theoretical computer science            
knuth  d  e          the art of computer programming  volume    fascicle    bitwise
tricks   techniques  binary decision diagrams  addison wesley professional 
maher  m   narodytska  n   quimper  c  g     walsh  t          flow based propagators
for the sequence and related global constraints  in proceedings of cp  vol      
of lncs  pp          springer 
narodytska  n          reformulation of global constraints  ph d  thesis  university of
new south wales 
regin  j  c          a filtering algorithm for constraints of difference in csps  in
proceedings of aaai  vol     pp          aaai press 
regin  j  c          global constraints  a survey  in van hentenryck  p     milano  m 
 eds    hybrid optimization  pp         springer 
regin  j  c     puget  j  f          a filtering algorithm for global sequencing constraints  in proceedings of cp  vol       of lncs  pp        springer 
rossi  f   van beek  p     walsh  t   eds            handbook of constraint programming 
elsevier 
van hoeve  w  j     katriel  i          global constraints  in rossi  f  van beek  p    
walsh  t   eds    handbook of constraint programming  chap     elsevier 
   

fibergman  cire   van hoeve

van hoeve  w  j   pesant  g   rousseau  l  m     sabharwal  a          revisiting the
sequence constraint  in proceedings of cp  vol       of lncs  pp          springer 
van hoeve  w  j   pesant  g   rousseau  l  m     sabharwal  a          new filtering
algorithms for combinations of among constraints  constraints             
wegener  i          branching programs and binary decision diagrams  theory and applications  siam monographs on discrete mathematics and applications  society for
industrial and applied mathematics 

   

fi