journal artificial intelligence research                 

submitted        published      

interactive cost configuration decision diagrams
henrik reif andersen

hra configit com

configit a s
dk      copenhagen  denmark

tarik hadzic

t hadzic  c ucc ie

cork constraint computation centre
university college cork
cork  ireland

david pisinger

pisinger man dtu dk

dtu management
technical university denmark
dk      kgs  lyngby  denmark

abstract
many ai domains product configuration  user interactively specify
solution must satisfy set constraints  scenarios  offline compilation
feasible solutions tractable representation important approach delivering efficient backtrack free user interaction online  particular  binary decision diagrams
 bdds  successfully used compilation target product service configuration  paper discuss extend bdd based configuration scenarios
involving cost functions express user preferences 
first show efficient  robust easy implement extension possible
cost function additive  feasible solutions represented using multi valued decision diagrams  mdds   discuss effect mdd size cost function
non additive encoded explicitly mdd  discuss interactive configuration presence multiple cost functions  prove even simplest form 
multiple cost configuration np hard input mdd  however  solving two cost
configuration develop pseudo polynomial scheme fully polynomial approximation scheme  applicability approach demonstrated experiments
real world configuration models product catalogue datasets  response times generally within fraction second even large instances 

   introduction
interactively specifying solution must satisfy number combinatorial restrictions
important problem many ai domains related decision making  buying
product online  selling insurance policy setting piece equipment  solutions
often modeled assignments variables constraints imposed 
assigning variables without sufficient guidance  user might forced backtrack  since
choices made cannot extended way would satisfy
succeeding constraints  improve usability interaction therefore important
indicate user values participate least one remaining solution 
c
    
ai access foundation  rights reserved 

fiandersen  hadzic    pisinger

user assigning values guaranteed able reach feasible solution
never forced backtrack  refer task computing values
calculating valid domains  cvd   since computationally challenging  np hard 
problem  short execution times important interactive setting 
suggested compile offline  prior user interaction  set feasible solutions
representation form supports efficient execution cvd online interaction 
mller  andersen  hulgaard        hadzic  subbarayan  jensen  andersen 
mller  hulgaard        investigated approach using binary decision diagrams  bdds  compilation target  bdds one data structures investigated
knowledge compilation community preprocess original problem formulations
tractable representations enhance solving subsequent tasks  cvd one
tasks occurring configuration domain  knowledge compilation successfully applied number areas planning  diagnosis  model checking etc 
beside bdds  number structures  various sublanguages negation normal forms  nnfs   darwiche   marquis         and or diagrams  mateescu  dechter   
marinescu         finite state automata  vempaty        amilhastre  fargier    marquis 
      various extensions decision diagrams  drechsler        wegener        meinel
  theobald        used compilation targets  suitable interactive configuration well  particular  vempaty        suggested compiling constraints
automaton  however  bdds investigated data structures tool
support unrivaled emerging representations  many highly optimized
open source bdd packages  e g   somenzi        lind nielsen        allow easy
efficient manipulation bdds  contrast  publicly available  open source compilers
still developed many newer representations  particular  application bdds
configuration resulted patent approval  lichtenberg  andersen  hulgaard  mller   
rasmussen        establishment spinoff company configit a s   
work paper motivated decision making scenarios solutions
associated cost function  expressing implicitly properties price  quality  failure probability etc  user might prefer one solution another given value
properties  natural way user expresses cost preferences configuration
setting bound minimal maximal cost solution willing accept 
therefore study problem calculating weighted valid domains  wcvd  
eliminate values every valid solution expensive user provided
maximal cost  present configurator supports efficient cost bounding wide
class additive cost functions  approach easily implementable scales well
instances previously compiled bdds standard interactive configuration  cornerstone approach reuse robust compilation constraints
bdd  extract corresponding multi valued decision diagram  mdd  
resulting mdd allows us label edges weights utilize efficient shortest path algorithms label nodes filter expensive values mdd edges  mdd extraction
technique novel  labeling edges decision diagram suggested works well 
generic interpretation  wilson         edges decision diagram labeled
elements semiring support algebraic computations relevant probabilistic rea   http   www configit com

   

fiinteractive cost configuration decision diagrams

soning  optimization etc  amilhastre et al         suggest labeling edges automaton
reason abut optimal restorations explanations  general  many knowledge compilation
structures weighted counterparts  many captured framework
valued negation normal forms  vnnfs   fargier   marquis         structures
utilized probabilistic reasoning  diagnosis  tasks involving reasoning
real valued rather boolean functions  principle used wcvd
queries  public tool support weighted variants less available tailored
tasks outside configuration domain 
extend approach support valid domains computation presence
multiple cost functions  user often multiple conflicting objectives 
satisfied simultaneously  traditional approaches multi criteria optimization  figueira 
greco    ehrgott        ehrgott   gandibleux        typically interact user
way unsuitable configuration setting cost functions combined single
objective interaction step non dominated solutions sampled displayed user  based user selections adequate aggregation costs performed
next interaction step  suggest configuration oriented interaction approach domains bounded respect multiple costs  prove
particularly challenging problem  computing valid domains mdd presence
two cost functions    wcvd  np hard  even simplest extension linear inequalities
positive coefficients boolean variables  despite negative result  provide
implementation   wcvd queries pseudo polynomial time space develop
fully polynomial time approximation scheme  fptas   prove pseudo polynomial
algorithm hence fully polynomial approximation scheme exists computing domains presence arbitrarily many cost functions since np hard problem
strong sense  finally  demonstrate experimental evaluation applicability wcvd   wcvd query large real world configuration models
product catalogue datasets  best knowledge  present first interactive configurator supporting configuration wrt  cost restrictions backtrack free
complete manner  constitutes novel addition existing product configuration
approaches well approaches within multi criteria decision making  figueira et al  
      
remainder paper organized follows  section   describe background
work notation  section   describe approach implementing wcvd query
mdd section   show compile mdd  section   discuss
configuring presence multiple costs  section   present empirical evaluation
approach  section   describe related work finally conclude section   

   preliminaries
briefly review important concepts background 
    constraint satisfaction problems
constraint satisfaction problems  csps  form framework modeling solving combinatorial problems  solution problem formulated assignment
   

fiandersen  hadzic    pisinger

variables satisfy certain constraints  standard form  csp involves finite
number variables  defined finite domains 
definition    csp  constraint satisfaction problem  csp  triple  x  d  f  
x set variables  x            xn      d       dn cartesian product finite
domains d            dn f    f         fm   set constraints defined variables x 
constraint f function defined subset variables xf x called scope
f   maps assignment xf variables          indicates f
satisfied   indicates f violated assignment  solution assignment
variables x satisfies constraints simultaneously 
formally  assignment values a            variables x            xn denoted set
pairs     x    a              xn       domain assignment dom   set
variables assigned  dom      xi   di   xi   a    variables
assigned  i e  dom     x  refer total assignment  say total
assignment valid satisfies rules  denoted    f   partial
assignment   dom   x valid extended total assignment  
valid      f   define solution space sol set valid total assignments 
i e  sol          f  dom     x  
    interactive configuration
interactive configuration important application domain user assisted
specifying valid configuration  of product  service something else  interactively
providing feedback valid options unspecified attributes  problem arises
number domains  example  buying product  user specify number
product attributes  attribute combinations might feasible guidance
provided  user might reach dead end interacting system 
forced backtrack  might seriously decrease user satisfaction 
many cases  valid configurations implicitly described specifying restrictions
combining product attributes  use csp model represent restrictions 
csp solution corresponds valid configuration  configurable attribute
represented variable  attribute option corresponds value
variable domain  example   illustrate simple configuration problem csp
model 
example   specify t shirt choose color  black  white  red  blue  
size  small  medium  large  print  men black   mib save
whales   stw   choose mib print color black chosen well 
choose small size stw print  including large picture whale 
cannot selected picture whale fit small shirt  configuration
problem  x  d  f   t shirt example consists variables x    x    x    x    representing
color  size print  variable domains d                  black   white  red   blue   d   
           small   medium  large   d            mib   stw    two rules translate
f    f    f     f  x      x       mib black   f   x      x       
 small stw     d    d    d         possible assignments  eleven
assignments valid configurations form solution space shown fig    
   

fiinteractive cost configuration decision diagrams

 black   small   mib  
 black   medium  mib  
 black   medium  stw  
 black   large  mib  

 black   large  stw  
 white  medium  stw  
 white  large  stw  
 red   medium  stw  

 red   large  stw  
 blue  medium  stw  
 blue  large  stw  

figure    solution space t shirt example 
fundamental task concerned paper calculating valid
domains  cvd  query  partial assignment representing previously made user assignments  configurator calculates displays valid domain vd    di
unassigned variable xi x   dom    domain valid contains
values extended total valid assignment     example 
user selects small t shirt  x        valid domains restricted mib print
v d        black color v d        
definition    cvd  given csp model  x  d  f    given partial assignment compute valid domains 
vdi       a di            f   xi   a       
task main interest since delivers important interaction requirements  backtrackfreeness  user never forced backtrack  completeness  all valid configurations
reachable   hadzic et al          queries relevant supporting
user interaction explanations restorations failure  recommendations
relevant products  etc   cvd essential operation mode interaction
primary importance paper 
    decision diagrams
decision diagrams form family rooted directed acyclic graphs  dags  node
u labeled variable xi outgoing edges e labeled value di  
node may one outgoing edge label  decision diagram
contains one terminal nodes  labeled constant outgoing
edges  well known member family binary decision diagrams  bdds 
 bryant        used manipulating boolean functions many areas 
verification  model checking  vlsi design  meinel   theobald        wegener       
drechsler        etc  paper primarily operate following variant
multi valued decision diagrams 
definition    mdd  mdd denoted rooted directed acyclic graph  v  e  
v set vertices containing special terminal vertex   root r v   further 
var   v             n      labeling nodes variable index var     
n      edge e e denoted triple  u  u    a  start node u  end node u 
associated value a 
work ordered mdds  total ordering   variables assumed
edges  u  u    a   var u    var u     convenience assume variables
   

fiandersen  hadzic    pisinger

x ordered according indices  ordered mdds considered
arranged n layers vertices  layer labeled variable index 
denote vi set nodes labeled xi   vi    u v   var u    i   similarly 
denote ei set edges originating vi   i e  ei    e u  u    a  e  
var u    i   unless otherwise specified  assume path root
terminal  every variable labels exactly one node 
mdd encodes csp solution set sol d        dn   defined variables
 x            xn    check whether assignment    a              d        dn sol
traverse root  every node u labeled variable xi   follow edge
labeled ai   edge solution  i e     sol  otherwise 
traversal eventually ends terminal   sol  denote p   u 
u 
path mdd u  u    also  edges u u  sometimes denoted
e   u u    value edge e u  u    a  sometimes denoted v e  
make distinction paths assignments  hence  set solutions represented
mdd sol    p   p   r
    fact  every node u vi associated
subset solutions sol u     p   p   u
   di       dn  
x 
 

 

x 
 
x 

 

x 
 

 

 
x 

 

x 

   

 

 

 

x 
 

 

   

x 

x 

 

 

x 

x 

x 

x 

 

 

 

 

x 
 

 

 

x 
 

x 

     
x 

x 

   

   

x 
     

x 
 

 

 a  mdd merging 

 b  merged mdd 

figure    uncompressed merged mdd t shirt example 
decision diagrams exponentially smaller size solution set
encode merging isomorphic subgraphs  two nodes u    u  isomorphic encode
solution set sol u      sol u     figure   show fully expanded mdd   a 
equivalent merged mdd   b  t shirt solution space  addition merging
isomorphic subgraphs  another compression rule usually utilized  removing redundant
nodes  node u vi redundant di outgoing edges  pointing
node u    nodes eliminated redirecting incoming edges u u  deleting u
v   introduces long edges skip layers  edge e u  u    a  long var u     
var u     case  e encodes set solutions   a  dvar u          dvar u      
refer mdd merging isomorphic nodes removal redundant
nodes taken place reduced mdd  constitutes multi valued generalization
bdds typically reduced ordered  reduced mdd t shirt csp
shown figure    paper  unless emphasized otherwise  mdd always
assume ordered merged reduced mdd  since exposition simpler  removal
redundant nodes linear effect size  given variable ordering
   

fiinteractive cost configuration decision diagrams

unique merged mdd given csp  x  d  f   solution set sol 
size mdd depends critically ordering  could vary exponentially  grow
exponentially number variables  practice  many interesting problems
size surprisingly small 
x 
   
x 

   
x 

 
x 

  
   

 

x 
 

 

figure    reduced mdd t shirt example 
interactive configuration decision diagrams  particularly attractive property decision diagrams support efficient execution number important
queries  checking consistency  validity  equivalence  counting  optimization etc 
utilized number application domains problem description
known offline  diagnosis  verification etc    particular  calculating valid domains linear
size mdd  since calculating valid domains np hard problem size
input csp model  possible guarantee interactive response real time 
fact  unacceptably long worst case response times empirically observed
purely search based approach computing valid domains  subbarayan et al         
therefore  compiling csp solutions off line  prior user interaction  decision
diagram  efficiently  in size mdd  compute valid domains online
interaction user  important note order user decides
variables completely unconstrained  i e  depend ordering mdd variables  previous work utilized binary decision diagrams  bdds  represent
valid configurations cvd queries executed efficiently  hadzic et al         
course  bdds might exponentially large input csp  many classes
constraints surprisingly compact 

   interactive cost processing mdds
main motivation work extending interactive configuration approach
mller et al          hadzic et al          subbarayan et al         situations
addition csp model  x  d  f   involving hard constraints  cost
function 
c   d        dn r 
product configuration setting  could product price  uncertainty setting 
cost function might indicate probability occurrence event represented
   

fiandersen  hadzic    pisinger

solution  failure hardware component  withdrawal bid auction etc   
decision support context  cost function might indicate user preferences 
number cost related queries user might interested  e g  finding optimal
solution  computing probable explanation  we  however  assume user
interested tight control variable values well cost selected solutions 
example  user might desire specific option xi   a  would care
would assignment affect cost remaining optimal solutions 
communicate information user  allow strike right balance
cost variable values allowing interactively limit maximal cost
product addition assigning variable values  therefore  paper primarily
concerned implementing weighted cvd  wcvd  query  user specified maximum
cost k  indicate values unassigned variable domains extended
total assignment valid costs less k  on  assume
user interested bounding maximal cost  limiting minimal cost symmetric  
definition    wcvd  given csp model  x  d  f    cost function c   r
maximal cost k  given partial assignment weighted cvd  wcvd  query requires
computation valid domains 
vdi    k     a di            f   xi   a     c     k  
section assume mdd representation csp solutions already
generated offline compilation step  postpone discussion mdd compilation
section   discuss delivering efficient online interaction top mdd 
first discuss practicability implementing wcvd queries explicit encoding
costs mdd  provide practical efficient approach implementing
wcvd mdd cost function additive  finally  discuss
extensions handling expressive cost functions 
    handling costs explicitly
immediate approach interactively handling cost function treat cost
solution attribute  i e  add variable variables x add constraint
  c x            xn  

   

formulas f enforce equal total cost  resulting configuration model
compiled mdd   user able bound cost restricting domain
y 
assuming variable ordering x            xn original csp model  x  d  f   
assuming inserted cost variable i th position  new variable set x  
variable ordering x             x n   s t  x     x            x i    xi    x i   x i    
xi           x n     xn   domain di  variable x i set feasible costs c sol   
 c s    sol   demonstrate mdd   may exponentially larger
 
lemma    ei     c sol   
   

fiinteractive cost configuration decision diagrams

proof   i th layer mdd   corresponding variable y  cost c c sol 
must least one path p   r
  c p    c  path  edge e ei 
i th layer must labeled v e    c  hence  cost must least
one edge ei    proves lemma 
 
furthermore  least one layers nodes vi    vi  
number nodes greater
p  
 ei    follows following lemma 
     e     
lemma   i th layer mdd      vi     vi  


    pairs nodes  u   u   v   v     statement
proof   since  vi    vi  
   
i  

follows fact pair  u    u    one edge e   u  u   
namely  every solution p  formed concatenating paths p    r
u  p    u 
 
unique cost c p     however  two edges e    e    u  u    would
different values v e       v e     then  solution c p    would correspond
two different costs v e     v e    

considerations see whenever range possible costs c sol 
exponential  resulting mdd   would exponentially large well  would
result significantly increased size  v      v    particularly large number
isomorphic nodes would become non isomorphic variable introduced
 since root paths different costs   extreme instance behavior
presented example    furthermore  even c sol  large  could orders
magnitude increase size   due breaking isomorphic nodes mdd
empirically demonstrated section    table    number configuration
instances  major disadvantage otherwise efficient cvd algorithms become
unusable since operate significantly larger structure 
example   consider model c x  d  f   constraints f       boolean variables dj           j             n  solution space includes assignments sol   d 
      dn corresponding mdd  v  e  one vertex two
layer 
pnedgesj 
xj  
 v     n       e      n  use cost function  c x            xn     j    
exponential number feasible costs c sol                 n     hence   ei     n
    greater
i th layer corresponding variable y  least one layers  vi      vi  

n  
 n      
however  significant node isomorphism   adding variable
necessarily lead significant increase size  extreme instance mdd
isomorphic nodes  example every edge labeled unique value 
mdd  number non terminal nodes n  sol   adding cost variable
y  resulting mdd would add one node per path  leading mdd
 n       sol  nodes  translates minor increase size   v      v      n      n 
property empirically demonstrated section    table    product catalogue
datasets  remainder paper develop techniques tailored instances
large increase size occurs  avoid explicit cost encoding aim exploit
structure cost function implement wcvd 
   

fiandersen  hadzic    pisinger

    processing additive cost functions
one main contributions paper practical efficient approach deliver
wcvd queries cost function additive  additive cost function form
c x            xn    

n
x

ci  xi  

i  

cost ci  ai   r assigned every variable xi every value domain
ai di  
additive functions one important frequently used modeling constructs  number important combinatorial problems modeled integer linear programs often constraints objective function linear  i e  represent
special cases additive cost functions  multi attribute utility theory user preferences
certain assumptions aggregated single additive function weighted
summation utilities individual attributes  product configuration context  many
properties additive memory capacity computer total weight 
particular  based experience commercially applying configuration technology 
price product often modeled  weighted  sum prices individual parts 
      labeling approach
assuming given mdd representation solution space sol cost
function c  approach answering wcvd queries based three steps     restricting
mdd wrt  latest user assignment     labeling remaining nodes executing shortest
path algorithms    filtering expensive values using node labels 
restricting mdd  given user assignment xi   ai   xi
unassigned variables  regardless position mdd variable ordering  initialize
mdd pruning removing edges e u  u    a   agreement latest
assignment  i e  var u       ai   might cause number edges
nodes become unreachable terminal root removed last edge
set children edges ch u  parent edges p  u     unreachable edge must
removed well  pruning repeated fixpoint reached  i e 
nodes edges removed  algorithm   implements scheme o  v      e   time
space using queue q maintain set edges yet removed 
note unassigning user assignment xi   ai easily implemented linear
time well  suffices restore copy initial mdd   perform restriction wrt 
partial assignment     xi   ai    current assignment  algorithm   easily
extended purpose initializing edge removal list q edges incompatible
wrt  assignments  
computing node labels  remaining edges e u  u    a  layer ei implicitly
labeled c e    ci  a   second step compute mdd node u v
upstream cost shortest path root r u  denoted u  u   downstream
cost shortest path u terminal    denoted d u  
 
 
 
 
x
x
u  u    min
c e 
   
c e    d u    min
p r

u

p u

ep

   

 

ep

fiinteractive cost configuration decision diagrams

algorithm    restrict mdd 
data  mdd  v  e   variable xi   value ai
foreach e ei   v e     ai
q push e  
q   
e u  u    a  q pop   
delete e  
ch u   
foreach e   u   u
q push e  
p  u     
foreach e   u  u  
q push e  

algorithm   computes u  u  d u  labels   v      e   time space 
algorithm    update u  labels 
data  mdd  v  e   cost function c
d       d        
foreach   n           
foreach u vi
foreach e   u u 
d u    min d u   c e    d u    
u        u  r      
foreach              n
foreach u vi
foreach e   u u 
u  u      min u  u     c e    u  u  

computing valid domains  upstream downstream costs u  computed  efficiently compute valid domains vdi wrt  maximal cost bound k
since 
vdi  k     v e    u  u    c e    d u    k  e   u u    u vi  
   
achieved linear time traversal   v      e   shown algorithm   
algorithm    compute valid domains 
data  mdd  v  e   cost function c  maximal cost k
foreach              n
v di    
foreach u vi
foreach e   u u 
u  u    c e    d u    k
v di v di  v e   

hence overall interaction follows  given current partial assignment   mdd
restricted wrt  algorithm    labels u  computed algorithm  
valid domains computed using algorithm    execution algorithms
   

fiandersen  hadzic    pisinger

requires   v      e   time space  hence  mdd representation solution
space available  interactively enforce additive cost restrictions linear time
space 
    processing additive costs long edges
scheme extended mdds containing long edges  multivalued csp
models large domains space savings due long edges might significant 
binary models binary decision diagrams  bdds  significant savings possible 
furthermore  similar fashion  scheme might adopted versions
decision diagrams contain long edges  with different semantics  zero suppressed
bdds long edge implies skipped variables assigned   
recall reduced mdds  redundant nodes u vi di outgoing edges 
pointing node u    eliminated  edge e u  u    a  var u   
k var u      l long k       l  case  e encodes set solutions 
 a  dk         dl    labeling edges generalized accommodate
edges well  let domains dj    j              n represent variable domains updated wrt 
current assignment  i e  dj    dj xj unassigned  dj      xj    otherwise  edge
e u  u    a    var u    k  var u      l  removed   dk  analogous way mdd
pruning previous subsection  otherwise  labeled
c e    ck  a   

l 
x

j k  

min cj  a   

a  dj 

   

cost cheapest assignment xk           xl  consistent edge
partial assignment   edges labeled  upstream downstream costs
u  computed   v      e   time  manner previous subsection 
however  computing valid domains extended  before  sufficient condition
vd existence edge e   u u    originating i th layer u vi
v e   
u  u    c e    d u    k 
   
however  longer necessary condition  even edge satisfying     
could exist long edge skipping i th layer still allows vd   therefore 
layer i  compute cost cheapest path skipping layer 
p  i    min u  u    c e    d u      e   u u  e  var u      var u    

   

edge skipping i th layer  set p  i      let cmin  i  denote cheapest
value di    i e  cmin  i    minadi  ci  a   determine long edge allowing
vd   unassigned variable xi   following must hold 
p  i    ci  a  cmin  i  k

   

finally  sufficient necessary condition vd one conditions    
    holds  variable xi assigned value drawn valid domain previous
step  guaranteed v di     xi    calculations necessary  labels p  i 
   

fiinteractive cost configuration decision diagrams

algorithm    update p labels 
data  mdd  v  e   cost function c
p       
foreach              n
foreach u vi
foreach e   u u 
foreach j  var u               var u      
p  j    min p  j   u  u    c e    d u     

computed algorithm   worst case o  e  n  time  note bound
over pessimistic assumes every edge  e  skipping every variable x 

auxiliary structures u  d  p computed  valid domains efficiently
extracted using algorithm    unassigned variable xi   value di valid
domain vdi  k  iff following holds  condition     satisfied edge e u  u    a  e
condition     satisfied  non assigned variable i  algorithm first checks
value di whether supported skipping edge p  i   afterwards  scans
i th layer extracts
p values supported edges ei   achieved   d     v      e  
time   d    ni    di   
algorithm    computing valid domains v di  
data  mdd  v  e   cost function c  maximal cost k
foreach              n
v di    
xi assigned ai
v di  ai   
continue 
foreach di
p  i    ci  a  cmin  i  k
v di v di  a  
foreach u vi
foreach e   u u 
u  u    c e    d u    k
v di v di  v e   

again  overall interaction remains same  labels p incrementally updated
worst case o  e  n  time  valid domains extracted   d     v      e   time 
response changing cost restriction k  auxiliary labels need updated  valid
domains extracted directly using algorithm     d     v      e   time 
    handling non additive cost functions
certain interaction settings  cost function additive  example  user preferences might depend entire package features rather selection individual
feature  similarly  price product need simple sum costs individual
parts  might depend combinations parts selected  general  cost
   

fiandersen  hadzic    pisinger

function c x            xn   might sum non unary cost functions ci                k 
c x            xn    

k
x

ci  xi  

i  

cost function ci expresses unique contribution combination features within
subset variables xi x 

dj r 
ci  
jxi

      non unary labeling
approach extended handle non unary costs adopting labeling techniques
used graphical representations  e g   wilson 
      mateescu et al  
pk
       assume given cost function c x            xn     i   ci  xi    let a i  denote
set cost functions cj xi last variable scope cj  
a i     cj   xi xj xi    xj   i    i  
given assignment a a            ai   variables x            xi   evaluate every function cj
ai   scope cj strict subset  x            xi    set cj  a  value
u  u
cj  xj  a   xj  a  projection onto xj   now  every path p   r
vi     last edge  in i th layer  e ei   label e sum cost functions
become completely instantiated assigning xi   ai  
x
cj  p  
   
c e  p   
cj a i 

respect labeling  ap
cost solution represented path p would indeed
sum costs edges  ep c e  p   order apply approach developed
additive cost functions section      edge labeled cost
incoming path  however  possible general  therefore
expand original mdd  creating multiple copies e splitting incoming paths
ensure two paths p    p  sharing copy e  edge e induce edge
cost c e    p      c e    p     mdd  denoted mc   generated using example
search caching isomorphic nodes suggested wilson         extending
standard apply operator handle weights suggested mateescu et al         
      impact size
increase size mc relatively cost oblivious version depends additivity cost function c  example  fully additive cost functions  each scope
xi contains single variable  mc     since label c e  regardless
incoming path  however  entire cost function c single non additive component
c   x    global scope  x    x   edges last mdd layer labeled 
case explicit cost encoding mdd section      must least
c sol  edges last layer  one feasible cost  hence  range costs c sol 
   

fiinteractive cost configuration decision diagrams

exponential  size mc   furthermore  even c sol  limited size  increase mc might significant due breakup node isomorphisms previous layers 
case explicit cost encoding  section      effect demonstrated empirically
section    similar effect size would occur graphical representations 
example  representations exploiting global csp structure   weighted cluster trees
 pargamin          adding non additive cost functions increases size clusters 
required non additive component ci  xi   least one cluster contains
entire scope xi   furthermore  criteria node merging wilson        mateescu
et al         refined  since nodes longer isomorphic root
set feasible paths  paths must cost well 
      semiring costs probabilistic queries
note approach generalized accommodate general aggregation costs discussed wilson         cost functions ci need map assignments
xi variables set real numbers r set equipped operators
     a            semiring  mdd property computed
p r   ep c e   operator aggregates edge costs operator aggregates path costs 
semiring distributes   global computation done efficiently local node based aggregations  much shortest path computed  framework based
reasoning paths minimal cost corresponds using    r          min    
different semirings could used  particular  taking    r              
handle probabilistic reasoning  cost function ci corresponds conditional probability table  cost edge c e   e   u u  ei corresponds probability

q
p  xi   v e   given assignments p   r
u  cost path c p    ep c e 
probability event represented path 
pfor given value di  can
get marginal probability p  xi   a  computing e u u   a ei  u  u  c e  d u    

   compiling mdds
previous section showed implement cost queries solution space
represented mdd  section  discuss generate mdds
csp model description  x  d  f    goal develop efficient easy implement
approach handle instances handled previously bdd based configuration
 hadzic et al         
variable ordering  first step choose ordering csp variables x 
critical since different variable orders could lead exponential differences mdd size 
well investigated problem  especially binary decision diagrams  fixed
formula  deciding ordering resulting bdd would
nodes  for threshold   np hard problem  bollig   wegener         however 
well developed heuristics  either exploit structure input model
use variable swapping existing bdd improve ordering local search manner
 meinel   theobald         example  fan in weight heuristics popular
input form combinational circuits  input csp  reasonable heuristic
choose ordering minimizes path width corresponding constraint graph 
   

fiandersen  hadzic    pisinger

mdd worst case exponential path width  bodlaender        wilson       
mateescu et al          investigating heuristics variable ordering scope
work  remainder paper assume ordering already given 
experiments use default orderings provided instances 
compilation technique  approach first compile csp model binary
decision diagrams  bdd  exploiting highly optimized stable bdd packages  e g  
somenzi        afterwards extract corresponding mdd  dedicated mdd packages
rare  provide limited functionality implementations optimized
bdd packages offer competitive performance  miller   drechsler         interesting
recent alternative generate bdds search caching isomorphic nodes 
approach suggested huang darwiche        compile bdds cnf
formulas  proved valuable addition standard compilation based pairwise
bdd conjunctions  however  compilation technology still early stages
development open source implementation publicly available 
    bdd encoding
regardless bdd compilation method  finite domain csp variables x first
encoded boolean variables  choosing proper encoding important since
intermediate bdd might large inadequate subsequent extraction  general 
csp variable xi would encoded ki boolean variables  xi            xiki    di
mapped bit vector enci  a     a            aki         ki different
values    a  get different vectors enci  a     enci  a     several standard boolean
encodings multi valued variables  walsh         log encoding scheme xi
encoded ki   dlog di  e boolean variables  representing digit binary notation 
multivalued assignment xi   translated set assignments xij   aj
p j 
pki j 
  xj    di   added
aj   additionally  domain constraint kj  
 
j    


forbid bit assignments  a            aki   encode values outside domain di  
direct encoding  or   hot encoding  common  especially well suited efficient
propagation searching single solution  scheme  multi valued variable
xi encoded  di   boolean variables  xi            xiki    variable xij indicates
whether j th value domain aj di assigned  variable xi   exactly one
value di assigned  therefore  enforce domain constraint xi         xiki    
             n  hadzic  hansen  osullivan        empirically demonstrated
using log encoding rather direct encoding yields smaller bdds 
sn thei set boolean variables fixed union encoding variables  xb  
i    x            xki   still specify ordering  common ordering
well suited efficiently answering configuration queries clustered ordering  here 
boolean variables  xi            xiki   grouped blocks respect ordering among
finite domain variables x            xn   is 
xij     xij   i    i   i    i  j    j    
might orderings yield smaller bdds specific classes constraints 
bartzis bultan        shown linear arithmetic constraints represented
   

fiinteractive cost configuration decision diagrams

compactly boolean variables xij grouped wrt  bit position j rather
finite domain variable xi   i e  xij     xij   j    j   j    j  i    i     however 
configuration constraints involve linear arithmetic constraints  space savings
reported bartzis bultan        significant variable domains
size power two  furthermore  clustered orderings yield bdds
preserve essentially combinatorial structure allows us extract mdds
efficiently seen section     
example   recall t shirt example d                  d               d   
        log encoding variables x     x     x     x     x     inducing variable set
xb                    log bdd clustered variable ordering shown figure   a  

x 

x 
x 

       

x 

x 

x 

x 

x 

x 

 
x 

x 
x 

x 

   
 

x 
 

 

 

 a  log bdd 

  

x 

 b  extracted mdd 

figure    log bdd clustered ordering  extracted mdd t shirt example  bdd  draw terminal node   terminal node  
incoming edges omitted clarity  node corresponding boolean
encoding variable xij labeled corresponding csp variable xi   edges
labeled     drawn dashed full lines  respectively 

    mdd extraction
bdd generated using clustered variable ordering extract corresponding
mdd using method originally suggested hadzic andersen       
subsequently expanded hadzic et al          following considerations 
use mapping cvar xij     denote csp variable xi encoding variable
xij and  slight abuse notation  apply cvar bdd nodes u labeled
xij   terminal nodes  define cvar      cvar      n      recall bdd two
terminal nodes     indicating false true respectively   analogously  use
mapping pos xij     j denote position bit variable encoding 
method based recognizing subset bdd nodes captures core
mdd structure  used directly construct corresponding mdd 
   

fiandersen  hadzic    pisinger

block bdd layers corresponding csp variable xi   li   vxi       vxi  
 
ki
suffices consider nodes reachable edge previous block
layers 
ini    u li    u   u e cvar u      cvar u   

 
 
first layer
sn  we take in     r   resulting mdd  v   e   contains nodes
 
ini   v   i   ini constructed using extraction algorithm    edge e u  u    a 
added e   whenever traversing bdd b u wrt  encoding ends u       
traversals executed using algorithm    starting u  step algorithm
traverses bdd taking low branch corresponding bit ai     high branch
ai      traversal takes ki steps  terminating soon reaches node
labeled different csp variable  mdd extracted log bdd figure   a 
shown figure   b  

algorithm    extract mdd 
data  bdd b v  e 
e      v    r  
foreach              n
foreach u ini
foreach di
 
u  traverse u  a  
u      
e   e     u  u    a   
v   v    u   
return  v     e     

algorithm    traverse bdd 
data  bdd b v  e   u 
cvar u  
 a            aki   enci  v  
repeat
pos u  
   
u low u  
else
u high u  
cvar u      
return u 

since traversal  in linep
  algorithm    takes o dlog di  e  steps  running time
mdd extraction
o  ni    ini    di   dlog di  e   resulting mdd  v     e    
pn
o  i    ini    di    edges
pnadd  di   edges every node
 
u ini   since keep nodes ini    v     i    ini    v   
    input model implementation details

important factor usability approach easiness specifying input
csp model  bdd packages callable libraries default support csp like input
language  best knowledge  open source bdd compilation tool
   

fiinteractive cost configuration decision diagrams

accepts input csp like model clab  jensen         configuration interface
top bdd package buddy  lind nielsen         clab constructs bdd
input constraint conjoins get final bdd  furthermore clab generates
bdd using log encoding clustered ordering suits well extraction approach 
therefore  compilation approach based using clab specify input model
generate bdd used extraction algorithm   
note extracting mdd  preprocess efficient online querying 
expand long edges merge isomorphic nodes get merged mdd 
translate efficient form online processing  rename bdd node names
indexes             v    root index   terminal   index  v   
allows subsequent efficient implementation u labels  well efficient
access children parent edges node  initial experiments got order
magnitude speed up wcvd queries switched bdd node names  which
required using less efficient mapping u   d  ch p structures  

   interactive configuration multiple costs
number domains  user configure presence multiple cost functions
express often conflicting objectives user wants achieve simultaneously 
example  configuring product  user wants minimize price  maximizing quality  reducing ecological impact  shortening delivery time etc  assume
therefore addition csp model  x  d  f   whose solution space represented
merged mdd   given k additive cost functions
ci  x            xn    

n
x

cij  xi                k

j  

expressing multiple objectives  multi cost scenarios often considered within multicriteria optimization framework  figueira et al         ehrgott   gandibleux        
usually assumed optimal  but unknown  way aggregate multiple
objectives single objective function would lead solution achieves
best balance satisfying various objectives  algorithms sample efficient solutions
 nondominated wrt  objective criteria  display user  user input 
algorithms learn aggregate objectives adequately used
next sampling efficient solutions etc  approaches user asked explicitly
assign
pkweights wi objectives ci aggregated weighted summation
c   i   wi ci  
adopting techniques run compiled representation solution space
would immediately improve complexity guarantees would useful many scenarios multi criteria techniques traditionally used  believe configuration
setting  explicit control variable values needed  user easily explore
effect assigning various variable values variables well cost functions 
therefore suggest directly extend wcvd query user could explore
effect cost restrictions way explores interactions regular variables  key query want deliver computing valid domains wrt  multiple cost
restrictions 
   

fiandersen  hadzic    pisinger

definition    k wcvd  given csp model  x  d  f    additive cost functions cj   r 
maximal costs kj   j              k  given partial assignment   compute 
vd     kj  kj        a di            f   xi   a    

k
 

j  

cj      kj   

particularly interested two cost configuration likely occur
practice strong connections existing research solving knapsack problems
multi criteria optimization  reminder section first discuss
complexity   wcvd queries develop practical implementation approach 
discuss general k wcvd query 
    complexity   wcvd query
assume input problem merged mdd   additive cost
functions c    c  cost bounds k    k    first question whether possible
restricted forms additive cost functions c    c  implement   wcvd polynomial
time  purpose formulate decision version   wcvd problem 
problem      wcvd sat  given csp  x  d  f   mdd
pnm representation solution space  given two additive cost functions ci  x    j   cij  xj           cost
restrictions k    k    decide whether f c   x  k  c   x  k  satisfiable 
unfortunately  answer even constraints involve positive coefficients 
binary domains  show reduce well known two partition
problem  tpp  np hard  garey   johnson         given set positive
integers    s            sn    tpp asks decide whether possible split set
indexes
 p            n  two sets   sum set same 
p

ii a si  
ia  

proposition     wcvd sat problem defined boolean variables involving
linear cost functions positive coefficients np hard 

proof   show stated reduction tpp  order reduce tpp two cost
configuration introduce  n binary variables x            x n
x i        x i      construct mdd f  
 x     x p
          x n     x n   introduce
p two linear cost functions positive coefficients 
c   x    ni   si p
x i  c   x    ni   si x i   overall capacity constraints set
k    k   
ii si     setting    i   x i       easily seen
f c   x  k  c   x  k  satisfiable tpp feasible solution 
hence  able solve   wcvd sat boolean variables positive linear cost
functions polynomial time  would able solve tpp problem polynomially 
    pseudo polynomial scheme   wcvd
previous subsection demonstrated answering   wcvd queries np hard even
simplest class positive linear cost functions boolean domains  hence 
   

fiinteractive cost configuration decision diagrams

hope solving   wcvd guaranteed polynomial execution time unless p   n p  
however  still want provide practical solution   wcvd problem  hope
avoid worst case performance exploiting specific nature cost functions
processing  subsection therefore show   wcvd solved pseudopolynomial time extending labeling approach section      furthermore 
show adopt advanced techniques used knapsack problem  kellerer  pferschy 
  pisinger        
      overall approach
algorithm runs analogous single cost approach developed section     
restricting mdd wrt  current assignment  calculate upstream downstream
costs u   which longer constants lists tuples   use check
edge e  whether v e  valid domain 
given edge e   u u    labeled costs c   e   c   e   follows v e  v di iff
paths p   r
u  p    u 
  c   p    c   e    c   p    k 
 
c   p    c   e    c   p   k    node u suffices store two sets labels 
u  u      c   p   c   p     p   r

u 

d u      c   p   c   p     p   u

  

then  given cost restrictions k    k    edge e   u u    u vi   domain v di  k    k   
contains v e   a    a    u  u   b    b    d u  holds
a    c   e    b  k  a    c   e    b  k 

   

      exploiting pareto optimality
single cost case sufficient store u  u   d u  minimal value
 the cost shortest path root terminal   multi cost case need store multiple
tuples  immediate extension would require storing k  k  tuples node 
however  need store non dominated tuples u lists  two
tuples  a    a     a     a     list
a  a   a  a  
may delete  a     a     test     succeeds  a     a     succeed  a    a    
remaining entries costs pareto optimal solutions  solution pareto optimal
wrt  solution set cost functions c    c  possible find cheaper solution
respect one cost without increasing other  path p   r
  represents
pareto optimal solution sol iff node u path  sub paths p    r
u
p    u
  pareto optimal wrt  sets paths  p   r
u   p   u
  
respectively  hence  node u suffices store 
u  u      c   p   c   p     p   r

u  p   r

u  c   p 

c   p     c   p  c   p     

d u      c   p   c   p     p   u

   p   u

   c   p 

c   p     c   p  c   p     

   

fiandersen  hadzic    pisinger

note due pareto optimality  a              k    a              k   
one tuple u first coordinate a  second
coordinate a    therefore  node u  u  u  d u  min k    k   
entries  hence  space requirements algorithmic scheme worst case o  v  k 
k   min k    k    
      computing u sets
discuss compute u sets efficiently utilizing advanced
techniques solving knapsack problems  kellerer et al          recursively update u
sets layer layer manner shown algorithm    critical component
recursion step algorithm merging lists lines      operation
new list formed dominated tuples detected eliminated  order
efficiently  critical keep u lists sorted wrt  first coordinate 
i e 
 a    a     a     a     a    a   
u sorted  merged o k  time using list merging algorithm
knapsack optimization  kellerer et al         section      
algorithm    update u  labels 

 
 

 
 

data  mdd   cost functions c    c    bounds k    k 
u              u  r             
foreach              n
foreach u vi
foreach e   u u 
 
foreach  a    a    u  u 
a    c   e  k  a    c   e  k 
 a    c   e   a    c   e   
u  u    ergelists s  u  u     
d             d               
foreach   n           
foreach u vi
foreach e   u u 
 
foreach  a    a    d u   
a    c   e  k  a    c   e  k 
 a    c   e   a    c   e   
d u  ergelists s  d u   

time complexity determined populating list  in lines      merging
 in lines       updates takes o k  worst case  since perform
updates edge e e  total time complexity algorithm   o  e  k 
worst case 
   

fiinteractive cost configuration decision diagrams

      valid domains computation
u  sets updated extract valid domains straightforward manner
using algorithm    edge e   u u  algorithm evaluates whether v e  v di
worst case o  u  u    d u        o k     steps  hence  valid domain extraction takes worst
case o  e  k     steps 
algorithm    compute valid domains 
data  mdd   cost functions c    c    cost bounds k    k    labels u  d
foreach              n
vdi  
foreach u vi
foreach e   u u 
foreach  a    a    u  u    b    b    d u   
a    c   e    b  k  a    c   e    b  k 
vdi vdi  v e   
break 

however  improve running time valid domains computation exploiting
    pareto optimality     fact sets u  sorted  critical observe
given edge e   u u     a    a    u  u  suffices perform validity
test     tuple  b    b    d u     b  maximal first coordinate satisfying
a    c   e    b  k    i e 
b    max b     b    b    d u     a    c   e    b  k    

namely  test succeeds  b     b     b     b    succeed  b    b   
since due pareto optimality  b     b  b    b   hence a   c   e  b    a   c   e  b  
k    since lists sorted  comparing relevant tuples performed efficiently
traversing u  u  increasing order  traversing d u    decreasing order  algorithm
   implements procedure 
algorithm     extract edge value 

 
 

data  mdd   cost constraints c    c    bounds k    k    edge e   u u  ei
a a    a      u  u  begin   
b b    b      d u    end   
     b   
a    c   e    b    k 
b b    b    d u    previous   
continue 
else a    c   e    b  k  a    c   e    b  k 
vdi vdi  v e   
return 
a a    a    u  u  next   

algorithm relies several list operations  given list l sorted tuples  operations
l begin   l end   return first last tuple respectively wrt  list ordering 
   

fiandersen  hadzic    pisinger

operations l next   l previous   return next previous element
list wrt  ordering  elements   indicate two special elements appear
last first element list respectively  indicate
passed beyond boundary list  algorithm terminates  line    soon
test succeeds  otherwise  keeps iterating tuples processed either
last tuple u  u  first tuple d u     case algorithm terminates
guaranteed v e    v di   step  traverse least one element
u  u  d u     hence  total execute u  u    d u     k operations 
therefore  time complexity single edge traversal o k  complexity valid
domains computation algorithm    after replacing quadratic loop algorithm
    o  e  k  k   min k    k    
conclusion  developed pseudo polynomial scheme computing valid domains wrt  two cost functions    wcvd   space complexity dominated storing u
sets node  worst case store o  v   k  entries  time
complexity compute u labels extract valid domains takes o  e  k  steps 
overall interaction similar single cost approach  assigning variable 
recompute labels well extract domains  tighten cost restrictions
k    k  k   k    k   k  need extract domains  however  relax either
cost restrictions  k     k  need recompute labels well 
precisely  labels u  need recomputed k    k max k max initial
cost restriction last assignment 
      extensions
note approach can  principle  extended handle general k wcvd query
fixed k  lists u would contain set non dominated k tuples  ordered that 
 a            ak    a             a k   iff smallest coordinate j aj    a j holds aj   a j  
list merging well valid domains extraction would directly generalized
operate ordered sets  although time complexity testing dominans
increase  worst case complexity would depend size efficient frontier 
k cost functions cost bounds k bounded o k k     practice however 
could expect number non dominated tuples much smaller  especially cost
functions smaller scopes smaller coefficients  note approach
extended accommodate non additive cost functions expanding mdd
accommodate non unary labels fashion discussed section     
    approximation scheme   wcvd
subsection analyze complexity answering   wcvd queries approximative
manner  i e  improve running time guarantees settling approximate
solution  assume one constraints k  fixed second constraint may
exceeded small tolerance     k    example  user might willing tolerate
small increase price long strict quality restrictions met  section present
fully polynomial time approximation scheme  fptas  calculating valid domains
time o en     problem  fptas satisfy feasible solution
respect original costs fathomed  feasible configuration found
   

fiinteractive cost configuration decision diagrams

use fptas domain restriction satisfy cost constraint within
      k    finally  fptas running time polynomial    input
size 
order develop fptas use standard scaling technique  schuurman  
woeginger        originally presented ibarra kim         given   let n
number decision variables  set   k    n      determine new costs c   e   
bc   e  t c new bounds k    dk   t e  perform valid domains computation
 label updating domain extraction  described section      using scaled weights 
following propositions prove obtained fptas scheme 
proposition   running time valid domains computation o    en 
proof   may assume k    k  otherwise may interchange two costs 
running time becomes
 
n  
    o en  
o e k      o ek   t     o ek 
k 

since n v polynomial input size o v   e  precision    
proposition   solution feasible respect original costs 
feasible respect scaled costs 
p
proof   assume ep c   e  k   
x
x
 
 
 x
c   e  k  k  e   k 
c   e   
bc   e  t c
ep


ep
ep
proposition   solution feasible respect scaled costs c   e  satisfies
original constraints within       k   
p
proof   assume ep c   e  c   
p
p
p
p
ep c   e    n
ep  bc   e  t c     
ep c   e  t
ep c   e   
k    n   dk   t e   n  k   t        n

  k     n     

since   k    n      get
x
c   e  k     n     k    n              k 
ep

shows stated 

time complexity improved using techniques kellerer et al        
knapsack problem  interested showing existence
fptas 
considerations previous subsections fully analyzed complexity
answering   wcvd queries  first showed np hard problem 
developed pseudo polynomial scheme solving it  finally devised fully polynomial time approximation scheme  even though cannot provide polynomial running time
guarantees  based considerations  hope provide reasonable performance
practical instances  demonstrated section   
   

fiandersen  hadzic    pisinger

    complexity k wcvd query
conclude section discussing complexity general k wcvd queries 
practical implementation efforts focused implementing   wcvd queries  wcvd
queries number cost constraints known advance  completeness
consider generic problem delivering k wcvd arbitrary k  i e  k part
input problem 
prove problem pseudo polynomial scheme unless
np p  show decision version problem k wcvd sat np hard
strong sense  garey   johnson        reduction bin packing problem  bpp 
strongly np hard  garey   johnson         decision form bpp asks
whether given set numbers s            sn placed k bins size k each  notice 
cannot use reduction showing np hardness   wcvd sat  since k
part input bpp 
theorem   k wcvd sat problem variable k  strongly np hard 
proof   given instance bpp reduce k wcvd sat instance follows 
construct mdd csp  x  d  f   n variables x    x            xn  
domain size k  di               k                n  set f     resulting mdd
allows assignments  n nonterminal nodes u            un corresponding numbers
s            sn   two nodes ui   ui   k edges costs  c   e   c   e           ck  e  
set
 si                      si                         si                                      si   
first node u  root u    r last node un connected terminal
un        overall capacity constraints  k            kk      k          k  
easily seen may find path r   bpp
feasible solution  since bpp strongly np hard shown k wcvd sat
strongly np hard 

   experimental evaluation
implemented compilation scheme algorithms wcvd   wcvd queries 
performed number experiments evaluate applicability approach
well confirm various hypotheses made throughout paper  used two sets
instances whose properties presented table    first set corresponds real world
configuration problems available configuration benchmarks library clib    csp
models configuration constraints  correspond highly structured configuration
problems huge number similar solutions  second set instances represents
product catalogue datasets used nicholson  bridge  wilson         catalogues
defined explicitly  tables solutions  represent much smaller sparser set
solutions 
   http   www itu dk research cla externals clib 

   

fiinteractive cost configuration decision diagrams

instance
esvs
fs
bike 
pc 
pc
big pc
renault
travel
laptops
cameras
lettings

sol
   
   
   
   
   
   
   
    
   
   
   

x
  
  
  
  
  
   
  
 
  
 
 

dmin
 
 
 
 
 
 
 
 
 
 
 

dmax
  
  
  
  
  
  
  
   
   
   
   

davg
 
 
 
 
 
  
 
   
  
  
  

table    first seven instances real world configuration problems available configuration benchmarks library clib  remaining four instances product catalogues
used nicholson et al          instance provide number solutions sol  number variables x  minimal  maximal average domain
size 

    mdd size
first set experiments  instance generated log encoded bdd b using
clab  jensen         extracted corresponding mdd b  finally 
expanded long edges merged isomorphic nodes generate merged mdd    
compare sizes b    table    structure provide number
nodes v edges e  provide size bdd b  conclude
table bdds mdds exponentially smaller size solution
space configuration instances significantly smaller diverse product
configuration catalogues  furthermore  see number edges merged
mdds   significantly larger comparison extracted mdds   hence  due
simpler online algorithms  using merged mdds seems well suited online reasoning 
see multi valued encoding many cases reduces number nodes
edges comparison bdds  even though compilation times less important since
generation mdd performed offline  worth noting largest instance 
renault  took around  min   sec compile instance bdd extract
mdd 
      encoding cost explicitly
investigated impact encoding cost information explicitly mdd 
instance compared size mdd without cost variables  m
c respectively   configuration
benchmarks introduce additional variable
p
             ni   ai xi coefficients ai randomly drawn
interval          put variable last ordering since positions
get mdds similar size  putting end allows easier theoretical analysis  since
   

fiandersen  hadzic    pisinger

instance
esvs
fs
bike 
pc 
pc
big pc
renault
travel
laptops
cameras
lettings

vb
   
     
     
      
      
       
       
    
    
    
    

eb
   
     
     
      
      
       
       
      
      
     
     

kb
 
  
  
   
   
     
     
   
   
  
  

vm
  
   
   
     
    
       
       
    
    
   
   

em
   
     
     
     
    
       
       
    
    
   
    

vm 
  
   
   
    
    
       
       
    
    
   
   

em 
   
    
    
    
    
       
       
    
    
   
    

table    comparison bdds mdds instances table    second 
third fourth column give number non terminal bdd nodes vb  
number edges eb size disk bdd kilobytes kb  fifth
sixth column give number vertices vm edges em mdd
extracted bdd using algorithm   page      final two columns
provide number nodes edges merged mdd  m     long
edges extracted mdd expanded 

product catalogues already contain cost variable  price   produce cost oblivious
version existentially quantifying y    c  
table   compare mdds c   structures provide number
edges well representation size kilobytes  show size cost range
c sol   observe configuration instances high level sharing
compression  introducing cost information explicitly induces order magnitude increase
size even cost range c sol  limited      times increase bike  instance  
mdds two largest instances could generated  however  product catalogues
much less sharing  removing cost information dramatic effect 
worst case  number edges c two times larger   hence 
experimental results confirm introducing cost explicitly could dramatic effect
mdd representations highly compressed solution spaces  usually implicitly defined
conjunction combinatorial constraints  however  effect adding explicit cost
information might modest solution space defined explicitly   sparse  list
database entries  case product catalogues  furthermore  size
cost range c sol  needs significant large increase size take place 
    response times wcvd queries
second set experiments  evaluated performance wcvd queries merged
mdd representations configuration instances  report running times
computing u labels  algorithm    well computing valid domains  algorithm    
table   report average worst case running times initial merged mdds
   

fiinteractive cost configuration decision diagrams

instance
esvs
fs
bike 
pc 
pc
big pc
renault
travel
laptops
cameras
lettings

e
   
     
     
     
     
       
       
    
    
   
   

kb
 
  
  
   
   
     
     
  
  
  
 

ec
       
       
       
         
         
    
    
   
    

kb
     
      
      
      
      
   
   
  
  

c sol 
     
     
     
     
     
   
   
   
   

table    effect explicitly encoding cost information  second third column indicate number edges representation size kilobytes cost oblivious
mdd  fourth fifth column show mdd containing
cost information  column c sol  indicates range available costs
solutions 

table    report time necessary restrict mdd wrt  assignment
 algorithm     randomly create additive cost function c assigning variable
xi value di cost ci  a           valid domains computed wrt 
maximal cost restriction k set value larger length longest
mdd path wrt  cost function c  ensures longest execution time algorithm   
data point table average maximum      executions fedora
  operating system  using dual quad core intel xeon processor running      ghz 
one core used instance  empirical evaluation demonstrates response times
easily within acceptable interaction bounds even largest instances  worst
case mdd nodes labeled within      seconds  valid domains computed within
     seconds mdd restricted wrt  assignment within      seconds 
    response times   wcvd query
generated analogous statistics   wcvd table    tested performance
algorithms computationally demanding circumstances  operate
original  fully sized  mdd  even though interaction would reduced due
user assignments  furthermore  cost functions c    c  global scope 
use cost restrictions computing u labels  i e  ignore condition
line   algorithm    hence  u     d r  correspond entire efficient frontier  
normally  cost functions would involve subset variables fraction
labels efficient frontier  within restrictions k    k    would relevant user 
generate cost functions c    c  drawing costs ci  a  randomly          computing
valid domains  use restrictions k    k  larger lengths corresponding longest
   

fiandersen  hadzic    pisinger

instance
esvs
fs
bike 
pc 
pc
big pc
renault

labeling u 
avg
max
      
    
      
    
      
    
      
    
      
    
      
    
      
    

valid domain
avg
max
      
    
      
    
      
    
      
    
      
    
      
    
      
    

restrict
avg
max
           
           
           
           
           
           
           

table    interaction time seconds wcvd queries  report time required computing u labels  valid domain computation restriction wrt  single
assignment 

paths  possible solutions efficient frontier allowed  would lead
longest execution time algorithm   
algorithms easily handle first five instances  largest two instances 
u labels known  calculating valid domains done within fraction
second  hence  user efficiently explore effect various cost restrictions k    k  wrt 
fixed partial assignment  user assigns variable  recomputing u labels
takes total average less      seconds  worst case less     seconds 
already within acceptable interaction times  usability system
enhanced  e g  using layered display information  always reacting
information fastest compute  such cvd wcvd   user analyzing
it  execute time consuming operations  particular  entire efficient frontier
known soon u labels generated worst case within      seconds 
stage  user explore cost space labels computed  on average within
next      seconds   note running times reduced number
additional schemes  e g  computing u labels parallel  two processors
present 

instance
esvs
fs
bike 
pc 
pc
big pc
renault

labeling u
avg
max
           
           
           
           
           
           
           

labeling
avg
max
           
           
           
           
           
           
           

valid domain
avg
max
      
    
      
    
      
    
      
    
      
    
      
    
      
    

table    interaction time seconds   wcvd query 

   

fiinteractive cost configuration decision diagrams

empirical evaluation demonstrates practical value approach  even
np hard   wcvd query implemented response times suitable interactive use 
applied huge configuration instances  note  however  order achieve
performance critical optimize mdd implementation well utilize advanced
list operation techniques  initial implementation efforts failed so  led
response times measured tens seconds largest instances 

   related work
several directions related work  large variety representations
investigated area knowledge compilation might suitable supporting
interactive decision making cost restrictions  number approaches
handle multiple cost functions multi criteria optimization 
    compiled knowledge representation forms
paper used binary decision diagrams  bdds  multi valued decision diagrams
 mdds  compiled representations csp model  however  might compiled representations might suitable supporting interactive configuration 
compiled representation supports efficient consistency checking conditioning
would theory support polytime interactive configuration  calculate valid domains
suffices value restrict representation check consistent  representation supports efficient optimization conditioning would support polytime
cost restrictions  would suffice restrict representation value check
minimum smaller threshold value  therefore briefly survey
related compiled representations evaluate suitability framework 
knowledge compilation structures  probably well known framework
comparing various compiled forms propositional theories based viewing
special classes negation normal form  nnf  languages  darwiche   marquis        
nnfs directed acyclic graphs internal nodes associated conjunctions   
disjunctions     leaf nodes labeled literals  x x  constants true
false  imposing various restrictions get subclasses nnf languages support
efficient execution various queries transformations  restrictive representations
less succinct i e  exponentially larger instances  support
larger number queries transformations polytime  comprehensive overview
representations presented darwiche marquis        
critical restriction makes nnf languages tractable decomposability 
exploits variable independencies enforcing children  node nonoverlapping
variable scopes  hence  propositional formula f   f  f 
var f    var f        evaluate satisfiability f suffices independently evaluate
f  f    resulting language decomposable negation normal form  dnnf 
already supports polytime two operations critical calculating valid domains  consistency checking conditioning  however  general dnnf compiler exists  current
compilation approach based exhaustive dpll search caching isomorphic nodes
 huang   darwiche        constructs subsets dnnf satisfy additional property
   

fiandersen  hadzic    pisinger

determinism  two children  node mutually exclusive  resulting structure called deterministic decomposable negation normal form  d dnnf   structure
would interesting target cost configuration  boolean csp models  additive
cost functions could efficiently optimized d dnnfs  multi valued models however  research necessary encode finite domain values way allows
efficient cost processing  tool support compiling d dnnfs far takes input
cnf formulas  unaware extensions allowing direct compilation general
csp models 
known knowledge representation forms retrieved enforcing additional
properties  example  enforcing nodes decision nodes
variable encountered path  read once property  get free
bdds  fbdds   enforcing decision nodes appear wrt  fixed ordering get
ordered bdds  obdds   fact  d dnnf compiler huang darwiche       
specialized compile obdds  proved valuable alternative way bdd
compilation 
weighted multi valued knowledge compilation structures  compiled representations propositional theories valued counterparts  many
seen special cases valued nnfs  vnnf   fargier   marquis         roughly  every
valued counterpart obtained changing semantics nodes  logical operators
 such     general operators  that could arithmetic       values
functions represented structures longer        r  furthermore 
functions need defined boolean domains  could take finite domain values 
general  subsets vnnf satisfy decomposability operator distributivity support
efficient optimization  fargier   marquis        could  principle  used support
cost configuration 
construction mdds based encoding bdds discussed srinivasan 
kam  malik  brayton         amilhastre et al         augmented automata vempaty        edge weights reason optimal restorations explanations 
weighted extensions correspond closely weighted mdds since variant automata
used vempaty        equivalent merged mdds  hadzic et al          however 
weights used compute different queries generate mdds based widely
available bdd packages  vempaty        report compilation tools used  semiring
labeled decision diagrams  sldds   wilson        label edges  unordered  mdd
values semiring allow computation number queries relevant reasoning
uncertainty  due relaxed ordering  sldds succinct weighted
mdds therefore attractive target cost based configuration  however 
proposal seems theoretic  seem implemented  arithmetic
circuits directed acyclic graphs internal nodes labeled summation
multiplication operators leaf nodes labeled constants variables  darwiche 
       could seen valued extension d dnnfs hence succinct
sldds  furthermore  support efficient optimization coefficients
positive  in bayesian context   support efficient computing probable explanations   compilation technology acs directly applicable general csp models 
used primarily representing bayesian networks  based compiling d dnnfs
tree clustering approaches  darwiche               context  acs might use   

fiinteractive cost configuration decision diagrams

ful optimizing non additive objective functions multiplicative coefficients
multi linear functions induced bayesian networks  however  purely propositional
constraints additive cost function optimized  purely propositional
representation form  such d dnnf  would adequate  furthermore  efficient optimization queries based acs implicitly assume constants  at leaf nodes 
positive  case modeling bayesian networks  hold general
cost functions 
global structure approaches  number techniques based tree clustering  dechter
  pearl        variable elimination  dechter        exploit variable independencies
present globally csp model  time space complexity techniques
turn bounded exponentially size important graph connectivity notion
tree width  bodlaender         techniques geared towards enhancing search single  optimal  solution  adaptive consistency  bucket elimination etc  
concepts utilized compiling representations solutions  and or
mdds  mateescu et al         restricted boolean variables subset d dnnf
formulas  variable labeling respects pseudo tree obtained variable elimination
order  due utilization variable independencies  nodes  succinct mdds therefore attractive compilation target cost configuration 
furthermore  already extended handle weighted graphical models support
bayesian reasoning  however  publicly available tool support limited allow
processing weighted cvd queries  tree driven automata  fargier   vilarem        utilize
tree clustering  dechter   pearl         generate partial variable ordering used
generate automaton  tree driven automata equivalent and or mdds
restricted boolean case represent subset d dnnf languages called
strongly ordered decomposable decision graphs  so ddg   fargier   marquis        
and or mdds succinct mdds therefore interesting target
cost configuration  however  tools compiling tree driven automata yet become publicly available  far extended handle costs  weighted
cluster trees pargamin        weighted extension cluster trees used support
interactive configuration preferences  however  publicly available compilation tool  an internal company based implementation presented   clusters
represented explicitly without utilizing compressions based local structure decision diagrams compiled representations  tree of bdds  tob   subbarayan       
directly exploit tree clustering representing cluster bdd  however 
support conditioning polytime fundamental transformation supporting user
interaction  assigning variables   however  compiled instances
d dnnf compilation fails  empirical evaluation shows average conditioning
times short 
bdd extensions  large variety weighted extensions binary decision diagrams  represent real valued functions f         n r rather boolean functions
f         n         extensions limited boolean variables adoption
future would consider encoding techniques multi valued variables avoid explosion size support cost processing  comprehensive overviews extensions
presented drechsler         wegener         meinel theobald         immediate extension form algebraic decision diagrams  adds   bahar  frohm  gaona 
   

fiandersen  hadzic    pisinger

hachtel  macii  pardo    somenzi         known multi terminal bdds  mtbdds  
essentially bdds multiple terminal nodes   one cost value 
structure oblivious approach encoding cost  much approach explicitly encoding
cost variable  size grows quickly increase number terminals  therefore number bdd extensions introduced based labeling edges weights 
differ mostly cost operators decomposition types associated nodes  edge valued
bdds  evbdds   lai   sastry        label every edge additive cost value c e 
edge e   u u    value val u    c e    val u    v e       otherwise
val u    val u      factored evbdds  fevbdds   tafertshofer   pedram        introduce multiplicative weights  v e       value val u    c e    w e  val u   
 otherwise val u    val u      affine adds  aadds  sanner mcallester       
introduce additive multiplicative edge weights edge  regardless v e   
val u    c e    w e  val u    every edge  shown aadds
special case valued nnfs  fargier   marquis        
orthogonal extension bdds change decomposition type nodes  obdds
based shannon decomposition fu   xi fu  xi fu    change decomposition
type positive davio  pd  decomposition fu   f  xi f  negative davio nd  decomposition fu   f  xi f    using pd decomposition get ordered functional decision
diagrams  ofdds   kebschull   rosenstiel         structures incomparable
obdds  i e  might exponentially larger smaller obdds depending
instance  however  ordered kronecker functional decision diagrams  okfdds  drechsler 
sarabi  theobald  becker    perkowski        allow three decomposition types  thus generalizing obdds ofdds  extending ofdds additive edge weights leads
binary moment diagrams  bmds   bryant   chen         adding multiplicative
edge weights leads multiplicative binary moment diagrams   bm ds   analogously 
extending okfdds additive multiplicative edge weights get kronecker binary
moment diagrams  kbmds  k bm ds respectively  drechsler  becker    ruppertz 
      
unclear whether boolean structures advanced cost labeling schemes
used directly represent multi valued csp models cost functions  however  could
compare generalizations labeling schemes multi valued structures  multivalued generalization evbdds would correspond roughly weighted mdds  however  introducing additive multiplicative weights aadds would correspond
generalization labeling scheme could prove useful labeling multilinear cost functions  namely  introduction multiplicative weights would
subgraph sharing  many nodes would refined accommodate non additive costs  however  due multiplicative factors  obvious
cashing technique based computing u  directly extended  especially
coefficients negative  case additive cost functions though  schemes
would correspond labeling scheme  structures pay price less
efficient operators  such apply operator  larger memory requirements maintain information  therefore  compiling boolean functions  using structures
would pose unnecessary overhead comparison obdds  hence  models
large number propositional  configuration  constraints  additive cost function 
would gain compiling using structures even boolean case 
   

fiinteractive cost configuration decision diagrams

cost function non additive  introducing elaborate cost representations might
prove beneficial reducing memory requirements  might make label computing
technique unapplicable  practical point view  implementations
supporting boolean versions structures  aware tool supporting
multi valued generalizations structures input language format used
specifying general propositional constraints 
    multi objective cost processing
multiple cost configuration close approaches within framework multi criteria
optimization decision maker find solution subject multiple  often conflicting  objectives  figueira et al         ehrgott   gandibleux         particular 
mdd based algorithms close approaches solving multiobjective shortest
path problem  given graph  v  e  arc labeled multiple costs 
goal typically compute set pareto optimal  efficient  non dominated  solutions
 ehrgott   gandibleux        muller hannemann   weihe        tarapata        reinhardt   pisinger         shown multi objective shortest path problem
intractable  particular  number pareto optimal solutions grow exponentially number vertices  v    fptas  fully polynomial time approximation
scheme  developed approximating set pareto optimal solutions  however  way solution space multi criteria optimization problems explored
significantly different approach  typically  interaction step subset
pareto optimal solutions computed afterwards decision maker interactively navigates set order reach satisfying compromising solution  interactive
methods multi criteria optimization usually compute subset solutions efficient
frontier  suggest user evaluation  based input compute new set
solutions  figueira et al         chapter      techniques would use user input
better estimate way aggregate multiple objectives  would require
user explicitly assign weights importance objectives  contrast  instead primarily driven costs solutions  interactive approach supports reasoning
variable assignments solutions valid domains computation  inherently different way exploring solution space adequate
users want explicit control variable assignments indicating
importance cost functions 
approaches csp community model preferences soft constraints
 meseguer  rossi    shiex        partially satisfied violated  goal
find satisfying least violating solution  usually presupposes preferences aggregated via algebraic operators  related single cost
optimization problems  however  approach rollon larrosa        deals
multiple costs explicitly  utilizes global structure  i e  variable independencies 
weighted csp model compute efficient frontier bucket based variable elimination  highly related approach utilizes global structure generalized additive
independence  gai  network presented dubus  gonzales  perny         order
compute efficient frontier  authors use message passing computation mechanism analogous computing buckets  addition  authors develop fully
   

fiandersen  hadzic    pisinger

polynomial approximation scheme approximate efficient frontier demonstrate
significant improvement performance  however  neither methods exploit
fact solution space hard constraints available compiled representation 
instead  methods operate unprocessed model specification  whether
weighted csp gai network  treating hard soft constraints uniformly
hence allowing scope hard constraints decrease variable independencies
model  and thus decrease performance algorithms   furthermore  result
computation methods allow full exploration efficient solutions 
value frontier single supporting efficient solution maintained
maintain efficient value set supporting efficient solutions  hence 
possible efficiently retrieve valid domains even algorithms terminate  would
interesting see however  whether methods could adopted work mdd
representations solution space 
knapsack constraints special case two cost configuration problems universally true mdd  trick        used dynamic programming propagate knapsack constraints csp search  fahle sellmann        presented approximated filtering
algorithm  based various integer programming bounds knapsack problem  sellmann        presented fully polynomial time approximation algorithm approximated
filtering  however  techniques considered constraint propagation context
none considered processing existing mdd structure 

   conclusions future work
paper presented extension bdd based interactive configuration configuring presence cost restrictions  guarantee polynomial time cost configuration
cost function additive feasible solutions represented using multi valued
decision diagram  process cost restrictions mdd extracted
underlying bdd  therefore strictly extend bdd based configuration hadzic et al 
       support cost bounding additive cost functions without incurring exponential
increase complexity  implementation delivers running times easily satisfy interactive response time requirements  furthermore  approach extended support
bounding presence non additive semiring based costs 
extended approach considering cost bounding wrt  multiple costs 
proved np hard problem input mdd size even processing
two linear inequalities positive coefficients boolean variables  however 
provided pseudo polynomial scheme fully polynomial approximation scheme twocost configuration  which  principle  extended k cost configuration
fixed k   empirical evaluation demonstrated despite inherent hardness
problem still provide satisfying performance interactive setting  interaction
based computing valid domains wrt  multiple cost restrictions novel addition
interaction modes within multiple criteria decision making  figueira et al         
provide explicit control variable assignments well cost functions 
future plan investigate compiled representations delivering
cost configuration might efficient investigate practical approaches processing
non unary cost functions  particular  plan examine whether existing methods
   

fiinteractive cost configuration decision diagrams

multiobjective non unary optimization  e g   rollon   larrosa        dubus et al        
adopted operate mdd representation solution space 

acknowledgments
would thank anonymous reviewers extensive comments helped
us improve paper  would thank erik van der meer providing
t shirt example  first version paper created tarik hadzic
university copenhagen  updated version made cork constraint
computation centre support ircset embark initiative postdoctoral fellowship scheme 

references
amilhastre  j   fargier  h     marquis  p          consistency restoration explanations
dynamic csps application configuration  artificial intelligence                
    
bahar  r   frohm  e   gaona  c   hachtel  e   macii  a   pardo  a     somenzi  f         
algebraic decision diagrams applications  ieee acm international conference cad  pp         
bartzis  c     bultan  t          construction efficient bdds bounded arithmetic
constraints  garavel  h     hatcliff  j   eds    tacas  vol       lecture notes
computer science  pp          springer 
bodlaender  h  l          tourist guide treewidth  acta cybernetica          
bollig  b     wegener  i          improving variable ordering obdds np complete 
computers  ieee transactions on                  
bryant  r  e          graph based algorithms boolean function manipulation  ieee
transactions computers             
bryant  r  e     chen  y  a          verification arithmetic circuits binary
moment diagrams  proceedings   nd acm ieee design automation
conference  pp         
darwiche  a     marquis  p          knowledge compilation map  journal artificial
intelligence research             
darwiche  a          logical approach factoring belief networks  fensel  d  
giunchiglia  f   mcguinness  d     williams  m  a   eds    kr      principles
knowledge representation reasoning  pp         san francisco  california 
morgan kaufmann 
darwiche  a          differential approach inference bayesian networks  journal
acm                 
   

fiandersen  hadzic    pisinger

dechter  r          bucket elimination  unifying framework reasoning  artificial
intelligence                  
dechter  r     pearl  j          tree clustering constraint networks  artificial intelligence                 
drechsler  r   sarabi  a   theobald  m   becker  b     perkowski  m  a          efficient
representation manipulation switching functions based ordered kronecker
functional decision diagrams  dac     proceedings   st annual conference
design automation  pp         new york  ny  usa  acm 
drechsler  r          binary decision diagrams theory practice  international journal
software tools technology transfer  sttt                 
drechsler  r   becker  b     ruppertz  s          k bmds  new data structure
verification  edtc     proceedings      european conference design
test  p    washington  dc  usa  ieee computer society 
dubus  j  p   gonzales  c     perny  p          multiobjective optimization using gai
models  boutilier  c   ed    ijcai  pp           
ehrgott  m     gandibleux  x          survey annotated bibliography multiobjective combinatorial optimization  spektrum             
fahle  t     sellmann  m          cost based filtering constrained knapsack
problem  annals operations research            
fargier  h     marquis  p          use partially ordered decision graphs
knowledge compilation quantified boolean formulae  proceedings aaai
      pp       
fargier  h     marquis  p          valued negation normal form formulas  proceedings ijcai       pp         
fargier  h     vilarem  m  c          compiling csps tree driven automata
interactive solving  constraints                
figueira  j  r   greco  s     ehrgott  m          multiple criteria decision analysis  state
art surveys  springer verlag  boston  dordrecht  london 
garey  m  r     johnson  d  s          computers intractability a guide theory
np completeness  w h freeman   co 
hadzic  t   subbarayan  s   jensen  r  m   andersen  h  r   mller  j     hulgaard  h 
        fast backtrack free product configuration using precompiled solution
space representation  proceedings peto conference  pp          dtutryk 
hadzic  t     andersen  h  r          bdd based polytime algorithm cost bounded
interactive configuration  proceedings aaai       pp       
   

fiinteractive cost configuration decision diagrams

hadzic  t   hansen  e  r     osullivan  b          automata  mdds bdds
constraint satisfaction  proceedings ecai      workshop inference
methods based graphical structures knowledge 
huang  j     darwiche  a          using dpll efficient obdd construction 
proceedings sat       pp         
huang  j     darwiche  a          dpll trace  sat knowledge compilation 
kaelbling  l  p     saffiotti  a   eds    ijcai  pp          professional book
center 
ibarra  o     kim  c          fast approximation algorithms knapsack sum
subset problem  journal acm             
jensen  r  m          clab  c   library fast backtrack free interactive product
configuration  http   www itu dk people rmj clab  
kebschull  u     rosenstiel  w          efficient graph based computation manipulation functional decision diagrams  design automation        european
event asic design  proceedings    th  european conference on         
kellerer  h   pferschy  u     pisinger  d          knapsack problems  springer  berlin 
germany 
lai  y  t     sastry  s          edge valued binary decision diagrams multi level hierarchical verification  dac     proceedings   th acm ieee conference
design automation  pp         los alamitos  ca  usa  ieee computer society
press 
lichtenberg  j   andersen  h  r   hulgaard  h   mller  j     rasmussen  a  s         
method configuring product  us patent no            
lind nielsen  j         
buddy   binary
http   sourceforge net projects buddy 

decision

diagram

package 

mateescu  r   dechter  r     marinescu  r          and or multi valued decision diagrams  aomdds  graphical models  journal artificial intelligence research 
           
meinel  c     theobald  t          algorithms data structures vlsi design 
springer 
meseguer  p   rossi  f     shiex  t          soft constraints  rossi  f   van beek 
p     walsh  t   eds    handbook constraint programming  foundations artificial intelligence  chap     pp          elsevier science publishers  amsterdam 
netherlands 
miller  d  m     drechsler  r          construction multiple valued decision
diagrams  proceedings   nd international symposium multiple valued
logic  ismvl     p      washington  dc  usa  ieee computer society 
   

fiandersen  hadzic    pisinger

mller  j   andersen  h  r     hulgaard  h          product configuration internet 
informs conference information systems technology 
muller hannemann  m     weihe  k          pareto shortest paths often feasible
practice  wae     proceedings  th international workshop algorithm
engineering  pp         london  uk  springer verlag 
nicholson  r   bridge  d  g     wilson  n          decision diagrams  fast flexible
support case retrieval recommendation  proceedings eccbr      
pp         
pargamin  b          extending cluster tree compilation non boolean variables
product configuration  tractable approach preference based configuration 
ijcai   workshop configuration 
reinhardt  l  b     pisinger  d          multi objective multi constrained nonadditive shortest path problems  computers operations research  submitted 
technical report version available at  http   man dtu dk upload institutter 
ipl publ publikationer        rapport      pdf 
rollon  e     larrosa  j          bucket elimination multiobjective optimization problems  journal heuristics                   
sanner  s     mcallester  d  a          affine algebraic decision diagrams  aadds 
application structured probabilistic inference  proceedings ijcai      
pp           
schuurman  p     woeginger  g  j          approximation schemes tutorial 
moehring  r   potts  c   schulz  a   woeginger  g     wolsey  l   eds    lectures
scheduling  forthcoming 
sellmann  m          practice approximated consistency knapsack constraints 
mcguinness  d  l     ferguson  g   eds    aaai  pp          aaai press  
mit press 
somenzi  f          cudd  colorado university decision diagram package  ftp   vlsi
 colorado edu pub  
srinivasan  a   kam  t   malik  s     brayton  r  k          algorithms discrete
function manipulation  international conference cad  pp       
subbarayan  s   jensen  r  m   hadzic  t   andersen  h  r   hulgaard  h     mller  j 
        comparing two implementations complete backtrack free interactive
configurator  proceedings cp   cspia workshop  pp        
subbarayan  s  m          exploiting structures constraint solving  ph d  thesis 
university copenhagen  copenhagen 
tafertshofer  p     pedram  m          factored edge valued binary decision diagrams 
formal methods system design  vol      pp          kluwer 
   

fiinteractive cost configuration decision diagrams

tarapata  z          selected multicriteria shortest path problems  analysis complexity  models adaptation standard algorithms  international journal applied
mathematics computer science                 
trick  m          dynamic programming approach consistency propagation
knapsack constraints   rd international workshop integration ai
techniques constraint programming combinatorial optimization problems cpai or  pp         
vempaty  n  r          solving constraint satisfaction problems using finite state automata 
proceedings tenth national conference artificial intelligence  pp     
    
walsh  t          sat v csp  dechter  r   ed    proceedings cp       lecture notes
computer science  pp         
wegener  i          branching programs binary decision diagrams  society industrial applied mathematics  siam  
wilson  n          decision diagrams computation semiring valuations 
proceedings nineteenth international joint conference artificial intelligence
 ijcai      pp         

   


