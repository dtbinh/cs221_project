journal artificial intelligence research                  

submitted        published     

abstract reasoning planning coordination
bradley j  clement

brad   clement   jpl   nasa   gov

jet propulsion laboratory  mail stop          
pasadena  ca       usa

edmund h  durfee

durfee   umich   edu

university michigan  eecs department ann arbor  mi       usa

anthony c  barrett

tony  barrett   jpl   nasa   gov

jet propulsion laboratory  mail stop          
pasadena  ca       usa

abstract
judicious use abstraction help planning agents identify key interactions
actions  resolve them  without getting bogged details  however  ignoring wrong
details lead agents building plans work  costly backtracking replanning overlooked interdependencies come light  claim associating systematicallygenerated summary information plans abstract operators ensure plan correctness  even
asynchronously executed plans must coordinated across multiple agents  still achieving valuable efficiency gains  paper  formally characterize hierarchical plans whose
actions temporal extent  describe principled method deriving summarized state
metric resource information actions  provide sound complete algorithms  along
heuristics  exploit summary information hierarchical refinement planning plan
coordination  analyses experiments show that  clearcut reasonable conditions 
using summary information speed planning much doubly exponentially even plans
involving interacting subproblems 

   introduction
abstraction powerful tool solving large scale planning scheduling problems  abstracting away less critical details looking large problem  agent find overall solution problem easily  then  skeleton overall solution place  agent
work additional details solution  sacerdoti        tsuneto  hendler    nau        
further  interdependencies fully resolved abstract levels  one agents
flesh sub pieces abstract solution full details independently  even parallel 
divide and conquer approach  korf        lansky        knoblock        
unfortunately  always obvious best abstract large  complex problems achieve
efficiency improvements  agent solving complicated  many step planning problem 
example  might able identify details earlier parts critical later
ones tried generate plans schedules seen interdependencies end
arising  even worse  multiple agents trying plan schedule activities shared
environment  unless lot prior knowledge other  extremely
difficult one agent anticipate aspects planned activities likely affect 
affected by  agents 

c
    
ai access foundation  rights reserved 

fic lement  urfee     barrett

paper  describe strategy balances benefits risks abstraction largescale single agent multi agent planning problems  approach avoids danger ignoring
important details lead incorrect plans  whose execution fail due overlooked interdependencies  substantial backtracking abstract decisions cannot consistently refined 
meanwhile  approach still achieves many computational benefits abstraction long
one number reasonable conditions  listed later  holds 
key idea behind strategy annotate abstract operator plan hierarchy
summary information potential needs effects potential refinements  might sound contrary purpose abstraction reducing number
details  fact show strikes good balance  specifically  possibly
relevant conditions effects modeled  agent agents reasoning abstract
operators absolutely sure important details cannot overlooked  however 
summary information abstracts away details refinement choices conditions
effects manifested  information relative timing conditions needed effects achieved  still often results exponential reduction information
compared flat representation 
based concept summary information  paper extends prior work summarized
section   make following contributions 
formal model hierarchical plans temporal extent  execution 
many planning systems sophisticated temporal models  e g   laborie   ghallab        muscettola        additionally use hierarchical representations alternative courses action
 allen  kautz  pelavin    tenenberg        currie   tate        chien  knight  stechert  sherwood    rabideau      a  castillo  fdez olivares  garca perez    palao         know
work extends hierarchical task network  htn  formalization  erol  hendler    nau 
    a  erol  nau    hendler      b  include temporal extent  need formalism order
clarify semantics summary information concurrently executing agents 
algorithms deriving summary information propositional metric resource conditions effects  using information determine potential definite interactions abstract tasks  prove summarization techniques guaranteed
correctly capture conditions effects associated abstract operator appropriately  augmented modal information whether conditions must may hold whether
hold entire operation time  summary information
captures conditions effects  algorithms reason operators different levels
abstraction predict often resolve operator interactions without fully detailing task hierarchies 
even operators executing asynchronously different agents 
sound complete algorithms hierarchical refinement planning centralized plan coordination actions temporal extent  supporting flexible plan execution systems 
agent reduce backtracking planning selectively interleaving refinement plan
predicting resolving potential interdependencies evolving plan plans
asynchronously executed agents  research found benefit
guiding refinement conditions specified higher levels plan hierarchy guide refinement  sacerdoti        young  pollack    moore        tsuneto et al          show
algorithms improve capabilities exploiting hierarchical structure using summary

   

fia bstract r easoning p lanning c oordination

information efficiently converge coordinated plans  refined
individually parallel participating agents 
ability coordinate abstract levels rather detailed plans allows
agents retain local flexibility refine operators best suits current expected
circumstances without jeopardizing coordination triggering new rounds renegotiation 
way  summary information supports robust execution systems prs  georgeff   lansky 
       umprs  lee  huber  durfee    kenny         raps  firby         jam  huber         etc 
interleave refinement abstract plan operators execution 
approach extends plan coordination  plan merging  techniques  georgeff        lansky        ephrati   rosenschein        utilizing plan hierarchies expressive temporal model  prior techniques assume actions atomic  meaning action either executes
before  after  exactly time another  contrast  use interval point algebra  vilain   kautz        represent possibility several actions one agent executing
execution one action another agent  algorithms choose alternative
refinements htn dynamically midst plan coordination  support interleaved local
planning  multiagent coordination  concurrent execution 
search techniques heuristics  including choose fewest threats first  cftf  expandmost threats first  emtf   take advantage summary information prune search
space  interdependencies run deeply agents plans  resolving abstract levels  possible all  lead unacceptable losses parallel activity  fortunately  even
agents need delve details plans tease interdependencies  summary information still enable exponential speedups guiding decomposition pruning refinement
choices  search efficiency using summary information comes ignoring irrelevant information  distributed planning system reduces communication overhead exponentially 
complexity analyses experiments showing potential doubly exponential speedups refinement local search planning scheduling using summary information  algorithms
demonstrate exploiting summary information guide hierarchical planning scheduling
achieve exponential speedups  resolving interdependencies abstract levels improve
performance plan coordination algorithms doubly exponentially  others shown
abstraction exponentially reduce search space size  korf        knoblock        subproblem independence properties hold  show techniques lead exponential improvements
broader conditions hold problem 
solutions found abstract levels 
amount summary information less higher levels lower levels 
choices decompositions lead varying numbers plan threats 
none conditions hold  show generating using summary information
provides benefit increase computation communication overhead  thus  care must
taken deciding use summary information  though proven extremely worthwhile
types problem domains examined  example next describe 

   

fic lement  urfee     barrett

m 

m 

e

transport 

transport 



b

c

tool

bin 

bin 

bin 

bin 

dock

figure    simple example manufacturing domain
produce h
produce g

produce h g

produce g
m 

produce g
m 

move a b
m 
move m 

move g
m 
build h

move h
bin 

build g

move b m 

figure    production managers hierarchical plan
    manufacturing example
running example motivate work  consider manufacturing plant production
manager  facilities manager  inventory manager goals separately
constructed hierarchical plans achieve them  however  still need coordinate use
equipment  availability parts used manufacturing parts  storage parts 
use transports moving parts around  state factory shown figure   
domain  agents produce parts using machines m  m   service machines tool 
move parts shipping dock storage bins shop floor using transports 
initially  machines m  m  free use  transports  transport  transport   
tool  parts  a e  shown storage locations available 
production manager responsible creating part h using machines m  m   either m  m  consume parts b produce g  m  produce h g 
production managers hierarchical plan manufacturing h involves using transports move
needed parts storage input trays machines  manufacturing g h  transporting h back storage  plan shown figure    arcs subplan branches mean
subplans must executed  branches without arcs denote alternative choices achieving
parents goal  decomposition produce g m  similar produce g m  
facilities manager services machine equipping tool calibrating it 
machines unavailable production serviced  facilities managers hierarchical plan branches choices servicing machines different orders uses transports

   

fia bstract r easoning p lanning c oordination

maintenance
service m  m 

service m 

service m 

service m  m 

move tool
dock

move tool equip m  tool calibrate m 
m 

figure    facilities managers hierarchical plan
move parts
move c dock

move d e

move bin 

move e bin 

figure    inventory managers hierarchical plan
getting tool storage machines  figure     decomposition service m m 
similar service m m  
parts must available space limited shop floor order agent use them 
whenever agent moves uses part  becomes unavailable  inventory managers goal
move part c dock move e bins shop floor  shown figure    
accelerate coordination plans  factory manager analyze hierarchical
plan derive summary information abstract plan operator affect world 
information includes summary pre   post   in conditions intuitively correspond
externally required preconditions  externally effective postconditions  internally required
conditions  respectively  plan based potential refinements  summary conditions augment state conditions modal information whether conditions must may hold
effect  examples given end section     
summary information computed  production inventory managers could
send information top level plan facilities manager  facilities manager could
reason top level summary information plans determine
facilities manager serviced machines production manager started producing
parts  production manager finished inventory manager began moving parts
dock  plans executed  refined  way  cananyway 
facilities manager could instruct others add communication actions plans
synchronize actions appropriately 
top level solution maximizes robustness choices production facilities managers plans preserved  solution inefficient concurrent
activityonly one manager executing plan time  production manager might
want wait facilities manager finish maintenance could negotiate solution
concurrency  case  facilities manager could determine could overlap

   

fic lement  urfee     barrett

plans way without risking conflict  cananyway   however  summary information
could tell might way overlap plans  mightsomeway   suggesting
search solution concurrency  at cost perhaps committing specific
refinement choices  hope success  case  facilities manager could request production manager summary information produce hs subplans  reason
interactions lower level actions way  find way synchronize subplans
fine grained solution plans executed concurrently  give algorithm
finding solutions section   
    overview
first formally define model concurrent hierarchical plan  execution  interactions
 section     next  describe summary information propositional states metric resources 
mechanisms determining whether particular interactions must may hold based information  algorithms deriving information  section     built upon algorithms others
using summary information determine whether set chips must might execute successfully set ordering constraints  section     turn used within sound
complete multilevel planning coordination algorithm employs search techniques heuristics
efficiently navigate prune search space refinement  section     show
planning  scheduling  coordinating abstract levels exponentially improve performance
search execution  section     provide experimental results demonstrating search
techniques greatly reduce search optimal solutions  section     finally  section  
differentiate approach related work mention elsewhere conclude 

   model hierarchical plans concurrent execution
representation temporal extent htn important modeling concurrently
executing agents performing abstract reasoning summary information  agent
scheduling abstract actions sequentially order them  severely restricted
kinds solutions find  example  agent may prefer solutions shorter
makespans  seek plans subthreads carried concurrently 
section define concurrent hierarchical plans  chips   state changes time
based executions  concepts success failure executions possible world 
history  later define summary information abstract plan interactions terms
definitions semantics given section  treatment fairly detailed  though
even comprehensive treatment  see clement         however  begin summarizing
main concepts notation introduced  give reader basic gist 
    overview
chip  or plan p  mainly differentiated htn including definition inconditions 
in p    sometimes called conditions  affect  or assert condition on  state
start time p  ts  p   must hold throughout duration p  preconditions  pre p   must
hold start  postconditions  post p   asserted finish time p  t f  p    metric
resource  res  consumption  usage p  res   instantaneous start time and  resource
defined non consumable  instantaneously restored end  decompositions p  d p  

   

fia bstract r easoning p lanning c oordination

style and or tree  either partial ordering  order p   choice child tasks
conditions 
execution e p instantiation start time  end time  decomposition  is 
execution nails exactly done when  order reason plan interactions 
quantify possible histories  history corresponds combination possible
executions concurrently executing chips partial ordering activities
context initial state  run  r h t   specifies state time history h 
achieve  clobber  undo interactions defined terms executions
plans assert positive literal   negative literal   relative   required another plans
execution history  looking literals achieved  clobbered  undone set
executions history  identify conditions must hold prior executions
history external preconditions must hold executions history
external postconditions 
value metric resource time  r res  h t   calculated subtracting prior
state value usage plans start executing  if non consumable  adding back usages
end t  execution e p fails condition required asserted time
state r h t  t  value resource  r res  h t   used plan
limits execution 
remainder section  give careful  detailed descriptions concepts
above  ground definitions firm semantics  casual reader skim
details desired  important note that  rather starting scratch  formalization
weaves together  necessary augments  appropriate aspects theories  including
allens temporal plans         georgeffs theory multiagent plans         fagin et al s
theory multiagent reasoning knowledge        
   

ch p

concurrent hierarchical plan p tuple hpre  in  post  usage  type  subplans  orderi  pre p  
in p   post p  sets literals  v v propositional variable v  representing
preconditions  inconditions  postconditions defined plan p  
borrow existing model metric resources  chien  rabideu  knight  sherwood  engelhardt  mutz  estlin  smith  fisher  barrett  stebbins    tran      b  laborie   ghallab        
plans usage function mapping resource variables amount used  write
usage p  res  indicate amount p uses resource res sometimes treat usage p  set
pairs  res  amount   metric resource res tuple hmin value  max value  typei  min
max values integer real values representing bounds capacity amount available  type resource either consumable non consumable  example  fuel
battery energy consumable resources because  use  depleted amount 
non consumable resource available use  e g  vehicles  computers  power  
domain modelers typically specify state conditions resource usage primitive actions hierarchy  thus  conditions usage chip used derive summary conditions 
describe section      algorithms reason action hierarchy 
order reason plan hierarchies and or trees actions  type plan p  type p  
   functions pre p  used referential convenience throughout paper  here  pre pre p 
same  pre p  read preconditions p 

   

fic lement  urfee     barrett

given value either primitive  and  or  plan non primitive plan accomplished carrying subplans  plan non primitive plan accomplished
carrying exactly one subplans  so  subplans set plans  primitive plans
subplans empty set  order p  defined plan p consistent set
temporal relations  allen        pairs subplans  plans left unordered respect
interpreted potentially execute concurrently 
decomposition chip style htn described erol et al 
     a   plan task network  plan extra construct representing set
methods accomplish goal compound task  network tasks corresponds
subplans plan 
example figure    production managers highest level plan produce h  figure   
tuple
h                and   produce g  produce h f rom g    be f ore       i 
f ore           indices subplans decomposition referring produce g
produce h f rom g respectively  conditions defined produce h rely
conditions defined primitive plans refinement  plan moving part
bin  first input tray m  using transport  tuple
h                and   start move  f inish move    meets       i 
plan decomposes two half moves help capture important intermediate effects 
parent orders children meets relation bind together single move 
start move plan
h at a  bin    available a   f ree transport    f ull m  tray    
 at a  bin    available a   f ull bin    f ull m  tray    f ree transport    
 at a  bin    available a   f ree transport    f ull bin    f ull m  tray    
    primitive        i 
f inish move plan
h at a  bin    available a   f ree transport    f ull bin    f ull m  tray    
 at a  bin    available a   f ree transport    f ull bin    f ull m  tray    
 at a  bin    at a  m  tray    available a   f ree transport    f ull bin    f ull m  tray    
    primitive        i 
split move plan two parts order ensure action executes
concurrently one use transport   part a  input tray m   would incorrect
instead specify f ree transport   incondition single plan another agent could 
instance  use transport  time f ree transport   incondition would agree
f ree transport   incondition move action  however  specification still
insufficient since two pairs  start move  f inish move  actions could start end
time without conflict  get around allowing planner reason
move plan parent plans  effect  hiding transition start finish actions 
so  representing transition f ree f ree without knowing transition
   

fia bstract r easoning p lanning c oordination

take place modeler ensures another move plan tries use transport  concurrently
one cause conflict  
postcondition required incondition specify whether incondition changes 
clarifies semantics inconditions conditions hold plan execution
whether caused action necessary conditions successful execution 
    executions
informally  execution chip recursively defined instance decomposition
ordering subplans executions  intuitively  executing plan  agent chooses plans
start time refined  determining points time conditions must hold 
witnesses finish time  formalism helps us reason outcomes different ways
execute group plans  describe state transitions  define summary information 
execution e chip p tuple hd ts  t f i  ts  e  f  e  positive  non zero real numbers
representing start finish times execution e  ts   f   thus  instantaneous actions
explicitly represented  d e  set subplan executions representing decomposition plan p
execution e  specifically  p plan  contains exactly one execution
subplans  plan  contains one execution one subplans 
empty primitive  addition  subplan executions  e  d  ts  e    f  e    must
consistent relations specified order p   also  first subplan s  start must start
time p  ts  e      ts  e   last subplan s  finish must finish time
p  f  e      f  e   possible executions plan p set e  p  includes possible
instantiations execution p  meaning possible values tuple hd ts  t f i  obeying
rules stated 
example section      execution production managers top level plan
produce h would e e  produce h   e might h e    e              e 
e  produce g   e  e  produce h f rom g   means execution produce h
begins time     ends time     
convenience  subexecutions execution e  subex e   defined recursively
set subplan executions es decomposition unioned subexecutions 
    histories runs
agent reasoning summary information make planning decisions abstract levels needs
first able reason chips  section complete semantics chips
describing affect state time  agent execute plan many different
ways different contexts  need able quantify possible worlds  or histories 
agents fulfill plans different ways  defining history  define run
transformation state time result history executions  formalization
histories runs follows closely fagin et al         describing multiagent execution 
state world  s  truth assignment set propositions  representing aspect
environment  refer state set true propositional variables  history 
   using universal quantification  weld        single plan could agent  agent    productionmanager
using transport   agent  condition would exclude concurrent access transport  could
simply specified transport  non consumable resource maximum capacity one 

   

fic lement  urfee     barrett

h  tuple he  si i  e set plan executions agents occurring h  si
initial state h plan begins executing  so  history h hypothetical world begins
si initial state executions e h  occur  particular  history
manufacturing domain might initial state shown figure   parts machines
available  transports free  set executions e would contain execution
produce h  maintenance  move parts  subexecutions 
run  r  function mapping history time point states  gives complete description
state world evolves time  time ranges positive real numbers 
axiom  
r h       si
axiom  
v r h t       v r h t  
p  e p e h    v in p  ts  e p        v post p  f  e p     t  
   p    e p  e h    v in p    ts  e p         v post p    f  e p      t  
axiom   states world initial state time zero  axiom   states predicate
v true time already true beforehand  plan asserts v incondition
postcondition t   in either case  plan asserts v t  plan starts t  inconditions
asserted right start     small positive real number  axiom   indicates
inconditions postconditions effects 
state resource level value  integer real   consumable resource usage  task
depletes resource modeled instantaneously deplete resource  subtract usage
current state  start task full amount  non consumable resource usage  task
depletes usage amount start task  usage restored  added back
resource state  end execution  task replenish resource negative usage 
refer level resource res time history h r res  h t   axioms    
describe calculations consumable non consumable resources  respectively 
axiom  
r consumable res  h t    r consumable res  h t   e p e h  ts  e p   t usage p  consumable res 
axiom  
r nonconsumable res  h t   r nonconsumable res  h t  
e p e h  ts  e p   t usage p  nonconsumable res  
e p e h  t f  e p   t usage p  nonconsumable res 
described chips change state  specify conditions
execution succeeds fails  stated formally definition    execution succeeds if 
plans preconditions met start  postconditions met end  inconditions
met throughout duration  not including start end   used resources stay within
value limits throughout duration  executions decomposition succeed  otherwise 
execution fails 
   

fia bstract r easoning p lanning c oordination

definition  
succeeds e p   h  pre p  r h ts  e p   
post p  r h t f  e p   
t  res ts  e p       f  e p   usage p  res      
in p  r h t 
min value res     r res  h t     max value res 
e d e p    succeeds e  h 
    asserting  clobbering  achieving  undoing
conventional planning literature often speaks clobbering achieving preconditions plans
 weld         chips  notions slightly different since inconditions clobber
clobbered  seen previous section  formalizing concepts another  undoing
postconditions  helps us define summary conditions  in section       however  convenient
define first means assert condition  figure   gives examples executions involved
interactions  define terms follows 
definition  
asserts e p     t  h   e p e h  
   in p    ts  e p    
  post p    f  e p   
 r t  h      
definition   states execution e p history h asserts literal time literal
effect p holds state t  note point on  beginning definition   
use brackets     shorthand defining similar terms procedures  example  saying  a 
b  implies  c  d  means implies c  b implies d  shorthand help us avoid repetition 
cost slightly difficult parsing 
definition  
 achieves  clobbers  precondition e p      e p   t  h 
e p   e p  e h 
asserts e p          t  h    pre p      ts  e p   
  e p    t       asserts e p       t      h  asserts e p       t      h        ts  e p   
definition  
clobbers  in  post condition e p      e p   t  h 
e p   e p  e h 
asserts e p     t  h     in p     post p      ts  e p        ts  e p    t   f  e p    
definition  
undoes e p      e p   t  h 
e p   e p  e h 
asserts e p     t  h    post p    f  e p     
  e p    t       asserts e p       t      h  asserts e p       t      h   f  e p        
   

fic lement  urfee     barrett

figure    interval interactions plan steps
so  execution achieves clobbers precondition last  or one last  assert
condition negation  respectively  required  likewise  execution undoes
postcondition first  or one first  assert negation condition
condition asserted  execution e clobbers incondition postcondition e  e asserts
negation condition end  respectively  e    achieving effects  inconditions
postconditions  make sense formalism  defined  figure   shows
different ways execution e achieves  clobbers  undoes execution e        point
asserted required met 
    external conditions
recognized tsuneto et al          external conditions important reasoning potential refinements abstract plans  although basic idea same  define little
differently call external preconditions differentiate conditions
call external postconditions  intuitively  external precondition group partially ordered
plans precondition one plans achieved another group must
met external group  external postconditions  similarly  undone
plans group net effects group  definition   states   external  pre 
post condition execution e p    pre  post condition subplan
 achieved  undone  subplan 
definition  
external  pre  post condition    e p  
h  e h     e p   subex e p  
 e p  e h      pre p     post p    
  e p   e h  t  achieves pre  undoes post condition e p        e p   t  h  

   

fia bstract r easoning p lanning c oordination

example figure    available g  external precondition because  although g
must exist produce h  g supplied execution produce g plan  thus  available g 
met internally  making available g  internal condition  available m   external precondition  internal condition  external postcondition needed externally
internally  effect produce g m  releases m  finished 
plan decomposition undoes effect 

   plan summary information
summary information used find abstract solutions guaranteed succeed matter
refined information describes potential conditions underlying
decomposition  thus  commitments particular plan choices  whether single agent
agents  made based summary information without worrying deeper details
lurk beneath doom commitments  htn planners used abstract conditions
guide search  e g   sacerdoti        tsuneto et al          rely user defined subset
constraints help detect potential conflicts  contrast  summary information
used identify potential conflicts 
formalisms previous section  define summary information
describe method computing non primitive plans  in section      
many detailed definitions algorithms section  follow structure
previous section  first give informal overview key concepts notation 
subsequently delve systematically 
    overview
summary information plan p consists summary pre   in   postconditions  presum  p  
insum  p   postsum  p    summary resource usage  usagesum  p  res   resource res  whether
plan executed way successfully  consistent  
summary condition  whether pre  post  in  specifies positive negated literal 
additional modal information  summary condition associated existence  whose
value either must may depending whether must hold possible decompositions
abstract operator may hold depending decomposition chosen  timing
summary condition either f irst  last  always  sometimes  specifying condition must
hold plans interval execution  plan p  must  achieve  clobber  summary precondition
c  p  execution p   or plan summary information  would
 achieve  clobber  condition summarized c   or plan summary information
p    
algorithm deriving summary conditions plan p takes input summary conditions immediate subplans p conditions defined chip p  pre   in  
postconditions p become must first  must always  must last summary conditions  respectively  algorithm retains existence timing subplan summary conditions parent
depending whether conditions achieved  clobbered  undone siblings  whether
decomposition or  whether subplan ordered first last  whether subplans
share condition  subplan first  always  last conditions become sometimes conditions parent  parent computed consistent long subplans consistent 

   

fic lement  urfee     barrett

subplan may clobber summary condition another  summarized resources violate
limits 
represent summary resource usage three value ranges  hlocal min  local max  persisti 
resources local usage occurs within tasks execution  persistent usage represents usage lasts task terminates depletable resources  summarization
algorithm abstract task takes summary resource usages subtasks  considers legal orderings subtasks  possible usages subintervals within interval
abstract task  build multiple usage profiles  profiles combined algorithms
computing parallel  sequential  disjunctive usages give summary usage parent task 
    summary conditions
summary information plan p  psum   tuple hpresum   insum   postsum   usagesum   consistenti 
whose members sets summary conditions  summarized resource usage  consistent flag
indicating whether plan execute consistently internally  presum  p  postsum  p  summary pre  postconditions  external pre  postconditions p  respectively 
summary inconditions p  insum  p   contain conditions must hold within execution
p successful  condition c one sets tuple h   existence timingi    c 
literal c  existence c must may  existence c    must  c called
must condition   must hold every successful plan execution  convenience usually
write must c   c may condition  may c  true    c  must hold successful execution 
timing summary condition c either always  sometimes  f irst  last  timing c 
always c insum   c  incondition must hold throughout potential executions p
   holds always   otherwise  timing c    sometimes meaning   c  holds one point  least  within
execution p  so  always condition must  define may always inconditions
whether may existence timing  significantly different may
sometimes planner reasons it  whether condition may always  however defined 
may sometimes  another plan may clobber relationship condition  as
defined section       note incondition chip restricted meaning
must always summary incondition  timing f irst c presum   c  holds beginning
execution p  otherwise  timing   sometimes  similarly  timing last c postsum   c 
asserted end successful execution p  otherwise  sometimes  although existence
timing syntactically take one value  semantically must c  may c   always c 
sometimes c  
considered using modal logic operators describe concepts  mix existing
temporal logic dynamic logic  pratt        notation could forced work  found
using terminology made definitions much simpler  discuss end
section   
definitions         give formal semantics existence timing representative
condition types  summary conditions plan defined recursively depend
summary conditions plans immediate subplans instead complete decomposition  single description summary information could represent many different plan hierarchies 
quantify plans p    whose subplans summary information
plan p summarized  could defined existence timing properties conditions
based entire hierarchy  so  deriving summary conditions would expensive

   

fia bstract r easoning p lanning c oordination

solving planning problem  one main purposes summary information reduce
computation planning problem  reason would expensive
worst case legal orderings plan steps must explored determine whether condition
must may  discuss example end subsection 
definition  
 must  may  f irst precondition    p 
p    hpre p   in p   post p      type p   subplans p     order p i
summary f ormation f subplans p      summary f ormation f subplans p 
h e p    e h     e p    subex e p     true  external precondition    e p    
e p   e h  ts  e p       ts  e p      pre p    

definition  
must always incondition    p 
p    hpre p   in p   post p      type p   subplans p     order p i
summary f ormation f subplans p      summary f ormation f subplans p 
h  e p   e h     e p    subex e p    t ts  e p        f  e p   
e p   e h  ts  e p         f  e p       in p    

definition  
 must  may  sometimes incondition    p 
    p    hpre p   in p   post p      type p   subplans p     order p i
summary f ormation f subplans p      summary f ormation f subplans p      
    h  e p   e h     e p    subex e p     t ts  e p        f  e p       
e p   e h     ts  e p       pre p    
ts  e p         f  e p       in p    
  f  e p       post p    
definition   states f irst precondition p external precondition always required beginning execution p  conditions p
summary information ordering subplans p  last postcondition always asserted
end execution  substitute pre post ts f last two lines definition      must may  sometimes precondition  must may  external precondition
f irst precondition  sometimes postcondition defined similarly  definition   states literal
  must  always incondition plan p time isolated execution p 
summary information p  executing plan p   incondition    definition  
states  must  may  sometimes incondition plan p condition required  any 
some  execution  any  some  plan p  summary information ordering
subplans p 
consistent flag boolean indicating whether plan  or plan summary information ordering subplans  would execute successfully matter decomposed matter subplans executed  definition    says possible
   

fic lement  urfee     barrett

executions succeed consistent plan  similar cananyway relation
defined section    include whether plan definitely succeed
summary information requires exponential computation see whether conflicts
subplans resolved  computation wait done planning summary
information fully derived 
definition   
consistent p 
p    hpre p   in p   post p   usage p  type p   subplans p     order p i
summary f ormation f subplans p      summary f ormation f subplans p 
h  e p  e  p     e p  succeeds
show subset summary conditions production managers top level plan  of
figure    below  following literal modal tags existence timing information  mu
must  may  f f irst  l last  sometimes  always 
production managers produce h plan 
summary preconditions 
available a muf  available m  mas  available m  mas
summary inconditions 
available a mus  available m  mas  available m  mus  available g mus 
available a mus  available m  mas  available m  mus  available g mus 
available h mus  available h mus
summary postconditions 
available a mus  available m  mas  available m  mus  available g mus 
available h mul

available m   summary precondition may condition production manager
may end using m  chooses use m  instead produce g  available a  f irst summary precondition part must used beginning execution transported
one machines  machines needed sometime parts transported 
sometimes  and first  conditions  needed point time beginning execution 
production manager may use m  produce g  available m   summary
incondition produce h  available m   available m   inconditions
consistent sometimes conditions  implying hold different times
plans execution  contrast  conditions would conflict must always
 meaning must always hold throughout every possible execution plan  
summary condition available a  must postcondition top level plan
definitely consumed make g produced plan decomposition
produce h f rom g  even though available g  effect produce g  external
postcondition produce h undone produce h f rom g  consumes g
make h  available h  last summary postcondition production manager releases
h end execution  available m   last manager finishes using m 
moving h storage 
notice available m   may summary precondition  however  matter hierarchy decomposed  m  must used produce h  available m   must established
   

fia bstract r easoning p lanning c oordination

externally production managers plan  summary information defined terms
summary information immediate subplans  subplans produce h  see
produce g available m  mas precondition available m  mas postcondition
would achieve available m  muf precondition produce h f rom g  summary
information tell us precondition produce g exists postcondition
exists  necessary condition determine derived precondition produce h must
condition  thus  may  augmented summary information subsets conditions
existed together  hunting combinations temporal orderings condition subsets among
subplans derive summary conditions would basically adaptation htn planning algorithm  summary information intended improve  instead  derive summary information
polynomial time use improve htn planning exponentially explain section    tradeoff made beginning section defining summary conditions
terms immediate subplans instead entire hierarchy  abstraction involves loss
information  loss enables computational gains 
    summary condition relationships algorithms
order derive summary conditions according definitions  need able recognize
achieve  clobber  undo relationships based summary conditions basic chip
conditions  give definitions algorithms these  build constructs algorithms
reasoning temporal relationships  described appendix a 
achieving clobbering similar  define together  definition    states
plan p  must  achieve  clobber  summary precondition c  p  executions
two plans  p   p     summary information ordering constraints p 
p    execution p   one subexecutions would  achieve  clobber  external precondition
  c    p    
definition   
must  achieve  clobber  precondition p    c    p    psum   order 
h h psum   order   p     p     e p     e p    
 p   p   summary ordering f ormation p  p   
t e p    subex e p      e p    subex e p     
 achieve  clobber  precondition e p        c     e p     t  h 
external precondition   c     e p    
achieving clobbering in  postconditions defined definition    substituting post pre removing last line inconditions  additionally substituting gives definitions may achieve clobber  furthermore  definitions
must may undo obtained substituting post pre undo achieve definition     note that  mentioned section      achieving inconditions postconditions
make sense formalism 
algorithms interactions given figure   figure    algorithms build
others  detailed appendix b  use interval point algebra determine whether plan must
may assert summary condition before  at  time another plan requires summary
condition hold  similar definition   must achieve chip conditions  figure   says p 
   

fic lement  urfee     barrett

algorithm  must  achieve  clobber 
input  plan p    summary condition c plan p  psum   order
output  true f alse  whether p  must  achieve  clobber  c
begin function
c  in p    post p   
  c       c     c   must c   
c insum  p  p  must assert c  c return  unde f ined  true 
c postsum  p  p  must assert c  c return  unde f ined  true 
c presum  p  p  must assert c  c
set assertion inbetween   f alse
c   in p     post p      p   psum assertion inbetween   f alse
 p  may assert c  c  
p   may assert c   c
  c        c     c   
 p  must assert c  c  
p   must assert c   c
  c        c     c   must c     
set assertion inbetween   true
assertion inbetween return true
return f alse
end function

figure    algorithm whether plan must achieve clobber summary condition
achieves summary condition c must asserts condition must hold 
plans may assert condition negative between  algorithm may achieve
 in figure    mainly differs p  may assert condition beforehand  plan
must assert between  undo algorithms achieve swapping c
c  must may assert lines 
complexity determining must may clobber inconditions postconditions simply
o c  check c conditions p    conditions hashed  algorithm constant time 
rest algorithm cases  complexity walking summary conditions
checking p   c   o nc  maximum c summary conditions n plans
represented psum   worst case  summary conditions summarize propositional
variable  o nc  conditions must visited 
lets look examples relationships  figure  a  p    equip m  tool mayclobber c   available m  mas summary preconditions p   produce g
history equip m  tool ends produce g starts  calibrate m  starts
produce g starts  figure  b  p    build h must achieve c   available h muf summary preconditions p   move h  here  c  available h mul summary postconditions
build h  histories  build h attempts assert c  move h requires c
met  plan execution attempts assert condition availability
h  equip m  tool may clobber c   available m  muf summary preconditions
build h even though equip m  tool asserts c    available m  mul c required
met  calibrate m  must assert available m  mua time
equip m  tool asserts c  c required  thus  calibrate m  must undo equip m  tool

   

fia bstract r easoning p lanning c oordination

algorithm  may  achieve  clobber 
input  plan p    summary condition c plan p
output  true f alse  whether p  may  achieve  clobber  c
begin function
c  in p    post p   
  c       c     c  
c insum  p  p  may assert c  c return  unde f ined  true 
c postsum  p  p  may assert c  c return  unde f ined  true 
c presum  p  p  may assert c  c
set assertion inbetween   f alse
c   in p     post p      p   psum assertion inbetween   f alse
p  must assert c  c  
p   must assert c   c
  c       c    c  must c     
set assertion inbetween   true
assertion inbetween return true
return f alse
end function

figure    algorithm whether plan may achieve clobber summary condition
a 

produce h
produce g

produce h g
move g

build h

move h

service m 
move

equip m 

tool

calibrate m 

tool

b 

produce h
produce h g

produce g

move g
 
move
tool

build h

move h

service m 

equip m 

calibrate m 

tool

figure    production facilities managers plans partially expanded  a  managers plans
unordered respect other  b  equip m  tool must clobber available m  mal
produce g  calibrate m  must clobber available m  muf build h 

summary postcondition  calibrate m  cannot assert postcondition available m  mul
build h requires available m  muf  calibrate m  must clobber summary precondition 

   

fic lement  urfee     barrett

    deriving summary conditions
algorithms determine interactions abstract plans based summary
conditions  create algorithm derives summary conditions according definitions section      figure   shows pseudocode algorithm  method deriving
summary conditions plan p recursive  first  summary information derived ps
subplans  conditions added based ps conditions  rest algorithm
derives summary conditions ps subplans  whether p consistent depends
consistency subplans whether summary conditions resource usages
conflict  braces     used slightly different semantics used
brackets  expression  x y  interpreted simply  x y  respectively  
definitions algorithms temporal relationships always  f irst covers
appendix a  algorithm adds copies condition set  one condition exist
literal  conditions information may overwritten literal  cases 
must overwrites may  f irst  last  always overwrite sometimes  but  vice versa  further 
uses recursion  procedure assumed work plans whose expansion finite 
    summary resource usage
section  define representation capturing ranges usage local task interval depleted usage lasting end interval  based introduce
summarization algorithm captures ranges uncertainty represented decomposition choices plans partial temporal orderings plan subtasks  representation
allows coordinator planner reason potential conflicts set tasks 
discuss reasoning later section      although referred resources  variables could
durations additive costs rewards 
      r epresentation
start new example simplicity motivates choice representation  consider
task coordinating collection rovers explore environment around lander
mars  exploration takes form visiting different locations making observations 
traversal locations follows established paths minimize effort risk  paths combine form network one mapped figure     vertices denote distinguished
locations  edges denote allowed paths  thinner edges harder traverse  labeled points
associated observation goals  paths hard ground  others loose
sand traversal harder since rover slip 
figure    gives example abstract task  imagine rover wants make early
morning trip point point b example map  trip sun slowly rises
horizon giving rover ability progressively use soak rays tasks provide
solar power  a non consumable resource    motors wheels  addition collecting photons 
morning traverse moves rover  resultant go tasks require path dependent amounts
power  rover traveling point point b take number paths  shortest
three involve following one  two  three steps 
   important confuse power battery energy  power source  e g  battery  solar panels  makes fixed
amount power watts available point time  batterys energy  in watt hours  reduced integral
total use power time 

   

fia bstract r easoning p lanning c oordination

algorithm  derive summary information
input  plan p
output  psum
begin function
derive summary information
p  d p 
v
set consistent p    p  d p  consistent p   
  pre p  add h   must  f irsti presum  p 
  in p  add h   must  alwaysi insum  p 
  post p  add h   must  lasti postsum  p 
summary condition c  p  d p 
set c   c 
c   presum  p    postsum  p    
c  must  achieved undone  must clobbered within d p  
type p     p  always   f irst last 
temporally ordered subplan according order p 
sometimes    f irst last  subplan p 
  f irst  last    c    condition  presum  p    postsum  p      
set timing c    sometimes
c  may  achieved undone  may clobbered p d p 
p   p must   c    condition  presum  p     postsum  p      
set existence c    may
copy c  presum  p  postsum  p  
c  insum  p    p  not always   f irst last  according order p  
must c    c  always not    f irst last  according order p  
set existence c    must
set p     
set allalways   true
p   d p   c   insum  p    
  c       c 
always c     add p   p
else set allalways   f alse
else allalways   f alse
always c    type p    p covers p according order p  
 type p    allalways   
set timing c    always
add c insum  p 
c  may clobbered  set consistent   f alse
usagesum  p    summarizeresourceusage p   in section       
consistent usagesum  p     f alse  set consistent p    f alse
end function

figure    algorithm deriving summary information
summarized resource usage consists ranges potential resource usage amounts
performing abstract task  represent summary information plan p
resource res using structure
usagesum  p  res    hlocal min p  res   local max p  res   persist p  res i 

   

fic lement  urfee     barrett




b
c
f
e

figure     example map established paths points rover domain
morning activities
move a b 
soak rays soak rays soak rays
use   w use   w use   w
   min
   min
   min
go a   
use  w
   min

take low path

go     
use  w
   min

high path
middle path
go a b 
go   b  use  w go a    go   b 
use  w    min use  w use  w
   min
   min    min

figure     and or tree defining rovers tasks resource usages
resources local usage occurs within ps execution  persistent usage represents
usage lasts execution terminates consumable resources 
definition   
usagesum  p  res 
h minhh e p e h   mints  e p   t t f  e p    r res  h t     maxhh e p e h   mints  e p   t t f  e p    r res  h t    
 minhh e p e h   maxts  e p   t t f  e p    r res  h t     maxhh e p e h   maxts  e p   t t f  e p    r res  h t    
 minhh e p e h   r res  h t f  e p     
maxhh e p e h   r res  h t f  e p     

context definition    set histories h value res   initial
state  e h  contains execution p subexecutions  thus  r res  h t  term
combined usage res time executions hierarchy defined section      so 
maximum local min highest among histories lowest point usage
ps execution  usage ranges capture multiple possible usage profiles task multiple
decomposition choices timing choices among loosely constrained subtasks  example 
high path task h                 i summary power use    minute interval  case
ranges single points due uncertainty task simply uses   watts    minutes
followed   watts    minutes  move a b  task provides slightly complex example
due decompositional uncertainty  task h                 i summary power use
   minute interval  cases persist       solar power non consumable
resource 
example reasoning resource usage summaries  suppose   watts power
available move a b  task  given       local max  know
enough power matter task decomposed  raising available power   watts makes
task executable depending gets decomposed scheduled  raising  
watts makes task executable possible decompositions 
   

fia bstract r easoning p lanning c oordination

representation abstract  or uncertain  metric resource usage seen extension
tracking optimistic pessimistic resource levels  drabble   tate         computing
upper lower bounds resource usage abstract plan gives information
whether lower upper bound constraints resource may  must  must violated 
complete  representing upper lower bounds ranges bounds
potential histories  certainly know whether bounds may  must  must violated
histories  example above  tracked one range local usage        
would know definitely conflict   watts available  knowing
extra information avoid exploration infeasible search space 
      r esource ummarization lgorithm
state summarization algorithm section     recursively propagates summary conditions upwards and or hierarchys leaves  algorithm resource summarization takes
approach  starting leaves  algorithm finds primitive tasks use constant amounts
resource  resource summary task using x units resource h x x   x x       i
h x x   x x   x x i tasks duration non consumable consumable resources respectively 
moving and or tree  summarization algorithm either comes branch 
branch combined summary usage comes computation
h  mincchildren  lb local min c     maxcchildren  ub local min c     
 mincchildren  lb local max c     maxcchildren  ub local max c     
 mincchildren  lb persist c    
maxcchildren  ub persist c    
i 

lb   ub   extract lower bound upper bound range respectively  children
denote branchs children durations extended length longest child 
duration extension alters childs resource summary information childs usage profile
zero resource usage extension  instance  determining resource usage
move a b   algorithm combines two    minute tasks    minute task  resulting
summary information describes    minute abstract task whose profile might zero watt
power usage    minutes  extension move a b        local min instead
       planners reason variable durations could use       duration ranging
      
computing branchs summary information bit complicated due timing
choices among loosely constrained subtasks  take x path examples illustrate simplest subcase  subtasks tightly constrained execute serially  profiles appended together 
resulting summary usage information comes serial and computation
h  mincchildren  lb local min c     lb  c    mincchildren  ub local min c     ub  c    
pre
pre
 maxcchildren  lb local max c     lb  c    maxcchildren  ub local max c     ub  c    
 cchildren  lb persist c    
cchildren  ub persist c    
i 
pre

pre

pre
pre
lb
 c  ub
 c  respective lower upper bounds cumulative persistent usages children execute c  computations form
computations final persist 
case subtasks execute parallel identical durations slightly simpler 
usage profiles add together  branchs resultant summary usage comes

   

fic lement  urfee     barrett

move a b 
soak rays
                       

                   

soak rays
                       

soak rays
                       

figure     possible task ordering rovers morning activities  resulting subintervals 
parallel and computation
h  cchildren  lb local min c    
maxcchildren  ub local min c     non
ub  c    
non
 mincchildren  lb local max c     lb  c    cchildren  ub local max c     
 cchildren  lb persist c    
cchildren  ub persist c    
i 
non
non
ub  c  lb  c  respective sums local max upper bounds local min
lower bounds children except c 
handle tasks loose temporal constraints  consider legal orderings child
task endpoints  example  rovers early morning tasks  three serial solar energy collection subtasks running parallel subtask drive location b  figure    shows
one possible ordering subtask endpoints  breaks move a b  three pieces 
two soak rays children half  given ordering  summarization algorithm    
use endpoints children determine subintervals      compute summary information
child task subinterval combination      combine parallel subinterval summaries using
parallel and computation      chain subintervals together using serialand computation  finally  tasks summary computed combining summaries
possible orderings using computation 
describe step     generates different summary resource usages subintervals
child task  child task summary resource usage h a b   c d   e  f  i contributes one two
summary resource usages intersecting subinterval   

h a  b    c  d         i  h a  d    a  d         i 

first usage tighter  a b   c d  local ranges  second looser  a d   a d  local
ranges  since b c bounds apply subintervals containing subtasks minimum
maximum usages  tighter ranges apply one subtasks intersecting subintervals 
minimum maximum usages may occur subinterval  symmetry arguments
let us connect computation  thus one subinterval tighter local ranges
intersecting subintervals get looser local ranges  extra complexity comes
investigate subtask subinterval assignment options  instance  three subintervals
intersecting move a b  figure     three different assignments summary resource usages
subintervals  placing             one subinterval             two 
placement options result subtask n subintervals n possible subinterval assignments 
child tasks n alternate assignments  nm combinations
potential subtask subinterval summary resource usage assignments  thus propagating summary
information branch exponential number subtasks multiple internal
   summary resource usages last interval intersecting child task  replace         e  f   persist 

   

fia bstract r easoning p lanning c oordination

subintervals  however since number subtasks controlled domain modeler
usually bounded constant  computation tractable  addition  summary information
often derived offline domain  propagation algorithm takes form 
consistent ordering endpoints 
consistent subtask subinterval summary usage assignment 
use parallel and computations combine subtask subinterval summary
usages subinterval 
use serial and computation subintervals combined summary usages
get consistent summary usage 
use computation combine consistent summary usages get tasks summary
usage 
described derive summary information  discuss use it 

   identifying abstract solutions
point  detailed algorithms deriving summary conditions reasoning
potential  may  definite  must  interactions tasks based summary information  addition  outlined algorithms deriving summarized resource usage
yet discussed identify solutions abstract levels  section  show
interactions summary conditions summarized metric resource usages identify potentially
resolvable threats unresolvable conflicts among plans group agents 
    threats summary conditions
agents attempt resolve conflicts among plans considering commitments particular
decompositions ordering constraints  order this  agents must able identify
remaining conflicts  threats  among plans  present simple algorithms reasoning
threats abstract plans required conditions 
formally  set chips p ordering constraints order  threat abstract plan
p p summary condition c  another plan p  p exists iff p may clobber c    say
threat unresolvable p must clobber c  must c    decomposition choices
ordering constraints could added resolve threat 
so  simple algorithm identifying threats check see o nc  summary
conditions n plans psum must  may clobbered plan  since complexity
checking see particular condition must  may clobbered o nc   algorithms
complexity o n  c    
many coordination tasks  agents could determine certain temporal constraints
plans decomposed way  cananyway  constraints
way successfully decomposed  mightsomeway   make coordination
decisions abstract levels without entering potentially costly search valid plan merges lower
levels  formal definitions cananyway mightsomeway 

   

fic lement  urfee     barrett

a 

produce h

b 

maintenance

produce h
maintenance
move parts

move parts
c 

produce h
produce g

produce h g
maintenance
service m  m 
service

service

m 

m 

move
tool

move parts

figure     top level plans managers manufacturing domain
definition   
 cananyway  mightsomeway  order  psum  
    h  p summary f ormation   psum h h p  order 
    e e h   succeeds e  h 
definition    states plans summary information psum ordering constraints
execute way sets plans p summary information psum
execute successfully history  mightsomeway true set plans
could possibly execute successfully  could describe cansomeway order psum  
mightanyway rel psum   fashion  obvious addition could
influence search  exploring relations may interesting topic future research 
figure   a  three top level plans managers unordered respect other 
leaf plans partially expanded hierarchies comprise psum   arrows represent constraints
order  cananyway     produce g  maintenance  move parts   false several conflicts use machines transports could occur certain executions
plans described section     figure    however  mightsomeway      produce g 
maintenance  move parts   true plans might way execute successfully
shown figure   b  ordering constraints figure   b  cananyway  before      
before        produce g  maintenance  move parts   true plans execute
way consistent ordering constraints without conflict  figure  b example
mightsomeway false calibrate m  must clobber available m  muf summary precondition build h 
shown figure     algorithm determining cananyway summary conditions
simple needs check threats  mightsomeway complicated
checking unresolvable threat enough  shown figure     case
plan p must clobber p  p   could come achieve precondition   p   
thus  p may clobbers   p p     however  obviously p clobber one other 
   

fia bstract r easoning p lanning c oordination

algorithm   cananyway  mightsomeway 
input  order  psum
output  true f alse
begin function
psum psum
 consistent psum    f alse  return f alse
p sum psum
summary condition c psum
p   may clobber  must clobber  c 
c  may must  must  
return f alse
resource res
 cananyway  mightsomeway  order  psum   res   see section     
return false
return true
end function

figure     algorithm determining whether plans given summary information cananyway
mightsomeway execute successfully 
p
l

p
 l

l

l

p
l

l

l

figure     mightsomeway false even though must clobber relationship 
mightsomeway false  order determine mightsomeway f alse  agent must exhaustively
search exponential number schedules see conflicts resolved  instead
performing exponential search determine mightsomeway  use simple algorithm
figure    checks must clobber relationships  section     describe flexible
search find conflict free abstract plans scheduling abstract level 
thus  cananyway algorithm sound complete  mightsomeway algorithm
complete sound  means determining mightsomeway sound
complete  still make use algorithms sound complete planning coordination algorithm section      complexity algorithms o n  c    since
o nc  procedures determining must may clobber must run nc conditions  c
summary conditions n plans represented psum   
    summary resource usage threats
planners detect threats resource constraints different ways  planner reasons partially ordered actions  must consider combinations actions overlap together
exceed  or fall below  resources maximum value  or minimum value   polynomial algorithm

   

fic lement  urfee     barrett

ixtet planner  laborie   ghallab         planners consider total order plans simply project levels resource initial state plan 
summing overlapping usages  see conflicts  e g   chien et al       b  
finding conflicts involving summarized resource usages work way 
partial order planner  resultant usage clusters actions tested using paralleland algorithm section      total order planner  level resource represented
summarized usage  initially h x  x    x  x    x  x i consumable resource initial level
x h x  x    x  x         i non consumable resource  then  subinterval
start end times schedule tasks  summary usage computed using
parallel and algorithm  level resource computed subinterval
propagating persistent usages using serial and algorithm 
decide cananyway mightsomeway defined section      terms summary usage values resulting invocations parallel and serial and propagation algorithm end section        cananyway order  psum   res  true
potential threats  algorithms discover threat ever compute interval

lb local min i     min value res  lb persist i     min value res 
ub local max i     max value res  ub persist i     max value res  

mightsomeway order  psum   res  true possible run potentially
threats  serial and discovers run returns summary usage
ub local min i   min value res  lb persist i   min value res 
lb local max i   max value res  ub persist i   max value res  

mechanisms deriving summary information evaluating plans based
summarizations  discuss exploit planning coordination algorithm 

   hierarchical planning coordination algorithm
earlier defined algorithms reasoning group agents plans multiple levels
abstraction  describe agents efficiently plan coordinate based summary
information  describe coordination algorithm searches ways restrict decomposition ordering collective actions agent s  order resolve conflicts
maximizing utilities individual agents global utility group 
approach starts making planning decisions abstract level and  needed 
decomposes agents plans top down fashion  idea introduce information needed  introducing irrelevant details complicates search increases communication 
describing top down planning coordination algorithm  describe search techniques
heuristics algorithm use exploit summary information 
    top down hierarchical planning coordination
formalism summary conditions culminated section   algorithms determine set
plans  abstract primitive  partial set ordering constraints definitely conflict free
 cananyway  unresolvable conflicts  mightsomeway   integrate algorithms
one searches consistent plan one agents  particular algorithm
describe shown sound complete  clement         search starts
top level plans agent  solution one possible conflicts among
   

fia bstract r easoning p lanning c oordination

agents plans  algorithm tries find solution top level expands hierarchies
deeper deeper optimal solution found search space exhausted 
pseudocode description algorithm given figure    
state search partially elaborated plan represent set plans  one
agent   set temporal constraints  set blocked plans  subplans plans
leaves partially expanded hierarchies agents  set temporal constraints
includes synchronization constraints added search addition dictated
agents individual hierarchical plans  blocked subplans keep track pruned subplans 
decisions made search decentralized fashion  agents negotiate
ordering constraints adopt  choices subplans accomplish higher level plans 
decompositions explore first  algorithm described specify  or
commit to  negotiation technique  provide mechanisms identifying choices
agents negotiate  although agents make search decisions decentralized fashion  describe algorithm given centralized process requests summary
information agents coordinated 
pseudocode figure     coordinating agent collects summary information
agents plans decomposes them  queue keeps track expanded search states 
cananyway relation holds search state  dominates function determines current
solutions better every agent solution represented current search state
keeps solution dominated  mightsomeway false  search space rooted
current search state pruned  otherwise  coordinator applies operators generate new
search states 
operators generating successor search states expanding non primitive plans  blocking subplans  adding temporal constraints pairs plans  agent expands one
plans  plans summary conditions replaced original conditions
parent plan  subplans summary information ordering constraints added
search state  subplan plan added  or selected  subplans
blocked  applyoperator called select block operators  search states
generated selectable blockable subplan  respectively  blocking subplan
effective resolving constraint subplans involved  example 
inventory manager plans use transport   production manager could block subplans
using transport   leaving subplans using transport  conflict inventory managers
plan  lead least commitment abstract solutions leave agents flexibility selecting among multiple applicable remaining subplans  agents take another approach
selecting subplan  effectively blocking others  investigate preferred choice one
likely avoids conflicts 
operator add temporal constraint  new search state created alternative temporal constraint could added  successor states enqueued
backtracking needed  alternative tried  adding temporal constraints generate new search states ordering consistent global local constraints 
implementation  add constraints help resolve threats determined
must may achieves clobbers algorithms  plan expanded selected  ordering
constraints must updated subplans added 
soundness completeness coordination algorithm depends soundness
completeness identifying solutions complete exploration search space  soundness
   

fic lement  urfee     barrett

concurrent hierarchical coordination algorithm
input  set top level plans  initial state
output  set solutions  pair order constraints blocked plan choices
begin function
summarized plans     
plan p plans
p    get summary information plan p
summarized plans   summarized plans   p   
end
threats      p  p      p  p  summarized plans  mayclobber p  p     
    
  threats   
queue        
solutions     
loop
queue      
return solutions
 order  blocked  threats    pop queue 
cananyway initial state  summarized plans  order  blocked 
solution    order  blocked 
solutions   solutions  solution 
sol  sol  solutions
dominates sol    sol   
solutions   solutions     sol   
mightsomeway initial state  summarized plans  order  blocked 
operator   choose  expand  select  block  constrain  
queue   queue applyoperator operator  summarized plans  order  blocked 
return solutions
end function

figure     concurrent hierarchical coordination algorithm 
completeness defined respect achieving particular goal predicates resolving
conflicts plan hierarchies  domain modeler may represent goals abstract chips
decompose possible plans accomplish series actions agent execute
successfully 
consider algorithm would find coordinated plans manufacturing agents 
beginning search  coordinating agent gathers summary information top level
plans three agents plans  first  ordering constraints  order empty
first search state  shown figure   a  popped queue  cananyway false 
mightsomeway true state described earlier section  coordinator chooses
operator apply search state  could choose constrain order maintenance
plan produce h resolve conflicts two plans  order updated
new constraint  new search state inserted queue according ranking
function  next iteration loop  search state queue inserted
popped  coordinator finds cananyway false  mightsomeway true since
move parts may still conflict plans use transports  choose constrain
produce h move parts resolve remaining conflicts  detected next cycle
search loop cananyway found true search state  shown figure   b  

   

fia bstract r easoning p lanning c oordination

plans  two constraints order  empty set blocked plans added solution
since previously found solution dominates it  dominates function uses domain
specific criteria determining solution value alternative kept
inferior compared another dropped  manufacturing domain  one solution
dominates another finish time least one agent earlier finish times later
agents  search continues find alternative superior solutions  although agents
may decide terminate search interest time 
    search techniques heuristics
although summary information valuable finding conflict free coordinated plans abstract
levels  information valuable directing search avoid branches search
space lead inconsistent suboptimal coordinated plans  coordinator prune away
inconsistent coordinated plans abstract level quick check see mightsomeway
false  example  search somehow reached state shown figure  b  coordinator
could backtrack expanding hierarchies avoid reasoning details
plans must fail 
another strategy first expand plans involved threats  sake completeness  order plan expansions matter long expanded point
search trail cannot pruned  but  employing expand threats first  emtf 
heuristic aims driving search hierarchy find subplan s  causing conflicts others resolved quickly  similar most constrained
variable heuristic often employed constraint satisfaction problems  example  facilities
inventory managers wished execute plans concurrently shown figure   a 
abstract level  coordinator would find conflicts use transports
moving parts  instead decomposing produce h reasoning plan details
conflicts  emtf heuristic would choose decompose either maintenance move parts
conflicts  decomposing maintenance agents resolve remaining
conflicts still execute concurrently 
another heuristic coordinator use parallel emtf choose fewest threats
first  cftf   search orders states search queue ascending numbers threats
left resolve  effect  least constraining value heuristic used constraint satisfaction
approaches  mentioned section      threats identified cananyway algorithm 
trying resolve threats coordinated plan search states fewer conflicts  hoped
solutions found quickly  so  emtf heuristic ordering subplans expand 
cftf  effect  orders subplan choices  example  production manager chooses
use machine m  instead m  produce g  coordinator likely closer solution
fewer conflicts resolve  heuristic applied selecting subplan
choices choosing temporal constraints variable bindings search operator
entire set operators 
addition  trying find optimal solutions style branch and bound search 
coordinator use cost abstract solutions prune away branches search space whose
minimum cost greater maximum cost current best solution  role
dominates function description coordination algorithm section      usually

   

fic lement  urfee     barrett

a 

maintenance
produce h
move parts

b 

maintenance
service m  m 
service

service

m 

m 

move
tool

produce h

move parts

figure    

emtf

heuristic resolving conflicts decomposing maintenance plan

assumes cost utility information decomposable hierarchy actions  cost
abstract action function decompositions 

   complexity analyses
even though planner coordinator use search techniques described section    
prune search space  able find solutions multiple levels abstraction reduce
computation much doubly exponentially  section  give example
analyze complexity planning scheduling characterize cost reduction
conditions occurs 
agent interleaves execution planning coordination often must limit total computation execution cost required achieve goals  planning algorithm described section
    able search solutions different levels abstraction  manufacturing example 
implementation centralized coordinator uses algorithm find     cpu seconds solution top level agents plans shown figure   b  define cost execution
makespan  completion time  coordinated plan  cost solution    
makespan production managers plan     facilities managers     inventory
managers     solution figure   c  coordinator required     cpu seconds 
makespan coordinated plan      another solution found intermediate level
abstraction  taking    cpu seconds makespan      so  little effort 
algorithm expanded hierarchy intermediate level cost solution
reduced     thus  overall cost reduced coordinating intermediate levels 
problem  coordinating higher levels abstraction less costly
fewer plan steps  but  even though fewer plans higher levels  plans may
greater numbers summary conditions reason collected much
greater set plans below  argue even worst case number summary
conditions per plan increases exponentially hierarchy  finding solutions abstract levels
expected exponentially cheaper lower levels  first analyze complexity
   

fia bstract r easoning p lanning c oordination

summarization algorithm help reader understand summary conditions collect
greater sets higher levels 
    complexity summarization
consider hierarchy n total plans  b subplans non primitive plan  depth d  starting
zero root  shown figure     procedure deriving summary conditions works
basically propagating conditions primitives hierarchy abstract
plans  conditions non primitive plan depend immediate subplans  deriving summary conditions done quickly number subplans large 
derivation algorithm mainly involves checking achieve  clobber  undo interactions among
subplans possible total orderings subplans  as described section       checking
one relations one summary condition one subplan o bs  b subplans 
summary conditions  as discussed section       since o bs  conditions must
checked set subplans  deriving summary conditions one plan subplans
o b  s    
however  maximum number summary conditions subplan grows exponentially
hierarchy since  worst case  summary conditions merge summarization 
happens conditions subplan completely different propositions variables
sibling subplan  case  separate summary condition generated
summary condition subplan  children share conditions variable 
information collapsed single summary condition parent plan 
shown third column table figure     plan lowest level   c
summary conditions derived c pre   in   postconditions  plan level   derives c
summary conditions conditions c b subplans giving c   bc summary conditions    o bc   so  worst case   o bdi c  plan level hierarchy
plan c  non summary  conditions  thus  complexity summarizing plan
level  with subplans level      o b  b  d i     c      o b  di  c     bi plans
level  second column figure   complexity summarizing set plans level
o bi b  di  c      o b di c    shown fourth column figure  thus  complexity
  di  c     summation    
summarizing entire hierarchy plans would o d 
i   b b
 d
 
dominates  complexity simplified o b c    n   o bd   plans
hierarchy  write simply o n  c     square size hierarchy 
best case conditions variable  plan c summary
   
conditions  thus  complexity summarizing hierarchy o d 
i   b b c   
simplifies o bd   c      o nbc     case  summarization conditions tractable 
discussed section        summarization resources tractable 
    complexity finding abstract solutions
order resolve conflicts  and potentially arrive solution  particular level expansion
hierarchy  coordination algorithm checks threats plans particular
ordering constraints level  checking threats involves finding clobber relations among
plans summary conditions  complexity finding threats among n plans
summary conditions o n  s    shown section     mightsomeway algorithm 
hierarchy expanded level i  n   o bi   plans frontier expansion  plan
   

fic lement  urfee     barrett

level  plans  conds    operations  test operations   solution
plan derive summ  info  solution candidate space

 

 

   

b

      
                                 
          
            
 

 

   

b

 

 

   

b

       

 

 

o bdc 

o b  bd  c   
  o b dc  

o   

 

 

b

o bd  c 

o bb  bd  c   
  o b d  c  

o b  b d   c   
  o b dc  

o kb 

 

b 

o bd  c  o b b  bd  c   
  o b d  c  

o b  b d   c   
  o b dc  

o kb  

d  

bd  

o b c 

o bd  b  bc   
  o bd  c  

o b  d    b c    o kb  
  o b dc  

d  

bd  

 c b c
  o bc 

o bd  b c  
  o bd  c  

o b  d    bc    o kb  
  o b dc  



bd

 c

o   

o b dc  

o kb  



bi

o bd ic 

o b d ic  

o b dc  

o kbi 

 

d  

d  



figure     complexity threat identification resolution abstract levels
  o bdi c  summary conditions  so  shown fifth column table figure    
worst case complexity checking threats one synchronization set plans level
o b i  bdi c       o b d c     notice drops formula  meaning complexity
checking candidate solution independent depth level  best case summary
conditions fully merge  plan   c summary conditions  complexity checking
candidate solution o b i c     factor o b  di   faster worst case 
however  algorithm may check many synchronizations particular level finding
solution exhausting search space  fact search complexity grows exponentially
number plans   thus  shown last column table figure     search space

o kb   bi plans level constant k   thus  search space grows doubly exponentially
hierarchy based number plan steps 
refinement coordination planning algorithm  conflict detection basic operation
done resolving conflicts  so  include effect size conditions  in
addition plan steps  complexity planning coordination algorithm  must multiply

complexity check threats  thus  complexity o kb b d c    summary information

merge o kb b i c    summary information fully merges  complexity

resolving conflicts primitive level o kb b d c     resolving conflicts abstract


level speeds search doubly exponentially  factor o kb b   even summary information
merge summarization  now  completely merges  speedup factor


o kb b b  di    
   fact  np complete  clement        
   georgeff chose cluster multiple operators critical regions synchronize  fewer  regions
since would many fewer interleavings check         exploiting hierarchical structure plans 
use clusters predefined hierarchy kind advantage without needing cluster bottom
up 

   

fia bstract r easoning p lanning c oordination

level
 
 


branching
factor b

   
 

 

n
c constraints
per hierarchy

v
variables

figure     schedule n task hierarchies c constraints v variables
plans analysis  case plans  able prune
branches higher levels based summary information greatly improve search despite
overhead deriving using summary conditions  pruning effectively reduces branching
factor since branch eliminated investigating details  thus  complexity based

number plan steps becomes o k bp    fraction p b branches pruned  thus 
pruning create exponential reduction search 
    scheduling complexity
local search planner  e g  aspen  chien et al       b  backtrack  problem
solved same  one might expect complexity advantages refinement planner  however  search operations local search planner different 
previous study technique called aggregation eliminates search inefficiencies lower levels
detail task hierarchies operating hierarchies single tasks  knight  rabideau    chien 
       thus  immediately clear additional improvements scheduler could obtained
using summary information  show improvements significant  first must
provide background aggregation 
moving tasks central scheduling operation iterative repair planners  planner
effectively schedule tasks moving related groups tasks preserve constraints among them 
hierarchical task representations common way representing groups constraints  aggregation involves moving fully detailed abstract task hierarchy preserving
temporal ordering constraints among subtasks  moving individual tasks independently
parent  siblings  subtasks shown much less efficient  knight et al          valid placements task hierarchy schedule computed state resource usage profiles
hierarchy tasks context movement  hierarchys profile represents one instantiation decomposition temporal ordering abstract task
hierarchy 
consider schedule n task hierarchies maximum branching factor b expanded
maximum depth shown figure     suppose hierarchy c constraints v
variables  states metric resources   move hierarchy tasks using aggregation  scheduler

   

fic lement  urfee     barrett

must compute valid intervals resource variable affected hierarchy   scheduler
intersects intervals get valid placements abstract tasks children 
complexity computing set valid intervals resource o cc  c number
constraints  usages  abstract task children variable  c number
constraints tasks schedule variable  knight et al          n similar
task hierarchies entire schedule  c    n   c  complexity computing valid
intervals o nc     computation done v resource variables  often constant
domain   moving task complexity o vnc     intersection valid intervals
across variables increase complexity  complexity o tnr 
nr valid intervals timeline  intersecting intervals pair timelines linear
number intervals    pairs timelines need intersected get intersection
set 
summary information abstract task represents constraints children 
children share constraints resource  information collapsed single
summary resource usage abstract task  therefore  moving abstract task  number
different constraints involved may far fewer depending domain  scheduler
trying place summarized abstract task among summarized tasks  computation valid
placement intervals greatly reduced c o vnc    smaller  consider
two extreme cases constraints fully collapsed cannot collapsed
all 
case tasks hierarchy constraints variable  number
constraints hierarchy o bd   hierarchy depth branching factor  number child
tasks per parent  b  aggregation  hierarchies fully detailed first  means
complexity moving task o vnb d   c   o bd    consider using aggregation
moving partially expanded hierarchy leaves summarized abstract tasks 
hierarchies schedule decomposed level i  o bi   tasks hierarchy 
one summarized constraint representing yet undetailed subtasks beneath
constraint variable  c   o bi    complexity moving task o vnb i    thus 
moving abstract task using summary information factor o b  di    times faster
aggregation  worst case number conflicts increases number plan
steps  just refinement planner   worst case complexity resolving conflicts based

number plan steps level o kb    thus  as refinement planning  using summary
di
information make speedups o kb b  di    summary information fully collapses 
extreme tasks place constraints different variables  case 
c     hierarchy one constraint per variable  fully detailed hierarchies
contain v   o bd   different variables  complexity moving task case o nbd   
moving summarized abstract task tasks schedule decomposed level i  v
abstract task summarizes constraints subtask hierarchy
beneath it  constraints different variables constraints combine
summarized  thus  complexity moving partially expanded hierarchy
fully expanded one  case  number conflicts change depth
hierarchy conflicts always pairs n hierarchies  so 
   analysis applies state constraints  restrict discussion resource usage constraints simplicity 

   

fia bstract r easoning p lanning c oordination

extreme case  summary information reduce complexity scheduling would
incur unnecessary overhead 
complexity analyses shown different forms hierarchical problem solving 
need backtrack lower higher levels interacting subproblems  reduce size search space exponential factor  korf        knoblock        
planner scheduler using summary information witness exponential improvements without
assumption  backtracking across abstraction levels occurs within planner coordinator described section     current search state mightsomeway another subplan
higher level selected  demonstrated search space grows doubly
exponentially hierarchy number plans grows exponentially  resolving
conflicts grows exponentially number plans  thus  long planner coordinator fully expand abstract plans primitive level summary information


merges higher levels  search complexity reduced least factor kb b
level search completed  depth hierarchy  yang        suggests
ways exponential speedups obtained subplans interact based hierarchy structure 
speedups complementary summary information limits decomposition
task hierarchies compresses information manipulated planner scheduler 

   experiments
experimentally evaluate use summary information planning coordination
three different domains  evacuation domain  manufacturing domain described section     
multi rover domain  domains  define performance different ways show
range benefits abstract reasoning offers 
evaluate algorithm described section      implementation orders search states
queue generated synchronization operators precede generated
expansion selection operators  thus  going deeper part hierarchy  implementation algorithm explores orderings agents plans digging deeper
hierarchy  investigating heuristics choosing synchronization decomposition
operators topic future research 
next section report experiments evacuation domain show abstract
reasoning using summary information find optimal coordination solutions quickly
conventional search strategies  optimal solutions evacuation domain minimal global execution times evacuees must transported safety quickly possible  section     
show summary information improves local search performance significantly tasks
within hierarchy constraints resource  solutions found
level abstraction  evaluate benefits using cftf emtf heuristics
iterative repair show summary information slow search 
domains  computation time may insignificant communication costs  costs
could terms privacy self interested agents  security sensitive information could
obtained malicious agents  simply communication delay  section      show multilevel coordination fails reduce communication delay manufacturing domain example but 
domains  expected reduce communication overhead exponentially 

   

fic lement  urfee     barrett

 
s 

 

 

 

s 
t 

t 
 

 

figure     evacuation problem
    coordinated planning experiments
section  describe experiments evaluate use summary information coordinating group evacuation transports must together retrieve evacuees number locations
constraints routes  comparing emtf cftf search techniques described section     conventional htn approaches  experiments show reasoning summary
information finds optimally coordinated plans much quickly prior htn techniques 
compare different techniques ordering expansion subplans
plans direct decomposition plan hierarchies search optimal solutions 
expansion techniques expand  for subplans  select  for subplans  operators
algorithm described section     
compare emtfs expansion plans excon heuristic random selection
heuristic  excon heuristic  tsuneto et al         first selects plans achieve external
precondition  plans  selects one threatens external precondition 
case neither achieving threatening plans  chooses randomly  note
emtf additionally choose expand plans threatened external preconditions
preference whether plan achieves  threatens  threatened  expansion
plans  compare cftf depth first  dfs  random heuristic 
compare combination cftf emtf faf  fewest alternatives first 
heuristic combination dfs excon  faf heuristic employ summary
information rather chooses expand select plans fewest subplans
 currie   tate        tsuneto  hendler    nau         since summary information used 
threats resolved primitive levels  shown faf heuristic
effectively used htn planner  tsuneto et al          combination dfs excon
shown make great improvements faf domain task interactions
 tsuneto et al          show one domain cftf emtf heuristics together
outperform combinations faf  dfs  excon 
problems generated evacuation domain transports responsible
visiting certain locations along restricted routes pick evacuees bring back safety
points  transports allowed location time  coordinator must
ensure transports avoid collisions along single lane routes  addition  order avoid
risk oncoming danger  from typhoon enemy attack   transports must accomplish
goals quickly possible 
suppose two transports  t  t   located safety points s  s  respectively 
must visit locations                 respectively bring evacuees back safe
   

fia bstract r easoning p lanning c oordination

evacuate
move s   

make rounds

one switch

switch
clockwise

first route

cw   

second route

cw   

move    

counterclockwise

ccw   

ccw   

go back

ccw   

goto safe loc

move

move   s 

move   s 

move    

figure     plan hierarchy transport t 
locations shown figure     overlap locations must visit  coordinator
must synchronize actions order avoid collision  coordinators goal network includes
two unordered tasks  one transport evacuate locations responsible 
shown figure     high level task t   evacuate  decomposes primitive action
moving location   ring abstract plan traverse ring  make rounds   t 
travel one direction around ring without switching directions  switch directions once 
t  either go clockwise counterclockwise and  switching  switch directions
location   f irst route  travel farthest location needs visit switched
 second route   visited locations  continues around reaches first
safety point path  go back goto sa f e loc   move plan case t 
already location    task t  refined similarly 
suppose coordinator gathers summary information plan hierarchy attempts
resolve conflicts  looking summary information one level top  coordinator
determine t  finishes evacuating t  even begins  conflicts
since external conditions t s evacuate plan none routes traversed 
solution makespan  total completion time     steps  optimal solution plan
duration seven t  moves clockwise reaches location s   t  starts clockwise 
switches directions location    winds s   solution t  waits location  
one time step avoid collision route location   location   
generated problems four  six  eight  twelve locations  two  three four
transports  no  some  complete overlap locations transports visit  performance measured number search states expanded find optimal solution  if
compared heuristics find optimal solution  number states expanded
find solutions highest common quality within memory time bounds  chose instead cpu time measure performance order avoid fairness issues respect
implementation details various approaches 

   

fic lement  urfee     barrett

search states expanded
      

cftf rand

     
    
   
  
 
 

  

   

            e   

cftf emtf

figure     comparing emtf random expansion searching optimal solutions

figure     comparing emtf excon searching optimal solutions
scatter plot figure    shows relative performance combination cftf
combination cftf random expansion  cftf rand  
chose scatterplots compare results capture results simply trying
plot three dimensions problem size complexity  note scatter plots  axes
scaled logarithmically  points diagonal line mean emtf  x axis  performing better
rand  y axis  fewer search states required find optimal solution 
performance similar problems  cases cftf emtf outperformed
cftf  rand order magnitude more  figure    exhibits similar effect cftf   emtf
cftf excon  note runs terminated expansion       search states  data
points        the ones forming horizontal line top  indicate solution found
within memory time constraints  performance similar problems  four
points along top cftf excon finds solution  thus  although emtf greatly
emtf   cftf   emtf  

   

fia bstract r easoning p lanning c oordination

figure     comparing cftf dfs searching optimal solutions
improve performance many problems  rarely performs much worse  almost always avoids
getting stuck fruitless areas search space compared excon random heuristic 
expected since emtf focuses resolving conflicts among problematic plans
first avoids spending lot time reasoning details less problematic plans 
combination cftf emtf  pruning inconsistent abstract plan spaces  branchand bound pruning costly abstract plan spaces  all described section      much
dramatically outperforms techniques reason abstract levels  figure    shows dfsrand expanding one three orders magnitude states cftf rand  runs
terminated expansion        search states  data points         forming
horizontal line top  indicate solution found within memory time constraints 
avoiding search spaces greater numbers conflicts  cftf finds optimal near optimal solutions much quickly  figures        cftf emtf outperforms faf faf  faf
selecting plans  dfs excon one two orders magnitude problems 
last two comparisons especially emphasize importance abstract reasoning finding
optimal solutions  within maximum       expanded search states  the lowest cutoff point
experiments   cftf emtf cftf rand found optimal solutions       problems 
cftf  excon faf  faf found     dfs  excon dfs  rand found three 
surprising result faf faf performs much better dfs excon evacuation
problems contrary results given tsuneto et al         show dfs excon dominating
problems goal interactions  believe result reproduced
experiments involved hierarchies plans  experiments show
selection subplans greatly affects performance order subplans expand 
so  believe dfs excon performed worse faf faf faf better choosing
subplans excon faf stronger selecting subplans dfs 
however  main point section heuristic combinations use summary information find solutions prune search space abstract levels  cftf emtf  cftfexcon  cftf rand  greatly outperform  faf faf  dfs excon 
dfs  rand  searching optimal solutions 

   

fic lement  urfee     barrett

figure     comparing use summary information faf heuristic

figure     comparing use summary information algorithm using external conditions
    scheduling experiments
experiments describe show summary information improves performance significantly tasks within hierarchy constraints resource  solutions
found level abstraction  time  cases abstract reasoning
incurs significant overhead solutions found deeper levels  however  domains
decomposition choices critical  show overhead insignificant
cftf heuristic chooses decompositions quickly lead solutions deeper levels 
experiments show emtf heuristic outperforms simpler heuristic depending
decomposition rate  raising new research questions  use aspen planning system  chien
et al       b  coordinate rover team problem described next 

   

fia bstract r easoning p lanning c oordination

figure     randomly generated rectangular field triangulated waypoints

figure     randomly generated waypoints along corridors
      p roblem omains
domain involves team rovers must resolve conflicts shared resources  generate
two classes maps within rovers move  one  randomly generate map triangulated waypoints  figure      other  generate corridor paths circle locations
three paths center points circle represent narrow paths around obstacles
 figure      corridor map used evaluate cftf heuristic  select subset
points science locations  where rovers study rocks soil  use simple multiple traveling salesman algorithm assign routes rovers traverse perform experiments 
idea map area around lander constructed image taken upon landing
mars 
paths waypoints assigned random capacities either one  two  three
rovers traverse path simultaneously  one rover waypoint  rovers may
traverse paths opposite directions time  constraints modeled metric
resources  state variables used ensure rovers locations
leave  addition  rovers must communicate lander telemetry using shared channel
fixed bandwidth  metric resource   depending terrain waypoints  required
bandwidth varies     problems generated two five rovers  three six science locations
per rover        waypoints  general  problems contain fewer waypoints
science goals difficult interactions among rovers 
schedules consist abstract task rover decomposition tasks
visiting assigned science location  tasks decomposition three shortest
paths waypoints target science location  paths decomposition
movements waypoints  additional levels hierarchy introduced longer paths
order keep offline resource summarization tractable  schedules ranged         
tasks 

   

fic lement  urfee     barrett

      e mpirical r esults ars rovers
compare aspen using aggregation without summarization three variations
rectangular field domain  using summary information  aspen uses emtf cftf
decomposition heuristics  one domain excludes communications channel resource  no channel  
one excludes path capacity restrictions  channel only   excludes neither  mixed  
since movement tasks reserve channel resource  greater improvement performance
expected using summary information according complexity analyses section     
constraints channel resource collapse summary information derived
higher levels task hierarchy one constraint resource 
aspen use summary information  hierarchies must fully expanded  number
constraints channel resource equivalent number leaf movement tasks 
however  tasks within rovers hierarchy rarely place constraints path variables
once  channel domain corresponds worst case summarization
collapses constraints  complexity moving abstract task without summary information fully expanded hierarchy summary information partially
expanded hierarchy 
figure     top  exhibits two distributions problems channel domain 
cases  points x y diagonal   aspen summary information finds solution quickly
level abstraction  however  many cases  summary information performs notably worse
 points x y diagonal   discovered problems finding solution requires
planner dig deeply rovers hierarchies  decomposes hierarchies
level solution  difference additional time find solution two
approaches negligible  unless use summary information found solution slightly higher
level abstraction quickly   thus  time spent reasoning summary information
higher levels incurred unnecessary overhead 
worst case analysis section     showed summary information advantage even found abstract solutions  so  summary information perform
better abstract solutions found  cftf heuristic since branch
choices result small differences numbers conflicts  actually results stochastic nature aspens iterative repair  although moving abstract tasks using aggregation without
summary information would enabled aspen find solutions quickly fully expanded
hierarchies  aspen must sometimes move lower level tasks independently parents siblings order resolve conflicts lower levels  problem aspen heuristic tell
level needs move activities  sometimes chooses move activities detailed
levels unnecessarily  search lower levels search space explodes  using summary
information search higher levels lower levels abstraction better protects aspen
unnecessary search 
figure     middle  shows significant improvement summary information mixed domain compared channel domain  adding channel resource rarely affects use
summary information collapse summary constraints incurs insignificant additional
complexity  however  channel resource makes scheduling task noticeably difficult
aspen using summary information  channel domain  figure    bottom   summary information finds solutions abstract level almost immediately  problems still
complicated aspen use summary information  results support complexity

   

fia bstract r easoning p lanning c oordination

a 

b 

c 
figure     plots a  channel  b  mixed  c  channel domains
analysis section     argues summary information exponentially improves performance
tasks within hierarchy constraints resource solutions
found level abstraction 
summary information generated offline  domain modeler knows front whether
constraints significantly collapsed  thus  obvious approach avoiding cases
reasoning summary information causes unnecessary overhead fully expand start
scheduling hierarchies tasks summary information collapse 
complexity moving task hierarchy case whether fully expanded not  aspen
waste time duplicating efforts level expansion reaching level
finds solution  evaluating approach subject future work 
earlier mentioned cftf heuristic effective rectangular field problems 
choice among different paths science location usually make

   

fic lement  urfee     barrett

figure     performance using cftf heuristic

significant difference number conflicts encounteredif rovers cross paths  path
choices usually still lead conflict  set corridor problems  path choices always lead
different corridor get target location  usually path avoids conflict
path causes one depending path choices rovers  aspen uses
cftf heuristic  performance dominates chooses decompositions randomly
two problems  figure      reflects experiments coordination algorithm section  
show cftf crucial reducing search time required find solutions 
order evaluate emtf heuristic iterative repair planning  compared simple
alternative  alternative strategy  that refer level decomposition  interleave repair
decomposition separate steps  step    planner repairs current schedule
number conflicts cannot reduced  step    decomposes abstract tasks one level
returns step    spending enough time particular level expansion appears
effective  planner attempts find highest decomposition level solutions exist without
wasting time level  time spent searching solution level expansion
controlled rate abstract tasks decomposed  emtf heuristic implemented
repair method give priority detailing plans involved conflicts 
figure    shows performance emtf vs  level decomposition different rates decomposition three problems set varied performance  plotted points averages
ten runs problem  depending choice rate decomposition  the probability
task decompose conflict encountered   performance varies significantly  however  best decomposition rate vary problem problem making potentially difficult
domain expert choose  example  problem figure  tested decomposition
rates emtf outperformed use level decomposition  time  problem c using
either decomposition technique make significant difference problem b choosing
rate emtf made big difference whether use emtf level decomposition  although
examples show varied performance  results problems showed decompo 

   

fia bstract r easoning p lanning c oordination

    


level decomp
    

b
b level decomp
c

cpu seconds

   

c level decomp
   

   

   

 
 

 

  

  

  

  

  

  

emtf decomposition rate

figure     performance emtf vs  level decomposition heuristics
sition rate around     successful  suggests domain modeler may able
choose generally successful decomposition rate running performance experiments set
example problems  
demonstrated many results complexity analyses section    scheduling
summary information gains speedups  over aggregation  resolving conflicts appropriate levels abstraction  summary information collapses  scheduler gains exponential
speedups  addition  cftf heuristic enables exponential speedups decomposition
choices varying numbers conflicts 
    communication overhead
show that  depending bandwidth  latency  summary information communicated among agents  delays due communication overhead vary  communication costs
concern  one extreme message delay dominates cost  sending plan hierarchy
without summary information makes sense  extreme bandwidth costs
dominate  makes sense send summary information task separate message
requested  still  cases sending summary information tasks groups
makes sense  section explain system designer choose much
summary information send time order reduce communication overhead exponentially 
consider simple protocol agents request coordination central coordinating agent 
search feasible solution  whenever decomposes task  coordinator requests
summary information subtasks yet received  manufacturing domain 
coordinator may already summary information task move part  encounters
different instantiation task schema  still must request parameters new task 
coordinator needs subplans plan  client agent sends required information
subplans  specifying preferences each  coordinator chooses preferred
   experiments  used decomposition rate     since seemed work well 

   

fic lement  urfee     barrett

a 

b 

figure     delay communicating different granularities summary information varying a 
latency b  bandwidth

subplan  case must backtrack  chooses next preferred subplan 
coordinator finds feasible solution  sends modifications agent specifying subplans blocked agent must send wait synchronization messages  agent
choose send summary information number levels expansion requested
tasks hierarchy 
manufacturing problem described section      communication data terms numbers messages size collected point coordinator found
solution figure   c  data collected cases agents sent summary information
tasks hierarchies  one time  two levels time  once  two levels
include requested task immediate subplans  following table summarizes
numbers total sizes messages sent granularity level information 

one task time
two levels time


number messages
 
 
 

total size  bytes 
    
     
     

assuming coordinator must wait requested information continuing search
request one task one agent time  coordination delayed amount
time depending bandwidth latency message passing  total delay calculated  n       s b  n number messages sent    latency seconds 
total size messages  b bandwidth bytes per second  use n   instead n
assume agents transmit first top level summary information message
time  three messages actually incur delay   instead    
figure   a shows communication delay varies three granularities information
fixed bandwidth     bytes second   we address lack realism example
shortly   latency less   seconds  sending summary information task
separate messages results smallest communication overhead  latencies greater   
seconds  sending entire hierarchy best  sending summary information two
levels time best  latency fixed     seconds  communication delay varies
   

fia bstract r easoning p lanning c oordination

a 

b 

figure     delay varying a  latency b  bandwidth hypothetical example
bandwidth shown figure   b  bandwidth less   bytes second  sending
one time best  sending best bandwidths greater    bytes second 
sending two levels time best bandwidths between 
admittedly  values unrealistic manufacturing domain  manufacturing problem simple provided mainly interesting domain coordination  realistic problems involving manufacturing domain could much larger hierarchies require
much larger scales data sent  case realistic bandwidth latency values would
exhibit similar tradeoffs 
see this  suppose manufacturing managers hierarchies common branching
factor b depth d  tasks generally reservations similar resources throughout hierarchies  amount total summary information particular level would grow exponentially
hierarchy would number tasks  agents agreed feasible solution
depth level hierarchy  table messages size would appear follows 

one task time
two levels time


number messages
o bi  
 i  
 

total size
o bi  
o bi  
o bd  

suppose branching factor b    depth     solution found level
     summary information task   kbyte  table would look this 

one task time
two levels time


number messages
   
 
 

total size  kbytes 
    
    
      

now  fixed bandwidth     kbyte second varied latency  realistic
tradeoffs seen figure   a  here  see unless latency small  sending summary
information two levels time best  shown figure   b  fix latency one second
vary bandwidth  realistic bandwidths sending summary information two levels
time best 

   

fic lement  urfee     barrett

simple protocol illustrates communication minimized sending summary
information particular granularity  agents chose send summary information
unsummarized hierarchies instead  would need send entire hierarchies 
experiment shows  hierarchies grow large  sending entire hierarchy  all once  would take
long time  even high bandwidth  thus  using summary information  as opposed using
it  reduce communication exponentially solutions found abstract levels 
extreme  agents sent summary information one task time  latency
sending many messages grow large larger task hierarchies  solutions could
found primitive levels  sending summary information one task time would cause
exponential latency overhead compared sending entire hierarchy once  but  solutions
found intermediate levels  able send summary information intermediate
granularity minimize total delay 
however  argument assumes summary information collapses higher levels hierarchy  otherwise  sending summary information intermediate level could almost
expensive sending entire hierarchy cause unnecessary overhead  actual manufacturing domain  tasks agents hierarchies mostly constraints different resources 
summarization able reduce summary information significantly constraints
collapse  result better  case  send entire hierarchy minimize
delay  unless unusual bandwidth latency constraints  shown experiment  
even so  coordination agent still summarize hierarchies take advantage
computational advantages abstract reasoning 
section showed domain modeler minimize communication overhead communicating summary information proper level granularity  bandwidth  latency 
common depth coordination solutions known  domain modeler perform hypothetical
experiment one varying granularities summary information determine
granularity optimal  summary information collapses hierarchy  solutions
found intermediate levels  communication exponentially reduced manner 

   related work
approach taken abstract reasoning originally inspired earlier work involving
hierarchical behavior space search agents represent planned behaviors multiple
levels abstraction  durfee   montgomery         distributed protocols used decide
level abstraction coordination needed resolve conflicts there  approach capitalizes
domains resources abstracted naturally  earlier work viewed
limited  special case work presented here  justified intuitively limited
experiments analyses 
corkill studied interleaved planning merging distributed version noah planner
        recognized that  conditions affected abstract plan operator
might unknown refinement  deal overall effects preconditions
hold matter operator refined captured used identify resolve
conflicts  recognized choices refinement synchronization choices
abstract levels could lead unresolvable conflicts deeper levels  backtracking could
necessary  work directed toward avoiding backtracking using summary information
guide search 

   

fia bstract r easoning p lanning c oordination

closer relation approach  pappachan shows interleave hierarchical plan coordination plan execution cooperative agents using online iterative constraint relaxation
 oicr  algorithm  pappachan         approach  coordination achieved higher
levels abstraction flexible execution  agents decompose tasks lower
levels tighter coordination improve plan quality  oicr approach tailored toward
interleaving coordination flexible execution price completeness coordination
algorithm presented aimed complete interleaved coordination planning price
potentially delaying execution due backtracking 
planning research  hierarchical plans often represented hierarchical task networks  htns  erol et al       a   planners noah  sacerdoti         nonlin  tate 
       sipe    wilkins         o plan  currie   tate         umcp  erol et al       b   shop  
 nau  au  ilghami  kuter  murdock  wu    yaman        use search combinations
alternative courses action achieve goals within particular context  actions may partially ordered  giving timing flexibility execution  wilkins        currie   tate        
ch p representation extends htn include temporal extent partial orderings expressed
constraints starting ending timepoints action 
yang presented method  similar summarization  preprocessing plan hierarchy
order able detect unresolvable conflicts abstract level planner could backtrack inconsistent search spaces  yang         corresponds use mightsomeway
section      however  approach requires decomposition hierarchy modeled
abstract operator unique main subaction preconditions effects
parent  avoid restriction analyzing subplans conditions ordering constraints
automatically compute parents summary conditions 
approach focused resolving conflicts among agents  cox durfee       
used summary information exploit synergistic interactions  idea using summary information identify overlapping effects help agents skip actions whose effects
achieved others  thangarajah  padgham  winikoff        used summary information
rescheduling execution  representations actually subsumed ours 
work significantly postdates first reporting work paper  clement   durfee        
dsipe  desjardins   wolverton        distributed version sipe     wilkins       
hierarchical planning system  way agents use summary information reduce
communication states common constraints  dsipe filters conditions
communicated among planners using irrelevance reasoning  wolverton   desjardins        
dpocl  decompositional partial order causal link  planner  young et al         adds
action decomposition snlp  mcallester   rosenblitt         htn planners  preconditions high level effects added abstract tasks order help planner resolve
conflicts decomposition  addition  causal links specified decomposition schemas
isolate external preconditions dpocl must satisfy  however  conditions
causal links necessarily capture external conditions abstract tasks  planner
find solutions abstract levels requires tasks completely decomposed  addition  dpocl cannot determine abstract plan unresolvable conflicts  mightsomeway 
may effects hidden decompositions yet undetailed tasks could achieve
open preconditions  deriving summary conditions automatically using algorithms determining causal link information  e g  must achieve   planning coordination algorithm find

   

fic lement  urfee     barrett

reject abstract plans search without adding burden domain expert specify redundant conditions causal links abstract tasks 
dpocl  tms  a framework task analysis  environment modeling  simulation 
allows domain modeler specify wide range task relationships  decker        
work offers quantitative methods analyzing simulating agents well interactions 
interactions represented discovered using summary conditions 
discover information analysis rather depending model developer
predefine interactions 
groszs shared plans model collaboration        presents theory modeling multiagent
belief intention  shared plans work directed toward cooperative agents  represents
action hierarchies provides mental models higher level represented article 
however  use analysis summary information complements groszs work providing
way automatically represent efficiently reason intentions agents multiple levels
abstraction  future work needed understand summary information bridged
mental states agents exploit techniques employed shared plans work based
bdi  belief desire intention  models agents  rao   georgeff        
analysis hierarchical planning  yang        explains that  case interacting subgoals  certain structures hierarchy minimize interactions reduce worst case
planning complexity exponentially  however  complexity analyses section   explain using summary information achieve exponential performance gains addition achieved
restructuring plan hierarchies according yangs analysis limiting decomposition task
hierarchies compressing information manipulated coordinator  planner  scheduler 
shop    nau et al         htn planner uses domain translation technique reason
durative action  however express temporal extent way planner
given here  model differs supports ordering relationships endpoints well
conditions effects actions execution  may domain translation
could achieve expression similar constraints solutions systems 
formal model expressions htn planning 
siadex  castillo et al         another htn planner handles temporal extent use
expressive simple temporal networks  dechter  meiri    pearl         performance
improvement techniques reported siadex temporal reasoning specific htns 
thus  work complementary ours  however  work needed understand
summary information exploited conjunction forward expansion approach
shop   siadex use perform competitively planning competition problems 
another class hierarchical planners based abstrips  sacerdoti        introduces conditions different levels abstraction critical conflicts handled higher levels
abstraction less important  or easier  conflicts resolved later lower levels 
approach similarly resolves conflicts abstract levels  planning decisions may consistent
conditions lower levels resulting backtracking  summary information provides means
make sound complete decisions abstract levels without need decompose check
consistency lower levels  however  resolving conflicts based criticality still improve
performance complement approach 
allens temporal planner        uses hierarchical representations tasks could applied
reasoning concurrent actions multiple agents  however  exploit hierarchy
reasoning abstraction levels separately generates plan proving consistency
   

fia bstract r easoning p lanning c oordination

collective constraints  allens model temporal plans        subsequent work interval
point algebra  vilain   kautz        strongly influenced hierarchical task representation
algorithms reason them 
many  many models theories concurrency  older examples include
automata representations  petri nets hoares theory communicating sequential processes
 glabbeek         many temporal logics computational tree logic  ctl 
emerson   halpern        allow modal expressions proposition holding
possible worlds time  time  next state  eventually 
proposition holds  another language specifying manufacturing processes process
standardized    years  bock        schlenoff  knutilla    ray         many
logics could used define summary conditions relations mightsomeway  however  found logics awkward representing inconditions defining summary
conditions terminology used article simplifies definitions 
model checking uses temporal logics verify different properties system models  software 
hardware  such correctness  deadlock free  convergence   fact  model checking
planning algorithms used interchangeably problems  e g   giunchiglia  
traverso         context model checking  summary information set properties
 akin specifiable ctl  system model  as planning domain  summarize system
variable requirements  conditions  assignments  effects   thus  model checking algorithm
could use summary information efficiently identify resolve potential requirement violations bugs  condition conflicts  deadlock  resource conflicts  system model operation
 planning scheduling problem instantiations  

   conclusion
article provides formalization hierarchical task network planning that  unlike umcp
formalism  erol et al       b   includes actions temporal extent  introduce sound
complete algorithm used generate plan  coordinate group agents hierarchical plans  interleave planning coordination 
algorithms summarizing propositional state metric resource conditions effects
abstract levels mechanisms reason summary information facilitate
construction planning coordination systems reason plans multiple levels
abstraction  mechanisms reasoning summary information determine whether
task  at level abstraction  must may achieve  clobber  undo condition another task
partial order constraints endpoints tasks  built mechanisms  mechanisms
determine whether group agents decompose execute set partially ordered abstract
tasks way  cananyway   might decompose execute way  mightsomeway  
cannot execute consistently way  mightsomeway  
algorithms enable planning system find solutions multiple levels abstraction
without needing fully detail task hierarchy  abstract solutions support flexible execution
remaining uncommitted alternative methods selected runtime  based
circumstances  achieve plan subgoals 
complexity analyses experiments different problem domains quantified benefits using summary information refinement planning local search scheduling algorithm 


potential doubly exponential speedup o kb b b  di    k ways resolve conflict 

   

fic lement  urfee     barrett

hierarchy branching factor b  depth hierarchy d  abstract solution depth i  exponential speedup obtained abstract solutions found  fewer summary conditions
abstract levels  alternative decomposition choices lead varying numbers threats 
conditions exponential improvement significant relaxation compared prior work 
performance improvement greater 
domain modeler run summarization algorithms offline library plan hierarchies
summary information available coordination planning set goal tasks
supported library  using algorithms reasoning summary information  agents
discover coordinate states resources must coordinate negotiate  communicating summary information different levels abstraction reduces
communication costs exponentially conditions similar reducing computation time 
use summary information local search planner  like aspen  section      another
contribution work  strength local search algorithms ability efficiently reason
large numbers tasks constraints metric resources  state variables  complex
resource classes  integrating algorithms reasoning summarized propositional state
metric resource constraints heuristic local search planner scheduler  enable scalable
planning systems scale even larger problem domains  use summary information
different style planner demonstrates applicability abstract reasoning improving
performance different kinds planning  and plan coordination  systems 
future work needed evaluate use summary information planning
scheduling systems wider classes problems requiring expressive representations
resources temporal constraints  already  approach exploiting cooperative action
among agents based summary information developed  cox   durfee        
promising approaches include abstracting plan information  probabilistic conditions
effects classes resources states  e g  location regions sub regions   work
needed understand communicate summary information distributed
planning system 

acknowledgments
authors wish thank pradeep pappachan  gregg rabideau  russell knight help
implementation  thank anonymous reviewers many valuable suggestions 
work performed jet propulsion laboratory  california institute technology 
contract national aeronautics space administration  university michigan
supported part darpa  f                 

appendix a  algorithms computing interval relations
algorithms determining whether defined relations hold summary conditions
plans p use point algebra constraint table  vilain   kautz         point algebra
table constructed interval endpoints corresponding executions plans p 
row column p ts  e   start endpoint execution e p  p  f  e   finish
endpoint  added plan p p  cell table gives time point constraint
row column                       empty      means

   

fia bstract r easoning p lanning c oordination

p
p 
p 
p   

p
 
 
 
 

p 
 
 
 
 

p 
 
 
 
 

p   
 
 
 
 

table    point algebra table p contains p 
p
p 
p 
p   

p
 
 

 

p 
 
 
   
   

p 

   
 
 

p   
 
   
 
 

table    point algebra table p p 
points unconstrained  cell empty  allowed temporal relations  indicating
inconsistency  table   shows point algebra table plans p p  constrained
ps execution contains p    table   shows table start p constrained
earlier start p    transitive closures constraint relations  table  
computed table   constraining p    p     by putting   cell row p 
column p      computing transitive closure  o n    algorithm n points  vilain  
kautz         transitive closure computed  constraints point
point looked constant time 
similarly  constraints order p added table  transitive closure
computed get constraints entailed order  needs done
p order determine achieve clobber relationships defined next section 
determine plan q ps subplans temporally ordered always   f irst last 
 q   q    constrained  before  after  equal points point algebra table
ps subplans  done looking entry row  q   q    checking see
constraint                  case  q not always   f irst last  
q always not   f irst last  row  q   q    entry       
constraint  otherwise  sometimes   f irst last  
interval i  covered set intervals    i    i            ik   interval
found intersects i  intersects nothing i  particular covering problem describes
intervals terms partial order endpoints  represent intervals point algebra
table  algorithm covering problem check see i  covered looking
pairs intervals see overlap  i  covered     either intervals meet either
 

  i        intervals endpoint contained i 
meet opposite endpoint another interval endpoint i        intervals
overlapping i    otherwise  i  covered  examples given figure    

   

fic lement  urfee     barrett

a 
 

 

b

 
c

c 

e

b 



f
 
g



h



figure     a  interval covered b  c  d  b  e covered f  g  h  c 
covered 

appendix b  algorithms must may asserting summary conditions
describe algorithms determining temporal plan relationships based summary information  used build algorithms determine whether plan must may achieve 
clobber  undo condition another particular ordering constraints 
definitions algorithms throughout section given within context set
plans p corresponding set summary information psum   set ordering constraints order 
set histories h including histories e h  includes execution e
plan p es subexecutions  e h  satisfies constraints order  concerned
ordering plan execution intervals timing conditions  themselves 
anything whether conditions may need met must met plan
execution 
first  order determine whether abstract plan executions achieve  clobber  undo
conditions others  agent needs able reason summary conditions asserted
required met  ultimately  agent needs able determine whether partial ordering
abstract plans succeed  may case agents action fails assert summary
condition required action another agent  therefore  formalize means
action attempt assert summary condition require summary condition
met  definitions rely linking summary condition plan chip conditions
summarizes subplans plans decompositions  thus  first define means
summary condition summarize conditions 
definition   
summary condition c summarizes condition   condition set conds
plan p iff c added procedure deriving summary information
summary condition set p          c   either c added   condition
set conds p   p    c added summary condition subplan p 
summarizes   conds p 
example  at bin   a  precondition start move plan moving part bin 
machine m   as given section       deriving summary conditions start move 

   

fia bstract r easoning p lanning c oordination

at bin   a  added summary preconditions  thus  summary precondition at bin  
a muf summarizes at bin   a  preconditions start move 
definition   
execution e p requires summary condition c met iff c
summary condition ps summary information  condition   condition
set conds p  summarized c  f irst c     ts  e   last c     f  e  
always c   within  ts  e  t f  e    sometimes c   execution
subplan p d e  requires summary condition c  met t  c 
summarizes   conds p   
so  basically  execution requires summary condition met whenever conditions
summarizes required  execution build g summary precondition at a m  tray   
execution requires summary condition met ts  build g  at a  m  tray  
precondition build gs first subplan summarized build gs summary precondition 
definition   
execution e p attempts assert summary condition c iff c
summary condition ps summary information  condition   condition
set conds p  summarized c  f irst c   always c   smallest
interval ts  e  start end execution follows ts  e  
last c     f  e   sometimes c   execution subplan p d e 
attempts assert summary condition c  t  c  summarizes   conds p   
say execution attempts assert summary condition asserting condition
fail due simultaneous assertion negation condition  example
requiring summary condition  executions build g  produce g m   produce h
assert summary postconditions m  becomes available f  build g  
order agents determine potential interactions among abstract plans  such clobbering achieving   need reason summary condition asserted one plan
relation asserted required another  based interval point algebra constraints
set abstract plans  agent specifically would need able determine whether plan
would assert summary condition time another plan requires asserts summary
condition state variable  addition  reason clobbering inconditions  agent
would need determine summary condition would asserted time summary incondition c required  asserted c   agents need detect summary postcondition
would asserted time another summary postcondition c  asserted c  
consider cases executions attempt assert summary in  postcondition
time incondition asserted cases  clobber relations already
detected executions always require summary inconditions attempt assert 
example  equip m  attempted assert incondition m  unavailable
time build g attempted assert postcondition m  available  incondition would
clobbered postcondition 
case ordering constraints allow alternative synchronizations abstract
plans  assertions summary conditions may come different orders  therefore  formalize
must assert may assert determine relationships must may occur respectively 
mentioned beginning section    use must may based disjunctive orderings existence summary conditions different decompositions 
   

fic lement  urfee     barrett

 
 
 
 

 
 
 

 
 

  
  

  
  
  
  

  
  
  
  

c  post p   
last


f
 
c  in p   
always


f
c  post p   
last

f
c  in p   
always

f
c  post p   
last


f
f
c  in p   
always


f
f

p  must assert c  c
order must impose
constraints

p  must assert c  c
order must impose
constraints

p    p
p    p
p    p
p    p

p      p
p      p
p      p
p      p


f
 
c in p 
always
 
 

p    p
p  p
f alse

p    p
p  p
f alse

p    p
p    p

p    p
p    p

 
 
c post p 
last

f

f

p  p
f alse

p    p
f alse

p    p 
p    p
p    p 
p    p

p      p 
p    p
p    p 
p    p


f

f

p    p 
p  p
f alse
f alse

p    p 
p  p
f alse
f alse

c pre p 
f irst

f
 
 

table    table must assert by before algorithm
following definitions algorithms must  may assert  assume c c  summary
conditions plans p 
definition   
p  p must assert c   by  before  c iff histories h h
e top level execution e h  p p requires c met t 
e  top level execution p  e h     e  attempts assert c 
     t   t      t  
must assert algorithm described table    p  must assert c  c iff order entails
relationship given row corresponding type timing two conditions  rows
table indicate timing summary conditions constraints order must dictate
must assert true  f table indicate whether timing column true
false condition    means timing doesnt matter condition case 
example  row   says case c  sometimes  last  postcondition p    c
incondition p timing  order must require end p  start
p order p  must assert c  time c asserted required 

   

fia bstract r easoning p lanning c oordination

 
 
 
 

 
 

 
 
 
  

  
  

  
  
  
  

  
  

c  post p   
last


f
f
c  in p   
always
 
 
c  post p   
last


f
f
c  in p   
always
 
 
c  post p   
last


f
f
c  in p   
always
 
 

p  may assert c  c
order cannot impose
constraints

p  may assert c  c
order cannot impose
constraints

p      p
p    p 
p  p
p  p 

p    p
p    p 
p  p
p  p 


f
c in p 
always

f

f

p  p
p  p 

p  p
p  p 

p      p
p    p 
p  p
p  p 

p      p
p    p 
p  p
p  p 


f
c post p 
last

f

f

p    p
p  p 

p  p
p  p 

p      p 
p    p 
p  p 
p  p 

p    p 
p    p 
p  p 
p  p 


f

p  p 
p  p 

p  p 
p  p 

c pre p 
f irst

f

f

table    table may assert by before algorithm

 
 
 
 

 
 
 
 

c  post p   
last


f
f
c  in p   
always


f
f

p  must assert c  c
order must impose
constraints

c in p 
always

f

f

p      p p      p 
f alse
p  p p    p 
f alse


f

f

p  p p    p 
f alse
f alse
f alse

c  post p   
last


f
f
c  in p   
always


f
f

c in p 
always

f

f

p    p
p    p
p    p
p    p






p    p 
p    p 
p  p 
p  p 


f

f

p    p
p    p
p    p
p    p






p  p 
p  p 
p  p 
p  p 

table    table must may assert algorithm

   

p  may assert c  c
order cannot impose
constraints

fic lement  urfee     barrett

 
 
 
 

c  post p   
last


f
f

c post p 
last

f

f

p  must assert c  c
order must impose
constraints
p      p 
f alse
f alse
f alse

c  post p   
last


f
f

c post p 
last

f

f

p  may assert c  c
order cannot impose
constraints
p       p 
p p    p 
p    p  p  p 
p    p p  p 
p   

table    table must may assert algorithm
definitions algorithms assert relationships similar  tables     describe
logic algorithms  may relationships  algorithm returns true iff none
corresponding ordering constraints table imposed  can deduced from  order 
illustrate relationships example figure    figure  a agents plans
unordered respect other  part g produced either machine m  m  depending potential decompositions produce g plan  produce g must assert c    must 
last available g  c   must  f irst available g  summary preconditions move g
matter plans decomposed  for executions histories plans
ordering constraints figure   execution produce g attempts assert c  execution move g requires c met  algorithm verifies finding
end produce g ordered start move g  row   table     case
equip m  tool may assert c    must  last available m   c   may  sometimes available m  
summary preconditions produce g two plans unordered respect
other  history equip m  tool precede produce g  algorithm finds
true since equip m  constrained start start produce g  row   table    
figure  b  move tool may assert c    must  last f ree transport   c   may  sometimes
f ree transport   produce gs summary inconditions history move tool attempts assert c  time produce g using transport  move part machine
m   addition  equip m  tool must assert c    must  last available m   c   may  last
available m   produce gs summary postconditions equip m  tool attempts assert
c  time produce g requires c met  end section     gives examples 

references
allen  j   kautz  h   pelavin  r     tenenberg  j          reasoning plans  morgan kaufmann 
allen  j  f          maintaining knowledge temporal intervals  communications acm 
               
allen  j  f     koomen  j  a          planning using temporal world model  proceedings
international joint conference artificial intelligence  pp         
bock  c          unified process specification language  requirements modeling process  tech 
rep  nistir       national institute standards technology 
castillo  l   fdez olivares  j   garca perez  o     palao  f          efficiently handling temporal
knowledge htn planner    th international conference automated planning
   

fia bstract r easoning p lanning c oordination

scheduling  icaps      pp        aaai 
chien  s   knight  r   stechert  a   sherwood  r     rabideau  g       a   using iterative repair
improve responsiveness planning scheduling  proceedings international
conference ai planning scheduling  pp         
chien  s   rabideu  g   knight  r   sherwood  r   engelhardt  b   mutz  d   estlin  t   smith  b  
fisher  f   barrett  t   stebbins  g     tran  d       b   automating space mission operations
using automated planning scheduling  proc  spaceops 
clement  b          abstract reasoning multiagent coordination planning  ph d  thesis 
university michigan  ann arbor 
clement  b     durfee  e          top down search coordinating hierarchical plans
multiple agents  proceedings international conference autonomous agents 
corkill  d          hierarchical planning distributed environment  proceedings
international joint conference artificial intelligence  pp         
cox  j  s     durfee  e  h          discovering exploiting synergy hierarchical planning agents  proceedings international joint conference autonomous agents
multiagent systems  pp         
currie  k     tate  a          o plan  open planning architecture  artificial intelligence     
     
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence     
     
decker  k          environment centered analysis design coordination mechanisms  ph d 
thesis  university massachusetts 
desjardins  m     wolverton  m          coordinating distributed planning system  ai magazine 
            
drabble  b     tate  a          use optimistic pessimistic resource profiles inform
search activity based planner  artificial intelligence planning systems  pp         
durfee  e  h     montgomery  t  a          coordination distributed search hierarchical
behavior space  ieee transactions systems  man cybernetics                  
emerson  e     halpern  j  y          decision procedures expressiveness temporal logic
branching time  journal computer system sciences             
ephrati  e     rosenschein  j          divide conquer multi agent planning  proceedings
national conference artificial intelligence  pp         
erol  k   hendler  j     nau  d       a   semantics hierarchical task network planning  tech 
rep  cs tr       university maryland 
erol  k   nau  d     hendler  j       b   umcp  sound complete planning procedure
hierarchical task network planning   proceedings international conference ai
planning scheduling 
fagin  r   halpern  j   moses  y     vardi  m          reasoning knowledge  mit press 
firby  j          adaptive execution complex dynamic domains  ph d  thesis  yale university 
   

fic lement  urfee     barrett

georgeff  m  p          communication interaction multiagent planning  proceedings
national conference artificial intelligence  pp         
georgeff  m  p          theory action multiagent planning  proceedings national
conference artificial intelligence  pp         
georgeff  m  p     lansky  a          procedural knowledge  proceedings ieee              
     
giunchiglia  f     traverso  p          planning model checking  proceedings  th
european conference planning  pp       london  uk  springer verlag 
glabbeek  r  v          notes methodology ccs csp  theoretical computer science 
                originally appeared report cs r      cwi  amsterdam       
grosz  b     kraus  s          collaborative plans complex group action  artificial intelligence 
           
huber  m          jam  bdi theoretic mobile agent architecture  proceedings international conference autonomous agents  pp         
knight  r   rabideau  g     chien  s          computing valid intervals collections activities shared states resources  proceedings international conference ai
planning scheduling  pp         
knoblock  c          search reduction hierarchical problem solving  proceedings
national conference artificial intelligence  pp         
korf  r          planning search  quantitative approach  artificial intelligence           
laborie  p     ghallab  m          planning sharable resource constraints  proceedings
international joint conference artificial intelligence  pp           
lansky  a          localized search controlling automated reasoning  proceedings
darpa workshop innovative approaches planning  scheduling control  pp     
    
lee  j   huber  m  j   durfee  e  h     kenny  p  g          umprs  implementation
procedural reasoning system multirobot applications  proceedings aiaa nasa
conference intelligent robotics field  factory  service  space  pp         
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
national conference artificial intelligence  pp         
muscettola  n          hsts  integrating planning scheduling  intelligent scheduling         
nau  d   au  t   ilghami  o   kuter  u   murdock  j   wu  d     yaman  f          shop  
htn planning system  journal artificial intelligence research             
pappachan  p          coordinating plan execution dynamic multiagent environments  ph d 
thesis  university michigan  ann arbor 
pratt  v  r          semantical considerations floyd hoare logic    th annual ieee symposium foundations computer science  pp         
rao  a  s     georgeff  m  p          bdi agents  theory practice  proceedings
international conference multi agent systems  san francisco 
   

fia bstract r easoning p lanning c oordination

sacerdoti  e          planning hierarchy abstraction spaces  artificial intelligence       
       
sacerdoti  e  d          structure plans behavior  elsevier north holland 
schlenoff  c   knutilla  a     ray  s          interprocess communication process specification language  tech  rep  nistir       national institute standards technology 
tate  a          generating project networks  proceedings international joint conference
artificial intelligence  pp         
thangarajah  j   padgham  l     winikoff  m          detecting   avoiding interference
goals intelligent agents  proceedings international joint conference artificial
intelligence  pp         
tsuneto  r   hendler  j     nau  d          space size minimization refinement planning 
proceedings european conference planning 
tsuneto  r   hendler  j     nau  d          analyzing external conditions improve efficiency
htn planning  proceedings national conference artificial intelligence  pp 
       
vilain    kautz  h          constraint propagation algorithms temporal reasoning  proceedings national conference artificial intelligence  pp         
weld  d          introduction least commitment planning  ai magazine              
wilkins  d  e          ai planners solve practical problems   computational intelligence 
             
wolverton  m     desjardins  m          controlling communication distributed planning using
irrelevance reasoning  proceedings national conference artificial intelligence 
pp         
yang  q          formalizing planning knowledge hierarchical planning  computational intelligence             
yang  q   ed            intelligent planning  decomposition abstraction based approach 
springer 
young  m   pollack  m     moore  j          decomposition causality partial order planning 
proceedings international conference ai planning scheduling  pp         

   


