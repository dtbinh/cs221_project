journal of artificial intelligence research                  

submitted        published      

algorithms and limits for compact plan representations
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department of computer science
linkoping university
se        linkoping  sweden

abstract
compact representations of objects is a common concept in computer science  automated planning can be viewed as a case of this concept  a planning instance is a compact
implicit representation of a graph and the problem is to find a path  a plan  in this graph 
while the graphs themselves are represented compactly as planning instances  the paths
are usually represented explicitly as sequences of actions  some cases are known where
the plans always have compact representations  for example  using macros  we show that
these results do not extend to the general case  by proving a number of bounds for compact
representations of plans under various criteria  like efficient sequential or random access
of actions  in addition to this  we show that our results have consequences for what can
be gained from reformulating planning into some other problem  as a contrast to this we
also prove a number of positive results  demonstrating restricted cases where plans do have
useful compact representations  as well as proving that macro plans have favourable access
properties  our results are finally discussed in relation to other relevant contexts 

   introduction
the usage and study of representations of objects that are much smaller than the objects
themselves is commonplace in computer science  most of us encounter such representations
on a daily basis in the form of zipped files  mp  files etc  for such practical cases  we usually
talk about compressed objects  while the terms compact and succinct are more common
in theoretical studies  the meaning of the terms vary but a common and interesting case
is when the size of the representation is at most polylogarithmic in the size of the object 
sometimes it is sufficient to just compute a compact representation of an object  for instance 
when archiving a file  in other cases the representation must also support various operations
efficiently without first unpacking the object into an explicit representation  performing
operations on a compact representation is often harder than performing the same operation
on an explicit object  but there are cases when a compact representation can make it easier
by emphasising some inherent structure in the object 
one archetypical case of using compact representations is automated planning  although
it is seldom viewed in that way  a planning instance is an implicit representation of a graph
that is typically exponentially larger than its representation  the instance  and where the
solutions  the plans  are paths in this graph  consider  for example  a strips instance with
n variables  these variables implicitly define a state space with  n states and an action with
m preconditions define  nm arcs in the graph  similarly  we can define instances where the
paths are of exponential length too  although the planning instances themselves are already
c
    
ai access foundation  all rights reserved 

fibackstrom   jonsson

compact representations  very little attention has been paid to compact representations of
the solutions  which are usually represented explicitly  this paper introduces and analyses
a number of such compact representations 
if we first turn to computer science in general we find that compact representations
of arbitrary strings is an intensively studied field  for example  charikar et al         and
rytter        address the problem of approximating the smallest string representation using
a compressed grammar  bille et al         show that such representations permit efficient
access and matching operations  while jansson  sadakane  and sung        demonstrate
representations with efficient edit operations  more structured objects than arbitrary strings
can potentially have more compact representations  the following are some examples 
displaying positive as well as negative results in various areas  both galperin and wigderson
       and wagner        study the complexity of common graph operations when the
graphs are implicitly represented as circuits that tell whether two vertices are connected 
balcazar        uses a variant of that approach to study the complexity of search in ai 
using a circuit that generates the adjacency list for a vertex  bulatov and dalmau       
present an efficient algorithm for certain csp problems that relies on using a compact
representation of the set of solutions  liberatore and schaerf        study preprocessing in
model checking with focus on the size of the preprocessed parts  cadoli et al         study
various formalisms for knowledge representation and study when problems modelled in one
formalism can be transformed into another formalism with at most a polynomially larger
representation 
one approach to compact representations in various areas is the use of macros  this
concept has been widely used for a long time also in planning  although seldom for the
purpose of providing compact representations  an exception is the following case  the  s
class  jonsson   backstrom      b  of planning instances has the property that optimal
plans can be of exponential length but it is always possible to decide in polynomial time
if there is a plan or not  gimenez and jonsson        showed that plans for the  s class
always have a polynomial size representation using macros  and that macro plans can even
be generated in polynomial time  that is  although the plan may be of exponential length 
and thus necessarily take exponential time to generate  it is possible to generate a compact
representation of it in polynomial time  jonsson        later demonstrated similar results
for a number of other classes  although these particular classes of planning instances may
still be too restricted to be of much practical use  the principle of compressing the solution
using macros is an interesting tool both for planning and plan explanation 
other approaches to compact plan representation appear only sparingly in the literature 
a notable exception is liberatore      a  who studies two concepts for plan representation
that have efficient random access and efficient sequential access respectively  just like macro
plans these are examples of representing one long plan compactly  we might also consider
representing a large set of plans compactly  for instance  plan recognition may have to
simultaneously consider an exponential number of candidate plans  geib         although
seldom viewed in that way  also a reactive plan is a representation of a large set of plans 
one for each state from which the goal can be reached  it is  however  known that reactive
plans cannot be both compact  efficient and correct in the general case  jonsson  haslum 
  backstrom         although these properties are important  for instance  in spaceship
applications  williams   pandurang nayak         pomdps may similarly be thought of
   

fialgorithms and limits for compact plan representations

as a probabilistic variant of reactive plans and compactness of representations is important
also in this case  boutilier   poole         yet another case is when the size of the plan
is big but the plan is not necessarily long  which can occur for various types of branching
plans  as in contingent planning  bonet   geffner         these three different concepts
are not isolated from each other  for instance  bonet        casts contingent planning
into the problem of conformant planning  that is  a branching plan is represented as one
long non branching plan  with the branches appearing as subplans  in all these cases  it
is interesting to know if the objects in question have compact representations  although
a compact representation can save space  this may be secondary in many cases  a more
important aspect is that if an object has a compact representation then the object has some
inherent structure that we may exploit also for other purposes  for instance  if we represent
a set of many plans then a representation using recursive macros  or similar  can emphasize
the differences and similarities between the plans  this make both comparisons and other
operations on the plans more efficient  similarly  in the case of branching plans we might
want to exploit a structure that clearly displays both what two branches have in common
and where they differ 
the positive results on macro representations  gimenez   jonsson        jonsson       
prompt the obvious question whether long plans can always be compressed using macros
 or any other method   we show in this paper that this is unlikely  no matter what type
of compact representation we try to use  macro plans  finite automata or whatever   the
remainder of the paper is organized as follows  section   introduces basic notation and
concepts as well as the planning framework used in the paper  and it also contains some
useful definitions for the complexity results  we then first ask  in section    whether all
 optimal  plans for an instance can have compact representations  we find that the answer
is no  it is not possible  neither by macros nor any other method  however  the results do
not exclude that some plans for each instance can have compact solutions  in section   we
thus restrict the question to whether there is a uniform compact representation of one plan
for each solvable instance  more precisely  we ask if there is an algorithm that corresponds
to one compact representation for each solvable instance  we show that such an algorithm
is unlikely to exist if it must also be able to access the actions of the plan in some useful way 
in section   we turn to the non uniform case  asking if each solvable instance has at least
one plan that has a compact representation  we primarily consider representations that
can efficiently access the actions of the plan sequentially or randomly  we show that also
this seems unlikely in the general case  but that there are interesting special cases where
such representations do exist  in this section we also investigate macro representations
and extend the results by gimenez and jonsson in two ways  we prove that all plans
that have a polynomial size macro representation can be random accessed in polynomial
time without having access to the full plan  however  we also prove that we cannot always
represent plans compactly using macros  in section   we analyse whether we can get around
the problem of long plans by reformulating planning to some other problem  also this is
answered negatively  if we actually ask for a plan for the original problem  then the problem
is inherently intractable also when using reformulation  however  even if considering only
the decision problem it still seems not possible to make planning simpler by reformulation 
finally  section   contains a discussion of how the results in the paper are related to and
relevant for various other topics like adding information to guide planners  causal graphs
   

fibackstrom   jonsson

and plan explanation  the paper ends with a summary of the results together with a list
of open questions 
some of the results in this paper have appeared in a previous conference publication
 backstrom   jonsson      b  

   preliminaries
this section consists of three parts  the first part introduces some general notation and
terminology used in the paper  the second part defines the two planning frameworks used
in the paper  finite functional planning and propositional strips  and presents some
constructions that will be frequently used  the third part briefly recapitulates the concept
of advice taking turing machines and also defines the  sat problem that will be used on
several occasions in the paper 
    general notation and terminology
a sequence of objects x    x            xn is written hx    x            xn i  with hi denoting the empty
sequence  given a set x of objects  the set of all sequences over x  including hi  is denoted
x    for a set  sequence or other aggregation x of objects  we write  x  to denote the
cardinality  the number of objects  of x and we write   x   to denote the size  the number
of bits of the representation  of x  the composition of two functions f and g is denoted
f  g and is defined as  f  g  x    f  g x   
the negation of a propositional atom x is denoted x  a literal is either an atom or
its negation and the set l x  of literals over a set x of atoms is defined as l x   
 x  x   x  x   negation is extended to literals such that   is the same literal as    negation
is also extended to sets such that if x is a set of literals then x           x   let y be
a subset of l x  for some set x of atoms  then p os y      x  x   x  y   is the set
of atoms that appear positive in y   n eg y      x  x   x  y   is the set of atoms that
appear negated in y and atoms y     p os y  n eg y    the set y is consistent if p os y  
n eg y   is empty and a set z of atoms satisfies y if both p os y    z and n eg y  z    
the update operator n is a binary function such that given a set x of atoms and a set y
of literals  x n y is a set of atoms defined as x n y    x  n eg y     p os y   
    planning
for positive results on compact representations  we want the results to apply to as general
and powerful planning languages as possible  so the results hold also for all languages that
are more restricted  hence  we use the finite functional planning formalism  backstrom  
jonsson      a   which makes a minimum of assumption about the language  except that
it is a ground language over state variables with finite domains 
definition    a finite functional planning  ffp  frame is a tuple hv  d  ai where v is an
implicitly ordered set of variables  d   v  n is a domain function that maps every variable
to a finite subset of the natural numbers and a is a set of actions  the frame implicitly
defines the state space s f     d v            d vn    where v            vn are the variables in
v in order  the members of s f   are referred to as states  each action a in a has two
associated total functions  the precondition pre a    s f           and the postcondition
   

fialgorithms and limits for compact plan representations

post a    s f    s f    for all pairs of states s  t  s f   and actions a  a  a is from s to t
if both
   pre a  s      and
   t   post a  s  
a sequence    ha            a  i  a is a plan from a state s   s f   to a state s   s f  
if either
      hi and s    s  or
   there are states s            s    s f   such that ai is from si  to si  for    i     
an ffp instance is a tuple p   hv  d  a  i  gi where f   hv  d  ai is an ffp frame 
i  s f   is a state and g   s f           is a total function  a state s  s f   is a goal
state for p if g s       the goal g is reachable from a state s  s f   if there is a plan from
s to some goal state for p  a solution for p is a plan from i to some goal state s  s f   
a solution for p is called a plan for p 
the complexity of computing the pre  and postconditions of the actions and of the goal
function is referred to as step complexity  in this paper  we will only consider the subclass
ffp  p   which consists of all ffp frames and instances with polynomial step complexity 
we will occasionally also consider restrictions of ffp  p   and use the notation ffp p  for
the class of all ffp frames f  and instances p  where the action pre  and postconditions
 and g  can all be computed in p   f     time  and in p   p    time   where p is a polynomial 
we furthermore say that an ffp  p   instance p   hv  d  a  i  gi is deterministic if for
all s  s p  such that p has a plan from i to s  there is at most one a  a such that
pre a  s       that is  if an instance is deterministic then the planner is never faced with
a choice between two or more actions 
when proving that no compact representation can exist  the result gets stronger if we
use a weaker formalism  that is  we want to use the most restricted formalism possible 
since the results will then automatically apply to all formalisms that are more expressive 
hence  we will use propositional strips for such results  there are a number of common
variants of propositional strips that are known to be equivalent to each other and to the
sas  formalism under a strong form of polynomial reduction  backstrom         what
we will refer to as strips in this paper is the variant called propositional strips with
negative goals  psn  by backstrom  it can be defined as a special case of ffp  p   that
uses binary variables  but we define it here in a more traditional way  treating the variables
as propositional atoms 
definition    a strips frame is a tuple f   hv  ai where v is a set of propositional atoms
and a is a set of actions  the state space is defined as s f      v and states are subsets
of v   each action a in a has a precondition pre a  and a postcondition post a   which are
both consistent sets of literals over v   for all pairs of states s  t  s f   and actions a  a 
a is from s to t if both
   s satisfies pre a  and
   t   s n post a  
a sequence    ha            a  i  a is a plan from a state s   s f   to a state s   s f  
if either
      hi and s    s  or
   there are states s            s    s f   such that ai is from si  to si  for    i     
   

fibackstrom   jonsson

a strips instance is a tuple p   hv  a  i  gi such that f   hv  ai is a strips frame  i is
a state in s f   and g is a consistent set of literals over v   a state s  s f   is a goal state
for p if s satisfies g  the goal g is reachable from a state s  s f   if there is a plan from
s to some goal state for p  a solution for p is a plan from i to some goal state s  s f   
a solution for p is called a plan for p 
the notation a   x  y will be frequently used to define an action a with precondition x
and postcondition y  
all negative results will be proven to hold for strips  however  in most cases the results
hold even for many restricted subclasses of strips  it would lead too far to survey such
cases in this paper so we will use the restriction to unary actions as an archetypical case
throughout the paper 
definition    a strips action a is unary if  post a        a set of strips actions is unary
if all its actions are unary and a strips frame or instance is unary if its action set is unary 
unary actions may seem like a very limiting restriction but has been demonstrated as
sufficient in many cases for use in on board controllers for spacecrafts  muscettola et al  
      brafman   domshlak         this is not surprising  though  since strips planning is
pspace complete and remains so even when restricted to unary actions  bylander        
given a strips instance it is always possible to construct a corresponding strips instance
that is unary  the following reduction to unary instances is a simplified strips version of
the reduction used for sas    backstrom        proof of theorem      
construction    let p   hv  a  i  gi be a strips instance  construct a corresponding
a
instance p     hv     a    i     g  i as follows  define vlock    vlock
  a  a   then let v    
 
 
 
v  vlock   i   i and g   g  vlock   define a such that for each a  a  it contains the
following actions 
a   
abegin   pre a   vlock   vlock
a
a   
aend   post a    vlock     vlock
a          for each    post a  
ai    vlock
i
i
we leave it without proof that this construction is a polynomial reduction from the class
of strips instances to the class of unary strips instances  it is furthermore worth noting
that the construction can easily be modified to use padding with redundant variables to
make all original actions correspond to the same number of actions in the unary instance 
hence  it is possible to make a reduction where the plans for the unary instance are at most
a constant factor longer than the corresponding plans for the original instance 
we will also make frequent use of strips instances that include encodings of binary
counters based on the following construction  which uses one action for each bit and can
increment a non negative integer encoded in binary 
construction    an n bit binary counter can be encoded in strips as follows  let v  
 x            xn   and let a contain the n actions
ai    xi   xi            x      xi   xi            x        i  n  
   

fialgorithms and limits for compact plan representations

the following is a plan for counting from   to    using a   bit counter according to construction   
ha    a    a    a    a    a    a    a    a    a    a    a    a    a    a    a  i 
while we could modify the binary counter to use only unary actions as described in construction    a more direct way to get unary actions is to count in gray code 
construction     backstrom   klein        an n bit gray code counter can be encoded
in strips as follows  let v    x            xn   and let a contain the  n actions
si    xi   xi    xi            x      xi       i  n  
ri    xi   xi    xi            x      xi       i  n  
the following is a plan for counting from   to    with a   bit gray code counter according
to construction   
hs    s    r    s    s    r    r    s    s    s    r    r    s    r    r    s  i 
    complexity theory
we will use the abbreviation dtm for deterministic turing machine and ntm for nondeterministic turing machine  in addition to these standard types  we will also use advice
taking turing machines of both deterministic and nondeterministic type 
an advice taking turing machine m has an associated sequence a    a    a          of advice
strings  a special advice tape and an advice function a  from the natural numbers to the
advice sequence  such that a n    an   on input x the advice tape is immediately loaded
with a   x     after that m continues in the normal way  except that it also has access to the
advice written on the advice tape  if there exists a polynomial p such that   a n     p n  
for all n      then m is said to use polynomial advice  the complexity class p poly is
the set of all decision problems that can be solved by some advice taking dtm that runs
in polynomial time using polynomial advice  this can be extended such that  for instance 
np poly is defined by the ntms that run in polynomial time using polynomial advice 
note that the advice depends only on the size of the input  not on its content  furthermore 
the advice sequence must only exist  it does not need to be computable  the following two
results from the literature will be used later in this paper 
theorem    a  if np  p poly  then the polynomial hierarchy collapses  karp   lipton 
      theorem       b  let k     be an integer  if pk  pk  poly  then the polynomial
hierarchy collapses to level k      yap        lemma   combined with theorem    
the  sat problem consists of instances of the form c    c            cm   where each ci  
for    i  m  is called a clause and is a set of exactly three literals over some universe
of binary variables  the instance c is satisfiable if there exists some assignment of truth
values to the variables used in c such that at least one literal is true in each ci  c  it
is otherwise unsatisfiable  deciding satisfiability for  sat is np complete  while deciding
unsatisfiability is conp complete  more precisely  we will use the following definition of
 sat in this paper 
   

fibackstrom   jonsson

definition    for all integers n      let xn    x            xn   be a set of variables and let
m n 
m n  be the number of possible   literal clauses over xn   let c n   c n           cn
be some
m n 
 
 
fixed systematic enumeration of these clauses and let cn    cn   cn           cn    each clause
m n   
cin defines three literals such that  cin      i     i     i    further  let cn    cn            cn 
be
i
i
a fixed systematic enumeration of all subsets of cn   and let s n   hxn   cn i  for    i  
m n 
 m n    also implicitly define the set en    e n   e n           en   of atoms and its subsets
eni    ejn   cjn  cni    for    i    m n   
m n 

  is a systematic enumeration of all possible  sat instances
the sequence s  n   s  n           s  n
over n variables  and hence equivalent to the usual definition of  sat  technically speaking 
this is a redundant encoding of  sat since it allows instances that specify more variables
than are used in the clauses  this is harmless  however  all non redundant instances remain 
so we still have all hard instances and neither of the redundantly encoded instances can
be harder than their non redundant counterpart  since m n    n    the enumerations of
cn and en can be chosen such that they are polynomial time computable  and we assume
some such enumerations have been fixed from now on  we also note that a set eni uniquely
identifies the clause set cni  

   representing arbitrary plans compactly
it is known that there are cases where planning instances have exponential size plans but
the plans always have a polynomial size representation  gimenez   jonsson         an
obvious question is thus whether all plans  including those of exponential length  can have
polynomial representations  for one interpretation of the question the answer is trivially yes 
observation    the set of all plans for an arbitrary ffp  p   instance p has an o   p   
size representation  since the instance itself together with a deterministic planning algorithm
that successively enumerates and outputs all plans is such a representation 
although this is a trivial and not very useful observation it highlights some fundamental issues of representations  liberatore      a  discusses a similar representation  where instead
of specifying an algorithm he defines a lexiographic ordering on the actions  furthermore 
he adds a plan index to be able to represent a single plan rather than just the whole set of
plans  however  such an index is not unproblematic  as we will see soon 
a more interesting interpretation of our question is whether every single plan for a
particular instance can have a polynomial representation  even more precisely  is there
a polynomial p such that every plan for every planning instance has a representation of
size o p n    where n is the size of the planning instance  to investigate this question we
consider the most simple compact notation possible  an index number i for each plan for
a particular instance  since instances may have infinitely many plans  due to cycles in the
state transition graph  we consider optimal plans only  there is  however  no guarantee that
even such an index is small enougha polynomial number of bits may not be sufficient to
represent it 
   we sometimes omit index n  when it can be assumed obvious from context  and thus write  ki rather
than  kn i  

   

fialgorithms and limits for compact plan representations

construction     given an arbitrary integer n      construct the strips instance p n  
hvn   an   in   gn i such that vn    x            xn   y   in     gn    x            xn   and an contains
the actions
ai    xi   xi            x      xi   xi            x    y      i  n 
bi    xi   xi            x      xi   xi            x    y      i  n  
lemma     for every integer n      instance pn according to construction    has   
optimal plans 

n  

proof  let n     be an arbitrary integer and p n a corresponding strips instance according
to construction     this instance is a binary counter over the variables x            xn as in
construction    except that it has an extra variable y that can be independently set to
true or false  depending on whether an action of type ai or bi is chosen  since the variables
x            xn can be interpreted as a binary number  let the notation hm  yi represent the
state where x            xn encodes the number m and y is false  and let hm  yi represent the
corresponding state where y is true  whenever in a state hm  yi or hm  yi  where m    n   
it is possible to go to either of hm      yi or hm      yi using one action  but to no other
states  the state transition graph for this instance appears in figure    the initial state is
h   yi and the only goal states are h n     yi and h n     yi  hence  any plan for p n must
be of length  n     from every state that is not a goal state there are two different actions
to choose between and they lead to different states  however  the goal is reachable from
n
both these states so the choice of action does not matter  hence  there are      different
plans for p n  

m 

 

 

 n   
y  

 

y  
goal

init

figure    state transition graph for proof of lemma    
although the atom y is redundant in this particular example the whole construction could
be a part of a larger instance  where y does have a purpose  it should also be noted that
the instances used in the proof have only optimal plans  all plans have the same length  all
is now set to prove the previous claim 
theorem     for every integer n      it takes  n    bits to index all optimal plans for
instance pn according to construction    
proof  since an m bit number can distinguish between at most  m different objects  it
follows from lemma    that at least  n    bits is necessary to index the plans for p n
   

fibackstrom   jonsson

this result immediately implies that not all  optimal  plans for a strips instance can have
polynomial size representations  this holds even under some restrictions  like unary actions 
if basing construction    on a gray counter instead of a binary counter then every action
has two postconditions  rewriting this using construction   yields an equivalent instance
with unary actions using a block of four actions for each action in the original instance 
although the plans get   times longer the number of plans will remain the same  hence 
theorem    still holds 
this theorem leaves the possibility open that some of the plans for an instance can have
polynomial representations  although not all of them can  an interesting question is thus
how many of the plans for an instance can have polynomial representations  to answer that
question we stray into the field of information theory and kolmogorov complexity  it is out
of the scope of this paper to treat that field in detail  but loosely speaking  the kolmogorov
complexity of a string is the size of the smallest dtm that can generate the string with
no input  let k x  denote the kolmogorov complexity of a binary string x  the following
lemma is due to buhrman et al         lm     
lemma      incompressibility lemma  let c be a positive integer  every set a of cardinality
m has at least m     c       elements x with k x   blog mc  c 
this lemma can be used to show that the fraction of plans that can be compactly represented
approaches zero as the size of instances approaches infinity 
theorem     let p be an arbitrary polynomial  consider instances pn according to construction    for arbitrary integers n      let t n  be the total number of plans for
pn and let s n  be the number of plans that can be represented with at most p n  bits 
then limn s n 
t n      
n

proof  let p be an arbitrary polynomial  we know from lemma    that t n          
for every n      let c n     n  p n      the incompressibility lemma then says that
there are at least t n      c n        plans  such that k    blog t n c  c n   that
is  there are at most  c n  t n     plans  such that k     blog t n c  c n   using
the values for t n  and c n  above  this simplifies to say that there are at most  p n      
plans  such that k    p n   hence  s n    p n        the theorem then follows since
 p n     
   limn s n 
    
t n   limn   n  
this means that even if it is the case that some plans for every solvable instance can have
compact representations  the probability that a particular plan has a compact representation
will be vanishingly low for large instances  although it is not strictly necessary to use
kolmogorov complexity to prove theorem    doing so makes the information theoretic
aspect of compact representations clearer 

   uniform compact representations of plans
we now know that we cannot  in general  compress arbitrary exponential plans to subexponential size  but what if we do not choose ourselves which plan to use  the previous
result still leaves open for the possibility that a small fraction of solutions for a planning instance could have compact representations  however  the planner  or an oracle or whatever 
   

fialgorithms and limits for compact plan representations

would then have to choose for us which plan to present us with a compact representation
of  suppose a planner could actually do this  how would we make use of it  if we still need
the actual plan itself then we cannot avoid its exponential size  hence  the interesting case
seems to be if we could at least access useful information in the plan efficiently 
the term representation is used in a loose sense here  but need not really be precisely
defined for the moment  it suffices to note that any representation needs both some kind
of data structure and some kind of access algorithm  with the extreme cases being either a
vector of data with the trivial access algorithm or an algorithm that embeds all the data 
what could it mean to access a compact representation efficiently  we will investigate
two such criteria  the first one is that we can efficiently retrieve the actions of the actual
plan sequentially  our interpretation of efficient will be that actions can be retrieved with
polynomial delay  johnson  papadimitriou    yannakakis         the second criterion is
that any action in the actual represented plan can be random accessed in polynomial time 
in the size of the instance 
before looking at explicit representations for each plan we take a look at the uniform
case  where we have a single representation that covers all instances  more precisely  we
consider the case of a single algorithm that works as a compact representation for some
plan for every solvable instance 
theorem     if there is an algorithm that for any solvable strips instance p can either
generate some plan for p sequentially with polynomial delay or random access any action
in some plan for p in polynomial time  then p   np 
note that this theorem does not follow from the fact that strips planning is pspacecomplete since only solvable instances are considered  before proving the theorem we need to
introduce some extra technical machinery  we start by encoding  sat instances according
to definition   in strips as follows 
construction     let n     and i  where    i    m n    be arbitrary integers  construct
the strips instance p in   hvn   an   eni    goal i such that vn   xn en  cts  ctu  goal  inc 
 v            vm n    and an has the actions specified in table   
as previously noted  each subset eni of en uniquely identifies the  sat instance s in by telling
which clauses in cn are enabled in s in   that is  the initial state selects the particular nvariable instance we are interested in  the actions are partitioned into three groups  group
i contains the two actions acs and acu  which set the atoms cts and ctu respectively  these
actions block each other and both cts and ctu are initially false  so only one of these atoms
can be set to true in any plan  that is  cts and ctu are mutually exclusive  group ii consists
of actions that all require cts true and group iii consists of actions that all require ctu true 
these two groups of actions are thus also mutually exclusive  hence  every plan must start
with exactly one action from group i and the rest of the plan consists only of actions from
either group ii or group iii  depending on which the first action is  the intention of this
is the following  if the plan starts with action acs then it commits to verifying that s in is
satisfiable and if the plan starts with action acu then it commits to verifying that s in is not
satisfiable  in either case the plan ends with an action that satisfies the goal only if the plan
has verified the commitment made by the first action  this can be interpreted as viewing
   

fibackstrom   jonsson

i

acs    ctu    cts 
acu    cts    ctu 

commit to prove satisfiability
commit to prove unsatisfiability

ii

aseti    cts  v      xi  
avt     cts    v   

set xi
start verification

avt j    cts  ejn   vj       vj  
avtkj    cts  ejn   vj     kj     vj  
ags    cts  vm n      goal 

skip disabled clause cj
verify cj true since  kj true
conclude instance satisfiable

avf j    ctu  inc  ejn     j     j     j     inc 
aixi    ctu  inc  xi   xi            x   
  inc  xi   xi            x   
agu    ctu  inc  x            xn     goal 

verify clause cj false
increment counter

iii

conclude instance unsatisfiable

index ranges     i  n     j  m n  and    k    

table    actions for construction    
the planner as a theorem prover which first outputs a theorem  the first action in the plan 
and then a proof of the theorem  the rest of the plan  
lemma     for every integer n     and integer i such that    i    m n    the strips
instance pin according to construction    has the following properties 
   it can be computed in polynomial time in n 
   it corresponds to the  sat instance sin such that every plan for pin starts with action
acs if sin is satisfiable and otherwise with action acu 
   it always has at least one plan 
proof  property   is trivial to prove  to prove property    we first note that the initial
state contains only atoms from en   as previously noted  each subset eni of en uniquely
identifies the  sat instance s in by telling which clauses in cn are enabled in s in  
we have two cases  if the plan starts with action acs then it commits to verifying that
i
s n is satisfiable and if the plan starts with action acu then it commits to verifying that s in
is not satisfiable  in either case the plan ends with an action that satisfies the goal only if
the plan has verified the commitment made by the first action  the details of the two cases
are as follows 
if the plan verifies satisfiability  then it must be of the form
k

m n 
hacs  aseti            asetih   avt    avtk             avtm n 
  agsi 
 z
 
 
 
 z
 

assign

verify

the assign block has h actions that set a satisfying assignment for x            xn   the verify
k
block consists of one action a   avtj j for each clause cjn   if cjn is enabled  ejn true   then
   kj    and a verifies that  kj in cjn is true for the assignment  otherwise  if cjn is
   

fialgorithms and limits for compact plan representations

disabled then kj      so a   avt j which skips over cjn without verifying anything  the
planner has thus
   committed to verify that s in is satisfiable 
   chosen a satisfying assignment for x            xn and
   chosen one literal for each enabled clause as a witness that the clause is true under
this assignment 
the last action ags makes the goal true if these three steps are successful  note that
this works also for the case where no clause is enabled  which corresponds to the trivially
satisfiable instance with an empty set of clauses  obviously  there is a plan of this form if
and only if s in is satisfiable 
if the plan instead verifies unsatisfiability  then it must be of the form
hacu  b    a    b    a    b            ah   bh   agui 
where h    n     except for the first and last actions  this plan can be viewed as two
interleaved sequences
   ha            ah i   haix    aix    aix    aix            aix  i
and
   hb    b            bh i 
the aixi actions are increment actions that use x            xn to form a binary counter  since
these variables correspond to the number   in the initial state and there are  n   increment
actions  the subplan  enumerates all possible truth assignments for x            xn   sequence
 consists only of actions of the type avf j   each avf j action verifies that the corresponding
clause cjn is enabled and false under the current assignment to x            xn   the aixi actions
require inc to be true and set it false  while the avf j actions instead require inc to be false
and set it true  hence the plan is synchronised such that it alternates between actions from
the two sequences  since the first aixi action is preceeded by an avf j action and there is
an avf j action after the last aixi action  it follows that there must be some unsatisfied and
enabled clause for every possible truth assignment  since the synchronization will otherwise
get stuck so the counter cannot increment  that is  there is a plan of this type if and only
if s in is unsatisfiable  the last action agu makes the goal true if this succeeded  note that
in this case there is no need for actions to skip over disabled clauses since it is sufficient to
demonstrate one enabled clause that is false for each assignment 
it follows that the plan is of the first form if s in is satisfiable and of the second form if
i
s n is unsatisfiable  furthermore  since the first action is a commitment for the rest of the
plan whether to verify satisfiability or unsatisfiability  it is sufficient to check this action to
decide if s in is satisfiable or not 
property   follows immediately from property   since the plan must be of either of the
two forms 
we now have the necessary tools to prove the theorem 
   

fibackstrom   jonsson

proof of theorem     suppose there is an algorithm with either sequential or random access as stated in the precondition of the theorem  we can then solve any  sat instance
s in in polynomial time by asking the algorithm for the first action of some plan for the
corresponding instance p in and tell from this action whether s in is satisfiable  however  this
implies that p   np 
this proof would still hold if rewriting construction    as described in construction    that
is  theorem    holds even if restricted to the set of unary strips instances only 

   non uniform compact representations of plans
theorem    uses a very strong criterion  it requires that one single algorithm can handle
all instances  a more relaxed variant is the non uniform case  where we allow different
representations for different instances  that is  we will consider compact representations
of single plans under different access criteria  in order to do so we must first define more
precisely what we mean by such representations 
    compact representations and access mechanisms
we define the concepts csar and crar which are representations of action sequences
characterised by their access properties   
definition     let f be an arbitrary function  let f   hv  d  ai be an ffp  p   frame
and let   a   a representation  of  is a dtm  furthermore 
    is f  compact if       f    f     and it runs in f    f     space including the input and
output tapes 
    is an f  compact sequential access representation  f  csar  of  if it is f  compact 
takes no input and generates the actions in  sequentially in f    f     time for each
successive action 
    is an f  compact random access representation  f  crar  of  if it is f  compact and
for an arbitrary index i  where    i      as input  it outputs action i of  in
f    f     time 
note that this definition does not require that the representations are computable  we
could have used two separate functions  one to bound the access time and one to bound the
size  which would allow for better precision  however  we choose to use a single function
for both since this makes the theory simpler and clearer while having sufficient precision for
our purposes in this paper  we further consider the output tape as cleared between actions
so the output is a single action  not the sequence   also note that the space complexity
includes the input and output tapes  which implies that the longest sequence an f  crar 
   note that this definition differs slightly from our previous one  backstrom   jonsson      b   first  we
have generalised the definition to allow compact representations for an arbitrary function f   not just an
arbitrary polynomial  second  in order to improve the precision we no longer use the o   notation but
exact functions  finally  the representations now have the same restriction for space and time  none of
these changes matter for the results in our previous publication  but only for the details of proofs 

   

fialgorithms and limits for compact plan representations

can represent is less than       actions since its input is limited to      bits  a csar has no
corresponding limit since it has no input  furthermore  the time restriction for an f  csar
can be viewed as a generalisation of the polynomial delay concept which is not restricted to
polynomials  we will often apply this definition to instances rather than frames  although
this makes a slight difference technically  it is not important in principle and ignoring it
allows for simpler theorems and proofs  we write only crar and csar when referring to
the whole family of representations of a particular type 
    sequential access representations
for sequential access in the non uniform case we would like to ask if all solvable strips
instances have at least one plan with a polynomial csar  unfortunately  that still remains
an open question  hence  we consider a more restricted case of this question where we also
require that the csar must be verifiable within some resource constraint  which we define
as follows 
definition     for every ffp  p   plan representation type r  define the following decision problem 
plan representation verification
instance  an ffp  p   instance p   hv  d  a  i  gi and a string  
question  is  an r representation of a plan for p 
the complexity of verification is measured in   p           we can now state the following
theorem about polynomial csars 
theorem     let c be an arbitrary complexity class and p an arbitrary polynomial  if
p csar verification is in np c and every solvable strips instance has at least one plan
with a corresponding p csar  then pspace  np c  
proof  let p be an arbitrary polynomial  suppose p csar verification is in npc and every
solvable strips instance has at least one plan with a corresponding p csar  let p be
an arbitrary strips instance  we can then decide if p has a plan by guessing a string of
length p   p    bits and then check if that string is a p csar for some plan for p  this can
be done in polynomial time  in   p    using an ntm with an oracle for c since p csar
verification is in npc   however  deciding if a strips instance has a plan is pspacecomplete  bylander        thm       so it follows that pspace  npc   since p was
chosen arbitrarily 
that is  a csar for a planning instance is of limited use if we must first verify that it is
correct before using it  since this verification may be as difficult as solving the instance itself 
also note that if c is a class in the polynomial hierarchy  then pspace  npc implies a
collapse of this hierarchy  the preceding theorem holds for the restriction to unary strips
instances  since planning is still pspace complete for this restriction  bylander       
thm        in fact  it holds for all restrictions where planning is still pspace complete 
which includes several other cases in bylanders analysis as well as many subclasses of
sas  planning  see backstrom   nebel        jonsson   backstrom      a  for overviews
of results  
   

fibackstrom   jonsson

although this result may seem disapointing  it holds only under the condition that we
must check whether the csar is correct  that means  for instance  that the theorem is
irrelevant if correctness of the csar is guaranteed by design  one such case is the following 
theorem     every strips instance according to construction    has a plan with a
polynomial csar 
proof  consider an arbitrary such instance p in   add n     extra bits b            bn such that b 
tells if s in is satisfiable or not  if s in is satisfiable then the remaining bits specify a satisfying
assignment such that bi gives the value for vi   and they are otherwise undefined  we claim
there is a simple deterministic algorithm that uses only p in and b            bn and generates a
plan for p in with polynomial delay as follows 
suppose b  says that s in is satisfiable and that h of bits b            bn are one  then there
is a plan for p in of the form
k

m n 
  agsi 
hacs  aseti            asetih   avt    avtk             avtm n 
 z
 
 
 z
 
 

assign

verify

the actions in the assign block can easily be generated from b            bn   for the avtkj actions 
output avt j if cjn is not enabled and otherwise output avtkj for the smallest k such that  kj
is true for the specified assignment  clearly this algorithm works with polynomial delay 
instead suppose s in is not satisfiable  then the plan is of the second type and must cycle
through all possible assignments  doing this and generating the corresponding counting
actions is trivial  for each assignment we must also output an avf j action  determine
the smallest j such that cjn is enabled but not satisfied for the current assignment  and
output avf j   this can be done in polynomial time since there is only a polynomial number
of clauses 
clearly this construction is a polynomial csar for some plan for p in  
the following theorem demonstrates that there are also more general and harder classes
of instances where even optimal plans have polynomial csars by design 
theorem     there is a subclass x of strips and a polynomial p such that deciding if
instances of x have a plan is pspace complete and all solvable instances of x have an
optimal plan with a p csar 
proof  pspace can be characterised by the class of polynomial space bounded dtms 
bylander        thm       used this fact to demonstrate a polynomial reduction from
pspace to strips planning  we refer to bylander for details but in brief  given a
machine m with input x he constructs a deterministic strips instance that has a plan if
and only if m  x  accepts  hence  it is a polynomial time problem to check that we are in a
valid state and then find the only action  if any  that can be applied in that state  it follows
that there is some polynomial p such that every such solvable strips instance has a plan
with a p csar  furthermore  since the instance is deterministic it has only one plan  which
must then be optimal 
   

fialgorithms and limits for compact plan representations

an even more general observation is that every deterministic ffp  p   instance that is
solvable has exactly one plan  which is thus optimal  and that this plan has a polynomial
csar  as a contrast to this we will next consider a class of instances where solvable instances
always have plans with polynomial csars but where we have no optimality guarantee  this
example thus illustrates that a csar is just a representation and that it gives no guarantees
about the actual data it represents  more precisely  the example uses the class of reversible
ffp  p   instances  where the state transition graph is symmetric 
definition     an ffp  p   frame f   hv  d  ai is reversible if for all pairs of states s
and t in s f    whenever there is an action a in a from s to t then there is also an action a 
in a from t to s 
note that reversible instances are not an easy special case of planning  deciding if there is
a plan or not is still pspace complete  jonsson et al         thm       that is  plans can
still be of exponential length 
theorem     there is a polynomial q such that for all polynomials p  every solvable and
reversible ffp p  instance has a  q  p  csar for some plan 
proof  let p   hv  d  a  i  gi be a solvable ffp p  instance such that f   hv  d  ai is
reversible  consider the algorithm in figure    optplan is assumed to be an algorithm such
that optplan s g  returns the length of the shortest plan from s to g 
if ignoring process b  it is clear that the algorithm outputs an optimal plan for p since
there is a plan by assumption  process b finds two actions a  and a  such that executing
ha    a  i in state s ends up in state s  such a choice of actions must exist since there is a
plan from s to some goal state and f is reversible  the synchronisation between processes
a and b make all such actions a    a  appear adjacent in that order in the output of the
algorithm  and they do thus not interfere with the plan produced by process a  they just
make the plan longer  choosing actions in process b can be done by a double loop through
all pairs of actions and checking them 
it is obvious that there is a polynomial r such that process b runs in r   p    time  we
can choose r to also allow extra time to run process a in parallel  let  be p together with
the algorithm  then         p     c for some constant c  choose r such that it also satisfies
n   c  r n  for all n      obviously   is an r csar for some plan for p  choose the
polynomial q such that r n   q p n   for all n     
algorithm optplan must obviously run in polynomial space  but its complexity is otherwise
not important  the parallel algorithm used in the proof of this theorem is to some extent a
nonsense algorithm  process a does all the job by consulting an ordinary planning algorithm
 optplan  but gives no time guarantees  process b  on the other hand  contributes nothing
relevant to the plan but satisfies the access time requirement  that is  process b buys time
for process a to find the plan by generating irrelevant actions frequently enough to satisfy
its time requirements  the wait statements are not strictly necessary but illustrate that we
can tune the step complexity of the algorithm by slowing down process b if desired 
although this example might  perhaps  be considered somewhat pathological  it clearly
demonstrates that a csar  just like a crar  is only a representation  just like most
other data structures it has certain access properties but does not guarantee any particular
   

fibackstrom   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  

s    i
while g s      do
do in parallel
process a 
    optplan s  g 
for all a   a s t  pre a    s      do
t    post a    s 
if optplan t  g      then
a    a         optplan t  g 
process b 
while process a running do
choose a   a s t  pre a    s     
u    post a    s 
choose a   a s t  pre a    u      and post a    u    s
output a 
wait t
output a 
wait t
output a
s    post a  s 

figure    csar algorithm for reversible instances 
properties of the actual data stored  this not uncommon for plan representations either 
for instance  a reactive plan could be constructed to have the same behaviour and still
be considered correct and run in polynomial time and space  we can alternatively use
a random walk algorithm  which will also output actions with polynomial delay  it will
eventually reach the goal if there is a plan  but it will also output a lot of redundant
actions  the algorithm in figure   may  in a sense  be viewed as a derandomized variant
of random walk 
    random access representations
the case of non uniform random access is clearer than the case of sequential access  here
we can answer the question of existence for crars without any further qualifications about
verifiability 
theorem     if there is a polynomial p such that every solvable strips instance has at
least one plan with a corresponding p crar  then the polynomial hierarchy collapses 
since this theorem is not conditioned by verifiability of the representations it is a stronger
result than theorem     before proving the theorem we need to introduce some additional theory 

   

fialgorithms and limits for compact plan representations

construction     let n     be an arbitrary integer  construct a strips instance p n  
hvn   an      goal i such that
vn   xn  en   v            vm n      svi  sva  sia  sii  sti  t  f  goal 
and an has the actions specified in table   

abi    svi  sva  sia  sii  sti    svi  t 

begin instance block

aba    svi  sia    sva  f   v    v            vm n   

begin assignment block

avtkj    sva  vj   vj    ejn    kj     vj  
avf j    sva  vj   vj    ejn     j     j     j     vj   f  

verify  j true in clause cj
verify clause cj false

avsj    sva  vj   vj    ejn     vj  

skip disabled clause cj

aaf    sva  vm n    f     sva  sia 
aat    sva  vm n    f     sva  sia  t 

verify assignment satisfying
verify assignment not satisfying

aixi    sia  xi   xi            x      sia  xi   xi            x   
arx    sia  xn           x      sia  svi  sti  xn           x   

increment assignment counter
reset assignment counter

ais    sti  t    sti  sii 
aiu    sti  t    sti  sii 

verify instance satisfiable
verify instance unsatisfiable

 
aiij    sii  ejn   enj            e      sii  ejn   ej 
n           en  

increment instance counter

ari  

m n 
 sii  en           e n  

  goal 

all instances checked

index ranges     i  n     j  m n  and    k    

table    actions for construction    
the previous construction    allows plans of two types  either choosing an assignment
and then verifying all clauses by chaining  or enumerating all assignments and demonstrate
one false clause for each  construction    mixes these methods  to check if an instance
is satisfiable the plan must enumerate all variable assignments and for each assignment
it must walk through all clauses by chaining  for each enabled clause it demonstrates
either a true literal or that none of the literals is true  while disabled clauses are skipped
over  atoms f and t keep track of whether all clauses were true for some assignment  in
m n 
which case the instance is satisfiable  an extra counter that uses the variables e n           en
enumerates all possible subsets eni of en   thus implicitly enumerating all  sat instances
m n   
s  n           s  n
  this counter constitutes an outer loop  so for each eni   all possible
assignments for x            xn are tested as described above  the plan can be thought of as
implementing the algorithm in figure   
lemma     for all integers n      instance pn according to construction    has the
following properties 
   it can be computed in polynomial time in n 
   

fibackstrom   jonsson

 
for all  sat instances s of size n do
 
clear t
 
for all assignments to x            xn do
 
clear f
 
for all clauses cj do
 
if cj disabled in s then
 
do nothing
 
elsif some  kj in cj is satisfied then
 
do nothing
  
else  neither of   j     j or   j is satisfied 
  
set f
  
if not f then
  
set t
  
if t then
  
report s as satisfiable
  
else
  
report s as unsatisfiable
figure    algorithmic description of construction    
   it always has at least one plan 
   there exist constants an and bn such that for every i  where    i    m n    the action
at position bn i   an in any plan for pn is ais if the  sat instance sin is satisfiable and
it is aiu if sin is unsatisfiable 
proof  in addition to the previous explanation of the construction we note that the instance
is designed to be deterministic  setting an    n  m n           and bn   an     satisfies
the claim  since the action at position bn i   an is ais if s in is satisfiable and it is aiu if it is
unsatisfiable 
all is now set to prove the theorem 
proof of theorem     suppose p is a polynomial such that all solvable strips instances
have at least one plan with a corresponding p crar  for each n      let p n be the
corresponding instance according to construction    and let n be a p crar for some plan
n for p n   by assumption  such n and n must exist for every n 
construct an advice taking dtm m which takes input of the form i in   hp n   ii  where
n and i are integers such that n     and    i    m n    let i be represented in binary
using exactly m n  bits  then    i in    is strictly increasing in n and depends only on n 
let sn     i in     which is well defined since   i in    does not depend on i   define the advice
function a such that a sn     n   the advice is thus a p crar for some plan for the strips
instance p n according to construction      recall that we only need to know that the
advice exists  not how to find it   let an and bn refer to the corresponding constants that
must exist according to lemma     since m can run whatever algorithm is used to access
n   it follows from the assumptions that m can find action bn i   an in n in polynomial
time in sn   let it return yes if this action is ais and otherwise return no 
   

fialgorithms and limits for compact plan representations

given an arbitrary  sat instance s in   compute the corresponding input i in for m and
then run m on this instance  by construction  m answers yes if and only if s in is satisfiable  the input i in can be computed in polynomial time in   s in    and m runs in polynomial time using polynomial advice  since m solves satisfiability for  sat it follows that
np  p poly  which is impossible unless the polynomial hierarchy collapses at level  
according to theorem  a 
it is further worth noting that the plans for instances according to construction   
contains a subplan for every  sat instance of a particular size  hence  we can alternatively
view such a plan as a representation of a set of exponentially many plans  which shows
that representing one long plan and representing a large set of plans are not fundamentally
different issues 
also for crars there are restricted cases where we can prove that they always exist 
one such example is  once again  construction    
theorem     every strips instance according to construction    has a plan with a
polynomial crar 
proof  add n   extra bits b            bn as explained in the proof of theorem    and construct
a polynomial time random access algorithm as follows 
suppose b  says that s in is satisfiable and that h of bits b            bn are one  then there
is a plan for p in of the form
k

m n 
hacs  aseti            asetih   avt    avtk             avtm n 
  agsi 
 
 z
 
 
 z
 

assign

verify

since h  n we can construct the whole assign sequence and then determine a specific action
in it in polynomial time  each of the avtkj actions correspond to a specific clause cjn   since
the clauses are ordered we can compute j from the index of the action we ask for  if cjn is
not enabled then output avf  j and otherwise output avf kj for the smallest k such that  kj is
true for the specified assignment b            bn  
instead suppose s in is not satisfiable  then all but the first and last actions are interleaved aixi and avf j actions  the aixi actions have the function of a counter over the
variables x            xn   let i be an arbitrary index i into the plan where i is not the first or
last action  if i is odd  then ai is an aixk action and k can easily be computed from i  so
output aixk   if i is even then ai is an avf j action  the value of x            xn immediately
before ai can easily be computed from i  use this value and check all enabled clauses in
order until finding a clause cjn that is not satisfied and then output avf j  
clearly this construction is a polynomial crar for some plan for p in  
another and much larger class of instances where plans have crars will be considered in
the next section 
    relationships between compact representations
in this section we investigate how the crar and csar concepts relate to each other  since
a macro plan can also be viewed as a compact representation we also investigate how macro
   

fibackstrom   jonsson

plans relate to our concepts  we start by showing that if there is a polynomial crar for a
plan then there is also a polynomial csar for that plan 
theorem     there is a polynomial q such that for all polynomials p  all ffp  p   frames
f   hv  d  ai and all   a   if  has a p crar  then it also has a  q  p  csar 
proof  let f be arbitrary ffp  p   instance and let  be a p crar for some plan  for f  
use an action counter that is initiated to index the first action in the plan  generate the
actions of the plan sequentially by repeatedly asking  for the action indexed by the counter
and then incrementing the counter  let   denote this algorithm together with   a      bit
counter is sufficient since  must be shorter than       actions  suppose it takes r m  time
to increment an m bit counter  then there is a constant c such that                c    runs
in  p   f       c space and   runs in p   f       r p   f        c time  define the polynomial q as
q n     r n  c  obviously               c  q        q p   f        p   f     c  q p   f     
and p   f       r p   f        c  q p   f      so   is a  q  p  csar for  
the opposite of this does not hold  however  in particular  while not all instances according
to construction    have a plan with a crar they all have a plan with a csar  so this
construction acts as a separation between the two concepts 
theorem     unless the polynomial hierarchy collapses  there is no polynomial q such that
for every polynomial p  every strips instance p and every plan  for p  if  has a p csar
then  has a  q  p  crar 
proof  let x denote the class of strips instances used in the proof of theorem     since
these instances are deterministic there is a polynomial p such that every solvable instance
has a p csar for some plan  however  it follows from the same proof that there is no
polynomial r such that all instances of x have a plan with an r crar  hence  there is no
polynomial q such that all instances have a plan with a  q  p  crar 
although not previously defined in the paper  it makes sense to also have a look at
macro plans in this context  a macro is a sequence of two or more actions  macros are
commonly used in planning and treated as a single action by the planner  macros can
be useful for planning if there are certain subsequences of actions that occur frequently in
plans  korf         however  macros may also be used for the purpose of representing a
plan in a more compact and structured way  this is especially true if macros are allowed
to also contain other macros  since this allows hierarchies of macros  for instance  it is well
known that the shortest solution for the towers of hanoi problem for arbitrary number
of disks can be described by a recursive schema  gill        ex       although the plan
itself is exponential in the number of disks  the  s class of planning instances  jonsson  
backstrom      b  has the property that we can always find out in polynomial time if an
instance has a plan  but the plan itself may be of exponential length and thus cannot be
generated in subexponential time  gimenez and jonsson        showed that plans for  s
instances always have a polynomial size representation using macros  in fact  such a macro
plan can even be generated in polynomial time although the actual non macro plan would
take exponential time to generate  this result was later generalised to some other classes
   

fialgorithms and limits for compact plan representations

of planning instances by jonsson         we will show that polynomial size macro plans
have an immediate connection to compact plan representations  however  in contrast to
gimenez and jonsson we will not discuss how to generate macro plans but only analyse
some of their properties 
macro plans can be very powerful tools for representing plans compactly  hence  it is
interesting to identify criteria for when compact macro plan representations exist and not 
that problem is out of the scope of this paper  but we will give a partial answer to the
question in the following way  it is straightforward to see that a macro plan can be viewed
as a context free grammar  cfg   let the actions be the terminals  let the macros be the
variables  let the macro expansions be the production rules and let the root macro be the
start symbol  we note that if we use macros to represent a single plan  rather than to represent various possibilities for planning  then the macro expansions must be acyclic in order to
produce a unique well defined plan  hence  a macro plan can be defined as an acyclic cfg 
when such cfgs are used to represent a single string compactly they are often referred
to as compressed grammars  furthermore  such a compressed grammar permits efficient
random access into the string it represents  both the access and the necessary preprocessing
is polynomial time in the size of the grammar  bille et al          more precisely  consider
a grammar of size n that represents a string of length n with a derivation tree of maximum
height h  after a polynomial time preprocessing  in the size of the grammar  it is possible
to random access any symbol in the string by index in o log n   time or  alternatively  in
o h  time  such algorithms typically work by first computing the length of the substrings
generated by each rule  the preprocessing step  and then use this information to find the
symbol with a certain index by top down search  since the grammar is acyclic we get h  n 
hence  the following proposition is immediate from the properties of compressed grammars 
proposition     there is a polynomial r such that for every ffp  p   frame hv  d  ai
and every macro plan  for a sequence   a    can be used to random access any action
in  in r       time 
we thus get the following relationship between macro plans and crars 
theorem     there is a polynomial p such that for all polynomials q  all ffp  p   frames
f   hv  d  ai and all action sequences   a   if  has a macro plan  such that      
q   f     then  has a  p  q  crar 
proof  let r be a polynomial such that all macro plans   can be random accessed in r        
time  let  be  together with the random access algorithm  then              c for some
constant c  define p such that p n    r n    c  we get              c  q   f       c 
r q   f        c   p q   f       furthermore   runs in r        r q   f        c   p q   f     
space and time  it follows that  is a  p  q  crar for  
it follows from theorem    that every plan with a polynomial macro plan also has a
polynomial crar  that is  the class of polynomial macro plans is a subclass of the class of
polynomial crars  but we do not know if it is a proper subclass  in any way  these results
do imply that we cannot always find a polynomial macro plan for an instance 
corollary     if there is a polynomial p such that every solvable strips instance has at
least one plan with a corresponding macro plan of size p   p    then the polynomial hierarchy collapses 
   

fibackstrom   jonsson

proof  immediate from theorems    and    

   problem reformulation
having now concluded that there seems to be little hope that plans can be compactly
represented in the general case  we turn to the idea of problem reformulation to see if that
can be of any help  while this may seem out of place in this context it is  to the contrary  a
quite logical step to take  so far  we have only analysed planning problems and plans  and
that is what the results hold for  it is not obvious that  or when  the results hold also when
planning instances are solved by reformulating them to instances of some other problem  it
is thus hypothetically possible that we could get around the problems with this approach 
however  to say something useful and relevant about this  it is not sufficient to look only at
naive approaches  such as polynomial reductions  so we will investigate a stronger criterion 
the basic idea of reformulation is to transform a planning instance to another equivalent instance  either another planning instance or an instance of some other problem  for
reformulation to be useful  the solution for the new instance must be of use to solve the
original instance  and something must be gained  often  reformulation is used with the intention that the overall process is faster than solving the original instance directly  common
variants are to reformulate planning into sat  csp  model checking or another planning
problem  reformulation of planning into sat was first suggested by kautz and selman
       and is still a popular approach to planning  long  fox  and hamdi        discuss
reformulation for planning in general and edelkamp  leue  and visser        discuss the
connections between model checking and planning 
the reformulation process can be viewed as shown in figure    a planning instance p has
a solution  that we can find directly using ordinary planning  solving p via reformulation
instead follows the indirect path in the figure  first p is reformulated into a new instance
r p   of some problem   then this instance is solved which produces a solution  for r p  
finally   is transformed back into a solution  for p 

p
direct

r p 
indirect




figure    reformulation of the generation problem 
obviously  reformulation cannot help us when plans are exponential  even if the first
two steps of the indirect path took polynomial time and  was of polynomial size  it would
still necessarily take exponential time to transform  into  because  is exponential  that
   

fialgorithms and limits for compact plan representations

is  the problem is inherently intractable whichever method we use to solve it  reformulation
could potentially speed things up  if  could somehow be used directly as a solution for the
original problem  but that would happen rarely  if at all 
the situation is different  though  if we consider the decision problem rather than the
generation problem  that is  if we ask not for a plan but for whether there is a plan or not 
in this case we can use the solution for r p  directly  since decision problems have only two
possible answers  yes or no  we may thus escape the inherent intractability  this variant of
reformulation is shown in figure    since no exponential solution is generated in this case 
reformulation could potentially be more efficient  we know that the decision problem for
strips is pspace complete in the general case  if the reformulated problem were easier
to solve  then it could be beneficial to first reformulate p to r p  and ask if that instance
has a solution or not  then it would be possible to check if there is a solution at all before
embarking on generating a possibly exponentially long plan  consider  for instance  the
 s class  jonsson   backstrom      b  where plans may be of exponential size but it is
always possible to decide in polynomial time if there is a plan  it thus seems like the case
of reformulating decision problems is the most interesting one to look at  and if that does
not give any improvement  then there can hardly be any improvement for plan generation
via reformulation either 

p
direct

r p 
indirect

yes no

yes no

figure    reformulation of the decision problem 
let pe strips  denote the decision problem  that is  plan existence  for strips  the
following two results are trivial  but illustrative 
theorem     a  there exists a decision problem x and a function r such that it holds for
all p  pe  strips  that r p   x and that p and r p  have the same answer  b  if there
is some complexity class c  some decision problem x  c and a polynomial time computable
function r such that it holds for all p  pe  strips  that r p   x and that p and r p 
have the same answer  then pspace  c 
proof  a  let x   pe strips  and r the identity function  b  immediate  since r is a
polynomial reduction from pe strips  to x 
in both cases we reformulate a pspace complete problem into a pspace complete problem  which is not very interesting  if we are to prove anything better  we must obviously
look for an x and an r with more useful restrictions 
   

fibackstrom   jonsson

it is important to note that when reformulating planning into some np complete problem  for instance sat  this does not magically make planning np complete  the reason
that strips planning is pspace complete is that it allows exponential solutions  as soon
as we restrict the solutions to be bounded by some fixed polynomial  planning belongs in
np  furthermore  encodings of planning instances in sat typically use atoms to encode
what actions appear at each position in the plan  that is  an exponential number of extra
atoms are required in the general case  hence  either our original problem was already in
np or we have to blow up the instance exponentially when reformulating to sat  in the
latter case  the complexity results are no longer comparable  also note  that if we deliberately restrict ourselves to ask only if there is a plan of a certain length or shorter  then we
are actually solving a restricted version of the optimization problem  and also in this case
planning itself would be no harder  in fact  it seems most unlikely that planning in general
could be reformulated into a problem in np  in order to avoid straightforward and naive
approaches to reformulation we consider and analyse reformulations defined as follows 
definition     let p   hv  a  i  gi be a strips instance  let f   hv  ai and let d   hi  gi 
let x be some decision problem  a reformulation of pe strips  into x is a pair hr  ri of
functions that maps every instance p   hf   d i  pe strips  to a corresponding instance
x   r r f    d    x such that p and x have the same answer  hr  ri is a polynomial
reformulation if there are also some fixed polynomials p  q such that
     r f      o p   f      and
   r is computable in o q   r f         d      time 
we thus consider a reformulation that involves two functions  r and r  function r is the
main reformulation function  intended to reformulate the difficult part of the instance  we
do not even require this function to be computable  we only require that it exists  function
r is then used to transform the initial and goal descriptions into something similar that the
new instance can use  and combine this with the result delivered by r into a proper instance
of x  it should be noted that this reformulation concept is similar  although not identical 
to the compilation concept used by nebel        
theorem     there is no polynomial reformulation of pe  strips  to some x  np 
unless the polynomial hierarchy collapses 
proof  suppose hr  ri is such a reformulation  for arbitrary integer n      let f un   hvn   an i
be defined as in construction     but without action acs  and let d in   heni    goal i  for all
i such that    i    m n    it follows trivially from the proof of lemma    that instance
p in   hf un   d in i has a solution if and only if s in is unsatisfiable  note that the sat part of
the instance is disarmed  
construct an advice taking ntm m with input i in   hf un   ii  for all n     and   
i    m n    representing i in binary using m n  bits  clearly    i in    is strictly increasing and
depends only on n  so let sn     i in     for arbitrary i   define the advice function a such that
a sn     r f un     note that we only need to know that the advice exists  not how to find it  
let m first compute d in from i in   and then compute x in   r a sn    d in     r r f un    d in   
both in polynomial time since a sn   is given for free as advice  by assumption  x in  x and
has answer yes if and only if p in has a solution  also by assumption  we have x  np so
   

fialgorithms and limits for compact plan representations

m can solve x in by guessing a solution and verifying it in polynomial time  hence  deciding
if p in has a solution is in np poly 
for an arbitrary  sat instance s in   compute i in in polynomial time  m answers yes for
i
i n if and only if s in is unsatisfiable  however  unsatisfiability for  sat is conp complete
so it follows that conp  np poly  which is impossible unless the polynomial hierarchy
collapses to level    according to theorem  b 
this result can be pushed arbitrarily high up in the polynomial hierarchy  thus making it
unlikely that planning could be reformulated to anything simpler at all 
corollary     there is no polynomial reformulation hr  ri of pe  strips  to some decision
problem x  pk   for k      unless the polynomial hierarchy collapses to level k     
proof sketch  construction    demonstrates how to encode both existential quantification
 choosing a truth assignment in the sat part  and universal quantification  enumerating
all truth assignments in the unsat part   hence  it is straightforward to modify it to an
analogous construction for qbf formulae with k alternations  given that  the rest of the
proof is analogous to the proof of theorem     but m must use an oracle for pk    the
same argument leads to pk  pk  poly  which is impossible unless the polynomial hierarchy
collapses to level k      according to theorem  b 
since both these proofs build on construction    and do not rely the exact position
of actions it follows that also this theorem and corollary hold when restricted to unary
strips instances only 

   discussion
this section consists of five parts  we first transfer the reformulation theorem to a more
general result about adding information to guide planners  and discuss how that can explain
various results in the literature  we then discuss the potential relationship between causal
graphs and compact representations  this is followed by a discussion on how the results in
the paper could be relevant for plan explanation  the fourth part discusses some related
work on compact representations and compilation  the section ends with a summary of the
results and a list of open questions 
    reformulation and additional information
theorem    has broader consequences than just for reformulation  in fact  it implies that
there is no way to help a planner by adding information to a planning frame  no matter
what information or how we get it  unless we accept that the amount of information is not
always polynomially bounded in the frame size  in the following theorem the function g is
assumed to represent the additional information  and it need not even be computable  we
only require that its result is polynomially bounded 
theorem     let p be an arbitrary polynomial  consider a function g and an algorithm
a such that
   g maps strips frames to        such that   g f      o p   f      for all frames f and
   

fibackstrom   jonsson

   for all strips instances p   hf  d i  algorithm a answers yes for input hp  g f  i if
and only if p has a plan 
if a runs in polynomial time  then the polynomial hierarchy collapses 
proof  assume there is a function g and an algorithm a with the properties described in
the theorem  define a function r such that r f     hf   g f  i for every strips frame f   also
define a function r such that r hf   xi  d     hhf   d i  xi for every strips instance p   hf   d i
and every string x  then r r f    d     hhf   d i  g f  i   hp  g f  i  so hr  ri is a polynomial
reformulation of strips planning into an equivalent problem that algorithm a can solve
in polynomial time  however  no such reformulation can exist according to theorem    
unless the polynomial hierarchy collapses 
this result can be extended upwards in the polynomial hierarchy in the same way as corollary     no longer requiring a to be a polynomial algorithm   that means that we cannot
make planning simpler by adding a polynomial amount of additional information to a frame
and use a clever algorithm to use that information when planning  planning will remain as
hard as it is without that extra information  while it may sometimes help to add information to a particular instance to somehow guide the planner  there is no systematic way to
add such information on the frame level if it is required to be of polynomial size 
the planning literature is rich with methods that are intended to make planning more
efficient by adding information in one way or another  although the methods are perhaps
not always thought of as doing so  a non exhaustive list of such methods  and similar  is
abstraction hierarchies  macros  case based planning  annotated planning and landmarks 
state space abstraction in planning goes back at least to the abstrips planner  sacerdoti         the main idea is to form abstraction hierarchies on the variables  and thus
implicitly on the actions  such that the planner can plan for the most important goals
first to get an abstract plan that can then be refined into a more detailed plan  knoblock
       proposed an algorithm for automatically computing such abstraction hierarchies 
while his algorithm was successful on many examples it was demonstrated to sometimes
fail and produce exponential plans for instances that have a linear optimal plan  backstrom
  jonsson         this is not surprising since the use of an abstraction hierarchy can be
viewed as adding information to the planning frame  automatic generation of abstraction
hierarchies is a systematic way to add information and can thus be treated as a special case
of theorem    
adding a set of macros to a planning frame is very similar to using abstraction hierarchies  as knoblock        pp          noted  a planner that uses abstraction searches for
a plan in an abstract space and then tries to refine each action into a subplan on the lower
lever  a planner that uses macros does not search an abstract space but instead already has
a set of macros available that each correspond to a subplan  finding a macro that works
and can be expanded is thus very similar to refining an abstract action  also the use of
macros has been demonstrated to speed up planning considerably in certain cases  korf 
       macros are typically added on the frame level  and learning has been suggested
as one method to create macros automatically  korf         however  macros are typically treated as any other action by the planner and are not expanded until after finding a
plan  hence  the addition of macros may also backfire and make planning less efficient  just
   

fialgorithms and limits for compact plan representations

as adding redundant actions may do  haslum   jonsson         once again  this is not
surprising since the addition of macros is addition of information and is thus also covered
by theorem    
case based planning  see spalazzi        for a survey  uses stored plans or plan skeletons
that the planner tries to reuse by modifying and or extending them  in one sense  this is
similar to macro planning  but with more advanced macros and macro expansion methods 
one can also view it as similar to abstraction  where a plan must be refined in order to
work  the difference is that the abstraction planner finds the plan skeleton by planning in
an abstract space while the case based planner has a set of such plans stored in a database 
these plans may be handcoded  but are usually the result of learning from previous planning
situations  it is well known that also case based planning may fail to improve efficiency and
that the cases used must be similar to the actual instance at hand  nebel   koehler       
liberatore      b   also this can be explained as a special case of our theorem    
the term annotated planning is sometimes used to refer to a number of similar techniques of adding control information to a planner  examples are the prodigy planner
 veloso et al         which allows control information like rules for goal ordering and
tlplan  bacchus   kabanza        which allows adding temporal logic axioms to control
the planner  while such techniques can be good if using hand tailored control rules axioms
for a particular application domain  it is immediate from theorem    that they cannot help
us in the general case 
planning with landmarks  hoffmann  porteous    sebastia        is the idea of adding
explicit subgoals  called landmarks  to a planning instance  the intention is to tell the
planner that the landmarks must be achieved by the plan in order to achieve its overall
goal  landmarks may also be ordered  to further guide the planner  however  as the
authors themselves point out  deciding if a variable value  or logic formula  is a necessary
subgoal is itself a pspace complete problem  hence  one usually considers incomplete
sets of landmarks  more interestingly  landmarks differ from the previous methods above in
a very important aspect  landmarks are added on the instance level  not on the frame level 
although this might not be quite a rigid difference in practice  it seems to be fundamental
in essence  hence  adding landmarks is a non uniform case of adding information and it is
thus not immediately covered by theorem     how to meaningfully analyse the non uniform
case remains an open question 
    causal graphs
knoblock        defined an ordering on the variables of a planning instance which he
used as a guidance for finding abstraction hierarchies  an ordering on the variables was
fundamental also for the  s class  jonsson   backstrom      b  and this ordering implicitly
defined an abstraction hierarchy  the concept of an ordering on the variables with the
intention of defining an abstraction hierarchy  define tractable subclasses etc  is nowadays
usually referred to as a causal graph  see chen   gimenez        for a survey of using
properties of the causal graph to define tractable subclasses of planning   many papers still
use knoblocks definition  which is as follows 
for every strips action a let vpre a    atoms pre a   and vpost a    atoms post a    let
   

fibackstrom   jonsson

f   hv  ai be a strips frame  the causal graph for f is the directed graph gcg   hv  i
where for all u  v  v   u  v if and only if both u    v and there is some a  a such that
u  vpre a   vpost a  and v  vpost a   
the idea behind causal graphs is that each strongly connected component of the graph
should correspond to an abstraction level  if applying this definition to examples in this
paper  we find that an instance according to construction    has a causal graph containing
a large strongly connected component  that is  it would not be possible to form any good
abstraction hierarchies for it based on such causal graphs  however  theorem    says that
plans for such instances seem not very likely to have useful compact representations anyway 
plans for the binary counter in construction   do have polynomial crars since they have
polynomial macro plans  yet  the whole causal graph for such an instance is also strongly
connected  on the other hand  plans for the gray counter in construction   are exponential
and have polynomial crars too  but the causal graph is acyclic in this case  it thus seems
that the causal graph of the type used by knoblock and many others is not a sufficient  or
even necessarily useful  tool for judging when plans have compact representations  there
are other variants of causal graphs  though  one example is interaction networks  chen  
gimenez         another is jonssons        refined version of knoblocks causal graph 
defined as follows 
let f   hv  ai be a strips frame  the refined causal graph for f is the directed graph
grcg   hv  i where for all u  v  v   u  v if and only if u    v and either
   there is some a  a such that u  vpre a   vpost a  and v  vpost a  or
   there is some a  a such that u  v  vpost a  and either
a  there is some a   a such that u  vpost a    and v   vpost a    or
b  there is no a   a such that u   vpost a    and v  vpost a     

the major difference between this variant and knoblocks is that if two variables both
appear in the postcondition of the same action  then they do not necessarily form a cycle
in the graph  hence  unary actions is no longer a prerequisite for acyclic graphs  if using
the refined causal graph  then both the gray counter and the binary counter have acyclic
graphs  while construction    still has a large strongly connected component  that is  in
these three examples acyclicity of the refined causal graph correlates with whether plans
have compact representations or not  while this correlation seems not to hold in general  the
difference between the two types of causal graphs suggests that further study of variations on
the concept could lead to further insight into the topic of compact representations  should
this turn out to be fruitful  then it would likely carry over also to other areas where causal
graphs have been used  like model checking  wehrle   helmert        
    plan explanation
the results in this paper are also important for plan explanation  bidot et al        
suggest that it is important for planning systems  and other ai systems  to be able to
   

fialgorithms and limits for compact plan representations

explain their plans and decisions to the user  or else the user may not trust the system 
similarly  southwick        writes 
there seems to be a general agreement amongst those involved in kbs research
that in order to be useful  a system must be able to explain its reasoning to a user 
although we do not consider any advanced explanation methods  as they do  our results have
implications for what is possible to explain meaningfully  for plan explanation  our results
are not necessarily as bad as for planning  consider for example a plan for an instance of
construction     in the case where the  sat instance is unsatisfiable  almost the whole plan
consists of an alternating sequence of the form ha  b  a  b  a  b       i  where a denotes either
of the actions aix             aix n and b denotes either of the actions avf             avf m   the first
group are actions that together implement an increment function  and thus all serve the
same purpose  similarly  the second group consists of actions that all serve the purpose of
verifying that some clause is false  an abstraction of this action sequence could have the
form hinc  vfy  inc  vfy  inc  vfy       i  where inc denotes any of the counting actions and vfy
any of the verification actions  for the purpose of explanation  it seems useful to replace the
actual actions with such abstract explanations of their functions  this abstract sequence is
easier to understand  and it also allows using macros to compress it  which might further
enhance its explaining power  however  in this particular case  it would probably be even
more useful to abstract the whole sequence into a for loop  or similar  this essentially
boils down to partitioning the set of actions into equivalence classes such that each such
class consist of actions that can be meaningfully seen as implementing the same concept 
it seems both interesting and important to investigate how and when one can partition the
set of actions into equivalence classes useful for such abstractions 
plan explanation could also mean trace explanation in model checking  where we would
analogously make a long trace shorter and more abstract in order to make it easier to understand  it is well known that there are close ties between planning and model checking  and
that model checking traces can be viewed as plans and vice versa  edelkamp et al         
the number of steps  or clock cycles  can be exponential in the number of state variables 
even if the system is divided into subsystems  individual subsystems may have exponential behaviour which blows up when combined with other subsystems  an exponential size
plan trace is not of much use to an engineerit is an almost impossible task to analyse
and understand such a plan  if the planning verifying system could autonomously find
repetitive patterns  and even recursive repetitive patterns  in the plan and abstract these 
then it would be considerably easier to understand what happens and why  in fact  it may
not be interesting to execute the plan  even in a simulator  so a compact understandable
explanation of the plan may be the actual goal 
furthermore  geib        discusses the problem of combinatorial explosion in plan recognition  where an exponential number of plans may share the plan prefix recognized so far 
it could clearly be useful to have structured compact representations of plan candidates
both to save space and to allow for more intelligent operations on these plans  although
this problem is slightly different from representing a single long plan  we have seen that
these two problems are related 
in all these cases  the primary purpose of a compact representation would thus be to find
and exploit some inherent structure in the plan  or set of plans  rather than to save space 
   

fibackstrom   jonsson

    additional related work
liberatore      a  has also studied the problem of representing plans compactly and there
are similarities as well as differences between his results and ours  in contrast to us  he
considers also plans represented as sequences of states  not only sequences of actions  for
both cases  he considers a random access representation as well as a sequential representation  his random access representation of action sequences  ta  is essentially the same
as our crar concept  except that he specifies that it must be implemented by a circuit 
the sequential representation of action sequences  sa   on the other hand  is different from
our csar concept  it is a function that takes a state as input and returns the next state 
hence  it is more like a restricted type of reactive plan than a csar  and his results are
thus not immediately comparable to ours  for instance  contrary to our theorem    he
proves that a ta representation cannot be polynomially converted to an sa representation 
which clearly shows that sa and csar are quite different concepts  his proof that not
all planning instances have plans with an sa representation does thus not obviously carry
over also to csars  furthermore  he uses a planning language where actions are modelled
as polynomial size circuits  this coincides with our class ffp  p    hence  his hardness
proofs are weaker than ours since we use the restricted strips language in those cases  it
should finally be noted that liberatores theorem    for the case of ta representations is a
result similar to our theorem     but we use different methods and different conditions 
nebel        defines a concept of compilation between planning languages  although in
some ways similar to our reformulation concept  there are also differences  a compilation is
a function from a planning frame to another frame in a different planning language  this
compilation need not be resource bounded but the resulting frame must be polynomially
bounded in the original frame  the initial state and goal must then be possible to translate
in polynomial time  that is  the first step corresponds to our function r while the second
step essentially corresponds to our function r  however  nebel only considers compilation
between planning languages and also requires a concept of modularity that is not present
in our approach  furthermore  his focus is not on the complexity of the decision problem
but on the question whether the size of solutions is preserved by compilations 
    conclusions and open questions
the current status of our knowledge about non uniform compact representations can be
visualized as in figure    the outer box represents the set of all solvable strips instances
while the inner boxes represent the subsets where at least one plan for each instance has a
csar  crar or polynomial macro plan  we know classes where at least one plan for each
instance is guaranteed to have a polynomial macro plan  like towers of hanoi and  s  we
also know classes where at least one plan for each instance has a crar but we do not know
if those plans also have a polynomial macro plan  construction    is such an example  it
is an open question if a plan can have a crar but no polynomial macro plan  we further
know classes where each instance has a plan with a csar but where we do not know if they
also have a crar  for example  the class of reversible systems  however  construction   
is a class where all instances have a plan with a csar but no plan with a crar  so this
case provides a strict separation between the csar and crar concepts  whether there are
classes of strips instances where no plan has a csar remains an open question  though 
   

fialgorithms and limits for compact plan representations

all plans
plans w  csar
plans w  crar

 s
towers of
hanoi

plans w  poly 
macro plans
 

 

anything
here 

reversible
systems

 

construction   

construction   

figure    current status for csars and crars 

we thus have the following chain of inclusions
polynomial macro plans  crar  csar  strips 
where we do not know if the first and last inclusions are strict 
theorem    may seem weak since it is only conditioned with p    np  using similar
techniques as in the proofs of lemma    and corollary    we could encode qbf with
arbitrary number of alternating quantifiers and  hence  push the result up in the polynomial
hierarchy  however  it remains an open question if the condition could be strengthened all
the way to p    pspace 
while we have argued that a number of results hold also when restricted to unary
instances  and in some cases also other restrictions  this is otherwise a largely unexplored
area  little is currently known about how various structural and other restrictions affect
the results in this paper  this applies both to whether plans have csars and crars and
to whether they have polynomial size macro plans 
just as we consider the non uniform case of compact representations of single plans for
single instances  it might also be interesting to consider the non uniform case of reformulation and of adding information  however  this seems not straightforward since we could
always reformulate an instance to a single bit telling whether the instance is solvable or not 
such a reformulation is clearly not interesting so additional criteria are necessary 
we have previously  backstrom   jonsson      a  defined a complexity measure based
on padding which is intended to be insensitive to plan length  this concept seems related
to nebels compilations  although the two concepts are not identical or directly comparable 
it is thus reasonable to believe that also compact representations and padded complexity
are somehow related  especially since padded complexity was motivated by instances with
long plans  however  we do not yet know what this relationship is  furthermore  it would
   

fibackstrom   jonsson

be interesting to consider compilations where we look at the size of compact representations
of plan rather than the size of explicit plans 
acknowledgments
malte helmert  anders jonsson and the anonymous reviewers of this paper and the earlier
conference version have provided valuable comments and suggestions 

references
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for planning  artificial intelligence                    
backstrom  c     jonsson  p       a   all pspace complete planning problems are equal
but some are more equal than others  in proceedings of the  th international symposium on combinatorial search  socs    castell de cardona  barcelona  spain  pp 
     
backstrom  c     jonsson  p       b   limits for compact representations of plans  in proceedings of the   st international conference on automated planning and scheduling 
 icaps     freiburg  germany  pp       
backstrom  c          computational complexity of reasoning about plans  phd dissertation  linkoping university  linkoping  sweden 
backstrom  c          expressive equivalence of planning formalisms  artificial intelligence 
               
backstrom  c     jonsson  p          planning with abstraction hierarchies can be exponentially less efficient  in proceedings of the   th international joint conference on
artificial intelligence  ijcai     montreal  qc  canada  pp           
backstrom  c     klein  i          planning in polynomial time  the sas pubs class 
computational intelligence            
backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence             
balcazar  j          the complexity of searching implicit graphs  artificial intelligence 
               
bidot  j   biundo  s   heinroth  t   minker  w   nothdurft  f     schattenberg  b         
verbal plan explanations for hybrid planning  in proceedings of the   th mkwi
related puk workshop  planung scheduling und konfigurieren entwurfen  puk    
pp           
bille  p   landau  g   raman  r   sadakane  k   satti  s     weimann  o          random
access to grammar compressed strings  in proceedings of the   nd acm siam symposium on discrete algorithms  soda     san fransisco  ca  usa  pp         
bonet  b          conformant plans and beyond  principles and complexity  artificial
intelligence                    
   

fialgorithms and limits for compact plan representations

bonet  b     geffner  h          planning with incomplete information as heuristic search
in belief space  in proceedings of the  th international conference on artificial intelligence planning systems  aips     breckenridge  co  usa  pp       
boutilier  c     poole  d          computing optimal policies for partially observable
decision processes using compact representations  in proceedings of the   th national
conference on artificial intelligence  aaai     portland  or  usa  vol     pp      
     
brafman  r  i     domshlak  c          structure and complexity in planning with unary
operators  journal of artificial intelligence research             
buhrman  h   jiang  t   li  m     vitanyi  p  m  b          new applications of the
incompressibility method  part ii  theoretical computer science                
bulatov  a     dalmau  v          a simple algorithm for maltsev constraints  siam
journal of computing               
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence                   
cadoli  m   donini  f   liberatore  p     schaerf  m          space efficiency of propositional
knowledge representation formalisms  journal of artificial intelligence research     
    
charikar  m   lehman  e   liu  d   panigrahy  r   prabhakaran  m   sahai  a     shelat  a 
        the smallest grammar problem  ieee transactions on information theory 
                 
chen  h     gimenez  o          causal graphs and structurally restricted planning  journal of computer and system sciences                 
edelkamp  s   leue  s     visser  w          summary of dagstuhl seminar       on
directed model checking  in directed model checking  no        in dagstuhl seminar
proceedings  dagstuhl  germany 
galperin  h     wigderson  a          succinct representations of graphs  information and
control                 
geib  c          assessing the complexity of plan recognition  in proceedings of the   th
national conference on artificial intelligence  aaai     san jose  ca  usa  pp 
       
gill  a          applied algebra for the computer sciences  prentice hall  englewood
cliffs  nj 
gimenez  o     jonsson  a          the complexity of planning problems with simple
causal graphs  journal of artificial intelligence research             
haslum  p     jonsson  p          planning with reduced operator sets  in proceedings of the
 th international conference on artificial intelligence planning systems  aips    
breckenridge  co  usa  pp         
hoffmann  j   porteous  j     sebastia  l          ordered landmarks in planning  journal
of artificial intelligence research             
   

fibackstrom   jonsson

jansson  j   sadakane  k     sung  w  k          compressed random access memory 
arxiv  abs          v  
johnson  d  s   papadimitriou  c  h     yannakakis  m          on generating all maximal
independent sets  information processing letters                 
jonsson  a          the role of macros in tractable planning  journal of artificial intelligence research             
jonsson  p     backstrom  c       a   state variable planning under structural restrictions 
algorithms and complexity  artificial intelligence                    
jonsson  p     backstrom  c       b   tractable plan existence does not imply tractable
plan generation  annals of mathematics and artificial intelligence                   
jonsson  p   haslum  p     backstrom  c          towards efficient universal planning  a
randomized approach  artificial intelligence               
karp  r  m     lipton  r  j          some connections between nonuniform and uniform complexity classes  in proceedings of the   th acm symposium on theory of
computing  stoc     los angeles  ca  usa  pp         
kautz  h  a     selman  b          planning as satisfiability  in proceedings of the   th
european conference on artificial intelligence  ecai     vienna  austria  pp     
    
knoblock  c  a          generating abstraction hierarchies  an automated approach to
reducing search in planning  kluwer academic publishers  norwell  ma 
knoblock  c  a          automatically generating abstractions for planning  artificial
intelligence                 
korf  r  e          macro operators  a weak method for learning  artificial intelligence 
             
korf  r  e          planning as search  a quantitative approach  artificial intelligence 
             
liberatore  p     schaerf  m          on the size of data structures used in symbolic model
checking  arxiv  abs           
liberatore  p       a   complexity issues in finding succinct solutions of pspace complete
problems  arxiv  abs cs         
liberatore  p       b   on the complexity of case based planning  journal of experimental
and theoretical artificial intelligence                 
long  d   fox  m     hamdi  m          reformulation in planning  in proceedings of
the  th international symposium on abstraction  reformulation and approximation
 sara     kananaskis  ab  canada  vol       of lecture notes in computer science  pp        springer 
muscettola  n   pandurang nayak  p   pell  b     williams  b  c          remote agent 
to boldly go where no ai system has gone before  artificial intelligence            
    
   

fialgorithms and limits for compact plan representations

nebel  b          on the compilability and expressive power of propositional planning
formalisms  journal of artificial intelligence research             
nebel  b     koehler  j          plan reuse versus plan generation  a theoretical and
empirical analysis  artificial intelligence                   
rytter  w          application of lempel ziv factorization to the approximation of
grammar based compression  theoretical computer science                    
sacerdoti  e  d          planning in a hierarchy of abstraction spaces  artificial intelligence 
              
southwick  r  w          explaining reasoning  an overview of explanation in knowledgebased systems  knowledge engineering review         
spalazzi  l          a survey on case based planning  artificial intelligence review     
    
veloso  m  m   carbonell  j  g   perez  a   borrajo  d   fink  e     blythe  j          integrating planning and learning  the prodigy architecture  journal of experimental
and theoretical artificial intelligence research               
wagner  k          the complexity of combinatorial problems with succinct input representation  acta informatica                 
wehrle  m     helmert  m          the causal graph revisited for directed model checking 
in proceedings of the   th international symposium on static analysis  sas     los
angeles  ca  usa  vol       of lecture notes in computer science  pp        
springer 
williams  b     pandurang nayak  p          a reactive planner for a model based executive  in proceedings of the   th international joint conference on artificial intelligence  ijcai     nagoya  japan  pp           
yap  c  k          some consequences of non uniform conditions on uniform classes  theoretical computer science             

   

fi