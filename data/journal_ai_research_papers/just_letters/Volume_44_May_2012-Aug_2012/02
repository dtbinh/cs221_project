journal artificial intelligence research                  

submitted        published      

algorithms limits compact plan representations
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department computer science
linkoping university
se        linkoping  sweden

abstract
compact representations objects common concept computer science  automated planning viewed case concept  planning instance compact
implicit representation graph problem find path  a plan  graph 
graphs represented compactly planning instances  paths
usually represented explicitly sequences actions  cases known
plans always compact representations  example  using macros  show
results extend general case  proving number bounds compact
representations plans various criteria  efficient sequential random access
actions  addition this  show results consequences
gained reformulating planning problem  contrast
prove number positive results  demonstrating restricted cases plans
useful compact representations  well proving macro plans favourable access
properties  results finally discussed relation relevant contexts 

   introduction
usage study representations objects much smaller objects
commonplace computer science  us encounter representations
daily basis form zipped files  mp  files etc  practical cases  usually
talk compressed objects  terms compact succinct common
theoretical studies  meaning terms vary common interesting case
size representation polylogarithmic size object 
sometimes sufficient compute compact representation object  instance 
archiving file  cases representation must support various operations
efficiently without first unpacking object explicit representation  performing
operations compact representation often harder performing operation
explicit object  cases compact representation make easier
emphasising inherent structure object 
one archetypical case using compact representations automated planning  although
seldom viewed way  planning instance implicit representation graph
typically exponentially larger representation  instance 
solutions  plans  paths graph  consider  example  strips instance
n variables  variables implicitly define state space  n states action
preconditions define  nm arcs graph  similarly  define instances
paths exponential length too  although planning instances already
c
    
ai access foundation  rights reserved 

fibackstrom   jonsson

compact representations  little attention paid compact representations
solutions  usually represented explicitly  paper introduces analyses
number compact representations 
first turn computer science general find compact representations
arbitrary strings intensively studied field  example  charikar et al        
rytter        address problem approximating smallest string representation using
compressed grammar  bille et al         show representations permit efficient
access matching operations  jansson  sadakane  sung        demonstrate
representations efficient edit operations  structured objects arbitrary strings
potentially compact representations  following examples 
displaying positive well negative results various areas  galperin wigderson
       wagner        study complexity common graph operations
graphs implicitly represented circuits tell whether two vertices connected 
balcazar        uses variant approach study complexity search ai 
using circuit generates adjacency list vertex  bulatov dalmau       
present efficient algorithm certain csp problems relies using compact
representation set solutions  liberatore schaerf        study preprocessing
model checking focus size preprocessed parts  cadoli et al         study
various formalisms knowledge representation study problems modelled one
formalism transformed another formalism polynomially larger
representation 
one approach compact representations various areas use macros 
concept widely used long time planning  although seldom
purpose providing compact representations  exception following case   s
class  jonsson   backstrom      b  planning instances property optimal
plans exponential length always possible decide polynomial time
plan not  gimenez jonsson        showed plans  s class
always polynomial size representation using macros  macro plans even
generated polynomial time  is  although plan may exponential length 
thus necessarily take exponential time generate  possible generate compact
representation polynomial time  jonsson        later demonstrated similar results
number classes  although particular classes planning instances may
still restricted much practical use  principle compressing solution
using macros interesting tool planning plan explanation 
approaches compact plan representation appear sparingly literature 
notable exception liberatore      a  studies two concepts plan representation
efficient random access efficient sequential access respectively  macro
plans examples representing one long plan compactly  might consider
representing large set plans compactly  instance  plan recognition may
simultaneously consider exponential number candidate plans  geib         although
seldom viewed way  reactive plan representation large set plans 
one state goal reached  is  however  known reactive
plans cannot compact  efficient correct general case  jonsson  haslum 
  backstrom         although properties important  instance  spaceship
applications  williams   pandurang nayak         pomdps may similarly thought
   

fialgorithms limits compact plan representations

probabilistic variant reactive plans compactness representations important
case  boutilier   poole         yet another case size plan
big plan necessarily long  occur various types branching
plans  contingent planning  bonet   geffner         three different concepts
isolated other  instance  bonet        casts contingent planning
problem conformant planning  is  branching plan represented one
long non branching plan  branches appearing subplans  cases 
interesting know objects question compact representations  although
compact representation save space  may secondary many cases 
important aspect object compact representation object
inherent structure may exploit purposes  instance  represent
set many plans representation using recursive macros  similar  emphasize
differences similarities plans  make comparisons
operations plans efficient  similarly  case branching plans might
want exploit structure clearly displays two branches common
differ 
positive results macro representations  gimenez   jonsson        jonsson       
prompt obvious question whether long plans always compressed using macros
 or method   show paper unlikely  matter type
compact representation try use  macro plans  finite automata whatever  
remainder paper organized follows  section   introduces basic notation
concepts well planning framework used paper  contains
useful definitions complexity results  first ask  section    whether
 optimal  plans instance compact representations  find answer
no  possible  neither macros method  however  results
exclude plans instance compact solutions  section  
thus restrict question whether uniform compact representation one plan
solvable instance  precisely  ask algorithm corresponds
one compact representation solvable instance  show algorithm
unlikely exist must able access actions plan useful way 
section   turn non uniform case  asking solvable instance least
one plan compact representation  primarily consider representations
efficiently access actions plan sequentially randomly  show
seems unlikely general case  interesting special cases
representations exist  section investigate macro representations
extend results gimenez jonsson two ways  prove plans
polynomial size macro representation random accessed polynomial
time without access full plan  however  prove cannot always
represent plans compactly using macros  section   analyse whether get around
problem long plans reformulating planning problem 
answered negatively  actually ask plan original problem  problem
inherently intractable using reformulation  however  even considering
decision problem still seems possible make planning simpler reformulation 
finally  section   contains discussion results paper related
relevant various topics adding information guide planners  causal graphs
   

fibackstrom   jonsson

plan explanation  paper ends summary results together list
open questions 
results paper appeared previous conference publication
 backstrom   jonsson      b  

   preliminaries
section consists three parts  first part introduces general notation
terminology used paper  second part defines two planning frameworks used
paper  finite functional planning propositional strips  presents
constructions frequently used  third part briefly recapitulates concept
advice taking turing machines defines  sat problem used
several occasions paper 
    general notation terminology
sequence objects x    x            xn written hx    x            xn i  hi denoting empty
sequence  given set x objects  set sequences x  including hi  denoted
x   set  sequence aggregation x objects  write  x  denote
cardinality  the number objects  x write   x   denote size  the number
bits representation  x  composition two functions f g denoted
f g defined  f g  x    f  g x   
negation propositional atom x denoted x  literal either atom
negation set l x  literals set x atoms defined l x   
 x  x   x x   negation extended literals   literal    negation
extended sets x set literals x          x   let
subset l x  set x atoms  p os y      x x   x   set
atoms appear positive   n eg y      x x   x   set atoms
appear negated atoms y     p os y  n eg y    set consistent p os y  
n eg y   empty set z atoms satisfies p os y   z n eg y  z    
update operator n binary function given set x atoms set
literals  x n set atoms defined x n    x n eg y    p os y   
    planning
positive results compact representations  want results apply general
powerful planning languages possible  results hold languages
restricted  hence  use finite functional planning formalism  backstrom  
jonsson      a   makes minimum assumption language  except
ground language state variables finite domains 
definition    finite functional planning  ffp  frame tuple hv  d  ai v
implicitly ordered set variables    v n domain function maps every variable
finite subset natural numbers set actions  frame implicitly
defines state space s f     d v          d vn    v            vn variables
v order  members s f   referred states  action two
associated total functions  precondition pre a    s f          postcondition
   

fialgorithms limits compact plan representations

post a    s f   s f    pairs states s  s f   actions a 

   pre a  s     
     post a  s  
sequence   ha            a  plan state s  s f   state s  s f  
either
     hi s    s 
   states s            s   s f   ai si  si  for      
ffp instance tuple p   hv  d  a  i  gi f   hv  d  ai ffp frame 
s f   state g   s f          total function  state s f   goal
state p g s       goal g reachable state s f   plan
goal state p  solution p plan goal state s f   
solution p called plan p 
complexity computing pre  postconditions actions goal
function referred step complexity  paper  consider subclass
ffp  p   consists ffp frames instances polynomial step complexity 
occasionally consider restrictions ffp  p   use notation ffp p 
class ffp frames f  and instances p  action pre  postconditions
 and g  computed p   f     time  and p   p    time   p polynomial 
furthermore say ffp  p   instance p   hv  d  a  i  gi deterministic
s p  p plan s  one
pre a  s       is  instance deterministic planner never faced
choice two actions 
proving compact representation exist  result gets stronger
use weaker formalism  is  want use restricted formalism possible 
since results automatically apply formalisms expressive 
hence  use propositional strips results  number common
variants propositional strips known equivalent
sas  formalism strong form polynomial reduction  backstrom        
refer strips paper variant called propositional strips
negative goals  psn  backstrom  defined special case ffp  p  
uses binary variables  define traditional way  treating variables
propositional atoms 
definition    strips frame tuple f   hv  ai v set propositional atoms
set actions  state space defined s f      v states subsets
v   action precondition pre a  postcondition post a  
consistent sets literals v   pairs states s  s f   actions a 

   satisfies pre a 
     n post a  
sequence   ha            a  plan state s  s f   state s  s f  
either
     hi s    s 
   states s            s   s f   ai si  si  for      
   

fibackstrom   jonsson

strips instance tuple p   hv  a  i  gi f   hv  ai strips frame 
state s f   g consistent set literals v   state s f   goal state
p satisfies g  goal g reachable state s f   plan
goal state p  solution p plan goal state s f   
solution p called plan p 
notation   x frequently used define action precondition x
postcondition  
negative results proven hold strips  however  cases results
hold even many restricted subclasses strips  would lead far survey
cases paper use restriction unary actions archetypical case
throughout paper 
definition    strips action unary  post a        set strips actions unary
actions unary strips frame instance unary action set unary 
unary actions may seem limiting restriction demonstrated
sufficient many cases use on board controllers spacecrafts  muscettola et al  
      brafman   domshlak         surprising  though  since strips planning
pspace complete remains even restricted unary actions  bylander        
given strips instance always possible construct corresponding strips instance
unary  following reduction unary instances simplified strips version
reduction used sas    backstrom        proof theorem      
construction    let p   hv  a  i  gi strips instance  construct corresponding

instance p     hv     a        g  follows  define vlock    vlock
  a   let v    
 
 
 
v vlock     g   g vlock   define a  contains
following actions 
  
abegin   pre a  vlock  vlock

  
aend   post a   vlock    vlock
          post a  
ai    vlock


leave without proof construction polynomial reduction class
strips instances class unary strips instances  furthermore worth noting
construction easily modified use padding redundant variables
make original actions correspond number actions unary instance 
hence  possible make reduction plans unary instance
constant factor longer corresponding plans original instance 
make frequent use strips instances include encodings binary
counters based following construction  uses one action bit
increment non negative integer encoded binary 
construction    n bit binary counter encoded strips follows  let v  
 x            xn   let contain n actions
ai    xi   xi            x     xi   xi            x       n  
   

fialgorithms limits compact plan representations

following plan counting      using   bit counter according construction   
ha    a    a    a    a    a    a    a    a    a    a    a    a    a    a    a  i 
could modify binary counter use unary actions described construction    direct way get unary actions count gray code 
construction     backstrom   klein        n bit gray code counter encoded
strips follows  let v    x            xn   let contain  n actions
si    xi   xi    xi            x     xi      n  
ri    xi   xi    xi            x     xi      n  
following plan counting        bit gray code counter according
construction   
hs    s    r    s    s    r    r    s    s    s    r    r    s    r    r    s  i 
    complexity theory
use abbreviation dtm deterministic turing machine ntm nondeterministic turing machine  addition standard types  use advice
taking turing machines deterministic nondeterministic type 
advice taking turing machine associated sequence a    a    a          advice
strings  special advice tape advice function a  natural numbers
advice sequence  a n      input x advice tape immediately loaded
a   x     continues normal way  except access
advice written advice tape  exists polynomial p   a n    p n  
n      said use polynomial advice  complexity class p poly
set decision problems solved advice taking dtm runs
polynomial time using polynomial advice  extended that  instance 
np poly defined ntms run polynomial time using polynomial advice 
note advice depends size input  content  furthermore 
advice sequence must exist  need computable  following two
results literature used later paper 
theorem    a  np p poly  polynomial hierarchy collapses  karp   lipton 
      theorem       b  let k     integer  pk pk  poly  polynomial
hierarchy collapses level k      yap        lemma   combined theorem    
 sat problem consists instances form c    c            cm   ci  
  m  called clause set exactly three literals universe
binary variables  instance c satisfiable exists assignment truth
values variables used c least one literal true ci c 
otherwise unsatisfiable  deciding satisfiability  sat np complete  deciding
unsatisfiability conp complete  precisely  use following definition
 sat paper 
   

fibackstrom   jonsson

definition    integers n      let xn    x            xn   set variables let
m n 
m n  number possible   literal clauses xn   let c n   c n           cn

m n 
 
 
fixed systematic enumeration clauses let cn    cn   cn           cn    clause
m n   
cin defines three literals that  cin      i     i     i    further  let cn    cn            cn 



fixed systematic enumeration subsets cn   let n   hxn   cn i     
m n 
 m n    implicitly define set en    e n   e n           en   atoms subsets
eni    ejn   cjn cni         m n   
m n 

  systematic enumeration possible  sat instances
sequence  n    n            n
n variables  hence equivalent usual definition  sat  technically speaking 
redundant encoding  sat since allows instances specify variables
used clauses  harmless  however  non redundant instances remain 
still hard instances neither redundantly encoded instances
harder non redundant counterpart  since m n   n    enumerations
cn en chosen polynomial time computable  assume
enumerations fixed on  note set eni uniquely
identifies clause set cni  

   representing arbitrary plans compactly
known cases planning instances exponential size plans
plans always polynomial size representation  gimenez   jonsson        
obvious question thus whether plans  including exponential length 
polynomial representations  one interpretation question answer trivially yes 
observation    set plans arbitrary ffp  p   instance p o   p   
size representation  since instance together deterministic planning algorithm
successively enumerates outputs plans representation 
although trivial useful observation highlights fundamental issues representations  liberatore      a  discusses similar representation  instead
specifying algorithm defines lexiographic ordering actions  furthermore 
adds plan index able represent single plan rather whole set
plans  however  index unproblematic  see soon 
interesting interpretation question whether every single plan
particular instance polynomial representation  even precisely 
polynomial p every plan every planning instance representation
size o p n    n size planning instance  investigate question
consider simple compact notation possible  index number plan
particular instance  since instances may infinitely many plans  due cycles
state transition graph  consider optimal plans only  is  however  guarantee
even index small enougha polynomial number bits may sufficient
represent it 
   sometimes omit index n  assumed obvious context  thus write  ki rather
 kn i  

   

fialgorithms limits compact plan representations

construction     given arbitrary integer n      construct strips instance p n  
hvn       gn vn    x            xn   y       gn    x            xn   contains
actions
ai    xi   xi            x     xi   xi            x    y     n 
bi    xi   xi            x     xi   xi            x    y     n  
lemma     every integer n      instance pn according construction      
optimal plans 

n  

proof  let n     arbitrary integer p n corresponding strips instance according
construction     instance binary counter variables x            xn
construction    except extra variable independently set
true false  depending whether action type ai bi chosen  since variables
x            xn interpreted binary number  let notation hm  yi represent
state x            xn encodes number false  let hm  yi represent
corresponding state true  whenever state hm  yi hm  yi  where    n   
possible go either hm      yi hm      yi using one action 
states  state transition graph instance appears figure    initial state
h   yi goal states h n    yi h n    yi  hence  plan p n must
length  n    every state goal state two different actions
choose lead different states  however  goal reachable
n
states choice action matter  hence       different
plans p n  

m 

 

 

 n  
y  

 

y  
goal

init

figure    state transition graph proof lemma    
although atom redundant particular example whole construction could
part larger instance  purpose  noted
instances used proof optimal plans  plans length 
set prove previous claim 
theorem     every integer n      takes  n   bits index optimal plans
instance pn according construction    
proof  since m bit number distinguish  m different objects 
follows lemma    least  n   bits necessary index plans p n
   

fibackstrom   jonsson

result immediately implies  optimal  plans strips instance
polynomial size representations  holds even restrictions  unary actions 
basing construction    gray counter instead binary counter every action
two postconditions  rewriting using construction   yields equivalent instance
unary actions using block four actions action original instance 
although plans get   times longer number plans remain same  hence 
theorem    still holds 
theorem leaves possibility open plans instance
polynomial representations  although can  interesting question thus
many plans instance polynomial representations  answer
question stray field information theory kolmogorov complexity 
scope paper treat field detail  loosely speaking  kolmogorov
complexity string size smallest dtm generate string
input  let k x  denote kolmogorov complexity binary string x  following
lemma due buhrman et al         lm     
lemma      incompressibility lemma  let c positive integer  every set cardinality
least m    c       elements x k x  blog mc c 
lemma used show fraction plans compactly represented
approaches zero size instances approaches infinity 
theorem     let p arbitrary polynomial  consider instances pn according construction    arbitrary integers n      let t n  total number plans
pn let s n  number plans represented p n  bits 
limn s n 
t n      
n

proof  let p arbitrary polynomial  know lemma    t n          
every n      let c n     n p n     incompressibility lemma says
least t n     c n        plans k   blog t n c c n  
is   c n  t n    plans k     blog t n c c n   using
values t n  c n  above  simplifies say  p n     
plans k   p n   hence  s n   p n       theorem follows since
 p n     
  limn s n 
    
t n  limn   n  
means even case plans every solvable instance
compact representations  probability particular plan compact representation
vanishingly low large instances  although strictly necessary use
kolmogorov complexity prove theorem    makes information theoretic
aspect compact representations clearer 

   uniform compact representations plans
know cannot  general  compress arbitrary exponential plans subexponential size  choose plan use  previous
result still leaves open possibility small fraction solutions planning instance could compact representations  however  planner  or oracle whatever 
   

fialgorithms limits compact plan representations

would choose us plan present us compact representation
of  suppose planner could actually this  would make use it  still need
actual plan cannot avoid exponential size  hence  interesting case
seems could least access useful information plan efficiently 
term representation used loose sense here  need really precisely
defined moment  suffices note representation needs kind
data structure kind access algorithm  extreme cases either
vector data trivial access algorithm algorithm embeds data 
could mean access compact representation efficiently  investigate
two criteria  first one efficiently retrieve actions actual
plan sequentially  interpretation efficient actions retrieved
polynomial delay  johnson  papadimitriou    yannakakis         second criterion
action actual represented plan random accessed polynomial time 
size instance 
looking explicit representations plan take look uniform
case  single representation covers instances  precisely 
consider case single algorithm works compact representation
plan every solvable instance 
theorem     algorithm solvable strips instance p either
generate plan p sequentially polynomial delay random access action
plan p polynomial time  p   np 
note theorem follow fact strips planning pspacecomplete since solvable instances considered  proving theorem need
introduce extra technical machinery  start encoding  sat instances according
definition   strips follows 
construction     let n     i       m n    arbitrary integers  construct
strips instance p   hvn     eni    goal i vn   xn en  cts  ctu  goal  inc 
 v            vm n    actions specified table   
previously noted  subset eni en uniquely identifies  sat instance telling
clauses cn enabled   is  initial state selects particular nvariable instance interested in  actions partitioned three groups  group
contains two actions acs acu  set atoms cts ctu respectively 
actions block cts ctu initially false  one atoms
set true plan  is  cts ctu mutually exclusive  group ii consists
actions require cts true group iii consists actions require ctu true 
two groups actions thus mutually exclusive  hence  every plan must start
exactly one action group rest plan consists actions
either group ii group iii  depending first action is  intention
following  plan starts action acs commits verifying
satisfiable plan starts action acu commits verifying
satisfiable  either case plan ends action satisfies goal plan
verified commitment made first action  interpreted viewing
   

fibackstrom   jonsson



acs    ctu   cts 
acu    cts   ctu 

commit prove satisfiability
commit prove unsatisfiability

ii

aseti    cts  v     xi  
avt     cts   v   

set xi
start verification

avt j    cts  ejn   vj      vj  
avtkj    cts  ejn   vj     kj    vj  
ags    cts  vm n     goal 

skip disabled clause cj
verify cj true since  kj true
conclude instance satisfiable

avf j    ctu  inc  ejn     j     j     j    inc 
aixi    ctu  inc  xi   xi            x   
 inc  xi   xi            x   
agu    ctu  inc  x            xn    goal 

verify clause cj false
increment counter

iii

conclude instance unsatisfiable

index ranges    n    j m n    k   

table    actions construction    
planner theorem prover first outputs theorem  the first action plan 
proof theorem  the rest plan  
lemma     every integer n     integer      m n    strips
instance pin according construction    following properties 
   computed polynomial time n 
   corresponds  sat instance sin every plan pin starts action
acs sin satisfiable otherwise action acu 
   always least one plan 
proof  property   trivial prove  prove property    first note initial
state contains atoms en   previously noted  subset eni en uniquely
identifies  sat instance telling clauses cn enabled  
two cases  plan starts action acs commits verifying

n satisfiable plan starts action acu commits verifying
satisfiable  either case plan ends action satisfies goal
plan verified commitment made first action  details two cases
follows 
plan verifies satisfiability  must form
k

m n 
hacs  aseti            asetih   avt    avtk             avtm n 
  agsi 
 z
 
 
 
 z
 

assign

verify

assign block h actions set satisfying assignment x            xn   verify
k
block consists one action   avtj j clause cjn   cjn enabled  ejn true  
  kj   verifies  kj cjn true assignment  otherwise  cjn
   

fialgorithms limits compact plan representations

disabled kj        avt j skips cjn without verifying anything 
planner thus
   committed verify satisfiable 
   chosen satisfying assignment x            xn
   chosen one literal enabled clause witness clause true
assignment 
last action ags makes goal true three steps successful  note
works case clause enabled  corresponds trivially
satisfiable instance empty set clauses  obviously  plan form
satisfiable 
plan instead verifies unsatisfiability  must form
hacu  b    a    b    a    b            ah   bh   agui 
h    n    except first last actions  plan viewed two
interleaved sequences
  ha            ah   haix    aix    aix    aix            aix 

  hb    b            bh i 
aixi actions increment actions use x            xn form binary counter  since
variables correspond number   initial state  n   increment
actions  subplan enumerates possible truth assignments x            xn   sequence
consists actions type avf j   avf j action verifies corresponding
clause cjn enabled false current assignment x            xn   aixi actions
require inc true set false  avf j actions instead require inc false
set true  hence plan synchronised alternates actions
two sequences  since first aixi action preceeded avf j action
avf j action last aixi action  follows must unsatisfied
enabled clause every possible truth assignment  since synchronization otherwise
get stuck counter cannot increment  is  plan type
unsatisfiable  last action agu makes goal true succeeded  note
case need actions skip disabled clauses since sufficient
demonstrate one enabled clause false assignment 
follows plan first form satisfiable second form

n unsatisfiable  furthermore  since first action commitment rest
plan whether verify satisfiability unsatisfiability  sufficient check action
decide satisfiable not 
property   follows immediately property   since plan must either
two forms 
necessary tools prove theorem 
   

fibackstrom   jonsson

proof theorem     suppose algorithm either sequential random access stated precondition theorem  solve  sat instance
polynomial time asking algorithm first action plan
corresponding instance p tell action whether satisfiable  however 
implies p   np 
proof would still hold rewriting construction    described construction   
is  theorem    holds even restricted set unary strips instances only 

   non uniform compact representations plans
theorem    uses strong criterion  requires one single algorithm handle
instances  relaxed variant non uniform case  allow different
representations different instances  is  consider compact representations
single plans different access criteria  order must first define
precisely mean representations 
    compact representations access mechanisms
define concepts csar crar representations action sequences
characterised access properties   
definition     let f arbitrary function  let f   hv  d  ai ffp  p   frame
let   representation dtm  furthermore 
   f  compact      f    f     runs f    f     space including input
output tapes 
   f  compact sequential access representation  f  csar  f  compact 
takes input generates actions sequentially f    f     time
successive action 
   f  compact random access representation  f  crar  f  compact
arbitrary index  where       input  outputs action
f    f     time 
note definition require representations computable 
could used two separate functions  one bound access time one bound
size  would allow better precision  however  choose use single function
since makes theory simpler clearer sufficient precision
purposes paper  consider output tape cleared actions
output single action  sequence   note space complexity
includes input output tapes  implies longest sequence f  crar
   note definition differs slightly previous one  backstrom   jonsson      b   first 
generalised definition allow compact representations arbitrary function f  
arbitrary polynomial  second  order improve precision longer use o   notation
exact functions  finally  representations restriction space time  none
changes matter results previous publication  details proofs 

   

fialgorithms limits compact plan representations

represent less       actions since input limited      bits  csar
corresponding limit since input  furthermore  time restriction f  csar
viewed generalisation polynomial delay concept restricted
polynomials  often apply definition instances rather frames  although
makes slight difference technically  important principle ignoring
allows simpler theorems proofs  write crar csar referring
whole family representations particular type 
    sequential access representations
sequential access non uniform case would ask solvable strips
instances least one plan polynomial csar  unfortunately  still remains
open question  hence  consider restricted case question
require csar must verifiable within resource constraint  define
follows 
definition     every ffp  p   plan representation type r  define following decision problem 
plan representation verification
instance  ffp  p   instance p   hv  d  a  i  gi string  
question  r representation plan p 
complexity verification measured   p           state following
theorem polynomial csars 
theorem     let c arbitrary complexity class p arbitrary polynomial 
p csar verification np c every solvable strips instance least one plan
corresponding p csar  pspace np c  
proof  let p arbitrary polynomial  suppose p csar verification npc every
solvable strips instance least one plan corresponding p csar  let p
arbitrary strips instance  decide p plan guessing string
length p   p    bits check string p csar plan p 
done polynomial time  in   p    using ntm oracle c since p csar
verification npc   however  deciding strips instance plan pspacecomplete  bylander        thm       follows pspace npc   since p
chosen arbitrarily 
is  csar planning instance limited use must first verify
correct using it  since verification may difficult solving instance itself 
note c class polynomial hierarchy  pspace npc implies
collapse hierarchy  preceding theorem holds restriction unary strips
instances  since planning still pspace complete restriction  bylander       
thm        fact  holds restrictions planning still pspace complete 
includes several cases bylanders analysis well many subclasses
sas  planning  see backstrom   nebel        jonsson   backstrom      a  overviews
results  
   

fibackstrom   jonsson

although result may seem disapointing  holds condition
must check whether csar correct  means  instance  theorem
irrelevant correctness csar guaranteed design  one case following 
theorem     every strips instance according construction    plan
polynomial csar 
proof  consider arbitrary instance p   add n     extra bits b            bn b 
tells satisfiable not  satisfiable remaining bits specify satisfying
assignment bi gives value vi   otherwise undefined  claim
simple deterministic algorithm uses p b            bn generates
plan p polynomial delay follows 
suppose b  says satisfiable h bits b            bn one 
plan p form
k

m n 
  agsi 
hacs  aseti            asetih   avt    avtk             avtm n 
 z
 
 
 z
 
 

assign

verify

actions assign block easily generated b            bn   avtkj actions 
output avt j cjn enabled otherwise output avtkj smallest k  kj
true specified assignment  clearly algorithm works polynomial delay 
instead suppose satisfiable  plan second type must cycle
possible assignments  generating corresponding counting
actions trivial  assignment must output avf j action  determine
smallest j cjn enabled satisfied current assignment 
output avf j   done polynomial time since polynomial number
clauses 
clearly construction polynomial csar plan p  
following theorem demonstrates general harder classes
instances even optimal plans polynomial csars design 
theorem     subclass x strips polynomial p deciding
instances x plan pspace complete solvable instances x
optimal plan p csar 
proof  pspace characterised class polynomial space bounded dtms 
bylander        thm       used fact demonstrate polynomial reduction
pspace strips planning  refer bylander details brief  given
machine input x constructs deterministic strips instance plan
 x  accepts  hence  polynomial time problem check
valid state find action  any  applied state  follows
polynomial p every solvable strips instance plan
p csar  furthermore  since instance deterministic one plan 
must optimal 
   

fialgorithms limits compact plan representations

even general observation every deterministic ffp  p   instance
solvable exactly one plan  thus optimal  plan polynomial
csar  contrast next consider class instances solvable instances
always plans polynomial csars optimality guarantee 
example thus illustrates csar representation gives guarantees
actual data represents  precisely  example uses class reversible
ffp  p   instances  state transition graph symmetric 
definition     ffp  p   frame f   hv  d  ai reversible pairs states
s f    whenever action action a 
s 
note reversible instances easy special case planning  deciding
plan still pspace complete  jonsson et al         thm       is  plans
still exponential length 
theorem     polynomial q polynomials p  every solvable
reversible ffp p  instance  q p  csar plan 
proof  let p   hv  d  a  i  gi solvable ffp p  instance f   hv  d  ai
reversible  consider algorithm figure    optplan assumed algorithm
optplan s g  returns length shortest plan g 
ignoring process b  clear algorithm outputs optimal plan p since
plan assumption  process b finds two actions a  a  executing
ha    a  state ends state s  choice actions must exist since
plan goal state f reversible  synchronisation processes
b make actions a    a  appear adjacent order output
algorithm  thus interfere plan produced process a 
make plan longer  choosing actions process b done double loop
pairs actions checking them 
obvious polynomial r process b runs r   p    time 
choose r allow extra time run process parallel  let p together
algorithm         p     c constant c  choose r satisfies
n   c r n  n      obviously  r csar plan p  choose
polynomial q r n  q p n   n     
algorithm optplan must obviously run polynomial space  complexity otherwise
important  parallel algorithm used proof theorem extent
nonsense algorithm  process job consulting ordinary planning algorithm
 optplan  gives time guarantees  process b  hand  contributes nothing
relevant plan satisfies access time requirement  is  process b buys time
process find plan generating irrelevant actions frequently enough satisfy
time requirements  wait statements strictly necessary illustrate
tune step complexity algorithm slowing process b desired 
although example might  perhaps  considered somewhat pathological  clearly
demonstrates csar  just crar  representation 
data structures certain access properties guarantee particular
   

fibackstrom   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  

  
g s     
parallel
process a 
    optplan s  g 
a  s t  pre a    s     
   post a    s 
optplan t  g     
   a         optplan t  g 
process b 
process running
choose a  s t  pre a    s     
u    post a    s 
choose a  s t  pre a    u      post a    u   
output a 
wait
output a 
wait
output
   post a  s 

figure    csar algorithm reversible instances 
properties actual data stored  uncommon plan representations either 
instance  reactive plan could constructed behaviour still
considered correct run polynomial time space  alternatively use
random walk algorithm  output actions polynomial delay 
eventually reach goal plan  output lot redundant
actions  algorithm figure   may  sense  viewed derandomized variant
random walk 
    random access representations
case non uniform random access clearer case sequential access 
answer question existence crars without qualifications
verifiability 
theorem     polynomial p every solvable strips instance
least one plan corresponding p crar  polynomial hierarchy collapses 
since theorem conditioned verifiability representations stronger
result theorem     proving theorem need introduce additional theory 

   

fialgorithms limits compact plan representations

construction     let n     arbitrary integer  construct strips instance p n  
hvn        goal i
vn   xn en  v            vm n     svi  sva  sia  sii  sti  t  f  goal 
actions specified table   

abi    svi  sva  sia  sii  sti   svi  t 

begin instance block

aba    svi  sia   sva  f   v    v            vm n   

begin assignment block

avtkj    sva  vj   vj    ejn    kj    vj  
avf j    sva  vj   vj    ejn     j     j     j    vj   f  

verify  j true clause cj
verify clause cj false

avsj    sva  vj   vj    ejn    vj  

skip disabled clause cj

aaf    sva  vm n    f    sva  sia 
aat    sva  vm n    f    sva  sia  t 

verify assignment satisfying
verify assignment satisfying

aixi    sia  xi   xi            x     sia  xi   xi            x   
arx    sia  xn           x     sia  svi  sti  xn           x   

increment assignment counter
reset assignment counter

ais    sti  t   sti  sii 
aiu    sti  t   sti  sii 

verify instance satisfiable
verify instance unsatisfiable

 
aiij    sii  ejn   enj            e     sii  ejn   ej 
n           en  

increment instance counter

ari  

m n 
 sii  en           e n  

 goal 

instances checked

index ranges    n    j m n    k   

table    actions construction    
previous construction    allows plans two types  either choosing assignment
verifying clauses chaining  enumerating assignments demonstrate
one false clause each  construction    mixes methods  check instance
satisfiable plan must enumerate variable assignments assignment
must walk clauses chaining  enabled clause demonstrates
either true literal none literals true  disabled clauses skipped
over  atoms f keep track whether clauses true assignment 
m n 
case instance satisfiable  extra counter uses variables e n           en
enumerates possible subsets eni en   thus implicitly enumerating  sat instances
m n   
 n            n
  counter constitutes outer loop  eni   possible
assignments x            xn tested described above  plan thought
implementing algorithm figure   
lemma     integers n      instance pn according construction   
following properties 
   computed polynomial time n 
   

fibackstrom   jonsson

 
 sat instances size n
 
clear
 
assignments x            xn
 
clear f
 
clauses cj
 
cj disabled
 
nothing
 
elsif  kj cj satisfied
 
nothing
  
else  neither   j     j   j satisfied 
  
set f
  
f
  
set
  

  
report satisfiable
  
else
  
report unsatisfiable
figure    algorithmic description construction    
   always least one plan 
   exist constants bn every i       m n    action
position bn   plan pn ais  sat instance sin satisfiable
aiu sin unsatisfiable 
proof  addition previous explanation construction note instance
designed deterministic  setting    n  m n           bn       satisfies
claim  since action position bn   ais satisfiable aiu
unsatisfiable 
set prove theorem 
proof theorem     suppose p polynomial solvable strips instances
least one plan corresponding p crar  n      let p n
corresponding instance according construction    let n p crar plan
n p n   assumption  n n must exist every n 
construct advice taking dtm takes input form   hp n   ii 
n integers n          m n    let represented binary
using exactly m n  bits  then    i    strictly increasing n depends n 
let sn     i     which well defined since   i    depend i   define advice
function a sn     n   advice thus p crar plan strips
instance p n according construction      recall need know
advice exists  find it   let bn refer corresponding constants
must exist according lemma     since run whatever algorithm used access
n   follows assumptions find action bn   n polynomial
time sn   let return yes action ais otherwise return no 
   

fialgorithms limits compact plan representations

given arbitrary  sat instance   compute corresponding input
run instance  construction  answers yes satisfiable  input computed polynomial time   s    runs polynomial time using polynomial advice  since solves satisfiability  sat follows
np p poly  impossible unless polynomial hierarchy collapses level  
according theorem  a 
worth noting plans instances according construction   
contains subplan every  sat instance particular size  hence  alternatively
view plan representation set exponentially many plans  shows
representing one long plan representing large set plans fundamentally
different issues 
crars restricted cases prove always exist 
one example is  again  construction    
theorem     every strips instance according construction    plan
polynomial crar 
proof  add n   extra bits b            bn explained proof theorem    construct
polynomial time random access algorithm follows 
suppose b  says satisfiable h bits b            bn one 
plan p form
k

m n 
hacs  aseti            asetih   avt    avtk             avtm n 
  agsi 
 
 z
 
 
 z
 

assign

verify

since h n construct whole assign sequence determine specific action
polynomial time  avtkj actions correspond specific clause cjn   since
clauses ordered compute j index action ask for  cjn
enabled output avf  j otherwise output avf kj smallest k  kj
true specified assignment b            bn  
instead suppose satisfiable  first last actions interleaved aixi avf j actions  aixi actions function counter
variables x            xn   let arbitrary index plan first
last action  odd  ai aixk action k easily computed i 
output aixk   even ai avf j action  value x            xn immediately
ai easily computed i  use value check enabled clauses
order finding clause cjn satisfied output avf j  
clearly construction polynomial crar plan p  
another much larger class instances plans crars considered
next section 
    relationships compact representations
section investigate crar csar concepts relate other  since
macro plan viewed compact representation investigate macro
   

fibackstrom   jonsson

plans relate concepts  start showing polynomial crar
plan polynomial csar plan 
theorem     polynomial q polynomials p  ffp  p   frames
f   hv  d  ai   p crar   q p  csar 
proof  let f arbitrary ffp  p   instance let p crar plan f  
use action counter initiated index first action plan  generate
actions plan sequentially repeatedly asking action indexed counter
incrementing counter  let   denote algorithm together        bit
counter sufficient since must shorter       actions  suppose takes r m  time
increment m bit counter  constant c               c    runs
 p   f       c space   runs p   f       r p   f        c time  define polynomial q
q n     r n  c  obviously              c q       q p   f        p   f     c q p   f     
p   f       r p   f        c q p   f         q p  csar  
opposite hold  however  particular  instances according
construction    plan crar plan csar 
construction acts separation two concepts 
theorem     unless polynomial hierarchy collapses  polynomial q
every polynomial p  every strips instance p every plan p  p csar
 q p  crar 
proof  let x denote class strips instances used proof theorem     since
instances deterministic polynomial p every solvable instance
p csar plan  however  follows proof
polynomial r instances x plan r crar  hence 
polynomial q instances plan  q p  crar 
although previously defined paper  makes sense look
macro plans context  macro sequence two actions  macros
commonly used planning treated single action planner  macros
useful planning certain subsequences actions occur frequently
plans  korf         however  macros may used purpose representing
plan compact structured way  especially true macros allowed
contain macros  since allows hierarchies macros  instance  well
known shortest solution towers of hanoi problem arbitrary number
disks described recursive schema  gill        ex       although plan
exponential number disks   s class planning instances  jonsson  
backstrom      b  property always find polynomial time
instance plan  plan may exponential length thus cannot
generated subexponential time  gimenez jonsson        showed plans  s
instances always polynomial size representation using macros  fact  macro
plan even generated polynomial time although actual non macro plan would
take exponential time generate  result later generalised classes
   

fialgorithms limits compact plan representations

planning instances jonsson         show polynomial size macro plans
immediate connection compact plan representations  however  contrast
gimenez jonsson discuss generate macro plans analyse
properties 
macro plans powerful tools representing plans compactly  hence 
interesting identify criteria compact macro plan representations exist not 
problem scope paper  give partial answer
question following way  straightforward see macro plan viewed
context free grammar  cfg   let actions terminals  let macros
variables  let macro expansions production rules let root macro
start symbol  note use macros represent single plan  rather represent various possibilities planning  macro expansions must acyclic order
produce unique well defined plan  hence  macro plan defined acyclic cfg 
cfgs used represent single string compactly often referred
compressed grammars  furthermore  compressed grammar permits efficient
random access string represents  access necessary preprocessing
polynomial time size grammar  bille et al          precisely  consider
grammar size n represents string length n derivation tree maximum
height h  polynomial time preprocessing  size grammar  possible
random access symbol string index o log n   time or  alternatively 
o h  time  algorithms typically work first computing length substrings
generated rule  preprocessing step  use information find
symbol certain index top down search  since grammar acyclic get h n 
hence  following proposition immediate properties compressed grammars 
proposition     polynomial r every ffp  p   frame hv  d  ai
every macro plan sequence   used random access action
r       time 
thus get following relationship macro plans crars 
theorem     polynomial p polynomials q  ffp  p   frames
f   hv  d  ai action sequences   macro plan     
q   f      p q  crar 
proof  let r polynomial macro plans   random accessed r        
time  let together random access algorithm              c
constant c  define p p n    r n    c  get             c q   f       c
r q   f        c   p q   f       furthermore  runs r       r q   f        c   p q   f     
space time  follows  p q  crar  
follows theorem    every plan polynomial macro plan
polynomial crar  is  class polynomial macro plans subclass class
polynomial crars  know proper subclass  way  results
imply cannot always find polynomial macro plan instance 
corollary     polynomial p every solvable strips instance
least one plan corresponding macro plan size p   p    polynomial hierarchy collapses 
   

fibackstrom   jonsson

proof  immediate theorems       

   problem reformulation
concluded seems little hope plans compactly
represented general case  turn idea problem reformulation see
help  may seem place context is  contrary 
quite logical step take  far  analysed planning problems plans 
results hold for  obvious that  when  results hold
planning instances solved reformulating instances problem 
thus hypothetically possible could get around problems approach 
however  say something useful relevant this  sufficient look
naive approaches  polynomial reductions  investigate stronger criterion 
basic idea reformulation transform planning instance another equivalent instance  either another planning instance instance problem 
reformulation useful  solution new instance must use solve
original instance  something must gained  often  reformulation used intention overall process faster solving original instance directly  common
variants reformulate planning sat  csp  model checking another planning
problem  reformulation planning sat first suggested kautz selman
       still popular approach planning  long  fox  hamdi        discuss
reformulation planning general edelkamp  leue  visser        discuss
connections model checking planning 
reformulation process viewed shown figure    planning instance p
solution find directly using ordinary planning  solving p via reformulation
instead follows indirect path figure  first p reformulated new instance
r p   of problem   instance solved produces solution r p  
finally  transformed back solution p 

p
direct

r p 
indirect




figure    reformulation generation problem 
obviously  reformulation cannot help us plans exponential  even first
two steps indirect path took polynomial time polynomial size  would
still necessarily take exponential time transform exponential 
   

fialgorithms limits compact plan representations

is  problem inherently intractable whichever method use solve it  reformulation
could potentially speed things up  could somehow used directly solution
original problem  would happen rarely  all 
situation different  though  consider decision problem rather
generation problem  is  ask plan whether plan not 
case use solution r p  directly  since decision problems two
possible answers  yes no  may thus escape inherent intractability  variant
reformulation shown figure    since exponential solution generated case 
reformulation could potentially efficient  know decision problem
strips pspace complete general case  reformulated problem easier
solve  could beneficial first reformulate p r p  ask instance
solution not  would possible check solution
embarking generating possibly exponentially long plan  consider  instance 
 s class  jonsson   backstrom      b  plans may exponential size
always possible decide polynomial time plan  thus seems case
reformulating decision problems interesting one look at 
give improvement  hardly improvement plan generation
via reformulation either 

p
direct

r p 
indirect

yes no

yes no

figure    reformulation decision problem 
let pe strips  denote decision problem  that is  plan existence  strips 
following two results trivial  illustrative 
theorem     a  exists decision problem x function r holds
p pe  strips  r p  x p r p  answer  b 
complexity class c  decision problem x c polynomial time computable
function r holds p pe  strips  r p  x p r p 
answer  pspace c 
proof  a  let x   pe strips  r identity function  b  immediate  since r
polynomial reduction pe strips  x 
cases reformulate pspace complete problem pspace complete problem  interesting  prove anything better  must obviously
look x r useful restrictions 
   

fibackstrom   jonsson

important note reformulating planning np complete problem  instance sat  magically make planning np complete  reason
strips planning pspace complete allows exponential solutions  soon
restrict solutions bounded fixed polynomial  planning belongs
np  furthermore  encodings planning instances sat typically use atoms encode
actions appear position plan  is  exponential number extra
atoms required general case  hence  either original problem already
np blow instance exponentially reformulating sat 
latter case  complexity results longer comparable  note  deliberately restrict ask plan certain length shorter 
actually solving restricted version optimization problem  case
planning would harder  fact  seems unlikely planning general
could reformulated problem np  order avoid straightforward naive
approaches reformulation consider analyse reformulations defined follows 
definition     let p   hv  a  i  gi strips instance  let f   hv  ai let   hi  gi 
let x decision problem  reformulation pe strips  x pair hr  ri
functions maps every instance p   hf   pe strips  corresponding instance
x   r r f      x p x answer  hr  ri polynomial
reformulation fixed polynomials p  q
     r f     o p   f     
   r computable o q   r f         d      time 
thus consider reformulation involves two functions  r r  function r
main reformulation function  intended reformulate difficult part instance 
even require function computable  require exists  function
r used transform initial goal descriptions something similar
new instance use  combine result delivered r proper instance
x  noted reformulation concept similar  although identical 
compilation concept used nebel        
theorem     polynomial reformulation pe  strips  x np 
unless polynomial hierarchy collapses 
proof  suppose hr  ri reformulation  arbitrary integer n      let f un   hvn  
defined construction     without action acs  let   heni    goal i 
     m n    follows trivially proof lemma    instance
p   hf un   solution unsatisfiable  note sat part
instance disarmed  
construct advice taking ntm input   hf un   ii  n      
   m n    representing binary using m n  bits  clearly    i    strictly increasing
depends n  let sn     i     for arbitrary i   define advice function
a sn     r f un     note need know advice exists  find it  
let first compute   compute x   r a sn        r r f un      
polynomial time since a sn   given free advice  assumption  x x
answer yes p solution  assumption  x np
   

fialgorithms limits compact plan representations

solve x guessing solution verifying polynomial time  hence  deciding
p solution np poly 
arbitrary  sat instance   compute polynomial time  answers yes

n unsatisfiable  however  unsatisfiability  sat conp complete
follows conp np poly  impossible unless polynomial hierarchy
collapses level    according theorem  b 
result pushed arbitrarily high polynomial hierarchy  thus making
unlikely planning could reformulated anything simpler all 
corollary     polynomial reformulation hr  ri pe  strips  decision
problem x pk   k      unless polynomial hierarchy collapses level k     
proof sketch  construction    demonstrates encode existential quantification
 choosing truth assignment sat part  universal quantification  enumerating
truth assignments unsat part   hence  straightforward modify
analogous construction qbf formulae k alternations  given that  rest
proof analogous proof theorem     must use oracle pk   
argument leads pk pk  poly  impossible unless polynomial hierarchy
collapses level k      according theorem  b 
since proofs build construction    rely exact position
actions follows theorem corollary hold restricted unary
strips instances only 

   discussion
section consists five parts  first transfer reformulation theorem
general result adding information guide planners  discuss explain
various results literature  discuss potential relationship causal
graphs compact representations  followed discussion results
paper could relevant plan explanation  fourth part discusses related
work compact representations compilation  section ends summary
results list open questions 
    reformulation additional information
theorem    broader consequences reformulation  fact  implies
way help planner adding information planning frame  matter
information get it  unless accept amount information
always polynomially bounded frame size  following theorem function g
assumed represent additional information  need even computable 
require result polynomially bounded 
theorem     let p arbitrary polynomial  consider function g algorithm

   g maps strips frames          g f     o p   f      frames f
   

fibackstrom   jonsson

   strips instances p   hf  i  algorithm answers yes input hp  g f  i
p plan 
runs polynomial time  polynomial hierarchy collapses 
proof  assume function g algorithm properties described
theorem  define function r r f     hf   g f  i every strips frame f  
define function r r hf   xi      hhf   i  xi every strips instance p   hf  
every string x  r r f        hhf   i  g f  i   hp  g f  i  hr  ri polynomial
reformulation strips planning equivalent problem algorithm solve
polynomial time  however  reformulation exist according theorem    
unless polynomial hierarchy collapses 
result extended upwards polynomial hierarchy way corollary     no longer requiring polynomial algorithm   means cannot
make planning simpler adding polynomial amount additional information frame
use clever algorithm use information planning  planning remain
hard without extra information  may sometimes help add information particular instance somehow guide planner  systematic way
add information frame level required polynomial size 
planning literature rich methods intended make planning
efficient adding information one way another  although methods perhaps
always thought so  non exhaustive list methods  similar 
abstraction hierarchies  macros  case based planning  annotated planning landmarks 
state space abstraction planning goes back least abstrips planner  sacerdoti         main idea form abstraction hierarchies variables  thus
implicitly actions  planner plan important goals
first get abstract plan refined detailed plan  knoblock
       proposed algorithm automatically computing abstraction hierarchies 
algorithm successful many examples demonstrated sometimes
fail produce exponential plans instances linear optimal plan  backstrom
  jonsson         surprising since use abstraction hierarchy
viewed adding information planning frame  automatic generation abstraction
hierarchies systematic way add information thus treated special case
theorem    
adding set macros planning frame similar using abstraction hierarchies  knoblock        pp          noted  planner uses abstraction searches
plan abstract space tries refine action subplan lower
lever  planner uses macros search abstract space instead already
set macros available correspond subplan  finding macro works
expanded thus similar refining abstract action  use
macros demonstrated speed planning considerably certain cases  korf 
       macros typically added frame level  learning suggested
one method create macros automatically  korf         however  macros typically treated action planner expanded finding
plan  hence  addition macros may backfire make planning less efficient 
   

fialgorithms limits compact plan representations

adding redundant actions may  haslum   jonsson         again 
surprising since addition macros addition information thus covered
theorem    
case based planning  see spalazzi        survey  uses stored plans plan skeletons
planner tries reuse modifying and or extending them  one sense 
similar macro planning  advanced macros macro expansion methods 
one view similar abstraction  plan must refined order
work  difference abstraction planner finds plan skeleton planning
abstract space case based planner set plans stored database 
plans may handcoded  usually result learning previous planning
situations  well known case based planning may fail improve efficiency
cases used must similar actual instance hand  nebel   koehler       
liberatore      b   explained special case theorem    
term annotated planning sometimes used refer number similar techniques adding control information planner  examples prodigy planner
 veloso et al         allows control information rules goal ordering
tlplan  bacchus   kabanza        allows adding temporal logic axioms control
planner  techniques good using hand tailored control rules axioms
particular application domain  immediate theorem    cannot help
us general case 
planning landmarks  hoffmann  porteous    sebastia        idea adding
explicit subgoals  called landmarks  planning instance  intention tell
planner landmarks must achieved plan order achieve overall
goal  landmarks may ordered  guide planner  however 
authors point out  deciding variable value  or logic formula  necessary
subgoal pspace complete problem  hence  one usually considers incomplete
sets landmarks  interestingly  landmarks differ previous methods
important aspect  landmarks added instance level  frame level 
although might quite rigid difference practice  seems fundamental
essence  hence  adding landmarks non uniform case adding information
thus immediately covered theorem     meaningfully analyse non uniform
case remains open question 
    causal graphs
knoblock        defined ordering variables planning instance
used guidance finding abstraction hierarchies  ordering variables
fundamental  s class  jonsson   backstrom      b  ordering implicitly
defined abstraction hierarchy  concept ordering variables
intention defining abstraction hierarchy  define tractable subclasses etc  nowadays
usually referred causal graph  see chen   gimenez        survey using
properties causal graph define tractable subclasses planning   many papers still
use knoblocks definition  follows 
every strips action let vpre a    atoms pre a   vpost a    atoms post a    let
   

fibackstrom   jonsson

f   hv  ai strips frame  causal graph f directed graph gcg   hv 
u  v v   u v u    v
u vpre a  vpost a  v vpost a   
idea behind causal graphs strongly connected component graph
correspond abstraction level  applying definition examples
paper  find instance according construction    causal graph containing
large strongly connected component  is  would possible form good
abstraction hierarchies based causal graphs  however  theorem    says
plans instances seem likely useful compact representations anyway 
plans binary counter construction   polynomial crars since
polynomial macro plans  yet  whole causal graph instance strongly
connected  hand  plans gray counter construction   exponential
polynomial crars too  causal graph acyclic case  thus seems
causal graph type used knoblock many others sufficient 
even necessarily useful  tool judging plans compact representations 
variants causal graphs  though  one example interaction networks  chen  
gimenez         another jonssons        refined version knoblocks causal graph 
defined follows 
let f   hv  ai strips frame  refined causal graph f directed graph
grcg   hv  u  v v   u v u    v either
   u vpre a  vpost a  v vpost a 
   u  v vpost a  either
a  a  u vpost a    v   vpost a   
b  a  u   vpost a    v vpost a     

major difference variant knoblocks two variables
appear postcondition action  necessarily form cycle
graph  hence  unary actions longer prerequisite acyclic graphs  using
refined causal graph  gray counter binary counter acyclic
graphs  construction    still large strongly connected component  is 
three examples acyclicity refined causal graph correlates whether plans
compact representations not  correlation seems hold general 
difference two types causal graphs suggests study variations
concept could lead insight topic compact representations 
turn fruitful  would likely carry areas causal
graphs used  model checking  wehrle   helmert        
    plan explanation
results paper important plan explanation  bidot et al        
suggest important planning systems  and ai systems  able
   

fialgorithms limits compact plan representations

explain plans decisions user  else user may trust system 
similarly  southwick        writes 
seems general agreement amongst involved kbs research
order useful  system must able explain reasoning user 
although consider advanced explanation methods  do  results
implications possible explain meaningfully  plan explanation  results
necessarily bad planning  consider example plan instance
construction     case  sat instance unsatisfiable  almost whole plan
consists alternating sequence form ha  b  a  b  a  b       i  denotes either
actions aix             aix n b denotes either actions avf             avf   first
group actions together implement increment function  thus serve
purpose  similarly  second group consists actions serve purpose
verifying clause false  abstraction action sequence could
form hinc  vfy  inc  vfy  inc  vfy       i  inc denotes counting actions vfy
verification actions  purpose explanation  seems useful replace
actual actions abstract explanations functions  abstract sequence
easier understand  allows using macros compress it  might
enhance explaining power  however  particular case  would probably even
useful abstract whole sequence loop  similar  essentially
boils partitioning set actions equivalence classes
class consist actions meaningfully seen implementing concept 
seems interesting important investigate one partition
set actions equivalence classes useful abstractions 
plan explanation could mean trace explanation model checking  would
analogously make long trace shorter abstract order make easier understand  well known close ties planning model checking 
model checking traces viewed plans vice versa  edelkamp et al         
number steps  or clock cycles  exponential number state variables 
even system divided subsystems  individual subsystems may exponential behaviour blows combined subsystems  exponential size
plan trace much use engineerit almost impossible task analyse
understand plan  planning verifying system could autonomously find
repetitive patterns  even recursive repetitive patterns  plan abstract these 
would considerably easier understand happens why  fact  may
interesting execute plan  even simulator  compact understandable
explanation plan may actual goal 
furthermore  geib        discusses problem combinatorial explosion plan recognition  exponential number plans may share plan prefix recognized far 
could clearly useful structured compact representations plan candidates
save space allow intelligent operations plans  although
problem slightly different representing single long plan  seen
two problems related 
cases  primary purpose compact representation would thus find
exploit inherent structure plan  set plans  rather save space 
   

fibackstrom   jonsson

    additional related work
liberatore      a  studied problem representing plans compactly
similarities well differences results ours  contrast us 
considers plans represented sequences states  sequences actions 
cases  considers random access representation well sequential representation  random access representation action sequences  ta  essentially
crar concept  except specifies must implemented circuit 
sequential representation action sequences  sa   hand  different
csar concept  function takes state input returns next state 
hence  restricted type reactive plan csar  results
thus immediately comparable ours  instance  contrary theorem   
proves ta representation cannot polynomially converted sa representation 
clearly shows sa csar quite different concepts  proof
planning instances plans sa representation thus obviously carry
csars  furthermore  uses planning language actions modelled
polynomial size circuits  coincides class ffp  p    hence  hardness
proofs weaker since use restricted strips language cases 
finally noted liberatores theorem    case ta representations
result similar theorem     use different methods different conditions 
nebel        defines concept compilation planning languages  although
ways similar reformulation concept  differences  compilation
function planning frame another frame different planning language 
compilation need resource bounded resulting frame must polynomially
bounded original frame  initial state goal must possible translate
polynomial time  is  first step corresponds function r second
step essentially corresponds function r  however  nebel considers compilation
planning languages requires concept modularity present
approach  furthermore  focus complexity decision problem
question whether size solutions preserved compilations 
    conclusions open questions
current status knowledge non uniform compact representations
visualized figure    outer box represents set solvable strips instances
inner boxes represent subsets least one plan instance
csar  crar polynomial macro plan  know classes least one plan
instance guaranteed polynomial macro plan  towers hanoi  s 
know classes least one plan instance crar know
plans polynomial macro plan  construction    example 
open question plan crar polynomial macro plan 
know classes instance plan csar know
crar  example  class reversible systems  however  construction   
class instances plan csar plan crar 
case provides strict separation csar crar concepts  whether
classes strips instances plan csar remains open question  though 
   

fialgorithms limits compact plan representations

plans
plans w  csar
plans w  crar

 s
towers
hanoi

plans w  poly 
macro plans
 

 

anything
here 

reversible
systems

 

construction   

construction   

figure    current status csars crars 

thus following chain inclusions
polynomial macro plans crar csar strips 
know first last inclusions strict 
theorem    may seem weak since conditioned p    np  using similar
techniques proofs lemma    corollary    could encode qbf
arbitrary number alternating quantifiers and  hence  push result polynomial
hierarchy  however  remains open question condition could strengthened
way p    pspace 
argued number results hold restricted unary
instances  cases restrictions  otherwise largely unexplored
area  little currently known various structural restrictions affect
results paper  applies whether plans csars crars
whether polynomial size macro plans 
consider non uniform case compact representations single plans
single instances  might interesting consider non uniform case reformulation adding information  however  seems straightforward since could
always reformulate instance single bit telling whether instance solvable not 
reformulation clearly interesting additional criteria necessary 
previously  backstrom   jonsson      a  defined complexity measure based
padding intended insensitive plan length  concept seems related
nebels compilations  although two concepts identical directly comparable 
thus reasonable believe compact representations padded complexity
somehow related  especially since padded complexity motivated instances
long plans  however  yet know relationship is  furthermore  would
   

fibackstrom   jonsson

interesting consider compilations look size compact representations
plan rather size explicit plans 
acknowledgments
malte helmert  anders jonsson anonymous reviewers paper earlier
conference version provided valuable comments suggestions 

references
bacchus  f     kabanza  f          using temporal logics express search control knowledge planning  artificial intelligence                    
backstrom  c     jonsson  p       a   pspace complete planning problems equal
equal others  proceedings  th international symposium combinatorial search  socs    castell de cardona  barcelona  spain  pp 
     
backstrom  c     jonsson  p       b   limits compact representations plans  proceedings   st international conference automated planning scheduling 
 icaps     freiburg  germany  pp       
backstrom  c          computational complexity reasoning plans  phd dissertation  linkoping university  linkoping  sweden 
backstrom  c          expressive equivalence planning formalisms  artificial intelligence 
               
backstrom  c     jonsson  p          planning abstraction hierarchies exponentially less efficient  proceedings   th international joint conference
artificial intelligence  ijcai     montreal  qc  canada  pp           
backstrom  c     klein  i          planning polynomial time  sas pubs class 
computational intelligence            
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence             
balcazar  j          complexity searching implicit graphs  artificial intelligence 
               
bidot  j   biundo  s   heinroth  t   minker  w   nothdurft  f     schattenberg  b         
verbal plan explanations hybrid planning  proceedings   th mkwi
related puk workshop  planung scheduling und konfigurieren entwurfen  puk    
pp           
bille  p   landau  g   raman  r   sadakane  k   satti  s     weimann  o          random
access grammar compressed strings  proceedings   nd acm siam symposium discrete algorithms  soda     san fransisco  ca  usa  pp         
bonet  b          conformant plans beyond  principles complexity  artificial
intelligence                    
   

fialgorithms limits compact plan representations

bonet  b     geffner  h          planning incomplete information heuristic search
belief space  proceedings  th international conference artificial intelligence planning systems  aips     breckenridge  co  usa  pp       
boutilier  c     poole  d          computing optimal policies partially observable
decision processes using compact representations  proceedings   th national
conference artificial intelligence  aaai     portland  or  usa  vol     pp      
     
brafman  r  i     domshlak  c          structure complexity planning unary
operators  journal artificial intelligence research             
buhrman  h   jiang  t   li  m     vitanyi  p  m  b          new applications
incompressibility method  part ii  theoretical computer science                
bulatov  a     dalmau  v          simple algorithm maltsev constraints  siam
journal computing               
bylander  t          computational complexity propositional strips planning 
artificial intelligence                   
cadoli  m   donini  f   liberatore  p     schaerf  m          space efficiency propositional
knowledge representation formalisms  journal artificial intelligence research     
    
charikar  m   lehman  e   liu  d   panigrahy  r   prabhakaran  m   sahai  a     shelat  a 
        smallest grammar problem  ieee transactions information theory 
                 
chen  h     gimenez  o          causal graphs structurally restricted planning  journal computer system sciences                 
edelkamp  s   leue  s     visser  w          summary dagstuhl seminar      
directed model checking  directed model checking  no        dagstuhl seminar
proceedings  dagstuhl  germany 
galperin  h     wigderson  a          succinct representations graphs  information
control                 
geib  c          assessing complexity plan recognition  proceedings   th
national conference artificial intelligence  aaai     san jose  ca  usa  pp 
       
gill  a          applied algebra computer sciences  prentice hall  englewood
cliffs  nj 
gimenez  o     jonsson  a          complexity planning problems simple
causal graphs  journal artificial intelligence research             
haslum  p     jonsson  p          planning reduced operator sets  proceedings
 th international conference artificial intelligence planning systems  aips    
breckenridge  co  usa  pp         
hoffmann  j   porteous  j     sebastia  l          ordered landmarks planning  journal
artificial intelligence research             
   

fibackstrom   jonsson

jansson  j   sadakane  k     sung  w  k          compressed random access memory 
arxiv  abs          v  
johnson  d  s   papadimitriou  c  h     yannakakis  m          generating maximal
independent sets  information processing letters                 
jonsson  a          role macros tractable planning  journal artificial intelligence research             
jonsson  p     backstrom  c       a   state variable planning structural restrictions 
algorithms complexity  artificial intelligence                    
jonsson  p     backstrom  c       b   tractable plan existence imply tractable
plan generation  annals mathematics artificial intelligence                   
jonsson  p   haslum  p     backstrom  c          towards efficient universal planning 
randomized approach  artificial intelligence               
karp  r  m     lipton  r  j          connections nonuniform uniform complexity classes  proceedings   th acm symposium theory
computing  stoc     los angeles  ca  usa  pp         
kautz  h  a     selman  b          planning satisfiability  proceedings   th
european conference artificial intelligence  ecai     vienna  austria  pp     
    
knoblock  c  a          generating abstraction hierarchies  automated approach
reducing search planning  kluwer academic publishers  norwell  ma 
knoblock  c  a          automatically generating abstractions planning  artificial
intelligence                 
korf  r  e          macro operators  weak method learning  artificial intelligence 
             
korf  r  e          planning search  quantitative approach  artificial intelligence 
             
liberatore  p     schaerf  m          size data structures used symbolic model
checking  arxiv  abs           
liberatore  p       a   complexity issues finding succinct solutions pspace complete
problems  arxiv  abs cs         
liberatore  p       b   complexity case based planning  journal experimental
theoretical artificial intelligence                 
long  d   fox  m     hamdi  m          reformulation planning  proceedings
 th international symposium abstraction  reformulation approximation
 sara     kananaskis  ab  canada  vol       lecture notes computer science  pp        springer 
muscettola  n   pandurang nayak  p   pell  b     williams  b  c          remote agent 
boldly go ai system gone before  artificial intelligence            
    
   

fialgorithms limits compact plan representations

nebel  b          compilability expressive power propositional planning
formalisms  journal artificial intelligence research             
nebel  b     koehler  j          plan reuse versus plan generation  theoretical
empirical analysis  artificial intelligence                   
rytter  w          application lempel ziv factorization approximation
grammar based compression  theoretical computer science                    
sacerdoti  e  d          planning hierarchy abstraction spaces  artificial intelligence 
              
southwick  r  w          explaining reasoning  overview explanation knowledgebased systems  knowledge engineering review         
spalazzi  l          survey case based planning  artificial intelligence review     
    
veloso  m  m   carbonell  j  g   perez  a   borrajo  d   fink  e     blythe  j          integrating planning learning  prodigy architecture  journal experimental
theoretical artificial intelligence research               
wagner  k          complexity combinatorial problems succinct input representation  acta informatica                 
wehrle  m     helmert  m          causal graph revisited directed model checking 
proceedings   th international symposium static analysis  sas     los
angeles  ca  usa  vol       lecture notes computer science  pp        
springer 
williams  b     pandurang nayak  p          reactive planner model based executive  proceedings   th international joint conference artificial intelligence  ijcai     nagoya  japan  pp           
yap  c  k          consequences non uniform conditions uniform classes  theoretical computer science             

   


