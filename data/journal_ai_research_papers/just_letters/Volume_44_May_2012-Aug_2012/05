journal artificial intelligence research                  

submitted        published     

algorithms generating ordered solutions explicit
and or structures
priyankar ghosh
amit sharma
p  p  chakrabarti
pallab dasgupta

priyankar cse iitkgp ernet in
amit ontop gmail com
ppchak cse iitkgp ernet in
pallab cse iitkgp ernet in

department computer science engineering
indian institute technology kharagpur
kharagpur         india

abstract
present algorithms generating alternative solutions explicit acyclic and or
structures non decreasing order cost  proposed algorithms use best first search
technique report solutions using implicit representation ordered cost 
paper  present two versions search algorithm  a  initial version best first
search algorithm  asg  may present one solution generating
ordered solutions   b  another version  lasg  avoids construction
duplicate solutions  actual solutions reconstructed quickly implicit
compact representation used  applied methods test domains 
synthetic others based well known problems including search
space   peg tower hanoi problem  matrix chain multiplication problem
problem finding secondary structure rna  experimental results show efficacy
proposed algorithms existing approach  proposed algorithms
potential use various domains ranging knowledge based frameworks service
composition  and or structure widely used representing problems 

   introduction
use and or structures modeling solving complex problems efficiently
attracted significant amount research effort last decades  initially 
and or search spaces mostly used problem reduction search solving complex
problems  logical reasoning theorem proving  etc   overall problem
hierarchically decomposed conjunction disjunction subproblems  pearl       
nilsson         subsequently  and or structures applied variety domains  e g   representing assembly plans  homem de mello   sanderson         generating vlsi floor plans  dasgupta  sur kolay    bhattacharya         puzzle solving  fuxi 
ming    yanxiang         etc  traditionally algorithm ao   pearl        nilsson       
martelli   montanari              chang   slagle        used searching implicitly defined and or structures  empirical study ao  found bonet
geffners        work 
recent past renewed research interest towards application
and or structures  various planning problems  including conditional planning
handle uncertainty  and or structure  russell   norvig        natural form

c
    
ai access foundation  rights reserved 

fighosh  sharma  chakrabarti    dasgupta

representation  problem generating solutions representations
studied extensively  hansen   zilberstein        jimenez   torras        chakrabarti 
       dechter mateescu        presented explicit and or search space
perspective graphical models  different search strategies  best first  branch bound 
etc   and or search spaces graphical models discussed marinescu
dechter      b         and or search spaces used solving mixed integer
linear programming  marinescu   dechter             integer programming  marinescu
  dechter      a   combinatorial optimization graphical models  marinescu   dechter 
    a      b   and or multivalued decision diagrams  aomdd   combine
idea multi valued decision diagrams mdd  and or structures  presented
mateescu  dechter  marinescu        research along direction
found work mateescu dechter         and or search spaces
applied solution sampling counting  gogate   dechter         smooth deterministic decomposable negative normal forms  sd dnnf   darwiche        exhibit explicit
and or dag structure used various applications including compiling
knowledge  darwiche         estimating belief states  elliott   williams         etc 
apart domains planning  constraint satisfaction  knowledge based reasoning 
etc   and or structure based techniques widely used various application based
domains  e g   web service composition  gu  xu    li        shin  jeon    lee        gu 
li    xu        ma  dong    he        yan  xu    gu        lang   su         vision
graphics tasks  chen  xu  liu    zhu         etc  lang su        described
and or graph search algorithm composing web services user requirements 
et al         advocated use and or trees capture dependencies
inputs outputs component web services propose top down search algorithm
generate solutions and or tree  research uses and or structures
context web service composition found works gu et al        
       shin et al         yan et al          chen et al         applied explicit
and or structures cloth modeling recognition important problem
vision graphics tasks 
recent adoption and or search spaces wide variety ai problems
warrants research towards developing suitable algorithms searching and or
structures different perspectives  general setting  fundamental problem
remains find minimum cost solution and or structures  given explicit
and or graph structure  minimum cost solution computed using either topdown bottom up approach  approaches based principle dynamic
programming complexity linear respect size search
space  finding minimum cost solution explicit and or structure fundamental
step approaches use implicit representation systematically explore
search space  particularly case ao   nilsson        potential
solution graph  psg  recomputed every time current explicit graph node
expanded  view recent research and or structures used leveraged
wide variety problems ranging planning domain web service composition 
need generating ordered set solutions given and or structure becomes
imminent  briefly mention areas ordered solutions useful 

   

figenerating ordered solutions explicit and or structures

ordered set solutions explicit and or dag used develop useful
variants ao  algorithm  currently ao   minimum cost solution computed whereas several variants a  algorithm exist  solutions often sought
within factor cost optimal solution  approaches  ebendt   drechsler       
pearl        developed adapt a  algorithm using inadmissible heuristics 
leveraging multiple heuristics  chakrabarti  ghose  pandey    desarkar         generating
solutions quickly within bounded sub optimality  etc  typically techniques order
open list using one evaluation function  next element expansion selected
ordered subset open using criterion  similar techniques developed
ao  search ordered set potential solutions made available  set
used node selection expansion instead expanding nodes current
best psg  opens interesting area significant research potential
existing variations a  algorithm extended and or search spaces 
context model based programming  problem finding ordered set
solutions significant importance  elliott        used valued sd dnnfs represent
problem proposed approach generate k best solutions  since valued sd dnnfs
and or structure  proposed approach possibly earliest algorithm
generating ordered set solutions and or structure  problem finding
ordered set solutions graphical models studied flerova dechter              
however techniques use alternative representations algorithm  and or
search spaces constructed  dechter   mateescu        graphical models  recent
research involving aomdd based representation weighted structures suggested future
extensions towards generalizing algebraic decision diagrams introduces notion
cost aomdds  envisage ordered set solutions finds useful applications
context research around and or decision diagram based representation 
domain service composition  primary motivation behind providing set
alternative solutions ordered cost offer choices  trading specified
cost criterion  to limited extent  favor unspecified criteria  primarily
standpoint quality   shiaa  fladmark  thiell        presented approach
generating ranked set solutions service composition problem  typically
quality criteria subjective nature difficult express terms single scalar cost
function able combine cost price quality aspects together 
aspects quality often encountered context serving custom user requirements
user prefers minimize cost price solution preserving his her
preferences  example  booking holiday package specific destination  travel
service portal typically offers list packages various combinations attractions 
hotel options meal plans ordered single cost criterion  namely  cost
package  general product solution composed number components
compositional flavor similar service composition becomes important present
user set alternative solutions ordered cost he she select best
alternative according his her preferences 
dynamic programming formulations typically underlying and or dag structure  formally studied past  martelli   montanari         besides
classical problems matrix chain multiplication  many real world optimization problems offer dynamic programming formulations  alternative solutions ordered cost
   

fighosh  sharma  chakrabarti    dasgupta

useful practice  one example problem finding secondary structure
rna  mathews   zuker        important problem bioinformatics  rnas
may viewed sequences bases belonging set  adenine a   cytocine c   guanine g   uracil u    rna molecules tend loop back form base pairs
resulting shape called secondary structure  primary factor influences
secondary structure rna number base pairings  higher number base pairings generally implies stable secondary structure   well established rules
base pairings  problem maximizing number base pairings interesting dynamic programming formulation  however  apart number base pairings 
factors influence stability  factors typically evaluated
experimentally  therefore  given rna sequence  useful compute pool
candidate secondary structures  in decreasing order number base pairings 
may subjected experimental evaluation order determine stable
secondary structure 
problem generating ordered set solutions well studied domains 
discrete optimization problems  lawler        proposed general procedure
generating k best solutions  similar problem finding k probable configurations
probabilistic expert systems addressed nilsson         fromer globerson       
addressed problem finding k maximum probability assignments probabilistic modeling using lp relaxation  context ordinary graphs  eppstein       
studied problem finding k smallest spanning trees  subsequently  algorithm
finding k best shortest paths proposed eppsteins        work  hamacher
queyranne        suggested algorithm k best solutions combinatorial optimization problems  algorithms generating k best perfect matching presented
chegireddy hamacher         researchers applied k shortest path problem
practical scenarios  as  routing transportation  developed specific solutions
 takkala  borndorfer    lobel        subramanian        topkis        sugimoto   katoh 
       however none approaches seems directly applicable and or structures  recently schemes related ordered solutions graphical models  flerova  
dechter              anytime and or graph search  otten   dechter       
proposed  anytime algorithms traditional search space  hansen   zhou       
well addressed research community 
paper  address problem generating ordered set solutions explicit
and or dag structure present new algorithms  existing method  proposed
elliott         works bottom up computing k best solutions current node
k best solutions children nodes  present best first search algorithm 
named alternative solution generation  asg  generating ordered set solutions 
proposed algorithm maintains list candidate solutions  initially containing
optimal solution  iteratively generates next solution non decreasing order cost
selecting minimum cost solution list  iteration  minimum cost
solution used construct another set candidate solutions  added
current list  present two versions algorithm
a  basic asg  will referred asg henceforth    version algorithm
may construct particular candidate solution once 

   

figenerating ordered solutions explicit and or structures

b  lazy asg lasg   another version asg algorithm constructs every candidate solution once 
algorithms  use compact representation  named signature  storing
solutions  signature solution  actual explicit form solution
constructed top down traversal given dag  representation allows
proposed algorithms work top down fashion starting initial optimal
solution  another salient feature proposed algorithms algorithms work
incrementally unlike existing approach  proposed algorithms interrupted
point time execution set ordered solutions obtained far
observed subsequent solutions generated algorithms resumed
again  moreover  upper limit estimate number solutions required known
priori  algorithms optimized using estimate 
rest paper organised follows  necessary formalisms definitions
presented section    section    address problem generating ordered set
solutions trees  subsequently section    address problem finding alternative
solutions explicit acyclic and or dags non decreasing order cost  present two
different solution semantics and or dags discuss existing approach well
proposed approach  along comparative analysis  detailed experimental results 
including comparison performance proposed algorithms existing
algorithm  elliott         presented section    used randomly constructed
trees dags well well known problem domains including   peg tower
hanoi problem  matrix chain multiplication problem problem finding
secondary structure rna test domain  time required memory used
generating specific number ordered solutions different domains reported
detail  section    outline briefly applying proposed algorithms implicitly
specified and or structures  finally present concluding remarks section   

   definitions
section  describe terminology and or trees dags followed
definitions used paper  g   hv  ei and or directed acyclic graph 
v set nodes e set edges  g refer
nodes nodes dag respectively  direction edges g
parent node child node  nodes g successors called terminal
nodes  non terminal nodes g two types i  nodes ii  nodes  
v v set nodes g respectively  n    v    n    v   
n    v    start  or root  node g denoted vr   edges edges
edges emanate nodes nodes respectively 
definition   a  solution graph  solution graph  s vq    rooted node vq v  
finite sub graph g defined as 
a  vq s vq   
b  vq node g vq s vq    exactly one immediate
successors g s vq   
c  vq node g vq s vq    immediate successors
g s vq   
   

fighosh  sharma  chakrabarti    dasgupta

d  every maximal  directed  path s vq   ends terminal node 
e  node vq successors g s vq   
solution graph g mean solution graph root vr  




definition   b  cost solution graph  g   every edge eqr e node vq
node vr finite non negative cost ce  hvq   vr i  ce  eqr    similarly every node vq
finite non negative cost denoted cv  vq    cost solution defined recursively
follows  every node vq s  cost c s  vq   is 


cv  vq    vq terminal node 






cv  vq     c s  vr     ce  hvq   vr i    vq node 

c s  vq    
vr successor vq s 


p


c s  vj     ce  hvq   vj i      j k  vq node
cv  vq    




degree k  v            vk immediate successors vq s 
therefore cost solution c s  vr   denoted c s   denote
optimal solution every node vq opt vq    therefore  optimal solution
entire and or dag g   denoted sopt   opt vr    cost optimal solution
rooted every node vq g copt  vq    defined recursively  for minimum cost
objective functions  follows 


cv  vq    vq terminal node 







cv  vq     min copt  vj     ce  hvq   vj i      j k  vq node
copt  vq    
degree k  v            vk immediate successors vq g  




cv  vq     p copt  vj     ce  hvq   vj i      j k  vq node




degree k  v            vk immediate successors vq g  
cost optimal solution sopt g denoted copt  vr   or  alternatively 
copt  sopt    objective function needs maximized  instead min function 
max function used definition copt  vq   



may noted possible one solution node
vq qualify optimal one  i e   cost  cost
minimum  ties optimal solution node vq resolved arbitrarily
one among qualifying solutions  determined tie breaking  marked
opt vq   
and or tree    hv  ei  and or dag additionally satisfies
restrictions tree structure i e   one parent node node vq
  context and or trees  use eq denote edge points
vertex vq   alternating and or tree    hv  ei  and or tree
restriction alternation nodes nodes  every
child node either node terminal node  every children
node either node terminal node  use term solution tree denote
solutions and or trees 
discuss different solution semantics  namely tree based semantics  and or
dags  every and or dag converted equivalent and or tree traversing
   

figenerating ordered solutions explicit and or structures

intermediate nodes reverse topological order replicating subtree rooted
every node whenever in degree traversed node    details
shown procedure convertdag  suppose and or dag g converted
equivalent and or tree   define solutions solutions g
tree based semantics 
procedure convertdag g  
input   and or dag g
output  equivalent and or tree
  construct list   non terminal nodes g   sorted reverse topological
order 
  empty
 
vq remove first element  
   suppose ein  vq   list incoming edges vq
  
 
indegree vq      
 
  indegree vq  
 
et ein  vq   i  
replicate
sub tree rooted vq vq root 
 
modify target node et vq vq  
 
 
end
  
end
   end
paper use solution semantics defined definition   a default
semantics solutions and or dags  tree based semantics used 
explicitly mentioned 
    example

     

h i
     

v 

v 

v 

h i

h i

h i

v 

     

v 

v 

    

h i

v 

h i

h i

v 

     

v 
h i

h i

h i

h i

v 

v  

v  

v  

v  

v  

v  

v 

v  

 

 

 

 

  

  

  

 

 

figure    alternating and or tree
   

v 

     

v 

    

h i

h i

h i

h i

h i

v 
h i

     

h i

v 

  

  
h i

v 

     

v 

v 

     

h i

h i

h i

  
h i

     

  

h i

figure    and or dag

  

fighosh  sharma  chakrabarti    dasgupta

present example alternating and or tree figure    figure 
terminal nodes represented circle thick outline  nodes shown
figures outgoing edges connected semi circular curve examples 
edge costs shown side edge within angled bracket  cost
terminal nodes shown inside box  every non terminal node vq   pair costs 
cv  vq   copt  vq    shown inside rectangle 
figure   optimal solution every node shown using thick dashed edges
arrow head  optimal solution and or tree traced following
thick dashed edges node v    cost optimal solution tree     also 
figure   shows example dag  cost optimal solution dag    

   generating ordered solutions and or trees
section address problem generating ordered solutions trees  use
notion alternating and or trees  defined section    present algorithms 
alternating and or tree presents succinct representation correctness
proofs much simpler alternating and or trees  appendix c show every
and or tree converted equivalent alternating and or tree respect
solution space 
worth noting search space problems  e g  search space multipeg tower hanoi problem  exhibit alternating and or tree structure  moreover 
algorithms presented alternating and or trees work without modification
general and or trees  section  first present existing algorithm  elliott 
      briefly  present proposed algorithms detail 
    existing bottom up evaluation based method computing alternative
solutions
illustrate working existing method proposed elliott       
computing alternative solutions trees using example alternating and or tree 
method  will referred bu henceforth  computes k best solutions bottomup fashion  every node  vq   k best solutions computed k best solutions
children vq   overall idea follows 
a  node vq   solution rooted vq obtained selecting solution
child  therefore k best solutions vq computed selecting top k solutions
entire pool consisting solutions children 
b  case nodes  every child node vq k solutions 
solution rooted node vq obtained combining one solution every
child vq   different combinations solutions children nodes vq generate
different solutions rooted vq   among combinations  top k combinations
stored vq  
figure   show working existing algorithm  every intermediate node
  best solutions shown within rounded rectangle  every node vq   ith  best
cost 
solution rooted vq shown triplet form   z 
    child  solidx      z 
 z
 
 
example  node v  second best solution shown     hv     i      means
   

figenerating ordered solutions explicit and or structures

 nd best solution rooted v  obtained selecting  nd best solution v   
similarly  every node vq   ith solution rooted vq shown triplet
form    sol vec   cost triplets  sol vec comma separated list solution indices
every element sol vec corresponds child vq   j th element sol vec
shows index solution j th child  example   nd best solution rooted v 
shown                 means  nd best solution rooted v  computed using
 nd best solution  st child  which v    best solution   st    nd
child  which v     index sol vec corresponds child shown placing
child node name every index position 

     

h i

     

v 

h i

    

v 

    hv     i    
    hv     i    

v 

h i

h i

v  v 
              
              

v 

     

  

h i

    hv     i   
    hv      i    

v  v 
              
              

v 

h i

h i

v 

     

v 

    hv      i    
    hv      i    

  

h i

h i

v 

     

h i

h i

    hv      i    
    hv      i    
h i

h i

h i

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    example working existing algorithm
existing method works input parameter k  i e   number solutions
generated known priori  method inherently incremental
nature  thus perform efficiently solutions needed demand  e g  
first  top    solutions needed  next    solutions needed  case
top    solutions recomputed computing next    solutions  i e  
  st solution   th solution  next present proposed top down approach
suffer limitation 
    top down evaluation algorithms generating ordered solutions
far discussed existing approaches primarily use bottom up approach
computing ordered solutions  propose top down approach generating alternative solutions non decreasing order cost  may noted top down
   

fighosh  sharma  chakrabarti    dasgupta

approach incremental nature  use edge marking based algorithm  alternative
solution generation  asg   generate next best solutions previously generated solutions  initial phase asg algorithm  compute optimal solution
given alternating and or tree perform initial marking edges 
following terminology notions used describe asg algorithm 
context and or trees  use eq denote edge points vertex vq  
use following definitions describing proposed top down approaches 
definition   c  aggregated cost  and or dag g   aggregated cost  ca  
edge eij node vi node vj   defined   ca  eij     ce  eij     copt  vj   


v 

     

 e      

       

h i

     

       

v 

h i

h i

 e      

v 

     

v 

  
h i

    

h i

v 

h i

v 

     

h i

v 

v 

     

  
 e       

 e      
h i

        

h i

h i

 e       
h i

         

h i

 e        h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    example or edge marking swap option
marking edge   notion marking edge follows 
node vq   l vq   list edges vq sorted non decreasing order aggregated
cost edges  define  i i    difference cost edges  ei
ei     ei ei   emanate node vq   ei   edge next
ei l vq    procedure markor describes marking process edges
node  intuitively  mark represents cost increment incurred corresponding
edge replaced solution next best sibling  edge maximum
aggregated cost marked 
consider solution  scur   containing edge ei    vq   vi    ei eopt  scur   
mark ei cost increment incurred construct next best solution
scur choosing another child vq   figure   marks corresponding edges
e    e    e    e     e     e    e         e         e         e          e          e        
   

figenerating ordered solutions explicit and or structures

procedure markor vq  
 

 
 
 
 
 
 
 

construct l vq        list edges vq sorted non decreasing order ca
values   
count number elements l vq    
    count  
ec l vq   i   
en l vq   i       
tmp    ca  en   ca  ec     
mark ec pair  en   tmp    
end

definition   d  swap option  swap option ij defined three tuple hei   ej   ij
ei ej emanate node vq   ej edge next ei l vq   
ij   ca  ej   ca  ei    also  say swap option ij belongs node vq  


consider node vq sorted list l vq    may observed l vq  
every consecutive pair edges forms swap option  therefore  k edges l vq   
k  swap options formed  node vq   swap options ranked according
rank original edges l vq    figure   swap options           he    e     i 
        he    e     i           he    e      i            he     e      i            he     e      i 
          he     e      i  consider node v  l v      he    e    e  i  therefore  swap
options                belong v    node v    rank                
respectively 
definition   e  swap operation  swap operation defined application swap
option ij   hei   ej   ij solution sm contains edge ei following way 
  edge e
a  remove subtree rooted vi sm   let modified tree sm

original edge ij  
  constructed previous step  let
b  add subtree opt vj   sm
  edge e swapped edge  
newly constructed solution sm
j
ij

intuitively  swap operation ij   hei   ej   ij constructs new solution sm


sm contains edge ei   moreover  cost sm increased ij compared cost
sm c sm   vi     copt  vi   



proposed algorithms use swap option based compact representation  named signature  storing solutions  intuitively  alternative solution described
set swap operations performed optimal solution sopt   interesting observe
applying ordered sequence swap options  h      k i  application
swap operation creates intermediate alternative solution  example 
first swap option sequence      applied optimal solution  sopt   new solution  say s    constructed  then   nd swap option      applied s    yet
another solution s  constructed  let si denote solution obtained applying
swap options          sopt sequence  although  ordered sequence swap
options  h      k i  used compact representation alternative
solution  following key points important observe 
a  among possible sequences generate particular solution  need preclude
sequences contain redundant swap options  those swap options whose orig   

fighosh  sharma  chakrabarti    dasgupta

inal edge present solution applied   formally defined
later superfluous swap options  order applying swap options another important aspect  two swap options  j     j k
source edge j belongs sub tree included solution
si applying si    case  apply j place   i e  
apply j directly si    effect source edge j present
si    i e   swapping location j sequence  j becomes
redundant swap option solution constructed would different swapped
sequence original sequence  formally define order relation pair
swap options based observation later part section formalize
compact representation solutions based order relation 
b  suppose swap option j belongs node vpj   important observe
application j sj  construct sj   invalidates application
swap options belong edge path root node vpj
solution sj   sj application swap option
belongs edge path root node vpj would make swap
vpj redundant  fact  swap option belonging node vpi     j 
application swap options belong edge path
root node vpi invalidated solution sj reason  condition
restricts set swap options applied particular solution 
c  finally  two swap options j     j k
j independent other  is   a  applying si  subsequently
application j sj     b  applying j si  subsequently application
sj    ultimately construct solution  happens
original edges j present si    thus application one swap option
influence application other  however  desirable use one
way generate solution sj   section      propose variation top down
approach  called lasg  resolves issue 
definition   f  order relation r  define order relation  namely r  pair
swap options follows 
a  path vi vr   ei er edges  qi rj
swap options   qi   rj   r  example  figure                      r 
b  pq   hep   eq   pq rt     et   rt two swap options vq   vr  
 pq   rt   r  figure                    r 


implicit representation solutions   use implicit representation
storing every solution optimal one  solutions constructed
optimal solution applying set swap options optimal solution
following way   i   j   r  applied j   therefore  every solution
represented sequence swap options  appears j  i   j   r 
intuitively application every swap option specifies swapped edge
part solution  since swap options applied specific order r  may
happen edge become part solution due application
earlier swap option may get swapped due application later swap option 
   

figenerating ordered solutions explicit and or structures

definition   g  superfluous swap option  consider sequence swap options  
h      corresponding solution sm   clearly possible swap option   
  m  present sequence original edge
present solution si  constructed successive applications swap
options       i  solution sopt   application effect si    i e  
solution si identical solution si    swap option superfluous swap
option respect sequence swap options corresponding solution sm  


property     sequence swap options corresponding solution minimal 
superfluous swap option 
property follows definition superfluous swap options notion
implicit representation solution 
definition   h  signature solution  minimal sequence swap options corresponding solution  sm   defined signature  sig sm    solution 
may noted optimal solution sopt alternating and or tree  
sig sopt         i e   empty sequence  possible construct one signature
solution  r partial order  important observe different signatures
particular solution equal length sets swap options corresponding
different signatures equal  therefore set swap options corresponding
signature canonical representation signature  henceforth use set
notation describing signature solution 
v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

    

h i

v 

h i

h i

v 

     

v 

v 

     

  
h i

h i
h i
        

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    solution  s    and or tree shown figure  
figure   show solution  say s    and or tree shown figure   
solution highlighted using thick dashed lines arrow head  pair  cv  vq    c s    vq   
   

fighosh  sharma  chakrabarti    dasgupta

shown within rectangles beside node vq solution s    used rectangles rounded corner whenever c s    vq      copt  vq    since s  generated applying
swap option       solution sopt   signature s    sig s      h      i  consider
another sequence      h               i  swap options  worth noting  
represents solution s    second swap option     namely       
applied solution constructed applying       sopt source edge         
e    present solution  hence        superfluous swap option    
definition   i  vopt eopt   solution graph sm and or dag g  
define set nodes 
fivopt  sm    set edges  eopt  sm    as 
a  vopt  sm     vq vq sm solution graph sm  vq   identical solution graph
opt vq  



b  eopt  sm     epr edge epr sm   vr vopt  sm  
clearly  node vq vopt  sm    vq present sopt    a  solution graph
sm  vq   identical solution graph sopt  vq     b  c sm   vq     copt  vq  


definition   j  swap list  swap list corresponding solution sm   l sm    list
swap options applicable sm   let sig sm              i    m 
swap option belongs node vpi   application swap options
belong edges path root node vpi invalidated solution
sm   hence  remaining swap options invalidated sm applied
sm constructing successor solutions sm  
important observe swap option   source edge belongs
eopt  sm    application invalidated sm   hence  solution sm   construct l sm   restricting swap operations edges belonging eopt  sm   
moreover  condition ensures cost newly constructed solution
computed directly form cost parent solution value applied swap
constructed form
option  elaborate  suppose solution sm
applying jk  

    c s    
cost sm computed directly form c sm   jk   c sm

jk
ej eopt  sm    procedure computeswaplist sm   describes details computing swap
options given solution sm  


procedure computeswaplist sm 
 
 
 

 
 
 

l sm     compute eopt  sm   
foreach edge ec eopt  sm  
exists swap option edge ec
   suppose ec emanates node vq ec   l vq   i   ec
marked pair htmp   en i  en   l vq   i     
  
cn hec   en   tmp i  add cn l sm   
end
end

swap list optimal solution  l sopt    figure                      
solution s    shown figure    vopt    v    v      except node v  v    
nodes vi s    opt vi      s   vi    rectangles rounded corner used
c s    vq      copt  vq    therefore  eopt    e    e      since exists swap option
   

figenerating ordered solutions explicit and or structures

v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

     

h i

v 

h i

v 

     

h i

v 

v 

     

  
h i
h i
        

h i

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    solution  s    and or tree shown figure  
edges  e  e     swap list solution s    l s        hence  solution
sm   l sm   may empty  though vopt  sm   never empty 
although use notation ij denote swap option edge ei original
edge edge ej swapped edge  succinct representation  use single
subscript      k   ij etc   represent swap option  alternative representation
swap options relate edge 
definition   k  successors predecessors solution  set successors
predecessors solution
sm defined as 
constructed
a  succ sm      sm
applying swap option

belongs swap
list sm  
succ s   


b  p red sm      sm



property     solution sm alternating and or tree following state p red s    c s   c s  
ment holds  sm




property follows definitions  one special case requires attention  consider
    c s   p red s    case arise swap
case c sm



option cost   applied sm   occurs case tie 
      asg algorithm
present asg  best first search algorithm  generating solutions alternating
and or tree non decreasing order costs  overall idea algorithm
follows  maintain list  open  initially contains optimal solution sopt  
point time open contains set candidate solutions next best
   

fighosh  sharma  chakrabarti    dasgupta

solution non decreasing order cost selected  iteration minimum cost
solution  smin   open removed open added another list  named  closed 
closed list contains set ordered solutions generated far  successor
set smin constructed successor solution currently present
open well already added closed inserted open  however
optimization  use sublist closed  named tlist  store relevant portion closed
checking respect solutions tlist sufficient figure whether
successor solution already added closed  interesting observe
algorithm interrupted time set ordered solutions computed far
obtained  also  algorithm resumed solutions needed 
details asg algorithm presented algorithm   
algorithm    alternative solution generation  asg  algorithm

 

 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  

input   alternating and or tree
output  alternative solutions non decreasing order cost
compute optimal solution sopt   perform edge marking populate
swap options 
create three lists  open  closed  tlist  initially empty 
put sopt open 
lastsolcost c sopt   
open empty
smin remove minimum cost solution open  
lastsolcost   c smin  
remove elements tlist 
lastsolcost c smin   
end
add smin closed tlist 
compute swap list  l smin    smin  
   construct succ smin   using l smin   add new solutions open
  
foreach ij l smin  
construct sm applying ij smin  
construct signature sm   sig sm    concatenating ij sig smin   
   check whether sm already present open tlist
  
 sm open   sm tlist 
add sm open 
end
end
report solutions closed 

pseudo code line   line   computes optimal solution sopt   performs
marking edges  populates swap options  initializes open  closed tlist 
loop line    responsible generating new solution every time executed
long open empty  line   asg algorithm  solution
current minimum cost solution open  smin   selected removed open 
tlist populated maintained line   line     loop line    generates

   

figenerating ordered solutions explicit and or structures

successor solutions smin one one adds newly constructed solutions
open newly constructed solution already present open well added
tlist  line    checking   proof correctness algorithm   presented
appendix a  discuss following issues related algorithm   
checking duplication   order check whether particular solution si already
present open tlist  signature si matched signatures solutions
already present open tlist  sufficient check equality
set swap options respective signatures set unique particular
solution  may noted tlist used optimization  avoids searching
entire closed list 
resolving ties   removing minimum cost solution open list  tie
may encountered among set solutions  suppose tie among set stie  
 s      sk    ties resolved favor predecessor solutions  is 


si   sj stie    if si predecessor sj    si removed sj  
cases ties resolved arbitrarily favor solution
added open first 
      working asg algorithm
illustrate working asg algorithm example and or tree shown
figure    contents different lists obtained first iterations outermost
loop shown table    use signature solution representation
purpose  solutions already present open constructed expanding
current smin   highlighted under braces 
it 
 
 
 
 

smin
  
         
        
                

l smin  
              

     
                 

 

                
         

                 

 

                

       

         

 

                
                   

       

open
                   
        
                
                           
                          
                           
                                    
                                    
                                     
 
 z
 
                                    

closed
  
             
                       
                        
                
                        
                
                          
                        

tlist
  
         
        
                
                
         
               

                
         
                          
                          
                                                              
                
                          
                
                   
                   
                          
                          
                          
         

table    working asg algorithm
   

fighosh  sharma  chakrabarti    dasgupta

entering outermost loop  line     asg computes optimal solution
sopt   populates swap options  inserts sopt open  thus  point time  open
contains optimal solution sopt   closed tlist empty  first iteration
sopt  the signature sopt     selected removed open  swap list
sopt   l sopt    computed  l sopt    consists two swap options  namely               
asg adds two new solutions                    open  solution sopt added
closed tlist 
next iteration  solution           minimum cost among solutions
currently open  selected removed open  swap list           computed
subsequently           added open tlist  happens  l               owing
fact eopt    e    e     exists swap option edges  e  e     
thus nothing else happens iteration  next iteration  solution          removed
open ultimately solution                  added open adding         
closed well tlist  next two iterations proceed similar fashion  now  consider
 th iteration  iteration  solution                            removed open 
successor set one solution                                        already present
open  inserted open iteration     therefore  solution                                     
inserted open again  shown iteration   table   
    technique avoiding checking duplicates open
section  present technique avoid checking done adding newly
constructed solution sm open determine whether sm already present open 
first explain scenario example  portion previous example
shown figure    figure       solutions shown using thick dashed line
arrow head  rectangles rounded corner used highlight fact
corresponding node marked solution belong vopt set solution 
v 

     
h i

     
h i

     
h i

         

h i

h i

v 
h i

v 

     

v 

     

h i

         

h i

v 

     
h i

h i

v 
h i

h i

v  

v  

v  

v  

v  

v  

v  

v  

 

 

  

  

 

 

  

  

figure    solution s 

figure    running example

consider solutions s    s  s   shown figure    figure    figure    
 a  l sopt                            b  succ sopt      s    s    
 c  sig s                   d  sig s                   e  sig s                           
algorithm   constructs solution s   shown figure    adding open twice
 i  part adding succ s    open   ii  adding succ s    open 
   

figenerating ordered solutions explicit and or structures

v 

     

h i

     
h i

     
h i

         

h i

h i

v 

v 

     

v 

h i

     

h i

h i

v 

     
h i

h i

h i

v 
h i

         

v  

v  

v  

v  

v  

v  

v  

v  

 

 

  

  

 

 

  

  

figure    solution s 

figure     solution s 

use following definitions describe another version asg algorithm 
constructs solutions way check find whether solution already
added open avoided 
definition   l  solution space dag ssdag   solution space dag alternating
and or tree directed acyclic graph  dag   g   hv  ei  v set
possible solutions and or tree   e set edges defined as 



sp   sm v 



e   espm fifi espm directed edge node sp sm  


sm succ sp  

clearly sopt root node g  




definition   m  solution space tree completeness  solution space tree
alternating and or tree tree   hv   e v v  v set
possible solutions and or tree   e set edges defined
as 



sp   sm v  









e


directed
edge

node



 

p

pm

e   epm

sp p red sm   




p red sm     sp      edge sm  
p
p
p
sibling set solution sm   denoted using sib t   sm    solution space tree
and or tree complete v   v 


may noted complete solution space tree alternating and or tree
necessarily unique  possible alternating and or tree
one complete solution space tree  however solution space dag and or tree
unique 
definition   n  native swap options solution  consider solution sm alternating and or tree   suppose sm constructed applying swap option ij
solution sp   since swap option ij   hei   ej   ij used construct sm   node vj
present sm   native swap options solution sm respect swap option ij  
n  sm   ij    subset l sm    comprises following swap options  
   

fighosh  sharma  chakrabarti    dasgupta

v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

     

h i

v 

h i

h i

v 

     

v 

v 

     

  
h i
h i
        

h i

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure     solution  s    and or tree shown figure  
a  jk   jk swap option edge ej
b    belongs node vq vq node sm  vj  
use term n  sm   denote native swap options ij understood
context  intuitively native swap options solution sm swap options
become available immediately applying ij   available predecessor
solution sm  



consider solution s  shown figure    sig s                                 
solution highlighted using thick dashed lines arrow head  used rectangles rounded corner beside node vq solution s    c s    vq      copt  vq   
suppose s  constructed form solution s   where sig s                        using swap
option           n  s                           whereas l s                           
consider solution s  sig s                                            worth observing applying native swap options s  instead swap options l s   
prevents construction solution s  solution s    s  constructed
applying         solution s    sig s                                  however  may
noted         native swap option solution s   
      lazy asg algorithm
intuition behind version asg algorithm follows  newly
constructed solution sm   need check whether sm already present open
sm constructed part computing successor set multiple solutions 
instead using entire swap list solution construct successors
add solutions open  using native swap options constructing subset
successor set ensures following  subset constructed using native swap options
   

figenerating ordered solutions explicit and or structures

consists solutions currently present open thus
added open without comparing existing entries open  construction

remaining successor solution sm
insertion open delayed
added closed 
every predecessor solution sm
algorithm    lazy asg  lasg  algorithm

 

 
 
 
 
 
 
 
 
  
  

  

  

  
  
  

  
  

  
  
  
  
  
  
  
  
  
  

input   alternating and or tree
output  alternative solutions non decreasing order cost
compute optimal solution sopt   perform edge marking populate
swap options 
create two lists  open closed  initially empty 
put sopt closed list 
create solution space tree sopt root 
compute swap list  l sopt    sopt  
construct succ sopt   using l sopt   
forall sm succ sopt  
add sm open 
end
open empty
smin remove minimum cost solution open  
   suppose smin constructed sm applying swap option ij
  
add node corresponding smin connect node using edge
sm  
compute swap list l smin   list native swap options n  smin   ij   
   expansion using native swap options
  
foreach tmp n  smin   ij  
construct stmp smin applying tmp  
construct signature stmp   sig stmp    concatenating tmp
sig smin   
add stmp open 
end
   lazy expansion
  

forall sp sib t   smin  
ij l sp  
construct sp sp using ij  
construct signature sp   sig sp    concatenating ij sig sp   
add sp open 
end
end
add smin closed 
end
report solutions closed 

solution space tree maintained throughout course algorithm
added closed  based idea
determine every predecessor sm
   

fighosh  sharma  chakrabarti    dasgupta

present lazy version asg algorithm  named lasg  selecting minimum cost
solution open  algorithm explores successor set current minimum cost
solution lazy fashion  solution sm   first subset succ sm   constructed
using native swap options sm   solutions belong succ sm  
explored late possible described above  resolving ties  lasg algorithm
uses strategy used asg algorithm  details lasg algorithm
presented algorithm    proof correctness algorithm presented
appendix b 
consider example tree shown figure   solutions s  s   shown figure  
figure      initially open contain sopt n  sopt                          
sopt selected open  s  s  added open  next s  selected
followed s    since  n  s      n  s        selecting s  s  successor
solutions constructed using native swap list  among predecessors s    s 
added last closed  selecting removing s  open  solution s  constructed
previously selected predecessor s  using swap option         used
construct solution s  sopt  
      working lasg algorithm  on and or tree figure   
entering outermost loop  algorithm    line      lasg computes
optimal solution sopt constructs succ sopt   
solutions succ sopt  
added open contents open becomes                       contents
different lists solution added closed shown table    solutions
represented using signatures  solutions added open result
lazy expansion  highlighted using under brace 
iteration
 
 
 

smin
  
         
        
                

n  smin  
              

     
                 

 

                          

       

 

                          



 

                          
         



open
                   
        
                
                           
                          
                           
                                    

closed
  
             
                       
                        
                
                        
                
                          
                                                              
                                    
                
 
 z
 
                          
                          
                                                              
                
                          
                          
                          
         

table    working lasg algorithm
generating first four solutions  contents different lists lasg
identical contents corresponding lists asg  shown table    
   

figenerating ordered solutions explicit and or structures

soltuions  native swap list equal actual swap list solution  worth noting that  unlike asg  lasg outermost loop starts
generating optimal solution sopt   thus generating solution
iteration number lasg less asg     th iteration  solution s                               native swap list equal swap list
described previously  holds true solution s                              
solution s                                          important observe lasg adds
solution s                                         open generation solution
s                               part lazy expansion  highlighted using under brace
table     whereas  asg algorithm adds s  open generating solution
s                               
    complexity analysis comparison among asg  lasg bu
section present complexity analysis asg lasg compare
bu  use following parameters analysis 
a  n n denote total number nodes number nodes
alternating and or tree 
b  denotes degree node maximum number children 
c  denotes maximum number edges solution 
d  denotes maximum size open  present complexity analysis
generating c solutions  therefore size closed o c  
      complexity asg
time complexity   time complexity major steps algorithm  
follows 
a  computing first solution done bottom up fashion  thus requiring o n  
steps  edges emanating node sorted non decreasing order
aggregated cost compute marks edges  marking process takes
n  d  log   since value
large general  can upper bounded
constant   n  d  log   o n   
b  number swap options available solution equal number
edges solution  thus  swap list every solution built
o m  time  c solutions  generating swap options take o c m  
c  since size successor set solution most  size open 
c m  size tlist equal c  the size
closed  
d  open list implemented using fibonacci heap  individual insert delete
operation open take o    amortized  o lg o  time respectively  hence 
inserting open deleting open altogether takes o o  lg o  time
o c m  log c m   
e  checking duplicates requires scanning entire open tlist  since
length tlist c  newly constructed solution checking takes
o c   o  time o c   o  solutions generated  since o c   o  actually
o o   generating c solutions  step takes o o   time  also  maximum value
   

fighosh  sharma  chakrabarti    dasgupta

o c m   thus  time complexity step o c m     clearly
step dominates o o  lg o  total time taken insertions open
deletions open 
however  time bound improved maintain hash map
solutions open tlist  case checking duplicates
done o o  time  case o o  lg o   total time taken insertions
open deletions open  becomes dominant time required checking
duplicates 
f  upper limit estimate could made estimating size solution tree

n regular complete alternating and or trees  important
observe value independent average degree node
 
combining
together get time complexity
asg algorithm  

factors


 
 
 
 
n     n    c m    n   c  n   o c  n  
howeverif additional
hash
reduced  

map used time complexity



n   o  lg   n   c  n   lg c n     n   n   c  lg c   c  lg n  
space complexity  following data structures primarily contribute space complexity asg algorithm 
a  three lists  namely  open  closed  tlist maintained throughout course
running asg  contributes o o   c  factor  o o  
b  since number swap options upper bounded total number edges 
constructing swap list contributes factor  o n  d  space complexity 
marking solution requires putting mark every node and or
tree  thus adding another o n   space clearly dominated previous
o n  d  factor 
c  since signature solution essentially set swap options  size
signature upper bounded total number swap options available  combining
open closed list  altogether  c   o  solutions need stored 
since  c   o 

o o   total space required storing solutions o n  d  
combining
factors
together get space complexity asg algorithm  
  n  d   o n  d   o o n  d 
additional
hash map used improve time complexity  another addi
tional o n  d space required maintaining hash map  although exact space
requirement doubled  asymptotically space complexity remains same 
      complexity lasg
time complexity   compared algorithm    algorithm   check
duplicates adds solution open required  therefore
terms complexity remain except term corresponding checking
duplicates  however  created maintained course algorithm   
creating maintaining tree require o c  time  lazy expansion
swap list previously generated sibling solutions searched  line    line   
algorithm     size swap list solution o m   maximum
number edges solution  o m  sibling solutions
   

figenerating ordered solutions explicit and or structures

solution  therefore complexity lazy expansion o c m     since o c m   
dominant factor  time complexity lasg o c m      o c n   
space complexity   compared asg algorithm  lasg algorithm maintain
tlist  however lasg maintains solution space tree whose size equal
closed list  thus adding another o c  factor space complexity incurred asg
algorithm  interesting observe worst case space complexity remains o o  
n  d   o n  d    o o n  d  equal space complexity asg algorithm 
      comparison bu
time complexity generating c best solutions and or tree o n  c  log c 
space complexity o n  c   detailed analysis found work
elliott         since  n  d   o n    space complexity asg lasg
algorithm reduces o n  c  time complexity lasg log c factor better
bu whereas time complexity asg quadratic respect c compared
 c  log c  factor bu  additional hash map used reduce time overhead
duplicate checking  asg beats lasg
bu terms time complexity 

o n   n   c  lg c   c  lg n   asymptotically lower o n  c  log c  
however worst case complexity possible and or trees duplicate solution generated  empirical results show length open  hardly reaches
o c m  

   ordered solution generation and or dags
section  present problem generating solutions non decreasing order
cost given and or dag  present working existing algorithm
generating solution tree based semantics default semantics  next present
modifications asg lasg handling dag 
    existing bottom up algorithm
figure    shows example working existing bottom up approach  bu 
and or dag figure    use notations used figure   describe
different solutions figure    generation top   solutions tree based
semantics shown 
important notice although bu correctly generates alternative solutions
and or dags tree based semantics  bu may generate solutions
invalid default semantics  figure    present solution and or dag
figure    solution example solution correct tree based
semantics invalid default semantics  solution dag  highlighted using
thick dashed lines arrow heads  figure    generated  rd solution
and or dag figure   running bu  every non terminal node  entry
 within rectangle  corresponding  rd solution highlighted using bold face  may
noted terminal nodes  v  v     included solution dag though
emanate parent node  therefore  solution valid one
default semantics 
   

fighosh  sharma  chakrabarti    dasgupta

     

v 

v  v 
              
              

h i
     

v 

    hv     i    
    hv     i    

v 
  

h i

v 

    hv     i    
    hv     i    

     

h i

v  v 
              
              

v 

    hv     i   
    hv      i    

v 

v 

  

  

    hv     i    
    hv     i    

v 

     

v 

    
h i

v 

     

v 

h i

    hv     i    
    hv     i    
h i

v  v 
              
              

v 
  

h i

h i

  

h i

h i

h i

h i

h i

h i
    

v 

h i
v 

     

     

v 

h i

h i

h i

h i

     

v  v 
              
              
              

    hv     i    
    hv     i    

v 
  

h i

v 

v  

v 

v  

 

 

 

 

figure     solution  tree based semantics 

figure     bu approach and or dag

proposed extension bu generate alternative solutions default
semantics   propose simple top down traversal pruning based extension
bu generate alternative solutions default semantics  generating ordered
solutions node vq combining solutions children  following 
newly constructed solution rooted vq   top down traversal solution
starting vq done check whether two edges node present
particular solution  a violation default semantics   violation
default semantics detected  solution pruned list alternative solutions
rooted vq   therefore  every node  new solution constructed 
additional top down traversal used detect semantics violation 
    top down method dags
proposed top down approaches  asg lasg  applicable and or
dags generate alternative solution dags default semantics  method
computing cost increment application swap option needs modified
incorporate fact node may included solution dag multiple
paths root node  use notion participation count computing cost
increment 
participation count   notion participation count applicable intermediate
nodes solution dag follows  solution dag  participation count
intermediate node  vq   total number distinct paths connecting root node  vr  
vq   example  figure     optimal solution dag shown using thick dashed
lines arrow heads  participation count every intermediate nodes
shown within circle beside node 
   

figenerating ordered solutions explicit and or structures

v 

h i

h i
 

h i

v 

     

 

h i

         

v 

v 

     

 

h i

v 

 

h i

v 

v 

     

          

 

h i

     

v 

     

v 

v 

  

  

 

h i

h i

h i

v 

 

 

  
h i

h i

     

          

h i

v 

     
h i

h i

v 

v 

  

h i

    

          

h i

h i

  
h i

     

v 

v 

    

          

  

h i

v 

v  

v 

v  

 

 

 

 

figure     solution dag s 

figure     and or dag

use notation ijk denote swap option context and or dags 
swap option ijk belongs node vi   source edge swap option eij
node vi node vj   destination edge eik node vi node vk  
      modification proposed top down approach
asg algorithm modified handling and or dags following way 
computation successor solution line    algorithm   modified incorporate
participation count node applied swap option belongs 
overall method shown algorithm   in next page  
order apply lasg and or dags  apart using mentioned
modification computing cost newly generated solution  another modification
needed computing native swap options given solution  modification
explained example  consider solution  s    shown figure     s  highlighted
using thick dashed lines arrow heads  pair  cv  vq    c s    vq    shown within
rectangles beside node vq   rectangles rounded corner used c s    vq     
copt  vq    swap option         applied sopt generate s    application
swap option           participation count node v  decremented    therefore
s  path root node node v  node v  still present s   
result  swap option          available s  participation count equal
  node v    whereas          available parent solution sopt participation
count   node v    words           available s  parent solution
sopt value participation count node v    therefore          becomes
native swap option s    generalized definition native swap options solution
presented below 
definition   o  native swap options solution  consider solution sm
and or dag g   sm constructed applying swap option hij solution
sp   since swap option hij   hehi   ehj   hij used construct sm   node vj belongs
   

fighosh  sharma  chakrabarti    dasgupta

sm   similarly  participation count node vi remains greater zero applying hij sm   node vi belongs sm   native swap options solution sm
respect swap option hij   n  sm   hij    subset l sm    comprises following
swap options  
a  hjk   hjk swap option edge ehj
b    belongs node vq vq node sm  vj  
c    node vi present sm belongs node vq vq
node sm  vi   
use term n  sm   denote native swap options hij understood
context  intuitively native swap options solution sm swap options
become available immediately applying hij   available predecessor
solution sm  


algorithm    asg algorithm and or dags
input   and or dag g
output  alternative solutions g non decreasing order cost
  compute optimal solution sopt   perform edge marking populate
swap options 
  create three lists  open  closed  tlist  initially empty 
  put sopt open 
  lastsolcost c sopt   
  open empty
 
smin remove minimum cost solution open 
 
lastsolcost   c smin  
 
remove elements tlist 
 
lastsolcost c smin   
  
end
  
add smin closed tlist 
  
compute swap list  l smin    smin  
   construct succ smin   using l smin   add new solutions open
  
  
foreach ij l smin  
  
construct sm applying ij smin  
  
construct signature sm   sig sm    concatenating ij sig smin   
  
let ij belongs node vq   p participation count vq  
cost increment ij  
  
c sm     c sm     p  
   check whether sm already present open tlist
  
  
 sm open   sm tlist 
  
add sm open 
  
end
   end
   report solutions closed 
worth noting definition   o native swap option generalization
earlier definition native swap option  definition   n   defined context trees 
   

figenerating ordered solutions explicit and or structures

case trees  participation count node maximum    therefore 
application swap option solution  participation count node 
original edge swap option points to  becomes    therefore third
condition never applicable trees 
lasg  algo     applied and or dags  mentioned modification
computing cost newly generated solution general definition native
swap option generate ordered solutions default semantics 
      working asg lasg algorithm and or dag
describe working asg algorithm example dag shown figure   
entering outermost loop  tlist closed empty  open contains
optimal solution sopt   contents different lists obtained first cycles
outermost loop shown table    solution represented signature 
solutions already present open constructed expanding
current smin   highlighted under braces  example  solution                     
added open iteration    while constructing successor solutions            
constructed iteration   expanding solution            
l smin  
open
                            
                                   
                  
                                              
                     
                       

                                              

it 
 
 

smin
  
          

 

           



                                 

 

          

                  

                                           
 
 z
 

closed
  
              
              
                     
               
                      
           
               
                      
                       

table    example working asg algorithm dag shown figure  
illustrate working lasg algorithm example dag shown figure    contents different lists solution added closed shown
table    worth noting solution s              swap list l s     
                      whereas native swap list n  s                   solutions
added open result lazy expansion  highlighted using under brace  example 
iteration   lasg adds solution s                         open generation
solution s             part lazy expansion  whereas asg algorithm adds s 
open generating solution s             
      generating solutions tree based semantics
unlike default semantics  asg lasg straight forward extension
generating solutions tree based semantics  figure    show example
solution valid tree based semantics  invalid default semantics 
edges emanating form node v    namely e      e        
   

fighosh  sharma  chakrabarti    dasgupta

n  smin  
open
                                                                
        
                        
                     
                       

                        

it 
 

smin
  
          

 

           



          

 

          

        

                      
                    
 
 z
 

closed
  
              
              
                     
               
                      
           
               
                      
                       

table    example working lasg algorithm dag shown fugure  

present solution  two edges included solution two
different paths emanating form root node  v    existing bottom up approach
stores alternative solutions node terms solutions children
node  representation allows different paths stored explicitly  thus making
bu amenable generating alternative solutions tree based semantics 
contrary  approach works top down using compact representation  signature  storing solutions  signature based representation  currently
possible store fact particular node included solution two
different paths may select different child node  use equivalent
tree constructed form given graph  compact representation work correctly  case  node would reachable root node one
path  and or dag converted equivalent and or tree representation
using procedure convertdag  described section    asg lasg applied equivalent tree representation order generate alternative solutions
correctly tree based semantics  however  worst case  procedure convertdag
incurs space explosion blow worst case complexity asg
lasg algorithms  using compact representations generate ordered solutions
tree based semantics given and or dag containing space explosion
worst case complexity algorithms remain comparable bu turns
interesting open problem 

   experimental results observations
obtain idea performance proposed algorithms compare
existing approach  implemented asg  lasg bu  existing bottom up
approach  tested following test domains 
a  set synthetically generated and or trees 
b  tower hanoi  toh  problem 
c  set synthetically generated and or dags 
d  matrix chain multiplication problem 
e  problem determining secondary structure rna sequences 
   

figenerating ordered solutions explicit and or structures

may noted implementation asg algorithm  implemented
space efficient version asg algorithm  without separate hash map storing
solutions open closed  thereby incurring extra overhead time duplication
checking   another important point every test case reported running time
asg lasg generating particular number solutions includes time required
constructing optimal solution graph  details different test domains
follows 
    complete trees
generated set complete d ary alternating and or trees varying  a 
degree non terminal nodes  denoted d    b  height  denoted h  
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
             
     
     
     
     
     
     
     
     
     
     
      
     
     
                     
     
     
     
     
     
     
      
     
     
     
     
     
      
     
     
     
     
     
      
     
     
     
     
     
      
            

    solutions
asg
lasg
bu
     
     
     
     
     
     
      
     
     
      
     
     
             
     

     
      
     
     
     
     
     
     
      
     
     
             
      

              
     
     
     
      
     
     
             
      
     
     
     
             
      
     
     
     
             
      
      
     
     
                     

    solutions
asg
lasg
bu
     
     
     
     
     
     
      
     
     
             
     
             
     

             
     
     
     
      
     
     
             
     

     
      

              
     
     
     
      
     
     

     
      
     
     
     
             
      
      
     
     
             
      
      
     
     

             

table    comparison running time  in seconds  generating               solutions
complete alternating and or trees  t denotes timeout    minutes 
trees viewed search space gift packing problem 
 a  terminal nodes represent cost elementary items 
 b  nodes model choice among items  elementary composite nature 
represented children 
 c  nodes model repackaging items returned children 
every packaging incurs cost modeled cost intermediate nodes 
objective find alternative gifts order non decreasing cost 
table   shows time required generating               solutions various
complete alternating and or trees  implemented asg  lasg
existing bottom up algorithm corresponding running time shown column
heading asg  lasg bu  respectively  used time limit    minutes
   

fighosh  sharma  chakrabarti    dasgupta

 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

asg
      
      
       
       
       
        
      
      
       
        
        
      
       
        
      
       
      
        
       
        

    solutions
lasg
bu
      
      
      
      
      
       
       
       
       
        
                  
      
      
      
       
       
        
                 
                  
      
      
       
       
                  
      
      
       
        
      
       
       
        
      
       
                  

asg
      
       
       
       
        

      
       
       
        

       
       
        
       
        
       
        
       
        

    solutions
lasg
bu
      
      
      
      
       
       
       
        
       
        
                  
      
      
       
       
       
        
                  
                   
      
       
       
        
                  
       
       
       
        
       
       
                  
       
       
                  

asg
      
       
       
        
        

      
       
        


       
       

       
        
       
        
       


    solutions
lasg
bu
      
      
       
      
       
       
       
        
        
        
        
         
      
      
       
       
       
        
        
         
                    
       
       
       
        
        
         
       
       
       
        
       
       
        
         
       
       
        
         

table    comparison space required  in kb  generating               solutions
complete alternating and or trees

entries marked denotes time out occurred test cases 
space required generating               solutions reported table   
observed terms time space required  lasg outperforms asg
bu  asg bu  test cases bu performs better asg
respect time required generating specific number solutions  space
requirement asg bu generating specific number solutions interesting
correlation degree d  height h  parameter tree  low numerical values
h parameter  e g    d  h  combinations                etc   bu performs
better asg  contrary  combinations  least one
h parameters high value  e g    d  h  combinations                         etc  
asg outperforms bu 
      experimentation queue bounded length
since open grow rapidly  asg lasg incur significant overhead
terms time well space maintain open list number solutions
generated known priori  fact  asg checking duplicates open
actually primary source time complexity storing solutions open major
contributing factor space complexity  number solutions generated
known priori  proposed top down approach leverage fact using bounded
length queue implementing open  bounded length queue used  time
requirement along space requirement decreases significantly 
   

figenerating ordered solutions explicit and or structures

 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
                    
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
            

    solutions
asg lasg
bu
           
     
           
     
           
     
           
     
           
     
                  
           
     
           
     
           
     
                  
                   
           
     
           
     
                  
           
     
                  
           
     
                  
           
     
                   

    solutions
asg lasg
bu
           
     
           
     
           
     
           
     
           
     
                  
           
     
           
     
           
     
                  
                   
           
     
           
     
                  
           
     
                  
           
     
                  
           
     
                   

table    comparison running time  in seconds  generating               solutions
complete alternating and or trees bounded length open queue asg
lasg
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

asg
      
      
      
       
       
        
      
      
       
       
        
      
       
        
      
       
      
       
      
        

    solutions
lasg
bu
     
      
     
      
      
       
      
       
       
        
                 
     
      
      
       
      
        
       
        
                  
     
      
      
       
                 
      
      
       
        
      
       
       
        
      
       
                  

asg
      
      
       
       
       
        
      
       
       
        
        
      
       
        
      
       
       
        
       
        

    solutions
lasg
bu
     
      
     
      
      
       
      
        
       
        
       
         
     
      
      
       
      
        
       
         
                   
     
       
      
        
       
         
      
       
       
        
      
       
       
         
      
       
                  

asg
      
       
       
       
        
        
      
       
       
        
         
      
       
        
       
       
       
        
       
        

    solutions
lasg
bu
     
      
      
      
      
       
      
        
       
        
       
         
     
      
      
       
      
        
       
         
                   
      
       
      
        
       
         
      
       
       
        
      
       
       
         
      
       
                  

table    comparison space required  in kb  generating               solutions
complete alternating and or trees bounded length open queue asg
lasg

   

fighosh  sharma  chakrabarti    dasgupta

show effect using bounded length queue implement open table    reporting time requirement  table    reporting memory usage  generating
              solutions  number solutions generated known beforehand  table   table   show case asg lasg outperforms
bu terms time well space requirements  particularly  asg performs well
setting  outperforming lasg cases 
      experimentation compare incremental nature
proposed top down algorithms incremental nature whereas existing bottomup approach incremental  generating specified number ordered solutions 
methods generate next solution incrementally without needing restart itself 
whereas existing approach needs restarted  example  generating
first    ordered solutions  asg lasg generate   th solution directly data
structures maintained far algorithms perform necessary updates
data structures  whereas  bu needs restarted input parameter    generating
  th solution  table   compare time needed generate subsequent   th
solution   th solution incrementally generating first    solutions  order
clarity comparison among running times respective algorithms 
used higher precision  upto  th decimal place  reporting running time
table    clearly  asg lasg outperform bu generating   th   th
solution terms time requirement 
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

asg
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

lasg
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

table    comparison running time  in seconds  generating first    solutions
  th solution   th solution incrementally complete alternating
and or trees

   

figenerating ordered solutions explicit and or structures

    multipeg tower hanoi problem
consider problem multipeg tower hanoi  majumdar        gupta  chakrabarti 
  ghose         problem  pegs fastened stand  initially disks rest
source peg small disk large disk ordering  objective transfer
disks destination peg b minimum legal moves  legal move 
topmost disk tower transferred peg larger disk
topmost disk  problem multi peg tower hanoi solved recursively follows 
a  move recursively topmost k  k varies      disks
intermediate peg  i  using pegs 
b  transfer remaining k disks b recursively  using      pegs
available 
c  recursively move k disks transferred previously  intermediate
peg b  using pegs 
may noted choice value k  may take value  
   solutions different values k may take different number moves 
solution incurs minimum number moves optimal solution  choice
value k modeled node  every choice  problem divided
three sub problems  decomposition sub problems modeled
node  therefore  search spaces multi peg tower hanoi problem correspond
alternating and or trees 
 disks
 
 
  
  
  
  

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
            
                    

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
      
                    
                     

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
      
     
      
      
      
      
                       

 opt  no 
moves
  
  
  
  
  
  

table     comparison running time  in seconds  alternating and or trees corresponding search spaces   peg tower hanoi problem different
number disks
 disks
 
 
  
  
  
  

    solutions
asg
lasg
bu
asg
      
      
       
      
      
       
        
       
       
       
        
       
       
                  
       
                           
        
                                        

    solutions
lasg
bu
asg
      
       
       
       
        
       
       
        
       
                  
        
                  
        
                              

    solutions
lasg
bu
       
       
       
        
       
         
                  
                   
                    

table     comparison space required  in kb  alternating and or trees corresponding search spaces   peg tower hanoi problem different number
disks
used search space   peg tower hanoi problem different number
disks    generated alternative solutions non decreasing order cost using asg
   

fighosh  sharma  chakrabarti    dasgupta

lasg algorithms  cost function expresses number legal moves  value
varied       table    table     report time required
space required  respectively  generating               solutions every test cases 
experimental results show performance asg similar performance
lasg respect space time  however asg well lasg outperforms
bu respect time space requirements 
    randomly constructed and or dags
constructed set randomly generated and or dags evaluated asg 
lasg  bu algorithm generating solutions default semantics  used
proposed extension bu algorithm generating solutions default semantics 
n



  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

    solutions
asg lasg
bu
                 
                 
                 
                 
                 
                 
                   
                 
                 
                  

     


    solutions
asg
lasg
bu
     
           
     
           
     
           
     
           
     
           
                  
                    
     
           
     
           
                   

     


    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
            
     
                    
     
     
     
            
     
                     

     


table     comparison running time  in seconds  generating               solutions and or dags  t denotes timeout    minutes 
n



  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

asg
      
      
      
      
      
       
       
      
       
       
        

    solutions
lasg
bu
     
     
      
      
      
       
      
     
      
      
       
       
                
      
      
      
       
                
        


asg
      
      
       
      
       
       
        
      
       
        


    solutions
lasg
bu
      
      
      
      
       
       
      
      
       
      
       
       
                
      
      
       
       
                
        


asg
      
       
       
      
       
        
        
       
       
        


    solutions
lasg
bu
      
      
      
      
       
       
      
      
       
       
       
       
                 
      
      
       
       
                
        


table     comparison space required  in kb  generating               solutions
and or dags

table    table    compare time required space required running asg 
lasg bu generating               solutions every test cases  first
second columns every row provide size  n   average out degree  d 
dag  results obtained test domain similar results randomly
   

figenerating ordered solutions explicit and or structures

constructed and or trees  may noted terms time space required 
lasg outperforms asg bu  asg bu  test cases
bu performs better asg respect time required generating specific
number solutions  whereas  space requirement asg bu generating
specific number solutions interesting co relation average degree d 
size  n   parameter dag  low numerical values n
parameter  e g    n   d  combinations                  etc   bu performs better
asg  contrary  combinations  least one n
parameter high value  e g    n   d  combinations                                
etc   asg outperforms bu 
    matrix chain multiplication problem
used well known matrix chain multiplication  cormen  stein  rivest   
leiserson        problem experimentation  search space popular dynamic
programming formulation problem correspond and or dag 
dag
cnstr 
 matrices
time
 sec 
  
     
  
     
  
     
  
     
  
     
  
      
  
      
  
      
   
       

sopt
cnstr 
time
 sec 
     
     
     
     
     
     
     
     
     

   solutions

   solutions

   solutions

asg

lasg

bu

asg

lasg

bu

asg

lasg

bu

     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
      
       
       




     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
       
       





     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
       
       





table     comparison time required  in seconds  and or dags corresponding
search spaces matrix chain multiplication different number matrices   t denotes timeout    minutes 
 matrices
  
  
  
  
  
  
  
  
   

asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
       
        
        
        
        




asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
       
        
        
        





asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
        
        
        
        





table     comparison space required  in kb  and or dags corresponding
search spaces matrix chain multiplication different number matrices

given sequence matrices  a    a        n matrices matrix ai dimension pi  pi   problem objective find efficient way multiply
   

fighosh  sharma  chakrabarti    dasgupta

matrices  classical dynamic programming approach works follows  suppose
a i j  denotes matrix results evaluating product  ai ai   aj   m i  j 
minimum number scalar multiplications required computing matrix a i j   
therefore  cost optimal solution denoted m i  j  recursively defined
 

m i  j   


  

min

ik j



  j 

m i  k    m k      j    pi  pk pj     j 

choice value k modeled node every choice  problem
divided three sub problems  decomposition sub problems modeled
node  worth noting unlike search space   peg toh problem 
search space matrix chain multiplication problem corresponds and or dag 
used search space different matrix sequences varying length
generated alternative solutions order non decreasing cost  table     report
time required table     report memory used generating        
   solutions every test cases 
table     test case  report time required constructing
explicit and or dag recursive formulation  nd column  optimal
solution construction time  rd column  interesting observe relative
performance asg lasg search space similar obtained  peg toh search space though search space domain and or dag  asg
lasg perform approximately respect time space requirement 
however  advantage asg well lasg bu respect time
space requirement significant domain 
    generating secondary structure rna
another relevant problem alternative solutions play important role
computation secondary structure rna  rna molecules viewed strings
bases  base belongs set  adenine  cytocine  guanine  u racil   also
denoted  a  c  g  u     rna molecules tend loop back form base pairs
resulting shape called secondary structure  mathews   zuker         stability
secondary structure largely depends number base pairings  in general  larger
number base pairings implies stable secondary structure   although
factors influence secondary structure  often possible express
factors using cost function typically evaluated empirically  therefore 
useful generate set possible alternative secondary structures ordered decreasing
numbering base pairings given rna subjected experimental
evaluation 
computation optimal secondary structure considering underlying principle maximizing number base pairings nice dynamic programming formulation  kleinberg   tardos         given rna molecule b   hb  b  bn
bi  a  c  g  u    secondary structure b set base pairings      i  j   
i  j        n   satisfies following conditions 
   

figenerating ordered solutions explicit and or structures

test case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

organism name
anaerorhabdus furcosa
archaeoglobus fulgidus
chlorobium limicola
desulfurococcus mobilis
haloarcula japonica
halobacterium sp 
mycoplasma genitalium
mycoplasma hyopneumoniae
mycoplasma penetrans
pyrobaculum aerophilum
pyrococcus abyssi
spiroplasma melliferum
sulfolobus acidocaldarius
symbiobacterium thermophilum

  bases
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table     details rna sequences used experimentation
a   i  j  d        j   condition states ends pair
separated least four intermediate bases 
b  elements pair consists either  a  u    c  g   in either order  
c  base appears one pairings  i e   matching 
d   i  j   k  l  two pairs d  possible   k   l   j  i e  
two pairings cross other 
test
case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

dag cnstr 
time  sec 
      
      
      
      
      
      
      
      
      
      
      
      
      
      

sopt cnstr 
time  sec 
     
     
     
     
     
     
     
     
     
     
     
     
     
     

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

  solutions
lasg
bu
             
             
             
              
             
             
             
             
             
     

             
             
             
             

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

   solutions
lasg
bu
             
     

             
     

              
     

             
             
             
     

              
             
     

             

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

   solutions
lasg
bu
              
     

              
     

     

     

             
             
             
     

     

             
     

              

table     comparison time required  in seconds  and or dags corresponding
search spaces rna secondary structure different number bases  t
denotes timeout    minutes 

mentioned conditions dynamic programming formulation follows 
suppose p  i  j  denotes maximum number base pairings secondary structure
bi bj   p  i  j  recursively defined  
p  i  j   


  

n


max p  i  j     max     p  i  k      p  k      j     
ik j

   

    j 

      j 

fighosh  sharma  chakrabarti    dasgupta

here  choice value k modeled node every choice 
problem divided three sub problems  decomposition sub problems
modeled node  experimented search space problem
set rna molecule sequences obtained test cases developed szymanski 
barciszewska  barciszewski  erdmann         details test cases shown
table    
every test cases  report time required table    generating          
solutions  setting  space required reported table     table    
test case  report time required constructing explicit and or dag
recursive formulation  nd column  time required constructing
optimal solution time  rd column  use high value time out       seconds 
order gather running time required bu  limit maximum solutions generated
   generating higher number solutions  bu timed
test cases  worth noting result obtained domain similar
result obtained matrix chain multiplication problem domain  space time
wise asg lasg perform similarly outperform bu significantly respect
time well space requirement 
test
case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
        
        
        
         
        
        
        
        
        

        
        
         
        

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

   solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
         

         

         

         
         
         

         
         

         

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

   solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
         

         



         
         
         


         

         

table     comparison space required  in kb  and or dags corresponding
search spaces rna secondary structure different number bases

    observations
experimental data shows lasg algorithm generally outperforms asg
algorithm existing bottom up approach terms running time complete
alternating and or trees and or dags  whereas  problem domains 
i e     peg tower hanoi problem  matrix chain multiplication problem 
problem determining secondary structure rna sequences  overall performance
asg algorithm similar performance lasg algorithm  behavior
explained average maximum length statistics open list  reported
table      table     mentioned test domains 
   

figenerating ordered solutions explicit and or structures

case complete trees random dags  asg algorithm  average well
maximum size open grows much faster lasg algorithm  table   
table      increase size tree dag 
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
  
   
   
    
  
   
    
    
   
   
    
     
   
    
     
     
   
   
     
     
   
   
   
   
   
   
    
    
   
   
    
     
   
   
     
     
   
   
            
         
   
    
   
   
    
    
   
   
     
     
   
   
    
    
   
   
    
     
   
   
    
    
   
   
     
     
   
   
    
    
   
   
     
     
   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
   
    
     
   
    
     
     
         
     
     
   
    


         
   
    
   
   
    
    
   
    
     
     
   
   
            
   
    


         
    
    
   
   
     
     
   
    
     
     
   
    
    
    
   
    
     
     
   
   
    
    
   
    
     
     
   
   
    
     
   
    
            
   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
    
     
     
   
    
     
     
         
            
   
    


         
    
    
   
    
    
     
         
     
     
   
    


         


         
    
    
   
    
     
     
         


         
    
     
   
    
     
     
   
    
    
     
   
    
            
   
    
     
     
         


   
    

table     average maximum length open generating               solutions complete alternating and or trees
n



  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
  
  
   
   
  
   
    
    
   
   
   
   
  
   
    
    
   
   
    
    
   
   
           
   
   
   
   
  
   
    
    
   
   
    
     
   
   


   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
   
    
    
   
   
   
    
   
   
    
    
        
           
        
           
        
    
    
   
   
    
     
        
           
        


        

    solutions
asg
lasg
avg 
max 
avg  max 
   
    
   
   
    
    
   
   
    
     
   
   
   
    
   
   
    
    
         
     
     
         
            
         
    
    
   
   
     
     
   
    
     
     
         


   
    

table     average maximum length open generating               solutions randomly constructed and or dags

since asg algorithm checks presence duplicates expanding solution 
time required duplication checking grows rapidly test domains  hence 
overall time required generating specific number solutions increases rapidly
 faster bu lasg  increase size tree dag  result 
bu outperforms asg respect time requirement trees dags  however
   

fighosh  sharma  chakrabarti    dasgupta

memory used generating specific number solutions increases moderately  slower
bu  increase size tree dag  therefore respect space
requirement  asg outperforms bu larger trees dags 
lasg bu  time well memory requirement bu increases
faster lasg degree and or tree dag increases 
happens because  bu  time taken merging sub solutions nodes
memory required storing alternative solutions rooted different nodes
increases rapidly increase degree node 
contrary  test domains    peg tower hanoi problem  matrix chain
multiplication problem  probelm finding secondary structure rna sequences 
average maximum size open asg lasg comparable  table     table    table      therefore  lasg algorithm  time saved
avoiding duplication checking compensated extra overhead maintaining
solution space tree checks required lazy expansion  hence running time
well space requirement almost algorithms three
mentioned problem domains 
moreover  due low values average maximum size open  asg
outperforms bu respect time requirement memory used three
test domains  three domains also  lasg bu  time well
memory requirement bu increases faster lasg size search
space  and or tree dag  increases 

   ramifications implicitly specified and or structures
section  briefly discuss use proposed algorithms generation alternative
solutions non decreasing order cost implicit and or search spaces  one
possible way extend standard ao generating given number solutions 
say k  follows  instead keeping one potential solution graph psg   stage k
psgs computed explicitly constructed search space instead expanding
one node  k nodes   that is  one node psg   expanded once 
expanding nodes  k psgs recomputed again  since cost nodes
often recomputed expanding nodes  swap options associated node
updated every recomputation 
another possible approach could run ao generates optimal solution 
point time swap options computed explicit portion
graph swap option minimum cost applied optimal solution 
resulting psg expanded resulting expansion explicit graph 
swap options re evaluated incorporate cost update  next best psg
computed  process continues till second best solution derived  among
remaining successor psgs first solution successor psgs second solution 
promising psg selected expanded  process continues till third solution
found  successor psgs added already existing pool candidate
psgs  two broad steps   a  selecting next best psg pool candidate
psgs   b  keeping expanding explicit graph till next best solution
found  continued till k solutions found 
   

figenerating ordered solutions explicit and or structures

  disks
 
 
  
  
  
  

    solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
   
  
  
   
   
  
  
   
   
  
   
   
   
  
   
   
   
   
   

    solutions
asg
lasg
avg  max  avg  max 
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
   
   

    solutions
asg
lasg
avg  max  avg  max 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
   
   
         
   
   

table     average maximum length open generating               solutions   peg tower hanoi problem different number disks
  matrices
  
  
  
  
  
  
  
  
   

   solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
   
  
   
  
   
  
  
  
   
  
   
  
   
  
   
   
   
  
   
   
   
  
   
   
   
   
   
   
   
   
   

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
  
   
   
  
   
  
   
  
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
  
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
   
   

table     average maximum length open generating            solutions
matrix chain multiplication problems
test case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

  solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
  
   
  
   
  
   
  
  
  
  
  
  
  
  
  
  
  
  

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
   
   
   
  
   
  
   
  
   
   
   
  
   
  
   
  
   
   
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
   
   
   
   
   
   
   
   
  
   
  
  
   
   
   
   
  
   
  
   

   solutions
asg
lasg
avg  max  avg  max 
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
  
   
  
   
   
   
   
   
   
   
  
   

table     average maximum length open generating           solutions
generating secondary structure rna sequences

   

fighosh  sharma  chakrabarti    dasgupta

important observe methods heavily depend incorporating updates explicit dag adding nodes  increase cost  etc   recomputing
associated swap options along signatures use swap options  handling
dynamic updates dag efficiently use implicit and or search spaces
remains interesting future direction 

   conclusion
work presented top down algorithm generating solutions given
weighted and or structure  dag  non decreasing order cost  ordered solutions
and or dags useful number areas including model based programming 
developing new variants ao   service composition based user preferences  real life
problems dynamic programming formulation  etc  proposed algorithm two
advantages  a  works incrementally  i e   generating specific number solutions 
next solution generated quickly   b  number solutions generated
known priori  algorithm leverage generate solutions faster  experimental
results show efficacy algorithm state of the art  opens
several interesting research problems development applications 

   acknowledgments
thank anonymous reviewers editor  prof  hector geffner  valuable
comments enriched presentation paper significantly  thank
prof  abhijit mitra  international institute information technology  hyderabad  india 
valuable inputs regarding test domain involving secondary structure rna 
thank aritra hazra srobona mitra  research scholar  department comp  sc   
engg   indian institute technology kharagpur  india  proof reading paper 

appendix a  proof correctness algorithm  
lemma a   every solution optimal solution sopt constructed
sopt applying sequence swap options according order r 
proof   lemma a    every solution sopt alternating and  tree
constructed choosing non optimal edges nodes  consider
solution sm   corresponding set non optimal edges suppose
 s     m  apply relation r obtain ordered sequence edges
e    e    e  appears e   e    e    r  show exists
sequence swap options constructed   every edge eij
 here eij ith edge   m   append subsequence edges
ei            eij   eij   ei            eij edges emanate
parent vq   ei            eij   first ij   edges l vq   
get sequence edges aug mentioned augmentation 
aug basically concatenation subsequences               sequence edges
ei            eij ei            eij edges emanate parent vq  
ei            eij first ij edges l vq    construct aug follows 
   

figenerating ordered solutions explicit and or structures

every   construct   hi   i            ij   ij i  ik  ik      heik   eik      ik  ik   
i  ik  ij     constructed concatenating every individual   hence exists
sequence swap options corresponding every solution sm  


definition a p  default path  lemma a    every non optimal solution sm
constructed initial optimal solution applying sequence swap options 
 sm    according order r  sequence solutions formed following  sm  
corresponds path sopt sm ssdag g   path defined default
path  pd  sm    sm  
lemma a   ssdag alternating and or tree contains every alternative
solution  
proof   lemma a    prove induction length default path pd
solutions 
 basis  n         consider swap list sopt   solutions whose default path length
equal   form succ sopt    therefore solutions present g 
 inductive step    suppose solutions whose default path length less equal
n present g  prove solutions default path length equal
n     present g  consider solution sm pd  sm     n      let  sm    
 s     h     i  since p  s    
h      n   n   i  consider solution sm
 
n





v  swap option
n  sm
n   l sm    directed edge sm sm g  
hence every solution default path length equal n     present g 


lemma a   alternating and or tree   algorithm   adds solutions closed
 at line     non decreasing order cost 
proof   lemma a    consider following invariants algorithm   follow
description algorithm   
a  minimum cost solution open always removed line   algorithm   
b  cost solutions added open  exploring successor set
solution sm  at line    algorithm     greater equal c sm   
two invariants follows algorithm   adds solutions closed  at line    
non decreasing order cost 
lemma a   alternating and or tree   every node ssdag  
agorithm   generates solution corresponding node 
proof   lemma a    lemma a   follows algorithm   generates solutions
non decreasing order cost  generating solution sm   mean adding sm
closed  at line    algorithm     purpose proof contradiction  let us assume
algorithm   generate solution sm   let sm first occurrence
   

fighosh  sharma  chakrabarti    dasgupta

scenario generating solutions mentioned order  according lemma a   
exists sequence swap options               k corresponding sm   consider
whose sequence swap options            
solution sm
 
k    according property     

c sm   c sm    consider following two cases 
    c s    since
a  c sm

first instance incorrect scenario  algo generated
rithm   generates solutions non decreasing order cost  sm
prior sm  
    c s    since algorithm   resolves tie favor parent solution 
b  c sm


sm first instance incorrect scenario case sm
generated prior sm  
  generated algorithm   
swap option k belongs swap list sm



is  sm added closed  sm expanded solutions
applying one swap option  added open list  since
constructed sm

applying one swap option  
constructed sm


added


open

k
  therefore
exploring successors sm
eventually generated
algorithm     contradiction 



lemma a   alternating and or tree   algorithm   add solution
closed  at line    algorithm    once 
proof   lemma a    purpose contradiction  let us assume sm first
solution added closed twice  therefore sm must added open twice 
consider following facts 
a  sm added closed first time  value lastsolcost c sm   
sm added tlist 
b  description algorithm   follows contents tlist deleted
value lastsolcost increases 
c  lemma a   follows algorithm   generates solutions non decreasing
order cost  hence  sm generated second time  value
lastsolcost change c sm   
facts follow sm present tlist sm added open
second time  since  adding solution open  algorithm   checks whether
present tlist  at line    algorithm     algorithm   must done
adding sm open second time  therefore sm could added open
second time contradiction 


theorem a   sj v  sj generated  at line     algorithm  
non decreasing order costs ties among solutions costs resolved
mentioned before 
proof   theorem a    follows lemma a    lemma a    lemma a   lemma a   


   

figenerating ordered solutions explicit and or structures

appendix b  proof correctness algorithm  
definition b q  reconvergent paths solution space dag  two paths   i  p   
si   si n  ii  p    si   si m   ssdag g alternating
and or tree reconvergent following holds 
a  si     si     i e  paths start node 
b  si n   si m   i e  paths ends node 

c   j     n     k          si j    si k   i e  paths common
intermediate node 
definition b r  order generation time  context algorithm    define
order relation  v v   sp   sq   sp generated algorithm   sq  
v set vertices ssdag g alternating and or tree  
lemma b   algorithm   adds solutions closed list non decreasing order
costs 
proof   lemma b    consider following invariants algorithm   follow
description algorithm   
a  minimum cost solution open always removed line    algorithm   
b  algorithm   expands solution  say sp   two phases  first phase sp
expanded using native swap options sp   solutions added open
result application native swap options  cost greater
equal c sp    second phase  i e   lazy expansion  sp expanded
using non native swap option  solution sp may undergo second phase times
    l sp     n  sp   k     k used construct sp   every lazy
expansion sp   new solution added open  consider solution sm
using algorithm   p red s    suppose swap
constructed sm

j

option l sm   
  n  sm   j    i e   native swap option sm  
   suppose successors respectively 
clearly l sm

c

c



constructed application   i e   sm
sc   sm
sc   let sc
added closed sm  
consider fact algorithm   apply swap option sm   is  sc
  c s    c s   c s   
added open sc added closed  since c sm

c
c
according algorithm    applied sm  during lazy expansion   sc
added open right sc added closed  consider time period
adding sm adding sc closed  period  every solution added
closed cost c sm   c sc    i e   cost less equal c sc   
general  application swap option add solution open delayed
amount time  say   solutions  added closed
time interval  cost less equal solution consideration 
   

fighosh  sharma  chakrabarti    dasgupta

facts follow algorithm   adds solutions closed list
non decreasing order costs 


lemma b   two reconvergent paths ssdag g alternating and or
tree equal length 
proof   lemma b    consider paths 












 
 
n
 
 
 i  p    s 
sp

sn    ii  p    s 
sp

sn  

edges paths represent application swap option solution  p 
p  start solution end solution  therefore sets
swap options used paths same  hence lengths paths
equal  is  context p  p    n   m 
lemma b   set reconvergent paths length n  algorithm   generates
one path 
proof   lemma b    following cases possible 
 case    n         consider following two paths 








 
 
 
 
 i  p    s 
s 
s     ii  p    s 
s 
s   

obvious               suppose s  s    algorithm  
apply swap option   s    therefore p  generated algorithm   
 case    any values n     case  path belonging set reconvergent paths  consists n different swap options  suppose       n   start
node end node paths consideration sp sm   consider nodes
paths length   sp   clearly n nodes 
among nodes  suppose algorithm   adds sp  closed first  sp  constructed
sp applying swap option     according algorithm      applied
node constructed sp added closed sp    therefore 
paths starting sp   whose second node sp    generated
algorithm    use similar argument paths sp  sm length n  
determine paths generated algorithm    stage  set
paths grown further  one path towards sm continue grow 
applying previous argument n times  one path sp sm
constructed  therefore algorithm   generate one path sp sm  


definition b s  connection relation rc rc   define connection relation  rc  
symmetric order relation pair nodes  vq vr   belonging alternating
and or tree as 
 vq   vr   rc   exists node vp  
exist two paths   i  p    vp       vq  

 ii  p    vp       vr
   

figenerating ordered solutions explicit and or structures

similarly connection relation  rc   defined two swap options follows  consider two swap options iq jr   iq   hei   eq   iq jr   hej   er   jr i  suppose
edges ei eq emanate vp   edges ej er emanate vt  
 iq   jr   rc  vp   vt   rc  
definition b t  mutually connected set  solution sm   set vm nodes
mutually connected 

v    v  vm    v     v      v    v    rc  
consider set nodes  vm    v      vk    swap option j belongs vj
  j k  set swap options vm          k   mutually connected 
lemma b   suppose sm solution alternating and or tree   p red sm    
 s      sk    swap option j used construct sm sj   j k 
swap options       k mutually connected 
proof   lemma b    since sm constructed s      sk applying       k respectively        k present signature sm   suppose set          k   
show

  b    a   b   rc

purpose proof contradiction  let us assume  i    i   
  rc   sm constructed applying i  i  si  si  respectively  consider path p  ssdag
starts sopt ends sm   along p    si  parent sm  
along path  i  applied application swap option i    similarly consider path p  ssdag starts sopt ends sm   along p   
si  parent sm   along path  i  applied application swap
option i   
suppose i  i  belongs node v  v  respectively  since along path p    i 
swap option applied last  sm contains node v    similarly along path p    i 
swap option applied last  hence sm contains node v    therefore  must
node vr   exist paths node v  v  implies
 i    i    rc   arrive contradiction proves       k mutually connected 



definition b u  subgraph ssdag  consider solution sp alternating and or
tree tand mutually connected set vm nodes sp   vq vm   c sp   vq    
 s   v     hv
copt  vq     subgraph gsub
p
sub   esub ssdag respect sp
vm defined follows  vsub consists solutions constructed
sp applying sequence swap options belonging vm   esub set edges
corresponding swap options belong vm  
 s   v  
lemma b   number total possible distinct solutions level gsub
p

 

 v
 
 
n 
n d 

n 

   

fighosh  sharma  chakrabarti    dasgupta

proof   lemma b    consider swap options belong nodes vm  
 s   v   represented sequence
respect swap options  every solution sr gsub
p
numbers length n  seq sr    every number corresponds distinct node vm  
numerical value number represent rank swap option chosen
node vq vm   according representation  level 
i  sum numbers seq sr   solution  sr   equal sum numbers
seq sr   solution  sr   level 
ii  sum numbers seq sr   solution  sr   increased   sum
numbers seq sr   solution  sp   previous level 
hence  dth level  n slots   increments need made
seq sr    instance well known combinatorial problem packing n    
objects n slots
restriction keeping least one object per slot 
n d 
done n  ways 


theorem b   solution space tree constructed algorithm   complete 
proof   theorem b    purpose contradiction  suppose sm first solution
generated algorithm    p red sm      spi   sm constructed
spi applying qi     k  lemma b   follows set
swap options  qi     k  mutually connected  therefore set nodes vm
swap options belong mutually connected  suppose  vm     n 
consider solution sq   vm mutually connected    k  every qi
belongs set native swap options sq respect swap option used
construct sq   clearly

vt vm   c sq   vt     copt  vt  

argue sq generated algorithm   sm first solution
rooted  
generated algorithm    consider subtree tsub
q
edges corresponding swap options belong vm considered  prove
equal
number solutions generated algorithm   every level tsub

number solutions level gsub  sq   vm   
consider solution sq set succ sq    suppose succ sq   vm   set
successor solutions constructed sq applying swap options belonging

minimum cost solution succ sq   vm    according
nodes vm   smin

algorithm   initially succ smin   partially explored using set native swap options

smin
  non native swap option  b   belongs nodes vm   used


explore succ smin
   right sibling solution smin
  constructed applying b sq 
added closed  consider fact solution sq   vt vm   c sq   vt     copt  vt  
holds  therefore swap options belonging vm eventually used explore

successors smin
  similarly second best successor sq able use

 
one swap option  c   used construct smin


immediate children smin tsub consist solutions  obtained


application one swap option vm smin
  native swap list smin
contains
swap option ranking next c   swap options  used construct
   

figenerating ordered solutions explicit and or structures


n   sibling solutions smin
  used lazy expansion  accounts


another n   children smin
  hence would n children smin
 

similarly  second best successor sq tsub n   immediate children 
n   children on  children
third best successor sq tsub
solutions children solutions own  increasing number
solutions level tree  way  increasing level  number
solutions present level keeps increasing  prove following proposition part
proving theorem b   
  given
proposition b   level d  number solutions n  d  n  tsub


n
x
n d 


n  d  n  tsub    
n  d    k  tsub    
n 
k  

proof   proposition b    second level  n solutions  give rise

k  

k 

n 
x

k 

k  

n 
x
k  

k

k  

solutions third level  similarly fourth level
n
x

n
x



           
    n     n    tsub
k           n     n  tsub

extend level result follows 

     
n     n  tsub


    n
n     n  tsub


n
x
n  

n     n  tsub    
k 
 
k  


n     n  tsub
 

 

n
x
k  


n     k  tsub
 

 




n  
 

induction depth d 
determine number solutions level tsub

 basis  d        

    n 
clearly  n     n  tsub



 inductive step    suppose  dth level number solutions n d 
  n d 
n 
d   
therefore    th level 





n
x
n d 
n d 
n d 


n  d      n  tsub    
 
n  d  k  tsub    
       
d 
d 
n 
k  

since algorithm   generate duplicate node  proposition b  
 s   v   level equal number solutions
number solutions gsub
q

 s   v   generated

level tsub   level set solutions gsub
q
 s   v   

algorithm   tsub   therefore  level  sm belongs gsub
q
generated algorithm    therefore sm generated algorithm  
contradiction establishes truth statement theorem b   


   

fighosh  sharma  chakrabarti    dasgupta

appendix c  conversion and or tree alternating
and or tree
and or tree generalization alternating and or tree restriction
strict alternation nodes relaxed  words intermediate
node child another intermediate node similar parent child
relation allowed node  present algorithm convert and or
equivalent alternating and or tree 
use two operations namely  folding unfolding conversions  corresponding
every edge  stack  update list  used conversions  and or tree  consider
two nodes  vq vr   similar type  and or  connected edge er  
edges  e      ek emanate er  
 folding node    suppose vq vr nodes  folding vr performed
follows 
source edges e      ek changed vr vq costs updated
ce  ei   ce  ei     ce  er     cv  vr     k  new cost sum
old cost cost edge points source ei   triplet
hvr   cv  vr    ce  er  i pushed update list ei     k 
edge er along node vr removed vq  
 folding node    suppose vq vr nodes  folding vr performed follows 
source edges e      ek changed vr vq   one edges among
e      ek   suppose ei   selected arbitrarily cost updated ce  ei  
ce  ei     ce  er     cv  vr     k  triplet hvr   cv  vr    ce  er  i pushed
update list ei   whereas triplet hvr       i pushed update list ej  
  j k j    i 
edge er along node vr removed vq  
unfolding operation reverse folding operation
nodes  works node vq follows 
procedure unfold node vq  
 
 
 
 
 
 
 
 
 
  
  

forall edge ei emanate vq
update list ei empty
hvt   c    c  pop update list ei   
exists edge et vq points node vt
create node vt   connect vt using edge et vq  
cv  vt   c   
ce  et   c   
else c      
ce  et   c   
end
end

   

figenerating ordered solutions explicit and or structures

function convert takes root node and or tree transforms equivalent
alternating and or tree recursively 
function convert vq  
 
 
 
 
 
 

 

every child vq terminal node
vq parent vp type
apply f old operation vq  
end
else
foreach child vr vq   vr intermediate and or node
convert vr   
end

function revert takes root node alternating and or tree converts
original and or tree recursively 
function revert vq  
 
 
 
 
 
 

every child vq terminal node
return 
perform unf old operation vq  
foreach child vr vq
revert vr   
end

overall process generating alternative solutions and or tree follows 
and or tree converted alternating and or tree using convert function 
solutions generated using asg algorithm  solutions transformed back
using revert function  proof correctness presented below 
c   proof correctness
suppose and or tree two nodes  vq vr   similar type  and or 
connected edge er   edges e      ek emanate er   fold operation
  and or tree generated application
applied vq vr   let
f old operation 
lemma c   context mentioned above  present claim following two
propositions 
proposition c   set solutions node vq generated set
  node v applying unfold operation v solutions
solutions
q
q
 
    contains node v   exists soluproposition c   every solution sm
q

 
tion sm generated sm applying unfold vq  

proof   proposition c    present proof following cases  consider
solution sm contains node vq  
   

fighosh  sharma  chakrabarti    dasgupta

a  vq vr nodes  two cases possible 
   vr absent sm   since fold operation modifies edge er only 
    therefore
edges vq present

 
present solution set remain unchanged
application unfold operation 
   vr present sm   since k distinct edges emanating vr  
let one edges  say ei   present sm   prove
      application unfold operation  
solution sm


generate sm   application fold operation node vr modifies source
   
cost edge ei vr vq ce  ei   ce  ei     ce  er     cv  vr  
  solution     edge e present    
suppose sm



 
subtree rooted vq   remaining parts sm
identical
 
 
other  clearly sm exists solution application
  generates  
unfold operation vq sm

b  vq vr nodes  since vq node sm contain
edges emanate vq   therefore edge er vr present
      following holds 
sm   consider solution sm

  
   vq present sm

   subtrees rooted children vq vr sm identical
   
subtrees rooted children vq sm
  identical
   subtree rooted vq   remaining parts sm

other 
  exists solution   application unfold operation v
clearly sm
q

 
sm generates sm  

 
solution sm
contain node vq   valid solution
well 



proof   proposition c    present proof following cases  consider
    contains node v  
solution sm
q

a  vq vr nodes  since vq node  exactly one edge ei vq
    two cases possible 
belong sm
    since fold operation modifies
   ei modified folding vr
edge er edges vr only  edges vq
    since e modified folding  solution
present

 
sm valid solution  
    suppose e connects v v
   ei modified folding vr

q

  generate solution  
 
sm   apply unfold operation node vq sm

edge ei replaced edge er connects vq vr ei
connect vr vi   argue sm valid solution since

   

figenerating ordered solutions explicit and or structures

subtree rooted vi modified sequence  a  folding vr
     b  unfolding v construct    
construct
q



  contain
b  vq vr nodes  since vq node  sm
edges emanate vq   two types edges emanating
   a  type     edges v present
vq
q

vq    b  type     edges added vq folding edges
  generate solution
vr   apply unfold operation node vq sm
sm   sm contain type   edges  another edge er vq   sm   vq vr
connected er type   edges originated vr   argue sm
valid solution since subtree rooted nodes pointed type   edges
   
modified sequence  a  folding vr construct

  
 b  unfolding vq construct sm sm


    contain node v valid solution
clearly solution sm
q


well 



lemma c   function convert applied root node and or tree  
alternating and or tree generated 
proof   lemma c    function convert traverses every intermediate node depth first
manner  consider sequence nodes  vq    vq      vqn type  vqi
parent vqi       n  obviously  fold operation applied vqi  
vqi       n  words  fold operation applied sequence
nodes reverse order folding vqi     edges vqi   modified
moved vqi       n  function call convert vq    returns  edges
vq      vqn already moved vq  sequence nodes  vq    vq      vqn
flattened  therefore  every sequence nodes type flattened  function
call convert vr   returns  vr root alternating and or tree
generated 
lemma c   function revert applied alternating and or tree   updatelist every edge becomes empty 
proof   lemma c    follows description revert 
theorem c   and or tree   possible construct alternating and or
tree using function convert  set possible solutions generated
order increasing cost applying algorithm     converting
individual solutions using function revert 
proof   theorem c    according lemma c    application function convert
alternating and or tree generated  consider intermediate and or
          n
trees generated folding every node   let


n   since generated i  
     
 

sequence and or trees





   

fighosh  sharma  chakrabarti    dasgupta

      n  according
folding exactly one node
generated i   unfolding
solutions

lemma c    solution   revert unfolds every node vq
vq folded convert transforming   therefore
generated solutions  

lemma c   
node  according
solution 
solutions

references
bonet  b     geffner  h          algorithm better ao    proceedings
  th national conference artificial intelligence   volume    pp            aaai
press 
chakrabarti  p  p          algorithms searching explicit and or graphs
applications problem reduction search  artif  intell                  
chakrabarti  p  p   ghose  s   pandey  a     desarkar  s  c          increasing search
efficiency using multiple heuristics  inf  process  lett                  
chang  c  l     slagle  j  r          admissible optimal algorithm searching
and or graphs  artif  intell                 
chegireddy  c  r     hamacher  h  w          algorithms finding k best perfect matchings  discrete applied mathematics                 
chen  h   xu  z  j   liu  z  q     zhu  s  c          composite templates cloth modeling
sketching  proceedings      ieee computer society conference
computer vision pattern recognition   volume    pp          ieee computer
society 
cormen  t  h   stein  c   rivest  r  l     leiserson  c  e          introduction algorithms
  nd edition   mcgraw hill higher education 
darwiche  a          compiling knowledge decomposable negation normal form 
proceedings   th international joint conference artifical intelligence   volume
   pp          morgan kaufmann publishers inc 
darwiche  a          decomposable negation normal form  j  acm             
dasgupta  p   sur kolay  s     bhattacharya  b          vlsi floorplan generation
area optimization using and or graph search  vlsi design         proceedings
 th international conference on  pp          
dechter  r     mateescu  r          and or search spaces graphical models  artif 
intell                    
ebendt  r     drechsler  r          weighted search   unifying view application 
artificial intelligence                      
elliott  p          extracting k best solutions valued and or acyclic graph 
masters thesis  massachusetts institute technology 
elliott  p     williams  b          dnnf based belief state estimation  proceedings
  st national conference artificial intelligence   volume    pp        aaai
press 
   

figenerating ordered solutions explicit and or structures

eppstein  d          finding k smallest spanning trees  proc   nd scandinavian
worksh  algorithm theory  no      lecture notes computer science  pp    
    springer verlag 
eppstein  d          finding k shortest paths  siam j  comput                  
flerova  n     dechter  r          best solutions graphical models   st workshop
constraint reasoning graphical structures 
flerova  n     dechter  r          bucket mini bucket schemes best solutions
graphical models  gkr      a workshop ijcai       
fromer  m     globerson  a          lp view m best map problem  advances
neural information processing systems  nips      pp         
fuxi  z   ming  t     yanxiang  h          solution billiard balls puzzle using ao
algorithm application product development  palade  v   howlett  r    
jain  l   eds    knowledge based intelligent information engineering systems 
vol       lecture notes computer science  pp            springer berlin  
heidelberg 
gogate  v     dechter  r          approximate solution sampling  and counting 
and or spaces  cp  pp         
gu  z   li  j     xu  b          automatic service composition based enhanced service
dependency graph  web services        icws     ieee international conference
on  pp          
gu  z   xu  b     li  j          service data correlation modeling application
data driven service composition  services computing  ieee transactions on        
       
gupta  p   chakrabarti  p  p     ghose  s          towers hanoi  generalizations 
specializations algorithms  international journal computer mathematics     
       
hamacher  h  w     queyranne  m          k best solutions combinatorial optimization
problems  annals operations research            
hansen  e  a     zhou  r          anytime heuristic search  j  artif  intell  res   jair  
           
hansen  e  a     zilberstein  s          lao   heuristic search algorithm finds
solutions loops  artificial intelligence                   
homem de mello  l     sanderson  a          and or graph representation assembly
plans  robotics automation  ieee transactions on                 
jimenez  p     torras  c          efficient algorithm searching implicit and or
graphs cycles  artif  intell            
kleinberg  j     tardos  e          algorithm design  addison wesley longman publishing
co   inc   boston  ma  usa 
lang  q  a     su  y          and or graph search algorithm discovering composite web services  international journal web services research              
   

fighosh  sharma  chakrabarti    dasgupta

lawler  e  l          procedure computing k best solutions discrete optimization
problems application shortest path problem  management science 
        pp         
ma  x   dong  b     he  m          and or tree search algorithm web service composition  paciia     proceedings      ieee pacific asia workshop
computational intelligence industrial application  pp        washington  dc 
usa  ieee computer society 
majumdar  a  a  k          generalized multi peg tower hanoi problem  journal
australian mathematical society  series b  applied mathematics             
marinescu  r     dechter  r          and or branch and bound solving mixed integer
linear programming problems  cp  p      
marinescu  r     dechter  r          memory intensive branch and bound search graphical models  aaai 
marinescu  r     dechter  r       a   best first and or search     integer programming  cpaior  pp         
marinescu  r     dechter  r       b   best first and or search graphical models 
aaai  pp           
marinescu  r     dechter  r       a   and or branch and bound search combinatorial
optimization graphical models  artif  intell                         
marinescu  r     dechter  r       b   memory intensive and or search combinatorial
optimization graphical models  artif  intell                         
martelli  a     montanari  u          additive and or graphs  proceedings
 rd international joint conference artificial intelligence  san francisco  ca  usa 
morgan kaufmann publishers inc 
martelli  a     montanari  u          optimizing decision trees heuristically guided
search  commun  acm               
mateescu  r     dechter  r          and or multi valued decision diagrams constraint
networks  concurrency  graphs models  pp         
mateescu  r   dechter  r     marinescu  r          and or multi valued decision diagrams  aomdds  graphical models  j  artif  intell  res   jair              
mathews  d  h     zuker  m          rna secondary structure prediction  encyclopedia
genetics  genomics  proteomics bioinformatics  john wiley   sons  ltd 
nilsson  d          efficient algorithm finding probable configurations
probabilistic expert systems  statistics computing            
nilsson  n  j          principles artificial intelligence  tioga publishing co 
otten  l     dechter  r          anytime and or depth first search combinatorial
optimization  socs 
pearl  j          heuristics  intelligent search strategies computer problem solving 
addison wesley longman publishing co   inc   boston  ma  usa 
   

figenerating ordered solutions explicit and or structures

russell  s     norvig  p          artificial intelligence  modern approach   nd edition
edition    chap  planning  pp          prentice hall  englewood cliffs  nj 
shiaa  m  m   fladmark  j  o     thiell  b          incremental graph based approach
automatic service composition  ieee international conference services computing              
shin  d  h   jeon  h  b     lee  k  h          sophisticated approach composing
services based action dominance relation  services computing conference  apscc        ieee asia pacific  pp          
subramanian  s          routing algorithms dynamic  intelligent transportation networks  masters thesis  virginia technical univ   dept  civil engineering 
sugimoto  k     katoh  n          algorithm finding k shortest loopless paths
directed network  trans  information processing soc  japan             
japanese 
szymanski  m   barciszewska  m  z   barciszewski  j     erdmann  v  a           s ribosomal rna database  http   biobases ibch poznan pl  sdata   online database 
takkala  t   borndorfer  r     lobel  a          dealing additional constraints
k shortest path problem  proc  wm      
topkis  d  m          k shortest path algorithm adaptive routing communications
networks  trans  communications                 
yan  y   xu  b     gu  z          automatic service composition using and or graph 
e commerce technology fifth ieee conference enterprise computing 
e commerce e services         th ieee conference on  pp         

   


