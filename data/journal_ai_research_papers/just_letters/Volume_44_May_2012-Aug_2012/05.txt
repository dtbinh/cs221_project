journal of artificial intelligence research                  

submitted        published     

algorithms for generating ordered solutions for explicit
and or structures
priyankar ghosh
amit sharma
p  p  chakrabarti
pallab dasgupta

priyankar cse iitkgp ernet in
amit ontop gmail com
ppchak cse iitkgp ernet in
pallab cse iitkgp ernet in

department of computer science and engineering
indian institute of technology kharagpur
kharagpur         india

abstract
we present algorithms for generating alternative solutions for explicit acyclic and or
structures in non decreasing order of cost  the proposed algorithms use a best first search
technique and report the solutions using an implicit representation ordered by cost  in this
paper  we present two versions of the search algorithm   a  an initial version of the best first
search algorithm  asg  which may present one solution more than once while generating
the ordered solutions  and  b  another version  lasg  which avoids the construction of the
duplicate solutions  the actual solutions can be reconstructed quickly from the implicit
compact representation used  we have applied the methods on a few test domains  some of
them are synthetic while the others are based on well known problems including the search
space of the   peg tower of hanoi problem  the matrix chain multiplication problem and
the problem of finding secondary structure of rna  experimental results show the efficacy
of the proposed algorithms over the existing approach  our proposed algorithms have
potential use in various domains ranging from knowledge based frameworks to service
composition  where the and or structure is widely used for representing problems 

   introduction
the use of and or structures for modeling and solving complex problems efficiently
has attracted a significant amount of research effort over the last few decades  initially 
and or search spaces were mostly used in problem reduction search for solving complex
problems  logical reasoning and theorem proving  etc   where the overall problem can be
hierarchically decomposed into conjunction and disjunction of subproblems  pearl       
nilsson         subsequently  and or structures were also applied in a variety of domains  e g   for representing assembly plans  homem de mello   sanderson         generating vlsi floor plans  dasgupta  sur kolay    bhattacharya         puzzle solving  fuxi 
ming    yanxiang         etc  traditionally the algorithm ao   pearl        nilsson       
martelli   montanari              chang   slagle        has been used for searching implicitly defined and or structures  an empirical study of ao  can be found in bonet
and geffners        work 
in the recent past there has been a renewed research interest towards the application
of and or structures  in various planning problems  including conditional planning to
handle uncertainty  the and or structure  russell   norvig        is a natural form

c
    
ai access foundation  all rights reserved 

fighosh  sharma  chakrabarti    dasgupta

for representation  the problem of generating solutions for such representations has been
studied extensively  hansen   zilberstein        jimenez   torras        chakrabarti 
       dechter and mateescu        have presented the explicit and or search space
perspective for graphical models  different search strategies  best first  branch and bound 
etc   over the and or search spaces in graphical models are discussed by marinescu and
dechter      b         and or search spaces are also used for solving mixed integer
linear programming  marinescu   dechter             integer programming  marinescu
  dechter      a   combinatorial optimization in graphical models  marinescu   dechter 
    a      b   and or multivalued decision diagrams  aomdd   which combine the
idea of multi valued decision diagrams mdd  and and or structures  is presented by
mateescu  dechter  and marinescu        and further research along this direction can
be found in the work of mateescu and dechter         and or search spaces are also
applied for solution sampling and counting  gogate   dechter         smooth deterministic decomposable negative normal forms  sd dnnf   darwiche        exhibit explicit
and or dag structure and have been used for various applications including compiling
knowledge  darwiche         estimating belief states  elliott   williams         etc 
apart from the domains of planning  constraint satisfaction  knowledge based reasoning 
etc   and or structure based techniques are also widely used for various application based
domains  e g   web service composition  gu  xu    li        shin  jeon    lee        gu 
li    xu        ma  dong    he        yan  xu    gu        lang   su         vision
and graphics tasks  chen  xu  liu    zhu         etc  lang and su        have described
an and or graph search algorithm for composing web services for user requirements  ma
et al         have advocated the use of and or trees to capture dependencies between the
inputs and outputs of the component web services and propose a top down search algorithm
to generate solutions of the and or tree  further research that uses and or structures
in the context of web service composition can be found in the works of gu et al        
       shin et al         and yan et al          chen et al         have applied explicit
and or structures for cloth modeling and recognition which is an important problem in
vision and graphics tasks 
such recent adoption of and or search spaces for a wide variety of ai problems
warrants further research towards developing suitable algorithms for searching and or
structures from different perspectives  in the general setting  the fundamental problem
remains to find the minimum cost solution of and or structures  for a given explicit
and or graph structure  the minimum cost solution is computed using either a topdown or a bottom up approach  these approaches are based on the principle of dynamic
programming and have complexity which is linear with respect to the size of the search
space  finding a minimum cost solution of an explicit and or structure is a fundamental
step for the approaches that use an implicit representation and systematically explore the
search space  this is particularly the case for ao   nilsson        where the potential
solution graph  psg  is recomputed every time from the current explicit graph after a node
is expanded  in view of recent research where and or structures are used and leveraged
in a wide variety of problems ranging from planning domain to web service composition 
the need for generating an ordered set of solutions of a given and or structure becomes
imminent  we briefly mention some areas where ordered solutions are useful 

   

figenerating ordered solutions for explicit and or structures

ordered set of solutions of an explicit and or dag can be used to develop useful
variants of the ao  algorithm  currently in ao   only the minimum cost solution is computed whereas several variants of the a  algorithm exist  where solutions are often sought
within a factor of cost of the optimal solution  these approaches  ebendt   drechsler       
pearl        were developed to adapt the a  algorithm for using inadmissible heuristics 
leveraging multiple heuristics  chakrabarti  ghose  pandey    desarkar         generating
solutions quickly within bounded sub optimality  etc  typically these techniques order the
open list using one evaluation function  and the next element for expansion is selected from
an ordered subset of open using some other criterion  similar techniques can be developed
for ao  search if ordered set of potential solutions are made available  that set can be
used for node selection and expansion instead of expanding nodes only from the current
best psg  this opens up an interesting area with significant research potential where the
existing variations of the a  algorithm can be extended for and or search spaces 
in the context of model based programming  the problem of finding ordered set of
solutions has significant importance  elliott        has used valued sd dnnfs to represent
the problem and proposed an approach to generate k best solutions  since valued sd dnnfs
have an and or structure  the proposed approach is possibly the earliest algorithm for
generating ordered set of solutions of an and or structure  the problem of finding
ordered set of solutions for graphical models is studied by flerova and dechter              
however these techniques use alternative representations for the algorithm  where and or
search spaces can be constructed  dechter   mateescu        for graphical models  recent
research involving aomdd based representation on weighted structures suggested future
extensions towards generalizing algebraic decision diagrams and introduces the notion of
cost in aomdds  we envisage that ordered set of solutions finds useful applications in the
context of research around and or decision diagram based representation 
in the domain of service composition  the primary motivation behind providing a set of
alternative solutions ordered by cost is to offer more choices  while trading off the specified
cost criterion  to a limited extent  in favor of other unspecified criteria  primarily from
the standpoint of quality   shiaa  fladmark  and thiell        have presented an approach
for generating a ranked set of solutions for the service composition problem  typically the
quality criteria are subjective in nature and difficult to express in terms of a single scalar cost
function which is able to combine the cost price and the quality aspects together  these
aspects of quality are often encountered in the context of serving custom user requirements
where the user prefers to minimize the cost price of the solution while preserving his her
preferences  for example  for booking a holiday package for a specific destination  a travel
service portal typically offers a list of packages with various combinations of attractions 
hotel options and meal plans ordered by a single cost criterion  namely  the cost of the
package  in general any product solution that is composed of a number of components has
a compositional flavor similar to service composition and it becomes important to present
the user a set of alternative solutions ordered by cost so that he she can select the best
alternative according to his her preferences 
dynamic programming formulations typically have an underlying and or dag structure  which had been formally studied in the past  martelli   montanari         besides
classical problems like matrix chain multiplication  many other real world optimization problems offer dynamic programming formulations  where alternative solutions ordered by cost
   

fighosh  sharma  chakrabarti    dasgupta

are useful in practice  one example of such a problem is finding the secondary structure of
rna  mathews   zuker        which is an important problem in bioinformatics  rnas
may be viewed as sequences of bases belonging to the set  adenine a   cytocine c   guanine g   uracil u    rna molecules tend to loop back and form base pairs with itself and
the resulting shape is called the secondary structure  the primary factor that influences the
secondary structure of rna is the number of base pairings  higher number of base pairings generally implies more stable secondary structure   under the well established rules
for base pairings  the problem of maximizing the number of base pairings has an interesting dynamic programming formulation  however  apart from the number of base pairings 
there are other factors that influence the stability  but these factors are typically evaluated
experimentally  therefore  for a given rna sequence  it is useful to compute a pool of
candidate secondary structures  in decreasing order of the number of base pairings  that
may be subjected to further experimental evaluation in order to determine the most stable
secondary structure 
the problem of generating ordered set of solutions is well studied in other domains 
for discrete optimization problems  lawler        had proposed a general procedure for
generating k best solutions  a similar problem of finding k most probable configurations in
probabilistic expert systems is addressed by nilsson         fromer and globerson       
have addressed the problem of finding k maximum probability assignments for probabilistic modeling using lp relaxation  in the context of ordinary graphs  eppstein        has
studied the problem of finding k smallest spanning trees  subsequently  an algorithm for
finding k best shortest paths has been proposed in eppsteins        work  hamacher and
queyranne        have suggested an algorithm for k best solutions to combinatorial optimization problems  algorithms for generating k best perfect matching are presented by
chegireddy and hamacher         other researchers applied the k shortest path problem
to practical scenarios  such as  routing and transportation  and developed specific solutions
 takkala  borndorfer    lobel        subramanian        topkis        sugimoto   katoh 
       however none of the approaches seems to be directly applicable for and or structures  recently some schemes related to ordered solutions to graphical models  flerova  
dechter              and anytime and or graph search  otten   dechter        have
been proposed  anytime algorithms for traditional or search space  hansen   zhou       
are well addressed by the research community 
in this paper  we address the problem of generating ordered set of solutions for explicit
and or dag structure and present new algorithms  the existing method  proposed
by elliott         works bottom up by computing k best solutions for the current node
from the k best solutions of its children nodes  we present a best first search algorithm 
named alternative solution generation  asg  for generating ordered set of solutions  the
proposed algorithm maintains a list of candidate solutions  initially containing only the
optimal solution  and iteratively generates the next solution in non decreasing order of cost
by selecting the minimum cost solution from the list  in each iteration  this minimum cost
solution is used to construct another set of candidate solutions  which is again added to the
current list  we present two versions of the algorithm 
a  basic asg  will be referred to as asg henceforth    this version of the algorithm
may construct a particular candidate solution more than once 

   

figenerating ordered solutions for explicit and or structures

b  lazy asg or lasg   another version of asg algorithm that constructs every candidate solution only once 
in these algorithms  we use a compact representation  named signature  for storing the
solutions  from the signature of a solution  the actual explicit form of that solution can
be constructed through a top down traversal of the given dag  this representation allows
the proposed algorithms to work in a top down fashion starting from the initial optimal
solution  another salient feature of our proposed algorithms is that these algorithms work
incrementally unlike the existing approach  our proposed algorithms can be interrupted at
any point of time during the execution and the set of ordered solutions obtained so far can
be observed and subsequent solutions will be generated when the algorithms are resumed
again  moreover  if an upper limit estimate on the number of solutions required is known a
priori  our algorithms can be further optimized using that estimate 
the rest of the paper is organised as follows  the necessary formalisms and definitions
are presented in section    in section    we address the problem of generating ordered set of
solutions for trees  subsequently in section    we address the problem of finding alternative
solutions of explicit acyclic and or dags in non decreasing order of cost  we present two
different solution semantics for and or dags and discuss the existing approach as well as
our proposed approach  along with a comparative analysis  detailed experimental results 
including the comparison of the performance of the proposed algorithms with the existing
algorithm  elliott         are presented in section    we have used randomly constructed
trees and dags as well as some well known problem domains including the   peg tower
of hanoi problem  the matrix chain multiplication problem and the problem of finding
the secondary structure of rna as test domain  the time required and the memory used
for generating a specific number of ordered solutions for different domains are reported in
detail  in section    we outline briefly about applying the proposed algorithms for implicitly
specified and or structures  finally we present the concluding remarks in section   

   definitions
in this section  we describe the terminology of and or trees and dags followed by other
definitions that are used in this paper  g   hv  ei is an and or directed acyclic graph 
where v is the set of nodes and e is the set of edges  here  and  in g refer to the
and nodes and or nodes in the dag respectively  the direction of edges in g is from
the parent node to the child node  the nodes of g with no successors are called terminal
nodes  the non terminal nodes of g are of two types  i  or nodes and ii  and nodes  
v and v are the set of and and or nodes in g respectively  and n    v    n    v   
and n    v    the start  or root  node of g is denoted by vr   or edges and and edges
are the edges that emanate from or nodes and and nodes respectively 
definition   a  solution graph  a solution graph  s vq    rooted at any node vq  v   is a
finite sub graph of g defined as 
a  vq is in s vq   
b  if vq is an or node in g and vq is in s vq    then exactly one of its immediate
successors in g is in s vq   
c  if vq is an and node in g and vq is in s vq    then all its immediate successors in
g are in s vq   
   

fighosh  sharma  chakrabarti    dasgupta

d  every maximal  directed  path in s vq   ends in a terminal node 
e  no node other than vq or its successors in g is in s vq   
by a solution graph s of g we mean a solution graph with root vr  




definition   b  cost of a solution graph  in g   every edge eqr  e from node vq to
node vr has a finite non negative cost ce  hvq   vr i  or ce  eqr    similarly every node vq has a
finite non negative cost denoted by cv  vq    the cost of a solution s is defined recursively
as follows  for every node vq in s  the cost c s  vq   is 


cv  vq    if vq is a terminal node 



 


cv  vq     c s  vr     ce  hvq   vr i    where vq is an or node  and

c s  vq    
vr is the successor of vq in s 

 
p


c s  vj     ce  hvq   vj i    where    j  k  vq is an and node
cv  vq    




with degree k  and v            vk are the immediate successors of vq in s 
therefore the cost of a solution s is c s  vr   which is also denoted by c s   we denote
the optimal solution below every node vq as opt vq    therefore  the optimal solution of the
entire and or dag g   denoted by sopt   is opt vr    the cost of the optimal solution
rooted at every node vq in g is copt  vq    which is defined recursively  for minimum cost
objective functions  as follows 


cv  vq    if vq is a terminal node 



 



cv  vq     min copt  vj     ce  hvq   vj i    where    j  k  vq is an or node
copt  vq    
with degree k  and v            vk are the immediate successors of vq in g  


 

cv  vq     p copt  vj     ce  hvq   vj i    where    j  k  vq is an and node




with degree k  and v            vk are the immediate successors of vq in g  
the cost of the optimal solution sopt of g is denoted by copt  vr   or  alternatively  by
copt  sopt    when the objective function needs to be maximized  instead of the min function 
the max function is used in the definition of copt  vq   



it may be noted that it is possible to have more than one solution below an or node
vq to qualify to be the optimal one  i e   when they have the same cost  and that cost is the
minimum  ties for the optimal solution below any such or node vq are resolved arbitrarily
and only one among the qualifying solutions  determined after tie breaking  is marked as
opt vq   
an and or tree  t   hv  ei  is an and or dag and additionally satisfies the
restrictions of a tree structure i e   there can be at most one parent node for any node vq
in t   in the context of and or trees  we use eq to denote the edge that points to
the vertex vq   an alternating and or tree  t   hv  ei  is an and or tree with the
restriction that there is an alternation between the and nodes and the or nodes  every
child of an and node is either an or node or a terminal node  and every children of an or
node is either an and node or a terminal node  we use the term solution tree to denote
the solutions of and or trees 
we also discuss a different solution semantics  namely tree based semantics  for and or
dags  every and or dag can be converted to an equivalent and or tree by traversing
   

figenerating ordered solutions for explicit and or structures

the intermediate nodes in reverse topological order and replicating the subtree rooted at
every node whenever the in degree of the traversed node is more than    the details are
shown in procedure convertdag  suppose an and or dag g is converted to an
equivalent and or tree t   we define the solutions of t as the solutions of g under
tree based semantics 
procedure convertdag g  
input   an and or dag g
output  an equivalent and or tree t
  construct a list m   of non terminal nodes of g   sorted in the reverse topological
order 
  while m is not empty do
 
vq  remove the first element of m  
   suppose ein  vq   is the list of incoming edges of vq
  
 
if indegree vq       then
 
for i    to indegree vq   do
 
et  ein  vq   i  
replicate
the sub tree rooted at vq with vq as the root 
 
modify the target node of et from vq to vq  
 
 
end
  
end
   end
in this paper we use the solution semantics defined in definition   a as the default
semantics for the solutions of and or dags  when the tree based semantics is used  it
is explicitly mentioned 
    example

     

h i
     

v 

v 

v 

h i

h i

h i

v 

     

v 

v 

    

h i

v 

h i

h i

v 

     

v 
h i

h i

h i

h i

v 

v  

v  

v  

v  

v  

v  

v 

v  

 

 

 

 

  

  

  

 

 

figure    alternating and or tree
   

v 

     

v 

    

h i

h i

h i

h i

h i

v 
h i

     

h i

v 

  

  
h i

v 

     

v 

v 

     

h i

h i

h i

  
h i

     

  

h i

figure    and or dag

  

fighosh  sharma  chakrabarti    dasgupta

we present an example of an alternating and or tree in figure    in the figure  the
terminal nodes are represented by a circle with thick outline  and nodes are shown in the
figures with their outgoing edges connected by a semi circular curve in all the examples 
the edge costs are shown by the side of each edge within an angled bracket  the cost of the
terminal nodes are shown inside a box  for every non terminal node vq   the pair of costs 
cv  vq   and copt  vq    is shown inside a rectangle 
in figure   the optimal solution below every node is shown using by thick dashed edges
with an arrow head  the optimal solution of the and or tree can be traced by following
these thick dashed edges from node v    the cost of the optimal solution tree is     also 
figure   shows an example of a dag  the cost of the optimal solution dag is    

   generating ordered solutions for and or trees
in this section we address the problem of generating ordered solutions for trees  we use
the notion of alternating and or trees  defined in section    to present our algorithms 
an alternating and or tree presents a succinct representation and so the correctness
proofs are much simpler for alternating and or trees  in appendix c we show that every
and or tree can be converted to an equivalent alternating and or tree with respect to
the solution space 
it is worth noting that the search space of some problems  e g  the search space of multipeg tower of hanoi problem  exhibit the alternating and or tree structure  moreover  the
algorithms that are presented for alternating and or trees work without any modification
for general and or trees  in this section  first we present the existing algorithm  elliott 
      briefly  and then we present our proposed algorithms in detail 
    existing bottom up evaluation based method for computing alternative
solutions
we illustrate the working of the existing method that is proposed by elliott        for
computing alternative solutions for trees using an example of an alternating and or tree 
this method  will be referred as bu henceforth  computes the k best solutions in a bottomup fashion  at every node  vq   k best solutions are computed from the k best solutions of
the children of vq   the overall idea is as follows 
a  for an or node vq   a solution rooted at vq is obtained by selecting a solution of a
child  therefore k best solutions of vq are computed by selecting the top k solutions
from the entire pool consisting of all solutions of all children 
b  in the case of and nodes  every child of an and node vq will have at most k solutions 
a solution rooted at an and node vq is obtained by combining one solution from every
child of vq   different combinations of the solutions of the children nodes of vq generate
different solutions rooted at vq   among those combinations  top k combinations are
stored for vq  
in figure   we show the working of the existing algorithm  at every intermediate node
  best solutions are shown within rounded rectangle  at every or node vq   the ith  best
cost  for
solution rooted at vq is shown as a triplet of the form    z 
i     child  solidx      z 
 z
 
 
example  at node v  the second best solution is shown as      hv     i      which means
   

figenerating ordered solutions for explicit and or structures

that the  nd best solution rooted at v  is obtained by selecting the  nd best solution of v   
similarly  at every and node vq   the ith solution rooted at vq is shown as a triplet of the
form  i    sol vec   cost triplets  here sol vec is a comma separated list of solution indices
such that every element of sol vec corresponds to a child of vq   the j th element of sol vec
shows the index of the solution of j th child  for example  the  nd best solution rooted at v 
is shown as                  this means the  nd best solution rooted at v  is computed using
the  nd best solution of the  st child  which is v    and the best solution   st   of the  nd
child  which is v     which index of sol vec corresponds to which child is shown by placing
the child node name above every index position 

     

h i

     

v 

h i

    

v 

    hv     i    
    hv     i    

v 

h i

h i

v  v 
              
              

v 

     

  

h i

    hv     i   
    hv      i    

v  v 
              
              

v 

h i

h i

v 

     

v 

    hv      i    
    hv      i    

  

h i

h i

v 

     

h i

h i

    hv      i    
    hv      i    
h i

h i

h i

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    example working of the existing algorithm
the existing method works with the input parameter k  i e   the number of solutions to
be generated have to be known a priori  also this method is not inherently incremental in
nature  thus does not perform efficiently when the solutions are needed on demand  e g   at
first  top    solutions are needed  then the next    solutions are needed  in this case the
top    solutions will have to be recomputed while computing next    solutions  i e   from
the   st solution to the   th solution  next we present our proposed top down approach
which does not suffer from this limitation 
    top down evaluation algorithms for generating ordered solutions
so far we have discussed the existing approaches which primarily use bottom up approach
for computing ordered solutions  now we propose a top down approach for generating alternative solutions in the non decreasing order of cost  it may be noted that the top down
   

fighosh  sharma  chakrabarti    dasgupta

approach is incremental in nature  we use an edge marking based algorithm  alternative
solution generation  asg   to generate the next best solutions from the previously generated solutions  in the initial phase of the asg algorithm  we compute the optimal solution
for a given alternating and or tree t and perform an initial marking of all or edges 
the following terminology and notions are used to describe the asg algorithm  in the
context of and or trees  we use eq to denote the edge that points to the vertex vq   we
will use the following definitions for describing our proposed top down approaches 
definition   c  aggregated cost  in an and or dag g   the aggregated cost  ca   for
an edge eij from node vi to node vj   is defined as   ca  eij     ce  eij     copt  vj   


v 

     

 e      

       

h i

     

       

v 

h i

h i

 e      

v 

     

v 

  
h i

    

h i

v 

h i

v 

     

h i

v 

v 

     

  
 e       

 e      
h i

        

h i

h i

 e       
h i

         

h i

 e        h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    example of or edge marking and swap option
marking of an or edge   the notion of marking an or edge is as follows  for an or
node vq   l vq   is the list of or edges of vq sorted in non decreasing order of the aggregated
cost of the edges  we define  i i    as the difference between the cost of or edges  ei and
ei     such that ei and ei   emanate from the same or node vq   and ei   is the edge next to
ei in l vq    procedure markor describes the marking process for the or edges of an or
node  intuitively  a mark represents the cost increment incurred when the corresponding
edge is replaced in a solution by its next best sibling  the or edge having maximum
aggregated cost is not marked 
consider a solution  scur   containing the edge ei    vq   vi    where ei  eopt  scur    we
mark ei with the cost increment which will be incurred to construct the next best solution
from scur by choosing another child of vq   in figure   the marks corresponding to or edges
e    e    e    e     e     and e   are  e         e         e         e          e         and  e        
   

figenerating ordered solutions for explicit and or structures

procedure markor vq  
 

 
 
 
 
 
 
 

construct l vq        list of or edges of vq sorted in the non decreasing order of ca
values   
count  number of elements in l vq    
for i    to i   count    do
ec  l vq   i   
en  l vq   i       
tmp    ca  en    ca  ec     
mark ec with the pair  en   tmp    
end

definition   d  swap option  a swap option ij is defined as a three tuple hei   ej   ij i
where ei and ej emanate from the same or node vq   ej is the edge next to ei in l vq    and
ij   ca  ej    ca  ei    also  we say that the swap option ij belongs to the or node vq   


consider the or node vq and the sorted list l vq    it may be observed that in l vq  
every consecutive pair of edges forms a swap option  therefore  if there are k edges in l vq   
k  swap options will be formed  at node vq   these swap options are ranked according to the
rank of their original edges in l vq    in figure   the swap options are           he    e     i 
        he    e     i           he    e      i            he     e      i            he     e      i  and
          he     e      i  consider the node v  where l v      he    e    e  i  therefore  the swap
options        and         belong to v    at node v    the rank of       and       are   and  
respectively 
definition   e  swap operation  swap operation is defined as the application of a swap
option ij   hei   ej   ij i to a solution sm that contains the or edge ei in the following way 
   edge e is
a  remove the subtree rooted at vi from sm   let the modified tree be sm
i
the original edge of ij  
   which is constructed at the previous step  let the
b  add the subtree opt vj   to sm
   edge e is the swapped edge of   
newly constructed solution be sm
j
ij
 from s when
intuitively  a swap operation ij   hei   ej   ij i constructs a new solution sm
m

sm contains the or edge ei   moreover  the cost of sm is increased by ij compared to cost
of sm if c sm   vi     copt  vi   



our proposed algorithms use a swap option based compact representation  named signature  for storing the solutions  intuitively  any alternative solution can be described as a
set of swap operations performed on the optimal solution sopt   it is interesting to observe
that while applying an ordered sequence of swap options  h         k i  the application of
each swap operation creates an intermediate alternative solution  for example  when the
first swap option in the sequence      is applied to the optimal solution  sopt   a new solution  say s    is constructed  then  when the  nd swap option      is applied to s    yet
another solution s  is constructed  let si denote the solution obtained by applying the
swap options           i   on sopt in this sequence  although  an ordered sequence of swap
options  like h         k i  can itself be used as a compact representation of an alternative
solution  the following key points are important to observe 
a  among all possible sequences that generate a particular solution  we need to preclude
those sequences which contain redundant swap options  those swap options whose orig   

fighosh  sharma  chakrabarti    dasgupta

inal edge is not present in the solution to which it is applied   this is formally defined
later as superfluous swap options  also the order of applying the swap options is another important aspect  there can be two swap options  i and j where    i   j  k
such that the source edge of j belongs to the sub tree which is included in the solution
si only after applying i to si    in this case  if we apply j at the place of i   i e  
apply j directly to si    it will have no effect as the source edge of j is not present
in si    i e   after swapping the location of i and j in the sequence  j becomes a
redundant swap option and the solution constructed would be different for the swapped
sequence from the original sequence  we formally define an order relation on a pair of
swap options based on this observation in the later part of this section and formalize
the compact representation of the solutions based on that order relation 
b  suppose the swap option j belongs to a node vpj   now it is important to observe
that the application of j on sj  to construct sj   invalidates the application of all
other swap options that belong to an or edge in the path from the root node to vpj in
the solution sj   this is because in sj the application of any such swap option which
belongs to an or edge in the path from the root node to vpj would make the swap at
vpj redundant  in fact  for each swap option i belonging to node vpi   where    i  j 
the application of all other swap options that belong to an or edge in the path from
the root node to vpi is invalidated in the solution sj for the same reason  this condition
restricts the set of swap options that can be applied on a particular solution 
c  finally  there can be two swap options i and j for    i   j  k such that i and
j are independent of each other  that is   a  applying i to si  and subsequently the
application of j to sj    and  b  applying j to si  and subsequently the application
of i to sj    ultimately construct the same solution  this happens only when the
original edges of both i and j are present in si    thus application of one swap option
does not influence the application of the other  however  it is desirable to use only one
way to generate solution sj   in section      we propose a variation of the top down
approach  called lasg  which resolves this issue 
definition   f  order relation r  we define an order relation  namely r  between a pair
of swap options as follows 
a  if there is a path from vi to vr in t   where ei and er are or edges  qi and rj are
swap options  then  qi   rj    r  for example  in figure                       r 
b  if pq   hep   eq   pq i and rt   her   et   rt i are two swap options such that vq   vr  
then  pq   rt    r  in figure                     r 


implicit representation of the solutions   we use an implicit representation for
storing every solution other than the optimal one  these other solutions can be constructed
from the optimal solution by applying a set of swap options to the optimal solution in the
following way  if  i   j    r  i has to be applied before j   therefore  every solution is
represented as a sequence  of swap options  where i appears before j in  if  i   j    r 
intuitively the application of every swap option specifies that the swapped edge will be the
part of the solution  since the swap options are applied in the specific order r  it may so
happen that an or edge which had become the part of solution due to the application of an
earlier swap option and may get swapped out due to the application of a later swap option 
   

figenerating ordered solutions for explicit and or structures

definition   g  superfluous swap option  consider a sequence of swap options   
h         m i corresponding to a solution sm   clearly it is possible for a swap option  i  
where    i  m  to be present in the sequence such that the original edge of i is not
present in the solution si  which is constructed by the successive applications of swap
options          i  to solution sopt   now the application of i has no effect on si    i e  
solution si is identical to solution si    each such swap option i is a superfluous swap
option with respect to the sequence  of swap options corresponding to solution sm  


property     the sequence of swap options corresponding to a solution is minimal  if it
has no superfluous swap option 
this property follows from the definition of superfluous swap options and the notion of the
implicit representation of a solution 
definition   h  signature of a solution  the minimal sequence of swap options corresponding to a solution  sm   is defined as the signature  sig sm    of that solution  it
may be noted that for the optimal solution sopt of any alternating and or tree t  
sig sopt         i e   an empty sequence  it is possible to construct more than one signature
for a solution  as r is a partial order  it is important to observe that all different signatures
for a particular solution are of equal length and the sets of swap options corresponding to
these different signatures are also equal  therefore the set of swap options corresponding
to a signature is a canonical representation of the signature  henceforth we will use the set
notation for describing the signature of a solution 
v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

    

h i

v 

h i

h i

v 

     

v 

v 

     

  
h i

h i
h i 
        

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    a solution  s    of the and or tree shown in figure  
in figure   we show a solution  say s    of the and or tree shown in figure    the
solution is highlighted using thick dashed lines with arrow head  the pair  cv  vq    c s    vq   
   

fighosh  sharma  chakrabarti    dasgupta

is shown within rectangles beside each node vq in solution s    and we have used the rectangles with rounded corner whenever c s    vq      copt  vq    since s  is generated by applying
the swap option       to solution sopt   the signature of s    sig s      h      i  consider
another sequence      h               i  of swap options  it is worth noting that   also
represents the solution s    here the second swap option in     namely        can not be
applied to the solution constructed by applying       to sopt as the source edge of         
e    is not present in that solution  hence        is a superfluous swap option for    
definition   i  vopt and eopt   for any solution graph sm of an and or dag g   we
define a set of nodes 
 fivopt  sm    and a set of or edges  eopt  sm    as 
a  vopt  sm     vq fi vq in sm and solution graph sm  vq   is identical to the solution graph
opt vq  
fi

 
b  eopt  sm     epr fi or edge epr in sm   and vr  vopt  sm  
clearly  for any node vq  vopt  sm    if vq is present in sopt   then   a  the solution graph
sm  vq   is identical to the solution graph sopt  vq    and  b  c sm   vq     copt  vq  


definition   j  swap list  the swap list corresponding to a solution sm   l sm    is the list
of swap options that are applicable to sm   let sig sm               m   and i     i  m 
each swap option i belongs to node vpi   the application of all other swap options that
belong to the or edges in the path from the root node to vpi is invalidated in the solution
sm   hence  only the remaining swap options that are not invalidated in sm can be applied
to sm for constructing the successor solutions of sm  
it is important to observe that for a swap option i   if the source edge of i belongs
to eopt  sm    the application is not invalidated in sm   hence  for a solution sm   we construct l sm   by restricting the swap operations only on the edges belonging to eopt  sm   
moreover  this condition also ensures that the cost of a newly constructed solution can be
computed directly form the cost of the parent solution and the  value of the applied swap
 is constructed form s
option  to elaborate  suppose solution sm
m by applying jk   the

     c s     
cost of sm can be computed directly form c sm   and jk as   c sm
m
jk if
ej  eopt  sm    procedure computeswaplist sm   describes the details of computing swap
options for a given solution sm  


procedure computeswaplist sm 
 
 
 

 
 
 

l sm      compute eopt  sm   
foreach or edge ec in eopt  sm   do
if there exists a swap option on edge ec then
   suppose ec emanates from or node vq such that ec   l vq   i   also ec is
marked with the pair htmp   en i  where en   l vq   i     
  
cn  hec   en   tmp i  add cn to l sm   
end
end

the swap list of the optimal solution  l sopt    in figure    is                    in the
solution s    shown in figure    vopt    v    v      because except node v  and v     for all
other nodes vi in s    opt vi      s   vi    here also rectangles with rounded corner are used
when c s    vq      copt  vq    therefore  eopt    e    e      since there exists no swap option
   

figenerating ordered solutions for explicit and or structures

v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

     

h i

v 

h i

v 

     

h i

v 

v 

     

  
h i
h i 
        

h i

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure    a solution  s    of the and or tree shown in figure  
on the or edges  e  and e     the swap list of solution s    l s        hence  for a solution
sm   l sm   may be empty  though vopt  sm   can never be empty 
although we use the notation ij to denote a swap option with edge ei as the original
edge and edge ej as the swapped edge  for succinct representation  we also use  with a single
subscript  such as     k   ij etc   to represent a swap option  this alternative representation
of swap options does not relate to any edge 
definition   k  successors and predecessors of a solution  the set of successors and
predecessors of a solution
fi sm is defined as 
 fi s  can be constructed from s
a  succ sm      sm
m by applying a swap option that
m
belongs to the swap
fi list of sm  
 fi s  succ s    


b  p red sm      sm
m
m

property     for any solution sm of an alternating and or tree t the following state  p red s    c s     c s  
ment holds  sm
m
m
m

the property follows from the definitions  one special case requires attention  consider
     c s   and s   p red s    this case can only arise when a swap
the case when c sm
m
m
m
option of cost   is applied to sm   this occurs in the case of a tie 
      asg algorithm
we present asg  a best first search algorithm  for generating solutions for an alternating
and or tree in non decreasing order of costs  the overall idea of this algorithm is as
follows  we maintain a list  open  which initially contains only the optimal solution sopt  
at any point of time open contains a set of candidate solutions from which the next best
   

fighosh  sharma  chakrabarti    dasgupta

solution in the non decreasing order of cost is selected  at each iteration the minimum cost
solution  smin   in open is removed from open and added to another list  named  closed 
the closed list contains the set of ordered solutions generated so far  then the successor
set of smin is constructed and any successor solution which is not currently present in
open as well as is not already added to closed is inserted to open  however as a further
optimization  we use a sublist of closed  named tlist  to store the relevant portion of closed
such that checking with respect to the solutions in tlist is sufficient to figure out whether
the successor solution is already added to closed  it is interesting to observe that this
algorithm can be interrupted at any time and the set of ordered solutions computed so far
can be obtained  also  the algorithm can be resumed if some more solutions are needed 
the details of asg algorithm are presented in algorithm   
algorithm    alternative solution generation  asg  algorithm

 

 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  

input   an alternating and or tree t
output  alternative solutions of t in the non decreasing order of cost
compute the optimal solution sopt   perform or edge marking and populate the
swap options 
create three lists  open  closed  and tlist  that are initially empty 
put sopt in open 
lastsolcost  c sopt   
while open is not empty do
smin  remove the minimum cost solution from open  
if lastsolcost   c smin   then
remove all the elements of tlist 
lastsolcost  c smin   
end
add smin to closed and tlist 
compute the swap list  l smin    of smin  
   construct succ smin   using l smin   and add new solutions to open
  
foreach ij  l smin   do
construct sm by applying ij to smin  
construct the signature of sm   sig sm    by concatenating ij after sig smin   
   check whether sm is already present in open or in tlist
  
if  sm not in open  and  sm not in tlist  then
add sm to open 
end
end
report the solutions in closed 

the pseudo code from line   to line   computes the optimal solution sopt   performs the
marking of or edges  populates the swap options  and initializes open  closed and tlist 
the loop in line    is responsible for generating a new solution every time it is executed
as long as open is not empty  in line   of the asg algorithm  the solution that is the
current minimum cost solution in open  smin   is selected and removed from open  the
tlist is populated and maintained from line   to line     the loop in line    generates

   

figenerating ordered solutions for explicit and or structures

the successor solutions of smin one by one and adds the newly constructed solutions to
open if the newly constructed solution is not already present in open as well as not added
to tlist  line    does the checking   the proof of correctness of algorithm   is presented
in appendix a  we discuss the following issues related to algorithm   
checking for duplication   in order to check whether a particular solution si is already
present in open or tlist  the signature of si is matched with the signatures of the solutions
that are already present in open and tlist  it is sufficient to check the equality between the
set of swap options in the respective signatures because that set is unique for a particular
solution  it may be noted that tlist is used as an optimization  which avoids searching the
entire closed list 
resolving ties   while removing the minimum cost solution from the open list  a tie
may be encountered among a set of solutions  suppose there is a tie among the set stie  
 s         sk    the ties are resolved in the favor of the predecessor solutions  that is 
 

si   sj  stie    if si is the predecessor of sj     si is removed before sj  
for all other cases the ties are resolved arbitrarily in the favor of the solution which was
added to open first 
      working of asg algorithm
we illustrate the working of the asg algorithm on the example and or tree shown in
figure    the contents of the different lists obtained after first few iterations of outermost
while loop are shown in table    we use the signature of a solution for representation
purpose  the solutions that are already present in open and also constructed by expanding
the current smin   are highlighted with under braces 
it 
 
 
 
 

smin
  
         
        
                

l smin  
              

     
                 

 

                
         

                 

 

                

       

         

 

                
                   

       

open
                   
        
                
                           
                          
                           
                                    
                                    
                                     
 
 z
 
                                    

closed
  
             
                       
                        
                
                        
                
                          
                        

tlist
  
         
        
                
                
         
               

                
         
                          
                          
                                                              
                
                          
                
                   
                   
                          
                          
                          
         

table    working of asg algorithm
   

fighosh  sharma  chakrabarti    dasgupta

before entering the outermost while loop  line     asg computes the optimal solution
sopt   populates the swap options  and inserts sopt to open  thus  at this point of time  open
contains only the optimal solution sopt   closed and tlist are empty  in the first iteration
sopt  the signature of sopt is     is selected and removed from open  then the swap list of
sopt   l sopt    is computed  l sopt    consists of two swap options  namely       and         
asg adds two new solutions          and           to open  then solution sopt is added to
both closed and tlist 
in the next iteration  solution           which has the minimum cost among the solutions
currently in open  is selected and removed from open  the swap list           is computed and
subsequently           is added to open and tlist  as it happens  l                owing to
the fact that eopt    e    e     and there exists no swap option on the or edges  e  and e     
thus nothing else happens in this iteration  in the next iteration  solution          is removed
from open and ultimately solution                  is added to open after adding          to
closed as well as to tlist  next two iterations proceed in a similar fashion  now  consider the
 th iteration  in this iteration  solution                            is removed from open  and its
successor set has only one solution                                        which is already present
in open  inserted to open in iteration     therefore  solution                                     
is not inserted to open again  we have shown up to iteration   in table   
    technique for avoiding the checking for duplicates in open
in this section  we present a technique to avoid the checking done before adding a newly
constructed solution sm to open to determine whether sm is already present in open  we
first explain the scenario with an example  which is a portion of the previous example
shown in figure    in figure       the solutions are shown using thick dashed line with
arrow head  also the rectangles with rounded corner are used to highlight the fact that the
corresponding node in the marked solution does not belong to the vopt set of that solution 
v 

     
h i

     
h i

     
h i

         

h i

h i

v 
h i

v 

     

v 

     

h i

         

h i

v 

     
h i

h i

v 
h i

h i

v  

v  

v  

v  

v  

v  

v  

v  

 

 

  

  

 

 

  

  

figure    solution s 

figure    running example

consider the solutions s    s  and s   shown in figure    figure    and figure     here
 a  l sopt                            b  succ sopt      s    s    
 c  sig s                   d  sig s                  and  e  sig s                           
algorithm   constructs the solution s   shown in figure    for adding to open twice 
 i  as a part of adding succ s    to open  and  ii  while adding succ s    to open 
   

figenerating ordered solutions for explicit and or structures

v 

     

h i

     
h i

     
h i

         

h i

h i

v 

v 

     

v 

h i

     

h i

h i

v 

     
h i

h i

h i

v 
h i

         

v  

v  

v  

v  

v  

v  

v  

v  

 

 

  

  

 

 

  

  

figure    solution s 

figure     solution s 

we use the following definitions to describe another version of the asg algorithm  which
constructs the solutions in such a way that the check to find out whether a solution is already
added to open is avoided 
definition   l  solution space dag ssdag   the solution space dag of an alternating
and or tree t is a directed acyclic graph  dag   g s   hv  ei  where v is the set of all
possible solutions of the and or tree t   and e is the set of edges which is defined as 

fi

fi sp   sm  v  and


fi
e   espm fifi espm is a directed edge from node sp to sm   and


fi sm  succ sp  

clearly sopt is the root node of g s  




definition   m  solution space tree and completeness  a solution space tree of an
alternating and or tree t is a tree t s   hv t   e t i where v t  v  where v is the set of
all possible solutions of the and or tree t   and e t is the set of edges which is defined
as 
fi


fi sp   sm  v t   and


fi




s
fi
e
is
a
directed
edge
from
node
s
to
s
 
and
p
m
s fi pm
t
e   epm fi

fi sp  p red sm    and


 

fi s   p red sm     sp    s     there is no edge between s  and sm   
p
p
p
the sibling set for a solution sm   is denoted using sib t s   sm    a solution space tree t s
for an and or tree is complete if v t   v 


it may be noted that the complete solution space tree of an alternating and or tree
is not necessarily unique  it is possible for an alternating and or tree to have more than
one complete solution space tree  however the solution space dag for any and or tree
is unique 
definition   n  native swap options of a solution  consider a solution sm of an alternating and or tree t   suppose sm is constructed by applying swap option ij to
solution sp   since swap option ij   hei   ej   ij i is used to construct sm   and node vj is
present in sm   the native swap options of solution sm with respect to swap option ij  
n  sm   ij    is a subset of l sm    and comprises of the following swap options  
   

fighosh  sharma  chakrabarti    dasgupta

v 

     

       

h i

     

       
h i

v 

v 

h i

     

v 

  
h i

     

h i

v 

h i

h i

v 

     

v 

v 

     

  
h i
h i 
        

h i

h i

         

h i

h i

h i

                   

v 

v  

v  

v  

v  

v  

v  

 

 

 

 

  

  

  

figure     a solution  s    of the and or tree shown in figure  
a  jk   where jk is the swap option on the edge ej
b  each t   if t belongs to an or node vq where vq is a node in sm  vj  
we use the term n  sm   to denote the native swap options when ij is understood from
the context  intuitively the native swap options for solution sm are the swap options that
become available immediately after applying ij   but were not available in the predecessor
solution of sm  



consider the solution s  shown in figure    where sig s                                  the
solution is highlighted using thick dashed lines with arrow head  we have used the rectangles with rounded corner beside each node vq in solution s    where c s    vq      copt  vq   
suppose s  is constructed form solution s   where sig s                        using swap
option           here n  s                           whereas l s                            now
consider solution s  where sig s                                            it is worth observing that applying only the native swap options to s  instead of all swap options in l s   
prevents the construction of solution s  from solution s    s  can also be constructed by
applying         to solution s    where sig s                                  however  it may
be noted that         is not a native swap option of solution s   
      lazy asg algorithm
the intuition behind the other version of the asg algorithm is as follows  for a newly
constructed solution sm   we need to check whether sm is already present in open because
sm can be constructed as a part of computing the successor set of multiple solutions 
instead of using the entire swap list of a solution to construct all successors at once and
then add those solutions to open  using the native swap options for constructing a subset of
the successor set ensures the following  the subset constructed using native swap options
   

figenerating ordered solutions for explicit and or structures

consists of only those solutions that are currently not present in open and thus can be
added to open without comparing with the existing entries in open  the construction of
 of s
each remaining successor solution sm
m and then insertion to open is delayed until
 is added to closed 
every other predecessor solution of sm
algorithm    lazy asg  lasg  algorithm

 

 
 
 
 
 
 
 
 
  
  

  

  

  
  
  

  
  

  
  
  
  
  
  
  
  
  
  

input   an alternating and or tree t
output  alternative solutions of t in the non decreasing order of cost
compute the optimal solution sopt   perform or edge marking and populate the
swap options 
create two lists  open and closed  that are initially empty 
put sopt in the closed list 
create a solution space tree t s with sopt as root 
compute the swap list  l sopt    of sopt  
construct succ sopt   using l sopt   
forall sm  succ sopt   do
add sm to open 
end
while open is not empty do
smin  remove the minimum cost solution from open  
   suppose smin is constructed from sm applying swap option ij
  
add a node corresponding to smin in t s and connect that node using an edge
from sm  
compute the swap list l smin   and the list of native swap options n  smin   ij   
   expansion using native swap options
  
foreach tmp  n  smin   ij   do
construct stmp from smin by applying tmp  
construct the signature of stmp   sig stmp    by concatenating tmp after
sig smin   
add stmp to open 
end
   lazy expansion
  
s
forall sp  sib t   smin   do
if ij  l sp   then
construct sp from sp using ij  
construct the signature of sp   sig sp    by concatenating ij after sig sp   
add sp to open 
end
end
add smin to closed 
end
report the solutions in closed 

the solution space tree t s is maintained throughout the course of the algorithm to
 is added to closed  based on this idea we
determine when every other predecessor of sm
   

fighosh  sharma  chakrabarti    dasgupta

present a lazy version of asg algorithm  named lasg  after selecting the minimum cost
solution from open  the algorithm explores the successor set of the current minimum cost
solution in a lazy fashion  for a solution sm   at first a subset of succ sm   is constructed
using only the native swap options of sm   the other solutions that belong to succ sm  
are explored as late as possible as described above  for resolving ties  lasg algorithm
uses the same strategy which is used by asg algorithm  the details of lasg algorithm
are presented in algorithm    the proof of correctness of this algorithm is presented in
appendix b 
consider the example tree shown in figure   and solutions s  and s   shown in figure  
and figure      initially the open will contain only sopt and n  sopt                          
when sopt is selected from open  both s  and s  is added to open  next s  will be selected
followed by s    since  n  s       and n  s        after selecting s  or s  no successor
solutions are constructed using the native swap list  among the predecessors of s    s  is
added last to closed  after selecting and removing s  from open  solution s  is constructed
from the previously selected predecessor s  using the swap option         which is used to
construct solution s  from sopt  
      working of lasg algorithm  on and or tree in figure   
before entering the outermost while loop  algorithm    line      lasg computes the
optimal solution sopt and constructs succ sopt    then
 the solutions  in succ sopt   are
added to open and the contents of the open becomes                       the contents of
the different lists when a solution is added to closed are shown in table    the solutions
are represented using their signatures  the solutions that are added to open as a result of
lazy expansion  are highlighted using under brace 
iteration
 
 
 

smin
  
         
        
                

n  smin  
              

     
                 

 

                          

       

 

                          



 

                          
         



open
                   
        
                
                           
                          
                           
                                    

closed
  
             
                       
                        
                
                        
                
                          
                                                              
                                    
                
 
 z
 
                          
                          
                                                              
                
                          
                          
                          
         

table    working of lasg algorithm
while generating the first four solutions  the contents of the different lists for lasg
are identical to the contents of the corresponding lists of asg  shown in table     for
   

figenerating ordered solutions for explicit and or structures

each of these soltuions  the native swap list is equal to the actual swap list of that solution  it is worth noting that  unlike asg  for lasg the outermost while loop starts
after generating the optimal solution sopt   thus while generating the same solution the
iteration number for lasg is less than that of asg by    in the  th iteration  for solution s                               the native swap list is not equal to the swap list as
described previously  the same holds true for solution s                               and
solution s                                          it is important to observe that lasg adds
the solution s                                         to open after the generation of solution
s                               as a part of lazy expansion  highlighted using under brace
in table     whereas  the asg algorithm adds s  to open after generating solution
s                               
    complexity analysis and comparison among asg  lasg and bu
in this section we present a complexity analysis of asg and lasg and compare them with
bu  we will use the following parameters in the analysis 
a  n and n denote the total number of nodes and the number of or nodes in an
alternating and or tree 
b  d denotes the out degree of the or node having maximum number of children 
c  m denotes the maximum number of or edges in a solution 
d  o denotes the maximum size of open  we will present the complexity analysis for
generating c solutions  therefore the size of closed is o c  
      complexity of asg
time complexity   the time complexity of the major steps of algorithm   are as
follows 
a  computing the first solution can be done in bottom up fashion  thus requiring o n  
steps  the edges emanating from an or node are sorted in the non decreasing order
of aggregated cost to compute the marks of the or edges  the marking process takes
o n  d  log d   since the value
 of d is not very large in general  can be upper bounded
by a constant   o n  d  log d   o n   
b  the number of swap options available to a solution can be at most equal to the number
of or edges in that solution  thus  the swap list for every solution can be built in
o m  time  for c solutions  generating swap options take o c m  
c  since the size of the successor set of a solution can be m at most  the size of open  o
can at most be c m  also the size of the tlist can at most be equal to c  the size of
closed  
d  the open list can be implemented using fibonacci heap  individual insert and delete
operation on open take o    amortized  and o lg o  time respectively  hence  for
inserting in the open and deleting from open altogether takes o o  lg o  time which
is o c m  log c m   
e  the checking for duplicates requires scanning the entire open and tlist  since the
length of tlist can be at most c  for a newly constructed solution this checking takes
o c   o  time and at most o c   o  solutions are generated  since o c   o  is actually
o o   for generating c solutions  this step takes o o   time  also  the maximum value
   

fighosh  sharma  chakrabarti    dasgupta

of o can be o c m   thus  the time complexity of this step is o c m     clearly this
step dominates o o  lg o  which is the total time taken for all insertions into the open
and deletions from open 
however  this time bound can be further improved if we maintain a hash map of the
solutions in the open and tlist  and in this case the checking for duplicates can be
done in o o  time  in that case o o  lg o   total time taken for all insertions into the
open and deletions from open  becomes dominant over the time required for checking
for duplicates 
f  an upper limit estimate of m could be made by estimating the size of a solution tree

which is n for regular and complete alternating and or trees  it is important
to observe that the value of m is independent of the average out degree of a node in
t  
combining
together we get the time complexity
of asg algorithm as  

 factors

 the above
 
 
 
 
o n   o   o n    c m    o n   c  n   o c  n  
howeverif the additional
hash
is further reduced to   

 map is used the time complexity



o n   o  lg o   o n   c  n   lg c n     o n   n   c  lg c   c  lg n  
space complexity  the following data structures primarily contribute to the space complexity of asg algorithm 
a  three lists  namely  open  closed  and tlist are maintained throughout the course of
the running asg  this contributes a o o   c  factor  which is o o  
b  since the number of swap options is upper bounded by the total number of or edges 
constructing the swap list contributes the factor  o n  d  to the space complexity 
also marking a solution requires putting a mark at every or node of the and or
tree  thus adding another o n   space which is clearly dominated by the previous
o n  d  factor 
c  since the signature of a solution is essentially a set of swap options  the size of a
signature is upper bounded by the total number of swap options available  combining
the open and closed list  altogether  c   o  solutions need to be stored 
since  c   o 

is o o   total space required for storing the solutions is o o n  d  
combining
 the above factors
 together we get the space complexity of asg algorithm as  
o o   n  d   o n  d   o o n  d 
when an additional
hash map is used to improve the time complexity  another addi
tional o o n  d space is required for maintaining the hash map  although the exact space
requirement is doubled  asymptotically the space complexity remains same 
      complexity of lasg
time complexity   compared to algorithm    algorithm   does not check for the
duplicates and adds the solution to open only when it is required  therefore the other
terms in the complexity remain the same except the term corresponding to the checking for
duplicates  however  here t s is created and maintained during the course of algorithm   
creating and maintaining the tree require o c  time  also during the lazy expansion the
swap list of the previously generated sibling solutions are searched  line    and line    of
algorithm     the size of the swap list of any solution is o m   where m is the maximum
number of or edges in a solution  also there can be at most o m  sibling solutions for a
   

figenerating ordered solutions for explicit and or structures

solution  therefore the complexity of the lazy expansion is o c m     since o c m    is the
dominant factor  the time complexity of lasg is o c m      o c n   
space complexity   compared to asg algorithm  lasg algorithm does not maintain
the tlist  however lasg maintains the solution space tree t s whose size is equal to
the closed list  thus adding another o c  factor to the space complexity incurred by asg
algorithm  it is interesting to observe that the worst case space complexity remains o o  
n  d   o n  d    o o n  d  which is equal to the space complexity of asg algorithm 
      comparison with bu
the time complexity of generating the c best solutions for an and or tree is o n  c  log c 
and the space complexity is o n  c   the detailed analysis can be found in the work
of elliott         since  n  d   o n    the space complexity of both asg and lasg
algorithm reduces to o n  c  and the time complexity of lasg is log c factor better than
bu whereas the time complexity of asg is quadratic with respect to c compared to the
 c  log c  factor of bu  when an additional hash map is used to reduce the time overhead of
duplicate checking  asg beats both lasg
 and bu both in terms time complexity  as both

o n   and o n   c  lg c   c  lg n   is asymptotically lower than o n  c  log c  
however this worst case complexity is only possible for and or trees where no duplicate solution is generated  empirical results show that the length of open  o hardly reaches
o c m  

   ordered solution generation for and or dags
in this section  we present the problem of generating solutions in non decreasing order
of cost for a given and or dag  we present the working of the existing algorithm for
generating solution for both tree based semantics and default semantics  next we present
the modifications in asg and lasg for handling dag 
    existing bottom up algorithm
figure    shows an example working of the existing bottom up approach  bu  on the
and or dag in figure    we use the notations that are used in figure   to describe
different solutions in figure    and the generation of the top   solutions under tree based
semantics is shown 
it is important to notice that although bu correctly generates alternative solutions of
an and or dags under tree based semantics  bu may generate some solutions which are
invalid under default semantics  in figure    we present a solution of the and or dag
in figure    this solution is an example of such a solution which is correct under tree based
semantics but is invalid under default semantics  the solution dag  highlighted using
thick dashed lines with arrow heads  in figure    will be generated as the  rd solution of
the and or dag in figure   while running bu  at every non terminal node  the entry
 within rectangle  corresponding to the  rd solution is highlighted using bold face  it may
be noted that the terminal nodes  v  and v     are included in the solution dag though both
of them emanate from the same parent or node  therefore  this solution is not a valid one
under default semantics 
   

fighosh  sharma  chakrabarti    dasgupta

     

v 

v  v 
              
              

h i
     

v 

    hv     i    
    hv     i    

v 
  

h i

v 

    hv     i    
    hv     i    

     

h i

v  v 
              
              

v 

    hv     i   
    hv      i    

v 

v 

  

  

    hv     i    
    hv     i    

v 

     

v 

    
h i

v 

     

v 

h i

    hv     i    
    hv     i    
h i

v  v 
              
              

v 
  

h i

h i

  

h i

h i

h i

h i

h i

h i
    

v 

h i
v 

     

     

v 

h i

h i

h i

h i

     

v  v 
              
              
              

    hv     i    
    hv     i    

v 
  

h i

v 

v  

v 

v  

 

 

 

 

figure     a solution  tree based semantics 

figure     bu approach for and or dag

proposed extension of bu to generate alternative solutions under default
semantics   we propose a simple top down traversal and pruning based extension of
bu to generate alternative solutions under default semantics  while generating the ordered
solutions at any and node vq by combining the solutions of the children  we do the following 
for each newly constructed solution rooted at vq   a top down traversal of that solution
starting from vq is done to check whether more than two edges of an or node are present
in that particular solution  a violation of the default semantics   if such a violation of the
default semantics is detected  that solution is pruned from the list of alternative solutions
rooted at vq   therefore  at every and node  when a new solution is constructed  an
additional top down traversal is used to detect the semantics violation 
    top down method for dags
the proposed top down approaches  asg and lasg  are also applicable for and or
dags to generate alternative solution dags under default semantics  only the method of
computing the cost increment after the application of a swap option needs to be modified to
incorporate the fact that an or node may be included in a solution dag through multiple
paths from the root node  we use the notion of participation count for computing the cost
increment 
participation count   the notion of participation count is applicable to the intermediate
nodes of a solution dag as follows  in a solution dag  the participation count of an
intermediate node  vq   is the total number of distinct paths connecting the root node  vr  
and vq   for example  in figure     the optimal solution dag is shown using thick dashed
lines with arrow heads  and the participation count for every intermediate or nodes are
shown within a circle beside the node 
   

figenerating ordered solutions for explicit and or structures

v 

h i

h i
 

h i

v 

     

 

h i

         

v 

v 

     

 

h i

v 

 

h i

v 

v 

     

          

 

h i

     

v 

     

v 

v 

  

  

 

h i

h i

h i

v 

 

 

  
h i

h i

     

          

h i

v 

     
h i

h i

v 

v 

  

h i

    

          

h i

h i

  
h i

     

v 

v 

    

          

  

h i

v 

v  

v 

v  

 

 

 

 

figure     solution dag s 

figure     and or dag

we use the notation ijk to denote a swap option in the context of and or dags 
where swap option ijk belongs to node vi   the source edge of the swap option is eij from
node vi to node vj   and the destination edge is eik from node vi to node vk  
      modification in the proposed top down approach
the asg algorithm is modified for handling and or dags in the following way  the
computation of the successor solution in line    of algorithm   is modified to incorporate
the participation count of the or node to which the applied swap option belongs  the
overall method is shown in algorithm   in the next page  
in order to apply lasg on and or dags  apart from using the above mentioned
modification for computing the cost of a newly generated solution  another modification
is needed for computing the native swap options for a given solution  the modification is
explained with an example  consider the solution  s    shown in figure     s  is highlighted
using thick dashed lines with arrow heads  the pair  cv  vq    c s    vq    is shown within
rectangles beside each node vq   rectangles with rounded corner are used when c s    vq     
copt  vq    swap option         was applied to sopt to generate s    after the application
of swap option           the participation count of node v  is decremented to    therefore
in s  there is a path from the root node to node v  and so node v  is still present in s   
as a result  the swap option          is available to s  with a participation count equal to
  for node v    whereas          is available to its parent solution sopt with participation
count   for node v    in other words           is not available to s  and its parent solution
sopt with the same value of participation count for node v    therefore          becomes the
native swap option of s    the generalized definition of native swap options for a solution
is presented below 
definition   o  native swap options of a solution  consider a solution sm of an
and or dag g   where sm is constructed by applying swap option hij to solution
sp   since swap option hij   hehi   ehj   hij i is used to construct sm   and node vj belongs
   

fighosh  sharma  chakrabarti    dasgupta

to sm   similarly  if the participation count of node vi remains greater than zero after applying hij to sm   node vi belongs to sm   the native swap options of solution sm with
respect to swap option hij   n  sm   hij    a subset of l sm    comprises of the following
swap options  
a  hjk   where hjk is the swap option on the edge ehj
b  each t   if t belongs to an or node vq where vq is a node in sm  vj  
c  each t   if node vi is present in sm and t belongs to an or node vq where vq is a
node in sm  vi   
we use the term n  sm   to denote the native swap options when hij is understood from
the context  intuitively the native swap options for solution sm are the swap options that
become available immediately after applying hij   but were not available in the predecessor
solution of sm  


algorithm    asg algorithm for and or dags
input   an and or dag g
output  alternative solutions of g in the non decreasing order of cost
  compute the optimal solution sopt   perform or edge marking and populate the
swap options 
  create three lists  open  closed  and tlist  that are initially empty 
  put sopt in open 
  lastsolcost  c sopt   
  while open is not empty do
 
smin  remove the minimum cost solution from open 
 
if lastsolcost   c smin   then
 
remove all the elements of tlist 
 
lastsolcost  c smin   
  
end
  
add smin to closed and tlist 
  
compute the swap list  l smin    of smin  
   construct succ smin   using l smin   and add new solutions to open
  
  
foreach ij  l smin   do
  
construct sm by applying ij to smin  
  
construct the signature of sm   sig sm    by concatenating ij after sig smin   
  
let ij belongs to or node vq   p is the participation count of vq   and  is the
cost increment for ij  
  
c sm     c sm     p   
   check whether sm is already present in open or in tlist
  
  
if  sm not in open  and  sm not in tlist  then
  
add sm to open 
  
end
   end
   report the solutions in closed 
it is worth noting that definition   o of native swap option is a generalization of the
earlier definition of native swap option  definition   n   defined in the context of trees  in
   

figenerating ordered solutions for explicit and or structures

the case of trees  the participation count of any node can be at maximum    therefore 
after the application of a swap option to a solution  the participation count of the node 
to which the original edge of the swap option points to  becomes    therefore the third
condition is never applicable for trees 
lasg  algo     can be applied on and or dags  with the mentioned modification
for computing the cost of a newly generated solution and the general definition of native
swap option to generate ordered solutions under default semantics 
      working of asg and lasg algorithm on and or dag
we describe the working of asg algorithm on the example dag shown in figure    before
entering the outermost while loop  tlist and closed are empty  and open contains the
optimal solution sopt   the contents of the different lists obtained after first few cycles of
outermost while loop are shown in table    each solution is represented by its signature 
the solutions that are already present in open and also constructed by expanding the
current smin   are highlighted with under braces  for example  the solution                     
which is added to open in iteration    while constructing the successor solutions of            
constructed again in iteration   while expanding solution            
l smin  
open
                            
                                   
                  
                                              
                     
                       

                                              

it 
 
 

smin
  
          

 

           



                                 

 

          

                  

                                           
 
 z
 

closed
  
              
              
                     
               
                      
           
               
                      
                       

table    example working of asg algorithm on the dag shown in figure  
now we illustrate the working of lasg algorithm on the example dag shown in figure    the contents of the different lists when a solution is added to closed are shown
in table    it is worth noting that for solution s              the swap list l s     
                      whereas the native swap list n  s                   the solutions that are
added to open as a result of lazy expansion  are highlighted using under brace  for example 
in iteration   lasg adds the solution s                         to open after the generation
of solution s             as a part of lazy expansion  whereas the asg algorithm adds s 
to open after generating solution s             
      generating solutions under tree based semantics
unlike the default semantics  asg or lasg does not have any straight forward extension
for generating solutions under tree based semantics  in figure    we show an example
solution which is valid under tree based semantics  but invalid under default semantics 
because both or edges emanating form the or node v    namely e      and e         are
   

fighosh  sharma  chakrabarti    dasgupta

n  smin  
open
                                                                
        
                        
                     
                       

                        

it 
 

smin
  
          

 

           



          

 

          

        

                      
                    
 
 z
 

closed
  
              
              
                     
               
                      
           
               
                      
                       

table    example working of lasg algorithm on the dag shown in fugure  

present in this solution  these two or edges are included in the solution through two
different paths emanating form the root node  v    as the existing bottom up approach
stores the alternative solutions at each node in terms of the solutions of the children of that
node  this representation allows these different paths to be stored explicitly  thus making
bu amenable for generating alternative solutions under tree based semantics 
on the contrary  our approach works top down using a compact representation  signature  for storing the solutions  in this signature based representation  it is currently not
possible to store the fact that a particular or node is included in the solution through two
different paths which may select different child of that or node  if we use the equivalent
tree constructed form the given graph  our compact representation will work correctly  because in that case  each node would be reachable from the root node through at most one
path  an and or dag can be converted to its equivalent and or tree representation
using procedure convertdag  described in section    and then asg or lasg can be applied on the equivalent tree representation in order to generate the alternative solutions
correctly under tree based semantics  however  in the worst case  procedure convertdag
incurs a space explosion which will blow up the worst case complexity of both asg and
lasg algorithms  using our compact representations to generate the ordered solutions
under tree based semantics for a given and or dag while containing the space explosion
such that the worst case complexity of our algorithms remain comparable with bu turns
out to be an interesting open problem 

   experimental results and observations
to obtain an idea of the performance of the proposed algorithms and to compare with
the existing approach  we have implemented the asg  lasg and bu  existing bottom up
approach  and tested on the following test domains 
a  a set of synthetically generated and or trees 
b  tower of hanoi  toh  problem 
c  a set of synthetically generated and or dags 
d  matrix chain multiplication problem  and
e  the problem of determining the secondary structure of rna sequences 
   

figenerating ordered solutions for explicit and or structures

it may noted that in our implementation of the asg algorithm  we have implemented the
more space efficient version of asg algorithm  without a separate hash map for storing the
solutions in open and closed  thereby incurring an extra overhead in time for duplication
checking   another important point is that for every test case the reported running time of
asg and lasg for generating a particular number of solutions includes the time required
for constructing the optimal solution graph  the details of the different test domains are
as follows 
    complete trees
we have generated a set of complete d ary alternating and or trees by varying   a  the
degree of the non terminal nodes  denoted by d   and  b  the height  denoted by h  
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
             
     
     
     
     
     
     
     
     
     
     
      
     
     
                     
     
     
     
     
     
     
      
     
     
     
     
     
      
     
     
     
     
     
      
     
     
     
     
     
      
            

    solutions
asg
lasg
bu
     
     
     
     
     
     
      
     
     
      
     
     
             
     
t
     
      
     
     
     
     
     
     
      
     
     
             
      
t
              
     
     
     
      
     
     
             
      
     
     
     
             
      
     
     
     
             
      
      
     
     
                     

    solutions
asg
lasg
bu
     
     
     
     
     
     
      
     
     
             
     
             
     
t
             
     
     
     
      
     
     
             
     
t
     
      
t
              
     
     
     
      
     
     
t
     
      
     
     
     
             
      
      
     
     
             
      
      
     
     
t
             

table    comparison of running time  in seconds  for generating           and     solutions
for complete alternating and or trees  t denotes the timeout after    minutes 
these trees can be viewed as the search space for a gift packing problem  where
 a  the terminal nodes represent the cost of elementary items 
 b  the or nodes model a choice among the items  elementary or composite in nature 
represented by the children  and
 c  the and nodes model the repackaging of the items returned by each of the children 
every packaging incurs a cost which is modeled by the cost of the intermediate and nodes 
here the objective is to find the alternative gifts in the order of non decreasing cost 
table   shows the time required for generating           and     solutions for various
complete alternating and or trees  we have implemented the asg  lasg and the
existing bottom up algorithm and the corresponding running time is shown in the column
with the heading asg  lasg and bu  respectively  we have used a time limit of    minutes
   

fighosh  sharma  chakrabarti    dasgupta

 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

asg
      
      
       
       
       
        
      
      
       
        
        
      
       
        
      
       
      
        
       
        

    solutions
lasg
bu
      
      
      
      
      
       
       
       
       
        
                  
      
      
      
       
       
        
                 
                  
      
      
       
       
                  
      
      
       
        
      
       
       
        
      
       
                  

asg
      
       
       
       
        
t
      
       
       
        
t
       
       
        
       
        
       
        
       
        

    solutions
lasg
bu
      
      
      
      
       
       
       
        
       
        
                  
      
      
       
       
       
        
                  
                   
      
       
       
        
                  
       
       
       
        
       
       
                  
       
       
                  

asg
      
       
       
        
        
t
      
       
        
t
t
       
       
t
       
        
       
        
       
t

    solutions
lasg
bu
      
      
       
      
       
       
       
        
        
        
        
         
      
      
       
       
       
        
        
         
                    
       
       
       
        
        
         
       
       
       
        
       
       
        
         
       
       
        
         

table    comparison of space required  in kb  for generating           and     solutions
for complete alternating and or trees

and the entries marked with t denotes that the time out occurred for those test cases  the
space required for generating           and     solutions is reported in table    it can
be observed that in terms of both time and space required  lasg outperforms both asg
and bu  between asg and bu  for most of the test cases bu performs better than asg
with respect to the time required for generating a specific number of solutions  the space
requirement of asg and bu for generating a specific number of solutions has an interesting
correlation with the degree d  and height h  parameter of the tree  for low numerical values
of the d and the h parameter  e g    d  h  combinations like                etc   bu performs
better than asg  on the contrary  for the other combinations  where at least one of these
d and h parameters has a high value  e g    d  h  combinations like                         etc  
asg outperforms bu 
      experimentation with queue with bounded length
since the open can grow very rapidly  both asg and lasg incur a significant overhead
in terms of time as well as space to maintain the open list when the number of solutions
to be generated is not known a priori  in fact  for asg checking for duplicates in open is
actually the primary source of time complexity and storing the solutions in open is a major
contributing factor in space complexity  if the number of solutions that have to generated is
known a priori  the proposed top down approach can leverage the fact by using a bounded
length queue for implementing open  when a bounded length queue is used  the time
requirement along with space requirement decreases significantly 
   

figenerating ordered solutions for explicit and or structures

 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
                    
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
            

    solutions
asg lasg
bu
           
     
           
     
           
     
           
     
           
     
                  
           
     
           
     
           
     
                  
                   
           
     
           
     
                  
           
     
                  
           
     
                  
           
     
                   

    solutions
asg lasg
bu
           
     
           
     
           
     
           
     
           
     
                  
           
     
           
     
           
     
                  
                   
           
     
           
     
                  
           
     
                  
           
     
                  
           
     
                   

table    comparison of running time  in seconds  for generating           and     solutions
for complete alternating and or trees with bounded length open queue for asg
and lasg
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

asg
      
      
      
       
       
        
      
      
       
       
        
      
       
        
      
       
      
       
      
        

    solutions
lasg
bu
     
      
     
      
      
       
      
       
       
        
                 
     
      
      
       
      
        
       
        
                  
     
      
      
       
                 
      
      
       
        
      
       
       
        
      
       
                  

asg
      
      
       
       
       
        
      
       
       
        
        
      
       
        
      
       
       
        
       
        

    solutions
lasg
bu
     
      
     
      
      
       
      
        
       
        
       
         
     
      
      
       
      
        
       
         
                   
     
       
      
        
       
         
      
       
       
        
      
       
       
         
      
       
                  

asg
      
       
       
       
        
        
      
       
       
        
         
      
       
        
       
       
       
        
       
        

    solutions
lasg
bu
     
      
      
      
      
       
      
        
       
        
       
         
     
      
      
       
      
        
       
         
                   
      
       
      
        
       
         
      
       
       
        
      
       
       
         
      
       
                  

table    comparison of space required  in kb  for generating           and     solutions
for complete alternating and or trees with bounded length open queue for asg
and lasg

   

fighosh  sharma  chakrabarti    dasgupta

we show the effect of using bounded length queue to implement open in table    reporting the time requirement  and in table    reporting the memory usage  for generating
          and     solutions  where the number of solutions to be generated are known beforehand  table   and table   show that in this case both asg and lasg outperforms
bu in terms of time as well as space requirements  particularly  asg performs very well in
this setting  outperforming lasg in some cases 
      experimentation to compare the incremental nature
the proposed top down algorithms are incremental in nature whereas the existing bottomup approach is not incremental  after generating a specified number of ordered solutions 
our methods can generate the next solution incrementally without needing to restart itself 
whereas the existing approach needs to be restarted  for example  after generating the
first    ordered solutions  asg and lasg generate the   th solution directly from the data
structures maintained so far by these algorithms and perform necessary updates to these
data structures  whereas  bu needs to be restarted with input parameter    for generating
the   th solution  in table   we compare the time needed to generate the subsequent   th
solution and   th solution incrementally after generating first    solutions  in order to have
more clarity in the comparison among the running times of the respective algorithms  we
have used higher precision  upto the  th decimal place  while reporting the running time
in table    clearly  both asg and lasg outperform bu for generating the   th and   th
solution in terms of the time requirement 
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

asg
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

lasg
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

first   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  th
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

table    comparison of running time  in seconds  for generating for first    solutions and
then the   th solution and   th solution incrementally for complete alternating
and or trees

   

figenerating ordered solutions for explicit and or structures

    multipeg tower of hanoi problem
consider the problem of multipeg tower of hanoi  majumdar        gupta  chakrabarti 
  ghose         in this problem   pegs are fastened to a stand  initially  disks rest on
the source peg a with small disk on large disk ordering  the objective is to transfer all
 disks from a to the destination peg b with minimum legal moves  in a legal move  the
topmost disk from any tower can be transferred to any other peg with a larger disk as the
topmost disk  the problem of multi peg tower of hanoi can be solved recursively as follows 
a  move recursively the topmost k  k varies from   to      disks from a to some
intermediate peg  i  using all the pegs 
b  transfer the remaining   k disks from a to b recursively  using the       pegs
available 
c  recursively move k disks that were transferred to i previously  from the intermediate
peg i to b  using all the  pegs 
it may be noted that there is a choice for the value of k  which may take any value from  
to      solutions with different values of k may take different number of moves  and the
solution which incurs minimum number of moves is the optimal solution  this choice of
the value of k is modeled as an or node  and for every such choice  the problem is divided
into three sub problems  this decomposition into sub problems is modeled as an and
node  therefore  the search spaces of the multi peg tower of hanoi problem correspond to
alternating and or trees 
 disks
 
 
  
  
  
  

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
            
                    

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
      
                    
                     

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
      
     
      
      
      
      
                       

 opt  no 
of moves
  
  
  
  
  
  

table     comparison of running time  in seconds  for alternating and or trees corresponding to the search spaces of   peg tower of hanoi problem with different
number of disks
 disks
 
 
  
  
  
  

    solutions
asg
lasg
bu
asg
      
      
       
      
      
       
        
       
       
       
        
       
       
                  
       
                           
        
                                        

    solutions
lasg
bu
asg
      
       
       
       
        
       
       
        
       
                  
        
                  
        
                              

    solutions
lasg
bu
       
       
       
        
       
         
                  
                   
                    

table     comparison of space required  in kb  for alternating and or trees corresponding to the search spaces of   peg tower of hanoi problem with different number
of disks
we have used the search space of   peg tower of hanoi problem with different number of
disks    and generated alternative solutions in non decreasing order of cost using asg and
   

fighosh  sharma  chakrabarti    dasgupta

lasg algorithms  here the cost function expresses the number of legal moves  the value
of  is varied from   to     and in table    and in table     we report the time required and
space required  respectively  for generating           and     solutions for every test cases 
experimental results show that the performance of asg is similar to the performance of
lasg with respect to both space and time  however asg as well as lasg outperforms
bu with respect to both time and space requirements 
    randomly constructed and or dags
we have constructed a set of randomly generated and or dags and evaluated the asg 
lasg  and bu algorithm for generating solutions under default semantics  we have used
the proposed extension to the bu algorithm for generating solutions under default semantics 
n

d

  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

    solutions
asg lasg
bu
                 
                 
                 
                 
                 
                 
                   
                 
                 
                  
t
     
t

    solutions
asg
lasg
bu
     
           
     
           
     
           
     
           
     
           
                  
                    
     
           
     
           
                   
t
     
t

    solutions
asg
lasg
bu
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
            
     
                    
     
     
     
            
     
                     
t
     
t

table     comparison of running time  in seconds  for generating           and     solutions for and or dags  t denotes the timeout after    minutes 
n

d

  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

asg
      
      
      
      
      
       
       
      
       
       
        

    solutions
lasg
bu
     
     
      
      
      
       
      
     
      
      
       
       
                
      
      
      
       
                
        
t

asg
      
      
       
      
       
       
        
      
       
        
t

    solutions
lasg
bu
      
      
      
      
       
       
      
      
       
      
       
       
                
      
      
       
       
                
        
t

asg
      
       
       
      
       
        
        
       
       
        
t

    solutions
lasg
bu
      
      
      
      
       
       
      
      
       
       
       
       
                 
      
      
       
       
                
        
t

table     comparison of space required  in kb  for generating           and     solutions
for and or dags

table    and table    compare the time required and space required for running asg 
lasg and bu for generating           and     solutions for every test cases  the first
and second columns of every row provide the size  n   and the average out degree  d  of
the dag  the results obtained for this test domain are similar to the results for randomly
   

figenerating ordered solutions for explicit and or structures

constructed and or trees  it may be noted that in terms of both time and space required 
lasg outperforms both asg and bu  between asg and bu  for most of the test cases
bu performs better than asg with respect to the time required for generating a specific
number of solutions  whereas  the space requirement of asg and bu for generating a
specific number of solutions has an interesting co relation with the average degree d  and
the size  n   parameter of the dag  for low numerical values of the d and the n
parameter  e g    n   d  combinations like                  etc   bu performs better than
asg  on the contrary  for the other combinations  where at least one of these n and d
parameter has a high value  e g    n   d  combinations like                                
etc   asg outperforms bu 
    matrix chain multiplication problem
we have also used the well known matrix chain multiplication  cormen  stein  rivest   
leiserson        problem for experimentation  the search space of the popular dynamic
programming formulation of this problem correspond to and or dag 
dag
cnstr 
 matrices
time
 sec 
  
     
  
     
  
     
  
     
  
     
  
      
  
      
  
      
   
       

sopt
cnstr 
time
 sec 
     
     
     
     
     
     
     
     
     

   solutions

   solutions

   solutions

asg

lasg

bu

asg

lasg

bu

asg

lasg

bu

     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
      
       
       
t
t
t

     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
       
       
t
t
t
t

     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     

     
     
      
       
       
t
t
t
t

table     comparison of time required  in seconds  for and or dags corresponding to
the search spaces of matrix chain multiplication with different number of matrices   t denotes the timeout after    minutes 
 matrices
  
  
  
  
  
  
  
  
   

asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
       
        
        
        
        
t
t
t

asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
       
        
        
        
t
t
t
t

asg
      
      
       
       
       
       
        
        
        

   solutions
lasg
      
      
       
       
       
       
        
        
        

bu
       
        
        
        
        
t
t
t
t

table     comparison of space required  in kb  for and or dags corresponding to the
search spaces of matrix chain multiplication with different number of matrices

given a sequence of matrices  a    a         an   of n matrices where matrix ai has dimension pi   pi   in this problem the objective is to find the most efficient way to multiply
   

fighosh  sharma  chakrabarti    dasgupta

these matrices  the classical dynamic programming approach works as follows  suppose
a i j  denotes matrix that results from evaluating the product  ai ai      aj   and m i  j 
is the minimum number of scalar multiplications required for computing the matrix a i j   
therefore  the cost of optimal solution is denoted by m i  j  which can be recursively defined
as  

m i  j   


  

 min

ik j



if i   j 
 
m i  k    m k      j    pi   pk  pj   if i   j 

the choice of the value of k is modeled as or node and for every such choice  the problem
is divided into three sub problems  this decomposition into sub problems is modeled as
an and node  it is worth noting that unlike the search space of   peg toh problem  the
search space of the matrix chain multiplication problem corresponds to and or dag 
we have used the search space for different matrix sequences having varying length and
generated alternative solutions in the order of non decreasing cost  in table     we report
the time required and in table     we report the memory used for generating         and
   solutions for every test cases 
in table     for each test case  we also report the time required for constructing the
explicit and or dag from the recursive formulation in the  nd column  and the optimal
solution construction time in the  rd column  it is interesting to observe that the relative
performance of asg and lasg for this search space is very similar to that obtained for  peg toh search space though this search space for this domain is and or dag  both asg
and lasg perform approximately the same with respect to time and space requirement 
however  the advantage of asg as well as lasg over bu with respect to both time and
space requirement is more significant in this domain 
    generating secondary structure for rna
another relevant problem where the alternative solutions play an important role is the
computation of the secondary structure of rna  rna molecules can be viewed as strings
of bases  where each base belongs to the set  adenine  cytocine  guanine  u racil   also
denoted as  a  c  g  u     rna molecules tend to loop back and form base pairs with itself
and the resulting shape is called secondary structure  mathews   zuker         the stability
of the secondary structure largely depends on the number of base pairings  in general  larger
number of base pairings implies more stable secondary structure   although there are other
factors that influence the secondary structure  it is often not possible to express these other
factors using a cost function and they are typically evaluated empirically  therefore  it is
useful to generate a set of possible alternative secondary structures ordered by decreasing
numbering of base pairings for a given rna which can be further subjected to experimental
evaluation 
the computation of the optimal secondary structure considering the underlying principle of maximizing the number of base pairings has a nice dynamic programming formulation  kleinberg   tardos         given an rna molecule b   hb  b     bn i where each
bi   a  c  g  u    the secondary structure on b is a set of base pairings  d     i  j    where
i  j            n   that satisfies the following conditions 
   

figenerating ordered solutions for explicit and or structures

test case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

organism name
anaerorhabdus furcosa
archaeoglobus fulgidus
chlorobium limicola
desulfurococcus mobilis
haloarcula japonica
halobacterium sp 
mycoplasma genitalium
mycoplasma hyopneumoniae
mycoplasma penetrans
pyrobaculum aerophilum
pyrococcus abyssi
spiroplasma melliferum
sulfolobus acidocaldarius
symbiobacterium thermophilum

  bases
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table     details of the rna sequences used for experimentation
a  if  i  j   d  then i       j   this condition states that the ends of each pair in d are
separated by at least four intermediate bases 
b  the elements of any pair in d consists of either  a  u   or  c  g   in either order  
c  no base appears in more than one pairings  i e   d is a matching 
d  if  i  j  and  k  l  are two pairs in d  then it is not possible to have i   k   l   j  i e  
no two pairings can cross each other 
test
case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

dag cnstr 
time  sec 
      
      
      
      
      
      
      
      
      
      
      
      
      
      

sopt cnstr 
time  sec 
     
     
     
     
     
     
     
     
     
     
     
     
     
     

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

  solutions
lasg
bu
             
             
             
              
             
             
             
             
             
     
t
             
             
             
             

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

   solutions
lasg
bu
             
     
t
             
     
t
              
     
t
             
             
             
     
t
              
             
     
t
             

asg
     
     
     
     
     
     
     
     
     
     
     
     
     
     

   solutions
lasg
bu
              
     
t
              
     
t
     
t
     
t
             
             
             
     
t
     
t
             
     
t
              

table     comparison of time required  in seconds  for and or dags corresponding to
the search spaces of rna secondary structure with different number of bases  t
denotes the timeout after    minutes 

under the above mentioned conditions the dynamic programming formulation is as follows 
suppose p  i  j  denotes the maximum number of base pairings in a secondary structure on
bi    bj   p  i  j  can be recursively defined as  
p  i  j   


  

n

  o
max p  i  j      max     p  i  k       p  k      j      
ik j

   

if i      j 

if i       j 

fighosh  sharma  chakrabarti    dasgupta

here  a choice of the value of k is modeled as an or node and for every such choice 
the problem is divided into three sub problems  this decomposition into sub problems is
modeled as an and node  we have experimented with the search space of this problem for
the set of rna molecule sequences obtained from the test cases developed by szymanski 
barciszewska  barciszewski  and erdmann         the details of the test cases are shown
in table    
for every test cases  we report the time required in table    for generating        and   
solutions  for the same setting  the space required is reported in table     in table     for
each test case  we also report the time required for constructing the explicit and or dag
from the recursive formulation in the  nd column  and the time required for constructing the
optimal solution time in the  rd column  we use a high value of time out       seconds  in
order to gather the running time required by bu  we limit the maximum solutions generated
at    because for generating higher number of solutions  bu is timed out for most of the
test cases  it is worth noting that the result obtained for this domain is very similar to the
result obtained for the matrix chain multiplication problem domain  both space and time
wise asg and lasg perform similarly and they outperform bu significantly with respect
to time as well as space requirement 
test
case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

  solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
        
        
        
         
        
        
        
        
        
t
        
        
         
        

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

   solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
         
t
         
t
         
t
         
         
         
t
         
         
t
         

asg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

   solutions
lasg
        
        
        
        
        
        
        
        
        
        
        
        
        
        

bu
         
t
         
t
t
t
         
         
         
t
t
         
t
         

table     comparison of space required  in kb  for and or dags corresponding to the
search spaces of rna secondary structure with different number of bases

    observations
the experimental data shows that the lasg algorithm generally outperforms the asg
algorithm and the existing bottom up approach in terms of the running time for complete
alternating and or trees and and or dags  whereas  for the other problem domains 
i e   the   peg tower of hanoi problem  the matrix chain multiplication problem  and the
problem of determining secondary structure of rna sequences  the overall performance of
the asg algorithm is similar to the performance of the lasg algorithm  this behavior
can be explained from the average and maximum length statistics of open list  reported in
table      table     for these above mentioned test domains 
   

figenerating ordered solutions for explicit and or structures

in the case of complete trees and random dags  for asg algorithm  the average as well
as the maximum size of open grows much faster than that of lasg algorithm  table   
and table      with the increase in the size of the tree dag 
 d  h 
      
      
       
       
       
       
      
      
      
       
       
      
      
      
      
      
      
      
      
      

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
  
   
   
    
  
   
    
    
   
   
    
     
   
    
     
     
   
   
     
     
   
   
   
   
   
   
    
    
   
   
    
     
   
   
     
     
   
   
            
         
   
    
   
   
    
    
   
   
     
     
   
   
    
    
   
   
    
     
   
   
    
    
   
   
     
     
   
   
    
    
   
   
     
     
   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
   
    
     
   
    
     
     
         
     
     
   
    
t
t
         
   
    
   
   
    
    
   
    
     
     
   
   
            
   
    
t
t
         
    
    
   
   
     
     
   
    
     
     
   
    
    
    
   
    
     
     
   
   
    
    
   
    
     
     
   
   
    
     
   
    
            
   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
    
     
     
   
    
     
     
         
            
   
    
t
t
         
    
    
   
    
    
     
         
     
     
   
    
t
t
         
t
t
         
    
    
   
    
     
     
         
t
t
         
    
     
   
    
     
     
   
    
    
     
   
    
            
   
    
     
     
         
t
t
   
    

table     average and maximum length of open while generating           and     solutions for complete alternating and or trees
n

d

  
   
   
  
   
    
    
   
   
    
     

 
 
 
 
 
 
 
 
 
 
 

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
  
  
   
   
  
   
    
    
   
   
   
   
  
   
    
    
   
   
    
    
   
   
           
   
   
   
   
  
   
    
    
   
   
    
     
   
   
t
t
   
   

    solutions
asg
lasg
avg 
max 
avg  max 
   
   
   
   
    
    
   
   
    
    
   
   
   
    
   
   
    
    
        
           
        
           
        
    
    
   
   
    
     
        
           
        
t
t
        

    solutions
asg
lasg
avg 
max 
avg  max 
   
    
   
   
    
    
   
   
    
     
   
   
   
    
   
   
    
    
         
     
     
         
            
         
    
    
   
   
     
     
   
    
     
     
         
t
t
   
    

table     average and maximum length of open while generating           and     solutions for randomly constructed and or dags

since asg algorithm checks for the presence of duplicates while expanding a solution  the
time required for duplication checking grows rapidly for these test domains  hence  the
overall time required for generating a specific number of solutions also increases rapidly
 faster than both bu and lasg  with the increase in the size of the tree dag  as a result 
bu outperforms asg with respect to the time requirement for trees and dags  however
   

fighosh  sharma  chakrabarti    dasgupta

the memory used for generating a specific number of solutions increases moderately  slower
than bu  with the increase in the size of the tree dag  therefore with respect to space
requirement  asg outperforms bu for larger trees and dags 
between lasg and bu  the time as well as the memory requirement of bu increases
faster than that of lasg when the degree of the and or tree or dag increases  this
happens because  for bu  the time taken for merging the sub solutions at the and nodes
and memory required for storing alternative solutions that are rooted at different nodes
increases rapidly with the increase in the degree of that node 
on the contrary  for the other test domains    peg tower of hanoi problem  matrix chain
multiplication problem  and the probelm of finding secondary structure of rna sequences 
the average and the maximum size of open for both asg and lasg are comparable  table     table    and table      therefore  for the lasg algorithm  the time saved by
avoiding the duplication checking is compensated by the extra overhead of maintaining the
solution space tree and the checks required for lazy expansion  hence the running time as
well as the space requirement are almost same for both algorithms for these three above
mentioned problem domains 
moreover  due to the low values of the average and the maximum size of open  asg
outperforms bu with respect to both time requirement and memory used for these three
test domains  for these three domains also  between lasg and bu  the time as well as the
memory requirement of bu increases faster than that of lasg when the size of the search
space  and or tree or dag  increases 

   ramifications on implicitly specified and or structures
in this section  we briefly discuss use of our proposed algorithms for generation of alternative
solutions in the non decreasing order of cost for implicit and or search spaces  one
possible way is to extend the standard ao for generating a given number of solutions 
say k  as follows  instead of keeping only one potential solution graph psg   at any stage k
psgs can be computed on the explicitly constructed search space and instead of expanding
one node  k nodes   that is  one node from each psg   can be expanded at once  after
expanding the nodes  k psgs are recomputed once again  since the cost of the nodes are
often recomputed after expanding nodes  the swap options associated with any such node
have to be updated after every such recomputation 
another possible approach could be to run ao until it generates the optimal solution 
at this point of time the swap options can be computed on the explicit portion of the
graph and swap option with minimum cost can be applied to the optimal solution  then
the resulting psg is again expanded further resulting in the expansion of the explicit graph 
the swap options are re evaluated to incorporate the cost update  again the next best psg
is computed  this process continues till the second best solution is derived  now among the
remaining successor psgs of the first solution and the successor psgs of second solution  the
most promising psg is selected and expanded  this process continues till the third solution
is found  then the successor psgs are also added to the already existing pool of candidate
psgs  these two broad steps   a  selecting the next best psg from the pool of candidate
psgs  and then  b  keeping on expanding the explicit graph till the next best solution is
found  is continued till k solutions are found 
   

figenerating ordered solutions for explicit and or structures

  disks
 
 
  
  
  
  

    solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
   
  
  
   
   
  
  
   
   
  
   
   
   
  
   
   
   
   
   

    solutions
asg
lasg
avg  max  avg  max 
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
   
   

    solutions
asg
lasg
avg  max  avg  max 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
   
   
         
   
   

table     average and maximum length of open while generating           and     solutions for   peg tower of hanoi problem with different number of disks
  matrices
  
  
  
  
  
  
  
  
   

   solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
   
  
   
  
   
  
  
  
   
  
   
  
   
  
   
   
   
  
   
   
   
  
   
   
   
   
   
   
   
   
   

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
  
   
   
  
   
  
   
  
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
  
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
   
   

table     average and maximum length of open while generating         and    solutions
for matrix chain multiplication problems
test case
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc 
tc  
tc  
tc  
tc  
tc  

  solutions
asg
lasg
avg  max  avg  max 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
  
   
  
   
  
   
  
  
  
  
  
  
  
  
  
  
  
  

   solutions
asg
lasg
avg  max  avg  max 
  
   
  
   
   
   
  
   
  
   
  
   
   
   
  
   
  
   
  
   
   
   
  
   
  
   
  
   
  
   
  
   
  
   
  
   
   
   
   
   
   
   
   
   
  
   
  
  
   
   
   
   
  
   
  
   

   solutions
asg
lasg
avg  max  avg  max 
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
  
   
  
   
   
   
   
   
   
   
  
   

table     average and maximum length of open while generating        and    solutions
for generating secondary structure of rna sequences

   

fighosh  sharma  chakrabarti    dasgupta

it is important to observe that both methods heavily depend on incorporating the updates in the explicit dag like adding nodes  increase in the cost  etc   and recomputing the
associated swap options along with the signatures that use those swap options  handling
dynamic updates in the dag efficiently and its use in implicit and or search spaces
remains an interesting future direction 

   conclusion
in our work we have presented a top down algorithm for generating solutions of a given
weighted and or structure  dag  in non decreasing order of cost  ordered solutions
for and or dags are useful for a number of areas including model based programming 
developing new variants of ao   service composition based on user preferences  real life
problems having dynamic programming formulation  etc  our proposed algorithm has two
advantages   a  it works incrementally  i e   after generating a specific number of solutions 
the next solution is generated quickly   b  if the number of solutions to be generated is
known a priori  our algorithm can leverage that to generate solutions faster  experimental
results show the efficacy of our algorithm over the state of the art  this also opens up
several interesting research problems and development of applications 

   acknowledgments
we thank the anonymous reviewers and the editor  prof  hector geffner  for their valuable
comments which have enriched the presentation of the paper significantly  we also thank
prof  abhijit mitra  international institute of information technology  hyderabad  india 
for his valuable inputs regarding the test domain involving secondary structure of rna  we
thank aritra hazra and srobona mitra  research scholar  department of comp  sc   
engg   indian institute of technology kharagpur  india  for proof reading the paper 

appendix a  proof of correctness of algorithm  
lemma a   every solution other than the optimal solution sopt can be constructed from
sopt by applying a sequence of swap options according to the order r 
proof   lemma a    every solution other than sopt of an alternating and  or tree t
is constructed by choosing some non optimal edges at some or nodes  consider any other
solution sm   corresponding to which the set of non optimal or edges is s and suppose
 s      m  we apply the relation r to s to obtain an ordered sequence  of or edges
where e    e     e  appears before e  in  if  e    e     r  we show that there exists a
sequence  of swap options that can be constructed for s   for every or edge eij of 
 here eij is the ith edge of  and    i  m   we append the subsequence of or edges
ei            eij   before eij   where ei            eij are the or edges that emanate from the same
parent vq   and ei            eij   are the first ij    edges in l vq   
we get a sequence of or edges aug from  by the above mentioned augmentation 
aug is basically a concatenation of subsequences             m   where i is a sequence of edges
ei            eij such that ei            eij are the or edges that emanate from the same parent vq  
and ei            eij are the first ij edges in l vq    we construct  from aug as follows  from
   

figenerating ordered solutions for explicit and or structures

every i   we construct i   hi   i            ij   ij i  where ik  ik      heik   eik      ik  ik    i and
i   ik   ij       is constructed by concatenating every individual i   hence there exists
a sequence of swap options  corresponding to every other solution sm  


definition a p  default path  from lemma a    every non optimal solution sm can
be constructed from the initial optimal solution by applying a sequence of swap options 
 sm    according to the order r  the sequence of solutions that is formed following  sm  
corresponds to a path from sopt to sm in ssdag g s   this path is defined as the default
path  pd  sm    for sm  
lemma a   the ssdag of an alternating and or tree t contains every alternative
solution of t  
proof   lemma a    we prove this by induction on the length of the default path pd of
the solutions 
 basis  n         consider the swap list of sopt   the solutions whose default path length
is equal to   form the succ sopt    therefore these solutions are present in g 
 inductive step    suppose the solutions whose default path length is less than or equal
to n are present in g  we prove that the solutions having default path length equal to
n     are also present in g  consider any solution sm where pd  sm     n      let  sm    
 where  s      h         i  since p  s     
h         n   n   i  consider the solution sm
 
n
d m
m
s


  v  and swap option 
n  sm
n    l sm    there is a directed edge from sm to sm in g  
hence every solution having a default path length equal to n     is also present in g 


lemma a   for any alternating and or tree t   algorithm   adds solutions to closed
 at line     in non decreasing order of cost 
proof   lemma a    consider the following invariants of algorithm   that follow from
the description of algorithm   
a  the minimum cost solution from open is always removed at line   of algorithm   
b  the cost of the solutions that are added in open  while exploring the successor set of
a solution sm  at line    of algorithm     are greater than or equal to c sm   
from these two invariants it follows that algorithm   adds solutions to closed  at line    
in non decreasing order of cost 
lemma a   for any alternating and or tree t   for every node of the ssdag of t  
agorithm   generates the solution corresponding to that node 
proof   lemma a    from lemma a   it follows that algorithm   generates the solutions
in the non decreasing order of cost  by generating a solution sm   we mean adding sm to
closed  at line    of algorithm     for the purpose of proof by contradiction  let us assume
that algorithm   does not generate solution sm   also let sm be the first occurrence of this
   

fighosh  sharma  chakrabarti    dasgupta

scenario while generating solutions in the mentioned order  according to lemma a    there
exists a sequence of swap options                k corresponding to sm   also consider the
 whose sequence of swap options is               
solution sm
 
k    according to property     

c sm    c sm    consider the following two cases 
     c s    since s
a  c sm
m
m is the first instance of the incorrect scenario  and algo is generated
rithm   generates the solutions in the non decreasing order of cost  sm
prior to sm  
     c s    since algorithm   resolves the tie in the favor of the parent solution 
b  c sm
m
 will be
and sm is the first instance of the incorrect scenario  in this case also sm
generated prior to sm  
   when s  was generated by algorithm   
the swap option k belongs to the swap list of sm
m


that is  when sm was added to closed  sm was also expanded and the solutions which can
 applying one swap option  were added to the open list  since s
be constructed from sm
m
 applying one swap option    s
was constructed from sm
was
also
added
to
the
open
m
k
   therefore s
while exploring the successors of sm
m will also be eventually generated by
algorithm     a contradiction 



lemma a   for any alternating and or tree t   algorithm   does not add any solution
to closed  at line    of algorithm    more than once 
proof   lemma a    for the purpose of contradiction  let us assume that sm is the first
solution that is added to closed twice  therefore sm must have been added to open twice 
consider the following facts 
a  when sm was added to closed for the first time  the value of lastsolcost was c sm   
and sm was added to tlist 
b  from the description of algorithm   it follows that the contents of tlist are deleted
only when the value of lastsolcost increases 
c  from lemma a   it follows that algorithm   generates the solutions in non decreasing
order of cost  hence  when sm was generated for the second time  the value of
lastsolcost did not change from c sm   
from the above facts it follow that sm was present in tlist when sm was added to open
for the second time  since  while adding a solution to open  algorithm   checks whether it
is present in tlist  at line    of algorithm     algorithm   must had done the same while
adding sm to open for the second time  therefore sm could not be added open for the
second time  a contradiction 


theorem a   sj  v  sj is generated  at line     by algorithm   only once and in the
non decreasing order of costs while ties among the solutions having same costs are resolved
as mentioned before 
proof   theorem a    follows from lemma a    lemma a    lemma a   and lemma a   


   

figenerating ordered solutions for explicit and or structures

appendix b  proof of correctness of algorithm  
definition b q  reconvergent paths in solution space dag  two paths   i  p   
si        si n and  ii  p    si        si m   in the ssdag g s of an alternating
and or tree t are reconvergent if the following holds 
a  si     si     i e  the paths start from the same node 
b  si n   si m   i e  the paths ends at the same node 

c   j      n      k      m       si j    si k   i e  the paths do not have any common
intermediate node 
definition b r  order on generation time  in the context of algorithm    we define an
order relation  t  v  v  where  sp   sq   t if sp is generated by algorithm   before sq  
here v is set of vertices in ssdag g s of an alternating and or tree t  
lemma b   algorithm   adds the solutions to the closed list in the non decreasing order
of costs 
proof   lemma b    consider the following invariants of algorithm   that follow from
the description of algorithm   
a  the minimum cost solution from open is always removed at line    of algorithm   
b  algorithm   expands any solution  say sp   in two phases  at the first phase sp is
expanded using the native swap options of sp   the solutions that are added to open
as a result of the application of the native swap options  will have cost greater than or
equal to c sp    in the second phase  i e   during lazy expansion  sp is again expanded
using a non native swap option  a solution sp may undergo the second phase  times
where        l sp      n  sp   k     and k is used to construct sp   in every lazy
expansion of sp   a new solution is added to open  consider a solution sm which is
 using  by algorithm   where s   p red s    suppose swap
constructed from sm
m
j
m
option i  l sm    and i 
  n  sm   j    i e   i is not a native swap option of sm  
    suppose s and s  are the successors of s and s  respectively 
clearly i  l sm
m
c
m
c
i
i
 
constructed by the application of i   i e   sm
 sc   and sm 
sc   also let sc is
added to closed after sm  
consider the fact that algorithm   does not apply swap option i to sm   that is  sc is
    c s    c s     c s   
not added to open until sc is added to closed  since c sm
m
c
c
according to algorithm    i is applied to sm  during the lazy expansion   and sc is
added to open right after sc is added to closed  consider the time period between
adding sm and adding sc to closed  during that period  every solution that is added
to closed has cost between c sm   and c sc    i e   the cost is less or equal to c sc    in
general  the application of a swap option to add a solution to open is delayed by such
an amount of time  say   so that all the solutions  which are added to closed during
this  time interval  have cost less than or equal to the solution under consideration 
   

fighosh  sharma  chakrabarti    dasgupta

from the above facts it follow that algorithm   adds the solutions to the closed list in
non decreasing order of costs 


lemma b   any two reconvergent paths in the ssdag g s of an alternating and or
tree t are of equal length 
proof   lemma b    consider the paths 












 
 
n
 
 
 i  p    s  
sp 
   
sn   and  ii  p    s  
sp 
   m
 sn  

the edges in the paths represent the application of a swap option to a solution  now p 
and p  start from the same solution and also end at the same solution  therefore the sets of
swap options that are used in these paths are also same  hence the lengths of those paths
are equal  that is  in the context of p  and p    n   m 
lemma b   for any set of reconvergent paths of any length n  algorithm   generates at
most one path 
proof   lemma b    the following cases are possible 
 case    n         consider the following two paths 








 
 
 
 
 i  p    s  
s  
s    and  ii  p    s  
s  
s   

it is obvious that       and         suppose s  t s    here algorithm   does not
apply the swap option   to s    therefore p  is not generated by algorithm   
 case    any other values of n     in this case  any path belonging to the set of reconvergent paths  consists of n different swap options  suppose          n   also the start
node and the end node of the paths under consideration are sp and sm   consider the nodes
in the paths having length   from sp   clearly there can be n such nodes 
among those nodes  suppose algorithm   adds sp  to closed first  and sp  is constructed
from sp by applying swap option     according to algorithm      will not be applied to
any other node that is constructed from sp and is added to closed after sp    therefore 
all those paths starting from sp   whose second node is not sp    will not be generated by
algorithm    we can use the similar argument on the paths from sp  to sm of length n   
to determine the paths which will not be generated by algorithm    at each stage  a set of
paths will not be grown further  and at most one path towards sm will continue to grow 
after applying the previous argument n times  at most one path from sp to sm will be
constructed  therefore algorithm   will generate at most one path from sp to sm  


definition b s  connection relation rc and rc   we define connection relation  rc   a
symmetric order relation for a pair of or nodes  vq and vr   belonging to an alternating
and or tree t as 
 vq   vr    rc   if in t there exists an and node vp   from which
there exist two paths   i  p    vp         vq   and

 ii  p    vp         vr
   

figenerating ordered solutions for explicit and or structures

similarly the connection relation  rc   is defined between two swap options as follows  consider two swap options iq and jr   where iq   hei   eq   iq i and jr   hej   er   jr i  suppose
or edges ei and eq emanate from vp   and or edges ej and er emanate from vt   now
 iq   jr    rc if  vp   vt    rc  
definition b t  mutually connected set  for a solution sm   a set vm of or nodes is
mutually connected  if

v    v   vm    v     v       v    v     rc  
consider the set of or nodes  vm    v         vk    where swap option j belongs to vj and
   j  k  here the set of swap options vm             k   is mutually connected 
lemma b   suppose sm is a solution of an alternating and or tree t   p red sm    
 s         sk    and swap option j is used to construct sm from sj where    j  k  the
swap options          k are mutually connected 
proof   lemma b    since sm is constructed from s         sk by applying          k respectively           k are present in the signature of sm   suppose set s             k   
we have to show that

a   b  s    a   b    rc

for the purpose of proof by contradiction  let us assume  i    i    
  rc   also sm is constructed by applying i  and i  to si  and si  respectively  consider the path p  in ssdag
of t which starts from sopt and ends at sm   and along p    si  is the parent of sm   now
along this path  i  is applied before the application of the swap option i    similarly consider the path p  in ssdag of t which starts from sopt and ends at sm   and along p   
si  is the parent of sm   along this path  i  is applied before the application of the swap
option i   
suppose i  and i  belongs to or node v  and v  respectively  since along path p    i 
is the swap option which is applied last  sm contains node v    similarly along path p    i 
is the swap option which is applied last  hence sm contains node v    therefore  there must
be an and node vr in t   from which there exist paths to node v  and v   implies that
 i    i     rc   we arrive at a contradiction that proves          k are mutually connected 



definition b u  subgraph of ssdag  consider a solution sp of an alternating and or
tree tand mutually connected set vm of or nodes in sp   where vq  vm   c sp   vq    
s  s   v     hv
copt  vq     the subgraph gsub
p m
sub   esub i of the ssdag with respect to sp and
vm is defined as follows  vsub consists of only those solutions which can be constructed from
sp by applying a sequence of swap options belonging to vm   and esub is the set of edges
corresponding to the swap options that belong to vm  
s  s   v  
lemma b   the number of total possible distinct solutions at each level d in gsub
p m

 
where
 v
 
 
n 
is n d 
m
n 

   

fighosh  sharma  chakrabarti    dasgupta

proof   lemma b    consider the swap options that belong to the nodes in vm   with
s  s   v   is represented by a sequence
respect to these swap options  every solution sr in gsub
p m
of numbers of length n  seq sr    where every number corresponds to a distinct node in vm  
the numerical value of a number represent the rank of the swap option that is chosen for
a node vq  vm   according to the representation  at each level 
i  the sum of numbers in seq sr   of a solution  sr   is equal to the sum of numbers in
seq sr   of any other solution  sr   in that same level 
ii  the sum of numbers in seq sr   of a solution  sr   is increased by   from the sum of
numbers in seq sr   of any solution  sp   of the previous level 
hence  at the dth level  there are n slots and d    increments that need to be made to
seq sr    this is an instance of the well known combinatorial problem of packing n   d   
objects in n slots
with the restriction of keeping at least one object per slot  this can be
n d 
done in n  ways 


theorem b   the solution space tree constructed by algorithm   is complete 
proof   theorem b    for the purpose of contradiction  suppose sm is the first solution
which is not generated by algorithm    also p red sm      spi   and sm can be constructed
from spi by applying qi   where    i  k  from lemma b   it follows that the set of
swap options  qi      i  k  is mutually connected  therefore the set of or nodes vm to
which the swap options belong is also mutually connected  suppose  vm     n 
consider the solution sq   where vm is mutually connected  and for    i  k  every qi
belongs to the set of native swap options of sq with respect the swap option that is used to
construct sq   clearly

vt  vm   c sq   vt     copt  vt  

we argue that sq is generated by algorithm   because sm is the first solution which is
s of t s rooted at s   where only
not generated by algorithm    consider the subtree tsub
q
the edges corresponding to swap options that belong to vm are considered  now we prove
s is equal to the
that the number of solutions generated by algorithm   at every level of tsub
s
number of solutions at the same level in gsub  sq   vm   
consider the solution sq and the set succ sq    suppose succ sq   vm   is the set of
successor solutions that are constructed from sq by applying the swap options belonging

is the minimum cost solution in succ sq   vm    according to
to the nodes in vm   and smin

algorithm   initially succ smin   is partially explored by using the set of native swap options

of smin
  any other non native swap option  b   that belongs to the nodes in vm   is used to


explore succ smin
   right after the sibling solution of smin
  constructed by applying b to sq 
is added to closed  consider the fact that for solution sq   vt  vm   c sq   vt     copt  vt  
holds  therefore all the swap options belonging to vm will also be eventually used to explore

the successors of smin
  similarly the second best successor of sq will be able use all but

 
one swap option  c   which is used to construct smin

s
the immediate children of smin in tsub will consist of all solutions  that can be obtained


by the application of one swap option in vm to smin
  the native swap list of smin
contains
the swap option ranking next to c   the swap options  that are used to construct the other
   

figenerating ordered solutions for explicit and or structures


n    sibling solutions of smin
  will be used again during lazy expansion  which accounts


for another n    children of smin
  hence there would be n children of smin
 
s
similarly  the second best successor of sq in tsub will have n    immediate children 
s will have n    children and so on  now the children
the third best successor of sq in tsub
of these solutions will again have children solutions of their own  increasing the number
of solutions at each level of the tree  this way  with each increasing level  the number of
solutions present in the level keeps increasing  we prove the following proposition as a part
of proving theorem b   
s   is given by
proposition b   at any level d  the number of solutions n  d  n  tsub


n
x
n d 
s
s
n  d  n  tsub    
n  d     k  tsub    
n 
k  

proof   proposition b    at second level  there are n solutions  these give rise to

k  

k 

n 
x

k 

k  

n 
x
k  

k

k  

solutions at third level  similarly at fourth level we have
n
x

n
x

s
s
           
    n     n     tsub
k           n     n  tsub

we can extend this to any level d and the result is as follows 
s
     
n     n  tsub

s
    n
n     n  tsub


n
x
n  
s
n     n  tsub    
k 
 
k  

s
n     n  tsub
 

 

n
x
k  

s
n     k  tsub
 

 




n  
 

s by induction on the depth d 
we determine the number of solutions at any level of tsub

 basis  d        

s     n 
clearly  n     n  tsub



 inductive step    suppose  at dth level the number of solutions is n d 
  n d 
n 
d   
therefore at d    th level 

 



n
x
n d 
n d 
n d 
s
s
n  d      n  tsub    
 
n  d  k  tsub    
        
d 
d 
n 
k  

since algorithm   does not generate duplicate node  and from proposition b   the
s  s   v   at any level is equal to the number of solutions in
number of solutions in gsub
q
m
s  s   v   is also generated by
s
that level of tsub   at any level the set of solutions in gsub
q m
s  s   v    will
s
algorithm   through tsub   therefore  the level  at which sm belongs in gsub
q m
also be generated by algorithm    therefore sm will also be generated by algorithm    a
contradiction which establishes the truth of the statement of theorem b   


   

fighosh  sharma  chakrabarti    dasgupta

appendix c  conversion between and or tree and alternating
and or tree
an and or tree is a generalization of alternating and or tree where the restriction of
strict alternation between and and or nodes are relaxed  in other words an intermediate
or node can be a child of another intermediate or node and the similar parent child
relation is also allowed for and node  we present an algorithm to convert an and or to
an equivalent alternating and or tree 
we use two operations namely  folding and unfolding for the conversions  corresponding
to every edge  a stack  update list  is used for the conversions  in an and or tree  consider
two nodes  vq and vr   of similar type  and or  and they are connected by an edge er  
edges  e         ek emanate from er  
 folding or node    suppose vq and vr are or nodes  the folding of vr is performed
as follows 
 the source of the edges e         ek are changed from vr to vq and the costs are updated
as ce  ei    ce  ei     ce  er     cv  vr   where    i  k  that is the new cost is the sum
of the old cost and the cost of the edge that points to the source of ei   the triplet
hvr   cv  vr    ce  er  i is pushed into the update list of ei      i  k 
 the edge er along with node vr is removed from vq  
 folding and node    suppose vq and vr are and nodes  the folding of vr is performed as follows 
 the source of the edges e         ek are changed from vr to vq   one of the edges among
e         ek   suppose ei   is selected arbitrarily and the cost is updated as ce  ei   
ce  ei     ce  er     cv  vr   where    i  k  the triplet hvr   cv  vr    ce  er  i is pushed into
the update list of ei   whereas the triplet hvr       i is pushed into the update list of ej  
where    j  k and j    i 
 the edge er along with node vr is removed from vq  
the unfolding operation is the reverse of the folding operation and it is same for both
or and and nodes  it works on a node vq as follows 
procedure unfold node vq  
 
 
 
 
 
 
 
 
 
  
  

forall edge ei that emanate from vq do
if the update list of ei is not empty then
hvt   c    c  i  pop update list of ei   
if there exists no edge et from vq that points to the node vt then
create a node vt   and connect vt using edge et from vq  
cv  vt    c   
ce  et    c   
else if c       then
ce  et    c   
end
end

   

figenerating ordered solutions for explicit and or structures

function convert takes the root node of and or tree and transforms it to an equivalent
alternating and or tree recursively 
function convert vq  
 
 
 
 
 
 

 

if every child of vq is a terminal node then
if vq and its parent vp are of same type then
apply f old operation to vq  
end
else
foreach child vr of vq   where vr is an intermediate and or node do
convert vr   
end

function revert takes the root node of an alternating and or tree and converts it to the
original and or tree recursively 
function revert vq  
 
 
 
 
 
 

if every child of vq is a terminal node then
return 
perform unf old operation to vq  
foreach child vr of vq do
revert vr   
end

the overall process of generating alternative solutions of an and or tree is as follows 
the and or tree is converted to an alternating and or tree using convert function 
and the solutions are generated using asg algorithm  the solutions are transformed back
using the revert function  the proof of correctness is presented below 
c   proof of correctness
suppose in an and or tree t two nodes  vq and vr   are of similar type  and or  and
they are connected by an edge er   edges e         ek emanate from er   now fold operation
  is the and or tree which is generated by the application
is applied to vq and vr   let t
of the f old operation 
lemma c   in the context mentioned above  we present the claim of in the following two
propositions 
proposition c   the set of solutions of t having node vq can be generated from the set
  having node v by applying the unfold operation to v of the solutions of
of solutions of t
q
q
t  
  of t   that contains node v   there exists a soluproposition c   for every solution sm
q

 
tion sm of t that can be generated from sm by applying unfold to vq  

proof   proposition c    we present the proof for the following cases  consider any
solution of sm of t that contains node vq  
   

fighosh  sharma  chakrabarti    dasgupta

a  vq and vr are or nodes  there are two cases possible 
   vr is absent from sm   since the fold operation modifies the edge er only  all
    therefore s
the other edges from vq in t are also present in t
m will also
 
be present in the solution set of t and it will remain unchanged after the
application of unfold operation 
   vr is present in sm   since there are k distinct or edges emanating from vr  
let any one of those or edges  say ei   is present in sm   we prove that there is
  of t     such that the application of unfold operation to s   will
a solution sm
m

generate sm   the application of fold operation to the node vr modifies the source
   
and the cost of edge ei from vr to vq and ce  ei   to ce  ei     ce  er     cv  vr   in t
  is a solution of t     where the edge e is present in s     also other
suppose sm
i
m

  and s
than the subtree rooted at vq   the remaining parts of sm
m are identical
 
 
with each other  clearly sm exists as a solution of t and the application of
  generates s  
unfold operation to vq in sm
m
b  vq and vr are and nodes  since vq is an and node sm will contain all of the
and edges that emanate from vq   therefore edge er and vr both will be present in
  of t     such that the following holds 
sm   consider the solution sm

  
   vq is present in sm

   the subtrees rooted at the children of vq other than vr in sm are identical with
   
the subtrees rooted at those children of vq in sm
  and s are identical
   other than the subtree rooted at vq   remaining parts of sm
m
with each other 
  exists as a solution of t   and the application of unfold operation to v
clearly sm
q

 
in sm generates sm  
 of t
 
any other solution sm
 that does not contain node vq   is a valid solution for t
as well 



proof   proposition c    we present the proof for the following cases  consider any
  of t   that contains node v  
solution sm
q

a  vq and vr are or nodes  since vq is an or node  exactly one or edge ei of vq will
    there are two cases possible 
belong to sm
    since the fold operation modifies
   ei was not modified while folding vr in t
the edge er and the or edges of vr only  all the other edges from vq in t are
    since e was not modified during folding  the same solution
also present in t
i
 
sm is also a valid solution for t  
    suppose e connects v and v in
   ei was modified while folding vr in t
i
q
i
  and generate solution s  
 
sm   apply the unfold operation to the node vq in sm
m
the edge ei will be replaced with edge er which connects vq and vr and then ei
will connect vr and vi   we argue that sm is a valid solution of t since the

   

figenerating ordered solutions for explicit and or structures

subtree rooted at vi is not modified by the sequence of   a  the folding of vr to
  from t   and  b  the unfolding of v to construct s from s    
construct t
q
m

m
  will contain all of the
b  vq and vr are and nodes  since vq is an and node  sm
and edges that emanate from vq   there are two types of and edges emanating from
  and they are  a  type     the edges from v that are also present in t
vq in t
q
 from
vq    b  type     the edges that are added to vq by folding and these edges are from
  and generate solution
vr in t   apply the unfold operation to the node vq in sm
sm   sm will contain type   edges  and another edge er from vq   in sm   vq and vr
are connected by er and the type   edges are originated from vr   we argue that sm
is a valid solution of t since the subtree rooted at nodes pointed by type   edges
  from t  
are not modified by the sequence of   a  the folding of vr to construct t

  
and  b  the unfolding of vq to construct sm from sm


  of t   that does not contain node v is valid solution for t
clearly any solution sm
q
 as

well 



lemma c   if function convert is applied to the root node of any and or tree t   an
alternating and or tree t is generated 
proof   lemma c    function convert traverses every intermediate node in a depth first
manner  consider any sequence of nodes  vq    vq         vqn of same type  where vqi is the
parent of vqi   in t and    i   n  obviously  the fold operation is applied to vqi  
before vqi   where    i   n  in other words  the fold operation applied to the sequence of
nodes in the reverse order and after folding vqi     all the edges of vqi   are modified and
moved to vqi   where    i   n  when the function call convert vq    returns  all the edges
of vq         vqn are already moved to vq  and the sequence of nodes  vq    vq         vqn are
flattened  therefore  every sequence of nodes of same type are flattened  when the function
call convert vr   returns  where vr is the root of t and an alternating and or tree
t is generated 
lemma c   if function revert is applied to an alternating and or tree t   the updatelist of every edge in t becomes empty 
proof   lemma c    follows from the description of revert 
theorem c   for any and or tree t   it is possible to construct an alternating and or
tree t using function convert  where the set of all possible solutions of t is generated
in the order of their increasing cost by applying algorithm   to t   and then converting
individual solutions using function revert 
proof   theorem c    according to lemma c    after the application of function convert
to t an alternating and or tree t is generated  consider the intermediate and or
    t          t n are the
trees that are the generated after folding every node in t   let t


n   since t i is generated from t i  
    t   t
 
t
sequence of and or trees and t





   

fighosh  sharma  chakrabarti    dasgupta

i   where    i   n  according
after folding exactly one node in t
i can be generated from t i   by unfolding the same
solutions of t

lemma c    for any solution of t   revert unfolds every node vq in
vq was folded by convert while transforming t to t   therefore
can be generated from the solutions of t  

to lemma c    the
node  according to
that solution  where
the solutions of t

references
bonet  b     geffner  h          an algorithm better than ao    in proceedings of the
  th national conference on artificial intelligence   volume    pp            aaai
press 
chakrabarti  p  p          algorithms for searching explicit and or graphs and their
applications to problem reduction search  artif  intell                  
chakrabarti  p  p   ghose  s   pandey  a     desarkar  s  c          increasing search
efficiency using multiple heuristics  inf  process  lett                  
chang  c  l     slagle  j  r          an admissible and optimal algorithm for searching
and or graphs  artif  intell                 
chegireddy  c  r     hamacher  h  w          algorithms for finding k best perfect matchings  discrete applied mathematics                 
chen  h   xu  z  j   liu  z  q     zhu  s  c          composite templates for cloth modeling
and sketching  in proceedings of the      ieee computer society conference on
computer vision and pattern recognition   volume    pp          ieee computer
society 
cormen  t  h   stein  c   rivest  r  l     leiserson  c  e          introduction to algorithms
  nd edition   mcgraw hill higher education 
darwiche  a          compiling knowledge into decomposable negation normal form  in
proceedings of the   th international joint conference on artifical intelligence   volume
   pp          morgan kaufmann publishers inc 
darwiche  a          decomposable negation normal form  j  acm             
dasgupta  p   sur kolay  s     bhattacharya  b          vlsi floorplan generation and
area optimization using and or graph search  in vlsi design         proceedings of
the  th international conference on  pp          
dechter  r     mateescu  r          and or search spaces for graphical models  artif 
intell                    
ebendt  r     drechsler  r          weighted a search   unifying view and application 
artificial intelligence                       
elliott  p          extracting the k best solutions from a valued and or acyclic graph 
masters thesis  massachusetts institute of technology 
elliott  p     williams  b          dnnf based belief state estimation  in proceedings of
the   st national conference on artificial intelligence   volume    pp        aaai
press 
   

figenerating ordered solutions for explicit and or structures

eppstein  d          finding the k smallest spanning trees  in proc   nd scandinavian
worksh  algorithm theory  no      in lecture notes in computer science  pp    
    springer verlag 
eppstein  d          finding the k shortest paths  siam j  comput                  
flerova  n     dechter  r          m best solutions over graphical models  in  st workshop
on constraint reasoning and graphical structures 
flerova  n     dechter  r          bucket and mini bucket schemes for m best solutions
over graphical models  in gkr      a workshop of ijcai       
fromer  m     globerson  a          an lp view of the m best map problem  in advances
in neural information processing systems  nips      pp         
fuxi  z   ming  t     yanxiang  h          a solution to billiard balls puzzle using ao
algorithm and its application to product development  in palade  v   howlett  r    
jain  l   eds    knowledge based intelligent information and engineering systems 
vol       of lecture notes in computer science  pp            springer berlin  
heidelberg 
gogate  v     dechter  r          approximate solution sampling  and counting  on
and or spaces  in cp  pp         
gu  z   li  j     xu  b          automatic service composition based on enhanced service
dependency graph  in web services        icws     ieee international conference
on  pp          
gu  z   xu  b     li  j          service data correlation modeling and its application in
data driven service composition  services computing  ieee transactions on        
       
gupta  p   chakrabarti  p  p     ghose  s          the towers of hanoi  generalizations 
specializations and algorithms  international journal of computer mathematics     
       
hamacher  h  w     queyranne  m          k best solutions to combinatorial optimization
problems  annals of operations research            
hansen  e  a     zhou  r          anytime heuristic search  j  artif  intell  res   jair  
           
hansen  e  a     zilberstein  s          lao    a heuristic search algorithm that finds
solutions with loops  artificial intelligence                    
homem de mello  l     sanderson  a          and or graph representation of assembly
plans  robotics and automation  ieee transactions on                 
jimenez  p     torras  c          an efficient algorithm for searching implicit and or
graphs with cycles  artif  intell            
kleinberg  j     tardos  e          algorithm design  addison wesley longman publishing
co   inc   boston  ma  usa 
lang  q  a     su  y          and or graph and search algorithm for discovering composite web services  international journal of web services research              
   

fighosh  sharma  chakrabarti    dasgupta

lawler  e  l          a procedure for computing the k best solutions to discrete optimization
problems and its application to the shortest path problem  management science 
        pp         
ma  x   dong  b     he  m          and or tree search algorithm in web service composition  in paciia     proceedings of the      ieee pacific asia workshop on
computational intelligence and industrial application  pp        washington  dc 
usa  ieee computer society 
majumdar  a  a  k          generalized multi peg tower of hanoi problem  the journal
of the australian mathematical society  series b  applied mathematics             
marinescu  r     dechter  r          and or branch and bound for solving mixed integer
linear programming problems  in cp  p      
marinescu  r     dechter  r          memory intensive branch and bound search for graphical models  in aaai 
marinescu  r     dechter  r       a   best first and or search for     integer programming  in cpaior  pp         
marinescu  r     dechter  r       b   best first and or search for graphical models  in
aaai  pp           
marinescu  r     dechter  r       a   and or branch and bound search for combinatorial
optimization in graphical models  artif  intell                         
marinescu  r     dechter  r       b   memory intensive and or search for combinatorial
optimization in graphical models  artif  intell                         
martelli  a     montanari  u          additive and or graphs  in proceedings of the
 rd international joint conference on artificial intelligence  san francisco  ca  usa 
morgan kaufmann publishers inc 
martelli  a     montanari  u          optimizing decision trees through heuristically guided
search  commun  acm               
mateescu  r     dechter  r          and or multi valued decision diagrams for constraint
networks  in concurrency  graphs and models  pp         
mateescu  r   dechter  r     marinescu  r          and or multi valued decision diagrams  aomdds  for graphical models  j  artif  intell  res   jair              
mathews  d  h     zuker  m          rna secondary structure prediction  in encyclopedia
of genetics  genomics  proteomics and bioinformatics  john wiley   sons  ltd 
nilsson  d          an efficient algorithm for finding the m most probable configurations
in probabilistic expert systems  statistics and computing            
nilsson  n  j          principles of artificial intelligence  tioga publishing co 
otten  l     dechter  r          anytime and or depth first search for combinatorial
optimization  in socs 
pearl  j          heuristics  intelligent search strategies for computer problem solving 
addison wesley longman publishing co   inc   boston  ma  usa 
   

figenerating ordered solutions for explicit and or structures

russell  s     norvig  p          artificial intelligence  a modern approach   nd edition
edition    chap  planning  pp          prentice hall  englewood cliffs  nj 
shiaa  m  m   fladmark  j  o     thiell  b          an incremental graph based approach
to automatic service composition  ieee international conference on services computing              
shin  d  h   jeon  h  b     lee  k  h          a sophisticated approach to composing
services based on action dominance relation  in services computing conference  apscc        ieee asia pacific  pp          
subramanian  s          routing algorithms for dynamic  intelligent transportation networks  masters thesis  virginia technical univ   dept  of civil engineering 
sugimoto  k     katoh  n          an algorithm for finding k shortest loopless paths
in a directed network  trans  information processing soc  japan              in
japanese 
szymanski  m   barciszewska  m  z   barciszewski  j     erdmann  v  a           s ribosomal rna database  http   biobases ibch poznan pl  sdata   online database 
takkala  t   borndorfer  r     lobel  a          dealing with additional constraints in the
k shortest path problem  in proc  wm      
topkis  d  m          a k shortest path algorithm for adaptive routing in communications
networks  trans  communications                 
yan  y   xu  b     gu  z          automatic service composition using and or graph  in
e commerce technology and the fifth ieee conference on enterprise computing 
e commerce and e services         th ieee conference on  pp         

   

fi