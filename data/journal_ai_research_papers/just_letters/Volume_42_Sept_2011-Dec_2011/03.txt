journal of artificial intelligence research                  

submitted       published      

unfounded sets and well founded semantics
of answer set programs with aggregates
mario alviano
francesco calimeri
wolfgang faber
nicola leone
simona perri

alviano mat unical it
calimeri mat unical it
faber mat unical it
leone mat unical it
perri mat unical it

department of mathematics
university of calabria
i       rende  cs   italy

abstract
logic programs with aggregates  lpa   are one of the major linguistic extensions to
logic programming  lp   in this work  we propose a generalization of the notions of unfounded set and well founded semantics for programs with monotone and antimonotone
aggregates  lpa
m a programs   in particular  we present a new notion of unfounded set
a
for lpm a programs  which is a sound generalization of the original definition for standard
 aggregate free  lp  on this basis  we define a well founded operator for lpa
m a programs 
the fixpoint of which is called well founded model  or well founded semantics  for lpa
m a
programs  the most important properties of unfounded sets and the well founded semantics for standard lp are retained by this generalization  notably existence and uniqueness
of the well founded model  together with a strong relationship to the answer set semantics for lpa
m a programs  we show that one of the d well founded semantics  defined by
pelov  denecker  and bruynooghe for a broader class of aggregates using approximating
operators  coincides with the well founded model as defined in this work on lpa
m a programs  we also discuss some complexity issues  most importantly we give a formal proof of
tractable computation of the well founded model for lpa
m a programs  moreover  we prove
a
that for general lp programs  which may contain aggregates that are neither monotone
nor antimonotone  deciding satisfaction of aggregate expressions with respect to partial
interpretations is conp complete  as a consequence  a well founded semantics for general
lpa programs that allows for tractable computation is unlikely to exist  which justifies the
restriction on lpa
m a programs  finally  we present a prototype system extending dlv 
which supports the well founded semantics for lpa
m a programs  at the time of writing the
only implemented system that does so  experiments with this prototype show significant
computational advantages of aggregate constructs over equivalent aggregate free encodings 

   introduction
the use of logical formulas as a basis for a knowledge representation language was proposed about    years ago in some seminal works of mccarthy         and mccarthy and
hayes         however  it was soon realized that the monotonic nature of classical logic
 the addition of new knowledge may only increase the set of consequences of a theory in
classical logic  is not always suited to model commonsense reasoning  which sometimes is
intrinsically nonmonotonic  minsky         as an alternative  it was suggested to represent
c
    
ai access foundation  all rights reserved 

fialviano  calimeri  faber  leone    perri

commonsense reasoning using logical languages with nonmonotonic consequence relations 
which can better simulate some forms of human reasoning  allowing new knowledge to invalidate some of the previous conclusions  this observation opened a new and important
research field  called nonmonotonic reasoning  and led to the definition and investigation of
new logical formalisms  called nonmonotonic logics  the most popular nonmonotonic logics
are circumscription  mccarthy               default logic  reiter         and nonmonotonic
modal logics  mcdermott   doyle        mcdermott        moore         later on  from
cross fertilizations between the field of nonmonotonic logics and that of logic programming 
another nonmonotonic language  called declarative logic programming  lp  has emerged 
incorporating a nonmonotonic negation operator denoted by not  declarative logic programming has gained popularity in the last years  and today it is a widely used formalism for
knowledge representation and reasoning  with applications in various scientific disciplines
and even in industry  ricca  alviano  dimasi  grasso  ielpa  iiritano  manna    leone 
      ricca  grasso  alviano  manna  lio  iiritano    leone        manna  ricca    terracina        manna  ruffolo  oro  alviano    leone         in lp problems are solved by
means of declarative specifications of requirements to be achieved  no ad hoc algorithms
are required 
several semantics for lp have been proposed in the literature  which have to take care
about the inherent non monotonicity of the not operator in programs  the well founded
semantics  van gelder  ross    schlipf        is one of the most prominent among them  it
associates a three valued model  the well founded model  to every logic program  originally 
the well founded semantics has been defined for normal logic programs  that is  standard
logic programs with nonmonotonic negation  a distinguishing property of the well founded
semantics is that existence and uniqueness of the well founded model is guaranteed for all
logic programs  moreover  the well founded semantics is computable in polynomial time
with respect to the input program in the propositional case 
even if lp is a declarative programming language  standard lp does not allow for
representing properties over sets of data in a natural way  a relevant aspect in many application domains  for addressing this insufficiency  several extensions of lp have been
proposed  the most relevant of which is the introduction of aggregate functions  lpa  
kemp   stuckey        denecker  pelov    bruynooghe        dix   osorio        gelfond        simons  niemela    soininen        dellarmi  faber  ielpa  leone    pfeifer 
      pelov   truszczynski        pelov  denecker    bruynooghe         among them 
recursive definitions involving aggregate functions  i e   aggregation in which aggregated
data depend on the evaluation of the aggregate itself  are particularly interesting  as the
definition of their semantics is not straightforward  pelov        faber  leone    pfeifer 
      son   pontelli        liu  pontelli  son    truszczynski         note that a similar
construct  referred to as abstract constraint  has been introduced in the literature  marek
  truszczynski        liu   truszczynski        son  pontelli    tu        truszczynski 
      brewka         all of the results in this paper carry over also to lp with abstract
constraints  for which well founded semantics to our knowledge has not been defined so far 
in this paper we focus on the fragment of lpa allowing for monotone and antimonotone
a
aggregate expressions  lpa
m a   calimeri  faber  leone    perri         lpm a programs
have many interesting properties  among them  we highlight similarities between monotone
aggregate expressions and positive standard literals  and between antimonotone aggregate
   

fiunfounded sets and well founded semantics of asp programs with aggregates

expressions and negative standard literals  in particular  we take advantage of this aspect
for defining unfounded sets and  based on this definition  a well founded semantics for the
a
lpa
m a fragment  the well founded semantics for lpm a programs obtained in this way
retains many desirable properties of the original well founded semantics for lp  which it
extends  for each lpa
m a program a unique well founded model exists  which is polynomialtime computable  approximates the programs answer sets  and coincides with the answer
set on stratified lpa
m a programs 
actually it turns out that the well founded semantics thus obtained coincides  on lpa
m a
programs  with a well founded semantics proposed by pelov  denecker  and bruynooghe
        pelov et al  define several semantics of logic programs with aggregates using various approximating immediate consequence operators  the notion of logic program adopted
by pelov et al  is more general than the one considered in the present work  allowing
for arbitrary first order formulas in bodies  unrestricted aggregates  and non herbrand interpretations  because of the equivalence of the two semantics  some properties proved by
pelov et al  carry over to this work as well  this applies to the results that the well founded
model is total on stratified programs  theorem     that the well founded model is contained
in each answer set  theorem      and that the well founded model is computable in polynomial time  theorem      however  the framework introduced in this article is considerably
different from the one developed by pelov et al   which allows for giving alternative proofs
to these result  vice versa  this article contains many new results  which carry over to the
framework of pelov et al  on lpa
m a programs  in particular  it provides an alternative
definition of the well founded semantics  a characterization of answer sets by means of unfounded sets  and an implemented system computing the well founded semantics  at the
time of writing the only one of its kind 
we would like to point out that for most extensions of lpa
m a programs that come to
mind  the definition of unfounded sets would have to be considerably changed  see for instance the definition provided in faber         and moreover the main desired properties
of the well founded semantics would no longer be guaranteed  for instance  the most obvious extension  including aggregate expressions that are neither monotone nor antimonotone
would most likely not be computable in polynomial time  in fact  while the evaluation of
aggregate expressions with respect to partial interpretations is tractable for monotone and
antimonotone aggregates  the same task is conp complete for general aggregate expressions  also  for instance allowing aggregates in rule heads would necessarily complicate the
definition of unfounded sets  would not guarantee the existence of a well founded model for
every program  and would most likely not guarantee polynomial time computability 
the concepts defined in this paper directly give rise to a computation method for the
well founded semantics on lpa
m a programs  we have implemented this method  which is
to the best of our knowledgethe first of its kind  we have conducted experiments with
this system on lpa
m a encodings of a particular problem domain  and compared it with
encodings not using aggregates  the latter encodings were tested with the system from
which our prototype was derived and with xsb  a state of the art system for computing
the well founded model  the experiments show a clear advantage of the lpa
m a encodings
run on our prototype system 
summarizing  the main contributions of the paper are as follows 
   

fialviano  calimeri  faber  leone    perri

 we define a new notion of unfounded set for logic programs with monotone and
antimonotone aggregates  lpa
m a programs   this notion is a sound generalization of
the concept of unfounded set previously given for standard logic programs  we show
that our definition coincides with the original definition of unfounded sets  van gelder
et al         on the class of normal  aggregate free  programs  and that it shares its
distinguishing properties  such as the existence of the greatest unfounded set  
 we define a well founded operator wp for logic programs with aggregates  which extends the classical well founded operator  van gelder et al          the total fixpoints
of wp are exactly the answer sets of p  and its least fixpoint wp    is contained in
the intersection of all answer sets  we also show that the operator is equivalent to an
operator defined by pelov et al         
 we provide a declarative characterization of answer sets in terms of unfounded sets 
in particular  we prove that the answer sets of an lpa
m a program are precisely the
unfounded free models 
 we show that reasoning with aggregates without restrictions may easily increase the
complexity of the computation  in particular  we prove that deciding the truth
or falsity of an aggregate expression with respect to a partial interpretation is a
conp complete problem  however  while the problem is intractable in general  it
is polynomial time solvable for monotone and antimonotone aggregates 
 we analyze the complexity of the well founded semantics  confirming and extending
results in the work of pelov et al          importantly  it turns out that wp   
is polynomial time computable for propositional lpa
m a programs  for non ground
programs  the data complexity remains polynomial  while the program complexity
rises from p to exptime  as for aggregate free programs 
 we present a prototype system supporting the well founded semantics defined in this
article  the prototype  obtained by extending dlv  is the first system implementing
a well founded semantics for  unrestricted  lpa
m a programs 
 we report on experimental results on the implemented prototype  more specifically 
we define the attacks problem  a problem inspired by the classic win lose problem
often considered in the context of the well founded semantics for standard logic programs  we compare the execution times of our prototype with an lpa
m a encoding and
with equivalent lp encodings  in particular  one of the tested lp encodings is obtained by means of a compilation of aggregates into standard lp  which is also briefly
presented in this paper  the obtained results evidence computational advantages for
the problem encoding using aggregate expressions over those without them 
the presentation is organized as follows  in section   we present the basics of the
lpa language and  in particular  we introduce the lpa
m a fragment  for this fragment 
we define unfounded sets and well founded semantics in section    relationships between
well founded semantics and answer set semantics are discussed in section    a complexity
analysis of the well founded semantics for lpa
m a programs is reported in section    in
   

fiunfounded sets and well founded semantics of asp programs with aggregates

section   we discuss the implemented prototype system and the experimentation  finally 
related work is discussed in section    and in section   we draw our conclusions 

   the lpa language
syntax  instantiation  interpretations and models of lpa programs are introduced in this
section  moreover  we introduce the lpa
m a fragment of the language  for which we define a
well founded semantics in section    for additional background on standard lp  we refer
to the literature  gelfond   lifschitz        baral        
    syntax
we assume sets of variables  constants  and predicates to be given  similar to prolog  we
assume variables to be strings starting with uppercase letters and constants to be nonnegative integers or strings starting with lowercase letters  predicates are strings starting
with lowercase letters  an arity  non negative integer  is associated with each predicate 
moreover  the language allows for using built in predicates  i e   predicates with a fixed
meaning  for the common arithmetic operations over positive integers  i e              
etc   written in infix notation   which are interpreted in the standard mathematical way 
      standard atom
a term is either a variable or a constant  a standard atom is an expression p t            tn   
where p is a predicate of arity n and t            tn are terms  an atom p t            tn   is ground if
t            tn are constants 
      set term
a set term is either a symbolic set or a ground set  a symbolic set is a pair  terms   conj   
where terms is a list of terms  variables or constants  and conj is a conjunction of standard
atoms  that is  conj is of the form a            ak and each ai     i  k  is a standard
atom  intuitively  a set term  x   a x  c   p x   stands for the set of x values making the
conjunction a x  c   p x  true  i e    x   a x  c  and p x  are true   a ground set is a set of
pairs of the form hconsts   conj i  where consts is a list of constants and conj is a conjunction
of ground standard atoms 
      aggregate function
an aggregate function is of the form f  s   where s is a set term  and f is an aggregate
function symbol  intuitively  an aggregate function can be thought of as a  possibly partial 
function mapping multisets of constants to a constant  throughout the remainder of the
paper  we will adopt the notation of the dlv system  leone  pfeifer  faber  eiter  gottlob 
perri    scarcello        for representing aggregates 
example   the most common aggregate functions are listed below 
  min  minimal term  undefined for the empty set 
  max  maximal term  undefined for the empty set 
   

fialviano  calimeri  faber  leone    perri

  count  number of terms 
  sum  sum of integers 
  times  product of integers 
  avg  average of integers  undefined for the empty set 
      aggregate atom
an aggregate atom is a structure of the form f  s   t   where f  s  is an aggregate function 
             is a comparison operator  and t is a term  variable or constant   an
aggregate atom f  s   t is ground if t is a constant and s is a ground set 
example   the following are aggregate atoms in dlv notation 
 max z   r z   a z  v      y
 max h    r     a    m i  h    r     a    n i     

      literal
a literal is either  i  a standard atom  or  ii  a standard atom preceded by the negation as
failure symbol not  or  iii  an aggregate atom  two standard literals are complementary if
they are of the form a and not a  for some standard atom a  for a standard literal   we
denote by   the complement of   abusing of notation  if l is a set of standard literals 
then  l denotes the set        l  
      program
a rule r is a construct of the form
a               m  

where a is a standard atom              m are literals  and m     the atom a is referred
to as the head of r  and the conjunction             m as the body of r  if the body is empty
 m       then the rule is called fact  we denote the head atom by h r    a  and the set of
body literals by b r                 m    moreover  the set of positive standard body literals
is denoted by b    r   the set of negative standard body literals by b   r   and the set of
aggregate body literals by b a  r   a rule r is ground if h r  and all the literals in b r  are
ground  a program is a set of rules  a program is ground if all its rules are ground 
      safety
a local variable of a rule r is a variable appearing solely in sets terms of r  a variable of r
which is not local is global  a rule r is safe if both the following conditions hold   i  for each
global variable x of r there is a positive standard literal   b    r  such that x appears in
   ii  each local variable of r appearing in a symbolic set  terms   conj   also appears in
conj   note that condition  i  is the standard safety condition adopted in lp to guarantee
that the variables are range restricted  ullman         while condition  ii  is specific for
aggregates  a program is safe if all its rules are safe 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

example   consider the following rules 
p x    q x  y  v     max z   r z   a z  v      y 
p x    q x  y  v     sum z   r x   a x  s     y 
p x    q x  y  v     min z   r z   a z  v      t 

the first rule is safe  while the second is not because the local variable z violates condition
 ii   also the third rule is not safe  since the global variable t violates condition  i  
    program instantiation  interpretations and models
in section   we define a well founded semantics for a relevant class of lpa programs 
the well founded semantics is defined for ground programs  while programs with variables
are associated with equivalent ground programs  in this section we introduce preliminary
notions such as program instantiation  interpretations and models 
      universe and base
given an lpa program p  the universe of p  denoted by up   is the set of constants
appearing in p  the base of p  denoted by bp   is the set of standard atoms constructible
from predicates of p with constants in up  
      instantiation
a substitution is a mapping from a set of variables to up   given a substitution  and
an lpa object obj  rule  set  etc    we denote by obj  the object obtained by replacing
each variable x in obj by  x   a substitution from the set of global variables of a rule
r  to up   is a global substitution for r  a substitution from the set of local variables of a
set term s  to up   is a local substitution for s  given a set term without global variables
s    terms   conj    the instantiation of s is the following ground set 
inst s     hterms    conj i    is a local substitution for s  
a ground instance of a rule r is obtained in two steps  first  a global substitution  for r
is applied  and then every set term s in r is replaced by its instantiation inst s   the
instantiation ground p  of a program p is the set of instances of all the rules in p 
example   consider the following program p   
q      not p       
p         not q    

q      not p       
p         not q    

t x    q x    sum y   p x  y        

the instantiation ground p    of p  is the following program 
q      not p       
p         not q    

q      not p       
p         not q    

t      q      sum h    p      i  h    p      i      
t      q      sum h    p      i  h    p      i      

      aggregate function domain
x

given a set x  let   denote the set of all multisets over elements from x  the domain of
an aggregate function is the set of multisets on which the function is defined  without loss
of generality  we assume that aggregate functions map to z  the set of integers  
   

fialviano  calimeri  faber  leone    perri

example   let us look at common domains for the aggregate functions of example   
u
z
 count is defined over    p  sum and  times over      min   max and  avg over
z
       
      interpretation
an interpretation i for an lpa program p is a consistent set of standard ground literals 
that is  i  bp   bp and i   i     we denote by i   and i  the set of standard
positive and negative literals occurring in i  respectively  an interpretation i is total if
i     i    bp   otherwise i is partial  the set of all the interpretations of p is denoted
by ip   given an interpretation i and a standard literal   the evaluation of  with respect
to i is defined as follows   i  if   i  then  is true with respect to i   ii  if    i  then
 is false with respect to i   iii  otherwise  if    i and     i  then  is undefined with
respect to i  an interpretation also provides a meaning to set terms  aggregate functions
and aggregate literals  namely a multiset  a value  and a truth value  respectively  we
first consider a total interpretation i  the evaluation i s  of a set term s with respect
to i is the multiset i s  defined as follows  let s i    ht         tn i   ht         tn   conj i 
s and all the atoms in conj are true with respect to i   i s  is the multiset obtained as
the projection of the tuples of si on their first constant  that is  i s     t    ht         tn i  s i   
the evaluation i f  s   of an aggregate function f  s  with respect to i is the result of the
application of f on i s    if the multiset i s  is not in the domain of f   then i f  s     
 where  is a fixed symbol not occurring in p   a ground aggregate atom    f  s   k is
true with respect to i if both i f  s       and i f  s    k hold  otherwise   is false 
example   let i  be a total interpretation having i      f      g        g        g        g       
h     h     h      assuming that all variables are local  we can check that 
  count x   g x  y        is false  indeed  if s  is the corresponding ground set  then
s i     h i  h i   i   s             and  count             
  count x  y   g x  y        is true  indeed  if s  is the corresponding ground set 
then s i     h    i  h    i  h    i  h    i   i   s                   and  count                   
  times y   f  x   g x  y          is true  indeed  if s  is the corresponding ground
set  then s i     h i  h i  h i   i   s                and  times                 
  sum x   g x  y    h y         is true  indeed  if s  is the corresponding ground set 
then s i     h i  h i   i   s             and  sum             
  sum x  y   g x  y    h y         is false  indeed  if s  is the corresponding ground
set  then s i     h    i  h    i  h    i  h    i   i   s                   and  sum                
   
  min x   f  x   h x        is false  indeed  if s  is the corresponding ground set 
then s i      i   s        and i    min        we recall that  is not in the domain
of  min  
   in this paper  we only consider aggregate functions value of which is polynomial time computable with
respect to the input multiset 

   

fiunfounded sets and well founded semantics of asp programs with aggregates

we now consider a partial interpretation i and refer to an interpretation j such that
i  j as an extension of i  if a ground aggregate atom  is true  resp  false  with respect
to each total interpretation j extending i  then  is true  resp  false  with respect to i 
otherwise   is undefined 
example   let s  be the ground set in the literal      sum h    p      i  h    p      i   
   and consider a partial interpretation i     p         since each total interpretation
extending i  contains either p       or not p        we have either i   s          or i   s     
        thus  the application of  sum yields either       or        and thus   is true with
respect to i   
remark   observe that our definitions of interpretation and truth values preserve knowledge monotonicity  if an interpretation j extends i  i e   i  j   each literal which is true
with respect to i is true with respect to j  and each literal which is false with respect to i
is false with respect to j as well 
      model
given an interpretation i  a rule r is satisfied with respect to i if at least one of the following
conditions is satisfied   i  h r  is true with respect to i   ii  some literal in b r  is false
with respect to i   iii  h r  and some literal in b r  are undefined with respect to i  an
interpretation m is a model of an lpa program p if all the rules r in ground p  are
satisfied with respect to m  
example   consider again the program p  of example    let i  be a total interpretation
for p  such that i      q     p        t      then i  is a minimal model of p   
    the lpa
m a language
a
the definition of lpa
m a programs  the fragment of lp analyzed in this paper  is based on
the following notion of monotonicity of literals 

      monotonicity
given two interpretations i and j  we say that i  j if i    j   and i   j    a
ground literal  is monotone if  for all interpretations i  j such that i  j  we have that 
 i   true with respect to i implies  true with respect to j  and  ii   false with respect
to j implies  false with respect to i  a ground literal  is antimonotone if the opposite
happens  that is  for all interpretations i  j such that i  j  we have that   i   false with
respect to i implies  false with respect to j  and  ii   true with respect to j implies
 true with respect to i  a ground literal  is nonmonotone if  is neither monotone nor
antimonotone  note that positive standard literals are monotone  whereas negative standard
literals are antimonotone  aggregate literals  instead  may be monotone  antimonotone or
nonmonotone  some examples are shown below and the complete picture for the most
common aggregate functions is summarized in table   
example   let us assume a universe in which all numerical constants are non negative
integers  all ground instances of the following aggregate literals are thus monotone 
   

fialviano  calimeri  faber  leone    perri

table    character of the most common aggregate literals 
function domain operator
character
 count
any
   
monotone
   
antimonotone
 sum
n
   
monotone
   
antimonotone
z
         nonmonotone
 times
n 
   
monotone
   
antimonotone
n  z
         nonmonotone
 min
any
   
nonmonotone
   
monotone
 max
any
   
monotone
   
nonmonotone
 avg
n  z
         nonmonotone


antimonotone if the context guarantees that the set term of the aggregate never becomes empty 

 sum z   r z       

 count z   r z       

ground instances of the following literals are instead antimonotone 
 sum z   r z       

 count z   r z       

      lpa
m a programs
a
let lpa
m a denote the fragment of lp allowing monotone and antimonotone literals  for
an lpa
m a rule r  the set of its monotone and antimonotone body literals are denoted by
m
b  r  and b a  r   respectively  an lpa
m a program p is stratified if there exists a function
        called level mapping  from the set of predicates of p to ordinals  such that for each
pair a  b of predicates  occurring in the head and body of a rule r  p  respectively   i  if b
appears in an antimonotone literal  then   b       a     ii  otherwise   b      a    intuitively 
stratification forbids recursion through antimonotone literals  for aggregate free programs
this definition coincides with the common notion of stratification with respect to negation  

example    consider an lpa
m a program consisting of the following rules 
q x    p x    count y   a y  x   b x      
p x    q x   b x  

and assume that the predicates a and b are defined by facts  which we do not include
explicitly  the program is stratified  as the level mapping   a       b          p       q      
satisfies the required conditions  if we add the rule b x    p x   then no such levelmapping exists  and the program becomes unstratified 
we would like to note that the definition of lpa
m a could be enlarged  as in the form
given above classifies literals independently of the context  that is  the program  in which
   

fiunfounded sets and well founded semantics of asp programs with aggregates

they occur  some aggregates that are nonmonotone by the definition given above  might
not manifest their nonmonotone effects in a given context  if one limits the interpretations
to be considered to those that do not violate the program in which the literal occurs 
some interpretation pairs that violate monotonicity and antimonotonicity may no longer
be present  in fact  one could refine the definition in this way  considering only pairs of
non violating interpretations of a given context program   the modified definition would
enlarge the class of lpa
m a programs  while retaining all of the results in this paper  but for
simplicity of exposition we refrain from doing it formally  as an example  any aggregate
atom involving  max with a   operator is formally not in lpa
m a   but when one considers
occurrences in a program that has no non violating interpretation i such that i s    
 where s the set term of the aggregate   then the aggregate behaves in an antimonotone
way in that particular program  we have noted these cases by a footnote in table   

   unfounded sets and well founded semantics
in this section we introduce a new notion of unfounded set for lpa
m a programs  which
extends the original definition for aggregate free programs introduced by van gelder et al 
        unfounded sets are then used for extending the well founded semantics  originally
defined for aggregate free programs by van gelder et al   to lpa
m a programs  we also
highlight a number of desirable properties of this semantics  in the following we deal with
ground programs  so we will usually denote by p a ground program  we will also use the
notation l   l for the set  l   l     l   where l and l are sets of standard ground
literals 
definition    unfounded set  a set x  bp of ground atoms is an unfounded set for
an lpa
m a program p with respect to a  partial  interpretation i if and only if  for each rule
r  p having h r   x   at least one of the following conditions holds 
    some  antimonotone  literal in b a  r  is false with respect to i  or
    some  monotone  literal in b m  r  is false with respect to i   x  
intuitively  each rule with its head atom belonging to an unfounded set x is already
satisfied with respect to i  in case condition     holds   or it is satisfiable by taking as false
all the atoms in the unfounded set  in case condition     holds   note that  according to
the definition above  the empty set is an unfounded set with respect to every program and
interpretation 
example    consider an interpretation i     a     a     a     for the following program
p   
r   
r   
r   

a       count h    a   i  h    a   i  h    a   i      
a    
a       count h    a   i  h    a   i  h    a   i      

then x     a     is an unfounded set for p  with respect to i    since condition     of
definition   holds for r   the only rule with head a      indeed  the  monotone  literal
appearing in b m  r    is false with respect to i    x     not a     a     a      similarly 
 a     and  a     a     are unfounded sets for p  with respect to i    clearly  also  is an
unfounded set  all other sets of atoms are not unfounded for p  with respect to i   
   

fialviano  calimeri  faber  leone    perri

as formalized below  definition   generalizes the one given by van gelder et al        
for aggregate free programs  a set of standard atoms x  bp is an unfounded set for a
program p with respect to an interpretation i if and only if  for each rule r  p such that
h r   x   either  i  b r    i      or  ii  b    r   x  
   
theorem   for an aggregate free program p  definition   is equivalent to the one introduced in the work of van gelder et al         
proof  for an aggregate free program p  conditions     and     of definition   are equivalent to  a  b   r    i     and  b  b    r     i   x        respectively  condition  b 
is equivalent to b    r      i   x      x        which holds if and only if either  b   
b    r     i   x        or  b    b    r   x  
    condition  b    is exactly condition  ii 
in the work of van gelder et al  concerning condition  b     since b    r  contains only
positive literals  we can ignore the negative literals in   i   x    that is  the positive literals
in i   x   by noting that the negative literals in i   x are precisely the negative literals in
i  we can then conclude that  b    is equivalent to b    r    i      finally  by combining
the previous statement with condition  a  above  we obtain condition  i  in the work of van
gelder et al 

thus  definition   is an alternative characterization of unfounded sets for aggregate free
programs  in fact  while condition     of definition   does not exactly cover the first one in
van gelder et al   condition     catches all cases of the second in the work of van gelder
et al  and those missed by condition     
theorem   if x and x  are unfounded sets for an lpa
m a program p with respect to an

interpretation i  then x  x is an unfounded set for p with respect to i 
proof  let r  p be such that h r   x  x    we want to show that either     some
 antimonotone  literal in b a  r  is false with respect to i  or     some  monotone  literal
in b m  r  is false with respect to j   i    x  x     by symmetry  we can assume that
h r  belongs to x   since x is an unfounded set with respect to i by hypothesis  either
 a  some  antimonotone  literal in b a  r  is false with respect to i  or  b  some  monotone 
literal in b m  r  is false with respect to k   i   x   case  a  is equals to      thus  it
remains to prove that case  b  implies      indeed  we have that j  k because j    k  
and j   k    therefore  by definition of monotonicity  each monotone literal  which is
false with respect to k is false with respect to j as well  and so we are done 

as a corollary of theorem    the union of all the unfounded sets is an unfounded set as
well 
corollary   the union of all the unfounded sets for an lpa
m a program p with respect to
an interpretation i is an unfounded set for p with respect to i as well  we refer to this set
as the greatest unfounded set of p with respect to i  denoted by gu sp  i  
below is an important monotonicity property of the greatest unfounded set 
proposition   let i and j be interpretations for an lpa
m a program p  if i  j  then
gu sp  i   gu sp  j  
   

fiunfounded sets and well founded semantics of asp programs with aggregates

proof  since gu sp  j  is the union of all the unfounded sets for p with respect to j by
definition  it is enough to show that x   gu sp  i  is an unfounded set for p with respect
to j  thus  we want to show that  for each rule r  p such that h r   x   either     some
 antimonotone  literal in b a  r  is false with respect to j  or     some  monotone  literal in
b m  r  is false with respect to j   x   we already know that x is an unfounded set for p
with respect to i by corollary    therefore  either  a  some  antimonotone  literal in b a  r 
is false with respect to i  or  b  some  monotone  literal in b m  r  is false with respect to
i   x   since i  j  we have that j and j   x are extensions of the interpretations i
and i   x   respectively  hence  by remark     a  implies     and  b  implies      and so
we are done 

we are now ready for extending the well founded operator defined by van gelder et al 
       to the case of lpa
m a programs 
definition   let p be an lpa
m a program  the immediate logical consequence operator
b
p
tp   ip   
and the well founded operator wp   ip   bp  bp are defined as follows 
tp  i       bp   r  p such that h r    
and all the literals in b r  are true with respect to i 
wp  i    tp  i    gu sp  i  
intuitively  given an interpretation i for a program p  wp derives as true a set of
atoms belonging to every model extending i  by means of the tp operator   moreover 
wp derives as false all the atoms belonging to some unfounded set for p with respect to
i  by means of the gu sp operator   note that tp  i  and gu sp  i  are set of atoms  so
wp  i     tp  i  and wp  i     gu sp  i   the following proposition formalizes the
intuition that definition   extends the wp operator defined by van gelder et al         for
standard programs to lpa
m a programs 
proposition   let p be an aggregate free program  the wp operator of definition  
coincides with the wp operator defined by van gelder et al         
proof  since wp is equal to the union of tp and  gu sp in both cases  we have just to
show that our definitions of tp and gu sp coincide with those introduced by van gelder
et al         for aggregate free programs 
 the two immediate logical consequence operators  tp   coincide for an aggregate free
program p  indeed  for each rule r  p  b r  has only standard literals 
 our definition of gu sp  i  coincides with the one of van gelder et al         for an
aggregate free program p and an interpretation i  indeed  in both cases gu sp  i  is
defined as the union of all the unfounded sets for p with respect to i  and our notion
of unfounded set coincides with the one in the work of van gelder et al  for standard
programs by theorem   

we next show that a fixpoint of the well founded operator wp is a  possibly partial 
model 
   

fialviano  calimeri  faber  leone    perri

 a  b 

 a  not b 

 a 

 b 

 not a  b   not a  not b 

 not b 

 not a 


figure    a meet semilattice
theorem   let p be an lpa
m a program and m a  partial  interpretation  if m is a
fixpoint of wp   then m is a  partial  model of p 
proof  let us assume that wp  m     m holds  thus  tp  m    m and  gu sp  m    m
hold  consider now a rule r  p  if all the literals in b r  are true with respect to m  
then h r   tp  m    m   if h r  is false with respect to m   then h r   gu sp  m   
since gu sp  m   is an unfounded set for p with respect to m by corollary    either some
literal in b a  r  is false with respect to m   or some literal in b m  r  is false with respect to
m   gu sp  m     m   we can then conclude that r is satisfied by m  

the theorem below states that wp is a monotone operator in the meet semilattice induced on ip by the subset containment relationship  we recall here that a meet semilattice
is a partially ordered set which has a meet  or greatest lower bound  for any nonempty finite
subset  an example of such a meet semilattice for a program with base  a  b  is reported
in figure   
theorem   let p be an lpa
m a program  the well founded operator wp is a monotone
operator in the meet semilattice hip   i 
proof  since wp is equal to the union of tp and  gu sp by definition    we have just to
prove the monotonicity of the operators tp and gu sp  
 we first show that tp is a monotone operator  that is  for each pair of interpretations
i  j for p such that i  j  it holds that tp  i   tp  j   consider an atom   tp  i  
by definition    there is a rule r  p such that h r     and all the literals in b r 
are true with respect to i  since i  j  we can conclude that all the literals in b r 
are true with respect to j as well  see remark     and so h r     belongs to tp  j 
by definition   
 we already know that gu sp is a monotone operator from proposition    for each
pair of interpretations i  j for p such that i  j  it holds that gu sp  i   gu sp  j  

we can now prove that the sequence w      wn     wp  wn   is well defined  that is 
each element of the sequence is an interpretation 
theorem   let p be an lpa
m a program  the sequence w      wn     wp  wn   is
well defined 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

proof  we use strong induction  the base case is trivial  since w      in order to prove
the consistency of wn     tp  wn   gu sp  wn    we assume the consistency of every wm
such that m  n  since wp is a monotone operator by theorem    it is enough to show
that gu sp  wn    wn       to this end  we next show that any set x of atoms such that
x  wn       is not an unfounded set for p with respect to wn  and so is not contained in
gu sp  wn     let wm   be the first element of the sequence such that x  wm        note
that m  n   consider any atom   x  wm     by definition of tp   there is a rule r  p
having h r     and such that all the literals in b r  are true with respect to wm   note
that no atom in wm can belong to x  for the way in which wm   has been chosen   thus 
by remark    all the literals in b r  are true with respect to both wn and wn   x  we
recall that wn  wm because wp is monotone   this ends the proof  as neither condition
    nor     of definition   hold for  

theorem   and theorem   imply that wp admits a least fixpoint  tarski         which
is referred to as the well founded model of p  the well founded semantics of an lpa
m a
program p is given by this model  we can now state a first important property of the
well founded semantics of lpa
m a programs 
property   for every lpa
m a program  the well founded model always exists and is unique 
another important property of well founded semantics easily follows from proposition   
property   on aggregate free programs  the well founded semantics as defined in this
paper coincides with the classical well founded semantics of van gelder et al         
although the well founded model  in general  might leave some atoms as undefined 
there are cases where wp    is a total interpretation 
example    consider the following program p   
a       sum h    a   i  h    a   i      
a      b 
b   not c 

the iterated application of wp yields the following sets 
  
  
  

wp       not a     not c  
wp   not a     not c      not a     not c  b  
wp   not a     not c  b      not a     not c  b  a       wp    

in this case  the well founded model is total  indeed  each atom in bp is either true or false
with respect to wp    
the totality of the well founded model of the program above is due to its stratification 
as formalized by the next theorem  given corollary     an equivalent result has been stated
already by pelov et al         as theorem     and its corollary      however  its proof is
labelled as sketch by pelov et al   which moreover relies on rather different formalisms than
our proof 
   

fialviano  calimeri  faber  leone    perri

theorem   on stratified lpa
m a programs  the well founded model is total 

proof  let p be a stratified lpa
m a program  in order to prove that wp    is total  we
show that each  standard  atom in bp  wp    is false with respect to wp     by definition
of stratification  there is a level mapping        of the  standard  predicates of p such that 
for each pair a  b of standard predicates occurring in the head and body of a rule r  p 
respectively  the following conditions are satisfied   i  if b appears in an antimonotone literal 
then   b       a   holds   ii  otherwise  if b appears in a monotone literal  then   b      a  
holds  we are then in order to define a non decreasing sequence of subsets of bp as follows 

l    
li     li     bp   the predicate of  is p and   p     i  

i  n 

our aim is then to show that  for each i  n  the set li    wp    is contained in  wp     
we use induction on i  the base case is trivial because l     holds by definition  now
suppose that all the atoms in li   wp    are false with respect to wp    in order to show
that all the atoms in li     wp    are false with respect to wp    as well  to this end 
we prove that li     wp    is an unfounded set for p with respect to wp     consider
a rule r  ground p  with h r   li     wp     we want to show that either     some
 antimonotone  literal in b a  r  is false with respect to wp     or     some  monotone 
literal in b m  r  is false with respect to wp       li     wp      since h r   li     by
definition of stratification the following propositions hold 
 a  each literal in b a  r  is either a negated standard atom belonging to li   or an aggregate
literal depending only on atoms in li  
 b  each literal in b m  r  is either a standard atom belonging to li     or an aggregate
literal depending only on atoms in li    
since h r    wp     that is  h r    tp  wp       there is a literal  in b r  such that 
is not true with respect to wp     by definition of tp    if  is an antimonotone literal  we
apply  a  and the induction hypothesis and conclude that     holds   cannot be undefined
with respect to wp     so  must be false   if  is a monotone literal  we apply  b  and the
induction hypothesis and conclude that     holds   cannot be undefined with respect to
wp       li     wp     and wp       li     wp      wp    holds  so  must be
false  


   answer set characterization via unfounded sets
the well founded semantics is a three valued semantics  that is  each program is associated with a model in which atoms are either true  false or undefined  other semantics in
the literature associate programs with two valued models  i e   models without undefined
atoms   a commonly accepted two value semantics in lp is the answer set semantics  in
this section we present a number of results concerning unfounded sets and answer sets of
lpa
m a programs  we first recall the definition of answer sets provided by faber  leone 
and pfeifer        
   

fiunfounded sets and well founded semantics of asp programs with aggregates

definition    minimal model  a total model m for p is  subset  minimal if no total
model n for p exists such that n    m     note that  under these definitions  the words
interpretation and model refer to possibly partial interpretations  while a minimal model is
always a total interpretation 
we next provide the transformation by which the reduct of a ground program with
respect to a total interpretation is formed  note that this definition is a generalization  faber
et al         of the gelfond lifschitz transformation        for standard logic programs 
definition    program reduct  given an lpa program p and a total interpretation
i  let ground p i denote the transformed program obtained from ground p  by deleting
rules in which a body literal is false with respect to i  i e  
ground p i    r  ground p    all the literals in b r  are true with respect to i  
we are now ready for introducing the notion of answer set for lpa programs 
definition    answer set for lpa programs  given an lpa program p  a total interpretation m of p is an answer set of p if and only if m is a minimal model of
ground p m  
example    consider two total interpretations i     p     and i     not p     for the
following two programs 
p     p       count x   p x        
p     p       count x   p x       

we then obtain the following transformed programs 
ground p   i 
ground p   i 
ground p   i 
ground p   i 

  ground p       p       count h    p   i       
 
 
  ground p       p       count h    p   i      

hence  i  is the only answer set of p    indeed  i  is not a minimal model of ground p   i   
moreover  p  has no answer sets  indeed  i  is not a minimal model of ground p   i    and
i  is not a model of ground p   i    ground p    
note that any answer set m of p is also a total model of p because ground p m 
ground p   and the rules in ground p    ground p m are satisfied with respect to m
 by definition    each of these rules must have at least one body literal which is false with
respect to m   
on the language lpa
m a considered in this work  answer sets as defined in definition  
coincide with stable models as defined by pelov  denecker  and bruynooghe        and
hence also those defined by pelov et al         and son et al          this equivalence
follows from propositions     and     of ferraris         which respectively state that stable
models of pelov et al         on lpa
m a coincide with a semantics defined by ferraris        
which in turn coincides with definition   on a larger class of programs  this means that all
our results involving answer sets also hold for these other semantics on lpa
m a   on the other
hand  this also implies that some of the results  for example theorem     are consequences
of results in the work of pelov et al         by virtue of theorem    in section   
in the remainder of this section we highlight relevant relationships between answer sets
and unfounded sets  before introducing our results  let us provide an additional definition 
   

fialviano  calimeri  faber  leone    perri

definition    unfounded free interpretation  an interpretation i for an lpa
m a program p is unfounded free if and only if i  x    holds for each unfounded set x for p
with respect to i 
for total interpretations  an equivalent characterization of the unfounded free property
is given below 
lemma    a total interpretation i for an lpa
m a program p is unfounded free if and only
 
if the empty set is the only subset of i which is an unfounded set for p with respect to i 
proof     straightforward  by definition    i is disjoint from all the unfounded set for
p with respect to i 
   we prove the contrapositive  if i is not unfounded free  then there exists a non empty
subset of i   which is an unfounded set for p with respect to i  from definition    if i is
not unfounded free  then there exists an unfounded set x for p with respect to i such that
i x  
    we next show that i  x is an unfounded set for p with respect to i  i e   for
each rule r  p such that h r   i  x   either     some  antimonotone  literal in b a  r 
is false with respect to i  or     some  monotone  literal in b m  r  is false with respect to
i    i  x    since x is an unfounded set  by definition    either  a  some  antimonotone 
literal in b a  r  is false with respect to i  or  b  some  monotone  literal in b m  r  is false with
respect to i   x   thus  we can end the proof by showing that i   x   i    i  x   
to this end  observe that  i   x     x   i     i  x    moreover  since i is total 
  bp   i       i    and thus  ii    x   i      x   i      i   i   x   by using  i  in
i   x    i   x     x and simplifying with  ii  we obtain i   x    i   x      i  x   
we conclude by observing that i   x   i    i  x    and thus i   x   i    i  x  
holds 

now we give another interesting characterization of total models for lpa
m a programs 
lemma    a total interpretation m is a  total  model for an lpa
m a program p if and
only if  m  is an unfounded set for p with respect to m  
proof  we start by observing that each rule r  p such that h r   m   is satisfied by
m   thus  we have to show that  for each rule r  p with h r    m    some literal in
b r  is false with respect to m if and only if either     some  antimonotone  literal in b a  r 
is false with respect to m   or     some  monotone  literal in b m  r  is false with respect
to m     m     to this end  it is enough to prove that m     m      m holds 
by definition     m     m       m    m       m    from the consistency of m
we have that m and  m  are disjoint  moreover    m    m  is a subset of m   by
simplifying    with the last two sentences  we obtain m     m      m  

now we give further characterizations of answer sets for lpa
m a programs 
theorem    a total model m is an answer set of an lpa
m a program p if and only if m
is unfounded free 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

proof     we prove the contrapositive  if a total model m of an lpa
m a program p is
not unfounded free  then m is not an answer set of p  by lemma     since m is a total
interpretation and it is not unfounded free  there exists an unfounded set x for p with
respect to m such that x  m   and x  
    therefore  to prove that m is not an answer

set of p  we next show that m   x is a model of p m such that m   x  m   to this
end  consider a rule r  p m   by definition   of reduct  all the literals in b r  are true with
respect to m   and so h r   m   because m is a model of p and p m  p  we now have
to consider two cases 
   h r    x   in this case  h r   m   x as well 
   h r   x   in this case  since x is an unfounded set for p with respect to m   either
    some literal in b a  r  is false with respect to m   or     some literal in b m  r  is false
with respect to m   x   by previous considerations  since r  p m       cannot hold 
and so we can conclude that some literal in b r  is false with respect to m   x  
hence  we have that r is satisfied by m   x either by head  in case h r    x    or by
body  in case h r   x    and so we are done 
   we prove the contrapositive  if a total model m of an lpa
m a program p is not an
answer set of p  then m is not unfounded free  since m is a model of p  p m but not an
answer set of p  there exists a total model n of p m such that n    m     we next show
that m     n   is an unfounded set for p with respect to m   that is  for each rule r  p such
that h r   m     n     either     some  antimonotone  literal in b a  r  is false with respect
to m   or     some  monotone  literal in b m  r  is false with respect to m    m     n     
we start by showing that m    m     n       n   by definition   a  m    m     n      
 m    m     n         m     n      from n    m   we have  b  m    m     n      
n    m    moreover  since n and m are total interpretations and n    m     we have  c 
n   m  and  d    m     n       n    m    thus  by using  b  and  d  in  a  we obtain
m    m     n       n   m   n   m     and by observing that m   n   m      n 
holds because of  c   we conclude  e  m    m     n       n    n    n  
consider now a rule r  p such that h r   m     n     we have to deal with two cases 
   r  p   p m   in this case  by definition    there must be a literal   b r  such that 
is false with respect to m   if  is an antimonotone literal  then     holds  otherwise 
 is a monotone literal and so  is false with respect to n as well  since n  m   thus 
    holds because of  e  
   r  p m   in this case  since n is a model of p m and h r  is false with respect to n
 because h r   m     n   by assumption   there must be a literal   b r  such that
 is false with respect to n   if  is an antimonotone literal  then  is false with respect
to m as well  since n  m   and so     holds  otherwise   is a monotone literal and
    holds because of  e  

we are then ready to state an important connection between answer sets and unfounded
sets 
theorem    a total interpretation m for an lpa
m a program p is an answer set of p if
and only if gu sp  m      m   
   

fialviano  calimeri  faber  leone    perri

proof     let m be an answer set of p  by lemma      m  is an unfounded set for p
with respect to m   and hence gu sp  m     m    by theorem     m is unfounded free 
and hence gu sp  m     m  because m is total  in sum  gu sp  m      m   
   let m be a total interpretation such that gu sp  m      m    then m and gu sp  m    
 m  are disjoint  and so m is unfounded free  moreover  by corollary    gu sp  m     m 
is an unfounded set for p with respect to m and so  by applying lemma     we conclude
that m is a model of p  we are then in order to apply theorem     m is an unfounded free
model of p  and conclude that m is an answer set of p 

the following theorem shows that answer sets of lpa
m a programs are exactly the total
fixpoints of the well founded operator defined in section   
theorem    let m be a total interpretation for an lpa
m a program p  then m is an
answer set for p if and only if m is a fixpoint of the well founded operator wp  
proof     let m be an answer set of p  we want to show that m is a fixpoint of wp   that
is  wp  m     m   our aim is then to show that tp  m     m   and  gu sp  m     m   
since m is an answer set  by applying theorem     we obtain gu sp  m      m    which
is equivalent to  gu sp  m     m    therefore  it remains to prove that tp  m     m    
   consider an atom   tp  m    by definition    there is a rule r  p such that
h r     and all the literals in b r  are true with respect to m   thus    m   holds
because m is a model of p 
   consider an atom   m     since m is an answer set of p  we can apply theorem   
and conclude that m is unfounded free  hence  the  singleton  set     m   is not
an unfounded set for p with respect to m   thus  by definition    there is a rule
r  p such that h r     and neither     some  antimonotone  literal in b a  r  is
false with respect to m   nor     some  monotone  literal in b m  r  is false with respect
to m       since m is a total interpretation  neither     nor     is equivalent to
both  i  all the  antimonotone  literals in b a  r  are true with respect to m   and  ii 
all the  monotone  literals in b m  r  are true with respect to m       by observing
that m       m   we can state that  ii  implies that all the  monotone  literals in
b m  r  are true with respect to m as well  by combining the latter statement with  i 
we obtain that all the literals in b r  are true with respect to m   and so   tp  m  
by definition   
   let m be a total fixpoint of wp   i e   wp  m     m   thus  m     gu sp  m   by
definition    and so m is an answer set for p because of theorem    

observe that theorem    is a generalization of theorem     of van gelder et al        
to the class of lpa
m a programs  it is also worth noting that wp  i  extends i preserving its
correctness  if i is contained in an answer set m   then wp  i  may add to i some literals
of m   but never introduces any literal which would be inconsistent with m  
proposition    let i be an interpretation for an lpa
m a program p  and let m be an
answer set for p  if i  m   then wp  i   m  
   

fiunfounded sets and well founded semantics of asp programs with aggregates

proof  this is a trivial consequence of the monotonicity of the operator wp  theorems   
and theorem     indeed  by theorems    wp is i  m implies wp  i   wp  m    and
wp  m     m by theorem    

we next show that the well founded model of an lpa
m a program is contained in all the
answer sets  if any  of p  we would like to point out that due to theorem    in section  
 showing the equivalence of the well founded operators defined in this work and the one
defined in pelov et al         and propositions      and     of ferraris        showing the
equivalence of answer sets in faber et al        and stable models in pelov et al         
the following results also hold by virtue of the definitions of the well founded and stable
semantics in the work of pelov et al   in particular due to proposition     of that paper  we
nevertheless also provide a proof using the concepts defined earlier 

theorem    let p be an lpa
m a program  for each answer set m of p  wp     m  

proof  let m be an answer set of p  note that wp    is the limit of the sequence w     
wn   wp  wn     we show that wn  m by induction on n  the base case is trivially
true since w     by definition  now assume wn  m in order to show that wn    m  
since wn     wp  wn   by definition and wn  m by induction hypothesis  we apply
proposition    and conclude that wn    m  

the theorem above suggests another property of well founded semantics for lpa
m a programs 
property   the well founded semantics for lpa
m a programs approximates the answer set
semantics  the well founded model is contained in the intersection of all answer sets  if
any  
by combining theorem    and theorem     we obtain the following claim 

corollary    let p be an lpa
m a program  if wp    is a total interpretation  then it is
the unique answer set of p 

therefore  by combining theorem   and the corollary above  we obtain another property
of well founded semantics for lpa
m a programs 
property   on stratified lpa
m a programs  the well founded model coincides with the
unique answer set 

   the complexity of the well founded semantics
for the complexity analysis carried out in this section  we consider ground programs and
polynomial time computable aggregate functions  note that all example aggregate functions
appearing in this paper fall into this class   however  we eventually provide a discussion on
how results change when considering non ground programs  we start with an important
property of monotone and antimonotone aggregate literals 
   

fialviano  calimeri  faber  leone    perri

lemma    let i be a partial interpretation for a ground lpa
m a program p  we define
two total interpretations for p as follows  imin   i    bp   i  and imax   i   bp    i  
for each  ground  aggregate literal a occurring in p  the following statements hold 
   if a is a monotone literal  then a is true  resp  false  with respect to i if and only if
a is true with respect to imin  resp  false with respect to imax   
   if a is an antimonotone literal  then a is true  resp  false  with respect to i if and
only if a is true with respect to imax  resp  false with respect to imin   
proof  we start by noting that imin  resp  imax   is a total interpretation extending i
and such that all the standard atoms which are undefined with respect to i are false with
respect to imin  resp  true with respect to imax    thus  we have    imin  i  imax   if a
is monotone and true with respect to imin  resp  false with respect to imax    then a is true
 resp  false  with respect to i because of     if a is antimonotone and true with respect
to imax  resp  false with respect to imin    then a is true  resp  false  with respect to i
because of     we end the proof by observing that if a is true  resp  false  with respect
to i  then a is true with respect to imin and imax by definition 

we are now ready to analyze the computational complexity of the well founded semantics
for lpa
m a programs  our analysis will lead to prove the following fundamental property 
property   the well founded model for a ground lpa
m a program is efficiently  polynomialtime  computable 
given corollary     this property also follows from theorem     in the work of pelov
et al          in the following  we will provide an alternative proof based on the concepts
defined earlier in this paper  which also leads to several interesting intermediate results 
property   is not trivial because aggregates may easily increase the complexity of the
evaluation  indeed  even deciding the truth of an aggregate with respect to a partial interpretation is intractable in general  a similar observation has already been made by pelov
        however  this task is polynomial time computable for the aggregate literals occurring in lpa
m a programs 
proposition    deciding whether a ground aggregate literal a is true  resp  false  with
respect to a partial interpretation i is 
 a  co np complete in general 
 b  polynomial time computable if a is either a monotone or an antimonotone literal 
proof   a  as for the membership  we consider the complementary problem  that is 
deciding whether a ground aggregate literal a is not true  resp  not false  with respect
to a partial interpretation i  and prove that it belongs to np  in order to show that a
is not true  resp  not false  with respect to i it is enough to find a total interpretation j
extending i  that is  j  i  such that a is false  resp  true  with respect to j  thus  we
can guess such a j and check the falsity  resp  truth  of a with respect to j in polynomial
   

fiunfounded sets and well founded semantics of asp programs with aggregates

time  if the aggregate function can be computed in polynomial time with respect to the size
of the input multiset  as we are assuming  
as for the hardness  we first consider the problem of checking the truth of an aggregate and provide a polynomial time reduction from tautology  the tautology
problem is co np complete and can be stated as follow  given a proposition formula 
on variables x            xn   does each truth assignment v for the variables x            xn satisfy
the formula   without loss of generality  we assume that  is a   dnf formula of the form
   d       dm  

where each disjunct di is a conjunction  i   i   i   and each ji is a positive or negative
literal  note that  in the context of tautology  the term literal denotes a variable
xk or a variable preceded by the negation symbol    for a given   we then consider a
partial interpretation i      and construct an aggregate literal a    sum s      where
s contains two groups of elements  the elements in the first group represent disjuncts of 
and are
h      i      i      i  i 
i              m  
where  for each i              m and j                 the propositional atom  ji   is defined as
follows 
 t
j
 xk if i is a positive literal xk   for some k              n  
j
 i    
 f
xk if ji is a negative literal xk   for some k              n  
the elements in the second group represent variables of  and are as follows 

h   


 h  
h  



h   

xk    i
xk   xtk i
 
xk   xfk i
xk   xtk   xfk i

k              n  

where xk and xk are constants associated with the variable xk   note that  for each variable
xk of   there are two atoms in a  xtk and xfk   thus  for each interpretation j  four cases
are possible 
     not xtk   not xfk    j  in this case  only h   xk   i contribute to the evaluation of
a  and its contribution is   
     xtk   xfk    j  in this case  all the four elements contribute to the evaluation of a 
and thus their contribution is               note that h   xk   xtk i and h   xk   xfk i
give a total contribution of   because of our pure set approach  
     xtk   not xfk    j  in this case  only h   xk   i and h   xk   xtk i contribute  giving
         
     not xtk   xfk    j  in this case  only h   xk   i and h   xk   xfk i contribute  giving
         
   

fialviano  calimeri  faber  leone    perri

thus  for each k              n   the total contribution of the four elements of s associated with
the variable xk is either   or    note that also the total contribution of the other elements
of s  i e   those in the first group  is either   or    therefore  if there is k              n  such
that either case     or     occurs  the interpretation j trivially satisfies a  otherwise  j
is such that  for each variable k              n   either     or     occurs  in this case  we say
that j is a good interpretation 
we next define a one to one mapping between the set of assignments for  and the set of
good interpretations  let v be an assignment for   the good interpretation iv associated
with v is such that   iv and

f
  xtk   not xk    iv if v xk      
 
k              n  

f
t
 not xk   xk    iv if v xk      
we want to show that v satisfies  if and only if a is true with respect to iv   since iv is
a good interpretation  the elements of s in the second group give a total contribution of   
and so we have just to consider the elements of s in the first group  these elements give a
contribution of   if and only if    i      i      i     i holds for at least one i              n  
and this holds if and only v di       holds for the disjunct di   we can then conclude that
a is true with respect to iv if and only v       
concerning the check of falsity of an aggregate  we can start from a   dnf formula 
and construct an aggregate literal a    sum s       where s is obtained as described
above  then  is a tautology if and only if a is false with respect to i      
 b  let i be a partial interpretation for an lpa
m a program p and a an aggregate literal
occurring in p  we want to show that deciding whether a is true  resp  false  with respect
to i can be done in polynomial time in the size of bp   by lemma     it is enough to evaluate
the aggregate with respect to either imin   i    bp   i  or imax   i   bp    i   we
then end the proof by observing that the interpretations imin and imax can be constructed
in polynomial time  and that the value of the aggregate function in a can be computed in
polynomial time with respect to the size of the input multiset by assumption 

in order to prove the tractability of the well founded semantics we need an efficient
method for computing the greatest unfounded set  which is part of the well founded operator
wp   hence  we next give a polynomial time construction of the set bp  gu sp  i  by means
of a monotone operator 
definition   let i be an interpretation for an lpa
m a program p  the operator i  
b
b
p
p
is defined as follows 
   
i  y        bp    r  p with h r     such that
no  antimonotone  literal in b a  r  is false with respect to i  and
all the  monotone  literals in b m  r  are true with respect to y    i   
the least fixpoint of i coincides with the greatest unfounded set of p with respect to
i 
theorem    let p be an lpa
m a program and i an interpretation for p  then 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

   the i operator has a least fixpoint i    
   gu sp  i    bp   i    
proof  the i operator is a monotonically increasing operator in the meet semilattice
hbp   i  and it therefore admits a least fixpoint i     tarski         we next prove that
gu sp  i    bp   i    in two steps 
   we first observe that i    can be computed iteratively  starting from the empty set 
as the limit of the sequence f      fi     i  fi    thus  we prove by induction on i
that gu sp  i   bp  fi holds  the base case is trivial  since f     by definition and
gu sp  i  is a subset of bp by definition    we then assume gu sp  i   bp   fi in
order to prove that gu sp  i   bp   fi     since gu sp  i  is an unfounded set for p
with respect to i by theorem    by definition   we have that  for each   gu sp  i 
and for each rule r  p with h r      either     some  antimonotone  literal in
b a  r  is false with respect to i  or     some  monotone  literal in b m  r  is false with
respect to i   gu sp  i   we want to show that such a  does not belong to fi    
that is  each rule r as above is such that either  i  some  antimonotone  literal in
b a  r  is false with respect to i  or  ii  some  monotone  literal in b m  r  is not true
with respect to fi    i   recall that fi     i  fi   by definition   since     and  i 
are equals  we have to show that     implies  ii   to this end  assume that there is
a  monotone  literal   b m  r  which is false with respect to i   gu sp  i   our
aim is to show that  is false with respect to j    fi    i       bp    fi    i     
since in this case  would be not true with respect to fi    i   see lemma     
we start by proving that  i   gu sp  i     i    gu sp  i  is a subset of j   
observe that j      bp    fi    i       i     bp   fi   because  i  is a
subset of bp   thus  since gu sp  i   bp   fi by induction hypothesis  we obtain
 i   gu sp  i     i    gu sp  i   i     bp   fi     j    since j is total 
 i   gu sp  i    j  implies that there is an extension k of i   gu sp  i 
such that k   j  and k    j   for example  the one containing as true all the
standard positive literals which are undefined with respect to i   gu sp  i    since
 is false with respect to i   gu sp  i  by assumption and k is an extension of
i   gu sp  i    is false with respect to k by remark    thus  since j  k and
 is monotone  the latter implies that  is false with respect to j as well 
   we prove that bp   i    is an unfounded set for p with respect to i  that is  for
each r  p with h r   bp   i     either     some  antimonotone  literal in b a  r  is
false with respect to i  or     some  monotone  literal in b m  r  is false with respect
to i    bp   i      by definition    h r    i    implies either that  i  some
 antimonotone  literal in b a  r  is false with respect to i  or that  ii  some  monotone 
literal in b m  r  is not true with respect to i       i    since  i  and     are equals 
we have to show that  ii  implies      to this end  assume that there is a  monotone 
literal   b m  r  which is not true with respect to i       i    thus  there is an
extension of i       i  for which  is false  and in particular  must be false with
respect to j    i       i       bp    i       i     because of lemma     now
observe that  i    bp   i        i    bp  i         bp   i     i      
   

fialviano  calimeri  faber  leone    perri

j  holds  because  i   bp    and so  i    bp   i        j   because j is total 
by combining the last two sentences we obtain i    bp   i      j  therefore 
since  is a monotone literal which is false with respect to j  the latter implies that 
is false with respect to i    bp   i     as well  and so     holds 

eventually  property   is a consequence of the following theorem  as mentioned earlier 
this theorem also follows from theorem     in the work of pelov et al         because of
corollary     but the proof provided here differs considerably from the one of theorem    
in the work of pelov et al 
theorem    given an lpa
m a program p 
   the greatest unfounded set gu sp  i  of p with respect to a given interpretation i is
polynomial time computable 
   wp    is polynomial time computable 
proof       from theorem     gu sp  i    bp   i     we next show that i    is
efficiently computable  the fixpoint i    is the limit  of the sequence       k  
i  k     this limit is reached in a polynomial number of applications of i because each
new element of the sequence k must add at least a new atom  otherwise the limit has been
already reached   that is     bp    if we show that each application of i is feasible in
polynomial time  we can conclude that  is computable in polynomial time  each step
processes at most all the rules once  and for each rule checks the truth value of at most
all body literals once  the check of the truth valuation is clearly tractable for all standard
 i e   non aggregates  literals  the tractability of the check for aggregate literals stems from
proposition     as we deal with monotone and antimonotone aggregate atoms only  in
conclusion   is computable in polynomial time  and gu sp  i  is tractable as well since it
is obtainable as bp   i    
     by the argumentation carried out for i     we can show that wp    is computed
in a number of steps which is polynomial  actually linear  in  bp    indeed  each step is
polynomial time computable  we have just proved the tractability of gu sp  i   and tp is
polynomial time computable as well 

this result has a positive impact also for the computation of the answer set semantics
of logic programs with aggregates  indeed  as stated in theorem     wp    approximates
the intersection of all answer sets  if any  from the bottom  and can be therefore used to
efficiently prune the search space  it is worthwhile noting that the computation of the
well founded semantics is also hard for polynomial time  in particular  deciding whether
a  ground  atom is true with respect to the well founded semantics is p complete  as this
task is p hard even for the standard well founded semantics of aggregate free programs  and 
from proposition    our semantics coincides with the standard well founded on aggregatefree programs  
we end this section by briefly addressing the complexity of non ground programs  when
considering data complexity  i e   an lpa
m a program p is fixed and the input only consists
of facts   the results are as for propositional programs  deciding whether a  ground  atom
is true with respect to the well founded semantics of a non ground program is p complete 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

under data complexity  van gelder et al          however  if program complexity  i e   an
lpa
m a program p is given as input  is considered  complexity of reasoning rises exponentially  indeed  a non ground program p can be reduced  by naive instantiation  to a ground
instance of the problem  and in general the size of ground p  is single exponential in the
size of p  the complexity of reasoning increases accordingly by one exponential  from p
to exptime  and the result can be derived using complexity upgrading techniques  eiter 
gottlob    mannila        gottlob  leone    veith        

   compilation into standard lp  implementation and experimental
results
the well founded semantics for lpa
m a programs has been implemented by extending the
dlv system  leone et al          in this section we briefly describe the implemented
prototype and report on the results of our experiments aimed at assessing its efficiency 
note that  even if lpa
m a programs can be replaced by equivalent lp programs  for a
rewriting strategy see section     below   our experimental results highlight a significant
performance advantage of lpa
m a encodings 
    compilation into standard logic programming
in this section we briefly present a strategy for representing  count   sum and  times
with standard constructs   the compilation is in the spirit of the one introduced for  min
and  max by alviano  faber  and leone        and defines a subprogram computing the
value of a  possibly recursive  aggregate  the compilation takes into account specific properties of monotone and antimonotone aggregate functions  and is therefore referred to as
monotone antimonotone encoding  mae  
the monotone antimonotone encoding of an lpa
m a program p is obtained by replacing
each aggregate literal a   f  s   t by a new predicate symbol f   predicate f is defined
by means of a subprogram  i e   a set of rules  that can be thought of as a compilation of a
into standard lp  the compilation uses a total order   of the elements of up      where
 is a symbol not occurring in p and such that    u for each u  up   we further assume
the presence of a built in relation y   y    where y   y            yn and y    y            yn
are lists of terms  this built in relation has y   y  if and only if y precedes y  in the
lexicographical order induced by    moreover  we will use a built in relation y  y    where
y  y  is true if and only if either y   y  or y   y    for simplicity  let us assume that a is
of the form f   y   p y   z     k  where y and z are lists of local variables and k is an
integer constant  for such an aggregate  we introduce a new predicate symbol faux of arity
 y       and rules for modeling that an atom faux  y  s  must be true whenever the value of
f   y   p y   z   y  y   is at least s  thus  we use a fact for representing the value of
the aggregate function for the empty set  and a rule for increasing this value for larger sets 
the lexicographical order induced by   is used to guarantee that all elements in the set are
   since we are considering only monotone and antimonotone aggregate literals  the domains of  sum and
 times are assumed to be n and n    respectively 

   

fialviano  calimeri  faber  leone    perri

user interface

diagnosis
frontend

inheritance
frontend

sql 
frontend

planning
frontend

dlv core
ground
program

intelligent
grounding

model
checker

model
generator

file
system

relational
database

filtering

output

figure    prototype system architecture 
considered at most once  in particular  the following rules are introduced 

faux      
          s     if f    count 
         s   y  if f    sum 
where
faux  y    x    faux  y   s   p y    z  

         s  y  if f    times 
y   y    x    
if         truth of an aggregate f   y   p y   z     k must be inferred if and only
if some atom faux  y  s  such that s  k is true  this aspect is modeled by means of the
following rules 
fk   faux  y   s   s  k 

f k   faux  y   s   s   k 

if  is   instead  truth of an aggregate f   y   p y   z     k must be inferred if and only
if all atoms faux  y  s  such that s   k are false  and similar if  is     these aspects are
modeled by means of the following rules 
fk   not f k  

f k   not fk  

extending the technique to aggregate literals with global variables is quite simple 
global variables are added to the arguments of all the atoms used in the compilation 
and a new predicate fgroupby is used for collecting their possible substitutions 
    system architecture and usage
we have extended dlv by implementing the well founded operator and the well founded
semantics for lpa
m a programs described in this paper  the architecture of the prototype is
   

fiunfounded sets and well founded semantics of asp programs with aggregates

reported in figure    in detail  we modified two modules of dlv  the intelligent grounding
module and the model generator module  in our prototype  the well founded semantics
is adopted if one of  wf or   well founded is specified on the command line  otherwise 
the stable model semantics is adopted as usual  the well founded operator wp introduced
in section   is used for both semantics  in particular  for the stable model semantics  the
well founded model is profitably used for pruning the search space  for the well founded
semantics  the well founded model is printed after the computation of the least fixpoint of
the well founded operator  in this case the output of the system consists of two sets  for
representing true and undefined standard atoms in the well founded model  a binary of the
prototype is available at http   www dlvsystem com dlvrecaggr  
    experimental results
to our knowledge  the implemented prototype is currently the only system supporting a
well founded semantics for logic programs with recursive aggregates  for certain special
cases  such as when the well founded model is total  the well founded model coincides with
other semantics such as answer sets  see corollary     and in theses cases systems supporting
those semantics such as idp  wittocx  marien    denecker         smodels  simons et al  
       or clasp  gebser  kaufmann  neumann    schaub         can be used to compute
the well founded model 
we are however interested in systems that are able to compute the well founded model
for all input programs  one of the major systems supporting the well founded semantics 
xsb  swift   warren         has some support for aggregates  but  apart from  min and
 max  xsb does not support recursive aggregates  i e   aggregates occurring in recursive
definitions   therefore  our experiments have been designed for investigating the computational behavior of aggregate constructs with respect to equivalent encodings without
aggregates 
more specifically  we introduce the attacks problem  which is inspired by the classic
win lose problem often used in the context of the well founded semantics for standard
logic programs  and study performance on it 
definition    attacks problem  in the attacks problem  a set of p players and a positive integer m are given  each player attacks n other players  a player wins if no more
than m winners attack it  this kind of problem is frequently present in turn based strategy
games 
note that the definition of winner is recursive and  in particular  a recursive aggregate
is the natural way of encoding this problem 
example    an instance of the attacks problem in which p      n     and m     could
be the following 
 player a attacks players b and c 

 player d attacks players b and f  

 player b attacks players a and c 

 player e attacks players c and f  

 player c attacks players a and b 

 player f attacks players d and e 

   

fialviano  calimeri  faber  leone    perri

b

d

a

f

e

c

figure    an instance of the attacks problem with   players  each one attacking   other
players 

a graphical representation of this instance is shown in figure    since d is only attacked by
f   we can conclude that d is a winner  similarly for e  therefore  f is not a winner because
f is attacked by d and e  which are winners  for the other players  namely a  b and c  we
cannot determine who is a winner or not 
in our experiments  instances of attacks are encoded by means of the predicates max 
player and attacks for representing the parameter m  the set of players and the attacks of
the players  respectively  we consider three equivalent encodings for the attacks problem 
      aggregate based encoding
this encoding is a natural representation of the attacks problem in lp a
m a   the complete
encoding consists of a single rule  reported below 
win x    max m    player x    count y   attacks y  x   win y     m 

      join based encoding
an equivalent encoding can be obtained by computing a number of joins proportional to
m  the tested encoding is reported below 
win x    player x   not lose x  
lose x    max     attacks y    x   win y    
attacks y    x   win y     y    y   
lose x    max     attacks y    x   win y    
attacks y    x   win y     y    y   
attacks y    x   win y     y    y    y    y   
lose x    max          

note that in the encoding above there is a rule for each possible value of parameter m 
however  only one of these rules is considered by our solver during program instantiation 
in fact  only the rule is instantiated  which contains the instance of atom max m  for which
a fact is present  all the other rules are satisfied because of a false body literal 
   

fiunfounded sets and well founded semantics of asp programs with aggregates

  

   

dlv join
a
dlv

  

   

  

   

  

   

  

   

 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

  
  

y

 

 

 

 

x

 a      players

 

 

   

 

 

 

 

 

 

 

  

y

 b      players

   

   

   

   

   

   

   

   

   

   

   
  

 

 

 

 

 

 

x

 

 

 

   

 

 

 

 

 

 

 

 

  

   
  

y

 

 

 
x

 c      players

 

 

 

 

   

 

 

 

 

 

 

 

 

  

y

 d      players

figure    attacks  average execution time of dlv running the aggregate based encoding
and dlv running the join based encoding 

      mae based encoding
this encoding has been obtained by applying the compilation presented in section     with
some minor simplifications  the full encoding is reported below 
win x    player x   not lose x  
lose x    count x  y  s   max m    s   m 
count x  y       aux x  y   
count x  y    s      count x  y  s   aux x  y     y   y    s    s     
aux x  y     attacks y  x   win y   

intuitively  an atom count x  y  s  stands for there are at least s constants y  such that
y   y and attacks y    x   win y    is true  note that the rules defining predicate count use
the natural order of integers to guarantee that each y  is counted at most once 
example    the instance shown in figure   is represented by means of the following facts 
player a  
attacks a  b  
attacks a  c  
max    

player b  
attacks b  a  
attacks b  c  

player c  
attacks c  a  
attacks c  b  

player d  
attacks d  b  
attacks d  f   

   

player e  
attacks e  c  
attacks e  f   

player f   
attacks f  d  
attacks f  e  

fialviano  calimeri  faber  leone    perri

 

  

xsb join
a
dlv

 
 

 
 
 

 

 

 

 

 

 
 

 
 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
 
  

y

 

 

 

 

x

 e      players

 

 

   

 

 

 

 

 

 

 

  

y

 f      players

 

  

 

  

 
 

 

 

 

 
 

 

 
 
  

 

 

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
  

y

 

 

 
x

 g      players

 

 

 

 

   

 

 

 

 

 

 

 

 

  

y

 h      players

figure    attacks  average execution time of dlv running the aggregate based encoding
and xsb running the join based encoding 

for all the encodings  the well founded model restricted to the win predicate is  win d  
win e   not win f     note that win a   win b  and win c  are neither true nor false  and so
they are undefined 
      discussion
we performed an intensive experimentation for this benchmark by varying the parameters
p  m and n  for each combination of these parameters  we measured the average execution
time of dlv and xsb  version      on   randomly generated instances  the experiments
r
r
have been performed on a  ghz intel
xeon
processor system with  gb ram under the
debian     operating system with gnu linux        kernel  the dlv prototype used has
been compiled with gcc        for every instance  we have allowed a maximum running
time of     seconds     minutes  and a maximum memory usage of  gb 
the results of our experimentation are reported in figures     in the graphs  dlv a
is the implemented prototype with the aggregate based encoding  dlv join and dlv mae
the implemented prototype with the aggregate free encodings  xsb join and xsb mae the
xsb system with the aggregate free encodings  as mentioned earlier  xsb does not support
   

fiunfounded sets and well founded semantics of asp programs with aggregates

dlv mae
a
dlv
 

  

 

  

 

 

 

 

 

 

 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
  

y

 

 

 

 

 

x

 i       players

 

 

   

 

 

 

 

 

 

 

 

  

y

 j       players

  

  
  

  

  
  
  
  
  
 
  

 

 

 
x

 

 

 

 

   

 

 

 

 

 

 

 

 

  

  
  

y

 

 

 
x

 k       players

 

 

 

 

   

 

 

 

 

 

 

 

 

  

y

 l        players

figure    attacks  average execution time of dlv running the aggregate based encoding
and dlv running the mae based encoding 

recursive aggregates   for the xsb system  we explicitly set indices and tabled predicates
for optimizing its computation 
for each graph  the number of players is fixed  while parameters m  x axis  and n
 y axis  vary  therefore  the size of the instances grows moving from left to right along
the y axis  while it is invariant with respect to the x axis  however  the number of joins
required by the join based encoding depends on the parameter m  as a matter of fact  we
can observe in the graphs in figures    that the average execution time of the join based
encoding increases along both the x  and y axis  for both dlv and xsb   instead  for
the encoding using aggregates  and for the mae based encoding  the average execution time
only depends on instance sizes  as shown in the graphs in figures    
for the join based encoding  xsb is generally faster than dlv  but consumes much
more memory  indeed  in figure    we can observe that xsb terminates its computation in
a few seconds for the smallest instances  but rapidly runs out of memory on slightly larger
instances  considering the mae based encoding  we can observe significant performance
gains for both dlv and xsb  see figures      indeed  both systems complete their computation in the allowed time and memory on larger instances  computational advantages
of the mae based encoding with respect to the join based encoding are particularly evident
   

fialviano  calimeri  faber  leone    perri

xsb mae
a
dlv
   

 
 

 

 
   

 

 

 

   

 
 

 
   
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

 

  

 
  

y

 

 

 

 

 

x

 m       players

 

 

   

 

 

 

 

 

 

 

 

  

y

 n        players

  

   
   

  

   
  

   

  

   
   

  
  
  

 

 

 
x

 

 

 

 

   

 

 

 

 

 

 

 

 

   

  

  
  

y

 

 

 
x

 o        players

 

 

 

 

   

 

 

 

 

 

 

 

 

  

y

 p        players

figure    attacks  average execution time of dlv running the aggregate based encoding
and xsb running the mae based encoding 

for xsb  which solved all tested instances with this encoding  however  also xsb with the
mae based encoding is outperformed by dlv with native support for aggregate constructs
 see figure    
in sum  the experimental results highlight that the presence of aggregate constructs can
significantly speed up the computation  indeed  the encoding using recursive aggregates
outperforms the aggregate free encodings in all tested instances 

   related work
defining a well founded semantics for logic programs with aggregates has been a challenge
of major interest in the last years  the first attempts  not relying on a notion of unfounded
set  have been defined on a restricted language  some of these are discussed by kemp and
stuckey         another semantics falling in this class is the one introduced by van gelder
        subsequently generalized by osorio and jayaraman         the main problem of
these semantics is that they often leave too many undefined literals  as shown by ross and
sagiv        
   

fiunfounded sets and well founded semantics of asp programs with aggregates

a first attempt to define a well founded semantics for unrestricted lpa has been done by
kemp and stuckey         this semantics is based on a notion of unfounded sets  according
to kemp and stuckey  a set x of standard atoms is an unfounded set for a  ground  program
p with respect to an interpretation i if  for each rule r  p with h r   x   either  a  some
literal in b r  is false with respect to i  or  b  b r   x  
    note that only standard
literals are considered by condition  b   and aggregates are not covered by it  we point
out that this definition of unfounded set makes the semantics inadequate for programs with
recursive aggregates  even if only monotone aggregates are considered  for example  for the
program  a     count x   a x          the well founded model in the work of kemp and
stuckey is   while a reasonable well founded semantics should identify a    as false 
pelov et al         defined a well founded semantics based on approximating operators 
namely d well founded semantics  which extends the standard well founded semantics  indeed  they coincide for aggregate free programs  more in detail  in that work aggregates
are evaluated in one of three possible ways  therefore  a family of semantics is defined by
pelov et al   which can be ordered by precision  more precise three valued aggregates lead
to more precise semantics  in general  higher precision comes at the price of a higher computational complexity  the authors discuss the following three valued aggregate relations
for the evaluation of aggregate literals  trivial  bound and ultimate approximating aggregates  where the first is the less precise  and the last is the most precise  semantics relying
on trivial approximating aggregates is very imprecise  but it is still suitable for the class
of stratified aggregate programs  both trivial and bound approximations have polynomial
complexity  while ultimate has been shown to be intractable for nonmonotone aggregate
functions  pelov         a detailed comparison with our results is presented in section     
ferraris        showed that the semantics of smodels programs with positive weight
constraints is equal to answer sets as defined by faber et al         on the respective
fragment  since by theorem    wp    approximates answer sets as defined by faber et al  
wp    can be used also as an approximating operator for the respective smodels programs 
indeed  it can be shown that the atmost pruning operator of smodels  simons et al        
is a special case of the i operator  defined in the proof of theorem     
other works attempted to define stronger notions of well founded semantics  also for
programs with aggregates   like the ultimate well founded semantics  denecker et al  
       or wfs  and wfs   dix   osorio         whether a characterization of these
semantics in terms of unfounded sets can exist for these semantics is unclear and left for
future research 
concerning compilations of lp a programs into standard lp  a transformation was provided by van gelder         the compilation that we presented in section     differs from
the one introduced by van gelder in several respects  our approach uses a total order
of the universe of the input program and takes advantage of the character of monotonicity antimonotonicity of the aggregate literals in the input program  while the transformation
defined by van gelder uses uninterpreted function symbols for representing ground sets 
and recursive negation for checking truth of aggregate literals  we briefly discuss these aspects in the following  roughly  for an aggregate f  s   k  uninterpreted function symbols
are used by the transformation in the work of van gelder for determining all pairs s    k 
such that s  is a ground set associated with s and k    f  s     after that  the transformation defined by van gelder checks whether there exists a pair s    k  satisfying the following
   

fialviano  calimeri  faber  leone    perri

conditions   i  for every element hconsts   conji in s    conj is true   ii  k   k holds  we
point out that condition  i  requires recursive negation in order to be checked  indeed 
it is equivalent to there is no element hconsts   conji in s  such that conj is not true 
this aspect of the transformation has an undesirable side effect  stratified lpa
m a programs
may have partial well founded models  that is  theorem   does not hold for programs compiled with the transformation introduced by van gelder  an example of this side effect is
given by van gelder  where it is shown that this transformation possibly leads to partial
well founded models for instances of company controls  a well known problem that can be
modeled by using monotone recursive aggregates 
    comparison with the work of pelov et al        
in this section we report a detailed comparison of the well founded semantics as defined
in this paper with the one of pelov et al          we recall that pelov et al  defines wellfounded and stable semantics as the least and total fixpoints of the three valued stable
model operator extended to aggregate programs 
we start by observing that the evaluation of ultimate approximating aggregates coincides
with the evaluation of aggregates defined in this article  also the evaluation of bound approximating aggregates coincides for monotone and antimonotone aggregates  as a consequence
of lemma    in this paper and proposition      in the work of pelov et al         
let us now introduce a translation of an aggregate literal into a formula of standard
literals  for a  partial  interpretation i  let conj i  denote the conjunction of all the literals
in i  the translation trm a  of a ground aggregate literal a is defined as follows 
w
trm a     conj i    i is a subset minimal interpretation
such that a is true with respect to i 
note that  for each  partial  interpretation j  the evaluation of a with respect to j coincides
with the evaluation of trm a  with respect to j  proposition   and proposition   in the
work of pelov et al          moreover  for a monotone  resp  antimonotone  aggregate literal
a  only positive  resp  negative  literals appear in trm a  
for a rule r in a ground lpa
m a program p and an aggregate literal a  b r   the
translation trm p  r  a  of a in r is the program obtained from p by removing r and
by adding a rule r such that h r     h r  and b r     b r     a   conj  for each
conj  trm a   therefore  the full translation trm p  of p is defined as the recursive
application of trm p  r  a   note that the order in which rules and aggregates are processed
is not relevant   we next show that p and trm p  have the same unfounded sets 
lemma    a set of atoms x is an unfounded set for a program p with respect to an
interpretation i if and only if x is an unfounded set for trm p  with respect to i 
proof  we use induction on the number of aggregate literals in p  if p has no aggregate
literals  then p   trm p   now consider a program p and a rule r  p with an aggregate
literal a in b r   we want to show that a set x of atoms is an unfounded set for p with
respect to i if and only if x is an unfounded set for trm p  r  a  with respect to i  since
in this case we might apply the induction hypothesis and prove the claim  thus  we can
end the proof by means of the following observations   i  a is false with respect to an
   

fiunfounded sets and well founded semantics of asp programs with aggregates

interpretation j if and only if trm a  is false with respect to j  that is  if and only if for
each conjunction conj  trm a  there is a literal   conj such that  is false with respect
to j   ii  such an  is a positive  resp  negative  standard literal if and only if a is monotone
 resp  antimonotone  

we can then prove that the well founded operators of p and trm p  coincide 
lemma    let p be an lpa
m a program and i an interpretation for p  then wp  i   
wtrm p   i  
proof  we have to show that     tp  i    ttrm p   i  and     gu sp  i    gu strm p   i  
we note that     immediately follows from lemma     in order to prove      we consider
an aggregate literal a occurring in p  by previous considerations  we have that a is true
with respect to i if and only if there is a conjunct in trm a  which is true with respect to
i  thus      holds 

we are now ready to relate our well founded operator with the one provided by pelov
et al         
theorem    for the class of lpa
m a programs  the well founded operator herein defined
coincides with the one of pelov et al         for both the ultimate and bound approximating
aggregate semantics   
proof  by lemma     we already know that wp  i    wtrm p   i   we also have that
wtrm p   i  coincides with the one in the work of van gelder et al         by theorem  
 since trm p  is a standard logic program   on the other hand  for both the ultimate and
bound approximating aggregate semantics  the well founded operators  as defined in pelov
et al         of p and trm p  coincide  this is a consequence of theorem   in the work of
pelov et al          because the three valued immediate consequence operators in the work
of pelov et al         and pelov et al         coincide  see definition   in pelov et al       
and definition     in pelov et al          moreover  the well founded operator of pelov et al 
       coincides with the one in the work of van gelder et al  for standard logic programs 
thereby obtaining the equality of the operators 

the correspondence of the two well founded semantics immediately follows from the
theorem above  indeed  the two well founded models are defined as the fixpoints of the
respective well founded operators 
corollary    the well founded model herein defined and the one of pelov et al        
for both the ultimate and bound approximating aggregate semantics  coincide for lpa
m a
programs 
as mentioned also earlier  by virtue of the above theorem and corollary  some of the
results presented in this paper also follow from earlier results in the literature  in particular 
theorem    theorem    and some of our complexity results follow from definitions and
results of pelov        and pelov et al         
   note that this operator is referred to as stable revision operator by pelov et al         

   

fialviano  calimeri  faber  leone    perri

   conclusion
in this paper we introduced a new notion of unfounded set for lpa
m a programs and analyzed
a well founded semantics for this language based on this notion  this semantics generalizes
the traditional well founded semantics for aggregate free programs and also coincides with
well founded semantics for aggregate programs as defined by pelov et al         the latter
not being defined by means of a notion of unfounded set   we could also show that this
semantics and its main operator wp have close ties with answer sets as defined by faber
et al                and can hence serve as approximations 
we proved that computing this semantics is a tractable problem  indeed  the semantics
is given by the least fixpoint of the well founded operator wp   the fixpoint is reached after a
polynomial number of applications of the operator wp  with respect to the size of the input
program   each of them requiring polynomial time  for showing that an application of wp
is polynomial time feasible  we have proved that evaluating monotone and antimonotone
aggregate literals remains polynomial time computable also for partial interpretations  since
in this case only one of the possibly exponential extensions must be checked  for a monotone
aggregate literal  this extension is obtained by falsifying each undefined literal  while for an
antimonotone aggregate literal  each undefined literal is taken as true in the extension 
motivated by these positive theoretical results  we have implemented the first system
supporting a well founded semantics for unrestricted lpa
m a   allowing for using monotone
and antimonotone aggregate literals  the implemented prototype is ready for experimenting
with the lpa
m a framework  the experiments conducted on the attacks benchmark highlight
the computational gains of a native implementation of aggregate constructs with respect to
equivalent encodings in standard lp 

acknowledgments
partly supported by regione calabria and eu under por calabria fesr           within
the pia project of dlvsystem s r l   and by miur under the prin project loden
and under the pon project frame proposed by atos italia s p a   we also thank the
anonymous reviewers for their valuable comments 

references
alviano  m   faber  w     leone  n          compiling minimum and maximum aggregates
into standard asp  in formisano  a   ed    proceedings of the   rd italian conference
on computational logic  cilc       
baral  c          knowledge representation  reasoning and declarative problem solving 
cambridge university press 
brewka  g          well founded semantics for extended logic programs with dynamic
preferences  journal of artificial intelligence research          
calimeri  f   faber  w   leone  n     perri  s          declarative and computational
properties of logic programs with aggregates  in nineteenth international joint
conference on artificial intelligence  ijcai      pp         
   

fiunfounded sets and well founded semantics of asp programs with aggregates

dellarmi  t   faber  w   ielpa  g   leone  n     pfeifer  g          aggregate functions
in dlv  in de vos  m     provetti  a   eds    proceedings asp     answer set
programming  advances in theory and implementation  pp          messina  italy 
online at http   ceur ws org vol     
denecker  m   pelov  n     bruynooghe  m          ultimate well founded and stable
model semantics for logic programs with aggregates  in codognet  p   ed    proceedings of the   th international conference on logic programming  pp         
springer verlag 
dix  j     osorio  m          on well behaved semantics suitable for aggregation  in
proceedings of the international logic programming symposium  ilps      port jefferson  n y 
eiter  t   gottlob  g     mannila  h          disjunctive datalog  acm transactions on
database systems                 
faber  w          unfounded sets for disjunctive logic programs with arbitrary aggregates  in baral  c   greco  g   leone  n     terracina  g   eds    logic programming and nonmonotonic reasoning   th international conference  lpnmr   
diamante  italy  september       proceedings  vol       of lecture notes in computer science  pp        springer verlag 
faber  w   leone  n     pfeifer  g          recursive aggregates in disjunctive logic programs  semantics and complexity  in alferes  j  j     leite  j   eds    proceedings
of the  th european conference on artificial intelligence  jelia        vol       of
lecture notes in ai  lnai   pp          springer verlag 
faber  w   leone  n     pfeifer  g          semantics and complexity of recursive aggregates
in answer set programming  artificial intelligence                   special issue 
john mccarthys legacy 
ferraris  p          answer sets for propositional theories  in baral  c   greco  g   leone 
n     terracina  g   eds    logic programming and nonmonotonic reasoning   th
international conference  lpnmr    diamante  italy  september       proceedings 
vol       of lecture notes in computer science  pp          springer verlag 
ferraris  p          logic programs with propositional connectives and aggregates  acm
transactions on computational logic          in press 
gebser  m   kaufmann  b   neumann  a     schaub  t          conflict driven answer
set solving  in twentieth international joint conference on artificial intelligence
 ijcai      pp          morgan kaufmann publishers 
gelfond  m          representing knowledge in a prolog  in kakas  a  c     sadri  f 
 eds    computational logic  logic programming and beyond  vol       of lncs  pp 
        springer 
gelfond  m     lifschitz  v          classical negation in logic programs and disjunctive
databases  new generation computing            
gottlob  g   leone  n     veith  h          succinctness as a source of expression complexity  annals of pure and applied logic                  
kemp  d  b     stuckey  p  j          semantics of logic programs with aggregates  in
saraswat  v  a     ueda  k   eds    proceedings of the international symposium on
logic programming  islp     pp          mit press 
   

fialviano  calimeri  faber  leone    perri

leone  n   pfeifer  g   faber  w   eiter  t   gottlob  g   perri  s     scarcello  f         
the dlv system for knowledge representation and reasoning  acm transactions
on computational logic                
liu  l   pontelli  e   son  t  c     truszczynski  m          logic programs with abstract
constraint atoms  the role of computations  artificial intelligence                   
liu  l     truszczynski  m          properties and applications of programs with monotone
and convex constraints  journal of artificial intelligence research             
manna  m   ruffolo  m   oro  e   alviano  m     leone  n          the hilex system for
semantic information extraction  transactions on large scale data and knowledgecentered systems  springer berlin heidelberg  to appear 
manna  m   ricca  f     terracina  g          consistent query answering via asp from
different perspectives  theory and practice  theory and practice of logic programming  to appear 
marek  v  w     truszczynski  m          logic programs with abstract constraint atoms 
in proceedings of the nineteenth national conference on artificial intelligence  aaai
       pp        aaai press   the mit press 
mccarthy  j          programs with common sense  in proceedings of the teddington
conference on the mechanization of thought processes  pp        her majestys
stationery office 
mccarthy  j          circumscription  a form of non monotonic reasoning  artificial
intelligence                
mccarthy  j          applications of circumscription to formalizing common sense
knowledge  artificial intelligence                
mccarthy  j          formalization of common sense  papers by john mccarthy edited by
v  lifschitz  ablex 
mccarthy  j     hayes  p  j          some philosophical problems from the standpoint
of artificial intelligence  in meltzer  b     michie  d   eds    machine intelligence   
pp          edinburgh university press  reprinted in  mccarthy        
mcdermott  d  v          non monotonic logic ii  nonmonotonic modal theories  journal
of the acm               
mcdermott  d  v     doyle  j          non monotonic logic i  artificial intelligence 
              
minsky  m          a framework for representing knowledge  in winston  p  h   ed   
the psychology of computer vision  pp          mcgraw hill 
moore  r  c          semantical considerations on nonmonotonic logic  artificial intelligence               
osorio  m     jayaraman  b          aggregation and negation as failure  new generation
computing                 
pelov  n          semantics of logic programs with aggregates  ph d  thesis  katholieke
universiteit leuven  leuven  belgium 
pelov  n   denecker  m     bruynooghe  m          translation of aggregate programs to
normal logic programs  in de vos  m     provetti  a   eds    proceedings asp  
  answer set programming  advances in theory and implementation  pp       
messina  italy  online at http   ceur ws org vol     
   

fiunfounded sets and well founded semantics of asp programs with aggregates

pelov  n   denecker  m     bruynooghe  m          partial stable models for logic programs with aggregates  in proceedings of the  th international conference on logic
programming and non monotonic reasoning  lpnmr     vol       of lecture notes
in ai  lnai   pp          springer 
pelov  n   denecker  m     bruynooghe  m          well founded and stable semantics of
logic programs with aggregates  theory and practice of logic programming        
       
pelov  n     truszczynski  m          semantics of disjunctive programs with monotone
aggregates   an operator based approach  in proceedings of the   th international
workshop on non monotonic reasoning  nmr        whistler  bc  canada  pp 
       
reiter  r          a logic for default reasoning  artificial intelligence                 
ricca  f   alviano  m   dimasi  a   grasso  g   ielpa  s  m   iiritano  s   manna  m    
leone  n          a logic based system for e tourism  fundamenta informaticae 
ios press                 
ricca  f   grasso  g   alviano  m   manna  m   lio  v   iiritano  s     leone  n         
team building with answer set programming in the gioia tauro seaport  theory
and practice of logic programming  cambridge university press  to appear 
ross  k  a     sagiv  y          monotonic aggregation in deductive databases  journal
of computer and system sciences               
simons  p   niemela  i     soininen  t          extending and implementing the stable
model semantics  artificial intelligence              
son  t  c     pontelli  e          a constructive semantic characterization of aggregates
in answer set programming  theory and practice of logic programming            
son  t  c   pontelli  e     tu  p  h          answer sets for logic programs with arbitrary
abstract constraint atoms  journal of artificial intelligence research             
swift  t     warren  d  s          xsb  extending prolog with tabled logic programming 
computing research repository  corr   abs           
tarski  a          a lattice theoretical fixpoint theorem and its applications  pacific j 
math            
truszczynski  m          reducts of propositional theories  satisfiability relations  and
generalizations of semantics of logic programs  artificial intelligence                
ullman  j  d          principles of database and knowledge base systems  computer
science press 
van gelder  a          the well founded semantics of aggregation  in proceedings of
the eleventh symposium on principles of database systems  pods     pp         
acm press 
van gelder  a   ross  k  a     schlipf  j  s          the well founded semantics for
general logic programs  journal of the acm                 
wittocx  j   marien  m     denecker  m          the idp system  a model expansion
system for an extension of classical logic  in denecker  m   ed    proceedings of
the  nd workshop on logic and search  computation of structures from declarative
descriptions  lash     pp         

   

fi