journal of artificial intelligence research               

submitted        published      

m app  a scalable multi agent path planning algorithm with
tractability and completeness guarantees
ko hsin cindy wang
adi botea

c indy wang   rsise   anu   edu   au
a di  b otea   nicta   com   au

nicta   the australian national university 
canberra  australia

abstract
multi agent path planning is a challenging problem with numerous real life applications  running a centralized search such as a  in the combined state space of all units is complete and
cost optimal  but scales poorly  as the state space size is exponential in the number of mobile units 
traditional decentralized approaches  such as far and w hca    are faster and more scalable  being
based on problem decomposition  however  such methods are incomplete and provide no guarantees with respect to the running time or the solution quality  they are not necessarily able to tell in
a reasonable time whether they would succeed in finding a solution to a given instance 
we introduce m app  a tractable algorithm for multi agent path planning on undirected graphs 
we present a basic version and several extensions  they have low polynomial worst case upper
bounds for the running time  the memory requirements  and the length of solutions  even though
all algorithmic versions are incomplete in the general case  each provides formal guarantees on
problems it can solve  for each version  we discuss the algorithms completeness with respect to
clearly defined subclasses of instances 
experiments were run on realistic game grid maps  m app solved        of all mobile units 
which is       better than the percentage of far and w hca    m app marked        of all
units as provably solvable during the first stage of plan computation  parts of m apps computation
can be re used across instances on the same map  speed wise  m app is competitive or significantly
faster than w hca    depending on whether m app performs all computations from scratch  when
data that m app can re use are preprocessed offline and readily available  m app is slower than the
very fast far algorithm by a factor of      on average  m apps solutions are on average    
longer than fars solutions and      longer than w hca  s solutions 

   introduction
path planning is important in many real life problems  including robotics  military operations  disaster rescue  logistics  and commercial games  single agent path planning  where the size of the state
space is bounded by the size of the map  can be tackled with a search algorithm such as a   hart 
nilsson    raphael         however  when there are many units moving simultaneously inside a
shared space  the problem becomes much harder  a centralized search from an initial state to a goal
state is a difficult problem even inside a fully known  two dimensional environment represented as
a weighted graph  where one node can be occupied by exactly one unit at a time  assuming that
units have the same size  and each unit moves synchronously to an adjacent unoccupied node in one
time step  the problems state space grows exponentially in the number of mobile units  existing
hardness results have shown that it is np complete to decide if a solution of at most k moves exists  ratner   warmuth         or to optimize the solution makespan  surynek      b   a version
of the problem with one robot only and movable obstacles at several nodes  where either the robot
c
    
ai access foundation  all rights reserved 

fiwang   b otea

or an obstacle can move to an adjacent vacant node per step  is also np complete  papadimitriou 
raghavan  sudan    tamaki         yet another version of the problem  determining if a solution exists for moving two dimensional rectangles of different sizes inside a box  has been shown
to be pspace hard  even without requiring optimality  hopcroft  schwartz    sharir         despite its completeness and solution optimality guarantees  a centralized a  search has little practical
value in a multi agent path planning problem  being intractable even for relatively small maps and
collections of mobile units 
scalability to larger problems can be achieved with decentralized approaches  which decompose
the global search into a series of smaller searches to significantly reduce computation  however 
existing decentralized methods such as far  wang   botea        and w hca    silver       
are incomplete  and provide no formal criteria to distinguish between problem instances that can be
successfully solved and other instances  further  no guarantees are given with respect to the running
time and the quality of the computed solutions 
in this work we present an algorithm that combines the strengths of both worlds  working well
in practice and featuring theoretical tractability and partial completeness guarantees  we introduce
m app  a tractable multi agent path planning algorithm for undirected graphs  for each problem instance  m app systematically identifies a set of units  which can contain all units in the instance  that
are guaranteed to be solved within low polynomial time  for the sake of clarity we will distinguish
between a basic version and a few extended versions of m app  m app provides formal guarantees
for problems it can solve  the basic m app algorithm is complete for a class of problems  called
s lidable  which we define in section    extended versions of the algorithm enlarge the completeness range  as discussed in section    and improve solution length  as discussed in section    we
will also evaluate a version that attempts to solve all units  not only the provably solvable ones 
given a problem with m graph nodes and n mobile units  m apps worst case performance for
the running time is o m  n     or even smaller  e g   o max mn    m  log m     depending on the
assumptions on the input instance  the worst case memory requirements are within o m  n  or
even o mn   an upper bound of the solution length  measured as the total number of moves  is in
the order of o m  n    or even o mn     see section   for a detailed discussion 
m app keeps its running costs low by eliminating the need for replanning  a path  u  for
each unit u is computed at the beginning  no replanning is required at runtime  a blank travel
idea  inspired from the way the blank moves around in sliding tile puzzles  is at the center of the
u
algorithm  a unit u can progress from its current location liu to the next location li  
on its path
u
 u  only if a blank is located there  i e   li   is empty   intuitively  if the next location is currently
occupied by another unit  m app tries to bring a blank along an alternate path  outlined in bold in
u
u
and li  
without passing through liu   when possible  the blank is
figure    which connects li 
u
brought to li   by shifting units along the alternate path  just as the blank travels in a sliding tile
puzzle  the ability to bring a blank to the next location is key to guarantee a units progress  formal
details are provided in section   
we performed detailed experiments  evaluating different versions of m app and comparing
m app with fast but incomplete methods such as far and w hca   on grid maps  the results are
presented in section    the benchmark data  wang   botea        consist of     to      mobile
units uniformly randomly generated on    game maps  with    scenario instances per number of
units of each map  we conclude that the extended m app has significantly better success ratio and
scalability than state of the art incomplete decentralized algorithms  in particular  m app solves
a higher percentage of units even on crowded instances  despite m apps incompleteness in the
  

fim app   s calable m ulti  agent path p lanning

a

b

u

l

a
u

c

b
c

figure    at the left  unit u is blocked by a  a blank is found at location l along the alternate
path  which is marked with a bold contour  at the right  by sliding b and then a along
u   for the sake of clarity and simplicity  we
the alternate path  the blank is brought to li  
illustrate examples in a four connected grid world 

general case  the algorithm marks        of all units as provably solvable during the first stage of
plan computation  when attempting to solve all units  not only the provably solvable ones  m app
succeeds for        of all units  in comparison  far solved        of all units  w hca   solved
        with diagonal moves allowed  and         with no diagonal moves  of all units  even in
challenging instances with       mobile units on the maps      to       mobile units in our test
data fall within m apps completeness range  i e   they are provably solvable   in terms of the percentage of fully solved instances  a version of m app that attempts to solve all units  not only those
that are provably solvable  is successful in       of all instances  this is significantly better than
far          w hca   with no diagonal moves          and w hca   with diagonals          
parts of m apps computation can be re used across instances on the same map  on instances
solved by all algorithms  m app is competitive in speed or significantly faster than w hca    depending on whether m app performs all computations from scratch  when such re usable data are
available  m app is slower than the very fast far algorithm by a factor of      on average  m apps
solutions reported here are on average     longer than fars solutions and      longer than
w hca  s solutions 
parts of this work have been reported in shorter conference papers as follows  a theoretical
description of basic m app  with no experiments  is provided in an earlier paper  wang   botea 
       a brief overview of m app extensions and a brief summary of initial results are the topic of a
two page paper  wang   botea         new material added in the current paper includes a detailed
algorithmic description of the enhancements to basic m app and formal proofs for the algorithms
properties  we also provide a comprehensive empirical analysis of enhanced m app  with several
additional experiments 
the rest of this paper is structured as follows  next we briefly overview related work  then 
we state our problem definition in section    sections    focus on basic m app  sections   and
  cover enhancements to the basic m app algorithm  extending its completeness range  section    
  

fiwang   b otea

and improving the quality of plans and also the running time  section     an empirical evaluation
is the topic of section    the last part contains conclusions and future work ideas 

   related work
finding a shortest path that connects a single pair of start target points on a known  finite map can
be optimally solved with the a  algorithm  hart et al          the extension to path planning for
multiple simultaneously moving units  with distinct start and target positions  introduces potential
collisions due to the physical constraint that one location can only be occupied by one unit at a
time  units have to interact and share information with other units in their path planning  making
the problem more complex 
in multi agent path planning  a centralized a  performs a single global search in the combined
state space l   l       ln for n units  where li is the set of possible locations of unit i 
centralized a  plans the paths for all units simultaneously  finding a joint plan containing all units
actions  waits as well as moves   it retains the optimality and completeness guarantees of a   but
has a prohibitively large state space of o mn   states  for n units on a graph with m nodes  moreover 
most of the search nodes generated are unpromising  taking some units farther from goal  standley 
       this poses a strong limiting factor on problems that a centralized a  can solve in practice 
on the other hand  a purely decentralized method  local repair a   l ra     stout        first
plans each units path independently with a   then  during execution  l ra   replans by additional
independent a  searches every time a collision occurs  in a good case  l ra   can significantly
reduce computations to o mn   however  it can also generate cycles between units  and is unable to
prevent bottlenecks  these problems have been discussed by silver         bulitko  sturtevant  lu 
and yau         pottinger         and zelinsky         in such cases  l ra   exhibits a significant
increase in running time and may not terminate  therefore  all of the straightforward extensions of
single agent a  outlined above have strong limitations in practice 
traditionally  multi agent path planning took a centralised or a decentralised approach  latombe 
      choset et al          a centralized approach plans globally  sharing information centrally 
such as using a potential field  barraquand  langlois    latombe         by contrast  a decentralized approach decomposes the problem into a series of smaller subproblems  typically first computing the units paths individually  ignoring all other units  then handling the interactions online 
examples in robotics include computing velocity profiles to avoid collisions with other units  kant
  zucker         or pre assigning priorities to process robots one by one  erdmann   lozanoperez         recent algorithms can also use a combination of the two approaches  for instance 
the biased cost pathfinding  bcp  technique  geramifard  chubak    bulitko        generalised
the notion of centralized planning to a central decision maker that resolves collision points on paths
that were pre computed independently per unit  by replanning colliding units around a highestpriority unit  to avoid excessively long  or even potentially unbounded  conflict resolutions  a limit
on planning time is set  bcp returns paths with the fewest collisions within that time  the algorithm
was shown to work well in small scale gridworld scenarios  but it is not complete or optimal in the
general case  standleys        algorithm  on the other hand  improved the standard centralized
search whilst preserving both optimality and completeness  his new state space representation incorporates the next move assignments of every unit into each state  and decomposes a timestep from
advancing all units to advancing units one by one in a fixed ordering  thus the branching factor is
reduced from  n to    while increasing the depth of the search by a factor of n  this technique gen  

fim app   s calable m ulti  agent path p lanning

erates no more than  nt state nodes with a perfect heuristic  t being the number of timesteps in the
optimal solution   in practice  this operator decomposition technique  od  is still often intractable 
producing a lower exponential search space than the standard joint search space  recognising that
it is much cheaper to perform several independent searches than one global search  standley also
decoupled planning for non interfering subgroups of units after an independence detection  id  
each group is then solved centrally such that optimality of the overall solution is still guaranteed 
the fully developed hybrid algorithm  od id  uses operator decomposition to improve the centralized planning of non independent subproblems  nonetheless  the optimality requirement is costly
in practice  planning time is still dominated by the largest subgroup of units  as the number of
units increases  they are less likely to be independent as their paths unavoidably overlap  so the
subgroups are expected to increase in size too  standleys        experiments showed that the incomplete algorithm hca   silver        actually solved more instances  furthermore  these are
relatively small problems compared to our experiments  wang   botea               having at
least   orders of magnitude fewer agents  between     units   and much smaller maps  with   to  
orders of magnitude fewer tiles  approximately     tiles  
therefore  methods for tackling larger problems take a decentralized approach  and are usually suboptimal in nature  in general  giving up optimality reduces computation significantly  decentralized path planning is often much faster  and scales up to much larger problems  but yields
suboptimal solutions and provides no completeness guarantees  recent work on grid maps include
w hca    silver         which uses a   dimensional temporal spatial reservation table and performs
a series of windowed forward searches on each unit  based on a true distance heuristic obtained
from an initial backward a  search from each target  in the far algorithm  wang   botea        
units follow a flow annotation on the map when planning and moving  repairing plans locally using
heuristic procedures to break deadlocks  other flow related ideas include jansen and sturtevants
       direction map for sharing information about units directions of travel  so later units can
follow the movement of earlier ones  with the improved coherence leading to reduced collisions 
methods such as these scale up to instances with the number of units well beyond the capabilities of
centralized search  however  as mentioned earlier  these methods have no known formal characterizations of their running time  memory requirements  and the quality of their solutions in the worst
case  they lack the ability to answer in a reasonable bounded time whether a given problem would
be successfully solved  which is always important in the case of incomplete algorithms 
in practice  both traditional approaches to multi agent pathfinding have serious drawbacks  with
the inherent trade off between scalability  optimality and completeness  recently  a body of work
has begun to bridge the gap between the two  by addressing both completeness and tractability issues
hand in hand  in a bounded suboptimal approach  ryan        introduced a complete method that
combines multi agent path planning with hierarchical planning on search graphs with specific substructures such as stacks  halls  cliques and rings  for example  a stack is a narrow corridor with
only one entrance  which is placed at one end of the stack  many maps  including the game maps
used in our experiments  seem not to allow an efficient decomposition into stacks  halls  cliques
and rings  b ibox  surynek      b  solves problems with at least   unoccupied vertices on a biconnected graph  in the worst case  the number of steps is cubic in the number of nodes  b ibox
was later extended to work with just   unoccupied vertex necessary  surynek      a   because of
the densely populated problems that the algorithm was designed for  surynek      a  has expressed
that b ibox does not target computer game scenarios  where there are normally a lot fewer units
than locations on the map  b ibox is suited for multi robot scenarios such as automatic packages
  

fiwang   b otea

inside a warehouse  surynek      c   bibox   surynek      a   that requires only   unoccupied
node  was shown to run significantly faster and have significantly shorter solutions than kornhauser 
miller  and spirakiss        algorithm for their related pebble coordination game  we performed
a quick evaluation of b ibox using the code obtained from the author  we found that  on graphs at
an order of magnitude smaller than our game maps  b ibox exhibits a fast growing runtime  e g  
more than    minutes for a graph with      locations  and long solutions  with millions of moves 
part of the explanation is that b ibox builds its instances to be very crowded  in our understanding 
b ibox was designed to solve very crowded instances  not necessarily to efficiently solve instances
with significantly fewer units than locations 

   problem statement
an instance is characterized by a graph representation of a map  and a non empty collection of
mobile units u   units are homogeneous in speed and size  each unit u  u has an associated starttarget pair  su   tu    all units have distinct starting and target positions  the objective is to navigate
all units from their start positions to the targets while avoiding all fixed and mobile obstacles  a state
contains the positions of all units at a given time  our work assumes undirected weighted graphs
where each unit occupies exactly one node at a time  and can move to an unoccupied neighbour
node  the time is discretized and one or more units can move synchronously at each time step 
travelling along an edge does not depend on or interfere with the rest of the problem  except for the
two nodes connected by that edge 
several methods exist to abstract a problem map into a search graph  including navigation
meshes  tozour         visibility points  rabin         and quadtrees  samet         however  a
graph abstraction that generates too few nodes  such as a visibility graph  may render a multi agent
pathfinding problem unsolvable  even though it works for the single agent case  on the other hand 
a search graph obtained from imposing a regular grid contains more nodes  covering all locations
of the traversable space  and offers more path options to avoid collisions between units  hence 
grid maps  besides being very popular and easy to implement  are more suitable to multi agent
problems  for clarity and practicality  we focus on grid maps in our examples and experiments 
nonetheless  the conditions and algorithmic definitions for m app  which we introduce in the next
few sections  are not specific to regular grid maps  in our illustrated examples  we assume that only
straight moves in the four cardinal directions can be performed    connected grid   restricting the
movements from   directions  cardinal   diagonals  to   cardinal directions has no negative impact
on completeness  since the standard practice is to allow a diagonal move only if an equivalent  but
longer  two move path exists  for every solution that allows diagonal moves  there is a solution with
only cardinal moves  therefore  any problem with diagonal moves can be reduced to a problem with
only straight moves  at the price of possibly taking longer paths  introducing diagonal moves could
reduce the path length  but has the potential drawback of blocking units more often than straight
moves on crowded maps  whether there is enough clearance to make a diagonal move depends on
the other two adjacent nodes  i e   the other two tiles sharing the common corner on the grid   since
it is physically impossible to squeeze through two units 

   the s lidable class of instances
we introduce a subclass of instances for which basic m app will be shown to be complete 

  

fim app   s calable m ulti  agent path p lanning

i
i  

u

 u 
i  

u and lu  denoted as i   
figure    an example of an alternate path  i   connecting locations li 
i  
and i     in the picture  that belong to the precomputed path  u  of unit u 

definition    s lidable unit and s lidable instance   a mobile unit u is s lidable iff a path
u
u
 u     l u   l u           l  u  
  of nodes exists  where l u   su   l  u  
  tu   such that all the following
conditions are met 
u   lu   lu on  u   except the
   alternate connectivity  for each three consecutive locations li 
i i  
last triple ending with tu   i e  for     i     u       an alternate path ui exists between
u and lu that does not go through lu   see figure   for an example 
li 
i  
i

   initial blank  in the initial state  l u is blank  i e  unoccupied  
   target isolation  no target interferes with the  or  paths of the other units  more formally 
both of the following hold for tu  
 a   v  u    u     tu 
   v   and
 b   v  u  i                v          tu 
  vi  
an instance belongs to the class s lidable iff all units u  u are s lidable 
the three conditions can be verified in polynomial time  the verification includes attempting to
compute the  and  paths for each unit  since each state space that a  has to explore here is linear
in m  each a  search time is polynomial in m  the checks for a blank location in the first step  and
for not passing through other targets  are trivial  the process that checks the s lidable conditions
serves for an important additional purpose  by the time the checks succeed and an instance is known
to belong to s lidable  we have completed all the search that is needed to solve the instance  the
remaining part of the algorithm will simply tell units when to wait  when to move forward  and
when to move backwards along the already computed  and  paths 
notice that the three conditions are not restricted to grid maps only  they work on the standard
assumption that one graph node can only be occupied by one unit at a time  and that moving along
an edge neither depends nor interferes with other parts of the graph except for two nodes at the ends
of that edge 
  

fiwang   b otea

algorithm   overview of m app 
   for each u  u do
  
compute  u  and s  as needed  from su to tu
  
if s lidable conditions hold then
  
mark u as s lidable
   initialize a as the set of s lidable units  optional  make all units active  as discussed in text 
   while a     do
  
do progression step
  
do repositioning step if needed

   basic m app
we present the basic version of the m app algorithm  which is complete on the s lidable class of
problems  a main feature of basic m app  and its extensions presented in sections   and    is that
it is deadlock free and cycle free  due to a total ordering of active units  units of lower priority do
not interfere with the ability of higher priority units to advance 
as illustrated in algorithm    for each problem instance  m app starts by computing a path  u 
for each unit u to its target  goal   constructing and caching alternate paths  along the way  note
that all paths  and alternate paths  need to satisfy the conditions in definition    if the for loop in
lines    succeeds for all units  m app can tell that the instance at hand belongs to s lidable  for
which m app is complete 
if only a subset of units are marked as s lidable  m app is guaranteed to solve them  this
is equivalent to solving a smaller instance that is s lidable  optionally  m app can attempt to
solve the remaining units as well  by adding them to the set of active units but giving them a lower
priority than s lidable units  it is important to stress out that  in the remaining part of the paper 
the implicit assumption is that m app attempts to solve only the provably solvable units  unless we
explicitly state the opposite  in the experiments section  however  we discuss both options 
the set of s lidable units is partitioned into a subset s of solved units that have already reached
their targets  and a subset a of active units  initially  all units are active  in the s lidable class 
after becoming solved  units do not interfere with the rest of the problem  as ensured by the target
isolation condition   as shown later  in basic m app solved units never become active again  and do
not have to be considered in the remaining part of the solving process 
definition    the advancing condition of an active unit u is satisfied iff its current position  pos u  
belongs to the path  u  and the next location on the path is blank 
definition    a state is well positioned iff all active units have their advancing condition satisfied 
lines    in algorithm   describe a series of two step iterations  a progression step advances
active units towards their targets  as shown later  each progression step brings at least one active
unit to its target  shrinking the active set a and ensuring that the algorithm terminates  reaching the
state where all units are solved  a progression could result in breaking the advancing condition of
one or more active units  if any remain  the objective of a repositioning step is to ensure that each
active unit has its advancing condition satisfied before starting the next progression step  note that
a repositioning step is necessary after every progression step except for the last 
  

fim app   s calable m ulti  agent path p lanning

a
b
a
b

a

a

b

b

a

a

b

a
b

i

b
ii

b
iii

b
iv

v

figure    example of how m app works 

    example
a simple example of how m app works is illustrated in figure    there are two units  a and b 
m app uses a total ordering of the active units in each progression step  section       here  a has a
higher priority than b  the targets of a and b are drawn as stars  in figure    i   as a and b progress
towards their targets  a becomes blocked by b  in  ii   a blank is brought in front of a by sliding
b down ai  outlined in bold   as a side effect  b is pushed off its path  at the end of the current
progression step  iii   a reaches its target  in the repositioning step  iv   since a is already solved 
as moves are ignored  repositioning undoes bs moves until b is back on its path and it has a blank
it front of it  now bs advancing condition is restored and therefore the global state in this example
is well positioned  in the next progression step  v   b reaches its target  the algorithm terminates 
    path computation
for each problem instance  we compute each path  u  individually  the paths  u  are fixed
throughout the solving process  to ensure that paths satisfy the alternate connectivity condition
 definition     we modify the standard a  algorithm as follows  when expanding a node x    a
neighbour x   is added to the open list only if there is an alternate path between x   and x  the parent
of x    by this process we compute each path  u  and its family of alternate paths  simultaneously 
to give each neighbour x   of the node x  a chance to be added to the open list  node x  might have
to be expanded at most three times  once per possible parent x  therefore  o m  node expansions
are required by a  search to find each  path  where m is the number of locations on the map 
equivalently  computing a  path could also be seen as a standard a  search in an extended space
of pairs of neighbouring nodes  at most four nodes are created in the extended space for each original
node  
since alternate paths depend only on the triple locations  not the unit  we can re use this information when planning paths for all units of the same problem  this means that the alternate path
for any set of three adjacent tiles on the map is computed at most once per problem instance  and
cached for later use  given a location l on a grid map  there are at most eight locations that could
be on a path two moves away on a four connect grid  as shown in figure  a  these eight locations
form a diamond shape around l  for each of the four locations that are on a straight line from l
  

fiwang   b otea

 
 

 
 

l

 
 

 
 

 

 

i

 

l

ii

 

 

 

 

 

a

b

figure     a  the eight locations two moves away from l   b  two two move paths from l to location
  go through i and ii 

 locations              we precompute an alternate path that avoids the in between location and any
targets  for each of the other four locations  labeled              we need to compute  at most  two
alternate paths  for example  there are two possible paths between l and   that are two moves long 
through i or ii  figure  b   we need one alternate path to avoid each intermediate location  i and
ii  in summary  we precompute at most    paths for each l  for at most m locations on a map  we
need at most   m
     m alternate paths  only one computation for each triple  since an alternate
path connects its two endpoints both ways  
a possible optimization is to reuse alternate paths across s lidable instances on the same map 
alternate paths that overlap targets in the new instance need to be re computed  we discuss this
option in the experiments section 
    progression
algorithm   shows the progression step in pseudocode  at each iteration of the outer loop  active
units attempt to progress by one move towards their targets  they are processed in order  line     if
unit v is processed before unit w  we say that v has a higher priority and write v   w  the ordering
is fixed inside a progression step  but it may change from one progression step to another  the actual
ordering affects neither the correctness nor the completeness of the method  but it may impact the
speed and the solution length  the ordering of units can be chosen heuristically  e g  giving higher
priority to units that are closer to target  thus  these units could get to their target more quickly  and
once solved they are out of the way of the remaining units in the problem 
to ensure that lower priority units do not harm the ability of higher priority units to progress 
we introduce the notion of a private zone  we will see in algorithm   that a unit cannot cause
moves that will occupy the private zone of a higher priority unit   given a unit u  let pos u  be
u
its current position  and let int  u      l u           l  u   
  be the interior of its precomputed path
 u   as shown in algorithm    a unit u might get pushed off its precomputed path  in which case
pos u  
   u  
u   lu   if pos u    lu  int  u   
definition    the private zone   u   of a unit u is  u     li 
i
i
otherwise   u     pos u    in other words  the private zone includes the current location of the

   a move caused by a unit u is either a move of u along its own  u  path  or a move of a different unit w  which is
being pushed around by u as a side effect of blank travel 

  

fim app   s calable m ulti  agent path p lanning

algorithm   progression step 
   while changes occur do
  
for each u  a in order do
  
if pos u  
   u  then
  
do nothing  u has been pushed off track as a result of blank travel 
u in current progression step then
  
else if u has already visited li  
  
do nothing
u   belongs to the private zone of a higher priority unit  i e 
  
else if the next location  li  
u
v   u   li     v  then
u is released by v 
  
do nothing  wait until li  
u is blank then
  
else if li  
u
   
move u to li  
u then
   
else if can bring blank to li  
u
   
bring blank to li  
u
   
move u to li  
   
else
   
do nothing

unit  in addition  when the unit is on its pre computed path but not on the start position  the location
behind the unit belongs to the private zone as well 
lines     in algorithm   show the processing of u  the active unit at hand  if u has been pushed
off its precomputed path  then no action is taken  lines      lines   and   cover the situation when
unit u has been pushed around  via blank travel  by higher priority units back to a location on  u 
already visited in the current progression step  in such a case  u doesnt attempt to travel again on
a previously traversed portion of its path  ensuring that the bounds on the total travelled distance
u
introduced later hold  if u is on its path but the next location li  
is currently blocked by a higheru is available  u
priority unit v  then no action is taken  lines      otherwise  if the next location li  
u
moves there  lines       finally  if li   is occupied by a smaller priority unit  an attempt is made
u
to first bring a blank to li  
and then have u move there  lines        when u moves to a new
u
u is the target location of u  if this
location li    lines    and      a test is performed to check if li  
is the case  then u is marked as solved by removing it from a and adding it to s  the set of solved
units 
u
bringing a blank to li  
 lines    and     was illustrated in figure    here we discuss the
process in more detail  a location l  ui is sought with the following properties      l is blank 
u  inclusive  along u belongs to the private zone of a higher    none of the locations from l to li  
i
u
priority unit  and     l is the closest  along ui   to li  
with this property  if such a location l is
u
found  then the test on line    succeeds  the actual travel of the blank from l to li  
along ui
 line     is identical to the movement of tiles in a sliding tile puzzle  figure   shows an example
u
before and after blank traveling  the intuition behind seeking a blank along ui is that  often  li 
u to lu and until the test on line    is
remains blank during the time interval after u advances from li 
i
performed  this is guaranteed to always hold in the case of the active unit with the highest priority 
which we call the master unit 
let us introduce and characterize the behaviour of the master unit more formally  at the beginning of a progression step  one master unit u is selected  it is the unit with the highest priority among
  

fiwang   b otea

the units that are active at the beginning of the progression step  the status of being the master unit
is preserved during the entire progression step  even after u becomes solved  at the beginning of
the next progression step  a new master unit will be selected among the remaining active units 
lemma    the master unit u can always bring a blank to its front  if it needs one 
u   belongs to its private zone   u   and no other unit can
proof  since us previous location  li 
u  
move into the private zone of the highest priority unit  u is guaranteed to always find a blank at li 
u to lu can belong to the private zone of a higher priority
moreover  no location along ui from li 
i  
unit since there are no units with a higher priority  note also that ui is free of physical obstacles by
u to lu  
construction  so it must be possible for the blank to travel from li 
i  

lemma    the master unit u is never pushed off its  path 
proof  if u is pushed off  u  in blank travelling performed by another unit  it contradicts with u
being the highest priority unit 
theorem    as long as the master unit u is not solved  it is guaranteed to advance along  u  at
each iteration of the outer  while  loop in algorithm    by the end of the current progression
step  at least u has reached its target 
proof  using the previous two lemmas  it is easy to check that u never enters a do nothing line in
algorithm    similar to lemma    u is never pushed and cannot revisit a previous location  also 
since u has the highest priority  its next location cannot be held in the private zone of another unit 
hence  us progress to its target is guaranteed 
the following result is useful to ensure that a progression step always terminates  either in a
state where all units are solved or in a state where all remaining active units are stuck 
theorem    algorithm   generates no cycles  i e   no repetitions of the global state  
proof  we show a proof by contradiction  assume that there are cycles  consider a cycle and the
active unit u in the cycle that has the highest priority  since no other unit in the cycle dominates u 
it means that the movements of u cannot be part of a blank travel triggered by a higher priority unit 
therefore  the movements of u are a result of either line    or line     that is  all us moves are
along its path  u   since  u  contains no cycles  u cannot run in a cycle 
    repositioning
by the end of a progression step  some of the remaining active units  if any are left  have their
advancing condition broken  recall that this happens for a unit u when either pos u  
   u  or u
is placed on its precomputed path but the next location on the path is not blank  a repositioning
step ensures that a well positioned state is reached  i e   all active units have the advancing condition
satisfied  before starting the next progression step 
a simple and computationally efficient method to perform repositioning is to undo a block of the
most recent moves performed in the preceding progression step  undoing a move means carrying
out the reverse move  solved units are not affected  for those remaining active units  we undo their
moves  in reverse global order  until a well positioned state is encountered  we call this strategy
reverse repositioning  an example is provided in section     
  

fim app   s calable m ulti  agent path p lanning

proposition    if the reverse repositioning strategy is used at line   of algorithm    when needed  
then all progression steps start from a well positioned state 
proof  this lemma can be proven by induction on the iteration number j in algorithm    since the
initial state is well positioned  this follows easily from definitions   and     the proof for j    
is trivial  assume that a repositioning step is performed before starting the iteration j      in the
worst case  reverse repositioning undoes all the moves of the remaining active units  but not the
moves of the units that have become solved   back to their original positions at the beginning of j th
progression step  in other words  we reach a state s that is similar to the state s  at the beginning
of the previous progression step  except that more units are on their targets in s  since s  is well
positioned  according to the induction step   it follows easily that s is well positioned too 

   worst case and best case analysis
we give here bounds on the runtime  memory usage  and solution length for the m app algorithm
on a problem in s lidable with n units on a map of m traversable tiles  we examine the worst case
scenario in each case  and also discuss a best case scenario at the end 
we introduce an additional parameter    to measure the maximal length of alternate paths   in
the worst case   grows linearly with m  however  in many practical situations   is a small constant 
since the ends of an  path are so close to each other  our analysis discusses both scenarios 
theorem     algorithm   has a worst case running time of o max n  m  m  log m   when  is a
constant  and o n  m    when  grows linearly with m 
proof  as outlined in section      each single agent a  search with a consistent heuristic   expands
o m  nodes  hence  assuming that the open list is implemented as a priority queue  each a  search
takes o m log m  time  note that  on graphs where all edges have the same cost  the log m factor
could in principle be eliminated using a breadth first search to find an optimal path  grid maps with
only cardinal moves fit into this category  however  for simplicity  here we assume that the log m
factor is present 
hence  in the worst case  the searches for  paths take o nm log m  time for all n units  the
a  searches for all s take o m  log m  time 
in a single progression step  outlined in algorithm    suppose blank travel is required by all n
units  for every move along the way except the first and last moves  since the length of  paths is
bounded by m and the length of alternate paths  is bounded by   the total number of moves in a
progression step is o nm   and so is the running time of algorithm   
clearly  the complexity of a repositioning step cannot exceed the complexity of the previous
progression step  hence the complexity of each iteration in algorithm    lines     is o nm  
the number of iterations is at most n  since the size of a reduces by at least one in each iteration  so
m app takes o max nm log m  m  log m  n  m   time to run  which is o max n  m  m  log m  
when  is constant and o n  m    when  grows linearly with m 
theorem     the maximum memory required to execute m app is o nm  when  is a constant  or
o nm    when  grows linearly with m 
   it is well known that the manhattan heuristic  which we used in our implementation  is consistent  the proof is
easy  being a direct result of    the definition of consistency and    the way the manhattan distance is computed  by
pretending that there are no obstacles on the map  

  

fiwang   b otea

proof  caching the possible  paths for the entire problem as described in section     takes o m 
memory  the a  searches for the  paths are performed one at a time  after each search   is stored
in a cache  and the memory used for the open and closed lists is released  the a  working memory
takes only o m  space  and storing the  paths takes o nm  space  overall  path computation
across all units requires o nm   m  space 
then  in lines    of algorithm    memory is required to store a stack of moves performed
in one progression step  to be used during repositioning  as shown in the proof of theorem    
the number of moves in a progression step is within o nm   so  the overall maximum memory
required to execute the program is o nm   which is o nm  when  is a constant and o nm   
when  grows linearly with m 
theorem     the total distance travelled by all units is at most o n  m  when  is a constant  or
o n  m    when  grows linearly with m 
proof  as shown previously  the number of moves in a progression step is within o nm   the
number of moves in a repositioning step is strictly smaller than the number of moves in the previous
progression step  there are at most n progression steps  followed by repositioning steps   hence 
the total travelled distance is within o n  m  
corollary     storing the global solution takes o n  m  memory when  is a constant  or o n  m   
when  grows linearly with m 
we discuss now a best case scenario  m app computes optimal solutions in the number of moves
when the paths  are optimal and all units reach their targets without any blank traveling  i e   units
travel only along the paths    an obvious example is where all paths  are disjoint  in such a case 
solutions are makespan optimal too  as well as preserving the optimality in the best case  the search
effort in m app can also be smaller than that spent in a centralised a  search  being n single agent
m 
o m  searches  compared to searching in the combined state space of n units  with up to  mn  
states 

   extending the completeness range
to extend m apps completeness beyond the class s lidable  we evaluated the impact of each of
the three s lidable conditions in a preliminary experiment  we ran basic m app on the same data
set that we also used in the main experiments  the data set and the main experiments are described
in section     in the preliminary experiment  we switched off one s lidable condition at a time
and counted how many units satisfy the remaining two conditions  a larger increase in the number
of solvable units suggests that relaxing the definition of the condition at hand could provide a more
significant increase in the completeness range 
this initial experimental evaluation indicates that basic m app with all three s lidable conditions solves        of units  basic case   if the alternate connectivity requirement is switched off 
       units satisfy the remaining two conditions  switching off target isolation makes       
units satisfy the remaining two conditions  however  ignoring the blank availability condition has a
very small impact  increasing the percentage only slightly  from        in the basic case to        
these results suggest that the alternate connectivity and the target isolation conditions are more restrictive than the blank availability condition  thus  we focus on relaxing these two conditions 
  

fim app   s calable m ulti  agent path p lanning

for target isolation  our extension allows a unit to plan its path through other targets  when doing
so can still guarantee that a clearly identified set of units will reach their targets  this is the topic
of section      to extend alternate connectivity  we developed a technique that allows  paths to
be planned through regions with no alternate paths  such as tunnels  the blank travelling operation
for a tunnel crossing unit now uses the blank positions ahead of this unit  along the remaining of its
pre computed path  as we describe in detail in section      an empirical analysis of each of these
features is provided in section   
    relaxing the target isolation condition
when several targets are close to each other  the target isolation condition  forbidding  and  paths
to pass through targets  can make targets behave as a virtual wall  disconnecting two areas of the
map  as a result  basic m app can report many units as non s lidable 
the extension we introduce allows a unit u to plan its path through the target of another unit v 
if subsequently v is never assigned a higher priority than u  more specifically  a partial ordering 
is defined  such that u  v iff the target of v belongs to the  path of u or to any
path along us
s u  
ui    every
 path  written more formally  u  v iff tv   u   where  u      u   ki  
time we mention  we refer to its transitive closure  we show in this section that  if paths can be
planned in such a way that the  possibly empty  relation  creates no cycles of the type u  u  then
an instance can be solved with a slight modification of basic m app 
units plan their  and  paths through a foreign target only when they have no other choice  to
achieve this strategy  in the a  searches we assign a very high cost to graph search edges adjacent
to a foreign target  this has the desirable outcome of reducing the interactions caused by the target
isolation relaxation  in particular  the way the original s lidable units compute their paths is
preserved  as no foreign targets will be crossed in such cases  in other words  instances in s lidable
are characterized by an empty  relation 
definition     an instance belongs to class t i s lidable iff for every unit u there exists a path  u 
satisfying the alternate connectivity and the initial blank condition as in the definition of s lidable
 definition     furthermore  no cycles are allowed in the  relation 
assume for a moment that a  possibly empty   relation without cycles is available  aspects
related to obtaining one are discussed later in this section 
definition     for solving t i s lidable instances  the extended algorithm  t i m app  has two
small modifications from the original algorithm 
   the total ordering   inside each progression step stays consistent with   u  v  u   v 
   if u  v  then v cannot be marked as solved  i e  moved from a to s  unless u has already
been marked as solved 
with these extra conditions at hand  we ensure that even if a unit x arrives at its target tx before
other units clear tx on their  paths  those units can get past x by performing the normal blank
travel  following that  x can undo its moves back to tx in the repositioning step  as in basic m app 
to prove that t i m app terminates  we first prove the following two lemmas hold for the highest
priority unit  u  in any progression step 
  

fiwang   b otea

lemma     no other unit will visit the target of u  tu   in the current progression step 
proof  since u is the master unit  it follows that u   v for any other active unit v  according to
point   of definition     it follows that u  v  relation  has no cycles  which means that v  u 
therefore  by applying the definition of   it follows that tu 
   v   this completes the proof  as
in m app all movements are performed along  and  paths 
since a repositioning step can only undo moves made in the previous progression step  units
will only revisit locations visited during that progression step  so  the following is a direct result of
lemma    
corollary     no other unit will visit tu in the repositioning step that follows 
corollary     after u is solved  it cannot interfere with the rest of the problem 
theorem     t i m app terminates 
proof  showing that at least the highest priority unit u reaches its target in a given progression step
is virtually identical to the proof for lemma    corollary    guarantees that  after solving u  it does
not interfere with the rest of the problem  hence  the number of active units strictly decreases after
each progression step  and the algorithm eventually terminates 
let us get back to the question of how to provide a cycle free  relation  testing whether all
units can plan their paths in such a way that no cycle is introduced might end up being expensive 
when a unit u cant possibly avoid all other targets  it might have to choose between crossing the
target of v or crossing the target of w  one option might lead to a cycle whereas the other might
avoid cycles  therefore  a systematic search might be required to seek a cycle free relation  
rather than searching systematically  our t i m app takes a cheaper  greedy approach  if there
are cycles  we mark a number of units as not being t i s lidable  these are selected in such a way
that all other units remain cycle free  we call these t i s lidable units   t i s lidable units are
guaranteed to be solved 
as a result of its greedy approach  t i m app is not complete on class t i s lidable  still  it
is complete on a superset of s lidable and it is able to identify many units  often all  that will be
provably solved 
finally  we wrap up the discussion of this extension by concluding that the upper bounds for
m app  given in section    still apply to t i m app  the proof is identical because we can make the
same worst case assumptions as before  only the master unit gets solved in a progression step  and
every move along each units  path requires blank travel  moreover  note the additional step after
path pre computation for topologically sorting the partial order    into a linear priority order   
can be done cheaply in time linear on the number of units  tarjan        
    relaxing the alternate connectivity condition
as we will show in section    the previous extension of target isolation significantly improves
m apps success ratio  i e   percentage of solvable units   yet  there was significant room for further
improvement  in particular  maps with single width tunnels still showed a bottleneck in terms of
success ratio  tunnels make the alternate connectivity condition  connecting the two ends of
a consecutive triple locations without going through the middle  harder or even impossible to
  

fim app   s calable m ulti  agent path p lanning

satisfy  when a single width tunnel bridges two otherwise disjoint regions  as shown in figure   
the versions of m app presented so far fail to find a path between the two regions  because alternate
connectivity is broken for triples inside the tunnel 

figure    an example where all units have their targets on the other side  and the only way is to
cross the single width bridge  units are drawn as circles  and their corresponding targets
are squares of the same shade 

in this section we introduce the buffer zone extension  our solution for relaxing the alternate
connectivity condition  it allows many paths  corresponding to many units  to cross the same singlewidth tunnel  the intuition is simple  often  there are plenty of blank positions ahead of a unit  along
the remaining locations of its precomputed  path and the corresponding  paths along it  our
tunnel crossing operation is essentially a generalisation of blank travelling  where a blank position
is sought from the path ahead  instead of the alternate path of the current location triple 
definition     for each precomputed path  u  that crosses tunnels  we define the following 
 the buffer zone    u    is the portion of  u  between the target and the end of the
last tunnel  at thesj th move on  u    together with the corresponding alternate paths 
  u    
 liu    ui  
i j       ku   

 a dynamic counter    u    keeps track of how many positions in the buffer zone are blank 
the counter is initialized at the beginning with the appropriate value  and it is incremented
and decremented as necessary later on 
 a threshold    u   is set to length t       where t is the longest tunnel to be crossed by the
unit u  this threshold acts as a minimal value of   u   that guarantees that u can cross
tunnels safely 

  

fiwang   b otea

when a unit u attempts to cross a tunnel  it can push units of lower priorities to the closest blank
locations in the buffer zone  until u exits the tunnel  for such a tunnel crossing operation to be
possible  enough blanks have to be available in the buffer zone  before we analyse the new extended
algorithm in detail  we introduce the extended class ac s lidable  whose definition includes those
units meeting the new buffer zone extension 
definition     in relaxing the alternate connectivity condition  we allow  u  to go through one or
more single width tunnels iff there are enough blanks in us buffer zone  with at least    u   blank
locations in   u   in the initial state  i e     u       u    as before  alternate paths are still
needed for all locations outside of tunnels 
definition     a unit u  u belongs to the extended class  which we call ac s lidable  iff it has
a path  u  meeting the initial blank and the target isolation conditions as given in the definition of
s lidable  definition     and the relaxed alternate connectivity condition  definition    above  
ac m app is modified from basic m app in the following two ways to integrate our buffer
zone technique for relaxing the alternate connectivity condition  firstly  a repositioning step cannot
finish if a counter    has a value below the threshold      in other words  we need to ensure that
enough blanks are available in a buffer zone before a progression step begins  the following is the
new advancing condition  updated from definition   by adding the extra  aforementioned condition 
definition     the advancing condition of an active  tunnel crossing unit u is satisfied iff its current
position belongs to the path  u  and the next location on the path is blank  as given in definition    
and also   u       u   
secondly  we need to preserve one of basic m apps main features  where units of lower priority
never block units with higher priority  ensuring that m app does not run into cycles or deadlocks 
hence  a unit u with a lower priority than v cannot cause moves that bring   v   below the
threshold  i e   from    v   to    v        recall that a move caused by u is either a move
of u along its own  u  path  checked in lines     of algorithm     or a move of a different unit
w  which has been pushed around by u as a side effect of blank travel  checked in lines      of
algorithm     thus the buffer zone of u acts as a generalised private zone  in which u holds at least
   u   locations that are not accessible to units with lower priorities 
our extensions for ac m app maintain the following properties of basic m app 
lemma     as long as the master unit u is not solved  it is guaranteed to advance along  u  at
each iteration of the outer  while  loop in algorithm    by the end of the current progression
step  at least u has reached its target 
proof  most of this result follows directly from the proof for lemma    the parts that are new
in algorithm   compared to algorithm    the progression step in basic m app  are the check in
lines     and the modified blank travelling operation  lines         since u has the highest priority
of the current progression step  it can cause moves affecting the buffer zone of every other unit  but
no other unit can move into the buffer zone of u when doing so would bring the number of blanks
below the threshold  i e    u        u    hence u is guaranteed to have enough blanks to cross
each tunnel on  u  
the proof for lemma    below is very similar to lemma   in section     
  

fim app   s calable m ulti  agent path p lanning

u  
algorithm   ac m app  canbringblank  unit u  location li  
   if u is outside of tunnels then
  
look for a nearest blank b along ui
   else if u is inside a tunnel then
  
look for a nearest blank b from   u  
   if no b can be found then
  
return false
u   do  segment along u or   u   from above 
   for each location l   b          li  
i
  
if v   u   l   v  then  check if causing another unit to move into the private zone of a
higher priority unit  v 
  
return false
   
else if v   u   l    v       v       v   then  check if causing another unit to
move into the buffer zone of a higher priority unit  v 
   
return false
    return true

algorithm   ac m app  progression step 
   while changes occur do
  
for each u  a in order do
  
if pos u  
   u  then
  
do nothing
u
  
else if v   u   li  
  v  then
  
do nothing
u
  
else if v   u   li  
   v       v       v   then  check when moving into the
buffer zone of a higher priority unit 
  
do nothing  wait until v has more blanks in its buffer zone 
u in current progression step then
  
else if u has already visited li  
   
do nothing
u is blank then
   
else if li  
u
   
move u to li  
u   then  algorithm   
   
else if canbringblank  u  li  
u
   
bring blank to li  
u
   
move u to li  
   
else
   
do nothing

lemma     algorithm   generates no cycles  i e   no repetitions of the global state  
theorem     ac m app terminates 
proof  it follows from lemmas    and    that the number of active units strictly decreases over
successive iterations of algorithm    hence  the algorithm ac m app eventually terminates 
since we have shown that the algorithm ac m app is guaranteed to solve the class ac s lid the completeness result shown below follows directly 

able  

  

fiwang   b otea

corollary     ac m app is complete on the class ac s lidable 
the ac m app extension preserves the upper bounds on running time  memory usage  and solution length given in section    here  we introduce max to denote the maximal length of tunnels that
units have to cross  in our worst case analysis  all units initiate blank travelling for every move along
the way  which now involves tunnels  so  depending on whether max or   the maximal length of
 paths  is longer  ac m app runs in o n  mmax   or o n  m  time  since both parameters are
often constant in practice  or grow at worst linear in m  the running time is o n  m  or o n  m    
as before  the bounds for total travel distance and global solution follow directly  lastly  there is
virtually no additional memory required for storing the buffer zones  except for one counter and one
threshold variable  per unit 
    combining target isolation and alternate connectivity relaxations
we show that the two extensions to the s lidable class can be combined 
definition     an instance belongs to the extended class  t i ac s lidable  iff for every unit u
there exists a path  u  meeting the initial blank condition as given in definition    and the relaxed
alternate connectivity condition from definition     furthermore  the  possibly empty   relation
introduced as a result of target isolation relaxation has to be cycle free  just as in definition    
we obtain an extended algorithm  t i ac m app  by combining t i m app  definition     and
ac m app  algorithms   and    
theorem     t i ac m app terminates 
proof  as in the proof for lemma     we can show that at least the highest priority unit u reaches its
target in a progression step  as follows  from definition     u is guaranteed to have enough blanks
to clear through any single width tunnels along its path  definitions    and    guarantee that 
outside of tunnels  u can always bring a blank when needed  as stated in lemma    furthermore 
this progression step generates no cycles  this can be proved as in the cases of lemmas    and   
we also know that the solved unit u does not interfere with the rest of the problem  from the
results of lemmas    and     and corollary     note that the tricky cases where units have their
targets inside single width tunnels are excluded from the extended class t i ac s lidable  because
they have zero buffer capacity according to how  was defined in definition    
since each iteration of the algorithm solves at least one unit  t i ac m app terminates 

   improving solution length
as mentioned before  to avoid replanning  units pushed off track in blank travelling by other units
undo some of their moves to get back on their  paths in the immediate repositioning step  we have
observed that  in practice  the reverse repositioning strategy  defined in section      can introduce
many unnecessary moves  which increase the solution length  increase the running time  and may
hurt the visual quality of solutions 
recall that  in a standard reverse repositioning step  new moves are added to the solution that
is being built  these moves undo  in reverse order  moves of active units  i e   those not solved
yet  made in the previous progression step  the process continues until a well positioned state is
  

fim app   s calable m ulti  agent path p lanning

u

 v 

u

 v 

v

v

 u 

 u 

figure    two examples of global checking for a well positioned state 

reached  which means that all active units have their advancing condition satisfied  i e   have every
active unit on its  path with a blank in front  
after each undo move  the well positioned check is performed globally  in other words  basic
m app checks the advancing condition for all active units  not only for the unit affected by the most
recent undo move  this global checking guarantees to eventually reach a well positioned state  as
proved in proposition    but  as mentioned earlier  it can often create many unnecessary moves 
we provide two simple examples in figure    to illustrate one case when global checking is
useful  and one case when global checking is too strong a condition  adding unnecessary moves 
first  consider two units  u and v  such that undoing one move off the global moves stack places u
back on its path  with a blank in front  assume further that us current position is on the way of vs
future undo moves  as shown on the left of figure    therefore  even if us advancing condition is
satisfied  u needs additional undo moves  to make room for the undo moves of other units  such as v 
in order to reach a globally well positioned state  in this case  global checking is useful  as a second
example  imagine that u and vs moves in the most recent progression step are independent from
each other  possibly even in two map areas far away from each other  a simple case is shown on the
right of figure    in the most recent progression  vs last move  when v was derailed  was followed
by a sequence of us moves  only the final move of u pushed it off track  whereas the preceding
moves were along us  path   u   reverse repositioning would undo moves in the reverse global
order  which means undoing all us moves before undoing vs last move  however  only one undo
move for u and one undo move for v are sufficient to restore both units to a well positioned state 
as we just illustrated  a global checking of the advancing condition could be too strong  whereas
a local checking could be insufficient  the solution that we introduce in this section  which is
called repositioning with counting  finds a middle ground between the two extremes  improves the
number of moves and still maintains the guarantee of reaching a well positioned state  intuitively 
the undo moves for a unit u can stop as soon as  a  us advancing condition is satisfied   b  its
current position cannot possibly interfere with future undo moves of other units   c  no other unit
performing repositioning can possibly stop in the blank position in the front of u on us  path 
  

fiwang   b otea

and  d  u doesnt stop in the initial second location of another active unit v  the initial second
location of a unit v is the position ahead of v at the beginning of the most recent progression step 
the fourth condition ensures that all units can have a blank in front at the end  as in the worst case
they will revert back to the initial position at the beginning of the most recent progression step  
definition     for each location l on a  or an  path  we keep a counter  c l   such that 
 at the beginning of each progression step  the counter c l  is reset to    if l is empty  and to   
if l is occupied 
 every time l is visited during the progression step  c l  is incremented 
 every time a unit leaves l as a result of an undo move during the repositioning step  c l  is
decremented 
following directly from the definition of c l  given above  we formulate the following two
results for c l  at repositioning time 
lemma     if c l       then no unit will pass through l in the remaining part of the current
repositioning step 
lemma     for a given active unit u  at its current position pos u   if c pos u        then all
progression moves through the location pos u  have already been undone  in other words  no other
unit in the remainder of this repositioning step will pass through pos u  
we now introduce our new enhancement for m app  aimed at eliminating many useless undo
moves in its repositioning steps 
definition     the enhanced algorithm  r c m app  uses the repositioning with counting strategy
at line   of algorithm    this means that each active unit u stops undoing moves in the current
repositioning step  as soon as it meets all of the following conditions 
 a  the advancing condition of u is satisfied according to definition    plus the extension in definition    
 b  for us current location  pos u   c pos u      
u   c lu      
 c  for the location in front of u  li  
i  

 d  the current location is not the initial second location of another active unit 
theorem     all repositioning steps in r c m app end in a well positioned state 
   condition d  can be ignored without invalidating the algorithms ability to make progress towards the goal state  even
if some units could possibly end up in a state without a blank in front  it is guaranteed that at least one unit  i e   the
one that finishes repositioning first  will have a blank in front  this further guarantees that at least one unit will be
solved in the next progression step 

  

fim app   s calable m ulti  agent path p lanning

proof  recall that all the moves made in a progression step are kept as a totally ordered list  we can
prove directly that repositioning with counting  by undoing a subset of those moves  reaches a wellpositioned state  since the counter c l  is incremented and decremented according to definition    
a unit u satisfying all three conditions in definition    has restored its own advancing condition 
furthermore  the combined results from lemmas    and    guarantee that no other units will later
get in us way  and that u is out of the way of the other units repositioning moves 

by theorem     applying r c in the repositioning steps of our extended algorithm t i ac m app
has no negative impact on completeness 

   experimental results
in this section we present our empirical evaluation of the m app algorithm  we first point out the
impact of each newly added feature  then we put our t i ac r c enhanced m app to the test
in a comparison with existing state of the art decoupled  incomplete methods  specifically  our
benchmarks are far  wang   botea         and an extended version of silvers        w hca  
algorithm by sturtevant and buro         called w hca   w a   which applies abstraction to the
expensive initial backward a  searches  as for m app  these algorithms have been tested on rather
large problems  both in terms of map size and number of units  we are not aware of other programs
that scale as well as far and w hca    the strengths of these two methods are the potential ability
to find a solution quickly  but their weakness is that they cannot tell whether they would be able to
solve a given instance 
we implemented m app from scratch and integrated it in the hierarchical open graph   hog 
framework  the source code for the extended w hca   algorithm  w hca   w  a   sturtevant  
buro         with the extra features of spatial abstraction and diagonal moves  but without a priority
system for unit replanning   was obtained from nathan sturtevant  the far algorithm was our
implementation as used in previous experiments  wang   botea        
experiments were run on a data set of randomly generated instances used in previously published work  wang   botea         the input grid maps  are    of the largest from the game baldurs gate    which range from       to       traversable tiles in size  as listed in table    these
game maps are quite challenging  containing different configurations of obstacles forming different
shapes of rooms  corridors  and narrow tunnels  we test each map with     to      mobile units
in increments of      a    minute timeout per instance is set  in the w hca   w  a  experiments 
we set the window size  w  to    and use the first level of abstraction  a       this seems to be a
good parameter setting in the work of sturtevant and buro         and our experiments comparing
with w hca         show w hca        to work better on this data set  abstraction allows w hca  
to build the heuristic on a graph that is smaller than the actual graph where the movement takes
place  in far  units make reservations for k     steps ahead  which is the recommended setting 
all experiments were run on a     ghz intel core   duo imac with  gb of ram 
  

fiwang   b otea

basic mapp

number in slidable

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number of agents

    

ti mapp
   
   
   
   
   
   
   
   
   
   

    
    
   
 

ac mapp
    

 

number in ac slidable

number in ti slidable

    

   
    
    
total number of agents

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number of agents

    

ti   ac mapp
number in ti ac slidable

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number of agents

    

figure    mapps widened completeness range after each relaxation  each graph line represents
the number of units solved for problem instances on a map  here  only provably solvable
units are counted 

  

fim app   s calable m ulti  agent path p lanning

far

number of agents solved

    

   
   
   
   
   
   
   
   
   
   

    

    

   

 

 

   
    
    
total number of agents

    

whca  with diagonals

number of agents solved

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number of agents

    

whca  no diagonals

number of agents solved

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number of agents

    

figure    the success ratios  averaged over    trials  of far  and w hca         with and without
diagonals  on the same set of problem instances  the timeout was set to    minutes per
instance for all   incomplete algorithms 
  

fiwang   b otea

map id
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr

short id
   
   
   
   
   
   
   
   
   
   

  nodes
     
     
     
     
     
     
     
     
     
     

table    the    maps in descending order  in terms of number of nodes 

    scalability as percentage of solved units
we compare far  w hca        and four versions of m app  basic m app with the original s lid able definitions  t i m app   the version with only the target isolation relaxation switched on  ac
m app  based on relaxing the alternate connectivity condition  and t i  ac m app  relaxing both the
target isolation condition  and the alternate connectivity condition  we measure the success ratio 
which is defined as the percentage of solved units  note that repositioning with counting  r c  does
not have to be considered in this section  since it has no impact on the success ratio  being designed
to improve solution length 
the m app versions used in this section attempt to solve only units that are provably solvable
 i e   units marked as s lidable  t i s lidable  ac s lidable  t i ac s lidable respectively  
the reason is that we want to evaluate how many units fall in each of these subclasses in practice 
the next section will show data obtained with a version of m app that attempts to solve all units 
figure   summarizes the success ratio data from each version of the m app algorithm on all
maps  the closer a curve is to the top diagonal line  being the total number of units   the better the
success ratio on that map  basic m app exhibits a mixed behaviour  having a greater success ratio on
six maps  on the four challenging maps                 and       the success ratio gets often below
    as the number of mobile units increases  these maps have a common feature of containing
long narrow corridors and even single width tunnels  connecting wider  more open regions of the
map  thus it is not surprising that  as mentioned in section    the alternate path and target isolation
conditions are identified as the greatest causes for failing to find a s lidable path 
relaxing the target isolation condition  t i m app  significantly improves the success ratio on
all maps  now a very good success ratio      or higher  is achieved for   maps across the entire
range of the number of mobile units  the other   maps contain not only a high proportion of narrow
corridors  but also single width tunnels 
relaxing alternate connectivity as well  t i  ac m app  yields an excellent success ratio for
all unit numbers on all maps  for example  in the scenarios with      units  which are the most
   http   webdocs cs ualberta ca nathanst hog html
   our experimental maps can be viewed online  at  http   users cecs anu edu au cwang gamemaps
   http   www bioware com games baldurs gate 

  

fim app   s calable m ulti  agent path p lanning

challenging according to figures   and    the smallest success ratio is      map      and the largest
one is        in scenarios with fewer mobile units  t i ac m app has even better success ratios 
next we compare the success ratio of t i ac m app  bottom plot of figure    to those of far
 top plot of figure    and w hca         middle and bottom of figure    with and without diagonals 
respectively   extended m app is the clear winner in terms of scalability  far and w hca   suffer
when the number of units is increased  these incomplete algorithms often time out even in scenarios
with significantly fewer units than       with      units  far solves as few as       of units 
while w hca   solves as few as only        no diagonal moves  and        with diagonal moves 
of the units  over the entire data set  t i ac m app solved        of all the units  far solved
       of units  while        and        are solved by w hca   with and without diagonal moves
allowed  respectively 
    scalability when attempting to solve all units
as in the previous section  we compare far  w hca   and m app  the t i ac m app version
used here attempts to solve all units  not only the provably solvable ones  attempt all feature   as
mentioned earlier  this is achieved by marking all units as active at the beginning  active units are
partitioned into three categories  i  provably solvable units that did not reach their target  ii  other
units that have not reached their target  and iii  units that have reached their target location  but they
are still active because other units still have to cross through that location  the total ordering   of
active units must respect the conditions that units in category i  have a higher priority than units in
category ii   which have a higher priority than units in category iii  
with the attempt all feature turned on  t i ac m apps percentage of solved units increases
from         section      to        
next we focus on the number of solved instances  an instance is considered to be solved iff all
units are solved  m app is successful in       of all instances  this is significantly better than far
         w hca   with no diagonal moves          and w hca   with diagonals          
the attempt all feature has a massive impact on the percentage of fully solved instances  improving it from     to        it might seem counter intuitive that the attempt all feature has a
small impact on the percentage of solved units but a great impact on the percentage of solved instances  the explanation is the following  when m app fails in an instance  it does so because of
a very small percentage of units that remain unsolved  often  there can be as few as one or two
unsolved units in a failed instance  managing to solve the very few remaining units as well with the
attempt all feature will result in the whole instance changing its label from failed to solved  even
though the change in the overall percentage of solved units will be small 
the remaining sections use the attempt all feature as well  the reason is that it increases the
number of solved instances and therefore we obtain a larger set of data to analyse 
    total travel distance
factors that may impact the length of plans are the lengths of the initial  paths  and the extra movements caused by blank travel and repositioning  in our experiments  the length of the precomputed
 paths has virtually no negative impact on the travel distance  even when m apps  paths have to
satisfy additional constraints  such as avoiding other targets when possible  they are very similar in
length with the normal unconstrained shortest paths  being only      longer on average 
  

fiwang   b otea

rc improved travel distance  map     
      

mapp total
rc mapp total
mapp pre computed pi
mapp undos
rc mapp undos

distance  moves 

      
      
      
      
      
      
      
 
 

 

 

                     
number of agents     s 

figure    a typical case of improved distances of r c m app over normal m app  note the precomputed  paths are not affected by the r c enhancement 

in this section  we first evaluate the improvement of repositioning with counting  r c  over
standard reverse repositioning  then we compare the total distance travelled by r c m app against
far and w hca   
      r educing u ndo m oves
we identified an excessive undoing of moves in repositioning as a bottleneck in basic m app  figure   shows the benefits of repositioning with counting  r c   the enhancement described in section    the figure compares the total travelled distance  as well as the number of undo moves  of
r c t i ac m app  shown as r c m app for short  to t i ac m app  m app for short  on an average case  as shown  repositioning with counting turns out to be quite effective  eliminating many
unnecessary undo moves  that do not help to reach the globally restored state   averaged over the
entire data set  r c m app has       shorter undo distance than m app with the standard reverse
repositioning  which results in reducing the total travelled distance by       on average 
      c omparing t otal d istance with far and w hca       
now we evaluate the solution length of attempt all r c t i ac m app as compared to far and
w hca         we plot the total travel distance averaged over the subset of input instances that all
algorithms considered here can fully solve 
figures    and    show average results for all maps  for m app  we show the length of the
precomputed  paths  the number of the undo  repositioning  moves  and the total travelled distance 
according to this performance criterion  the set of maps is roughly partitioned into three subsets 
in a good case  such as map      m app performs better than w hca        without diagonals
in terms of total travel distance  and is even comparable to far  in an average case  m apps travel
  

fim app   s calable m ulti  agent path p lanning

total travel distance  good case      
     

whca       nod
far
mapp total
whca      
mapp pi
mapp undos

     
     
     

      
distance

     

distance

total distance travelled  average case      
      

     
     

      

whca  nod
mapp total
far
whca      
mapp pi
mapp undos

      
      

     

     

     
 
   

   

   

           
number of agents

   

   

 
   

   

total distance travelled      
      

distance

      
      
      

whca  nod
mapp total
whca  d
far
mapp pi
mapp undos

      

     
     

      

mapp total
whca  nod
far
mapp pi
whca  d
mapp undos

      
      

     

     

     
 
   

                           
number of agents

total distance travelled      
      

distance

      

   

   

   

               
number of agents

   

 
   

   

   

   
   
    
number of agents

    

figure     distance travelled plotted averaged over instances fully solved by all algorithms 

distance is roughly comparable to w hca   without diagonals  maps           and     belong to
this category  finally  in a harder case  m apps total distance increases at a faster rate than the
others  which is a direct result of an increasingly larger number of undo moves  these harder cases
include maps                          and      upon inspection  these cases typically involve a
high number of turns and corners  in m apps case  this results in a high degree of path overlapping 
as units keep close to the edge when rounding a corner  to obtain shorter  paths 
to summarise the overall results  m apps travel distance ranges from       shorter than w hca  
without diagonal moves  to at most      longer  being    longer on average  compared to the
version of w hca   with diagonal moves enabled  m apps total distance is     longer on average 
varying from      shorter to at most      longer  compared to far  m apps solutions range
from      shorter to at most      longer  being     longer on average 
a closer look at the results reveals that  even with repositioning by counting in use  m app can
still make unnecessary undo moves  each useless undo move counts double in the final solution
length  since the undo has to be matched with a new forward move in the next progression step 
improving the solution length further is a promising direction for future work 
    running time analysis
as in the case of travel distance analysis  for a meaningful runtime comparison  we also restrict the
analysis to the subset of instances completed by all algorithms  far  both w hca   versions  and
  

fiwang   b otea

total travel distance  harder case      
      

distance

      
      

mapp total
whca       nod
far
mapp pi
whca  d
mapp undos

      

total distance travelled      
      
      
      
distance

      

      
      
      

      

      

     

     

 
   

   

 
                      
number of agents

mapp total
whca  nod
far
mapp pi
whca  d
mapp undos

   

mapp total
whca  nod
far
mapp pi
whca  d
mapp undos

      
      

mapp total
whca       nod
far
mapp pi
whca      
mapp undos

      
      
     
 

                                             
number of agents

                                             
number of agents

total distance travelled      
      

distance

      
      

mapp total
whca  nod
far
mapp pi
whca  d
mapp undos

      

total distance travelled      
      
      
distance

      

      

mapp total
whca  nod
far
mapp pi
whca  d
mapp undos

      
      

      

     

     
 

                      
number of agents

total travel distance      
      

distance

distance

total distance travelled      
      
      
      
      
      
      
      
      
      
     
 

   

 
                                             
number of agents

   

   

                      
number of agents

figure     distance travelled continued  the remaining six maps 

t i ac r c m app with the attempt all feature turned on   we show both overall summary data  in
tables   and    and charts for all    maps  in figures    and    
our implementation of m app builds from scratch all the required paths  including the  paths 
however  most  paths can be re used between instances on the same map  only  paths that
contain a target in the current instance might have to be recomputed  this is a small percentage
of all  paths  since the number of targets is typically much smaller than the map size  such
evidence strongly supports taking the  path computations offline into a map pre processing step
to improve m apps running time  hence  we distinguish between the case when m app performs
all computations from scratch  and the case when the alternate paths  i e    paths  are already
available  e g   from previous instances on the map at hand  or as a result of preprocessing   note
  

fim app   s calable m ulti  agent path p lanning

time ratio 
average
min
max

vs far
     
    
     

vs w hca  
    
    
    

vs w hca   d
    
    
    

table    m apps runtime divided by the runtime of far  w hca    and w hca   d  in this table 
we assume that m app performs all computations  including alternate path search  from
scratch 

time ratio 
average
min
max

vs far
    
    
    

vs w hca  
    
    
    

vs w hca   d
    
    
    

table    m apps runtime divided by the runtime of far  w hca    and w hca   d  in this table 
the time to compute alternate paths is omitted  as they could be re used for instances on
the same map 

that with far and w hca    most computation depends on every units start and target locations 
and therefore cannot easily be taken into a map pre processing step  since storing entire search trees
take up too much memory to be practical  
table   shows that  when m app performs all computations from scratch  it is comparable in
speed with w hca    being actually slightly faster on average  however  this version of m app is
about    times slower than far on average  when  paths are already available  m apps speed
improves significantly  as  path computation is the most expensive part of m app  as can be seen
in table    m apps speed ratio vs far reduces to       m app also becomes        times faster
than w hca   with and without diagonals  on average 
figure    shows more detailed runtime data for   out of    maps  even when it does all computation from scratch  m app is faster than w hca   d  i e   with diagonal moves enabled   it is also
often faster  or at least comparable  with w hca   without diagonals  m app with offline preprocessing is reasonably close to far  even though far is consistently faster or at least comparable to
m app  the remaining two maps  which represent the most difficult cases for m app  are presented
in figure     on map     especially  the largest in our data set  which is also significantly larger
than the rest  almost    times larger   m app has significantly higher total time  as shown at the top
right of figure    
a break down of m apps total running time  shown at the bottom of figure    for map     
consistently shows that the search time dominates  furthermore  in node expansions  the  node
expansions are generally several times greater than  node expansions  resulting in the majority of
path computation time being spent searching for  paths 
  

fiwang   b otea

total running times      
   

whca       nod
whca      
mapp total
mapp with preprocessing
far

   
   

   
   
time  s 

   

time  s 

total running times      
   

   
   

  
  
  

   

  

  
 

whca       nod
whca      
mapp total
mapp with preprocessing
far

   

   

 
   

                           
number of agents

   

   

   

   

   
   

   

 
   

                                             
number of agents
total running times      
   

whca       nod
whca      
mapp total
mapp with preprocessing
far

   
   
time  s 

time  s 

   

   

   

whca      
whca       nod
mapp total
mapp with preprocessing
far

   

   

whca      
mapp total
whca       nod
mapp with preprocessing
far

   

total running times      
   

           
number of agents

total running times      
   

time  s 

time  s 

total running times      
   
whca       nod
   
whca      
mapp total
   
    mapp with preprocessing
far
   
   
   
   
   
  
 
                       
number of agents

   

   
   

   
   
   
   

   
 

  
 
                                             
number of agents
total running times      

   

   
   
   
time  s 

time  s 

   
   
   

   
   
number of agents

    

    

mapp total
whca       nod
whca      
mapp with preprocessing
far

   
   
   
   

  
 

   

total running times      
   

whca       nod
whca      
mapp total
mapp with preprocessing
far

   

   

  
   

   

   
        
number of agents

    

 
    

                                             
number of agents

figure     runtime data averaged over fully completed instances by all algorithms  map ids are
displayed in shorthand in brackets  m app with preprocessing stands for the version
that computes no alternate paths 

  

fim app   s calable m ulti  agent path p lanning

total running times      
   

time  s 

   
   

total running times  worst case      
   

whca      
mapp total
whca       nod
mapp with preprocessing
far

mapp total
whca      
whca       nod
    mapp with preprocessing
far
   
   

time  s 

   

  
  

   

  

   

  

  

 
   

   

   
        
number of agents

    

 
    

   

   

   
        
number of agents

    

    

mapp times breakdown      
   

total runtime
total search
omega search
repositioning

   

time  s 

   
   
   
   
  
 
   

   

   
        
number of agents

    

    

figure     top  hard cases for t i ac r c m apps total runtime  bottom  time breakdown  showing that the  path computation takes up the majority of m apps search time 

    conclusion
traditional multi agent path planning methods trade off between optimality  completeness  and scalability  while a centralised method typically preserves optimality and  theoretical  completeness  a
decentralised method can achieve significantly greater scalability and efficiency  on the other hand 
both approaches have shortcomings  the former faces an exponentially growing state space in the
number of units  the latter gives up optimality and offers no guarantees with respect to completeness  running time and solution length  our new approach  aimed at bridging these missing links 
identifies classes of multi agent path planning problems that can be solved in polynomial time  we
also introduced an algorithm  m app  to solve problems in these classes  with low polynomial upper
bounds for time  space and solution length 
we performed a detailed empirical evaluation of m app  the extended m apps completeness
range reaches           even on the most challenging scenarios with      mobile units  the
completeness range is even better in scenarios with fewer units  on our data set  m app has a significantly better percentage of solved units         provably solvable  and        in the attempt all
mode  than far          and w hca           and         with and without diagonal moves  
the attempt all version of m app solves       more instances than the benchmark algorithms 
  

fiwang   b otea

on instances solved by all algorithms  m app is significantly faster than both variants of w hca   
and slower than the very fast far algorithm by a factor of      on average  when all alternate
paths needed in an instance are readily available  when performing all computations from scratch 
m apps speed is comparable to w hca    m apps solutions reported here are on average     longer
than fars solutions and      longer than w hca  s solutions  however  unlike algorithms such
as far and w hca    m app does offer partial completeness guarantees and low polynomial bounds
for runtime  memory and solution length  thus  m app combines strengths from two traditional
approaches  providing formal completeness and upper bound guarantees  as well as being scalable
and efficient in practice 
our findings presented here open up avenues for future research into large scale multi agent
pathfinding  in the long term  m app can be part of an algorithm portfolio  since we can cheaply
detect when it is guaranteed to solve an instance  thus it is worthwhile to investigate other tractable
classes  such as subclasses where far is complete  m app can further be improved to run faster 
compute better solutions  and cover more instances  solution quality can be measured not only as
total travel distance  but also in terms of makespan  i e   total duration when actions can be run in
parallel  and total number of actions  including move and wait actions   so far  we have worked on
relaxing two of the original s lidable conditions  target isolation and alternate connectivity  future
work could address the initial blank condition  moreover  some of the initially non s lidable units
in the problem could become s lidable later on  as other s lidable units are getting solved 
extending m app to instances where units are heterogeneous in size and speed is another promising
direction 

acknowledgments
nicta is funded by the australian governments department of communications  information
technology  and the arts and the australian research council through backing australias ability
and the ict research centre of excellence programs 
many thanks to nathan sturtevant for providing the hog framework  and his help with our
understanding of the program  thanks also to philip kilby  jussi rintanen  and nick hay for their
many helpful comments  we thank the anonymous reviewers for their valuable feedback 

references
barraquand  j   langlois  b     latombe  j  c          numerical potential field techniques for
robot path planning  in international conference on advanced robotics  icar   vol     pp 
         
bulitko  v   sturtevant  n   lu  j     yau  t          graph abstraction in real time heuristic
search  journal of artificial intelligence research  jair             
choset  h   lynch  k   hutchinson  s   kantor  g   burgard  w   kavaraki  l     thrun  s         
principles of robot motion  theory  algorithms  and implementation  the mit press 
erdmann  m     lozano perez  t          on multiple moving objects  in ieee international
conference on robotics and automation  icra   pp           
geramifard  a   chubak  p     bulitko  v          biased cost pathfinding  in artificial intelligence
and interactive digital entertainment conference  aiide   pp         
  

fim app   s calable m ulti  agent path p lanning

hart  p   nilsson  n     raphael  b          a formal basis for the heuristic determination of
minimum cost paths  ieee transactions on systems science and cybernetics           
    
hopcroft  j  e   schwartz  j  t     sharir  m          on the complexity of motion planning for
multiple independent objects  pspace hardness of the warehousemans problem  international journal of robotics research  ijrr              
jansen  r     sturtevant  n          a new approach to cooperative pathfinding  in international
conference on autonomous agents and multiagent systems  aamas   pp           
kant  k     zucker  s  w          toward efficient trajectory planning  the path velocity decomposition  international journal of robotics research  ijrr              
kornhauser  d   miller  g     spirakis  p          coordinating pebble motion on graphs  the diameter of permutation groups  and applications  in proceedings of the   th annual symposium
on foundations of computer science  focs   pp         
latombe  j  c          robot motion planning  kluwer academic publishers 
papadimitriou  c   raghavan  p   sudan  m     tamaki  h          motion planning on a graph  in
  th annual symposium on foundations of computer science  pp         
pottinger  d          coordinated unit movement  http   www gamasutra com view 
feature      coordinated unit movement php 
rabin  s          a  speed optimizations  in deloura  m   ed    game programming gems  pp 
        charles river media 
ratner  d     warmuth  m          finding a shortest solution for the n  n extension of the   puzzle is intractable  in proceedings of aaai national conference on artificial intelligence
 aaai      pp         
ryan  m  r  k          exploiting subgraph structure in multi robot path planning  journal of
artificial intelligence research  jair              
samet  h          an overview of quadtrees  octrees  and related hierarchical data structures 
nato asi series  vol  f   
silver  d          cooperative pathfinding  in artificial intelligence and interactive digital entertainment conference  aiide   pp         
silver  d          cooperative pathfinding  ai programming wisdom           
standley  t          finding optimal solutions to cooperative pathfinding problems  in proceedings of the twenty fourth aaai conference on artificial intelligence  aaai      pp         
stout  b          smart moves  intelligent pathfinding  game developer magazine 
sturtevant  n  r     buro  m          improving collaborative pathfinding using map abstraction  
in artificial intelligence and interactive digital entertainment  aiide   pp       
surynek  p       a   an application of pebble motion on graphs to abstract multi robot path planning  in proceedings of the   st international conference on tools with artificial intelligence
 ictai   pp         
surynek  p       b   a novel approach to path planning for multiple robots in bi connected graphs 
in ieee international conference on robotics and automation  icra   pp           
  

fiwang   b otea

surynek  p       a  personal communication 
surynek  p       b   an optimization variant of multi robot path planning is intractable  in
proceedings of the   th aaai conference on artificial intelligence  aaai      pp      
     
surynek  p       c   multi robot path planning  pp          intech   open access publisher 
tarjan  r  e          edge disjoint spanning trees and depth first search  acta informatica       
       
tozour  p          building a near optimal navigation mesh  in rabin  s   ed    ai game programming wisdom  pp          charles river media 
wang  k  h  c     botea  a          fast and memory efficient multi agent pathfinding  in proceedings of the international conference on automated planning and scheduling  icaps  
pp         
wang  k  h  c     botea  a          tractable multi agent path planning on grid maps  in proceedings of the international joint conference on artificial intelligence  ijcai   pp      
     
wang  k  h  c     botea  a          scalable multi agent pathfinding on grid maps with
tractability and completeness guarantees  in proceedings of the european conference on
artificial intelligence  ecai   pp         
zelinsky  a          a mobile robot navigation exploration algorithm  ieee transactions of
robotics and automation               

  

fi