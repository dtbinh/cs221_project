journal artificial intelligence research               

submitted        published      

app  scalable multi agent path planning algorithm
tractability completeness guarantees
ko hsin cindy wang
adi botea

c indy wang   rsise   anu   edu   au
di  b otea   nicta   com   au

nicta   australian national university 
canberra  australia

abstract
multi agent path planning challenging problem numerous real life applications  running centralized search a  combined state space units complete
cost optimal  scales poorly  state space size exponential number mobile units 
traditional decentralized approaches  far w hca    faster scalable 
based problem decomposition  however  methods incomplete provide guarantees respect running time solution quality  necessarily able tell
reasonable time whether would succeed finding solution given instance 
introduce app  tractable algorithm multi agent path planning undirected graphs 
present basic version several extensions  low polynomial worst case upper
bounds running time  memory requirements  length solutions  even though
algorithmic versions incomplete general case  provides formal guarantees
problems solve  version  discuss algorithms completeness respect
clearly defined subclasses instances 
experiments run realistic game grid maps  app solved        mobile units 
      better percentage far w hca    app marked       
units provably solvable first stage plan computation  parts apps computation
re used across instances map  speed wise  app competitive significantly
faster w hca    depending whether app performs computations scratch 
data app re use preprocessed offline readily available  app slower
fast far algorithm factor      average  apps solutions average    
longer fars solutions      longer w hca  s solutions 

   introduction
path planning important many real life problems  including robotics  military operations  disaster rescue  logistics  commercial games  single agent path planning  size state
space bounded size map  tackled search algorithm a   hart 
nilsson    raphael         however  many units moving simultaneously inside
shared space  problem becomes much harder  centralized search initial state goal
state difficult problem even inside fully known  two dimensional environment represented
weighted graph  one node occupied exactly one unit time  assuming
units size  unit moves synchronously adjacent unoccupied node one
time step  problems state space grows exponentially number mobile units  existing
hardness results shown np complete decide solution k moves exists  ratner   warmuth         optimize solution makespan  surynek      b   version
problem one robot movable obstacles several nodes  either robot
c
    
ai access foundation  rights reserved 

fiwang   b otea

obstacle move adjacent vacant node per step  np complete  papadimitriou 
raghavan  sudan    tamaki         yet another version problem  determining solution exists moving two dimensional rectangles different sizes inside box  shown
pspace hard  even without requiring optimality  hopcroft  schwartz    sharir         despite completeness solution optimality guarantees  centralized a  search little practical
value multi agent path planning problem  intractable even relatively small maps
collections mobile units 
scalability larger problems achieved decentralized approaches  decompose
global search series smaller searches significantly reduce computation  however 
existing decentralized methods far  wang   botea        w hca    silver       
incomplete  provide formal criteria distinguish problem instances
successfully solved instances  further  guarantees given respect running
time quality computed solutions 
work present algorithm combines strengths worlds  working well
practice featuring theoretical tractability partial completeness guarantees  introduce
app  tractable multi agent path planning algorithm undirected graphs  problem instance  app systematically identifies set units  contain units instance 
guaranteed solved within low polynomial time  sake clarity distinguish
basic version extended versions app  app provides formal guarantees
problems solve  basic app algorithm complete class problems  called
lidable  define section    extended versions algorithm enlarge completeness range  discussed section    improve solution length  discussed section   
evaluate version attempts solve units  provably solvable ones 
given problem graph nodes n mobile units  apps worst case performance
running time o m  n     even smaller  e g   o max mn    m  log m     depending
assumptions input instance  worst case memory requirements within o m  n 
even o mn   upper bound solution length  measured total number moves 
order o m  n    even o mn     see section   detailed discussion 
app keeps running costs low eliminating need replanning  path  u 
unit u computed beginning  replanning required runtime  blank travel
idea  inspired way blank moves around sliding tile puzzles  center
u
algorithm  unit u progress current location liu next location li  
path
u
 u  blank located  i e   li   empty   intuitively  next location currently
occupied another unit  app tries bring blank along alternate path  outlined bold
u
u
li  
without passing liu   possible  blank
figure    connects li 
u
brought li   shifting units along alternate path  blank travels sliding tile
puzzle  ability bring blank next location key guarantee units progress  formal
details provided section   
performed detailed experiments  evaluating different versions app comparing
app fast incomplete methods far w hca   grid maps  results
presented section    benchmark data  wang   botea        consist          mobile
units uniformly randomly generated    game maps     scenario instances per number
units map  conclude extended app significantly better success ratio
scalability state of the art incomplete decentralized algorithms  particular  app solves
higher percentage units even crowded instances  despite apps incompleteness
  

fim app   calable ulti  agent path p lanning



b

u

l


u

c

b
c

figure    left  unit u blocked a  blank found location l along alternate
path  marked bold contour  right  sliding b along
u   sake clarity simplicity 
alternate path  blank brought li  
illustrate examples four connected grid world 

general case  algorithm marks        units provably solvable first stage
plan computation  attempting solve units  provably solvable ones  app
succeeds        units  comparison  far solved        units  w hca   solved
        with diagonal moves allowed          with diagonal moves  units  even
challenging instances       mobile units maps            mobile units test
data fall within apps completeness range  i e   provably solvable   terms percentage fully solved instances  version app attempts solve units 
provably solvable  successful       instances  significantly better
far          w hca   diagonal moves          w hca   diagonals          
parts apps computation re used across instances map  instances
solved algorithms  app competitive speed significantly faster w hca    depending whether app performs computations scratch  re usable data
available  app slower fast far algorithm factor      average  apps
solutions reported average     longer fars solutions      longer
w hca  s solutions 
parts work reported shorter conference papers follows  theoretical
description basic app  experiments  provided earlier paper  wang   botea 
       brief overview app extensions brief summary initial results topic
two page paper  wang   botea         new material added current paper includes detailed
algorithmic description enhancements basic app formal proofs algorithms
properties  provide comprehensive empirical analysis enhanced app  several
additional experiments 
rest paper structured follows  next briefly overview related work  then 
state problem definition section    sections    focus basic app  sections  
  cover enhancements basic app algorithm  extending completeness range  section    
  

fiwang   b otea

improving quality plans running time  section     empirical evaluation
topic section    last part contains conclusions future work ideas 

   related work
finding shortest path connects single pair start target points known  finite map
optimally solved a  algorithm  hart et al          extension path planning
multiple simultaneously moving units  distinct start target positions  introduces potential
collisions due physical constraint one location occupied one unit
time  units interact share information units path planning  making
problem complex 
multi agent path planning  centralized a  performs single global search combined
state space l  l  ln n units  li set possible locations unit i 
centralized a  plans paths units simultaneously  finding joint plan containing units
actions  waits well moves   retains optimality completeness guarantees a  
prohibitively large state space o mn   states  n units graph nodes  moreover 
search nodes generated unpromising  taking units farther goal  standley 
       poses strong limiting factor problems centralized a  solve practice 
hand  purely decentralized method  local repair a   l ra     stout        first
plans units path independently a   then  execution  l ra   replans additional
independent a  searches every time collision occurs  good case  l ra   significantly
reduce computations o mn   however  generate cycles units  unable
prevent bottlenecks  problems discussed silver         bulitko  sturtevant  lu 
yau         pottinger         zelinsky         cases  l ra   exhibits significant
increase running time may terminate  therefore  straightforward extensions
single agent a  outlined strong limitations practice 
traditionally  multi agent path planning took centralised decentralised approach  latombe 
      choset et al          centralized approach plans globally  sharing information centrally 
using potential field  barraquand  langlois    latombe         contrast  decentralized approach decomposes problem series smaller subproblems  typically first computing units paths individually  ignoring units  handling interactions online 
examples robotics include computing velocity profiles avoid collisions units  kant
  zucker         pre assigning priorities process robots one one  erdmann   lozanoperez         recent algorithms use combination two approaches  instance 
biased cost pathfinding  bcp  technique  geramifard  chubak    bulitko        generalised
notion centralized planning central decision maker resolves collision points paths
pre computed independently per unit  replanning colliding units around highestpriority unit  avoid excessively long  or even potentially unbounded  conflict resolutions  limit
planning time set  bcp returns paths fewest collisions within time  algorithm
shown work well small scale gridworld scenarios  complete optimal
general case  standleys        algorithm  hand  improved standard centralized
search whilst preserving optimality completeness  new state space representation incorporates next move assignments every unit state  decomposes timestep
advancing units advancing units one one fixed ordering  thus branching factor
reduced  n    increasing depth search factor n  technique gen  

fim app   calable ulti  agent path p lanning

erates  nt state nodes perfect heuristic  t number timesteps
optimal solution   practice  operator decomposition technique  od  still often intractable 
producing lower exponential search space standard joint search space  recognising
much cheaper perform several independent searches one global search  standley
decoupled planning non interfering subgroups units independence detection  id  
group solved centrally optimality overall solution still guaranteed 
fully developed hybrid algorithm  od id  uses operator decomposition improve centralized planning non independent subproblems  nonetheless  optimality requirement costly
practice  planning time still dominated largest subgroup units  number
units increases  less likely independent paths unavoidably overlap 
subgroups expected increase size too  standleys        experiments showed incomplete algorithm hca   silver        actually solved instances  furthermore 
relatively small problems compared experiments  wang   botea              
least   orders magnitude fewer agents  between     units   much smaller maps     
orders magnitude fewer tiles  approximately     tiles  
therefore  methods tackling larger problems take decentralized approach  usually suboptimal nature  general  giving optimality reduces computation significantly  decentralized path planning often much faster  scales much larger problems  yields
suboptimal solutions provides completeness guarantees  recent work grid maps include
w hca    silver         uses   dimensional temporal spatial reservation table performs
series windowed forward searches unit  based true distance heuristic obtained
initial backward a  search target  far algorithm  wang   botea        
units follow flow annotation map planning moving  repairing plans locally using
heuristic procedures break deadlocks  flow related ideas include jansen sturtevants
       direction map sharing information units directions travel  later units
follow movement earlier ones  improved coherence leading reduced collisions 
methods scale instances number units well beyond capabilities
centralized search  however  mentioned earlier  methods known formal characterizations running time  memory requirements  quality solutions worst
case  lack ability answer reasonable bounded time whether given problem would
successfully solved  always important case incomplete algorithms 
practice  traditional approaches multi agent pathfinding serious drawbacks 
inherent trade off scalability  optimality completeness  recently  body work
begun bridge gap two  addressing completeness tractability issues
hand hand  bounded suboptimal approach  ryan        introduced complete method
combines multi agent path planning hierarchical planning search graphs specific substructures stacks  halls  cliques rings  example  stack narrow corridor
one entrance  placed one end stack  many maps  including game maps
used experiments  seem allow efficient decomposition stacks  halls  cliques
rings  b ibox  surynek      b  solves problems least   unoccupied vertices biconnected graph  worst case  number steps cubic number nodes  b ibox
later extended work   unoccupied vertex necessary  surynek      a  
densely populated problems algorithm designed for  surynek      a  expressed
b ibox target computer game scenarios  normally lot fewer units
locations map  b ibox suited multi robot scenarios automatic packages
  

fiwang   b otea

inside warehouse  surynek      c   bibox   surynek      a   requires   unoccupied
node  shown run significantly faster significantly shorter solutions kornhauser 
miller  spirakiss        algorithm related pebble coordination game  performed
quick evaluation b ibox using code obtained author  found that  graphs
order magnitude smaller game maps  b ibox exhibits fast growing runtime  e g  
   minutes graph      locations  long solutions  millions moves 
part explanation b ibox builds instances crowded  understanding 
b ibox designed solve crowded instances  necessarily efficiently solve instances
significantly fewer units locations 

   problem statement
instance characterized graph representation map  non empty collection
mobile units u   units homogeneous speed size  unit u u associated starttarget pair  su   tu    units distinct starting target positions  objective navigate
units start positions targets avoiding fixed mobile obstacles  state
contains positions units given time  work assumes undirected weighted graphs
unit occupies exactly one node time  move unoccupied neighbour
node  time discretized one units move synchronously time step 
travelling along edge depend interfere rest problem  except
two nodes connected edge 
several methods exist abstract problem map search graph  including navigation
meshes  tozour         visibility points  rabin         quadtrees  samet         however 
graph abstraction generates nodes  visibility graph  may render multi agent
pathfinding problem unsolvable  even though works single agent case  hand 
search graph obtained imposing regular grid contains nodes  covering locations
traversable space  offers path options avoid collisions units  hence 
grid maps  besides popular easy implement  suitable multi agent
problems  clarity practicality  focus grid maps examples experiments 
nonetheless  conditions algorithmic definitions app  introduce next
sections  specific regular grid maps  illustrated examples  assume
straight moves four cardinal directions performed    connected grid   restricting
movements   directions  cardinal   diagonals    cardinal directions negative impact
completeness  since standard practice allow diagonal move equivalent  but
longer  two move path exists  every solution allows diagonal moves  solution
cardinal moves  therefore  problem diagonal moves reduced problem
straight moves  price possibly taking longer paths  introducing diagonal moves could
reduce path length  potential drawback blocking units often straight
moves crowded maps  whether enough clearance make diagonal move depends
two adjacent nodes  i e   two tiles sharing common corner grid   since
physically impossible squeeze two units 

   lidable class instances
introduce subclass instances basic app shown complete 

  

fim app   calable ulti  agent path p lanning


i  

u

 u 
i  

u lu  denoted  
figure    example alternate path    connecting locations li 
i  
    picture  belong precomputed path  u  unit u 

definition    s lidable unit lidable instance   mobile unit u lidable iff path
u
u
 u     l u   l u           l  u  
  nodes exists  l u   su   l  u  
  tu   following
conditions met 
u   lu   lu  u   except
   alternate connectivity  three consecutive locations li 
i  
last triple ending tu   i e          u      alternate path ui exists
u lu go lu   see figure   example 
li 
i  


   initial blank  initial state  l u blank  i e  unoccupied  
   target isolation  target interferes  paths units  formally 
following hold tu  
 a   v u    u     tu
   v  
 b   v u                v         tu
  vi  
instance belongs class lidable iff units u u lidable 
three conditions verified polynomial time  verification includes attempting
compute paths unit  since state space a  explore linear
m  a  search time polynomial m  checks blank location first step 
passing targets  trivial  process checks lidable conditions
serves important additional purpose  time checks succeed instance known
belong lidable  completed search needed solve instance 
remaining part algorithm simply tell units wait  move forward 
move backwards along already computed paths 
notice three conditions restricted grid maps only  work standard
assumption one graph node occupied one unit time  moving along
edge neither depends interferes parts graph except two nodes ends
edge 
  

fiwang   b otea

algorithm   overview app 
   u u
  
compute  u   as needed  su tu
  
lidable conditions hold
  
mark u lidable
   initialize set lidable units  optional  make units active  discussed text 
     
  
progression step
  
repositioning step needed

   basic app
present basic version app algorithm  complete lidable class
problems  main feature basic app  and extensions presented sections     
deadlock free cycle free  due total ordering active units  units lower priority
interfere ability higher priority units advance 
illustrated algorithm    problem instance  app starts computing path  u 
unit u target  goal   constructing caching alternate paths along way  note
paths alternate paths need satisfy conditions definition    loop
lines    succeeds units  app tell instance hand belongs lidable 
app complete 
subset units marked lidable  app guaranteed solve them 
equivalent solving smaller instance lidable  optionally  app attempt
solve remaining units well  adding set active units giving lower
priority lidable units  important stress that  remaining part paper 
implicit assumption app attempts solve provably solvable units  unless
explicitly state opposite  experiments section  however  discuss options 
set lidable units partitioned subset solved units already reached
targets  subset active units  initially  units active  lidable class 
becoming solved  units interfere rest problem  as ensured target
isolation condition   shown later  basic app solved units never become active again 
considered remaining part solving process 
definition    advancing condition active unit u satisfied iff current position  pos u  
belongs path  u  next location path blank 
definition    state well positioned iff active units advancing condition satisfied 
lines    algorithm   describe series two step iterations  progression step advances
active units towards targets  shown later  progression step brings least one active
unit target  shrinking active set ensuring algorithm terminates  reaching
state units solved  progression could result breaking advancing condition
one active units  remain  objective repositioning step ensure
active unit advancing condition satisfied starting next progression step  note
repositioning step necessary every progression step except last 
  

fim app   calable ulti  agent path p lanning


b

b





b

b





b


b



b
ii

b
iii

b
iv

v

figure    example app works 

    example
simple example app works illustrated figure    two units  b 
app uses total ordering active units progression step  section       here 
higher priority b  targets b drawn stars  figure    i   b progress
towards targets  becomes blocked b   ii   blank brought front sliding
b ai  outlined bold   side effect  b pushed path  end current
progression step  iii   reaches target  repositioning step  iv   since already solved 
moves ignored  repositioning undoes bs moves b back path blank
front it  bs advancing condition restored therefore global state example
well positioned  next progression step  v   b reaches target  algorithm terminates 
    path computation
problem instance  compute path  u  individually  paths  u  fixed
throughout solving process  ensure paths satisfy alternate connectivity condition
 definition     modify standard a  algorithm follows  expanding node x   
neighbour x   added open list alternate path x   x  parent
x    process compute path  u  family alternate paths simultaneously 
give neighbour x   node x  chance added open list  node x  might
expanded three times  per possible parent x  therefore  o m  node expansions
required a  search find path  number locations map 
equivalently  computing path could seen standard a  search extended space
pairs neighbouring nodes  at four nodes created extended space original
node  
since alternate paths depend triple locations  unit  re use information planning paths units problem  means alternate path
set three adjacent tiles map computed per problem instance 
cached later use  given location l grid map  eight locations could
path two moves away four connect grid  shown figure  a  eight locations
form diamond shape around l  four locations straight line l
  

fiwang   b otea

 
 

 
 

l

 
 

 
 

 

 



 

l

ii

 

 

 

 

 



b

figure     a  eight locations two moves away l   b  two two move paths l location
  go ii 

 locations              precompute alternate path avoids in between location
targets  four locations  labeled              need compute  at most  two
alternate paths  example  two possible paths l   two moves long 
ii  figure  b   need one alternate path avoid intermediate location 
ii  summary  precompute    paths l  locations map 
need   m
     m alternate paths  only one computation triple  since alternate
path connects two endpoints ways  
possible optimization reuse alternate paths across lidable instances map 
alternate paths overlap targets new instance need re computed  discuss
option experiments section 
    progression
algorithm   shows progression step pseudocode  iteration outer loop  active
units attempt progress one move towards targets  processed order  line    
unit v processed unit w  say v higher priority write v   w  ordering
fixed inside progression step  may change one progression step another  actual
ordering affects neither correctness completeness method  may impact
speed solution length  ordering units chosen heuristically  e g  giving higher
priority units closer target  thus  units could get target quickly 
solved way remaining units problem 
ensure lower priority units harm ability higher priority units progress 
introduce notion private zone  see algorithm   unit cannot cause
moves occupy private zone higher priority unit   given unit u  let pos u 
u
current position  let int  u      l u           l  u   
  interior precomputed path
 u   shown algorithm    unit u might get pushed precomputed path  case
pos u 
   u  
u   lu   pos u    lu int  u   
definition    private zone   u   unit u  u     li 


otherwise   u     pos u    words  private zone includes current location

   move caused unit u either move u along  u  path  move different unit w 
pushed around u side effect blank travel 

  

fim app   calable ulti  agent path p lanning

algorithm   progression step 
   changes occur
  
u order
  
pos u 
   u 
  
nothing  u pushed track result blank travel 
u current progression step
  
else u already visited li  
  
nothing
u   belongs private zone higher priority unit  i e 
  
else next location  li  
u
v   u   li    v 
u released v 
  
nothing  wait li  
u blank
  
else li  
u
   
move u li  
u
   
else bring blank li  
u
   
bring blank li  
u
   
move u li  
   
else
   
nothing

unit  addition  unit pre computed path start position  location
behind unit belongs private zone well 
lines     algorithm   show processing u  active unit hand  u pushed
precomputed path  action taken  lines      lines     cover situation
unit u pushed around  via blank travel  higher priority units back location  u 
already visited current progression step  case  u doesnt attempt travel
previously traversed portion path  ensuring bounds total travelled distance
u
introduced later hold  u path next location li  
currently blocked higheru available  u
priority unit v  action taken  lines      otherwise  next location li  
u
moves  lines       finally  li   occupied smaller priority unit  attempt made
u
first bring blank li  
u move  lines        u moves new
u
u target location u 
location li    lines         test performed check li  
case  u marked solved removing adding s  set solved
units 
u
bringing blank li  
 lines        illustrated figure    discuss
process detail  location l ui sought following properties      l blank 
u  inclusive  along u belongs private zone higher    none locations l li  

u
priority unit      l closest  along ui   li  
property  location l
u
found  test line    succeeds  actual travel blank l li  
along ui
 line     identical movement tiles sliding tile puzzle  figure   shows example
u
blank traveling  intuition behind seeking blank along ui that  often  li 
u lu test line   
remains blank time interval u advances li 

performed  guaranteed always hold case active unit highest priority 
call master unit 
let us introduce characterize behaviour master unit formally  beginning progression step  one master unit u selected  unit highest priority among
  

fiwang   b otea

units active beginning progression step  status master unit
preserved entire progression step  even u becomes solved  beginning
next progression step  new master unit selected among remaining active units 
lemma    master unit u always bring blank front  needs one 
u   belongs private zone   u   unit
proof  since us previous location  li 
u  
move private zone highest priority unit  u guaranteed always find blank li 
u lu belong private zone higher priority
moreover  location along ui li 
i  
unit since units higher priority  note ui free physical obstacles
u lu  
construction  must possible blank travel li 
i  

lemma    master unit u never pushed  path 
proof  u pushed  u  blank travelling performed another unit  contradicts u
highest priority unit 
theorem    long master unit u solved  guaranteed advance along  u 
iteration outer  while  loop algorithm    end current progression
step  least u reached target 
proof  using previous two lemmas  easy check u never enters nothing line
algorithm    similar lemma    u never pushed cannot revisit previous location  also 
since u highest priority  next location cannot held private zone another unit 
hence  us progress target guaranteed 
following result useful ensure progression step always terminates  either
state units solved state remaining active units stuck 
theorem    algorithm   generates cycles  i e   repetitions global state  
proof  show proof contradiction  assume cycles  consider cycle
active unit u cycle highest priority  since unit cycle dominates u 
means movements u cannot part blank travel triggered higher priority unit 
therefore  movements u result either line    line     is  us moves
along path  u   since  u  contains cycles  u cannot run cycle 
    repositioning
end progression step  remaining active units  if left 
advancing condition broken  recall happens unit u either pos u 
   u  u
placed precomputed path next location path blank  repositioning
step ensures well positioned state reached  i e   active units advancing condition
satisfied  starting next progression step 
simple computationally efficient method perform repositioning undo block
recent moves performed preceding progression step  undoing move means carrying
reverse move  solved units affected  remaining active units  undo
moves  reverse global order  well positioned state encountered  call strategy
reverse repositioning  example provided section     
  

fim app   calable ulti  agent path p lanning

proposition    reverse repositioning strategy used line   algorithm    when needed  
progression steps start well positioned state 
proof  lemma proven induction iteration number j algorithm    since
initial state well positioned  this follows easily definitions       proof j    
trivial  assume repositioning step performed starting iteration j     
worst case  reverse repositioning undoes moves remaining active units  but
moves units become solved   back original positions beginning j th
progression step  words  reach state similar state s  beginning
previous progression step  except units targets s  since s  well
positioned  according induction step   follows easily well positioned too 

   worst case best case analysis
give bounds runtime  memory usage  solution length app algorithm
problem lidable n units map traversable tiles  examine worst case
scenario case  discuss best case scenario end 
introduce additional parameter    measure maximal length alternate paths  
worst case  grows linearly m  however  many practical situations  small constant 
since ends path close other  analysis discusses scenarios 
theorem     algorithm   worst case running time o max n  m  m  log m  
constant  o n  m    grows linearly m 
proof  outlined section      single agent a  search consistent heuristic   expands
o m  nodes  hence  assuming open list implemented priority queue  a  search
takes o m log m  time  note that  graphs edges cost  log factor
could principle eliminated using breadth first search find optimal path  grid maps
cardinal moves fit category  however  simplicity  assume log
factor present 
hence  worst case  searches  paths take o nm log m  time n units 
a  searches take o m  log m  time 
single progression step  outlined algorithm    suppose blank travel required n
units  every move along way except first last moves  since length paths
bounded length alternate paths bounded   total number moves
progression step o nm   running time algorithm   
clearly  complexity repositioning step cannot exceed complexity previous
progression step  hence complexity iteration algorithm    lines     o nm  
number iterations n  since size reduces least one iteration 
app takes o max nm log m  m  log m  n  m   time run  o max n  m  m  log m  
constant o n  m    grows linearly m 
theorem     maximum memory required execute app o nm  constant 
o nm    grows linearly m 
   well known manhattan heuristic  used implementation  consistent  proof
easy  direct result    definition consistency    way manhattan distance computed  by
pretending obstacles map  

  

fiwang   b otea

proof  caching possible paths entire problem described section     takes o m 
memory  a  searches paths performed one time  search  stored
cache  memory used open closed lists released  a  working memory
takes o m  space  storing paths takes o nm  space  overall  path computation
across units requires o nm   m  space 
then  lines    algorithm    memory required store stack moves performed
one progression step  used repositioning  shown proof theorem    
number moves progression step within o nm   so  overall maximum memory
required execute program o nm   o nm  constant o nm   
grows linearly m 
theorem     total distance travelled units o n  m  constant 
o n  m    grows linearly m 
proof  shown previously  number moves progression step within o nm  
number moves repositioning step strictly smaller number moves previous
progression step  n progression steps  followed repositioning steps   hence 
total travelled distance within o n  m  
corollary     storing global solution takes o n  m  memory constant  o n  m   
grows linearly m 
discuss best case scenario  app computes optimal solutions number moves
paths optimal units reach targets without blank traveling  i e   units
travel along paths    obvious example paths disjoint  case 
solutions makespan optimal too  well preserving optimality best case  search
effort app smaller spent centralised a  search  n single agent
m 
o m  searches  compared searching combined state space n units   mn  
states 

   extending completeness range
extend apps completeness beyond class lidable  evaluated impact
three lidable conditions preliminary experiment  ran basic app data
set used main experiments  the data set main experiments described
section     preliminary experiment  switched one lidable condition time
counted many units satisfy remaining two conditions  larger increase number
solvable units suggests relaxing definition condition hand could provide
significant increase completeness range 
initial experimental evaluation indicates basic app three lidable conditions solves        units  basic case   alternate connectivity requirement switched off 
       units satisfy remaining two conditions  switching target isolation makes       
units satisfy remaining two conditions  however  ignoring blank availability condition
small impact  increasing percentage slightly         basic case        
results suggest alternate connectivity target isolation conditions restrictive blank availability condition  thus  focus relaxing two conditions 
  

fim app   calable ulti  agent path p lanning

target isolation  extension allows unit plan path targets 
still guarantee clearly identified set units reach targets  topic
section      extend alternate connectivity  developed technique allows paths
planned regions alternate paths  tunnels  blank travelling operation
tunnel crossing unit uses blank positions ahead unit  along remaining
pre computed path  describe detail section      empirical analysis
features provided section   
    relaxing target isolation condition
several targets close other  target isolation condition  forbidding paths
pass targets  make targets behave virtual wall  disconnecting two areas
map  result  basic app report many units non s lidable 
extension introduce allows unit u plan path target another unit v 
subsequently v never assigned higher priority u  specifically  partial ordering
defined  u v iff target v belongs  path u
path along us
u  
ui    every
 path  written formally  u v iff tv  u    u      u  ki  
time mention refer transitive closure  show section that  paths
planned way  possibly empty  relation creates cycles type u u 
instance solved slight modification basic app 
units plan paths foreign target choice 
achieve strategy  a  searches assign high cost graph search edges adjacent
foreign target  desirable outcome reducing interactions caused target
isolation relaxation  particular  way original lidable units compute paths
preserved  foreign targets crossed cases  words  instances lidable
characterized empty relation 
definition     instance belongs class i s lidable iff every unit u exists path  u 
satisfying alternate connectivity initial blank condition definition lidable
 definition     furthermore  cycles allowed relation 
assume moment  possibly empty  relation without cycles available  aspects
related obtaining one discussed later section 
definition     solving i s lidable instances  extended algorithm  app  two
small modifications original algorithm 
   total ordering   inside progression step stays consistent   u v u   v 
   u v  v cannot marked solved  i e  moved s  unless u already
marked solved 
extra conditions hand  ensure even unit x arrives target tx
units clear tx  paths  units get past x performing normal blank
travel  following that  x undo moves back tx repositioning step  basic app 
prove app terminates  first prove following two lemmas hold highest
priority unit  u  progression step 
  

fiwang   b otea

lemma     unit visit target u  tu   current progression step 
proof  since u master unit  follows u   v active unit v  according
point   definition     follows u v  relation cycles  means v u 
therefore  applying definition   follows tu
   v   completes proof 
app movements performed along paths 
since repositioning step undo moves made previous progression step  units
revisit locations visited progression step  so  following direct result
lemma    
corollary     unit visit tu repositioning step follows 
corollary     u solved  cannot interfere rest problem 
theorem     app terminates 
proof  showing least highest priority unit u reaches target given progression step
virtually identical proof lemma    corollary    guarantees that  solving u 
interfere rest problem  hence  number active units strictly decreases
progression step  algorithm eventually terminates 
let us get back question provide cycle free relation  testing whether
units plan paths way cycle introduced might end expensive 
unit u cant possibly avoid targets  might choose crossing
target v crossing target w  one option might lead cycle whereas might
avoid cycles  therefore  systematic search might required seek cycle free relation  
rather searching systematically  app takes cheaper  greedy approach 
cycles  mark number units i s lidable  selected way
units remain cycle free  we call i s lidable units   i s lidable units
guaranteed solved 
result greedy approach  app complete class i s lidable  still 
complete superset lidable able identify many units  often all 
provably solved 
finally  wrap discussion extension concluding upper bounds
app  given section    still apply app  proof identical make
worst case assumptions before  master unit gets solved progression step 
every move along units path requires blank travel  moreover  note additional step
path pre computation topologically sorting partial order    linear priority order   
done cheaply time linear number units  tarjan        
    relaxing alternate connectivity condition
show section    previous extension target isolation significantly improves
apps success ratio  i e   percentage solvable units   yet  significant room
improvement  particular  maps single width tunnels still showed bottleneck terms
success ratio  tunnels make alternate connectivity condition connecting two ends
consecutive triple locations without going middle harder even impossible
  

fim app   calable ulti  agent path p lanning

satisfy  single width tunnel bridges two otherwise disjoint regions  shown figure   
versions app presented far fail find path two regions  alternate
connectivity broken triples inside tunnel 

figure    example units targets side  way
cross single width bridge  units drawn circles  corresponding targets
squares shade 

section introduce buffer zone extension  solution relaxing alternate
connectivity condition  allows many paths  corresponding many units  cross singlewidth tunnel  intuition simple  often  plenty blank positions ahead unit  along
remaining locations precomputed  path corresponding paths along it 
tunnel crossing operation essentially generalisation blank travelling  blank position
sought path ahead  instead alternate path current location triple 
definition     precomputed path  u  crosses tunnels  define following 
buffer zone    u    portion  u  target end
last tunnel  at thesj th move  u    together corresponding alternate paths 
  u    
 liu   ui  
i j       ku   

dynamic counter    u    keeps track many positions buffer zone blank 
counter initialized beginning appropriate value  incremented
decremented necessary later on 
threshold   u   set length t       longest tunnel crossed
unit u  threshold acts minimal value   u   guarantees u cross
tunnels safely 

  

fiwang   b otea

unit u attempts cross tunnel  push units lower priorities closest blank
locations buffer zone  u exits tunnel  tunnel crossing operation
possible  enough blanks available buffer zone  analyse new extended
algorithm detail  introduce extended class ac lidable  whose definition includes
units meeting new buffer zone extension 
definition     relaxing alternate connectivity condition  allow  u  go one
single width tunnels iff enough blanks us buffer zone  least   u   blank
locations   u   initial state  i e     u     u    before  alternate paths still
needed locations outside tunnels 
definition     unit u u belongs extended class  call ac lidable  iff
path  u  meeting initial blank target isolation conditions given definition
lidable  definition     relaxed alternate connectivity condition  definition    above  
ac app modified basic app following two ways integrate buffer
zone technique relaxing alternate connectivity condition  firstly  repositioning step cannot
finish counter    value threshold     words  need ensure
enough blanks available buffer zone progression step begins  following
new advancing condition  updated definition   adding extra  aforementioned condition 
definition     advancing condition active  tunnel crossing unit u satisfied iff current
position belongs path  u  next location path blank  as given definition    
  u     u   
secondly  need preserve one basic apps main features  units lower priority
never block units higher priority  ensuring app run cycles deadlocks 
hence  unit u lower priority v cannot cause moves bring   v  
threshold  i e     v     v       recall move caused u either move
u along  u  path  checked lines     algorithm     move different unit
w  pushed around u side effect blank travel  checked lines     
algorithm     thus buffer zone u acts generalised private zone  u holds least
  u   locations accessible units lower priorities 
extensions ac app maintain following properties basic app 
lemma     long master unit u solved  guaranteed advance along  u 
iteration outer  while  loop algorithm    end current progression
step  least u reached target 
proof  result follows directly proof lemma    parts new
algorithm   compared algorithm    the progression step basic app  check
lines     modified blank travelling operation  lines         since u highest priority
current progression step  cause moves affecting buffer zone every unit 
unit move buffer zone u would bring number blanks
threshold  i e    u       u    hence u guaranteed enough blanks cross
tunnel  u  
proof lemma    similar lemma   section     
  

fim app   calable ulti  agent path p lanning

u  
algorithm   ac app canbringblank  unit u  location li  
   u outside tunnels
  
look nearest blank b along ui
   else u inside tunnel
  
look nearest blank b   u  
   b found
  
return false
u    segment along u   u   above 
   location l  b          li  

  
v   u   l  v   check causing another unit move private zone
higher priority unit  v 
  
return false
   
else v   u   l   v       v     v    check causing another unit
move buffer zone higher priority unit  v 
   
return false
    return true

algorithm   ac app progression step 
   changes occur
  
u order
  
pos u 
   u 
  
nothing
u
  
else v   u   li  
 v 
  
nothing
u
  
else v   u   li  
  v       v     v    check moving
buffer zone higher priority unit 
  
nothing  wait v blanks buffer zone 
u current progression step
  
else u already visited li  
   
nothing
u blank
   
else li  
u
   
move u li  
u    algorithm   
   
else canbringblank  u  li  
u
   
bring blank li  
u
   
move u li  
   
else
   
nothing

lemma     algorithm   generates cycles  i e   repetitions global state  
theorem     ac app terminates 
proof  follows lemmas       number active units strictly decreases
successive iterations algorithm    hence  algorithm ac app eventually terminates 
since shown algorithm ac app guaranteed solve class ac lid completeness result shown follows directly 

able  

  

fiwang   b otea

corollary     ac app complete class ac lidable 
ac app extension preserves upper bounds running time  memory usage  solution length given section    here  introduce max denote maximal length tunnels
units cross  worst case analysis  units initiate blank travelling every move along
way  involves tunnels  so  depending whether max   maximal length
paths  longer  ac app runs o n  mmax   o n  m  time  since parameters
often constant practice  grow worst linear m  running time o n  m  o n  m    
before  bounds total travel distance global solution follow directly  lastly 
virtually additional memory required storing buffer zones  except one counter one
threshold variable  per unit 
    combining target isolation alternate connectivity relaxations
show two extensions lidable class combined 
definition     instance belongs extended class  i ac lidable  iff every unit u
exists path  u  meeting initial blank condition given definition    relaxed
alternate connectivity condition definition     furthermore   possibly empty  relation
introduced result target isolation relaxation cycle free  definition    
obtain extended algorithm  i ac app  combining app  definition    
ac app  algorithms      
theorem     i ac app terminates 
proof  proof lemma     show least highest priority unit u reaches
target progression step  follows  definition     u guaranteed enough blanks
clear single width tunnels along path  definitions       guarantee that 
outside tunnels  u always bring blank needed  stated lemma    furthermore 
progression step generates cycles  proved cases lemmas      
know solved unit u interfere rest problem 
results lemmas        corollary     note tricky cases units
targets inside single width tunnels excluded extended class i ac lidable 
zero buffer capacity according defined definition    
since iteration algorithm solves least one unit  i ac app terminates 

   improving solution length
mentioned before  avoid replanning  units pushed off track blank travelling units
undo moves get back  paths immediate repositioning step 
observed that  practice  reverse repositioning strategy  defined section      introduce
many unnecessary moves  increase solution length  increase running time  may
hurt visual quality solutions 
recall that  standard reverse repositioning step  new moves added solution
built  moves undo  reverse order  moves active units  i e   solved
yet  made previous progression step  process continues well positioned state
  

fim app   calable ulti  agent path p lanning

u

 v 

u

 v 

v

v

 u 

 u 

figure    two examples global checking well positioned state 

reached  means active units advancing condition satisfied  i e   every
active unit  path blank front  
undo move  well positioned check performed globally  words  basic
app checks advancing condition active units  unit affected
recent undo move  global checking guarantees eventually reach well positioned state 
proved proposition    but  mentioned earlier  often create many unnecessary moves 
provide two simple examples figure    illustrate one case global checking
useful  one case global checking strong condition  adding unnecessary moves 
first  consider two units  u v  undoing one move global moves stack places u
back path  blank front  assume us current position way vs
future undo moves  shown left figure    therefore  even us advancing condition
satisfied  u needs additional undo moves  make room undo moves units  v 
order reach globally well positioned state  case  global checking useful  second
example  imagine u vs moves recent progression step independent
other  possibly even two map areas far away other  simple case shown
right figure    recent progression  vs last move  when v derailed  followed
sequence us moves  final move u pushed track  whereas preceding
moves along us  path   u   reverse repositioning would undo moves reverse global
order  means undoing us moves undoing vs last move  however  one undo
move u one undo move v sufficient restore units well positioned state 
illustrated  global checking advancing condition could strong  whereas
local checking could insufficient  solution introduce section 
called repositioning counting  finds middle ground two extremes  improves
number moves still maintains guarantee reaching well positioned state  intuitively 
undo moves unit u stop soon  a  us advancing condition satisfied   b 
current position cannot possibly interfere future undo moves units   c  unit
performing repositioning possibly stop blank position front u us  path 
  

fiwang   b otea

 d  u doesnt stop initial second location another active unit v  initial second
location unit v position ahead v beginning recent progression step 
fourth condition ensures units blank front end  worst case
revert back initial position beginning recent progression step  
definition     location l path  keep counter  c l   that 
beginning progression step  counter c l  reset    l empty    
l occupied 
every time l visited progression step  c l  incremented 
every time unit leaves l result undo move repositioning step  c l 
decremented 
following directly definition c l  given above  formulate following two
results c l  repositioning time 
lemma     c l       unit pass l remaining part current
repositioning step 
lemma     given active unit u  current position pos u   c pos u       
progression moves location pos u  already undone  words 
unit remainder repositioning step pass pos u  
introduce new enhancement app  aimed eliminating many useless undo
moves repositioning steps 
definition     enhanced algorithm  r c app  uses repositioning counting strategy
line   algorithm    means active unit u stops undoing moves current
repositioning step  soon meets following conditions 
 a  advancing condition u satisfied according definition    plus extension definition    
 b  us current location  pos u   c pos u      
u   c lu      
 c  location front u  li  
i  

 d  current location initial second location another active unit 
theorem     repositioning steps r c app end well positioned state 
   condition d  ignored without invalidating algorithms ability make progress towards goal state  even
units could possibly end state without blank front  guaranteed least one unit  i e  
one finishes repositioning first  blank front  guarantees least one unit
solved next progression step 

  

fim app   calable ulti  agent path p lanning

proof  recall moves made progression step kept totally ordered list 
prove directly repositioning counting  undoing subset moves  reaches wellpositioned state  since counter c l  incremented decremented according definition    
unit u satisfying three conditions definition    restored advancing condition 
furthermore  combined results lemmas       guarantee units later
get us way  u way units repositioning moves 

theorem     applying r c repositioning steps extended algorithm i ac app
negative impact completeness 

   experimental results
section present empirical evaluation app algorithm  first point
impact newly added feature  put i ac r c enhanced app test
comparison existing state of the art decoupled  incomplete methods  specifically 
benchmarks far  wang   botea         extended version silvers        w hca  
algorithm sturtevant buro         called w hca   w a   applies abstraction
expensive initial backward a  searches  app  algorithms tested rather
large problems  terms map size number units  aware programs
scale well far w hca    strengths two methods potential ability
find solution quickly  weakness cannot tell whether would able
solve given instance 
implemented app scratch integrated hierarchical open graph   hog 
framework  source code extended w hca   algorithm  w hca   w  a   sturtevant  
buro         extra features spatial abstraction diagonal moves  but without priority
system unit replanning   obtained nathan sturtevant  far algorithm
implementation used previous experiments  wang   botea        
experiments run data set randomly generated instances used previously published work  wang   botea         input grid maps     largest game baldurs gate    range             traversable tiles size  listed table   
game maps quite challenging  containing different configurations obstacles forming different
shapes rooms  corridors  narrow tunnels  test map          mobile units
increments         minute timeout per instance set  w hca   w  a  experiments 
set window size  w     use first level abstraction  a       seems
good parameter setting work sturtevant buro         experiments comparing
w hca         show w hca        work better data set  abstraction allows w hca  
build heuristic graph smaller actual graph movement takes
place  far  units make reservations k     steps ahead  recommended setting 
experiments run     ghz intel core   duo imac  gb ram 
  

fiwang   b otea

basic mapp

number slidable

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number agents

    

ti mapp
   
   
   
   
   
   
   
   
   
   

    
    
   
 

ac mapp
    

 

number ac slidable

number ti slidable

    

   
    
    
total number agents

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number agents

    

ti   ac mapp
number ti ac slidable

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number agents

    

figure    mapps widened completeness range relaxation  graph line represents
number units solved problem instances map  here  provably solvable
units counted 

  

fim app   calable ulti  agent path p lanning

far

number agents solved

    

   
   
   
   
   
   
   
   
   
   

    

    

   

 

 

   
    
    
total number agents

    

whca  diagonals

number agents solved

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number agents

    

whca  diagonals

number agents solved

    

   
   
   
   
   
   
   
   
   
   

    
    
   
 
 

   
    
    
total number agents

    

figure    success ratios  averaged    trials  far  w hca         without
diagonals  set problem instances  timeout set    minutes per
instance   incomplete algorithms 
  

fiwang   b otea

map id
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr
ar    sr

short id
   
   
   
   
   
   
   
   
   
   

  nodes
     
     
     
     
     
     
     
     
     
     

table       maps descending order  terms number nodes 

    scalability percentage solved units
compare far  w hca        four versions app  basic app original lid able definitions  app   version target isolation relaxation switched on  ac
app  based relaxing alternate connectivity condition   ac app  relaxing
target isolation condition  alternate connectivity condition  measure success ratio 
defined percentage solved units  note repositioning counting  r c 
considered section  since impact success ratio  designed
improve solution length 
app versions used section attempt solve units provably solvable
 i e   units marked lidable  lidable  ac lidable  i ac lidable respectively  
reason want evaluate many units fall subclasses practice 
next section show data obtained version app attempts solve units 
figure   summarizes success ratio data version app algorithm
maps  closer curve top diagonal line  being total number units   better
success ratio map  basic app exhibits mixed behaviour  greater success ratio
six maps  four challenging maps                       success ratio gets often
    number mobile units increases  maps common feature containing
long narrow corridors even single width tunnels  connecting wider  open regions
map  thus surprising that  mentioned section    alternate path target isolation
conditions identified greatest causes failing find lidable path 
relaxing target isolation condition  t app  significantly improves success ratio
maps  good success ratio      higher  achieved   maps across entire
range number mobile units    maps contain high proportion narrow
corridors  single width tunnels 
relaxing alternate connectivity well  t  ac app  yields excellent success ratio
unit numbers maps  example  scenarios      units 
   http   webdocs cs ualberta ca nathanst hog html
   experimental maps viewed online  at  http   users cecs anu edu au cwang gamemaps
   http   www bioware com games baldurs gate 

  

fim app   calable ulti  agent path p lanning

challenging according figures      smallest success ratio      map      largest
one        scenarios fewer mobile units  i ac app even better success ratios 
next compare success ratio i ac app  bottom plot figure    far
 top plot figure    w hca         middle bottom figure    without diagonals 
respectively   extended app clear winner terms scalability  far w hca   suffer
number units increased  incomplete algorithms often time even scenarios
significantly fewer units            units  far solves       units 
w hca   solves        no diagonal moves         with diagonal moves 
units  entire data set  i ac app solved        units  far solved
       units                solved w hca   without diagonal moves
allowed  respectively 
    scalability attempting solve units
previous section  compare far  w hca   app  i ac app version
used attempts solve units  provably solvable ones  attempt all feature  
mentioned earlier  achieved marking units active beginning  active units
partitioned three categories  i  provably solvable units reach target  ii 
units reached target  iii  units reached target location 
still active units still cross location  total ordering  
active units must respect conditions units category i  higher priority units
category ii   higher priority units category iii  
attempt all feature turned on  i ac apps percentage solved units increases
        section             
next focus number solved instances  instance considered solved iff
units solved  app successful       instances  significantly better far
         w hca   diagonal moves          w hca   diagonals          
attempt all feature massive impact percentage fully solved instances  improving            might seem counter intuitive attempt all feature
small impact percentage solved units great impact percentage solved instances  explanation following  app fails instance 
small percentage units remain unsolved  often  one two
unsolved units failed instance  managing solve remaining units well
attempt all feature result whole instance changing label failed solved  even
though change overall percentage solved units small 
remaining sections use attempt all feature well  reason increases
number solved instances therefore obtain larger set data analyse 
    total travel distance
factors may impact length plans lengths initial paths  extra movements caused blank travel repositioning  experiments  length precomputed
paths virtually negative impact travel distance  even apps paths
satisfy additional constraints  avoiding targets possible  similar
length normal unconstrained shortest paths       longer average 
  

fiwang   b otea

rc improved travel distance  map     
      

mapp total
rc mapp total
mapp pre computed pi
mapp undos
rc mapp undos

distance  moves 

      
      
      
      
      
      
      
 
 

 

 

                     
number agents     s 

figure    typical case improved distances r c app normal app  note precomputed  paths affected r c enhancement 

section  first evaluate improvement repositioning counting  r c 
standard reverse repositioning  compare total distance travelled r c app
far w hca   
      r educing u ndo oves
identified excessive undoing moves repositioning bottleneck basic app  figure   shows benefits repositioning counting  r c   enhancement described section    figure compares total travelled distance  well number undo moves 
r c t i ac app  shown r c app short  i ac app  m app short  average case  shown  repositioning counting turns quite effective  eliminating many
unnecessary undo moves  that help reach globally restored state   averaged
entire data set  r c app       shorter undo distance app standard reverse
repositioning  results reducing total travelled distance       average 
      c omparing otal istance far w hca       
evaluate solution length attempt all r c t i ac app compared far
w hca         plot total travel distance averaged subset input instances
algorithms considered fully solve 
figures       show average results maps  app  show length
precomputed paths  number undo  repositioning  moves  total travelled distance 
according performance criterion  set maps roughly partitioned three subsets 
good case  map      app performs better w hca        without diagonals
terms total travel distance  even comparable far  average case  apps travel
  

fim app   calable ulti  agent path p lanning

total travel distance  good case      
     

whca       nod
far
mapp total
whca      
mapp pi
mapp undos

     
     
     

      
distance

     

distance

total distance travelled  average case      
      

     
     

      

whca  nod
mapp total
far
whca      
mapp pi
mapp undos

      
      

     

     

     
 
   

   

   

           
number agents

   

   

 
   

   

total distance travelled      
      

distance

      
      
      

whca  nod
mapp total
whca 
far
mapp pi
mapp undos

      

     
     

      

mapp total
whca  nod
far
mapp pi
whca 
mapp undos

      
      

     

     

     
 
   

                           
number agents

total distance travelled      
      

distance

      

   

   

   

               
number agents

   

 
   

   

   

   
   
    
number agents

    

figure     distance travelled plotted averaged instances fully solved algorithms 

distance roughly comparable w hca   without diagonals  maps               belong
category  finally  harder case  apps total distance increases faster rate
others  direct result increasingly larger number undo moves  harder cases
include maps                               upon inspection  cases typically involve
high number turns corners  apps case  results high degree path overlapping 
units keep close edge rounding corner  obtain shorter  paths 
summarise overall results  apps travel distance ranges       shorter w hca  
without diagonal moves       longer     longer average  compared
version w hca   diagonal moves enabled  apps total distance     longer average 
varying      shorter      longer  compared far  apps solutions range
     shorter      longer      longer average 
closer look results reveals that  even repositioning counting use  app
still make unnecessary undo moves  useless undo move counts double final solution
length  since undo matched new forward move next progression step 
improving solution length promising direction future work 
    running time analysis
case travel distance analysis  meaningful runtime comparison  restrict
analysis subset instances completed algorithms  far  w hca   versions 
  

fiwang   b otea

total travel distance  harder case      
      

distance

      
      

mapp total
whca       nod
far
mapp pi
whca 
mapp undos

      

total distance travelled      
      
      
      
distance

      

      
      
      

      

      

     

     

 
   

   

 
                      
number agents

mapp total
whca  nod
far
mapp pi
whca 
mapp undos

   

mapp total
whca  nod
far
mapp pi
whca 
mapp undos

      
      

mapp total
whca       nod
far
mapp pi
whca      
mapp undos

      
      
     
 

                                             
number agents

                                             
number agents

total distance travelled      
      

distance

      
      

mapp total
whca  nod
far
mapp pi
whca 
mapp undos

      

total distance travelled      
      
      
distance

      

      

mapp total
whca  nod
far
mapp pi
whca 
mapp undos

      
      

      

     

     
 

                      
number agents

total travel distance      
      

distance

distance

total distance travelled      
      
      
      
      
      
      
      
      
      
     
 

   

 
                                             
number agents

   

   

                      
number agents

figure     distance travelled continued  remaining six maps 

i ac r c app attempt all feature turned on   show overall summary data 
tables      charts    maps  figures       
implementation app builds scratch required paths  including  paths 
however   paths re used instances map   paths
contain target current instance might recomputed  small percentage
 paths  since number targets typically much smaller map size 
evidence strongly supports taking  path computations offline map pre processing step
improve apps running time  hence  distinguish case app performs
computations scratch  case alternate paths  i e   paths  already
available  e g   previous instances map hand  result preprocessing   note
  

fim app   calable ulti  agent path p lanning

time ratio 
average
min
max

vs far
     
    
     

vs w hca  
    
    
    

vs w hca   d
    
    
    

table    apps runtime divided runtime far  w hca    w hca   d  table 
assume app performs computations  including alternate path search 
scratch 

time ratio 
average
min
max

vs far
    
    
    

vs w hca  
    
    
    

vs w hca   d
    
    
    

table    apps runtime divided runtime far  w hca    w hca   d  table 
time compute alternate paths omitted  could re used instances
map 

far w hca    computation depends every units start target locations 
therefore cannot easily taken map pre processing step  since storing entire search trees
take much memory practical  
table   shows that  app performs computations scratch  comparable
speed w hca    actually slightly faster average  however  version app
   times slower far average  paths already available  apps speed
improves significantly   path computation expensive part app  seen
table    apps speed ratio vs far reduces       app becomes        times faster
w hca   with without diagonals  average 
figure    shows detailed runtime data      maps  even computation scratch  app faster w hca   d  i e   diagonal moves enabled  
often faster  least comparable  w hca   without diagonals  app offline preprocessing reasonably close far  even though far consistently faster least comparable
app  remaining two maps  represent difficult cases app  presented
figure     map     especially  largest data set  significantly larger
rest  almost    times larger   app significantly higher total time  shown top
right figure    
break apps total running time  shown bottom figure    map     
consistently shows search time dominates  furthermore  node expansions  node
expansions generally several times greater node expansions  resulting majority
path computation time spent searching  paths 
  

fiwang   b otea

total running times      
   

whca       nod
whca      
mapp total
mapp preprocessing
far

   
   

   
   
time  s 

   

time  s 

total running times      
   

   
   

  
  
  

   

  

  
 

whca       nod
whca      
mapp total
mapp preprocessing
far

   

   

 
   

                           
number agents

   

   

   

   

   
   

   

 
   

                                             
number agents
total running times      
   

whca       nod
whca      
mapp total
mapp preprocessing
far

   
   
time  s 

time  s 

   

   

   

whca      
whca       nod
mapp total
mapp preprocessing
far

   

   

whca      
mapp total
whca       nod
mapp preprocessing
far

   

total running times      
   

           
number agents

total running times      
   

time  s 

time  s 

total running times      
   
whca       nod
   
whca      
mapp total
   
    mapp preprocessing
far
   
   
   
   
   
  
 
                       
number agents

   

   
   

   
   
   
   

   
 

  
 
                                             
number agents
total running times      

   

   
   
   
time  s 

time  s 

   
   
   

   
   
number agents

    

    

mapp total
whca       nod
whca      
mapp preprocessing
far

   
   
   
   

  
 

   

total running times      
   

whca       nod
whca      
mapp total
mapp preprocessing
far

   

   

  
   

   

   
        
number agents

    

 
    

                                             
number agents

figure     runtime data averaged fully completed instances algorithms  map ids
displayed shorthand brackets  app preprocessing stands version
computes alternate paths 

  

fim app   calable ulti  agent path p lanning

total running times      
   

time  s 

   
   

total running times  worst case      
   

whca      
mapp total
whca       nod
mapp preprocessing
far

mapp total
whca      
whca       nod
    mapp preprocessing
far
   
   

time  s 

   

  
  

   

  

   

  

  

 
   

   

   
        
number agents

    

 
    

   

   

   
        
number agents

    

    

mapp times breakdown      
   

total runtime
total search
omega search
repositioning

   

time  s 

   
   
   
   
  
 
   

   

   
        
number agents

    

    

figure     top  hard cases i ac r c apps total runtime  bottom  time breakdown  showing  path computation takes majority apps search time 

    conclusion
traditional multi agent path planning methods trade optimality  completeness  scalability  centralised method typically preserves optimality  theoretical  completeness 
decentralised method achieve significantly greater scalability efficiency  hand 
approaches shortcomings  former faces exponentially growing state space
number units  latter gives optimality offers guarantees respect completeness  running time solution length  new approach  aimed bridging missing links 
identifies classes multi agent path planning problems solved polynomial time 
introduced algorithm  app  solve problems classes  low polynomial upper
bounds time  space solution length 
performed detailed empirical evaluation app  extended apps completeness
range reaches           even challenging scenarios      mobile units 
completeness range even better scenarios fewer units  data set  app significantly better percentage solved units         provably solvable         attempt all
mode  far          w hca                   without diagonal moves  
attempt all version app solves       instances benchmark algorithms 
  

fiwang   b otea

instances solved algorithms  app significantly faster variants w hca   
slower fast far algorithm factor      average  alternate
paths needed instance readily available  performing computations scratch 
apps speed comparable w hca    apps solutions reported average     longer
fars solutions      longer w hca  s solutions  however  unlike algorithms
far w hca    app offer partial completeness guarantees low polynomial bounds
runtime  memory solution length  thus  app combines strengths two traditional
approaches  providing formal completeness upper bound guarantees  well scalable
efficient practice 
findings presented open avenues future research large scale multi agent
pathfinding  long term  app part algorithm portfolio  since cheaply
detect guaranteed solve instance  thus worthwhile investigate tractable
classes  subclasses far complete  app improved run faster 
compute better solutions  cover instances  solution quality measured
total travel distance  terms makespan  i e   total duration actions run
parallel  total number actions  including move wait actions   far  worked
relaxing two original lidable conditions  target isolation alternate connectivity  future
work could address initial blank condition  moreover  initially non s lidable units
problem could become lidable later on  lidable units getting solved 
extending app instances units heterogeneous size speed another promising
direction 

acknowledgments
nicta funded australian governments department communications  information
technology  arts australian research council backing australias ability
ict research centre excellence programs 
many thanks nathan sturtevant providing hog framework  help
understanding program  thanks philip kilby  jussi rintanen  nick hay
many helpful comments  thank anonymous reviewers valuable feedback 

references
barraquand  j   langlois  b     latombe  j  c          numerical potential field techniques
robot path planning  international conference advanced robotics  icar   vol     pp 
         
bulitko  v   sturtevant  n   lu  j     yau  t          graph abstraction real time heuristic
search  journal artificial intelligence research  jair             
choset  h   lynch  k   hutchinson  s   kantor  g   burgard  w   kavaraki  l     thrun  s         
principles robot motion  theory  algorithms  implementation  mit press 
erdmann  m     lozano perez  t          multiple moving objects  ieee international
conference robotics automation  icra   pp           
geramifard  a   chubak  p     bulitko  v          biased cost pathfinding  artificial intelligence
interactive digital entertainment conference  aiide   pp         
  

fim app   calable ulti  agent path p lanning

hart  p   nilsson  n     raphael  b          formal basis heuristic determination
minimum cost paths  ieee transactions systems science cybernetics           
    
hopcroft  j  e   schwartz  j  t     sharir  m          complexity motion planning
multiple independent objects  pspace hardness warehousemans problem  international journal robotics research  ijrr              
jansen  r     sturtevant  n          new approach cooperative pathfinding  international
conference autonomous agents multiagent systems  aamas   pp           
kant  k     zucker  s  w          toward efficient trajectory planning  path velocity decomposition  international journal robotics research  ijrr              
kornhauser  d   miller  g     spirakis  p          coordinating pebble motion graphs  diameter permutation groups  applications  proceedings   th annual symposium
foundations computer science  focs   pp         
latombe  j  c          robot motion planning  kluwer academic publishers 
papadimitriou  c   raghavan  p   sudan  m     tamaki  h          motion planning graph 
  th annual symposium foundations computer science  pp         
pottinger  d          coordinated unit movement  http   www gamasutra com view 
feature      coordinated unit movement php 
rabin  s          a  speed optimizations  deloura  m   ed    game programming gems  pp 
        charles river media 
ratner  d     warmuth  m          finding shortest solution n n extension   puzzle intractable  proceedings aaai national conference artificial intelligence
 aaai      pp         
ryan  m  r  k          exploiting subgraph structure multi robot path planning  journal
artificial intelligence research  jair              
samet  h          overview quadtrees  octrees  related hierarchical data structures 
nato asi series  vol  f   
silver  d          cooperative pathfinding  artificial intelligence interactive digital entertainment conference  aiide   pp         
silver  d          cooperative pathfinding  ai programming wisdom           
standley  t          finding optimal solutions cooperative pathfinding problems  proceedings twenty fourth aaai conference artificial intelligence  aaai      pp         
stout  b          smart moves  intelligent pathfinding  game developer magazine 
sturtevant  n  r     buro  m          improving collaborative pathfinding using map abstraction  
artificial intelligence interactive digital entertainment  aiide   pp       
surynek  p       a   application pebble motion graphs abstract multi robot path planning  proceedings   st international conference tools artificial intelligence
 ictai   pp         
surynek  p       b   novel approach path planning multiple robots bi connected graphs 
ieee international conference robotics automation  icra   pp           
  

fiwang   b otea

surynek  p       a  personal communication 
surynek  p       b   optimization variant multi robot path planning intractable 
proceedings   th aaai conference artificial intelligence  aaai      pp      
     
surynek  p       c   multi robot path planning  pp          intech   open access publisher 
tarjan  r  e          edge disjoint spanning trees depth first search  acta informatica       
       
tozour  p          building near optimal navigation mesh  rabin  s   ed    ai game programming wisdom  pp          charles river media 
wang  k  h  c     botea  a          fast memory efficient multi agent pathfinding  proceedings international conference automated planning scheduling  icaps  
pp         
wang  k  h  c     botea  a          tractable multi agent path planning grid maps  proceedings international joint conference artificial intelligence  ijcai   pp      
     
wang  k  h  c     botea  a          scalable multi agent pathfinding grid maps
tractability completeness guarantees  proceedings european conference
artificial intelligence  ecai   pp         
zelinsky  a          mobile robot navigation exploration algorithm  ieee transactions
robotics automation               

  


