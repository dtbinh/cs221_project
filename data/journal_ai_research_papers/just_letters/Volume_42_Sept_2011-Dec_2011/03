journal artificial intelligence research                  

submitted       published      

unfounded sets well founded semantics
answer set programs aggregates
mario alviano
francesco calimeri
wolfgang faber
nicola leone
simona perri

alviano mat unical it
calimeri mat unical it
faber mat unical it
leone mat unical it
perri mat unical it

department mathematics
university calabria
i       rende  cs   italy

abstract
logic programs aggregates  lpa   one major linguistic extensions
logic programming  lp   work  propose generalization notions unfounded set well founded semantics programs monotone antimonotone
aggregates  lpa
m a programs   particular  present new notion unfounded set

lpm a programs  sound generalization original definition standard
 aggregate free  lp  basis  define well founded operator lpa
m a programs 
fixpoint called well founded model  or well founded semantics  lpa
m a
programs  important properties unfounded sets well founded semantics standard lp retained generalization  notably existence uniqueness
well founded model  together strong relationship answer set semantics lpa
m a programs  show one d well founded semantics  defined
pelov  denecker  bruynooghe broader class aggregates using approximating
operators  coincides well founded model defined work lpa
m a programs  discuss complexity issues  importantly give formal proof
tractable computation well founded model lpa
m a programs  moreover  prove

general lp programs  may contain aggregates neither monotone
antimonotone  deciding satisfaction aggregate expressions respect partial
interpretations conp complete  consequence  well founded semantics general
lpa programs allows tractable computation unlikely exist  justifies
restriction lpa
m a programs  finally  present prototype system extending dlv 
supports well founded semantics lpa
m a programs  time writing
implemented system so  experiments prototype show significant
computational advantages aggregate constructs equivalent aggregate free encodings 

   introduction
use logical formulas basis knowledge representation language proposed    years ago seminal works mccarthy         mccarthy
hayes         however  soon realized monotonic nature classical logic
 the addition new knowledge may increase set consequences theory
classical logic  always suited model commonsense reasoning  sometimes
intrinsically nonmonotonic  minsky         alternative  suggested represent
c
    
ai access foundation  rights reserved 

fialviano  calimeri  faber  leone    perri

commonsense reasoning using logical languages nonmonotonic consequence relations 
better simulate forms human reasoning  allowing new knowledge invalidate previous conclusions  observation opened new important
research field  called nonmonotonic reasoning  led definition investigation
new logical formalisms  called nonmonotonic logics  popular nonmonotonic logics
circumscription  mccarthy               default logic  reiter         nonmonotonic
modal logics  mcdermott   doyle        mcdermott        moore         later on 
cross fertilizations field nonmonotonic logics logic programming 
another nonmonotonic language  called declarative logic programming  lp  emerged 
incorporating nonmonotonic negation operator denoted not  declarative logic programming gained popularity last years  today widely used formalism
knowledge representation reasoning  applications various scientific disciplines
even industry  ricca  alviano  dimasi  grasso  ielpa  iiritano  manna    leone 
      ricca  grasso  alviano  manna  lio  iiritano    leone        manna  ricca    terracina        manna  ruffolo  oro  alviano    leone         lp problems solved
means declarative specifications requirements achieved  ad hoc algorithms
required 
several semantics lp proposed literature  take care
inherent non monotonicity operator programs  well founded
semantics  van gelder  ross    schlipf        one prominent among them 
associates three valued model  well founded model  every logic program  originally 
well founded semantics defined normal logic programs  is  standard
logic programs nonmonotonic negation  distinguishing property well founded
semantics existence uniqueness well founded model guaranteed
logic programs  moreover  well founded semantics computable polynomial time
respect input program propositional case 
even lp declarative programming language  standard lp allow
representing properties sets data natural way  relevant aspect many application domains  addressing insufficiency  several extensions lp
proposed  relevant introduction aggregate functions  lpa  
kemp   stuckey        denecker  pelov    bruynooghe        dix   osorio        gelfond        simons  niemela    soininen        dellarmi  faber  ielpa  leone    pfeifer 
      pelov   truszczynski        pelov  denecker    bruynooghe         among them 
recursive definitions involving aggregate functions  i e   aggregation aggregated
data depend evaluation aggregate itself  particularly interesting 
definition semantics straightforward  pelov        faber  leone    pfeifer 
      son   pontelli        liu  pontelli  son    truszczynski         note similar
construct  referred abstract constraint  introduced literature  marek
  truszczynski        liu   truszczynski        son  pontelli    tu        truszczynski 
      brewka         results paper carry lp abstract
constraints  well founded semantics knowledge defined far 
paper focus fragment lpa allowing monotone antimonotone

aggregate expressions  lpa
m a   calimeri  faber  leone    perri         lpm a programs
many interesting properties  among them  highlight similarities monotone
aggregate expressions positive standard literals  antimonotone aggregate
   

fiunfounded sets well founded semantics asp programs aggregates

expressions negative standard literals  particular  take advantage aspect
defining unfounded sets and  based definition  well founded semantics

lpa
m a fragment  well founded semantics lpm a programs obtained way
retains many desirable properties original well founded semantics lp 
extends  lpa
m a program unique well founded model exists  polynomialtime computable  approximates programs answer sets  coincides answer
set stratified lpa
m a programs 
actually turns well founded semantics thus obtained coincides  on lpa
m a
programs  well founded semantics proposed pelov  denecker  bruynooghe
        pelov et al  define several semantics logic programs aggregates using various approximating immediate consequence operators  notion logic program adopted
pelov et al  general one considered present work  allowing
arbitrary first order formulas bodies  unrestricted aggregates  non herbrand interpretations  equivalence two semantics  properties proved
pelov et al  carry work well  applies results well founded
model total stratified programs  theorem     well founded model contained
answer set  theorem      well founded model computable polynomial time  theorem      however  framework introduced article considerably
different one developed pelov et al   allows giving alternative proofs
result  vice versa  article contains many new results  carry
framework pelov et al  lpa
m a programs  particular  provides alternative
definition well founded semantics  characterization answer sets means unfounded sets  implemented system computing well founded semantics 
time writing one kind 
would point extensions lpa
m a programs come
mind  definition unfounded sets would considerably changed  see instance definition provided faber         moreover main desired properties
well founded semantics would longer guaranteed  instance  obvious extension  including aggregate expressions neither monotone antimonotone
would likely computable polynomial time  fact  evaluation
aggregate expressions respect partial interpretations tractable monotone
antimonotone aggregates  task conp complete general aggregate expressions  also  instance allowing aggregates rule heads would necessarily complicate
definition unfounded sets  would guarantee existence well founded model
every program  would likely guarantee polynomial time computability 
concepts defined paper directly give rise computation method
well founded semantics lpa
m a programs  implemented method 
best knowledgethe first kind  conducted experiments
system lpa
m a encodings particular problem domain  compared
encodings using aggregates  latter encodings tested system
prototype derived xsb  state of the art system computing
well founded model  experiments show clear advantage lpa
m a encodings
run prototype system 
summarizing  main contributions paper follows 
   

fialviano  calimeri  faber  leone    perri

define new notion unfounded set logic programs monotone
antimonotone aggregates  lpa
m a programs   notion sound generalization
concept unfounded set previously given standard logic programs  show
definition coincides original definition unfounded sets  van gelder
et al         class normal  aggregate free  programs  shares
distinguishing properties  such existence greatest unfounded set  
define well founded operator wp logic programs aggregates  extends classical well founded operator  van gelder et al          total fixpoints
wp exactly answer sets p  least fixpoint wp    contained
intersection answer sets  show operator equivalent
operator defined pelov et al         
provide declarative characterization answer sets terms unfounded sets 
particular  prove answer sets lpa
m a program precisely
unfounded free models 
show reasoning aggregates without restrictions may easily increase
complexity computation  particular  prove deciding truth
falsity aggregate expression respect partial interpretation
conp complete problem  however  problem intractable general 
polynomial time solvable monotone antimonotone aggregates 
analyze complexity well founded semantics  confirming extending
results work pelov et al          importantly  turns wp   
polynomial time computable propositional lpa
m a programs  non ground
programs  data complexity remains polynomial  program complexity
rises p exptime  aggregate free programs 
present prototype system supporting well founded semantics defined
article  prototype  obtained extending dlv  first system implementing
well founded semantics  unrestricted  lpa
m a programs 
report experimental results implemented prototype  specifically 
define attacks problem  problem inspired classic win lose problem
often considered context well founded semantics standard logic programs  compare execution times prototype lpa
m a encoding
equivalent lp encodings  particular  one tested lp encodings obtained means compilation aggregates standard lp  briefly
presented paper  obtained results evidence computational advantages
problem encoding using aggregate expressions without them 
presentation organized follows  section   present basics
lpa language and  particular  introduce lpa
m a fragment  fragment 
define unfounded sets well founded semantics section    relationships
well founded semantics answer set semantics discussed section    complexity
analysis well founded semantics lpa
m a programs reported section   
   

fiunfounded sets well founded semantics asp programs aggregates

section   discuss implemented prototype system experimentation  finally 
related work discussed section    section   draw conclusions 

   lpa language
syntax  instantiation  interpretations models lpa programs introduced
section  moreover  introduce lpa
m a fragment language  define
well founded semantics section    additional background standard lp  refer
literature  gelfond   lifschitz        baral        
    syntax
assume sets variables  constants  predicates given  similar prolog 
assume variables strings starting uppercase letters constants nonnegative integers strings starting lowercase letters  predicates strings starting
lowercase letters  arity  non negative integer  associated predicate 
moreover  language allows using built in predicates  i e   predicates fixed
meaning  common arithmetic operations positive integers  i e              
etc   written infix notation   interpreted standard mathematical way 
      standard atom
term either variable constant  standard atom expression p t            tn   
p predicate arity n t            tn terms  atom p t            tn   ground
t            tn constants 
      set term
set term either symbolic set ground set  symbolic set pair  terms   conj   
terms list terms  variables constants  conj conjunction standard
atoms  is  conj form a            ak ai    k  standard
atom  intuitively  set term  x   a x  c   p x   stands set x values making
conjunction a x  c   p x  true  i e    x   a x  c  p x  true   ground set set
pairs form hconsts   conj i  consts list constants conj conjunction
ground standard atoms 
      aggregate function
aggregate function form f  s   set term  f aggregate
function symbol  intuitively  aggregate function thought  possibly partial 
function mapping multisets constants constant  throughout remainder
paper  adopt notation dlv system  leone  pfeifer  faber  eiter  gottlob 
perri    scarcello        representing aggregates 
example   common aggregate functions listed below 
 min  minimal term  undefined empty set 
 max  maximal term  undefined empty set 
   

fialviano  calimeri  faber  leone    perri

 count  number terms 
 sum  sum integers 
 times  product integers 
 avg  average integers  undefined empty set 
      aggregate atom
aggregate atom structure form f  s    f  s  aggregate function 
           comparison operator  term  variable constant  
aggregate atom f  s  ground constant ground set 
example   following aggregate atoms dlv notation 
 max z   r z   a z  v     
 max h    r     a    m i  h    r     a    n i     

      literal
literal either  i  standard atom   ii  standard atom preceded negation
failure symbol not   iii  aggregate atom  two standard literals complementary
form a  standard atom a  standard literal  
denote   complement   abusing notation  l set standard literals 
 l denotes set      l  
      program
rule r construct form
               

standard atom              literals     atom referred
head r  conjunction             body r  body empty
 m       rule called fact  denote head atom h r    a  set
body literals b r                    moreover  set positive standard body literals
denoted b    r   set negative standard body literals b  r   set
aggregate body literals b  r   rule r ground h r  literals b r 
ground  program set rules  program ground rules ground 
      safety
local variable rule r variable appearing solely sets terms r  variable r
local global  rule r safe following conditions hold   i 
global variable x r positive standard literal b    r  x appears
   ii  local variable r appearing symbolic set  terms   conj   appears
conj   note condition  i  standard safety condition adopted lp guarantee
variables range restricted  ullman         condition  ii  specific
aggregates  program safe rules safe 
   

fiunfounded sets well founded semantics asp programs aggregates

example   consider following rules 
p x    q x  y  v     max z   r z   a z  v      y 
p x    q x  y  v     sum z   r x   a x  s     y 
p x    q x  y  v     min z   r z   a z  v      t 

first rule safe  second local variable z violates condition
 ii   third rule safe  since global variable violates condition  i  
    program instantiation  interpretations models
section   define well founded semantics relevant class lpa programs 
well founded semantics defined ground programs  programs variables
associated equivalent ground programs  section introduce preliminary
notions program instantiation  interpretations models 
      universe base
given lpa program p  universe p  denoted   set constants
appearing p  base p  denoted bp   set standard atoms constructible
predicates p constants  
      instantiation
substitution mapping set variables   given substitution
lpa object obj  rule  set  etc    denote obj object obtained replacing
variable x obj  x   substitution set global variables rule
r  to   global substitution r  substitution set local variables
set term  to   local substitution s  given set term without global variables
   terms   conj    instantiation following ground set 
inst s     hterms   conj   local substitution s  
ground instance rule r obtained two steps  first  global substitution r
applied  every set term r replaced instantiation inst s  
instantiation ground p  program p set instances rules p 
example   consider following program p   
q      p       
p         q    

q      p       
p         q    

t x    q x    sum y   p x         

instantiation ground p    p  following program 
q      p       
p         q    

q      p       
p         q    

t      q      sum h    p      i  h    p      i      
t      q      sum h    p      i  h    p      i      

      aggregate function domain
x

given set x  let   denote set multisets elements x  domain
aggregate function set multisets function defined  without loss
generality  assume aggregate functions map z  the set integers  
   

fialviano  calimeri  faber  leone    perri

example   let us look common domains aggregate functions example   
u
z
 count defined    p  sum  times      min   max  avg
z
       
      interpretation
interpretation lpa program p consistent set standard ground literals 
is  bp  bp  i     denote   set standard
positive negative literals occurring i  respectively  interpretation total
   i   bp   otherwise partial  set interpretations p denoted
ip   given interpretation standard literal   evaluation respect
defined follows   i  i  true respect i   ii    i 
false respect i   iii  otherwise        i  undefined
respect i  interpretation provides meaning set terms  aggregate functions
aggregate literals  namely multiset  value  truth value  respectively 
first consider total interpretation i  evaluation i s  set term respect
multiset i s  defined follows  let    ht         tn   ht         tn   conj
atoms conj true respect i   i s  multiset obtained
projection tuples si first constant  is  i s     t    ht         tn   
evaluation i f  s   aggregate function f  s  respect result
application f i s    multiset i s  domain f   i f  s    
 where fixed symbol occurring p   ground aggregate atom   f  s  k
true respect i f  s      i f  s   k hold  otherwise  false 
example   let i  total interpretation i      f      g        g        g        g       
h     h     h      assuming variables local  check that 
 count x   g x         false  indeed  s  corresponding ground set 
s i     h i  h i   i   s              count             
 count x    g x         true  indeed  s  corresponding ground set 
s i     h    i  h    i  h    i  h    i   i   s                    count                   
 times y   f  x   g x           true  indeed  s  corresponding ground
set  s i     h i  h i  h i   i   s                 times                 
 sum x   g x     h y         true  indeed  s  corresponding ground set 
s i     h i  h i   i   s              sum             
 sum x    g x     h y         false  indeed  s  corresponding ground
set  s i     h    i  h    i  h    i  h    i   i   s                    sum                
   
 min x   f  x   h x        false  indeed  s  corresponding ground set 
s i      i   s        i    min       we recall domain
 min  
   paper  consider aggregate functions value polynomial time computable
respect input multiset 

   

fiunfounded sets well founded semantics asp programs aggregates

consider partial interpretation refer interpretation j
j extension i  ground aggregate atom true  resp  false  respect
total interpretation j extending i  true  resp  false  respect i 
otherwise  undefined 
example   let s  ground set literal      sum h    p      i  h    p      i   
   consider partial interpretation i     p         since total interpretation
extending i  contains either p       p        either i   s          i   s     
        thus  application  sum yields either              thus   true
respect i   
remark   observe definitions interpretation truth values preserve knowledge monotonicity  interpretation j extends  i e   j   literal true
respect true respect j  literal false respect
false respect j well 
      model
given interpretation i  rule r satisfied respect least one following
conditions satisfied   i  h r  true respect i   ii  literal b r  false
respect i   iii  h r  literal b r  undefined respect i 
interpretation model lpa program p rules r ground p 
satisfied respect  
example   consider program p  example    let i  total interpretation
p  i      q     p        t      i  minimal model p   
    lpa
m a language

definition lpa
m a programs  fragment lp analyzed paper  based
following notion monotonicity literals 

      monotonicity
given two interpretations j  say j   j   j  
ground literal monotone if  interpretations i  j j  that 
 i  true respect implies true respect j   ii  false respect
j implies false respect i  ground literal antimonotone opposite
happens  is  interpretations i  j j  that   i  false
respect implies false respect j   ii  true respect j implies
true respect i  ground literal nonmonotone neither monotone
antimonotone  note positive standard literals monotone  whereas negative standard
literals antimonotone  aggregate literals  instead  may monotone  antimonotone
nonmonotone  examples shown complete picture
common aggregate functions summarized table   
example   let us assume universe numerical constants non negative
integers  ground instances following aggregate literals thus monotone 
   

fialviano  calimeri  faber  leone    perri

table    character common aggregate literals 
function domain operator
character
 count

  
monotone
  
antimonotone
 sum
n
  
monotone
  
antimonotone
z
        nonmonotone
 times
n 
  
monotone
  
antimonotone
n  z
        nonmonotone
 min

  
nonmonotone
  
monotone
 max

  
monotone
  
nonmonotone
 avg
n  z
        nonmonotone


antimonotone context guarantees set term aggregate never becomes empty 

 sum z   r z      

 count z   r z       

ground instances following literals instead antimonotone 
 sum z   r z      

 count z   r z       

      lpa
m a programs

let lpa
m a denote fragment lp allowing monotone antimonotone literals 
lpa
m a rule r  set monotone antimonotone body literals denoted

b  r  b  r   respectively  lpa
m a program p stratified exists function
       called level mapping  set predicates p ordinals 
pair a  b predicates  occurring head body rule r p  respectively   i  b
appears antimonotone literal    b       a     ii  otherwise   b     a    intuitively 
stratification forbids recursion antimonotone literals  for aggregate free programs
definition coincides common notion stratification respect negation  

example    consider lpa
m a program consisting following rules 
q x    p x    count y   a y  x   b x     
p x    q x   b x  

assume predicates b defined facts  include
explicitly  program stratified  level mapping   a       b          p       q      
satisfies required conditions  add rule b x    p x   levelmapping exists  program becomes unstratified 
would note definition lpa
m a could enlarged  form
given classifies literals independently context  that is  program 
   

fiunfounded sets well founded semantics asp programs aggregates

occur  aggregates nonmonotone definition given above  might
manifest nonmonotone effects given context  one limits interpretations
considered violate program literal occurs 
interpretation pairs violate monotonicity antimonotonicity may longer
present  fact  one could refine definition way  considering pairs
non violating interpretations given context program   modified definition would
enlarge class lpa
m a programs  retaining results paper 
simplicity exposition refrain formally  example  aggregate
atom involving  max   operator formally lpa
m a   one considers
occurrences program non violating interpretation i s   
 where set term aggregate   aggregate behaves antimonotone
way particular program  noted cases footnote table   

   unfounded sets well founded semantics
section introduce new notion unfounded set lpa
m a programs 
extends original definition aggregate free programs introduced van gelder et al 
        unfounded sets used extending well founded semantics  originally
defined aggregate free programs van gelder et al   lpa
m a programs 
highlight number desirable properties semantics  following deal
ground programs  usually denote p ground program  use
notation l  l set  l   l    l   l l sets standard ground
literals 
definition    unfounded set  set x bp ground atoms unfounded set
lpa
m a program p respect  partial  interpretation if  rule
r p h r  x   least one following conditions holds 
     antimonotone  literal b  r  false respect i 
     monotone  literal b  r  false respect  x  
intuitively  rule head atom belonging unfounded set x already
satisfied respect  in case condition     holds   satisfiable taking false
atoms unfounded set  in case condition     holds   note that  according
definition above  empty set unfounded set respect every program
interpretation 
example    consider interpretation i     a     a     a     following program
p   
r   
r   
r   

a       count h    a   i  h    a   i  h    a   i      
a    
a       count h    a   i  h    a   i  h    a   i      

x     a     unfounded set p  respect i    since condition    
definition   holds r   the rule head a      indeed   monotone  literal
appearing b  r    false respect i   x     not a     a     a      similarly 
 a      a     a     unfounded sets p  respect i    clearly 
unfounded set  sets atoms unfounded p  respect i   
   

fialviano  calimeri  faber  leone    perri

formalized below  definition   generalizes one given van gelder et al        
aggregate free programs  set standard atoms x bp unfounded set
program p respect interpretation if  rule r p
h r  x   either  i  b r   i       ii  b    r  x  
   
theorem   aggregate free program p  definition   equivalent one introduced work van gelder et al         
proof  aggregate free program p  conditions         definition   equivalent  a  b  r   i     b  b    r    i  x        respectively  condition  b 
equivalent b    r     i   x     x        holds either  b   
b    r    i   x         b    b    r  x  
    condition  b    exactly condition  ii 
work van gelder et al  concerning condition  b     since b    r  contains
positive literals  ignore negative literals   i   x    is  positive literals
  x   noting negative literals   x precisely negative literals
i  conclude  b    equivalent b    r   i      finally  combining
previous statement condition  a  above  obtain condition  i  work van
gelder et al 

thus  definition   alternative characterization unfounded sets aggregate free
programs  fact  condition     definition   exactly cover first one
van gelder et al   condition     catches cases second work van gelder
et al  missed condition     
theorem   x x unfounded sets lpa
m a program p respect

interpretation i  x x unfounded set p respect i 
proof  let r p h r  x x   want show either    
 antimonotone  literal b  r  false respect i       monotone  literal
b  r  false respect j     x x    symmetry  assume
h r  belongs x   since x unfounded set respect hypothesis  either
 a   antimonotone  literal b  r  false respect i   b   monotone 
literal b  r  false respect k    x   case  a  equals      thus 
remains prove case  b  implies      indeed  j k j   k  
j k   therefore  definition monotonicity  monotone literal
false respect k false respect j well  done 

corollary theorem    union unfounded sets unfounded set
well 
corollary   union unfounded sets lpa
m a program p respect
interpretation unfounded set p respect well  refer set
greatest unfounded set p respect i  denoted gu sp  i  
important monotonicity property greatest unfounded set 
proposition   let j interpretations lpa
m a program p  j 
gu sp  i  gu sp  j  
   

fiunfounded sets well founded semantics asp programs aggregates

proof  since gu sp  j  union unfounded sets p respect j
definition  enough show x   gu sp  i  unfounded set p respect
j  thus  want show that  rule r p h r  x   either    
 antimonotone  literal b  r  false respect j       monotone  literal
b  r  false respect j  x   already know x unfounded set p
respect corollary    therefore  either  a   antimonotone  literal b  r 
false respect i   b   monotone  literal b  r  false respect
 x   since j  j j  x extensions interpretations
 x   respectively  hence  remark     a  implies      b  implies     
done 

ready extending well founded operator defined van gelder et al 
       case lpa
m a programs 
definition   let p lpa
m a program  immediate logical consequence operator
b
p
tp   ip  
well founded operator wp   ip  bp  bp defined follows 
tp  i      bp   r p h r   
literals b r  true respect i 
wp  i    tp  i   gu sp  i  
intuitively  given interpretation program p  wp derives true set
atoms belonging every model extending  by means tp operator   moreover 
wp derives false atoms belonging unfounded set p respect
 by means gu sp operator   note tp  i  gu sp  i  set atoms 
wp  i     tp  i  wp  i     gu sp  i   following proposition formalizes
intuition definition   extends wp operator defined van gelder et al        
standard programs lpa
m a programs 
proposition   let p aggregate free program  wp operator definition  
coincides wp operator defined van gelder et al         
proof  since wp equal union tp  gu sp cases 
show definitions tp gu sp coincide introduced van gelder
et al         aggregate free programs 
two immediate logical consequence operators  tp   coincide aggregate free
program p  indeed  rule r p  b r  standard literals 
definition gu sp  i  coincides one van gelder et al        
aggregate free program p interpretation i  indeed  cases gu sp  i 
defined union unfounded sets p respect i  notion
unfounded set coincides one work van gelder et al  standard
programs theorem   

next show fixpoint well founded operator wp  possibly partial 
model 
   

fialviano  calimeri  faber  leone    perri

 a  b 

 a  b 

 a 

 b 

 not a  b   not a  b 

 not b 

 not a 


figure    meet semilattice
theorem   let p lpa
m a program  partial  interpretation 
fixpoint wp    partial  model p 
proof  let us assume wp  m     holds  thus  tp  m    gu sp  m  
hold  consider rule r p  literals b r  true respect  
h r  tp  m     h r  false respect   h r  gu sp  m   
since gu sp  m   unfounded set p respect corollary    either
literal b  r  false respect   literal b  r  false respect
 gu sp  m       conclude r satisfied  

theorem states wp monotone operator meet semilattice induced ip subset containment relationship  recall meet semilattice
partially ordered set meet  or greatest lower bound  nonempty finite
subset  example meet semilattice program base  a  b  reported
figure   
theorem   let p lpa
m a program  well founded operator wp monotone
operator meet semilattice hip   i 
proof  since wp equal union tp  gu sp definition   
prove monotonicity operators tp gu sp  
first show tp monotone operator  is  pair interpretations
i  j p j  holds tp  i  tp  j   consider atom tp  i  
definition    rule r p h r    literals b r 
true respect i  since j  conclude literals b r 
true respect j well  see remark     h r    belongs tp  j 
definition   
already know gu sp monotone operator proposition   
pair interpretations i  j p j  holds gu sp  i  gu sp  j  

prove sequence w      wn     wp  wn   well defined  is 
element sequence interpretation 
theorem   let p lpa
m a program  sequence w      wn     wp  wn  
well defined 
   

fiunfounded sets well founded semantics asp programs aggregates

proof  use strong induction  base case trivial  since w      order prove
consistency wn     tp  wn   gu sp  wn    assume consistency every wm
n  since wp monotone operator theorem    enough show
gu sp  wn   wn       end  next show set x atoms
x wn      unfounded set p respect wn  and contained
gu sp  wn     let wm   first element sequence x wm       note
n   consider atom x wm     definition tp   rule r p
h r    literals b r  true respect wm   note
atom wm belong x  for way wm   chosen   thus 
remark    literals b r  true respect wn wn  x  we
recall wn wm wp monotone   ends proof  neither condition
        definition   hold  

theorem   theorem   imply wp admits least fixpoint  tarski        
referred well founded model p  well founded semantics lpa
m a
program p given model  state first important property
well founded semantics lpa
m a programs 
property   every lpa
m a program  well founded model always exists unique 
another important property well founded semantics easily follows proposition   
property   aggregate free programs  well founded semantics defined
paper coincides classical well founded semantics van gelder et al         
although well founded model  general  might leave atoms undefined 
cases wp    total interpretation 
example    consider following program p   
a       sum h    a   i  h    a   i      
a      b 
b   c 

iterated application wp yields following sets 
  
  
  

wp       not a     c  
wp   not a     c      not a     c  b  
wp   not a     c  b      not a     c  b  a       wp    

case  well founded model total  indeed  atom bp either true false
respect wp    
totality well founded model program due stratification 
formalized next theorem  given corollary     equivalent result stated
already pelov et al         theorem     corollary      however  proof
labelled sketch pelov et al   moreover relies rather different formalisms
proof 
   

fialviano  calimeri  faber  leone    perri

theorem   stratified lpa
m a programs  well founded model total 

proof  let p stratified lpa
m a program  order prove wp    total 
show  standard  atom bp  wp    false respect wp     definition
stratification  level mapping        standard  predicates p that 
pair a  b standard predicates occurring head body rule r p 
respectively  following conditions satisfied   i  b appears antimonotone literal 
  b       a   holds   ii  otherwise  b appears monotone literal    b     a  
holds  order define non decreasing sequence subsets bp follows 

l   
li     li   bp   predicate p   p     i  

n 

aim show that  n  set li    wp    contained  wp     
use induction i  base case trivial l    holds definition 
suppose atoms li   wp    false respect wp    order show
atoms li     wp    false respect wp    well  end 
prove li     wp    unfounded set p respect wp     consider
rule r ground p  h r  li     wp     want show either    
 antimonotone  literal b  r  false respect wp          monotone 
literal b  r  false respect wp      li     wp      since h r  li    
definition stratification following propositions hold 
 a  literal b  r  either negated standard atom belonging li   aggregate
literal depending atoms li  
 b  literal b  r  either standard atom belonging li     aggregate
literal depending atoms li    
since h r    wp     that is  h r    tp  wp       literal b r 
true respect wp     by definition tp    antimonotone literal 
apply  a  induction hypothesis conclude     holds   cannot undefined
respect wp     must false   monotone literal  apply  b 
induction hypothesis conclude     holds   cannot undefined respect
wp      li     wp     wp      li     wp     wp    holds  must
false  


   answer set characterization via unfounded sets
well founded semantics three valued semantics  is  program associated model atoms either true  false undefined  semantics
literature associate programs two valued models  i e   models without undefined
atoms   commonly accepted two value semantics lp answer set semantics 
section present number results concerning unfounded sets answer sets
lpa
m a programs  first recall definition answer sets provided faber  leone 
pfeifer        
   

fiunfounded sets well founded semantics asp programs aggregates

definition    minimal model  total model p  subset  minimal total
model n p exists n       note that  definitions  words
interpretation model refer possibly partial interpretations  minimal model
always total interpretation 
next provide transformation reduct ground program
respect total interpretation formed  note definition generalization  faber
et al         gelfond lifschitz transformation        standard logic programs 
definition    program reduct  given lpa program p total interpretation
i  let ground p i denote transformed program obtained ground p  deleting
rules body literal false respect i  i e  
ground p i    r ground p    literals b r  true respect i  
ready introducing notion answer set lpa programs 
definition    answer set lpa programs  given lpa program p  total interpretation p answer set p minimal model
ground p m  
example    consider two total interpretations i     p     i     not p    
following two programs 
p     p       count x   p x        
p     p       count x   p x      

obtain following transformed programs 
ground p   i 
ground p   i 
ground p   i 
ground p   i 

  ground p       p       count h    p   i       
 
 
  ground p       p       count h    p   i     

hence  i  answer set p    indeed  i  minimal model ground p   i   
moreover  p  answer sets  indeed  i  minimal model ground p   i   
i  model ground p   i    ground p    
note answer set p total model p ground p m
ground p   rules ground p    ground p m satisfied respect
 by definition    rules must least one body literal false
respect   
language lpa
m a considered work  answer sets defined definition  
coincide stable models defined pelov  denecker  bruynooghe       
hence defined pelov et al         son et al          equivalence
follows propositions         ferraris         respectively state stable
models pelov et al         lpa
m a coincide semantics defined ferraris        
turn coincides definition   larger class programs  means
results involving answer sets hold semantics lpa
m a  
hand  implies results  for example theorem     consequences
results work pelov et al         virtue theorem    section   
remainder section highlight relevant relationships answer sets
unfounded sets  introducing results  let us provide additional definition 
   

fialviano  calimeri  faber  leone    perri

definition    unfounded free interpretation  interpretation lpa
m a program p unfounded free x   holds unfounded set x p
respect i 
total interpretations  equivalent characterization unfounded free property
given below 
lemma    total interpretation lpa
m a program p unfounded free
 
empty set subset unfounded set p respect i 
proof     straightforward  definition    disjoint unfounded set
p respect i 
   prove contrapositive  unfounded free  exists non empty
subset   unfounded set p respect i  definition   
unfounded free  exists unfounded set x p respect
x  
    next show x unfounded set p respect i  i e  
rule r p h r  x   either      antimonotone  literal b  r 
false respect i       monotone  literal b  r  false respect
  i x    since x unfounded set  definition    either  a   antimonotone 
literal b  r  false respect i   b   monotone  literal b  r  false
respect  x   thus  end proof showing  x     i x   
end  observe  i   x     x   i    i x    moreover  since total 
  bp           thus  ii    x   i      x         x   using  i 
 x    i   x    x simplifying  ii  obtain  x    i   x     i x   
conclude observing   x      i x    thus  x     i x  
holds 

give another interesting characterization total models lpa
m a programs 
lemma    total interpretation  total  model lpa
m a program p
 m unfounded set p respect  
proof  start observing rule r p h r    satisfied
  thus  show that  rule r p h r   m   literal
b r  false respect either      antimonotone  literal b  r 
false respect        monotone  literal b  r  false respect
   m    end  enough prove    m     holds 
definition        m      m    m     m   consistency
 m disjoint  moreover    m   subset  
simplifying    last two sentences  obtain    m      

give characterizations answer sets lpa
m a programs 
theorem    total model answer set lpa
m a program p
unfounded free 
   

fiunfounded sets well founded semantics asp programs aggregates

proof     prove contrapositive  total model lpa
m a program p
unfounded free  answer set p  lemma     since total
interpretation unfounded free  exists unfounded set x p
respect x   x  
    therefore  prove answer

set p  next show  x model p  x  
end  consider rule r p   definition   reduct  literals b r  true
respect   h r    model p p p 
consider two cases 
   h r    x   case  h r   x well 
   h r  x   case  since x unfounded set p respect   either
    literal b  r  false respect       literal b  r  false
respect  x   previous considerations  since r p       cannot hold 
conclude literal b r  false respect  x  
hence  r satisfied  x either head  in case h r    x   
body  in case h r  x    done 
   prove contrapositive  total model lpa
m a program p
answer set p  unfounded free  since model p p
answer set p  exists total model n p n       next show
    n   unfounded set p respect   is  rule r p
h r      n     either      antimonotone  literal b  r  false respect
       monotone  literal b  r  false respect   m     n     
start showing   m     n       n   definition   a    m     n      
 m    m     n        m     n      n      b     m     n      
n     moreover  since n total interpretations n        c 
n  d    m     n       n     thus  using  b   d   a  obtain
  m     n       n    n  m    observing  n  m     n
holds  c   conclude  e    m     n       n   n   n  
consider rule r p h r      n     deal two cases 
   r p   p   case  definition    must literal b r 
false respect   antimonotone literal      holds  otherwise 
monotone literal false respect n well  since n   thus 
    holds  e  
   r p   case  since n model p h r  false respect n
 because h r      n   assumption   must literal b r 
false respect n   antimonotone literal  false respect
well  since n       holds  otherwise  monotone literal
    holds  e  

ready state important connection answer sets unfounded
sets 
theorem    total interpretation lpa
m a program p answer set p
gu sp  m      m  
   

fialviano  calimeri  faber  leone    perri

proof     let answer set p  lemma      m unfounded set p
respect   hence gu sp  m    m   theorem     unfounded free 
hence gu sp  m    m total  sum  gu sp  m      m  
   let total interpretation gu sp  m      m   gu sp  m    
 m disjoint  unfounded free  moreover  corollary    gu sp  m    
unfounded set p respect so  applying lemma     conclude
model p  order apply theorem     m unfounded free
model p  conclude answer set p 

following theorem shows answer sets lpa
m a programs exactly total
fixpoints well founded operator defined section   
theorem    let total interpretation lpa
m a program p 
answer set p fixpoint well founded operator wp  
proof     let answer set p  want show fixpoint wp  
is  wp  m       aim show tp  m        gu sp  m      
since answer set  applying theorem     obtain gu sp  m      m  
equivalent  gu sp  m       therefore  remains prove tp  m        
   consider atom tp  m    definition    rule r p
h r    literals b r  true respect   thus    holds
model p 
   consider atom     since answer set p  apply theorem   
conclude unfounded free  hence   singleton  set     
unfounded set p respect   thus  definition    rule
r p h r    neither      antimonotone  literal b  r 
false respect        monotone  literal b  r  false respect
     since total interpretation  neither         equivalent
 i   antimonotone  literals b  r  true respect    ii 
 monotone  literals b  r  true respect      observing
      state  ii  implies  monotone  literals
b  r  true respect well  combining latter statement  i 
obtain literals b r  true respect   tp  m  
definition   
   let total fixpoint wp   i e   wp  m       thus     gu sp  m  
definition    answer set p theorem    

observe theorem    generalization theorem     van gelder et al        
class lpa
m a programs  worth noting wp  i  extends preserving
correctness  contained answer set   wp  i  may add literals
  never introduces literal would inconsistent  
proposition    let interpretation lpa
m a program p  let
answer set p    wp  i   
   

fiunfounded sets well founded semantics asp programs aggregates

proof  trivial consequence monotonicity operator wp  theorems   
theorem     indeed  theorems    wp implies wp  i  wp  m   
wp  m     theorem    

next show well founded model lpa
m a program contained
answer sets  if any  p  would point due theorem    section  
 showing equivalence well founded operators defined work one
defined pelov et al         propositions          ferraris        showing
equivalence answer sets faber et al        stable models pelov et al         
following results hold virtue definitions well founded stable
semantics work pelov et al   particular due proposition     paper 
nevertheless provide proof using concepts defined earlier 

theorem    let p lpa
m a program  answer set p  wp     

proof  let answer set p  note wp    limit sequence w     
wn   wp  wn     show wn induction n  base case trivially
true since w    definition  assume wn order show wn    
since wn     wp  wn   definition wn induction hypothesis  apply
proposition    conclude wn    

theorem suggests another property well founded semantics lpa
m a programs 
property   well founded semantics lpa
m a programs approximates answer set
semantics  well founded model contained intersection answer sets  if
any  
combining theorem    theorem     obtain following claim 

corollary    let p lpa
m a program  wp    total interpretation 
unique answer set p 

therefore  combining theorem   corollary above  obtain another property
well founded semantics lpa
m a programs 
property   stratified lpa
m a programs  well founded model coincides
unique answer set 

   complexity well founded semantics
complexity analysis carried section  consider ground programs
polynomial time computable aggregate functions  note example aggregate functions
appearing paper fall class   however  eventually provide discussion
results change considering non ground programs  start important
property monotone antimonotone aggregate literals 
   

fialviano  calimeri  faber  leone    perri

lemma    let partial interpretation ground lpa
m a program p  define
two total interpretations p follows  imin     bp   i  imax    bp    i  
 ground  aggregate literal occurring p  following statements hold 
   monotone literal  true  resp  false  respect
true respect imin  resp  false respect imax   
   antimonotone literal  true  resp  false  respect
true respect imax  resp  false respect imin   
proof  start noting imin  resp  imax   total interpretation extending
standard atoms undefined respect false
respect imin  resp  true respect imax    thus     imin imax  
monotone true respect imin  resp  false respect imax    true
 resp  false  respect     antimonotone true respect
imax  resp  false respect imin    true  resp  false  respect
    end proof observing true  resp  false  respect
i  true respect imin imax definition 

ready analyze computational complexity well founded semantics
lpa
m a programs  analysis lead prove following fundamental property 
property   well founded model ground lpa
m a program efficiently  polynomialtime  computable 
given corollary     property follows theorem     work pelov
et al          following  provide alternative proof based concepts
defined earlier paper  leads several interesting intermediate results 
property   trivial aggregates may easily increase complexity
evaluation  indeed  even deciding truth aggregate respect partial interpretation intractable general  similar observation already made pelov
        however  task polynomial time computable aggregate literals occurring lpa
m a programs 
proposition    deciding whether ground aggregate literal true  resp  false 
respect partial interpretation is 
 a  co np complete general 
 b  polynomial time computable either monotone antimonotone literal 
proof   a  membership  consider complementary problem  is 
deciding whether ground aggregate literal true  resp  false  respect
partial interpretation i  prove belongs np  order show
true  resp  false  respect enough find total interpretation j
extending  that is  j i  false  resp  true  respect j  thus 
guess j check falsity  resp  truth  respect j polynomial
   

fiunfounded sets well founded semantics asp programs aggregates

time  if aggregate function computed polynomial time respect size
input multiset  assuming  
hardness  first consider problem checking truth aggregate provide polynomial time reduction tautology  tautology
problem co np complete stated follow  given proposition formula
variables x            xn   truth assignment v variables x            xn satisfy
formula   without loss generality  assume   dnf formula form
  d  dm  

disjunct di conjunction  i  i  i   ji positive negative
literal  note that  context tautology  term literal denotes variable
xk variable preceded negation symbol    given   consider
partial interpretation      construct aggregate literal    sum s    
contains two groups elements  elements first group represent disjuncts

h      i      i      i  i 
              
where               j                 propositional atom  ji   defined
follows 

j
xk positive literal xk   k             n  
j
 i    
f
xk ji negative literal xk   k             n  
elements second group represent variables follows 

h   


h  
h  



h   

xk  
xk   xtk
 
xk   xfk
xk   xtk   xfk

k              n  

xk xk constants associated variable xk   note that  variable
xk   two atoms a  xtk xfk   thus  interpretation j  four cases
possible 
     not xtk   xfk   j  case  h   xk   contribute evaluation
a  contribution   
     xtk   xfk   j  case  four elements contribute evaluation a 
thus contribution              note h   xk   xtk h   xk   xfk
give total contribution   pure set approach  
     xtk   xfk   j  case  h   xk   h   xk   xtk contribute  giving
        
     not xtk   xfk   j  case  h   xk   h   xk   xfk contribute  giving
        
   

fialviano  calimeri  faber  leone    perri

thus  k             n   total contribution four elements associated
variable xk either      note total contribution elements
 i e   first group  either      therefore  k             n 
either case         occurs  interpretation j trivially satisfies a  otherwise  j
that  variable k             n   either         occurs  case  say
j good interpretation 
next define one to one mapping set assignments set
good interpretations  let v assignment   good interpretation iv associated
v iv

f
 xtk   xk   iv v xk      
 
k              n  

f

 not xk   xk   iv v xk      
want show v satisfies true respect iv   since iv
good interpretation  elements second group give total contribution   
consider elements first group  elements give
contribution      i      i      i    holds least one             n  
holds v di       holds disjunct di   conclude
true respect iv v       
concerning check falsity aggregate  start   dnf formula
construct aggregate literal    sum s       obtained described
above  tautology false respect      
 b  let partial interpretation lpa
m a program p aggregate literal
occurring p  want show deciding whether true  resp  false  respect
done polynomial time size bp   lemma     enough evaluate
aggregate respect either imin     bp   i  imax    bp    i  
end proof observing interpretations imin imax constructed
polynomial time  value aggregate function computed
polynomial time respect size input multiset assumption 

order prove tractability well founded semantics need efficient
method computing greatest unfounded set  part well founded operator
wp   hence  next give polynomial time construction set bp  gu sp  i  means
monotone operator 
definition   let interpretation lpa
m a program p  operator  
b
b
p
p
defined follows 
   
 y       bp   r p h r   
 antimonotone  literal b  r  false respect i 
 monotone  literals b  r  true respect    i  
least fixpoint coincides greatest unfounded set p respect
i 
theorem    let p lpa
m a program interpretation p  then 
   

fiunfounded sets well founded semantics asp programs aggregates

   operator least fixpoint    
   gu sp  i    bp      
proof  operator monotonically increasing operator meet semilattice
hbp   i  therefore admits least fixpoint     tarski         next prove
gu sp  i    bp      two steps 
   first observe    computed iteratively  starting empty set 
limit sequence f      fi      fi    thus  prove induction
gu sp  i  bp  fi holds  base case trivial  since f    definition
gu sp  i  subset bp definition    assume gu sp  i  bp  
order prove gu sp  i  bp   fi     since gu sp  i  unfounded set p
respect theorem    definition   that  gu sp  i 
rule r p h r      either      antimonotone  literal
b  r  false respect i       monotone  literal b  r  false
respect  gu sp  i   want show belong fi    
is  rule r either  i   antimonotone  literal
b  r  false respect i   ii   monotone  literal b  r  true
respect    i  recall fi      fi   definition   since      i 
equals  show     implies  ii   end  assume
 monotone  literal b  r  false respect  gu sp  i  
aim show false respect j    fi    i     bp    fi    i    
since case would true respect    i  see lemma     
start proving  i  gu sp  i      gu sp  i  subset j  
observe j     bp    fi    i        bp      i
subset bp   thus  since gu sp  i  bp   induction hypothesis  obtain
 i  gu sp  i      gu sp  i    bp       j   since j total 
 i  gu sp  i   j implies extension k  gu sp  i 
k j k   j  for example  one containing true
standard positive literals undefined respect  gu sp  i    since
false respect  gu sp  i  assumption k extension
 gu sp  i   false respect k remark    thus  since j k
monotone  latter implies false respect j well 
   prove bp      unfounded set p respect i  is 
r p h r  bp       either      antimonotone  literal b  r 
false respect i       monotone  literal b  r  false respect
  bp        definition    h r       implies either  i 
 antimonotone  literal b  r  false respect i   ii   monotone 
literal b  r  true respect       i   since  i      equals 
show  ii  implies      end  assume  monotone 
literal b  r  true respect       i   thus 
extension       i false  particular must false
respect j    i       i     bp    i       i    lemma    
observe  i   bp            bp  i         bp   i     i     
   

fialviano  calimeri  faber  leone    perri

j holds  because  i bp     i   bp         j   j total 
combining last two sentences obtain   bp       j  therefore 
since monotone literal false respect j  latter implies
false respect   bp       well      holds 

eventually  property   consequence following theorem  mentioned earlier 
theorem follows theorem     work pelov et al        
corollary     proof provided differs considerably one theorem    
work pelov et al 
theorem    given lpa
m a program p 
   greatest unfounded set gu sp  i  p respect given interpretation
polynomial time computable 
   wp    polynomial time computable 
proof       theorem     gu sp  i    bp       next show   
efficiently computable  fixpoint    limit sequence       k  
 k     limit reached polynomial number applications
new element sequence k must add least new atom  otherwise limit
already reached   is   bp    show application feasible
polynomial time  conclude computable polynomial time  step
processes rules once  rule checks truth value
body literals once  check truth valuation clearly tractable standard
 i e   non aggregates  literals  tractability check aggregate literals stems
proposition     deal monotone antimonotone aggregate atoms only 
conclusion  computable polynomial time  gu sp  i  tractable well since
obtainable bp      
     argumentation carried     show wp    computed
number steps polynomial  actually linear   bp    indeed  step
polynomial time computable  proved tractability gu sp  i   tp
polynomial time computable well 

result positive impact computation answer set semantics
logic programs aggregates  indeed  stated theorem     wp    approximates
intersection answer sets  if any  bottom  therefore used
efficiently prune search space  worthwhile noting computation
well founded semantics hard polynomial time  particular  deciding whether
 ground  atom true respect well founded semantics p complete 
task p hard even standard well founded semantics aggregate free programs  and 
proposition    semantics coincides standard well founded aggregatefree programs  
end section briefly addressing complexity non ground programs 
considering data complexity  i e   lpa
m a program p fixed input consists
facts   results propositional programs  deciding whether  ground  atom
true respect well founded semantics non ground program p complete 
   

fiunfounded sets well founded semantics asp programs aggregates

data complexity  van gelder et al          however  program complexity  i e  
lpa
m a program p given input  considered  complexity reasoning rises exponentially  indeed  non ground program p reduced  naive instantiation  ground
instance problem  general size ground p  single exponential
size p  complexity reasoning increases accordingly one exponential  p
exptime  result derived using complexity upgrading techniques  eiter 
gottlob    mannila        gottlob  leone    veith        

   compilation standard lp  implementation experimental
results
well founded semantics lpa
m a programs implemented extending
dlv system  leone et al          section briefly describe implemented
prototype report results experiments aimed assessing efficiency 
note that  even lpa
m a programs replaced equivalent lp programs  for
rewriting strategy see section     below   experimental results highlight significant
performance advantage lpa
m a encodings 
    compilation standard logic programming
section briefly present strategy representing  count   sum  times
standard constructs   compilation spirit one introduced  min
 max alviano  faber  leone        defines subprogram computing
value  possibly recursive  aggregate  compilation takes account specific properties monotone antimonotone aggregate functions  therefore referred
monotone antimonotone encoding  mae  
monotone antimonotone encoding lpa
m a program p obtained replacing
aggregate literal   f  s  new predicate symbol f   predicate f defined
means subprogram  i e   set rules  thought compilation
standard lp  compilation uses total order   elements    
symbol occurring p   u u   assume
presence built in relation       y            yn   y            yn
lists terms  built in relation   precedes
lexicographical order induced    moreover  use built in relation  
true either       simplicity  let us assume
form f   y   p y   z    k  z lists local variables k
integer constant  aggregate  introduce new predicate symbol faux arity
 y       rules modeling atom faux  y  s  must true whenever value
f   y   p y   z   y   least s  thus  use fact representing value
aggregate function empty set  rule increasing value larger sets 
lexicographical order induced   used guarantee elements set
   since considering monotone antimonotone aggregate literals  domains  sum
 times assumed n n    respectively 

   

fialviano  calimeri  faber  leone    perri

user interface

diagnosis
frontend

inheritance
frontend

sql 
frontend

planning
frontend

dlv core
ground
program

intelligent
grounding

model
checker

model
generator

file
system

relational
database

filtering

output

figure    prototype system architecture 
considered once  particular  following rules introduced 

faux      
           f    count 
         y  f    sum 

faux  y   x    faux  y   s   p y   z  

       y  f    times 
    x    
       truth aggregate f   y   p y   z    k must inferred
atom faux  y  s  k true  aspect modeled means
following rules 
fk   faux  y   s   k 

f k   faux  y   s     k 

  instead  truth aggregate f   y   p y   z    k must inferred
atoms faux  y  s    k false  and similar     aspects
modeled means following rules 
fk   f k  

f k   fk  

extending technique aggregate literals global variables quite simple 
global variables added arguments atoms used compilation 
new predicate fgroupby used collecting possible substitutions 
    system architecture usage
extended dlv implementing well founded operator well founded
semantics lpa
m a programs described paper  architecture prototype
   

fiunfounded sets well founded semantics asp programs aggregates

reported figure    detail  modified two modules dlv  intelligent grounding
module model generator module  prototype  well founded semantics
adopted one  wf   well founded specified command line  otherwise 
stable model semantics adopted usual  well founded operator wp introduced
section   used semantics  particular  stable model semantics 
well founded model profitably used pruning search space  well founded
semantics  well founded model printed computation least fixpoint
well founded operator  case output system consists two sets 
representing true undefined standard atoms well founded model  binary
prototype available http   www dlvsystem com dlvrecaggr  
    experimental results
knowledge  implemented prototype currently system supporting
well founded semantics logic programs recursive aggregates  certain special
cases  well founded model total  well founded model coincides
semantics answer sets  see corollary     theses cases systems supporting
semantics idp  wittocx  marien    denecker         smodels  simons et al  
       clasp  gebser  kaufmann  neumann    schaub         used compute
well founded model 
however interested systems able compute well founded model
input programs  one major systems supporting well founded semantics 
xsb  swift   warren         support aggregates   apart  min
 max  xsb support recursive aggregates  i e   aggregates occurring recursive
definitions   therefore  experiments designed investigating computational behavior aggregate constructs respect equivalent encodings without
aggregates 
specifically  introduce attacks problem  inspired classic
win lose problem often used context well founded semantics standard
logic programs  study performance it 
definition    attacks problem  attacks problem  set p players positive integer given  player attacks n players  player wins
winners attack it  kind problem frequently present turn based strategy
games 
note definition winner recursive and  particular  recursive aggregate
natural way encoding problem 
example    instance attacks problem p      n         could
following 
player attacks players b c 

player attacks players b f  

player b attacks players c 

player e attacks players c f  

player c attacks players b 

player f attacks players e 

   

fialviano  calimeri  faber  leone    perri

b





f

e

c

figure    instance attacks problem   players  one attacking  
players 

graphical representation instance shown figure    since attacked
f   conclude winner  similarly e  therefore  f winner
f attacked e  winners  players  namely a  b c 
cannot determine winner not 
experiments  instances attacks encoded means predicates max 
player attacks representing parameter m  set players attacks
players  respectively  consider three equivalent encodings attacks problem 
      aggregate based encoding
encoding natural representation attacks problem lp
m a   complete
encoding consists single rule  reported below 
win x    max m    player x    count y   attacks y  x   win y    m 

      join based encoding
equivalent encoding obtained computing number joins proportional
m  tested encoding reported below 
win x    player x   lose x  
lose x    max     attacks y    x   win y    
attacks y    x   win y     y    y   
lose x    max     attacks y    x   win y    
attacks y    x   win y     y    y   
attacks y    x   win y     y    y    y    y   
lose x    max          

note encoding rule possible value parameter m 
however  one rules considered solver program instantiation 
fact  rule instantiated  contains instance atom max m 
fact present  rules satisfied false body literal 
   

fiunfounded sets well founded semantics asp programs aggregates

  

   

dlv join

dlv

  

   

  

   

  

   

  

   

 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

  
  



 

 

 

 

x

 a      players

 

 

   

 

 

 

 

 

 

 

  



 b      players

   

   

   

   

   

   

   

   

   

   

   
  

 

 

 

 

 

 

x

 

 

 

   

 

 

 

 

 

 

 

 

  

   
  



 

 

 
x

 c      players

 

 

 

 

   

 

 

 

 

 

 

 

 

  



 d      players

figure    attacks  average execution time dlv running aggregate based encoding
dlv running join based encoding 

      mae based encoding
encoding obtained applying compilation presented section    
minor simplifications  full encoding reported below 
win x    player x   lose x  
lose x    count x  y  s   max m      m 
count x  y       aux x    
count x        count x  y  s   aux x               
aux x      attacks y  x   win y   

intuitively  atom count x  y  s  stands least constants
attacks y   x   win y   true  note rules defining predicate count use
natural order integers guarantee counted once 
example    instance shown figure   represented means following facts 
player a  
attacks a  b  
attacks a  c  
max    

player b  
attacks b  a  
attacks b  c  

player c  
attacks c  a  
attacks c  b  

player d  
attacks d  b  
attacks d  f   

   

player e  
attacks e  c  
attacks e  f   

player f   
attacks f  d  
attacks f  e  

fialviano  calimeri  faber  leone    perri

 

  

xsb join

dlv

 
 

 
 
 

 

 

 

 

 

 
 

 
 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
 
  



 

 

 

 

x

 e      players

 

 

   

 

 

 

 

 

 

 

  



 f      players

 

  

 

  

 
 

 

 

 

 
 

 

 
 
  

 

 

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
  



 

 

 
x

 g      players

 

 

 

 

   

 

 

 

 

 

 

 

 

  



 h      players

figure    attacks  average execution time dlv running aggregate based encoding
xsb running join based encoding 

encodings  well founded model restricted win predicate  win d  
win e   win f     note win a   win b  win c  neither true false 
undefined 
      discussion
performed intensive experimentation benchmark varying parameters
p  n  combination parameters  measured average execution
time dlv xsb  version        randomly generated instances  experiments
r
r
performed  ghz intel
xeon
processor system  gb ram
debian     operating system gnu linux        kernel  dlv prototype used
compiled gcc        every instance  allowed maximum running
time     seconds     minutes  maximum memory usage  gb 
results experimentation reported figures     graphs  dlv
implemented prototype aggregate based encoding  dlv join dlv mae
implemented prototype aggregate free encodings  xsb join xsb mae
xsb system aggregate free encodings  as mentioned earlier  xsb support
   

fiunfounded sets well founded semantics asp programs aggregates

dlv mae

dlv
 

  

 

  

 

 

 

 

 

 

 
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

  

 
  



 

 

 

 

 

x

 i       players

 

 

   

 

 

 

 

 

 

 

 

  



 j       players

  

  
  

  

  
  
  
  
  
 
  

 

 

 
x

 

 

 

 

   

 

 

 

 

 

 

 

 

  

  
  



 

 

 
x

 k       players

 

 

 

 

   

 

 

 

 

 

 

 

 

  



 l        players

figure    attacks  average execution time dlv running aggregate based encoding
dlv running mae based encoding 

recursive aggregates   xsb system  explicitly set indices tabled predicates
optimizing computation 
graph  number players fixed  parameters  x axis  n
 y axis  vary  therefore  size instances grows moving left right along
y axis  invariant respect x axis  however  number joins
required join based encoding depends parameter m  matter fact 
observe graphs figures    average execution time join based
encoding increases along x  y axis  for dlv xsb   instead 
encoding using aggregates  mae based encoding  average execution time
depends instance sizes  shown graphs figures    
join based encoding  xsb generally faster dlv  consumes much
memory  indeed  figure    observe xsb terminates computation
seconds smallest instances  rapidly runs memory slightly larger
instances  considering mae based encoding  observe significant performance
gains dlv xsb  see figures      indeed  systems complete computation allowed time memory larger instances  computational advantages
mae based encoding respect join based encoding particularly evident
   

fialviano  calimeri  faber  leone    perri

xsb mae

dlv
   

 
 

 

 
   

 

 

 

   

 
 

 
   
  

 

 

 

 

 

x

 

 

   

 

 

 

 

 

 

 

 

 

  

 
  



 

 

 

 

 

x

 m       players

 

 

   

 

 

 

 

 

 

 

 

  



 n        players

  

   
   

  

   
  

   

  

   
   

  
  
  

 

 

 
x

 

 

 

 

   

 

 

 

 

 

 

 

 

   

  

  
  



 

 

 
x

 o        players

 

 

 

 

   

 

 

 

 

 

 

 

 

  



 p        players

figure    attacks  average execution time dlv running aggregate based encoding
xsb running mae based encoding 

xsb  solved tested instances encoding  however  xsb
mae based encoding outperformed dlv native support aggregate constructs
 see figure    
sum  experimental results highlight presence aggregate constructs
significantly speed up computation  indeed  encoding using recursive aggregates
outperforms aggregate free encodings tested instances 

   related work
defining well founded semantics logic programs aggregates challenge
major interest last years  first attempts  relying notion unfounded
set  defined restricted language  discussed kemp
stuckey         another semantics falling class one introduced van gelder
        subsequently generalized osorio jayaraman         main problem
semantics often leave many undefined literals  shown ross
sagiv        
   

fiunfounded sets well founded semantics asp programs aggregates

first attempt define well founded semantics unrestricted lpa done
kemp stuckey         semantics based notion unfounded sets  according
kemp stuckey  set x standard atoms unfounded set  ground  program
p respect interpretation if  rule r p h r  x   either  a 
literal b r  false respect i   b  b r  x  
    note standard
literals considered condition  b   aggregates covered it  point
definition unfounded set makes semantics inadequate programs
recursive aggregates  even monotone aggregates considered  example 
program  a     count x   a x          well founded model work kemp
stuckey   reasonable well founded semantics identify a    false 
pelov et al         defined well founded semantics based approximating operators 
namely d well founded semantics  extends standard well founded semantics  indeed  coincide aggregate free programs  detail  work aggregates
evaluated one three possible ways  therefore  family semantics defined
pelov et al   ordered precision  precise three valued aggregates lead
precise semantics  general  higher precision comes price higher computational complexity  authors discuss following three valued aggregate relations
evaluation aggregate literals  trivial  bound ultimate approximating aggregates  first less precise  last precise  semantics relying
trivial approximating aggregates imprecise  still suitable class
stratified aggregate programs  trivial bound approximations polynomial
complexity  ultimate shown intractable nonmonotone aggregate
functions  pelov         detailed comparison results presented section     
ferraris        showed semantics smodels programs positive weight
constraints equal answer sets defined faber et al         respective
fragment  since theorem    wp    approximates answer sets defined faber et al  
wp    used approximating operator respective smodels programs 
indeed  shown atmost pruning operator smodels  simons et al        
special case operator  defined proof theorem     
works attempted define stronger notions well founded semantics  also
programs aggregates   ultimate well founded semantics  denecker et al  
       wfs  wfs   dix   osorio         whether characterization
semantics terms unfounded sets exist semantics unclear left
future research 
concerning compilations lp programs standard lp  transformation provided van gelder         compilation presented section     differs
one introduced van gelder several respects  approach uses total order
universe input program takes advantage character monotonicity antimonotonicity aggregate literals input program  transformation
defined van gelder uses uninterpreted function symbols representing ground sets 
recursive negation checking truth aggregate literals  briefly discuss aspects following  roughly  aggregate f  s  k  uninterpreted function symbols
used transformation work van gelder determining pairs   k
ground set associated k   f  s    that  transformation defined van gelder checks whether exists pair   k satisfying following
   

fialviano  calimeri  faber  leone    perri

conditions   i  every element hconsts   conji   conj true   ii  k k holds 
point condition  i  requires recursive negation order checked  indeed 
equivalent element hconsts   conji conj true 
aspect transformation undesirable side effect  stratified lpa
m a programs
may partial well founded models  is  theorem   hold programs compiled transformation introduced van gelder  example side effect
given van gelder  shown transformation possibly leads partial
well founded models instances company controls  well known problem
modeled using monotone recursive aggregates 
    comparison work pelov et al        
section report detailed comparison well founded semantics defined
paper one pelov et al          recall pelov et al  defines wellfounded stable semantics least total fixpoints three valued stable
model operator extended aggregate programs 
start observing evaluation ultimate approximating aggregates coincides
evaluation aggregates defined article  evaluation bound approximating aggregates coincides monotone antimonotone aggregates  as consequence
lemma    paper proposition      work pelov et al         
let us introduce translation aggregate literal formula standard
literals   partial  interpretation i  let conj i  denote conjunction literals
i  translation trm a  ground aggregate literal defined follows 
w
trm a     conj i    subset minimal interpretation
true respect i 
note that   partial  interpretation j  evaluation respect j coincides
evaluation trm a  respect j  proposition   proposition  
work pelov et al          moreover  monotone  resp  antimonotone  aggregate literal
a  positive  resp  negative  literals appear trm a  
rule r ground lpa
m a program p aggregate literal b r  
translation trm p  r  a  r program obtained p removing r
adding rule r h r     h r  b r     b r     a  conj 
conj trm a   therefore  full translation trm p  p defined recursive
application trm p  r  a   note order rules aggregates processed
relevant   next show p trm p  unfounded sets 
lemma    set atoms x unfounded set program p respect
interpretation x unfounded set trm p  respect i 
proof  use induction number aggregate literals p  p aggregate
literals  p   trm p   consider program p rule r p aggregate
literal b r   want show set x atoms unfounded set p
respect x unfounded set trm p  r  a  respect i  since
case might apply induction hypothesis prove claim  thus 
end proof means following observations   i  false respect
   

fiunfounded sets well founded semantics asp programs aggregates

interpretation j trm a  false respect j  is 
conjunction conj trm a  literal conj false respect
j   ii  positive  resp  negative  standard literal monotone
 resp  antimonotone  

prove well founded operators p trm p  coincide 
lemma    let p lpa
m a program interpretation p  wp  i   
wtrm p   i  
proof  show     tp  i    ttrm p   i      gu sp  i    gu strm p   i  
note     immediately follows lemma     order prove      consider
aggregate literal occurring p  previous considerations  true
respect conjunct trm a  true respect
i  thus      holds 

ready relate well founded operator one provided pelov
et al         
theorem    class lpa
m a programs  well founded operator herein defined
coincides one pelov et al         ultimate bound approximating
aggregate semantics   
proof  lemma     already know wp  i    wtrm p   i  
wtrm p   i  coincides one work van gelder et al         theorem  
 since trm p  standard logic program   hand  ultimate
bound approximating aggregate semantics  well founded operators  as defined pelov
et al         p trm p  coincide  consequence theorem   work
pelov et al          three valued immediate consequence operators work
pelov et al         pelov et al         coincide  see definition   pelov et al       
definition     pelov et al          moreover  well founded operator pelov et al 
       coincides one work van gelder et al  standard logic programs 
thereby obtaining equality operators 

correspondence two well founded semantics immediately follows
theorem above  indeed  two well founded models defined fixpoints
respective well founded operators 
corollary    well founded model herein defined one pelov et al        
ultimate bound approximating aggregate semantics  coincide lpa
m a
programs 
mentioned earlier  virtue theorem corollary 
results presented paper follow earlier results literature  particular 
theorem    theorem    complexity results follow definitions
results pelov        pelov et al         
   note operator referred stable revision operator pelov et al         

   

fialviano  calimeri  faber  leone    perri

   conclusion
paper introduced new notion unfounded set lpa
m a programs analyzed
well founded semantics language based notion  semantics generalizes
traditional well founded semantics aggregate free programs coincides
well founded semantics aggregate programs defined pelov et al         latter
defined means notion unfounded set   could show
semantics main operator wp close ties answer sets defined faber
et al                hence serve approximations 
proved computing semantics tractable problem  indeed  semantics
given least fixpoint well founded operator wp   fixpoint reached
polynomial number applications operator wp  with respect size input
program   requiring polynomial time  showing application wp
polynomial time feasible  proved evaluating monotone antimonotone
aggregate literals remains polynomial time computable partial interpretations  since
case one possibly exponential extensions must checked  monotone
aggregate literal  extension obtained falsifying undefined literal 
antimonotone aggregate literal  undefined literal taken true extension 
motivated positive theoretical results  implemented first system
supporting well founded semantics unrestricted lpa
m a   allowing using monotone
antimonotone aggregate literals  implemented prototype ready experimenting
lpa
m a framework  experiments conducted attacks benchmark highlight
computational gains native implementation aggregate constructs respect
equivalent encodings standard lp 

acknowledgments
partly supported regione calabria eu por calabria fesr           within
pia project dlvsystem s r l   miur prin project loden
pon project frame proposed atos italia s p a   thank
anonymous reviewers valuable comments 

references
alviano  m   faber  w     leone  n          compiling minimum maximum aggregates
standard asp  formisano  a   ed    proceedings   rd italian conference
computational logic  cilc       
baral  c          knowledge representation  reasoning declarative problem solving 
cambridge university press 
brewka  g          well founded semantics extended logic programs dynamic
preferences  journal artificial intelligence research          
calimeri  f   faber  w   leone  n     perri  s          declarative computational
properties logic programs aggregates  nineteenth international joint
conference artificial intelligence  ijcai      pp         
   

fiunfounded sets well founded semantics asp programs aggregates

dellarmi  t   faber  w   ielpa  g   leone  n     pfeifer  g          aggregate functions
dlv  de vos  m     provetti  a   eds    proceedings asp     answer set
programming  advances theory implementation  pp          messina  italy 
online http   ceur ws org vol     
denecker  m   pelov  n     bruynooghe  m          ultimate well founded stable
model semantics logic programs aggregates  codognet  p   ed    proceedings   th international conference logic programming  pp         
springer verlag 
dix  j     osorio  m          well behaved semantics suitable aggregation 
proceedings international logic programming symposium  ilps      port jefferson  n y 
eiter  t   gottlob  g     mannila  h          disjunctive datalog  acm transactions
database systems                 
faber  w          unfounded sets disjunctive logic programs arbitrary aggregates  baral  c   greco  g   leone  n     terracina  g   eds    logic programming nonmonotonic reasoning  th international conference  lpnmr   
diamante  italy  september       proceedings  vol       lecture notes computer science  pp        springer verlag 
faber  w   leone  n     pfeifer  g          recursive aggregates disjunctive logic programs  semantics complexity  alferes  j  j     leite  j   eds    proceedings
 th european conference artificial intelligence  jelia        vol      
lecture notes ai  lnai   pp          springer verlag 
faber  w   leone  n     pfeifer  g          semantics complexity recursive aggregates
answer set programming  artificial intelligence                   special issue 
john mccarthys legacy 
ferraris  p          answer sets propositional theories  baral  c   greco  g   leone 
n     terracina  g   eds    logic programming nonmonotonic reasoning  th
international conference  lpnmr    diamante  italy  september       proceedings 
vol       lecture notes computer science  pp          springer verlag 
ferraris  p          logic programs propositional connectives aggregates  acm
transactions computational logic          press 
gebser  m   kaufmann  b   neumann  a     schaub  t          conflict driven answer
set solving  twentieth international joint conference artificial intelligence
 ijcai      pp          morgan kaufmann publishers 
gelfond  m          representing knowledge a prolog  kakas  a  c     sadri  f 
 eds    computational logic  logic programming beyond  vol       lncs  pp 
        springer 
gelfond  m     lifschitz  v          classical negation logic programs disjunctive
databases  new generation computing            
gottlob  g   leone  n     veith  h          succinctness source expression complexity  annals pure applied logic                  
kemp  d  b     stuckey  p  j          semantics logic programs aggregates 
saraswat  v  a     ueda  k   eds    proceedings international symposium
logic programming  islp     pp          mit press 
   

fialviano  calimeri  faber  leone    perri

leone  n   pfeifer  g   faber  w   eiter  t   gottlob  g   perri  s     scarcello  f         
dlv system knowledge representation reasoning  acm transactions
computational logic                
liu  l   pontelli  e   son  t  c     truszczynski  m          logic programs abstract
constraint atoms  role computations  artificial intelligence                   
liu  l     truszczynski  m          properties applications programs monotone
convex constraints  journal artificial intelligence research             
manna  m   ruffolo  m   oro  e   alviano  m     leone  n          hilex system
semantic information extraction  transactions large scale data knowledgecentered systems  springer berlin heidelberg  appear 
manna  m   ricca  f     terracina  g          consistent query answering via asp
different perspectives  theory practice  theory practice logic programming  appear 
marek  v  w     truszczynski  m          logic programs abstract constraint atoms 
proceedings nineteenth national conference artificial intelligence  aaai
       pp        aaai press   mit press 
mccarthy  j          programs common sense  proceedings teddington
conference mechanization thought processes  pp        majestys
stationery office 
mccarthy  j          circumscription form non monotonic reasoning  artificial
intelligence                
mccarthy  j          applications circumscription formalizing common sense
knowledge  artificial intelligence                
mccarthy  j          formalization common sense  papers john mccarthy edited
v  lifschitz  ablex 
mccarthy  j     hayes  p  j          philosophical problems standpoint
artificial intelligence  meltzer  b     michie  d   eds    machine intelligence   
pp          edinburgh university press  reprinted  mccarthy        
mcdermott  d  v          non monotonic logic ii  nonmonotonic modal theories  journal
acm               
mcdermott  d  v     doyle  j          non monotonic logic i  artificial intelligence 
              
minsky  m          framework representing knowledge  winston  p  h   ed   
psychology computer vision  pp          mcgraw hill 
moore  r  c          semantical considerations nonmonotonic logic  artificial intelligence               
osorio  m     jayaraman  b          aggregation negation as failure  new generation
computing                 
pelov  n          semantics logic programs aggregates  ph d  thesis  katholieke
universiteit leuven  leuven  belgium 
pelov  n   denecker  m     bruynooghe  m          translation aggregate programs
normal logic programs  de vos  m     provetti  a   eds    proceedings asp  
  answer set programming  advances theory implementation  pp       
messina  italy  online http   ceur ws org vol     
   

fiunfounded sets well founded semantics asp programs aggregates

pelov  n   denecker  m     bruynooghe  m          partial stable models logic programs aggregates  proceedings  th international conference logic
programming non monotonic reasoning  lpnmr     vol       lecture notes
ai  lnai   pp          springer 
pelov  n   denecker  m     bruynooghe  m          well founded stable semantics
logic programs aggregates  theory practice logic programming        
       
pelov  n     truszczynski  m          semantics disjunctive programs monotone
aggregates   operator based approach  proceedings   th international
workshop non monotonic reasoning  nmr        whistler  bc  canada  pp 
       
reiter  r          logic default reasoning  artificial intelligence                 
ricca  f   alviano  m   dimasi  a   grasso  g   ielpa  s  m   iiritano  s   manna  m    
leone  n          logic based system e tourism  fundamenta informaticae 
ios press                 
ricca  f   grasso  g   alviano  m   manna  m   lio  v   iiritano  s     leone  n         
team building answer set programming gioia tauro seaport  theory
practice logic programming  cambridge university press  appear 
ross  k  a     sagiv  y          monotonic aggregation deductive databases  journal
computer system sciences               
simons  p   niemela  i     soininen  t          extending implementing stable
model semantics  artificial intelligence              
son  t  c     pontelli  e          constructive semantic characterization aggregates
answer set programming  theory practice logic programming            
son  t  c   pontelli  e     tu  p  h          answer sets logic programs arbitrary
abstract constraint atoms  journal artificial intelligence research             
swift  t     warren  d  s          xsb  extending prolog tabled logic programming 
computing research repository  corr   abs           
tarski  a          lattice theoretical fixpoint theorem applications  pacific j 
math            
truszczynski  m          reducts propositional theories  satisfiability relations 
generalizations semantics logic programs  artificial intelligence                
ullman  j  d          principles database knowledge base systems  computer
science press 
van gelder  a          well founded semantics aggregation  proceedings
eleventh symposium principles database systems  pods     pp         
acm press 
van gelder  a   ross  k  a     schlipf  j  s          well founded semantics
general logic programs  journal acm                 
wittocx  j   marien  m     denecker  m          idp system  model expansion
system extension classical logic  denecker  m   ed    proceedings
 nd workshop logic search  computation structures declarative
descriptions  lash     pp         

   


