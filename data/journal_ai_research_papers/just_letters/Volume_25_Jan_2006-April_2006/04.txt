journal of artificial intelligence research                  

submitted       published     

dynamic local search for the maximum clique problem
wayne pullan

w pullan griffith edu au

school of information and communication technology 
griffith university 
gold coast  qld  australia

holger h  hoos

hoos cs ubc ca

department of computer science
university of british columbia
     main mall  vancouver  bc  v t  z  canada

abstract
in this paper  we introduce dls mc  a new stochastic local search algorithm for the maximum clique problem  dls mc alternates between phases of iterative improvement  during
which suitable vertices are added to the current clique  and plateau search  during which
vertices of the current clique are swapped with vertices not contained in the current clique 
the selection of vertices is solely based on vertex penalties that are dynamically adjusted
during the search  and a perturbation mechanism is used to overcome search stagnation 
the behaviour of dls mc is controlled by a single parameter  penalty delay  which controls the frequency at which vertex penalties are reduced  we show empirically that dlsmc achieves substantial performance improvements over state of the art algorithms for the
maximum clique problem over a large range of the commonly used dimacs benchmark
instances 

   introduction
the maximum clique problem  max clique  calls for finding the maximum sized subgraph of pairwise adjacent vertices in a given graph  max clique is a prominent combinatorial optimisation problem with many applications  for example  information retrieval 
experimental design  signal transmission and computer vision  balus   yu         more
recently  applications in bioinformatics have become important  pevzner   sze        ji 
xu    stormo         the search variant of max clique can be stated as follows  given
an undirected graph g    v  e   where v is the set of all vertices and e the set of all edges 
find a maximum size clique in g  where a clique in g is a subset of vertices  c  v   such
that all pairs of vertices in c are connected by an edge  i e   for all v  v   c   v  v     e 
and the size of a clique c is the number of vertices in c  max clique is n p hard
and the associated decision problem is n p complete  garey   johnson         furthermore  it is inapproximable in the sense that no deterministic polynomial time algorithm
can find cliques of size  v    for any       unless n p   zpp  hastad          the
best polynomial time approximation algorithm for max clique achieves an approximation ratio of o  v    log  v        boppana   halldorsson         therefore  large and hard
instances of max clique are typically solved using heuristic approaches  in particular 
   zpp is the class of problems that can be solved in expected polynomial time by a probabilistic algorithm
with zero error probability 
c
    
ai access foundation  all rights reserved 

fipullan   hoos

greedy construction algorithms and stochastic local search  sls  algorithms such as simulated annealing  genetic algorithms and tabu search   for an overview of these and other
methods for solving max clique  see bomze  budinich  pardalos    pelillo         it
may be noted that the maximum clique problem is equivalent to the independent set problem as well as to the minimum vertex cover problem  and any algorithm for max clique
can be directly applied to these equally fundamental and application relevant problems
 bomze et al         
from the recent literature on max clique algorithms  it seems that  somewhat unsurprisingly  there is no single best algorithm  although most algorithms have been empirically
evaluated on benchmark instances from the second dimacs challenge  johnson   trick 
       it is quite difficult to compare experimental results between studies  mostly because
of differences in the respective experimental protocols and run time environments  nevertheless  particularly considering the comparative results reported by grosso et al   grosso 
locatelli    croce         it seems that there are five heuristic max clique algorithms
that achieve state of the art performance 
reactive local search  rls   battiti   protasi        has been derived from reactive
tabu search  battiti   tecchiolli         an advanced and general tabu search method
that automatically adapts the tabu tenure parameter  which controls the amount of diversification  during the search process  rls also uses a dynamic restart strategy to provide
additional long term diversification 
qualex ms  busygin        is a deterministic iterated greedy construction algorithm that uses vertex weights derived from a nonlinear programming formulation of maxclique 
the more recent deep adaptive greedy search  dags  algorithm  grosso et al        
also uses an iterated greedy construction procedure with vertex weights  the weights in
dags  however  are initialised uniformly and updated after every iteration of the greedy
construction procedure  in dags  this weighted iterated greedy construction procedure is
executed after an iterative improvement phase that permits a limited amount of plateau
search  empirical performance results indicate that dags is superior to qualex ms for
most of the max clique instances from the dimacs benchmark sets  but for some hard
instances it does not reach the performance of rls  grosso et al         
the k opt algorithm  katayama  hamamoto    narihisa        is based on a conceptually simple variable depth search procedure that uses elementary search steps in which a
vertex is added to or removed from the current clique  while there is some evidence that it
performs better than rls on many instances from the dimacs benchmark sets  katayama
et al          its performance relative to dags is unclear 
finally  edge ac ls  solnon   fenet         a recent ant colony optimisation algorithm for max clique that uses an elitist subsidiary local search procedure  appears to
reach  or exceed  the performance of dags and rls on at least some of the dimacs
instances 
in this work  we introduce a new sls algorithm for max clique algorithm dubbed
dynamic local search  max clique  dls mc  which is based on a combination of constructive search and perturbative local search  and makes use of penalty values associated
with the vertices of the graph  which are dynamically determined during the search and
help the algorithm to avoid search stagnation 
   

fidynamic local search for max clique problem

based on extensive computational experiments  we show that dls mc outperforms
other state of the art max clique search algorithms  in particular dags  on a broad
range of widely studied benchmark instances  and hence represents an improvement in
heuristic max clique solving algorithms  we also present detailed results on the behaviour of dls mc and offer insights into the roles of its single parameter and the dynamic
vertex penalties  we note that the use of vertex penalties in dls mc is inspired by the
dynamic weights in dags and  more generally  by current state of the art dynamic local
search  dls  algorithms for other well known combinatorial problems  such as sat and
max sat  hutter  tompkins    hoos        tompkins   hoos        thornton  pham 
bain    ferreira        pullan   zhao         for a general introduction to dls  see also
the work of  hoos   stutzle         our results therefore provide further evidence for the
effectiveness and broad applicability of this algorithmic approach 
the remainder of this article is structured as follows  we first describe the dls mc
algorithm and key aspects of its efficient implementation  next  we present empirical performance results that establish dls mc as the new state of the art in heuristic max clique
solving  this is followed by a more detailed investigation of the behaviour of dls mc and
the factors determining its performance  finally  we summarise the main contributions of
this work  insights gained from our study and outline some directions for future research 

   the dls mc algorithm
like the dags algorithm by grosso et al   our new dls mc algorithm is based on the fundamental idea of augmenting a combination of iterative improvement and plateau search
with vertex penalties that are modified during the search  the iterative improvement procedure used by both algorithms is based on a greedy construction mechanism that starts with
a trivial clique consisting of a single vertex and successively expands this clique c by adding
vertices that are adjacent to all vertices in c  when such an expansion is impossible  there
may still exist vertices that are connected to all but one of the vertices in c  by including
such a vertex v in c and removing the single vertex in c not connected to v  a new clique
with the same number of vertices can be obtained  this type of search is called plateau
search  it should be noted that after one or more plateau search steps  further expansion
of the current clique may become possible  therefore  dls mc alternates between phases
of expansion and plateau search 
the purpose of vertex penalties is to provide additional diversification to the search
process  which otherwise could easily stagnate in situations where the current clique has
few or no vertices in common with an optimal solution to a given max clique instance 
perhaps the most obvious approach for avoiding this kind of search stagnation is to simply
restart the constructive search process from a different initial vertex  however  even if there
is random  or systematic  variation in the choice of this initial vertex  there is still a risk that
the heuristic guidance built into the greedy construction mechanism causes a bias towards
a limited set of suboptimal cliques  therefore  both dags and dls mc utilise numerical
weights associated with the vertices  these weights modulate the heuristic selection function
used in the greedy construction procedure in such a way that vertices that repeatedly occur
in the cliques obtained from the constructive search process are discouraged from being used
in future constructions  following this intuition  and consistent with the general approach
   

fipullan   hoos

of dynamic local search  dls   which is based on the same idea  in this paper  we refer to
the numerical weights as vertex penalties 
based on these general considerations  the dls mc algorithm works as follows  see also
the algorithm outline in figure     after picking an initial vertex from the given graph g
uniformly at random and setting the current clique c to the set consisting of this single
vertex  all vertex penalties are initialised to zero  then  the search alternates between
an iterative improvement phase  during which suitable vertices are repeatedly added to
the current clique c  and a plateau search phase  in which repeatedly one vertex of c is
swapped with a vertex currently not contained in c 
the two subsidiary search procedures implementing the iterative improvement and
plateau search phases  expand and plateausearch  are shown in figure    note that both 
expand and plateausearch select the vertex to be added to the current clique c using only
the penalties associated with all candidate vertices  in the case of expand  the selection is
made from the set ni  c  of all vertices that are connected to all vertices in c by some
edge in g  we call this set the improving neighbour set of c  in plateausearch  on the other
hand  the vertex to be added to c is selected from the level neighbour set of c  nl  c  
which comprises the vertices that are connected to all vertices in c except for one vertex 
say v    which is subsequently removed from c 
note that both procedures always maintain a current clique c  expand terminates when
the improving neighbour set of c becomes empty  while plateausearch terminates when
either ni  c  is no longer empty or when nl  c  becomes empty  also  in order to reduce the
incidence of unproductive plateau search phases  dls mc implements the plateau search
termination condition of  katayama et al         by recording the current clique  c    at the
start of the plateau search phase and terminating plateausearch when there is no overlap
between the recorded clique c  and the current clique c 
at the end of the plateau search phase  the vertex penalties are updated by incrementing
the penalty values of all vertices in the current clique  c  by one  additionally  every pd
penalty value update cycles  where pd is a parameter called penalty delay   all non zero
vertex penalties are decremented by one  this latter mechanism prevents penalty values
from becoming too large and allows dls mc to forget penalty values over time 
after updating the penalties  the current clique is perturbed in one of two ways  if the
penalty delay is greater than one  i e   penalties are only decreased occasionally  the current
clique is reduced to the last vertex v that was added to it  because the removed vertices
all have increased penalty values  they are unlikely to be added back into the current clique
in the subsequent iterative improvement phase  this is equivalent to restarting the search
from v  however  as a penalty delay of one corresponds to a behaviour in which penalties are
effectively not used at all  since an increase of any vertex penalty is immediately undone  
keeping even a single vertex of the current clique c carries a high likelihood of reconstructing
c in the subsequent iterative improvement phase  therefore  to achieve a diversification
of the search  when the penalty delay is one  c is perturbed by adding a vertex v that is
chosen uniformly at random from the given graph g and removing all vertices from c that
are not connected to v 
as stated above  the penalty values are used in the selection of a vertex from a given
neighbour set s  more precisely  the selectminpenalty s  selects a vertex from s by choosing
uniformly at random from the set of vertices in s with minimal penalty values  after a vertex
   

fidynamic local search for max clique problem

procedure dls mc g  tcs  pd  maxsteps 
input  graph g    v  e   integers tcs  target clique size   pd  penalty delay   maxsteps
output  clique in g of size at least tcs or failed
begin
numsteps      
c     random v    
initpenalties 
while numsteps   maxsteps do
 c  v     expand g  c  
if  c    tcs then return c   end if
c     c 
 c  v     plateausearch g  c  c    
while ni  c      do
 c  v     expand g  c  
if  c    tcs then return c   end if
 c  v     plateausearch g  c  c    
end while
updatepenalties pd   
if pd     then
c     v  
else
v    random v   
c    c   v  
remove all vertices from c that are not connected to v in g 
end if
end while
return failed  
end

figure    outline of the dls mc algorithm  for details  see text 

has been selected from s  it becomes unavailable for subsequent selections until penalties
have been updated and perturbation has been performed  this prevents the plateau search
phase from repeatedly visiting the same clique  also  as a safeguard to prevent penalty
values from becoming too large  vertices with a penalty value greater than    are never
selected 
in order to implement dls mc efficiently  all sets are maintained using two array data
structures  the first of these  the vertex list array  contains the vertices that are currently
in the set  the second one  the vertex index array  is indexed by vertex number and contains
the index of the vertex in the vertex list array  or    if the vertex is not in the set   all
additions to the set are performed by adding to the end of the vertex list array and updating
the vertex index array  deletions from the set are performed by overwriting the vertex list
entry of the vertex to be deleted with the last entry in vertex list and then updating the
vertex index array  furthermore  as vertices can only be swapped once into the current
clique during the plateau search phase  the intersection between the current clique and the
recorded clique can be simply maintained by recording the size of the current clique at the
start of the plateau search and decrementing this by one every time a vertex is swapped
   

fipullan   hoos

procedure expand g  c 
input  graph g    v  e   vertex set c  v  clique 
output  vertex set c  v  expanded clique   vertex v  most recently added vertex 
begin
while ni  c      do
v    selectminpenalty ni  c   
c    c   v  
numsteps    numsteps     
end while 
return  c  v   
end

procedure plateausearch g  c  c   
input  graph g    v  e   vertex sets c  v  clique   c   c  recorded clique 
output  vertex set c  v  modified clique   vertex v  most recently added vertex 
begin
while ni  c     and nl  c      and c  c      do
v    selectminpenalty nl  c   
c    c   v  
remove the vertex from c that is not connected to v in g 
numsteps    numsteps     
end while 
return  c  v   
end

figure    subsidiary search procedures of dls mc  for details  see text 
into the current clique  finally  all array elements are accessed using pointers rather than
via direct indexing of the array   
finally  it may be noted that in order to keep the time complexity of the individual
search steps minimal  the selection from the improving and level neighbour sets does not
attempt to maximise the size of the set after the respective search step  but rather chooses
a vertex with minimal penalty uniformly at random  this is in keeping with the common
intuition that  in the context of sls algorithms  it is often preferable to perform many
relatively simple  but efficiently computable search steps rather than fewer complex search
steps 

   empirical performance results
in order to evaluate the performance and behaviour of dls mc  we performed extensive computational experiments on all max clique instances from the second dimacs
implementation challenge               which have also been used extensively for benchmarking purposes in the recent literature on max clique algorithms  the    dimacs
max clique instances were generated from problems in coding theory  fault diagnosis
problems  kellers conjecture on tilings using hypercubes and the steiner triple problem 
   several of these techniques are based on implementation details of henry kautzs highly efficient walksat code  see http   www cs washington edu homes kautz walksat 
   http   dimacs rutgers edu challenges 

   

fidynamic local search for max clique problem

in addition to randomly generated graphs and graphs where the maximum clique has been
hidden by incorporating low degree vertices  these problem instances range in size from
less than    vertices and       edges to greater than       vertices and           edges 
all experiments for this study were performed on a dedicated     ghz pentium iv machine with    kb l  cache and    mb ram  running redhat linux         and using the
g   c   compiler with the  o  option  to execute the dimacs machine benchmark   
this machine required      cpu seconds for r            cpu seconds for r      and      
cpu seconds for r       in the following  unless explicitly stated otherwise  all cpu times
refer to our reference machine 
in the following sections  we first present results from a series of experiments that were
aimed at providing a detailed assessment of the performance of dls mc  then  we report
additional experimental results that facilitate a more direct comparison between dls mc
and other state of the art max clique algorithms 
    dls mc performance
to evaluate the performance of dls mc on the dimacs benchmark instances  we performed     independent runs of it for each instance  using target clique sizes  tcs  corresponding to the respective provably optimal clique sizes or  in cases where such provably
optimal solutions are unknown  largest known clique sizes  in order to assess the peak
performance of dls mc  we conducted each such experiment for multiple values of the
penalty delay parameter  pd  and report the best performance obtained  the behaviour of
dls mc for suboptimal pd values and the method used to identify the optimal pd value
are discussed in section      the only remaining parameter of dls mc  maxsteps  was
set to              in order to maximise the probability of reaching the target clique size in
every run 
the results from these experiments are displayed in table    for each benchmark
instance we show the dls mc performance results  averaged over     independent runs 
for the complete set of    dimacs benchmark instances  note that dls mc finds optimal
 or best known  solutions with a success rate of      over all     runs per instance for   
of the    instances  the only cases where the target clique size was not reached consistently
within the alotted maximum number of search steps  maxsteps  are 
 c        where    of     runs were successful giving a maximum clique size  average
clique size  minimum clique size  of                
 mann a    where    of     runs obtained cliques of size       while the remaining
runs produced cliques of size       and
 mann a    where all runs achieved a maximum clique size of     
for these three cases  the reported cpu time statistics are over successful runs only and
are shown in parentheses in table    furthermore  the expected time required by dls mc
to reach the target clique size is less than   cpu second for    of the    instances  and an

   dmclique  ftp   dimacs rutgers edu in directory  pub dsj clique

   

fipullan   hoos

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
dsjc      
dsjc     
hamming    
hamming    
hamming   
hamming   
hamming   
hamming   
johnson      
johnson      
johnson     
johnson     
mann a  
mann a  
mann a  
mann a 
san    
san         
san         
san         
san         
san         
san         
san         
san         
san         
san         
sanr       

br
  
   
  
   
  
   
  
   
  
  
  
  
   
   
   
  
  
 
   
   
 
  
 
  
    
    
    
  
  
  
  
  
  
  
  
  
  
  
   
  

pd
 
 
 
 
  
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 

cpu s 
      
      
      
      
      
      
      
      
       
       
       
      
     
      
      
      
 
 
      
 
 
 
 
 
      
         
          
 
      
      
      
      
      
      
      
      
      
      
      
     

steps
     
     
     
     
      
      
     
     
        
       
       
       
     
    
    
    
  
 
   
  
 
  
 
  
     
          
          
  
      
    
     
   
   
    
     
     
     
      
    
    

sols 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
 
   
 
  
   
  
   
   
  
  
   
     
    
  
 
 
 
 
 
 
 
 
 
 
 
  

instance
sanr       
sanr       
sanr       
c      
c     
c      
c      
c     
c      
c     
c fat     
c fat     
c fat     
c fat     
c fat      
c fat     
c fat     
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
keller 
keller 
keller 
p hat      
p hat      
p hat      
p hat      
p hat      
p hat      
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     

br
  
  
  
  
   
  
  
   
  
  
  
  
  
  
   
  
  
   
   
  
  
  
   
  
  
  
  
  
   
  
  
  
   
   
 
  
  
   
   
  

pd
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

cpu s 
      
      
     
    
      
      
         
      
        
      
      
     
      
      
      
      
     
     
      
      
     
      
 
      
        
      
      
      
      
      
      
      
      
      
     
      
      
      
     
      

steps
     
    
    
       
   
     
          
   
       
     
  
   
   
  
   
  
   
    
   
     
   
   
  
    
        
   
   
    
      
   
    
   
  
   
   
   
    
    
   
   

sols 
  
 
  
  
  
  
    
  
  
 
  
 
 
  
 
  
 
 
 
 
 
 
  
   
   
  
  
  
 
  
  
  
  
  
  
  
  
 
  
  

table    dls mc performance results  averaged over     independent runs  for the complete set of dimacs benchmark instances  the maximum known clique size for
each instance is shown in the br column  marked with an asterisk where proven to
be optimal   pd is the optimised dls mc penalty delay for each instance  cpu s 
is the run time in cpu seconds  averaged over all successful runs  for each instance  average cpu times less than        seconds are shown as     steps is
the number of vertices added to the clique  averaged over all successful runs  for
each instance  sols  is the total number of distinct maximum sized cliques found
for each instance  all runs achieved the best known cliques size shown with the
exception of  c        where    of     runs were successful giving a maximum
clique size  average clique size  minimum clique size  of                mann a   
where    of     runs obtained      giving                      and mann a   
where all runs achieved a maximum clique size of     

   

fidynamic local search for max clique problem

expected run time of more than    cpu seconds is only required for   of the    remaining
instances  all of which have at least     vertices  finally  the variation coefficients  stddev mean  of the run time distributions  measured in search steps  in order to overcome
inaccuracies inherent to extremely small cpu times  for the instances on which      success rate was obtained were found to reach average and maximum values of      and      
respectively 
it may be interesting to note that the time complexity of search steps in dls mc
is generally very low  as an indicative example  brock      with     vertices         
edges and a maximum clique size of    vertices  dls mc performs  on average         
search steps  i e   additions to the current clique  per cpu second  generally  the timecomplexity of dls mc steps increases with the size of the improving  ni   and level  nl  
neighbour sets as well as  to a lesser degree  with the maximum clique size  this relationship
can be seen from table   which shows  for the  randomly generated  dimacs c   and
brock   instances  how the performance of dls mc in terms of search steps per cpu
second decreases as the number of vertices  and hence the size of ni   nl   increases 
instance
c     
c     
c     
c      
c      
brock     
brock     
brock     

vertices
   
   
   
    
    
   
   
   

edges
    
     
      
      
       
     
     
      

br
  
  
  
  
  
  
  
  

dls mc pd
 
 
 
 
 
 
  
  

steps   second
       
      
      
      
      
      
      
      

table    average number of dls mc search steps per cpu second  on our reference machine  over     runs for the dimacs c   and brock   instances  the br and
dls mc pd figures from table   are also shown  as these factors have a direct
impact on the performance of dls mc  that is  as br increases  the greater the
overhead in maintaining the sets within dls mc  furthermore  larger pd values
cause higher overhead for maintaing penalties  because more vertices tend to be
penalised  the c   instances are randomly generated with an edge probability
of      while the brock   instances are constructed so as to hide the maximum
clique and have considerably lower densities  i e   average number of edges per
vertex   the scaling of the average number of search steps per cpu second performed by dls mc on the c   instances only  running on our reference machine 
can be approximated as         n         where n is the number of vertices in the
given graph  this approximation achieves an r  value of         
a more detailed analysis of dls mcs performance in terms of implementation independent
measures of run time  such as search steps or iteration counts  is beyond the scope of this
work  but could yield useful insights in the future 
    comparative results
the results reported in the previous section demonstrate clearly that dls mc achieves
excellent performance on the standard dimacs benchmark instances  however  a com   

fipullan   hoos

parative analysis of these results  as compared to the results found in the literature on
other state of the art max clique algorithms  is not a straight forward task because of
differences in 
 computing hardware  to date  computing hardware has basically been documented in terms of cpu speed which only allows a very basic means of comparison
 i e   by scaling based on the computer cpu speed which  for example  takes no account of other features  such as memory caching  memory size  hardware architecture 
etc    unfortunately  for some algorithms  this was the only realistic option available
to us for this comparison 
 result reporting methodology  most empirical results on the performance of
max clique algorithms found in the literature are in the form of statistics on the
clique size obtained after a fixed run time  to conduct performance comparisons on
such data  care must be taken to avoid inconclusive situations in which an algorithm
a achieves larger clique sizes than another algorithm b  but at the cost of higher runtimes  it is important to realise that the relative performance of a and b can vary
substantially with run time  while a may reach higher clique sizes than b for relatively
short run times  the opposite could be the case for longer run times  finally  seemingly
small differences in clique size may in fact represent major differences in performance 
since  as in many hard optimisation problems  finding slightly sub optimal cliques is
typically substantially easier than finding maximal cliques  for example  for c       
the average time needed to find a clique of size     with      success rate  is      
cpu seconds  whereas reaching the maximum clique size of     with     success
rate  requires on average  over successful runs only  of         cpu seconds 
 termination criteria  some max clique algorithms  such as dags  do not
terminate upon reaching a given target clique size  but will instead run for a given
number of search steps or fixed amount of cpu time  even if an optimal clique is
encountered early in the search  it would obviously be highly unfair to directly compare published results for such algorithms with those of dls mc  which terminates
as soon as it finds the user supplied target clique size 
therefore  to confirm that dls mc represents a significant improvement over previous
state of the art max clique algorithms  we conducted further experiments and analyses
designed to yield performance results for dls mc that can be more directly compared with
the results of other max clique algorithms  in particular  we compared dls mc with
the following max clique algorithms  dags  grosso et al          grasp  resende 
feo    smith         using the results contained in grosso et al          k opt  katayama
et al          rls  battiti   protasi         gene  marchiori         iter  marchiori 
      and qualex ms  busygin         to rank the performance of max clique
algorithms and to determine the dominant algorithm for each of our benchmark instances 
we used a set of criteria that are based  primarily  on the quality of the solution and then 
when this is deemed equivalent  on the cpu time requirements of the algorithms  these
criteria are shown  in order of application  in table   

   

fidynamic local search for max clique problem

   if an algorithm is the only algorithm to find the largest known maximum clique for an instance then it is
ranked as the dominant algorithm for that instance 
   if more than one algorithm achieves a      success rate for an instance then the algorithm with the lowest
average  scaled  cpu time becomes the dominant algorithm for that instance 
   if a single algorithm achieves a      success rate for an instance then that algorithm becomes the dominant
algorithm for that instance 
   if no algorithm achieves a      success rate for an instance  then the algorithm that achieves the largest
size clique  has the highest average clique size and the lowest average cpu time becomes the
dominant algorithm for that instance 
   if  for any instance  no algorithm meets any of the four criteria listed above  then no conclusion can be
drawn about which is the dominant algorithm for that instance 

table    the criteria used for ranking max clique algorithms 

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
c      
c      
c      
c     
gen    p      
gen    p      
gen    p      
gen    p      
keller 
mann a  
p hat      
p hat      
san         
san         
sanr       

dls mc
clique size
cpu s 
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
       
  
       
  
       
  
      
  
    
            
       
           
  
      
  
     
  
      
  
     
  
      
           
   
       
  
      
  
      
  
      
  
      
  
      

dags
clique size
scpu s 
  
     
  
     
  
     
           
     
            
     
           
     
           
     
  
     
             
      
           
      
           
     
           
      
            
      
           
       
           
       
            
    
            
     
           
     
           
     
           
     
           
       
                    
            
      
            
      
           
     
           
    
            
     

grasp
clique size
scpu s 
  
     
  
     
  
     
  
     
  
      
  
      
           
      
  
      
  
  
  
     
            
      
  
      
           
       
           
       
            
       
  
      
            
      
            
      
           
     
           
     
                    
              
       
  
       
  
      
            
     
           
     
  
      

table    performance comparison of dls mc  dags and grasp for selected dimacs
instances  the scpu columns contain the scaled dags and grasp average
run times in cpu seconds  dags and grasp results are based on    runs per
instance  and dls mc results are based on     runs per instance  in cases where
the best known result was not found in all runs  clique size entries are in the format
maximum clique size  average clique size  minimum clique size   dls mc is the
dominant algorithm for all instances in this table 

   

fipullan   hoos

table   contrasts performance results for dags and grasp from the literature  grosso
et al         with the respective performance results for dls mc  since the dags and
grasp runs had been performed on a     ghz pentium iv cpu  while dls mc ran on
our     ghz pentium iv reference machine  we scaled their cpu times by a factor or      
 note that this is based on the assumption of a linear scaling of run time with cpu clock
speed  in reality  the speedup is typically significantly smaller   using our ranking criteria 
this data shows that dls mc dominates both dags and grasp for all the benchmark
instances listed in table    to confirm this ranking  we modified dags so it terminated
as soon a given target clique size was reached  this is the termination condition used in
dls mc  and performed a direct comparison with dls mc on all    dimacs instances 
running both algorithms on our reference machine  as can be seen from the results of
this experiment  shown in table    dls mc dominates dags on all but one instance  the
exception being san      
table   shows performance results for dls mc as compared to results for k opt  katayama
et al          gene  marchiori         iter  marchiori        and rls  battiti   protasi 
      from the literature  to roughly compensate for differences in cpu speed  we scaled
the cpu times for k opt  gene and iter by a factor of       these had been obtained on
a     ghz pentium iv  and those for rls  measured on a     mhz pentium ii cpu  by
      using the ranking criteria in table    rls is the dominant algorithm for instances
keller  and mann a    k opt is the dominant algorithm for mann a   and dls mc is
the dominant algorithm  with the exception of c        for the remainder of the dimacs
instances listed in table    to identify the dominant algorithm for c        a further experiment was performed  running dls mc with its maxsteps parameter  which controls
the maximum allowable run time  reduced to the point where the average clique size for
dls mc just exceeded that reported for rls  in this experiment  dls mc reached the
optimum clique size of    in    of     independent runs with an average and minimum
clique size of       and     respectively and an average run time of    cpu sec  taking into
account all runs   this establishes dls mc as dominant over rls and k opt on instance
c       
analagous experiments were performed to directly compare the performance of dlsmc and k opt on selected dimacs benchmark instances  the results  shown in table   
confirm that dls mc dominates k opt for these instances 
finally  table   shows performance results for dls mc in comparison with results
for qualex ms from the literature  busygin         the cpu times for qualex ms
have been scaled by a factor of      to compensate for differences in cpu speed      ghz
pentium iv cpu vs our     ghz pentium iv reference machine   using the ranking
criteria in table    qualex ms dominates dls mc for instances brock       brock      
brock      and brock       while dls mc dominates qualex ms for the remaining   
of the    dimacs instances 

   

fidynamic local search for max clique problem

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
dsjc      
dsjc     
c      
c     
c      
c      
c     
c      
c     
c fat     
c fat     
c fat     
c fat     
c fat      
c fat     
c fat     
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
hamming    
hamming    
hamming   
hamming   
hamming   
hamming   
johnson      

dls mc
success cpu s 
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
       
   
       
   
       
   
      
   
     
   
      
   
    
   
      
  
       
   
      
   
      
            
   
      
   
      
   
     
   
      
   
      
   
      
   
      
   
     
   
     
   
      
   
      
   
     
   
      
   
      
   
      
   
 
   
 
   
      
   
 
   
 

dags
success cpu s 
  
      
  
      
   
      
  
      
  
      
  
      
  
      
  
     
 
       
  
      
  
       
  
       
  
     
   
      
 
    
   
      
          
   
       
  
      


 
       
   
      
   
      
   
      
   
      
   
      
   
      
   
      
  
      
   
      
 
      
  
      
  
      
   
      
   
      
   
      
   
 
   
      
   
      
   
      

instance
johnson      
johnson     
johnson     
keller 
keller 
keller 
mann a  
mann a  
mann a  
mann a 
p hat      
p hat      
p hat      
p hat      
p hat      
p hat      
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
san    
san         
san         
san         
san         
san         
san         
san         
san         
san         
san         
sanr       
sanr       
sanr       
sanr       

dls mc
success cpu s 
   
 
   
 
   
 
   
 
   
      
            
   
      
   
       
           
   
 
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
   
      
   
      
   
     
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
   
      
   
     

dags
success cpu s 
   
      
   
 
   
      
   
      
   
     


   
      
  
     


   
      
   
      
   
      
  
    
  
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
  
      
   
      
   
      
   
      
   
      
   
      
   
      
  
      
   
      
   
      
  
      
  
     
   
      

table    success rates and average cpu times for dls mc and dags  based on     runs
per instance   for the    dimacs instances  dls mc had a superior success rate
for    instances and  with exception of san      required less or the same cpu
time than dags for all other instances  entries of  signify that the runs were
terminated because of excessive cpu time requirements  to obtain a meaningful
comparison for dls mc and dags  for mann a   and mann a        and
     respectively were used as best known results in producing this table  for
both dls mc and dags  the average cpu time is over successful runs only 
using the ranking criteria of this study  dags is the dominant algorithm for the
san     instance  while dls mc is the dominant algorithm for all other instances 

   

fipullan   hoos

dls mc
instance
clique size
brock     
  
brock     
  
brock     
  
brock     
  
brock     
  
brock     
  
c      
  
c     
  
c      
  
c      
           
c     
  
c      
  
c     
  
dsjc      
  
dsjc     
  
gen    p      
  
gen    p      
  
gen    p      
  
gen    p      
  
gen    p      
  
hamming    
  
hamming   
  
keller 
  
keller 
  
keller 
  
mann a  
   
mann a  
   
mann a                     
p hat      
  
p hat      
  
p hat      
  
p hat     
 
p hat     
  
p hat     
  
p hat     
  
p hat     
  
p hat     
  

k opt

rls

cpu s 
clique size
scpu s 
clique size
scpu s 
      
  
       
  
       
      
  
       
  
       
      
           
                     
       
      
  
                              
       
           
       
  
       
      
           
       
  
       
    
  
      
  
      
      
  
       
  
       
      
           
  
       
       
                                            
      
  
       
  
       
        
           
            
      
           
       
  
       
     
  
       
  
       
      
  
       
  
       
     
  
       
  
       
      
  
       
  
       
      
           
       
  
       
     
  
       
  
      
      
  
       
  
       
      
  
       
  
       
 
  
       
  
       
 
  
       
  
       
      
  
       
  
       
        
                     
           
      
   
       
   
       
       
              
                      
       
                          
      
             
      
           
  
       
      
  
       
  
       
      
  
     
  
       
      
 
       
 
       
      
  
       
  
       
      
  
      
  
       
      
  
       
  
       
     
  
       
  
       
      
  
       
  
       

gene
iter
avg 
avg 
clique size clique size
    
    
    
    
    
    
    
    
    
    
    
  
    
    
    
  
    
    
    
    
    
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
  
  
  
  
    
    
    
     
   
     
     
      
    
    
    
    
    
    
  
 
 
  
  
    
    
   
   
    
    
    
    

table    performance of dls mc  k opt  rls  gene and iter for selected dimacs
instances  the scpu columns contain the scaled average run time in cpu seconds
for k opt and rls  dls mc and rls results are based on     runs per instance 
and the k opt  gene and iter results are based on    runs per instance  using
the ranking criteria of this study  rls is the dominant algorithm for instances
mann a   and keller   while dls mc is the dominant algorithm for all other
instances 

   

fidynamic local search for max clique problem

dls mc
instance
clique size cpu s 
brock                         
brock     
         
brock                         
brock                         

k opt
dls mc
k opt
clique size scpu s  instance clique size cpu s  clique size scpu s 
           
      c                          
         
     
  
      c                                      
      
           
      c      
         
  
      
           
     
keller                                         

table    performance of dls mc and k opt where the dls mc parameter maxsteps has
been reduced to the point where the clique size results are comparable to those for
k opt  the cpu s  values for dls mc include the unsuccessful runs  dls mc
results are based on     runs and k opt results on    runs  per instance  
dls mc
qualex ms
dls mc
qualex ms
instance
clique size cpu s  clique size scpu s 
instance
clique size
cpu s  clique size scpu s 
brock     
  
      
  
     johnson      
  
 
  
    
brock     
  
      
  
       johnson     
 
 
 
      
brock     
  
      
  
     johnson     
  
 
  
      
brock     
  
      
  
      
keller 
  
 
  
    
brock     
  
      
  
    
keller 
  
      
  
     
brock     
  
      
  
    
keller 
           
  
      
brock     
  
      
  
    
mann a  
   
      
   
    
brock     
  
      
  
    
mann a  
           
   
     
brock     
          
  
     
mann a                              
    
      
brock     
          
  
     
mann a 
  
 
  
      
brock     
          
  
     
p hat      
  
      
  
     
brock     
  
      
  
     
p hat      
  
      
  
     
c      
  
    
  
     
p hat      
  
      
  
     
c     
  
      
  
      
p hat      
  
      
  
    
c      
  
      
  
      
p hat      
  
      
  
     
c                           
  
     
p hat      
  
      
  
     
c     
  
      
  
    
p hat     
 
      
 
    
c      
           
  
      
p hat     
  
      
  
    
c     
  
      
  
    
p hat     
  
      
  
    
c fat     
  
      
  
      
p hat     
 
     
 
    
c fat     
  
     
  
      
p hat     
  
      
  
    
c fat     
  
      
  
      
p hat     
  
      
  
    
c fat     
  
      
  
    
p hat     
  
      
  
   
c fat      
   
      
   
    
p hat     
  
     
  
    
c fat     
  
      
  
    
p hat     
  
      
  
    
c fat     
  
     
  
    
san    
  
      
  
    
dsjc      
  
     
  
      san         
  
      
  
    
dsjc     
  
      
  
    san         
  
      
  
      
gen    p      
  
     
  
       san         
  
      
  
      
gen    p      
  
      
  
     san         
  
      
  
    
gen    p      
  
      
  
     san         
  
      
  
      
gen    p      
  
     
  
     san         
  
      
  
    
gen    p      
  
      
  
     san         
  
      
  
    
hamming    
   
      
   
      san         
  
      
  
    
hamming    
  
      
  
     san         
  
      
  
    
hamming   
  
 
  
       san         
   
      
   
    
hamming   
 
 
 
      
sanr       
  
     
  
    
hamming   
   
      
   
      
sanr       
  
      
  
      
hamming   
  
 
  
    
sanr       
  
      
  
    
johnson      
 
 
 
      
sanr       
  
     
  
    

table    performance of dls mc and qualex ms  the scpu column contains the
scaled run time for qualex ms in cpu seconds  dls mc results are based
on     runs per instance  using the ranking criteria of this study  qualex ms
is the dominant algorithm for instances brock       brock       brock      and
brock       while dls mc is the dominant algorithm for all other instances 
   

fipullan   hoos

overall  the results from these comparative performance evaluations can be summarised
as follows 
 qualex ms is dominant for the brock       brock       brock      and brock     
dimacs instances 
 rls is the dominant algorithm for the mann a   and keller  dimacs instances 
 dags is the dominant algorithm for the san     dimacs instance 
 k opt is the dominant algorithm for the mann a   dimacs instance 
 dls mc is the dominant algorithm for the remaining    dimacs instances 
in addition  within the alotted run time and number of runs  dls mc obtained the current best known results for all dimacs instances with the exceptions of mann a   and
mann a   

   discussion
to gain a deeper understanding of the run time behaviour of dls mc and the efficacy of
its underlying mechanisms  we performed additional empirical analyses  specifically  we
studied the variability in run time between multiple independent runs of dls mc on the
same problem instance  the role of the vertex penalties in general and  in particular  the
impact of the penalty delay parameter on the performance and behaviour of dls mc  and
the frequency of pertubation as well as the role of the perturbation mechanism 
these investigations were performed using two dimacs instances  c       and brock      
these instances were selected because  firstly  they are of reasonable size and difficulty  secondly  c       is a randomly generated instance where the vertices in the optimal maximum
clique have predominantly higher vertex degree than the average vertex degree  intuitively
it would seem reasonable that  for a randomly generated problem  vertices in the optimal
maximum clique would tend to have higher vertex degrees   for brock       on the other
hand  the vertices in the optimal maximum clique have predominantly lower than average
vertex degree   note that the dimacs brock instances were created in an attempt to defeat
greedy algorithms that used vertex degree for selecting vertices brockington   culberson 
      
this fundamental difference is further highlighted by the results of a quantitative analysis of the maximum cliques for these instances  which showed that  for c        averaged
over all maximal cliques found by dls mc  the average vertex degree of vertices in the maximal cliques is      standard deviation of    as compared to         when averaged over all
vertices  for brock       the corresponding figures were          and          respectively 
    variability in run time
the variability of run time between multiple independent runs on a given problem is an important aspect of the behaviour of sls algorithms such as dls mc  following the methology of hoos and stutzle         we studied this aspect based on run time distributions
 rtds  of dls mc on our two reference instances 
   

fidynamic local search for max clique problem

as can be seen from the empirical rtd graphs shown in figure    each based on
    independent runs that all reached the respective best known clique size   dls mc
shows a large variability in run time  closer investigation shows that the rtds are quite
well approximated by exponential distributions  a kolmogorov smirnov goodness of fit test
failed to reject the null hypothesis that the sampled run times stem from the exponential
distributions shown in the figure at a standard confidence level of         with p values
between      and        this observation is consistent with similar results for other highperformance sls algorithms  e g   for sat  hoos   stutzle        and scheduling problems
 watson  whitley    howe         as a consequence  performing multiple independent
runs of dls mc in parallel will result in close to optimal parallelisation speedup  hoos
  stutzle         similar observation were made for most of the other difficult dimacs
instances 
 

 

empirical rld for dls mc
ed         

   

   

   

   

   

   

   

p solve 

p solve 

   

   
   

   
   

   

   

   

   

   

   

 
    

     

      

 e    

empirical rtd for dls mc
ed      

 
     

 e    

    

run time  search steps 
 

 

empirical rld for dls mc
ed         

   

   

   

   

   

   

   

p solve 

p solve 

   

   
   

   
   

   

   
 e    
 e    
run time  search steps 

  

 e    

 e    

empirical rtd for dls mc
ed    

   

   

      

 

   

   

 
     

   
run time  cpu sec 

 
    

   

 
  
run time  cpu sec 

   

    

figure    run time distributions for dls mc applied to c        top  and brock     
 bottom   measured in search steps  left  and cpu seconds  right  on our reference machine  based on     independent runs each of which reached the best
known clique size   these empirical rtds are well approximated by exponential
distributions  labelled ed m  x        x m in the plots 
    penalty delay parameter and vertex penalties
the penalty delay parameter pd specifies the number of penalty increase iterations that must
occur in dls mc before there is a penalty decrease  by    for all vertices that currently have
   

fipullan   hoos

vertex frequency

a penalty  for the max clique problem  pd basically provides a mechanism for focusing
on lower degree vertices when constructing current cliques  with pd      i e   no penalties  
the frequency with which vertices are in the improving neighbour   level neighbour sets will
basically be solely dependent on their degree  increasing pd overcomes this bias towards
higher degree vertices  as it allows their penalty values to increase  as they are more often
in the current clique   which inhibits their selection for the current clique  this in turn
allows lower degree vertices to become part of the current clique  this effect of the penalty
delay parameter is illustrated in figure    which shows the correlation between the degree
of the vertices and their frequency of being included in the current clique immediately prior
to a perturbation being performed within dls mc 

c        pd    
   
   

vertex frequency

 
  

   

  

  

  
  
vertex degree

  

  

  

brock       pd    

   
   
   
 
  

  

  

  
vertex degree

  

  

  

  

  
vertex degree

  

  

  

vertex frequency

    
brock       pd     
   
    
   
    
  

  

figure    correlation between the vertex degree and the frequency with which vertices
were present in the clique immediately prior to each dls mc perturbation  for
c       and brock       with pd      the higher degree vertices tend to have a
higher frequency of being present in the clique immediately prior to each dls mc
perturbation  for brock       with pd       the frequency of being present in the
clique immediately prior to each dls mc perturbation is almost independent of
the vertex degree 
currently  pd needs to be tuned to a family  or  in the case of the brock instances  a
sub family  of instances  in general  this could be done in a principled way based on rtd
graphs  but for dls mc  which is reasonably robust with regard to the exact value of the
parameter  as shown by figures   and     the actual tuning process was a simple  almost
interactive process and did not normally require evaluating rtd graphs  still  fine tuning
based on rtd data could possibly result in further  minor performance improvements 

   

fidynamic local search for max clique problem

   

  success rate

  
  
  
  
  
  

 

  

  

  
penalty delay

  

  

  

 

  

  

  
penalty delay

  

  

  

median processor time

   
   
   
   
   
  
 

figure    success rate and median cpu time of dls mc as a function of the penalty delay
parameter  pd  for the benchmark instance brock       each data point is based
on     independent runs 

cumulative success rate

   
  

pd     
pd     
pd     

  
  
  
 
 
  

 

 

  

 

  
steps

 

  

  

cumulative success rate

   
  

pd     
pd     
pd     

  
  
  
 
 
  

 

  

 

  
processor time  seconds 

 

  

figure    run time distributions for dls mc on brock      for penalty delays of       
and     measuring run time in search steps  top  and cpu seconds  bottom  
the performance for a penalty delay of    clearly dominates that for    and    

   

fipullan   hoos

the effect of the penalty delay parameter on the vertex penalties is clearly illustrated in
figure    which shows cumulative distributions of the number of penalised vertices at each
perturbation in dls mc  for representative runs of dls mc on the dimacs brock     
instance  for varying values of the parameter pd  note that for brock       the optimal
pd value of    corresponds to the point where  on average  about     of the vertices have
been penalised  the role of the pd parameter is further illustrated in figure    which shows
the  sorted  frequency with which vertices were present in the current clique immediately
prior to each perturbation for c       and brock       note that for both instances 
using higher penalty delay settings significanly reduces the bias towards including certain
vertices in the current clique  as previously demonstrated  without vertex penalties  i e  
for pd       dls mc prefers to include high degree vertices in the current clique  which in
the case of problem instances like c        where optimal cliques tend to consist of vertices
with higher than average degrees  is an effective strategy  in instances such as brock      
however  where the optimal clique contains many vertices of lower than average degree  the
heuristic bias towards high degree vertices is misleading and needs to be counteracted  e g  
by means of vertex penalties 
   
pd    
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     

  

  

cumulative frequency

  

  

  

  

  

  

  

 

 

   

   

   

   
   
penalised vertices

   

   

   

figure    cumulative distributions of the number of penalised vertices measured at each
search perturbation over representative independent runs of dls mc on the dimacs brock      instance as the penalty delay parameter pd is varied  the left
most curve corresponds to pd       note that for the approx  optimal penalty
delay of pd       solid line   on average about     vertices are penalised  i e  
have a penalty value greater than zero  
generally  by reducing the bias in the cliques visited  vertex penalties help to diversify
the search in dls mc  at the same time  penalties do not appear to provide a learning
mechanism through which dls mc identifies those vertices that should be included in
   

fidynamic local search for max clique problem

c      
  frequency vertex in clique

   
pd    
pd     

   
   
   
   
 

 

   

   

   

   

   
vertex

   

   

   

   

    

brock     
  frequency vertex in clique

   
pd    
pd     
   

   

   

 

 

   

   

   

   
vertex

   

   

   

   

figure    sorted frequency with which vertices were present in the current clique immediately prior to each dls mc perturbation for c        top  and brock     
 bottom   based on a representative run on each problem instance  note that by
using penalty delay values pd      the bias towards using certain vertices more
frequently than others is substantially reduced 
the current clique  this is in agreement with recent results for saps  a high performance
dynamic local search algorithm for sat  hoos   stutzle        
    perturbation mechanism and search mobility
to prevent search stagnation  dls mc uses a perturbation mechanism that is executed
whenever its plateau search procedure has failed to lead to a clique that can be further
expanded  since this mechanism causes major changes in the current clique  it has relatively
high time complexity  it is therefore interesting to investigate how frequently these rather
costly and disruptive perturbation steps are performed  figure   shows the distribution of
the number of improving search steps  i e   clique expansions  and plateau steps  i e   vertex
swaps  between successive perturbation phases for a representative run of dls mc on the
c       instance  analogous results for brock      are shown in figure     these figures
basically show the result of the interactions between the improving and plateau search steps 
the perturbation mechanism and the problem structure 

   

fipullan   hoos

c      

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

  

  

  

  

  
  
improving steps

  

  

  

   

  

  

  

  
  
plateau swaps

  

  

  

   

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

  

figure    number of improving search steps and plateau swaps between successive perturbation phases of dls mc for c        the graphs show the cumulative distributions of these measures collected over representative independent runs for each
pd value  the solid lines correspond to the approx  optimal penalty delay for this
instance  pd     
brock     

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

 

  

  

  
improving steps

  

  

  

  

  

  

  
plateau swaps

  

  

  

  

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

 

figure     number of improving search steps and plateau swaps between successive perturbation phases of dls mc for brock       the graphs show the cumulative
distributions of these measures collected over representative independent runs
for each pd value  the solid lines correspond to the approx  optimal penalty delay
for this instance  pd      
   

fidynamic local search for max clique problem

as can be seen from this data  when compared to higher penalty delay values  pd    
results in significantly shorter plateau phases and somewhat longer improvement phases 
at the same time  the differences in the behaviour of dls mc observed for various penalty
delay values greater than one are relatively small  one explanation for this phenomenon lies
in the fact that for pd      effectively no vertex penalties are used  and consequently  the
selection from the improving and level neighbours sets in each search step is less constrained 
intuitively  this should make it easier to find exits off plateaus in the underlying search
landscape and to follow gradients for a larger number of search steps 

whether this renders the search more efficient clearly depends on the topology of the
given search landscape  instance c       has at least    optimal solutions  see table     and
by construction  these optimal cliques have higher than average vertex degree  this suggests
that the respective search landscape has a relatively high fitness distance correlation  which
would explain why this problem instance is relatively easy to solve and also why using the
less radical perturbation mechanism associated with pd      which adds a randomly chosen
vertex v to the current clique and removes all vertices not connected to v  provides sufficient
diversification to the search process  instance brock       on the other hand  appears to
have only a single optimal solution but many near optimal solutions  i e   large but nonoptimal cliques that cannot be further extended   since by construction  its optimal clique
has lower than average vertex degree  this suggests that the respective search landscape
has relatively low fitness distance correlation  and therefore  the more radical perturbation
mechanism used for pd      which restarts clique construction from the most recently
added vertex and uses vertex penalties for diversification  is required in order to obtain
good performance  this hypothesis is also in agreement with the relatively high cost for
solving this problem instance 

to further investigate the efficacy of perturbation in dls mc as a diversification mechanism  we measured the relative mobility of the search  defined as the hamming distance
between the current cliques  i e   number of different vertices  at consecutive perturbations
divided by two times the maximum clique size  for representative runs of dls mc on instances c       and brock       this mobility measure is closely related to those used in
previous studies  schuurmans   southey          as can be seen from figure     there
is a large difference in mobility between the two variants of the perturbation mechanism
for pd     and pd      the former restarts the search from a randomly chosen vertex
and consequently leads to a large variability in hamming distance to the previous clique 
while the latter restarts from the most recently added vertex  using vertex penalties to
increase search diversification  and hence shows consistently much higher mobility  note
that when vertex penalties are used  i e   pd       the pd value has no significant effect on
search mobility  at the same time  as previously observed  see figure     the performance
of dls mc does significantly depend on the penalty update delay pd  this demonstrates
that in order to achieve peak performance  the increased mobility afforded by the use of
vertex penalties needs to be combined with the correct amount of additional diversification
achieved by using a specific penalty update delay 
   

fipullan   hoos

c      

cumulative frequency

   
delay  
delay  
delay   

  
  
  
  
 

 

    

   

    

   

    
   
relative mobility

    

   

    

   

    

   

    

   

brock     

cumulative frequency

   
delay  
delay  
delay   

  
  
  
  
 

 

    

   

    

   

    
   
relative mobility

figure     mobility of search between consecutive perturbation phases in dls mc for instances c        top  and brock       bottom   mobility is measured in terms
of relative hamming distance  i e   number of different vertices between the respective cliques divided by two times the maximum clique size  the graphs
show the cumulative distributions of relative mobility measurements collected
over representative independent runs for each pd value and problem instance 
the solid lines correspond to the respective approx  optimal pd values 

   conclusions and future work
we have demonstrated how by applying the general paradigm of dynamic local search to the
maximum clique problem  the state of the art in max clique solving can be improved 
our new algorithm  dls mc  has some similarity to previous max clique algorithms  in
particular to the recently introduced dags algorithm  both algorithms use vertex penalties
to guide the heuristic selection of vertices when searching for maximum cliques  however 
unlike dags  which has an initial phase of unweighted greedy construction search  dls mc
uses and updates the vertex penalties throughout the entire search process  furthermore 
weight updates in dags are monotone while  in dls mc  vertex penalties are subject
to increases as well as to occasional decreases  which effectively allows the algorithm to
forget vertex penalties over time  furthermore  dls mc selects the vertex to be added
to the current clique in each step solely based on its penalty  while vertex selection in
dags is based on the total weight of the neighbouring vertices and hence implicitely uses
vertex degree for heuristic guidance  the fact that dls mc  although conceptually slightly
simpler  outperforms dags on all but one of the standard dimacs benchmark instances
in combination with its excellent performance compared to other high performance max   

fidynamic local search for max clique problem

clique algorithms clearly demonstrates the value of the underlying paradigm of dynamic
local search with non monotone penalty dynamics 
the work presented in this article can be extended in several directions  in particular  it
would be interesting to investigate to which extent the use of multiplicative penalty update
mechanisms in dls mc instead of its current additive mechanism can lead to further performance improvements  we also believe that the current implementation of dls mc can
be further optimised  for example  for each selection of a vertex to be added to the current
clique  our implementation of dls mc performs a complete scan of either the improving
or plateaus sets to build the list of vertices with the lowest penalties  it would probably be
more efficient to maintain this list by means of an incremental update scheme  another
very interesting direction for future research is to develop mechanisms for automatically
adjusting dls mcs penalty delay parameter during the search  similar to the scheme used
for dynamically adapting the tabu tenure parameter in rls  battiti   protasi        and
reactive tabu search  battiti   tecchiolli         or the mechanism used for controlling
the noise parameter in adaptive novelty   hoos         finally  given the excellent performance of dls mc on standard max clique instances reported here suggests that the
underlying dynamic local search method has substantial potential to provide the basis for
high performance algorithms for other combinatorial optimisation problems  particularly
weighted versions of max clique and conceptually related clustering problems 

acknowledgments
the authors would like to thank liang zhao for her participation in performing some of the
initial experiments for this paper 

references
balus  e     yu  c          finding a maximum clique in an arbitary graph  siam journal
of computing                   
battiti  r     protasi  m          reactive local search for the maximum clique problem 
algorithmica             
battiti  r     tecchiolli  g          the reactive tabu search  orsa journal on computing 
              
bomze  i   budinich  m   pardalos  p     pelillo  m          the maximum clique problem 
in d z  du  p  p   ed    handbook of combinatorial optimization  vol  a  pp      
boppana  r     halldorsson  m          approximating maximum independent sets by
excluding subgraphs  bit             
brockington  m     culberson  j          camouflaging independent sets in quasi random
graphs  in d s  johnson  m  t   ed    cliques  coloring and satisfiability  second
dimacs implementation challenge  vol     of dimacs series  american mathematical society 
   

fipullan   hoos

busygin  s          a new trust region technique for the maximum clique problem  internal
report  http   www busygin dp ua 
garey  m  r     johnson  d  s          computers and intractability  a guide to the theory
of n p completeness  freeman  san francisco  ca  usa 
grosso  a   locatelli  m     croce  f  d          combining swaps and node weights in
an adaptive greedy approach for the maximum clique problem  journal of heuristics 
           
hastad  j          clique is hard to approximate within n    acta mathematica      
       
hoos  h  h          an adaptive noise mechanism for walksat  in proceedings of the
eighteenth national conference on artificial intelligence  pp          aaai press  
the mit press  menlo park  ca  usa 
hoos  h  h     stutzle  t          stochastic local search  foundations and applications 
morgan kaufmann publishers  usa 
hoos  h     stutzle  t          local search algorithms for sat  an empirical evaluation 
in gent  i   v maaren  h     walsh  t   eds    sat       pp        ios press 
hutter  f   tompkins  d  a  d     hoos  h  h          scaling and probabilistic smoothing  efficient dynamic local search for sat  in hentenryck  p  v   ed    principles
and practice of constraint programming  cp       vol       of lecture notes in
computer science  pp          springer verlag  berlin  germany 
ji  y   xu  x     stormo  g  d          a graph theoretical approach for predicting common rna secondary structure motifs including pseudoknots in unaligned sequences 
bioinformatics                    
johnson  d     trick  m   eds            cliques  coloring and satisfiability  second dimacs implementation challenge  vol     of dimacs series  american mathematical
society 
katayama  k   hamamoto  a     narihisa  h          solving the maximum clique problem by k opt local search  in proceedings of the      acm symposium on applied
computing  pp           
marchiori  e          genetic  iterated and multistart local search for the maximum clique
problem  in applications of evolutionary computing  vol       of lecture notes in
computer science  pp          springer verlag  berlin  germany 
pevzner  p  a     sze  s  h          combinatorial approaches to finding subtle signals in
dna sequences  in proceedings of the eighth international conference on intelligent
systems for molecular biology  pp          aaai press 
pullan  w     zhao  l          resolvent clause weighting local search  in tawfik  a  y  
  goodwin  s  d   eds    advances in artificial intelligence    th conference of the
canadian society for computational studies of intelligence  vol       of lecture notes
in computer science  pp          springer verlag  berlin  germany 
   

fidynamic local search for max clique problem

resende  m   feo  t     smith  s          algorithm      fortran subroutine for approximate solution of the maximum independent set problem using grasp  acm
transactions on mathematical software             
schuurmans  d     southey  f          local search characteristics of incomplete sat
procedures  in proceedings of the seventeenth national conference on artificial intelligence  pp          aaai press   the mit press  menlo park  ca  usa 
solnon  c     fenet  s          a study of aco capabilities for solving the maximum clique
problem  journal of heuristics  to appear 
thornton  j   pham  d  n   bain  s     ferreira  v          additive versus multiplicative
clause weighting for sat  in proceedings of the   th national conference on artificial
intelligence  aaai      pp          aaai press   the mit press  menlo park  ca 
usa 
tompkins  d     hoos  h          scaling and probabilistic smoothing  dynamic local
search for unweighted max sat  in xiang  y     chaib draa  b   eds    advances
in artificial intelligence    th conference of the canadian society for computational
studies of intelligence  vol       of lecture notes in computer science  pp         
springer verlag  berlin  germany 
watson  j   whitley  l     howe  a          linking search space structure  run time
dynamics  and problem difficulty  a step toward demystifying tabu search  journal
of artificial intelligence             

   

fi