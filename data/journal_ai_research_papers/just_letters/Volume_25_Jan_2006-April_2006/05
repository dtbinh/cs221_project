journal artificial intelligence research                  

submitted        published      

approach temporal planning scheduling
domains predictable exogenous events
alfonso gerevini
alessandro saetti
ivan serina

gerevini ing unibs it
saetti ing unibs it
serina ing unibs it

dipartimento di elettronica per lautomazione
universita degli studi di brescia
via branze     i       brescia  italy

abstract
treatment exogenous events planning practically important many realworld domains preconditions certain plan actions affected events 
paper focus planning temporal domains exogenous events happen
known times  imposing constraint certain actions plan must executed
predefined time windows  actions durations  handling temporal constraints adds extra difficulty planning  propose approach planning
domains integrates constraint based temporal reasoning graph based
planning framework using local search  techniques implemented planner
took part  th international planning competition  ipc     statistical analysis
results ipc   demonstrates effectiveness approach terms
cpu time plan quality  additional experiments show good performance
temporal reasoning techniques integrated planner 

   introduction
many real world planning domains  execution certain actions occur
predefined time windows one necessary conditions hold  instance 
car refueled gas station gas station open  space telescope
take picture certain planet region region observable  truth
conditions determined exogenous events happen known times 
cannot influenced actions available planning agent  e g  
closing gas station planet movement  
several frameworks supporting action durations time windows proposed
 e g   vere        muscettola        laborie   ghallab        schwartz   pollack       
kavuluri   u        sanchez  tang    mali         however  domaindependent systems fast enough large scale problems  paper  propose
new approach planning temporal features  integrating constraint based
temporal reasoning graph based planning framework 
last two versions domain definition language international planning competition  ipc  support action durations predictable  deterministic  exogenous
events  fox   long        edelkamp   hoffmann         pddl     predictable exogenous events implicitly represented  fox  long    halsey         pddl   
explicitly represented timed initial literals  one two new pddl
c
    
ai access foundation  rights reserved 

figerevini  saetti   serina

features      competition  ipc    focused  timed initial literals specified
description initial state planning problem assertions form
 at l   real number  l ground literal whose predicate
appear effects domain action  obvious meaning  at l  l
true time t  set assertions involving ground predicate defines
sequence disjoint time windows timed predicate holds  example
well known zenotravel domain  penberthy        long   fox      a 
 at
 at
 at
 at

   open fuelstation city   
    not  open fuelstation city    
    open fuelstation city   
    not  open fuelstation city     

assertions define two time windows  open fuelstation city   true 
i e         excluded         excluded   timed initial literal relevant
planning process precondition domain action  call timed
precondition action  timed precondition action seen temporal
scheduling constraint action  defining feasible time window s  action
executed  actions plan durations timed preconditions  computing
valid plan requires planning reasoning time integrated  order check
whether execution planned actions satisfy scheduling constraints 
action plan cannot scheduled  plan valid must revised 
main contributions work are   i  new representation temporal plans
action durations timed preconditions  called temporally disjunctive action graph 
 tda graph  integrating disjunctive constraint based temporal reasoning recent
graph based approach planning   ii  polynomial method solving disjunctive temporal reasoning problems arise context   iii  new local search techniques
guide planning process using representation   iv  experimental analysis
evaluating performance methods implemented planner called lpg td 
took part ipc   showing good performance many benchmark problems 
td extension name planner abbreviation timed initial literals
derived predicates  two main new features pddl      lpg td  techniques
handling timed initial literals quite different techniques handling derived
predicates  first ones concern representing temporal plans predictable exogenous
events fast temporal reasoning action scheduling planning  second ones
concern incorporating rule based inference system efficient reasoning derived
predicates planning  timed initial literals derived predicates require
change heuristics guiding search planner  radically different way 
paper  focus timed initial literals  significant useful
extension pddl     moreover  analysis results ipc   shows lpg td
top performer benchmark problems involving feature  treatment derived
predicates lpg td presented another recent paper  gerevini et al       b  
   derived predicates allow us express concise natural way indirect action effects  informally  predicates appear effect action  truth determined
domain rules specified part domain description 

   

fian approach temporal planning scheduling

paper organized follows  section    necessary background 
introduce tda graph representation method solving disjunctive temporal
reasoning problems arise context  section    describe new local
search heuristics planning space tda graphs  section    present
experimental analysis illustrating efficiency approach  section    discuss
related work  finally  section   give conclusions 

   temporally disjunctive action graph
partial order causal link planning   e g   penberthy   weld        mcallester  
rosenblitt        nguyen   kambhampati         framework search space
partial plans  search state partial temporal plan represent
temporally disjunctive action graph  tda graph   tda graph extension
linear action graph representation  gerevini  saetti    serina        integrates disjunctive temporal constraints handling timed initial literals  linear action graph
variant well known planning graph  blum   furst         section 
necessary background linear action graphs disjunctive temporal constraints 
introduce tda graphs  propose techniques temporal reasoning
context representation used next section 
    background  linear action graph disjunctive temporal constraints
linear action graph  la graph  planning problem directed acyclic leveled
graph alternating fact level  action level  fact levels contain fact nodes 
labeled ground predicate   fact node f level l associated
no op action node level l representing dummy action predicate f
precondition effect  action level contains one action node labeled
name domain action represents  no op nodes corresponding
level 
action node labeled level l connected incoming edges fact nodes
level l representing preconditions  precondition nodes   outgoing edges
fact nodes level l     representing effects  effect nodes   initial level
contains special action node astart   last level special action node aend  
effect nodes astart represent positive facts initial state   precondition
nodes aend goals  
pair action nodes  possibly no op nodes  constrained persistent mutex
relation  fox   long         i e   mutually exclusive relation holding every level
graph  imposing involved actions never occur parallel valid plan 
relations efficiently precomputed using algorithm proposed previous
work  gerevini et al         
la graph contains set ordering constraints actions  partial  plan represented graph  constraints  i  constraints imposed
search deal mutually exclusive actions  action level l mutex
action node b level l  constrained finish start b   ii 
constraints actions implied causal structure plan  action
   

figerevini  saetti   serina

used achieve precondition action b  constrained finish start
b 
effects action node automatically propagated next levels
graph corresponding no ops  interfering  mutex  action
blocking propagation  last level graph reached  gerevini et al  
       rest paper  assume la graph incorporates propagation 
disjunctive temporal problem  dtp   stergiou   koubarakis        tsamardinos
  pollack        pair hp  ci  p set time point variables  c set
disjunctive constraints c  cn   ci form yi xi ki   xi yi p  ki
real number  i       n   c contains unary constraints  dtp called simple
temporal problem  stp   dechter  meiri    pearl        
dtp consistent dtp solution  solution dtp
assignment real values variables dtp consistent every constraint
dtp  computing solution dtp np hard problem  dechter et al         
computing solution stp accomplished polynomial time  given
stp special start time variable preceding others  compute
solution stp variable shortest possible distance o n c 
time  n variables c constraints stp  dechter et al         gerevini   cristani 
       call solution optimal solution stp  clearly  dtp consistent
choose constraint dtp disjunct obtaining consistent
stp  solution stp solution original dtp 
finally  stp consistent distance graph stp
contain negative cycles  dechter et al          distance graph stp hp  ci
directed labeled graph vertex labeled p p p  edge v p
w p labeled k constraint w v k c 
    augmenting la graph disjunctive temporal constraints
let p timed precondition set w  p  time windows  following  x x 
indicate start time end time x  respectively  x either time window
action  moreover  al indicates action node level l la graph consideration 
clarity presentation  describe techniques focusing action preconditions
must hold whole execution action  except end point
action   operator effects hold end action execution  i e   pddl
conditions type all  pddl effects type end  fox   long          
order represent plans actions durations time windows
execution  augment ordering constraints la graph  i  action duration
constraints  ii  action scheduling constraints  duration constraints form
a    dur a  
dur a  denotes duration action  for special actions start aend  
 

 
dur astart     dur aend        since
start   astart aend   aend    duration
constraints supported representation proposed previous work  gerevini
   methods planner support types operator condition effect specified
pddl         

   

fian approach temporal planning scheduling

level  
   
p 

level  

level  

goal level

  

p 

p 

p 

p 
p

mutex

p 

   

    

p 

    

p 

    

p 

a 

a 
   

astart

   

p 

p 

p 

   

p 

p 
mutex

  

astart

p 

    

    

a 

aend

    

p 

    

p 

p

p  

    
    

    
   

p

    

a 
a 

    

p 

aend

a 
   

p 

   

p 

   

p 

    
   

    

p 

    

p 

    

p 

    

 

  

  

  

  

   

p 

figure    example la graph nodes labeled  values  in round brackets  
gantt chart actions labeling nodes la graph  square
nodes action nodes  circle nodes fact nodes  action nodes marked
duration represented actions  in square brackets   unsupported
precondition nodes labeled     dashed edges form chains no ops blocked
mutex actions  grey areas gantt chart represent time windows
timed precondition p a   

et al          representation treatment scheduling constraints major
contribution work 
let plan represented la graph a  easy see set c formed
ordering constraints duration constraints actions
encoded stp  instance  ai used support precondition node aj  

a 
aj   c  ai aj two mutex actions   ai ordered aj  

a 
aj   c  moreover  every action   following stp constraints
c 
a  dur a   a  dur a  
equivalent a    dur a   scheduling constraint imposes constraint
execution action must occur time windows associated timed
precondition action  syntactically  disjunctive constraint c  cn  
ci form


 yi x
hi    vi ui ki   

u
  vi   xi   yi action start times action end times  hi   ki r   every action
timed precondition p  following disjunctive constraint added c 

   

figerevini  saetti   serina

 

ww  p 



 
 


 
a 
a 
 
start w
start w

definition   temporally disjunctive action graph  tda graph    tuple ha    p  ci

linear action graph 
assignment real values nodes a 
p set time point variables corresponding start times end times
actions labeling action nodes a 
c set ordering constraints  duration constraints scheduling constraints
involving variables p 
tda graph ha    p  ci represents  partial  plan formed actions labeling
action nodes start times assigned   figure   gives la graph
 values simple tda graph containing five action nodes  astart   a    a    a    aend  
several fact nodes representing ten facts  ordering constraints duration constraints
c are  

 

a 
  a     a  a    

 
 

 
a  a        a 
        a  a       

assuming p timed precondition a  windows                    
scheduling constraint c is 

 
 
 

 
 
  a 
start a       a  astart        astart a       a  astart       

pair hp  ci defines dtp d   let ds set scheduling constraints d 
represents set stps  consists constraints
ds one disjunct  pair stp constraints  disjunction subset s 
ds  ds  ds    call consistent stp induced stp d  induced
stp contains disjunct every disjunction ds  i e   ds    ds    say
 consistent  stp complete induced stp d 
values assigned action nodes action start times corresponding optimal solution induced stp  call start times schedule
actions a  value labeling fact node f earliest time   ta   dur a 
   note that  p timed condition action a  end time
exogenous event making p false happens  pddl p required true end
 fox   long        

 

   brevity  examples omit constraints a 
start ai   ai aend    action
ai   well duration constraints astart aend   duration zero 
   disjunctive constraints c exactly dtp form  however  easy see every
disjunctive constraint c translated equivalent conjunction constraints exact dtpform  use compact notation clarity efficiency reasons 

   

fian approach temporal planning scheduling

supports f a  starts ta   induced stp derive
schedule incomplete  may violate scheduling constraint action nodes 
say unscheduled current tda graph 
following definitions present notions optimality complete induced stp
optimal schedule  used next section 
definition   given dtp point variable p  complete induced stp
optimal induced stp p iff solution assigning p value less
equal value assigned p every solution every complete induced
stp d 
definition   given dtp tda graph g  optimal schedule actions
g optimal solution optimal induced stp
end  
note optimal solution minimizes makespan represented  possibly
partial  plan  dtp previous example  figure    two induced stps  one
time window p  s     one including pair stp constraints imposing
time window           p  s     stp obtained imposing time window         
p induced stp dtp  consistent  s  partial induced
stp d  s  complete optimal start time aend   temporal values
derived optimal solution s  assigned action nodes
 



 

tda graph are 
start   astart      a       a       a        aend   aend      
    solving dtp tda graph
general  computing complete induced stp dtp  if exists  np hard problem
solved backtracking algorithm  stergiou   koubarakis        tsamardinos
  pollack         however  given particular structure temporal constraints
forming tda graph  show task accomplished polynomial time
backtrack free algorithm  moreover  algorithm computes optimal induced stp

end  
following  assume time window timed precondition shorter
duration action  otherwise  time window removed
available precondition and  time window remains  action cannot
used valid plan   moreover  without loss generality  assume
action one timed precondition  easy see always replace
set timed conditions action single equivalent timed precondition 
whose time windows obtained intersecting windows forming different original
timed conditions a  set start timed conditions set end timed
conditions compiled single equivalent timed preconditions  achieved
translating conditions conditions type all  idea similar
one presented edelkamp         difference one
time window associated timed condition  edelkamp assumes timed
condition associated unique time window  specifically  every start timed
condition p action translated equivalent timed condition p   type
replacing scheduling constraint p 
   

figerevini  saetti   serina

p

p

dur a 

dur a 

q

dur a 

r

r

x
 

     

  

  

  

   

   

   

   

figure    example set timed conditions compiled single timed precondition  x   solid boxes represent time windows associated timed
conditions p  of type start   q  of type end   r  of type all 
action a  solid box extended dashed box indicates extension
time window translation corresponding timed condition
timed condition a 

 

ww  p 







 
a 
a 
 
start   w
start   w

forcing occur one time windows 
 

ww  p 



 
 
 


a 
a 
start   w   dur a   
start   w

similarly  every end timed condition p translated equivalent
timed condition replacing scheduling constraint
 

ww  p 



 

 

 
a 
a 
 
start   w
start   w

forcing a  occur one time windows 
 

ww  p 



 

 


 
a 
 
start   w   dur a  astart   w

clearly  translation timed conditions domain action single timed
precondition action accomplished preprocessing step polynomial time 
figure   shows example  assume action duration    timed conditions
p type start  q type end r type all  let                   
time windows p           time window q  finally                    
time windows r  compile timed conditions new timed condition x
time window          
   note timed conditions type start end need use   instead   however 
properties algorithms stps easily generalized stps extended   constraints
 e g   gerevini   cristani        

   

fian approach temporal planning scheduling

solve dtp x  s 
input  set x meta variables meta csp dtp  partial solution meta csp 
output  either solution meta csp fail 
  
  
  
  
  
  
  
  
  
   

x   stop return s 
x selectvariable x   x   x  x  
d x    
selectvalue d x   
   x d   d x  d x   d  
d   x  d x      saving domain values   
forwardcheck dtp x        
solve dtp x         
d x     x      restoring domain values   
return fail     backtracking   

forwardcheck dtp x  s 
input  set x meta variables   partial  solution s 
output  either true false 
  
  
  
  
  
  

forall x x
forall d x 
consistency stp s  x d  
d x  d x   d  
d x    return false     dead end   
return true 

figure    basic algorithm solving dtp  d x  global variable whose value
current domain meta variable x  consistency stp s  returns true 
stp formed variable values  partial  solution solution  false
otherwise 

observed stergiou kourbarakis        tsamardinos pollack        
dtp seen meta csp  variables meta csp constraints
original csp  values  meta  variables disjuncts forming
constraints original csp  constraints meta csp explicitly
stated  instead  implicitly defined follows  assignment values
meta variables satisfies constraints meta csp iff forms consistent stp  an
induced stp dtp   solution meta csp complete induced stp
dtp 
figure   shows algorithm solving meta csp dtp  tsamardinos  
pollack         variant forward checking backtracking algorithm solving
general csps  appropriately choosing next meta variable instantiate  function
selectvariable  value  function selectvalue   show algorithm finds
solution backtracking  if one exists   moreover  simple modification solve   

figerevini  saetti   serina

dtp  derive algorithm backtrack free even input meta csp
solution  achieved exploiting information la graph
tda graph decompose dtp sequence growing dtps
d  d      dlast  
 i  last number levels a   ii  variables vi di  i      last 
variables corresponding action nodes level i   iii 
constraints di constraints involving variables vi   e g  

 

 

 
dtp figure    point variables d  a 
start   a    a    a    a    a    a    set
constraints d 

 

 

 

 

  a 
  a     a  a     a  a        a  a        a  a       

 
 
 

 
 
  a 
start a       a  astart        astart a       a  astart        

decomposed dtp  derive ordered partition set metavariables meta csp original dtp
x   x  x      xlast  
xi set meta variables corresponding constraints di di   
     d  otherwise  ordered partition used define order
selectvariable chooses next variable instantiate  crucial avoid backtracking  specifically  every variable single domain value  i e   ordering constraint 
duration constraint  scheduling constraint one time window  selected
every variable one possible value  i e   scheduling constraint
one time window   moreover  xi xi   xj xj   j  xi selected
xj  
order avoid backtracking  order selectvalue chooses value
meta variable important well  given meta variable one value
 time window  current domain  choose value corresponding earliest
available time window  e g   current domain selected meta variable
possible values
 

i    m

 


 
 

a 
 
start wi astart wi

selectvalue chooses j th value  wj      wh    every h          m  
j          m   h    j 
following give simple example illustrating order selectvariable
selectvalue select meta variables meta values  respectively  consider
tda graph figure   additional time window            timed precondition p a    dtp extended tda graph six meta variables  x    x            x    
whose domains  the disjuncts corresponding constraints original csp  are 

x     a 
  a    
 

x     a  a    

   

fian approach temporal planning scheduling

x   
x   
x   
x   


 a 
  a       
 

 a  a       

 a 
  a       
 
 
 
 

 
 
  astart
       a  astart       astart a       a  astart      
 

 
 
 astart a        a  astart       

exploiting level structure tda graph  derive ordered partition
meta variables formed following sets 
x     x     x     x     x     x    x    x    x    
since x  belongs x  x  belongs x    selectvariable selects x  selecting
x    similarly  function selects x  meta variables x    algorithm
instantiates x    first meta value x   i e   first time window timed precondition a    removed domain forward checking  selectvalue selects

 
 
 

 
 
 a 
start a       a  astart       astart a        a  astart      
first meta value corresponds time window starting time    
second one corresponds time window starting time     
using techniques selecting next meta variable instantiate
value  prove following theorem 
theorem   given dtp tda graph  meta csp x solvable 
solve dtp finds solution x backtracking  moreover  solution optimal
induced stp
end  
proof  proof two key points  way meta variables selected instantiated
selectvariable selectvalue  respectively  particular type constraints d 
disjunctive constraints specific form encoding set disjoint time windows 
and  construction d 

j   j   
j   ai  

   


set ordering constraints duration constraints d 
 aj  
endpoint ai  aj    property      cannot imply restriction
maximum distance endpoint ai endpoint aj  while  course 
lower bound distance   i e   positive quantity u

j   j     a
j ai u  

   

let assume selectvariable chooses meta variable x cannot consistently
instantiated value d x   and means reached backtracking point  
show cannot case 
selectvariable chooses meta variables stp constraints metavariable scheduling constraint one value  time window   let x
set meta variables associated scheduling constraints d 
x must meta variable x   assuming meta csp x
solvable  use forward checking subroutine guarantees least one value x
consistent respect meta variables instantiated current partial
   

figerevini  saetti   serina

solution s  hence  case step   solve dtp forwardcheck dtp
returns false every value  time window  d x   i e   every d x 
exists another uninstantiated meta variable x  x that  every d  d x    
check consistency stp s  x  d     executed forward checking subroutine returns
false  however  x solution  d consistent   cannot case
 i  value chosen selectvalue instantiate x previously instantiated metavariables  step    earliest available time window current domain
meta variable consideration  least commitment assignment 
 ii  one scheduling constraint  meta variable x   level
tda graph 
let a  action constrained scheduling constraint associated x     since
selectvariable selects x x     ii  a  level following level
action constrained scheduling constraint associated x  thus  property     
x  could instantiated  would every time window
a  constrains a  start early  current partial solution x augmented
possible values x implies start time a  end
last time window a    then   i  assumption x solvable guarantee
cannot case 
moreover  since value every instantiated meta variable propagated forward
checking unassigned variables  first value assigned metavariable value assigned variable solution found csp  if
any  easy see first value chosen selectvalue d x   feasible
 forwardcheck dtp x         returns false   every next value chosen x
feasible 
finally  since value chosen selectvalue meta variable corresponds
earliest available window current domain meta variable  follows
solution computed algorithm complete optimal induced stp
end    
consequence previous theorem  solve dtp performs backtracking  step     
input meta csp solution  thus  obtain general backtrack free
algorithm dtp tda graph simply replacing step   
    stop return fail 
correctness modified algorithm  called solve dtp    follows
theorem    next theorem states runtime complexity solve dtp   polynomial 
theorem   given tda graph g dtp d  solve dtp  processes meta csp
corresponding polynomial time respect number action nodes g
maximum number time windows scheduling constraint d   
   noted main goal give complexity bound polynomial  use
improved forward checking techniques  e g   tsamardinos   pollack        could lead complexity
bound lower one given proof theorem 

   

fian approach temporal planning scheduling

proof  time complexity depends number times forwardcheck dtp executed  time complexity  contains linear number variables respect
number n domain action nodes la graph tda graph  o n     ordering constraints  o n  duration constraints scheduling constraints  hence 
meta csp o n    meta variables  one variable constraint original
csp   let maximum number time windows scheduling constraint d 
forwardcheck dtp executed times meta variable x  i e   o  n     times
total  consistency stp decides satisfiability stp involving o n  variables 
accomplished o n    time  dechter et al         gerevini   cristani          note
variables stp processed consistency stp variables
original csp  i e   starting time end time actions plan  
finally  consistency stp run o  n    times run forwardcheck dtp 
follows runtime complexity solve dtp  o    n      
exploiting structure temporal constraints forming dtp tdagraph  make following additional changes solve dtp  improving efficiency
algorithm 
instead starting empty assignment  no meta variable instantiated  
initially every meta variable associated ordering constraint duration
constraint instantiated value  x contains meta variables associated
scheduling constraints  observed proof theorem    meta
csp solvable  values assigned meta variables initial form
consistent stp 
forward checking performed meta variable 
proof theorem   shown that  meta csp solvable 
first value chosen selectvalue feasible  i e   forwardcheck dtp returns
true   thus  first value feasible  stop algorithm return fail
meta csp solvable  moreover  omit steps    
save restore domain values meta variables 
finally  improved algorithm made incremental exploiting particular
way update dtp tda graph planning  i e  
search solution tda graph described next section   described
next section  search step either addition new action node certain
level l  removal action node l  cases  suffices recompute
sub solution meta variables subsets xl   xl          xlast   values
assigned meta variables assignment last solution
computed updating dtp  part input algorithm 
moreover  order use local search techniques described next section 
need another change basic algorithm  algorithm detects x
solution  instead returning failure   i  keeps processing remaining meta variables 
 ii  terminates  returns  partial  induced stp si formed values
assigned meta variables  optimal solution si defines  assignment
tda graph 
   

figerevini  saetti   serina

next section  sg denotes induced stp dtp tda graph g computed method 

   local search techniques tda graphs
tda graph ha    p  ci contain two types flaw  unsupported precondition nodes
a  called propositional flaws  action nodes scheduled   called
temporal flaws  level contains flaw  say level flawed  example 
time window p tda graph figure             level   would
flawed  start time a  would     violates scheduling constraint
a  imposing action must executed          
tda graph flawed level represents valid plan called solution graph 
section  present new heuristics finding solution graph search space
tda graphs  heuristics used guide local search procedure  called walkplan 
originally proposed gerevini serina        heart
search engine planner 
initial tda graph contains astart aend   search step identifies
neighborhood n  g   successor states  current tda graph g  search state  
set tda graphs obtained g adding helpful action node removing
harmful action node attempt repair earliest flawed level g   
following  sake brevity refer action node tda graph 
implicitly referring action node la graph tda graph  similarly
level tda graph  moreover  remind reader l denotes action
level l  la denotes level action a 
definition   given flawed level l tda graph g  action node helpful l iff
insertion g level l would remove propositional flaw l 
definition   given flawed level l tda graph g  action node level l
harmful l iff removal g would remove propositional flaw l  would
decrease  value al   al unscheduled 
examples helpful action node harmful action node
action node representing action effect p  helpful level   tda graph
figure   added level      bear mind insertion action node
level   determines expansion tda graph postponing a  level    details
given end examples   action node a  figure   harmful level   
precondition node p  unsupported  action node a  harmful level   
blocks no op propagation p  level    would support precondition node p 
level    moreover  assuming w  p                a  unscheduled plan represented
la graph  action node a  harmful level    removal a 
   designed several flaw selection strategies described experimentally evaluated
recent paper  gerevini  saetti    serina         strategy preferring flaws earliest level
graph tends perform better others  used default strategy planner 
details discussion strategy given aforementioned paper 

   

fian approach temporal planning scheduling

would decrease temporal value a    contrary  a  harmful level   
removal would affect possible scheduling a    notice action
node helpful harmful  a  harmful level    helpful
goal level  because supports precondition node p   aend   
add action node level l empty  la graph extended
one level  action nodes l shifted forward one level  i e   moved
next level   new action inserted level l   similarly  remove
action node level l  graph shrunk removing level l  additional
details process given another paper  gerevini et al          moreover 
pointed previous section  addition  removal  action node requires us
update dtp g adding  removing  appropriate ordering constraints
actions la graph g  duration constraint a  scheduling
constraint  if any   updated dtp  use method described
previous section revise   compute possibly new schedule actions g
 i e   optimal solution sg   
elements n  g  evaluated using heuristic evaluation function e consisting
two weighted terms  estimating additional search cost temporal cost  i e  
number search steps required repair new flaws introduced  contribution
makespan represented plan  respectively  element n  g  lowest
combined cost selected using noise parameter randomizing search escape
local minima  gerevini et al          addition  order escape local minima 
new version planner uses short tabu list  glover   laguna         rest
section  focus search cost term e  techniques use
evaluation temporal cost  automatic  setting term weights e
similar introduced previous work  gerevini et al         
search cost adding helpful action node repair flawed level l g
estimated constructing relaxed temporal plan achieving
    unsupported precondition nodes a  denoted pre a 
    propositional flaws remaining l adding a  denoted unsup l  
    supported precondition nodes action nodes g would become
unsupported adding a  denoted threats a  
moreover  estimate number additional temporal flaws addition
g would determine  i e   count number
 i  action nodes g would become unscheduled adding g 
 ii  unsatisfied timed preconditions a  unscheduled tda graph extended  
 iii  action nodes scheduling constraint estimate cannot satisfied
context g 
search cost adding g number actions plus  i    ii   iii  
new terms heuristic evaluation  note action nodes  i 
   

figerevini  saetti   serina

aend     

goal level
    

p 

p 
    

a      

    

p 

action
b 
b 
b 
b 

    

    

p  
p

    

p 

    

p 

p 

    

    

    

    

p 

p 

est lower bound
 
 
  
  

    
   

q

p 

p 

p 

relaxed plan

level  
  

action
b 
b 
b 
b 

n um acts
 
 
 
 

anew     

    

p      

p 

p 

level  
p 
p 

p 
mutex

p 

   

    

a     

level  
   

    

   

p 

mutex

p 

p 
p 
p 

   

   

a      
   
  

p 
p 
p 

    

q 

q 
    
    

   

b 

    

q 

   
    

p 

   

b     


astart    

   

p 

     

q
p 

b      

   

q 

p 

    

    

b     

p 

   

    

p 

figure    example relaxed temporal plan   square nodes represent action nodes 
nodes represent fact nodes  solid nodes correspond nodes
 anew    dotted nodes correspond precondition nodes action nodes
considered construction   gray dotted nodes
selected inclusion   action nodes marked duration
represented actions  in square brackets  estimated start time  in
round brackets   meaning num acts described text  lower
bounds earliest action start times  est lower bound  computed
algorithm appendix a 

would ordered  because used achieve one
preconditions  action nodes mutex a  that  given estimated end
time duration a  would excessively increase start time   ii 
consider original formulation timed preconditions  i e   formulation
possible compilation one merged new precondition  discussed section      
finally  check scheduling constraint action   consider estimated end
time relaxed subplan used achieve preconditions action 
example relaxed temporal plan additional temporal flaws  iiii 
figure   gives example evaluating addition anew level   lagraph left side figure  the graph one used figure    
   

fian approach temporal planning scheduling

relaxedtimeplan g  i  a 
input  set goal facts  g   initial state relaxed plan  i   set reusable actions  a  
output  set actions acts forming relaxed plan g earliest time
facts g achieved 
  
  
  
  
  
  
  
  
  
   
   
   
   


acts a  f aacts add  a  
ax  t  g    g g f g g i  
g g i 
g f   
g fact g f  
b bestaction g  
ha  t  relaxedtimeplan pre b   i  acts  
 b  computeeft  b  t    
ax t   b   
forall f add b 

 f    f   st  b    dur b   
acts  b   f aacts add  a  
return hacts  ti 

figure    algorithm computing relaxed temporal plan  computeeft  b      returns
estimated earliest finishing time b consistent scheduling
constraint b  if any   t    dur b   for example see
appendix a   add  a  denotes set positive effects a 

helpful action node unsupported precondition p    goals unsupported
preconditions q  q  anew   initial state formed fact nodes
supported level    actions anew   b  b   numbers name
actions facts relaxed plan indicate order relaxedtimeplan
considers them  estimated start time end time b         respectively 
assume timed precondition q anew associated time window         
concerning point  i   action node g would become unscheduled adding
anew g  concerning point  ii   anew unscheduled one timed precondition
unsatisfied  q   concerning point  iii   b  cannot scheduled
context current tda graph g  finally  since contains three actions 
sum  i    ii   iii     search cost adding anew g level  
  
evaluation tda graph derived removing harmful action node
flawed level l similar  achieving
precondition nodes supported would become unsupported removing

la   l  unsupported precondition nodes level l become supported removing a 
   

figerevini  saetti   serina

regarding second point  note l   la   flaws l eliminated because 
remove action   automatically  remove precondition nodes  while 
la   l  removal could leave flaws level l 
plan relaxed sense derivation ignores possible  negative  interference actions   actions may unscheduled  derivation
takes account actions already current partial plan  the plan represented
tda graph g   particular  actions current plan used define
initial state   obtained applying actions g level la    ordered
according corresponding levels  moreover  fact f marked temporal
value   f    corresponding time f becomes true  and remains  
current subplan formed actions level la   
relaxed plan constructed using backward process  called relaxedtimeplan  see
figure     extension relaxedplan algorithm proposed previous
work  gerevini et al          algorithm outputs two values  set actions forming
 sub relaxed plan  estimated earliest finishing time  used defined temporal
cost term e   set actions acts forming derived running relaxedtimeplan
twice  first goals pre a   initial state empty set reusable actions 
goals unsup l   hreats a   initial state threats a  add  a   set reusable
actions formed actions computed first run plus a 
main novelty extended algorithm computing concerns choice
actions forming relaxed plan  action b chosen achieve  sub goal g action
minimizing sum
estimated minimum number additional actions required support propositional preconditions  num acts b  i   
number supported precondition nodes la graph would become
unsupported adding b g  threats b   
number timed preconditions b estimate would unsatisfied g
extended  timedpre b   
number action nodes scheduled estimate would become unscheduled adding b g  timethreats b   
formally  action chosen bestaction g  step   relaxedtimeplan
achieve  sub goal g action satisfying


 
 
 
 
argmin num acts a   i     threats a       timedpre a       timethreats a     
 a  ag  

ag    a    g add  a     set domain actions whose preconditions
reachable i  
num acts b  i  computed algorithm given appendix a  threats b  computed previous method deriving  gerevini et al          i e   considering
negative interactions  through mutex relations  b precondition nodes
supported levels al   timedpre b  timethreats b  new components
action selection method  computed follows 
   

fian approach temporal planning scheduling

order compute timedpre b   estimate earliest start time b  est b  
earliest finishing time b  ef t b    using values  count number
timed preconditions b cannot satisfied  ef t b  defined est b    dur b  
est b  maximum
lower bound possible earliest start time b  est lower bound b   computed
reachability analysis algorithm given appendix a 
 values action nodes ci current tda graph g    la  

mutex b addition b g would occur addition c 
b  
dtp g 
maximum estimated lower bound time preconditions
b achieved relaxed plan  estimate computed causal structure
relaxed plan  duration scheduling constraints actions 
 values facts initial state i 
example timedpre
example figure    estimated start time b  maximum    
est lower bound b       maximum time estimated
times preconditions b  supported  p  supported initial state
time    q  supported time      notice a  mutex b  
second point definition est b   apply here  since estimated earliest
start time b     duration b      ef t b              thus  assume
q associated time window         timed precondition q b 
cannot scheduled  i e   q timedpre b   
order compute timethreats b   use following notion time slack
action nodes 
definition   given two action nodes ai aj tda graph ha    p  ci

c    a 
  aj   slack ai   aj   maximum time  value ai
consistently increased sg without violating time window chosen scheduling aj  
order estimate whether action b time threat action node k
current tda graph extended action node adding repairing level
l  l   k   check
 b   a    slack a  ak  
holds  b portion relaxed plan computed far   b   a 
estimated delay adding actions b g would cause start time a 
examples time slack timethreat
slack anew a  tda graph figure   extended anew    
even anew started     a  could still executed time window
           imposed timed precondition p   anew started        a 
would finish       determined summing start time anew   dur anew    dur a    
   

figerevini  saetti   serina

dur a      scheduling constraint a  would violated  assume
evaluating inclusion b  relaxed plan figure   achieving q  
 b    anew         
i e  estimated delay portion plan formed b  would add end
time anew      since slack anew a     
slack anew   a       b    anew   
a  timethreats b    contrary  since
slack anew   a       b    anew       
a    timethreats b   
conclude section  observe way consider scheduling constraints
evaluation search neighborhood similarity well known
technique used scheduling  example  suppose evaluating tda graphs
obtained adding helpful action node one among alternative possible levels
graph  current tda graph contains another action node c mutex
a  search neighborhood contains two tda graphs corresponding     adding
level lc     adding level lc       violates less scheduling
constraints      then  according points  i  iii       preferred      similar
heuristic method  called constraint based analysis  proposed erschler  roubellat
vernhes        decide whether action scheduled another
conflicting action  used scheduling work guiding search
toward consistent scheduling tasks involved problem  e g   smith   cheng 
      

   experimental results
implemented approach planner called lpg td  obtained  nd prize
metric temporal track  satisficing planners   th international planning competition  ipc     lpg td incremental planner  sense produces sequence
valid plans improves quality previous ones  plan quality
measured using metric expression specified planning problem description 
incremental process lpg td described another paper  gerevini et al         
essentially  process iterates search solution graph additional constraint
lower bound plan quality  determined quality previously
generated plans  lpg td written c available http   lpg ing unibs it 
section  present results experimental study two main goals 
testing efficiency approach temporal planning predictable exogenous
events comparing performance lpg td recent planners
ipc   attempted benchmark problems involving timed initial literals  edelkamp 
hoffmann  littman    younes        
   

fian approach temporal planning scheduling

planner

lpg td
sgplan
p mep
crikey
lpg ipc 
downward  diag 
downward
marvin
yahsp
macro ff
fap
roadmapper
tilsapa
optop

solved
   
    
  
   
   
   
   
   
   
   
  
  
  
 

attempted
    
    
   
   
   
   
   
   
   
   
   
   
   
  

success ratio
   
   
   
   
   
   
   
   
   
   
   
   
   
  

planning capabilities ipc  
propositional   dp  metric temporal  til
propositional   dp  metric temporal  til
propositional  metric temporal  til
propositional  metric temporal
propositional  metric temporal
propositional   dp
propositional   dp
propositional   dp
propositional
propositional
propositional
propositional
til
til

table    number problems attempted solved success ratio  satisficing  planners took part ipc    dp means derived predicates  til means timed
initial literals  propositional means strips adl  planning capabilities pddl    features test problems attempted planner
ipc   

testing effectiveness proposed temporal reasoning techniques integrated
planning process understand  particular  impact overall
performance system  compare existing techniques 
first analysis  consider test problems variant ipc   metrictemporal domains involving timed initial literals  comparison lpg td ipc  
planners considering variants ipc   metric temporal domains given
appendix b  additional results available web site planner 
second experiments  use new domains problems obtained extending
two well known benchmark domains  and relative problems  ipc   timed
initial literals  long   fox      a   
tests conducted intel xeon tm    ghz    gbytes ram  ran lpg td
default settings every problem attempted 
    lpg td ipc   planners
section  use official results ipc   compare performance lpg td
planners took part competition  performance lpg td
corresponds single run  cpu time limit run    minutes 
termination forced  lpg td s indicates cpu time required planner derive
first plan  lpg td bq indicates best quality plan found within cpu time limit 
   description ipc   domains relative variants  reader visit
official web site ipc    http   ls  www cs uni dortmund de edelkamp ipc   index html  
extended versions ipc   domains used experiments available
http   zeus ing unibs it lpg testsipc  til tgz 

   

figerevini  saetti   serina

focusing analysis ipc   domains involving timed initial literals 
table   give brief overview results ipc    satisficing  planners 
terms planning capabilities problems attempted solved planner  table
summarizes results domain variants ipc    lpg td sgplan  chen  hsu 
  wah b         planners supporting major features pddl   
pddl     planners good success ratio  close       downward  helmert 
      yahsp  vidal        success ratio better lpg td sgplan 
handle propositional domains  downward supports derived predicates 
yahsp not   sgplan attempted problems lpg td tested
compiled version variants derived predicates timed initial literals    
moreover  lpg td attempt numerical variant two versions promela
domain adl variant psr large  use equality numerical
preconditions conditional effects  currently planner support 
figure   shows performance lpg td variants three domains involving
predictable exogenous events respect  satisficing  planners ipc   supporting timed initial literals  sgplan  p mep  sanchez et al         tilsapa  kavuluri
  u         airport  upper plots figure   lpg td solves    problems    
sgplan     p mep     tilsapa    terms cpu time  lpg td performs much better
p mep tilsapa  lpg td faster sgplan nearly problems  except
problems        particular  gap performance problems      nearly
one order magnitude  regarding plan quality  performance lpg td similar
performance p mep tilsapa  while  overall  sgplan finds plan worse quality
 with exception problems        sgplan performs slightly better 
easiest problems lpg td sgplan perform similarly  
lpg td tilsapa planners ipc   attempted variant
pipesworld timed initial literals  central plots figure     lpg td solves    problems     tilsapa solves   problems  domain variant lpg td performs
much better tilsapa 
flaw version umts  bottom plots figure     lpg td solves    problems 
sgplan solves    problems  p mep tilsapa attempt domain variant  
moreover  lpg td one order magnitude faster sgplan every problem
solved  compared ipc   benchmark problems  umts problems generally
easier solve  test problems  main challenge finding plans good quality 
overall  best quality plans lpg td much better sgplan plans  except
simplest problems two planners generate plans similar quality  basic
version umts without flawed actions  sgplan solves problems lpg td  terms
plan quality lpg td performs much better 
figure   shows results wilcoxon sign rank test  known wilcoxon
matched pairs test  wilcoxon   wilcox         comparing performance lpg td
planners attempted benchmark problems ipc   involving timed initial literals  test used long fox      a  comparing performance
    versions generated planners support features pddl    
competition test lpg td problems compiled domains planner
supports original version domains  lpg td attempted every problem  uncompiled 
ipc   domains could attempt terms planning language supports 

   

fian approach temporal planning scheduling

airport windows

milliseconds
 e   

lpg td s     solved 
p mep     solved 
sgplan     solved 
tilsapa    solved 

 e   

airport windows

makespan
    

lpg td bq     solved 
p mep     solved 
sgplan     solved 
tilsapa    solved 

    

    
      
   
     
   
    
   
   

   

  

 
 

 

  

  

  

  

  

  

  

  

pipesworldnotankage deadlines

milliseconds
 e   

 

 

  

  

  

  

  

  

  

  

pipesworldnotankage deadlines

makespan
  

lpg td bq     solved 
tilsapa    solved 

lpg td s     solved 
tilsapa    solved 
 e   

  

      

  

     

  

    

  

   

 

  

 
 

 

  

  

  

  

  

umtsflaw windows

milliseconds
     

 

 

  

  

  

  

  

umtsflaw windows

makespan
    

lpg td s     solved 
sgplan     solved 

lpg td bq     solved 
sgplan     solved 
    
    

    

    
    
    

   

    
    
    

  

    
 

 

  

  

  

  

  

  

  

  

  

 

 

  

  

  

  

  

  

  

  

figure    cpu time plan quality lpg td  p mep  sgplan  tilsapa three
ipc   domains timed initial literals  x axis problem
names simplified numbers  plots left  y axis
cpu milliseconds  logarithmic scale   plots right  y axis
plan makespan  the lower better  
   

  

figerevini  saetti   serina

lpg td s vs p mep
     
       
  

lpg td bq vs p mep
       
  

cpu time analysis
lpg td s vs sgplan
     
        
   

lpg td s vs tilsapa
      
       
   

plan quality analysis
lpg td bq vs sgplan lpg td bq vs tilsapa
     
     
       
       
   
  

figure    results wilcoxon test performance lpg td compared
ipc    satisficing  planners terms cpu times plan quality benchmark problems timed initial literals 

lpg td s

sgplan

tilsapa

p mep

cpu time

lpg td bq

sgplan

tilsapa

p mep



b 

consistently better b



b 

better b
significant number times
 confidence level        

plan quality

figure    partial order performance ipc    satisficing  planners according
wilcoxon test benchmark problems timed initial literals 
dashed arrow indicates performance relationship holds confidence
level slightly less       

ipc   planners  cpu time analysis  consider problems attempted
compared planners solved least one  when planner
solve problem  corresponding cpu time ieee arithmetic representation
positive infinity   plan quality  makespan  analysis  consider problems
solved compared planners 
   

fian approach temporal planning scheduling

order carry wilcoxon test  planning problem computed
difference cpu times two planners compared  defining samples
test cpu time analysis  similarly  test concerning plan quality
analysis computed differences makespan plans generated
two planners  absolute values differences ranked increasing numbers
starting lowest value   the lowest value ranked    next lowest value
ranked    on   sum ranks positive differences  sum
ranks negative differences  performance two planners significantly
different  number positive differences approximately equal
number negative differences  sum ranks set positive
differences approximately equal sum ranks set  intuitively 
test considers weighted sum number times one planner performs better
other  sum weighted test uses performance gap assign rank
performance difference 
cell figure   gives result comparison performance
lpg td another ipc   planner  number samples sufficiently large 
t distribution used wilcoxon test approximatively normal distribution 
therefore  cells figure contain z value p value characterizing
normal distribution  higher z value  significant difference
performance is  p value represents level significance performance gap 
use confidence level        hence  p value lower       
performance compared planners statistically different  information
appears left  right  side cell  first  second  planner named title
cell performs better planner    analysis comparing cputime  value cell number problems solved least one planner 
analysis comparing plan quality  number problems solved
planners 
figure   shows graphical description relative performance ipc   satisficing
planners according wilcoxon test benchmark problems timed initial
literals  solid arrow planner planner b  or cluster planners b 
indicates performance statistically different performance b 
performs better b  every planner b   dashed arrow b
indicates better b significant number times  significant
wilcoxon relationship b confidence level        on
hand  relationship holds confidence level slightly less         results
analysis say lpg td consistently faster tilsapa p mep 
faster sgplan significant number times  terms plan quality  lpg td performs
consistently better p mep  sgplan tilsapa 
although lpg td guarantee optimal plans  interesting compare
performance optimal planners took part ipc    especially see good
lpg tds plans are  figure   shows performance lpg td best results
results optimal ipc   planners  allothers opt  temporal variants
airport umts  without flawed actions   plots plan quality  makespan 
    p value cell comparing lpg td p mep omitted number problems solved
lpg td p mep high enough approximate t distribution normal distribution 

   

figerevini  saetti   serina

airport time

milliseconds
 e   

airport time

makespan
    

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

   

 e   

   
   

      

   
     

   
   

    

   
   

   

   
  

 
 

 

  

  

  

  

  

  

  

  

umts time

milliseconds
 e   

 

 

  

  

  

  

  

  

  

umts time

makespan
   

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

  

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

   

 e   
   
      
   

     

   

   
    
   
   
   

  

   
 

 

  

  

  

  

  

  

  

  

  

 

 

  

  

  

  

  

  

  

  

  

figure    performance lpg td best optimal planners ipc  
 allothers opt  airport time umts time  cpu time logarithmic scale
 left plots  plan makespan  right plots   x axis problem
names simplified numbers 

show that  nearly every problem domains  best quality plan found lpg td
optimal solution  first plan found lpg td generally good solution 
plots cpu time show lpg td finds plan much quickly
optimal planner  cpu time required lpg td find best plan often
lower cpu time required allothers opt  except problems           
   airport   noted lpg td bq last plan sequence
computed plans increasing quality  and cpu time   intermediate plans
sequence could already good quality  particular  shown plan quality plot
airport  first plan  lpg td s  solving problem    near optimal quality 
computed much quickly lpg td bq plan allothers opt plan 
   

fian approach temporal planning scheduling

figure     plan quality distance solutions found lpg td corresponding optimal solutions  x axis  classes quality distance
 e g         means plan generated lpg td worse
optimal plan factor            y axis 
percentage solved problems classes 

finally  figure    gives results general analysis plan quality distance 
considering metric temporal strips variants ipc   domains     analysis
uses problems solved least one ipc   optimal planner  important
note consider plans generated incremental process lpg td using
cpu time cpu time required fastest optimal planner  allothersopt   overall  results figure    provide significant empirical evidence supporting
claim often incremental local search approach allows us compute plans
good quality using less cpu time optimal approach  particular 
bars      class plot metric temporal problems show
percentage test problems best quality plan lpg td  lpg td bq 
optimal nearly optimal  i e   plan quality worse optimal factor
          meaning difference       moreover  often first plan
computed lpg td  lpg td s  good quality      plans quality
optimal nearly optimal      quality worse
optimal factor greater     
interestingly  plot right figure    shows similar results concerning good
quality lpg tds plans strips problems ipc    with lower percentage
lpg td s plans      class  slightly higher percentage
lpg td bqs plans       class  
    temporal reasoning lpg td
conducted two main experiments  first aimed testing performance
lpg td number windows timed initial literals varies problems
    strips problems  plan quality metric number actions plan 

   

figerevini  saetti   serina

initial state goals  second experiment focused temporal
reasoning techniques main goals empirically evaluating performance 
understanding impact overall performance lpg td 
experiments used two well known ipc   domains  modified
include timed initial literals  rovers zenotravel  version rovers timed
initial literals obtained ipc   temporal version follows  problem
specification  waypoint  added collection pairs timed initial literals
type
 at t   in sun waypoint   
 at t   not  in sun waypoint    

t    t    pairs defines time window involved literal 
operator specification file  recharge operator precondition
 over  in sun  w  

imposes constraint recharging actions applied rover
sun   w operator parameter representing waypoint recharging action  
modified version zenotravel obtained similarly  problem specification 
city added collection pairs timed initial literals type
 at t   open station city   
 at t   not  open station city    

operator specification file  added timed precondition
 over  open station  c  

refuel operator   c operator parameter representing city
refuel action executed 
given planning problem collection time windows w timed literal  
noted that  general  difficulty solving affected three parameters 
number windows w   size  way distributed time
line    considered two methods generating test problems taking account
parameters   indicates original ipc   problem either rovers zenotravel
domain  n indicates number windows w   
 i  let best  shortest makespan  plan among generated lpg td
solving within certain cpu time limit  makespan   time
interval     t  divided  n   sub intervals equal size  time windows
timed literal extended problem   odd sub intervals     t  
i e  

nh
h

h
 t

 t
   n 
 

 
w       n 
   n 
            n  t
 n 
 ii  let maximum duration action timed precondition  
time interval         n     divided  n   sub intervals duration d 
    general  parameters influence hardness temporal reasoning planning 
logical part planning process  i e   selection actions forming plan 
lpg td done using heuristics taking exogenous events account  

   

fian approach temporal planning scheduling

rovers windows

milliseconds
     

zenotravel windows

milliseconds
 e   

  time window per waypoint
   time windows per waypoint

  time window per city
   time windows per city

      

    
     

    
   

   

  

  
 

 

 

 

 

  

  

  

  

  

  

 

 

 

 

 

  

  

  

  

  

  

figure     performance lpg td rovers zenotravel domains extended
timed initial literals       time windows timed literal   test
problems generated using method i  x axis problem
names simplified numbers  y axis cpu milliseconds  logarithmic scale  

similarly method  i   time windows extended problem  
odd sub intervals  
notice use first method number windows relatively
small because  many time windows small size  extended problem
become unsolvable  no window large enough schedule necessary action
timed precondition   second method designed avoid problem 
used test techniques planning problems involving many time windows 
figures       give results first experiment  cpu times plots
median values five runs problem  results figure     use
ipc   test problems modified method i  results figure    use
ipc   test problems modified method ii  cases lpg td solves problems 
plots figure    indicate performance degradation number
windows increases      generally moderate  except two cases  plots
figure    indicate that  number windows increases exponentially  
        approach scales well benchmark problems considered  instance 
consider first zenotravel problem    window lpg td solves problem   
milliseconds     windows    milliseconds      windows    milliseconds 
     windows     milliseconds         windows   second 
moreover  observed performance degradation mainly determined heavier
pre processing phase  parsing instantiation operators  
tables     give results concerning experiment temporal reasoning
techniques implemented lpg td  consider problems    time windows
 for timed fluent  used tests figure     examine computational
   

figerevini  saetti   serina

performance lpg td rovers timewindows

milliseconds
      

performance lpg td zenotravel timewindows

milliseconds
 e   

  time window per waypoint
   time windows per waypoint
    time windows per waypoint
     time windows per waypoint
       time windows per waypoint

  time window per city
   time windows per city
    time windows per city
     time windows per city
       time windows per city

      

     

     
    
    

   
   

  

  
 

 

 

 

 

  

  

  

  

  

  

 

 

 

 

 

  

  

  

  

  

  

figure     performance lpg td rovers zenotravel domains extended
timed initial literals          time windows timed literal   test
problems generated using method ii  x axis problem
names simplified numbers  y axis cpu milliseconds  logarithmic scale  

cost temporal reasoning planning problems  approach temporal
planning  search step defines set temporal constraints formed ordering
scheduling constraints current tda graph  table   gives statistical information
dtps using compact constraint representation lpg td classical
dtp representation  action tda graph  two temporal variables
 the start end times action   except astart aend  for which  pointed out 
use one variable   number scheduling constraints number
ordering constraints depend actions current tda graph 
actions  causally exclusively  related other  respectively  we
one scheduling constraint action timed precondition tda graph  
notice representation scheduling constraints much compact
classical dtp formulation   
table gives information average number dtps  i e   search steps 
generated planning  indicating many satisfiable  indicated
sat  dtps  
table   gives cpu time required temporal reasoning techniques implemented
lpg td  solve dtp    tsat    armando  castellini  giunchiglia    maratea 
       state of the art general dtp solver  dtps considered
table    i e   sets temporal constraints tda graph search
    classical dtp translation scheduling constraint contains exponential number disjuncts
respect number time windows scheduling constraint  example  let q
timed precondition wq                          scheduling constraint determined q

 

translated four classical dtp constraints  as abbreviates astart     a 
       
 
 

 
 
 
 
 

 
 

  







    
 a



  



     
 a





  




 a 
     






   

fian approach temporal planning scheduling

problems
rovers
problem  
problem  
problem   
problem   
problem   
zenotravel
problem  
problem  
problem   
problem   
problem   

variables
max mean
  
  
  
  
   

    
    
    
    
     

 
  
   
   
   

 
  
    
     
     

sc    windows  dc 
max
mean
 
 
 
 
 

      
      
      
      
      

        
        
           
           
           

dtps
 sat  dtps 

            
            
           
           
           

       
       
        
       
         

            
            
             
             
             

     
       
          
         
         

table    characteristics dtps generated planning lpg td solving
problems rovers zenotravel domains  maximum mean number variables   nd  rd columns   maximum mean number scheduling constraints  sc  non unary disjunctions  dc  dtp form translation   th  th columns   number dtps satisfiable dtps solved lpg td
  th column  

step planning process  noted comparison solve dtp  
tsat   means intended determine one better other  indeed
tsat   developed manage much larger class dtps  however  best
knowledge exists specialized dtp solver handling scheduling constraints could used  goal comparison experimentally show
existing general dtp solvers  although designed work efficiently general case 
adequate managing class dtps arise planning framework 
hence  important develop specialized techniques which  empirically demonstrated results table    much efficient  instance  consider problem
   rovers domain  indicated last column table    lpg td solves
problem    search steps  defines    dtps  data table   show
total cpu time spent lpg td solving temporal reasoning problems
negligible        seconds   tsat   requires      cpu seconds total  note
whole temporal planning problem solved lpg td      seconds      overall 
specialized temporal reasoning technique several orders magnitude faster
efficient general dtp  terms cpu time solving single dtp  cpu time
solving dtps generated planning 
    cpu time tsat   includes neither generation explicit  classical  dtps tdagraph  parsing time  moreover  tsat   decides satisfiability input dtps 
solve dtp  finds schedule optimal  dtp satisfiable 

   

figerevini  saetti   serina

problems

rovers
problem  
problem  
problem   
problem   
problem   
zenotravel
problem  
problem  
problem   
problem   
problem   

cpu seconds temporal reasoning
solve dtp 
tsat  
max
mean
total
max
mean
total

total
cpu time
lpg td

     
     
     
     
    

     
     
     
     
      

     
     
     
     
    

     
     
    
    
    

     
     
     
     
    

    
    
    
    
     

    
    
    
    
    

     
     
    
    
    

     
     
       
       
       

     
     
   
    
   

     
    
   
    
     

      
     
   
   
    

    
    
    
      
       

    
    
    
    
     

table    performance solve dtp  tsat   dtps generated planning
lpg td solving problems rovers zenotravel domains 
maximum  mean total cpu seconds  last column gives total cputime lpg td solving planning problem  tsat   run using default
settings 

finally  experimentally tested effectiveness improvements solve dtp  
making algorithm incremental described end section    such
improvements included implementation solve dtp  table     particular
observed that  problems table    average cpu time basic  nonincremental  version solve dtp  one three orders magnitude higher
incremental version  however  basic version still always significantly faster
tsat    from one four orders magnitude  

   related work
several researchers addressed temporal reasoning context dtp framework  general techniques aimed efficiently solving dtp proposed
 e g   armando et al         tsamardinos   pollack         worst case complexity
remains exponential  section    presented experimental results indicating
simple use state of the art dtp solver adequate solving subclass
dtps arise context 
various planning approaches supporting temporal features considered paper
proposed  one first planners capable handling predictable
exogenous events deviser  vere         developed nonlin  tate        
deviser temporal partial order planner using network activities called plan
network  starting plan generation  plan network contains exogenous events
   

fian approach temporal planning scheduling

explicit nodes network  plan generation  activities added network
ordered respect scheduled events  depending relevance events
activities  similar explicit treatment exogenous events could adopted
context action graph representation  initial action graph contains special
action nodes representing predicted exogenous events  however  simple method
disadvantages respect method  treats exogenous events
temporal level representation rather logical  causal  level  particular 
high number timed initial literals  explicit representation
exogenous events action graph could lead large graphs  causing memory
consumption problems possibly heavy cpu time cost heuristic evaluation
 possibly large  search neighborhood 
late   s early   s temporal planners handling exogenous events
developed  general  systems use input descriptions planning problem domain significantly different pddl descriptions accepted modern
fully automated planners  one successful among hsts  frederking  
muscettola        muscettola         representation problem solving framework
provides integrated view planning scheduling  hsts represents predictable exogenous events non controllable state variables  lpg td hsts manage
temporal constraints  two systems use considerably different approaches temporal
planning  lpg td adopts classical state transition view change  hsts adopts
histories view change  ghallab  nau    traverso         based
different plan representations search techniques 
zeno  penberthy        penberthy   weld        one first domain independent
planners supports rich class metric temporal features  including exogenous events 
zeno powerful extension causal link partial order planner ucpop  penberthy  
weld         however  terms computational performance  planner competitive recent temporal planners 
ixtet  ghallab   laruelle        laborie   ghallab        another causal link planner uses techniques ideas scheduling  temporal constraint reasoning 
graph algorithms  ixtet supports expressive language temporal description actions  including timed preconditions features cannot
expressed pddl     expressive power language obtained cost increased semantic complexity  fox   long         observed ghallab  nau traverso
        ixtet embodies compromise expressiveness complex temporal domains  planning efficiency  however  planner still remains noncompetitive
recent temporal planners 
smith weld        studied extension graphplan style planning
managing temporal domains  proposed extension tgp planner makes
possible represent predictable exogenous events  tgp supports subclass
durative actions expressible pddl     prevents cases concurrency
pddl    admitted  tgp optimal planner  under assumed conservative
model action concurrency   lpg td near optimal  satisficing  planner  main
drawback tgp scale adequately 
recently  edelkamp        proposed method planning timed initial
literals based compiling action timed preconditions time window as   

figerevini  saetti   serina

sociated action  defining interval action scheduled 
gives efficient  polynomial algorithm based critical path analysis computing
optimal action schedule sequential plans generated using compiled representation  techniques presented edelkamp assume unique time window
timed precondition  techniques propose general  sense
action representation treats multiple time windows associated timed precondition 
temporal reasoning method computes optimal schedules partially ordered plans
preserving polynomiality 
cresswell coddington        proposed extension lpgp planner  long
  fox      b  handle timed initial literals  represented special deadline
actions  literal asserted hold time represented deadline action
starting time initial state  duration t  deadline actions
plan construction translated particular linear inequalities that  together
equalities inequalities generated plan representation  managed
general linear programming solver  lpg td uses different representation
encode timed initial literals special actions  temporal scheduling
constraints associated actions plan managed efficient algorithm
derived specializing general dtp solver 
order handle problems timed initial literals sapa planner  do   kambhampati         do  kambhampati zimmerman        proposed forward search
heuristic based relaxed plans  constructed exploiting technique similar
time slack analysis used scheduling  smith   cheng         given set candidate
actions choosing action add relaxed plan construction  technique
computes minimum slack candidate action actions currently
relaxed plan  candidate action highest minimum slack preferred  lpg td
uses different time slack analysis  exploited different way  method
selecting actions forming relaxed plan uses time slacks counting number
scheduling constraints would violated adding candidate action  prefer
candidate actions cause lowest number violations  moreover  sapa
slack analysis limited actions relaxed plan  method considers
actions real plan construction 
dt pop recent planner  schwartz   pollack        extending pop style
planning action model involving disjunctive temporal constraints  language
dt pop elegant express rich class temporal features 
indirectly  and less elegantly  expressed pddl     fox et al          treatment
temporal constraints required manage predictable exogenous events dt pop
appears less efficient planner  since dt pop uses general dtp solver
enhanced efficiency techniques  lpg td uses polynomial solver specialized
subclass dtps arise representation  dt pop handles mutex actions
 threats  posting explicit temporal disjunctive constraints imposing disjointness
mutex actions  lpg td implicitly decides disjunctions search time
choosing level graph actions inserted  asserting appropriate
precedence constraints  moreover  search procedure heuristics dt pop lpgtd significantly different 
   

fian approach temporal planning scheduling

ipc    planners reasoned timed initial literals tilsapa  kavuluri  
u         sgplan  chen et al          p mep  sanchez et al         lpg td  first
two planners  time writing  best knowledge available literature
sufficiently detailed description clearly understand possible similarities
differences lpg td treatment predictable exogenous events  regarding
p mep  planner uses forward state space search guided relaxed plan heuristic which 
differently relaxed plans lpg td  constructed without taking account
temporal aspects relaxed plan real plan construction  the makespan
constructed relaxed plans considered comparative evaluation  

   conclusions
presented techniques temporal planning domains certain fluents
made true false known times predictable exogenous events cannot
influenced actions available planner  external events present many
realistic domains  planner take account guarantee correctness
synthesized plans  generate plans good optimal quality  makespan  
use effective search heuristics fast planning 
approach  causal structure plan represented graph based representation called tda graph  action ordering scheduling constraints managed
efficient constraint based reasoning  plan search based stochastic local search
procedure  proposed algorithm managing temporal constraints
tda graph specialization general csp based method solving dtps 
algorithm polynomial worst case complexity and  combined plan
representation  practice efficient  presented local search
techniques temporal planning using new tda graph representation  techniques improve accuracy heuristic methods adopted previous version
lpg  extend consider action scheduling constraints evaluation
search neighborhood  based relaxed temporal plans exploiting  dynamic 
reachability information 
techniques implemented planner lpg td  experimentally
investigated performance planner statistical analysis ipc   results
using wilcoxons test  results analysis show planner performs well
compared recent temporal planners supporting predictable exogenous events 
terms cpu time find valid plan quality best plan generated  moreover 
comparison plans computed lpg td generated optimal planners
ipc   shows often lpg td generates plans good optimal quality 
finally  additional experiments indicate temporal reasoning techniques manage
class dtps arise context efficiently 
directions future work temporal planning within framework are 
extension local search heuristics temporal reasoning techniques explicitly handle action effects limited persistence delays  treatment predictable exogenous
events affecting numerical fluents discrete continuous way  development tech   

figerevini  saetti   serina

niques supporting controllable exogenous events    management actions
variable durations  fox   long         i e   actions whose durations specified
inequalities constraining lower upper bounds  whose actual duration decided
planner 
moreover  intend study integration framework techniques
goal partitioning subplan composition successfully used sgplan
 chen et al         ipc    application approach plan revision 
latter already partially explored  simple strips domains using
less powerful search techniques  gerevini   serina        

acknowledgments
paper revised extended version paper appearing proceedings
nineteenth international joint conference artificial intelligence  gerevini  saetti   
serina      a   research supported part miur grant anemone  work
ivan serina part carried department computer information
sciences university strathclyde  glasgow  uk   supported marie curie
fellowship n hpmf ct             would thank anonymous reviewers
helpful comments  paolo toninelli extended parser lpg td handle
new language features pddl    

appendix a  reachability information
techniques described paper computing action evaluation function use
heuristic reachability information minimum number actions required reach
preconditions domain action  n um acts  lower bound earliest
finishing time  ef t  reachable actions  the actions whose preconditions reachable  
following  s l  denotes state defined facts corresponding fact nodes
supported level l current tda graph  l      s l  represents initial state
planning problem  i  
action a  lpg td pre computes n um acts a  i   i e   estimated minimum
number actions required reach preconditions i  ef t a  i   i e  
estimated earliest finishing time  if reachable i   similarly  fact f
reachable i  lpg td computes estimated minimum number actions required
reach f  n um acts f  i   estimated earliest time f made
true plan starting  et f  i    l      n um acts a  s l   ef t a  s l  
computed search  depend action nodes
current tda graph levels preceding l  since search many action nodes
added removed  operations n um acts a  s l   ef t a  s l  
could change  if operation concerns level preceding l   important
computed efficiently 
    consider instance transportation domain shuttle bus train station extra
run airport midnight booked advance  shuttle booking domain action
available planner  event night stop shuttle controlled planner 

   

fian approach temporal planning scheduling

reachabilityinformation i  o 
input  initial state planning problem consideration  i  ground instances
 actions  operators  o  
output  action a  estimate number actions  n um acts a  i   required reach
preconditions i  estimate earliest finishing time  ef t a  i   
  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

forall facts f    set facts precomputed operator instantiation phase   
f
n um acts f  i  et f  i     action f  i  astart  
else n um acts f  i  et f  i   
forall actions n um acts a  i  ef t a  i  lf t a   
f i  fnew i  o  arev  
  fnew    arev     
f f fnew   fnew   arev   arev  
a     a   p re a  f   empty
action a   
computeeft a  ax et f  i   
f p re a 

  ef t a  i  ef t a  i  t 
lf t a  computelft a  
ef t a  i  lf t a     scheduled   
ra requiredactions i  p re a   
n um acts a  i    ra n um acts a  i  ra 
forall f add a 
et f  i   
et f  i  t 
arev arev  a    f p re a     
n um acts f  i     ra     
n um acts f  i  ra      action f  i  a 
fnew fnew add a  f  
 a  

requiredactions i  g 
input  set facts set action preconditions g 
output  estimate min number actions required achieve facts g  acts  
  
  
  
  
  
  
  
  

act  
g g i 
g   
g element g 
action g  i  
act act  a  
g g p re a  bact add b  
return  act s   

figure     algorithms computing heuristic information search cost
time reaching set facts g i 

   

figerevini  saetti   serina

figure    gives reachabilityinformation  algorithm used lpg td computing
n um acts a  i   ef t a  i   n um acts f  i  et f  i   reachabilityinformation similar
reachability algorithm used version lpg took part      planning
competition  lpg ipc    significant differences  main differences are 
 i  order estimate earliest finishing time domain actions  reachabilityinformation takes account scheduling constraints  considered
previous version algorithm 
 ii  algorithm used lpg ipc  applies domain action once  reachabilityinformation apply once 
notice  i  improves accuracy estimated finishing time actions
 ef t   important piece information used search neighborhood
evaluation selecting actions forming temporal relaxed plans  see section    
moreover   i  allows us identify domain actions cannot scheduled
time windows associated timed preconditions  pruned
away 
regarding  ii   forward process computing reachability information 
action re applied whenever estimated earliest time one preconditions
decreased  important two reasons  one hand  reconsidering actions already
applied useful lead better estimate action finishing times 
hand  necessary guarantee correctness reachability
algorithm  latter because  overestimate earliest finishing time action
scheduling constraint  could incorrectly conclude action cannot
scheduled  and would consider action inapplicable   action necessary
valid plan  incorrect estimate earliest finishing time could lead
incorrect conclusion planning problem unsolvable  words  estimated
finishing time action scheduling constraint lower bound actual
earliest finishing time 
reachabilityinformation could used update n um acts a  s l   ef t a  s l  
action insertion removal  l      when l      instead i  input algorithm
s l    however  order make updating process efficient  revision done
selective focused way  instead revising reachability information
graph modification  search step   evaluating search neighborhood
choosing estimated best modification  specifically  repairing flawed level l 
update reachability information actions facts levels preceding
l updated yet   for instance  suppose ith search step add
action level     i     th step add another action level    
 i     th step need consider updating reachability information levels
     since information levels    already updated ith step  
sufficient search neighborhood repairing flawed level consideration
 l  contain graph modifications concerning levels preceding l 
describing steps reachabilityinformation  need introduce notation  add  a  denotes set positive effects a  pre a  denotes set
 non timed  preconditions a  arev denotes set actions already applied whose
   

fian approach temporal planning scheduling

reachability could revised estimated earliest time preconditions revised application  given action node current
earliest start time computed maximum earliest times preconditions reachable  computeeft  a  t  function computing earliest finishing
time consistent scheduling constraint  if any 
  dur a      computelft  a  function computing latest finishing time
action a  i e   returns upper bound last time window
scheduled  if one exists   returns timed precondition 
example  let action preconditions true initial
state  i e         duration     scheduling constraint imposing
action executed interval            computeeft  a  t  returns    
computelft  a  t  returns      thus  scheduling constraint satisfied 
contrary  earliest start time      computeeft  a  t  returns    
cannot scheduled           
sake clarity  first describe steps reachabilityinformation used derive
n um acts  comment computation ef t  steps    
every fact f   algorithm initializes n um acts f  i     f i  otherwise
 indicating f reachable   while  step    n um acts a  i  initialized
 indicating reachable i   then  steps     algorithm iteratively
constructs set f facts reachable i  starting f   i 
terminating f cannot extended set arev actions reconsider
empty  set available actions initialized set possible actions
 step     reduced application  step      augmented set
actions arev  step    action application  modify estimated time
precondition action becomes reachable  added rev  step     
internal while loop  steps      applies actions current f   possibly deriving
new set facts fnew step     fnew arev empty  f extended
fnew   extended arev   internal loop repeated  action a 
 the subset actions currently applicable f   applied  reachability
information effects revised follows  first estimate minimum number
ra actions required achieve p re a  using subroutine requiredactions  step
     use ra possibly update n um acts a  i  n um acts f  i  effect
f  steps              number actions required achieve preconditions
lower current value n um acts a  i   n um acts a  i  set ra 
moreover  application leads lower estimate f   i e   ra     less
current value n um acts f  i   n um acts f  i  set ra      addition  data
structure indicating current best action achieve f  action f  i   set
 step      information used subroutine requiredactions 
fact f initial state  value action f  i  astart  step    
subroutine requiredactions one reachability algorithm lpg ipc  
subroutine uses action derive ra backward process starting input
set action preconditions  g   ending g i  subroutine incrementally
constructs set actions  acts  achieving facts g preconditions
    scheduling constraint associated a  existing scheduling constraints cannot
satisfied starting action t  computeeft  a  t  returns   dur a  

   

figerevini  saetti   serina

actions already selected  using action   iteration set g revised adding
preconditions last action selected  removing facts belonging
effects actions already selected  step     termination requiredactions guaranteed
every element g reachable i 
briefly describe computation temporal information  eft a  i   computed way similar n um acts a  i   steps     reachabilityinformation initializes
estimated earliest time  et f  i   fact f becomes reachable    f i 
otherwise  moreover  algorithm sets ef t a  i  lf t a  i    then  every
application action forward process described above  estimate earliest
finishing time ef adding duration  current  maximum estimated earliest
time preconditions a  taking account scheduling constraints
using computeeft  a   step      addition  compute latest finishing time lf
using computelft  a   step      earliest finishing time action
greater latest finishing time  timed preconditions cannot satisfied
i  steps      executed  see if statement step      effect f
current temporal value higher earliest finishing time a  steps     
set et f  i  t  step    adds arev  because decreased estimated
earliestx time f   revision could decrease estimated start time action
precondition f   

appendix b  wilcoxon test metric temporal domains ipc  
appendix  present results wilcoxon sign rank test performance
lpg td satisficing ipc   planners attempted metric temporal
domains  performance evaluated terms cpu times plan quality 
cell first two tables gives result comparison performance
lpg td another ipc   planner  number samples sufficiently large 
t distribution used wilcoxon test approximatively normal distribution  hence 
cell figure give z value p value characterizing normal
distribution  higher z value  significant difference performance
is  p value represents level significance difference performance 
use confidence level        therefore  p value lower       
performance two planners statistically different  information appears
left  right  side cell  first  second  planner named title cell
performs better other  analysis comparing cpu time  value
cell number problems solved least one planner  analysis
comparing plan quality  number problems solved planners 
pictures tables show partial order performance compared
planners terms cpu time plan quality  solid edge planner another
planner b  or cluster planners b  indicates performance statistically
different performance b  performs better b  every planner
b   dashed edge b indicates better b significant number
times  significant wilcoxon relationship confidence level
      
   

fian approach temporal planning scheduling

lpg td s vs crikey
      
       
   

analysis cpu time
lpg td s vs p mep
lpg td s vs sgplan
      
     
       
       
   
   

lpg td s vs tilsapa
      
       
   

lpg td bq vs crikey
      
       
   

analysis plan quality
lpg td bq vs p mep lpg td bq vs sgplan
     
      
       
       
  
   

lpg td bq vs tilsapa
     
       
  

lpg td s
crikey

p mep

tilsapa

sgplan

cpu time

sgplan
lpg td bq
p mep

crikey



b 

consistently better b

tilsapa



b 

better b significant number times
 confidence level        

plan quality

   

figerevini  saetti   serina

references
armando  a   castellini  c   giunchiglia  e     maratea  m          sat based decision
procedure boolean combination difference constraints  proceedings
seventh international conference theory applications satisfiability testing
 sat      berlin  heidelberg  new york  springer verlag  sat      lncs volume 
blum  a     furst  m          fast planning planning graph analysis  artificial
intelligence      pp         
chen  y   hsu  c     wah b   w          sgplan  subgoal partitioning resolution
planning  edelkamp  s   hoffmann  j   littman  m     younes  h   eds   
abstract booklet competing planners icaps     pp       
cresswell  s     coddington  a          adapting lpgp plan deadlines  proceedings sixteenth european conference artificial intelligence  ecai     
pp          amsterdam  netherlands  ios press 
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence      pp       
do  m   b   kambhampati  s     zimmerman  t          planning   scheduling connections
exogenous events  proceedings icaps    workshop integrating
planning scheduling  pp       
do  m     kambhampati  s          sapa  multi objective metric temporal planner 
journal artificial intelligence research  jair       pp         
edelkamp  s          extended critical paths temporal planning  proceedings
icaps    workshop integrating planning scheduling  pp       
edelkamp  s     hoffmann  j          pddl     language classic part
 th international planning competition  technical report      institut fur informatik 
freiburg  germany 
edelkamp  s   hoffmann  j   littman  m     younes  h         abstract booklet
competing planners icaps    
erschler  j   roubellat  f     vernhes  j  p          finding essential characteristics
feasible solutions scheduling problem  operations research  or       pp 
       
fox  m     long  d          pddl     extension pddl expressing temporal
planning domains  journal artificial intelligence research  jair       pp        
fox  m     long  d          planning time  fisher  m   gabbay  d     vila  l   eds   
handbook temporal reasoning artificial intelligence  pp          elsevier science publishers  new york  ny  usa 
fox  m   long  d     halsey  k          investigation expressive power
pddl     proceedings sixteenth european conference artificial intelligence  ecai      pp          amsterdam  netherlands  ios press 
frederking  r   e     muscettola  n          temporal planning transportation planning scheduling  ieee international conference robotics automation
 icra      pp            ieee computer society press 
   

fian approach temporal planning scheduling

gerevini  a     cristani  m          finding solution temporal constraint satisfaction
problems  proceedings fifteenth international joint conference artificial
intelligence  ijcai      vol     pp            san francisco  ca  usa  morgan
kaufmann publishers 
gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs  journal artificial intelligence research  jair       pp 
       
gerevini  a   saetti  a     serina  i          empirical analysis heuristic features
local search lpg  proceedings fourteenth international conference
automated planning scheduling  icaps      pp          menlo park  ca 
usa  aaai press 
gerevini  a   saetti  a     serina  i       a   integrating planning temporal reasoning domains durations time windows  proceedings nineteenth
international joint conference artificial intelligence  ijcai      pp           
menlo park  ca  usa  international joint conference artificial intelligence inc 
gerevini  a   saetti  a   serina  i     toninelli  p       b   fast planning domains
derived predicates  approach based rule action graphs local search 
proceedings twentieth national conference artificial intelligence  aaai     pp            menlo park  ca  usa  aaai press 
gerevini  a     serina  i          fast planning greedy action graphs  proceedings
sixteenth national conference artificial intelligence  aaai      pp     
     menlo park  ca  usa  aaai press mit press 
gerevini  a     serina  i          fast plan adaptation planning graphs  local
systematic search techniques  proceedings fifth international conference
artificial intelligence planning scheduling  aips      pp          menlo park 
ca  usa  aaai press mit press 
ghallab  m     laruelle  h          representation control ixtet  temporal planner  proceedings second international conference artificial intelligence
planning systems  aips      pp        menlo park  ca  usa  aaai press 
ghallab  m   nau  d     traverso  p          automated planning  theory practice 
morgan kaufmann publishers  san francisco  ca  usa 
glover  f     laguna  m          tabu search  kluwer academic publishers  boston  usa 
helmert  m          planning heuristic based causal graph analysis  proceedings
fourteenth international conference automated planning scheduling
 icaps      pp          menlo park  ca  usa  aaai press 
kavuluri  b  r     u  s          tilsapa   timed initial literals using sapa  edelkamp  s  
hoffmann  j   littman  m     younes  h   eds    abstract booklet competing
planners icaps     pp       
laborie  p     ghallab  m          planning sharable resource constraints  proceedings fourteenth international joint conference artificial intelligence
 ijcai      vol     pp            san francisco  ca  usa  morgan kaufmann publishers 
   

figerevini  saetti   serina

long  d     fox  m       a    rd international planning competition  results
analysis  journal artificial intelligence research  jair       pp      
long  d     fox  m       b   exploiting graphplan framework temporal planning 
proceedings thirteenth international conference automated planning
scheduling  icaps      pp        menlo park  ca  usa  aaai press 
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
ninth national conference artificial intelligence  aaai      pp         
menlo park  ca  usa  aaai press 
muscettola  n          hsts  integrating planning scheduling  zweben    fox
 eds    intelligent scheduling  pp          san francisco  ca  usa  morgan kaufmann publishers 
nguyen  x     kambhampati  s          reviving partial order planning  proceedings
seventeenth international joint conference artificial intelligence  ijcai     
vol     pp          san francisco  ca  usa  morgan kaufmann publishers 
penberthy  j     weld  d          ucpop  sound  complete  partial order planner
adl  proceedings third international conference principles knowledge
representation reasoning  kr     pp          san mateo  ca  usa  morgan
kaufmann publishers 
penberthy  j     weld  d          temporal planning continuous change  proceedings
twelfth national conference artificial intelligence  aaai      pp      
      menlo park  ca  usa  aaai press mit press 
penberthy  j   s          planning continuous change  ph d  thesis  university
washington  seattle  wa  usa  available technical report uw cse          
sanchez  j   tang  m     mali  a   d          p mep  parallel expressive planner 
edelkamp  s   hoffmann  j   littman  m     younes  h   eds    abstract booklet
competing planners icaps     pp       
schwartz  p   j     pollack  m   e          planning disjunctive temporal constraints 
proceedings icaps    workshop integrating planning scheduling 
pp       
smith  d     weld  d          temporal planning mutual exclusive reasoning 
proceedings sixteenth international joint conference artificial intelligence
 ijcai      pp          san francisco  ca  usa  morgan kaufmann publishers 
smith  s     cheng  c          slack based heuristics constraint satisfaction scheduling 
proceedings eleventh national conference artificial intelligence  aaai     pp          menlo park  ca  usa  aaai press the mit press 
stergiou  k     koubarakis  m          backtracking algorithms disjunctions temporal
constraints  artificial intelligence           pp        
tate  a          generating project networks  proceedings fifth international
joint conference artificial intelligence  ijcai      pp          cambridge  ma 
usa  mit  william kaufmann 
   

fian approach temporal planning scheduling

tsamardinos  i     pollack  m  e          efficient solution techniques disjunctive
temporal reasoning problems  artificial intelligence             pp       
vere  s  a          planning time  windows durations activities goals  ieee
transactions pattern analysis machine intelligence         pp         
vidal  v          lookahead strategy heuristic search planning  proceedings
fourteenth international conference automated planning scheduling  icaps     pp          menlo park  ca  usa  aaai press 
wilcoxon  f     wilcox  r  a          rapid approximate statistical procedures 
american cyanamid co   pearl river  ny  usa 

   


