journal of artificial intelligence research                  

submitted        published      

an approach to temporal planning and scheduling in
domains with predictable exogenous events
alfonso gerevini
alessandro saetti
ivan serina

gerevini ing unibs it
saetti ing unibs it
serina ing unibs it

dipartimento di elettronica per lautomazione
universita degli studi di brescia
via branze     i       brescia  italy

abstract
the treatment of exogenous events in planning is practically important in many realworld domains where the preconditions of certain plan actions are affected by such events 
in this paper we focus on planning in temporal domains with exogenous events that happen
at known times  imposing the constraint that certain actions in the plan must be executed
during some predefined time windows  when actions have durations  handling such temporal constraints adds an extra difficulty to planning  we propose an approach to planning
in these domains which integrates constraint based temporal reasoning into a graph based
planning framework using local search  our techniques are implemented in a planner that
took part in the  th international planning competition  ipc     a statistical analysis
of the results of ipc   demonstrates the effectiveness of our approach in terms of both
cpu time and plan quality  additional experiments show the good performance of the
temporal reasoning techniques integrated into our planner 

   introduction
in many real world planning domains  the execution of certain actions can only occur during
some predefined time windows where one or more necessary conditions hold  for instance 
a car can be refueled at a gas station only when the gas station is open  or a space telescope
can take a picture of a certain planet region only when this region is observable  the truth
of these conditions is determined by some exogenous events that happen at known times 
and that cannot be influenced by the actions available to the planning agent  e g   the
closing of the gas station or the planet movement  
several frameworks supporting action durations and time windows have been proposed
 e g   vere        muscettola        laborie   ghallab        schwartz   pollack       
kavuluri   u        sanchez  tang    mali         however  most of them are domaindependent systems or are not fast enough on large scale problems  in this paper  we propose
a new approach to planning with these temporal features  integrating constraint based
temporal reasoning into a graph based planning framework 
the last two versions of the domain definition language of the international planning competition  ipc  support action durations and predictable  deterministic  exogenous
events  fox   long        edelkamp   hoffmann         in pddl     predictable exogenous events can be implicitly represented  fox  long    halsey         while in pddl   
they can be explicitly represented through timed initial literals  one of the two new pddl
c
    
ai access foundation  all rights reserved 

figerevini  saetti   serina

features on which the      competition  ipc    focused  timed initial literals are specified
in the description of the initial state of the planning problem through assertions of the form
 at t l   where t is a real number  and l is a ground literal whose predicate does not
appear in the effects of any domain action  the obvious meaning of  at t l  is that l is
true from time t  a set of these assertions involving the same ground predicate defines a
sequence of disjoint time windows over which the timed predicate holds  an example in the
well known zenotravel domain  penberthy        long   fox      a  is
 at
 at
 at
 at

   open fuelstation city   
    not  open fuelstation city    
    open fuelstation city   
    not  open fuelstation city     

these assertions define two time windows over which  open fuelstation city   is true 
i e   from   to     excluded  and from    to     excluded   a timed initial literal is relevant
to the planning process when it is a precondition of a domain action  which we call a timed
precondition of the action  each timed precondition of an action can be seen as a temporal
scheduling constraint for the action  defining the feasible time window s  when the action
can be executed  when actions in a plan have durations and timed preconditions  computing
a valid plan requires planning and reasoning about time to be integrated  in order to check
whether the execution of the planned actions can satisfy their scheduling constraints  if an
action in the plan cannot be scheduled  then the plan is not valid and it must be revised 
the main contributions of this work are   i  a new representation of temporal plans
with action durations and timed preconditions  called temporally disjunctive action graph 
 tda graph  integrating disjunctive constraint based temporal reasoning into a recent
graph based approach to planning   ii  a polynomial method for solving the disjunctive temporal reasoning problems that arise in this context   iii  some new local search techniques
to guide the planning process using our representation  and  iv  an experimental analysis
evaluating the performance of our methods implemented in a planner called lpg td  which
took part in ipc   showing very good performance in many benchmark problems 
the td extension in the name of our planner is an abbreviation of timed initial literals
and derived predicates  the two main new features of pddl      in lpg td  the techniques
for handling timed initial literals are quite different from the techniques for handling derived
predicates  the first ones concern representing temporal plans with predictable exogenous
events and fast temporal reasoning for action scheduling during planning  the second ones
concern incorporating a rule based inference system for efficient reasoning about derived
predicates during planning  both timed initial literals and derived predicates require to
change the heuristics guiding the search of the planner  but in a radically different way  in
this paper  we focus on timed initial literals  which are by themselves a significant and useful
extension to pddl     moreover  an analysis of the results of ipc   shows that lpg td was
top performer in the benchmark problems involving this feature  the treatment of derived
predicates in lpg td is presented in another recent paper  gerevini et al       b  
   derived predicates allow us to express in a concise and natural way some indirect action effects  informally  they are predicates which do not appear in the effect of any action  and their truth is determined
by some domain rules specified as part of the domain description 

   

fian approach to temporal planning and scheduling

the paper is organized as follows  in section    after some necessary background  we
introduce the tda graph representation and a method for solving the disjunctive temporal
reasoning problems that arise in our context  in section    we describe some new local
search heuristics for planning in the space of tda graphs  in section    we present the
experimental analysis illustrating the efficiency of our approach  in section    we discuss
some related work  finally  in section   we give the conclusions 

   temporally disjunctive action graph
like in partial order causal link planning   e g   penberthy   weld        mcallester  
rosenblitt        nguyen   kambhampati         in our framework we search in a space
of partial plans  each search state is a partial temporal plan that we represent by a
temporally disjunctive action graph  tda graph   a tda graph is an extension of the
linear action graph representation  gerevini  saetti    serina        which integrates disjunctive temporal constraints for handling timed initial literals  a linear action graph is
a variant of the well known planning graph  blum   furst         in this section  after
some necessary background on linear action graphs and disjunctive temporal constraints 
we introduce tda graphs  and we propose some techniques for temporal reasoning in the
context of this representation that will be used in the next section 
    background  linear action graph and disjunctive temporal constraints
a linear action graph  la graph  a for a planning problem  is a directed acyclic leveled
graph alternating a fact level  and an action level  fact levels contain fact nodes  each of
which is labeled by a ground predicate of   each fact node f at a level l is associated
with a no op action node at level l representing a dummy action having the predicate of f
as its only precondition and effect  each action level contains one action node labeled by
the name of a domain action that it represents  and the no op nodes corresponding to that
level 
an action node labeled a at a level l is connected by incoming edges from the fact nodes
at level l representing the preconditions of a  precondition nodes   and by outgoing edges
to the fact nodes at level l     representing the effects of a  effect nodes   the initial level
contains the special action node astart   and the last level the special action node aend   the
effect nodes of astart represent the positive facts of the initial state of   and the precondition
nodes of aend the goals of  
a pair of action nodes  possibly no op nodes  can be constrained by a persistent mutex
relation  fox   long         i e   a mutually exclusive relation holding at every level of the
graph  imposing that the involved actions can never occur in parallel in a valid plan  such
relations can be efficiently precomputed using an algorithm that we proposed in a previous
work  gerevini et al         
an la graph a also contains a set of ordering constraints between actions in the  partial  plan represented by the graph  these constraints are  i  constraints imposed during
search to deal with mutually exclusive actions  if an action a at level l of a is mutex with
an action node b at a level after l  then a is constrained to finish before the start of b   ii 
constraints between actions implied by the causal structure of the plan  if an action a is
   

figerevini  saetti   serina

used to achieve a precondition of an action b  then a is constrained to finish before the start
of b 
the effects of an action node can be automatically propagated to the next levels of
the graph through the corresponding no ops  until there is an interfering  mutex  action
blocking the propagation  or the last level of the graph has been reached  gerevini et al  
       in the rest of the paper  we assume that the la graph incorporates this propagation 
a disjunctive temporal problem  dtp   stergiou   koubarakis        tsamardinos
  pollack        is a pair hp  ci  where p is a set of time point variables  c is a set of
disjunctive constraints c       cn   ci is of form yi  xi  ki   xi and yi are in p  and ki is a
real number  i       n   when c contains only unary constraints  the dtp is called simple
temporal problem  stp   dechter  meiri    pearl        
a dtp is consistent if and only if the dtp has a solution  a solution of a dtp is an
assignment of real values to the variables of the dtp that is consistent with every constraint
in the dtp  computing a solution for a dtp is an np hard problem  dechter et al         
while computing a solution of an stp can be accomplished in polynomial time  given
an stp with a special start time variable s preceding all the others  we can compute a
solution of the stp where each variable has the shortest possible distance from s in o n  c 
time  for n variables and c constraints in the stp  dechter et al         gerevini   cristani 
       we call such a solution an optimal solution of the stp  clearly  a dtp is consistent if
and only if we can choose from each constraint in the dtp a disjunct obtaining a consistent
stp  and any solution of such an stp is also a solution of the original dtp 
finally  an stp is consistent if and only if the distance graph of the stp does not
contain negative cycles  dechter et al          the distance graph of an stp hp  ci is a
directed labeled graph with a vertex labeled p for each p  p  and with an edge from v  p
to w  p labeled k for each constraint w  v  k  c 
    augmenting the la graph with disjunctive temporal constraints
let p be a timed precondition over a set w  p  of time windows  in the following  x  and x 
indicate the start time and end time of x  respectively  where x is either a time window or an
action  moreover  al indicates an action node at level l of the la graph under consideration 
for clarity of presentation  we will describe our techniques focusing on action preconditions
that must hold during the whole execution of the action  except at the end point of the
action   and on operator effects that hold at the end of the action execution  i e   on pddl
conditions of type over all  and pddl effects of type at end  fox   long          
in order to represent plans where actions have durations and time windows for their
execution  we augment the ordering constraints of an la graph with  i  action duration
constraints and  ii  action scheduling constraints  duration constraints have form
a   a   dur a  
where dur a  denotes the duration of an action a  for the special actions a start and aend  
 

 
we have dur astart     dur aend        since a
start   astart and aend   aend    duration
constraints are supported by the representation proposed in a previous work  gerevini
   our methods and planner support all the types of operator condition and effect that can be specified in
pddl     and     

   

fian approach to temporal planning and scheduling

level  
   
p 

level  

level  

goal level

  

p 

p 

p 

p 
p

mutex

p 

   

    

p 

    

p 

    

p 

a 

a 
   

astart

   

p 

p 

p 

   

p 

p 
mutex

  

astart

p 

    

    

a 

aend

    

p 

    

p 

p

p  

    
    

    
   

p

    

a 
a 

    

p 

aend

a 
   

p 

   

p 

   

p 

    
   

    

p 

    

p 

    

p 

    

 

  

  

  

  

   

p 

figure    an example of la graph with nodes labeled by t  values  in round brackets  
and the gantt chart of the actions labeling the nodes of the la graph  square
nodes are action nodes  circle nodes are fact nodes  action nodes are also marked
by the duration of the represented actions  in square brackets   unsupported
precondition nodes are labeled     dashed edges form chains of no ops blocked
by mutex actions  grey areas in the gantt chart represent the time windows for
the timed precondition p of a   

et al          while the representation and treatment of scheduling constraints are a major
contribution of this work 
let  be the plan represented by an la graph a  it is easy to see that the set c formed
by the ordering constraints in a and the duration constraints of the actions in  can be
encoded into an stp  for instance  if ai   is used to support a precondition node of aj  

then a 
i  aj    is in c  if ai and aj are two mutex actions in   and ai is ordered before aj  

then a 
i  aj    is in c  moreover  for every action a    the following stp constraints
are in c 
a   a  dur a   a  a   dur a  
which are equivalent to a   a   dur a   a scheduling constraint imposes the constraint
that the execution of an action must occur during the time windows associated with a timed
precondition of the action  syntactically  it is a disjunctive constraint c       cn   where
ci is of the form


 yi  x
i  hi     vi  ui  ki   
  
u
i   vi   xi   yi are action start times or action end times  and hi   ki  r   for every action
a   with a timed precondition p  the following disjunctive constraint is added to c 

   

figerevini  saetti   serina

 

ww  p 



   
  


 
a 
 a  a 
 
start  a  w
start  w

definition   a temporally disjunctive action graph  tda graph  is a   tuple ha  t   p  ci
where
 a is a linear action graph 
 t is an assignment of real values to the nodes of a 
 p is the set of time point variables corresponding to the start times and the end times
of the actions labeling the action nodes of a 
 c is a set of ordering constraints  duration constraints and scheduling constraints
involving variables in p 
a tda graph ha  t   p  ci represents the  partial  plan formed by the actions labeling
the action nodes of a with start times assigned by t   figure   gives the la graph and
t  values of a simple tda graph containing five action nodes  astart   a    a    a    aend   and
several fact nodes representing ten facts  the ordering constraints and duration constraints
in c are  

 

a 
   a      a   a     

 
 

 
a   a        a   a
        a   a       

assuming that p is a timed precondition of a  with windows          and            the only
scheduling constraint in c is 

 
 
 

 
 
  a 
start  a         a   astart          astart  a         a   astart        

the pair hp  ci defines a dtp d   let ds be the set of scheduling constraints in d 
we have that d represents a set  of stps  each of which consists of the constraints in
d  ds and one disjunct  pair of stp constraints  for each disjunction in a subset d s  of
ds  ds   ds    we call a consistent stp in  an induced stp of d  when an induced
stp contains a disjunct for every disjunction in ds  i e   ds    ds    we say that such a
 consistent  stp is a complete induced stp of d 
the values assigned by t to the action nodes of a are the action start times corresponding to an optimal solution of an induced stp  we call these start times a schedule of the
actions in a  the t value labeling a fact node f of a is the earliest time t   ta   dur a 
   note that  if p is an over all timed condition of an action a  then the end of a can be the time when an
exogenous event making p false happens  because in pddl p is not required to be true at the end of a
 fox   long        

 

   for brevity  in our examples we omit the constraints a 
start  ai    and ai  aend     for each action
ai   as well as the duration constraints of astart and aend   which have duration zero 
   the disjunctive constraints in c are not exactly in dtp form  however  it is easy to see that every
disjunctive constraint in c can be translated into an equivalent conjunction of constraints in exact dtpform  we use our more compact notation for clarity and efficiency reasons 

   

fian approach to temporal planning and scheduling

such that a supports f in a  and a starts at ta   if the induced stp from which we derive a
schedule is incomplete  then t may violate the scheduling constraint of some action nodes 
that we say are unscheduled in the current tda graph 
the following definitions present the notions of optimality for a complete induced stp
and of optimal schedule  which will be used in the next section 
definition   given a dtp d with a point variable p  a complete induced stp of d is an
optimal induced stp of d for p iff it has a solution assigning to p a value that is less
than or equal to the value assigned to p by every solution of every other complete induced
stp of d 
definition   given a dtp d of a tda graph g  an optimal schedule for the actions
in g is an optimal solution of an optimal induced stp of d for a
end  
note that an optimal solution minimizes the makespan of the represented  possibly
partial  plan  the dtp d of the previous example  figure    has two induced stps  one
with no time window for p  s     and one including the pair of stp constraints imposing the
time window           to p  s     the stp obtained by imposing the time window         
to p is not an induced stp of the dtp  because it is not consistent  s  is a partial induced
stp of d  while s  is complete and optimal for the start time of aend   the temporal values
derived from the optimal solution of s  that are assigned by t to the action nodes of the
 



 

tda graph are  a
start   astart      a       a       a        aend   aend      
    solving the dtp of a tda graph
in general  computing a complete induced stp of a dtp  if it exists  is an np hard problem
that can be solved by a backtracking algorithm  stergiou   koubarakis        tsamardinos
  pollack         however  given the particular structure of the temporal constraints
forming a tda graph  we show that this task can be accomplished in polynomial time with
a backtrack free algorithm  moreover  the algorithm computes an optimal induced stp for
a
end  
in the following  we assume that each time window for a timed precondition is no shorter
than the duration of its action  otherwise  the time window should be removed from those
available for this precondition and  if no time window remains  then the action cannot be
used in any valid plan   moreover  without loss of generality  we can assume that each
action has at most one timed precondition  it is easy to see that we can always replace a
set of over all timed conditions of an action a with a single equivalent timed precondition 
whose time windows are obtained by intersecting the windows forming the different original
timed conditions of a  also a set of at start timed conditions and a set of at end timed
conditions can be compiled into single equivalent timed preconditions  this can be achieved
by translating these conditions into conditions of type over all  the idea is similar to the
one presented by edelkamp         with the difference that we can have more than one
time window associated with a timed condition  while edelkamp assumes that each timed
condition is associated with a unique time window  specifically  every at start timed
condition p of an action a can be translated into an equivalent timed condition p   of type
over all by replacing the scheduling constraint of p 
   

figerevini  saetti   serina

p

p

dur a 

dur a 

q

dur a 

r

r

x
 

     

  

  

  

   

   

   

   

figure    an example of a set of timed conditions compiled into a single timed precondition  x   the solid boxes represent the time windows associated with the timed
conditions p  of type at start   q  of type at end   and r  of type over all  of
an action a  a solid box extended by a dashed box indicates the extension of
the time window in the translation of the corresponding timed condition into an
over all timed condition for a 

 

ww  p 



  



 
a 
 a  a 
 
start  a   w
start   w

forcing a to occur during one or more time windows  with
 

ww  p 



  
   
 


 a  a 
a 
start   w   dur a   
start  a   w

similarly  every at end timed condition p can be translated into an equivalent over all
timed condition by replacing the scheduling constraint
 

ww  p 



   

 

 
a 
 a  a 
 
start  a   w
start   w

forcing a  to occur during one or more time windows  with
 

ww  p 



   

 


 
a 
 
start  a   w   dur a   a  astart   w

clearly  this translation of the timed conditions of each domain action into a single timed
precondition for the action can be accomplished by a preprocessing step in polynomial time 
figure   shows an example  assume that action a has duration    and timed conditions
p of type at start  q of type at end and r of type over all  let         and            be
the time windows of p           the time window of q  and finally          and            the
time windows of r  we can compile these timed conditions into a new timed condition x
with the time window          
   note that for timed conditions of type at start and at end we need to use   instead of   however 
the properties and algorithms for stps can be easily generalized to stps extended with   constraints
 e g   gerevini   cristani        

   

fian approach to temporal planning and scheduling

solve dtp x  s 
input  the set x of meta variables in the meta csp of a dtp  a partial solution s of the meta csp 
output  either a solution of the meta csp or fail 
  
  
  
  
  
  
  
  
  
   

if x    then stop and return s 
x  selectvariable x   x    x   x  
while d x      do
d  selectvalue d x   
s    s   x  d   d x   d x    d  
d   x   d x      saving the domain values   
if forwardcheck dtp x     s     then
solve dtp x     s     
d x   d    x      restoring the domain values   
return fail     backtracking   

forwardcheck dtp x  s 
input  the set x of meta variables  a  partial  solution s 
output  either true or false 
  
  
  
  
  
  

forall x  x do
forall d  d x  do
if not consistency stp s   x  d   then
d x   d x    d  
if d x     then return false     dead end   
return true 

figure    basic algorithm for solving a dtp  d x  is a global variable whose value is the
current domain of the meta variable x  consistency stp s  returns true  if the
stp formed by the variable values in the  partial  solution s has a solution  false
otherwise 

as observed by stergiou and kourbarakis        and tsamardinos and pollack        
a dtp can be seen as a meta csp  the variables of the meta csp are the constraints
of the original csp  and the values of these  meta  variables are the disjuncts forming
the constraints of the original csp  the constraints of the meta csp are not explicitly
stated  instead  they are implicitly defined as follows  an assignment  of values to the
meta variables satisfies the constraints of the meta csp iff  forms a consistent stp  an
induced stp of the dtp   a solution of the meta csp is a complete induced stp of the
dtp 
figure   shows an algorithm for solving the meta csp of a dtp  tsamardinos  
pollack         which is a variant of the forward checking backtracking algorithm for solving
general csps  by appropriately choosing the next meta variable to instantiate  function
selectvariable  and its value  function selectvalue   we can show that the algorithm finds a
solution with no backtracking  if one exists   moreover  by a simple modification of solve   

figerevini  saetti   serina

dtp  we can derive an algorithm that is backtrack free even when the input meta csp has
no solution  this can be achieved by exploiting the information in the la graph a of the
tda graph to decompose its dtp d into a sequence of growing dtps
d   d        dlast   d
where  i  last is the number of the levels in a   ii  the variables vi of di  i      last  are
all the variables of d corresponding to the action nodes in a up to level i  and  iii  the
constraints of di are all the constraints of d involving only the variables in vi   e g   for the

 

 

 
dtp of figure    the point variables of d  are a 
start   a    a    a    a    a    a    and the set
of constraints d  is

 

 

 

 

  a 
   a      a   a      a   a        a   a        a   a       

 
 
 

 
 
  a 
start a         a  astart          astart a         a  astart         

from the decomposed dtp  we can derive an ordered partition of the set of metavariables in the meta csp of the original dtp
x   x   x        xlast  
where xi is the set of the meta variables corresponding to the constraints in di  di   
if i      and in d  otherwise  this ordered partition is used to define the order in which
selectvariable chooses the next variable to instantiate  which is crucial to avoid backtracking  specifically  every variable with a single domain value  i e   an ordering constraint 
a duration constraint  or a scheduling constraint with only one time window  is selected
before every variable with more than one possible value  i e   a scheduling constraint with
more than one time window   moreover  if xi  xi   xj  xj and i   j  then xi is selected
before xj  
in order to avoid backtracking  the order in which selectvalue chooses the value for a
meta variable is very important as well  given a meta variable with more than one value
 time window  in its current domain  we choose the value corresponding to the earliest
available time window  e g   if the current domain of the selected meta variable with m
possible values is
  

i    m

   


 
 

a 
 
start  a  wi  a  astart  wi

then selectvalue chooses the j th value such that  wj      wh    for every h           m  
j           m   h    j 
in the following we give a simple example illustrating the order in which selectvariable
and selectvalue select the meta variables and their meta values  respectively  consider the
tda graph in figure   with the additional time window            for the timed precondition p of a    the dtp of the extended tda graph has six meta variables  x    x            x    
whose domains  the disjuncts of the corresponding constraints of the original csp  are 

x     a 
   a     
 

x     a   a     

   

fian approach to temporal planning and scheduling

x   
x   
x   
x   


 a 
   a       
 

 a   a       

 a 
   a       
 
 
 
 

 
 
  astart  a
         a   astart        astart  a         a   astart       
 

 
 
 astart  a          a   astart        

by exploiting the level structure of the tda graph  we derive an ordered partition of the
meta variables formed by the following sets 
x     x     x     x     x     x    x    x    x    
since x  belongs to x  while x  belongs to x    selectvariable selects x  before selecting
x    similarly  the function selects x  before the meta variables in x    when the algorithm
instantiates x    the first meta value of x   i e   the first time window of the timed precondition of a    has been removed from its domain by forward checking  and selectvalue selects

 
 
 

 
 
 a 
start  a         a   astart       before  astart  a          a   astart       
because the first meta value corresponds to a time window starting at time     while the
second one corresponds to a time window starting at time     
by using these techniques for selecting the next meta variable to instantiate and its
value  we can prove the following theorem 
theorem   given a dtp d for a tda graph  if the meta csp x of d is solvable  then
solve dtp finds a solution of x with no backtracking  moreover  this solution is an optimal
induced stp of d for a
end  
proof  the proof has two key points  the way meta variables are selected and instantiated
by selectvariable and selectvalue  respectively  the particular type of constraints of d  in
which all disjunctive constraints have a specific form encoding a set of disjoint time windows 
and  by construction of d  we have

j i such that i   j and     a
j   ai  

   


where  is the set of ordering constraints and duration constraints in d  and a 
i  aj   is
an endpoint of ai  aj    because of property       cannot imply any restriction on the
maximum distance between an endpoint of ai and endpoint of aj  while  of course  there
can be a lower bound on this distance   i e   for any positive quantity u we have

j i such that i   j and      a
j  ai  u  

   

let assume that selectvariable chooses a meta variable x that cannot be consistently
instantiated to a value in d x   and this means that we have reached a backtracking point  
we show that this cannot be the case 
selectvariable chooses the meta variables of the stp constraints of d before any metavariable of a scheduling constraint with more than one value  time window   let x s be
the set of the meta variables associated with the scheduling constraints in d  we have
that x must be a meta variable in x s   because we are assuming that the meta csp x is
solvable  the use of the forward checking subroutine guarantees that at least one value of x
is consistent with respect to the meta variables that are instantiated in the current partial
   

figerevini  saetti   serina

solution s  hence  it should be the case that at step   of solve dtp forwardcheck dtp
returns false for every value d  time window  in d x   i e   that for every d  d x  there
exists another uninstantiated meta variable x   x s such that  for every d   d x     the
check consistency stp s   x   d     executed by the forward checking subroutine returns
false  however  if x has a solution  d is consistent   this cannot be the case because
 i  the value chosen by selectvalue to instantiate x and the previously instantiated metavariables  step    is the earliest available time window in the current domain of the
meta variable under consideration  which is a least commitment assignment  and
 ii  we have at most one scheduling constraint  meta variable in x s   for each level of the
tda graph 
let a  be the action constrained by the scheduling constraint associated with x     since
selectvariable selects x before x    by  ii  we have that a  is at a level following the level of the
action constrained by the scheduling constraint associated with x  thus  by property     
we have that if x  could not be instantiated  then this would be because every time window
of a  constrains a  to start too early  the current partial solution of x augmented with
any of the possible values of x implies that the start time of a  should be after the end of
the last time window of a    but then   i  and the assumption that x is solvable guarantee
that this cannot be the case 
moreover  since the value of every instantiated meta variable is propagated by forward
checking to the unassigned variables  we have that the first value assigned to any metavariable is the same value assigned to that variable in the solution found for the csp  if
any   it is easy to see that if the first value chosen by selectvalue d x   is not feasible
 forwardcheck dtp x     s     returns false   then every other next value chosen for x is not
feasible 
finally  since the value chosen by selectvalue for a meta variable corresponds to the
earliest available window in the current domain of the meta variable  it follows that the
solution computed by the algorithm is a complete optimal induced stp of d for a 
end    
as a consequence of the previous theorem  if solve dtp performs backtracking  step     
then the input meta csp has no solution  thus  we can obtain a general backtrack free
algorithm for the dtp of any tda graph by simply replacing step    with
    stop and return fail 
the correctness of the modified algorithm  which we called solve dtp    follows from
theorem    the next theorem states that the runtime complexity of solve dtp   is polynomial 
theorem   given a tda graph g with dtp d  solve dtp  processes the meta csp
corresponding to d in polynomial time with respect to the number of action nodes in g and
the maximum number of time windows in a scheduling constraint of d   
   it should be noted that here our main goal is to give a complexity bound that is polynomial  the use of
improved forward checking techniques  e g   tsamardinos   pollack        could lead to a complexity
bound that is lower than the one given in the proof of the theorem 

   

fian approach to temporal planning and scheduling

proof  the time complexity depends on the number of times forwardcheck dtp is executed  and on its time complexity  d contains a linear number of variables with respect
to the number n of domain action nodes in the la graph of the tda graph  o n     ordering constraints  and o n  duration constraints and scheduling constraints  hence  the
meta csp of d has o n    meta variables  one variable for each constraint of the original
csp   let  be the maximum number of time windows in a scheduling constraint of d 
forwardcheck dtp is executed at most  times for each meta variable x  i e   o  n     times
in total  consistency stp decides the satisfiability of an stp involving o n  variables  which
can be accomplished in o n    time  dechter et al         gerevini   cristani          note
that the variables of the stp that is processed by consistency stp are the variables of the
original csp  i e   they are the starting time and the end time of the actions in the plan  
finally  consistency stp is run o   n    times during each run of forwardcheck dtp  it
follows that the runtime complexity of solve dtp  is o     n      
by exploiting the structure of the temporal constraints forming the dtp of a tdagraph  we can make the following additional changes to solve dtp  improving the efficiency
of the algorithm 
 instead of starting from an empty assignment s  no meta variable is instantiated  
initially every meta variable associated with an ordering constraint or with a duration
constraint is instantiated with its value  and x contains only meta variables associated
with the scheduling constraints  as observed in the proof of theorem    if the meta
csp is solvable  the values assigned to the meta variables by the initial s form a
consistent stp 
 forward checking is performed only once for each meta variable  this is because in
the proof of theorem   we have shown that  if the meta csp is solvable  then the
first value chosen by selectvalue should be feasible  i e   forwardcheck dtp returns
true   thus  if the first value is not feasible  we can stop the algorithm and return fail
because the meta csp is not solvable  moreover  we can omit steps   and   which
save and restore the domain values of the meta variables 
 finally  the improved algorithm can be made incremental by exploiting the particular
way in which we update the dtp of the tda graph during planning  i e   during the
search of a solution tda graph described in the next section   as described in the
next section  each search step is either an addition of a new action node to a certain
level l  or the removal of an action node from l  in both cases  it suffices to recompute
the sub solution for the meta variables in the subsets xl   xl          xlast   the values
assigned to the other meta variables is the same as the assignment in the last solution
computed before updating the dtp  and it is part of the input of the algorithm 
moreover  in order to use the local search techniques described in the next section  we
need another change to the basic algorithm  when the algorithm detects that x has no
solution  instead of returning failure   i  it keeps processing the remaining meta variables 
and  ii  when it terminates  it returns the  partial  induced stp si formed by the values
assigned to the meta variables  the optimal solution of si defines the t  assignment of the
tda graph 
   

figerevini  saetti   serina

in the next section  sg denotes the induced stp for the dtp of a tda graph g computed by our method 

   local search techniques for tda graphs
a tda graph ha  t   p  ci can contain two types of flaw  unsupported precondition nodes
of a  called propositional flaws  and action nodes of a that are not scheduled by t   called
temporal flaws  if a level of a contains a flaw  we say that this level is flawed  for example 
if the only time window for p in the tda graph of figure   were           then level   would
be flawed  because the start time of a  would be     which violates the scheduling constraint
for a  imposing that this action must be executed during          
a tda graph with no flawed level represents a valid plan and is called a solution graph 
in this section  we present new heuristics for finding a solution graph in a search space of
tda graphs  these heuristics are used to guide a local search procedure  called walkplan 
that was originally proposed by gerevini and serina        and that is the heart of the
search engine of our planner 
the initial tda graph contains only astart and aend   each search step identifies the
neighborhood n  g   successor states  of the current tda graph g  search state   which is
a set of tda graphs obtained from g by adding a helpful action node to a or removing a
harmful action node from a in an attempt to repair the earliest flawed level of g   
in the following  for the sake of brevity when we refer to an action node of a tda graph 
we are implicitly referring to an action node of the la graph of a tda graph  similarly
for the level of a tda graph  moreover  we remind the reader that a l denotes the action
at level l  while la denotes the level of action a 
definition   given a flawed level l of a tda graph g  an action node is helpful for l iff
its insertion into g at a level i  l would remove a propositional flaw at l 
definition   given a flawed level l of a tda graph g  an action node at a level i  l
is harmful for l iff its removal from g would remove a propositional flaw at l  or would
decrease the t  value of al   if al is unscheduled 
examples of helpful action node and harmful action node
an action node representing an action with effect p  is helpful for level   of the tda graph
of figure   if it is added at level   or    bear in mind that the insertion of an action node at
level   determines an expansion of the tda graph postponing a  to level    more details are
given at the end of the examples   action node a  of figure   is harmful for level    because
its precondition node p  is unsupported  action node a  is harmful for level    because it
blocks the no op propagation of p  at level    which would support the precondition node p 
at level    moreover  assuming w  p                a  is unscheduled in the plan represented
by the la graph  action node a  is harmful for level    because the removal of a  from
   we have designed several flaw selection strategies that are described and experimentally evaluated in a
recent paper  gerevini  saetti    serina         the strategy preferring flaws at the earliest level of the
graph tends to perform better than the others  and so it is used as the default strategy of our planner 
more details and a discussion about this strategy are given in the aforementioned paper 

   

fian approach to temporal planning and scheduling

a would decrease the temporal value of a    on the contrary  a  is not harmful for level   
because its removal would not affect the possible scheduling of a    notice that an action
node can be both helpful and harmful  a  is harmful for level    and it is helpful for the
goal level  because it supports the precondition node p   of aend   
when we add an action node to a level l that is not empty  the la graph is extended
by one level  all action nodes from l are shifted forward by one level  i e   they are moved
to their next level   and the new action is inserted at level l   similarly  when we remove
an action node from level l  the graph is shrunk by removing level l  some additional
details about this process are given in another paper  gerevini et al          moreover  as
pointed out in the previous section  the addition  removal  of an action node a requires us
to update the dtp of g by adding  removing  the appropriate ordering constraints between
a and other actions in the la graph of g  the duration constraint of a  and the scheduling
constraint of a  if any   from the updated dtp  we can use the method described in the
previous section to revise t   and to compute a possibly new schedule of the actions in g
 i e   an optimal solution of sg   
the elements in n  g  are evaluated using a heuristic evaluation function e consisting
of two weighted terms  estimating their additional search cost and temporal cost  i e   the
number of search steps required to repair the new flaws introduced  and their contribution
to the makespan of the represented plan  respectively  an element of n  g  with the lowest
combined cost is then selected using a noise parameter randomizing the search to escape
from local minima  gerevini et al          in addition  in order to escape local minima  the
new version of our planner uses a short tabu list  glover   laguna         in the rest of
this section  we will focus on the search cost term of e  the techniques that we use for the
evaluation of the temporal cost and the  automatic  setting of the term weights of e are
similar to those that we introduced in a previous work  gerevini et al         
the search cost of adding a helpful action node a to repair a flawed level l of g is
estimated by constructing a relaxed temporal plan  achieving
    the unsupported precondition nodes of a  denoted by pre a 
    the propositional flaws remaining at l after adding a  denoted by unsup l   and
    the supported precondition nodes of other action nodes in g that would become
unsupported by adding a  denoted by threats a  
moreover  we estimate the number of additional temporal flaws that the addition of a and
 to g would determine  i e   we count the number of
 i  action nodes of g that would become unscheduled by adding a and  to g 
 ii  the unsatisfied timed preconditions of a  if a is unscheduled in the tda graph extended with a and  
 iii  the action nodes of  with a scheduling constraint that we estimate cannot be satisfied
in the context of  and of g 
the search cost of adding a to g is the number of actions in  plus  i    ii  and  iii  
which are new terms of the heuristic evaluation  note that the action nodes of  i  are
   

figerevini  saetti   serina

aend     

goal level
    

p 

p 
    

a      

    

p 

action
b 
b 
b 
b 

    

    

p  
p

    

p 

    

p 

p 

    

    

    

    

p 

p 

est lower bound
 
 
  
  

    
   

q

p 

p 

p 

relaxed plan 

level  
  

action
b 
b 
b 
b 

n um acts
 
 
 
 

anew     

    

p      

p 

p 

level  
p 
p 

p 
mutex

p 

   

    

a     

level  
   

    

   

p 

mutex

p 

p 
p 
p 

   

   

a      
   
  

p 
p 
p 

    

q 

q 
    
    

   

b 

    

q 

   
    

p 

   

b     

i
astart    

   

p 

     

q
p 

b      

   

q 

p 

    

    

b     

p 

   

    

p 

figure    an example of relaxed temporal plan   square nodes represent action nodes 
while the other nodes represent fact nodes  solid nodes correspond to nodes in
a   anew    dotted nodes correspond to the precondition nodes and action nodes
that are considered during the construction of   the gray dotted nodes are those
selected for their inclusion in   action nodes are marked by the duration of
the represented actions  in square brackets  and by their estimated start time  in
round brackets   the meaning of num acts is described in the text  the lower
bounds on the earliest action start times  est lower bound  are computed by the
algorithm in appendix a 

those that would have to be ordered after a  because a is used to achieve one of their
preconditions  or these action nodes are mutex with a  and that  given the estimated end
time of  and the duration of a  would excessively increase their start time  in  ii  we
consider the original formulation of the timed preconditions of a  i e   the formulation before
their possible compilation into one merged new precondition  as discussed in section      
finally  to check the scheduling constraint of an action in   we consider the estimated end
time of the relaxed subplan of  used to achieve the preconditions of this action 
example of relaxed temporal plan and additional temporal flaws  iiii 
figure   gives an example of  for evaluating the addition of anew at level   of the lagraph on the left side of the figure  the same graph as the one used in figure     which is a
   

fian approach to temporal planning and scheduling

relaxedtimeplan g  i  a 
input  a set of goal facts  g   an initial state for the relaxed plan  i   a set of reusable actions  a  
output  the set of actions acts forming a relaxed plan for g from i and the earliest time when all
facts in g can be achieved 
  
  
  
  
  
  
  
  
  
   
   
   
   

s
acts  a  f  aacts add  a  
t  m ax  t  g    g  g  f or g  g  i  
g  g  i 
while g  f    
g  a fact in g  f  
b  bestaction g  
ha  t  i  relaxedtimeplan pre b   i  acts  
t  b   computeeft  b  t    
t  m ax t  t  b   
forall f  add b  do

t  f    m in t  f   st  b    dur b   
acts  a   b   f  aacts add  a  
return hacts  ti 

figure    algorithm for computing a relaxed temporal plan  computeeft  b  t     returns
the estimated earliest finishing time  of b that is consistent with the scheduling
constraint of b  if any   and such that t    dur b     for an example see
appendix a   add  a  denotes the set of the positive effects of a 

helpful action node for the unsupported precondition p    the goals of  are the unsupported
preconditions q  and q  of anew   while the initial state i of  is formed by the fact nodes that
are supported at level    the actions of  are anew   b  and b   the numbers in the name
of the actions and facts of the relaxed plan indicate the order in which relaxedtimeplan
considers them  the estimated start time and end time of b  are    and     respectively 
assume that the timed precondition q of anew has associated with it the time window         
concerning point  i   there is no action node of g that would become unscheduled by adding
anew and  to g  concerning point  ii   anew is unscheduled and has one timed precondition
that is unsatisfied  q   concerning point  iii   we have that b  cannot be scheduled in the
context of  and the current tda graph g  finally  since  contains three actions  and the
sum of  i    ii  and  iii  is    we have that the search cost of adding anew to g at level  
is   
the evaluation of a tda graph derived by removing a harmful action node a for a
flawed level l is similar  with  achieving
 the precondition nodes supported by a that would become unsupported by removing
a and
 when la   l  the unsupported precondition nodes at level l that do not become supported by removing a 
   

figerevini  saetti   serina

regarding the second point  note that if l   la   then all flaws at l are eliminated because 
when we remove an action  we also  automatically  remove all its precondition nodes  while 
when la   l  the removal of a could leave some flaws at level l 
plan  is relaxed in the sense that its derivation ignores the possible  negative  interference between actions in   and the actions in  may be unscheduled  the derivation of
 takes into account the actions already in the current partial plan  the plan represented
by the tda graph g   in particular  the actions of the current plan are used to define an
initial state i for   which is obtained by applying the actions of g up to level la    ordered
according to their corresponding levels  moreover  each fact f in i is marked by a temporal
value  t  f    corresponding to the time when f becomes true  and remains so in   in the
current subplan formed by the actions up to level la    
the relaxed plan  is constructed using a backward process  called relaxedtimeplan  see
figure     which is an extension of the relaxedplan algorithm that we proposed in a previous
work  gerevini et al          the algorithm outputs two values  a set of actions forming
a  sub relaxed plan  and its estimated earliest finishing time  used to defined the temporal
cost term of e   the set of actions acts forming  is derived by running relaxedtimeplan
twice  first with goals pre a   initial state i and an empty set of reusable actions  then with
goals unsup l    t hreats a   initial state i  threats a   add  a   and a set of reusable
actions formed by the actions computed by the first run plus a 
the main novelty of the extended algorithm for computing  concerns the choice of the
actions forming the relaxed plan  the action b chosen to achieve a  sub goal g is an action
minimizing the sum of
 the estimated minimum number of additional actions required to support its propositional preconditions from i  num acts b  i   
 the number of supported precondition nodes in the la graph that would become
unsupported by adding b to g  threats b   
 the number of timed preconditions of b that we estimate would be unsatisfied in g
extended with   timedpre b   
 the number of action nodes scheduled by t that we estimate would become unscheduled when adding b to g  timethreats b   
more formally  the action chosen by bestaction g  at step   of relaxedtimeplan to
achieve a  sub goal g is an action satisfying


 
 
 
 
argmin num acts a   i     threats a       timedpre a       timethreats a     
 a  ag  

where ag    a   o   g  add  a     o is the set of all the domain actions whose preconditions
are reachable from i  
num acts b  i  is computed by the algorithm given in appendix a  threats b  is computed as in our previous method for deriving   gerevini et al          i e   by considering
the negative interactions  through mutex relations  of b with the precondition nodes that
are supported at levels after al   timedpre b  and timethreats b  are new components of
the action selection method  and they are computed as follows 
   

fian approach to temporal planning and scheduling

in order to compute timedpre b   we estimate the earliest start time of b  est b   and
the earliest finishing time of b  ef t b    using these values  we count the number of the
timed preconditions of b that cannot be satisfied  ef t b  is defined as est b    dur b  
while est b  is the maximum over
 a lower bound on the possible earliest start time of b  est lower bound of b   computed
by the reachability analysis algorithm given in appendix a 
 the t  values of the action nodes ci in the current tda graph g  with i   la   that are

mutex with b because the addition of b to g would occur the addition of c 
i b   
to the dtp of g 
 the maximum over an estimated lower bound on the time when all the preconditions of
b are achieved in the relaxed plan  this estimate is computed from the causal structure
of the relaxed plan  the duration and scheduling constraints of its actions  and the
t  values of the facts in the initial state i 
example of timedpre
in the example of figure    the estimated start time of b  is the maximum between    
which is the est lower bound of b   and     which is the maximum time over the estimated
times when the preconditions of b  are supported  p  is supported in the initial state of 
at time    while q  is supported at time      notice that a  is not mutex with b   and so the
second point in the definition of est b   does not apply here  since the estimated earliest
start time of b  is    and the duration of b  is     ef t b              thus  if we assume
that q has associated with it the time window         then the timed precondition q of b 
cannot be scheduled  i e   q  timedpre b   
in order to compute timethreats b   we use the following notion of time slack between
action nodes 
definition   given two action nodes ai and aj of a tda graph ha  t   p  ci such that

c    a 
i   aj   slack ai   aj   is the maximum time by which the t  value of ai can be
consistently increased in sg without violating the time window chosen for scheduling aj  
in order to estimate whether an action b is a time threat for an action node a k in the
current tda graph extended with the action node a that we are adding for repairing level
l  l   k   we check if
 b   a    slack a  ak  
holds  where b is the portion of the relaxed plan computed so far  and  b   a  is the
estimated delay that adding the actions in b to g would cause to the start time of a 
examples of time slack and timethreat
the slack between anew and a  in the tda graph of figure   extended with anew is    
because even if anew started at     a  could still be executed during the time window
           imposed by the timed precondition p   while if anew started at        then a 
would finish at       determined by summing the start time of anew   dur anew    dur a    
   

figerevini  saetti   serina

and dur a      and so the scheduling constraint of a  would be violated  assume that we
are evaluating the inclusion of b  in the relaxed plan of figure   for achieving q   we have
 b    anew         
i e  the estimated delay that the portion of the plan formed by b  would add to the end
time of anew is      since the slack between anew and a  is    
slack anew   a       b    anew   
and so a   timethreats b    on the contrary  since
slack anew   a       b    anew       
we have that a    timethreats b   
to conclude this section  we observe that the way we consider scheduling constraints
during the evaluation of the search neighborhood has some similarity with a well known
technique used in scheduling  for example  suppose that we are evaluating the tda graphs
obtained by adding a helpful action node a to one among some alternative possible levels of
the graph  and that the current tda graph contains another action node c which is mutex
with a  if the search neighborhood contains two tda graphs corresponding to     adding
a to a level before lc  and     adding a to a level after lc   and     violates less scheduling
constraints than      then  according to points  i  iii       is preferred to      a similar
heuristic method  called constraint based analysis  has been proposed by erschler  roubellat
and vernhes        to decide whether an action should be scheduled before or after another
conflicting action  and it has been also used in other scheduling work for guiding the search
toward a consistent scheduling of the tasks involved in the problem  e g   smith   cheng 
      

   experimental results
we implemented our approach in a planner called lpg td  which obtained the  nd prize in
the metric temporal track  satisficing planners  of the  th international planning competition  ipc     lpg td is an incremental planner  in the sense that it produces a sequence
of valid plans each of which improves the quality of the previous ones  plan quality is
measured using the metric expression that is specified in the planning problem description 
the incremental process of lpg td is described in another paper  gerevini et al         
essentially  the process iterates the search of a solution graph with an additional constraint
on the lower bound of the plan quality  which is determined by the quality of the previously
generated plans  lpg td is written in c and is available from http   lpg ing unibs it 
in this section  we present the results of an experimental study with two main goals 
 testing the efficiency of our approach to temporal planning with predictable exogenous
events by comparing the performance of lpg td and other recent planners that at
ipc   attempted the benchmark problems involving timed initial literals  edelkamp 
hoffmann  littman    younes        
   

fian approach to temporal planning and scheduling

planner

lpg td
sgplan
p mep
crikey
lpg ipc 
downward  diag 
downward
marvin
yahsp
macro ff
fap
roadmapper
tilsapa
optop

solved
   
    
  
   
   
   
   
   
   
   
  
  
  
 

attempted
    
    
   
   
   
   
   
   
   
   
   
   
   
  

success ratio
   
   
   
   
   
   
   
   
   
   
   
   
   
  

planning capabilities at ipc  
propositional   dp  metric temporal  til
propositional   dp  metric temporal  til
propositional  metric temporal  til
propositional  metric temporal
propositional  metric temporal
propositional   dp
propositional   dp
propositional   dp
propositional
propositional
propositional
propositional
til
til

table    number of problems attempted solved and success ratio of the  satisficing  planners that took part in ipc    dp means derived predicates  til means timed
initial literals  propositional means strips or adl  the planning capabilities are the pddl    features in the test problems attempted by each planner at
ipc   

 testing the effectiveness of the proposed temporal reasoning techniques integrated
into the planning process to understand  in particular  their impact on the overall
performance of the system  and to compare them with other existing techniques 
for the first analysis  we consider the test problems of the variant of the ipc   metrictemporal domains involving timed initial literals  a comparison of lpg td and other ipc  
planners considering all the variants of the ipc   metric temporal domains is given in
appendix b  additional results are available from the web site of our planner 
for the second experiments  we use new domains and problems obtained by extending
two well known benchmark domains  and the relative problems  from ipc   with timed
initial literals  long   fox      a   
all tests were conducted on an intel xeon tm    ghz    gbytes of ram  we ran lpg td
with the same default settings for every problem attempted 
    lpg td and other ipc   planners
in this section  we use the official results of ipc   to compare the performance of lpg td
with those of other planners that took part in the competition  the performance of lpg td
corresponds to a single run  the cpu time limit for the run was    minutes  after which
termination was forced  lpg td s indicates the cpu time required by our planner to derive
the first plan  lpg td bq indicates the best quality plan found within the cpu time limit 
   for a description of the ipc   domains and of the relative variants  the reader can visit the
official web site of ipc    http   ls  www cs uni dortmund de edelkamp ipc   index html  
the extended versions of the ipc   domains used in our experiments are available from
http   zeus ing unibs it lpg testsipc  til tgz 

   

figerevini  saetti   serina

before focusing our analysis on the ipc   domains involving timed initial literals  in
table   we give a very brief overview of all the results of the ipc    satisficing  planners  in
terms of planning capabilities and problems attempted solved by each planner  the table
summarizes the results for all the domain variants of ipc    lpg td and sgplan  chen  hsu 
  wah b         are the only planners supporting all the major features of pddl    and
pddl     both planners have a good success ratio  close to       downward  helmert 
      and yahsp  vidal        have a success ratio better than lpg td and sgplan  but
they handle only propositional domains  downward supports derived predicates  while
yahsp does not   sgplan attempted more problems than lpg td because it was also tested
on the compiled version of the variants with derived predicates and timed initial literals    
moreover  lpg td did not attempt the numerical variant of the two versions of the promela
domain and the adl variant of psr large  because they use equality in some numerical
preconditions or conditional effects  which currently our planner does not support 
figure   shows the performance of lpg td in the variants of three domains involving
predictable exogenous events with respect to the other  satisficing  planners of ipc   supporting timed initial literals  sgplan  p mep  sanchez et al         and tilsapa  kavuluri
  u         in airport  upper plots of the figure   lpg td solves    problems over    
sgplan     p mep     and tilsapa    in terms of cpu time  lpg td performs much better
than p mep and tilsapa  lpg td is faster than sgplan in nearly all problems  except
problems   and      in particular  the gap of performance in problems      is nearly
one order of magnitude  regarding plan quality  the performance of lpg td is similar to
the performance of p mep and tilsapa  while  overall  sgplan finds plan of worse quality
 with the exception of problems    and     where sgplan performs slightly better  and the
easiest problems where lpg td and sgplan perform similarly  
lpg td and tilsapa are the only planners of ipc   that attempted the variant of
pipesworld with timed initial literals  central plots of figure     lpg td solves    problems over     while tilsapa solves only   problems  in this domain variant lpg td performs
much better than tilsapa 
in the flaw version of umts  bottom plots of figure     lpg td solves all    problems 
while sgplan solves    problems  p mep and tilsapa did not attempt this domain variant  
moreover  lpg td is about one order of magnitude faster than sgplan in every problem
solved  compared to the other ipc   benchmark problems  the umts problems are generally
easier to solve  in these test problems  the main challenge is finding plans of good quality 
overall  the best quality plans of lpg td are much better than sgplan plans  except for
the simplest problems where the two planners generate plans of similar quality  in the basic
version of umts without flawed actions  sgplan solves all problems as lpg td  but in terms
of plan quality lpg td performs much better 
figure   shows the results of the wilcoxon sign rank test  also known as the wilcoxon
matched pairs test  wilcoxon   wilcox         comparing the performance of lpg td and
the planners that attempted the benchmark problems of ipc   involving timed initial literals  the same test has been used by long and fox      a  for comparing the performance
    such versions were generated for planners that do not support these features of pddl     during the
competition we did not test lpg td with the problems of the compiled domains because the planner
supports the original version of these domains  lpg td attempted every problem of the  uncompiled 
ipc   domains that it could attempt in terms of the planning language it supports 

   

fian approach to temporal planning and scheduling

airport windows

milliseconds
 e   

lpg td s     solved 
p mep     solved 
sgplan     solved 
tilsapa    solved 

 e   

airport windows

makespan
    

lpg td bq     solved 
p mep     solved 
sgplan     solved 
tilsapa    solved 

    

    
      
   
     
   
    
   
   

   

  

 
 

 

  

  

  

  

  

  

  

  

pipesworldnotankage deadlines

milliseconds
 e   

 

 

  

  

  

  

  

  

  

  

pipesworldnotankage deadlines

makespan
  

lpg td bq     solved 
tilsapa    solved 

lpg td s     solved 
tilsapa    solved 
 e   

  

      

  

     

  

    

  

   

 

  

 
 

 

  

  

  

  

  

umtsflaw windows

milliseconds
     

 

 

  

  

  

  

  

umtsflaw windows

makespan
    

lpg td s     solved 
sgplan     solved 

lpg td bq     solved 
sgplan     solved 
    
    

    

    
    
    

   

    
    
    

  

    
 

 

  

  

  

  

  

  

  

  

  

 

 

  

  

  

  

  

  

  

  

figure    cpu time and plan quality of lpg td  p mep  sgplan  and tilsapa for three
ipc   domains with timed initial literals  on the x axis we have the problem
names simplified by numbers  in the plots on the left  on the y axis we have
cpu milliseconds  logarithmic scale   in the plots on the right  on the y axis we
have the plan makespan  the lower the better  
   

  

figerevini  saetti   serina

lpg td s vs p mep
     
       
  

lpg td bq vs p mep
       
  

cpu time analysis
lpg td s vs sgplan
     
        
   

lpg td s vs tilsapa
      
       
   

plan quality analysis
lpg td bq vs sgplan lpg td bq vs tilsapa
     
     
       
       
   
  

figure    results of the wilcoxon test for the performance of lpg td compared with other
ipc    satisficing  planners in terms of cpu times and plan quality for the benchmark problems with timed initial literals 

lpg td s

sgplan

tilsapa

p mep

cpu time

lpg td bq

sgplan

tilsapa

p mep

a

b 

a is consistently better than b

a

b 

a is better than b a
significant number of times
 confidence level        

plan quality

figure    partial order of the performance of the ipc    satisficing  planners according
to the wilcoxon test for the benchmark problems with timed initial literals  a
dashed arrow indicates that the performance relationship holds with a confidence
level slightly less than       

of the ipc   planners  for the cpu time analysis  we consider all the problems attempted
by both the compared planners and solved by at least one of them  when a planner does
not solve a problem  the corresponding cpu time is the ieee arithmetic representation of
positive infinity   for the plan quality  makespan  analysis  we consider all the problems
solved by both the compared planners 
   

fian approach to temporal planning and scheduling

in order to carry out the wilcoxon test  for each planning problem we computed the
difference between the cpu times of the two planners being compared  defining the samples
of the test for the cpu time analysis  similarly  for the test concerning the plan quality
analysis we computed the differences between the makespan of the plans generated by the
two planners  the absolute values of these differences are ranked by increasing numbers
starting from the lowest value   the lowest value is ranked    the next lowest value is
ranked    and so on   then we sum the ranks of the positive differences  and we sum the
ranks of the negative differences  if the performance of the two planners is not significantly
different  then the number of the positive differences will be approximately equal to the
number of the negative differences  and the sum of the ranks in the set of the positive
differences will be approximately equal to the sum of the ranks in the other set  intuitively 
the test considers a weighted sum of the number of times one planner performs better than
the other  the sum is weighted because the test uses the performance gap to assign a rank
to each performance difference 
each cell in figure   gives the result of a comparison between the performance of
lpg td and another ipc   planner  when the number of the samples is sufficiently large 
the t distribution used by the wilcoxon test is approximatively a normal distribution 
therefore  the cells of the figure contain the z value and the p value characterizing the
normal distribution  the higher the z value  the more significant the difference of the
performance is  the p value represents the level of significance in the performance gap 
we use a confidence level of        hence  if the p value is lower than        then the
performance of the compared planners is statistically different  when this information
appears on the left  right  side of the cell  the first  second  planner named in the title of
the cell performs better than the other planner    for the analysis comparing the cputime  the value under each cell is the number of the problems solved by at least one planner 
while for the analysis comparing the plan quality  it is the number of problems solved by
both the planners 
figure   shows a graphical description of the relative performance of the ipc   satisficing
planners according to the wilcoxon test for the benchmark problems with timed initial
literals  a solid arrow from a planner a to a planner b  or a cluster of planners b 
indicates that the performance of a is statistically different from the performance of b 
and that a performs better than b  every planner in b   a dashed arrow from a to b
indicates that a is better than b a significant number of times  but there is no significant
wilcoxon relationship between a and b with a confidence level of        on the other
hand  the relationship holds with a confidence level slightly less than         the results
of this analysis say that lpg td is consistently faster than tilsapa and p mep  while it is
faster than sgplan a significant number of times  in terms of plan quality  lpg td performs
consistently better than p mep  sgplan and tilsapa 
although lpg td does not guarantee optimal plans  it is interesting to compare its
performance with the optimal planners that took part in ipc    especially to see how good
lpg tds plans are  figure   shows the performance of lpg td and the best results over the
results of all the other optimal ipc   planners  allothers opt  in the temporal variants
of airport and umts  without flawed actions   the plots for the plan quality  makespan 
    the p value in the cell comparing lpg td and p mep is omitted because the number of problems solved by
both lpg td and p mep is not high enough to approximate the t distribution to a normal distribution 

   

figerevini  saetti   serina

airport time

milliseconds
 e   

airport time

makespan
    

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

   

 e   

   
   

      

   
     

   
   

    

   
   

   

   
  

 
 

 

  

  

  

  

  

  

  

  

umts time

milliseconds
 e   

 

 

  

  

  

  

  

  

  

umts time

makespan
   

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

  

lpg td s     solved 
lpg td bq     solved 
allothers opt     solved 

   

 e   
   
      
   

     

   

   
    
   
   
   

  

   
 

 

  

  

  

  

  

  

  

  

  

 

 

  

  

  

  

  

  

  

  

  

figure    performance of lpg td and the best over all the optimal planners of ipc  
 allothers opt  in airport time and umts time  cpu time in logarithmic scale
 left plots  and plan makespan  right plots   on the x axis we have the problem
names simplified by numbers 

show that  in nearly every problem of these domains  the best quality plan found by lpg td
is an optimal solution  and that the first plan found by lpg td is generally a good solution 
the plots for the cpu time show that lpg td finds a plan much more quickly than any
optimal planner  and that the cpu time required by lpg td to find the best plan is often
lower than the cpu time required by allothers opt  except for problems            and
   of airport   it should be noted that lpg td bq is the last plan over a sequence of
computed plans with increasing quality  and cpu time   the intermediate plans in this
sequence could already have good quality  in particular  as shown by the plan quality plot
for airport  the first plan  lpg td s  solving problem    has near optimal quality  but it is
computed much more quickly than the lpg td bq plan and the allothers opt plan 
   

fian approach to temporal planning and scheduling

figure     plan quality distance between the solutions found by lpg td and the corresponding optimal solutions  on the x axis  we have some classes of quality distance
 e g         means that the plan generated by lpg td is worse than the
optimal plan by a factor between     and        on the y axis  we have the
percentage of solved problems for each of these classes 

finally  figure    gives the results of a more general analysis on the plan quality distance 
considering all metric temporal and strips variants of the ipc   domains     the analysis
uses only the problems solved by at least one ipc   optimal planner  it is also important to
note that we consider only the plans generated by the incremental process of lpg td using
no more cpu time than the cpu time required by the fastest optimal planner  allothersopt   overall  the results in figure    provide significant empirical evidence supporting
the claim that often an incremental local search approach allows us to compute plans with
very good quality using less or no more cpu time than an optimal approach  in particular 
the bars for the      class in the plot of the metric temporal problems show that the
percentage of the test problems in which the best quality plan of lpg td  lpg td bq  is
optimal or nearly optimal  i e   plan quality is worse than optimal by a factor between
  and       with   meaning no difference  is about      moreover  often the first plan
computed by lpg td  lpg td s  has good quality      of all these plans have quality that
is optimal or nearly optimal  and only about     of them have a quality that is worse than
the optimal by a factor greater than     
interestingly  the plot on the right of figure    shows similar results concerning the good
quality of lpg tds plans also for the strips problems of ipc    with a lower percentage
of the lpg td s plans that are in the      class  and a slightly higher percentage of the
lpg td bqs plans that are in the       class  
    temporal reasoning in lpg td
we conducted two main experiments  the first was aimed at testing the performance
of lpg td when the number of windows for the timed initial literals varies in problems
    for the strips problems  the plan quality metric is the number of the actions in the plan 

   

figerevini  saetti   serina

having the same initial state and goals  the second experiment focused on our temporal
reasoning techniques with the main goals of empirically evaluating their performance  and
understanding their impact on the overall performance of lpg td 
for these experiments we used two well known ipc   domains  which were modified to
include timed initial literals  rovers and zenotravel  the version of rovers with timed
initial literals was obtained from the ipc   temporal version as follows  in the problem
specification  for each waypoint  we added a collection of pairs of timed initial literals of
the type
 at t   in sun waypoint   
 at t   not  in sun waypoint    

where t    t    each of these pairs defines a time window for the involved literal  in the
operator specification file  the recharge operator has the precondition
 over all  in sun  w  

which imposes the constraint that the recharging actions are applied only when the rover is
in the sun   w is the operator parameter representing the waypoint of the recharging action  
the modified version of zenotravel was obtained similarly  in the problem specification 
for each city we added a collection of pairs of timed initial literals of the type
 at t   open station city   
 at t   not  open station city    

and in the operator specification file  we added the timed precondition
 over all  open station  c  

to the refuel operator  where  c is the operator parameter representing the city where
the refuel action is executed 
given a planning problem  and a collection of time windows w for a timed literal   it
should be noted that  in general  the difficulty of solving  is affected by three parameters 
the number of windows in w   their size  and the way they are distributed on the time
line    we considered two methods for generating test problems taking account of these
parameters   indicates an original ipc   problem in either the rovers or zenotravel
domain  and n indicates the number of windows in w   
 i  let  be the best  shortest makespan  plan among those generated by lpg td for
solving  within a certain cpu time limit  and t the makespan of   the time
interval     t  is divided into  n    sub intervals of equal size  the time windows for
each timed literal  of the extended problem   are the odd sub intervals of     t  
i e  
o
nh
 h

h
 t
t
 t
   n 
 
t
 
w       n 
   n 
            n  t
 n 
 ii  let d be the maximum duration of an action in  with a timed precondition   the
time interval        d    n      is divided into  n    sub intervals of duration d 
    in general  these parameters influence not only the hardness of temporal reasoning during planning  but
also the logical part of the planning process  i e   the selection of the actions forming the plan  that in
lpg td is done using heuristics taking exogenous events into account  

   

fian approach to temporal planning and scheduling

rovers windows

milliseconds
     

zenotravel windows

milliseconds
 e   

  time window per waypoint
   time windows per waypoint

  time window per city
   time windows per city

      

    
     

    
   

   

  

  
 

 

 

 

 

  

  

  

  

  

  

 

 

 

 

 

  

  

  

  

  

  

figure     performance of lpg td in the rovers and zenotravel domains extended with
timed initial literals    and    time windows for each timed literal   the test
problems were generated using method i  on the x axis we have the problem
names simplified by numbers  on the y axis we have cpu milliseconds  logarithmic scale  

similarly to method  i   the time windows for  in the extended problem   are the
odd sub intervals of  
notice that we can use the first method only when the number of windows is relatively
small because  if there are too many time windows of small size  the extended problem can
become unsolvable  no window is large enough to schedule into it a necessary action with
a timed precondition   the second method was designed to avoid this problem  and it can
be used to test our techniques on planning problems involving many time windows 
figures    and    give the results of the first experiment  the cpu times in these plots
are median values over five runs for each problem  for the results of figure     we use
the ipc   test problems modified by method i  while for the results of figure    we use
the ipc   test problems modified by method ii  in both cases lpg td solves all problems 
the plots of figure    indicate that the performance degradation when the number of
windows increases from   to    is generally moderate  except in two cases  the plots of
figure    indicate that  when the number of windows increases exponentially from   to
        the approach scales up well for the benchmark problems considered  for instance 
consider the first zenotravel problem  with   window lpg td solves this problem in   
milliseconds  with    windows in    milliseconds  with     windows in    milliseconds 
with      windows in about     milliseconds  and with        windows in about   second 
moreover  we observed that the performance degradation is mainly determined by a heavier
pre processing phase  parsing and instantiation of the operators  
tables   and   give some results concerning the experiment about our temporal reasoning
techniques implemented in lpg td  we consider some of the problems with    time windows
 for each timed fluent  used for the tests of figure     and we examine the computational
   

figerevini  saetti   serina

performance of lpg td in rovers timewindows

milliseconds
      

performance of lpg td in zenotravel timewindows

milliseconds
 e   

  time window per waypoint
   time windows per waypoint
    time windows per waypoint
     time windows per waypoint
       time windows per waypoint

  time window per city
   time windows per city
    time windows per city
     time windows per city
       time windows per city

      

     

     
    
    

   
   

  

  
 

 

 

 

 

  

  

  

  

  

  

 

 

 

 

 

  

  

  

  

  

  

figure     performance of lpg td in the rovers and zenotravel domains extended with
timed initial literals          time windows for each timed literal   the test
problems were generated using method ii  on the x axis we have the problem
names simplified by numbers  on the y axis we have cpu milliseconds  logarithmic scale  

cost of temporal reasoning during planning for these problems  in our approach to temporal
planning  each search step defines a set of temporal constraints formed by the ordering and
scheduling constraints in the current tda graph  table   gives statistical information about
such dtps using both the compact constraint representation of lpg td and the classical
dtp representation  for each action in the tda graph  we have two temporal variables
 the start end times of the action   except astart and aend  for which  as we have pointed out 
we can use only one variable   the number of the scheduling constraints and the number
of the ordering constraints depend on which actions are in the current tda graph  and on
how these actions are  causally or exclusively  related to each other  respectively  we have
one scheduling constraint for each action with a timed precondition in the tda graph  
notice that our representation of the scheduling constraints is much more compact than
the classical dtp formulation   
the table also gives information about the average number of dtps  i e   search steps 
generated during planning  indicating how many of them are satisfiable  indicated with
sat  dtps  
table   gives the cpu time required by our temporal reasoning techniques implemented
in lpg td  solve dtp    and by tsat    armando  castellini  giunchiglia    maratea 
       a state of the art general dtp solver  the dtps considered here are the same as
those of table    i e   the sets of the temporal constraints in the tda graph at each search
    the classical dtp translation of a scheduling constraint contains an exponential number of disjuncts
with respect to the number of time windows in the scheduling constraint  for example  let q be a
timed precondition of a and wq                          the scheduling constraint of a determined by q is

 

translated into four classical dtp constraints  as abbreviates astart     a 
s a      as a      
 
 

 
 
 
 
 

 
 

  

a

a

a

    
 a

a

  

a

     
 a

a

a

  

a

a
 a 
s       
s
s
s
s
s

   

fian approach to temporal planning and scheduling

problems
rovers
problem  
problem  
problem   
problem   
problem   
zenotravel
problem  
problem  
problem   
problem   
problem   

variables
max mean
  
  
  
  
   

    
    
    
    
     

 
  
   
   
   

 
  
    
     
     

sc with    windows  dc 
max
mean
 
 
 
 
 

      
      
      
      
      

        
        
           
           
           

dtps
 sat  dtps 

            
            
           
           
           

       
       
        
       
         

            
            
             
             
             

     
       
          
         
         

table    characteristics of the dtps generated during planning by lpg td when solving
some problems in the rovers and zenotravel domains  maximum mean number of variables   nd  rd columns   maximum mean number of scheduling constraints  sc  and of non unary disjunctions  dc  in their dtp form translation   th  th columns   number of dtps and of satisfiable dtps solved by lpg td
  th column  

step of the planning process  it should be noted that the comparison of solve dtp   and
tsat   is by no means intended to determine which one is better than the other  indeed
tsat   was developed to manage a much larger class of dtps  however  to the best of
our knowledge there exists no other more specialized dtp solver handling scheduling constraints that we could have used  the goal of this comparison is to experimentally show
that existing general dtp solvers  although designed to work efficiently in the general case 
are not adequate for managing the class of dtps that arise in our planning framework 
hence  it is important to develop more specialized techniques which  as empirically demonstrated by the results of table    can be much more efficient  for instance  consider problem
   in the rovers domain  as indicated by the last column of table    lpg td solves this
problem with    search steps  which defines    dtps  the data in table   show that
the total cpu time spent by lpg td for solving all these temporal reasoning problems is
negligible        seconds   while tsat   requires      cpu seconds in total  note that
the whole temporal planning problem is solved by lpg td in only      seconds      overall 
our specialized temporal reasoning technique is several orders of magnitude faster than an
efficient general dtp  in terms of both cpu time for solving a single dtp  and cpu time
for solving all the dtps that are generated during planning 
    the cpu time of tsat   includes neither the generation of the explicit  classical  dtps from the tdagraph  nor the parsing time  moreover  while tsat   only decides satisfiability of the input dtps 
solve dtp  also finds a schedule that is optimal  if the dtp is satisfiable 

   

figerevini  saetti   serina

problems

rovers
problem  
problem  
problem   
problem   
problem   
zenotravel
problem  
problem  
problem   
problem   
problem   

cpu seconds for temporal reasoning
solve dtp 
tsat  
max
mean
total
max
mean
total

total
cpu time
of lpg td

     
     
     
     
    

     
     
     
     
      

     
     
     
     
    

     
     
    
    
    

     
     
     
     
    

    
    
    
    
     

    
    
    
    
    

     
     
    
    
    

     
     
       
       
       

     
     
   
    
   

     
    
   
    
     

      
     
   
   
    

    
    
    
      
       

    
    
    
    
     

table    performance of solve dtp  and tsat   for the dtps generated during planning
by lpg td when solving some problems in the rovers and zenotravel domains 
maximum  mean and total cpu seconds  the last column gives the total cputime of lpg td for solving the planning problem  tsat   was run using its default
settings 

finally  we experimentally tested the effectiveness of the improvements to solve dtp  
for making the algorithm incremental that we have described at the end of section    such
improvements are included in the implementation of solve dtp  of table     in particular
we observed that  for the problems of table    the average cpu time of the basic  nonincremental  version of solve dtp  is from one to three orders of magnitude higher than
the incremental version  however  the basic version is still always significantly faster than
tsat    from one to four orders of magnitude  

   related work
several researchers have addressed temporal reasoning in the context of the dtp framework  some general techniques aimed at efficiently solving a dtp have been proposed
 e g   armando et al         tsamardinos   pollack         but their worst case complexity
remains exponential  in section    we presented some experimental results indicating that
the simple use of a state of the art dtp solver is not adequate for solving the subclass of
dtps that arise in our context 
various planning approaches supporting the temporal features considered in this paper
have been proposed  one of the first planners that was capable of handling predictable
exogenous events is deviser  vere         which was developed from nonlin  tate        
deviser is a temporal partial order planner using a network of activities called a plan
network  before starting plan generation  the plan network contains the exogenous events
   

fian approach to temporal planning and scheduling

as explicit nodes of the network  during plan generation  the activities added to the network
are ordered with respect to these scheduled events  depending on the relevance of the events
for the activities  a similar explicit treatment of the exogenous events could be also adopted
in the context of the action graph representation  the initial action graph contains special
action nodes representing the predicted exogenous events  however  this simple method
has some disadvantages with respect to our method  that treats exogenous events at the
temporal level of the representation rather than at the logical  causal  level  in particular 
when there is a high number of timed initial literals  the explicit representation of the
exogenous events in the action graph could lead to very large graphs  causing memory
consumption problems and a possibly heavy cpu time cost for the heuristic evaluation of
the  possibly very large  search neighborhood 
in the late   s and early   s some other temporal planners handling exogenous events
were developed  in general  these systems use input descriptions of the planning problem domain that are significantly different from the pddl descriptions accepted by modern
fully automated planners  one of the most successful among them is hsts  frederking  
muscettola        muscettola         a representation and problem solving framework that
provides an integrated view of planning and scheduling  hsts represents predictable exogenous events through non controllable state variables  both lpg td and hsts manage
temporal constraints  but the two systems use considerably different approaches to temporal
planning  lpg td adopts the classical state transition view of change  while hsts adopts
the histories view of change  ghallab  nau    traverso         and they are based on
different plan representations and search techniques 
zeno  penberthy        penberthy   weld        is one of the first domain independent
planners which supports a rich class of metric temporal features  including exogenous events 
zeno is a powerful extension of the causal link partial order planner ucpop  penberthy  
weld         however  in terms of computational performance  this planner is not competitive with more recent temporal planners 
ixtet  ghallab   laruelle        laborie   ghallab        is another causal link planner which uses some techniques and ideas from scheduling  temporal constraint reasoning 
and graph algorithms  ixtet supports a very expressive language for the temporal description of the actions  including timed preconditions and some features that cannot be
expressed in pddl     the expressive power of the language is obtained at the cost of increased semantic complexity  fox   long         as observed by ghallab  nau and traverso
        ixtet embodies a compromise between the expressiveness of complex temporal domains  and the planning efficiency  however  this planner still remains noncompetitive with
the more recent temporal planners 
smith and weld        studied an extension of the graphplan style of planning for
managing temporal domains  they proposed an extension of their tgp planner that makes
it possible to represent predictable exogenous events  tgp supports only a subclass of the
durative actions expressible in pddl     which prevents some cases of concurrency that
in pddl    are admitted  tgp is an optimal planner  under the assumed conservative
model of action concurrency   while lpg td is a near optimal  satisficing  planner  a main
drawback of tgp is that it does not scale up adequately 
more recently  edelkamp        proposed a method for planning with timed initial
literals that is based on compiling the action timed preconditions into a time window as   

figerevini  saetti   serina

sociated with the action  defining the interval during which the action can be scheduled 
he gives an efficient  polynomial algorithm based on critical path analysis for computing
an optimal action schedule from sequential plans generated using the compiled representation  the techniques presented by edelkamp assume a unique time window for each
timed precondition  the techniques that we propose are more general  in the sense that our
action representation treats multiple time windows associated with a timed precondition 
and our temporal reasoning method computes optimal schedules for partially ordered plans
preserving polynomiality 
cresswell and coddington        proposed an extension of the lpgp planner  long
  fox      b  to handle timed initial literals  which are represented by special deadline
actions  a literal that is asserted to hold at time t is represented by a deadline action
starting at the time of the initial state  and having duration t  the deadline actions in the
plan under construction are translated into particular linear inequalities that  together with
other equalities and inequalities generated from the plan representation  are managed by
a general linear programming solver  lpg td uses a different representation that does not
encode timed initial literals as special actions  and in which the temporal and scheduling
constraints associated with the actions in the plan are managed by an efficient algorithm
derived by specializing a general dtp solver 
in order to handle problems with timed initial literals in the sapa planner  do   kambhampati         do  kambhampati and zimmerman        proposed a forward search
heuristic based on relaxed plans  which are constructed by exploiting a technique similar to
the time slack analysis used in scheduling  smith   cheng         given a set of candidate
actions for choosing an action to add to the relaxed plan under construction  this technique
computes the minimum slack between each candidate action and the actions currently in
the relaxed plan  the candidate action with the highest minimum slack is preferred  lpg td
uses a different time slack analysis  which is exploited in a different way  our method for
selecting the actions forming the relaxed plan uses the time slacks for counting the number
of scheduling constraints that would be violated when adding a candidate action  we prefer
the candidate actions which cause the lowest number of violations  moreover  in sapa the
slack analysis is limited to the actions of the relaxed plan  while our method also considers
the actions in the real plan under construction 
dt pop is a recent planner  schwartz   pollack        extending the pop style of
planning with an action model involving disjunctive temporal constraints  the language of
dt pop is elegant and can express a rich class of temporal features  most of which can be
only indirectly  and less elegantly  expressed in pddl     fox et al          the treatment
of the temporal constraints required to manage predictable exogenous events in dt pop
appears to be less efficient than in our planner  since dt pop uses a general dtp solver
enhanced with some efficiency techniques  while lpg td uses a polynomial solver specialized
for the subclass of dtps that arise in our representation  dt pop handles mutex actions
 threats  by posting explicit temporal disjunctive constraints imposing disjointness of
the mutex actions  while lpg td implicitly decides these disjunctions at search time by
choosing the level of the graph where actions are inserted  and asserting the appropriate
precedence constraints  moreover  the search procedure and heuristics in dt pop and lpgtd are significantly different 
   

fian approach to temporal planning and scheduling

at ipc    the planners that reasoned with timed initial literals are tilsapa  kavuluri  
u         sgplan  chen et al          p mep  sanchez et al         and lpg td  for the first
two planners  at the time of writing  to the best of our knowledge in the available literature
there is no sufficiently detailed description to clearly understand their possible similarities
and differences with lpg td about the treatment of predictable exogenous events  regarding
p mep  this planner uses forward state space search guided by a relaxed plan heuristic which 
differently from the relaxed plans of lpg td  is constructed without taking account of the
temporal aspects of the relaxed plan and real plan under construction  the makespan of the
constructed relaxed plans is considered only for their comparative evaluation  

   conclusions
we have presented some techniques for temporal planning in domains where certain fluents
are made true or false at known times by predictable exogenous events that cannot be
influenced by the actions available to the planner  such external events are present in many
realistic domains  and a planner has to take them into account to guarantee the correctness
of the synthesized plans  to generate plans of good or optimal quality  makespan   and to
use effective search heuristics for fast planning 
in our approach  the causal structure of the plan is represented by a graph based representation called tda graph  action ordering and scheduling constraints are managed by
efficient constraint based reasoning  and the plan search is based on a stochastic local search
procedure  we have proposed an algorithm for managing the temporal constraints in a
tda graph which is a specialization of a general csp based method for solving dtps 
the algorithm has a polynomial worst case complexity and  when combined with our plan
representation  in practice it is very efficient  we have also presented some local search
techniques for temporal planning using the new tda graph representation  these techniques improve the accuracy of the heuristic methods adopted in the previous version of
lpg  and they extend them to consider action scheduling constraints in the evaluation of the
search neighborhood  which is based on relaxed temporal plans exploiting some  dynamic 
reachability information 
all our techniques are implemented in the planner lpg td  we have experimentally
investigated the performance of our planner by a statistical analysis of the ipc   results
using wilcoxons test  the results of this analysis show that our planner performs very well
compared to other recent temporal planners supporting predictable exogenous events  both
in terms of cpu time to find a valid plan and quality of the best plan generated  moreover 
a comparison of the plans computed by lpg td and those generated by the optimal planners
of ipc   shows that very often lpg td generates plans with very good or optimal quality 
finally  additional experiments indicate that our temporal reasoning techniques manage the
class of dtps that arise in our context very efficiently 
some directions for future work on temporal planning within our framework are  an
extension of the local search heuristics and temporal reasoning techniques to explicitly handle action effects with limited persistence or delays  the treatment of predictable exogenous
events affecting numerical fluents in a discrete or continuous way  the development of tech   

figerevini  saetti   serina

niques supporting controllable exogenous events    and the management of actions with
variable durations  fox   long         i e   actions whose durations are specified only by
inequalities constraining their lower or upper bounds  and whose actual duration is decided
by the planner 
moreover  we intend to study the integration into our framework of the techniques for
goal partitioning and subplan composition that have been successfully used by sgplan
 chen et al         in ipc    and the application of our approach to plan revision  the
latter has already been partially explored  but only for simple strips domains and using
less powerful search techniques  gerevini   serina        

acknowledgments
this paper is a revised and extended version of a paper appearing in the proceedings of
the nineteenth international joint conference on artificial intelligence  gerevini  saetti   
serina      a   the research was supported in part by miur grant anemone  the work
of ivan serina was in part carried out at the department of computer and information
sciences of the university of strathclyde  glasgow  uk   and was supported by marie curie
fellowship n hpmf ct             we would like to thank the anonymous reviewers for
their helpful comments  and paolo toninelli who extended the parser of lpg td to handle
the new language features of pddl    

appendix a  reachability information
the techniques described in the paper for computing the action evaluation function use
heuristic reachability information about the minimum number of actions required to reach
the preconditions of each domain action  n um acts  and a lower bound on the earliest
finishing time  ef t  of the reachable actions  the actions whose preconditions are reachable  
in the following  s l  denotes the state defined by the facts corresponding to the fact nodes
supported at level l of the current tda graph  when l      s l  represents the initial state
of the planning problem  i  
for each action a  lpg td pre computes n um acts a  i   i e   the estimated minimum
number of actions required to reach the preconditions of a from i  and ef t a  i   i e   the
estimated earliest finishing time of a  if a is reachable from i   similarly  for each fact f that
is reachable from i  lpg td computes the estimated minimum number of actions required
to reach f from i  n um acts f  i   and the estimated earliest time when f can be made
true by a plan starting from i  et f  i    for l      n um acts a  s l   and ef t a  s l  
can be computed only during search  because they depend on which action nodes are in the
current tda graph at the levels preceding l  since during search many action nodes can be
added and removed  and after each of these operations n um acts a  s l   and ef t a  s l  
could change  if the operation concerns a level preceding l   it is important that they are
computed efficiently 
    consider for instance a transportation domain in which a shuttle bus is at the train station for an extra
run to the airport at midnight only if booked in advance  if the shuttle booking is a domain action
available to the planner  then the event night stop of the shuttle can be controlled by the planner 

   

fian approach to temporal planning and scheduling

reachabilityinformation i  o 
input  the initial state of the planning problem under consideration  i  and all ground instances
 actions  of the operators  o  
output  for each action a  an estimate of the number of actions  n um acts a  i   required to reach
the preconditions of a from i  an estimate of the earliest finishing time of a from i  ef t a  i   
  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

forall facts f do    the set of all facts is precomputed by the operator instantiation phase   
if f  i then
n um acts f  i   et f  i      action f  i   astart  
else n um acts f  i   et f  i    
forall actions a do n um acts a  i   ef t a  i   lf t a    
f  i  fnew  i  a  o  arev   
while   fnew     or arev      
f  f  fnew   fnew    a  a  arev   arev   
while a     a  a   p re a   f   is not empty
a  an action in a   
t  computeeft a  m ax et f  i   
f p re a 

if t   ef t a  i  then ef t a  i   t 
lf t a   computelft a  
if ef t a  i   lf t a  then    a can be scheduled   
ra  requiredactions i  p re a   
if n um acts a  i    ra then n um acts a  i   ra 
forall f  add a  do
if et f  i    t then
et f  i   t 
arev  arev   a   o  a   f  p re a     
if n um acts f  i     ra      then
n um acts f  i   ra      action f  i   a 
fnew  fnew  add a   f  
a  a   a  

requiredactions i  g 
input  a set of facts i and a set of action preconditions g 
output  an estimate of the min number of actions required to achieve all facts in g from i  acts  
  
  
  
  
  
  
  
  

act s   
g  g  i 
while g    
g  an element of g 
a  action g  i  
act s  act s   a   s
g  g  p re a   i  bact s add b  
return  act s   

figure     algorithms for computing heuristic information about the search cost and the
time for reaching a set of facts g from i 

   

figerevini  saetti   serina

figure    gives reachabilityinformation  the algorithm used by lpg td for computing
n um acts a  i   ef t a  i   n um acts f  i  and et f  i   reachabilityinformation is similar
to the reachability algorithm used by the version of lpg that took part in      planning
competition  lpg ipc    but with some significant differences  the main differences are 
 i  in order to estimate the earliest finishing time of the domain actions  reachabilityinformation takes into account the scheduling constraints  which were not considered in
the previous version of the algorithm 
 ii  the algorithm used by lpg ipc  applies each domain action at most once  while reachabilityinformation can apply them more than once 
notice that  i  improves the accuracy of the estimated finishing time of the actions
 ef t   which is an important piece of information used during the search neighborhood
evaluation for selecting the actions forming the temporal relaxed plans  see section    
moreover   i  allows us to identify some domain actions that cannot be scheduled during
the time windows associated with their timed preconditions  and so these can be pruned
away 
regarding  ii   during the forward process of computing the reachability information  an
action is re applied whenever the estimated earliest time of one of its preconditions has been
decreased  this is important for two reasons  on one hand  reconsidering actions already
applied is useful because it can lead to a better estimate of the action finishing times 
on the other hand  this is also necessary to guarantee the correctness of the reachability
algorithm  the latter is because  if we overestimate the earliest finishing time of an action
with a scheduling constraint  then we could incorrectly conclude that the action cannot be
scheduled  and so we would consider the action inapplicable   but if this action is necessary
in any valid plan  then the incorrect estimate of its earliest finishing time could lead to the
incorrect conclusion that the planning problem is unsolvable  in other words  the estimated
finishing time of an action with a scheduling constraint should be a lower bound of its actual
earliest finishing time 
reachabilityinformation could be used to update n um acts a  s l   and ef t a  s l   after
each action insertion removal  for any l      when l      instead of i  in input the algorithm
has s l    however  in order to make the updating process more efficient  the revision is done
in a more selective focused way  instead of revising the reachability information after each
graph modification  search step   we do so before evaluating the search neighborhood and
choosing the estimated best modification  specifically  if we are repairing the flawed level l 
we update only the reachability information for the actions and facts at the levels preceding
l that have not been updated yet   for instance  suppose that at the ith search step we add
an action to level    and that at the  i     th step we add another action at level     at
the  i     th step we need to consider updating only the reachability information at levels
     since this information at levels    has already been updated by the ith step   this is
sufficient because the search neighborhood for repairing the flawed level under consideration
 l  can contain only the graph modifications concerning the levels preceding l 
before describing the steps of reachabilityinformation  we need to introduce some notation  add  a  denotes the set of the positive effects of a  pre a  denotes the set of the
 non timed  preconditions of a  arev denotes the set of the actions already applied whose
   

fian approach to temporal planning and scheduling

reachability could be revised because the estimated earliest time of some of their preconditions has been revised after their application  given an action node a and its current
earliest start time t computed as the maximum over the earliest times at which its preconditions are reachable  computeeft  a  t  is a function computing the earliest finishing
time  of a that is consistent with the scheduling constraint of a  if any  and such that
t   dur a        computelft  a  is a function computing the latest finishing time of the
action a  i e   it returns the upper bound of the last time window during which a can be
scheduled  if one exists   while it returns  if a has no timed precondition 
for example  let a be an action such that all its preconditions are true in the initial
state i  i e   t       the duration of a is     and a has a scheduling constraint imposing that
the action is executed during the interval            computeeft  a  t  returns     while
computelft  a  t  returns      thus  the scheduling constraint of a can be satisfied  on
the contrary  if the earliest start time of a is      then computeeft  a  t  returns     and
a cannot be scheduled during           
for the sake of clarity  first we describe the steps of reachabilityinformation used to derive
n um acts  and then we comment on those for the computation of ef t  in steps     for
every fact f   the algorithm initializes n um acts f  i  to    if f  i  and to  otherwise
 indicating that f is not reachable   while  in step    n um acts a  i  is initialized to 
 indicating that a is not reachable from i   then  in steps     the algorithm iteratively
constructs the set f of the facts that are reachable from i  starting with f   i  and
terminating when f cannot be further extended and the set arev of the actions to reconsider
is empty  the set a of the available actions is initialized to the set of all possible actions
 step     a is reduced by a after its application  step      and it is augmented by the set of
actions arev  step    after each action application  when we modify the estimated time at
which a precondition of an action a becomes reachable  a is added to a rev  step      the
internal while loop  steps      applies the actions in a to the current f   possibly deriving
a new set of facts fnew in step     if fnew or arev are not empty  then f is extended with
fnew   a is extended with arev   and the internal loop is repeated  when an action a in a 
 the subset of actions currently in a that are applicable to f   is applied  the reachability
information for its effects are revised as follows  first we estimate the minimum number
ra of actions required to achieve p re a  from i using the subroutine requiredactions  step
     then we use ra to possibly update n um acts a  i  and n um acts f  i  for any effect
f of a  steps              if the number of actions required to achieve the preconditions
of a is lower than the current value of n um acts a  i   then n um acts a  i  is set to ra 
moreover  if the application of a leads to a lower estimate of f   i e   if ra     is less than the
current value of n um acts f  i   then n um acts f  i  is set to ra      in addition  a data
structure indicating the current best action to achieve f from i  action f  i   is set to a
 step      this information is used by the subroutine requiredactions 
for any fact f in the initial state  the value of action f  i  is astart  step     the
subroutine requiredactions is the same as the one in the reachability algorithm of lpg ipc  
the subroutine uses action to derive ra through a backward process starting from the input
set of action preconditions  g   and ending when g  i  the subroutine incrementally
constructs a set of actions  acts  achieving the facts in g and the preconditions of the
    if there is no scheduling constraint associated with a  or the existing scheduling constraints cannot be
satisfied by starting the action at t  then computeeft  a  t  returns t   dur a  

   

figerevini  saetti   serina

actions already selected  using action   at each iteration the set g is revised by adding the
preconditions of the last action selected  and removing the facts belonging to i or to the
effects of actions already selected  step     termination of requiredactions is guaranteed
because every element of g is reachable from i 
we now briefly describe the computation of the temporal information  eft a  i   is computed in a way similar to n um acts a  i   in steps     reachabilityinformation initializes
the estimated earliest time  et f  i   when a fact f becomes reachable to    if f  i  and
to  otherwise  moreover  the algorithm sets ef t a  i  and lf t a  i  to   then  at every
application of an action a in the forward process described above  we estimate the earliest
finishing time ef t by adding the duration of a to the  current  maximum estimated earliest
time of the preconditions of a  and by taking into account the scheduling constraints of a
using computeeft  a   step      in addition  we compute the latest finishing time lf t
of a using computelft  a   step      when the earliest finishing time of an action a is
greater than its latest finishing time  the timed preconditions of a cannot be satisfied from
i  and so steps      are not executed  see the if statement of step      for any effect f of
a with a current temporal value higher than the earliest finishing time t of a  steps     
set et f  i  to t  and step    adds a in arev  because we have decreased the estimated
earliestx time of f   and this revision could decrease the estimated start time of an action
with precondition f   

appendix b  wilcoxon test for the metric temporal domains of ipc  
in this appendix  we present the results of the wilcoxon sign rank test on the performance
of lpg td and the other satisficing ipc   planners that attempted the metric temporal
domains  the performance is evaluated both in terms of cpu times and plan quality 
each cell in the first two tables gives the result of a comparison between the performance
of lpg td and another ipc   planner  when the number of samples is sufficiently large  the
t distribution used by the wilcoxon test is approximatively a normal distribution  hence 
in each cell of the figure we give the z value and the p value characterizing the normal
distribution  the higher the z value  the more significant the difference of the performance
is  the p value represents the level of significance in the difference of the performance 
we use a confidence level of        therefore  if the p value is lower than        then the
performance of the two planners is statistically different  when this information appears
on the left  right  side of the cell  the first  second  planner named in the title of the cell
performs better than the other  for the analysis comparing the cpu time  the value under
each cell is the number of the problems solved by at least one planner  while for the analysis
comparing the plan quality  it is the number of problems solved by both the planners 
the pictures under the tables show the partial order of the performance of the compared
planners in terms of cpu time and plan quality  a solid edge from a planner a to another
planner b  or a cluster of planners b  indicates that the performance of a is statistically
different from the performance of b  and that a performs better than b  every planner in
b   a dashed edge from a to b indicates that a is better than b a significant number of
times  but there is not significant wilcoxon relationship between them at a confidence level
of       
   

fian approach to temporal planning and scheduling

lpg td s vs crikey
      
       
   

analysis of cpu time
lpg td s vs p mep
lpg td s vs sgplan
      
     
       
       
   
   

lpg td s vs tilsapa
      
       
   

lpg td bq vs crikey
      
       
   

analysis of plan quality
lpg td bq vs p mep lpg td bq vs sgplan
     
      
       
       
  
   

lpg td bq vs tilsapa
     
       
  

lpg td s
crikey

p mep

tilsapa

sgplan

cpu time

sgplan
lpg td bq
p mep

crikey

a

b 

a is consistently better than b

tilsapa

a

b 

a is better than b a significant number of times
 confidence level        

plan quality

   

figerevini  saetti   serina

references
armando  a   castellini  c   giunchiglia  e     maratea  m          a sat based decision
procedure for the boolean combination of difference constraints  in proceedings of the
seventh international conference on theory and applications of satisfiability testing
 sat      berlin  heidelberg  new york  springer verlag  sat      lncs volume 
blum  a     furst  m          fast planning through planning graph analysis  artificial
intelligence      pp         
chen  y   hsu  c     wah b   w          sgplan  subgoal partitioning and resolution
in planning  in edelkamp  s   hoffmann  j   littman  m     younes  h   eds    in
abstract booklet of the competing planners of icaps     pp       
cresswell  s     coddington  a          adapting lpgp to plan with deadlines  in proceedings of the sixteenth european conference on artificial intelligence  ecai     
pp          amsterdam  the netherlands  ios press 
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence      pp       
do  m   b   kambhampati  s     zimmerman  t          planning   scheduling connections
through exogenous events  in proceedings of the icaps    workshop on integrating
planning into scheduling  pp       
do  m     kambhampati  s          sapa  a multi objective metric temporal planner 
journal of artificial intelligence research  jair       pp         
edelkamp  s          extended critical paths in temporal planning  in proceedings of the
icaps    workshop on integrating planning into scheduling  pp       
edelkamp  s     hoffmann  j          pddl     the language for the classic part of the
 th international planning competition  technical report      institut fur informatik 
freiburg  germany 
edelkamp  s   hoffmann  j   littman  m     younes  h         in abstract booklet of the
competing planners of icaps    
erschler  j   roubellat  f     vernhes  j  p          finding some essential characteristics
of the feasible solutions for a scheduling problem  operations research  or       pp 
       
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research  jair       pp        
fox  m     long  d          planning in time  in fisher  m   gabbay  d     vila  l   eds   
handbook of temporal reasoning in artificial intelligence  pp          elsevier science publishers  new york  ny  usa 
fox  m   long  d     halsey  k          an investigation into the expressive power of
pddl     in proceedings of the sixteenth european conference on artificial intelligence  ecai      pp          amsterdam  the netherlands  ios press 
frederking  r   e     muscettola  n          temporal planning for transportation planning and scheduling  in ieee international conference on robotics and automation
 icra      pp            ieee computer society press 
   

fian approach to temporal planning and scheduling

gerevini  a     cristani  m          on finding a solution in temporal constraint satisfaction
problems  in proceedings of the fifteenth international joint conference on artificial
intelligence  ijcai      vol     pp            san francisco  ca  usa  morgan
kaufmann publishers 
gerevini  a   saetti  a     serina  i          planning through stochastic local search and
temporal action graphs  journal of artificial intelligence research  jair       pp 
       
gerevini  a   saetti  a     serina  i          an empirical analysis of some heuristic features
for local search in lpg  in proceedings of the fourteenth international conference
on automated planning and scheduling  icaps      pp          menlo park  ca 
usa  aaai press 
gerevini  a   saetti  a     serina  i       a   integrating planning and temporal reasoning for domains with durations and time windows  in proceedings of the nineteenth
international joint conference on artificial intelligence  ijcai      pp           
menlo park  ca  usa  international joint conference on artificial intelligence inc 
gerevini  a   saetti  a   serina  i     toninelli  p       b   fast planning in domains with
derived predicates  an approach based on rule action graphs and local search  in
proceedings of the twentieth national conference on artificial intelligence  aaai     pp            menlo park  ca  usa  aaai press 
gerevini  a     serina  i          fast planning through greedy action graphs  in proceedings
of the sixteenth national conference on artificial intelligence  aaai      pp     
     menlo park  ca  usa  aaai press mit press 
gerevini  a     serina  i          fast plan adaptation through planning graphs  local and
systematic search techniques  in proceedings of the fifth international conference on
artificial intelligence planning and scheduling  aips      pp          menlo park 
ca  usa  aaai press mit press 
ghallab  m     laruelle  h          representation and control in ixtet  a temporal planner  in proceedings of the second international conference on artificial intelligence
planning systems  aips      pp        menlo park  ca  usa  aaai press 
ghallab  m   nau  d     traverso  p          automated planning  theory and practice 
morgan kaufmann publishers  san francisco  ca  usa 
glover  f     laguna  m          tabu search  kluwer academic publishers  boston  usa 
helmert  m          a planning heuristic based on causal graph analysis  in proceedings
of the fourteenth international conference on automated planning and scheduling
 icaps      pp          menlo park  ca  usa  aaai press 
kavuluri  b  r     u  s          tilsapa   timed initial literals using sapa  in edelkamp  s  
hoffmann  j   littman  m     younes  h   eds    in abstract booklet of the competing
planners of icaps     pp       
laborie  p     ghallab  m          planning with sharable resource constraints  in proceedings of the fourteenth international joint conference on artificial intelligence
 ijcai      vol     pp            san francisco  ca  usa  morgan kaufmann publishers 
   

figerevini  saetti   serina

long  d     fox  m       a   the  rd international planning competition  results and
analysis  journal of artificial intelligence research  jair       pp      
long  d     fox  m       b   exploiting a graphplan framework in temporal planning  in
proceedings of the thirteenth international conference on automated planning and
scheduling  icaps      pp        menlo park  ca  usa  aaai press 
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings
of the ninth national conference on artificial intelligence  aaai      pp         
menlo park  ca  usa  aaai press 
muscettola  n          hsts  integrating planning and scheduling  in zweben    fox
 eds    intelligent scheduling  pp          san francisco  ca  usa  morgan kaufmann publishers 
nguyen  x     kambhampati  s          reviving partial order planning  in proceedings of
the seventeenth international joint conference on artificial intelligence  ijcai     
vol     pp          san francisco  ca  usa  morgan kaufmann publishers 
penberthy  j     weld  d          ucpop  a sound  complete  partial order planner for
adl  in proceedings of the third international conference on principles of knowledge
representation and reasoning  kr     pp          san mateo  ca  usa  morgan
kaufmann publishers 
penberthy  j     weld  d          temporal planning with continuous change  in proceedings
of the twelfth national conference on artificial intelligence  aaai      pp      
      menlo park  ca  usa  aaai press mit press 
penberthy  j   s          planning with continuous change  ph d  thesis  university of
washington  seattle  wa  usa  available as technical report uw cse          
sanchez  j   tang  m     mali  a   d          p mep  parallel more expressive planner  in
edelkamp  s   hoffmann  j   littman  m     younes  h   eds    in abstract booklet
of the competing planners of icaps     pp       
schwartz  p   j     pollack  m   e          planning with disjunctive temporal constraints 
in proceedings of the icaps    workshop on integrating planning into scheduling 
pp       
smith  d     weld  d          temporal planning with mutual exclusive reasoning  in
proceedings of the sixteenth international joint conference on artificial intelligence
 ijcai      pp          san francisco  ca  usa  morgan kaufmann publishers 
smith  s     cheng  c          slack based heuristics for constraint satisfaction scheduling 
in proceedings of the eleventh national conference on artificial intelligence  aaai     pp          menlo park  ca  usa  aaai press the mit press 
stergiou  k     koubarakis  m          backtracking algorithms for disjunctions of temporal
constraints  artificial intelligence           pp        
tate  a          generating project networks  in proceedings of the fifth international
joint conference on artificial intelligence  ijcai      pp          cambridge  ma 
usa  mit  william kaufmann 
   

fian approach to temporal planning and scheduling

tsamardinos  i     pollack  m  e          efficient solution techniques for disjunctive
temporal reasoning problems  artificial intelligence             pp       
vere  s  a          planning in time  windows and durations for activities and goals  ieee
transactions on pattern analysis and machine intelligence         pp         
vidal  v          a lookahead strategy for heuristic search planning  in proceedings of the
fourteenth international conference on automated planning and scheduling  icaps     pp          menlo park  ca  usa  aaai press 
wilcoxon  f     wilcox  r  a          some rapid approximate statistical procedures 
american cyanamid co   pearl river  ny  usa 

   

fi