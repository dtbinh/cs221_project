journal artificial intelligence research                  

submitted       published     

dynamic local search maximum clique problem
wayne pullan

w pullan griffith edu au

school information communication technology 
griffith university 
gold coast  qld  australia

holger h  hoos

hoos cs ubc ca

department computer science
university british columbia
     main mall  vancouver  bc  v t  z  canada

abstract
paper  introduce dls mc  new stochastic local search algorithm maximum clique problem  dls mc alternates phases iterative improvement 
suitable vertices added current clique  plateau search 
vertices current clique swapped vertices contained current clique 
selection vertices solely based vertex penalties dynamically adjusted
search  perturbation mechanism used overcome search stagnation 
behaviour dls mc controlled single parameter  penalty delay  controls frequency vertex penalties reduced  show empirically dlsmc achieves substantial performance improvements state of the art algorithms
maximum clique problem large range commonly used dimacs benchmark
instances 

   introduction
maximum clique problem  max clique  calls finding maximum sized subgraph pairwise adjacent vertices given graph  max clique prominent combinatorial optimisation problem many applications  example  information retrieval 
experimental design  signal transmission computer vision  balus   yu        
recently  applications bioinformatics become important  pevzner   sze        ji 
xu    stormo         search variant max clique stated follows  given
undirected graph g    v  e   v set vertices e set edges 
find maximum size clique g  clique g subset vertices  c v  
pairs vertices c connected edge  i e   v  v c   v  v   e 
size clique c number vertices c  max clique n p hard
associated decision problem n p complete  garey   johnson         furthermore  inapproximable sense deterministic polynomial time algorithm
find cliques size  v         unless n p   zpp  hastad         
best polynomial time approximation algorithm max clique achieves approximation ratio o  v    log  v        boppana   halldorsson         therefore  large hard
instances max clique typically solved using heuristic approaches  particular 
   zpp class problems solved expected polynomial time probabilistic algorithm
zero error probability 
c
    
ai access foundation  rights reserved 

fipullan   hoos

greedy construction algorithms stochastic local search  sls  algorithms simulated annealing  genetic algorithms tabu search   for overview
methods solving max clique  see bomze  budinich  pardalos    pelillo        
may noted maximum clique problem equivalent independent set problem well minimum vertex cover problem  algorithm max clique
directly applied equally fundamental application relevant problems
 bomze et al         
recent literature max clique algorithms  seems that  somewhat unsurprisingly  single best algorithm  although algorithms empirically
evaluated benchmark instances second dimacs challenge  johnson   trick 
       quite difficult compare experimental results studies  mostly
differences respective experimental protocols run time environments  nevertheless  particularly considering comparative results reported grosso et al   grosso 
locatelli    croce         seems five heuristic max clique algorithms
achieve state of the art performance 
reactive local search  rls   battiti   protasi        derived reactive
tabu search  battiti   tecchiolli         advanced general tabu search method
automatically adapts tabu tenure parameter  which controls amount diversification  search process  rls uses dynamic restart strategy provide
additional long term diversification 
qualex ms  busygin        deterministic iterated greedy construction algorithm uses vertex weights derived nonlinear programming formulation maxclique 
recent deep adaptive greedy search  dags  algorithm  grosso et al        
uses iterated greedy construction procedure vertex weights  weights
dags  however  initialised uniformly updated every iteration greedy
construction procedure  dags  weighted iterated greedy construction procedure
executed iterative improvement phase permits limited amount plateau
search  empirical performance results indicate dags superior qualex ms
max clique instances dimacs benchmark sets  hard
instances reach performance rls  grosso et al         
k opt algorithm  katayama  hamamoto    narihisa        based conceptually simple variable depth search procedure uses elementary search steps
vertex added removed current clique  evidence
performs better rls many instances dimacs benchmark sets  katayama
et al          performance relative dags unclear 
finally  edge ac ls  solnon   fenet         recent ant colony optimisation algorithm max clique uses elitist subsidiary local search procedure  appears
reach  or exceed  performance dags rls least dimacs
instances 
work  introduce new sls algorithm max clique algorithm dubbed
dynamic local search max clique  dls mc  based combination constructive search perturbative local search  makes use penalty values associated
vertices graph  dynamically determined search
help algorithm avoid search stagnation 
   

fidynamic local search max clique problem

based extensive computational experiments  show dls mc outperforms
state of the art max clique search algorithms  particular dags  broad
range widely studied benchmark instances  hence represents improvement
heuristic max clique solving algorithms  present detailed results behaviour dls mc offer insights roles single parameter dynamic
vertex penalties  note use vertex penalties dls mc inspired
dynamic weights dags and  generally  current state of the art dynamic local
search  dls  algorithms well known combinatorial problems  sat
max sat  hutter  tompkins    hoos        tompkins   hoos        thornton  pham 
bain    ferreira        pullan   zhao         general introduction dls  see
work  hoos   stutzle         results therefore provide evidence
effectiveness broad applicability algorithmic approach 
remainder article structured follows  first describe dls mc
algorithm key aspects efficient implementation  next  present empirical performance results establish dls mc new state of the art heuristic max clique
solving  followed detailed investigation behaviour dls mc
factors determining performance  finally  summarise main contributions
work  insights gained study outline directions future research 

   dls mc algorithm
dags algorithm grosso et al   new dls mc algorithm based fundamental idea augmenting combination iterative improvement plateau search
vertex penalties modified search  iterative improvement procedure used algorithms based greedy construction mechanism starts
trivial clique consisting single vertex successively expands clique c adding
vertices adjacent vertices c  expansion impossible 
may still exist vertices connected one vertices c  including
vertex v c removing single vertex c connected v  new clique
number vertices obtained  type search called plateau
search  noted one plateau search steps  expansion
current clique may become possible  therefore  dls mc alternates phases
expansion plateau search 
purpose vertex penalties provide additional diversification search
process  otherwise could easily stagnate situations current clique
vertices common optimal solution given max clique instance 
perhaps obvious approach avoiding kind search stagnation simply
restart constructive search process different initial vertex  however  even
random  or systematic  variation choice initial vertex  still risk
heuristic guidance built greedy construction mechanism causes bias towards
limited set suboptimal cliques  therefore  dags dls mc utilise numerical
weights associated vertices  weights modulate heuristic selection function
used greedy construction procedure way vertices repeatedly occur
cliques obtained constructive search process discouraged used
future constructions  following intuition  consistent general approach
   

fipullan   hoos

dynamic local search  dls   based idea  paper  refer
numerical weights vertex penalties 
based general considerations  dls mc algorithm works follows  see
algorithm outline figure     picking initial vertex given graph g
uniformly random setting current clique c set consisting single
vertex  vertex penalties initialised zero  then  search alternates
iterative improvement phase  suitable vertices repeatedly added
current clique c  plateau search phase  repeatedly one vertex c
swapped vertex currently contained c 
two subsidiary search procedures implementing iterative improvement
plateau search phases  expand plateausearch  shown figure    note both 
expand plateausearch select vertex added current clique c using
penalties associated candidate vertices  case expand  selection
made set ni  c  vertices connected vertices c
edge g  call set improving neighbour set c  plateausearch 
hand  vertex added c selected level neighbour set c  nl  c  
comprises vertices connected vertices c except one vertex 
say v   subsequently removed c 
note procedures always maintain current clique c  expand terminates
improving neighbour set c becomes empty  plateausearch terminates
either ni  c  longer empty nl  c  becomes empty  also  order reduce
incidence unproductive plateau search phases  dls mc implements plateau search
termination condition  katayama et al         recording current clique  c  
start plateau search phase terminating plateausearch overlap
recorded clique c current clique c 
end plateau search phase  vertex penalties updated incrementing
penalty values vertices current clique  c  one  additionally  every pd
penalty value update cycles  where pd parameter called penalty delay   non zero
vertex penalties decremented one  latter mechanism prevents penalty values
becoming large allows dls mc forget penalty values time 
updating penalties  current clique perturbed one two ways 
penalty delay greater one  i e   penalties decreased occasionally  current
clique reduced last vertex v added it  removed vertices
increased penalty values  unlikely added back current clique
subsequent iterative improvement phase  equivalent restarting search
v  however  penalty delay one corresponds behaviour penalties
effectively used  since increase vertex penalty immediately undone  
keeping even single vertex current clique c carries high likelihood reconstructing
c subsequent iterative improvement phase  therefore  achieve diversification
search  penalty delay one  c perturbed adding vertex v
chosen uniformly random given graph g removing vertices c
connected v 
stated above  penalty values used selection vertex given
neighbour set s  precisely  selectminpenalty s  selects vertex choosing
uniformly random set vertices minimal penalty values  vertex
   

fidynamic local search max clique problem

procedure dls mc g  tcs  pd  maxsteps 
input  graph g    v  e   integers tcs  target clique size   pd  penalty delay   maxsteps
output  clique g size least tcs failed
begin
numsteps      
c     random v    
initpenalties 
numsteps   maxsteps
 c  v     expand g  c  
 c    tcs return c   end
c    c 
 c  v     plateausearch g  c  c   
ni  c    
 c  v     expand g  c  
 c    tcs return c   end
 c  v     plateausearch g  c  c   
end
updatepenalties pd   
pd    
c     v  
else
v    random v   
c    c  v  
remove vertices c connected v g 
end
end
return failed  
end

figure    outline dls mc algorithm  details  see text 

selected s  becomes unavailable subsequent selections penalties
updated perturbation performed  prevents plateau search
phase repeatedly visiting clique  also  safeguard prevent penalty
values becoming large  vertices penalty value greater    never
selected 
order implement dls mc efficiently  sets maintained using two array data
structures  first these  vertex list array  contains vertices currently
set  second one  vertex index array  indexed vertex number contains
index vertex vertex list array  or    vertex set  
additions set performed adding end vertex list array updating
vertex index array  deletions set performed overwriting vertex list
entry vertex deleted last entry vertex list updating
vertex index array  furthermore  vertices swapped current
clique plateau search phase  intersection current clique
recorded clique simply maintained recording size current clique
start plateau search decrementing one every time vertex swapped
   

fipullan   hoos

procedure expand g  c 
input  graph g    v  e   vertex set c v  clique 
output  vertex set c v  expanded clique   vertex v  most recently added vertex 
begin
ni  c    
v    selectminpenalty ni  c   
c    c  v  
numsteps    numsteps     
end while 
return  c  v   
end

procedure plateausearch g  c  c  
input  graph g    v  e   vertex sets c v  clique   c c  recorded clique 
output  vertex set c v  modified clique   vertex v  most recently added vertex 
begin
ni  c    nl  c     c c   
v    selectminpenalty nl  c   
c    c  v  
remove vertex c connected v g 
numsteps    numsteps     
end while 
return  c  v   
end

figure    subsidiary search procedures dls mc  details  see text 
current clique  finally  array elements accessed using pointers rather
via direct indexing array   
finally  may noted order keep time complexity individual
search steps minimal  selection improving level neighbour sets
attempt maximise size set respective search step  rather chooses
vertex minimal penalty uniformly random  keeping common
intuition that  context sls algorithms  often preferable perform many
relatively simple  efficiently computable search steps rather fewer complex search
steps 

   empirical performance results
order evaluate performance behaviour dls mc  performed extensive computational experiments max clique instances second dimacs
implementation challenge               used extensively benchmarking purposes recent literature max clique algorithms     dimacs
max clique instances generated problems coding theory  fault diagnosis
problems  kellers conjecture tilings using hypercubes steiner triple problem 
   several techniques based implementation details henry kautzs highly efficient walksat code  see http   www cs washington edu homes kautz walksat 
   http   dimacs rutgers edu challenges 

   

fidynamic local search max clique problem

addition randomly generated graphs graphs maximum clique
hidden incorporating low degree vertices  problem instances range size
less    vertices       edges greater       vertices           edges 
experiments study performed dedicated     ghz pentium iv machine    kb l  cache    mb ram  running redhat linux         using
g   c   compiler  o  option  execute dimacs machine benchmark   
machine required      cpu seconds r            cpu seconds r           
cpu seconds r       following  unless explicitly stated otherwise  cpu times
refer reference machine 
following sections  first present results series experiments
aimed providing detailed assessment performance dls mc  then  report
additional experimental results facilitate direct comparison dls mc
state of the art max clique algorithms 
    dls mc performance
evaluate performance dls mc dimacs benchmark instances  performed     independent runs instance  using target clique sizes  tcs  corresponding respective provably optimal clique sizes or  cases provably
optimal solutions unknown  largest known clique sizes  order assess peak
performance dls mc  conducted experiment multiple values
penalty delay parameter  pd  report best performance obtained  behaviour
dls mc suboptimal pd values method used identify optimal pd value
discussed section      remaining parameter dls mc  maxsteps 
set              order maximise probability reaching target clique size
every run 
results experiments displayed table    benchmark
instance show dls mc performance results  averaged     independent runs 
complete set    dimacs benchmark instances  note dls mc finds optimal
 or best known  solutions success rate          runs per instance   
   instances  cases target clique size reached consistently
within alotted maximum number search steps  maxsteps  are 
c               runs successful giving maximum clique size  average
clique size  minimum clique size                 
mann a           runs obtained cliques size       remaining
runs produced cliques size      
mann a    runs achieved maximum clique size     
three cases  reported cpu time statistics successful runs
shown parentheses table    furthermore  expected time required dls mc
reach target clique size less   cpu second       instances 

   dmclique  ftp   dimacs rutgers edu directory  pub dsj clique

   

fipullan   hoos

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
dsjc      
dsjc     
hamming    
hamming    
hamming   
hamming   
hamming   
hamming   
johnson      
johnson      
johnson     
johnson     
mann a  
mann a  
mann a  
mann a 
san    
san         
san         
san         
san         
san         
san         
san         
san         
san         
san         
sanr       

br
  
   
  
   
  
   
  
   
  
  
  
  
   
   
   
  
  
 
   
   
 
  
 
  
    
    
    
  
  
  
  
  
  
  
  
  
  
  
   
  

pd
 
 
 
 
  
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 

cpu s 
      
      
      
      
      
      
      
      
       
       
       
      
     
      
      
      
 
 
      
 
 
 
 
 
      
         
          
 
      
      
      
      
      
      
      
      
      
      
      
     

steps
     
     
     
     
      
      
     
     
        
       
       
       
     
    
    
    
  
 
   
  
 
  
 
  
     
          
          
  
      
    
     
   
   
    
     
     
     
      
    
    

sols 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
 
   
 
  
   
  
   
   
  
  
   
     
    
  
 
 
 
 
 
 
 
 
 
 
 
  

instance
sanr       
sanr       
sanr       
c      
c     
c      
c      
c     
c      
c     
c fat     
c fat     
c fat     
c fat     
c fat      
c fat     
c fat     
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
keller 
keller 
keller 
p hat      
p hat      
p hat      
p hat      
p hat      
p hat      
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     

br
  
  
  
  
   
  
  
   
  
  
  
  
  
  
   
  
  
   
   
  
  
  
   
  
  
  
  
  
   
  
  
  
   
   
 
  
  
   
   
  

pd
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

cpu s 
      
      
     
    
      
      
         
      
        
      
      
     
      
      
      
      
     
     
      
      
     
      
 
      
        
      
      
      
      
      
      
      
      
      
     
      
      
      
     
      

steps
     
    
    
       
   
     
          
   
       
     
  
   
   
  
   
  
   
    
   
     
   
   
  
    
        
   
   
    
      
   
    
   
  
   
   
   
    
    
   
   

sols 
  
 
  
  
  
  
    
  
  
 
  
 
 
  
 
  
 
 
 
 
 
 
  
   
   
  
  
  
 
  
  
  
  
  
  
  
  
 
  
  

table    dls mc performance results  averaged     independent runs  complete set dimacs benchmark instances  maximum known clique size
instance shown br column  marked asterisk proven
optimal   pd optimised dls mc penalty delay instance  cpu s 
run time cpu seconds  averaged successful runs  instance  average cpu times less        seconds shown     steps
number vertices added clique  averaged successful runs 
instance  sols  total number distinct maximum sized cliques found
instance  runs achieved best known cliques size shown
exception of  c               runs successful giving maximum
clique size  average clique size  minimum clique size                 mann a   
       runs obtained      giving                      mann a   
runs achieved maximum clique size     

   

fidynamic local search max clique problem

expected run time    cpu seconds required      remaining
instances  least     vertices  finally  variation coefficients  stddev mean  run time distributions  measured search steps  order overcome
inaccuracies inherent extremely small cpu times  instances      success rate obtained found reach average maximum values           
respectively 
may interesting note time complexity search steps dls mc
generally low  indicative example  brock          vertices         
edges maximum clique size    vertices  dls mc performs  average         
search steps  i e   additions current clique  per cpu second  generally  timecomplexity dls mc steps increases size improving  ni   level  nl  
neighbour sets well as  lesser degree  maximum clique size  relationship
seen table   shows   randomly generated  dimacs c  
brock   instances  performance dls mc terms search steps per cpu
second decreases number vertices  and hence size ni   nl   increases 
instance
c     
c     
c     
c      
c      
brock     
brock     
brock     

vertices
   
   
   
    
    
   
   
   

edges
    
     
      
      
       
     
     
      

br
  
  
  
  
  
  
  
  

dls mc pd
 
 
 
 
 
 
  
  

steps   second
       
      
      
      
      
      
      
      

table    average number dls mc search steps per cpu second  on reference machine      runs dimacs c   brock   instances  br
dls mc pd figures table   shown  factors direct
impact performance dls mc  is  br increases  greater
overhead maintaining sets within dls mc  furthermore  larger pd values
cause higher overhead maintaing penalties  vertices tend
penalised  c   instances randomly generated edge probability
     brock   instances constructed hide maximum
clique considerably lower densities  i e   average number edges per
vertex   scaling average number search steps per cpu second performed dls mc c   instances only  running reference machine 
approximated       n         n number vertices
given graph  this approximation achieves r  value         
detailed analysis dls mcs performance terms implementation independent
measures run time  search steps iteration counts  beyond scope
work  could yield useful insights future 
    comparative results
results reported previous section demonstrate clearly dls mc achieves
excellent performance standard dimacs benchmark instances  however  com   

fipullan   hoos

parative analysis results  compared results found literature
state of the art max clique algorithms  straight forward task
differences in 
computing hardware  date  computing hardware basically documented terms cpu speed allows basic means comparison
 i e   scaling based computer cpu speed which  example  takes account features  memory caching  memory size  hardware architecture 
etc    unfortunately  algorithms  realistic option available
us comparison 
result reporting methodology  empirical results performance
max clique algorithms found literature form statistics
clique size obtained fixed run time  conduct performance comparisons
data  care must taken avoid inconclusive situations algorithm
achieves larger clique sizes another algorithm b  cost higher runtimes  important realise relative performance b vary
substantially run time  may reach higher clique sizes b relatively
short run times  opposite could case longer run times  finally  seemingly
small differences clique size may fact represent major differences performance 
since  as many hard optimisation problems  finding slightly sub optimal cliques
typically substantially easier finding maximal cliques  example  c       
average time needed find clique size     with      success rate       
cpu seconds  whereas reaching maximum clique size     with     success
rate  requires average  over successful runs only          cpu seconds 
termination criteria  max clique algorithms  such dags 
terminate upon reaching given target clique size  instead run given
number search steps fixed amount cpu time  even optimal clique
encountered early search  would obviously highly unfair directly compare published results algorithms dls mc  terminates
soon finds user supplied target clique size 
therefore  confirm dls mc represents significant improvement previous
state of the art max clique algorithms  conducted experiments analyses
designed yield performance results dls mc directly compared
results max clique algorithms  particular  compared dls mc
following max clique algorithms  dags  grosso et al          grasp  resende 
feo    smith         using results contained grosso et al          k opt  katayama
et al          rls  battiti   protasi         gene  marchiori         iter  marchiori 
      qualex ms  busygin         rank performance max clique
algorithms determine dominant algorithm benchmark instances 
used set criteria based  primarily  quality solution then 
deemed equivalent  cpu time requirements algorithms 
criteria shown  order application  table   

   

fidynamic local search max clique problem

   algorithm algorithm find largest known maximum clique instance
ranked dominant algorithm instance 
   one algorithm achieves      success rate instance algorithm lowest
average  scaled  cpu time becomes dominant algorithm instance 
   single algorithm achieves      success rate instance algorithm becomes dominant
algorithm instance 
   algorithm achieves      success rate instance  algorithm achieves largest
size clique  highest average clique size lowest average cpu time becomes
dominant algorithm instance 
   if  instance  algorithm meets four criteria listed above  conclusion
drawn dominant algorithm instance 

table    criteria used ranking max clique algorithms 

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
c      
c      
c      
c     
gen    p      
gen    p      
gen    p      
gen    p      
keller 
mann a  
p hat      
p hat      
san         
san         
sanr       

dls mc
clique size
cpu s 
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
       
  
       
  
       
  
      
  
    
            
       
           
  
      
  
     
  
      
  
     
  
      
           
   
       
  
      
  
      
  
      
  
      
  
      

dags
clique size
scpu s 
  
     
  
     
  
     
           
     
            
     
           
     
           
     
  
     
             
      
           
      
           
     
           
      
            
      
           
       
           
       
            
    
            
     
           
     
           
     
           
     
           
       
                    
            
      
            
      
           
     
           
    
            
     

grasp
clique size
scpu s 
  
     
  
     
  
     
  
     
  
      
  
      
           
      
  
      
  
  
  
     
            
      
  
      
           
       
           
       
            
       
  
      
            
      
            
      
           
     
           
     
                    
              
       
  
       
  
      
            
     
           
     
  
      

table    performance comparison dls mc  dags grasp selected dimacs
instances  scpu columns contain scaled dags grasp average
run times cpu seconds  dags grasp results based    runs per
instance  dls mc results based     runs per instance  cases
best known result found runs  clique size entries format
maximum clique size  average clique size  minimum clique size   dls mc
dominant algorithm instances table 

   

fipullan   hoos

table   contrasts performance results dags grasp literature  grosso
et al         respective performance results dls mc  since dags
grasp runs performed     ghz pentium iv cpu  dls mc ran
    ghz pentium iv reference machine  scaled cpu times factor      
 note based assumption linear scaling run time cpu clock
speed  reality  speedup typically significantly smaller   using ranking criteria 
data shows dls mc dominates dags grasp benchmark
instances listed table    confirm ranking  modified dags terminated
soon given target clique size reached  this termination condition used
dls mc  performed direct comparison dls mc    dimacs instances 
running algorithms reference machine  seen results
experiment  shown table    dls mc dominates dags one instance  the
exception san      
table   shows performance results dls mc compared results k opt  katayama
et al          gene  marchiori         iter  marchiori        rls  battiti   protasi 
      literature  roughly compensate differences cpu speed  scaled
cpu times k opt  gene iter factor       these obtained
    ghz pentium iv  rls  measured     mhz pentium ii cpu 
      using ranking criteria table    rls dominant algorithm instances
keller  mann a    k opt dominant algorithm mann a   dls mc
dominant algorithm  exception c        remainder dimacs
instances listed table    identify dominant algorithm c        experiment performed  running dls mc maxsteps parameter  which controls
maximum allowable run time  reduced point average clique size
dls mc exceeded reported rls  experiment  dls mc reached
optimum clique size           independent runs average minimum
clique size           respectively average run time    cpu sec  taking
account runs   establishes dls mc dominant rls k opt instance
c       
analagous experiments performed directly compare performance dlsmc k opt selected dimacs benchmark instances  results  shown table   
confirm dls mc dominates k opt instances 
finally  table   shows performance results dls mc comparison results
qualex ms literature  busygin         cpu times qualex ms
scaled factor      compensate differences cpu speed      ghz
pentium iv cpu vs     ghz pentium iv reference machine   using ranking
criteria table    qualex ms dominates dls mc instances brock       brock      
brock      brock       dls mc dominates qualex ms remaining   
   dimacs instances 

   

fidynamic local search max clique problem

instance
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
brock     
dsjc      
dsjc     
c      
c     
c      
c      
c     
c      
c     
c fat     
c fat     
c fat     
c fat     
c fat      
c fat     
c fat     
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
hamming    
hamming    
hamming   
hamming   
hamming   
hamming   
johnson      

dls mc
success cpu s 
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
       
   
       
   
       
   
      
   
     
   
      
   
    
   
      
  
       
   
      
   
      
            
   
      
   
      
   
     
   
      
   
      
   
      
   
      
   
     
   
     
   
      
   
      
   
     
   
      
   
      
   
      
   
 
   
 
   
      
   
 
   
 

dags
success cpu s 
  
      
  
      
   
      
  
      
  
      
  
      
  
      
  
     
 
       
  
      
  
       
  
       
  
     
   
      
 
    
   
      
          
   
       
  
      


 
       
   
      
   
      
   
      
   
      
   
      
   
      
   
      
  
      
   
      
 
      
  
      
  
      
   
      
   
      
   
      
   
 
   
      
   
      
   
      

instance
johnson      
johnson     
johnson     
keller 
keller 
keller 
mann a  
mann a  
mann a  
mann a 
p hat      
p hat      
p hat      
p hat      
p hat      
p hat      
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
san    
san         
san         
san         
san         
san         
san         
san         
san         
san         
san         
sanr       
sanr       
sanr       
sanr       

dls mc
success cpu s 
   
 
   
 
   
 
   
 
   
      
            
   
      
   
       
           
   
 
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
   
      
   
      
   
     
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
   
      
   
     

dags
success cpu s 
   
      
   
 
   
      
   
      
   
     


   
      
  
     


   
      
   
      
   
      
  
    
  
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
      
   
     
   
      
  
      
   
      
   
      
   
      
   
      
   
      
   
      
  
      
   
      
   
      
  
      
  
     
   
      

table    success rates average cpu times dls mc dags  based     runs
per instance      dimacs instances  dls mc superior success rate
   instances and  exception san      required less cpu
time dags instances  entries signify runs
terminated excessive cpu time requirements  obtain meaningful
comparison dls mc dags  mann a   mann a       
     respectively used best known results producing table 
dls mc dags  average cpu time successful runs only 
using ranking criteria study  dags dominant algorithm
san     instance  dls mc dominant algorithm instances 

   

fipullan   hoos

dls mc
instance
clique size
brock     
  
brock     
  
brock     
  
brock     
  
brock     
  
brock     
  
c      
  
c     
  
c      
  
c      
           
c     
  
c      
  
c     
  
dsjc      
  
dsjc     
  
gen    p      
  
gen    p      
  
gen    p      
  
gen    p      
  
gen    p      
  
hamming    
  
hamming   
  
keller 
  
keller 
  
keller 
  
mann a  
   
mann a  
   
mann a                     
p hat      
  
p hat      
  
p hat      
  
p hat     
 
p hat     
  
p hat     
  
p hat     
  
p hat     
  
p hat     
  

k opt

rls

cpu s 
clique size
scpu s 
clique size
scpu s 
      
  
       
  
       
      
  
       
  
       
      
           
                     
       
      
  
                              
       
           
       
  
       
      
           
       
  
       
    
  
      
  
      
      
  
       
  
       
      
           
  
       
       
                                            
      
  
       
  
       
        
           
            
      
           
       
  
       
     
  
       
  
       
      
  
       
  
       
     
  
       
  
       
      
  
       
  
       
      
           
       
  
       
     
  
       
  
      
      
  
       
  
       
      
  
       
  
       
 
  
       
  
       
 
  
       
  
       
      
  
       
  
       
        
                     
           
      
   
       
   
       
       
              
                      
       
                          
      
             
      
           
  
       
      
  
       
  
       
      
  
     
  
       
      
 
       
 
       
      
  
       
  
       
      
  
      
  
       
      
  
       
  
       
     
  
       
  
       
      
  
       
  
       

gene
iter
avg 
avg 
clique size clique size
    
    
    
    
    
    
    
    
    
    
    
  
    
    
    
  
    
    
    
    
    
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
  
  
  
  
    
    
    
     
   
     
     
      
    
    
    
    
    
    
  
 
 
  
  
    
    
   
   
    
    
    
    

table    performance dls mc  k opt  rls  gene iter selected dimacs
instances  scpu columns contain scaled average run time cpu seconds
k opt rls  dls mc rls results based     runs per instance 
k opt  gene iter results based    runs per instance  using
ranking criteria study  rls dominant algorithm instances
mann a   keller   dls mc dominant algorithm
instances 

   

fidynamic local search max clique problem

dls mc
instance
clique size cpu s 
brock                         
brock     
         
brock                         
brock                         

k opt
dls mc
k opt
clique size scpu s  instance clique size cpu s  clique size scpu s 
           
      c                          
         
     
  
      c                                      
      
           
      c      
         
  
      
           
     
keller                                         

table    performance dls mc k opt dls mc parameter maxsteps
reduced point clique size results comparable
k opt  cpu s  values dls mc include unsuccessful runs  dls mc
results based     runs k opt results    runs  per instance  
dls mc
qualex ms
dls mc
qualex ms
instance
clique size cpu s  clique size scpu s 
instance
clique size
cpu s  clique size scpu s 
brock     
  
      
  
     johnson      
  
 
  
    
brock     
  
      
  
       johnson     
 
 
 
      
brock     
  
      
  
     johnson     
  
 
  
      
brock     
  
      
  
      
keller 
  
 
  
    
brock     
  
      
  
    
keller 
  
      
  
     
brock     
  
      
  
    
keller 
           
  
      
brock     
  
      
  
    
mann a  
   
      
   
    
brock     
  
      
  
    
mann a  
           
   
     
brock     
          
  
     
mann a                              
    
      
brock     
          
  
     
mann a 
  
 
  
      
brock     
          
  
     
p hat      
  
      
  
     
brock     
  
      
  
     
p hat      
  
      
  
     
c      
  
    
  
     
p hat      
  
      
  
     
c     
  
      
  
      
p hat      
  
      
  
    
c      
  
      
  
      
p hat      
  
      
  
     
c                           
  
     
p hat      
  
      
  
     
c     
  
      
  
    
p hat     
 
      
 
    
c      
           
  
      
p hat     
  
      
  
    
c     
  
      
  
    
p hat     
  
      
  
    
c fat     
  
      
  
      
p hat     
 
     
 
    
c fat     
  
     
  
      
p hat     
  
      
  
    
c fat     
  
      
  
      
p hat     
  
      
  
    
c fat     
  
      
  
    
p hat     
  
      
  
   
c fat      
   
      
   
    
p hat     
  
     
  
    
c fat     
  
      
  
    
p hat     
  
      
  
    
c fat     
  
     
  
    
san    
  
      
  
    
dsjc      
  
     
  
      san         
  
      
  
    
dsjc     
  
      
  
    san         
  
      
  
      
gen    p      
  
     
  
       san         
  
      
  
      
gen    p      
  
      
  
     san         
  
      
  
    
gen    p      
  
      
  
     san         
  
      
  
      
gen    p      
  
     
  
     san         
  
      
  
    
gen    p      
  
      
  
     san         
  
      
  
    
hamming    
   
      
   
      san         
  
      
  
    
hamming    
  
      
  
     san         
  
      
  
    
hamming   
  
 
  
       san         
   
      
   
    
hamming   
 
 
 
      
sanr       
  
     
  
    
hamming   
   
      
   
      
sanr       
  
      
  
      
hamming   
  
 
  
    
sanr       
  
      
  
    
johnson      
 
 
 
      
sanr       
  
     
  
    

table    performance dls mc qualex ms  scpu column contains
scaled run time qualex ms cpu seconds  dls mc results based
    runs per instance  using ranking criteria study  qualex ms
dominant algorithm instances brock       brock       brock     
brock       dls mc dominant algorithm instances 
   

fipullan   hoos

overall  results comparative performance evaluations summarised
follows 
qualex ms dominant brock       brock       brock      brock     
dimacs instances 
rls dominant algorithm mann a   keller  dimacs instances 
dags dominant algorithm san     dimacs instance 
k opt dominant algorithm mann a   dimacs instance 
dls mc dominant algorithm remaining    dimacs instances 
addition  within alotted run time number runs  dls mc obtained current best known results dimacs instances exceptions mann a  
mann a   

   discussion
gain deeper understanding run time behaviour dls mc efficacy
underlying mechanisms  performed additional empirical analyses  specifically 
studied variability run time multiple independent runs dls mc
problem instance  role vertex penalties general and  particular 
impact penalty delay parameter performance behaviour dls mc 
frequency pertubation well role perturbation mechanism 
investigations performed using two dimacs instances  c       brock      
instances selected because  firstly  reasonable size difficulty  secondly  c       randomly generated instance vertices optimal maximum
clique predominantly higher vertex degree average vertex degree  intuitively
would seem reasonable that  randomly generated problem  vertices optimal
maximum clique would tend higher vertex degrees   brock      
hand  vertices optimal maximum clique predominantly lower than average
vertex degree   note dimacs brock instances created attempt defeat
greedy algorithms used vertex degree selecting vertices brockington   culberson 
      
fundamental difference highlighted results quantitative analysis maximum cliques instances  showed that  c        averaged
maximal cliques found dls mc  average vertex degree vertices maximal cliques      standard deviation    compared         averaged
vertices  brock       corresponding figures                   respectively 
    variability run time
variability run time multiple independent runs given problem important aspect behaviour sls algorithms dls mc  following methology hoos stutzle         studied aspect based run time distributions
 rtds  dls mc two reference instances 
   

fidynamic local search max clique problem

seen empirical rtd graphs shown figure    each based
    independent runs reached respective best known clique size   dls mc
shows large variability run time  closer investigation shows rtds quite
well approximated exponential distributions  a kolmogorov smirnov goodness of fit test
failed reject null hypothesis sampled run times stem exponential
distributions shown figure standard confidence level        p values
            observation consistent similar results highperformance sls algorithms  e g   sat  hoos   stutzle        scheduling problems
 watson  whitley    howe         consequence  performing multiple independent
runs dls mc parallel result close to optimal parallelisation speedup  hoos
  stutzle         similar observation made difficult dimacs
instances 
 

 

empirical rld dls mc
ed         

   

   

   

   

   

   

   

p solve 

p solve 

   

   
   

   
   

   

   

   

   

   

   

 
    

     

      

 e    

empirical rtd dls mc
ed      

 
     

 e    

    

run time  search steps 
 

 

empirical rld dls mc
ed         

   

   

   

   

   

   

   

p solve 

p solve 

   

   
   

   
   

   

   
 e    
 e    
run time  search steps 

  

 e    

 e    

empirical rtd dls mc
ed    

   

   

      

 

   

   

 
     

   
run time  cpu sec 

 
    

   

 
  
run time  cpu sec 

   

    

figure    run time distributions dls mc applied c        top  brock     
 bottom   measured search steps  left  cpu seconds  right  reference machine  based     independent runs reached best
known clique size   empirical rtds well approximated exponential
distributions  labelled ed m  x       x m plots 
    penalty delay parameter vertex penalties
penalty delay parameter pd specifies number penalty increase iterations must
occur dls mc penalty decrease  by    vertices currently
   

fipullan   hoos

vertex frequency

penalty  max clique problem  pd basically provides mechanism focusing
lower degree vertices constructing current cliques  pd      i e   penalties  
frequency vertices improving neighbour   level neighbour sets
basically solely dependent degree  increasing pd overcomes bias towards
higher degree vertices  allows penalty values increase  as often
current clique   inhibits selection current clique  turn
allows lower degree vertices become part current clique  effect penalty
delay parameter illustrated figure    shows correlation degree
vertices frequency included current clique immediately prior
perturbation performed within dls mc 

c       pd    
   
   

vertex frequency

 
  

   

  

  

  
  
vertex degree

  

  

  

brock      pd    

   
   
   
 
  

  

  

  
vertex degree

  

  

  

  

  
vertex degree

  

  

  

vertex frequency

    
brock      pd     
   
    
   
    
  

  

figure    correlation vertex degree frequency vertices
present clique immediately prior dls mc perturbation 
c       brock       pd      higher degree vertices tend
higher frequency present clique immediately prior dls mc
perturbation  brock       pd       frequency present
clique immediately prior dls mc perturbation almost independent
vertex degree 
currently  pd needs tuned family  or  case brock instances 
sub family  instances  general  could done principled way based rtd
graphs  dls mc  reasonably robust regard exact value
parameter  as shown figures       actual tuning process simple  almost
interactive process normally require evaluating rtd graphs  still  fine tuning
based rtd data could possibly result further  minor performance improvements 

   

fidynamic local search max clique problem

   

  success rate

  
  
  
  
  
  

 

  

  

  
penalty delay

  

  

  

 

  

  

  
penalty delay

  

  

  

median processor time

   
   
   
   
   
  
 

figure    success rate median cpu time dls mc function penalty delay
parameter  pd  benchmark instance brock       data point based
    independent runs 

cumulative success rate

   
  

pd     
pd     
pd     

  
  
  
 
 
  

 

 

  

 

  
steps

 

  

  

cumulative success rate

   
  

pd     
pd     
pd     

  
  
  
 
 
  

 

  

 

  
processor time  seconds 

 

  

figure    run time distributions dls mc brock      penalty delays       
    measuring run time search steps  top  cpu seconds  bottom  
performance penalty delay    clearly dominates       

   

fipullan   hoos

effect penalty delay parameter vertex penalties clearly illustrated
figure    shows cumulative distributions number penalised vertices
perturbation dls mc  representative runs dls mc dimacs brock     
instance  varying values parameter pd  note brock       optimal
pd value    corresponds point where  average      vertices
penalised  role pd parameter illustrated figure    shows
 sorted  frequency vertices present current clique immediately
prior perturbation c       brock       note instances 
using higher penalty delay settings significanly reduces bias towards including certain
vertices current clique  previously demonstrated  without vertex penalties  i e  
pd       dls mc prefers include high degree vertices current clique 
case problem instances c        optimal cliques tend consist vertices
higher than average degrees  effective strategy  instances brock      
however  optimal clique contains many vertices lower than average degree 
heuristic bias towards high degree vertices misleading needs counteracted  e g  
means vertex penalties 
   
pd    
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     
pd     

  

  

cumulative frequency

  

  

  

  

  

  

  

 

 

   

   

   

   
   
penalised vertices

   

   

   

figure    cumulative distributions number penalised vertices measured
search perturbation representative independent runs dls mc dimacs brock      instance penalty delay parameter pd varied  the left
curve corresponds pd       note approx  optimal penalty
delay pd       solid line   average     vertices penalised  i e  
penalty value greater zero  
generally  reducing bias cliques visited  vertex penalties help diversify
search dls mc  time  penalties appear provide learning
mechanism dls mc identifies vertices included
   

fidynamic local search max clique problem

c      
  frequency vertex clique

   
pd    
pd     

   
   
   
   
 

 

   

   

   

   

   
vertex

   

   

   

   

    

brock     
  frequency vertex clique

   
pd    
pd     
   

   

   

 

 

   

   

   

   
vertex

   

   

   

   

figure    sorted frequency vertices present current clique immediately prior dls mc perturbation c        top  brock     
 bottom   based representative run problem instance  note
using penalty delay values pd      bias towards using certain vertices
frequently others substantially reduced 
current clique  agreement recent results saps  high performance
dynamic local search algorithm sat  hoos   stutzle        
    perturbation mechanism search mobility
prevent search stagnation  dls mc uses perturbation mechanism executed
whenever plateau search procedure failed lead clique
expanded  since mechanism causes major changes current clique  relatively
high time complexity  therefore interesting investigate frequently rather
costly disruptive perturbation steps performed  figure   shows distribution
number improving search steps  i e   clique expansions  plateau steps  i e   vertex
swaps  successive perturbation phases representative run dls mc
c       instance  analogous results brock      shown figure     figures
basically show result interactions improving plateau search steps 
perturbation mechanism problem structure 

   

fipullan   hoos

c      

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

  

  

  

  

  
  
improving steps

  

  

  

   

  

  

  

  
  
plateau swaps

  

  

  

   

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

  

figure    number improving search steps plateau swaps successive perturbation phases dls mc c        graphs show cumulative distributions measures collected representative independent runs
pd value  solid lines correspond approx  optimal penalty delay
instance  pd     
brock     

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

 

  

  

  
improving steps

  

  

  

  

  

  

  
plateau swaps

  

  

  

  

cumulative frequency

   
pd    
pd    
pd     

  
  
  
  
 

 

 

figure     number improving search steps plateau swaps successive perturbation phases dls mc brock       graphs show cumulative
distributions measures collected representative independent runs
pd value  solid lines correspond approx  optimal penalty delay
instance  pd      
   

fidynamic local search max clique problem

seen data  compared higher penalty delay values  pd    
results significantly shorter plateau phases somewhat longer improvement phases 
time  differences behaviour dls mc observed various penalty
delay values greater one relatively small  one explanation phenomenon lies
fact pd      effectively vertex penalties used  consequently 
selection improving level neighbours sets search step less constrained 
intuitively  make easier find exits plateaus underlying search
landscape follow gradients larger number search steps 

whether renders search efficient clearly depends topology
given search landscape  instance c       least    optimal solutions  see table    
construction  optimal cliques higher than average vertex degree  suggests
respective search landscape relatively high fitness distance correlation 
would explain problem instance relatively easy solve using
less radical perturbation mechanism associated pd      which adds randomly chosen
vertex v current clique removes vertices connected v  provides sufficient
diversification search process  instance brock       hand  appears
single optimal solution many near optimal solutions  i e   large nonoptimal cliques cannot extended   since construction  optimal clique
lower than average vertex degree  suggests respective search landscape
relatively low fitness distance correlation  therefore  radical perturbation
mechanism used pd      which restarts clique construction recently
added vertex uses vertex penalties diversification  required order obtain
good performance  hypothesis agreement relatively high cost
solving problem instance 

investigate efficacy perturbation dls mc diversification mechanism  measured relative mobility search  defined hamming distance
current cliques  i e   number different vertices  consecutive perturbations
divided two times maximum clique size  representative runs dls mc instances c       brock       this mobility measure closely related used
previous studies  schuurmans   southey          seen figure    
large difference mobility two variants perturbation mechanism
pd     pd      former restarts search randomly chosen vertex
consequently leads large variability hamming distance previous clique 
latter restarts recently added vertex  using vertex penalties
increase search diversification  hence shows consistently much higher mobility  note
vertex penalties used  i e   pd       pd value significant effect
search mobility  time  previously observed  see figure     performance
dls mc significantly depend penalty update delay pd  demonstrates
order achieve peak performance  increased mobility afforded use
vertex penalties needs combined correct amount additional diversification
achieved using specific penalty update delay 
   

fipullan   hoos

c      

cumulative frequency

   
delay  
delay  
delay   

  
  
  
  
 

 

    

   

    

   

    
   
relative mobility

    

   

    

   

    

   

    

   

brock     

cumulative frequency

   
delay  
delay  
delay   

  
  
  
  
 

 

    

   

    

   

    
   
relative mobility

figure     mobility search consecutive perturbation phases dls mc instances c        top  brock       bottom   mobility measured terms
relative hamming distance  i e   number different vertices respective cliques divided two times maximum clique size  graphs
show cumulative distributions relative mobility measurements collected
representative independent runs pd value problem instance 
solid lines correspond respective approx  optimal pd values 

   conclusions future work
demonstrated applying general paradigm dynamic local search
maximum clique problem  state art max clique solving improved 
new algorithm  dls mc  similarity previous max clique algorithms 
particular recently introduced dags algorithm  algorithms use vertex penalties
guide heuristic selection vertices searching maximum cliques  however 
unlike dags  initial phase unweighted greedy construction search  dls mc
uses updates vertex penalties throughout entire search process  furthermore 
weight updates dags monotone while  dls mc  vertex penalties subject
increases well occasional decreases  effectively allows algorithm
forget vertex penalties time  furthermore  dls mc selects vertex added
current clique step solely based penalty  vertex selection
dags based total weight neighbouring vertices hence implicitely uses
vertex degree heuristic guidance  fact dls mc  although conceptually slightly
simpler  outperforms dags one standard dimacs benchmark instances
combination excellent performance compared high performance max   

fidynamic local search max clique problem

clique algorithms clearly demonstrates value underlying paradigm dynamic
local search non monotone penalty dynamics 
work presented article extended several directions  particular 
would interesting investigate extent use multiplicative penalty update
mechanisms dls mc instead current additive mechanism lead performance improvements  believe current implementation dls mc
optimised  example  selection vertex added current
clique  implementation dls mc performs complete scan either improving
plateaus sets build list vertices lowest penalties  would probably
efficient maintain list means incremental update scheme  another
interesting direction future research develop mechanisms automatically
adjusting dls mcs penalty delay parameter search  similar scheme used
dynamically adapting tabu tenure parameter rls  battiti   protasi       
reactive tabu search  battiti   tecchiolli         mechanism used controlling
noise parameter adaptive novelty   hoos         finally  given excellent performance dls mc standard max clique instances reported suggests
underlying dynamic local search method substantial potential provide basis
high performance algorithms combinatorial optimisation problems  particularly
weighted versions max clique conceptually related clustering problems 

acknowledgments
authors would thank liang zhao participation performing
initial experiments paper 

references
balus  e     yu  c          finding maximum clique arbitary graph  siam journal
computing                   
battiti  r     protasi  m          reactive local search maximum clique problem 
algorithmica             
battiti  r     tecchiolli  g          reactive tabu search  orsa journal computing 
              
bomze  i   budinich  m   pardalos  p     pelillo  m          maximum clique problem 
d z  du  p  p   ed    handbook combinatorial optimization  vol  a  pp      
boppana  r     halldorsson  m          approximating maximum independent sets
excluding subgraphs  bit             
brockington  m     culberson  j          camouflaging independent sets quasi random
graphs  d s  johnson  m  t   ed    cliques  coloring satisfiability  second
dimacs implementation challenge  vol     dimacs series  american mathematical society 
   

fipullan   hoos

busygin  s          new trust region technique maximum clique problem  internal
report  http   www busygin dp ua 
garey  m  r     johnson  d  s          computers intractability  guide theory
n p completeness  freeman  san francisco  ca  usa 
grosso  a   locatelli  m     croce  f  d          combining swaps node weights
adaptive greedy approach maximum clique problem  journal heuristics 
           
hastad  j          clique hard approximate within n    acta mathematica      
       
hoos  h  h          adaptive noise mechanism walksat  proceedings
eighteenth national conference artificial intelligence  pp          aaai press  
mit press  menlo park  ca  usa 
hoos  h  h     stutzle  t          stochastic local search  foundations applications 
morgan kaufmann publishers  usa 
hoos  h     stutzle  t          local search algorithms sat  empirical evaluation 
gent  i   v maaren  h     walsh  t   eds    sat       pp        ios press 
hutter  f   tompkins  d  a  d     hoos  h  h          scaling probabilistic smoothing  efficient dynamic local search sat  hentenryck  p  v   ed    principles
practice constraint programming cp       vol       lecture notes
computer science  pp          springer verlag  berlin  germany 
ji  y   xu  x     stormo  g  d          graph theoretical approach predicting common rna secondary structure motifs including pseudoknots unaligned sequences 
bioinformatics                    
johnson  d     trick  m   eds            cliques  coloring satisfiability  second dimacs implementation challenge  vol     dimacs series  american mathematical
society 
katayama  k   hamamoto  a     narihisa  h          solving maximum clique problem k opt local search  proceedings      acm symposium applied
computing  pp           
marchiori  e          genetic  iterated multistart local search maximum clique
problem  applications evolutionary computing  vol       lecture notes
computer science  pp          springer verlag  berlin  germany 
pevzner  p  a     sze  s  h          combinatorial approaches finding subtle signals
dna sequences  proceedings eighth international conference intelligent
systems molecular biology  pp          aaai press 
pullan  w     zhao  l          resolvent clause weighting local search  tawfik  a  y  
  goodwin  s  d   eds    advances artificial intelligence    th conference
canadian society computational studies intelligence  vol       lecture notes
computer science  pp          springer verlag  berlin  germany 
   

fidynamic local search max clique problem

resende  m   feo  t     smith  s          algorithm      fortran subroutine approximate solution maximum independent set problem using grasp  acm
transactions mathematical software             
schuurmans  d     southey  f          local search characteristics incomplete sat
procedures  proceedings seventeenth national conference artificial intelligence  pp          aaai press   mit press  menlo park  ca  usa 
solnon  c     fenet  s          study aco capabilities solving maximum clique
problem  journal heuristics  appear 
thornton  j   pham  d  n   bain  s     ferreira  v          additive versus multiplicative
clause weighting sat  proceedings   th national conference artificial
intelligence  aaai      pp          aaai press   mit press  menlo park  ca 
usa 
tompkins  d     hoos  h          scaling probabilistic smoothing  dynamic local
search unweighted max sat  xiang  y     chaib draa  b   eds    advances
artificial intelligence    th conference canadian society computational
studies intelligence  vol       lecture notes computer science  pp         
springer verlag  berlin  germany 
watson  j   whitley  l     howe  a          linking search space structure  run time
dynamics  problem difficulty  step toward demystifying tabu search  journal
artificial intelligence             

   


