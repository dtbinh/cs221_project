journal artificial intelligence research                 

submitted       published      

learning first order definitions functions
j  r  quinlan

quinlan cs su oz au

basser department computer science
university sydney
sydney      australia

abstract

first order learning involves finding clause form definition relation examples
relation relevant background information  paper  particular first order
learning system modified customize finding definitions functional relations 
restriction leads faster learning times and  cases  definitions
higher predictive accuracy  first order learning systems might benefit similar
specialization 

   introduction
empirical learning subfield ai develops algorithms constructing theories
data  classification research area used attribute value formalism 
data represented vectors values fixed set attributes labelled
one small number discrete classes  learning system develops mapping
attribute values classes used classify unseen data 
despite well documented successes algorithms developed paradigm  e g  
michie  spiegelhalter  taylor        langley simon         potential
applications learning fit within it  data may concern objects observations
arbitrarily complex structure cannot captured values predetermined
set attributes  similarly  propositional theory language employed attribute value
learners may inadequate express patterns structured data  instead  may
necessary describe learning input relations  relation set tuples
constants  represent learned first order language  four examples
practical learning tasks kind are 

speeding logic programs  zelle mooney         idea learn

guard nondeterministic clause inhibits execution unless lead
solution  input learner consists prolog program one
execution traces  one example dolphin  system cited above  transformed
program complexity o n   o n    

learning search control heuristics  leckie zukerman         formulation pref 

erence criteria improve eciency planning applications similar avor 
one task investigated familiar  blocks world  varying numbers
blocks must rearranged robot manipulator  input learning concerns
particular situation search includes complete description current planning state goals  amount information increases

c      ai access foundation morgan kaufmann publishers  rights reserved 

fiquinlan

number blocks inter relationships  cannot encoded fixed set
values 
recovering software specifications  cohen        describes application based
software system consisting million lines c code  part system implements virtual relations compute projections joins underlying base
relations  goal reconstruct definitions  input learning consists
queries  responses  traces showing base relations accessed answering queries  output logical description virtual relation  since
involves quantified variables  lies beyond scope propositional attribute value
languages 
learning properties organic molecules  muggleton  king  sternberg       
srinivasan  muggleton  sternberg  king         approach learning
papers based representing structure molecules
addition properties molecules molecule segments  latter paper notes
discovery useful indicator mutagenicity expressed terms structure 
development learning methods based powerful relational formalism
sometimes called inductive logic programming  muggleton        lavrac dzeroski 
      de raedt         input typically consists tuples belong  belong 
target relation  together relevant information expressed set background
relations  learning task formulate definition target relation terms
background relations 
relational learning task described detail following section  several
algorithms relational learning developed recently  section   introduces
one system called foil  quinlan         foil used relations
kind  one particularly common use relations represent functions  changes
foil effect customize learning functional relations outlined section   
several comparative studies  presented section    show specialization leads
much shorter learning times and  cases  accurate definitions  related work
learning functional relations discussed section    paper ends
conclusions study directions development 

   relational learning

n ary relation consists set n tuples ground terms  here constants  
constants ith position tuples belong type  types may differentiated constants may taken belong single universal type 
alternative extensional definition  possibly infinite  set  relation
specified intensionally via n argument predicate ri defined prolog program 

hc    c       cn   ri  c    c         cn   true
constants fci g  intensional extensional definitions equivalent 
convenience  subscripts ri omitted r used denote
either set tuples predicate 
   

filearning first order definitions functions

input relational learning task consists extensional information target
relation r extensional intensional definitions collection background relations 
examples tuples known belong target relation provided and  cases 
examples tuples known belong r  goal learn prolog program
r covers tuples known belong r tuples known belong r
or  words  program agrees extensional information provided
r 
many relations interest infinite  alternative selecting examples belong
belong r define finite vocabulary v specify relations respect
vocabulary  is  r represented finite set tuples  constants
belong v   since specification r complete vocabulary  tuples
belong r inferred closed world assumption complement
tuples r 
function f  x    x         xk   k arguments represented k   ary relation
f  x    x         xk   xk     where  tuple f   value last argument
result applying f first k arguments   rouveirol        proves attening
used remove non constant function symbols first order language  
functional relations additional property constants fc    c        ck g
exactly one value ck   hc    c         ck   belongs f  
example  consider three argument predicate append a b c  whose meaning
result appending list list b list c   corresponding relation append
infinite  restricted vocabulary defined lists containing elements
f     g whose length less equal       lists
                                                 

         tuples lists  respect vocabulary  append consists    
  tuples  viz  

h           i  h           i       h                 i       h                   i 
background relation components  components a b c  means list
head b tail c  goal learn intensional definition append given
background relation components  suitable result might expressed
append     a a  
append a b c     components a d e   append e b f   components c d f  

recognizable prolog definition append 
   prolog  append invoked combination arguments bound find possible
values unbound arguments  section      however  append treated function
first two arguments third 

   

fiquinlan

initialization 
definition    null program
remaining    tuples belonging target relation r
remaining empty
   grow new clause   
clause    r a  b        while clause covers tuples known belong r
   specialize clause   
find appropriate literal s  l
add l body clause
remove remaining tuples r covered clause
add clause definition
figure    outline foil

   description foil

common many first order learning systems  foil requires background relations defined extensionally sets tuples constants   although intensional
definition learned particular set examples  intended executable
prolog program background relations may specified intensionally
definitions rather sets ground tuples  instance  although append definition
might learned particular examples lists  correctly append
arbitrary lists  provided components specified suitable clausal definition   the
applicability learned definitions unseen examples cannot guaranteed  however  bell
weber        call open domain assumption  
language foil expresses theories restricted form prolog omits
cuts  fail  disjunctive goals  functions constants  allows negated literals
not l        essentially datalog language specified ullman         except
requirement variables negated literal appear head
another unnegated literal  foil interprets using negation failure  bratko        

    broad brush overview
outlined figure    foil uses separate and conquer method  iteratively learning
clause removing tuples target relation r covered clause none
remain  clause grown repeated specialization  starting general clause
   prominent exceptions include focl  pazzani kibler         filp  bergadano gunetti        
foidl  mooney califf         allow background relations defined extensionally 
progol  muggleton         information relations non ground form 

   

filearning first order definitions functions

head adding literals body clause cover tuples known
belong r 
literals appear body clause restricted requirement
programs function free  constants appearing equalities  possible
literal forms foil considers are 

q x    x         xk    q x    x         xk     q relation xi s de 

note known variables bound earlier clause new variables 
least one variable must bound earlier partial clause  either
head literal body 

xi  xj xi   xj   known variables xi xj type 
xi  c xi  c  xi known variable c constant appropriate

type  constants designated suitable appear definition
considered   reasonable definition append might reference null list    
arbitrary list       

xi xj   xi   xj   xi t  xi   t  xi xj known variables
numeric values threshold chosen foil 

learned definition must pure prolog  negated literal forms  q       xi      
excluded option 
clause construction guided different possible bindings variables partial
clause satisfy clause body  clause contains k variables  binding k tuple
constants specifies value variables sequence  possible binding
labelled according whether tuple values variables clause head
belong target relation 
illustration  consider tiny task constructing definition plus a b c  
meaning a b   c  using background relation dec a b   denoting b   a   
vocabulary restricted integers          plus consists tuples

h     i  h     i  h     i  h     i  h     i  h     i
dec contains h   i h   i 
initial clause consists head
plus a b c    

variable unique  labelled bindings corresponding initial partial
clause tuples belong  belong  target relation  i e  

h     i
h     i
h     i
h     i
h     i

h     i
h     i
h     i
h     i
h     i

h     i
h     i
h     i
h     i
h     i

h     i
h     i
h     i
h     i

   

h     i
h     i
h     i
h     i

h     i
h     i
h     i
h     i

 

fiquinlan

foil repeatedly tries construct clause covers tuples target relation

r tuples definitely r  restated finding clause

bindings bindings  one reason adding literal clause
move direction increasing relative proportion bindings  gainful
literals evaluated using information based heuristic  let number
bindings partial clause n n respectively  average information provided
discovery one bindings label
 
n


 n   n       log  n   n bits 
literal l added  bindings may excluded rest give
rise one bindings new partial clause  suppose k n bindings
excluded l  numbers bindings new partial clause
respectively  l chosen increase proportion bindings  total
information gained adding l

k  i  n  n      m      bits 
consider result specializing clause addition literal a   
nine bindings eliminated corresponding values variables
satisfy new partial clause  bindings reduced

h     i h     i h     i
h     i h     i h     i h     i h     i h     i
proportion bindings increased           information
gained adding literal therefore    i                     bits  adding
literal b c excludes bindings  giving complete first clause
plus a b c     a    b c 

or  would commonly written 
plus   b b  

clause covers three tuples plus removed set tuples
covered subsequent clauses  commencement search second clause 
head plus a b c  bindings

h     i
h     i
h     i
h     i
h     i

h     i
h     i
h     i
h     i
h     i

h     i
h     i h     i h     i h     i
h     i h     i h     i h     i
h     i h     i h     i h     i
h     i
 

literals added body first clause gain information  quite different justification adding literal introduce new variables
may needed final clause  determinate literals based idea introduced
   

filearning first order definitions functions

golem  muggleton feng         determinate literal one introduces new
variables new partial clause exactly one binding binding
current clause  one binding binding  determinate literals useful introduce new variables  neither reduce potential coverage
clause increase number bindings 
bindings include a    literal dec a d  determinate
because  value a  one value satisfies literal  similarly  since
bindings contain none c    literal dec c e  determinate 
figure    literals l added foil step

literal greatest gain  gain near maximum possible
 namely n  n   n      otherwise
determinate literals found  otherwise
literal highest positive gain  otherwise
first literal investigated introduces new variable 
start second clause  literal near maximum gain determinate
literals added clause body  partial clause
plus a b c     dec a d   dec c e  

five variables bindings satisfy

h         i h         i h         i
h         i h         i h         i h         i h         i
literal plus b d e   uses newly introduced variables  satisfied
three bindings none bindings  giving complete second clause
plus a b c     dec a d   dec c e   plus b d e  

tuples plus covered one clauses  constitute complete
intensional definition target relation 

    details omitted
foil good deal complex overview would suggest  since

important paper  matters following discussed here 
covered  quinlan cameron jones              

recursive soundness  goal able execute learned definitions

ordinary prolog programs  important terminate  foil elaborate
mechanism ensure recursive literal  such plus b d e  above 
added clause body cause problems respect  least ground
queries 
   

fiquinlan

pruning  practical applications numerous background relations  number

possible literals l could added step grows exponentially
number variables partial clause  foil employs heuristics limit
space  golem s bound depth variable  muggleton feng 
       importantly  regions literal space pruned without
examination shown contain neither determinate literals 
literals higher gain best gainful literal found far 
complete search  presented above  foil straightforward greedy hillclimbing algorithm  fact  foil sometimes reach impasse
search clause  contains limited non chronological backtracking facility
allow recover situations 
simplifying definitions  addition partial clause determinate literals
found may seem excessive  however  clause completed  foil examines
literal clause body see whether could discarded without causing
simpler clause match tuples target relation r  similarly 
definition complete  clause checked see whether could omitted
without leaving tuples r uncovered  heuristics aim
make clauses understandable substituting simpler literals  such variable
equalities  literals based complex relations 
recognizing boundaries closed worlds  literals appear discriminate
bindings consequence boundary effects attributable
limited vocabulary   definition including literals executed larger
vocabularies  open domain assumption mentioned may violated  foil
contains optional mechanism describing literals might satisfied
bindings outside closed world  allowing literals unpredictable behavior
excluded 
quinlan        quinlan cameron jones        summarize several applications
successfully addressed foil  discussed section   

   learning functional relations
learning approach used foil makes assumptions form target

relation r  however  append plus above  relation often used represent
function   tuple constants satisfies r  last constant uniquely determined
others  bergadano gunetti        show property exploited
make learning task tractable 

    functional relations foil
although foil learn definitions functional relations  handicapped two ways 
ground queries  foil s approach recursive soundness assumes ground
queries made learned definition  is  definition r x    x         xn  

   example arises section     

   

filearning first order definitions functions

used provide true false answers queries form r c    c         cn   
ci  s constants  r functional relation  however  sensible query
would seem r c    c         cn     x    determine value function
specified ground arguments  case plus  instance  would expect ask plus           is           rather plus     x     what        
r c    c         cn     x    called standard query functional relations 
negative examples  foil needs tuples belong target relation
least not  common ilp systems golem  muggleton
feng         latter used detect partial clause still general 
specified foil directly or  commonly  derived
closed world assumption that  respect vocabulary  tuples r
given  second mechanism often lead large collections tuples
r  nearly        append illustration earlier  every
tuple belonging r results binding start clause 
uncomfortably many bindings must maintained tested stage
clause development   however  functional relations need explicit counterexamples  even set tuples belonging r complete respect
vocabulary   knowing hc    c         cn belongs r implies
constant c n hc    c         c n r 
problematic aspects foil vis vis functional relations suggest modifications
address them  alterations lead new system  ffoil  still close spirit
progenitor 

    description ffoil

since last argument functional relation special role  referred
output argument relation  similarly  variable corresponding argument
head clause called output variable 
fundamental change ffoil concerns bindings partial clauses
way labelled  new constant   introduced indicate undetermined
value output variable binding  bindings labelled according value
output variable  namely value correct  given value earlier
constants   value incorrect  value undetermined 
outline ffoil  figure    similar figure    differences
highlighted  start clause one binding every remaining tuple
target relation  output variable value   bindings value
changed subsequent literal assigns value variable  small
plus example section      initial bindings first clause
h     i h     i h     i h     i h     i h     i
ancestor  ffoil assesses potential literals adding clause body
gainful determinate  although concepts must adjusted accommodate new
label fi  suppose r distinct constants range target function 
   reason  foil includes option sample bindings instead using them 

   

fiquinlan

initialization 
definition    null program
remaining    tuples belonging target relation r
remaining empty
   grow new clause   
clause    r a  b        while clause bindings
   specialize clause   
find appropriate literal s  l
add l body clause
remove remaining tuples r covered clause
add clause definition
simplify final definition
add default clause
figure    outline ffoil

binding converted binding changing   correct value
function  binding changing   r     incorrect values 
computing information gain  ffoil thus counts binding   binding r    
bindings  determinate literal one introduces one variables that 
new partial clause  exactly one binding current binding
one binding current binding  ffoil uses preference criterion
adding literals l  literal near maximum gain  determinate literals 
gainful literal  finally non determinate literal introduces new variable 
first literal chosen foil section     a   since increases concentration bindings           with corresponding information gain  
ffoil s perspective  however  literal simply reduces six bindings three gives
gain  range plus set f     g  r      putative concentration
bindings would alter           literal a c  hand  causes
value output variable determined results bindings

h     i h     i h     i
h     i h     i h     i  
corresponds increase concentration bindings notional     

     information gain   bits  literal added
clause body  ffoil finds literal b   eliminates bindings  giving
   

filearning first order definitions functions

complete clause
plus a b c     a c  b   

remaining tuples plus give bindings

h     i h     i h     i
start second clause  literals dec b d  dec e a  determinate
and  added clause  bindings become

h         i h         i h         i
output variable still undetermined  partial clause specialized
adding literal plus e d c   new bindings

h         i h         i h         i
give correct value c case  since bindings  clause

complete 
one important consequence new way bindings initialized start
clause easily overlooked  foil  one binding tuple
belong r  since clause excludes bindings  discriminates tuples
r tuples r  reason learned clauses regarded
set executed order without changing set answers query 
ffoil  however  initial bindings concern remaining tuples r  learned
clause depends context established earlier clauses  example  suppose target
relation background relation defined
  fhv  i  hw  i  hx  i  hy  i  hz  ig
  fhvi  hwi  hxig  

first clause learned ffoil might
s a       t a  

remaining bindings fhy  i  hz  ig could covered clause
s a    

latter clause clearly correct standard queries covered
first clause  example illustrates  learned clauses must interpreted order
learned  clause must ended cut     protect later
clauses giving possibly incorrect answers query  since target relation r
functional  one correct response standard query defined above 
use cuts safe cannot rule correct answer 
foil ffoil tend give easily learning definitions explain noisy
data  result over specialized clauses cover target relation partially 
tasks definition learned ffoil incomplete  final global simplification
   

fiquinlan

phase invoked  clauses definition generalized removing literals long
total number errors target relation increase  way  accuracy
individual clauses balanced accuracy definition whole  simplifying
clause removing literal may increase number errors made clause 
offset reduction number uncovered bindings consequently
lower global error rate  clauses simplified much possible  entire
clauses contribute nothing accuracy definition removed 
final step figure    target relation assumed represent total function 
consequence response must always returned standard query 
safeguard  ffoil adds default clause

r x    x         xn     c  
c common value function   common value output
argument plus    complete definition example  normal prolog notation 
becomes
plus a   a       
plus a b c     dec b d   dec e a   plus e d c     
plus a b    

    advantages disadvantages ffoil

although definitions plus sections         superficially similar 
considerable differences learning processes constructed
operational characteristics used 

ffoil generally needs maintain fewer bindings learns quickly  whereas

foil keeps    bindings learning definition plus  ffoil never uses
  

output variable guaranteed bound every clause learned ffoil 
necessarily case foil  since requirement every variable
appearing head must appear clause body 

definitions found ffoil often execute eciently foil counterparts 

firstly  ffoil definitions  use cuts  exploit fact cannot
one correct answer standard query  secondly  clause bodies constructed
ffoil tend use output variable bound  less
backtracking evaluation  illustration  foil definition section
    evaluates    goals answering query plus     x    many six
evaluations needed ffoil definition query 

entries side ledger 
   default clause added value function occurs once 

   

filearning first order definitions functions

task

bkgd
relns

append
last element
reverse
left shift
translate

 
 
  
  
  

length  
bindings
time





foil ffoil

          
   
  
  
   
       
   
       
   
             

length  
bindings
time





foil ffoil

                     
       
    
   
                     
                    
                     

    
   
   
   
    

table    results tasks  bratko        

foil applicable learning tasks ffoil  limited learning
definitions functional relations 

implementation ffoil complex foil  example  many

heuristics pruning literal search space checking recursive soundness
require special cases constant   bindings 

   empirical trials

section performance ffoil variety learning tasks summarized
compared foil  release       since systems similar respects 
comparison highlights consequences restricting target relation function 
times dec axp          workstation  learned definitions first
three subsections may found appendix 

    small list manipulation programs

quinlan cameron jones        report results applying foil    tasks taken
bratko s        well known prolog text  list processing examples exercises
chapter   attempted sequence  background information task
includes previously encountered relations  even though irrelevant
task hand   two different vocabularies used     lists length  
three elements     lists length   four elements 
table   describes five functional relations set presents performance
foil ffoil them  learned definitions correct arbitrary lists 
one exception   foil s definition reverse learned larger vocabulary includes
clause
reverse a a     append a a c   del d e c  

exploits bounded length lists   times reveal considerable advantage
   c twice length e one element longer c still length   
length must      case reverse 

   

fiquinlan

task
foil ffoil
quicksort
   
   
bubblesort    
   
table    times  sec  learning sort 

     
   
   
golem    
progol     

ffoil
foil

time  secs 
ratio      
           
                 
     
   
   
        
   
    
   
    
              
     
    
    
                   
                                      

table    comparative times quicksort task 

ffoil tasks except second  fact  first last task larger
vocabulary  times understate ffoil s advantage  total number bindings
append           million  foil option used sample   
bindings prevent foil exceeding available memory  possible run foil

bindings  time required learn definition would considerably
longer  similarly  foil exhausted available memory translation task        
possible bindings used  results obtained using sample    
bindings 

    learning quicksort bubblesort
tasks concern learning sort lists examples sorted lists  first 
target relation qsort a b  means b sorted form a  three background
relations provided  components append before  partition a b c d   meaning
partitioning list b value gives list c elements less list
elements greater a  second task  background relations learning
bsort a b  components lt a b   meaning a b  vocabulary used tasks
lists length   non repeated elements drawn f       g 
thus         bindings task 
foil ffoil learn  standard  definition quicksort  times shown table
  comparable  mainly ffoil learns super uous over specialized clause
later discarded favor general recursive clause  outcome bubblesort
quite different   ffoil learns twenty times faster foil definition
verbose 
quicksort task provides opportunity compare ffoil two wellknown relational learning systems  ffoil foil  golem  muggleton
   

filearning first order definitions functions

task
foil ffoil
ackermann s function
    
   
greatest common divisor      
   
table    times  sec  arithmetic functions 

feng        progol  release       muggleton        implemented c 
timing comparisons meaningful  furthermore  systems include quicksort among
demonstration learning tasks  reasonable assume parameters
control systems set appropriate values 
four learning systems evaluated using four sets training examples  obtained
varying maximum length lists size alphabet nonrepeating elements appear lists   quinlan         denoting set
pair  s  a   four datasets                             total numbers
possible bindings tasks                          respectively  span two orders
magnitude  table   summarizes execution times  required systems
datasets  neither golem progol completed last task  golem exhausted available
swap space   mb  progol terminated using nearly day cpu time 
table shows ratio execution time latter three simplest dataset
       growth ffoil s execution time far slower systems 
primarily ffoil needs tuples others use tuples 
golem s execution time seems grow slightly slower foil s  progol s growth
rate much higher 

    arithmetic functions

systems used learn definitions complex functions arithmetic 
ackermann s function
 
 
   
  n  
f  m  n      f  m        
n    
  f  m      f  m  n       otherwise
provides testing example recursion control  background relation succ a b  represents b a    finding greatest common divisor two numbers another interesting
task  background relation plus  tasks vocabulary consists integers
          respectively  giving    tuples ackermann a b c  a  b
c less equal         tuples gcd a b c  
shown table    ffoil    times faster foil learning definition
ackermann     times faster gcd  due solely ffoil s smaller
numbers bindings  gcd  example  foil starts           bindings whereas
ffoil never uses     bindings 
   diculties experienced running golem axp           times table
decstation          

   

fiquinlan

foil ffoil learn exactly program ackermann s function
mirrors definition above  case gcd  however  definitions highlight
potential simplification achievable ordered clauses  definition found foil
gcd a a a  
gcd a b c     plus b d a   gcd b a c  
gcd a b c     plus a d b   gcd a d c  

learned ffoil  omitting default clause 
gcd a a a       
gcd a b c     plus a d b   gcd a d c     
gcd a b c     gcd b a c     

last clause exploits fact cases less equal b
filtered first two clauses 

    finding past tense english verbs
previous examples concerned tasks compact  correct definition
known exist  application  learning change english verb phonetic
notation present past tense  real world avor totally correct
definition would extremely complex  considerable literature built around
task  starting connectionist community  moving symbolic learning
work ling         relational learning  quinlan        mooney califf        
quinlan        proposes representing task relation past a b c   interpreted
past tense verb formed stripping ending b adding string c 
single background relation split a b c  shows ways word split two
non empty substrings b c  following experiment reported  ling         corpus
     verbs used generate ten randomly selected learning tasks  containing    
verbs definition learned     different verbs used test definition 
prolog interpreter used evaluate definitions learned foil  unseen word
w mapped test query past w x y    result query judged correct
x bound proper strings  multiple responses
query  first used   disadvantages foil somewhat  since system
attempt reorder learned clauses maximum accuracy single response queries 
average accuracy definitions found foil       
apply ffoil task  relation past a b c  must factored two functional
relations delete a b  add a c  since ffoil currently learn functions
single output variable  training test sets verbs used  giving rise
two separate learning tasks  test judged correct delete add
give correct results unseen verb  definitions learned ffoil higher
average accuracy        ten trials  ffoil outperforms foil nine inferior
one  difference significant    level using one tailed sign test 
average time required ffoil learn pair definitions  approximately     minutes 
somewhat less time taken foil learn single definition 
   

filearning first order definitions functions

object edges

b
c

e
total

  
  
  
  
  
   

correct

time  sec 

foil ffoil mfoil golem fors foil ffoil

  
  
  
  
  
   
 
  
  
 
  
   
 
  
 
 
 
   
  
  
 
  
  
   
  
  
  
  
  
   
  
   
  
  
       
                             

   
    
   
    
   
    

table    cross validation results finite element mesh data 

    finite element mesh design
application  first discussed dolsak muggleton         concerns division
object appropriate number regions finite element simulation  edge
object cut number intervals task learn determine suitable
number   fine division requires excessive computation simulation 
coarse partitioning results poor approximation object s true behavior 
data concern five objects total     edges  target relation mesh a b 
specifies edge number intervals b recommended expert  ranging
      thirty background relations describe properties edge  shape
topological relationship edges object  five trials conducted 
information one object withheld  definition learned edges
remaining objects  definition tested edges omitted object 
table   shows  trial  number edges definitions learned
foil ffoil predict number intervals specified expert  table   shows
published results mesh task three relational learning systems  numbers
edges mfoil golem predict correct number intervals taken
 lavrac dzeroski         general relational learning systems foil 
fors  karalic         ffoil  specialized learning functional relations
kind  since general relational learning systems could return multiple answers
query mesh e x   edge e  first answer used  puts disadvantage
respect foil fors accounts least part lower accuracy  using
one tailed sign test    level  ffoil s accuracy significantly higher
achieved foil golem  differences significant 
time required ffoil domain approximately three times used
foil  turnabout caused ffoil s global pruning phase  requires many literal
eliminations order maximize overall accuracy training data  one ply
cross validation  instance  initial definition  consisting    clauses containing   
body literals  fails cover         given tuples target relation mesh 
global pruning  however  final definition   clauses    body literals 
makes     errors training data 
   

fiquinlan

   related research

mooney califf s        recent system foidl strong uence development ffoil  three features together distinguish foidl earlier systems
foil are 

following example focl  pazzani kibler         background relations

defined intensionally programs rather extensionally tuple sets 
eliminates problem applications complete extensional definition
background relations would impossibly large 

examples tuples belong target relation needed  instead 
argument target relation mode foidl assumes output
completeness  i e   tuples relation show valid outputs inputs
appear 

learned definition ordered every clause ends cut 
output completeness weaker restriction functionality since may several
correct answers standard query r c    c         cn     x     however  fact
clause ends cut reduces exibility somewhat  since answers query must
generated single clause 
although foidl ffoil learn ordered clauses cuts 
different ways  ffoil learns clause  sequence clauses cover remaining
tuples  first clause definition first clause learned  foidl instead
follows webb brkic        learning last clause first  prepending sequence
clauses filter exceptions learned clause  strategy advantage
general rules learned first still act defaults clauses cover
specialized situations 
principal differences foidl ffoil thus use intensional versus
extensional background knowledge order clauses learned 
subsidiary differences   example  foidl never manipulates bindings explicitly
estimates number syntactically  however  many ways ffoil may viewed
intermediate system lying mid way foil foidl 
foidl motivated past tense task described section      performs
extremely well it  formulation task foidl uses relation past a b 
indicate b past tense verb a  together intensional background
relation split s h t  denote possible ways dividing string substrings h
t  definitions learned foidl compact intelligible  slightly higher
accuracy         ffoil s using ten sets training test examples 
interesting see systems compare applications 
bergadano gunetti        first pointed advantages learning systems
restricting relations functions  filp system assumes relations  target
background  functional  although allow functions multiple outputs 
assumption greatly reduces number literals considered specializing clause 
leading shorter learning times   on hand  many tasks discussed
previous section involve non functional background relations would satisfy filp s
   

filearning first order definitions functions

functionality assumption   theory  filp requires oracle answer non ground
queries regarding unspecified tuples target background relations  although
would required relevant tuples provided initially  filp guarantees
learned definition completely consistent given examples  inappropriate
noisy domains discussed sections         
contrast ffoil foidl  definitions learned filp consist unordered
sets clauses  despite fact target relation known functional 
prevents clause exploiting context established earlier clauses  gcd task
 section       definition learned filp would require bodies second
third clauses include literal plus               domains past tense task 
complexity definitions learned ffoil foidl would greatly increased
constrained unordered clauses 

   conclusion
study  mature relational learning system modified customize
functional relations  fact specialized ffoil performs much better
general foil relations kind lends support bergadano gunetti s
       thesis functional relations easier learn  interesting speculate
similar improvement might well obtainable customizing general first order
systems progol  muggleton        learning functional relations 
results quicksort experiments suggest ffoil scales better general
first order systems learning functional relations  past tense
mesh design experiments demonstrate effectiveness noisy domains 
nevertheless  hoped improve ffoil several ways  system
extended multifunctions one output variable  permitted
filp foidl  secondly  many real world tasks sections        
result definitions output variable usually bound equated
constant rather appearing body literal  applications  ffoil heavily
biased towards constructing next clause cover frequent function value
remaining tuples  binding tends highest gain  time
clause specialized exclude exceptions  however  end covering
tuples relation  special cases could filtered first  clauses
would simpler would cover tuples target relation  better learning
strategy situations would seem grow new clause every function value
uncovered tuples  retain one greatest coverage discard rest 
would involve increase computation lead better  concise
definitions 
although conceptual changes moving foil ffoil relatively slight 
effects code level substantial  with three    files make
foil escaping modification   result decided preserve separate
systems  rather incorporating ffoil option foil  available  for
academic research purposes  anonymous ftp ftp cs su oz au  directory pub  file names
foil  sh ffoil  sh 
   

fiquinlan

acknowledgements
research made possible grant australian research council  thanks
william cohen  ray mooney  michael pazzani  anonymous reviewers comments helped improve paper 

appendix  learned definitions
definition learned foil appears left ffoil right 
latter s default clauses irrelevant tasks  omitted 

list processing functions  section     
 a  using lists length   
append     b b  
append a b c     components a d e  
components c d f   append e b f  
last a b     components a b      
last a b     components a c d   last d b  
reverse a a     append a c d  
components d e a  
reverse a b     last a c   last b d  
components a d e  
components b c f   reverse e g  
del d b g  
shift a b     components a c d   del c b d  
append d e b  
translate          
translate a b     components a c d  
components b e f   translate d f  
means c e  

append     b b       
append a b c     components a d e  
append e b f   components c d f     
last a b     components a c d   last d b     
last a b     member b a     
reverse a a     append a c d  
components d e a     
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  

append     b b  
append a b c     components a d e  
components c d f   append e b f  
last a b     components a b      
last a b     components a c d   last d b  
reverse a a     append a a c   del d e c  
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  

append     b b       
append a b c     components a d e  
append e b f   components c d f     
last a b     components a c d   last d b     
last a b     member b a     
reverse a a     append a c d  
components d e a     
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  
shift a b     components a c d  
append e d a   append d e b  

shift a b     components a c d  
append e d a   append d e b  
translate               
translate a b     components a c d  
translate d e   means c f  
components b f e  

 b  using lists length   

shift a b     components a c d   del c b d  
append d e b  

   

filearning first order definitions functions

translate          
translate a b     components a c d  
components b e f   translate d f  
means c e  

translate               
translate a b     components a c d  
translate d e   means c f  
components b f e  

quicksort bubblesort  section     
qsort          
qsort a b     components a c d  
partition c d e f   qsort e g  
qsort f h   components i c h  
append g i b  
bsort          
bsort a a     components a c      
bsort a b     components a c d  
components b c e   bsort d e  
components e f g   lt c f  
bsort a b     components a c d  
components b e f   bsort d g  
components g e h   lt e c  
components i c h   bsort i f  

qsort               
qsort a b     components a c d  
partition c d e f   qsort e g  
qsort f h   components i c h  
append g i b     
bsort               
bsort a a     components a c         
bsort a b     components a c d   bsort d e  
components e f g  
components b c e   lt c f     
bsort a b     components a c d   bsort d e  
components e f g  
components d h i  
components j c i   bsort j k  
components b f k     
bsort a b     components a c d   bsort d e  
components f c e   bsort f b     

arithmetic functions  section     
ackermann   b c     succ b c  
ackermann a   c     succ d a  
ackermann d   c  
ackermann a b c     succ d a   succ e b  
ackermann a e f  
ackermann d f c  
gcd a a a  
gcd a b c     plus b d a   gcd b a c  
gcd a b c     plus a d b   gcd a d c  

ackermann   b c     succ b c     
ackermann a   c     succ   d   succ e a  
ackermann e d c     
ackermann a b c     succ d a   succ e b  
ackermann a e f  
ackermann d f c     
gcd a a a       
gcd a b c     plus a d b   gcd a d c     
gcd a b c     gcd b a c     

references

bell  s     weber  s          close logical relationship foil frameworks helft plotkin  proceedings third international workshop inductive
logic programming  bled  slovenia  pp          
bergadano  f     gunetti  d          interactive system learn functional logic programs  proceedings thirteenth international joint conference artificial intelligence  chambery  france  pp             san francisco  morgan kaufmann 
bratko  i          prolog programming artificial intelligence   nd edition   wokingham 
uk  addison wesley 
   

fiquinlan

cameron jones  r  m     quinlan  j  r          ecient top down induction logic
programs  sigart           
de raedt  l   ed            advances inductive logic programming  amsterdam  ios
press 
dolsak  b     muggleton  s          application inductive logic programming
finite element mesh design  muggleton  s   ed    inductive logic programming  pp 
         london  academic press 
karalic  a          first order regression  ph d  thesis  faculty electrical engineering
computer science  university ljubljana  slovenia 
langley  p     simon  h  a          applications machine learning rule induction 
communications acm                 
lavrac  n     dzeroski  s          inductive logic programming  london  ellis horwood 
ling  c  x          learning past tense english verbs  symbolic pattern associator
versus connectionist models  journal artificial intelligence research             
michie  d   spiegelhalter  d  j     taylor  c  c   eds            machine learning  neural
statistical classification  hertfordshire  uk  ellis horwood 
mooney  r  j     califf  m  e          induction first order decision lists  results
learning past tense english verbs  journal artificial intelligence research    
     
muggleton  s   ed            inductive logic programming  london  academic press 
muggleton  s          inverse entailment progol  new generation computing     
        
muggleton  s     feng  c          ecient induction logic programs  muggleton  s 
 ed    inductive logic programming  pp           london  academic press 
muggleton  s   king  r  d     sternberg  m  j          protein secondary structure prediction using logic based machine learning  protein engineering             
pazzani  m  j     kibler  d          utility knowledge inductive learning  machine
learning           
quinlan  j  r          learning logical definitions relations  machine learning    
        
quinlan  j  r          determinate literals inductive logic programming  proceedings
twelfth international joint conference artificial intelligence  sydney  pp          
san francisco  morgan kaufmann 
quinlan  j  r          past tenses verbs first order learning  proceedings ai   
seventh australian joint conference artificial intelligence  armidale  australia 
pp         singapore  world scientific 
   

filearning first order definitions functions

quinlan  j  r     cameron jones  r  m          foil  midterm report  proceedings european conference machine learning  vienna  pp        berlin  springer verlag 
quinlan  j  r     cameron jones  r  m          induction logic programs  foil
related systems  new generation computing              
rouveirol  c          flattening saturation  two representation changes generalization  machine learning              
srinivasan  a   muggleton  s  h   sternberg  m  j  e     king  r  d          theories
mutagenicity  study first order feature based induction  artificial intelligence              
ullman  j  d          principles database knowledge base systems  rockville  md 
computer science press 
webb  g  i     brkic  n          learning decision lists prepending inferred rules  proceedings australian workshop machine learning hybrid systems  melbourne 
australia  pp       
zelle  j  m     mooney  r  j          combining foil ebg speed up logic programs 
proceedings thirteenth international joint conference artificial intelligence 
chambery  france  pp             san francisco  morgan kaufmann 

   


